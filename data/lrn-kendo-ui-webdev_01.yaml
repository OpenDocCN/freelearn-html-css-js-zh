- en: 'Chapter 1. Interacting with Data: DataSource, Templates, TabStrip, and Grid'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 与数据交互：数据源、模板、标签页和网格
- en: Today is an exciting time to be a web developer. Web browsers and web standards
    have matured to the point that today's programmer has rich frameworks available
    to boost productivity and to reach wide audiences with less code and fewer headaches.
    HTML, CSS, and JavaScript have converged into a powerful and coherent unit that
    allows web applications to be both aesthetically and architecturally beautiful
    and elegant. Kendo UI, from Telerik, is a modern framework that embraces these
    advances and provides a set of tools to enable rich web development and configurable
    widgets, all with a familiar and accessible syntax.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天是成为一名网页开发者的激动人心的时候。网络浏览器和网络标准已经发展到程序员现在有丰富的框架可供选择，以提升生产力，用更少的代码和更少的烦恼触及广泛的受众。HTML、CSS
    和 JavaScript 已经合并成一个强大而连贯的单元，使得网络应用在美学和架构上既美丽又优雅。来自 Telerik 的 Kendo UI 是一个拥抱这些进步的现代框架，提供了一套工具，以实现丰富的网络开发和可配置的控件，所有这些都具有熟悉和易访问的语法。
- en: Along these same lines, development tools have been improving as well and Visual
    Studio 2012 from Microsoft is a good example. JavaScript is now a first-class
    citizen in the Microsoft world and there are many improvements for JavaScript
    development in the IDE, along with improved support for HTML5 and CSS3\. This
    is largely to support a new programming model in Windows 8 that allows web developers
    to take their skills to the Windows 8 desktop, but these improvements also directly
    benefit ASP.NET development —especially ASP.NET MVC. This is the programming environment
    that we will use throughout this book to demonstrate and learn the Kendo UI framework
    for the web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着同样的思路，开发工具也在不断改进，Microsoft 的 Visual Studio 2012 就是一个很好的例子。JavaScript 现在是 Microsoft
    世界中的第一公民，IDE 中对 JavaScript 开发的改进以及 HTML5 和 CSS3 的支持也得到了改善。这主要是为了支持 Windows 8 中的新编程模型，允许网络开发者将他们的技能带到
    Windows 8 桌面，但这些改进也直接受益于 ASP.NET 开发——特别是 ASP.NET MVC。这是我们将在本书中使用的编程环境，用于演示和学习
    Kendo UI 框架。
- en: Setting up the sample project
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置样本项目
- en: Kendo UI for web development is a client-side, jQuery-powered JavaScript framework
    that is not dependent on any specific server technology or platform. This means
    that you can type and run the client-side examples in this book using your choice
    of tools and debugging/testing environment. However, Telerik has also released
    a great set of server-side extensions for the Microsoft ASP.NET MVC framework
    that can significantly boost productivity. To take advantage of both of these
    models, I will be using Visual Studio 2012 and the ASP.NET MVC 4 project template
    for all my demonstrations and I invite you to follow along with me. Visual Studio
    2012 Express is a freely available download from [http://www.microsoft.com/visualstudio/eng/products/visual-studio-overview](http://www.microsoft.com/visualstudio/eng/products/visual-studio-overview),
    if you do not already have it installed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo UI for web development 是一个客户端、由 jQuery 驱动的 JavaScript 框架，它不依赖于任何特定的服务器技术或平台。这意味着您可以使用您选择的工具和调试/测试环境来编写和运行本书中的客户端示例。然而，Telerik
    也发布了一套针对 Microsoft ASP.NET MVC 框架的服务器端扩展，这可以显著提高生产力。为了利用这两种模型，我将使用 Visual Studio
    2012 和 ASP.NET MVC 4 项目模板来进行所有演示，并邀请您跟我一起学习。Visual Studio 2012 Express 可以从 [http://www.microsoft.com/visualstudio/eng/products/visual-studio-overview](http://www.microsoft.com/visualstudio/eng/products/visual-studio-overview)
    免费下载，如果您还没有安装它。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Rather download completed samples?**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**是否想要下载完成的样本？**'
- en: The samples that are displayed in this book are available for download and you
    can start from the completed code if you do not want to follow all of the steps
    of setting it up yourself.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书展示的样本可供下载，如果您不想自己设置所有步骤，也可以从完成的代码开始。
- en: 'Once you have Visual Studio 2012 installed, click on **New Project** either
    from the Start page or from the **File** menu. Then choose **ASP.NET MVC 4 Web
    Application** from the **Web** group of project choices. As you can see from the
    following screenshot, I have named my project `LearningKendoUIWeb`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了 Visual Studio 2012，请从启动页面或从 **文件** 菜单中选择 **新建项目**。然后从项目选择中的 **Web** 组中选择
    **ASP.NET MVC 4 网络应用**。如以下截图所示，我已经将我的项目命名为 `LearningKendoUIWeb`：
- en: '![Setting up the sample project](img/4346OT_01_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![设置样本项目](img/4346OT_01_01.jpg)'
- en: Select this and click on **OK**. The next window will display some selections
    for the type of template you want to use. I chose the basic template, but you
    can choose any of the templates other than the empty template in order to follow
    along with the examples. You do not need to create a unit test project for the
    purposes of this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项并单击 **确定**。下一个窗口将显示一些关于你想要使用的模板类型的选项。我选择了基本模板，但你可以选择任何模板，除了空模板，以便跟随示例。你不需要为本书的目的创建单元测试项目。
- en: '![Setting up the sample project](img/4346OT_01_21.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![设置示例项目](img/4346OT_01_21.jpg)'
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com) . If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 书籍的账户 [http://www.packtpub.com](http://www.packtpub.com) 下载示例代码文件。如果你在其他地方购买了这本书，你可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给你。
- en: Visual Studio will create the folder structure for your new project, and will
    copy all of the necessary files into that structure so that you can run your project
    in the debugger. Once this is complete, you will see your project tree in the
    **Solution Explorer** section of the Visual Studio IDE.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 将为你的新项目创建文件夹结构，并将所有必要的文件复制到该结构中，以便你可以在调试器中运行你的项目。一旦完成，你将在 Visual
    Studio IDE 的 **解决方案资源管理器** 部分看到你的项目树。
- en: '![Setting up the sample project](img/4346OT_01_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![设置示例项目](img/4346OT_01_02.jpg)'
- en: 'Now that we have our structure, it is time to download the Telerik Kendo UI
    files and place them in their proper location. Navigate to the Telerik Kendo UI
    website at [http://www.kendoui.com/download.aspx](http://www.kendoui.com/download.aspx)
    and download the 30-day free trial of the Kendo UI Complete package that includes
    the server wrappers for ASP.NET MVC. It will arrive as a ZIP file containing everything
    that you need for development with Kendo UI. Extract the contents of the ZIP file
    somewhere you will remember since you will need to reference these files throughout
    the rest of the book. This screenshot shows what the ZIP file should contain:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的结构，是时候下载 Telerik Kendo UI 文件并将它们放在正确的位置了。导航到 Telerik Kendo UI 网站 [http://www.kendoui.com/download.aspx](http://www.kendoui.com/download.aspx)，下载包含
    ASP.NET MVC 服务器包装器的 Kendo UI 完整包的 30 天免费试用版。它将以 ZIP 文件的形式到达，包含你使用 Kendo UI 进行开发所需的所有内容。将
    ZIP 文件的内容提取到你可以记住的地方，因为你将需要在本书的其余部分引用这些文件。此截图显示了 ZIP 文件应该包含的内容：
- en: '![Setting up the sample project](img/4346OT_01_03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![设置示例项目](img/4346OT_01_03.jpg)'
- en: 'Now, follow these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤操作：
- en: Go back to Visual Studio and right-click on the `Content` folder in the **Solution
    Explorer** and choose **Add, New Folder**. Name the new folder `kendo`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Visual Studio，在 **解决方案资源管理器** 中的 `Content` 文件夹上右键单击，并选择 **添加，新建文件夹**。将新文件夹命名为
    `kendo`。
- en: Right-click on the `kendo` folder that you just created and create two more
    folders—`Default` and `textures`. Now, right-click on the `Default` folder and
    choose **Add, Existing Item**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击你刚刚创建的 `kendo` 文件夹，再创建两个新的文件夹—`Default` 和 `textures`。现在，右键单击 `Default` 文件夹，并选择
    **添加，现有项**。
- en: In the file dialog that displays, navigate to the folder with the unzipped Kendo
    files, then open the `Styles` folder and then the `Default` folder inside it.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示的文件对话框中，导航到解压后的 Kendo 文件夹所在的文件夹，然后打开 `Styles` 文件夹，接着打开其内部的 `Default` 文件夹。
- en: Select all of the files in this folder and click on the **Add** button. This
    will add all of these items to the Visual Studio project so that they show in
    **Solution Explorer** and can be managed from the Visual Studio IDE.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择此文件夹中的所有文件，然后单击 **添加** 按钮。这将把这些所有项目添加到 Visual Studio 项目中，以便在 **解决方案资源管理器**
    中显示，并可以从 Visual Studio IDE 中进行管理。
- en: Next, follow these same steps to add all of the items to the `textures` folder.
    Once you have these files in place, right click on the `kendo` folder in **Solution
    Explorer** again and choose **Add, Existing Item**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照相同的步骤将这些所有项目添加到 `textures` 文件夹中。一旦这些文件就位，再次在 **解决方案资源管理器** 中右键单击 `kendo`
    文件夹，并选择 **添加，现有项**。
- en: 'In the dialog that displays, choose these two specific files from the `Styles`
    folder of the unzipped kendo files and add them as well:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的对话框中，从解压的 kendo 文件夹的 `Styles` 文件夹中选择这两个特定的文件，并将它们也添加进去：
- en: '`kendo.common.min.css`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kendo.common.min.css`'
- en: '`kendo.default.min.css`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kendo.default.min.css`'
- en: 'Once these two files appear in **Solution Explorer**, rename them by removing
    the .`min` portion of their file names (`kendo.default.min.css` becomes `kendo.default.css`);
    this will be explained in greater detail in next few paragraphs. The `Content`
    folder in **Solution Explorer** should look something like this when you are finished:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这两个文件出现在**解决方案资源管理器**中，通过删除文件名中的`.min`部分来重命名它们（`kendo.default.min.css`变为`kendo.default.css`）；这将在接下来的几个段落中详细解释。当你完成时，**解决方案资源管理器**中的`Content`文件夹应该看起来像这样：
- en: '![Setting up the sample project](img/4346OT_01_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![设置示例项目](img/4346OT_01_04.jpg)'
- en: 'Next, we will prepare the `Scripts` folder by following some very similar steps.
    Create a `kendo` folder inside of the `Scripts` folder in **Solution Explorer**
    and then copy these files from the `js` folder of the downloaded Kendo files:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按照一些非常相似的步骤准备`Scripts`文件夹。在**解决方案资源管理器**中，在`Scripts`文件夹内创建一个`kendo`文件夹，然后从下载的Kendo文件的`js`文件夹中复制以下文件：
- en: '`jquery.min.css`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.min.css`'
- en: '`kendo.all.min.js`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kendo.all.min.js`'
- en: '`kendo.aspnetmvc.min.jskendo.web.min.js`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kendo.aspnetmvc.min.js` `kendo.web.min.js`'
- en: 'Once again, remove the `.min` portion of their filenames. We will, however,
    need two versions of the `kendo.aspnetmvc.js` file as will be explained later.
    Go ahead and copy the file, but only remove the <code>.min</code> portion of the
    filename from one copy. This way you will have one copy of the file with a `.min`
    filename and another copy of the file without the `.min` file name. The completed
    `kendo` folder in **Solution Explorer** should look something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，删除文件名中的`.min`部分。然而，我们稍后将需要两个版本的`kendo.aspnetmvc.js`文件。现在，请复制该文件，但只从其中一个副本中删除文件名中的`<code>.min</code>`部分。这样，你将有一个带有`.min`文件名的文件副本，另一个没有`.min`文件名的文件副本。完成后的`kendo`文件夹在**解决方案资源管理器**中应该看起来像这样：
- en: '![Setting up the sample project](img/4346OT_01_05.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![设置示例项目](img/4346OT_01_05.jpg)'
- en: 'As a web developer, you are surely familiar with the exercise of referencing
    scripts and styles in the head portion of your web pages. ASP.NET MVC 4 comes
    with a great feature that enables bundling and minimization of these scripts,
    along with built-in caching, so that the browser can download these files faster
    and thereby increase the performance of your site with very little effort on your
    part. This feature also works with CDN locations, so that you can run with local
    files during debugging and still reference CDN hosted scripts or style sheets
    when your site is deployed. To enable this functionality for our sample project,
    you will need to add the following code to the `BundleConfig.cs` file in the `App_Start`
    folder of the project. First, add this code at the top of the file to enable CDN
    functionality and to save the paths of the CDN locations that we want to use:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名网页开发者，你肯定熟悉在网页头部引用脚本和样式的练习。ASP.NET MVC 4自带一个很棒的功能，可以对这些脚本进行打包和压缩，同时内置缓存，以便浏览器可以更快地下载这些文件，从而在几乎不需要你做任何努力的情况下提高你网站的性能。此功能还适用于CDN位置，因此你可以在调试时使用本地文件，同时在网站部署时引用CDN托管的脚本或样式表。为了使我们的示例项目启用此功能，你需要在项目的`App_Start`文件夹中的`BundleConfig.cs`文件中添加以下代码。首先，在文件顶部添加此代码以启用CDN功能并保存我们想要使用的CDN位置的路径：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, add this code at the bottom of the file to create the bundles for your
    Kendo files. By passing the CDN location as the second parameter of the `ScriptBundle`
    constructor, Visual Studio will build your solution using your local files when
    debugging and will build your solution using the CDN location files when building
    in release mode. This is also where I should explain why we removed the `.min`
    portion of the JavaScript and stylesheet filenames. The bundling and minification
    features of ASP.NET MVC intentionally ignore files that include `.min` in their
    filenames during debugging. This means that none of your script references from
    the Kendo download will work during debugging because we do not have the pre-minified
    files included in our project. There are several documented ways to deal with
    this problem floating around the Internet, but the easiest way to address this
    for our project is just to rename to files to avoid the entire issue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在文件底部添加以下代码以创建您的 Kendo 文件捆绑包。通过将 CDN 位置作为 `ScriptBundle` 构造函数的第二个参数传递，Visual
    Studio 将在调试时使用您本地的文件构建解决方案，并在发布模式下使用 CDN 位置的文件构建解决方案。这也是我应该解释为什么我们移除了 JavaScript
    和样式表文件名中的 `.min` 部分。ASP.NET MVC 的捆绑和压缩功能在调试期间有意忽略了文件名中包含 `.min` 的文件。这意味着在调试期间，您的
    Kendo 下载中的所有脚本引用都不会工作，因为我们项目中没有包含预压缩的文件。互联网上有几种处理此问题的方法，但对我们项目来说，最简单的方法就是重命名文件以避免整个问题。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have the `BundleConfig.cs` file properly configured, we can adjust
    the references in the head portion of our `_Layout.cshtml` file. The `_Layout.cshtml`
    file acts as our default master page by creating a uniform head structure for
    all of our pages and a default layout within which all the other pages place their
    specific content. Open the `_Layout.cshtml` file in the `Views`, `Shared` folder
    and make some changes. By default, it will have some script references that appear
    in the body portion of the page and some that appear in the head portion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确配置了 `BundleConfig.cs` 文件，我们可以调整 `_Layout.cshtml` 文件头部部分的引用。`_Layout.cshtml`
    文件通过为所有页面创建统一的头部结构以及一个默认布局，在其中所有其他页面放置其特定内容，充当我们的默认母版页。在 `Views`、`Shared` 文件夹中打开
    `_Layout.cshtml` 文件并做一些修改。默认情况下，它将包含一些出现在页面主体部分的脚本引用，以及一些出现在头部部分的。
- en: 'There are undoubtedly some good reasons for doing this, but since we will have
    references to Kendo scripts in the body of our page before these script references
    would appear, we need to move everything to the head portion. Since this file
    is not very long, I have included my finished version here so that you can copy
    it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无疑有很好的理由这样做，但由于在这些脚本引用出现之前，我们页面的主体中已经有了 Kendo 脚本的引用，因此我们需要将所有内容移动到头部部分。由于这个文件不是很长，我已经在这里包含了我的完成版本，以便您可以复制它：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note also that I have added an `@using` statement at the top of the file, make
    sure you copy that as well since it will enable **Intellisense** on all of your
    pages. Intellisense is a feature of Visual Studio that auto-completes code as
    you write and is a great productivity booster. To fully enable this, you will
    also need to add a reference to the `Kendo.Mvc.dll` file to your Visual Studio
    project:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我还已经在文件的顶部添加了一个 `@using` 语句，请确保也复制它，因为它将启用所有页面的 **Intellisense**。Intellisense
    是 Visual Studio 的一个功能，可以在您编写代码时自动完成代码，并且是一个极大的生产力提升器。要完全启用此功能，您还需要将 `Kendo.Mvc.dll`
    文件添加到您的 Visual Studio 项目中：
- en: First, right-click on the **LearningKendoUIWeb** project in the Visual Studio
    **Solution Explorer** and choose **Add Reference**.![Setting up the sample project](img/4346OT_01_22.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Visual Studio 的 **Solution Explorer** 中右键单击 **LearningKendoUIWeb** 项目，并选择
    **添加引用**。![设置示例项目](img/4346OT_01_22.jpg)
- en: Next, click on **Browse** and navigate the file dialog to the location where
    you downloaded the Kendo files.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，单击 **浏览** 并在文件对话框中导航到您下载 Kendo 文件的位置。
- en: Find the folder named `aspnetmvc`, open the folder named `Binaries` inside it,
    and then open the folder named `Mvc3` inside that.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到名为 `aspnetmvc` 的文件夹，打开其中名为 `Binaries` 的文件夹，然后打开该文件夹内名为 `Mvc3` 的文件夹。
- en: Here you will find the `Kendo.Mvc.dll` file; click on it and choose **Add**.![Setting
    up the sample project](img/4346OT_01_23.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里您可以找到 `Kendo.Mvc.dll` 文件；单击它并选择 **添加**。![设置示例项目](img/4346OT_01_23.jpg)
- en: With this reference added, you can make the code inside it available to all
    of your web pages by adding a special entry in a file called `web.config`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此引用后，您可以通过在名为 `web.config` 的文件中添加一个特殊条目，使该代码中的所有内容对您的所有网页可用。
- en: 'This file is located in the root of your **LearningKendoUIWeb** project. Open
    `web.config` and locate the section called `namespaces`. Add the `Kendo.Web.UI`
    namespace to the list like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此文件位于你的**LearningKendoUIWeb**项目的根目录中。打开`web.config`文件，找到名为`namespaces`的部分。将`Kendo.Web.UI`命名空间添加到列表中，如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now create a folder to hold static content in the project. Right-click the project
    name in **Solution Explorer**, choose **Add, New Folder**. Call the new folder
    `static`. This will be the location where we place all of our client-side examples
    that run apart from the MVC framework.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在项目中创建一个文件夹来存放静态内容。在**解决方案资源管理器**中右键单击项目名称，选择**添加，新建文件夹**。将新文件夹命名为`static`。这将是我们放置所有除MVC框架之外客户端示例的位置。
- en: 'Visual Studio 2012 includes some good improvements in JavaScript Intellisense
    and it is going to help us as we write our code. Open the file called `"_references.js`"
    in the scripts folder and delete all of the text in it. This is the entire contents
    of my `"_references.js`" file, copy this into yours as well:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2012在JavaScript Intellisense方面有一些很好的改进，这将帮助我们编写代码。在脚本文件夹中打开名为`"_references.js"`的文件，并删除其中的所有文本。这是我的`"_references.js"`文件的全部内容，将其复制到你的文件中：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Visual Studio 2012 uses this file as the list of JavaScript libraries that
    it should use for Intellisense in the editor. I have included the jQuery file
    included with the Kendo zipped package and two JavaScript files that we will be
    using in the majority of our web pages. Once you have this in place, you will
    get some very helpful coding assistance in your JavaScript files like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2012使用此文件作为编辑器中Intellisense应使用的JavaScript库列表。我已经包含了Kendo压缩包中包含的jQuery文件以及我们将在大多数网页中使用的两个JavaScript文件。一旦你设置好这些，你将在JavaScript文件中获得一些非常有帮助的编码辅助，如下所示：
- en: '![Setting up the sample project](img/4346OT_01_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![设置示例项目](img/4346OT_01_06.jpg)'
- en: Notice how all of the Kendo options show up as you type JavaScript code in the
    editor? As you program the examples throughout this book, this will become something
    that you will help you.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当你开始在编辑器中输入JavaScript代码时，所有的Kendo选项是如何显示出来的？当你在这本书的示例中编程时，这将变成帮助你的一项技能。
- en: OK, now we are ready!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们准备好了！
- en: KendoUI syntax styles
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KendoUI语法风格
- en: 'When using the KendoUI framework in your web pages, you will find that there
    are two ways to add the widgets to your content. The standard method is to use
    a jQuery syntax within script elements like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网页中使用KendoUI框架时，你会发现有两种方法可以将小部件添加到你的内容中。标准方法是使用类似这样的jQuery语法在脚本元素中：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The convention, as shown, is to select the elements through jQuery and then
    apply a JavaScript method from the Kendo namespaces that alters the content into
    an interactive Kendo UI widget.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，惯例是先通过jQuery选择元素，然后从Kendo命名空间中应用一个JavaScript方法，将内容转换为交互式的Kendo UI小部件。
- en: 'There is another way, now available through HTML5, to add Kendo UI widgets
    to your content through a method known as declarative initialization. This is
    a practice where you typically add special attributes to your elements that start
    with "data-" and then call an initializer that reads these attributes and then
    applies the appropriate changes. See this code as an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在还有一种方法，通过HTML5提供，可以通过称为声明性初始化的方法将Kendo UI小部件添加到你的内容中。这是一种通常添加以"data-"开头的特殊属性到你的元素中的实践，然后调用一个初始化器，该初始化器读取这些属性并应用适当的更改。以下代码是一个示例：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This type of syntax allows for a cleaner separation between JavaScript and mark-up,
    and is important in the MVVM pattern that we will cover later in the book. It
    is also powerfully expressive and can make the code more readable, since relevant
    attributes are contained directly within the elements to which they pertain. Script
    blocks containing code do not necessarily appear beside the code actually being
    affected, which can make things difficult to trace in a complicated project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法允许JavaScript和标记之间有更清晰的分离，这在我们在书中稍后要介绍的MVVM模式中非常重要。它也非常强大且表达力丰富，可以使代码更易于阅读，因为相关的属性直接包含在它们相关的元素中。包含代码的脚本块不一定出现在实际受影响的代码旁边，这可能会在复杂的项目中使追踪变得困难。
- en: Kendo UI MVC – basics
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kendo UI MVC – 基础
- en: Since we will be using ASP.NET MVC quite a bit in this book, I should define
    some important terms so that there isn't any confusion later. **MVC** stands for
    **Model-View-Controller**; so let's establish a common terminology around these.
    First, a web page is referred to as a *view* and, when using Razor syntax with
    C#, the web pages have a file extension, `cshtml`. There is also the option of
    using Visual Basic in which case the web pages have a file extension, `vbhtml`,
    but we will be using C# in this book so you won't see this in the examples.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书将大量使用ASP.NET MVC，因此我应该定义一些重要术语，以避免以后产生混淆。**MVC**代表**模型-视图-控制器**；让我们围绕这些术语建立一个共同的理解。首先，一个网页被称为*视图*，当使用C#的Razor语法时，网页有一个文件扩展名，`cshtml`。还有使用Visual
    Basic的选项，在这种情况下，网页有一个文件扩展名，`vbhtml`，但本书我们将使用C#，所以你不会在示例中看到这一点。
- en: Second, the *controller* is a server-side classfile that is responsible for
    all of the logic used in generating the content included in a web page (view).
    The controller, along with the route table, is also responsible for establishing
    the publicly accessible URLs to which the server will respond, and enforcing which
    HTTP verbs are required to access them. In general, a controller is responsible
    for contacting any external dependencies, such as a database or web server, performing
    any necessary logic and calculations on the data retrieved from those external
    dependencies, and then packaging up all of that processed data into an object
    called the *model*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，*控制器*是一个服务器端类文件，负责生成网页（视图）中包含的所有逻辑。控制器，连同路由表，还负责建立公开可访问的URL，服务器将对此做出响应，并强制执行访问它们所需的HTTP动词。一般来说，控制器负责联系任何外部依赖项，如数据库或Web服务器，对从这些外部依赖项检索的数据执行任何必要的逻辑和计算，然后将所有处理过的数据打包成一个称为*模型*的对象。
- en: The model, then, is an object container that contains the data that the web
    page (view) needs in order to display itself. In a properly separated system,
    the controller is the engine that performs all logic, data manipulation, user-input
    handling, authorization, and security. The view is the data presenter and is concerned
    only with the graphical representation of the data it has been given; no logic
    apart from what is required for presentation (not to say that presentation can't
    be complex). The model is the standard data format that the controller uses to
    send its final product to the view to be presented to the user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，模型是一个对象容器，包含网页（视图）需要的数据，以便显示自己。在一个正确分离的系统里，控制器是执行所有逻辑、数据处理、用户输入处理、授权和安全的引擎。视图是数据展示者，只关心所提供数据的图形表示；除了展示所需的逻辑之外（不排除展示可能很复杂），不涉及任何其他逻辑。模型是控制器用来将其最终产品发送到视图进行展示的标准数据格式。
- en: 'When programming in the ASP.NET MVC environment, Kendo UI offers a rich set
    of server-side extensions for creating its widgets. Instead of typing out an HTML
    element, specifying its attributes and wiring it up to Kendo UI JavaScript, the
    entire process can be done using server-side objects that appear in the view.
    For example, creating a `DatePicker` widget in MVC Razor syntax looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当在ASP.NET MVC环境中编程时，Kendo UI提供了一套丰富的服务器端扩展，用于创建其小部件。你不需要编写HTML元素，指定其属性并将其连接到Kendo
    UI JavaScript，整个过程可以使用出现在视图中的服务器端对象来完成。例如，在MVC Razor语法中创建一个`DatePicker`小部件看起来像这样：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'No HTML, no JavaScript, just extension methods on the HTML class. When the
    page is generated, however, you can see what was sent to the browser:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 没有HTML，没有JavaScript，只有HTML类的扩展方法。然而，当页面生成时，你可以看到发送到浏览器的内容：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The extension methods create all the HTML, JavaScript, and CSS information dynamically.
    You can see how the final output uses the jQuery method of selecting the input
    element and using `.kendoDatePicker(…)` to create the widget through JavaScript.
    So, although the programmer didn't type out the JavaScript, it was still necessary
    for Kendo UI to work; the MVC extensions are only wrappers around the normal Kendo
    UI client-side framework.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法会动态创建所有HTML、JavaScript和CSS信息。你可以看到最终输出如何使用jQuery方法选择输入元素，并使用`.kendoDatePicker(…)`通过JavaScript创建小部件。因此，尽管程序员没有编写JavaScript，但Kendo
    UI仍然需要它；MVC扩展只是正常Kendo UI客户端框架的包装器。
- en: I should also explain that even though the view is what generates the final
    web page sent to the user's browser, it is processed on the server first. The
    Razor syntax (everything that starts with `@`) never appears in the final page
    markup, it is processed on the server in order to generate the final markup. This
    means that the Kendo MVC extension methods are really a server-side shortcut to
    creating the final markup needed to make them work as they normally would in JavaScript.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该解释，尽管视图是生成发送到用户浏览器的最终网页的部分，但它首先在服务器上处理。Razor语法（以`@`开头的一切）永远不会出现在最终的页面标记中，它是在服务器上处理的，以便生成最终的标记。这意味着Kendo
    MVC扩展方法实际上是在服务器端创建最终标记的快捷方式，以便它们像在JavaScript中那样正常工作。
- en: Programming in the MVC framework allows for a very clean separation of concerns
    within the web server itself and this, in turn, allows for a great deal of flexibility
    around how the views run and how dependent they are on server-side logic. For
    example, widgets that use data can receive this data either as embedded material
    in the view itself (a dependency on server-side logic), or they can query for
    data from the client-side by calling action methods that return JSON (less dependency
    on server-side logic).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC框架中编程允许在Web服务器内部实现非常清晰的关注点分离，这反过来又允许在视图的运行方式和它们对服务器端逻辑的依赖性方面有很大的灵活性。例如，使用数据的控件可以从视图本身接收这些数据（对服务器端逻辑的依赖），或者它们可以通过调用返回JSON的动作方法从客户端查询数据（对服务器端逻辑的依赖较少）。
- en: 'As an example of a server-dependent implementation, here is a strongly-typed
    view with embedded model data that can then be used by widgets on the page. A
    strongly-typed view is a view page that specifies a specific type of object that
    contains its model data. You can see the strongly-typed model object in this sample
    on the first line starting with `@model`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务器依赖实现的一个示例，这里有一个包含嵌入式模型数据的强类型视图，然后可以由页面上的控件使用。强类型视图是一个指定包含其模型数据的特定类型对象的视图页面。您可以在示例的第一行看到强类型模型对象，它以`@model`开头：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`ViewBag` is a dynamic object that is available to you within controller action
    methods and view pages. It is a dictionary object that can contain any data or
    objects that you need in your view pages. The controller can add anything that
    you need to `ViewBag,` and your view pages will then have access to that data
    or object just as this sample code has shown. In this case, the controller has
    attached an object called `serverData` that contains a JSON representation of
    its model data. We are using the JavaScript function called `eval()` to parse
    it into a JavaScript object and then showing on the JavaScript console what was
    inside. This is merely an example of how to embed data into the view itself without
    having to use additional network requests, such as the jQuery functions `$.get`
    or `$.ajax`, to retrieve data to display on the page; it may prove beneficial
    in some cases where network traffic needs to be weighed against immediate data
    availability that the server can provide up front.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewBag`是一个动态对象，在控制器动作方法和视图页面上可用。它是一个字典对象，可以包含您在视图页面上需要的任何数据或对象。控制器可以添加任何您需要添加到`ViewBag`中的内容，然后您的视图页面将能够访问这些数据或对象，就像这个示例代码所展示的那样。在这种情况下，控制器附加了一个名为`serverData`的对象，其中包含其模型数据的JSON表示。我们使用名为`eval()`的JavaScript函数将其解析为JavaScript对象，然后在JavaScript控制台上显示其内容。这仅仅是一个示例，说明如何将数据嵌入到视图本身，而无需使用额外的网络请求，例如jQuery函数`$.get`或`$.ajax`来检索显示在页面上的数据；在某些情况下，这可能是有益的，因为需要权衡网络流量和服务器可以预先提供的即时数据可用性。'
- en: 'The `ViewBag.serverData` property is filled in the controller like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewBag.serverData`属性在控制器中填充如下：'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that in this example the controller is both filling in this `ViewBag`
    property and sending the same data to the view as a strongly-typed model; this
    isn''t necessary, but it is handy here since we can leverage the server''s `JavaScriptSerializer`
    class to create JSON for us before we send it to the view. Here is what the JavaScript
    console shows when we fill `ViewBag.serverData` with the JSON representation of
    an array of objects that have a **Name** property:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个示例中，控制器既填充了这个`ViewBag`属性，又将相同的数据作为强类型模型发送到视图；这不是必需的，但在这里很有用，因为我们可以利用服务器的`JavaScriptSerializer`类在我们将其发送到视图之前为我们创建JSON。以下是当我们用具有**名称**属性的数组对象的JSON表示填充`ViewBag.serverData`时，JavaScript控制台显示的内容：
- en: '![Kendo UI MVC – basics](img/4346OT_01_11.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Kendo UI MVC – 基础](img/4346OT_01_11.jpg)'
- en: It is far more common to request data from a separate endpoint and then use
    it once it has been retrieved. This allows for data from external sources, and
    breaks the dependency on the server to provide the data inside the page, which
    in turn means the specific server implementation is likely less important and
    less complex. jQuery provides several common and friendly ways of retrieving JSON
    data such as `$.ajax`, `$.get`, and `$.getJSON`. Kendo also provides standard
    ways of retrieving external data through configuration options on its widgets,
    often through the property method `transport.read`. We will see more about this
    in the rest of this chapter as we discuss DataSource and Grid, and throughout
    the rest of the book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从单独的端点请求数据，然后在获取后使用它的情况要常见得多。这允许使用来自外部源的数据，并打破了服务器在页面内部提供数据的依赖性，这意味着特定的服务器实现可能不太重要且更简单。jQuery提供了几种常见且友好的方式来检索JSON数据，如`$.ajax`、`$.get`和`$.getJSON`。Kendo也通过其小部件的配置选项提供标准方式来检索外部数据，通常通过`transport.read`属性方法。我们将在本章的其余部分以及本书的其余部分中看到更多关于此的内容，当我们讨论DataSource和Grid时。
- en: Managing data
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据
- en: The Kendo UI framework consists of two parts—the framework components and the
    user interface (UI) widgets. Most of the content that we will cover in this book
    relates to the user interface widgets and how to use them, but we will begin with
    the important topic of how to manage data within Kendo UI. The DataSource component
    and Templates provide a good starting place and will build a foundation that we
    will use throughout the rest of this book.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo UI框架由两部分组成——框架组件和用户界面（UI）小部件。本书中我们将涵盖的大部分内容与用户界面小部件及其使用方法相关，但我们将从如何在Kendo
    UI中管理数据这个重要主题开始。DataSource组件和模板提供了一个良好的起点，并将为我们在这本书的其余部分使用的基础。
- en: Templates
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: 'Kendo UI Templates are script blocks that contain a small section of page markup
    that is used by other Kendo UI widgets to display repeating content. We will cover
    these first, since they will be used throughout the rest of our examples. Here
    is an example of a simple template:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo UI模板是包含一小部分页面标记的脚本块，这些标记由其他Kendo UI小部件用于显示重复内容。我们将首先介绍这些内容，因为它们将在我们接下来的所有示例中使用。以下是一个简单模板的示例：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this code would set the HTML content of the `horseDiv` to a span element
    that contained the `horseColor` value that was passed into the template function
    object. It would produce the following code output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会将`horseDiv`的HTML内容设置为包含传递到模板函数对象中的`horseColor`值的span元素。它将产生以下代码输出：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Templates can also be written within a special type of HTML script block so
    that their layout appears more naturally within the HTML content.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 模板也可以在特殊类型的HTML脚本块中编写，这样它们的布局在HTML内容中看起来更自然。
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this template sample, note the lines containing the code fragments `#= variable_name
    #`. These indicate the sections of code that are interpreted by the Kendo UI Template
    engine. The variable names inside these code blocks are supplied to the template
    when it is used. The JavaScript property names that you use inside of a template
    need to be properties on the object that is passed to the template when it is
    called. Note also that the script type is `x-kendo-template` instead of `javascript`,
    this is important so that the browser will not attempt to execute the script block
    on its own. This is a code sample showing this template being initialized in JavaScript:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个模板示例中，请注意包含代码片段`#= variable_name #`的行。这些表示由Kendo UI模板引擎解释的代码部分。当模板被使用时，这些代码块内的变量名被提供给模板。在模板内部使用的JavaScript属性名需要在调用模板时传递给模板的对象上的属性。请注意，脚本类型是`x-kendo-template`而不是`javascript`，这是很重要的，这样浏览器就不会尝试自行执行脚本块。以下是一个代码示例，展示了如何在JavaScript中初始化此模板：'
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice how the template is created through a call to `kendo.template()`. This
    method takes the literal template code as its parameter, which is why the example
    shows a call to the jQuery statement `$("#template").html()` since this code returns
    the literal content of the template script block as it appears in the web page.
    So, in this example, it is equivalent to calling `kendo.template(''<tr><td>#=
    rank #</td>…'')`. This means that templates can also be created in-line by typing
    out the exact template code directly in the constructor.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '注意模板是通过调用 `kendo.template()` 来创建的。这个方法接受字面模板代码作为其参数，这就是为什么示例中显示了调用 jQuery 语句
    `$("#template").html()`，因为这段代码返回了模板脚本块在网页中出现的字面内容。因此，在这个例子中，它等同于调用 `kendo.template(''<tr><td>#=
    rank #</td>…'')`。这意味着模板也可以通过直接在构造函数中键入确切的模板代码来创建。'
- en: 'When the template object is called as a method, it needs the data passed in
    as a parameter. When the example code above runs, it produces this output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板对象作为方法被调用时，它需要传入的数据作为参数。当上面的示例代码运行时，它会产生以下输出：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Templates can also include JavaScript which makes it possible to do more advanced
    operations, such as iterating over an array and rendering the template for each
    item in that array individually. In this case, you supply the template with an
    array of objects instead of a single object as before. This time, using the explicit
    parameter name `data` is critical. Note how JavaScript code is surrounded by single
    `#` signs like `# javascript code #` and variable statements are surrounded by
    `#=` and then `#` as in `#= variable statement #`. Note also that the space between
    the `#` signs and the content inside is important.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '模板还可以包含 JavaScript，这使得执行更高级的操作成为可能，例如遍历数组并为数组中的每个项目单独渲染模板。在这种情况下，你需要向模板提供一个对象数组而不是之前的一个单独的对象。这次，使用显式的参数名
    `data` 是至关重要的。注意 JavaScript 代码被单 `#` 符号包围，如 `# javascript code #`，变量语句被 `#=` 和
    `#` 包围，如 `#= variable statement #`。还要注意 `#` 符号和内容之间的空格很重要。'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Templates are an important part of building functional Kendo UI widgets, and
    they become even more useful when used in tandem with the DataSources and Grids
    as we will see later.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是构建功能 Kendo UI 小部件的重要组成部分，当与 DataSources 和 Grids 结合使用时，它们将变得更加有用，正如我们稍后将要看到的。
- en: DataSource
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DataSource
- en: 'The Kendo UI DataSource is a JavaScript object that gives data a common interface
    for the various Kendo UI widgets. The full documentation for the DataSource object
    can be found on the Kendo UI website at this address: [http://docs.kendoui.com/api/framework/datasource](http://docs.kendoui.com/api/framework/datasource).
    The DataSource is a fairly complicated object and relies on some building blocks
    that deserve explanations of their own. These building blocks are the Kendo objects
    known as Schema, Transport, and Model. Let''s address these first and then continue
    exploring the DataSource itself.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo UI DataSource 是一个 JavaScript 对象，为数据提供了各种 Kendo UI 小部件的共同接口。关于 DataSource
    对象的完整文档可以在 Kendo UI 网站上的此地址找到：[http://docs.kendoui.com/api/framework/datasource](http://docs.kendoui.com/api/framework/datasource)。DataSource
    是一个相当复杂的对象，依赖于一些需要单独解释的构建块。这些构建块是 Kendo 对象，称为 Schema、Transport 和 Model。让我们首先处理这些，然后再继续探索
    DataSource 本身。
- en: 'It is important to note that when creating a DataSource object, you should
    use the `new` keyword to instantiate a new object instead of just using an object
    literal:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在创建 DataSource 对象时，你应该使用 `new` 关键字来实例化一个新对象，而不是仅仅使用对象字面量：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Model
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: 'The Model object is from the namespace `kendo.data.Model` and inherits from
    Kendo''s `ObservableObject`. It provides a known structure, or model, to the data
    that is used by a DataSource and can also be used to enable some more advanced
    functionality such as change tracking. To create a new model, you must do so through
    the method `kendo.data.Model.define()` . In this method, you pass an object that
    defines the structure of the model and sets configurable options on the data elements
    within. Here is an example of a model:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模型对象来自命名空间 `kendo.data.Model`，并继承自 Kendo 的 `ObservableObject`。它为 DataSource
    使用的提供了一种已知结构，或模型，同时也可以用来启用一些更高级的功能，例如变更跟踪。要创建一个新的模型，你必须通过方法 `kendo.data.Model.define()`
    来实现。在这个方法中，你需要传递一个对象来定义模型的结构，并设置数据元素的可配置选项。以下是一个模型的示例：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, we have created a model with three properties and we set the
    data type for each of them. We then created a new model object from our model
    definition and demonstrated how to access its properties through the `model.get()`
    method. We just demonstrated that the ID of the model object is defined through
    the property called `id`, and that the fields are defined through a property called
    `fields`. Within the `fields` property, these are the options that can be set
    to configure each data element:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个具有三个属性的模型，并为每个属性设置了数据类型。然后，我们根据模型定义创建了一个新的模型对象，并演示了如何通过 `model.get()`
    方法访问其属性。我们刚刚演示了模型对象的 ID 是通过名为 `id` 的属性定义的，字段是通过名为 `fields` 的属性定义的。在 `fields` 属性中，这些是可以设置以配置每个数据元素的选项：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These are not all required, but they are available when you want a very specific
    configuration. Here is an example from the Kendo UI site:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并非都是必需的，但在你需要一个非常具体的配置时它们是可用的。以下是从 Kendo UI 网站上的一个示例：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since the properties within a model are observable, you need to use special
    getter and setter methods to properly trigger the behaviors that other functions
    and objects are observing. To retrieve the current value of one of these properties,
    use `model_name.get()` such as `currentService.get('unitPrice')`. To set the value
    of the property and thereby change it, use `model_name.set()` such as `currentService.set('unitPrice',
    14.95)`. The concept of observable objects is a key feature of the MVVM framework
    that we will cover in a later chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型中的属性是可观察的，你需要使用特殊的获取器和设置器方法来正确触发其他函数和对象观察到的行为。要检索这些属性之一的当前值，请使用 `model_name.get()`，例如
    `currentService.get('unitPrice')`。要设置属性的值并因此更改它，请使用 `model_name.set()`，例如 `currentService.set('unitPrice',
    14.95)`。可观察对象的概念是 MVVM 框架的一个关键特性，我们将在后面的章节中介绍。
- en: Two other methods available on model objects are `isNew` and `toJSON`. The `isNew`
    method checks if the model is new or not. This is determined by whether or not
    the `id` field is still set at the default value. If the `id` field is not set
    at the default value, the model object is not considered new. The `toJSON` method
    returns a JSON representation of the complete model's properties and values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 模型对象上可用的另外两种方法是 `isNew` 和 `toJSON`。`isNew` 方法检查模型是否为新的。这是通过检查 `id` 字段是否仍然设置为默认值来确定的。如果
    `id` 字段没有设置为默认值，则模型对象不被视为新的。`toJSON` 方法返回模型属性和值的完整 JSON 表示。
- en: 'Since, as I mentioned, the model inherits from `ObservableObject`, it exposes
    three events to which you can attach custom behaviors—`change`, `get`, and `set`.
    The syntax for these is to use `model.bind()` with the name of the event and a
    function to handle it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，模型继承自 `ObservableObject`，它公开了三个你可以附加自定义行为的事件——`change`、`get` 和 `set`。这些的语法是使用
    `model.bind()`，后面跟着事件名称和处理该事件的函数：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Schema
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Schema
- en: 'The `schema` object within a DataSource is responsible for describing the raw
    data format. It functions at a higher level than the model, and can even contain
    a model definition within it. The Schema''s job is to instruct the DataSource
    on where to find information on errors, aggregates, data, groups, and total records
    within the raw data object that the DataSource is using. Each of these pieces
    of information exists as a property within the `schema` object like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: DataSource 中的 `schema` 对象负责描述原始数据格式。它在模型之上工作，甚至可以包含模型定义。Schema 的任务是指导 DataSource
    在原始数据对象中查找有关错误、聚合、数据、分组和总记录的信息。这些信息作为 `schema` 对象中的属性存在，如下所示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code sample, each of the properties has been set to a function
    which, when passed the raw data object, will return the appropriate data from
    within that object. These properties can also be set to text fields, in which
    case the field name given must exist at the top level of the object and already
    contain the appropriate data in the appropriate format:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，每个属性都设置为函数，当传递原始数据对象时，将返回该对象内的适当数据。这些属性也可以设置为文本字段，在这种情况下，给定的字段名必须存在于对象的顶层，并且已经包含适当格式的适当数据：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `aggregates` property needs data returned in an object format with a structure
    something like this. Each property name inside the **aggregates** object can contain
    information on its aggregate values, such as the maximum value (**max**), minimum
    value (**min**), or the total **count**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`aggregates`属性需要以对象格式返回数据，其结构类似于以下示例。**aggregates**对象中的每个属性名都可以包含有关其聚合值的信息，例如最大值（**max**）、最小值（**min**）或总**计数**：'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, the data has a **max** and **min** defined on the **unitPrice**
    field and a **count** defined on the **productName** field. The DataSource object
    has not calculated these values; rather they are already present in the raw data
    sent from the remote server, and the schema has indicated to the DataSource object
    where to locate them. It is possible to use a function to calculate aggregate
    values, but it is normal for the raw data to already contain these values within
    it as returned by a remote server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据在**unitPrice**字段上定义了**最大值**和**最小值**，在**productName**字段上定义了**计数**。数据源对象没有计算这些值；相反，它们已经存在于从远程服务器发送的原始数据中，并且模式已经向数据源对象指示了它们的位置。可以使用函数来计算聚合值，但通常原始数据已经包含由远程服务器返回的这些值。
- en: 'As I said earlier, the schema can contain a model definition within it. If
    this is the case, the DataSource will call `kendo.data.Model.define` on the model
    definition for you, in order to create the model objects from the raw data:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，模式可以包含一个模型定义。如果是这种情况，数据源将为你调用`kendo.data.Model.define`来处理模型定义，以便从原始数据中创建模型对象：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you have already defined a Model definition, you can simply reference it
    and the DataSource will use it just the same:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经定义了一个模型定义，你可以简单地引用它，数据源将像使用它一样使用它：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `schema` object has a `parse` property, which you can set to a function
    that will be called before the raw data is processed. This gives you a chance
    to do any pre-processing if you need it. There is also a `type` property that
    can be set to either `json` or `xml`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`schema`对象有一个`parse`属性，你可以将其设置为在处理原始数据之前将被调用的函数。这给你提供了一个机会，如果你需要的话，进行任何预处理。还有一个`type`属性，可以设置为`json`或`xml`。'
- en: Transport
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输
- en: The `transport` object contains properties that a DataSource can use to communicate
    with a remote server for any of its normal data functions. Those data functions
    are `create`, `destroy`, `read`, and `update` (corresponding to the different
    actions that can be taken on a record). Each of these data functions exists as
    a property object within the `transport` object and follows the same pattern of
    configuration options. I should note that not all of the data functions are required;
    only those functions that your DataSource should perform need to be defined within
    your `transport` object. This is the basic configuration structure for the `transport`
    object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`transport`对象包含数据源可以使用它来与远程服务器通信以执行其任何正常数据功能的属性。这些数据功能是`create`、`destroy`、`read`和`update`（对应于可以在记录上执行的不同操作）。这些数据功能作为`transport`对象内的属性对象存在，并遵循相同的配置选项模式。我应该指出，并非所有数据功能都是必需的；只有那些需要在你的`transport`对象中定义的功能才需要定义。这是`transport`对象的基本配置结构。'
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here are the different options for configuring the transport object's remote
    data operations. Each of the four properties follows the same configuration pattern,
    but in this code sample I have shown different ways of configuring them for the
    sake of example. In this first code sample, I have configured the **create** operation
    to simply send the value of an HTML element to the remote server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是配置传输对象的远程数据操作的不同的选项。这四个属性遵循相同的配置模式，但在本代码示例中，我展示了不同的配置方式以供参考。在这个第一个代码示例中，我配置了**创建**操作，仅将HTML元素的值发送到远程服务器。
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we have set the destroy method to use a jQuery `$.ajax` function
    to send data to the remote server instead of configuring it directly on the **destroy**
    configuration object. You can do this if you prefer the jQuery syntax and want
    to easily attach callback functions to the results of the operation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们已将销毁方法设置为使用jQuery `$.ajax`函数将数据发送到远程服务器，而不是直接在**销毁**配置对象上配置它。如果你更喜欢jQuery语法并希望轻松地将回调函数附加到操作的结果，你可以这样做。
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we have created a function to serve as the source of data for
    the read operation. This might be useful if you need to perform some custom logic
    before receiving remote data, or if you need to bypass the remote data source
    entirely for some reason.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个函数作为读取操作的数据源。如果您需要在接收到远程数据之前执行一些自定义逻辑，或者由于某些原因需要完全绕过远程数据源，这可能很有用。
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember that the configuration options you just saw are valid for any of the
    transport operations, I simply showed different operations as an example for each
    configuration. When a DataSource is configured with a transport configuration
    like this, it will use the properties and functions within these options to perform
    the related actions. It will call `read` when it is loading data, `update` when
    a record has been changed, `destroy` when a record has been deleted, and `create`
    when a new record is added.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您刚才看到的配置选项对任何传输操作都有效，我只是简单地展示了每个配置的不同操作作为示例。当DataSource配置了这样的传输配置时，它将使用这些选项中的属性和函数来执行相关操作。当它加载数据时将调用`read`，当记录被更改时将调用`update`，当记录被删除时将调用`destroy`，当添加新记录时将调用`create`。
- en: Other DataSource properties
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他DataSource属性
- en: 'When reading from local data, you need to reference it by using the property
    called `data` like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当从本地数据读取时，您需要通过使用名为`data`的属性来引用它，如下所示：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Some other properties of DataSource that we have not yet seen are more for data
    manipulation—`aggregate` , `filter` , `group` , `sort` , `page` , and `pageSize`.
    They can work on the data client-side, or they can request that the server do
    the operations by using the `serverAggregates`, `serverFiltering`, `serverGrouping`,
    `serverSorting`, and `serverPaging` properties by adding these to the DataSource
    object properties list and setting them to true.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未看到的DataSource的一些其他属性更多用于数据处理——`aggregate`、`filter`、`group`、`sort`、`page`和`pageSize`。它们可以在客户端数据上工作，或者可以通过使用`serverAggregates`、`serverFiltering`、`serverGrouping`、`serverSorting`和`serverPaging`属性来请求服务器执行操作，通过将这些属性添加到DataSource对象属性列表并将它们设置为true。
- en: 'The `aggregate` property takes an array of fieldnames and aggregate function
    names:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`aggregate`属性接受一个字段名和聚合函数名的数组：'
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `filter` property can take a simple object, an array of simple objects,
    or a configurable object with some more logic to specify filtering that should
    be done on the data:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`属性可以接受一个简单的对象、简单对象的数组，或者一个具有更多逻辑的可配置对象，以指定应在数据上执行筛选：'
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These are the different operators that can be used with the filter object. They
    can also be used when asking the server for filtering by using the `serverFiltering`
    property.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可以与筛选对象一起使用的不同运算符。它们也可以在通过使用`serverFiltering`属性向服务器请求筛选时使用。
- en: '**Equality**: `eq`, `==`, `isequalto`, `equals`, `equalto`, `equal`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等于**: `eq`, `==`, `isequalto`, `equals`, `equalto`, `equal`'
- en: '**Inequality**: `neq`, `!=`, `isnotequalto`, `notequals`, `notequalto`, `notequal`,
    `ne`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不等式**: `neq`, `!=`, `isnotequalto`, `notequals`, `notequalto`, `notequal`,
    `ne`'
- en: '**Less**: `lt`, `<`, `islessthan`, `lessthan`, `less`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小于**: `lt`, `<`, `islessthan`, `lessthan`, `less`'
- en: '**Less or Equal**: `lte`, `<=`, `islessthanorequalto`, `lessthanequal`, `le`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小于或等于**: `lte`, `<=`, `islessthanorequalto`, `lessthanequal`, `le`'
- en: '**Greater**: `gt`, `>`, `isgreaterthan`, `greaterthan`, `greater`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大于**: `gt`, `>`, `isgreaterthan`, `greaterthan`, `greater`'
- en: '**Greater or Equal**: `gte`, `>=`, `isgreaterthanorequalto`, `greaterthanequal`,
    `ge`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大于或等于**: `gte`, `>=`, `isgreaterthanorequalto`, `greaterthanequal`, `ge`'
- en: '**Starts With**: `startswith`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以...开头**: `startswith`'
- en: '**Ends With**: `endswith`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以...结尾**: `endswith`'
- en: '**Contains**: `contains`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**: `contains`'
- en: 'The `group` and `sort` properties can take either an object or an array of
    objects to specify grouping:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`group`和`sort`属性可以接受一个对象或对象数组来指定分组：'
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `page` and `pageSize` properties both take numbers to indicate the page
    number and records per page respectively.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`page`和`pageSize`属性都接受数字来分别表示页码和每页的记录数。'
- en: DataSource methods
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DataSource方法
- en: 'The DataSource methods are used to either change or retrieve certain elements
    of the DataSource object. Several of them are related to the same data manipulation
    properties that we just talked about—`aggregate`, `aggregates`, `filter`, `group`,
    `page`, `pageSize`, and `sort`. In each of these cases, calling the method without
    parameters will return the current value of the like-named property within the
    DataSource; calling the method with a parameter value will set the value of the
    like-named property of the DataSource to the new value passed in:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: DataSource 方法用于更改或检索 DataSource 对象的某些元素。其中一些与刚刚讨论过的相同数据操作属性相关——`aggregate`、`aggregates`、`filter`、`group`、`page`、`pageSize`
    和 `sort`。在这些情况下，不传递参数调用方法将返回 DataSource 中同名属性的当前值；调用带有参数值的方法将设置 DataSource 中同名属性的值为传入的新值：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are also methods for adding and removing records. The methods `add` and
    `insert` both add a new record to the DataSource. The `add` method simply takes
    a model object or an object literal matching the current data format of the items
    in the DataSource. The `insert` method takes the same object as `add,` but also
    specifies an `index` property indicating the zero-based location at which to insert
    the new record. The `remove` method takes a model object and removes it from the
    DataSource:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有添加和删除记录的方法。`add` 和 `insert` 方法都向 DataSource 添加一个新记录。`add` 方法简单地接受一个模型对象或与
    DataSource 中的项目当前数据格式匹配的对象字面量。`insert` 方法接受与 `add` 相同的对象，但还指定一个 `index` 属性，指示插入新记录的零基位置。`remove`
    方法接受一个模型对象并将其从 DataSource 中删除：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `at` , `get` , and `getByUid` methods retrieve specific records from the
    DataSource:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`at`、`get` 和 `getByUid` 方法用于从 DataSource 中检索特定记录：'
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `fetch` , `query` , `read` , `sync` , `cancelChanges` , and `view` methods
    are used for managing the current contents and structure of the DataSource:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`、`query`、`read`、`sync`、`cancelChanges` 和 `view` 方法用于管理 DataSource 的当前内容和结构：'
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To finish up the list, we will look at `data`, `total` , and `totalPages`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成列表，我们将查看 `data`、`total` 和 `totalPages`：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is important to note that you must call `dataSource.read()` in order for
    the DataSource object to initiate the read process and populate itself with data.
    In other words, until you call `dataSource.read()`, there is nothing to read inside
    your DataSource.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，你必须调用 `dataSource.read()` 以使 DataSource 对象启动读取过程并自行填充数据。换句话说，在你调用 `dataSource.read()`
    之前，你的 DataSource 中没有任何可读取的内容。
- en: DataSource events
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DataSource 事件
- en: There are three events that are available on the DataSource object— `change`
    , `error` , and `requestStart` . The `change` event is fired when data is changed
    or read from the transport. The `error` event is fired any time an error occurs
    during data read or data sync; it is also fired if `schema.errors` has been set
    within the DataSource and the response from a server operation contains data in
    the field specified by `schema.errors`. The `requestStart` event is fired when
    a data request is about to start. Like other events, these can be set as part
    of the DataSource definition or later through the `bind` method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: DataSource 对象上有三个可用的事件——`change`、`error` 和 `requestStart`。当数据从传输中更改或读取时，会触发
    `change` 事件。当数据读取或数据同步过程中发生错误时，会触发 `error` 事件；如果 DataSource 中的 `schema.errors`
    已设置，并且来自服务器操作的响应包含由 `schema.errors` 指定的字段中的数据，也会触发 `error` 事件。当数据请求即将开始时，会触发 `requestStart`
    事件。与其他事件一样，这些事件可以作为 DataSource 定义的一部分设置，或者稍后通过 `bind` 方法设置。
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you will see later, the change event can be a good place to put some code
    in order to generate markup while a DataSource is reading in new records. It is
    also the appropriate place to put any other code that should respond to changes
    in the DataSource.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你稍后将会看到的，更改事件是一个很好的地方，可以在 DataSource 读取新记录时生成标记。它也是放置任何其他应该对 DataSource 中的更改做出响应的代码的适当位置。
- en: Getting started with basic usage
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用基本用法
- en: 'Now that we have seen the definitions of the components within a DataSource,
    we will put together our first example page to demonstrate the basic usage of
    the DataSource object in JavaScript. Add a new HTML file to the static folder
    of the project and name it `DataSource.html`. Start out by adding this code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了 DataSource 内部组件的定义，我们将组合我们的第一个示例页面，以演示在 JavaScript 中使用 DataSource
    对象的基本用法。向项目的静态文件夹中添加一个新的 HTML 文件，并将其命名为 `DataSource.html`。首先添加以下代码：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We have referenced jQuery and Kendo UI Web JavaScript files in the head of
    our page. Now let''s add a template block after the `div` tag so that we can script
    the creation of additional table rows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在页面的头部引用了jQuery和Kendo UI Web JavaScript文件。现在让我们在`div`标签之后添加一个模板块，以便我们可以编写脚本以创建额外的表格行：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now what we need is the ability to take some data and fill out that table using
    the layout as defined by this template, enter the DataSource. Add this code after
    the template script block that you just typed in:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要的是能够获取一些数据，并使用由这个模板定义的布局来填写表格，即使用数据源。在您刚才输入的模板脚本块之后添加以下代码：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's step through this code. You should recognize the first few lines where
    a Kendo template is created from the script block that you typed just a few paragraphs
    ago. After that, you see a JavaScript array of objects holding data about various
    movies. This array is going to be the raw data behind the DataSource object that
    comes next. The DataSource object is instantiated (note the `new` keyword) into
    the variable called `dataSource`. It references the `movies` array as its data
    parameter and then defines a function to handle the `change` event of the DataSource
    object. Inside this `change` event, we are using jQuery to select the `movies`
    table and then using `kendo.render()` to generate markup from our `template` variable
    for each item in our `dataSource` object. Note how the template we are using does
    not need special JavaScript to iterate over a collection; the DataSource object
    passes all of the data to the `change` event through `this.view()`. Finally, we
    call `dataSource.read()` which reads in the data and consequently fires the `change`
    event, thereby adding the content to our `movies` table.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这段代码。你应该能认出前面几行，其中创建了一个Kendo模板，这个模板是从你刚才输入的脚本块中创建的。之后，你将看到一个包含关于各种电影数据的JavaScript对象数组。这个数组将成为下一个数据源对象的原始数据。数据源对象被实例化（注意`new`关键字）到名为`dataSource`的变量中。它将`movies`数组作为其数据参数，并定义了一个处理数据源对象`change`事件的函数。在这个`change`事件内部，我们使用jQuery选择`movies`表格，然后使用`kendo.render()`从我们的`template`变量为`dataSource`对象中的每个项目生成标记。注意我们使用的模板不需要特殊的JavaScript来迭代集合；数据源对象通过`this.view()`将所有数据传递给`change`事件。最后，我们调用`dataSource.read()`来读取数据，从而触发`change`事件，将内容添加到我们的`movies`表格中。
- en: The `kendo.render()` method takes a template function as its first argument
    and then an array of data as its second argument. It runs the data through the
    template, generating the resulting markup and returning it back to the caller.
    In the case above, we have used jQuery to set the `<tbody>` element's HTML to
    the result of this `kendo.render()`function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`kendo.render()`方法将其第一个参数作为模板函数，第二个参数作为数据数组。它将数据通过模板运行，生成结果标记并返回给调用者。在上面的例子中，我们使用了jQuery将`<tbody>`元素的HTML设置为`kendo.render()`函数的结果。'
- en: Binding to remote data
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绑定到远程数据
- en: Our last example was a demonstration of using local data (a JavaScript array)
    with a DataSource. It is also very common and important to use the DataSource
    with data that exists on a remote system. To simulate this, we will turn to the
    ASP.NET MVC framework to create a server for our remote data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上一个例子是演示如何使用本地数据（一个JavaScript数组）与数据源结合使用。使用数据源与远程系统上存在的数据进行操作也是非常常见且重要的。为了模拟这种情况，我们将转向ASP.NET
    MVC框架来创建一个用于我们远程数据的服务器。
- en: In the Visual Studio Solution Explorer window, right-click on the **Controllers**
    folder and choose **Add, Controller**. Name the new controller **KendoController**
    and leave the rest of the dialog that opens at its default settings.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio的解决方案资源管理器窗口中，右键单击**控制器**文件夹，选择**添加，控制器**。将新控制器命名为**KendoController**，并保持打开的对话框的其余部分为默认设置。
- en: '![Binding to remote data](img/4346OT_01_08.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![绑定到远程数据](img/4346OT_01_08.jpg)'
- en: 'The newly created controller class will appear in the editor portion of Visual
    Studio and you will see a generic `Index()` method sitting in the file. This method
    is known as an **action method** and is used to process an HTML response back
    to a web browser. The comment above it indicates the route and HTTP verb that
    are used to locate this action method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的控制器类将出现在Visual Studio的编辑器部分，你将看到文件中有一个通用的`Index()`方法。这个方法被称为**动作方法**，用于处理返回给网页浏览器的HTML响应。上面的注释表明了用于定位此动作方法的路由和HTTP动词：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, it shows that typing the route "Kendo", as in `http://<server-name>/Kendo/`,
    would match this action method and cause it to return its view to the browser.
    It would also work to specify `http://<server-name>/Kendo/Index` and it is usual
    to supply both the controller name, "Kendo", and the action method name, "Index",
    in a normal route. As a matter of convention, the MVC framework names all controller
    classes with the suffix "Controller", but it does not use the suffix when referring
    to the controller in an actual route (such as the path in the address bar of your
    web browser). This means that the `KendoController` class is referred to as "kendo"
    when it is part of a route. GET is the default HTTP verb that this controller
    will accept when the browser requests this route.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它表明键入路由"Kendo"，如`http://<server-name>/Kendo/`，将匹配此动作方法并导致它将视图返回到浏览器。指定`http://<server-name>/Kendo/Index`也将有效，通常在正常路由中提供控制器名称"Kendo"和动作方法名称"Index"。按照惯例，MVC框架使用后缀"Controller"命名所有控制器类，但在实际路由（如您网络浏览器地址栏中的路径）中引用控制器时不使用后缀。这意味着当`KendoController`类是路由的一部分时，它被称为"kendo"。GET是此控制器在浏览器请求此路由时将接受的默认HTTP动词。
- en: 'At the top of `KendoController`, add a `using` statement for a namespace that
    we are about to create—`LearningKendoUIWeb.Repository`. Also add `Kendo.Mvc.UI`
    and `Kendo.Mvc.Extensions`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`KendoController`顶部添加一个用于我们即将创建的命名空间`LearningKendoUIWeb.Repository`的`using`语句。还要添加`Kendo.Mvc.UI`和`Kendo.Mvc.Extensions`：
- en: '![Binding to remote data](img/4346OT_01_09.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![绑定到远程数据](img/4346OT_01_09.jpg)'
- en: 'Add a new action method called `RemoteData` and set it up like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为`RemoteData`的新动作方法，并按照以下方式设置它：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is a simple method that instantiates a repository (which we will create
    in just a moment), gathers some data from that repository, and then returns it
    to the client as JSON. The second parameter to the `Json()` method notifies the
    controller class that it is acceptable to return JSON data from this method even
    though the verb is GET.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实例化存储库（我们将在接下来的时刻创建它），从该存储库中收集一些数据，然后将它作为JSON返回给客户端的方法。`Json()`方法的第二个参数通知控制器类，即使动词是GET，也可以从这个方法返回JSON数据。
- en: 'Right-click on the **Models** folder and click on **Add, Class**. Name the
    new class `Movie.cs`. This is a very simple class to hold data about a movie:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击**Models**文件夹，然后单击**添加，类**。将新类命名为`Movie.cs`。这是一个非常简单的类，用于存储有关电影的数据：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add a new folder to the project and call it `Repository`. Add a class to this
    folder called `SampleRepository.cs`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目中添加一个新文件夹，并将其命名为`Repository`。向此文件夹添加一个名为`SampleRepository.cs`的类：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Feel free to add more movies to this list, the more the better. Now we have
    a simple repository class that can return a list of movie objects, so the action
    method we created in `KendoController` is finally valid. When the `RemoteData`
    action method is called, it will return the list of Movie objects as a JSON array
    of objects like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 随意添加更多电影到这个列表，越多越好。现在我们有一个简单的存储库类，可以返回电影对象的列表，因此我们在`KendoController`中创建的动作方法最终是有效的。当调用`RemoteData`动作方法时，它将以如下所示的JSON对象数组形式返回电影对象列表：
- en: '![Binding to remote data](img/4346OT_01_10.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![绑定到远程数据](img/4346OT_01_10.jpg)'
- en: 'I have added more movies to my repository, but the structure of the result
    is the same. This is exactly the sort of data that DataSource knows how to use.
    Here is how to wire up DataSource to use it, find the line in the `RemoteData.cshtml`
    file where the `dataSource` variable is created in JavaScript and change the code
    so that it looks like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经向我的存储库添加了更多电影，但结果的结构是相同的。这正是DataSource知道如何使用的数据类型。以下是连接DataSource以使用它的方法，在`RemoteData.cshtml`文件中找到创建`dataSource`变量的JavaScript代码行，并更改代码，使其看起来像这样：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instead of the using the `data` property to point to a locally available array
    of objects, we are using the `transport` property to tell Kendo that we need to
    request the data from a remote source. In this case, all we have specified is
    how the DataSource can read remote data and that is all we need, since the only
    method call we make to the DataSource is in this line:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用`data`属性指向一个本地可用的对象数组，而是使用`transport`属性告诉Kendo我们需要从远程源请求数据。在这种情况下，我们只指定了DataSource如何读取远程数据，这就是我们所需要的，因为我们对DataSource的唯一方法调用就在这一行：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These examples have only scratched the surface, but it does show the DataSource
    in action in a real page. It is hard, however, to really demonstrate a DataSource
    object in isolation. The DataSource is only actually useful when it serves a data-rich
    widget, like the Kendo UI Grid. In the pages to follow, we will explore this Grid
    widget and will be able to demonstrate a more fully configured DataSource that
    the Grid can take full advantage of. We will also see how to configure both the
    Grid and the DataSource through the MVC Razor syntax within a view page.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子只是触及了表面，但它确实展示了 DataSource 在实际页面上的应用。然而，真正独立演示 DataSource 对象是很困难的。实际上，DataSource
    只有在它服务于数据丰富的控件时才有用，比如 Kendo UI Grid。在接下来的页面中，我们将探讨这个 Grid 控件，并能够展示一个 Grid 可以充分利用的更完全配置的
    DataSource。我们还将看到如何在视图页面中通过 MVC Razor 语法配置 Grid 和 DataSource。
- en: Page layout
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面布局
- en: Now that we have discussed the DataSource and Template features of the Kendo
    UI framework, we can turn our attention to widgets that provide graphical elements
    on our web pages. Some of these widgets actually assist you in organizing the
    content or the data in your page, and the Grid is a very good example of this,
    which we will cover next.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了 Kendo UI 框架的 DataSource 和 Template 功能，我们可以将注意力转向那些在网页上提供图形元素的控件。其中一些控件实际上帮助您组织页面上的内容或数据，Grid
    就是一个很好的例子，我们将在下一部分进行介绍。
- en: Grid
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grid
- en: 'The Kendo UI Grid is a very handy widget to be familiar with. It is an easy
    way to transform data into a usable and interactive grid that would normally take
    a full-featured server control (as in ASP.NET WebForms) or some complex and time-consuming
    JavaScript development in the page markup. In fact, it is remarkably easy to set
    up a simple example. Let''s say we have some JavaScript data like this that we
    want to display within a web page:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo UI Grid 是一个非常实用的控件，需要熟悉。它是一种简单的方法，可以将数据转换成可使用和交互式的表格，这在通常需要完整的服务器控件（如
    ASP.NET WebForms）或页面标记中的复杂且耗时的 JavaScript 开发中是常见的。实际上，设置一个简单的示例非常容易。假设我们有一些如下所示的
    JavaScript 数据，我们想在网页中显示：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In order to turn this into a well-formatted dynamic table, it would normally
    require some looping and HTML markup generation, probably through jQuery. With
    Kendo UI, however, all we have to do is create a `kendoGrid()` function and we
    can see some magic in action. Take note of how little code is involved to create
    a grid from this data here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其转换成一个格式良好的动态表格，通常需要一些循环和 HTML 标记生成，可能通过 jQuery 实现。然而，通过 Kendo UI，我们只需要创建一个
    `kendoGrid()` 函数，我们就可以看到一些魔法在行动。注意，创建一个从这些数据中生成的表格所涉及的代码是多么少：
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And here is the page output from this simple code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这段简单代码的页面输出：
- en: '![Grid](img/4346OT_01_12.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Grid](img/4346OT_01_12.jpg)'
- en: See how the code involved didn't even require a table to be present within the
    web page? Kendo UI generated everything that it needed in order to display this
    data as a grid on the page. Now we can turn our attention to creating grids that
    are more interactive and intelligent, and explore what the Kendo UI Grid widget
    has to offer in displaying data from different sources.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 看看相关的代码是否甚至不需要在网页中存在表格？Kendo UI 生成了它需要的一切，以便在页面上以表格的形式显示这些数据。现在我们可以将注意力转向创建更互动和智能的表格，并探索
    Kendo UI Grid 控件在显示来自不同来源的数据方面能提供什么。
- en: Columns
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列
- en: 'First of all, we can take control of the formatting of the Grid by specifying
    properties on a `columns` object array. This object array is used to indicate
    to the Grid how to display the data appropriately so that it appears as you want
    on the page. Here is a columns object example using the Grid that we saw just
    a moment ago to demonstrate the various options available for formatting:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过在 `columns` 对象数组上指定属性来控制 Grid 的格式化。这个对象数组用于指示 Grid 如何适当地显示数据，以便它在页面上看起来像你想要的那样。以下是一个使用我们刚才看到的
    Grid 的列对象示例，展示了可用于格式化的各种选项：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here is the effect on the output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出效果：
- en: '![Columns](img/4346OT_01_13.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![列](img/4346OT_01_13.jpg)'
- en: There are also simple options for enabling some dynamic interactive behaviors
    by specifying which columns are filterable or sortable. Note that these are only
    useful if the Grid, as a whole, has `pageable` and/or `sortable` set to `true`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些简单的选项，通过指定哪些列是可筛选或可排序的，来启用一些动态交互行为。请注意，这些选项只有在 Grid 作为整体将 `pageable` 和/或
    `sortable` 设置为 `true` 时才有用。
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Note in the following screenshot, how the **Service** column has been sorted
    alphabetically and I have clicked the filter icon, which enables me to input a
    filter on the data to be displayed on the page. You can see the filter icon right
    above the open window on the screen, it looks like a small funnel. Kendo UI takes
    care of actually doing the sorting and the filtering by means of the `dataSource`
    property that we set on the Grid. This means that settings you have put in place
    on the `dataSource` that you supply to the Grid will be used by the Grid for sorting
    and filtering:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下截图，**服务**列是如何按字母顺序排序的，我已经点击了过滤器图标，这使我能够对要在页面上显示的数据输入过滤器。您可以看到过滤器图标位于屏幕上打开窗口的上方，它看起来像一个小漏斗。Kendo
    UI通过我们在网格上设置的`dataSource`属性来处理实际的排序和过滤。这意味着您在提供给网格的`dataSource`上设置的设置将被网格用于排序和过滤：
- en: '![Columns](img/4346OT_01_14.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![列](img/4346OT_01_14.jpg)'
- en: 'When the Grid has been configured to allow editing of data, the `columns` property
    allows you to specify a custom editor function that can be used when changing
    data in that column. This can be a useful way of giving the user an easier way
    to input a change, or even to control the sort of changes that can be made. For
    example, this updated code sample shows adding an editor function to the `Labor`
    column so that it displays a drop-down list when edited, giving the user a specific
    set of options to choose from. There are a couple of other changes here that we
    will talk about next:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当网格配置为允许编辑数据时，`columns`属性允许您指定一个自定义编辑函数，该函数可以在更改该列中的数据时使用。这是一种为用户提供更简单的方式来输入更改，甚至控制可以进行的更改类型的有用方式。例如，此更新的代码示例显示了向`Labor`列添加编辑函数，以便在编辑时显示下拉列表，为用户提供一组特定的选项进行选择。这里还有一些其他更改，我们将在下一节中讨论：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here is the output of the `editor` function, showing the drop-down list that
    appears when a row enters the edit mode. It is important to set the `name` attribute
    of the `<select>` element so that Kendo can bind the user's choice back to the
    `dataSource` when the edit is saved.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`editor`函数的输出，显示了当行进入编辑模式时出现的下拉列表。设置`<select>`元素的`name`属性非常重要，以便Kendo可以在编辑保存时将用户的选项绑定回`dataSource`。
- en: '![Columns](img/4346OT_01_15.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![列](img/4346OT_01_15.jpg)'
- en: 'When using a custom editor function like this, the `container` and `options`
    objects that are passed in have some specific properties available to them that
    can be useful to you when writing your function. The `container` object is the
    page element to which you should add any new mark-up, as we did in our example.
    The `options` object contains two properties: `options.field` and `options.model`.
    The `options.field` property contains the name of the field that you should use
    in your new mark-up so that Kendo can bind everything properly. The `options.model`
    property contains a reference to the actual model of the data being edited if
    one was specified in the `dataSource`; this gives you access to data that could
    be important when creating your custom logic.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此类自定义编辑函数时，传入的`container`和`options`对象具有一些特定的属性，这些属性在您编写函数时可能对您有所帮助。`container`对象是您应该添加任何新标记的页面元素，正如我们在示例中所做的那样。`options`对象包含两个属性：`options.field`和`options.model`。`options.field`属性包含您应该在新的标记中使用的字段名称，以便Kendo可以正确绑定一切。`options.model`属性包含对在`dataSource`中指定的实际数据模型的引用（如果指定了的话）；这使您能够访问在创建自定义逻辑时可能很重要的数据。
- en: 'Additional changes that appeared in the code sample were the `editable: "inline"`
    property on the Grid definition (required for editing to work; the alternative
    to `inline` is `popup`, which opens a special window for editing the record),
    and the new column that includes command buttons. The command property of a column
    object takes an array of command buttons to generate within each row. The available
    options for this array include `edit`, `create`, `destroy`, `save`, and `cancel`.
    We will return to this topic soon when we go into more detail on how to bind a
    Grid to CRUD operations.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '在代码示例中出现的其他更改包括在网格定义上的`editable: "inline"`属性（这是编辑功能正常工作所必需的；`inline`的替代方案是`popup`，它打开一个特殊窗口以编辑记录），以及包含命令按钮的新列。列对象的命令属性接受一个命令按钮数组，用于在每一行中生成。此数组可用的选项包括`edit`、`create`、`destroy`、`save`和`cancel`。当我们更详细地介绍如何将网格绑定到CRUD操作时，我们将很快回到这个话题。'
- en: Note that all that was necessary to add these command buttons to the Grid was
    to specify the `command` property of the column object. I did not add any `<button>`
    elements to the column, nor did I create JavaScript event handlers. Kendo UI generated
    all of this necessary markup for me through the Grid widget's existing functionality.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要向网格添加这些命令按钮，只需指定列对象的 `command` 属性即可。我没有向列添加任何 `<button>` 元素，也没有创建 JavaScript
    事件处理器。Kendo UI 通过网格小部件的现有功能为我生成了所有这些必要的标记。
- en: 'A significant portion of Grid functionality can be enabled through properties
    that describe the Grid''s current capabilities. Each of them end in -able. These
    properties are `editable` , `filterable` , `groupable` , `navigatable` , `pageable`
    , `scrollable` , `selectable` , and `sortable` . We have already seen `filterable`
    and `sortable` and that they take simple true/false values when used. We have
    also seen `editable`, but there is more that can be done with this option:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分网格功能可以通过描述网格当前能力的属性来启用。每个属性都以 -able 结尾。这些属性是 `editable`、`filterable`、`groupable`、`navigatable`、`pageable`、`scrollable`、`selectable`
    和 `sortable`。我们已经看到了 `filterable` 和 `sortable`，并且当使用时它们接受简单的真/假值。我们也看到了 `editable`，但这个选项还有更多可以做的：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `groupable` property lets the user group columns by dragging them to the
    top of the screen. The `groupable` option also includes a property, `groupable.messages.empty`
    that will be displayed in an empty grouping area on a Grid. If you specify this
    `messages` property, the `groupable: true` value is assumed and does not need
    to be specified. The `navigatable` property turns on or off keyboard navigation
    within the Grid. Here is how the bottom of our Grid definition would look with
    `groupable` and `navigatable` turned on:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupable` 属性允许用户通过将列拖动到屏幕顶部来对列进行分组。`groupable` 选项还包括一个属性 `groupable.messages.empty`，它将在网格的空分组区域中显示。如果您指定此
    `messages` 属性，则假定 `groupable: true` 值，并且不需要指定。`navigatable` 属性在网格内打开或关闭键盘导航。以下是我们的网格定义底部在
    `groupable` 和 `navigatable` 启用时的外观：'
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And the output in the page when rendered with these options:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项渲染时的页面输出：
- en: '![Columns](img/4346OT_01_16.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![列](img/4346OT_01_16.jpg)'
- en: 'The `pageable` option can be simply set to `true`/`false`, like several of
    the other options, but it also allows for more fine-grained control if you desire
    it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`pageable` 选项可以简单地设置为 `true`/`false`，就像其他几个选项一样，但如果您需要更精细的控制，它也允许这样做：'
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Our example code configured for paging with 10 items per page would appear
    like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每页10个项目配置的示例代码将看起来像这样：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And the output generated with these options:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项生成的输出：
- en: '![Columns](img/4346OT_01_17.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![列](img/4346OT_01_17.jpg)'
- en: The `scrollable` property configures whether a Grid can have a vertical scroll
    bar within it, and is usually specified if you have restricted the height of the
    Grid on your page. It can be set to a simple Boolean value of `true/false`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrollable` 属性配置网格内部是否可以有一个垂直滚动条，通常在您在页面上限制了网格的高度时指定。它可以设置为简单的布尔值 `true/false`。'
- en: 'The `selectable` property indicates whether selection is enabled or disabled
    within the Grid. Its possible values are `row`, `cell`, `multiple, row`, and `multiple,
    cell`. Here is how our example Grid looks with `selectable: "multiple, cell"`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectable` 属性指示在网格内是否启用或禁用选择。它的可能值是 `row`、`cell`、`multiple, row` 和 `multiple,
    cell`。以下是我们的示例网格在 `selectable: "multiple, cell"` 时的外观。'
- en: Note that I have selected some rows for display.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经选择了部分行进行显示。
- en: '![Columns](img/4346OT_01_18.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![列](img/4346OT_01_18.jpg)'
- en: 'The `toolbar` property enables a toolbar for the Grid with a certain set of
    commands, similar to the command property of the column objects. Each toolbar
    within the `toolbar` object array can have a `name`, `template`, and `text` configured:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`toolbar` 属性为网格启用一个具有一组命令的工具栏，类似于列对象的命令属性。`toolbar` 对象数组中的每个工具栏都可以配置 `name`、`template`
    和 `text`：'
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note how a toolbar can be a simple text value indicating which command to implement.
    You can also specify objects to contain the configuration data that you want (as
    in the preceding screenshot). Refer to the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意工具栏可以是一个简单的文本值，指示要执行哪个命令。您还可以指定包含所需配置数据的对象（如前面的截图所示）。请参考以下截图：
- en: '![Columns](img/4346OT_01_19.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![列](img/4346OT_01_19.jpg)'
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered a lot of fundamental information so that you
    can get started creating Kendo UI-enabled web pages properly. It is essential
    to understand how to use a Template and how to use a DataSource in order to do
    much at all with the Kendo UI framework. Second to these, the Grid is an essential
    component of the Kendo UI framework and knowing how to configure it will give
    you a head start when building pages that need to display tabular data to a user.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的基础知识，以便您能够正确地开始创建启用 Kendo UI 的网页。理解如何使用模板以及如何使用数据源对于在 Kendo UI
    框架中做很多事情至关重要。在这些之后，网格是 Kendo UI 框架的一个基本组件，了解如何配置它将在构建需要向用户显示表格数据的页面时给您带来先机。
- en: In the next chapter, we will learn about the AutoComplete widget. It allows
    you to add a word-wheel effect to input text boxes, to assist users in typing
    information that can be looked up from a data source. It is a great tool that
    many users are drawn to and will add a lot of functionality to your web pages
    without a lot of effort in writing the code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于自动完成小部件的内容。它允许您向输入文本框添加一个单词轮效果，以帮助用户输入可以从数据源中查找的信息。这是一个许多用户都会被吸引的工具，它将为您的网页添加很多功能，而无需在编写代码上花费太多精力。
