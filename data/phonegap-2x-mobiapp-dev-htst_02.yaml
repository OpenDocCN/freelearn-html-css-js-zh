- en: Chapter 2. Let's Get Social!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。让我们社交起来！
- en: Social networking has changed the way we share information in our world. Where
    it used to be an e-mail to a friend (or even a letter!), now it's a Twitter or
    a Facebook post, often for the world to see. What's even more amazing is how relatively
    young the various social networks are and how quickly they have changed the way
    we communicate and consume information. Because of this transformation, our apps
    need to support sharing to social networks, lest our app appears dated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络已经改变了我们在这个世界上分享信息的方式。过去，它可能是一封发往朋友的电子邮件（甚至是一封信！），现在它可能是一条Twitter或Facebook帖子，常常是供全世界看到的。更令人惊讶的是，各种社交网络相对较年轻，它们是如何迅速改变我们的沟通和信息消费方式的。正因为这种转变，我们的应用程序需要支持社交网络分享，否则我们的应用程序可能会显得过时。
- en: What do we build?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建什么？
- en: In this project, we will build an app that illustrates both sides of the social
    network equation. The first is that of consuming the information from various
    sources; we'll be using Twitter streams for this. The second is that of sharing
    information; we'll be using each platform's native sharing capabilities for this,
    except for iOS where we'll be using a project called ShareKit to implement sharing.
    (Note that iOS 5 supports Twitter sharing and iOS 6 expands that to Facebook.
    Sooner or later a plugin is bound to appear that supports these functions, but
    ShareKit provides more targets.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将构建一个应用程序，展示社交网络方程的两个方面。一方面是消费来自各种来源的信息；我们将使用Twitter流来完成这项工作。另一方面是分享信息；我们将使用每个平台的本地分享功能来完成这项工作，但在iOS上，我们将使用一个名为ShareKit的项目来实现分享。（请注意，iOS
    5支持Twitter分享，iOS 6将其扩展到Facebook。迟早会有一个插件支持这些功能，但ShareKit提供了更多的目标。）
- en: What does it do?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它能做什么？
- en: Our app, called Socializer, will display the Twitter streams from five pre-set
    Twitter accounts. The user can then read these streams, and should they find an
    interesting tweet, they can tap on it to do more with it. For example, they may
    wish to view a link embedded in the tweet. More importantly, the end user may
    wish to share the information using their own social network of choice, and the
    app will offer a Share button to do just that.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序，名为Socializer，将显示来自五个预设Twitter账户的Twitter流。用户可以阅读这些流，如果他们发现一条有趣的推文，他们可以点击它来进行更多操作。例如，他们可能希望查看推文中嵌入的链接。更重要的是，最终用户可能希望使用他们自己的社交网络来分享信息，应用程序将提供一个分享按钮来实现这一点。
- en: To accomplish this, we'll be working with Twitter's JSON API, a natural fit
    for an app already written largely in JavaScript. The only downside is that Twitter
    has a pretty low cap for rate-limiting API requests, so we'll also have to build
    some basic support for when this occurs. (To be honest, this is far more likely
    to occur to us as a developer than the user because we often reload the app to
    test a new feature, which incurs new API requests far faster than an end user
    would typically incur them.)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将与Twitter的JSON API合作，这对于主要用JavaScript编写的应用程序来说是一个自然的选择。唯一的缺点是Twitter对API请求的速率限制设定了一个相当低的上限，因此我们还将为这种情况构建一些基本支持。（说实话，这种情况更有可能发生在我们作为开发者身上，而不是用户，因为我们经常重新加载应用程序来测试新功能，这会导致新的API请求比最终用户通常产生的要快得多。）
- en: We'll also introduce the concept of PhoneGap plugins, as sharing functionality
    is not present in the typical PhoneGap install by default. A plugin is essentially
    a bridge between some amount of native code (such as Java, Objective C, or C#)
    and our JavaScript code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍PhoneGap插件的概念，因为默认情况下，典型的PhoneGap安装中不包含分享功能。插件本质上是在一定数量的本地代码（如Java、Objective-C或C#）和我们的JavaScript代码之间的一座桥梁。
- en: For this project, we'll be using two plugins for each platform we support. One,
    `ChildBrowser` , is supported across most platforms, which makes it far easier
    to write code that uses it. The second is based upon the platform's sharing capabilities
    and what plugins are available for the platform and PhoneGap. Since this varies,
    we'll have to deal with separate code paths for each platform, but the idea will
    be the same—to share content.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将为每个我们支持的平台使用两个插件。一个是`ChildBrowser`，它在大多数平台上都受到支持，这使得编写使用它的代码变得容易得多。第二个是基于平台的分享能力和该平台和PhoneGap可用的插件。由于这些各不相同，我们将不得不为每个平台处理不同的代码路径，但理念将是相同的——分享内容。
- en: Why is it great?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它很棒？
- en: This project is a great introduction to handling APIs using JSON, including
    Twitter's API. While we're using a very small subset of Twitter's API, the lessons
    learned in this project can be expanded to deal with the rest of the APIs. Furthermore,
    JSON APIs are frequently used by many web platforms, and learning how to deal
    with Twitter's API is a great way to learn how to deal with any JSON API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是使用JSON处理API（包括Twitter的API）的绝佳入门，尽管我们只使用了Twitter API的一小部分，但在这个项目中学到的经验可以扩展到处理其他API。此外，JSON
    API在许多网络平台上被广泛使用，学习如何处理Twitter的API是学习如何处理任何JSON API的绝佳方法。
- en: We'll also be dealing with how to share content. While Android provides a shared
    mechanism between all apps that provide a nice list of sharing apps, iOS does
    not. So we'll also have to write code that is platform specific to handle the
    differences in how each platform (and the corresponding plugin) supports sharing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将处理如何共享内容。虽然Android为所有提供良好共享应用列表的应用程序提供了一个共享机制，但iOS没有。因此，我们还需要编写特定于平台的代码来处理每个平台（以及相应的插件）在支持共享方面的差异。
- en: We'll also be working with PhoneGap plugins, something many apps will eventually
    require in one way or another. For example, our app should be able to handle links
    to external websites; the best way to do this is to have the `ChildBrowser` plugin
    handle it. This lets the user stay inside our app and easily return to our app
    when they are done. Without it, we'd be taking the user out of the app and into
    the default browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将与PhoneGap插件一起工作，许多应用最终都会以某种方式需要这些插件。例如，我们的应用应该能够处理指向外部网站的链接；最好的方式是让`ChildBrowser`插件来处理。这使用户能够留在我们的应用中，并在完成操作后轻松返回。如果没有它，我们就需要将用户从应用中移出，进入默认浏览器。
- en: How are we going to do it?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何进行？
- en: 'To do this, we''re going to break down the creation of our app into several
    different parts, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将把我们的应用创建过程分解成几个不同的部分，如下所示：
- en: Designing the app – UI/interaction design
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计应用 – UI/交互设计
- en: Designing the app – the data model
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计应用 – 数据模型
- en: Implementing the data model
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据模型
- en: Configuring the plugins
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置插件
- en: Implementing the social view
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现社交视图
- en: Implementing the tweet view
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现推文视图
- en: Just like in the previous project, we'll focus on the design of the app before
    we handle the implementation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的那个项目中一样，在处理实现之前，我们将专注于应用的设计。
- en: What do I need to get started?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要准备些什么才能开始？
- en: 'You''ll need to go ahead and create your project, just like we did in the last
    project. You can, to some degree, copy the previous project and replace the necessary
    files and settings as well. There is one additional iOS setting that should be
    modified, but it''s really a matter of taste (whether or not you like your status
    bars black or grey):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要继续创建您的项目，就像我们在上一个项目中做的那样。在一定程度上，您可以复制上一个项目，并替换必要的文件和设置。还有一个额外的iOS设置需要修改，但这完全取决于个人喜好（您是否喜欢黑色或灰色的状态栏）：
- en: Open `Socializer-info.plist`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Socializer-info.plist`。
- en: Add `Status Bar style` and set it to `UIStatusBarStyleOpaqueBlack`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`状态栏样式`并将其设置为`UIStatusBarStyleOpaqueBlack`。
- en: 'We''ll also be using the same directory structure as the previous project,
    with two exceptions: we''ll be adding a `www/childbrowser` directory and a `www/plugins`
    directory. Underneath the `www/plugins` directory, we''ll have a directory for
    each platform: namely, `/www/plugins/Android` and `/www/plugins/iOS`. We''ll fill
    these directories later, but go ahead and create them now.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用与上一个项目相同的目录结构，但有两个例外：我们将添加一个`www/childbrowser`目录和一个`www/plugins`目录。在`www/plugins`目录下，我们将为每个平台创建一个目录：即`/www/plugins/Android`和`/www/plugins/iOS`。我们将在稍后填充这些目录，但现在请先创建它们。
- en: 'We''ll be using the same framework, so be sure to copy the framework files.
    We won''t worry about localizing the content, but even so, we''ll use all the
    localization functions so that it would be easy to do so. We''ll also use a script
    to deal with scrolling in `www/framework` called `scroller.js`. You''ll need to
    add this to your index files in order to use it correctly, as shown in the following
    code snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的框架，所以请确保复制框架文件。我们不会担心本地化内容，但即便如此，我们也会使用所有本地化功能，以便于将来进行本地化。我们还将使用一个名为`scroller.js`的脚本来处理`www/framework`中的滚动，您需要将其添加到索引文件中才能正确使用，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll also need to download the PhoneGap plugins repository available at [http://www.github.com/phonegap/phonegap-plugins](http://www.github.com/phonegap/phonegap-plugins).
    This will ensure you have all the necessary plugins we'll need as well as any
    plugins you might be interested in working with on your own.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要下载位于[http://www.github.com/phonegap/phonegap-plugins](http://www.github.com/phonegap/phonegap-plugins)的PhoneGap插件库。这将确保你拥有我们需要的所有必要插件，以及你可能感兴趣自己使用的任何插件。
- en: Finally, for iOS, we'll need to get the ShareKit 2.0 plugin available at [https://github.com/ShareKit/ShareKit](https://github.com/ShareKit/ShareKit).
    Due to the way it is distributed, you'll need to install Git and make sure you
    enable Git for the project. (Alternatively, you can use the `/Submodules` directory
    in the download files).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于iOS，我们需要获取位于[https://github.com/ShareKit/ShareKit](https://github.com/ShareKit/ShareKit)的ShareKit
    2.0插件。由于它的分发方式，你需要安装Git并确保为项目启用Git。（或者，你可以使用下载文件中的`/Submodules`目录）。
- en: Designing the app – UI/interaction design
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计应用程序 – UI/交互设计
- en: 'Our first task is to design our user interface and the interaction between
    the various widgets and views. Like in the previous task, we will have three views:
    the start view, the social view, and the tweet view.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是设计用户界面以及各种小部件和视图之间的交互。就像在之前的任务中一样，我们将有三个视图：开始视图、社会视图和推文视图。
- en: Getting on with it
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: We'll begin with the start view. As in the last project, this will be a very
    simple view and is entirely optional in this app. All we'll be doing is explaining
    the app and providing a way to move to the main view.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从开始视图开始。就像在最后一个项目中一样，这将是一个非常简单的视图，在这个应用程序中完全是可选的。我们将会解释应用程序并提供一种方式来移动到主视图。
- en: 'With that in mind, following is our screenshot for the start view:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，以下是我们开始视图的截图：
- en: '![Getting on with it](img/9403OS_02_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动](img/9403OS_02_01.jpg)'
- en: In this screenshot, we have a **Start** button (1) that will push the social
    view on to the view stack. We also have some explanatory text (2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，我们有一个**开始**按钮（1），它将社会视图推入视图堆栈。我们还有一些说明性文字（2）。
- en: 'Our next view is the social view, shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个视图是社会视图，如下面的截图所示：
- en: '![Getting on with it](img/9403OS_02_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动](img/9403OS_02_02.jpg)'
- en: The social view is essentially a list of tweets, one after the other. We'll
    display several tweets at a time, and, as such, we'll have to deal with scrolling
    at some point. While you can use various libraries to accomplish this, we'll be
    using our own minimalist scrolling library.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 社会观点本质上是一系列推文的列表，一个接一个。我们将一次显示几条推文，因此我们不得不处理滚动问题。虽然你可以使用各种库来完成这个任务，但我们将使用我们自己的极简滚动库。
- en: Each tweet will consist of a profile image (1), the screen name and real name
    (if available) (2), and the text of the tweet (3). When the user taps a tweet,
    we'll transition to the tweet view.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每条推文将包括一个个人资料图片（1），屏幕名称和真实姓名（如果可用）（2），以及推文文本（3）。当用户点击一条推文时，我们将过渡到推文视图。
- en: At the bottom of the view (4), we have a series of profile images for five different
    Twitter accounts. The images will be retrieved from Twitter itself; we won't be
    storing the images ourselves. When an image is tapped, we'll load the respective
    Twitter stream.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图底部（4），我们有五个不同Twitter账户的系列个人资料图片。这些图片将从Twitter本身检索；我们不会自己存储这些图片。当图片被点击时，我们将加载相应的Twitter流。
- en: 'Our tweet view looks like the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的推文视图看起来如下面的截图所示：
- en: '![Getting on with it](img/9403OS_02_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动](img/9403OS_02_03.jpg)'
- en: 'First, note that our tweet view repeats the tweet (1) that the user tapped
    on in the stream view. The same information is repeated, but we also list out
    the various web links (2) that the tweet might have, any hashtags (3), and any
    user mentions (4). Items (2) to (4) are intended to be tappable: that is, if a
    user taps on (2), they should be taken to the particular website. If they tap
    on (3), they should be taken back to the social view with a stream of tweets referencing
    the hashtag. The same should happen if they tap on (4), except that it would be
    that particular user''s stream.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，我们的推文视图重复了用户在流视图中点击的推文（1）。相同的信息被重复，但我们还列出了推文可能包含的各种网页链接（2），任何标签（3），以及任何用户提及（4）。项目（2）到（4）旨在可点击：也就是说，如果用户点击（2），他们应该被带到特定的网站。如果他们点击（3），他们应该返回到包含该标签的推文流的社会视图。如果他们点击（4），也应该发生同样的情况，除了它会是那个特定用户的流。
- en: We also have a **Back** button in our navigation bar to take the user back to
    the previous view, and a **Share** button (5) in our toolbar. This button, when
    tapped, should display a list (6) of various social network services. What this
    list will look like will depend upon the platform the app is on, and what social
    networks are installed on the device.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的导航栏中，我们还有一个 **返回** 按钮用于将用户带回到上一个视图，以及工具栏中的 **分享** 按钮（5）。当按下此按钮时，应该显示一个包含各种社交网络服务的列表（6）。这个列表的外观将取决于应用程序所在的平台以及设备上安装的社交网络。
- en: Now that we've created our mockup, we need to define some of the resources we'll
    need. Let's open up our editing program and get busy designing our app.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的草图，我们需要定义我们将需要的某些资源。让我们打开我们的编辑程序，开始设计我们的应用程序。
- en: '![Getting on with it](img/9403_02_20.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动](img/9403_02_20.jpg)'
- en: The preceding screenshot is a pretty good representation of how our final product
    will look. A lot of it can be accomplished with CSS . The background of the Twitter
    stream and the navigation bar are the only two components that will be difficult,
    so we should save those out to our `www/images` directory as `Background.png`
    and `NavigationBar.png` respectively. Notice that, both have a texture, so make
    sure to save them in a way that they will tile without visible seams.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图相当好地展示了我们的最终产品将是什么样子。其中很多都可以通过 CSS 完成。Twitter 流和导航栏的背景是唯一两个可能比较困难的部分，因此我们应该将它们保存到我们的
    `www/images` 目录中，分别命名为 `Background.png` 和 `NavigationBar.png`。注意，它们都有纹理，所以请确保以这种方式保存它们，以便它们可以无缝拼接。
- en: What did we do?
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: For this task, we've defined how our UI should look, and the various interactions
    between widgets and views. We also generated a mockup of the app in our graphics
    editor and created some image resources for our later use.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们已经定义了我们的 UI 应该看起来什么样，以及小部件和视图之间的各种交互。我们还使用我们的图形编辑器创建了一个应用程序的草图，并为后续使用创建了一些图像资源。
- en: Designing the app – the data model
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计应用程序 – 数据模型
- en: In this task, we will design our data model for handling Twitter users and streams.
    Our model will, to some extent, rely on Twitter's model as well. The results that
    it returns from its API we will use unmodified. The rest of the model we will
    define in this task.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将设计我们的数据模型来处理 Twitter 用户和流。我们的模型在一定程度上将依赖于 Twitter 的模型。我们将未修改地使用它从其
    API 返回的结果。我们将在这个任务中定义模型的其他部分。
- en: Getting on with it
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: 'Let''s take a look at our data model:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的数据模型：
- en: '![Getting on with it](img/9403OS_02_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![开始行动](img/9403OS_02_04.jpg)'
- en: 'We''ll be using `TWITTER` as the namespace and within it, we''ll have two objects
    we''ll be using a lot: `TwitterUser` and `TwitterStream`. The idea behind `TwitterUser`
    is to be an instance of a particular user, which we''ll represent by an image
    on the toolbar in the streams view. The `TwitterStream` object will be a representation
    of a single stream.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `TWITTER` 作为命名空间，并在其中，我们将使用两个经常使用的对象：`TwitterUser` 和 `TwitterStream`。`TwitterUser`
    的理念是作为一个特定用户的实例，我们将通过在流视图的工具栏上的一个图像来表示它。`TwitterStream` 对象将表示一个单一的流。
- en: 'Let''s examine `TwitterUser` more closely. The object has two properties: `screenName`
    and `userData`. The `screenName` property holds the user''s Twitter username.
    The `userData` property will hold the response from Twitter''s API. It will have
    lots of different information about the user, including their profile image URL,
    their real name, and more.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地检查 `TwitterUser`。该对象有两个属性：`screenName` 和 `userData`。`screenName` 属性包含用户的
    Twitter 用户名。`userData` 属性将包含来自 Twitter API 的响应。它将包含有关用户的大量不同信息，包括他们的个人资料图片 URL、他们的真实姓名等等。
- en: The constructor will return an initialized `TwitterUser` based upon the supplied
    screen name. Internally, the constructor just calls the `setScreenName()` method,
    which will request the user data from Twitter. The `getScreenName()` method simply
    returns the screen name. The `getProfileImageUrl()` method will return the URL
    to the user's profile image. The `getUserData()` method will return the data that
    Twitter returned, and the `getTimeline()` method will create a `TwitterStream`
    object for the particular user.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将根据提供的屏幕名称返回一个初始化的 `TwitterUser`。内部，构造函数只是调用 `setScreenName()` 方法，该方法将从
    Twitter 请求用户数据。`getScreenName()` 方法简单地返回屏幕名称。`getProfileImageUrl()` 方法将返回用户个人资料的图片
    URL。`getUserData()` 方法将返回 Twitter 返回的数据，而 `getTimeline()` 方法将为特定用户创建一个 `TwitterStream`
    对象。
- en: 'The `TwitterStream` object operates on a similar idea: it will house the data
    returned by Twitter. The `TwitterStream` object also provides us the ability to
    get a stream for a particular user as well as the ability to return a stream for
    any search (such as a hashtag).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterStream`对象基于类似的想法：它将存储Twitter返回的数据。`TwitterStream`对象还提供了获取特定用户流的能力，以及返回任何搜索（如标签）流的能力。'
- en: 'When constructed, we pass three options: the screen name or the search phrase,
    the maximum number of tweets to return (up to 200), and a function to call when
    the stream is fully loaded. It will call the `loadStream()` method to do the actual
    loading.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造时，我们传递三个选项：屏幕名或搜索短语，要返回的最大推文数量（最多200条），以及当流完全加载时调用的函数。它将调用`loadStream()`方法来进行实际的加载。
- en: We have some methods related to the properties in the object such as `setScreenName()`
    , `setSearchPhrase()` , `getSearchPhrase()` , `setMaxCount()` , `getMaxCount()`
    , and `getStream()` .
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些与对象中的属性相关的方法，例如`setScreenName()`、`setSearchPhrase()`、`getSearchPhrase()`、`setMaxCount()`、`getMaxCount()`和`getStream()`。
- en: The `setScreenName()` method does the same thing as setting a `searchPhrase()`
    method except that it adds an `@` character to the name. The `loadStream()` method
    then can decide which API to call when loading a stream, either by calling the
    API to return the user's stream, or by calling the search API.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`setScreenName()`方法与设置`searchPhrase()`方法做的是同样的事情，只不过它会在名字前添加一个`@`字符。然后`loadStream()`方法可以决定在加载流时调用哪个API，要么调用API返回用户的流，要么调用搜索API。'
- en: What did we do?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: 'We created and defined our data model for our app. We''ve defined two objects:
    namely, `TwitterUser` and `TwitterStream`, and saw how they interact.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的应用程序创建并定义了数据模型。我们定义了两个对象：即`TwitterUser`和`TwitterStream`，并看到了它们是如何交互的。
- en: Implementing the data model
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据模型
- en: 'We''ll be creating two files: namely, `twitter.js` and `twitterUsers.js`. Place
    these in the `www/models` directory.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个文件：即`twitter.js`和`twitterUsers.js`。将这些文件放在`www/models`目录下。
- en: Getting on with it
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'Let''s start with the `twitter.js` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`twitter.js`文件开始：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As always, we define our namespace, in this case, `TWITTER`, as seen in the
    following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们定义了我们的命名空间，在这个例子中，是`TWITTER`，如下代码片段所示：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We define two variables global to the `TWITTER` namespace: namely, `_baseURL`
    and `_searchBase`. These two URLs point at Twitter''s JSON API; the first is for
    API requests such as user lookups, user streams, and such, while the latter is
    only for searching. We define them here for two reasons: to make the URLs a little
    less nasty in the following code, and if Twitter should ever decide to have a
    different version of the API (and you want to change it), you can do so here.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个属于`TWITTER`命名空间的全局变量：即`_baseURL`和`_searchBase`。这两个URL指向Twitter的JSON API；第一个用于API请求，如用户查找、用户流等，而后者仅用于搜索。我们在这里定义它们有两个原因：使URL在接下来的代码中不那么令人讨厌，并且如果Twitter决定有不同版本的API（并且你想更改它），你可以在这里进行更改。
- en: 'Next, we define our first object, `TwitterUser`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的第一个对象，`TwitterUser`：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ve defined our two properties: `_screenName` and `_userData`. Unlike in
    the last project, we''re using underscores in front to indicate that these are
    internal (private) variables that no outside object should access. Instead, an
    outside object should use the `get`/`set` methods we define next:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的两个属性：`_screenName`和`_userData`。与上一个项目不同，我们使用下划线来表示这些是内部（私有）变量，外部对象不应访问。相反，外部对象应使用我们定义的下一个`get`/`set`方法：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This one''s simple enough, it just returns the private member when asked. But
    the next one''s more complicated:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单，它只是当被请求时返回私有成员。但下一个更复杂：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Like with a normal `set` method, we've assigned `theScreenName` to `_screenName`.
    But when this happens, we want to load in the user information from Twitter. This
    is why it is important to have `get`/`set` methods in front of private methods.
    You might just need to do something important when the value changes or is read.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像正常的`set`方法一样，我们将`theScreenName`赋值给`_screenName`。但在这个时候，我们希望从Twitter加载用户信息。这就是为什么在私有方法前有`get`/`set`方法很重要的原因。你可能只需要在值改变或读取时做一些重要的事情。
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we've defined our URL that we're going to use to ask Twitter to look up
    the user in question. For more information about how this particular URL works,
    see the Twitter documentation at [https://dev.twitter.com/docs/api/1/get/users/lookup](https://dev.twitter.com/docs/api/1/get/users/lookup).
    You can see a full example of what is returned at the bottom of the page.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了我们将要用来请求Twitter查找特定用户的URL。有关此特定URL如何工作的更多信息，请参阅Twitter文档[https://dev.twitter.com/docs/api/1/get/users/lookup](https://dev.twitter.com/docs/api/1/get/users/lookup)。您可以在页面底部看到一个完整的返回示例。
- en: 'Now that we have our URL, we''re going to use another utility function defined
    for us in `PKUTIL` ([www/framework/utility.js](http://www/framework/utility.js))
    called `loadJSON()` . It uses AJAX to send a request to the preceding URL, and
    Twitter then sends a response back, in the form of JSON. When it is finished,
    the function will call the `completion` function we''re passing as the second
    parameter after `getUserURL`. This method can check if the request succeeded or
    not, and set any private members that are necessary. We''ll also call the `completion`
    function passed to the `setScreenName()` method. These actions are defined in
    the following code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的URL，我们将使用在`PKUTIL`中为我们定义的另一个实用函数`loadJSON()`。它使用AJAX向前面的URL发送请求，然后Twitter以JSON的形式发送响应。当它完成时，该函数将调用作为`getUserURL`的第二个参数传递的`completion`函数。此方法可以检查请求是否成功，并设置任何必要的私有成员。我们还将调用传递给`setScreenName()`方法的`completion`函数。这些操作在下面的代码片段中定义：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If success is true, then the JSON has been properly returned and parsed into
    the data parameter. We just assign it to the private `_userData` member as seen
    in the preceding code block.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功为真，那么JSON已经被正确返回并解析到数据参数中。我们只需将其分配给前面代码块中看到的私有`_userData`成员。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But if success is false, then something's gone wrong. Any number of things could
    have happened, Twitter might be down (not unheard of), the network connection
    might have failed, or Twitter might have rate limited us. For now we're just going
    to assume the latter, but you could certainly build more complicated error-detection
    schemes to figure out which is which.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果成功为假，那么可能出了问题。可能发生了任何数量的情况，Twitter可能宕机（并非闻所未闻），网络连接可能失败，或者Twitter可能对我们进行了速率限制。目前我们只是假设后者，但您当然可以构建更复杂的错误检测方案来确定是哪一个。
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, regardless of success or failure, we call the `completion` function
    passed to us. This is important so that we know when we can safely access the
    `_userData` member (via `getUserData` a little lower down).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无论成功与否，我们都会调用传递给我们的`completion`函数。这很重要，这样我们就可以知道何时可以安全地访问`_userData`成员（通过稍低一点的`getUserData`）。
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, the method `getProfileImageURL()` is a convenience
    function that returns the user's profile image URL. This is a link to the avatar
    being used for Twitter. First we check to see if `_userData[0]` exists, and if
    so, return `profile_image_url`, a value defined by the Twitter API. If it doesn't,
    we'll just return an empty string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`getProfileImageURL()`方法是一个便利函数，用于返回用户的个人资料图片URL。这是一个指向Twitter所使用的头像的链接。首先我们检查`_userData[0]`是否存在，如果存在，则返回`profile_image_url`，这是一个由Twitter
    API定义的值。如果不存在，我们只返回一个空字符串。
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, `getUserData()` is used to return the `_userData` member. If it has been
    properly loaded, it will have a lot of values in it, all determined by Twitter.
    If it has failed to load, it'll have an error property in it, and if it hasn't
    been loaded at all, it'll be empty.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`getUserData()`方法来返回`_userData`成员。如果它已经被正确加载，它将包含很多值，所有这些值都是由Twitter决定的。如果它未能加载，它将包含一个错误属性，如果它根本未加载，它将是空的。
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`getTimeline()` is also a convenience function used to get the timeline for
    the Twitter user. `theMaxCount` is the maximum number of tweets to return (up
    to 200), and `completion` is a function to call when it''s all done. We do this
    by creating a new `TwitterStream` object (defined in the following code snippet)
    with the Twitter screen name prepended by an `@` character.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTimeline()`也是一个便利函数，用于获取Twitter用户的微博。`theMaxCount`是返回的最大推文数（最多200条），而`completion`是一个在所有操作完成后要调用的函数。我们通过创建一个新的`TwitterStream`对象（在下面的代码片段中定义）并在Twitter屏幕名称前加上一个`@`字符来实现这一点。'
- en: If `theMaxCount` isn't specified, we use a little `||` trick to indicate the
    default value, `25` tweets.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定`theMaxCount`，我们使用一个小的`||`技巧来表示默认值，即`25`条推文。
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last thing we do is actually call the `setScreenName()` method with `theScreenName`
    and `completion` functions passed in to the constructor. If you remember your
    JavaScript, this whole function, while we can think of it as defining an object,
    is also the constructor of that object. In this case, as soon as you create the
    `TwitterUser` object, we'll fire off a request to Twitter to load in the user's
    data and set it to `_userData`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要做的事情实际上是调用`setScreenName()`方法，并将构造函数中传入的`theScreenName`和`completion`函数传递给它。如果你还记得你的JavaScript，这个整个函数，虽然我们可以将其视为定义一个对象，但实际上也是该对象的构造函数。在这种情况下，一旦你创建了`TwitterUser`对象，我们就会向Twitter发送一个请求来加载用户数据并将其设置为`_userData`。
- en: 'Our next object is the `TwitterStream` object defined as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个对象是`TwitterStream`对象，定义如下：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we've defined three properties, namely, `_searchPhrase`, `_stream`, and
    `_theMaxCount`. The `_searchPhrase` property can be either the screen name of
    a user or a literal search term, such as a hashtag. The `_stream` property is
    the actual collection of tweets obtained from Twitter, and the `_theMaxCount`
    property is the maximum number of tweets to ask for. (Keep in mind that Twitter
    is free to return less than this amount.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了三个属性，即`_searchPhrase`、`_stream`和`_theMaxCount`。`_searchPhrase`属性可以是用户的屏幕名称或一个字面搜索词，如标签。`_stream`属性是从Twitter获取的实际推文集合，而`_theMaxCount`属性是请求的推文最大数量。（请记住，Twitter可以返回少于这个数量的推文。）
- en: You may ask why we're storing either a search phrase or a screen name. The reason
    is that we're attempting to promote some code re-use. It's only logical to assume
    that a Twitter stream is a Twitter stream, regardless of how it was found, either
    by asking for a particular user's stream or by searching for a word. Nice assumption,
    right?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么我们要存储搜索词或屏幕名称。原因是我们在尝试促进代码重用。假设Twitter流是Twitter流，这是合乎逻辑的，无论它是通过请求特定用户的流还是通过搜索一个词来找到的。这是一个很好的假设，对吧？
- en: Yeah, totally wrong too. The streams are close, close enough that we can work
    around the differences, but still, not the same. So even though we're treating
    them here as one-and-the-same, they really aren't, at least until Twitter decides
    to change their search API to better match their non-search API.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，完全错误。流非常接近，足够接近以至于我们可以处理差异，但仍然不是同一个。所以尽管我们在这里将它们视为同一事物，但实际上它们并不是，至少直到Twitter决定更改其搜索API以更好地匹配其非搜索API。
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we have the `get`/`set` methods for `_theMaxCount`. All we do is `set`
    and retrieve the value. One thing to note is that this should be called before
    we actually load a stream; this value is part of the ultimate URL we sent to Twitter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`_theMaxCount`的`get`/`set`方法。我们只是设置和检索值。有一点要注意的是，这应该在实际上载流之前调用；这个值是我们发送给Twitter的最终URL的一部分。
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that we have two `set` methods that act on `_searchPhrase` while we only
    have one `get` method. What we're doing here is permitting someone to call `setScreenName()`
    without the `@` character. The `_searchPhrase` property will then be set to `@`
    prepended to the screen name. The next `set` method (`setSearchPhrase()`) is intended
    to be used when setting real search terms (such as a hashtag).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们只有一个`get`方法时，我们有两个`set`方法作用于`_searchPhrase`。我们在这里做的是允许某人调用`setScreenName()`而不带`@`字符。然后`_searchPhrase`属性将被设置为在屏幕名称前添加的`@`。下一个`set`方法（`setSearchPhrase()`）是为了在设置真实搜索词（如标签）时使用。
- en: Internally, we'll use that `@` at the front to mean something special, but you'll
    see that in a second.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我们将使用前面的`@`来表示特殊含义，但你会看到这一点。
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `getStream()` method just returns our `_stream`, which if we haven''t loaded
    one, will be blank. So let''s look at the `loadStream()` method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`getStream()`方法只是返回我们的`_stream`，如果我们还没有加载一个，它将是空的。所以让我们看看`loadStream()`方法：'
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `loadStream()` method takes a `completion` function; we'll call this at
    the end of the operation no matter what. It lets the rest of our code know when
    it is safe to access the `_stream` member via `getStream()`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadStream()`方法接受一个`completion`函数；无论操作结果如何，我们都会在操作结束时调用它。它让我们的其他代码知道何时可以通过`getStream()`安全地访问`_stream`成员。'
- en: 'The other component is the `forScreenName` variable; if true, we''ll be asking
    Twitter for the stream that belongs to the screen name stored in `_searchPhrase`;
    otherwise, we''ll ask Twitter to do an actual search for `_searchPhrase`. This
    variable is defined in the following code snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个组件是`forScreenName`变量；如果为真，我们将请求Twitter获取存储在`_searchPhrase`中的屏幕名称所属的流；否则，我们将请求Twitter对`_searchPhrase`进行实际搜索。这个变量在以下代码片段中定义：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All we''ve done so far is define `theStreamURL` to point either at the search
    API (for a search term) or the non-search API (for a screen name''s stream). Next
    we''ll load it with `loadJSON(` `)`, as shown in the following code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的一切只是定义`theStreamURL`指向搜索API（对于搜索词）或非搜索API（对于屏幕名的流）。接下来，我们将使用以下代码片段中的`loadJSON(`
    `)`来加载它：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here's another reason why we need to know if we're processing for a screen name
    or for a search, the JSON we get back is slightly different. When searching, Twitter
    helpfully includes other information (such as the time it took to execute the
    search). In our case, we're not interested in anything but the results, hence
    the two separate code paths.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个我们需要知道我们是在处理屏幕名还是搜索的原因，我们得到的JSON略有不同。在搜索时，Twitter会很有帮助地包括其他信息（例如执行搜索所需的时间）。在我们的情况下，我们只对结果感兴趣，因此有两个不同的代码路径。
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, if we have a failure, we're assuming that we are rate-limited.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们遇到失败，我们假设我们受到了速率限制。
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When done, we call the `completion` method, helpfully passing along the data
    stream.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们调用`completion`方法，并帮助传递数据流。
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just like at the end of the last object, we call some methods at the end of
    this object too. First we set the incoming search phrase, then set the maximum
    number of tweets to return (or 25, if it isn't given to us), and then call the
    `loadStream()` method with the `completion` function. This means that the moment
    we create a new `TwitterStream` object, it's already working on loading all the
    tweets we'll be wanting to have access to.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一个对象的末尾一样，我们也在这个对象的末尾调用了一些方法。首先，我们设置搜索短语，然后设置要返回的最大推文数量（如果没有给出，则为25），然后使用`completion`函数调用`loadStream()`方法。这意味着当我们创建一个新的`TwitterStream`对象时，它已经开始加载我们将要访问的所有推文。
- en: 'We''ve taken care of almost all our data model, but we''ve just a little bit
    left to do in `twitterUsers.js`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了几乎所有的数据模型，但在`twitterUsers.js`中我们还有一小部分工作要做：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'First, we create a `users()` array in the `TWITTER` namespace. We''re going
    to use this to store our predefined Twitter users, which will be loaded with the
    `loadTwitterUsers()` method as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`TWITTER`命名空间中创建一个`users()`数组。我们将使用这个数组来存储预定义的Twitter用户，这些用户将通过以下`loadTwitterUsers()`方法加载：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What we've done here essentially is just chained together five requests for
    five different Twitter accounts. You can store these in an array and ask for them
    all at once, yes, but our app needs to know when they've all loaded. You could
    also do this by using recursion through an array of users, but we'll leave it
    as an example to you, the reader.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里本质上只是将针对五个不同Twitter账户的五个请求连接在一起。你可以将它们存储在数组中并一次性请求它们，是的，但我们的应用程序需要知道它们何时全部加载。你也可以通过使用用户数组的递归来完成这个任务，但我们将把它作为一个例子留给读者。
- en: What did we do?
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We implemented our data model and predefined the five Twitter accounts we want
    to use. We also went over the `loadJSON()` method in `PKUTIL` which helps with
    the entire process. We've also been introduced to the Twitter API.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了我们的数据模型，并预定义了我们想要使用的五个Twitter账户。我们还介绍了`PKUTIL`中的`loadJSON()`方法，它有助于整个流程。我们还介绍了Twitter
    API。
- en: What else do I need to know?
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要知道什么？
- en: 'Before we go on, let''s take a look at the `loadJSON()` method you''ve been
    introduced to. It''s been added to this project''s `www/framework/utility.js`
    file, and is defined as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看看你刚刚接触到的`loadJSON()`方法。它已被添加到这个项目的`www/framework/utility.js`文件中，定义如下：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First off, this is a pretty simple function to begin with. What we're really
    doing is utilizing `PKUTIL.load()` to do the hard work of calling out to the URL
    and passing us the response, but when the response is received, it's going to
    be coming back to us in the data variable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一个相当简单的函数。我们真正做的是利用`PKUTIL.load()`来完成调用URL并传递给我们响应的繁重工作，但是当响应被接收时，它将作为数据变量返回给我们。
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `theParsedData` variable will store the actual JSON data, fully parsed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`theParsedData`变量将存储实际已完全解析的JSON数据。'
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the URL returns something successfully, we try to parse the data. Assuming
    it is a valid JSON string, it''ll be put into `theParsedData`. If it isn''t, `JSON.parse()`
    will throw an exception, as shown in the following code block:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果URL返回成功的结果，我们尝试解析数据。假设它是一个有效的JSON字符串，它将被放入`theParsedData`中。如果不是，`JSON.parse()`将抛出一个异常，如下面的代码块所示：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Any exceptions will be logged to the console, and we''ll end up telling our
    `completion` function that the request failed, as shown in the following code
    block:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 任何异常都将记录到控制台，并且我们将告诉我们的`completion`函数请求失败，如下面的代码块所示：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At the end, we call our `completion` function and tell it if the request failed
    or succeeded, and what the JSON data was (if successfully parsed).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用我们的`completion`函数，并告诉它请求是否失败或成功，以及JSON数据（如果成功解析）。
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Configuring the plugins
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置插件
- en: Most PhoneGap plugins aren't terribly hard to install or configure, but they
    will undoubtedly play a vital role in your app, especially if you need to use
    a feature that PhoneGap doesn't provide on its own.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数PhoneGap插件安装或配置并不特别困难，但它们无疑将在您的应用中扮演至关重要的角色，尤其是如果您需要使用PhoneGap本身不提供的功能。
- en: In our case, we need two plugins, one to display websites within our app and
    another to share the content. For the first, we'll be using a plugin called `ChildBrowser`
    across all the platforms we support, but for the latter, we'll have to use a separate
    plugin for iOS and Android.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们需要两个插件，一个用于在我们的应用中显示网站，另一个用于分享内容。对于前者，我们将使用名为`ChildBrowser`的插件在所有我们支持的平台上使用，但对于后者，我们将不得不为iOS和Android使用不同的插件。
- en: 'Here''s what each sharing plugin will look like when we''re done, starting
    with iOS:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，每个分享插件将看起来如下，从iOS开始：
- en: '![Configuring the plugins](img/9403_02_28.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![配置插件](img/9403_02_28.jpg)'
- en: 'For Android the sharing plugin will look like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，分享插件将如下所示：
- en: '![Configuring the plugins](img/9403_02_29.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![配置插件](img/9403_02_29.jpg)'
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't already, you should download the entire community PhoneGap plugin
    repository located at [https://github.com/phonegap/phonegap-plugins](https://github.com/phonegap/phonegap-plugins).
    This will provide you with nearly all the content necessary to use the plugins.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有做，您应该下载位于[https://github.com/phonegap/phonegap-plugins](https://github.com/phonegap/phonegap-plugins)的整个社区PhoneGap插件仓库。这将为您提供使用插件所需的几乎所有内容。
- en: If you wish to support sharing on iOS, you also need to download ShareKit 2.0,
    which is available at [https://github.com/ShareKit/ShareKit](https://github.com/ShareKit/ShareKit),
    or use the fork bundled with the code available for this book. It is located outside
    of the directories for each project in a directory labeled `Submodules`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在iOS上支持分享，您还需要下载ShareKit 2.0，它可在[https://github.com/ShareKit/ShareKit](https://github.com/ShareKit/ShareKit)找到，或者使用本书提供的代码捆绑的分支。它位于每个项目的目录之外，在一个标记为`Submodules`的目录中。
- en: Getting on with it
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行动
- en: We're going to split this one up into what we have to do for each platform,
    as the steps and environments are all quite different.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据每个平台的不同步骤和环境来拆分这项工作。
- en: Plugin configuration for iOS
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iOS插件配置
- en: You wouldn't know it, but our first platform is also the hardest. In fact, it'll
    make the remaining two platforms feel a bit like child's play.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不知道，但我们的第一个平台也是最难的一个。实际上，它会让剩下的两个平台感觉有点像儿戏。
- en: The `ChildBrowser` plugin itself is easy to install and configure, but ShareKit
    2.0 is, well, anything but, especially when used in conjunction with PhoneGap.
    The problem stems from the fact that when you compile the project with PhoneGap
    and ShareKit 2.0 together, some symbols are duplicated, and the linker throws
    out a nasty little error. Long story short, your app doesn't compile. Not good.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildBrowser`插件本身易于安装和配置，但ShareKit 2.0则不然，尤其是在与PhoneGap一起使用时。问题源于当您将PhoneGap和ShareKit
    2.0一起编译项目时，一些符号会重复，链接器会抛出一个讨厌的小错误。长话短说，您的应用无法编译。这可不是什么好事。'
- en: 'Let''s look first at the steps necessary for installing the `ChildBrowser`
    plugin, as these are far more typical of most plugins:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看安装`ChildBrowser`插件所需的步骤，因为这些步骤对于大多数插件来说更为典型：
- en: Open the collection of plugins you downloaded and navigate to `iOS/ChildBrowser`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您下载的插件集合，导航到`iOS/ChildBrowser`。
- en: Drag `ChildBrowser.bundle`, `ChildBrowserCommand.h`, `ChildBrowserCommand.m`,
    `ChildBrowserViewController.h`, `ChildBrowserViewController.m`, and `ChildBrowserViewController.xib`
    into XCode to `Socializer/Plugins`, as shown in the following screenshot:![Plugin
    configuration for iOS](img/9403_02_06.jpg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ChildBrowser.bundle`、`ChildBrowserCommand.h`、`ChildBrowserCommand.m`、`ChildBrowserViewController.h`、`ChildBrowserViewController.m`和`ChildBrowserViewController.xib`拖入XCode的`Socializer/Plugins`中，如下面的截图所示：![iOS插件配置](img/9403_02_06.jpg)
- en: At the prompt, make sure to copy the files (instead of linking to them). This
    can be done by checking the **Copy items into destination group's folder** entry,
    as shown in the following screenshot:![Plugin configuration for iOS](img/9403_02_07.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示时，请确保复制文件（而不是链接到它们）。这可以通过勾选**将项目复制到目标组的文件夹中**选项来完成，如下截图所示：![iOS插件配置](img/9403_02_07.jpg)
- en: Copy `ChildBrowser.js` to your `www/plugins/iOS` directory. You can do this
    in XCode or in Finder.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ChildBrowser.js`复制到您的`www/plugins/iOS`目录。您可以在XCode或Finder中完成此操作。
- en: 'Add the plugin to `Cordova.plist` in `Socializer/Supporting Files` in XCode.
    Find the `Plugins` row, and add a new entry of the order as seen in the following
    table:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XCode中的`Socializer/Supporting Files`中的`Cordova.plist`中添加插件。找到**插件**行，并添加一个新条目，如下表所示：
- en: '| `ChildBrowserCommand` | `String` | `ChildBrowserCommand` |'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `ChildBrowserCommand` | `String` | `ChildBrowserCommand` |'
- en: 'This can be better explained with the help of the following screenshot:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以通过以下截图更好地解释：
- en: '![Plugin configuration for iOS](img/9403_02_05.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![iOS插件配置](img/9403_02_05.jpg)'
- en: There, that was easy, wasn't it? Now comes the hard part, getting ShareKit 2.0
    installed and working. For that, we're going to refer to [Appendix B](apb.html
    "Appendix B. InstallingShareKit 2.0"), *Installing ShareKit 2.0* as the process
    is rather long.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，很简单，不是吗？现在来点难的，安装并使ShareKit 2.0运行起来。为此，我们将参考[附录B](apb.html "附录 B. 安装ShareKit
    2.0")，*安装ShareKit 2.0*，因为这个过程相当长。
- en: 'When that''s done, we need to duplicate the plugin setup that we did for `ChildBrowser`,
    except for ShareKit, using the following steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们需要复制为`ChildBrowser`所做的插件设置，除了ShareKit，按照以下步骤进行：
- en: Navigate to the `iOS/ShareKitPlugin` directory in your plugin repository.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到插件仓库中的`iOS/ShareKitPlugin`目录。
- en: Copy `ShareKitPlugin.h`, `ShareKitPlugin.m`, `SHKSharer+Phonegap.h`, `SHKSharer+Phonegap.m`
    to the `Plugins` folder in your project.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ShareKitPlugin.h`、`ShareKitPlugin.m`、`SHKSharer+Phonegap.h`、`SHKSharer+Phonegap.m`复制到项目中的`Plugins`文件夹。
- en: Copy `ShareKitPlugin.js` to your `www/plugins/iOS` folder.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ShareKitPlugin.js`复制到您的`www/plugins/iOS`文件夹。
- en: Modify `Cordova.plist` to add this new plugin to the list.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Cordova.plist`以添加此新插件到列表中。
- en: 'Find the **Plugins** row, and add a new entry, as in the following table:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到**插件**行，并添加一个新条目，如下表所示：
- en: '| `ShareKitPlugin` | `String` | `ShareKitPlugin` |'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `ShareKitPlugin` | `String` | `ShareKitPlugin` |'
- en: 'This can be better explained with the help of the following screenshot:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以通过以下截图更好地解释：
- en: '![Plugin configuration for iOS](img/9403_02_19.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![iOS插件配置](img/9403_02_19.jpg)'
- en: 'The final step is to update our `www/index.html` file to include these two
    plugins for our app. Add the following lines after the line that is loading the
    `cordova-2.2.0-ios.js` script:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新我们的`www/index.html`文件，以包含这两个插件。在加载`cordova-2.2.0-ios.js`脚本之后的行后添加以下行：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Whew! We did it, we've got two plugins installed for iOS devices. Now, let's
    tackle the remaining platform. Don't faint. Android's a lot easier.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！我们做到了，我们为iOS设备安装了两个插件。现在，让我们解决剩余的平台。别晕倒。Android要简单得多。
- en: Plugin configuration for Android
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android插件配置
- en: 'For Android, we''ll be using two plugins: namely, `ChildBrowser` and `Share`.
    Both are located in the repository you should have already downloaded from GitHub.
    Let''s start with installing and configuring `ChildBrowser` first, using the following
    steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，我们将使用两个插件：即`ChildBrowser`和`Share`。这两个插件都位于您应该已经从GitHub下载的仓库中。让我们先按照以下步骤安装和配置`ChildBrowser`：
- en: Create a new package (**File** | **New** | **Package**) under your project's
    `src` folder. Name it `com.phonegap.plugins.childBrowser`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`src`文件夹下创建一个新的包（**文件** | **新建** | **包**）。将其命名为`com.phonegap.plugins.childBrowser`。
- en: Navigate to `Android/ChildBrowser/src/com/phonegap/plugins/childBrowser` and
    drag `ChildBrowser.java` to the newly created package in Eclipse.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Android/ChildBrowser/src/com/phonegap/plugins/childBrowser`，并将`ChildBrowser.java`拖到新创建的包中。
- en: Go to `res/xml` in your project and open `plugins.xml` with the text editor
    (usually this is done by a right-click and then navigating to **Open With** |
    **Text Editor**).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往项目中的`res/xml`，并使用文本编辑器打开`plugins.xml`（通常是通过右键单击然后导航到**打开方式** | **文本编辑器**）。
- en: 'Add the following line at the bottom of the file, just above the `</plugins>`
    ending tag:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的底部添加以下行，位于`</plugins>`结束标签之上：
- en: '[PRE33]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Navigate to the `Android/ChildBrowser/www` folder in the repository.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到仓库中的`Android/ChildBrowser/www`文件夹。
- en: Copy `childbrowser.js` to `assets/www/plugins/Android`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`childbrowser.js`复制到`assets/www/plugins/Android`。
- en: Copy the `childbrowser` folder to `assets/www` (copy the folder, not the contents,
    and you should end up with `assets/www/childbrowser` when done).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `childbrowser` 文件夹复制到 `assets/www`（复制文件夹，而不是内容，完成后你应该会有 `assets/www/childbrowser`）。
- en: 'For our next plugin, `Share`, use the following steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个插件 `Share`，请按照以下步骤操作：
- en: Create a package in Eclipse under your project's `src` directory named `com.schaul.plugins.share`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中，在你的项目 `src` 目录下创建一个名为 `com.schaul.plugins.share` 的包。
- en: Navigate to `Android/Share` in the plugin repository and copy `Share.java` to
    the package in Eclipse.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到插件库中的 `Android/Share`，并将 `Share.java` 复制到 Eclipse 中的包。
- en: 'Add the following line at the bottom of the `plugins.xml` file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `plugins.xml` 文件的底部添加以下一行：
- en: '[PRE34]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Copy share.js` to your project''s `assets/www/plugins/Android` directory.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `share.js` 复制到你的项目 `assets/www/plugins/Android` 目录。
- en: 'The last step is to update our `www/index_Android.html` file by adding the
    following lines just below the portion that is loading the `cordova-2.2.0-android.js`
    file:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是更新我们的 `www/index_Android.html` 文件，在加载 `cordova-2.2.0-android.js` 文件的部分下方添加以下几行：
- en: '[PRE35]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That's it! Our plugins are correctly installed and configured for Android.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们的插件已经正确安装并配置好了 Android。
- en: What did we do?
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We set up the `ChildBrowser` plugin on both of our supported platforms. We set
    up ShareKit 2.0 and the `ShareKitPlugin` for iOS, and the `Share` plugin for Android.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的两个支持平台上设置了 `ChildBrowser` 插件。我们为 iOS 设置了 ShareKit 2.0 和 `ShareKitPlugin`，以及
    Android 的 `Share` 插件。
- en: What else do I need to know?
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: 'We''ve not actually dealt with how to use the plugins; we just installed them.
    We''ll be dealing with that as we come to the necessary steps when implementing
    our project. But there is one important detail to pay attention to: the plugin''s
    `readme` file, if available.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并没有处理如何使用插件；我们只是安装了它们。当我们实施项目时，我们会处理必要的步骤。但有一个重要的细节需要注意：插件的 `readme` 文件，如果有的话。
- en: This file will often indicate the installation steps necessary, or any quirks
    that you might need to watch out for. The proper use of the plugin is also usually
    detailed. Unfortunately, some plugins don't come with instructions. At that point,
    the best thing to do is to try installing it in the *normal* fashion (as we've
    done earlier for `ChildBrowser` and all the other plugins except for ShareKit)
    and see if it works.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件通常会指示必要的安装步骤，或者你可能需要注意的任何怪癖。插件的正确使用通常也会详细说明。不幸的是，一些插件没有提供说明。在这种情况下，最好的做法是尝试以
    *正常* 方式安装它（就像我们之前为 `ChildBrowser` 和所有其他插件（除了 ShareKit）所做的那样）并查看它是否工作。
- en: The other thing to remember is that PhoneGap is an ongoing project. It means
    that there are plugins that are out-of-date (and indeed, some have had to be updated
    by the author for this book) and won't work correctly with the most recent versions
    of PhoneGap. You'll need to pay attention to the plugins so that you know which
    version it supports, and if it will need to be modified to work with a newer version
    of PhoneGap. Modifications usually aren't terribly difficult, but it does involve
    getting into the native code, so you may want to ask the community for help in
    the modification. (See the end of the project for links to the community.)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是，PhoneGap 是一个持续的项目。这意味着有些插件已经过时（实际上，有些作者已经为此书更新了它们），并且无法与 PhoneGap
    的最新版本正确工作。你需要注意插件，以便知道它支持哪个版本，以及是否需要修改以与较新的 PhoneGap 版本兼容。修改通常并不特别困难，但它确实涉及到进入原生代码，所以你可能需要向社区寻求修改帮助。（请参阅项目末尾的社区链接。）
- en: Implementing the social view
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现社交视图
- en: While our app has three views, the start view is so similar to the previous
    project's start view that we won't go into great detail in this project about
    how it works. You're welcome to take a look at the code in the `www/views/startView.html`
    file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的应用有三个视图，但起始视图与之前项目的起始视图非常相似，所以我们不会在这个项目中详细说明它是如何工作的。你可以查看 `www/views/startView.html`
    文件中的代码。
- en: The bulk of our code is going to reside in the social view and the tweet view,
    so that's where our primary focus will be. So let's get started!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分代码将驻留在社交视图和推文视图中，因此我们的主要关注点将在这里。那么，让我们开始吧！
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Go ahead and create the `socialView.html` file now based on what we have discussed.
    Then we'll go over the portions you haven't seen before.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在根据我们讨论的内容创建 `socialView.html` 文件。然后我们将回顾你之前没有看到的部分。
- en: Getting on with it
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'When we''re finished with this task, we should have a view that looks like
    this for iOS:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个任务后，我们应该有一个看起来像这样的视图，适用于iOS：
- en: '![Getting on with it](img/9403_02_22.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_02_22.jpg)'
- en: 'The view for Android will be as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Android的视图将如下所示：
- en: '![Getting on with it](img/9403_02_23.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_02_23.jpg)'
- en: 'As with all our views to this point, we''re going to start with the HTML portion
    that describes the actual view; it is given as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就像到目前为止的所有视图一样，我们将从描述实际视图的HTML部分开始；它如下所示：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Generally, this looks very much like our previous views, except that there are
    a couple of critical details. We've added a style to the inner `div` element.
    This takes away our default `div` styling (from `www/framework/base.css`) and
    forces the height to fit to the content (instead of to the screen). This means
    that when we want to scroll, we'll have the whole content to scroll through.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这看起来非常像我们之前的视图，除了有几个关键细节。我们给内部`div`元素添加了一个样式。这移除了我们的默认`div`样式（来自`www/framework/base.css`）并强制高度适应内容（而不是屏幕）。这意味着当我们想要滚动时，我们将有整个内容可以滚动。
- en: 'This is the first time we''ve talked about scrolling in our apps at all, actually,
    and for good reason: it''s often hard on mobile platforms. In a perfect world,
    we could just rely on `overflow:scroll` to work on all our platforms, but that
    simply doesn''t work. We can rely on native scrolling in iOS 5 and later, but
    that has its own share of problems (depending on the version of PhoneGap and various
    other WebKit gotchas), and rules out any lower platform, and of course, it doesn''t
    work on Android at any version. So for iOS and Android, we''ll have to use our
    own implementation for scrolling or use a third-party scrolling library such as
    iScroll 4\. In this case, we''re using our own implementation, which we''ll cover
    a little later.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是我们第一次在我们的应用中讨论滚动，而且有很好的理由：在移动平台上这通常很困难。在一个完美的世界里，我们可以仅仅依靠`overflow:scroll`在所有平台上工作，但这根本不起作用。我们可以依赖iOS
    5及以后的本地滚动，但这也有它自己的问题（取决于PhoneGap的版本和各种其他WebKit的陷阱），并且排除了任何低版本的平台，当然，在任何版本的Android上都不起作用。所以对于iOS和Android，我们将不得不使用我们自己的滚动实现或使用第三方滚动库，如iScroll
    4。在这种情况下，我们正在使用我们自己的实现，我们稍后会对其进行简要介绍。
- en: 'First we need to determine how our toolbar will show its profile images using
    the following template:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确定我们的工具栏将如何使用以下模板来显示其个人头像：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that we have a little bit of JavaScript that fires when the user touches
    the image, this is to load the appropriate stream for that image.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有一段JavaScript代码在用户触摸图像时触发，这是为了加载该图像的适当流。
- en: 'Next, we need to define what the tweets should look like within our view. This
    is done by using the following code snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义推文在我们视图中的样子。这是通过以下代码片段完成的：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this segment of HTML, we've defined what the rest of a tweet should look
    like. We've given every `div` and `span` a class so that we can target them in
    our `style.css` file (located in `www/style`). That is mainly to keep the display
    of the tweet as separate from the content of the tweet as possible and to make
    it easy to change the look of a tweet whenever we want. Go ahead and take a look
    at the `style.css` file to get a good idea of how they will work to give our tweets
    some style.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个HTML段中，我们定义了推文的其余部分应该看起来像什么。我们给每个`div`和`span`都添加了一个类，这样我们就可以在`style.css`文件中定位它们（位于`www/style`）。这主要是为了尽可能地将推文的显示与推文的内容分开，并且使我们可以轻松地更改推文的样式。请查看`style.css`文件以了解它们是如何工作的，以给我们的推文添加一些样式。
- en: 'Next up is our code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的代码：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As always, we give ourselves a namespace, in this case `socialView`. We also
    declare a few properties: `firstTime`, which will track if this is the first time
    our view is being displayed or not, and `currentStream`, which will hold the current
    visible stream from Twitter. The `lastScrollTop` property will record the position
    the user has scrolled to on our current page so we can restore it when they return
    from looking an individual tweet, and `myScroll` will hold our actual scroller.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们给自己定义了一个命名空间，在这个例子中是`socialView`。我们还声明了一些属性：`firstTime`，它将跟踪这个视图是否是第一次显示，以及`currentStream`，它将保存从Twitter当前可见的流。`lastScrollTop`属性将记录用户在我们当前页面上滚动的位置，这样我们就可以在他们从查看单个推文返回时恢复它，而`myScroll`将保存我们的实际滚动器。
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our `initializeView()` method isn't terribly different from our previous project.
    I've highlighted a couple lines, however – note that we load our models and when
    they are complete, we call `TWITTER.loadTwitterUsers()`. We pass along a completion
    function, which we define next so that when Twitter has returned the user data
    for all five of our Twitter users, we can call it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`initializeView()`方法与我们的前一个项目没有太大区别。我突出显示了几个行，但是请注意，我们加载我们的模型，当它们完成时，我们调用`TWITTER.loadTwitterUsers()`。我们传递一个完成函数，我们将在下一部分定义它，这样当Twitter返回我们五个Twitter用户的用户数据时，我们就可以调用它。
- en: We've also defined our scroller. If you want to see the complete code take a
    look in `www/framework/scroller.js`, but it should suffice to say, it is a reasonably
    nice scroller that is simple to use. It doesn't beat native scrolling, but nothing
    will. You're free to replace it with any library you'd like, but for the purposes
    of this project, we've gone this route.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了我们的滚动器。如果你想查看完整的代码，请查看`www/framework/scroller.js`，但可以说，它是一个相当不错的滚动器，使用简单。它并不比原生滚动更好，但也没有什么可以做到这一点。你可以自由地用任何你喜欢的库替换它，但在这个项目的目的上，我们已经选择了这条路。
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: One of the first things we do after obtaining the template's HTML is to check
    on our `TWITTER.users` array. This array should have been filled with all sorts
    of user data, but if Twitter has rate-limited us for some reason, it may not be.
    So we check to see if there is an error condition, and if so, we let the user
    know. Granted, it's not the best method to let a user know, but for our example
    app, it suffices.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取模板的HTML之后，我们首先要检查我们的`TWITTER.users`数组。这个数组应该已经填充了各种用户数据，但如果Twitter出于某种原因限制了我们的请求频率，它可能没有。因此，我们会检查是否存在错误条件，如果有，我们会通知用户。当然，这不是通知用户的最优方法，但对我们这个示例应用来说，这已经足够了。
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we iterate through each of the users. There should be five, but you could
    configure it for a different number and build up an HTML string that we''ll put
    into the toolbar as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历每个用户。应该有五个，但你可以配置为不同的数量，并构建一个HTML字符串，然后按照以下方式将其放入工具栏中：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our next function, `loadStreamFor()` does the really hard work in this view.
    It requests a stream from Twitter and then processes it for display. The code
    snippet for it is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个函数`loadStreamFor()`在这个视图中做了真正困难的工作。它从Twitter请求一个流，然后对其进行处理以供显示。它的代码片段如下：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Something to note is that we are now inside the `completion` function, the function
    that will be called when the Twitter stream is obtained.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们现在处于`completion`函数中，这个函数将在获取Twitter流时被调用。
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because Twitter may rate-limit us at any time, we check again for any error
    in the stream in the preceding code snippet.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Twitter可能在任何时候限制我们的请求频率，我们在前面的代码片段中再次检查流中的任何错误。
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we're iterating through each item in the stream and building up a large
    HTML string from the template we defined earlier.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在遍历流中的每个项目，并从我们之前定义的模板构建一个大的HTML字符串。
- en: One important part to notice is how we're obtaining the data of the tweet, using
    `theTweet.from_user || theTweet.user.screen_name` and such. This is to deal with
    how Twitter returns a slightly different data format when searching for a word
    or a hashtag versus the data format when returning a user's timeline. Should one
    be undefined, we'll load the other, and since we can only get one or the other,
    it's easier than building a lot of if statements to take care of it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的重要部分是我们如何获取推文的数据，使用`theTweet.from_user || theTweet.user.screen_name`等。这是为了处理Twitter在搜索单词或标签时返回的数据格式与返回用户时间线时的数据格式略有不同的情况。如果其中一个未定义，我们将加载另一个，因为我们只能获取其中一个，所以这比构建大量if语句来处理它要简单得多。
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once our stream HTML is built, we assign it to the content area so that the
    user can see it. We also store the stream into the `currentStream` property so
    we can reference it later. When that's done, we scroll to the top of the page
    so that the user can see the most recent tweets.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的流HTML构建完成，我们就将其分配给内容区域，以便用户可以看到它。我们还将其存储到`currentStream`属性中，以便我们稍后可以引用它。完成这些后，我们滚动到页面顶部，以便用户可以看到最新的推文。
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That last `100`? Well, it's actually part of the call to `TwitterStream()`.
    It's the number of items to return in the stream.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 那最后的`100`？实际上它是`TwitterStream()`调用的一部分。这是流中要返回的项目数量。
- en: 'Our next function deals with what should happen when a user taps on a displayed
    tweet:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个函数处理的是当用户点击显示的推文时应该发生的事情：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This function is pretty simple. All we do is tell the tweet view what tweet
    was tapped, and then push it on to the view stack.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能相当简单。我们只是告诉推文视图哪个推文被点击了，然后将其推送到视图堆栈中。
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This `viewWillAppear()` method is pretty similar to the last project except
    for the middle and the last portion. In the middle we're checking if this is the
    first time the view has been displayed. If it is, we want to load a default stream
    for the user. Remember, up till now we've only loaded a stream when the user taps
    on a profile image in the toolbar. But we don't want to reload this stream every
    time our view displays; we could be coming back from the tweet view and the user
    might want to continue where they left off in the previous stream. In the final
    portion, we're checking to see if we had a previous scroll position, and if so,
    we scroll the view to that point. We have to create a delay here, since if we
    set it too early, the view will be offscreen (and won't scroll), or it will be
    onscreen, and it'll be noticeable to the user.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`viewWillAppear()`方法与上一个项目非常相似，除了中间和最后部分。在中间，我们检查这是否是视图第一次显示。如果是，我们希望为用户加载默认流。记住，到目前为止，我们只在用户在工具栏中点击个人资料图片时加载流。但我们不希望每次我们的视图显示时都重新加载这个流；我们可能正从推文视图返回，用户可能想要继续他们在上一个流中的位置。在最后部分，我们检查是否有之前的滚动位置，如果有，我们将视图滚动到那个点。我们必须在这里创建一个延迟，因为如果我们设置得太早，视图将不在屏幕上（并且不会滚动），或者它将在屏幕上，这将让用户注意到。
- en: The remaining two functions, `viewWillHide()` and `backButtonPressed()` present
    no new functionality, so while you do need them in your code, we won't go over
    them here.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个函数`viewWillHide()`和`backButtonPressed()`没有提供新的功能，所以虽然你需要在你的代码中包含它们，但这里我们不会详细说明。
- en: That's it, not terribly difficult, but it does what we need–display a list of
    tweets. Once a user taps on the tweet, they'll be taken to the tweet view to do
    more, and that's what we'll look at in the next task.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，并不特别困难，但它做到了我们需要的——显示推文列表。一旦用户点击推文，他们就会被带到推文视图进行更多操作，这就是我们将在下一个任务中要查看的内容。
- en: What did we do?
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: In this task we defined the HTML code and templates for our social view. We
    also used the Twitter-stream data to construct a Twitter stream that the end user
    can interact with.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们定义了我们的社交视图的HTML代码和模板。我们还使用了Twitter流数据来构建一个最终用户可以与之交互的Twitter流。
- en: Implementing the tweet view
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现推文视图
- en: Our tweet view will be where the user interacts with a given tweet. They can
    open any links within the tweet using the `ChildBrowser` plugin, or they can search
    any hashtags contained within the tweet (or any mentions, too). The view also
    gives the user the opportunity to share the tweet to any of their social networks.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的推文视图将是用户与特定推文交互的地方。他们可以使用`ChildBrowser`插件打开推文内的任何链接，或者他们可以搜索推文（或提及）中包含的任何标签（或任何提及）。视图还给了用户分享推文到他们任何社交网络的机会。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Go ahead and create your own `www/tweetView.html` file based on the one we discussed.
    We'll go over the code that is new, while leaving the rest to you to review.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们讨论的内容，创建你自己的`www/tweetView.html`文件。我们将讨论新的代码，其余的留给你自己审查。
- en: Getting on with it
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: 'For this next task, we should end up with a view that looks like the following
    on iOS:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个任务，我们应该得到一个在iOS上看起来如下所示的观点：
- en: '![Getting on with it](img/9403_02_25.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_02_25.jpg)'
- en: 'For Android, the view will be as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，视图将如下所示：
- en: '![Getting on with it](img/9403_02_26.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![继续前进](img/9403_02_26.jpg)'
- en: 'This time, we''re not going to display the HTML for defining the layout of
    our view. You may ask why? This is because you''ve seen it several times before
    and can look it up in the code for this project. We''re going to start with the
    templates that will define the content instead:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不会显示定义视图布局的HTML。你可能会问为什么？这是因为你之前已经看过几次，可以在本项目的代码中查找。我们将从定义内容的模板开始：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This code is pretty similar to the template in the previous view with a couple
    of exceptions: one that we''ve made the profile image larger, and two, we''ve
    added a `div` element that lists all the *entities* in the tweet. Twitter defines
    an entity as a URL, a hashtag, or a mention of another twitter user. We''ll display
    any of these that are in a tweet so that the user can tap on them to get more
    information.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与上一个视图中的模板非常相似，有几个例外：我们使个人资料图片更大，并且添加了一个`div`元素，列出了推文中的所有*实体*。Twitter将实体定义为URL、标签或对其他Twitter用户的提及。我们将显示推文中包含的任何这些内容，以便用户可以点击它们以获取更多信息。
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here's our template for any entity. Notice that we've given it the class of
    `entity`, so that all our entities can have a similar appearance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的任何实体的模板。请注意，我们给它分配了 `entity` 类，这样我们的所有实体都可以有相似的外观。
- en: Next up, we define what each particular entity looks like, in this case, the
    URL template.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义每个特定实体看起来像什么，在这个例子中，是 URL 模板。
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note the use of `PKUTIL.showURL()` in this template. It is a convenience method
    we've defined in `PKUTIL` to use `ChildBrowser` to show a webpage. We've done
    the work of combining how it works on each platform and put it into one function
    so that it is easy to call. We'll take a look at it a little later.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个模板中 `PKUTIL.showURL()` 的使用。这是我们在 `PKUTIL` 中定义的一个便利方法，用于使用 `ChildBrowser`
    显示网页。我们已经完成了在每个平台上如何工作的组合工作，并将其放入一个函数中，以便于调用。我们稍后会看看它。
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This template is for a hashtag. The big difference between this and the previous
    template is that it is actually referring back to our previous view! It does this
    to tell it to load a stream for the hashtag, and then we call `popView()` to go
    back to the view. Chances are the view won't have the loaded information from
    Twitter just yet, but give it a second and it'll reload with the new stream.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板是为标签设计的。与之前的模板相比，最大的不同之处在于它实际上是在引用我们之前的视图！这样做是为了告诉它加载一个标签的流，然后我们调用 `popView()`
    返回到视图。很可能会是，视图还没有加载来自 Twitter 的信息，但给它一点时间，它会重新加载并显示新的流。
- en: 'Similarly, the code for a mention is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，提及的代码如下：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'So that defines how our tweet looks and works, let''s see how the view actually
    creates the tweet itself:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义了我们的推文的外观和工作方式，让我们看看视图实际上是如何创建推文的：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we've defined the `setTweet()` method, which stores a given tweet into
    our `theTweet` property. Remember, this is called from the Twitter stream view
    when a tweet is tapped to send us the tweet to display.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了 `setTweet()` 方法，它将一个特定的推文存储到我们的 `theTweet` 属性中。记住，当点击推文以发送给我们显示的推文时，这个方法是从
    Twitter 流视图调用的。
- en: 'The next method of interest is `loadTweet()`. We''ll skip the `initializeView()`
    method as it is similar to the previous view. The `loadTweet()` method is given
    as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们感兴趣的方法是 `loadTweet()`。我们将跳过 `initializeView()` 方法，因为它与之前的视图相似。`loadTweet()`
    方法的定义如下：
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'First, we obtain the HTML for each template we need—and there are several!
    These are given as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取我们需要的每个模板的 HTML——而且有很多！这些如下所示：
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this code, we've gone through every URL entity that Twitter has sent us and
    added it to our entity HTML string. We'll repeat that for hashtags and for mentions,
    but the code is so similar, we won't repeat it here.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们已经遍历了 Twitter 发送给我们的每个 URL 实体，并将其添加到我们的实体 HTML 字符串中。我们将对标签和提及重复这一过程，但由于代码非常相似，这里不再重复。
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Once we've gone through all the entities, we handle the tweet itself. Note that
    we had to handle the entities first because we handle the substitution earlier.
    Just like with the previous view, we correctly handle if the tweet is from a search
    or from a timeline as well.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理完所有实体，我们就会处理推文本身。注意，我们必须先处理实体，因为我们之前已经处理了替换。就像之前的视图一样，我们正确地处理了推文来自搜索或来自时间线的情况。
- en: The next method of interest is the `share()` method, so we'll skip over `viewWillAppear()`,
    `viewWillHide()`, and `backButtonPressed()`. Suffice to say, the only different
    thing the `viewWIllAppear()` method does than any of the others is call the `loadTweet()`
    method to display the tweet when our view is shown.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们感兴趣的方法是 `share()` 方法，所以我们将跳过 `viewWillAppear()`、`viewWillHide()` 和 `backButtonPressed()`。简单来说，`viewWillAppear()`
    方法与其它方法唯一的不同之处在于，当我们的视图显示时，它会调用 `loadTweet()` 方法来显示推文。
- en: 'The `share()` method is where we call each platform''s plugin for sharing.
    Each platform has a slightly different syntax, so we have to check which platform
    we''re on and decide which plugin to call based on that. We can do so using the
    following code snippet:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`share()` 方法是我们调用每个平台的插件进行分享的地方。每个平台都有略微不同的语法，因此我们必须检查我们所在的平台，并根据这个决定调用哪个插件。我们可以使用以下代码片段来完成：'
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For Android, we're using the `Share` plugin, and this is how we can share with
    it. Android will then display a list of services that support sharing, including
    Twitter and Facebook, if the user has them installed. The text we give it will
    be included in the message, and Android is nice enough to let us send a success
    and a failure function should we want to do something after the tweet.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，我们使用`Share`插件，以下是使用它的方法。如果用户已经安装了这些服务，Android将显示一个支持分享的服务列表，包括Twitter和Facebook。我们给它的文本将被包含在消息中，而且Android足够友好，允许我们在推文后发送成功和失败函数。
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Our default method is for iOS, which will display an action sheet listing a
    few services, probably Twitter and Facebook, and the user can tap the button of
    the service they want to share to. Once they authenticate to the service, they
    can then send the message.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认的方法是针对iOS的，它将显示一个动作表，列出一些服务，可能是Twitter和Facebook，用户可以点击他们想要分享的服务按钮。一旦他们验证了服务，他们就可以发送消息。
- en: What did we do?
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们做了什么？
- en: We displayed a single tweet and processed the various entities within it. We
    demonstrated loading an external site in the `ChildBrowser` plugin by using `PKUTIL.showURL()`.
    We also demonstrated how to use the various sharing plugins.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了一条推文，并处理了其中的各种实体。我们通过使用`PKUTIL.showURL()`演示了如何在`ChildBrowser`插件中加载外部网站。我们还演示了如何使用各种分享插件。
- en: What else do I need to know?
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我还需要了解什么？
- en: Let's take a quick look at `PKUTIL.showURL()`, the method used to display a
    `ChildBrowser` with an external site. It's a pretty simple function, but since
    it takes three different ways to show `ChildBrowser`, we packaged it up into a
    function that makes it easy to use.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下`PKUTIL.showURL()`，这是用来显示带有外部网站的`ChildBrowser`的方法。这是一个相当简单的函数，但由于它以三种不同的方式显示`ChildBrowser`，我们将其打包成一个易于使用的函数。
- en: '[PRE62]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: For Android, it's simple to call `ChildBrowser`. Typically this is how you call
    any plugin you want to use in PhoneGap.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，调用`ChildBrowser`很简单。通常，这就是你在PhoneGap中调用任何插件的方式。
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: WP7 is here too, since the platform supports it, and is a little more difficult.
    We have to pack the URL into an options array and then send it to the plugin to
    show.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: WP7也在这里，因为该平台支持它，而且稍微困难一些。我们必须将URL打包到一个选项数组中，然后发送到插件以显示。
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: For iOS, it's very similar to Android's method, except we call it directly instead
    of using `window.plugins.*`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS，方法与Android非常相似，只是我们直接调用它，而不是使用`window.plugins.*`。
- en: Game Over..... Wrapping it up
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束..... 结束语
- en: Well, you've done it. You've successfully written an app that displays information
    obtained from Twitter and that lets the user share it on their own social network.
    For some platforms, it wasn't too hard to configure the plugins necessary to do
    this work, while for iOS, you probably got a bit more familiar with Xcode and
    header paths and such than you wanted. The rest was easy; adding plugins gets
    easier the more you do it, and chances are pretty good you'll need at least the
    `ChildBrowser` plugin in nearly every project you do. Thankfully, it's also an
    easy install!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你已经做到了。你成功地编写了一个应用程序，显示从Twitter获取的信息，并允许用户在自己的社交网络上分享它。对于某些平台，配置完成这项工作的插件并不太难，而对于iOS，你可能比预期的更熟悉Xcode和头文件路径等。其余的都是容易的；添加插件越做越容易，而且几乎在每一个项目中你都需要至少`ChildBrowser`插件。幸运的是，安装它也很简单！
- en: 'Some resources you might find valuable are as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你可能觉得有价值的资源如下：
- en: 'ShareKit: [https://github.com/ShareKit/ShareKit](https://github.com/ShareKit/ShareKit)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ShareKit: [https://github.com/ShareKit/ShareKit](https://github.com/ShareKit/ShareKit)'
- en: 'JSON: [http://www.json.org/](http://www.json.org/)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JSON: [http://www.json.org/](http://www.json.org/)'
- en: 'Twitter JSON documentation: [https://dev.twitter.com/docs/api/1](https://dev.twitter.com/docs/api/1)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Twitter JSON文档: [https://dev.twitter.com/docs/api/1](https://dev.twitter.com/docs/api/1)'
- en: 'Phonegap plugins: [http://www.github.com/phonegap/phonegap-plugins](http://www.github.com/phonegap/phonegap-plugins)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Phonegap插件: [http://www.github.com/phonegap/phonegap-plugins](http://www.github.com/phonegap/phonegap-plugins)'
- en: 'Phonegap community: [http://groups.google.com/group/phonegap](http://groups.google.com/group/phonegap)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Phonegap社区: [http://groups.google.com/group/phonegap](http://groups.google.com/group/phonegap)'
- en: 'iScroll 4: [http://cubiq.org/iscroll-4](http://cubiq.org/iscroll-4)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'iScroll 4: [http://cubiq.org/iscroll-4](http://cubiq.org/iscroll-4)'
- en: Can you take the HEAT? The Hotshot Challenge
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能承受压力吗？热手挑战
- en: 'As a project, Socializer does what it is set out to do, but there''s actually
    so much more that you could do to it to make it truly useful. Why don''t you try
    one or more of the following challenges:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 作为项目，Socializer完成了它设定的目标，但实际上你还可以做更多的事情来使其真正有用。为什么不尝试以下一个或多个挑战：
- en: Let the end user select their own initial Twitter accounts, instead of our initial
    five.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许最终用户选择他们自己的初始Twitter账户，而不仅仅是我们的前五个。
- en: Display a loading graphic while the Twitter stream is loading so that the user
    knows that the app is working on something.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在加载Twitter流时显示一个加载图形，以便用户知道应用正在处理某事。
- en: Style any links, mentions, or hashtags in the Twitter stream to make them stand
    out more.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Twitter流中的任何链接、提及或标签样式化，使它们更加突出。
- en: Try your hand at working with the API of any other social network you like.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用你喜欢的任何社交网络的API进行操作。
- en: Try to add OAuth authentication.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试添加OAuth身份验证。
