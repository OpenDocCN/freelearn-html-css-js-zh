- en: E2E Testing in React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 中的端到端测试
- en: For our backend development, we vehemently followed **Test-Driven Development**
    (**TDD**) – we started development by writing E2E tests, and we wrote some implementation
    code to make these tests pass. After we implemented this feature, we added unit
    and integration tests to add more confidence to our underlying code, and also
    to help catch regression.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的后端开发，我们坚决遵循 **测试驱动开发**（**TDD**）——我们通过编写端到端测试开始开发，并编写了一些实现代码来使这些测试通过。在实现了这个功能之后，我们添加了单元和集成测试来增加我们对底层代码的信心，并帮助捕获回归。
- en: 'Now that we have a basic understanding of React, we will, in this chapter,
    examine how we can implement TDD in React. Specifically, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 React 有了一个基本的了解，在本章中，我们将探讨如何在 React 中实现 TDD。具体来说，我们将涵盖：
- en: Using **Selenium** to automate interaction with the browser
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Selenium** 自动化与浏览器的交互
- en: Working with **React Router** to implement **client-side routing**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **React Router** 实现 **客户端路由**
- en: Testing strategies
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试策略
- en: As it turns out, TDD on the frontend follows a similar approach involving automated
    UI testing and Unit tests.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，前端上的 TDD 采用类似的方法，涉及自动化 UI 测试和单元测试。
- en: Automated UI testing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化 UI 测试
- en: When we write E2E tests for our API, we first compose our request, send it,
    and assert that it returns what is expected. In other words, our E2E tests are
    mimicking how an end user would interact with our API. For the frontend, a user
    would interact with our application through the user interface (UI). Therefore,
    the equivalent to E2E testing would be automated UI testing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为我们的 API 编写端到端测试时，我们首先编写我们的请求，发送它，并断言它返回预期的结果。换句话说，我们的端到端测试是在模仿最终用户如何与我们的
    API 交互。对于前端，用户将通过用户界面（UI）与我们的应用程序交互。因此，端到端测试的对应物将是自动化 UI 测试。
- en: 'UI tests automate the actions that a user of the application would take. For
    example, if we want to test that an user can register, we''d write a test that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: UI 测试自动化了应用程序用户可能采取的操作。例如，如果我们想测试用户可以注册，我们会编写一个测试，它：
- en: Navigates to the `/register` page
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到 `/register` 页面
- en: Types in the email
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入电子邮件
- en: Types in the password
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入密码
- en: Presses the Register button
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击注册按钮
- en: Asserts that the user is registered
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言用户已注册
- en: These tests can be written in Gherkin and run with Cucumber. The actual mimicking
    of the user action can automate these using Browser Automation Tools like Selenium.
    For example, when we run the test step "Press the Register button", we can instruct
    Selenium to select the button with the `id` value `register-button` and trigger
    a click event on it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试可以用 Gherkin 编写，并使用 Cucumber 运行。实际的用户操作模拟可以通过使用像 Selenium 这样的浏览器自动化工具来自动化。例如，当我们运行测试步骤“点击注册按钮”时，我们可以指示
    Selenium 选择具有 `id` 值 `register-button` 的按钮并触发其上的点击事件。
- en: Unit testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: For the frontend, unit testing involves two different aspects—logical units
    and component units.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端，单元测试涉及两个不同的方面——逻辑单元和组件单元。
- en: Logical units
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑单元
- en: A unit can be a function or class that does not interact with the UI; functions
    like `validateInput` are a prime example. These logical units uses plain JavaScript
    and should work independently from the environment. Therefore, we can unit test
    them using Mocha, Chai, and Sinon in the same manner as we did for our backend
    code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单元可以是一个不与 UI 交互的函数或类；例如 `validateInput` 函数就是一个很好的例子。这些逻辑单元使用纯 JavaScript，并且应该能够独立于环境工作。因此，我们可以使用
    Mocha、Chai 和 Sinon 以与我们的后端代码相同的方式对它们进行单元测试。
- en: Because logical units are the easiest to test. You should pull as much of that
    application logic as possible and test it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为逻辑单元是最容易测试的。你应该尽可能多地提取应用程序逻辑并对其进行测试。
- en: Component units
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件单元
- en: A unit may also refer to a single component in React. For example, we can test
    that when the input has changed, that the state of the component is updated in
    an expected way; or for controlled components, that the right callback is called
    with the correct parameters
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元也可能指 React 中的单个组件。例如，我们可以测试当输入改变时，组件的状态以预期的方式更新；或者对于受控组件，正确的回调是否以正确的参数被调用。
- en: Browser testing
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器测试
- en: Thanks to headless browsers—browsers that don't render to a display interface—both
    E2E and unit tests can be run from the server. However, we should also test these
    unit tests in a real browser, as there might be inconsistencies between NodeJS
    (which uses the V8 JavaScript Engine), and other browsers like Firefox (which
    uses the SpiderMonkey engine), Microsoft Edge (which uses the Chakra engine),
    and Safari (which uses the Nitro engine).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了无头浏览器——这些浏览器不会渲染到显示界面——我们可以在服务器上运行端到端（E2E）和单元测试。然而，我们也应该在真实浏览器中测试这些单元测试，因为NodeJS（使用V8
    JavaScript引擎）和其他浏览器（如Firefox使用SpiderMonkey引擎、Microsoft Edge使用Chakra引擎、Safari使用Nitro引擎）之间可能存在不一致性。
- en: To test on real browsers and devices, we can use a different test runner called
    *Karma* ([https://karma-runner.github.io/2.0/index.html](https://karma-runner.github.io/2.0/index.html)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在真实浏览器和设备上测试，我们可以使用一个名为*Karma*（[https://karma-runner.github.io/2.0/index.html](https://karma-runner.github.io/2.0/index.html)）的不同测试运行器。
- en: Writing E2E tests with Gherkin, Cucumber, and Selenium
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gherkin、Cucumber和Selenium编写端到端测试
- en: Now, we are ready to integrate with tools that can mimic user interaction with
    a browser. For our first test, let's test something very simple—a user will type
    in a valid email, but their password is too short. In this case, we want to assert
    that the Register button will be disabled.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好与可以模拟用户与浏览器交互的工具集成。对于我们的第一个测试，让我们测试一个非常简单的事情——用户将输入一个有效的电子邮件，但他们的密码太短。在这种情况下，我们想要断言注册按钮将被禁用。
- en: 'Like our backend E2E tests, we will be writing our test cases in Gherkin, and
    using Cucumber to run our scenarios. So, let''s add these as development dependencies:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的后端端到端测试一样，我们将使用Gherkin编写测试用例，并使用Cucumber运行场景。所以，让我们将这些添加为开发依赖项：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we need to create feature files and step definition files. For our first
    scenario, I have opted to group the features and steps in the following structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建功能文件和步骤定义文件。对于我们的第一个场景，我选择按照以下结构将功能和步骤分组：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Feel free to group them differently, as long as the features are separated from
    the step definitions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随意分组，只要确保功能与步骤定义分开。
- en: Adding test script
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加测试脚本
- en: 'Although we haven''t written any tests yet, we can simply copy the test script
    we wrote for our API and place it in `scripts/e2e.test.sh`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有编写任何测试，但我们可以简单地复制我们为API编写的测试脚本，并将其放置在`scripts/e2e.test.sh`中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The only difference between our script and the backend test script is this
    line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本和后端测试脚本之间的唯一区别是这一行：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With `> /dev/null`, we are directing `stdout` into the *null device* (`/dev/null`),
    which discards anything piped into it. With `2>&1`, we are directing `stderr`
    to `stdout`, which will end up at `/dev/null` eventually. Basically, this line
    is saying "I don't care about the output of `yarn run serve`, just throw it away".
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`> /dev/null`，我们将`stdout`重定向到`null device`（`/dev/null`），它会丢弃任何被管道传输的内容。使用`2>&1`，我们将`stderr`重定向到`stdout`，最终也会到达`/dev/null`。基本上，这一行是在说“我不关心`yarn
    run serve`的输出，只是把它扔掉”。
- en: We do this because, as Selenium is navigating between different pages, the output
    from the `http-server` will be sent to `stdout` and interspersed between the test
    results, making it hard to read.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为，当Selenium在页面之间导航时，`http-server`的输出将被发送到`stdout`并穿插在测试结果之间，这使得阅读变得困难。
- en: 'Also, don''t forget to install the script''s dependencies:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了安装脚本的依赖项：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also need to create a `.babelrc` file to instruct `babel-register` to use
    the `env` preset:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个`.babelrc`文件来指导`babel-register`使用`env`预设：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, update the `package.json` with the new script:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`package.json`以包含新的脚本：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Specifying a feature
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定一个功能
- en: 'Now, we are ready to define our first feature. In `spec/cucumber/features/users/reigster/main.feature`,
    add the following specification:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好定义我们的第一个功能。在`spec/cucumber/features/users/reigster/main.feature`中添加以下规范：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding IDs to elements
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给元素添加ID
- en: We will use Selenium to automate the interaction with the UI elements of our
    application. However, we must provide some sort of selector for Selenium to select
    the element we want to interact with. The most precise selector we can have is
    an `id` attribute.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Selenium来自动化与我们的应用程序UI元素的交互。然而，我们必须提供某种选择器，以便Selenium可以选择我们想要与之交互的元素。我们可以拥有的最精确的选择器是一个`id`属性。
- en: 'So, before we use Selenium, let''s add some ids to our elements. Open `src/components/registration-form/index.jsx` and
    add an `id` prop to each element:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们使用Selenium之前，让我们给我们的元素添加一些ID。打开`src/components/registration-form/index.jsx`并给每个元素添加一个`id`属性：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, in `src/components/input/index.jsx` and `src/components/button/index.jsx`,
    pass the `id` prop into the element as an attribute. For instance, the `Button`
    component would become:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`src/components/input/index.jsx`和`src/components/button/index.jsx`中，将`id`属性作为属性传递给元素。例如，`Button`组件将变为：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Selenium
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium
- en: 'We are now ready to use Selenium. Selenium was written by Jason Huggins in
    2004 while working at ThoughtWorks. It is not just a single tool, but a suite
    of tools, that allows you to automate browsers across multiple platforms. We will
    be using the JavaScript binding to Selenium WebDriver, but it''s beneficial for
    us to take a quick look at each part of the tool suite:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始使用Selenium了。Selenium是由Jason Huggins在2004年，在ThoughtWorks工作时编写的。它不仅仅是一个单一的工具，而是一套工具，允许您跨多个平台自动化浏览器。我们将使用Selenium
    WebDriver的JavaScript绑定，但快速浏览工具套件的每个部分对我们来说是有益的：
- en: Selenium **Remote Control** (**RC**), also known as Selenium 1.0, is the first
    tool in the suite that allows you to automate browsers. It works by injecting
    JavaScript scripts into the browser when the page is first loaded. These scripts
    would simulate user interaction by clicking on buttons and inputting texts. Selenium
    RC has been deprecated and is superseded by Selenium WebDriver.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium **远程控制**（**RC**），也称为Selenium 1.0，是套件中的第一个工具，允许您自动化浏览器。它通过在页面首次加载时向浏览器注入JavaScript脚本来实现，这些脚本通过点击按钮和输入文本来模拟用户交互。Selenium
    RC已被弃用，并由Selenium WebDriver取代。
- en: Selenium WebDriver, also known as Selenium 2, is the successor of Selenium RC,
    and uses the standardized WebDriver API to mimic user interaction. Most browsers
    have built-in support for the WebDriver API, and so the tool doesn't need to inject
    scripts onto the page anymore.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium WebDriver，也称为Selenium 2，是Selenium RC的继任者，并使用标准化的WebDriver API来模拟用户交互。大多数浏览器都内置了对WebDriver
    API的支持，因此工具不再需要将脚本注入页面。
- en: Selenium Server allows you to run your tests on a remote machine, such as when
    using Selenium Grid.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium Server允许您在远程机器上运行测试，例如在使用Selenium Grid时。
- en: Selenium Grid allows you to distribute your tests over multiple machines or
    virtual machines (VMs). These tests can then run in parallel. If your test suite
    is large, and/or you need to run tests on multiple browsers and/or operating systems,
    then test execution is likely to take a long time. By distributing these tests
    across multiple machines, you can run them in parallel and reduce the total execution
    time.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium Grid允许您将测试分布在多台机器或虚拟机（VM）上。然后，这些测试可以并行运行。如果您的测试套件很大，或者您需要在多个浏览器和/或操作系统上运行测试，那么测试执行可能需要很长时间。通过将这些测试分布在多台机器上，您可以并行运行它们，从而减少总执行时间。
- en: Selenium IDE is a Chrome extension/Firefox plugin that provides a rapid prototyping
    tool for building test scripts. Essentially, it can record actions a user takes
    on a page, and exports them as a reusable script in many languages. A developer
    can then take this script and further customize it to their own needs.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium IDE是一个Chrome扩展/Firefox插件，它提供了一个快速原型设计工具，用于构建测试脚本。本质上，它可以记录用户在页面上的操作，并将它们导出为许多语言的可重用脚本。然后，开发者可以取用这个脚本，并根据他们的需求进一步定制它。
- en: For testing our application, we are going to be using Selenium WebDriver.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的应用程序，我们将使用Selenium WebDriver。
- en: WebDriver API
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebDriver API
- en: '*WebDriver* is a standardized API that allows you to inspect and control a
    user agent (for example, a browser or mobile application). It was originally conceived
    in 2006 by Simon Stewart, a Google engineer at the time. It has now been defined
    by the World Wide Web Consortium (W3C), and its specification can be found at
    [https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/). The document
    is currently in the *Candidate Recommendation* stage.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*WebDriver*是一个标准化的API，允许您检查和控制用户代理（例如，浏览器或移动应用程序）。它最初由当时在谷歌工作的工程师Simon Stewart在2006年构思。现在，它已经被万维网联盟（W3C）定义，其规范可以在[https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)找到。该文档目前处于*候选推荐*阶段。'
- en: Instead of injecting JavaScript scripts into the web page and using them to
    mimic user interaction, Selenium WebDriver uses the WebDriver API, which most
    browsers support. However, you may see variation in the level of support, as well
    as how the standard is implemented, between different browsers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与将JavaScript脚本注入网页并使用它们来模拟用户交互不同，Selenium WebDriver使用WebDriver API，大多数浏览器都支持这个API。然而，您可能会看到在不同浏览器之间对标准的支持程度以及实现方式的差异。
- en: While the API is platform- and language-neutral, there have been many implementations
    of it. Specifically, we are going to be using the official JavaScript binding,
    which is available as the "selenium-webdriver" package on NPM.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然API是平台和语言中立的，但已经有许多实现。具体来说，我们将使用官方的 JavaScript 绑定，它作为 "selenium-webdriver"
    包在 NPM 上提供。
- en: Using Selenium WebDriver
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Selenium WebDriver
- en: 'Let''s start by adding the Selenium WebDriver JavaScript package to our project:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的项目中添加 Selenium WebDriver JavaScript 包开始：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will use `selenium-webdriver` to define our Step Definitions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `selenium-webdriver` 来定义我们的步骤定义。
- en: Selenium requires a browser to run tests on. This may be a real browser like
    Chrome, or a headless browser such a PhantomJS. You're likely familiar with the
    different real browsers, so let's spend some time taking a look at the headless
    browsers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 需要一个浏览器来运行测试。这可能是一个真实的浏览器，如 Chrome，或者一个无头浏览器，如 PhantomJS。你很可能熟悉不同的真实浏览器，所以让我们花些时间来看看无头浏览器。
- en: Headless browsers
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无头浏览器
- en: Headless browsers are browsers that do not render the page on an interface.
    A header browser would fetch the content of the page and then download images,
    stylesheets, scripts, and so on, and process them just like a real browser.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 无头浏览器是那些不在界面上渲染页面的浏览器。一个头浏览器会获取页面内容，然后下载图片、样式表、脚本等，并像真实浏览器一样处理它们。
- en: 'The benefits of using a headless browser is that it is much faster. This is
    because the browser doesn''t have a Graphical User Interface (GUI), and thus there''s
    no need to wait for the display to actually render the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无头浏览器的优点是它要快得多。这是因为浏览器没有图形用户界面 (GUI)，因此不需要等待显示实际渲染输出：
- en: PhantomJS ([http://phantomjs.org/](http://phantomjs.org/)) uses the WebKit web
    browser engine, which is the same one that is used by Safari. It is arguably the
    most popular headless browser today. However, activity on its repository has almost
    come to a halt since the middle of 2016.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhantomJS ([http://phantomjs.org/](http://phantomjs.org/)) 使用 WebKit 网络浏览器引擎，这与
    Safari 所使用的相同。它可以说是目前最流行的无头浏览器。然而，自 2016 年中以来，其仓库的活动几乎已经停止。
- en: SlimerJS ([https://slimerjs.org/](https://slimerjs.org/)) uses the Gecko web
    browser engine, and SpiderMonkey as the JavaScript engine, which is the same as
    Firefox. SlimerJS is not a headless browser by default, as it uses the X11 display
    server on the test machine. However, you can integrate it with *Xvfb* (short for
    *X virtual framebuffer*), which is an in-memory display server that does not require
    a display. Since Firefox 56, you can also enable headless mode with the `--headless`
    flag.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SlimerJS ([https://slimerjs.org/](https://slimerjs.org/)) 使用 Gecko 网络浏览器引擎，以及
    SpiderMonkey 作为 JavaScript 引擎，这与 Firefox 相同。SlimerJS 默认不是一个无头浏览器，因为它在测试机器上使用 X11
    显示服务器。然而，你可以通过与 *Xvfb*（即 *X 虚拟帧缓冲区*）集成来使用它，这是一个内存中的显示服务器，不需要显示。自 Firefox 56 版本起，你也可以通过
    `--headless` 标志启用无头模式。
- en: ZombieJS ([http://zombie.js.org/](http://zombie.js.org/)) is a faster implementation
    of a headless browser because it does not use an actual web browser engine like
    PhantomJS or SlimerJS. Instead, it uses JSDOM, which is a pure-JavaScript implementation
    of the DOM and HTML. However, also because of this, the results may not be 100%
    accurate or as realistic as testing against an actual web browser engine.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZombieJS ([http://zombie.js.org/](http://zombie.js.org/)) 是一个无头浏览器的更快实现，因为它不使用像
    PhantomJS 或 SlimerJS 这样的实际网络浏览器引擎。相反，它使用 JSDOM，这是一个 DOM 和 HTML 的纯 JavaScript 实现。然而，正因为如此，结果可能不会完全准确，或者不如针对实际网络浏览器引擎的测试那样真实。
- en: HtmlUnit ([http://htmlunit.sourceforge.net/](http://htmlunit.sourceforge.net/))
    is a "GUI-less browser for Java programs". It uses the Rhino JavaScript engine,
    which, like Selenium, is written in Java. From experience, HtmlUnit is the quickest
    headless browser but also the most error-prone. It's ideal for simple static pages
    that do not involve heavy JavaScript usage.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HtmlUnit ([http://htmlunit.sourceforge.net/](http://htmlunit.sourceforge.net/))
    是一个“无GUI浏览器，用于 Java 程序”。它使用 Rhino JavaScript 引擎，与 Selenium 一样，是用 Java 编写的。根据经验，HtmlUnit
    是最快的无头浏览器，但也是最容易出现错误的。它非常适合简单的静态页面，不涉及大量 JavaScript 使用。
- en: There are many more headless browsers out there. Asad Dhamani has curated a
    list which you can find at [https://github.com/dhamaniasad/HeadlessBrowsers](https://github.com/dhamaniasad/HeadlessBrowsers).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多无头浏览器。Asad Dhamani 编制了一个列表，您可以在 [https://github.com/dhamaniasad/HeadlessBrowsers](https://github.com/dhamaniasad/HeadlessBrowsers)
    找到。
- en: 'However, purely-headless browsers might be a thing of the past soon, as many
    "real" browsers now support Headless Mode. The following browsers have Headless
    Mode support:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，纯无头浏览器可能很快就会成为过去式，因为许多“真实”浏览器现在都支持无头模式。以下浏览器支持无头模式：
- en: Chrome 59
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome 59
- en: Firefox 55 (on Linux) and 56 (on macOS and Windows)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox 55（在 Linux 上）和 56（在 macOS 和 Windows 上）
- en: For those that don't, we can use Xvfb to substitute for the X11 display server,
    and run the real browser on a CI server. However, this will lose the performance
    benefit of running a headless browser.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持这种情况的用户，我们可以使用 Xvfb 来替代 X11 显示服务器，并在 CI 服务器上运行真实浏览器。然而，这将失去运行无头浏览器的性能优势。
- en: Browser drivers
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器驱动程序
- en: Selenium WebDriver supports many browsers, both real and headless, and each
    one requires its own driver that implements WebDriver's wire protocol for that
    specific browser.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver 支持许多浏览器，包括真实和无头浏览器，每个浏览器都需要实现 WebDriver 的特定浏览器线协议的驱动程序。
- en: 'For real browsers:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真实浏览器：
- en: Chrome and Chrome on Android uses the ChromeDriver ([https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/)),
    which is maintained by the Chromium project itself
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome 和 Android 上的 Chrome 使用 ChromeDriver ([https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/))，由
    Chromium 项目本身维护
- en: Firefox uses the geckodriver ([https://github.com/mozilla/geckodriver/](https://github.com/mozilla/geckodriver/))
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox 使用 geckodriver ([https://github.com/mozilla/geckodriver/](https://github.com/mozilla/geckodriver/))
- en: Internet Explorer uses the Internet Explorer Driver
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Internet Explorer 使用 Internet Explorer Driver
- en: Edge uses Microsoft WebDriver ([https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/))
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Edge 使用 Microsoft WebDriver ([https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/))
- en: Safari uses SafariDriver ([https://webkit.org/blog/6900/webdriver-support-in-safari-10/](https://webkit.org/blog/6900/webdriver-support-in-safari-10/))
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Safari 使用 SafariDriver ([https://webkit.org/blog/6900/webdriver-support-in-safari-10/](https://webkit.org/blog/6900/webdriver-support-in-safari-10/))
- en: Opera uses Opera Driver
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opera 使用 Opera Driver
- en: iOS (native, hybrid, or mobile web application) uses ios-driver ([http://ios-driver.github.io/ios-driver/](http://ios-driver.github.io/ios-driver/))
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS（原生、混合或移动 Web 应用程序）使用 ios-driver ([http://ios-driver.github.io/ios-driver/](http://ios-driver.github.io/ios-driver/))
- en: Android (native, hybrid, or mobile web application) uses Selendroid
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android（原生、混合或移动 Web 应用程序）使用 Selendroid
- en: 'For headless browsers:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无头浏览器：
- en: HtmlUnit uses HtmlUnitDriver ([https://github.com/SeleniumHQ/htmlunit-driver](https://github.com/SeleniumHQ/htmlunit-driver))
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HtmlUnit 使用 HtmlUnitDriver ([https://github.com/SeleniumHQ/htmlunit-driver](https://github.com/SeleniumHQ/htmlunit-driver))
- en: PhantomJS uses GhostDriver ([https://github.com/detro/ghostdriver](https://github.com/detro/ghostdriver)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhantomJS 使用 GhostDriver ([https://github.com/detro/ghostdriver](https://github.com/detro/ghostdriver))
- en: Setup and teardown
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和销毁
- en: 'Before we can run any tests, we must tell Selenium which browser to use. Chrome
    is, by far, the most popular browser in use today, and so we will start with using
    ChromeDriver. Let''s install it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以运行任何测试之前，我们必须告诉 Selenium 要使用哪个浏览器。Chrome 目前是使用最广泛的浏览器，因此我们将从使用 ChromeDriver
    开始。让我们来安装它：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, inside `spec/cucumber/steps/index.js`, define `Before` and `After` hooks
    which are run before each scenario:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `spec/cucumber/steps/index.js` 中，定义在每次场景之前运行的 `Before` 和 `After` 钩子：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `Before` hook, we are creating a new instance of the driver. A driver
    is akin to an user session, and a session can have many windows opened (just like
    you can have multiple tabs opened at the same time).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Before` 钩子中，我们正在创建驱动程序的新实例。驱动程序类似于用户会话，一个会话可以打开多个窗口（就像你可以在同一时间打开多个标签页一样）。
- en: 'The `webdriver.Builder` constructor function returns with an instance that
    implements the `ThenableWebDriver` interface, which allows us to specify parameters
    for the driver by chaining methods together. Some popular methods include the
    following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`webdriver.Builder` 构造函数返回一个实现 `ThenableWebDriver` 接口的实例，这允许我们通过链式调用方法来指定驱动程序的参数。一些常用方法包括以下内容：'
- en: '`forBrowser`: Specify which browser to use.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forBrowser`：指定要使用的浏览器。'
- en: '`withCapabilities`: Passes parameters to the browser command. Later on, we
    will use this to run Chrome in Headless Mode.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withCapabilities`：将参数传递给浏览器命令。稍后我们将使用它以无头模式运行 Chrome。'
- en: Once the parameters have been set, terminate the chain using the `build` method
    to return an instance of the driver.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了参数，使用 `build` 方法终止链式调用，以返回驱动程序的实例。
- en: In the `After` hook, we are disposing the driver using the `quit` method. This
    will close all windows and end the session.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`After`钩子中，我们使用`quit`方法来释放驱动。这将关闭所有窗口并结束会话。
- en: We are storing the driver instance in Cucumber's World (the context) for other
    steps to use.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将驱动实例存储在Cucumber的世界（上下文）中，以便其他步骤可以使用。
- en: Implementing step definitions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现步骤定义
- en: Next, we need to implement the step definitions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现步骤定义。
- en: Navigating to a page
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航到页面
- en: 'Now that everything is set up, let''s implement our first step, which is `When
    user navigates to /`. Navigation can be done using the `.get` method on our driver
    object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，让我们实现我们的第一个步骤，即`When user navigates to /`。导航可以通过在驱动对象上使用`.get`方法来完成：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This step takes the server host and port from the environment variables. `this.driver.get`
    returns a promise which is returned. Cucumber will wait for this promise to be
    resolved or rejected before moving on to the next step.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤从环境变量中获取服务器主机和端口。`this.driver.get`返回一个承诺，该承诺被返回。Cucumber将在移动到下一个步骤之前等待此承诺解决或拒绝。
- en: Typing into input
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入到输入框中
- en: 'This is our next step:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的下一个步骤：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This involves finding the element with the `id` of `email`, and then sending
    keystroke events to it. In `spec/cucumber/steps/interactions/input.js`, add the
    following step definition:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到找到具有`id`为`email`的元素，然后向其发送按键事件。在`spec/cucumber/steps/interactions/input.js`中添加以下步骤定义：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `driver.findElement` returns an instance of `WebElementPromise`. We are
    using the `async`/`await` syntax to avoid callback hell or heavily chained promises.
    The same step definition would work for our next step, which types in a short
    password into the `#password` input element.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`driver.findElement`返回一个`WebElementPromise`实例。我们使用`async`/`await`语法来避免回调地狱或深度链式承诺。相同的步骤定义将适用于我们的下一个步骤，即在`#password`输入元素中输入一个简短的密码。
- en: Asserting a result
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言结果
- en: 'The last step is to do the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是执行以下操作：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As before, we need to find the element, but this time read its `disabled` attribute
    and assert that it is set to `"true"`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要找到元素，但这次读取其`disabled`属性并断言它设置为`"true"`。
- en: The HTML *content* attribute will always be a string, even when you'd expect
    a boolean or number.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: HTML的`content`属性始终是一个字符串，即使你期望它是布尔值或数字。
- en: 'In `spec/cucumber/steps/assertions/index.js`, add the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spec/cucumber/steps/assertions/index.js`中添加以下内容：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we use the `getAttribute` method from the `WebElement` instance to get
    the value of the `disabled` attribute. Again, this is an asynchronous operation,
    so we are using `async`/`await` syntax to keep things neat.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`getAttribute`方法从`WebElement`实例中获取`disabled`属性值。同样，这是一个异步操作，所以我们使用`async`/`await`语法来保持代码整洁。
- en: If you have time, it's always a good idea to read the official documentation.
    The API of all classes and methods from `selenium-webdriver` can be found at [https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/](https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有时间，阅读官方文档总是一个好主意。`selenium-webdriver`中所有类和方法的API可以在[https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/](https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/)找到。
- en: Running the tests
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'Now, we are ready to run the tests:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好运行测试：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will run the `./scripts/e2e.test.sh` script, which will build the project
    using Webpack (this may take some time). Then, a Google Chrome browser will pop
    up, and you''ll see the input fields being automatically populated with the text
    we specified. After Selenium has performed all actions required, the `driver.quit()`
    method call in our After hook will close the browser, and the results will be
    displayed in our terminal.:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行`./scripts/e2e.test.sh`脚本，该脚本将使用Webpack构建项目（这可能需要一些时间）。然后，一个Google Chrome浏览器将弹出，你会看到输入字段被自动填充了我们指定的文本。Selenium执行完所有必要的操作后，我们After钩子中的`driver.quit()`方法调用将关闭浏览器，并将结果显示在我们的终端中：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding multiple testing browsers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加多个测试浏览器
- en: The biggest benefit of using Selenium is that you can use the same tests to
    test multiple browsers. If we are interested in just a single browser, like Chrome,
    we'd be better off using Puppeteer. So, let's add Firefox to our tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Selenium的最大好处是你可以使用相同的测试来测试多个浏览器。如果我们只对单个浏览器感兴趣，比如Chrome，那么使用Puppeteer会更好。所以，让我们将Firefox添加到我们的测试中。
- en: 'Firefox, like Chrome, requires a driver to work. Firefox''s driver is `geckodriver`,
    which uses the *Marionette* proxy to send instructions to Firefox (Marionette
    is similar to Chrome''s DevTools Protocol):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox，就像Chrome一样，需要一个驱动程序才能工作。Firefox的驱动程序是`geckodriver`，它使用*Marionette*代理向Firefox发送指令（Marionette类似于Chrome的DevTools协议）：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, all we need to do is change the `forBrowser` call to use `"firefox"`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将`forBrowser`调用更改为使用`"firefox"`：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we run our tests again, Firefox will be used instead of Chrome.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次运行测试时，将使用Firefox而不是Chrome。
- en: 'However, instead of hard-coding the browser into our code, let''s update our
    scripts to allow us to specify the browsers we want to test. We can do this by
    passing arguments into the shell script. For instance, if we execute the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，而不是在我们的代码中硬编码浏览器，让我们更新我们的脚本来允许我们指定我们想要测试的浏览器。我们可以通过将参数传递到shell脚本中来实现这一点。例如，如果我们执行以下操作：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, in our `scripts/e2e.test.sh`, we can access the arguments using `$1`
    for the first argument (`chrome`), `$2` for `firefox`, and so on. Alternatively,
    we can use the special argument `"$@"`, which is an array-like construct that
    contains all arguments. In `scripts/e2e.test.sh`, change the test block to the
    following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`scripts/e2e.test.sh`中，我们可以使用`$1`来访问第一个参数（`chrome`），`$2`来访问`firefox`，依此类推。或者，我们可以使用特殊的参数`"$@"`，它是一个类似于数组的结构，包含所有参数。在`scripts/e2e.test.sh`中，将测试块更改为以下内容：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will loop through our list of browsers, `export` it in the `TEST_BROWSER`
    variable, and run our tests. Then, in the `forBrowser` call inside `spec/cucumber/steps/index.js`,
    pass in the browser name from `process.env` instead of hard-coding it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历我们的浏览器列表，`export`它到`TEST_BROWSER`变量中，并运行我们的测试。然后，在`spec/cucumber/steps/index.js`中的`forBrowser`调用中，传递来自`process.env`的浏览器名称而不是硬编码它：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, try running it with `$ yarn run test:e2e -- chrome firefox`, and you should
    see our tests being run first on Chrome, and then Firefox, and then the results
    neatly displayed in a standard output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用`$ yarn run test:e2e -- chrome firefox`运行它，你应该看到我们的测试首先在Chrome上运行，然后是Firefox，然后结果整洁地显示在标准输出中：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lastly, we should define NPM scripts to make it obvious to other developers
    what operations we can run. By adding it as an NPM script, all the user needs
    to do is look at the `package.json`, and won''t have to study the shell script
    to see how it works. So, in the `scripts` section of the `package.json`, change
    our `test:e2e` to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该定义NPM脚本来让其他开发者清楚地知道我们可以运行的操作。通过将其添加为NPM脚本，用户只需要查看`package.json`，而不必研究shell脚本以了解它是如何工作的。因此，在`package.json`的`scripts`部分，将我们的`test:e2e`更改为以下内容：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have now successfully written our first test and run it. Next, let''s make
    our scenario more generic by covering all the invalid cases:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功编写并运行了我们的第一个测试。接下来，让我们通过涵盖所有无效情况来使我们的场景更加通用：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running our backend API
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的后端API
- en: Next, we need to cater for the happy path scenario where a user fills in valid
    details and the Register button is clicked.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理一个快乐的路径场景，其中用户填写了有效详细信息并点击了注册按钮。
- en: Here, we will write a test that says "When a user submits valid details, after
    the server response is received, the UI will display a success message". This
    feature has not been implemented yet, which means this would be our first step
    toward TDD in frontend!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个测试，说明“当用户提交有效详细信息后，在收到服务器响应后，UI将显示成功消息”。这个功能尚未实现，这意味着这将是我们前端TDD的第一步！
- en: Dynamic string substitution with Webpack
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Webpack进行动态字符串替换
- en: There's one minor improvement we must make before we can do E2E testing with
    the API backend. At the moment, we are hard-coding the URL for our production
    API endpoint (`localhost:8080`), even though during the test, the testing URL
    (`localhost:8888`) will be used. Therefore, we need to replace this with a placeholder
    that we can override during build time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用API后端进行端到端测试之前，我们必须进行一项小的改进。目前，我们正在硬编码生产API端点的URL（`localhost:8080`），尽管在测试期间将使用测试URL（`localhost:8888`）。因此，我们需要用一个占位符来替换它，我们可以在构建时覆盖这个占位符。
- en: 'First, in `src/components/registration-form/index.jsx`, replace the following
    line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`src/components/registration-form/index.jsx`中，替换以下行：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With this one:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using `%%` to mark our placeholder because it's a relatively uncommon
    sequence of characters. You may choose any placeholder syntax you like.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`%%`来标记我们的占位符，因为它是一个相对不常见的字符序列。你可以选择任何你喜欢的占位符语法。
- en: 'Next, we need to add a new loader to replace this placeholder at build time.
    `string-replace-loader` fits the bill perfectly. Let''s install it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个新的加载器来在构建时替换此占位符。`string-replace-loader` 完美地符合要求。让我们安装它：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, in `.env` and `.env.example`, add the details of the API host and port
    for different environment:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `.env` 和 `.env.example` 中添加不同环境的 API 主机和端口的详细信息：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, use the plugin inside `webpack.config.js`. We want the loader to transform
    all `.js` and `.jsx` files, and so we can use the same rules that we used for
    `babel-loader`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `webpack.config.js` 中使用插件。我们希望加载器转换所有 `.js` 和 `.jsx` 文件，因此我们可以使用与 `babel-loader`
    相同的规则：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At the top, we are checking the `NODE_ENV` environment variable and using it
    to determine which port the API is using. Then, in the options for our loader,
    we are instructing it to do a global RegEx search for the string, and replacing
    it with the dynamically-derived host and port.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们正在检查 `NODE_ENV` 环境变量，并使用它来确定 API 正在使用哪个端口。然后，在我们的加载器选项中，我们指示它对字符串进行全局正则表达式搜索，并将其替换为动态生成的宿主和端口。
- en: Serving the API from a submodule
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从子模块中提供 API 服务
- en: 'When we run our tests, we want to make sure that our backend API is running
    using the `NODE_ENV` environment variable set to `test`. At the moment, we are
    doing this manually. However, it''s more ideal to add it as part of our test script.
    Just as we did for our Swagger UI, we can use Git submodules to include the Hobnob
    API repository in the client''s repository without duplicating the code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们想确保我们的后端 API 正在使用设置为 `test` 的 `NODE_ENV` 环境变量运行。目前，我们正在手动执行此操作。然而，将其作为测试脚本的一部分添加更为理想。就像我们为
    Swagger UI 所做的那样，我们可以使用 Git 子模块将 Hobnob API 仓库包含在客户端仓库中，而不重复代码：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, to make life easier for later, add the following NPM scripts to `package.json`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了简化后续操作，将以下 NPM 脚本添加到 `package.json` 中：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`api:init` will download the Hobnob API repository using the commit hash that''s
    been stored. `api:install` uses `--cwd` to change directory into the `api` directory
    before running `yarn install`. `api:serve` first runs the `build` script from
    our API repository, loads the environment variables, and then runs the API server.
    `api:update` will download but also update the API repository to the latest commit
    in the same branch.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`api:init` 将使用存储的提交哈希下载 Hobnob API 仓库。`api:install` 使用 `--cwd` 在运行 `yarn install`
    之前更改目录到 `api` 目录。`api:serve` 首先运行我们的 API 仓库中的 `build` 脚本，加载环境变量，然后运行 API 服务器。`api:update`
    将下载并更新 API 仓库到同一分支的最新提交。'
- en: 'Lastly, run the NPM scripts inside `scripts/e2e.test.sh`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `scripts/e2e.test.sh` 中运行 NPM 脚本：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Defining the happy scenario
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义愉快的场景
- en: 'Let''s begin defining our happy scenario by writing the feature file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写功能文件来开始定义我们的愉快场景：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Generating random data
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成随机数据
- en: 'In this scenario, we cannot hard-code a single email to test because it may
    lead to a `409 Conflict` error because an account with that email already exists.
    Therefore, we need to generate a random email each time the test is run. We need
    to define a new step definition where the data is randomly generated each time:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们不能硬编码一个单独的电子邮件来测试，因为这可能导致一个 `409 冲突` 错误，因为已经存在具有该电子邮件的账户。因此，每次运行测试时，我们需要生成一个随机电子邮件。我们需要定义一个新的步骤定义，其中数据每次都是随机生成的：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we create a generic step definition and use the yet-to-be-defined `generateSampleData`
    function to provide the random data. We will define the `generateSampleData` function
    in a new file at `spec/cucumber/steps/utils/index.js` and, just as we did for
    in our backend tests, use the `chance` package to generate the random data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个通用的步骤定义，并使用尚未定义的 `generateSampleData` 函数来提供随机数据。我们将在 `spec/cucumber/steps/utils/index.js`
    的新文件中定义 `generateSampleData` 函数，就像我们在后端测试中所做的那样，使用 `chance` 包来生成随机数据。
- en: 'First, install the `chance` package:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装 `chance` 包：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And then define `generateSampleData` as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式定义 `generateSampleData`：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Making step definitions more generic
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使步骤定义更通用
- en: 'This scenario checks the `disabled` attribute as before, but this time testing
    that it is *not* set. Therefore, update our step definition at `spec/cucumber/steps/assertions/index.js`
    to take this into account:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此场景检查 `disabled` 属性，就像之前一样，但这次测试它没有被设置。因此，更新我们的步骤定义在 `spec/cucumber/steps/assertions/index.js`
    中，以考虑这一点：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Clicking
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击
- en: 'The final two step sees the WebDriver clicking on the Register button and waiting
    for the server to respond. For the click step, we just need to find the `WebElement`
    instance and invoke its `click` method. Define the following step definition at
    `spec/cucumber/steps/interactions/element.js`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个步骤是 WebDriver 点击注册按钮并等待服务器响应。对于点击步骤，我们只需要找到 `WebElement` 实例并调用它的 `click`
    方法。在 `spec/cucumber/steps/interactions/element.js` 中定义以下步骤定义：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Waiting
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待
- en: The last step requires us to wait for the API server to respond to our request,
    after which we should display a success message.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步需要我们等待 API 服务器对我们的请求做出响应，之后我们应该显示一个成功消息。
- en: 'A naive, but very common, approach would be to wait a few seconds before making
    an assertion. However, this has two disadvantages:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单但非常常见的方法是在进行断言之前等待几秒钟。然而，这有两个缺点：
- en: If the time set is too short, it can lead to flaky tests where the tests would
    pass on some instances, and fail on others.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设置的时间太短，可能会导致测试不稳定，即在某些实例上通过，在其他实例上失败。
- en: If the time set is too long, it'll lengthen the test duration. In practice,
    lengthy tests means the tests are ran less often, and less useful in providing
    feedback to the developer.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设置的时间太长，它会延长测试持续时间。在实践中，长时间的测试意味着测试运行得较少，对开发者提供反馈的作用也较小。
- en: 'Luckily, Selenium provides the `driver.wait` method, which has the following
    signature:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Selenium 提供了 `driver.wait` 方法，它具有以下签名：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`condition` can be a `Condition` instance, a function, or a promise-like thenable.
    `driver.wait` will repeatedly evaluate the value of `condition` until it returns
    a truthy value. If `condition` is a promise, it will wait until the promise is
    resolved and check the resolved value to see if it is truthy. `timeout` is the
    time (in milliseconds) for which `driver.wait` will keep trying.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition` 可以是一个 `Condition` 实例、一个函数或一个类似承诺的 thenable。`driver.wait` 将重复评估
    `condition` 的值，直到它返回一个真值。如果 `condition` 是一个承诺，它将等待承诺解决并检查解决值是否为真。`timeout` 是 `driver.wait`
    将尝试的时间（以毫秒为单位）。'
- en: 'In `spec/cucumber/steps/assertions/index.js`, add the following step definition:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `spec/cucumber/steps/assertions/index.js` 中，添加以下步骤定义：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We are using `until.elementLocated` as the condition, which will resolve to
    a truthy value if the element is located. We are also using `chai` and `chai-as-promised`
    as our assertion library (instead of `assert`); they provide us with the `expect` and
    `.to.be.fulfilled` syntax which makes tests involving promises much more readable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `until.elementLocated` 作为条件，如果元素被定位，它将解析为真值。我们还使用 `chai` 和 `chai-as-promised`
    作为我们的断言库（而不是 `assert`）；它们为我们提供了 `expect` 和 `.to.be.fulfilled` 语法，这使得涉及承诺的测试更加易于阅读。
- en: 'Run the tests, and the last step should fail. This is because we haven''t implemented
    the `#registration-success` element yet:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，最后一步应该失败。这是因为我们还没有实现 `#registration-success` 元素：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Render components based on state
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据状态渲染组件
- en: 'To be able to display the `#registration-success` element at the opportune
    time, we must store the results of our request in our state. Currently, inside
    our `RegistrationForm` component, we are only logging the results onto the console:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在合适的时间显示 `#registration-success` 元素，我们必须将我们请求的结果存储在我们的状态中。目前，在我们的 `RegistrationForm`
    组件中，我们只是在控制台记录结果：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Instead, when the server responds with the new user''s ID, we store it inside
    the state under the `userId` property:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当服务器响应新用户的 ID 时，我们将它存储在状态下的 `userId` 属性中：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, make sure that you are setting the initial state of the `userId` to `null`
    in the class'' constructor:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保你在类的构造函数中将 `userId` 的初始状态设置为 `null`：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, in our `render` method, check whether the `userId` state is truthy, and
    if so, display an element with an ID of `registration-success` instead of the
    form:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的 `render` 方法中，检查 `userId` 状态是否为真，如果是，则显示一个 ID 为 `registration-success`
    的元素，而不是表单：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Run our tests again, and they should, once again, pass!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的测试，它们应该再次通过！
- en: Routing with React Router
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Router 进行路由
- en: 'Next, we will develop the Login page. This requires us to use a different path
    for each page. For instance, the Register page can be served under the path `/register`,
    and the Login page under the `/login` path. For this, we need a *router*. On the
    server, we use Express to route the request hitting our API; for the frontend,
    we need a client-side router to do the same. In the React ecosystem, the most
    mature router is *React Router*. Let''s install it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开发登录页面。这需要我们为每个页面使用不同的路径。例如，注册页面可以在 `/register` 路径下提供服务，而登录页面在 `/login`
    路径下。为此，我们需要一个**路由器**。在服务器上，我们使用 Express 来路由击中我们的 API 的请求；对于前端，我们需要一个客户端路由器来完成同样的工作。在
    React 生态系统中，最成熟的路由器是 *React Router*。让我们安装它：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`react-router` provides the core functionality, and `react-router-dom` allows
    us to use the React Router on the web. It''s similar to how React on the web is
    split into `react` and `react-dom`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router` 提供核心功能，而 `react-router-dom` 允许我们在网页上使用 React Router。这类似于 React
    在网页上被分为 `react` 和 `react-dom`。'
- en: Basics
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: As explained previously, everything in React is a component. React Router is
    no different. React Router provides a set of *navigational components* that'll
    collect data from the URL, viewport, and device information, in order to display
    the appropriate component.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，React 中的所有内容都是组件。React Router 也不例外。React Router 提供了一套**导航组件**，这些组件将从 URL、视口和设备信息中收集数据，以便显示适当的组件。
- en: 'There are three types of components in React Router:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 中有三种类型的组件：
- en: Router components
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由组件
- en: Route matching components
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由匹配组件
- en: Navigation components
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航组件
- en: Router
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器
- en: A router component is a wrapper around our application. The router component
    is responsible for keeping a history of the routes, so that you can "Go back"
    to the previous screen. There are two router components – `<BrowserRouter>` and
    `<HashRouter>`. `<HashRouter>` is purely used for serving static files; therefore,
    we'll use the `<BrowserRouter>` component.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 路由组件是我们应用的包装器。路由组件负责保持路由的历史记录，以便你可以“返回”到上一个屏幕。有两个路由组件 —— `<BrowserRouter>` 和
    `<HashRouter>`。`<HashRouter>` 仅用于服务静态文件；因此，我们将使用 `<BrowserRouter>` 组件。
- en: 'In `src/index.jsx`, wrap our root component (currently `<RegistrationForm />`)
    with our `BrowserRouter` component:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/index.jsx` 中，用我们的 `BrowserRouter` 组件包裹我们的根组件（目前是 `<RegistrationForm />`）：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Route matching
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由匹配
- en: 'At the moment, if you serve the application, nothing would have changed – we''ve
    simply wrapped our app in `BrowserRouter` so that *inside* `<BrowserRouter>` we
    can define *route matching* components. Let''s suppose we want the `<RegistrationForm>`
    component to only render when the route is `/register`, we can use a `<Route>`
    component:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你提供应用程序，没有什么变化——我们只是将我们的应用包裹在 `BrowserRouter` 中，这样我们就可以在 `<BrowserRouter>`
    内定义**路由匹配**组件。假设我们只想在路由是 `/register` 时渲染 `<RegistrationForm>` 组件，我们可以使用一个 `<Route>`
    组件：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `<Route>` component usually uses two props – `path` and `component`. If
    a `<Route>` component has a `path` prop that matches the current URL's path name
    (such as `window.location.pathname`), the component specified in the `component
    prop` will be rendered.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Route>` 组件通常使用两个属性 —— `path` 和 `component`。如果一个 `<Route>` 组件有一个 `path` 属性与当前
    URL 的路径名匹配（例如 `window.location.pathname`），则 `component` 属性中指定的组件将被渲染。'
- en: Matching is done in an *inclusive* fashion. For instance, the pathnames `/register/user`,
    `/register/admin`, and `register` will all match the path `/register`. However,
    for our use case, we want this element to show only if the path matches exactly,
    and so we are using the `exact` prop.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是以**包含**的方式进行的。例如，路径名 `/register/user`、`/register/admin` 和 `register` 都会匹配路径
    `/register`。然而，对于我们的用例，我们希望此元素仅在路径完全匹配时显示，因此我们使用了 `exact` 属性。
- en: After making the change, let's serve the application again.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更改后，让我们再次提供应用程序。
- en: Supporting the History API
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持历史 API
- en: 'But when we go to `http://localhost:8200/register`, we get a `404 Not Found`
    response. From the terminal, we can see that this is because the request is handled
    by `http-server`, and not by our application:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们访问 `http://localhost:8200/register` 时，我们得到一个 `404 Not Found` 响应。从终端中，我们可以看到这是因为请求由
    `http-server` 处理，而不是我们的应用程序：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This makes sense because `http-server` is a very simple *static* server, whereas
    we want our routing done *dynamically* on the client. Therefore, we need to a
    use a server that supports this. `pushstate-server` is a static server that also
    works with HTML5 History API. Let''s install it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意义的，因为 `http-server` 是一个非常简单的 *静态* 服务器，而我们需要在客户端 *动态* 执行路由。因此，我们需要使用支持此功能的服务器。`pushstate-server`
    是一个静态服务器，它也支持 HTML5 历史API。让我们安装它：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, in `scripts/serve.sh`, replace the `http-server` line with the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `scripts/serve.sh` 中，将 `http-server` 行替换为以下内容：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When we run `yarn run serve` and navigate to `localhost:8200/register`, everything
    works as expected!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `yarn run serve` 并导航到 `localhost:8200/register` 时，一切如预期工作！
- en: 'Lastly, update our Cucumber test feature file so that the test navigates to
    the correct page:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新我们的 Cucumber 测试功能文件，以便测试导航到正确的页面：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Navigation
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航
- en: 'The last important component classes provided by React Router are the navigational
    components, of which there are three types:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 提供的最后重要的组件类是导航组件，共有三种类型：
- en: '`<Link>`: This will render an anchor (`<a>`) component, for example, `<Link
    to=''/''>Home</Link>`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Link>`：这将渲染一个锚点 (`<a>`) 组件，例如，`<Link to=''/''>Home</Link>`'
- en: '`<NavLink>`: This is a special type of `<Link>` that will add a class to the
    element if the pathname matches the `to` prop, for example, `<NavLink to=''/profile''
    activeClassName=''active''>Profile</NavLink>`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<NavLink>`：这是一种特殊的 `<Link>` 类型，如果路径名与 `to` 属性匹配，它将向元素添加一个类，例如，`<NavLink to=''/profile''
    activeClassName=''active''>Profile</NavLink>`'
- en: '`<Redirect>`: This is a component that will navigate to the `to` prop, for
    example, `<Redirect to=''/login''/>`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Redirect>`：这是一个将导航到 `to` 属性的组件，例如，`<Redirect to=''/login''/>`'
- en: 'Therefore, we can update our `#registration-success` element to include links
    to the Home and Login page (which we haven''t implemented yet!):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以更新我们的 `#registration-success` 元素，以包含指向主页和登录页面的链接（我们尚未实现！）：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: TDD
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD
- en: When we developed the Register page, we implemented the features before writing
    the test. We did this because we didn't know how E2E tests work with React. Now
    that we do, it's time to implement a proper TDD process.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发注册页面时，我们在编写测试之前实现了功能。我们这样做是因为我们不知道 E2E 测试在 React 中是如何工作的。现在我们知道了，是时候实施一个合适的
    TDD 流程了。
- en: To implement TDD, we should look at the design of the UI, identify key elements
    that our tests would need interact with, and assign each of them an unique `id`.
    These ids then form the contract between our tests and the implementation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 TDD，我们应该查看 UI 的设计，确定测试需要与之交互的关键元素，并为每个元素分配一个唯一的 `id`。这些 `id` 然后形成我们测试和实现之间的契约。
- en: For instance, if we developed our Registration Page using TDD, we would first
    assign the inputs to the IDs `#email`, `#password`, and `#register-button`, and
    write our test code using these IDs to select the element. Then, when we implement
    the feature, we will make sure to use the same IDs as specified in the test.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用 TDD 开发了注册页面，我们首先将输入分配给 `#email`、`#password` 和 `#register-button` 这些
    ID，并使用这些 ID 编写测试代码来选择元素。然后，当我们实现功能时，我们将确保使用测试中指定的相同 ID。
- en: By using an `id` field, we can change the implementation details but leave the
    tests untouched. Imagine if we used a different selector, say, `form > input[name="email"]`;
    then, if we add an inner wrapper within the `<form>` element, we'd have to update
    our tests.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `id` 字段，我们可以更改实现细节，但保持测试不变。想象一下，如果我们使用了不同的选择器，比如说，`form > input[name="email"]`；那么，如果我们向
    `<form>` 元素内添加一个内部包装器，我们就必须更新我们的测试。
- en: Design and frontend is one of the most volatile endeavors in the software development
    stage; it's wise to write tests that can withstand this volatility. It's not uncommon
    for a project to change frameworks completely. Let's say in a few years time,
    another frontend framework came along and totally revolutionizes the frontend
    landscape. By using ids to select elements, we can switch our implementation to
    this new framework without having to rewrite our tests.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和前端是软件开发阶段中最具波动性的任务之一；编写能够承受这种波动性的测试是明智的。一个项目完全更换框架并不罕见。比如说，在几年后，另一个前端框架出现并彻底改变了前端格局。通过使用
    `id` 来选择元素，我们可以在不重写测试的情况下切换到这个新框架。
- en: Login
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: We will follow a TDD process when developing the Login page.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发登录页面时，我们将遵循 TDD 流程。
- en: Writing tests
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: This means starting with composing the Cucumber features file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着从编写 Cucumber 功能文件开始。
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This introduces several new steps. The `When a random user is registered` step
    directly calls the API to register a user. We will use this user to test our login
    step. It is implemented inside a new module called `spec/cucumber/steps/auth/index.js`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了几个新的步骤。`当随机用户注册` 步骤直接调用 API 来注册用户。我们将使用此用户来测试我们的登录步骤。它实现在一个名为 `spec/cucumber/steps/auth/index.js`
    的新模块中：
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We are using the `generateSampleData` utility function we defined earlier to
    generate details for a new user. We are also storing these details within the
    context. Next, we use the Fetch API to send a Create User request to the API.
    However, the Fetch API is an API native to the browser. Therefore, in order to
    use the Fetch API in Node, we must install a polyfill, `node-fetch`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用我们之前定义的 `generateSampleData` 工具函数来生成新用户的详细信息。我们也将这些详细信息存储在上下文中。接下来，我们使用
    Fetch API 向 API 发送创建用户请求。然而，Fetch API 是浏览器原生的 API。因此，为了在 Node 中使用 Fetch API，我们必须安装一个
    polyfill，`node-fetch`：
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Then, for the steps `And user types in his/her email in the "#email" element`
    and `And user types in his/her password in the "#password" element`, we are using
    the details stored in the context to fill out the Login form and submit it. If
    the request is successful, an element with an ID of `login-success` is expected
    to appear.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于步骤 `用户在 "#email" 元素中输入他的/她的电子邮件` 和 `用户在 "#password" 元素中输入他的/她的密码`，我们正在使用上下文中存储的详细信息来填写登录表单并提交它。如果请求成功，预期将出现一个
    ID 为 `login-success` 的元素。
- en: If you forget the endpoint and parameters for any of the endpoints for the API,
    just refer to the Swagger Documentation, which you can serve by running `yarn
    run docs:serve`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了任何 API 端点和参数，只需参考 Swagger 文档，你可以通过运行 `yarn run docs:serve` 来提供该文档。
- en: Implementing Login
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现登录
- en: 'Implementing the Login form is similar to the Register form, however, it involves
    two steps instead of one. The client must first retrieve the salt from the API,
    use it to hash the password, and then send a second request to the API to log
    in. Your implementation may look like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实现登录表单与注册表单类似，但是它涉及两个步骤而不是一个。客户端必须首先从 API 中检索盐，使用它来散列密码，然后向 API 发送第二个请求以登录。你的实现可能看起来像这样：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that we have the form component ready, let''s add it to the router. In
    React Router versions prior to v4, you can simply add a new `<Route>` component
    to `<BrowserRouter>`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了表单组件，让我们将其添加到路由器中。在 React Router 版本 v4 之前，你只需将一个新的 `<Route>` 组件添加到 `<BrowserRouter>`：
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: However, with React Router v4, Router components can only have one child component.
    Therefore, we must encase the `<Route>` components inside a container.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着 React Router v4 的推出，路由组件只能有一个子组件。因此，我们必须将 `<Route>` 组件包裹在一个容器中。
- en: 'The `react-router-dom` package provides a `<Switch>` component, which we will
    use as our container. The `<Switch>` component will render only the component
    specified in the *first* matching `<Route>`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router-dom` 包提供了 `<Switch>` 组件，我们将将其用作容器。`<Switch>` 组件将只渲染第一个匹配的 `<Route>`
    中指定的组件：'
- en: '[PRE62]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding example, if we navigate to `/register`, the `<Switch>` component
    will see that there's a match in the first `<Route>` component, and will stop
    looking for any more matches and return `<RegistrationForm>`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果我们导航到 `/register`，`<Switch>` 组件将看到第一个 `<Route>` 组件中有一个匹配项，并将停止寻找更多匹配项并返回
    `<RegistrationForm>`。
- en: Over to you
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在轮到你了
- en: We have already gone over how to write E2E tests in a previous chapter, and
    we have demonstrated how to apply TDD for our Register and Login pages.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中介绍了如何编写端到端测试，并演示了如何为注册和登录页面应用 TDD。
- en: Now, we pass the baton to you so that you can improve on what we've done so
    that it conforms to the design, as well as complete the rest of the app in a TDD
    manner.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将接力棒传给你，以便你可以改进我们所做的，使其符合设计，并以 TDD 的方式完成应用程序的其余部分。
- en: You don't need to focus on making things look pretty – that's not the focus
    here. Just make sure that all of the components are there and that the user flow
    is correct.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要专注于使事物看起来很漂亮——这并不是这里的重点。只需确保所有组件都在那里，并且用户流程是正确的。
- en: After you've done this, take a look at our implementation and use it to improve
    yours. Then, we'll take a look at unit tests and other types of testing that can
    be applied to front-end code.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，查看我们的实现并使用它来改进你的实现。然后，我们将查看单元测试以及其他可以应用于前端代码的测试类型。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have carried over what we did for our back-end API to the
    front-end code. We used Cucumber, Gherkin and Selenium to compose UI tests that
    runs directly on a real browser. We also implemented client-side routing using
    React Router.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为后端API所做的工作应用到前端代码中。我们使用了Cucumber、Gherkin和Selenium来编写直接在真实浏览器上运行的UI测试。我们还使用了React
    Router实现了客户端路由。
- en: In the next chapter, we will round off our excursion into the front-end world
    by learning about **Redux**, a powerful state management library.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习**Redux**，一个强大的状态管理库，来结束我们对前端世界的探索之旅。
