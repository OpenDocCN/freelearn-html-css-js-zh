- en: Chapter 3. Working with Vector Layers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章.处理矢量图层
- en: 'In this chapter we cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Adding a GML layer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加GML图层
- en: Adding KML layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加KML图层
- en: Creating features programmatically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式创建特征
- en: Reading and creating features from a WKT
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从WKT读取和创建特征
- en: Adding markers to the map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上添加标记
- en: Using point features as markers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点特征作为标记
- en: Working with popups
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理弹出窗口
- en: Adding features from a WFS server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从WFS服务器添加特征
- en: Using the cluster strategy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用聚类策略
- en: Filtering features in WFS requests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WFS请求中过滤特征
- en: Reading features directly using Protocols
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接使用协议读取特征
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter talks about vector layers. In addition to raster, vector information
    is the other important type of information we can work with in a GIS system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论矢量图层。除了栅格信息外，矢量信息是我们在GIS系统中可以处理的其他重要信息类型。
- en: The chapter tries to summarize the most common and important recipes you may
    need to work with in OpenLayers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章试图总结您在OpenLayers中可能需要使用的一些最常见和重要的菜谱。
- en: In GIS, a real-world phenomenon is represented by the concept of a feature.
    It can be a place—like a city or a village—it can be a road or a railway, it can
    be a region, a lake, the border of a country, or something similar.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在GIS中，现实世界现象通过特征的概念来表示。它可以是一个地点——比如一个城市或村庄——它可以是道路或铁路，它可以是地区、湖泊、国家的边界或类似的东西。
- en: 'Every feature has a set of attributes: population, length, and so on. It is
    represented visually by a geometrical symbol: point, line, polygon, and so on,
    using some visual style: color, radius, width, and so on.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特征都有一组属性：人口、长度等等。它通过几何符号进行视觉表示：点、线、多边形等等，使用一些视觉风格：颜色、半径、宽度等等。
- en: As you can see, there are many concepts to take into account when working with
    vector information. Fortunately, OpenLayers provides us classes to work with them.
    We will learn more about these in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在处理矢量信息时需要考虑许多概念。幸运的是，OpenLayers为我们提供了处理它们的类。我们将在本章中了解更多关于这些类的内容。
- en: The base class for vector layers is `OpenLayers.Layer.Vector` class, which defines
    the common properties and behavior for all the subclasses.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量图层的基础类是`OpenLayers.Layer.Vector`类，它定义了所有子类的公共属性和行为。
- en: The `OpenLayers.Layer.Vector` class contains a set of features. These features
    are instances of the `OpenLayers.Feature.Vector` subclasses (which, in fact, are
    inherited from a more generic `OpenLayers.Feature` class).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Layer.Vector`类包含一组特征。这些特征是`OpenLayers.Feature.Vector`子类的实例（实际上，它们是从更通用的`OpenLayers.Feature`类继承而来的）。'
- en: Each feature has an `attributes` property and an `OpenLayers.Geometry` class
    instance associated with it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特征都有一个`attributes`属性和一个与它关联的`OpenLayers.Geometry`类实例。
- en: The vector layer itself or each feature can have a visual style associated with
    it, which will be used to render the feature on the map.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量图层本身或每个特征都可以关联一个与之相关的视觉风格，该风格将用于在地图上渲染特征。
- en: 'In addition to the representation on the screen, we need to take into account
    the data source. OpenLayers offers classes to read/write features from/to many
    sources, or protocols, and using different formats: GML, KML, GeoJSON, GeoRSS,
    and so on.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了屏幕上的表示外，我们还需要考虑数据源。OpenLayers提供类来从/向许多来源或协议读取/写入特征，并使用不同的格式：GML、KML、GeoJSON、GeoRSS等等。
- en: 'The vector layer has optionally associated an instance of the `OpenLayers.Protocol`
    class and a list of instances of the `OpenLayers.Strategy` class. The first is
    responsible to read/write data using some protocol, such as HTTP or WFS, while
    the second (the strategy) is responsible to control tasks such as when to load
    or refresh the data in the layer: only once, every time the layer is moved, every
    few seconds, and so on.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量图层可以可选地关联一个`OpenLayers.Protocol`类的实例和一个`OpenLayers.Strategy`类实例的列表。第一个负责使用某些协议（如HTTP或WFS）读取/写入数据，而第二个（策略）负责控制诸如何时加载或刷新图层中的数据等任务：只加载一次，每次图层移动时，每隔几秒等等。
- en: Let's get started and see these classes in action.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，看看这些类是如何工作的。
- en: Adding a GML layer
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加GML图层
- en: The **Geography Markup Language (GML)** is an XML grammar used to express geographic
    features. It is an OGC standard and is very well accepted by the GIS community.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**地理标记语言（GML）**是一种用于表达地理特征的XML语法。它是一个OGC标准，并且被GIS社区广泛接受。'
- en: '![Adding a GML layer](img/7843_03_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![添加GML图层](img/7843_03_01.jpg)'
- en: In this recipe, we will show you how to create a vector layer from a GML file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将向您展示如何从GML文件创建矢量图层。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the necessary files in the GML format attached to the source code
    of this book on the Packt Publishing website.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Packt Publishing 网站上找到此书的源代码中附加的 GML 格式文件。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create an HTML file with the required OpenLayers dependencies and insert the
    following code. First add the `div` element to hold the map:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所需 OpenLayers 依赖项的 HTML 文件，并插入以下代码。首先添加 `div` 元素来容纳地图：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, add the JavaScript code to initialize the map, add a base layer, and
    a layer switcher control:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加初始化地图、添加基本层和图层切换控件所需的 JavaScript 代码：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, add a vector layer with the GML data:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个带有 GML 数据的矢量层：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before using the `OpenLayers.Layer.Vector` class, we need to take some aspects
    into consideration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `OpenLayers.Layer.Vector` 类之前，我们需要考虑一些方面。
- en: If we need to load data from some source then we need to set a protocol and
    a strategy. In this case, we have used a fixed strategy, through the `OpenLayers.Strategy.Fixed`
    class instance, which means the data content is loaded only once. It is never
    refreshed or loaded again.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要从某个来源加载数据，那么我们需要设置一个协议和策略。在这种情况下，我们使用了一个固定的策略，通过 `OpenLayers.Strategy.Fixed`
    类实例，这意味着数据内容只加载一次。它永远不会刷新或再次加载。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The data to be loaded is accessible via the HTTP protocol and a URL to the file.
    The protocol, as an instance of the `OpenLayers.Protocol.HTTP` class, is responsible
    to read the data from the specified resource and requires a URL and a format to
    know how to read the data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载的数据可以通过 HTTP 协议和一个指向文件的 URL 访问。该协议作为 `OpenLayers.Protocol.HTTP` 类的一个实例，负责从指定的资源读取数据，并需要一个
    URL 和一个格式来了解如何读取数据。
- en: OpenLayers offers many format classes to read/write data, but in this recipe
    we have made use of an `OpenLayer.Format.GML` instance because our data source
    is a GML file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers 提供了许多格式类来读取/写入数据，但在这个菜谱中，我们使用了 `OpenLayer.Format.GML` 实例，因为我们的数据源是一个
    GML 文件。
- en: See also
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding a KML layer* recipe
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加 KML 层** 菜谱'
- en: The *Creating features programmatically* recipe
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序化创建要素** 菜谱'
- en: Adding a KML layer
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 KML 层
- en: The arrival of Google Maps leads to an explosion in the world of GIS and web
    mapping. Google introduced not only an API but also some file formats.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps 的到来导致 GIS 和网络制图领域的爆炸式增长。Google 不仅引入了一个 API，还引入了一些文件格式。
- en: The **Keyhole Markup Language (KML)** had become one of the most extensively
    used formats, and finally it became an OGC standard.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键孔标记语言 (KML**) 已成为最广泛使用的格式之一，最终它成为了一个 OGC 标准。'
- en: '![Adding a KML layer](img/7843_03_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![添加 KML 层](img/7843_03_02.jpg)'
- en: This recipe will show you how easy it is to add features from a KML file. You
    can find the necessary files in the KML format attached to the source code of
    this book available on the Packt Publishing website.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向您展示如何轻松地从 KML 文件中添加要素。您可以在 Packt Publishing 网站上找到此书源代码中附加的 KML 格式文件。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create an HTML file including the OpenLayers library and insert the following
    code in it. First, add the `DOM` element that will hold the map:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 OpenLayers 库的 HTML 文件，并在其中插入以下代码。首先，添加将容纳地图的 `DOM` 元素：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, initialize a map instance, add a base layer, add a layer switcher control,
    and center the view:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，初始化地图实例，添加基本层，添加图层切换控件，并居中视图：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, add a vector layer that will load data from a KML file:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个将加载数据从 KML 文件中的矢量层：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After initializing the map, we centered the view and added some controls. Then
    we added a vector layer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化地图后，我们居中视图并添加了一些控件。然后我们添加了一个矢量层。
- en: Because we want to load data from a KML file, that is accessible via HTTP protocol,
    we have set an `OpenLayers.Protocol.HTTP` instance as the protocol of the vector
    layer. It uses the URL of the file and uses an `OpenLayers.Format.KML` instance
    as the `format` property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想从 KML 文件加载数据，该文件可以通过 HTTP 协议访问，所以我们设置了一个 `OpenLayers.Protocol.HTTP` 实例作为矢量层的协议。它使用文件的
    URL，并使用 `OpenLayers.Format.KML` 实例作为 `format` 属性。
- en: In addition, we have set an `OpenLayers.Strategy.Fixed` instance as the strategy
    of the vector layer, which makes the file load only once.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将 `OpenLayers.Strategy.Fixed` 实例设置为矢量层的策略，这使得文件只加载一次。
- en: In addition, we have used a couple of `OpenLayers.Format.KML` classes, `extractStyles`
    and `extractAttributes`, to maintain the color styles and attributes specified
    in the source KML file. Otherwise, OpenLayers will apply a default style.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还使用了几个 `OpenLayers.Format.KML` 类，`extractStyles` 和 `extractAttributes`，以保持源
    KML 文件中指定的颜色样式和属性。否则，OpenLayers 将应用默认样式。
- en: There's more...
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: The KML format, like GML, offers tons of options and possibilities at the cost
    of complexity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: KML格式，就像GML一样，提供了大量的选项和可能性，但代价是复杂性。
- en: In the KML format, placemarks can have a description attached to them and, if
    you load a KML file in Google Maps, the placemark's description is shown as a
    balloon (or popup) when you click on them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在KML格式中，地标可以附加描述，如果你在谷歌地图中加载KML文件，当你点击它们时，地标描述会以气球（或弹出窗口）的形式显示。
- en: In OpenLayers, this approach differs a bit. As we will see in the *Working with
    popups* recipe, the process to load the KML data and the behavior to show them
    are completely different. So don't expect the vector layer that loads the data
    to also attach the required code to control the click event, show the popup, and
    so on. That is our work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenLayers中，这种方法略有不同。正如我们将在*使用弹出窗口*食谱中看到的那样，加载KML数据和显示它们的行为完全不同。因此，不要期望加载数据的矢量层也会附加控制点击事件、显示弹出窗口等所需的代码。这是我们的工作。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding a GML layer* recipe
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加GML层*食谱'
- en: The *Creating features programmatically* recipe
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建特征的方法*食谱'
- en: The *Working with popups* recipe
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用弹出窗口*食谱'
- en: Creating features programmatically
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建特征的方法
- en: Loading data from an external source is not the only way to work with vector
    layers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部源加载数据不是唯一与矢量层一起工作的方式。
- en: 'Imagine a web mapping application where the user can create new features on
    the fly: cities, rivers, areas of interest, and so on, and add them to a vector
    layer with some style. This scenario requires the ability to create and add the
    features programmatically.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个网络地图应用程序，用户可以实时创建新特征：城市、河流、感兴趣区域等，并将它们以某种样式添加到矢量层中。这种场景需要能够以编程方式创建和添加特征的能力。
- en: In this recipe we will see some ways to create and manage features programmatically.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将看到一些创建和管理特征的方法。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Start by creating a new HTML file with the required OpenLayers dependencies.
    Add the `div` element to hold the map:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的HTML文件，并添加所需的OpenLayers依赖项。添加`div`元素以容纳地图：
- en: '[PRE7]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, initialize the map instance and add a base layer:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，初始化地图实例并添加一个基本层：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, create three vector layers to put three different types of features:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建三个矢量层以放置三种不同类型的特征：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the function that will create the point, line, and polygon features and
    add them to each of the previous layers:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用创建点、线和多边形特征并将其添加到每个先前层的函数：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As described in the chapter's introduction, a vector layer contains a set of
    features. Each feature represents some phenomenon of the real world and has a
    geometry and a style associated with it, which will determine the visual representation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，矢量层包含一组特征。每个特征代表现实世界中的某种现象，并与其关联一个几何形状和样式，这将决定其视觉表示。
- en: 'Let''s start looking at the code responsible for creating random points:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看负责创建随机点的代码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, each feature is represented by a point geometry, because we first
    need to create an `OpenLayers.Geometry.Point` instance with the coordinates of
    the point.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个特征由一个点几何形状表示，因为我们首先需要创建一个带有点坐标的`OpenLayers.Geometry.Point`实例。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to express the coordinates in the appropriate projection, the one used
    by the map, or set the right projection in the vector layer so that OpenLayers
    can translate the coordinates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要以地图使用的适当投影表达坐标，或者在矢量层中设置正确的投影，以便OpenLayers可以转换坐标。
- en: Once we have the geometry instance, we can create a new `OpenLayers.Feature.Vector`
    instance by passing the desired geometry instance to be used by the feature.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了几何实例，我们可以通过传递要由特征使用的所需几何实例来创建一个新的`OpenLayers.Feature.Vector`实例。
- en: Note that we will cover working with feature styles in another chapter. It will
    be rendered with a default OpenLayers style.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将在另一章中介绍如何使用特征样式。它将以默认的OpenLayers样式进行渲染。
- en: All the features are stored in an array and passed at once to the vector layer
    using the `addFeatures()` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有特征都存储在一个数组中，并使用`addFeatures()`方法一次性传递给矢量层。
- en: Next in the difficulty order is the creation of lines, named in the geometry
    objects terminology as LineStrings. When you want to represent a feature as a
    LineString you need to use an instance of the geometry class `OpenLayers.Geometry.LineString`.
    As we can see in the following block of code, the line string constructor needs
    an array of the `OpenLayers.Geometry.Point` instance that conforms the set of
    points for the lines.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在难度顺序中，接下来是创建线，在几何对象术语中被称为LineStrings。当你想要将一个特征表示为LineString时，你需要使用几何类`OpenLayers.Geometry.LineString`的一个实例。正如我们可以在下面的代码块中看到的那样，线字符串构造函数需要一个`OpenLayers.Geometry.Point`实例的数组，该数组符合构成线的点集。
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The OGC's Simple Feature Access specification ([http://www.opengeospatial.org/standards/sfa](http://www.opengeospatial.org/standards/sfa))
    contains an in-depth description of the standard. It also contains an UML class
    diagram where you can see all the geometry classes and hierarchy.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: OGC的简单特征访问规范([http://www.opengeospatial.org/standards/sfa](http://www.opengeospatial.org/standards/sfa))包含了对标准的深入描述。它还包含一个UML类图，其中你可以看到所有几何类和层次结构。
- en: Finally, we found the code that creates some polygons.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们找到了创建一些多边形的代码。
- en: Polygons are great geometries to represent states or countries. We can think
    of polygons as a simple set of lines where the start and end point is the same,
    a so called *LineRing*, and filled with some color. But be aware, polygons can
    be very complex structures that complicate the way we must express them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形是表示州或国家等区域的优秀几何形状。我们可以将多边形视为一组简单的线，其中起点和终点相同，称为*LineRing*，并用某种颜色填充。但请注意，多边形可以是非常复杂的结构，这可能会使我们必须表达它们的方式变得复杂。
- en: For example, think of a region with a hole in it. In this case we have two line
    rings to describe the external and internal perimeters. We must also specify which
    part must be colored.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个内部有空洞的区域。在这种情况下，我们有两个线环来描述外部和内部周界。我们还必须指定哪些部分必须着色。
- en: 'Take a look at the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we create an `OpenLayers.Geometry.LineRing` instance by passing an array
    of `OpenLayers.Geometry.Point` with the set of points that conforms the line ring.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过传递一个`OpenLayers.Geometry.Point`的数组，其中包含构成线环的点集，创建了一个`OpenLayers.Geometry.LineRing`实例。
- en: Once we have one or more line rings, we can create a new instance of the `OpenLayers.Geometry.Polygon`
    class, which will be used to render our new vector layer feature.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个或多个线环，我们可以创建`OpenLayers.Geometry.Polygon`类的新实例，该实例将用于渲染我们新的矢量层特征。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding marker to the map* recipe
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向地图添加标记*菜谱'
- en: The *Reading and creating features from WKT* recipe
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从WKT读取和创建特征*菜谱'
- en: The *Working with popups* recipe
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用弹出窗口工作*菜谱'
- en: The *Styling features using symbolizers* recipe in [Chapter 7](ch07.html "Chapter 7. Styling
    Features"), *Styling Features*
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。使用符号化样式特征")中的*使用符号化样式特征*菜谱'
- en: Reading and creating features from a WKT
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从WKT读取和创建特征
- en: OpenLayers comes with a great set of format classes, which are used to read/write
    from/to different file data formats. GeoJSON, GML, or GPX are some of the many
    formats we can find.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers附带了一套优秀的格式类，用于从/向不同的文件数据格式读写。GeoJSON、GML或GPX是我们能找到的许多格式中的一些。
- en: If you have read the *Adding a GML layer* recipe in this chapter, you will know
    that a vector class can read the features stored in a file, specify the format
    of the data source, and place the contained features in the map.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了本章中的*添加GML层*菜谱，你就会知道矢量类可以读取存储在文件中的特征，指定数据源的格式，并将包含的特征放置在地图上。
- en: This recipe wants to show us exactly that. We will see the magic step responsible
    to read data from a file using a format class, and transform it to the corresponding
    feature ready to be placed in the layer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱想要展示的就是这一点。我们将看到负责从文件中读取数据并使用格式类将其转换为对应特征的神奇步骤。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity, we will only see how to read features from the WKT text. You
    can learn more about WKT (Well-Known Text) format from [http://en.wikipedia.org/wiki/Well-known_text](http://en.wikipedia.org/wiki/Well-known_text).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们只看看如何从WKT文本中读取特征。你可以从[http://en.wikipedia.org/wiki/Well-known_text](http://en.wikipedia.org/wiki/Well-known_text)了解更多关于WKT（Well-Known
    Text）格式的信息。
- en: As can be seen in the previous screenshot, we are going to create a map on the
    left side, and on the right we will place a couple of text area components to
    add and get features in the WKT format.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们将在左侧创建一个地图，在右侧我们将放置一些文本区域组件来添加和获取WKT格式的特征。
- en: '![Reading and creating features from a WKT](img/7843_03_09.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![从 WKT 读取和创建特征](img/7843_03_09.jpg)'
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new HTML file with OpenLayers dependencies. Then, add the following
    HTML code for the map, text area, and buttons:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 HTML 文件，并添加 OpenLayers 依赖项。然后，为地图、文本区域和按钮添加以下 HTML 代码：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, we are using Dojo toolkit framework ([http://dojotoolkit.org](http://dojotoolkit.org))
    to improve our components, so some elements will have attributes like `dojoType="dijit.form.Button"`.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，我们正在使用 Dojo 工具包框架（[http://dojotoolkit.org](http://dojotoolkit.org)）来改进我们的组件，因此一些元素将具有如
    `dojoType="dijit.form.Button"` 这样的属性。
- en: 'Now, we will initialize the map component and place a base layer:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将初始化地图组件并放置一个基本图层：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s go on to create a vector layer to hold the features we will read from
    the WKT:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建一个矢量层来保存我们将从 WKT 中读取的特征：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need a couple of functions to handle the button events. The first function
    is responsible to clean the vector layer:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要几个函数来处理按钮事件。第一个函数负责清理矢量层：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second function reads the data from the WKT string and places the features
    on the vector layer:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个函数读取 WKT 字符串中的数据，并将特征放置在矢量层上：
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the format classes are inherited from the `OpenLayers.Format` base class,
    which defines the basic behavior of the format classes, that is, have a `read`
    and a `write` method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有格式类都继承自 `OpenLayers.Format` 基类，该基类定义了格式类的基行为，即具有 `read` 和 `write` 方法。
- en: The `read()` method is supposed to read data in some format (a JSON string,
    a WKT string, and so on) and return an array of features as instances of the `OpenLayers.Feature.Vector`
    class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()` 方法应该以某种格式（JSON 字符串、WKT 字符串等）读取数据，并返回一个特征数组，作为 `OpenLayers.Feature.Vector`
    类的实例。'
- en: The `write()` method, on the other hand, receives an array of features and returns
    a string that represents the desired format.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`write()` 方法接收一个特征数组，并返回一个表示所需格式的字符串。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on the format subclass, the `read` and `write` methods can accept
    additional parameters. Always be careful and read the API documentation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 根据格式子类的不同，`read` 和 `write` 方法可以接受额外的参数。始终要小心，并阅读 API 文档。
- en: 'To read the features from a WKT string, we only need to instantiate the desired
    format class and call its `read` method by passing a valid string as the argument:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 WKT 字符串中读取特征，我们只需要实例化所需的格式类，并通过传递一个有效的字符串作为参数来调用其 `read` 方法：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we get the current features of the vector layer and convert them to a
    WKT representation by passing them to the `write` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取矢量层的当前特征，并通过将它们传递给 `write` 方法将它们转换为 WKT 表示：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding a GML layer* recipe
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加 GML 层的配方*'
- en: The *Creating features programmatically* recipe
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过编程创建特征*的配方'
- en: The *Reading features directly using Protocols* recipe
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直接使用协议读取特征*的配方'
- en: Adding markers to the map
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将标记添加到地图
- en: Markers are widely used in web mapping applications. They allow us to quickly
    identify points of interest (POI) by showing an icon at the desired place.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 标记在网络地图应用中被广泛使用。它们允许我们通过在期望的位置显示一个图标来快速识别兴趣点（POI）。
- en: This recipe shows how to add markers to our maps by using the `OpenLayers.Marker`
    and `OpenLayers.Layer.Markers` classes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何使用 `OpenLayers.Marker` 和 `OpenLayers.Layer.Markers` 类将标记添加到我们的地图中。
- en: '![Adding markers to the map](img/7843_03_03.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![将标记添加到地图](img/7843_03_03.jpg)'
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Start by creating an HTML page with dependencies on the OpenLayers library.
    Add the `div` element that will hold the map:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个依赖于 OpenLayers 库的 HTML 页面。添加将包含地图的 `div` 元素：
- en: '[PRE21]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, add a new kind of layer, `OpenLayers.Layer.Markers`, specially designed
    to contain the `OpenLayers.Marker` instances:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个新的图层类型，`OpenLayers.Layer.Markers`，专门设计用来包含 `OpenLayers.Marker` 实例：
- en: '[PRE22]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will now create markers at random places by using a random icon from an
    array:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将通过使用数组中的一个随机图标在随机位置创建标记：
- en: '[PRE23]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The class `OpenLayers.Layer.Markers` is a direct subclass of the `OpenLayers.Layer`
    base class, and is specially designed to contain markers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Layer.Markers` 类是 `OpenLayers.Layer` 基类的一个直接子类，并且专门设计用来包含标记。'
- en: On the other hand, a marker is represented by instances of the class `OpenLayers.
    Layer.Markers`. Every marker has an associated point, expressed with an instance
    of the `OpenLayers.LonLat` class, and an icon using an instance of `OpenLayers.Icon`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，标记由 `OpenLayers.Layer.Markers` 类的实例表示。每个标记都有一个关联的点，用 `OpenLayers.LonLat`
    类的实例表示，以及使用 `OpenLayers.Icon` 类的实例表示的图标。
- en: An icon requires a *URL* of the image to be loaded, a *size* expressed as an
    instance of `OpenLayers.Size`, and an *offset* expressed as an instance of `OpenLayers.Pixel`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图标需要一个要加载的图像的 *URL*，一个表示为 `OpenLayers.Size` 实例的 *大小*，以及一个表示为 `OpenLayers.Pixel`
    实例的 *偏移量*。
- en: In addition, for each marker we have registered two listeners, one to know when
    the mouse is over and one to know when it leaves the marker. In this way, we can
    modify the size and opacity of the marker to highlight when the mouse has selected
    or deselected it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于每个已注册的标记，我们有两个监听器，一个用于知道鼠标何时悬停在标记上，另一个用于知道鼠标何时离开标记。这样，我们就可以修改标记的大小和透明度，以突出显示鼠标何时选中或取消选中它。
- en: 'Inside the handler functions, we have made use of the methods `inflate()`,
    to change the size of the icon augmenting its proportions, and `setOpacity()`,
    to change the icon opacity:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理函数内部，我们使用了 `inflate()` 方法，以改变图标的尺寸，增加其比例，以及 `setOpacity()` 方法，以改变图标的透明度：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For beginners in JavaScript, remember the object that calls the anonymous function
    that handles the marker event is the marker itself. Because the `this` keyword
    is referencing the marker with which we can call the `inflate()` or `setOpacity()`
    methods.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript初学者，请记住调用处理标记事件的匿名函数的对象是标记本身。因为 `this` 关键字引用的是标记，我们可以调用 `inflate()`
    或 `setOpacity()` 方法。
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The use of markers through the `OpenLayers.Marker` and `OpenLayers.Layer.Markers`
    classes is not the only way we can show POIs in our maps.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `OpenLayers.Marker` 和 `OpenLayers.Layer.Markers` 类使用标记并不是我们展示地图中POI的唯一方式。
- en: As you can see in the *Using point features as markers* recipe, we can also
    use features to show POIs as an alternative that can be improved by the use of
    strategies, formats, and so on.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 *使用点特征作为标记* 配方中所看到的，我们还可以使用特征来显示POI，这是一个可以通过使用策略、格式等改进的替代方案。
- en: In addition, OpenLayers offers some classes, such as `OpenLayers.Layer.GeoRSS`
    or `OpenLayers.Layer.Text`, that create markers automatically from the GeoRSS
    and CSV files respectively. They are relatively simple and are implemented for
    a specific usage and, most probably, you will soon need more flexibility than
    offered by those classes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，OpenLayers提供了一些类，如 `OpenLayers.Layer.GeoRSS` 或 `OpenLayers.Layer.Text`，它们可以自动从GeoRSS和CSV文件中创建标记。它们相对简单，是为了特定的用途实现的，而且，你很快就会需要比这些类提供的更多灵活性。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using point features as markers* recipe
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用点特征作为标记* 的配方'
- en: The *Creating features programmatically* recipe
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过编程创建特征* 的配方'
- en: The *Reading features directly using Protocol* recipe
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直接使用协议读取特征* 的配方'
- en: Using point features as markers
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用点特征作为标记
- en: Displaying markers is not only limited to using the `OpenLayers.Marker` and
    `OpenLayers.Layer.Markers` classes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 显示标记不仅限于使用 `OpenLayers.Marker` 和 `OpenLayers.Layer.Markers` 类。
- en: 'A marker can be understood as a point of interest (POI) where we place an icon
    to identify it and has some information associated with it: a monument, a parking
    area, a bridge, and so on.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 标记可以理解为兴趣点（POI），我们在其中放置一个图标来识别它，并与之关联一些信息：一座纪念碑、一个停车场、一座桥梁等。
- en: In this recipe, we will learn how to use these features with a point geometry
    type associated to create markers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用这些特征与一个与点几何类型关联的创建标记。
- en: '![Using point features as markers](img/7843_03_04.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![使用点特征作为标记](img/7843_03_04.jpg)'
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once you have created the right HTML file with OpenLayers dependencies, add
    a `div` element to hold the map:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你创建了包含OpenLayers依赖项的正确HTML文件，添加一个 `div` 元素来包含地图：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Start initializing the map instance and add a base layer and control:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始初始化地图实例并添加一个基本层和控制：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, add a vector layer that will contain a set of random markers:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个矢量层，它将包含一组随机标记：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create some random points. To improve the performance we add all the points
    to an array and then to the vector layer all at once with the `addFeatures` method:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些随机点。为了提高性能，我们将所有点添加到一个数组中，然后一次性使用 `addFeatures` 方法将它们添加到矢量层中：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, attach two event listeners to the vector layer for the `featureselected`
    and `featureunselected` events. The listener will be responsible for changing
    the feature style:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将两个事件监听器附加到矢量层上，用于 `featureselected` 和 `featureunselected` 事件。监听器将负责更改特征样式：
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we need to attach a `SelectFeature` control to the map, and reference
    the vector layer:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将一个 `SelectFeature` 控制器附加到地图上，并引用矢量层：
- en: '[PRE30]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The idea is simple, add point features to the layer and listen for their selection
    event to change the style.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单，向层中添加点要素并监听它们的选取事件以更改样式。
- en: 'In a different way than working with the `OpenLayers.Marker` instances, we
    need to attach listeners to the vector layer and not to the feature itself, using
    the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`OpenLayers.Marker`实例的方式不同，我们需要使用以下代码将监听器附加到矢量层而不是要素本身：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Within the listener function, we can access the selected feature or the vector
    layer it belongs to with the `event` variable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在监听器函数中，我们可以通过`event`变量访问选定的要素或它所属的矢量层：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Chapter 7](ch07.html "Chapter 7. Styling Features"), *Styling Features*,
    we will learn more about styling features and improving its look using images,
    in a similar way to the `OpenLayers.Marker` class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。要素样式")，*要素样式*中，我们将学习更多关于要素样式以及如何使用图像改进其外观，类似于`OpenLayers.Marker`类。
- en: 'Once the feature style is changed, we can call `drawFeature()` on the vector
    layer to refresh the feature on the map:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦要素样式更改，我们就可以在矢量层上调用`drawFeature()`来刷新地图上的要素：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To allow the vector layer to trigger events, we need to attach a `SelectFeature`
    control to the map, reference the vector layer, and activate it. Without it the
    listeners will never be invoked.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许矢量层触发事件，我们需要将一个`SelectFeature`控件附加到地图上，引用矢量层，并激活它。没有它，监听器永远不会被调用。
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See also
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating features programmatically* recipe
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*程序化创建要素*配方'
- en: The *Adding markers to the map* recipe
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向地图添加标记*配方'
- en: The *Working with popups* recipe
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理弹出窗口*配方'
- en: The *Using the cluster strategy* recipe
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用集群策略*配方'
- en: Working with popups
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理弹出窗口
- en: A common charecteristic of web mapping applications is the ability to show information
    related to the features the map contains. By feature we mean any real phenomenon
    or aspect we can visually represent with points, lines, polygons, and so on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 网络地图应用的一个共同特征是能够显示与地图包含的要素相关的信息。要素意味着任何我们可以用点、线、多边形等视觉表示的真实现象或方面。
- en: Of course we can select a feature, retrieve its associated information and show
    it anywhere in our application layout, but the most common way to show it is by
    using popups.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以选择一个要素，检索其关联信息并在我们的应用程序布局中的任何位置显示它，但最常见的方式是通过弹出窗口显示。
- en: '![Working with popups](img/7843_03_05.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![处理弹出窗口](img/7843_03_05.jpg)'
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create an HTML file with OpenLayers dependencies. Then add the `div` element
    to hold the map:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含OpenLayers依赖项的HTML文件。然后添加`div`元素以容纳地图：
- en: '[PRE35]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Within the JavaScript section, initialize the map and add a base layer:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript部分，初始化地图并添加一个基本图层：
- en: '[PRE36]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a vector layer and add some features to it:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个矢量层并向其中添加一些要素：
- en: '[PRE37]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, add some random features to the vector layer:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向矢量层添加一些随机要素：
- en: '[PRE38]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You need to change the previous URL to the right address of your custom server.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要将之前的URL更改为您自定义服务器的正确地址。
- en: 'Finally, add the code responsible to manage the feature selection to show the
    popup:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加负责管理要素选取以显示弹出窗口的代码：
- en: '[PRE39]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing we did, after creating the vector layer, was the creation of
    some random point features.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建矢量层之后，我们首先创建了一些随机的点要素。
- en: Because we are computing random latitude and longitude values in decimal degrees
    ("EPSG:4326" projection), we need to translate it to the projection used by the
    map. In this case, because `OpenStreetMap` is the base layer, it applies an`"EPSG:900913"`
    projection as the map's projection.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在计算十进制度数的随机纬度和经度值（"EPSG:4326"投影），我们需要将其转换为地图使用的投影。在这种情况下，因为`OpenStreetMap`是基本图层，它使用`"EPSG:900913"`投影作为地图的投影。
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here we are creating features with a custom style. The constructor of the `OpenLayers.Feature.Vector`
    class accepts three parameters: a *geometry* parameter, which is mandatory, and
    two optional parameters, the feature *attributes* and the feature *style*.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建具有自定义样式的要素。`OpenLayers.Feature.Vector`类的构造函数接受三个参数：一个必需的*几何*参数，以及两个可选参数，要素的*属性*和要素的*样式*。
- en: Our features have no special attributes so we have passed a `null` value but,
    on the other hand, we have used a custom style to show an icon image instead of
    a simple point to represent them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的特征没有特殊属性，所以我们传递了一个`null`值，但另一方面，我们使用自定义样式来显示图标图像，而不是简单的点来表示它们。
- en: Once we have the features we want, it is time to show a popup with some nice
    description when a feature is selected.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了想要的特征，就在特征被选择时显示一个带有一些美好描述的弹出窗口。
- en: 'To achieve this, we have used the `SelectFeature` control. Given a layer, this
    control allows the user to select features. We can customize the behavior of the
    control with the `options` argument:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用了`SelectFeature`控件。给定一个图层，此控件允许用户选择特征。我们可以使用`options`参数自定义控件的行为：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this recipe we have used the following three options:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了以下三个选项：
- en: '`hover:` It indicates that the features must be selected or unselected without
    the need of clicking on it, and by simply moving the mouse over the button.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hover:` 它表示无需点击即可选择或取消选择特征，只需将鼠标移到按钮上即可。'
- en: '`onSelect:` This function is executed when a feature is selected. It receives
    the selected feature as an argument.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSelect:` 当特征被选择时执行此函数。它接收选择的特征作为参数。'
- en: '`onUnselect:` This function is executed when a feature is unselected. It receives
    the unselected feature as an argument.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUnselect:` 当特征被取消选择时执行此函数。它接收取消选择的特征作为参数。'
- en: Now let's take a look at how to create the popups.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建弹出窗口。
- en: The important point to be noted here is that popups are added to the map. They
    are not added to a feature and nor to a layer. So to show or hide a popup, we
    simply need to add or remove it from the map with the methods `addPopup()` or
    `removePopup()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要一点是，弹出窗口被添加到地图中。它们不是添加到特征或图层中。因此，要显示或隐藏弹出窗口，我们只需使用`addPopup()`或`removePopup()`方法将其添加或从地图中移除。
- en: OpenLayers offers some classes to be used as popups, but all of them are inherited
    from the base class `OpenLayers.Popup`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers提供了一些用作弹出窗口的类，但它们都继承自基本类`OpenLayers.Popup`。
- en: 'We have chosen the `OpenLayers.Popup.FramedCloud` subclass, which is a visually
    decent styled popup. The constructor requires the following parameters:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了`OpenLayers.Popup.FramedCloud`子类，这是一个视觉上相当不错的样式弹出窗口。构造函数需要以下参数：
- en: '`id:` A string that identifies the popup among all the popups that can exist,
    which are attached to the map'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id:` 一个字符串，用于在所有可以附加到地图的弹出窗口中标识弹出窗口'
- en: '`lonlat:` The location where the popup must appear'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lonlat:` 弹出窗口必须出现的位置'
- en: '`contentSize:` The dimensions of the popup, as an instance of the `OpenLayers.Size`
    class'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contentSize:` 弹出窗口的尺寸，作为`OpenLayers.Size`类的实例'
- en: '`contentHTML:` The HTML string to be put as content'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contentHTML:` 要作为内容放入的HTML字符串'
- en: '`anchor:` An object where the popup will be anchored'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor:` 弹出窗口将被锚定的对象'
- en: '`closeBox:` Boolean indicating if the close buttons must be shown'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeBox:` 布尔值，指示是否必须显示关闭按钮'
- en: '`closeBoxCallback:` A function that will be executed when the user clicks on
    the close button'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeBoxCallback:` 当用户点击关闭按钮时将被执行的功能'
- en: 'With all these parameters, our code to create a `FramedCloud` popup looks as
    follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有这些参数，我们创建`FramedCloud`弹出窗口的代码如下：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once created, we add it to the map, which makes it visible automatically:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，我们将其添加到地图中，使其自动可见：
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We have also stored a reference of the popup within the feature. In this way,
    we can easily find a reference to the popup in the function that is executed when
    the feature is unselected and remove it from the map:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在特征中存储了弹出窗口的引用。这样，我们可以在特征被取消选择时执行的功能中轻松找到弹出窗口的引用并将其从地图中移除：
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a note, the map's `addPopup()` method has a second and optional parameter
    `exclusive`, which if set, automatically removes all existing popups in the map
    when a new one is added.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 作为备注，地图的`addPopup()`方法有一个第二个可选参数`exclusive`，如果设置，则在添加新弹出窗口时自动从地图中移除所有现有弹出窗口。
- en: See also
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding markers to the map* recipe
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向地图添加标记**的菜谱'
- en: The *Using point features as markers* recipe
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用点特征作为标记**的菜谱'
- en: Adding features from a WFS server
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从WFS服务器添加特征
- en: The **Web Feature Service (WFS)** is an OGC standard, which provides independent
    platform calls to request geographical features to a server. In practice, it means
    a client makes a HTTP request to a server that implements the WFS standard and
    gets a set of features in the GML (Geographic Markup Language, [http://en.wikipedia.org/wiki/Geography_Markup_Language)](http://en.wikipedia.org/wiki/Geography_Markup_Language))
    format.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web特征服务（WFS）**是一个OGC标准，它提供独立平台调用，向服务器请求地理特征。在实践中，这意味着客户端向实现WFS标准的服务器发出HTTP请求，并获取一组GML（地理标记语言，[http://en.wikipedia.org/wiki/Geography_Markup_Language](http://en.wikipedia.org/wiki/Geography_Markup_Language)）格式的特征。'
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A nice introduction to WFS can be found in the tutorial about WFS available
    at [https://www.e-education.psu.edu/geog585/book/export/html/1724](http://https://www.e-education.psu.edu/geog585/book/export/html/1724).
    If you want to learn more about this, there is a complete specification on the
    OGC site [http://www.opengeospatial.org/standards/wfs](http://www.opengeospatial.org/standards/wfs).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在关于 WFS 的教程中找到对 WFS 的良好介绍，该教程可在 [https://www.e-education.psu.edu/geog585/book/export/html/1724](http://https://www.e-education.psu.edu/geog585/book/export/html/1724)
    找到。如果你想了解更多关于这个话题的信息，可以在 OGC 网站上找到完整的规范 [http://www.opengeospatial.org/standards/wfs](http://www.opengeospatial.org/standards/wfs).
- en: From the OpenLayers point of view, the WFS is nothing more than another data
    source we can read to fill a vector layer.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenLayers 的角度来看，WFS 仅仅是我们可以读取以填充矢量图层的数据源之一。
- en: Before continuing, there is an important point to take into account. Most of
    the requests made by OpenLayers when data is loaded, say GML, KML, or GeoRSS files,
    are made asynchronously through the helper class `OpenLayers.Request`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有一个重要的要点需要考虑。OpenLayers 在加载数据时（例如 GML、KML 或 GeoRSS 文件）做出的大多数请求都是通过辅助类
    `OpenLayers.Request` 以异步方式进行的。
- en: Any JavaScript call is limited by the security model imposed by the browser,
    which avoids cross domain requests. This means you can only make requests to the
    same server that the web page originally came from.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 JavaScript 调用都受到浏览器强加的安全模型限制，这避免了跨域请求。这意味着你只能向网页最初来自的服务器发出请求。
- en: There are different ways to avoid this fact, but a simple one is the use of
    a proxy on the server side.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以避免这一点，但一个简单的方法是在服务器端使用代理。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read a clearer explanation at
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中阅读更清晰的解释
- en: '[http://developer.yahoo.com/javascript/howto-proxy.html](http://developer.yahoo.com/javascript/howto-proxy.html).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.yahoo.com/javascript/howto-proxy.html](http://developer.yahoo.com/javascript/howto-proxy.html).'
- en: The idea of a proxy is simple, instead of making a request directly to a cross
    domain we make a request to a script on the same domain, which is responsible
    for making the cross domain request and returning the results.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的想法很简单，我们不是直接向跨域请求，而是向同一域上的一个脚本发出请求，该脚本负责进行跨域请求并返回结果。
- en: A script, say PHP, Python, or Java servlet, is not limited by the cross domain
    requests. It is only security imposed by the browser in the JavaScript calls.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一个脚本，比如 PHP、Python 或 Java servlet，不受跨域请求的限制。它只受浏览器在 JavaScript 调用中的安全限制。
- en: OpenLayers offers a proxy implementation as a Python script that we can use
    in our application. It can be found in the `examples/proxy.cgi` file in the source
    code bundle.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers 提供了一个作为 Python 脚本的代理实现，我们可以在我们的应用程序中使用它。它可以在源代码包中的 `examples/proxy.cgi`
    文件中找到。
- en: It is not the only possibility. For this recipe we will be using a PHP proxy
    file (see the `utils/proxy.php` file in the book's source code) from the `MapBuilder`
    project.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是唯一的选择。在这个食谱中，我们将使用来自 `MapBuilder` 项目的 PHP 代理文件（请参阅书中源代码中的 `utils/proxy.php`
    文件）。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a HTML file, set the OpenLayers dependencies, and add a `div` element
    to hold the map:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 HTML 文件，设置 OpenLayers 依赖项，并添加一个 `div` 元素来容纳地图：
- en: '[PRE45]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Set the `OpenLayers.ProxyHost` variable to our proxy URL:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OpenLayers.ProxyHost` 变量设置为我们的代理 URL：
- en: '[PRE46]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Initialize the map and add a base layer:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化地图并添加一个基本图层：
- en: '[PRE47]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, create a vector layer that uses the WFS protocol to access the data
    source:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个使用 WFS 协议访问数据源的矢量图层：
- en: '[PRE48]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first important step is to set the `OpenLayers.ProxyHost` variable:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重要步骤是设置 `OpenLayers.ProxyHost` 变量：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Most of the JavaScript requests in OpenLayers are made through the helper class
    `OpenLayers.Request`, which checks if the previous variable is set. If so, all
    requests are made using the proxy.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers 中的大多数 JavaScript 请求都是通过辅助类 `OpenLayers.Request` 进行的，该类会检查前一个变量是否已设置。如果是这样，所有请求都将通过代理进行。
- en: 'After that, the main action in this recipe is the creation of a vector layer
    filling its data from a WFS server:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个食谱中的主要操作是创建一个从 WFS 服务器填充数据的矢量图层：
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, the only thing to do is set the protocol to be used by the layer.
    In this case, we use an instance of the `OpenLayers.Protocol.WFS` class.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，唯一要做的就是设置图层要使用的协议。在这种情况下，我们使用 `OpenLayers.Protocol.WFS` 类的一个实例。
- en: 'The WFS protocol constructor has many parameters but the most important ones
    are as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: WFS 协议构造函数有很多参数，但最重要的如下：
- en: '`url:` The URL to the WFS server'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url:` WFS 服务器的 URL'
- en: '`featureType:` The feature to be queried'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`featureType:` 要查询的特征'
- en: '`featureNS:` The namespace of the feature'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`featureNS:` 特征的命名空间'
- en: 'Other important options and, more or less, the commonly used ones are as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 其他重要选项以及或多或少常用的选项如下：
- en: '`geometryName:` Specifies the name of the attribute that stores the feature''s
    geometry information. By default it is `the_geom`.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geometryName:` 指定存储特征几何信息的属性名称。默认为`the_geom`。'
- en: '`srsName:` The spatial reference system used in the requests. By default it
    is`"EPSG:4326".`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srsName:` 请求中使用的空间参考系统。默认为`"EPSG:4326"`。'
- en: Finally, the vector layer uses an `OpenLayers.Strategy.BBOX` strategy, which
    is responsible to refresh the content of the layer every time the map's viewport
    changes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，向量层使用一个`OpenLayers.Strategy.BBOX`策略，该策略负责在地图的视口每次更改时刷新图层的内容。
- en: There's more...
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: Many times the map server that supports WMS and WFS protocols, can serve the
    same information both in raster and vector formats.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，支持WMS和WFS协议的地图服务器，可以以栅格和向量格式同时提供相同的信息。
- en: Imagine a set of regions stored in PostgreSQL/PostGIS and a map server, such
    as GeoServer, with a layer of countries configured to be served both as raster
    images via WMS requests, or as vector GML format using WFS requests.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一组存储在PostgreSQL/PostGIS中的区域和地图服务器，例如GeoServer，其中配置了一个国家图层，既可以通过WMS请求作为栅格图像提供，也可以通过WFS请求作为向量GML格式提供。
- en: In these cases, if we have previously created an `OpenLayers.Layer.WMS` layer,
    there is an easy way to create a new WFS protocol instance with the static method
    `OpenLayers.Protocol.WFS.fromWMSLayer`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，如果我们之前创建了一个`OpenLayers.Layer.WMS`图层，有一个简单的方法可以创建一个新的WFS协议实例，即使用静态方法`OpenLayers.Protocol.WFS.fromWMSLayer`。
- en: Given a WMS layer and some options, the method initializes an `OpenLayers.Protocol.WFS`
    instance, supposing the WFS `url, srsName`, and other properties are the same
    as in the WMS instance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个WMS层和一些选项，该方法初始化一个`OpenLayers.Protocol.WFS`实例，假设WFS的`url`、`srsName`和其他属性与WMS实例相同。
- en: See also
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Filtering features in WFS requests* recipe
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WFS请求中过滤特征的方法
- en: The *Working with popups* recipe
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与弹出窗口一起工作的方法
- en: The *Using point features as markers* recipe
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点特征作为标记的方法
- en: The *Reading features directly using Protocols* recipe
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接使用协议读取特征的方法
- en: Using the cluster strategy
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用聚类策略
- en: As we have seen in the chapter's introduction, the behavior of vector layers
    is determined by the strategies we attach to them.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在章节引言中看到的，向量层的行为由我们附加给它们的策略决定。
- en: Imagine a scenario where we want to show all the museums in every city around
    the world. What will happen when the user navigates within the map and sets a
    zoom level to see the whole world? We simply see a cloud of points, all at the
    same place.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，我们想要展示世界上每个城市的所有博物馆。当用户在地图内导航并设置缩放级别以查看整个世界时会发生什么？我们简单地看到一个点云，所有点都在同一个地方。
- en: The solution to this problem is to cluster the features on each zoom level.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是聚类每个缩放级别的特征。
- en: '![Using the cluster strategy](img/7843_03_06.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![使用聚类策略](img/7843_03_06.jpg)'
- en: This recipe shows how easy it is to use the cluster strategy on a vector layer,
    which is responsible for clustering the features to avoid a situation similar
    to the one we just mentioned.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法展示了在向量层上使用聚类策略是多么简单，该策略负责将特征聚类以避免我们刚才提到的情况。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create an HTML file and insert the following code in it:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTML文件，并在其中插入以下代码：
- en: '[PRE51]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see the vector layer is using two strategies:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，向量层正在使用两种策略：
- en: '[PRE52]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A vector layer can have more than one strategy associated with it. In this
    recipe we have added the `OpenLayers.Strategy.Fixed` strategy, which loads the
    layer content only once, and the `OpenLayers.Strategy.Cluster` strategy, which
    automatically clusters the features to avoid an ugly cloud of features caused
    by overlapping:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一个向量层可以与多个策略相关联。在这个方法中，我们添加了`OpenLayers.Strategy.Fixed`策略，它只加载一次图层内容，以及`OpenLayers.Strategy.Cluster`策略，该策略自动聚类特征以避免由重叠引起的丑陋特征云：
- en: '[PRE53]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Every time we change the zoom level, the cluster strategy computes the distance
    among all features and adds all the features that conform to some parameters of
    the same cluster.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们更改缩放级别时，聚类策略都会计算所有特征之间的距离，并将符合同一聚类某些参数的所有特征添加到聚类中。
- en: 'The main parameters we can use to control the behavior of the cluster strategy
    are as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下主要参数来控制聚类策略的行为：
- en: '`distance:` The distance in pixels between features to be considered that they
    are in the same cluster. By default it is set to 20 pixels.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distance:` 被考虑在同一个簇中的特征之间的像素距离。默认设置为 20 像素。'
- en: '`threshold:` If the number of features in a cluster is less than the threshold,
    then they will be added directly to the layer instead of the cluster'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threshold:` 如果簇中的特征数量小于阈值，则它们将直接添加到图层而不是簇中'
- en: There's more...
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'OpenLayers has a set of basic but very common strategies that we can combine
    in vector layers:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers 提供了一套基本但非常常见的策略，我们可以将其组合到矢量图层中：
- en: The *Box* strategy, to request features every time the map's viewport changes
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*框* 策略，每次地图视口改变时请求特征'
- en: The *Refresh* strategy, to update the layer features periodically after some
    time
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*刷新* 策略，在一段时间后定期更新图层特征'
- en: The *Filter* strategy to limit the features the layer must request
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤* 策略以限制图层必须请求的特征'
- en: We encourage those more advanced JavaScript readers, to take a close look at
    the OpenLayers source code and learn more about how strategies work.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励那些更高级的 JavaScript 读者仔细查看 OpenLayers 源代码，并了解更多关于策略如何工作的信息。
- en: See also
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Creating features programmatically* recipe
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*以编程方式创建特征* 食谱'
- en: The *Adding features from a WFS server* recipe
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从 WFS 服务器添加特征* 食谱'
- en: Filtering features in WFS requests
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WFS 请求中的特征过滤
- en: A key concept when working against a WFS server is the concept of filters.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 与 WFS 服务器交互时的一个关键概念是过滤器的概念。
- en: Among many other specifications, the OGC has defined a standard that defines
    the notation to be used for filtering, the *Filter Encoding Specification*.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多其他规范中，OGC 定义了一个标准，该标准定义了用于过滤的符号表示法，即 *Filter Encoding Specification*。
- en: Filters are similar to the `WHERE` clause in SQL and allow us to select features
    that meet some conditions.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器类似于 SQL 中的 `WHERE` 子句，并允许我们选择满足某些条件的特征。
- en: Note
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the Filter Encoding Specification on the OGC website available
    at [http://www.opengeospatial.org/standards/filter](http://www.opengeospatial.org/standards/filter).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 OGC 网站上找到 Filter Encoding Specification，网址为 [http://www.opengeospatial.org/standards/filter](http://www.opengeospatial.org/standards/filter)。
- en: As we will see in [Chapter 7](ch07.html "Chapter 7. Styling Features"), *Styling
    Features*, filters are not only used to query features but are also used to define
    rules to style them.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 7 章](ch07.html "第 7 章。特征样式") 中将看到的，*特征样式*，过滤器不仅用于查询特征，还用于定义样式规则。
- en: 'OpenLayers offers a set of classes suited to work with the filters the specification
    defines: property filters `(PropertyIsEqualTo, PropertyIsLessThan`, and so on),
    logical filters, and spatial filters `(Intersects, Within`, and so on).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers 提供了一套适合与规范定义的过滤器一起工作的类：属性过滤器（`PropertyIsEqualTo`、`PropertyIsLessThan`
    等），逻辑过滤器和空间过滤器（`Intersects`、`Within` 等）。
- en: '![Filtering features in WFS requests](img/7843_03_07.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![WFS 请求中的特征过滤](img/7843_03_07.jpg)'
- en: This recipe shows a basic usage of the filter classes to restrict the features
    queried on a WFS server.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱展示了使用过滤器类的基本用法来限制在 WFS 服务器上查询的特征。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to query a remote WFS server, so we will require a proxy script
    that was configured in our own server to make the real WFS request.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查询一个远程 WFS 服务器，因此我们需要一个代理脚本，该脚本配置在我们的服务器上以执行真实的 WFS 请求。
- en: See the *Adding features from a WFS server* recipe in this chapter for more
    information about proxy scripts.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 有关代理脚本的信息，请参阅本章的 *从 WFS 服务器添加特征* 食谱。
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create an HTML file and insert the following code:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 HTML 文件并插入以下代码：
- en: '[PRE54]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The first step in the JavaScript code is to set the proxy script required to
    solve the cross domain request policy:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 代码中的第一步是设置解决跨域请求策略所需的代理脚本：
- en: '[PRE55]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Set OSM as the base layer:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 OSM 设置为底图：
- en: '[PRE56]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To center the map''s viewport in a concrete location we need to transform the
    desired location from latitude/longitude to the projection used by the base layer,
    that is, the projection used by the map:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将地图视口中心定位在具体位置，我们需要将所需位置从纬度/经度转换为底图使用的投影，即地图使用的投影：
- en: '[PRE57]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add a vector layer, which requests some states:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个矢量图层，它请求一些状态：
- en: '[PRE58]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main part of this recipe is the code involved in the instantiation of the
    vector layer. The constructor receives two parameters, the name and an options
    object. Within the options object we have set three properties:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的主要部分是涉及矢量图层实例化的代码。构造函数接收两个参数，名称和一个选项对象。在选项对象中，我们设置了三个属性：
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s take a look at the protocol, strategies, and filter used in the layer.
    We are querying a WFS server, so we need to use an `OpenLayers.Protocol.WFS` instance
    to talk to it:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看该层中使用的协议、策略和过滤器。我们正在查询一个WFS服务器，因此我们需要使用一个 `OpenLayers.Protocol.WFS` 实例来与之通信：
- en: '[PRE60]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the same way as WMS, the WFS server has the `GetCapabilities` action, which
    allows the client to know the capabilities it provides: kind of features, available
    operations, and so on.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 与WMS一样，WFS服务器有 `GetCapabilities` 动作，它允许客户端了解它提供的功能：特征的类型、可用的操作等等。
- en: 'Check the response obtained from the server used in the recipe: [http://demo.opengeo.org/geoserver/wfs?request=GetCapabilities](http://demo.opengeo.org/geoserver/wfs?request=GetCapabilities).'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 检查菜谱中使用的服务器返回的响应：[http://demo.opengeo.org/geoserver/wfs?request=GetCapabilities](http://demo.opengeo.org/geoserver/wfs?request=GetCapabilities)。
- en: 'As a strategy, we want the layer to refresh the features every time the map''s
    viewport is modified, so `OpenLayers.Strategy.BBOX` is the right instance:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 作为策略，我们希望层在地图视口每次修改时刷新功能，因此 `OpenLayers.Strategy.BBOX` 是正确的实例：
- en: '[PRE61]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, there is a `filter` property, which performs all the magic in this
    recipe. We have tried to use a more or less complete filter, which includes one
    logical filter, one comparison filter, and one spatial filter:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个 `filter` 属性，在这个菜谱中执行所有魔法。我们尝试使用一个或多或少完整的过滤器，它包括一个逻辑过滤器、一个比较过滤器和一个空间过滤器：
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Depending on the kind of filter, they can have different properties with different
    values allowed.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 根据过滤器的类型，它们可以有不同的属性和不同的允许值。
- en: Our filter queries for all states in the WFS server, on the specified layer,
    that are within the bounding box defined by `[-120, 10,-90,50]` and have a `MALE`
    population greater than `700,000`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过滤器查询WFS服务器中指定层内的所有状态，这些状态位于由 `[-120, 10,-90,50]` 定义的边界框内，并且 `MALE` 人口数量大于
    `700,000`。
- en: There's more...
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: The `OpenLayers.Protocol` class has a `defaultFilter` property, which allows
    us to set a default filter for the requests.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Protocol` 类有一个 `defaultFilter` 属性，它允许我们为请求设置默认过滤器。'
- en: The filters specified in the vector layer, will be the logical AND operator,
    which is merged before making the request.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量层中指定的过滤器将是逻辑 AND 运算符，它在发出请求之前合并。
- en: See also
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding features from a WFS server* recipe
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从WFS服务器添加功能* 菜单'
- en: The *Reading features directly using Potocols* recipe
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直接使用协议读取功能* 菜单'
- en: Reading features directly using Protocols
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接使用协议读取功能
- en: 'OpenLayers allows us to read data from different origins and sources. As we
    have described in the chapter''s introduction, OpenLayers offers the helper classes:
    protocols and formats.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers 允许我们从不同的来源和资源读取数据。正如我们在章节引言中所描述的，OpenLayers 提供了辅助类：协议和格式。
- en: 'Protocols are designed to simplify the task of retrieving data from different
    origins: via HTTP, from an WFS server, and so on.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 协议旨在简化从不同来源检索数据的任务：通过HTTP、从WFS服务器等。
- en: On the other hand, formats simplifies the task of reading from (or writing to)
    a given data format. It is very common to load data from different origins and
    know how to work directly with protocols that can incredibly simplify this task.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，格式简化了从（或写入）给定数据格式的任务。从不同来源加载数据并知道如何直接与可以极大地简化此任务的协议一起工作是非常常见的。
- en: '![Reading features directly using Protocols](img/7843_03_08.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![直接使用协议读取功能](img/7843_03_08.jpg)'
- en: As an example, this recipe shows how we can add features from different data
    sources in the same vector layer, by working directly with the protocol instances.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个菜谱展示了我们如何通过直接与协议实例工作，在同一个矢量层中添加来自不同数据源的功能。
- en: How to do it...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create an HTML file and add the OpenLayers dependencies. Then create a `DOM`
    element to hold the map:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTML文件并添加OpenLayers依赖项。然后创建一个 `DOM` 元素来保存地图：
- en: '[PRE63]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, initialize the map, add some base layer, and center the viewport:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，初始化地图，添加一些基本图层，并定位视口：
- en: '[PRE64]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, create a vector layer:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个矢量层：
- en: '[PRE65]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create two protocols pointing to the desired remote files:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个指向所需远程文件的协议：
- en: '[PRE66]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, add the callback function to be executed when the protocol instances
    load data from remote files:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加当协议实例从远程文件加载数据时要执行的回调函数：
- en: '[PRE67]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The goal of this recipe is to show how we can work directly with a protocol
    and load content from different data sources on the same vector layer.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的目标是展示我们如何直接与协议一起工作，并在同一个矢量层中从不同的数据源加载数据。
- en: 'Because of this we have created an empty vector layer, without specifying the
    protocol and strategy to use:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们创建了一个空的矢量层，没有指定要使用的协议和策略：
- en: '[PRE68]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'After that, we have created an `OpenLayers.Protocol.HTTP` instance that reads
    a remote `GeoJSON` file:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了一个 `OpenLayers.Protocol.HTTP` 实例，用于读取远程的 `GeoJSON` 文件：
- en: '[PRE69]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note how we can specify a callback function that will be called once the file
    is loaded and read it using the desired format. The function receives one parameter
    of type `OpenLayers.Protocol.Response`, which among others, contains a `features`
    array property with the set of features read from the file.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何指定一个回调函数，该函数将在文件加载并读取后调用，并使用所需的格式读取它。该函数接收一个类型为 `OpenLayers.Protocol.Response`
    的参数，其中包含一个 `features` 数组属性，其中包含从文件中读取的特征集。
- en: 'To make the protocol start the reading process we simply need to call:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要使协议开始读取过程，我们只需调用：
- en: '[PRE70]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Finally, let's take a look at the callback function. This function is called
    when both the protocols finish reading the data. We have implemented it to transform
    the features to the right projection and add to the vector layer only those of
    type `OpenLayers.Geometry.Point:`
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看回调函数。当两个协议都完成数据读取时，会调用此函数。我们已实现它以将特征转换为正确的投影，并将类型为 `OpenLayers.Geometry.Point:`
    的特征添加到矢量层中：
- en: '[PRE71]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As we can see, this is another way to filter the content we put in a vector
    layer, but take into account that the filtering is made on the client side and
    not on the server side. That means the entire data is transferred from the server
    to the client.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是在矢量层中过滤我们放入内容的另一种方式，但请注意，过滤是在客户端而不是在服务器端进行的。这意味着整个数据都是从服务器传输到客户端的。
- en: There's more...
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We would like to mention that in this recipe we do not set the `OpenLayers.ProxyHost`
    variable. This is because the files we are requesting via AJAX are in the same
    domain the HTML file is loaded from.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想提到的是，在这个配方中我们没有设置 `OpenLayers.ProxyHost` 变量。这是因为我们通过 AJAX 请求的文件与加载 HTML 文件的域相同。
- en: See also
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding a GML layer* recipe
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加 GML 层* 的配方'
- en: The *Adding features from a WFS server* recipe
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从 WFS 服务器添加特征* 的配方'
- en: The *Filtering features in WFS requests* recipe
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 WFS 请求中过滤特征* 的配方'
