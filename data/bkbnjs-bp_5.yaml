- en: Chapter 5. Building a Chat Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：构建聊天应用
- en: So far, all the applications that we've built have used plain old Backbone.
    This isn't to say that we haven't used helper libraries, but that we haven't yet
    used any libraries that extend Backbone itself. However, such libraries do exist;
    the Backbone GitHub wiki has a whole list of them ([https://github.com/jashkenas/backbone/wiki/Extensions%2C-Plugins%2C-Resources](https://github.com/jashkenas/backbone/wiki/Extensions%2C-Plugins%2C-Resources)).
    In this chapter, we'll use one of these libraries to make building this application
    a little simpler.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们构建的所有应用都使用了普通的 Backbone。这并不是说我们没有使用辅助库，而是我们还没有使用任何扩展 Backbone 自身的库。然而，这样的库确实存在；Backbone
    GitHub 维基上有一个完整的列表（[https://github.com/jashkenas/backbone/wiki/Extensions%2C-Plugins%2C-Resources](https://github.com/jashkenas/backbone/wiki/Extensions%2C-Plugins%2C-Resources)）。在本章中，我们将使用这些库之一来简化构建这个应用的过程。
- en: 'We''ll be focusing on the following ideas:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注以下想法：
- en: Using a third-party library to make large applications easier to handle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方库使大型应用更容易处理
- en: Doing real-time communication between the server and the client
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器和客户端之间进行实时通信
- en: Outlining the application
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述应用
- en: Before we get started, let's define exactly what it is we're going to build.
    It will be an online chat application; a user will go to the website, choose a
    screen name, choose a room, and chat with other members in the room. There won't
    be real user accounts; you join by simply giving a name, kind of like a simpler
    version of IRC. If someone else is using that name, you'll have to choose another.
    Users will also be able to create new rooms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们明确我们要构建的内容。它将是一个在线聊天应用；用户将访问网站，选择一个昵称，选择一个房间，然后与其他房间成员聊天。这里不会有真实的用户账户；你可以通过简单地提供一个名字加入，有点像更简单的
    IRC 版本。如果其他人正在使用那个名字，你必须选择另一个。用户还可以创建新的房间。
- en: 'We will be using a few new tools in this chapter: Socket.IO and Marionette.
    **Socket.IO** ([http://socket.io](http://socket.io)) is a real-time communication
    library that allows the client to talk to the server quickly and easily. Think
    of it as a publish and subscribe system (like Backbone''s `trigger` and `listenTo`
    methods) between the client and the server; you can read more about that design
    pattern on Wikipedia ([https://en.wikipedia.org/wiki/Publish_and_subscribe](https://en.wikipedia.org/wiki/Publish_and_subscribe)).
    We''ll use this to make the live aspect of our chat application a lot easier to
    write.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一些新的工具：Socket.IO 和 Marionette。**Socket.IO** ([http://socket.io](http://socket.io))
    是一个实时通信库，它允许客户端快速且容易地与服务器通信。将其视为客户端和服务器之间的发布和订阅系统（类似于 Backbone 的 `trigger` 和 `listenTo`
    方法）；你可以在维基百科上了解更多关于这种设计模式的信息（[https://en.wikipedia.org/wiki/Publish_and_subscribe](https://en.wikipedia.org/wiki/Publish_and_subscribe)）。我们将使用这个库来使我们的聊天应用实时功能更容易编写。
- en: '**Marionette** ([http://marionettejs.com](http://marionettejs.com)), however,
    is a little more interesting. It bills itself as a composite application library
    for Backbone.js that aims to simplify the construction of large scale JavaScript
    applications. Here''s the idea; as you may have noticed from all the previous
    chapters, a lot of the code that we write in Backbone applications is repeated
    in each application. For example, we have views for both models and collections.
    Often, the collection view will loop over the models in the collection and render
    a model view for each of them, putting them in a container element. As this is
    a common pattern, Marionette wraps all this up for us and allows us to write just
    a few lines to do it all. However, Marionette also offers other tools that make
    managing large applications a little easier. We''ll look at a bunch of these in
    this chapter.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**Marionette** ([http://marionettejs.com](http://marionettejs.com)) 则更有趣。它将自己定位为
    Backbone.js 的复合应用库，旨在简化大型 JavaScript 应用的构建。这个想法是；正如你可能从所有前面的章节中注意到的，我们在 Backbone
    应用中编写的很多代码在每个应用中都是重复的。例如，我们既有模型视图也有集合视图。通常，集合视图会遍历集合中的模型，并为每个模型渲染一个视图，将它们放入一个容器元素中。由于这是一个常见的模式，Marionette
    为我们封装了所有这些，并允许我们只写几行代码就能完成所有这些。然而，Marionette 还提供了其他一些工具，使管理大型应用变得更容易。在本章中，我们将探讨其中的一些。
- en: Setting up the application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置应用
- en: 'We have to begin this application with a bit of server-side code. We will use
    Express as our primary server; however, we also want to use Socket.IO, so we have
    to set it up. Copy the template to start the new project. Then, in the project
    directory, go ahead and install all our packages and then Socket.IO with npm as
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须从一点服务器端代码开始这个应用程序。我们将使用 Express 作为我们的主要服务器；然而，我们还想使用 Socket.IO，因此我们必须设置它。将模板复制以启动新项目。然后，在项目目录中，继续安装所有我们的包，然后使用
    npm 安装 Socket.IO，如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, to get Express and Socket.IO to play together nicely, we need to do things
    a bit differently in our `server.js` file. First, we require the `http` library
    of Node.js and `socket.io`. Here''s how:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使 Express 和 Socket.IO 顺利协作，我们需要在 `server.js` 文件中做一些不同的操作。首先，我们需要引入 Node.js
    的 `http` 库和 `socket.io`。以下是方法：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we have to wrap our Express application (the `app` object) in a Node.js
    server object as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将我们的 Express 应用程序（`app` 对象）封装在 Node.js 服务器对象中，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we have a server. The final step to getting things working with Socket.IO
    is to create a Socket.IO instance that listens to our server. We do that this
    way:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了服务器。要使用 Socket.IO 使一切正常工作，最后一步是创建一个监听我们服务器的 Socket.IO 实例。我们这样做：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Currently in the `server.js` file, you''ll have the code that calls the `app.listen`
    function. However, as we''re now wrapping our Express app in a Node.js server
    object, we need to call `listen` on that. So remove the `app.listen` call, and
    replace it with the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在 `server.js` 文件中，你将看到调用 `app.listen` 函数的代码。然而，由于我们现在正在将 Express 应用封装在 Node.js
    服务器对象中，我们需要在那个对象上调用 `listen`。因此，请移除 `app.listen` 调用，并用以下代码替换：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point, you should be able to boot up the server (`npm start`) and go
    to `http://localhost:3000` and get our blank page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够启动服务器（`npm start`），然后访问 `http://localhost:3000` 并看到我们的空白页面。
- en: Preparing our template
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备我们的模板
- en: 'The next step takes us into the `views/index.ejs` file. Marionette, of course,
    is a client library, but Socket.IO has a client component too; so we''ll need
    to add script tags for both of them. Put these just below the tag for `backbone.js`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将带我们进入 `views/index.ejs` 文件。Marionette 当然是一个客户端库，但 Socket.IO 也有一个客户端组件；因此，我们需要为它们两个都添加脚本标签。将这些标签放在
    `backbone.js` 标签的下方：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Socket.IO on the backend will send the right file to that route, even though
    we never put `socket.io.js` in place. However, we do need to download Marionette.
    If you head over to the Marionette downloads page ([http://marionettejs.com/#download](http://marionettejs.com/#download)),
    you''ll see there are a few versions available. The Marionette library uses two
    main components: `Backbone.Wreqr` and `Backbone.BabySitter` (both have been built
    by the same good folks who made Marionette). You can download Wreqr, BabySitter,
    and Marionette separately, or you can get them bundled together. Make sure you
    download the bundled version and place it in the `public` directory.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有在 `socket.io.js` 中放置任何内容，Socket.IO 在后端也会将正确的文件发送到那个路由。然而，我们确实需要下载 Marionette。如果你访问
    Marionette 下载页面（[http://marionettejs.com/#download](http://marionettejs.com/#download)），你会看到有几个版本可供选择。Marionette
    库使用两个主要组件：`Backbone.Wreqr` 和 `Backbone.BabySitter`（这两个组件都是由制作 Marionette 的同一群好人构建的）。你可以单独下载
    Wreqr、BabySitter 和 Marionette，或者将它们捆绑在一起。确保你下载捆绑版本并将其放置在 `public` 目录中。
- en: Also, we will split our application into many smaller pieces and place them
    in their own files, similar to how we've done in the previous two chapters. For
    each file we make, you would want to add a script tag for it to the `views/index.ejs`
    file. In this case, the order will matter, and we'll see why that is and how to
    order them correctly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将把我们的应用程序拆分成许多更小的部分，并将它们放在各自的文件中，类似于我们在前两章中所做的那样。对于我们创建的每个文件，你都会想要在 `views/index.ejs`
    文件中为其添加一个脚本标签。在这种情况下，顺序很重要，我们将会看到为什么顺序很重要以及如何正确排序它们。
- en: A word about Socket.IO
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 Socket.IO 的一些话
- en: 'Socket.IO makes it really easy to send data back and forth between the server
    and the client. As we''ve seen, this is one of the most important parts of Backbone;
    sending our models to and from the server. It would be relatively easier to replace
    the `Backbone.sync` function (as we did in [Chapter 2](ch02.html "Chapter 2. Building
    a Photo-sharing Application"), *Building a Photo-sharing Application*) with an
    implementation that uses Socket.IO. For example, we might do something like what
    is shown in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 使得在服务器和客户端之间发送和接收数据变得非常容易。正如我们所见，这是 Backbone 最重要的一部分；将我们的模型发送到服务器和从服务器接收。相对而言，用
    Socket.IO 替换 `Backbone.sync` 函数（如我们在第 2 章[Building a Photo-sharing Application](ch02.html
    "Chapter 2. Building a Photo-sharing Application")中所述）会更容易一些。例如，我们可能会做如下所示的事情：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you haven't used Socket.IO before, this code won't make much sense just yet;
    but look at this again towards the end of the chapter and it should be clear.
    While we could write a Backbone application using Socket.IO this way, that's not
    the way we're going to be doing it here. To the get the live aspect of our chat
    application, we can't use the regular Backbone methods that talk to the server,
    such as `save` and `create`; we'll need to take things into our own hands. Part
    of the beauty of Backbone is that this will work out fine; if we decide to use
    Backbone to build an application that doesn't really fall within its *normal*
    usage, there's no extra friction from Backbone. However, you should know that
    you can use Socket.IO to do the syncing of a normal Backbone application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过 Socket.IO，这段代码现在可能不太容易理解；但请在本章末尾再次查看，它应该会变得清晰。虽然我们可以使用 Socket.IO
    以这种方式编写 Backbone 应用程序，但这里我们不会这样做。为了获得我们聊天应用程序的实时特性，我们不能使用与服务器通信的常规 Backbone 方法，如
    `save` 和 `create`；我们需要自己动手。Backbone 的一个优点是，这将顺利工作；如果我们决定使用 Backbone 来构建一个实际上并不在其
    *正常* 使用范围内的应用程序，Backbone 不会产生额外的摩擦。然而，你应该知道你可以使用 Socket.IO 来同步一个常规 Backbone 应用程序。
- en: Creating modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块
- en: Almost all of our code in this chapter will be put into modules, which Marionette
    will provide for us. But we need to start with some application preparation code.
    Previously, we've seen how we can put all the components of our application in
    a single global variable. Marionette takes this a step further by giving us an
    `Application` class; it's more than just an object onto which we can hang our
    own classes. As you'll see, it provides a lot of other interesting features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分代码都将放入模块中，Marionette 将为我们提供这些模块。但我们需要从一些应用程序准备代码开始。之前，我们看到了如何将我们应用程序的所有组件放入一个单独的全局变量中。Marionette
    通过给我们一个 `Application` 类来更进一步，它不仅仅是一个我们可以挂载我们自己的类的对象。正如你将看到的，它提供了许多其他有趣的功能。
- en: 'So we start in the usual `app.js` file. Here''s the code that we''ll put in
    that file for starters:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先从常规的 `app.js` 文件开始。以下是我们将首先放入该文件的代码：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We're already familiar with template settings for Underscore, so the other lines
    are what you should focus on. The first line is how we create our single global
    variable for our application. All the special classes and components that Marionette
    gives us are available through the `Backbone.Marionette` namespace, and here,
    we will create an instance of the `Backbone.Marionette.Application`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了 Underscore 的模板设置，所以其他行是你应该关注的。第一行是我们为应用程序创建单个全局变量的方式。Marionette 给我们的所有特殊类和组件都通过
    `Backbone.Marionette` 命名空间提供，在这里，我们将创建一个 `Backbone.Marionette.Application` 的实例。
- en: The way a Marionette application object works is that we'll eventually start
    up the application with `App.start()`. When we do that, any initializers we have
    added (with the `App.addInitializer` method) to the application will be run. We
    haven't added any initializers yet, but we will later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette 应用程序对象的工作方式是，我们将最终使用 `App.start()` 启动应用程序。当我们这样做时，我们添加到应用程序中的任何初始化器（使用
    `App.addInitializer` 方法）都将被执行。我们还没有添加任何初始化器，但稍后我们会这样做。
- en: In the final part of that code, we're listening for the `initialize:after` event.
    Marionette fires many different events at many points in the life of an application,
    and this is one of them. As you probably suspect, this event is fired after all
    the initializers we set up have been run. Once the application is initialized,
    we can start the router by starting Backbone's history mechanism, as we've done
    before.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的最后部分，我们正在监听`initialize:after`事件。Marionette在应用程序生命周期的许多点上触发许多不同的事件，这是其中之一。正如你可能猜到的，这个事件是在我们设置的初始化器全部运行之后触发的。一旦应用程序初始化完成，我们可以通过启动Backbone的历史机制来启动路由器，就像我们之前做的那样。
- en: Now that we have a basic application object, we can create modules. In general,
    in any programming language or library, modules are a way of grouping related
    code into one piece; the internals are kept hidden, and only the pieces we choose
    can be accessed from outside the module. This is exactly how Marionette uses them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个基本的应用程序对象，我们可以创建模块。一般来说，在任何编程语言或库中，模块是将相关代码组合成一个单元的方式；内部细节被隐藏起来，只有我们选择的片段可以从模块外部访问。这正是Marionette使用它们的方式。
- en: 'Our first module will be very simple; it''s the Socket module. The file will
    be `public/socket.js`. The following is the code for this file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个模块将会非常简单；它是Socket模块。该文件将是`public/socket.js`。以下是这个文件的代码：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is the Marionette way of creating a module. We call the `App.module` method;
    it takes two parameters. The first is the name of the module. The module will
    be made available as a property of our `App` object by this name. As we call it
    `Socket` here, we'll be able to access this module in other places through `App.Socket`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Marionette创建模块的方式。我们调用`App.module`方法；它接受两个参数。第一个是模块的名称。通过这个名称，模块将作为我们`App`对象的一个属性提供。由于我们在这里将其命名为`Socket`，我们将在其他地方通过`App.Socket`访问这个模块。
- en: The second parameter is a function; of course, in this function we create the
    module. You might expect that whatever object we return from this function becomes
    our module, but that's not actually how it works. Instead, the `App.module` function
    will pass a parameter to our function; we will call it `Socket` as well. This
    is the object that will become our property. Anything we make a property of that
    object will be accessible from the `App` object. So in all our other modules,
    we can call the `App.Socket.io` property. However, what exactly is this property
    that we've just created?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个函数；当然，在这个函数中我们创建模块。你可能会期望从这个函数返回的任何对象都将成为我们的模块，但实际上并非如此。相反，`App.module`函数将传递一个参数给我们的函数；我们将称之为`Socket`。这个对象将成为我们的属性。我们将其作为属性设置的所有内容都将从`App`对象中访问。因此，在我们所有的其他模块中，我们可以调用`App.Socket.io`属性。然而，我们刚刚创建的这个属性究竟是什么呢？
- en: The script that we added to the `index.ejs` file will give us a global `io`
    object that we can work with. We create our connection by calling the `connect`
    method and passing it the URL to which we want to connect. Since we're running
    our local server on port 3000, this is the path we connect to; if you were to
    use this in a public application, you'll want to put the public URL for your application
    in there. So this is our connection object, and as we just saw, we'll be able
    to access it from other modules.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`index.ejs`文件中的脚本将给我们一个全局的`io`对象，我们可以与之交互。我们通过调用`connect`方法并传递我们想要连接的URL来创建我们的连接。由于我们正在本地服务器上运行端口3000，这是我们连接的路径；如果你要在公共应用中使用它，你将想要在那里放置你应用的公共URL。因此，这是我们连接对象，正如我们刚才看到的，我们将能够从其他模块访问它。
- en: Creating users
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户
- en: Next, we'll create users. Unlike some of our previous applications, these aren't
    user accounts that users can log into. Instead, a user is just someone who is
    currently using our chat application; all they need to provide is a screen name.
    So a collection of users is really just a list of currently used screen names.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建用户。与我们的某些先前应用不同，这些用户并不是可以登录的用户账户。相反，一个用户只是当前正在使用我们的聊天应用的人；他们需要提供的只是昵称。因此，用户集合实际上只是一个当前使用的昵称列表。
- en: 'So, create a `public/user.js` file and start with the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个`public/user.js`文件，并从以下代码开始：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s how we start. First, we create a basic `UserModel` class (we can''t
    just call it `User` because that would overwrite our module variable). Then, we
    create a collection class. As we''ve done before, we give it the model class.
    Things begin to get interesting in the collection''s `initialize` function. Remember,
    we''re not using the normal channels for communicating with the server here, so,
    we need to set up a way to discover when other users join or leave the site. We''ll
    use Socket.IO on the server to emit a `user:join` event whenever a user joins
    the site; the event will send the new user''s data to the client, which is an
    object with a name property, such as `{ name: ''Andrew'' }`. We can listen for
    this event with `App.Socket.io.on`; this method takes the name of the event we''re
    listening for and a function that will be run each time the event occurs. As you
    can see, each time a user joins, we''ll add that user to the collection.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '这就是我们开始的方式。首先，我们创建一个基本的 `UserModel` 类（我们不能简单地将其命名为 `User`，因为这会覆盖我们的模块变量）。然后，我们创建一个集合类。正如我们之前所做的那样，我们给它一个模型类。在集合的
    `initialize` 函数中，事情开始变得有趣。记住，我们在这里不是使用正常的通道与服务器通信，因此，我们需要设置一种方式来发现其他用户何时加入或离开网站。我们将在服务器上使用
    Socket.IO 来发射一个 `user:join` 事件，每当有用户加入网站时；该事件将发送新用户的数据到客户端，它是一个具有名称属性的对象，例如 `{
    name: ''Andrew'' }`。我们可以使用 `App.Socket.io.on` 来监听这个事件；这个方法接受我们正在监听的事件的名称和一个函数，每次事件发生时都会运行这个函数。正如你所看到的，每次有用户加入，我们都会将该用户添加到集合中。'
- en: We also need to know when a user leaves. We'll listen for the `user:leave` event;
    when this happens, we'll use the collection's `findWhere` method to find that
    `UserModel` instance, and then destroy it, removing it from the collection. A
    Backbone collection's `findWhere` method will return the first model that matches
    the attributes hash we pass to it. Since we'll make sure that each name is unique
    on the server side, we can be sure we're destroying the right user.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要知道何时有用户离开。我们将监听 `user:leave` 事件；当发生这种情况时，我们将使用集合的 `findWhere` 方法来找到那个 `UserModel`
    实例，然后销毁它，从集合中移除。Backbone 集合的 `findWhere` 方法将返回第一个与我们传递给它的属性哈希匹配的模型。由于我们将在服务器端确保每个名称都是唯一的，我们可以确信我们正在销毁正确的用户。
- en: One last thing to point out is that we will keep the `UserModel` class local
    to the module, but we will make the `Collection` class public by putting it on
    the `User` object. This is because we will never need to use the model class directly
    (only through the collection), so we can keep it hidden. There's no need to give
    the code outside this module access to more functionality from within this module
    than we need to.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要指出的一点是，我们将把 `UserModel` 类保留在模块内部，但我们将通过将其放在 `User` 对象上来使 `Collection` 类公开。这是因为我们永远不会直接使用模型类（只通过集合），因此我们可以将其隐藏。没有必要让这个模块外部的代码访问比我们需要的更多这个模块的功能。
- en: 'Now that we''ve created our model and collection classes, let''s make views
    for them. These views go in the `User` module too. The views look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了模型和集合类，让我们为它们创建视图。这些视图也放在 `User` 模块中。视图看起来是这样的：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we''re using two of the handy view classes that Marionette gives us:
    `Backbone.Marionette.ItemView` and `Backbone.Marionette.CollectionView`. We commonly
    create views specifically to render individual models or collections, and these
    classes wrap up that common code for us. First, we create an `ItemView` class.
    The only properties we need to give it are `tagName` and `template`. These are
    both properties that we usually use; however, you''ll notice something different
    about the `template` attribute. Instead of getting the template text via jQuery
    and using Underscore to convert it to a template function, all we have to do is
    set the template to a selector string. Here, we will set it to `#user`. Of course,
    we''ll put this template in the `index.ejs` file, with the following lines of
    code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 Marionette 给我们的两个方便的视图类：`Backbone.Marionette.ItemView` 和 `Backbone.Marionette.CollectionView`。我们通常创建特定的视图来渲染单个模型或集合，这些类为我们封装了常见的代码。首先，我们创建一个
    `ItemView` 类。我们只需要给它提供 `tagName` 和 `template` 属性。这两个属性我们通常都会使用；然而，你会发现 `template`
    属性有些不同。我们不是通过 jQuery 获取模板文本并使用 Underscore 将其转换为模板函数，我们只需要将模板设置为选择器字符串。在这里，我们将将其设置为
    `#user`。当然，我们将把这个模板放在 `index.ejs` 文件中，以下是一些代码行：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A simple template for sure. However, it shows how the extensions that Marionette
    provides can make complex applications simpler.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的模板确实。然而，它展示了 Marionette 提供的扩展如何使复杂的应用程序变得更简单。
- en: The `User.CollectionView` is even simpler. We don't have to give it a `tagName`,
    but we can, and as our `ItemView` instances are list items, it makes sense to
    make the elements of `CollectionView` a list. Then, we only have to say what `itemView`
    is. In our case, this is the `ItemView` class we just created. The way a `Marionette.CollectionView`
    works is that it will loop over the collection, create an `itemView` for each
    item, and append it to the collection's element.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.CollectionView`甚至更简单。我们不必给它一个`tagName`，但我们可以，而且由于我们的`ItemView`实例是列表项，所以将`CollectionView`的元素做成列表是有意义的。然后，我们只需要说明`itemView`是什么。在我们的例子中，这是我们刚刚创建的`ItemView`类。`Marionette.CollectionView`的工作方式是它会遍历集合，为每个项目创建一个`itemView`，并将其附加到集合的元素上。'
- en: So that's our first module. We'll be creating several more modules in this application,
    but the `User` module is a good example of a typical Marionette module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们第一个模块。我们将在这个应用程序中创建更多模块，但`User`模块是一个典型的Marionette模块的好例子。
- en: 'We''ve created three files here (`app.js`, `socket.js`, and `users.js`), so
    let''s add them to the `index.ejs` file. Make sure that `app.js` comes first.
    We will add the three files using the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了三个文件（`app.js`、`socket.js`和`users.js`），所以让我们将它们添加到`index.ejs`文件中。确保`app.js`排在第一位。我们将使用以下代码添加这三个文件：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Building the layout
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建布局
- en: 'The next step is the layout. This isn''t something we''ve done in the previous
    applications, but it is something that Marionette gives us. This functionality
    allows us to organize and manipulate the many views we''ll have on screen at once.
    In a large application, this can get tricky, and Marionette has two classes that
    make this simpler: `Region` and `Layout`. A region is basically an area of the
    screen, an object we can use to easily show and hide views or layouts. A layout
    is basically a group of regions.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是布局。这不是我们在之前的应用程序中做过的事情，但Marionette给了我们这个功能。这个功能允许我们组织和操作屏幕上同时显示的许多视图。在一个大型应用程序中，这可能会变得复杂，Marionette有两个类使这变得更简单：`Region`和`Layout`。一个区域基本上是屏幕上的一个区域，一个我们可以用来轻松显示和隐藏视图或布局的对象。布局基本上是一组区域。
- en: 'We''re going to create a `Layout` module for our layout classes. The following
    is the whole of our `public/layout.js` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的布局类创建一个`Layout`模块。以下是我们整个`public/layout.js`文件的内容：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first class is the layout for our application. Think of it as a view class
    but with no model or collection to display. Instead, it gives us access to several
    regions. Just like with the `ItemView`, the `template` property is a selector
    for the template. The template is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类是我们应用程序的布局。把它想象成一个视图类，但没有模型或集合来显示。相反，它给我们提供了访问几个区域的方法。就像`ItemView`一样，`template`属性是一个模板的选择器。模板如下：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we have four main areas, and these are the regions. We have
    a list of users, a list of rooms, the actual chat conversation, and a controls
    area where the user will log in and type in their message. In our `Layout` class,
    we have a `regions` property, which defines what the regions of our layout are.
    Each one is a selector, pointing to each of the four `<div>` elements in our template.
    When we create an instance of this `Layout` class, we'll be able to control the
    content of each of these regions individually.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有四个主要区域，这些是区域。我们有一个用户列表，一个房间列表，实际的聊天对话，以及一个用户将登录并输入消息的控制区域。在我们的`Layout`类中，我们有一个`regions`属性，它定义了我们的布局区域。每个都是一个选择器，指向我们的模板中的四个`<div>`元素中的每一个。当我们创建这个`Layout`类的实例时，我们将能够单独控制这些区域的内容。
- en: 'After that comes the `MainRegion` class, which is a `Marionette Region`. This
    time, instead of setting a `tagName`, we will set the `el` property. When we do
    this, the class will use an existing DOM element instead of creating a new one.
    This is simply a region within which we will render our layout. In fact, this
    is our next step; to make our `App` object aware of this main region. In `app.js`,
    we need to add a call to the `addInitialize` method we discussed earlier. This
    can be done as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之后是`MainRegion`类，这是一个`Marionette Region`。这次，我们不再设置`tagName`，而是设置`el`属性。当我们这样做时，该类将使用现有的DOM元素而不是创建一个新的。这只是一个我们将在其中渲染布局的区域。实际上，这是我们下一步；让我们的`App`对象意识到这个主要区域。在`app.js`中，我们需要添加之前讨论过的`addInitialize`方法的调用。这可以通过以下方式完成：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `App` object has an `addRegions` method that takes an object as a parameter.
    The property names are the names of the regions, and the value is the region class
    we're using. Here, we will create a single region, `main`, with our `MainRegion`
    class. Notice how, since we assigned `main` as a property of `Layout` in `layout.js`,
    we can access it via `App.Layout.MainRegion`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`App`对象有一个`addRegions`方法，它接受一个对象作为参数。属性名称是区域的名称，值是我们使用的区域类。在这里，我们将创建一个单独的区域`main`，使用我们的`MainRegion`类。请注意，由于我们在`layout.js`中将`main`分配为`Layout`的属性，我们可以通过`App.Layout.MainRegion`来访问它。
- en: Starting the router
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动路由器
- en: Without a doubt, the most complex part of this chapter's application is the
    router, and with more advanced applications, this will often be the case. Due
    to this, Marionette's recommended pattern is to split the functionality of the
    Backbone router into two parts. The first part is still called the router; its
    job is to decide what should be done based on the current route. Then, there's
    the controller that actually performs the action decided upon by the router. Marionette
    has the `Marionette.AppRouter` class for the routing functionality. Interestingly,
    Marionette provides no framework for the controller. All that's required is a
    basic object with the right methods. We will create a constructor function and
    place all our methods on the prototype. So, let's create `router.js` within `public`
    and get started.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，本章应用程序中最复杂的部分是路由器，并且对于更高级的应用程序，这通常也是情况。因此，Marionette推荐的模式是将Backbone路由器的功能分成两部分。第一部分仍然被称为路由器；它的任务是根据当前路由决定应该做什么。然后，有一个控制器实际执行路由器决定的操作。Marionette有`Marionette.AppRouter`类用于路由功能。有趣的是，Marionette没有提供控制器框架。所需的所有东西只是一个具有正确方法的基本对象。我们将创建一个构造函数，并将所有方法放在原型上。所以，让我们在`public`中创建`router.js`并开始吧。
- en: 'As Marionette recommends shifting most of the traditional Backbone router''s
    work to the controller, the router itself is very minimal. Here''s how it starts:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Marionette建议将大多数传统的Backbone路由器的工作转移到控制器上，因此路由器本身非常简单。以下是它是如何启动的：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We wrap this in a `Router` module. Then, we use Marionette's `AppRouter` class;
    as in many other Backbone classes, we create an `initialize` function that will
    run when we create our router instance. This is where we render our layout. We
    create a new instance of our `Layout` class and pass it to the `main` region's
    `show` method. As you'll see in the controller, this is the Marionette way of
    rendering layouts and views. we never call the `render` method ourselves. Instead,
    we pass a layout or view instance to a region's `show` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个包裹在`Router`模块中。然后，我们使用Marionette的`AppRouter`类；正如许多其他Backbone类一样，我们创建一个`initialize`函数，该函数将在我们创建路由器实例时运行。这就是我们渲染布局的地方。我们创建`Layout`类的新实例，并将其传递给`main`区域的`show`方法。正如您将在控制器中看到的，这是Marionette渲染布局和视图的方式。我们从不自己调用`render`方法。相反，我们将布局或视图实例传递给区域的`show`方法。
- en: 'Also, notice that we''re making our layout instance a property on our `App`
    module: `App.layout`. This is how we''ll access our four regions from within the
    controller using `App.layout.users` or `App.layout.controls`. As these are regions,
    they will have the `show` method, to which we can pass the views we want to render.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们将布局实例作为我们的`App`模块的一个属性：`App.layout`。这就是我们如何在控制器内部通过`App.layout.users`或`App.layout.controls`来访问我们的四个区域。由于这些是区域，它们将具有`show`方法，我们可以向其中传递我们想要渲染的视图。
- en: Finally, instead of a `routes` property, our `AppRouter` will have an `appRoutes`
    property. This works just like the `routes` method of a normal router, except
    that the methods we call will be in the controller instead of on the router itself.
    We will start with a simple `index` route.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，而不是`routes`属性，我们的`AppRouter`将有一个`appRoutes`属性。这就像正常路由器的`routes`方法一样工作，只不过我们调用的方法将在控制器上而不是在路由器本身上。我们将从一个简单的`index`路由开始。
- en: 'Now, let''s start with the controller. This also goes inside the `Router` module
    that we''ve created. The controller can be started like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从控制器开始。这也位于我们创建的`Router`模块内部。控制器可以像这样启动：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There's a lot more to come, but this is what we can do right now with the code
    we've already written. In the constructor function, we'll create a `users` property.
    This is the collection that will manage our list of users. As our router will
    be looking for a method called `index`, we'll add that to `prototype` of our `Controller`
    function. This method simply creates an `App.User.CollectionView` instance and
    renders it in the `users` region of our layout.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多内容即将到来，但这是我们目前可以用我们已编写的代码做到的。在构造函数中，我们将创建一个`users`属性。这是将管理我们用户列表的集合。由于我们的路由器将寻找一个名为`index`的方法，我们将将其添加到`Controller`函数的`prototype`中。这个方法简单地创建一个`App.User.CollectionView`实例，并在我们布局的`users`区域中渲染它。
- en: 'Before we load up our page, we need to instantiate the router. At the bottom
    of the `Router` module, add the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们加载页面之前，我们需要实例化路由器。在`Router`模块的底部，添加以下代码：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we instantiate our router, passing it a new `Controller` object as a property
    in an options object. The router will use this object as the controller for our
    application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化我们的路由器，传递一个新`Controller`对象作为选项对象中的一个属性。路由器将使用此对象作为我们应用程序的控制器。
- en: 'The last step to having some code we can actually run is to add a few lines
    to the `index.ejs` file. This can be done as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一些我们可以实际运行的代码，最后一步是向`index.ejs`文件中添加几行代码。这可以按照以下方式完成：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We add our layout and router modules, and then, right at the bottom, we start
    the application. Remember that, even when we add other script tags later on, it
    is important that the `router.js` script should be the last one loaded because
    it references almost all the other files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加我们的布局和路由模块，然后，在底部，我们启动应用程序。记住，即使我们稍后添加其他脚本标签，`router.js`脚本应该是最后一个加载的，因为它几乎引用了所有其他文件。
- en: 'Now, you can run `npm start` to boot the server up and load `http://localhost:3000`
    in a browser. At this point, you won''t see anything at all on the page; however,
    open the developer tools and you''ll see that things are starting to take shape.
    We can see this in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行`npm start`来启动服务器并加载浏览器中的`http://localhost:3000`。在这个时候，你将看不到页面上有任何东西；然而，打开开发者工具，你会看到事情开始成形。我们可以在以下屏幕截图中看到这一点：
- en: '![Starting the router](img/6997OS_05_01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![启动路由器](img/6997OS_05_01.jpg)'
- en: You can see that our layout has been rendered and that the `<ul>` element of
    our `User.CollectionView` instance is present. Even though we aren't rendering
    any content, this is an important step. We've written a lot of code that might
    seem disparate and unconnected, but it has all come together to create the humble
    beginnings of our application. Now that we have the infrastructure working, we
    can start to think about specific features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的布局已经被渲染，并且我们的`User.CollectionView`实例的`<ul>`元素是存在的。尽管我们没有渲染任何内容，但这是一个重要的步骤。我们编写了很多看似分散和无关的代码，但它们都汇集在一起，为我们应用程序的谦逊开端做出了贡献。现在，我们的基础设施已经工作，我们可以开始考虑具体的功能。
- en: Letting users join the fun
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让用户加入乐趣
- en: Our first serious feature will be allowing users to choose a screen name and
    join the chat rooms. We'll need a view with a form where a user can submit their
    name. However, as part of this, we'll need a way to ask the server if this name
    has been taken yet.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个重要功能将是允许用户选择一个屏幕名并加入聊天室。我们需要一个带有表单的视图，用户可以在其中提交他们的名字。然而，作为这部分的一部分，我们需要一种方式来询问服务器这个名字是否已经被占用。
- en: 'For all this, we go back to the `User` module, and add a method to the `User.CollectionView`,
    using the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些，我们回到`User`模块，并向`User.CollectionView`添加一个方法，使用以下代码：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This method takes the `name` that the user wants to use as well as a `callback`
    function. Inside the method, we use another Socket.IO method: `emit`. This is
    the flip side of the `App.Socket.io.on` method we saw earlier in this class''s
    `initialize` method. The `on` method listens for events while `emit` actually
    makes the occurrence of the event. The `emit` method takes at least one parameter;
    the name of the event that we''re triggering. We can then pass as many subsequent
    parameters as we like; these are pieces of data that we can associate with the
    event. If the server is listening for this event, it will receive these parameters.
    We pass the user''s name and a function. The name makes sense; if the server is
    going to tell us whether this name is already in use, we need to send it the name.
    However, the function is a little different. We receive the function on the server
    side, but when we call the function (from the server, remember!) it will be executed
    here in the browser. This is not only incredibly cool, it''s also very useful.
    On the server, we''ll pass that function a Boolean value; `true` if the user can
    use this name and has been added to the list of current users or `false` if the
    name is already in use.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受用户想要使用的`name`以及一个`callback`函数。在方法内部，我们使用另一个Socket.IO方法：`emit`。这是我们在本类`initialize`方法中较早看到的`App.Socket.io.on`方法的反面。`on`方法用于监听事件，而`emit`实际上使事件发生。`emit`方法至少需要一个参数；我们正在触发的事件的名称。然后我们可以传递尽可能多的后续参数；这些是与事件相关联的数据。如果服务器正在监听此事件，它将接收到这些参数。我们传递用户的名字和一个函数。名字是有意义的；如果服务器要告诉我们这个名字是否已被使用，我们需要发送这个名字。然而，函数是有一点不同的。我们在服务器端接收这个函数，但当我们从服务器调用这个函数（记住！）时，它将在浏览器这里执行。这不仅非常酷，而且非常有用。在服务器上，我们将传递一个布尔值给这个函数；如果用户可以使用这个名字并且已被添加到当前用户列表中，则为`true`；如果名字已被使用，则为`false`。
- en: If the user has successfully joined the chat rooms, we'll set their screen name
    as a property of our `App` object, so we can access it from other places. Then,
    we'll call the `callback` function that was passed to the `addUser` method, passing
    it the `joined` value. The `context` parameter is actually just a nice touch.
    I'm not a fan of having to put the value of `this` in a variable every time I
    enter a callback function, so when I have the option, I'll create functions that
    take a context as a final parameter. This way, I can use `this` as I want inside
    the function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户成功加入了聊天室，我们将设置他们的屏幕名字作为我们`App`对象的属性，这样我们就可以在其他地方访问它。然后，我们将调用传递给`addUser`方法的`callback`函数，并将`joined`值传递给它。`context`参数实际上是一个很好的细节。我不是很喜欢每次进入回调函数时都要将`this`的值放入变量中，所以当我有这个选择时，我会创建接受上下文作为最后一个参数的函数。这样，我就可以在函数内部按需使用`this`。
- en: 'With that in place, let''s move over to `server.js`. We haven''t written any
    Socket.IO-specific code yet, but we''re going to start that now. Start by adding
    this to `server.js`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这些之后，让我们转到`server.js`文件。我们还没有编写任何Socket.IO特定的代码，但现在我们将开始编写。首先，将以下内容添加到`server.js`中：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We start with a `users` object; it's empty right now, but as users join, it
    will be used. As we aren't creating actual user accounts, there's no need for
    this record to be persistent; a regular object will do.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个`users`对象开始；目前它是空的，但随着用户的加入，它将被使用。由于我们并没有创建实际的用户账户，因此这个记录不需要持久化；一个普通对象就足够了。
- en: Earlier, we created the `io` object. This object has a `sockets` object on which
    we have the `on` method, which we can use to listen for connections being opened
    from browsers. As you can see here, we're listening for the `connection` event.
    The callback function here will be run when a new connection is made. The new
    socket (the connection to the browser) is a parameter of the function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们创建了`io`对象。这个对象有一个`sockets`对象，上面有一个`on`方法，我们可以使用它来监听来自浏览器的连接。如你所见，我们正在监听`connection`事件。当建立新的连接时，这里的回调函数将被执行。新的socket（与浏览器的连接）是这个函数的参数。
- en: 'Inside this callback, we''ll start by listening for the `join` event that the
    `User.CollectionView` class'' `addUser` method was emitting. Add this inside that
    callback function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调函数内部，我们将首先监听`User.CollectionView`类的`addUser`方法所发出的`join`事件。将以下内容添加到那个回调函数中：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember that when we emitted the `join` event, we sent the name and a function
    along with it. You can see these here on the server as the parameters of the function
    that will be called when this event occurs. In this function, we check to see
    whether the user exists using a `userExists` function, which we haven't written
    yet. If the user already exists, we'll call that `response` function (that is
    executed on the client, remember?) and pass `false` (because the user can't join
    under that name). However, if the user doesn't currently exist, we'll respond
    with `true`. Then, we'll add the user to the `users` object. We can use the unique
    `socket.id` as a key. Finally, we'll emit the `user:join` event, passing a basic
    user object as the data associated with that event. All the currently connected
    clients (including the client that sent the join event) will receive this event.
    Remember that in our `User.Collection` class' `initialize` method, we're listening
    for this event. This is how the client can learn about new users joining the chat
    room.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们发出`join`事件时，我们发送了名字和一个函数。你可以在服务器上看到这些参数，作为当此事件发生时将被调用的函数的参数。在这个函数中，我们使用一个名为`userExists`的函数来检查用户是否存在，而这个函数我们还没有编写。如果用户已经存在，我们将调用那个`response`函数（记住，这是在客户端执行的）并传递`false`（因为用户不能使用那个名字加入）。然而，如果用户当前不存在，我们将响应`true`。然后，我们将用户添加到`users`对象中。我们可以使用唯一的`socket.id`作为键。最后，我们将发出`user:join`事件，传递一个基本用户对象作为与该事件关联的数据。所有当前连接的客户端（包括发送加入事件的客户端）都将接收到此事件。记住，在我们的`User.Collection`类的`initialize`方法中，我们正在监听这个事件。这就是客户端如何了解新用户加入聊天室的方式。
- en: You might wonder why we can't just look at the users in the collection to see
    whether a name is in use, instead of asking the server whenever a new user tries
    to join. After all, if the collection is a list of currently connected users,
    it should know whether the name is already in use. The problem with this is that
    in some scenarios, which we haven't yet come to, the user will try to join before
    the server has had the chance to send the current list of users to the collection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们不能直接查看集合中的用户来检查一个名字是否已被使用，而不是每次有新用户尝试加入时都询问服务器。毕竟，如果集合是当前连接用户的列表，它应该知道名字是否已被使用。但问题是，在某些我们尚未涉及的场景中，用户会在服务器有机会将当前用户列表发送到集合之前尝试加入。
- en: 'This is something we have to add. When a new socket is connected, we need to
    send it the list of the currently connected users. This can be done as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们必须添加的。当一个新的套接字连接时，我们需要发送当前连接用户的列表给它。这可以按以下方式完成：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Object.keys` method takes an object and returns an array of its keys. We
    can loop over all the users in our `users` object and emit the `user:join` event
    for each one. There's an important difference between this event and the `user:join`
    event we emitted previously. In the `join` event listener, we use `io.sockets.emit`,
    which emits the event to all sockets. Here, we use `socket.emit`. This way, only
    that socket will receive these events.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.keys`方法接受一个对象并返回其键的数组。我们可以遍历我们的`users`对象中的所有用户，并为每个用户发出`user:join`事件。这个事件与我们之前发出的`user:join`事件有一个重要的区别。在`join`事件监听器中，我们使用`io.sockets.emit`，它将事件发送到所有套接字。这里，我们使用`socket.emit`。这样，只有那个套接字会接收到这些事件。'
- en: 'With this code in place, we''re ready to write the view that allows our users
    to join the chat rooms. We''ll put this code in our `User` module:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好这段代码后，我们就准备好编写允许我们的用户加入聊天室的视图了。我们将这段代码放入我们的`User`模块中：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we create a `Marionette.ItemView` class, so we don''t have to write the
    `render` method ourselves. Instead of passing in a `model`, when creating an instance
    of this class, we''re putting it right here in the class definition (this is possible
    in a regular Backbone view too; it''s not special to Marionette). We''re doing
    this because of the template. Normally, our views that display forms don''t have
    models, but this one does because we want to use this template for multiple views.
    We will use a template with the ID `form`. The template is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`Marionette.ItemView`类，这样我们就不必自己编写`render`方法。在创建这个类的实例时，我们直接在这里将`model`放入类定义中（这在普通的Backbone视图中也是可能的；这并不特别针对Marionette）。我们这样做是因为模板的原因。通常，显示表单的视图没有模型，但这个视图有模型，因为我们想为多个视图使用这个模板。我们将使用ID为`form`的模板。模板如下：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is very basic. It has only an input element and a button. The placeholder
    text and the button text need to come from a model, so that's why we add a basic
    Backbone model with the right attributes to this class definition.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常基础。它只有一个输入元素和一个按钮。占位文本和按钮文本需要来自模型，这就是为什么我们向这个类定义添加了一个具有正确属性的简单 Backbone 模型。
- en: The `events` property is not new or special. When we click on the button, we'll
    call the `addUser` method (of this class). The `ui` property, on the other hand,
    is special to Marionette views; we often need to reference specific elements of
    the view from within view methods, and the `ui` property is a shortcut to access
    them. The keys are the names by which we'll refer to the element, and the value
    is a selector for the element. In this case, we find the input element and call
    it `input`. You can see this in use in the `addUser` method. Instead of searching
    for the input element with `this.$("input")`, we can just reference `this.ui.input`;
    it's even a jQuery object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`events` 属性并不新颖或特殊。当我们点击按钮时，我们将调用这个类的 `addUser` 方法。另一方面，`ui` 属性是 Marionette
    视图特有的；我们经常需要在视图方法中引用视图的特定元素，而 `ui` 属性是访问它们的快捷方式。键是我们引用元素的名称，值是元素的选择器。在这种情况下，我们找到输入元素并将其命名为
    `input`。你可以在 `addUser` 方法中看到它的使用。我们不需要用 `this.$("input")` 搜索输入元素，我们可以直接引用 `this.ui.input`；它甚至是一个
    jQuery 对象。'
- en: In `addUser`, we start by preventing the default submission of the form. Then,
    we get whatever name the user typed into the textbox, and send it to the collection's
    `addUser` method. In our callback function, if the user has successfully joined
    the chat rooms, we'll trigger the `user-added` event on this view. This is the
    Backbone equivalent of emitting an event with Socket.IO (this isn't Marionette-specific;
    you can trigger and listen for events in plain Backbone applications as well).
    Later, we'll listen for this event. If the user did not join successfully, we'll
    clear the input element so that they can try a new name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `addUser` 函数中，我们首先阻止表单的默认提交。然后，我们获取用户在文本框中输入的任何名称，并将其发送到集合的 `addUser` 方法。在我们的回调函数中，如果用户成功加入了聊天室，我们将在该视图中触发
    `user-added` 事件。这是 Backbone 在 Socket.IO 中发出事件的等效操作（这不是 Marionette 特有的；你同样可以在纯
    Backbone 应用程序中触发和监听事件）。稍后，我们将监听此事件。如果用户未能成功加入，我们将清除输入元素，以便他们可以尝试一个新的名称。
- en: 'Now, go back to the `Controller.prototype.index` method in the `router.js`
    file. We need to render a `LogInView` instance, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 `router.js` 文件中的 `Controller.prototype.index` 方法。我们需要渲染一个 `LogInView`
    实例，如下所示：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that this is where the collection in the `addUser` method comes from.
    With this code in place, things are starting to get interesting. If you open `http://localhost:3000`,
    you'll see a textbox and button. Type in a name and click on **Join**; and the
    name will appear above in the list. Now, the magic begins. Open the site in another
    browser tab. You'll see the first name already in the list. Go ahead and add another
    one; it will appear in the list. Now, go back to the first window. You'll see
    that it also received the second name. Isn't that amazing! This works for two
    reasons. First, Socket.IO makes sure every new user is added to the user collection
    of every connected browser. Then, Marionette's `CollectionView` will immediately
    render new models added to the collection, which is why it appears in the list
    without us doing any manual rendering or watching the collection for changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这就是 `addUser` 方法中的集合来源。有了这段代码，事情开始变得有趣。如果你打开 `http://localhost:3000`，你会看到一个文本框和一个按钮。输入一个名称并点击
    **加入**；然后名称将出现在上面的列表中。现在，魔法开始了。在另一个浏览器标签中打开网站。你会看到第一个名称已经在列表中。继续添加另一个；它也会出现在列表中。现在，回到第一个窗口。你会看到它也接收到了第二个名称。这不是很神奇吗！这有两个原因。首先，Socket.IO
    确保每个新用户都被添加到每个连接浏览器的用户集合中。然后，Marionette 的 `CollectionView` 将立即渲染添加到集合中的新模型，这就是为什么它出现在列表中，而无需我们进行任何手动渲染或监视集合的变化。
- en: There's a little problem, though. If you close the second window and go back
    to the first one, you'll find that both names are still in the list. We need to
    remove a name from the collection when a user closes the site.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个小问题。如果你关闭第二个窗口并回到第一个窗口，你会发现两个名称仍然在列表中。当用户关闭网站时，我们需要从集合中移除一个名称。
- en: 'This is done in `server.js`. When a socket disconnects from the server, we
    get a disconnect event; so let''s listen for that (within the `connection` event
    callback). We can do that as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `server.js` 中完成的。当一个 socket 从服务器断开连接时，我们得到一个断开连接的事件；所以让我们监听这个事件（在 `connection`
    事件回调中）。我们可以这样做：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When this socket disconnects, we check the user's object to see whether there's
    an entry for this Socket ID. Remember, if the user never tried to join the chat
    rooms (maybe they loaded the page and then closed it), they won't have an entry;
    that's why we check. If they do, we'll emit a `user:leave` event to all sockets,
    and then delete that entry from our users hash.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当此套接字断开连接时，我们检查用户的对象以查看是否为该 Socket ID 有条目。记住，如果用户从未尝试加入聊天室（也许他们加载了页面然后关闭了它），他们将不会有条目；这就是我们检查的原因。如果他们确实有，我们将向所有套接字发出
    `user:leave` 事件，然后从我们的用户哈希中删除该条目。
- en: Now, we know that our user collection is listening for the `user:leave` event,
    and when it occurs, the user will be removed from the collection. Accordingly,
    Marionette will update the `User.CollectionView`. Now, if you do our quick-and-dirty
    test in the browser again, you'll see that when you close the second browser window,
    the second name disappears from the first window. Clever, no?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道我们的用户集合正在监听 `user:leave` 事件，当它发生时，用户将从集合中移除。相应地，Marionette 将更新 `User.CollectionView`。现在，如果你再次在浏览器中进行快速测试，你会看到当你关闭第二个浏览器窗口时，第二个名字将从第一个窗口中消失。聪明，不是吗？
- en: 'Before leaving the user module behind, let''s add one more feature. Later,
    we''ll be writing some CSS for our application; so let''s highlight the user''s
    own name in the list. In the `ItemView` class in the `User` module, let''s add
    a method called `onRender`. This method will be called after the view has been
    rendered. Here''s how that looks:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开用户模块之前，让我们添加一个新功能。稍后，我们将为我们的应用程序编写一些 CSS；所以让我们在列表中突出显示用户的自己的名字。在 `User` 模块中的
    `ItemView` 类中，让我们添加一个名为 `onRender` 的方法。此方法将在视图渲染后被调用。下面是这个方法的示例：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It's quick and simple. If the model we're rendering this view for has the same
    name as the user in this browser, add the class `highlight` to the element.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常快速且简单。如果我们为渲染此视图所使用的模型与浏览器中的用户名相同，则将类 `highlight` 添加到该元素。
- en: Joining a room
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入房间
- en: Once a user has selected their screen name, the next step is selecting a room.
    This is a bit more complex than choosing a name because they can either choose
    from a list of existing rooms, or they can start a new room by typing in a new
    name. If the user types in the name of an existing room, they'll go to the existing
    rooms because we obviously can't have multiple rooms with the same name. The tricky
    part in all this is that while we're calling them rooms, they're actually more
    like tags. The only place they exist is as a property on the chat messages; they
    aren't stored on their own. When a user creates a new room, there's no actual
    record of the room until they write the first message in that room. If they create
    a room and then close the page, the room doesn't exist. All this will make it
    a bit trickier to keep track of the rooms, but we love a good challenge, right?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了他们的屏幕名，下一步就是选择一个房间。这比选择名字要复杂一些，因为他们可以从现有房间的列表中选择，或者他们可以通过输入一个新名字来创建一个新的房间。如果用户输入了现有房间的名字，他们将进入现有房间，因为我们显然不能有多个同名房间。所有这一切中棘手的部分是，虽然我们称之为房间，但它们实际上更像标签。它们只存在于聊天消息的属性上；它们并没有独立存储。当用户创建一个新房间时，直到他们在该房间中写下第一条消息之前，该房间实际上没有记录。如果他们创建了一个房间然后关闭了页面，该房间就不存在了。所有这一切都会使跟踪房间变得有些棘手，但我们喜欢接受挑战，对吧？
- en: 'Open a new file, `rooms.js`, in `public`. Just like our `user.js` file, this
    will have a model, collection, model view, collection view, and form view. The
    following code shows how we start with this file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `public` 中打开一个新的文件，`rooms.js`。就像我们的 `user.js` 文件一样，这将有一个模型、集合、模型视图、集合视图和表单视图。以下代码显示了我们是怎样从这个文件开始的：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We call the module `Room`, and we start with `RoomModel`. This model has a
    single method; it returns the URL for the room. The plan is to eventually allow
    users to go straight to the room of their choice by having it in the URL. This
    makes specific rooms easy to bookmark. Of course, they''ll still have to enter
    their screen name before they can actually see the room, but it will omit the
    "choose a room" step from the process. We''ll use this method to get the route
    to a given room model. Next, we write the collection, which looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模块命名为 `Room`，并从 `RoomModel` 开始。此模型有一个单独的方法；它返回房间的 URL。计划是最终允许用户通过将其包含在 URL
    中直接进入他们选择的房间。这使得特定房间更容易被收藏。当然，他们仍然需要在实际看到房间之前输入他们的屏幕名，但将省略“选择一个房间”的步骤。我们将使用此方法获取给定房间模型的路由。接下来，我们编写集合，如下所示：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Just like in our `User.Collection` class, the `initialize` method here listens
    for an event. In this case, it''s the `room:new` event. When that happens, we''ll
    call this class''s `getRoom` method. This method probably doesn''t look like what
    you''d expect. Its purpose, in this context is to add the room to the collection
    if it isn''t already there. You might expect it to look something like the following
    code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的`User.Collection`类中一样，这里的`initialize`方法监听一个事件。在这种情况下，是`room:new`事件。当这个事件发生时，我们将调用这个类的`getRoom`方法。这个方法可能看起来不像你预期的样子。在这个上下文中，它的目的是如果房间尚未存在于集合中，则将其添加到集合中。你可能期望它看起来像以下代码：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, later on we'll also need a method that takes a room name, and either
    returns the existing room by that name or creates a new room with that name, and
    this is exactly what the `getRoom` method does. As it turns out, the logic in
    `getRoom` is exactly the same as this example `addRoom` method. If the room doesn't
    exist, add it. So our `getRoom` method is a two-for-one deal.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，稍后我们还需要一个方法，该方法接受一个房间名称，要么返回该名称的现有房间，要么创建一个新的房间，这正是`getRoom`方法所做的事情。实际上，`getRoom`中的逻辑与这个示例`addRoom`方法完全相同。如果房间不存在，就添加它。所以我们的`getRoom`方法是一举两得。
- en: 'Let''s move over to `server.js` for a moment. When a new socket connects, we
    need to send the list of existing rooms to this room collection. Inside the function
    that is run when a new socket connects, add this code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时转到`server.js`。当一个新套接字连接时，我们需要将现有房间的列表发送到这个房间集合。在运行新套接字连接时调用的函数内部，添加以下代码：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What we're doing in the preceding code is finding all the records in our database;
    these records are the chat messages. What we need to do is convert this array
    of messages into a list of the rooms that they are in. Although we don't have
    any messages yet, each one will have a `room` property. We loop over each model
    and add a property to a disposable `rooms` object. As an object can't have multiple
    properties with the same name, the result will be an object whose keys are a unique
    list of the existing rooms. Then, we can use `Object.keys` to get an array of
    just those keys; finally, we'll loop over that array and emit the `room:new` event
    for each room. As we've just seen, the `Room.Collection` instance will catch these
    on the browser's end and fill the list.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在查找我们数据库中的所有记录；这些记录是聊天消息。我们需要做的是将这些消息数组转换为它们所在的房间列表。尽管我们还没有任何消息，但每一条消息都将有一个`room`属性。我们遍历每个模型，并将一个属性添加到一个可丢弃的`rooms`对象中。由于一个对象不能有多个同名属性，结果将是一个对象，其键是现有房间的唯一列表。然后，我们可以使用`Object.keys`获取仅包含这些键的数组；最后，我们将遍历这个数组，并为每个房间发出`room:new`事件。正如我们刚才看到的，`Room.Collection`实例将在浏览器端捕获这些事件并填充列表。
- en: 'Now that we have our model and collection, we can make their respective views
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的模型和集合，我们可以按照以下方式制作它们各自的视图：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `RoomView` class is the item view in this case. It will be a list item
    element; the template has the ID `room`. Here''s that template:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`RoomView`类是项目视图。它将是一个列表项元素；模板的ID是`room`。以下是该模板：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the list of rooms will be links; then in the view, we'll listen
    for a click on one of these anchor elements. When that happens, we'll prevent
    the default reloading of the page, and use Backbone to navigate to the room's
    URL. This time, instead of pulling a method from the router, we're using the `Backbone.history.navigate`
    method. Of all the ways of changing the route that we've looked at, this is clearly
    the best one (of course, it's good to know about the others).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，房间列表将是链接；然后在视图中，我们将监听这些锚点元素之一上的点击。当发生这种情况时，我们将阻止页面的默认重新加载，并使用Backbone导航到房间的URL。这次，我们不是从路由器中拉取方法，而是使用`Backbone.history.navigate`方法。在我们查看的所有更改路由的方法中，这显然是最好的一个（当然，了解其他方法也很好）。
- en: The `Room.CollectionView` class is very basic. We just make the wrapping element
    a list and point to the item view.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Room.CollectionView`类非常基础。我们只是将包装元素设置为列表，并指向项目视图。'
- en: 'This is all we need to display the list of existing rooms. However, if a user
    wants to create a new room, we need a view for that. So, here''s that view:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们显示现有房间列表所需的所有内容。然而，如果用户想要创建一个新的房间，我们需要一个视图来处理这个需求。所以，以下是那个视图：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Room.CreateRoomView` class will use the same form template that we used
    in `Login View`, so the whole class will look pretty similar. We're adding the
    model here, so we can set the template's placeholder text and button text. When
    the button is clicked, we'll call the `createRoom` method. This method will prevent
    the default form submission and then get the text from the input element. As our
    room names will be used in URLs, we need to clean the name up a bit by first replacing
    all spaces with underscores and then removing all other non-word characters. Then,
    we pass the room name to the collection's `getRoom` function. As we know, this
    will return a room (either a newly created one or an existing one with that name).
    Then, we'll navigate to that room's URL.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Room.CreateRoomView`类将使用我们在`Login View`中使用的相同表单模板，所以整个类看起来相当相似。我们在这里添加模型，这样我们就可以设置模板的占位文本和按钮文本。当按钮被点击时，我们将调用`createRoom`方法。这个方法将阻止默认的表单提交，然后从输入元素中获取文本。由于我们的房间名称将用于URL中，我们需要先替换所有空格为下划线，然后删除所有其他非单词字符。然后，我们将房间名称传递给集合的`getRoom`函数。正如我们所知，这将返回一个房间（要么是新建的，要么是具有该名称的现有房间）。然后，我们将导航到该房间的URL。'
- en: 'Now that we have these classes, we can use them. First, in `index.ejs`, add
    the `Room` module:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些类，我们可以使用它们。首先，在`index.ejs`中添加`Room`模块：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, in the `Controller` function in `router.js`, add the following line of
    code. It will be the collection object that our application uses to keep track
    of the rooms:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`router.js`中的`Controller`函数中，添加以下代码行。它将是我们的应用程序用来跟踪房间的集合对象：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, go to our controller''s `index` function; we''ve already written part
    of it, but here''s the whole new and improved version:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到我们控制器的`index`函数；我们已经编写了其中的一部分，但这里是整个新改进的版本：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As earlier, we render the list of users and the login form. However, we're also
    rendering our new rooms collection in the appropriate collection view in the `rooms`
    region of the layout. Then, we listen for the `user-added` event on the login
    form. Remember, that event will be emitted when a user successfully joins the
    site. When that happens, we'll render a different view in the `controls` region;
    the view to create a new room. We can't forget to give that view the collection,
    to which it can add the new room. The Backbone `on` method takes a context variable
    as a third parameter, so we can use `this` inside the callback.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们渲染用户列表和登录表单。然而，我们还在布局的`rooms`区域中渲染我们的新房间集合。然后，我们在登录表单上监听`user-added`事件。记住，当用户成功加入网站时，该事件将被触发。当发生这种情况时，我们将在`controls`区域渲染不同的视图；创建新房间的视图。我们不能忘记给这个视图提供集合，以便它可以添加新房间。Backbone的`on`方法将上下文变量作为第三个参数，因此我们可以在回调函数中使用`this`。
- en: 'Now, if you test our application, you''ll see that after you put in a screen
    name, the form will change and ask for a room name, as shown in the following
    screenshots:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你测试我们的应用程序，你会看到在你输入屏幕名称后，表单将改变并要求输入房间名称，如下面的截图所示：
- en: '![Joining a room](img/6997OS_05_03.jpg)![Joining a room](img/6997OS_05_04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![加入房间](img/6997OS_05_03.jpg)![加入房间](img/6997OS_05_04.jpg)'
- en: Of course, there's no list of room names to choose from as we haven't stored
    any messages yet, but if you look at the DOM, you'll see the empty `<ul>` element
    waiting. Type in a room name and click on the button, and two things should happen.
    First, the room name should appear on screen in a list. Second, the URL will change
    to the room route.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有可供选择的房间名称列表，因为我们还没有存储任何消息，但如果你查看DOM，你会看到等待的空`<ul>`元素。输入一个房间名称并点击按钮，应该发生两件事。首先，房间名称应该出现在屏幕上的列表中。其次，URL将更改为房间路由。
- en: 'This URL change means we need to add a route to our `Router` class. In the
    `appRoutes` property, add this line of code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL更改意味着我们需要向我们的`Router`类中添加一个路由。在`appRoutes`属性中，添加以下代码行：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This means that we need to create a `room` method on our controller prototype.
    Before we write the method, think of this; if choosing a room sends our user to
    the room route, it's also possible that the user could directly to the route.
    If they do this, the room will be selected, but the user will not have chosen
    a screen name. This means that this method will have to check for the presence
    of a screen name, and if a screen name hasn't been given, we'll have to get one
    before showing the room.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要在我们的控制器原型上创建一个`room`方法。在我们编写这个方法之前，考虑一下这个问题；如果选择房间将用户发送到房间路由，那么用户也可能直接访问这个路由。如果他们这样做，房间将被选择，但用户没有选择屏幕名。这意味着这个方法将必须检查屏幕名的存在，如果没有提供屏幕名，我们将在显示房间之前获取一个。
- en: 'First, as it is possible that this route will be loaded directly (and not via
    Backbone through the room link), we''ll need to render the user list and the room
    list. Since we''ll do this first in all the routes we will end up creating, let''s
    move that into a helper function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为这个路由可能会直接加载（而不是通过Backbone通过房间链接），我们需要渲染用户列表和房间列表。由于我们将在我们最终创建的所有路由中首先做这件事，让我们将其移动到一个辅助函数中：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `showUsersAndRooms` method on the controller prototype renders those views
    in the right regions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器原型上的`showUsersAndRooms`方法在正确的区域渲染这些视图。
- en: 'Let''s write one more helper function. As we figured out, if the user hasn''t
    selected a screen name yet, we''ll need to display the same view we''re showing
    in the `index` route: `logInView`. So let''s write a `showLogin` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个辅助函数。正如我们之前所想的那样，如果用户还没有选择一个屏幕名，我们需要显示我们在`index`路由中显示的相同视图：`logInView`。所以让我们写一个`showLogin`函数：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll create `loginView`, display it in the `controls` region, and then return
    the view. We return it because the route function that calls this helper function
    will probably want to listen for that `user-added` event. With these two helper
    functions in place, we can really clean up the `index` function as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`loginView`，在`controls`区域显示它，然后返回视图。我们返回它是因为调用这个辅助函数的路由函数可能希望监听那个`user-added`事件。有了这两个辅助函数，我们真的可以清理`index`函数，如下所示：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, the reason for creating these helper functions is that they''ll also
    be useful in the room route function we need to create:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建这些辅助函数的原因是它们在我们需要创建的房间路由函数中也将非常有用：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We first render the users and rooms lists. Then, we set a property on our global
    `App` object for the room that the user chooses to view. Then, we check to see
    whether `App.name` is set. If the user has come from the `index` route (or has
    switched rooms by clicking on a link from the list), `App.name` will be set. If
    it isn't set, we'll show the login form. If the name is set, or after the name
    is set (determined by the `user-added` event we're listening for), we'll need
    to render the chat room conversation. To do this, we need to create the `Chat`
    module.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先渲染用户和房间列表。然后，我们在全局`App`对象上设置一个属性，用于显示用户选择的房间。然后，我们检查`App.name`是否已设置。如果用户是从`index`路由（或通过点击列表中的链接切换房间）来的，`App.name`将会被设置。如果没有设置，我们将显示登录表单。如果设置了名字，或者设置名字之后（由我们监听的`user-added`事件确定），我们需要渲染聊天室对话。为了做到这一点，我们需要创建`Chat`模块。
- en: Building the chat module
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天模块
- en: 'To create the `Chat` module, we''ll create the `chat.js` file within `public`.
    Once again, we''ll start with the model and collection classes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`Chat`模块，我们将在`public`目录下创建一个`chat.js`文件。再次，我们将从模型和集合类开始：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Message` model is very simple, but the `Chat.Collection` class is a little
    more interesting. First, notice that this function takes two parameters: `models`
    and `options`. We never actually expect to receive any models, but it is a Backbone
    convention for a collection to receive these two parameters. So, we''ll follow
    this convention. We expect that option''s object to have the name of the room
    that these messages are in. Once we have that name, we can emit the `room:join`
    event with two parameters: the name of the room and a callback function. The function
    is this collection''s `add` method. We expect the server to call the callback
    function with a list of all the messages currently in the room. Then, for all
    messages created after the collection is created, the server will emit a `message:new`
    event. We''ll pick up on this `message:new` event here, and if the room on the
    new message is in the same room as the room this `Chat.Collection` instance is
    for, we''ll add it to the collection.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`模型非常简单，但`Chat.Collection`类要有趣一些。首先，请注意，这个函数接受两个参数：`models`和`options`。我们实际上并不期望收到任何模型，但这是Backbone约定，集合接收这两个参数。因此，我们将遵循这个约定。我们期望`options`对象包含这些消息所在的房间名称。一旦我们有了这个名称，我们就可以发出带有两个参数的`room:join`事件：房间的名称和一个回调函数。这个函数是这个集合的`add`方法。我们期望服务器调用回调函数，并传递当前房间中所有消息的列表。然后，对于在集合创建后创建的所有消息，服务器将发出`message:new`事件。我们将在这里捕获这个`message:new`事件，如果新消息的房间与这个`Chat.Collection`实例对应的房间相同，我们将将其添加到集合中。'
- en: 'Also, we''ll add item and collection views as we''ve done before. Here''s how
    that works:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还会添加项目和集合视图，就像我们之前做的那样。以下是它是如何工作的：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `MessageView` is simple: a list item element that will render the message
    template. Here''s that template:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageView`很简单：一个用于渲染消息模板的列表项元素。以下是该模板：'
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Every message will have a user name, the text of the message, and the date and
    time when the message was created. Notice that we're not displaying the date value
    as it is. Instead, we use the Moment library to convert that date to a string
    such as `10 minutes ago`. As we've done in previous applications, we can go ahead
    and download Moment ([http://momentjs.com](http://momentjs.com)) and add the appropriate
    script tag to `index.ejs`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息都将包含用户名、消息文本以及消息创建的日期和时间。请注意，我们没有直接显示日期值。相反，我们使用Moment库将日期转换为类似于`10分钟前`的字符串。就像我们在之前的应用程序中所做的那样，我们可以继续下载Moment（[http://momentjs.com](http://momentjs.com)）并将适当的脚本标签添加到`index.ejs`中。
- en: The `CollectionView` makes use of the `onRender` function in an interesting
    way. After the view renders, this function will set a timeout, to recall the `render`
    method again in 60 seconds. This is done so that the *time ago* timestamp will
    update on our message views.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionView`以一种有趣的方式使用了`onRender`函数。在视图渲染后，这个函数将设置一个超时，以便在60秒后再次调用`render`方法。这样做是为了确保我们的消息视图中的*时间前*时间戳会更新。'
- en: 'The last view for this module is the `Chat.CreateMessageView` view:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块的最后一个视图是`Chat.CreateMessageView`视图：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is very similar to our other two form views. We have the model for setting
    the placeholder and button text. Then, when we click on the button, we run the
    `addMessage` method. This method will prevent the form from getting submitted,
    and then emit a `message:new` event to the server. As data, we get the user's
    name, the text in the input element, the name of the room that the user is currently
    in, and the current date and time. All this data is sent to the server. Then,
    we clear the input element, and focus it for the next message.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前的两个表单视图非常相似。我们有一个用于设置占位符和按钮文本的模型。然后，当我们点击按钮时，我们运行`addMessage`方法。这个方法将阻止表单提交，并向服务器发出`message:new`事件。作为数据，我们获取用户的姓名、输入元素中的文本、用户当前所在的房间名称以及当前日期和时间。所有这些数据都发送到服务器。然后，我们清除输入元素，并使其聚焦于下一条消息。
- en: Now that we're done with `chat.js`, add it to the `index.ejs` file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`chat.js`，将其添加到`index.ejs`文件中。
- en: 'So what happens on the server? Well, that''s where we listen for the the `message:new`
    event:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那么服务器上会发生什么？嗯，这就是我们监听`message:new`事件的地方：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When that happens, we'll insert the data into the database. Once it has been
    successfully saved, we'll emit the `message:new` event to all connected clients.
    Those viewing the room this message was in will see it almost immediately. We
    also search the database for records in the same room. If a user has started a
    new chat room, there will be only one message with that room name (the one we
    just saved). However, this also means that all the other clients don't yet have
    this room in their `Room.Collection` object. So, we'll send them all a `room:new`
    event with the room's name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，我们将数据插入数据库。一旦成功保存，我们将向所有连接的客户端发出`message:new`事件。那些查看此消息所在房间的用户将几乎立即看到它。我们还搜索数据库中相同房间的记录。如果一个用户已经开始了一个新的聊天室，那么将只有一个带有该房间名称的消息（我们刚刚保存的那个）。然而，这也意味着所有其他客户端的`Room.Collection`对象中还没有这个房间。因此，我们将向他们所有人发送一个带有房间名称的`room:new`事件。
- en: Back to the controller
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到控制器
- en: 'With the `Chat` module created, we can turn back to the controller, where we
    want to render the chat for the chosen room. Let''s create a helper function for
    this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Chat`模块后，我们可以回到控制器，我们想要为所选房间渲染聊天。让我们为这个功能创建一个辅助函数：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `controls` region, we put `Chat.CreateMessageView`. Then, in the `conversation`
    region, we render a `Chat.CollectionView` instance. Now, in our `Controller.prototype.room`
    method, we can call this `showChat` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`controls`区域，我们放置`Chat.CreateMessageView`。然后，在`conversation`区域，我们渲染一个`Chat.CollectionView`实例。现在，在我们的`Controller.prototype.room`方法中，我们可以调用这个`showChat`方法：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, this route is complete. Once we have a name, we'll show the chat messages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个路由已经完成。一旦我们有一个名字，我们将显示聊天消息。
- en: Adding some other routes
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些其他路由
- en: Right now, we have two routes. However, we want to add a few more. Next, we'll
    add a `/user/:name` route, so that the user can skip the logging-in step. For
    example, I could go directly to `http://localhost:3000/user/Andrew`, and I wouldn't
    have to log in; I could just choose a room. While this may not be practical or
    realistic, I think it's a fun touch that is very simple to add.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有两个路由。然而，我们还想添加一些。接下来，我们将添加一个`/user/:name`路由，这样用户就可以跳过登录步骤。例如，我可以直接访问`http://localhost:3000/user/Andrew`，我就不需要登录；我可以选择一个房间。虽然这可能不实用或不现实，但我认为这是一个有趣的功能，而且很容易添加。
- en: 'In the router class, add the following route:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由器类中，添加以下路由：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s write this method in the controller as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个方法在控制器中编写如下：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, we'll call our `showUsersAndRooms` helper method to display the lists
    of users and rooms. Then, we'll call the user collection's `addUser` method. Remember
    that this method will decide whether the user can use the screen name they chose.
    Since the screen name is part of the URL, we get it as a parameter to the function.
    In the callback function, if the user has successfully joined, we'll display `CreateRoomView`
    where they can start a new room (alternatively, they can click on a room in the
    rooms list). Otherwise, we'll redirect them to the root route where they can choose
    an unused screen name.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将调用我们的`showUsersAndRooms`辅助方法来显示用户和房间的列表。然后，我们将调用用户集合的`addUser`方法。记住，这个方法将决定用户是否可以使用他们选择的屏幕名。由于屏幕名是URL的一部分，我们将其作为函数的参数获取。在回调函数中，如果用户成功加入，我们将显示`CreateRoomView`，他们可以在其中开始一个新的房间（或者他们也可以点击房间列表中的一个房间）。否则，我们将将他们重定向到根路由，他们可以在那里选择一个未使用的屏幕名。
- en: 'So, we''ve made it possible for someone coming to our application to choose
    either their screen name or a room right from the URL. Why don''t we take it one
    step further and allow users to do both? We can make it work in both ways:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使来我们应用程序的人可以选择他们的屏幕名或直接从URL中选择房间。为什么我们不更进一步，允许用户同时做这两件事？我们可以使两种方式都起作用：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the router, add the following lines of code to the `appRoutes` property:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由器中，将以下代码行添加到`appRoutes`属性中：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ll start with the `room_user` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`room_user`方法开始：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We start by calling `showUsersAndRooms` again. Then, we get the room model through
    the name given to us in the URL. Lastly, we try to log the user in. If they join
    successfully, we'll show the chat room they chose. If they need to pick another
    screen name, we'll redirect them to the URL for that room.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先再次调用`showUsersAndRooms`。然后，我们通过URL中给出的名称获取房间模型。最后，我们尝试登录用户。如果他们成功加入，我们将显示他们选择的聊天室。如果他们需要选择另一个屏幕名，我们将将他们重定向到该房间的URL。
- en: 'With this in place, the `user_room` method simply switches the order of the
    parameters:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，`user_room`方法只是简单地交换了参数的顺序：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With that, we have all the functionality we need in place! Our application is
    just about finished. All it needs now is a coat of paint.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就已经放置了所有需要的功能！我们的应用几乎完成了。现在它只需要一点装饰。
- en: Writing CSS
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写CSS
- en: Since styling isn't the main purpose of this book, we've left this for the end;
    if you aren't interested, jump to the chapter summary.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于样式化不是本书的主要目的，所以我们将其放在了最后；如果你不感兴趣，可以跳到章节概述。
- en: 'While our application is functioning very well right now, it''s certainly not
    easy on the eyes. Let''s fix that. First, we''ll link to a stylesheet from the
    `<head>` element in the `index.ejs` file as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的应用现在运行得非常好，但它确实对眼睛不太友好。让我们来修复这个问题。首先，我们将从`index.ejs`文件中的`<head>`元素链接到一个样式表，如下所示：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, create that file in `style.css` within `public`. We''ll start with some
    generic styling:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`public`目录下创建一个名为`style.css`的文件。我们将从一些通用的样式开始：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It's really just a mini reset; we use several `<ul>` elements in this application,
    so this will be important.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上只是一个微小的重置；我们在本应用中使用了多个`<ul>`元素，所以这一点很重要。
- en: 'The next few lines of code are mainly for styling the list of users:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行代码主要是为了样式化用户列表：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The users and room lists will be the sidebars on the left and right, respectively.
    We'll set their width and margin, shrink the font size a bit, and then float them
    to the left. We then do some basic styling for the user list items. You'll recall
    that we added the `highlight` class to the user view for the logged-in user; we're
    defining that class here.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和房间列表将分别位于左侧和右侧的侧边栏。我们将设置它们的宽度和边距，稍微缩小字体大小，然后将它们浮动到左侧。然后我们对用户列表项进行一些基本的样式化。你会记得我们为登录用户在用户视图中添加了`highlight`类；我们在这里定义这个类。
- en: 'Next, we style the list of rooms with these lines:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用这些行来样式化房间列表：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Then, we provide some styling for the user list; it's a bit more complex as
    the list items have anchor elements inside them. Of course, we add some basic
    hover styling.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为用户列表提供一些样式；由于列表项内部有锚点元素，所以它稍微复杂一些。当然，我们添加了一些基本的悬停样式。
- en: 'Next, we style the conversation itself:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为对话本身添加样式：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `conversation` region goes in the middle, between the two sidebars, so it
    is important that it be floated to the left-hand side as well. The `<span>` element
    we style is where the date and time of the message will be displayed, so we shrink
    the text a bit, and move it to the right.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`conversation`区域位于中间，在两个侧边栏之间，因此它也很重要，需要将其浮动到左侧。我们样式化的`<span>`元素是显示消息日期和时间的地方，所以我们稍微缩小了文本，并将其移动到右边。'
- en: 'Finally, we style the controls:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为控件添加样式：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The last portion of the CSS styles is the `control` region. This is where all
    the forms will be displayed. We're doing something a bit different here. We're
    using a position that is fixed to attach it to the bottom of the screen. Now,
    the conversation can get as long as it wants, but the message form will always
    be visible.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: CSS样式的最后一部分是`control`区域。这是所有表单将被显示的地方。在这里我们做了一些不同的事情。我们使用了一个固定位置来将其附着到屏幕的底部。现在，对话可以无限延长，但消息表单始终可见。
- en: 'Now, the code is complete. The following is a screenshot of the final application
    in use:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码已经完成。以下是在使用中的最终应用的截图：
- en: '![Writing CSS](img/6997OS_05_02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![编写CSS](img/6997OS_05_02.jpg)'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: I hope you found this chapter interesting. The biggest idea we've looked at
    here is using Marionette instead of plain Backbone to build our application. As
    you've seen, when using a framework designed for large applications, there's a
    lot more of what you might call scaffolding code. Basing everything on an application
    object, using modules, splitting routers and controllers, it all makes for a lot
    more moving parts. Here's the thing; the application we've built here really can't
    be called large, so you might think it doesn't really make that much sense to
    use Marionette. However, if you've worked on any large projects, you know that
    the more code that's involved, the more you'll appreciate the constructs that
    a framework like Marionette gives you. That extra level of boundaries is certainly
    not required, but I think you'll find that it can be extremely helpful and that
    it keeps a huge project manageable as it grows and changes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你觉得这一章很有趣。我们在这里探讨的最大想法是使用Marionette而不是普通的Backbone来构建我们的应用。正如你所看到的，当使用为大型应用设计的框架时，会有更多你可能称之为脚手架代码的东西。基于应用对象，使用模块，分割路由器和控制器，这些都使得应用有更多的可移动部分。这里的关键是，我们构建的应用实际上并不能称为大型应用，所以你可能认为使用Marionette并不真的那么有意义。然而，如果你参与过任何大型项目，你就会知道，涉及的代码越多，你就越会欣赏Marionette这样的框架为你提供的结构。那个额外的边界层当然不是必需的，但我认为你会发现它可能非常有帮助，并且随着项目的增长和变化，它可以帮助保持大型项目的管理。
- en: The other big idea in this chapter was Socket.IO. In this application, we completely
    ignored the built-in syncing channels that Backbone gives us, but as I mentioned
    earlier, that's not the only way it can be done. Now would be a good time to go
    back and look at the implementation of `Backbone.sync` using Socket.IO, and maybe
    even build a small application to test it. The bigger thing to take away from
    the way in which we used Socket.IO is that Backbone is just another tool, and
    there's no one right way to use it. Don't ignore the conventions and suggestions
    of the Backbone community, but don't be afraid to bend it to your will and see
    what happens. We'll do more of this in the next chapter when we create a podcast
    subscription application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的另一个重要概念是Socket.IO。在这个应用中，我们完全忽略了Backbone为我们提供的内置同步通道，但正如我之前提到的，这并不是唯一的方法。现在是一个很好的时机去回顾使用Socket.IO实现`Backbone.sync`的方式，甚至可以构建一个小型应用来测试它。从我们使用Socket.IO的方式中可以吸取的更大的一点是，Backbone只是一个工具，并没有一种正确的方式来使用它。不要忽视Backbone社区的传统和建议，但也不必害怕根据你的意愿调整它，看看会发生什么。在下一章中，当我们创建一个播客订阅应用时，我们会做更多类似的事情。
