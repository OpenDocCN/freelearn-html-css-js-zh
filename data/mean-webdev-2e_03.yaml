- en: Chapter 3. Building an Express Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。构建一个Express Web应用程序
- en: 'This chapter will cover the proper way to build your first Express application.
    You''ll begin by installing and configuring the Express module and then learning
    about Express'' main APIs. We''ll discuss Express request, response, and application
    objects and learn how to use them. We''ll then cover the Express routing mechanism
    and learn how to properly use it. We''ll also discuss the structure of the application
    folder and how you can utilize different structures for different project types.
    By the end of this chapter, you''ll learn how to build a complete Express application.
    In this chapter, we''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍构建你的第一个Express应用程序的正确方法。你将首先安装和配置Express模块，然后学习Express的主要API。我们将讨论Express请求、响应和应用程序对象，并学习如何使用它们。然后我们将介绍Express路由机制，并学习如何正确使用它。我们还将讨论应用程序文件夹的结构以及如何利用不同的结构来处理不同的项目类型。在本章结束时，你将学会如何构建一个完整的Express应用程序。在本章中，我们将涵盖以下主题：
- en: Installing Express and creating a new Express application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Express并创建一个新的Express应用程序
- en: Organizing your project's structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织你的项目结构
- en: Configuring your Express application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置你的Express应用程序
- en: Using the Express routing mechanism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express路由机制
- en: Rendering EJS views
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染EJS视图
- en: Serving static files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Configuring an Express session
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Express会话
- en: Introducing Express
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Express
- en: To say that TJ Holowaychuk is a productive developer would be a huge understatement.
    TJ's involvement in the Node.js community is almost unmatched by any other developer,
    and with more than 500 open source projects, he's responsible for some of the
    most popular frameworks in the JavaScript ecosystem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 说TJ Holowaychuk是一个富有成效的开发者几乎是一个巨大的低估。TJ在Node.js社区的参与几乎是任何其他开发者无法比拟的，他负责一些JavaScript生态系统中最受欢迎的框架，拥有500多个开源项目。
- en: One of his greatest projects is the Express web framework. The Express framework
    is a small set of common web application features kept to a minimum in order to
    maintain the Node.js style. It is built on top of Connect and makes use of its
    middleware architecture. Its features extend Connect to allow a variety of common
    web application use cases, such as the inclusion of modular HTML template engines,
    extending the response object to support various data format outputs, a routing
    system, and much more.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 他最伟大的项目之一是Express web框架。Express框架是一组常见的Web应用程序功能的最小集合，以保持Node.js风格。它建立在Connect之上，并利用其中间件架构。其功能扩展Connect，允许各种常见的Web应用程序用例，例如包含模块化HTML模板引擎，扩展响应对象以支持各种数据格式输出，路由系统等等。
- en: So far, we have used a single `server.js` file to create our application. However,
    when using Express, you'll learn more about better project structure, properly
    configuring your application, and breaking your application logic into different
    modules. You'll also learn how to use the EJS template engine, manage sessions,
    and add a routing scheme. By the end of this section, you'll have a working application
    skeleton that you'll use for the rest of the book. Let's begin the journey of
    creating your first Express application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了一个`server.js`文件来创建我们的应用程序。然而，使用Express时，你将学习更多关于更好的项目结构，正确配置你的应用程序，并将应用程序逻辑分解为不同的模块。你还将学习如何使用EJS模板引擎，管理会话，并添加路由方案。在本节结束时，你将拥有一个可用的应用程序框架，你将在本书的其余部分中使用它。让我们开始创建你的第一个Express应用程序的旅程。
- en: Installing Express
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Express
- en: 'Up until now, we used npm to directly install external modules for our Node
    application. You could, of course, use this approach and install Express by typing
    the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用npm直接为我们的Node应用程序安装外部模块。当然，你可以使用这种方法，并通过输入以下命令来安装Express：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, directly installing modules isn''t really scalable. Think about it
    for a bit: you''re going to use many Node modules in your application, transfer
    it between working environments, and probably share it with other developers.
    So, installing the project modules this way will soon become a dreadful task.
    Instead, you should start using the `package.json` file, which organizes your
    project metadata and helps you manage your application dependencies. Begin by
    creating a new working folder and a new `package.json` file inside it, which contains
    the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，直接安装模块并不是真正可扩展的。想一想：你将在应用程序中使用许多Node模块，在工作环境之间传输它，并且可能与其他开发人员共享它。因此，以这种方式安装项目模块很快就会变成一项可怕的任务。相反，你应该开始使用`package.json`文件，它可以组织项目元数据并帮助你管理应用程序的依赖关系。首先，创建一个新的工作文件夹，并在其中创建一个新的`package.json`文件，其中包含以下代码片段：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `package.json` file, note that you included three properties: the name
    and version of your application and the dependencies property, which defines what
    modules should be installed before your application can run. To install your application
    dependencies, use your command-line tool and navigate to your application folder,
    and then issue the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中，注意到你包含了三个属性：应用程序的名称和版本，以及依赖属性，它定义了在应用程序运行之前应安装哪些模块。要安装应用程序的依赖项，请使用命令行工具并导航到应用程序文件夹，然后发出以下命令：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: npm will then install the Express module because, currently, it is the only
    dependency defined in your `package.json` file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: npm然后会安装Express模块，因为目前它是在你的`package.json`文件中定义的唯一依赖项。
- en: Creating your first Express application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个Express应用程序
- en: 'After creating your `package.json` file and installing your dependencies, you
    can create your first Express application by adding your already familiar `server.js`
    file with the following lines of code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的第一个Express应用程序
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should have already recognized most of the code. The first two lines require
    the Express module and create a new Express application object. Then, we use the
    `app.use()` method to mount a middleware function with a specific path and the
    `app.listen()` method to tell the Express application to listen to port `3000`.
    Note how the `module.exports` object is used to return the `app` object. This
    will later help you load and test your Express application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经认识到大部分代码了。前两行需要Express模块并创建一个新的Express应用程序对象。然后，我们使用`app.use()`方法来挂载一个具有特定路径的中间件函数，以及`app.listen()`方法来告诉Express应用程序监听端口`3000`。注意`module.exports`对象是如何用于返回`app`对象的。这将帮助你加载和测试你的Express应用程序。
- en: This new code should also be familiar to you because it resembles the code you
    used in the previous Connect example. This is because Express wraps the Connect
    module in several ways. The `app.use()` method is used to mount a middleware function,
    which will respond to any HTTP request made to the root path. Inside the middleware
    function, the `res.status()` method is then used to set the HTTP response code,
    and the `res.send()` method is used to send the response back. The `res.send()`
    method is basically an Express wrapper that sets the Content-Type header according
    to the response object type and then sends a response back using the Connect `res.end()`
    method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码对你来说也应该很熟悉，因为它类似于你在之前的Connect示例中使用的代码。这是因为Express以多种方式包装了Connect模块。`app.use()`方法用于挂载一个中间件函数，该函数将响应任何发送到根路径的HTTP请求。在中间件函数内部，`res.status()`方法用于设置HTTP响应代码，`res.send()`方法用于发送响应。`res.send()`方法基本上是一个Express包装器，根据响应对象类型设置Content-Type标头，然后使用Connect的`res.end()`方法发送响应。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When passing a buffer to the `res.send()` method, the Content-Type header will
    be set to `application/octet-stream`; when passing a string, it will be set to
    `text/html`; and when passing an object or an array, it will be set to `application/json`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当将缓冲区传递给`res.send()`方法时，Content-Type标头将设置为`application/octet-stream`；当传递字符串时，它将设置为`text/html`；当传递对象或数组时，它将设置为`application/json`。
- en: 'To run your application, simply execute the following command in your command-line
    tool:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你的应用程序，只需在命令行工具中执行以下命令：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations! You have just created your first Express application. You can
    test it by visiting `http://localhost:3000` in your browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了你的第一个Express应用程序。你可以通过访问`http://localhost:3000`在浏览器中测试它。
- en: The application, request, and response objects
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序、请求和响应对象
- en: Express presents three major objects that you'll frequently use. The application
    object is the instance of an Express application you created in the first example
    and is usually used to configure your application. The request object is a wrapper
    of Node's HTTP request object and is used to extract information about the currently
    handled HTTP request. The response object is a wrapper of Node's HTTP response
    object and is used to set the response data and headers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Express提供了三个主要对象，你会经常使用它们。应用对象是你在第一个例子中创建的Express应用程序的实例，通常用于配置你的应用程序。请求对象是Node的HTTP请求对象的包装器，用于提取关于当前处理的HTTP请求的信息。响应对象是Node的HTTP响应对象的包装器，用于设置响应数据和标头。
- en: The application object
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用对象
- en: 'The application object contains the following methods to help you configure
    your application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 应用对象包含以下方法，帮助你配置你的应用程序：
- en: '`app.set(name, value)`: This is a method used to set environment variables
    that Express will use in its configuration.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.set(name, value)`: 这是一个用于设置Express将在其配置中使用的环境变量的方法。'
- en: '`app.get(name)`: This is a method used to get environment variables that Express
    is using in its configuration.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.get(name)`: 这是一个用于获取Express在其配置中使用的环境变量的方法。'
- en: '`app.engine(ext, callback)`: This is a method used to define a given template
    engine to render certain file types; for example, you can tell the EJS template
    engine to use HTML files as templates like this: `app.engine(''html'', require(''ejs'').renderFile)`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.engine(ext, callback)`: 这是一个用于定义给定模板引擎以渲染特定文件类型的方法；例如，你可以告诉EJS模板引擎使用HTML文件作为模板，就像这样：`app.engine(''html'',
    require(''ejs'').renderFile)`。'
- en: '`app.locals`: This is a property used to send application-level variables to
    all rendered templates.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.locals`: 这是一个用于向所有渲染的模板发送应用级变量的属性。'
- en: '`app.use([path], callback)`: This is a method used to create an Express middleware
    to handle HTTP requests sent to the server. Optionally, you''ll be able to mount
    middleware to respond to certain paths.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.use([path], callback)`: 这是一个用于创建Express中间件来处理发送到服务器的HTTP请求的方法。可选地，你可以挂载中间件来响应特定路径。'
- en: '`app.VERB(path, [callback...], callback)`: This is used to define one or more
    middleware functions to respond to HTTP requests made to a certain path in conjunction
    with the HTTP verb declared. For instance, when you want to respond to requests
    that are using the GET verb, you can just assign the middleware using the `app.get()`
    method. For POST requests, you''ll use `app.post()`, and so on.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.VERB(path, [callback...], callback)`: 这用于定义一个或多个中间件函数来响应与声明的HTTP动词一起使用的特定路径的HTTP请求。例如，当你想要响应使用GET动词的请求时，你可以使用`app.get()`方法来分配中间件。对于POST请求，你将使用`app.post()`，依此类推。'
- en: '`app.route(path).VERB([callback...], callback)`: This is a method used to define
    one or more middleware functions to respond to HTTP requests made to a certain
    unified path in conjunction with multiple HTTP verbs. For instance, when you want
    to respond to requests that are using the GET and POST verbs, you can just assign
    the appropriate middleware functions using `app.route(path).get(callback).post(callback)`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.route(path).VERB([callback...], callback)`: 这是一个用于定义一个或多个中间件函数来响应与多个HTTP动词一起使用的特定统一路径的HTTP请求的方法。例如，当你想要响应使用GET和POST动词的请求时，你可以使用`app.route(path).get(callback).post(callback)`来分配适当的中间件函数。'
- en: '`app.param([name], callback)`: This is a method used to attach a certain functionality
    to any request made to a path that includes a certain routing parameter. For instance,
    you can map logic to any request that includes the `userId` parameter using `app.param(''userId'',
    callback)`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.param([name], callback)`: 这是一种方法，用于将特定功能附加到包含特定路由参数的路径上发出的任何请求。例如，您可以使用`app.param(''userId'',
    callback)`将逻辑映射到包含`userId`参数的任何请求。'
- en: There are many more application methods and properties you can use, but using
    these common basic methods enables developers to extend Express in whichever way
    they find reasonable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用许多其他应用程序方法和属性，但使用这些常见的基本方法使开发人员能够以他们认为合理的方式扩展Express。
- en: The request object
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求对象
- en: 'The request object also provides a handful of helping methods that contain
    the information you need about the current HTTP request. The key properties and
    methods of the request object are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象还提供了一些有助于包含有关当前HTTP请求的信息的方法。请求对象的关键属性和方法如下：
- en: '`req.query`: This is a property that contains the parsed query-string parameters.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req.query`: 这是一个包含解析后的查询字符串参数的属性。'
- en: '`req.params`: This is a property that contains the parsed routing parameters.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req.params`: 这是一个包含解析后的路由参数的属性。'
- en: '`req.body`: This is a property that''s used to retrieve the parsed request
    body. It is included in the `bodyParser()` middleware.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req.body`: 这是用于检索解析后的请求体的属性。它包含在`bodyParser()`中间件中。'
- en: '`req.path` / `req.hostname` / `req.ip`: These are used to retrieve the current
    request path, hostname, and remote IP.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req.path` / `req.hostname` / `req.ip`: 这些用于检索当前请求的路径、主机名和远程IP。'
- en: '`req.cookies`: This is a property used in conjunction with the `cookieParser()`
    middleware to retrieve the cookies sent by the user agent.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req.cookies`: 这是与`cookieParser()`中间件一起使用的属性，用于检索用户代理发送的cookie。'
- en: The request object contains many more methods and properties that we'll discuss
    later in this book, but these methods are what you'll usually use in a common
    web application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象包含许多我们将在本书后面讨论的方法和属性，但这些方法通常是您在常见的Web应用程序中使用的。
- en: The response object
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应对象
- en: 'The response object is frequently used when developing an Express application
    because any request sent to the server will be handled and responded to using
    the response object methods. It has several key methods, which are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象在开发Express应用程序时经常使用，因为发送到服务器的任何请求都将使用响应对象方法进行处理和响应。它有几个关键方法，如下所示：
- en: '`res.status(code)`: This is a method used to set the response HTTP status code.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.status(code)`: 这是用于设置响应HTTP状态代码的方法。'
- en: '`res.set(field, [value])`: This is a method used to set the response HTTP header.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.set(field, [value])`: 这是用于设置响应HTTP标头的方法。'
- en: '`res.cookie(name, value, [options])`: This is a method used to set a response
    cookie. The options argument is used to pass an object that defines common cookie
    configuration, such as the `maxAge` property.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.cookie(name, value, [options])`: 这是用于设置响应cookie的方法。选项参数用于传递定义常见cookie配置的对象，例如`maxAge`属性。'
- en: '`res.redirect([status], url)`: This is a method used to redirect the request
    to a given URL. Note that you can add an HTTP status code to the response. When
    not passing a status code, it will be defaulted to `302 Found`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.redirect([status], url)`: 这是用于将请求重定向到给定URL的方法。请注意，您可以向响应添加HTTP状态代码。当不传递状态代码时，它将默认为`302
    Found`。'
- en: '`res.status([status]).send( [body])`: This is a method used for non-streaming
    responses. It does a lot of background work, such as setting the Content-Type
    and Content-Length headers and responding with the proper cache headers.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.status([status]).send( [body])`: 这是用于非流式响应的方法。它会做很多后台工作，例如设置Content-Type和Content-Length标头，并使用适当的缓存标头进行响应。'
- en: '`res.status([status]).json( [body])`: This is identical to the `res.send()`
    method when sending an object or array. Most of the time, it is used as syntactic
    sugar, but sometimes you may need to use it to force a JSON response to non-objects,
    such as `null` or `undefined`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.status([status]).json( [body])`: 当发送对象或数组时，这与`res.send()`方法相同。大多数情况下，它被用作语法糖，但有时您可能需要使用它来强制将JSON响应发送到非对象，例如`null`或`undefined`。'
- en: '`res.render(view, [locals], callback)`: This is a method used to render a view
    and send an HTML response.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.render(view, [locals], callback)`: 这是用于呈现视图并发送HTML响应的方法。'
- en: The response object also contains many more methods and properties to handle
    different response scenarios, which you'll learn about later in this book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象还包含许多其他方法和属性，用于处理不同的响应场景，您将在本书后面学习到。
- en: External middleware
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部中间件
- en: 'The Express core is minimal, yet the team behind it provides various predefined
    middleware to handle common web development features. These types of middleware
    vary in size and functionality and extend Express to provide a better framework
    support. The popular Express middleware are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Express核心是最小的，但是背后的团队提供了各种预定义的中间件来处理常见的Web开发功能。这些类型的中间件在大小和功能上都有所不同，并扩展了Express以提供更好的框架支持。流行的Express中间件如下：
- en: '`morgan`: This is an HTTP request logger middleware.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`morgan`: 这是一个HTTP请求记录器中间件。'
- en: '`body-parser`: This is a body-parsing middleware that is used to parse the
    request body, and it supports various request types.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body-parser`: 这是一个用于解析请求体的中间件，它支持各种请求类型。'
- en: '`method-override`: This is a middleware that provides HTTP verb support, such
    as PUT or DELETE, in places where the client doesn''t support it.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method-override`: 这是一个提供HTTP动词支持的中间件，例如在客户端不支持的地方使用PUT或DELETE。'
- en: '`compression`: This is a compression middleware that is used to compress the
    response data using GZIP/deflate.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compression`: 这是一个压缩中间件，用于使用GZIP/deflate压缩响应数据。'
- en: '`express.static`: This is a middleware used to serve static files.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express.static`: 这是用于提供静态文件的中间件。'
- en: '`cookie-parser`: This is a cookie-parsing middleware that populates the `req.cookies`
    object.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie-parser`: 这是一个用于解析cookie的中间件，它填充了`req.cookies`对象。'
- en: '`Session`: This is a session middleware used to support persistent sessions.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Session`: 这是用于支持持久会话的会话中间件。'
- en: There are many more types of Express middleware that enable you to shorten your
    development time along with a larger number of third-party middleware.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种类型的Express中间件，可以帮助您缩短开发时间，同时还有更多的第三方中间件。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about the Connect and Express middleware, visit the Connect module's
    official repository page at [https://github.com/senchalabs/connect#middleware](https://github.com/senchalabs/connect#middleware).
    If you'd like to browse the third-party middleware collection, visit Connect's
    wiki page at [https://github.com/senchalabs/connect/wiki](https://github.com/senchalabs/connect/wiki).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Connect和Express中间件的信息，请访问Connect模块的官方存储库页面[https://github.com/senchalabs/connect#middleware](https://github.com/senchalabs/connect#middleware)。如果您想浏览第三方中间件集合，请访问Connect的wiki页面[https://github.com/senchalabs/connect/wiki](https://github.com/senchalabs/connect/wiki)。
- en: Implementing the MVC pattern
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现MVC模式
- en: The Express framework is pattern-agnostic, which means that it doesn't support
    any predefined syntax or structure, as some other web frameworks do. Applying
    the MVC pattern to your Express application means that you can create specific
    folders where you place your JavaScript files in a certain logical order. All
    these files are basically CommonJS modules that function as logical units. For
    instance, models will be CommonJS modules that contain a definition of Mongoose
    models placed in the `models` folder, views will be HTML or other template files
    placed in the `views` folder, and controllers will be CommonJS modules with functional
    methods placed in the `controllers` folder. To illustrate this better, it's time
    to discuss the different types of application structure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Express框架是模式不可知的，这意味着它不支持任何预定义的语法或结构，就像其他一些Web框架所做的那样。将MVC模式应用于您的Express应用程序意味着您可以创建特定的文件夹，将您的JavaScript文件按照一定的逻辑顺序放置在其中。所有这些文件基本上都是作为逻辑单元的CommonJS模块。例如，模型将是包含在`models`文件夹中的Mongoose模型定义的CommonJS模块，视图将是放置在`views`文件夹中的HTML或其他模板文件，控制器将是放置在`controllers`文件夹中的具有功能方法的CommonJS模块。为了更好地说明这一点，现在是讨论不同类型的应用程序结构的时候了。
- en: The application folder structure
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序文件夹结构
- en: 'We previously discussed better practices when developing a real application,
    where we recommended the use of the `package.json` file over directly installing
    your modules. However, this was only the beginning; once you continue developing
    your application, you''ll soon find yourself wondering how you should arrange
    your project files and break them into logical units of code. JavaScript, in general,
    and—consequently—the Express framework are agnostic about the structure of your
    application as you can easily place your entire application in a single JavaScript
    file. This is because no one expected JavaScript to be a full-stack programming
    language, but it doesn''t mean that you shouldn''t dedicate special attention
    to organizing your project. Since the MEAN stack can be used to build all sorts
    of applications that vary in size and complexity, it is also possible to handle
    the project structure in various ways. The decision is often directly related
    to the estimated complexity of your application. For instance, simple projects
    may require a leaner folder structure, which has the advantage of being clearer
    and easier to manage, while complex projects will often require a more complex
    structure and a better breakdown of logic since it will include many features
    and a bigger team working on the project. To simplify this discussion, it would
    be reasonable to divide it into two major approaches: a horizontal structure for
    smaller projects and a vertical structure for feature-rich applications. Let''s
    begin with a simple horizontal structure.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了在开发真实应用时的最佳实践，我们推荐使用`package.json`文件而不是直接安装模块。然而，这只是一个开始；一旦您继续开发应用程序，您很快会想知道如何安排项目文件并将它们分解为逻辑代码单元。总的来说，JavaScript和因此Express框架对于应用程序的结构是不可知的，因为你可以很容易地将整个应用程序放在一个JavaScript文件中。这是因为没有人预期JavaScript会成为一个全栈编程语言，但这并不意味着你不应该特别注意组织你的项目。由于MEAN堆栈可以用于构建各种大小和复杂度的应用程序，因此也可以以各种方式处理项目结构。决定往往直接与您的应用程序的预估复杂性有关。例如，简单的项目可能需要更简洁的文件夹结构，这样有利于更清晰和更容易管理，而复杂的项目通常需要更复杂的结构和更好的逻辑分解，因为它将包括许多功能和更大的团队在项目上工作。为了简化这个讨论，将其合理地分为两种主要方法：较小项目的水平结构和功能丰富应用程序的垂直结构。让我们从一个简单的水平结构开始。
- en: Horizontal folder structure
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平文件夹结构
- en: 'A horizontal project structure is based on the division of folders and files
    by their functional role rather than by the feature they implement, which means
    that all the application files are placed inside a main application folder that
    contains an MVC folder structure. This also means that there is a single `controllers`
    folder that contains all of the application controllers, a single `models` folder
    that contains all of the application models, and so on. An example of the horizontal
    application structure would be as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 水平项目结构是基于按功能角色划分文件夹和文件，而不是按照它们实现的功能来划分，这意味着所有应用程序文件都放在一个主应用程序文件夹中，其中包含一个MVC文件夹结构。这也意味着有一个单独的`controllers`文件夹，其中包含所有应用程序控制器，一个单独的`models`文件夹，其中包含所有应用程序模型，依此类推。水平应用程序结构的一个示例如下：
- en: '![Horizontal folder structure](img/B05071_03_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![水平文件夹结构](img/B05071_03_01.jpg)'
- en: 'Let''s review the folder structure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾一下文件夹结构：
- en: 'The `app` folder is where you keep your Express application logic, and it is
    divided into the following folders that represent a separation of functionality
    in order to comply with the MVC pattern:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`文件夹是您保存Express应用程序逻辑的地方，它分为以下文件夹，代表了功能的分离，以符合MVC模式：'
- en: The `controllers` folder is where you keep your Express application controllers
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllers`文件夹是您保存Express应用程序控制器的地方'
- en: The `models` folder is where you keep your Express application models
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`文件夹是您保存Express应用程序模型的地方'
- en: The `routes` folder is where you keep your Express application routing middleware
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`文件夹是您保存Express应用程序路由中间件的地方'
- en: The `views` folder is where you keep your Express application views
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`文件夹是您保存Express应用程序视图的地方'
- en: 'The `config` folder is where you keep your Express application configuration
    files. In time, you''ll add more modules to your application, and each module
    will be configured in a dedicated JavaScript file, which is placed inside this
    folder. Currently, it contains several files and folders, which are as follows:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`文件夹是您保存Express应用程序配置文件的地方。随着时间的推移，您将向应用程序添加更多模块，每个模块将在专用的JavaScript文件中进行配置，该文件放在此文件夹中。目前，它包含几个文件和文件夹，如下所示：'
- en: The `env` folder is where you'll keep your Express application environment's
    configuration files
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`文件夹是您保存Express应用程序环境配置文件的地方'
- en: The `config.js` file is where you'll configure your Express application
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.js`文件是您配置Express应用程序的地方'
- en: The `express.js` file is where you'll initialize your Express application
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express.js`文件是您初始化Express应用程序的地方'
- en: 'The `public` folder is where you keep your static client-side files, and it
    is divided into the following folders that represent a separation of functionalities
    in order to comply with the MVC pattern:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`文件夹是您保存静态客户端文件的地方，它分为以下文件夹，代表了功能的分离，以符合MVC模式：'
- en: The `config` folder is where you keep your Angular application configuration
    files
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`文件夹是您保存Angular应用程序配置文件的地方'
- en: The `components` folder is where you keep your Angular application components
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`文件夹是您保存Angular应用程序组件的地方'
- en: The `css` folder is where you keep your CSS files
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css`文件夹是您保存CSS文件的地方'
- en: The `directives` folder is where you keep your Angular application directives
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directives`文件夹是您保存Angular应用程序指令的地方'
- en: The `pipes` folder is where you keep your Angular application pipes
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipes`文件夹是您保存Angular应用程序管道的地方'
- en: The `img` folder is where you keep your image files
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img`文件夹是您保存图像文件的地方'
- en: The `templates` folder is where you keep your Angular application templates
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`文件夹是您保存Angular应用程序模板的地方'
- en: The `bootstrap.ts` file is where you initialize your Angular application
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap.ts`文件是您初始化Angular应用程序的地方'
- en: The `package.json` file is the metadata file that helps you organize your application
    dependencies.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`文件是帮助您组织应用程序依赖关系的元数据文件。'
- en: The `server.js` file is the main file of your Node.js application, and it will
    load the `express.js` file as a module in order to bootstrap your Express application.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.js`文件是您的Node.js应用程序的主文件，它将加载`express.js`文件作为模块，以启动您的Express应用程序。'
- en: As you can see, the horizontal folder structure is very useful for small projects
    where the number of features is limited so that files can be conveniently placed
    inside folders that represent their general roles. Nevertheless, in order to handle
    large projects, where you'll have many files that handle certain features, it
    might be too simplistic. In this case, each folder could be overloaded with too
    many files, and you'd get lost in the chaos. A better approach would be to use
    a vertical folder structure.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，水平文件夹结构对于功能有限的小型项目非常有用，因此文件可以方便地放在代表其一般角色的文件夹中。然而，为了处理大型项目，在那里您将有许多处理特定功能的文件，这可能太简单了。在这种情况下，每个文件夹可能会被过多的文件所超载，您可能会在混乱中迷失。更好的方法是使用垂直文件夹结构。
- en: Vertical folder structure
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垂直文件夹结构
- en: 'A vertical project structure is based on the division of folders and files
    by the feature they implement, which means that each feature has its own autonomous
    folder that contains an MVC folder structure. An example of the vertical application
    structure would be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直项目结构基于按功能实现的文件夹和文件的划分，这意味着每个功能都有自己独立的文件夹，其中包含一个MVC文件夹结构。垂直应用程序结构的示例如下：
- en: '![Vertical folder structure](img/B05071_03_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![垂直文件夹结构](img/B05071_03_02.jpg)'
- en: 'As you can see, each feature has its own application-like folder structure.
    In this example, we have the `core feature` folder that contains the main application
    files and the `feature` folder that includes the feature''s files. An example
    feature will be a user management feature that includes authentication and authorization
    logic. To understand this better, let''s review a single feature''s folder structure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个功能都有自己类似应用程序的文件夹结构。在这个例子中，我们有包含主应用程序文件的`core feature`文件夹和包含功能文件的`feature`文件夹。一个示例功能将是包含身份验证和授权逻辑的用户管理功能。为了更好地理解这一点，让我们来看一个单个功能的文件夹结构：
- en: 'The `server` folder is where you keep your feature''s server logic, and it
    is divided into the following folders that represent a separation of functionality
    in order to comply with the MVC pattern:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server`文件夹是您保存功能的服务器逻辑的地方，它分为以下文件夹，代表了功能的分离，以符合MVC模式：'
- en: The `controllers` folder is where you keep your feature's Express controllers
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllers`文件夹是您保存功能的Express控制器的地方'
- en: The `models` folder is where you keep your feature's Express models
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`文件夹是您保存功能的Express模型的地方'
- en: The `routes` folder is where you keep your feature's Express routing middleware
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`文件夹是您保存功能的Express路由中间件的地方'
- en: The `views` folder is where you keep your feature's Express views
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`文件夹是您保存功能的Express视图的地方'
- en: The `config` folder is where you keep your feature's server configuration files
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`文件夹是您保存功能服务器配置文件的地方'
- en: The `env` folder is where you keep your feature's environment server configuration
    files
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`文件夹是您保存功能环境服务器配置文件的地方'
- en: The `feature.server.config.js` file is where you configure your features
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feature.server.config.js`文件是您配置功能的地方'
- en: 'The `client` folder is where you keep your feature''s client-side files, and
    it is divided into the following folders that represent a separation of functionality
    in order to comply with the MVC pattern:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client`文件夹是您保存功能的客户端文件的地方，它分为以下文件夹，代表了功能的分离，以符合MVC模式：'
- en: The `config` folder is where you keep your feature's Angular configuration files
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`文件夹是您保存特性的Angular配置文件的地方'
- en: The `components` folder is where you keep your feature's Angular `components`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`components`文件夹是您保存特性的Angular `components`的地方'
- en: The `css` folder is where you keep your feature's CSS files
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css`文件夹是您保存特性的CSS文件的地方'
- en: The `directives` folder is where you keep your feature's Angular directives
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directives`文件夹是您保存特性的Angular指令的地方'
- en: The `pipes` folder is where you keep your feature's Angular pipes
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipes`文件夹是您保存特性的Angular管道的地方'
- en: The `img` folder is where you keep your feature's image files
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img`文件夹是您保存特性的图像文件的地方'
- en: The `templates` folder is where you keep your feature's Angular templates
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`文件夹是您保存特性的Angular模板的地方'
- en: The `feature.module.ts` file is where you initialize your feature's Angular
    module
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feature.module.ts`文件是您初始化特性的Angular模块的地方'
- en: As you can see, the vertical folder structure is very useful for large projects
    where the number of features is unlimited and each feature includes a substantial
    number of files. It will allow large teams to work together and maintain each
    feature separately, and it can also be useful in sharing features among different
    applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，垂直文件夹结构对于特性数量无限且每个特性包含大量文件的大型项目非常有用。它将允许大型团队共同工作并分别维护每个特性，并且在不同应用程序之间共享特性时也很有用。
- en: Although these are two distinctive types of most application structures, the
    reality is that the MEAN stack can be assembled in many different ways. It's even
    likely for a team to structure their project in a way that combines these two
    approaches; so essentially, it is up to the project leader to decide which structure
    to use. In this book, we'll use the horizontal approach for reasons of simplicity,
    but we'll incorporate the Angular part of our application in a vertical manner
    to demonstrate the flexibility of the MEAN stack's structure. Keep in mind that
    everything presented in this book can be easily restructured to accommodate your
    project's specifications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种类型的应用程序结构是不同的，但事实上MEAN堆栈可以以许多不同的方式组装。甚至一个团队可能会以结合这两种方法的方式来构建他们的项目；因此，基本上由项目负责人决定使用哪种结构。在本书中，出于简单起见，我们将使用水平方法，但我们将以垂直方式整合我们应用程序的Angular部分，以展示MEAN堆栈结构的灵活性。请记住，本书中提出的所有内容都可以轻松重构以适应您项目的规格。
- en: File-naming conventions
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件命名约定
- en: 'While developing your application, you''ll soon notice that you end up with
    many files with the same name. The reason is that MEAN applications often have
    a parallel MVC structure for both the Express and Angular components. To understand
    this issue, take a look at a common vertical feature''s folder structure:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，您很快会注意到您最终会得到许多具有相同名称的文件。原因是MEAN应用程序通常对Express和Angular组件都有并行的MVC结构。要理解这个问题，看一下常见的垂直特性文件夹结构：
- en: '![File-naming conventions](img/B05071_03_03.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![文件命名约定](img/B05071_03_03.jpg)'
- en: As you can see, enforcing the folder structure helps you understand each file's
    functionality, but it will also cause several files to have the same name. This
    is because an application's feature is usually implemented using several JavaScript
    files, each having a different role. This issue can cause some confusion for the
    development team, so to solve this, you'll need to use some sort of a naming convention.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，强制文件夹结构有助于理解每个文件的功能，但也会导致多个文件具有相同的名称。这是因为一个应用程序的特性通常是使用多个JavaScript文件来实现的，每个文件都有不同的角色。这个问题可能会给开发团队带来一些困惑，因此为了解决这个问题，您需要使用某种命名约定。
- en: The simplest solution would be to add each file's functional role to the filename.
    So, a feature controller file will be named `feature.controller.js`, a feature
    model file will be named `feature.model.js`, and so on. However, things get even
    more complicated when you consider the fact that MEAN applications use JavaScript
    MVC files for both Express and Angular applications. This means that you'll often
    have two files with the same name. To solve this issue, it is also recommended
    that you extend file names with their execution destination. This might seem like
    overkill at first, but you'll soon discover that it's quite helpful to quickly
    identify the role and execution destination of your application files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是将每个文件的功能角色添加到文件名中。因此，特性控制器文件将被命名为`feature.controller.js`，特性模型文件将被命名为`feature.model.js`，依此类推。然而，当考虑到MEAN应用程序同时使用JavaScript
    MVC文件来处理Express和Angular应用程序时，情况变得更加复杂。这意味着您经常会有两个具有相同名称的文件。为了解决这个问题，还建议您扩展文件名以包含它们的执行目的地。这一开始可能看起来有些多余，但您很快会发现，快速识别应用程序文件的角色和执行目的地是非常有帮助的。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to remember that this is a best practice convention. You can
    easily replace the `controller`, `model`, `client`, and `server` keywords with
    your own keywords.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住这是一种最佳实践约定。您可以轻松地用自己的关键字替换`controller`、`model`、`client`和`server`。
- en: Implementing the horizontal folder structure
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施水平文件夹结构
- en: 'To begin the structuring of your first MEAN project, create a new project folder
    with the following folders inside it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建您的第一个MEAN项目的结构，请在其中创建一个新的项目文件夹，并在其中创建以下文件夹：
- en: '![Implementing the horizontal folder structure](img/B05071_03_04.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![实施水平文件夹结构](img/B05071_03_04.jpg)'
- en: 'Once you have created all the preceding folders, go back to the application''s
    root folder and create a `package.json` file that contains the following code
    snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了所有前述文件夹后，返回到应用程序的根文件夹并创建一个包含以下代码片段的`package.json`文件：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, in the `app/controllers` folder, create a file named `index.server.controller.js`
    with the following lines of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`app/controllers`文件夹中，创建一个名为`index.server.controller.js`的文件，其中包含以下代码：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Congratulations! You just created your first Express controller. This code probably
    looks very familiar; that's because it's a copy of the middleware you created
    in the previous examples. What you do here is use the CommonJS module pattern
    to define a function named `render()`. Later on, you'll be able to acquire this
    module and use this function. Once you've created a controller, you'll need to
    use an Express-routing functionality to utilize the controller.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了你的第一个Express控制器。这段代码可能看起来很熟悉；那是因为它是你在之前示例中创建的中间件的副本。你在这里所做的是使用CommonJS模块模式来定义一个名为`render()`的函数。稍后，你将能够获取这个模块并使用这个函数。一旦你创建了一个控制器，你就需要使用Express路由功能来利用这个控制器。
- en: Handling request routing
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理请求路由
- en: 'Express supports the routing of requests using either the `app.route(path).VERB(callback)`
    method or the `app.VERB(path, callback)` method, where `VERB` should be replaced
    with a lowercase HTTP verb. Take a look at the following example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Express支持使用`app.route(path).VERB(callback)`方法或`app.VERB(path, callback)`方法来路由请求，其中`VERB`应该替换为小写的HTTP动词。看一下以下例子：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This tells Express to execute the middleware function for any HTTP request
    using the `GET` verb and directed to the root path. If you''d like to deal with
    `POST` requests, your code should be as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Express执行中间件函数来处理任何使用`GET`动词并指向根路径的HTTP请求。如果你想处理`POST`请求，你的代码应该如下所示：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, Express also enables you to define a single route and then chain several
    middleware to handle different HTTP requests. This means that the preceding code
    example can also be written as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Express还允许你定义单个路由，然后链接多个中间件来处理不同的HTTP请求。这意味着前面的代码示例也可以写成如下形式：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another cool feature of Express is its ability to chain several middleware
    in a single routing definition. This means that middleware functions will be called
    in an order, passing them to the next middleware so that you can determine how
    to proceed with middleware execution. This is usually used to validate requests
    before executing the response logic. To understand this better, take a look at
    the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Express的另一个很酷的功能是能够在单个路由定义中链接多个中间件。这意味着中间件函数将按顺序调用，将它们传递给下一个中间件，以便你可以确定如何继续执行中间件。这通常用于在执行响应逻辑之前验证请求。要更好地理解这一点，看一下以下代码：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, there are two middleware functions named `hasName()`
    and `sayHello()`. The `hasName()` middleware is looking for the `name` parameter;
    if it finds a defined `name` parameter, it will call the next middleware function
    using the next argument. Otherwise, the `hasName()` middleware will handle the
    response by itself. In this case, the next middleware function would be the `sayHello()`
    middleware function. This is possible because we've added the middleware function
    in a row using the `app.get()` method. It is also worth noting the order of the
    middleware functions because it determines which middleware function is executed
    first.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，有两个名为`hasName()`和`sayHello()`的中间件函数。`hasName()`中间件正在寻找`name`参数；如果找到了定义的`name`参数，它将使用next参数调用下一个中间件函数。否则，`hasName()`中间件将自己处理响应。在这种情况下，下一个中间件函数将是`sayHello()`中间件函数。这是可能的，因为我们使用`app.get()`方法将中间件函数按顺序添加。还值得注意的是中间件函数的顺序，因为它决定了哪个中间件函数首先执行。
- en: This example demonstrates well how routing middleware can be used to perform
    different validations when determining what the response should be. You can, of
    course, leverage this functionality to perform other tasks, such as validating
    user authentication and resources' authorization. For now, though, let's just
    continue with our example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很好地演示了路由中间件如何在确定响应时执行不同的验证。当然，你可以利用这个功能来执行其他任务，比如验证用户身份验证和资源授权。不过，现在让我们继续我们的例子。
- en: Adding the routing file
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加路由文件
- en: 'The next file you''re going to create is your first routing file. In the `app/routes`
    folder, create a file named `index.server.routes.js` with the following code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来要创建的文件是你的第一个路由文件。在`app/routes`文件夹中，创建一个名为`index.server.routes.js`的文件，其中包含以下代码片段：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you did a few things. First, you used the CommonJS module pattern again.
    As you may remember, the CommonJS module pattern supports both the exporting of
    several functions, such as what you did with your controller, and the use of a
    single module function, such as what you did here. Next, you required your `index`
    controller and used its `render()` method as a middleware to GET requests made
    to the root path.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你做了一些事情。首先，你再次使用了CommonJS模块模式。你可能还记得，CommonJS模块模式支持导出多个函数，比如你在控制器中所做的，以及使用单个模块函数，就像你在这里所做的那样。接下来，你需要引入你的`index`控制器，并将其`render()`方法用作中间件来处理根路径的GET请求。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The routing module function accepts a single argument called `app`, so when
    you call this function, you'll need to pass it the instance of the Express application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模块函数接受一个名为`app`的参数，所以当你调用这个函数时，你需要传递Express应用程序的实例。
- en: 'All that you have left to do is to create the Express application object and
    bootstrap it using the controller and routing modules you just created. To do
    this, go to the `config` folder and create a file named `express.js` with the
    following code snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你所剩下的就是创建Express应用程序对象，并使用你刚刚创建的控制器和路由模块进行引导。为此，转到`config`文件夹，并创建一个名为`express.js`的文件，其中包含以下代码片段：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code snippet, you required the Express module and then used
    the CommonJS module pattern to define a `module` function that initializes the
    Express application. First, it creates a new instance of an Express application,
    and then it requires your routing file and calls it as a function, passing it
    the application instance as an argument. The routing file will use the application
    instance to create a new routing configuration, and then it will call the controller's
    `render()` method. The `module` function ends by returning the application instance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，您需要引入Express模块，然后使用CommonJS模块模式来定义一个`module`函数，该函数初始化Express应用程序。首先，它创建一个新的Express应用程序实例，然后需要您的路由文件并将其作为函数调用，将应用程序实例作为参数传递给它。路由文件将使用应用程序实例来创建新的路由配置，然后调用控制器的`render()`方法。`module`函数通过返回应用程序实例来结束。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `express.js` file is where we configure our Express application. This is
    where we add everything related to the Express configuration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.js`文件是我们配置Express应用程序的地方。这是我们添加与Express配置相关的所有内容的地方。'
- en: 'To finalize your application, you''ll need to create a file named `server.js`
    in the root folder and copy the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成您的应用程序，您需要在根文件夹中创建一个名为`server.js`的文件，并复制以下代码：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is it! In the main application file, you connected all the loose ends by
    requiring the Express configuration module and then using it to retrieve your
    application object instance and listening to port `3000`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！在主应用程序文件中，通过需要Express配置模块并使用它来检索您的应用程序对象实例，并侦听端口`3000`，您连接了所有松散的端点。
- en: 'To start your application, navigate to your application''s root folder using
    your command-line tool and install your application dependencies using `npm`,
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动您的应用程序，请使用`npm`在命令行工具中导航到您的应用程序的根文件夹，并安装您的应用程序依赖项，如下所示：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the installation process is over, all you have to do is start your application
    using Node''s command-line tool:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程结束后，您只需使用Node的命令行工具启动应用程序：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Your Express application should run now! To test it, navigate to `http://localhost:3000`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Express应用程序现在应该可以运行了！要测试它，请导航到`http://localhost:3000`。
- en: In this example, you learned how to properly build your Express application.
    It is important that you note the different ways in which you used the CommonJS
    module pattern to create your files and require them across the application. This
    pattern will often repeat itself in this book.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您学会了如何正确构建您的Express应用程序。重要的是，您注意到了使用CommonJS模块模式创建文件并在整个应用程序中引用它们的不同方式。这种模式在本书中经常重复出现。
- en: Configuring an Express application
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Express应用程序
- en: Express comes with a pretty simple configuration system that enables you to
    add certain functionalities to your Express application. Although there are predefined
    configuration options that you can change to manipulate the way it works, you
    can also add your own key/value configuration options for any other usage. Another
    robust feature of Express is its ability to configure your application based on
    the environment it's running on. For instance, you may want to use the Express
    logger in your development environment and not in production, while compressing
    your responses body might seem like a good idea when running in a production environment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Express具有一个非常简单的配置系统，可以让您为Express应用程序添加某些功能。虽然有预定义的配置选项可以更改以操纵其工作方式，但您也可以为任何其他用途添加自己的键/值配置选项。Express的另一个强大功能是根据其运行的环境配置应用程序。例如，您可能希望在开发环境中使用Express记录器，而在生产环境中不使用，同时在生产环境中压缩响应主体可能看起来是一个不错的主意。
- en: To achieve this, you will need to use the `process.env` property. `process.env`
    is a global variable that allows you to access predefined environment variables,
    and the most common one is the `NODE_ENV` environment variable. The `NODE_ENV`
    environment variable is often used for environment-specific configurations. To
    understand this better, let's go back to the previous example and add some external
    middleware. To use this middleware, you will first need to download and install
    them as your project dependencies.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您需要使用`process.env`属性。`process.env`是一个全局变量，允许您访问预定义的环境变量，最常见的是`NODE_ENV`环境变量。`NODE_ENV`环境变量通常用于特定环境的配置。为了更好地理解这一点，让我们回到之前的例子并添加一些外部中间件。要使用这些中间件，您首先需要将它们下载并安装为项目的依赖项。
- en: 'To do this, edit your `package.json` file to look like the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请编辑您的`package.json`文件，使其看起来像以下代码片段：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we stated previously, the `morgan` module provides a simple logger middleware,
    the `compression` module provides response compression, the `body-parser` module
    provides several middleware to handle the request data, and the `method-override`
    module provides `DELETE` and `PUT` HTTP verbs'' legacy support. To use these modules,
    you will need to modify your `config/express.js` file to look like the following
    code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所述，`morgan`模块提供了一个简单的日志记录中间件，`compression`模块提供了响应压缩，`body-parser`模块提供了几个中间件来处理请求数据，`method-override`模块提供了`DELETE`和`PUT`
    HTTP动词的旧版本支持。要使用这些模块，您需要修改您的`config/express.js`文件，使其看起来像以下代码片段：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we just used the `process.env.NODE_ENV` variable to determine
    our environment and configure the Express application accordingly. We simply used
    the `app.use()` method to load the `morgan()` middleware in a development environment
    and the `compress()` middleware in a production environment. The `bodyParser.urlencoded()`,
    `bodyParser.json()`, and `methodOverride()` middleware will always load regardless
    of the environment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只是使用`process.env.NODE_ENV`变量来确定我们的环境，并相应地配置Express应用程序。我们只是使用`app.use()`方法在开发环境中加载`morgan()`中间件，在生产环境中加载`compress()`中间件。`bodyParser.urlencoded()`、`bodyParser.json()`和`methodOverride()`中间件将始终加载，无论环境如何。
- en: 'To finalize your configuration, you''ll need to change your `server.js` file
    to look like the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成您的配置，您需要将您的`server.js`文件更改为以下代码片段：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note how the `process.env.NODE_ENV` variable is set to the default `development`
    value if it doesn't exist. This is because often, the `NODE_ENV` environment variable
    is not properly set.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果不存在，`process.env.NODE_ENV`变量将设置为默认的`development`值。这是因为通常`NODE_ENV`环境变量没有正确设置。
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is recommended that you set the NODE_ENV environment variable in your operating
    system prior to running your application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在运行应用程序之前在操作系统中设置NODE_ENV环境变量。
- en: 'In a Windows environment, this can be done by executing the following command
    in your command prompt:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows环境中，您可以通过在命令提示符中执行以下命令来执行此操作：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'While in a Unix-based environment, you should simply use the following export
    command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 而在基于Unix的环境中，您应该简单地使用以下导出命令：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To test your changes, navigate to your application''s root folder using your
    command-line tool and install your application dependencies using `npm`, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的更改，请使用`npm`导航到应用程序的根文件夹，并安装应用程序依赖项，如下所示：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the installation process is over, all you have to do is start your application
    using Node''s command-line tool:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程结束后，您只需使用Node的命令行工具启动应用程序：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Your Express application should now run! To test it, navigate to `http://localhost:3000`,
    and you'll be able to see the logger in action in your command-line output. However,
    the `process.env.NODE_ENV` environment variable can be used in an even more sophisticated
    manner when dealing with more complex configuration options.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Express应用程序现在应该运行！要测试它，请导航到`http://localhost:3000`，您将能够在命令行输出中看到记录器的操作。但是，当处理更复杂的配置选项时，`process.env.NODE_ENV`环境变量可以以更复杂的方式使用。
- en: Environment configuration files
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境配置文件
- en: 'During your application development, you will often need to configure third-party
    modules to run differently in various environments. For instance, when you connect
    to your MongoDB server, you''ll probably use different connection strings in your
    development and production environments. Doing this in the current setting will
    probably cause your code to be filled with endless `if` statements, which will
    generally be harder to maintain. To solve this issue, you can manage a set of
    environment configuration files that hold these properties. You will then be able
    to use the `process.env.NODE_ENV` environment variable to determine which configuration
    file to load, thus keeping your code shorter and easier to maintain. Let''s begin
    by creating a configuration file for our default development environment. To do
    this, create a new file inside your `config/env` folder and call it `development.js`.
    Inside your new file, paste the following lines of code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发过程中，您经常需要配置第三方模块以在各种环境中以不同方式运行。例如，当连接到MongoDB服务器时，您可能会在开发和生产环境中使用不同的连接字符串。在当前设置中这样做可能会导致您的代码充斥着无尽的`if`语句，这通常会更难以维护。为了解决这个问题，您可以管理一组环境配置文件来保存这些属性。然后，您将能够使用`process.env.NODE_ENV`环境变量来确定要加载哪个配置文件，从而使您的代码更短，更易于维护。让我们首先为我们的默认开发环境创建一个配置文件。为此，请在`config/env`文件夹内创建一个新文件，并将其命名为`development.js`。在新文件中，粘贴以下代码：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, your configuration file is currently just an empty CommonJS
    module initialization. Don''t worry about it; we''ll soon add the first configuration
    option, but first, we''ll need to manage the configuration files'' loading. To
    do this, go to your application''s `config` folder and create a new file named
    `config.js`. Inside your new file, paste the following lines of code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您的配置文件目前只是一个空的CommonJS模块初始化。不用担心；我们很快将添加第一个配置选项，但首先，我们需要管理配置文件的加载。为此，请转到应用程序的`config`文件夹，并创建一个名为`config.js`的新文件。在新文件中，粘贴以下代码：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, this file simply loads the correct configuration file according
    to the `process.env.NODE_ENV` environment variable. In the upcoming chapters,
    we'll use this file, which will load the correct environment configuration file
    for us. To manage other environment configurations, you'll just need to add a
    dedicated environment configuration file and properly set the `NODE_ENV` environment
    variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此文件只是根据`process.env.NODE_ENV`环境变量加载正确的配置文件。在接下来的章节中，我们将使用此文件，它将为我们加载正确的环境配置文件。要管理其他环境配置，您只需要添加一个专门的环境配置文件，并正确设置`NODE_ENV`环境变量。
- en: Rendering views
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染视图
- en: 'A very common feature of web frameworks is the ability to render views. The
    basic concept is passing your data to a template engine that will render the final
    view, usually in HTML. In the MVC pattern, your controller uses the model to retrieve
    the data portion and the view template to render the HTML output, as described
    in the next diagram. The Express extendable approach allows the usage of many
    Node.js template engines to achieve this functionality. In this section, we''ll
    use the EJS template engine, but you can later replace it with other template
    engines. The following diagram shows the MVC pattern in rendering application
    views:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Web框架的一个非常常见的特性是渲染视图的能力。基本概念是将数据传递给模板引擎，该引擎将渲染最终的视图，通常是HTML。在MVC模式中，控制器使用模型来检索数据部分，并使用视图模板来渲染HTML输出，如下图所示。Express可扩展的方法允许使用许多Node.js模板引擎来实现此功能。在本节中，我们将使用EJS模板引擎，但您可以随后将其替换为其他模板引擎。以下图表显示了渲染应用视图的MVC模式：
- en: '![Rendering views](img/B05071_03_05.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![渲染视图](img/B05071_03_05.jpg)'
- en: 'Express has two methods to render views: `app.render()`, which is used to render
    the view and then pass the HTML to a callback function, and the more common `res.render()`,
    which renders the view locally and sends the HTML as a response. You''ll use `res.render()`
    more frequently because you usually want to output the HTML as a response. However,
    if, for instance, you''d like your application to send HTML e-mails, you will
    probably use `app.render()`. Before we begin exploring the `res.render()` method,
    let''s first configure our view system.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Express有两种方法来渲染视图：`app.render()`用于渲染视图然后将HTML传递给回调函数，更常见的是`res.render()`，它在本地渲染视图并将HTML作为响应发送。你将更频繁地使用`res.render()`，因为通常你希望将HTML输出为响应。不过，例如，如果你希望你的应用程序发送HTML电子邮件，你可能会使用`app.render()`。在我们开始探索`res.render()`方法之前，让我们先配置我们的视图系统。
- en: Configuring the view system
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置视图系统
- en: 'In order to configure the Express view system, you will need to use the EJS
    template engine. Let''s get back to our example and install the EJS module. You
    should begin by changing your `package.json` file to look like the following code
    snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置Express视图系统，你需要使用EJS模板引擎。让我们回到我们的示例并安装EJS模块。你应该首先更改你的`package.json`文件，使其看起来像以下代码片段：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, install the EJS module by navigating in the command line to your project''s
    root folder and issuing the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在命令行中导航到项目的根文件夹并发出以下命令来安装EJS模块：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After npm finishes the installation of the EJS module, you''ll be able to configure
    Express to use it as the default template engine. To configure your Express application,
    go back to the `config/express.js` file and change it to look like the following
    lines of code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在npm完成安装EJS模块后，你将能够配置Express将其用作默认模板引擎。要配置你的Express应用程序，回到`config/express.js`文件，并将其更改为以下代码行：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note how we use the `app.set()` method to configure the Express application
    `view` folder and template engine. Let's create your first view.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`app.set()`方法来配置Express应用程序的`view`文件夹和模板引擎。让我们创建你的第一个视图。
- en: Rendering EJS views
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染EJS视图
- en: 'EJS views basically consist of HTML code mixed with `EJS` tags. EJS templates
    will reside in the `app/views` folder and will have the `.ejs` extension. When
    you use the `res.render()` method, the EJS engine will look for the template in
    the `views` folder, and if it finds a complying template, it will render the HTML
    output. To create your first EJS view, go to your `app/views` folder and create
    a new file named `index.ejs`, which contains the following HTML code snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: EJS视图基本上由HTML代码和`EJS`标签混合而成。EJS模板将驻留在`app/views`文件夹中，并具有`.ejs`扩展名。当你使用`res.render()`方法时，EJS引擎将在`views`文件夹中查找模板，如果找到符合的模板，它将渲染HTML输出。要创建你的第一个EJS视图，转到你的`app/views`文件夹，并创建一个名为`index.ejs`的新文件，其中包含以下HTML代码片段：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code should be mostly familiar to you, except for the `<%= %>` tag. These
    tags are the way to tell the EJS template engine where to render the template
    variables—in this case, the `title` variable. All you have left to do is configure
    your controller to render this template and automatically output it as an HTML
    response. To do this, go back to your `app/controllers/index.server.controller.js`
    file and change it to look like the following code snippet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对你来说应该大部分都很熟悉，除了`<%= %>`标签。这些标签是告诉EJS模板引擎在哪里渲染模板变量的方式——在这种情况下是`title`变量。你所要做的就是配置你的控制器来渲染这个模板，并自动将其输出为HTML响应。要做到这一点，回到你的`app/controllers/index.server.controller.js`文件，并将其更改为以下代码片段的样子：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note the way the `res.render()` method is used. The first argument is the name
    of your EJS template without the `.ejs` extension, and the second argument is
    an object containing your template variables. The `res.render()` method will use
    the EJS template engine to look for the file in the `views` folder that we set
    in the `config/express.js` file and will then render the view using the template
    variables. To test your changes, use your command-line tool and issue the following
    command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`res.render()`方法的使用方式。第一个参数是你的EJS模板的名称，不包括`.ejs`扩展名，第二个参数是一个包含你的模板变量的对象。`res.render()`方法将使用EJS模板引擎在我们在`config/express.js`文件中设置的`views`文件夹中查找文件，然后使用模板变量渲染视图。要测试你的更改，使用你的命令行工具并发出以下命令：
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Well done; you have just created your first EJS view! Test your application
    by visiting `http://localhost:3000`, where you'll be able to view the rendered
    HTML.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，你刚刚创建了你的第一个EJS视图！通过访问`http://localhost:3000`来测试你的应用程序，在那里你将能够查看渲染的HTML。
- en: EJS views are simple to maintain, and they provide an easy way to create your
    application views. We'll elaborate a bit more on EJS templates later in this book,
    not as much as you would expect, however, because in MEAN applications, most of
    the HTML rendering is done on the client side using Angular.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: EJS视图易于维护，并提供了一种简单的方式来创建你的应用程序视图。我们将在本书的后面详细介绍EJS模板，不过不会像你期望的那样多，因为在MEAN应用程序中，大部分的HTML渲染是在客户端使用Angular完成的。
- en: Serving static files
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: 'In any web application, there is always a need to serve static files. Fortunately,
    Express'' only built-in middleware is the `express.static()` middleware, which
    provides this feature. To add static file support to the previous example, just
    make the following changes in your `config/express.js` file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Web应用程序中，总是需要提供静态文件。幸运的是，Express的唯一内置中间件是`express.static()`中间件，它提供了这个功能。要将静态文件支持添加到前面的示例中，只需在你的`config/express.js`文件中进行以下更改：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `express.static()` middleware takes one argument to determine the location
    of the `static` folder. Note how the `express.static()` middleware is placed below
    the call for the routing file. This order matters because if it were above it,
    Express would first try to look for HTTP request paths in the `static files` folder.
    This would make the response a lot slower as it would have to wait for a filesystem
    I/O operation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.static()`中间件接受一个参数来确定`static`文件夹的位置。注意`express.static()`中间件放置在路由文件调用下面。这个顺序很重要，因为如果它在上面，Express首先会尝试在`static
    files`文件夹中查找HTTP请求路径。这会使响应变得更慢，因为它必须等待文件系统的I/O操作。'
- en: 'To test your static middleware, add an image named `logo.png` to the `public/img`
    folder and then make the following changes in your `app/views/index.ejs` file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的静态中间件，将一个名为`logo.png`的图片添加到`public/img`文件夹中，然后在你的`app/views/index.ejs`文件中做以下更改：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, run your application using Node''s command-line tool:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Node的命令行工具运行你的应用程序：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To test the result, visit `http://localhost:3000` in your browser and watch
    how Express is serving your image as a static file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试结果，访问`http://localhost:3000`，观察Express如何将你的图片作为静态文件提供。
- en: Configuring sessions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置会话
- en: 'Sessions are a common web application pattern that allows you to keep track
    of the user''s behavior when they visit your application. To add this functionality,
    you will need to install and configure the `express-session` middleware. To do
    this, start by modifying your `package.json` file as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是一种常见的Web应用程序模式，允许你跟踪用户访问应用程序时的行为。要添加这个功能，你需要安装和配置`express-session`中间件。首先，修改你的`package.json`文件如下：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, install the `express-session` module by navigating to your project''s
    root folder in the command line and issuing the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在命令行中导航到项目的根文件夹并发出以下命令来安装`express-session`模块：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the installation process is finished, you''ll be able to configure your
    Express application to use the `express-session` module. The `express-session`
    module will use a cookie-stored, signed identifier to identify the current user.
    To sign the session identifier, it will use a secret string, which will help prevent
    malicious session tampering. For security reasons, it is recommended that the
    cookie secret be different for each environment, which means that this would be
    an appropriate place to use our environment configuration file. To do this, change
    the `config/env/development.js` file to look like the following code snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程完成后，你将能够配置你的Express应用程序使用`express-session`模块。`express-session`模块将使用一个存储在cookie中的签名标识符来识别当前用户。为了签署会话标识符，它将使用一个秘密字符串，这将有助于防止恶意会话篡改。出于安全原因，建议每个环境的cookie秘密都不同，这意味着这将是使用我们的环境配置文件的合适地方。为此，将`config/env/development.js`文件更改为以下代码片段的样子：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since this is just an example, feel free to change the secret string. For other
    environments, just add the `sessionSecret` property in their environment configuration
    files. To use the configuration file and configure your Express application, go
    back to your `config/express.js` file and change it to look like the following
    code snippet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个例子，可以随意更改秘密字符串。对于其他环境，只需在它们的环境配置文件中添加`sessionSecret`属性。要使用配置文件并配置你的Express应用程序，返回到你的`config/express.js`文件，并将其更改为以下代码片段的样子：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note how the configuration object is passed to the `express.session()` middleware.
    In this configuration object, the `secret` property is defined using the configuration
    file you previously modified. The session middleware adds a session object to
    all request objects in your application. Using this session object, you can set
    or get any property that you wish to use in the current session. To test the session,
    change the `app/controller/index.server.controller.js` file as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意配置对象是如何传递给`express.session()`中间件的。在这个配置对象中，使用之前修改过的配置文件定义了`secret`属性。会话中间件将会话对象添加到应用程序中的所有请求对象中。使用这个会话对象，你可以设置或获取任何你希望在当前会话中使用的属性。为了测试会话，将`app/controller/index.server.controller.js`文件更改如下：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What you did here was basically record the time of the last user request. The
    controller checks whether the `lastVisit` property was set in the `session` object,
    and if so, it outputs the last visit date to the console. It then sets the `lastVisit`
    property to the current time. To test your changes, use Node''s command-line tool
    to run your application, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里做的基本上是记录最后一次用户请求的时间。控制器检查`session`对象中是否设置了`lastVisit`属性，如果设置了，就将最后访问日期输出到控制台。然后将`lastVisit`属性设置为当前时间。为了测试你的更改，使用Node的命令行工具运行你的应用程序，如下所示：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, test your application by visiting `http://localhost:3000` in your browser
    and watching the command-line output.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在浏览器中访问`http://localhost:3000`并观察命令行输出来测试你的应用程序。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you created your first Express application and learned how
    to properly configure it. You arranged your files and folders in an organized
    structure and discovered alternative folder structures. You also created your
    first Express controller and learned how to call its methods using Express' routing
    mechanism. You rendered your first EJS view and learned how to serve static files.
    You also learned how to use `express-session` to track your user's behavior. In
    the next chapter, you'll learn how to save your application's persistent data
    using MongoDB.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你创建了你的第一个Express应用程序，并学会了如何正确配置它。你将文件和文件夹组织成了一个有组织的结构，并发现了替代的文件夹结构。你还创建了你的第一个Express控制器，并学会了如何使用Express的路由机制调用它的方法。你渲染了你的第一个EJS视图，并学会了如何提供静态文件。你还学会了如何使用`express-session`来跟踪用户的行为。在下一章中，你将学会如何使用MongoDB保存你应用程序的持久数据。
