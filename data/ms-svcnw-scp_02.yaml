- en: Exploring the ServiceNow Glide Class
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 ServiceNow Glide 类
- en: In this chapter, we will explore the the ServiceNow Glide class. We will look
    at the exposed JavaScript APIs that allow developers to conveniently and rapidly
    write ServiceNow scripts. We will then look at the different classes on the server
    and client sides before looking at some examples of some of the most commonly
    used classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 ServiceNow Glide 类。我们将查看允许开发者方便且快速编写 ServiceNow 脚本的公开 JavaScript
    API。然后，我们将查看服务器和客户端上的不同类，最后查看一些常用类的示例。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to use ServiceNow exposed JavaScript APIs, including GlideRecord
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 ServiceNow 公开的 JavaScript API，包括 GlideRecord
- en: Client-side Glide classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端 Glide 类
- en: Server-side Glide classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端 Glide 类
- en: Examples covering some commonly used Glide classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖一些常用 Glide 类的示例
- en: Using ServiceNow exposed JavaScript APIs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ServiceNow 公开的 JavaScript API
- en: ServiceNow provides developers with some exposed JavaScript APIs to aid them
    with the scripts they write. This saves a lot of time in accessing records and
    fields in scripts in ServiceNow. There are a number of different classes and objects
    available to developers, some of which very helpful and others rarely used.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceNow 为开发者提供了一些公开的 JavaScript API，以帮助他们编写脚本。这大大节省了在 ServiceNow 脚本中访问记录和字段的时间。开发者可以使用许多不同的类和对象，其中一些非常有用，而另一些则很少使用。
- en: GlideRecord
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlideRecord
- en: One of the most common JavaScript APIs is the `GlideRecord` class, which is
    extremely handy and will fast become a staple of most scripting. `GlideRecord`
    is a way of finding and counting records in ServiceNow based on many different
    queries. It is quite similar to a SQL statement if that is something you are familiar
    with.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 JavaScript API 之一是 `GlideRecord` 类，它非常实用，很快将成为大多数脚本的必备工具。`GlideRecord`
    是在 ServiceNow 中根据许多不同的查询查找和计数记录的一种方式。如果你熟悉 SQL 语句，它相当类似。
- en: Let's have a look at how to use `GlideRecord`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `GlideRecord`。
- en: 'We''ll take a look at how to query all the records in a particular table. The
    format of the `GlideRecord` script for this is shown in the following, with `table_name`
    being the only parameter. This needs to be the table name rather than the table
    label:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看如何查询特定表中的所有记录。此 `GlideRecord` 脚本的格式如下所示，其中 `table_name` 是唯一的参数。这需要是表名而不是表标签：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will set a variable to hold the `GlideRecord` object and define the table
    that will be used to query. In this example, we will use the incident table:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个变量来保存 `GlideRecord` 对象，并定义将用于查询的表。在这个例子中，我们将使用事件表：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `glideRecord` variable now holds a `GlideRecord` object for the incident
    table. We then query the table and add any filtering. In this case, we will add
    no filter and simply return all records for the incident table, therefore showing
    the full script:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`glideRecord` 变量现在保存了事件表的 `GlideRecord` 对象。然后我们查询表并添加任何过滤。在这种情况下，我们将添加没有过滤，仅返回事件表的所有记录，因此显示完整的脚本：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a very important part of ServiceNow scripting as it is the way coders
    can access the records in ServiceNow by cycling through them and applying some
    code to each relevant record.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 ServiceNow 脚本中的一个非常重要的部分，因为这是编码者通过遍历它们并应用一些代码到每个相关记录的方式来访问 ServiceNow 中的记录的方式。
- en: 'Now that we''ve seen how to set up a `GlideRecord` query, let''s have a look
    at the script line that can filter a `GlideRecord` for us:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何设置 `GlideRecord` 查询，让我们看看可以为我们过滤 `GlideRecord` 的脚本行：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we filter based on a field name and compare the value in that field using
    the operator to the value we define. The default `operator` is that the value
    equals the value in the field so if this is the operator we need, we can just
    leave it out.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据字段名称进行过滤，并使用运算符将那个字段中的值与我们定义的值进行比较。默认的 `operator` 是值等于字段中的值，所以如果这是我们需要的运算符，我们就可以省略它。
- en: 'Let''s have a look at another example. This time, we''ll look to query all
    the problem records with a critical priority using our filter line:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。这次，我们将使用过滤行查询所有具有关键优先级的问题记录：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the preceding code, we omitted the operator because we want
    problem records with a priority equal to `1` and therefore we did not need to
    include it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们省略了运算符，因为我们想要具有优先级等于 `1` 的问题记录，因此我们不需要包含它。
- en: 'In the examples so far, we have cycled through all of the records, but we can
    amend the loop to return just one if it exists by changing the `while` to an `if`.
    This is often helpful when checking whether all tasks of a parent record are complete.
    Let''s look at how it would change our script from our last example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们已经遍历了所有记录，但我们可以通过将 `while` 改为 `if` 来修改循环，以便只返回一个存在的记录。这在检查父记录的所有任务是否完成时非常有帮助。让我们看看它将如何改变我们上一个示例中的脚本：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code could be used to check whether any priority critical problems exist
    and will run some code against it if one does.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以用来检查是否存在任何优先级关键的问题，如果存在，将会对它运行一些代码。
- en: You can add more than one query and each record that is returned will need to
    satisfy each filter being defined. In that respect, it is quite like searching
    for a house. You could just search for all houses, but you more likely would want
    to build filters up to find exactly what you are looking for – price range, bedrooms,
    location, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加多个查询，并且每个返回的记录都需要满足定义的每个过滤器。在这方面，它很像寻找房子。你可以只搜索所有的房子，但你更有可能想要建立一系列过滤器来找到你确切想要的东西——价格范围、卧室数量、位置等等。
- en: 'With all of these filters adding up and essentially creating a series of logical
    `AND` statements, we also need a way of creating a logical `OR` statement. In
    the same way you can add a query line, you can also add an `OR` condition line
    of script. Let''s see how it works:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些过滤器累加起来，本质上创建了一系列逻辑 `AND` 语句，我们还需要一种创建逻辑 `OR` 语句的方法。同样地，你可以在查询行中添加，也可以添加一个脚本中的
    `OR` 条件行。让我们看看它是如何工作的：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the original condition is stored in a variable, `orQuery`, and
    then the `OR` condition is added to this variable before the query takes place.
    This type of query is handy if you want certain code to execute when a record
    is in a certain set of states.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，原始条件存储在一个变量中，`orQuery`，然后在查询之前将 `OR` 条件添加到这个变量中。如果你想在记录处于某些状态时执行某些代码，这种查询类型非常方便。
- en: 'There are many ways to achieve the same goal in ServiceNow and to show this,
    we can set up the same filter on change records using a different operator. This
    uses the fact that many values of choice lists in ServiceNow are numbers so we
    can just search for all change requests with a risk of greater than or equal to
    `2`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ServiceNow 中实现相同目标的方法有很多，为了展示这一点，我们可以使用不同的运算符在更改记录上设置相同的过滤器。这是基于 ServiceNow
    中选择列表的许多值都是数字的事实，因此我们可以搜索所有风险大于或等于 `2` 的更改请求：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This second example would usually be considered better than the first, as it
    is using fewer lines of code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例通常被认为比第一个更好，因为它使用了更少的代码行。
- en: 'Now we have looked at how to get the records we want, we will look at how to
    alter the records we have found. First, we''ll take a look at a simple update
    to a record. In this example, we will update all incident records with a high
    urgency and move it down to medium:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何获取我们想要的记录，我们将探讨如何修改我们找到的记录。首先，我们将查看对记录的简单更新。在这个例子中，我们将更新所有紧急程度高的突发事件记录，将其降低到中等：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When updating a record, you can amend many of the fields and then use `update`
    to save the changes. This is a very important method and is relatively simple
    to use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新一条记录时，你可以修改许多字段，然后使用 `update` 来保存更改。这是一个非常重要的方法，并且相对简单易用。
- en: The final examples we will look at are how to delete records. Obviously, be
    careful when deleting records and ensure the query you have written is correct
    before executing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个示例是关于如何删除记录。显然，在删除记录时要非常小心，并且在执行之前确保你编写的查询是正确的。
- en: 'There are two main methods of deleting records: either individually through
    looping or all in one go. Let''s look at deleting individual records first. In
    this example, we''ll delete all of the `network` category incidents:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 删除记录有两种主要方法：要么通过循环逐个删除，要么一次性全部删除。让我们先看看如何逐个删除记录。在这个例子中，我们将删除所有 `network` 类别的突发事件：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we''ll look at how to delete all of the queried records in one go:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何一次性删除所有查询到的记录：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the script for both of these `delete` methods is quite different,
    but the end result is the same. The `deleteMultiple` method is a quicker, more
    efficient method; however, it will delete everything in one go. If there is a
    large amount of data to be deleted, this can cause resources to be tied up for
    a long time. I have used the `deleteRecord` method instead in the case of a large
    volume of data to stagger the deletion of records in smaller groups of records.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个 `delete` 方法的脚本相当不同，但最终结果相同。`deleteMultiple` 方法是一种更快、更有效的方法；然而，它将一次性删除所有内容。如果需要删除大量数据，这可能会导致资源长时间占用。在处理大量数据的情况下，我使用了
    `deleteRecord` 方法来分批删除记录。
- en: When creating a `delete` script, try executing it first with the `delete` method
    commented out and some logging to show what you have deleted. If the logging brings
    back the records you want, then go ahead with the deletion. This helps to ensure
    the wrong records are not removed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `delete` 脚本时，尝试先注释掉 `delete` 方法并添加一些日志来显示你已删除的内容。如果日志返回了你想要的记录，那么就可以继续删除。这有助于确保不会删除错误的记录。
- en: That concludes `GlideRecord` for now, but it will feature again throughout the
    book, further proving how important it is.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，`GlideRecord` 的介绍就到这里，但它在整本书中还会出现，进一步证明它的重要性。
- en: Server-side Glide classes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端 Glide 类
- en: Now we will look at some of the server-side classes that we can use for our
    scripts. Remember these methods will not work on the client side so make sure
    you are aware whether the script you are writing is on the server side.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨一些我们可以用于脚本的服务器端类。请记住，这些方法在客户端不起作用，所以请确保你清楚你正在编写的脚本是在服务器端。
- en: GlideSystem
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlideSystem
- en: '`GlideSystem` is probably the most commonly used server-side classes. Let''s
    have a look at how we can utilize this class to aid us in our scripting.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlideSystem` 可能是使用最广泛的服务器端类。让我们看看我们如何利用这个类来帮助我们进行脚本编写。'
- en: ServiceNow shortens `GlideSystem` to `gs` in scripts so the methods of `GlideSystem`
    will be prefixed with `gs`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，ServiceNow 将 `GlideSystem` 缩写为 `gs`，因此 `GlideSystem` 的方法将以 `gs` 为前缀。
- en: 'Let''s start by seeing how to get a user''s `sys_id` using `GlideSystem`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用 `GlideSystem` 获取用户的 `sys_id`：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This puts the logged-in user's `sys_id` in the `userID` variable. This can be
    helpful as you can use this in scripts where you may want to execute different
    lines of script depending on the attributes of the user. Now we have the user's
    `sys_id`, we could use a `GlideRecord` query to return the fields we desire. ServiceNow
    does allow us to obtain some of this information in an easier way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将登录用户的 `sys_id` 存储在 `userID` 变量中。这很有用，因为你可以将其用于脚本中，根据用户的属性执行不同的脚本行。现在我们有了用户的
    `sys_id`，我们可以使用 `GlideRecord` 查询来返回我们想要的字段。ServiceNow 允许我们以更简单的方式获取一些信息。
- en: 'We can get the `user` object and then use some helpful functions to access
    further information about the user. To get the `user` object, we simply write
    the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取 `user` 对象，然后使用一些有用的函数来获取有关用户的更多信息。要获取 `user` 对象，我们只需编写以下代码：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, let us see some of the most helpful functions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些最有用的函数：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Most of the preceding code is fairly self-explanatory, but the ID functions
    will return the `sys_id` of the record in the same way as the user `sys_id`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的大部分内容相当直观，但 ID 函数将以与用户 `sys_id` 相同的方式返回记录的 `sys_id`。
- en: The user's details can be useful for sending notifications and setting up approvals
    and condition scripts based on locations or companies.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的详细信息对于发送通知和根据位置或公司设置批准和条件脚本非常有用。
- en: 'Whilst we are on user data, it is often important to find out which roles a
    user has to decide what they should have access to. `GlideSystem` allows us to
    see whether a user has a certain role in the script, as shown in the following
    example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论用户数据时，了解用户拥有哪些角色通常很重要，以便决定他们应该有权访问什么。`GlideSystem` 允许我们在脚本中查看用户是否拥有特定的角色，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `hasRole` method is especially useful when using script to allow or restrict
    data to a user. It can also be used to hide or show UI actions that would require
    an elevated privilege to use. One thing to note is that the `hasRole` method will
    always return `true` for an administrator.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasRole` 方法在用脚本允许或限制用户访问数据时特别有用。它还可以用于隐藏或显示需要更高权限才能使用的 UI 操作。需要注意的是，`hasRole`
    方法对于管理员总是返回 `true`。'
- en: '`GlideSystem` is also good for letting the user know what has happened during
    a script through an output message for the user. This is done using an `Info`
    or `Error` message. The `Info` message is displayed in a nice blue box and the
    `Error` message, unsurprisingly, in a red one at the top of the form once processing
    has completed and the next screen has loaded.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlideSystem`也适用于通过用户的输出消息让用户知道脚本中发生了什么。这是通过使用`Info`或`Error`消息来完成的。`Info`消息以漂亮的蓝色框显示，而`Error`消息，不出所料，在处理完成后和下一个屏幕加载后，在表单的顶部以红色显示。'
- en: 'Let''s have a look at how to script these:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写这些脚本：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These are fairly simple lines, but are very handy in keeping a user updated
    with how scripts performed when processed and whether there were any problems.
    I tend to use the info message to let a user know an action completed successfully
    when it is not immediately obvious on the screen they are returned to. An `Error`
    message is good when something in a script goes wrong. Remember that this message
    will be displayed to a variety of users so it is best to not get too technical
    in the message.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些线条相当简单，但在保持用户了解脚本在处理过程中的表现以及是否存在任何问题时非常实用。我倾向于使用信息消息来告知用户操作已成功完成，尤其是在他们返回的屏幕上并不立即明显的情况下。当脚本中出现问题的时候，错误消息是很好的。记住，这条消息将会显示给各种用户，所以最好不要在消息中过于技术化。
- en: '`GlideSystem` also allows us to perform logging so that we can debug our server-side
    scripts. As server-side scripts are running behind the scenes, we need a way of
    logging what happened in the script so we can look at it later and review and
    debug if necessary.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlideSystem`还允许我们执行日志记录，以便我们可以调试我们的服务器端脚本。由于服务器端脚本在幕后运行，我们需要一种方法来记录脚本中发生的事情，这样我们就可以稍后查看它，并在必要时进行审查和调试。'
- en: 'The little bit of script that is the most common for this is `log`. Simply
    used, this is just a string of text to send to the logs:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，最常见的脚本片段是`log`。简单来说，这只是一个要发送到日志中的文本字符串：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This message will now be visible in the Script Log Statements module in the
    application navigator. If you are looking through older script in a ServiceNow
    instance, you will often find these log messages. Sometimes they are commented
    out in case they are needed again for debugging and sometimes they should have
    been commented out and the developer forgot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息现在将在应用程序导航器中的脚本日志语句模块中可见。如果您正在查看ServiceNow实例中的旧脚本，您通常会找到这些日志消息。有时它们被注释掉，以防将来需要用于调试，有时它们应该被注释掉，但开发者忘记了。
- en: 'If many logs are being created, it can be helpful to give your log a unique
    source so you can more easily search for only logs from your particular source.
    Let''s have a look at what this looks like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在创建许多日志，给您的日志一个独特的来源可能会有所帮助，这样您就可以更容易地搜索来自您特定来源的日志。让我们看看这看起来是什么样子：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This message will then appear in the system log with a source of `My Script
    Log`. One thing to note is that it will no longer appear in the Script Log Statements
    module as you have changed the source to a custom source.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息将随后出现在系统日志中，来源为`My Script Log`。需要注意的是，由于您已将来源更改为自定义来源，它将不再出现在脚本日志语句模块中。
- en: '`GlideSystem` is probably the most useful server-side Glide class and there
    are more methods on top of the ones we have discussed.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlideSystem`可能是最有用的服务器端Glide类，并且还有更多我们讨论过的方法。'
- en: GlideDateTime
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlideDateTime
- en: '`GlideDateTime` is, unsurprisingly, about scripting with dates and times, specifically
    the `GlideDateTime` object. The `GlideDateTime` object is mainly used to populate
    Date/Time fields and the methods around them to manipulate dates and times to
    add or remove time to a field.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlideDateTime`显然是关于日期和时间的脚本，具体来说是`GlideDateTime`对象。`GlideDateTime`对象主要用于填充日期/时间字段及其周围的日期和时间方法，以向字段添加或减去时间。'
- en: 'First, let''s look at defining a new `GlideDateTime`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何定义一个新的`GlideDateTime`：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will put the current date and time in GMT format in the `glideDT` field
    as part of a `GlideDateTime` object. This can be helpful if you want to compare
    a date in a field with the current date and time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把当前的日期和时间以GMT格式放入`glideDT`字段，作为`GlideDateTime`对象的一部分。如果您想比较字段中的日期与当前日期和时间，这可能很有帮助。
- en: 'Now, with any date and time scripting, time zones are always an issue. One
    of the best ways to get around this is to use the display value to make sure dates
    and times are displayed to users in the correct format for the user who is viewing
    it. Let''s look at how this is done by logging the display value:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在处理任何日期和时间脚本时，时区总是一个问题。解决这个问题的最好方法之一是使用显示值，确保日期和时间以正确的格式显示给查看它的用户。让我们看看如何通过记录显示值来完成这项工作：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is very helpful in scripting to ensure that all users see the correct times.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这在脚本中非常有用，可以确保所有用户都能看到正确的时间。
- en: 'Sometimes there will also be the requirement to add or remove time from a Date/Time
    field using script. There are a few methods to add various amounts of time to
    or from a Date/Time field. We''ll have a look at one of these; the others work
    in a very similar way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时也可能需要使用脚本从日期/时间字段中添加或删除时间。有一些方法可以将各种时间量添加到或从日期/时间字段中。我们将查看其中之一；其他的工作方式非常相似：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, we would be adding 1 day, so 24 hours, to the current day
    and time:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将向当前日期和时间添加 1 天，即 24 小时。
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using a negative number, we actually subtract time from the object so the
    preceding example would actually give you the date and time of this time yesterday.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用负数，我们实际上从对象中减去时间，所以前面的例子实际上会给你昨天这个时间的日期和时间。
- en: '`GlideDateTime` is helpful when dealing with dates and times, which can often
    be a headache in coding. Remember, when using negative figures in `addtime` methods,
    this reduces the time instead of increasing it.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlideDateTime` 在处理日期和时间时非常有用，这在编码中经常会导致头疼。记住，当在 `addtime` 方法中使用负数时，这会减少时间而不是增加它。'
- en: GlideElement
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlideElement
- en: '`GlideElement` provides methods for dealing with the fields in a `GlideRecord`
    object. This class is one of the smaller ones in ServiceNow.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlideElement` 为处理 `GlideRecord` 对象中的字段提供了方法。这个类是 ServiceNow 中较小的一个。'
- en: 'One very handy set of methods in this class is detecting changes to a field.
    This is very helpful in closing down records. Sometimes we may want to run some
    script on closure of the record, but not every time the record is updated. This
    is when the `changesTo` method can be used. We''ll assume we are using an incident,
    in this case where the closed state is `7`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中有一组非常方便的方法，用于检测字段的更改。这在关闭记录时非常有用。有时我们可能希望在记录关闭时运行一些脚本，但不是每次记录更新时都运行。这就是
    `changesTo` 方法可以发挥作用的时候。我们将假设我们正在使用一个事件，在这种情况下，关闭状态是 `7`：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This preceding example will allow for some script to run when the record is
    closed, but only when it moves to being closed. If the closed record is subsequently
    updated, then this script will not run again. That is why this method is so helpful.
    You can also use `changes` and `changesFrom` methods as part of this set.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子将允许在记录关闭时运行一些脚本，但只有在它变为关闭状态时才会运行。如果关闭的记录随后被更新，那么这个脚本将不会再次运行。这就是为什么这个方法如此有用的原因。你还可以使用
    `changes` 和 `changesFrom` 方法作为这个集合的一部分。
- en: You may or may not be aware of what `current` refers to at this point, but we
    will take a closer look at this when we look at business rules in [Chapter 5](170b38f0-5b60-4c8d-aef3-6833efee13f1.xhtml),
    *Introduction to Server-Side Scripting*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能或可能不知道此时 `current` 指的是什么，但当我们查看第 [5](170b38f0-5b60-4c8d-aef3-6833efee13f1.xhtml)
    章“服务器端脚本简介”中的业务规则时，我们会更详细地探讨这一点。
- en: Another helpful set of methods in `GlideElement` is checking whether a user
    is able to create, read, or write to records. We can use this to see whether a
    user should be able to perform these actions, which can be very helpful in UI
    action conditions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GlideElement` 中还有一组很有用的方法，用于检查用户是否有能力创建、读取或写入记录。我们可以使用这个方法来查看用户是否应该能够执行这些操作，这在
    UI 动作条件中非常有帮助。
- en: 'Let''s see how it works:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will check whether the logged-in user is able to create a record of the
    current type (incident, change request, and so on) and, if so, then run the script
    inside the `if` statement. We can also use the `canRead` and `canWrite` methods
    in a similar way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检查登录用户是否有能力创建当前类型的记录（事件、变更请求等），如果是的话，那么就在 `if` 语句内部运行脚本。我们也可以以类似的方式使用 `canRead`
    和 `canWrite` 方法。
- en: With `GlideElement` being a smaller class, it is not as well used as some of
    the other server-side classes, but some of its methods are very helpful, particularly
    in UI actions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `GlideElement` 是一个较小的类，它不像其他一些服务器端类那样被广泛使用，但其中一些方法非常有帮助，尤其是在 UI 动作中。
- en: GlideAggregate
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlideAggregate
- en: The `GlideAggregate` class is an extension of `GlideRecord` and works in a similar
    way. The difference is that `GlideRecord` tends to give you database objects whereas
    `GlideAggregate` deals in counts and numbers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlideAggregate` 类是 `GlideRecord` 的扩展，工作方式类似。区别在于 `GlideRecord` 通常会给你数据库对象，而
    `GlideAggregate` 处理的是计数和数字。'
- en: 'We''ll take a quick look at how `GlideAggregate` works:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速了解一下 `GlideAggregate` 的工作原理：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This first example will give us the number of incidents in the database and
    place it in the `noOfIncidents` field. We can add `addQuery` lines in exactly
    the same way we would for `GlideRecord` if we wanted to reduce the number of incident
    records we returned.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个例子将给出数据库中事件的数量，并将其放置在 `noOfIncidents` 字段中。如果我们想减少返回的事件记录数，我们可以像对 `GlideRecord`
    一样添加 `addQuery` 行。
- en: As well as `COUNT`, we can also use `SUM`, `MAX`, `MIN`, and `AVG` to get the
    total sum, maximum number, minimum number, and average, respectively.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `COUNT`，我们还可以使用 `SUM`、`MAX`、`MIN` 和 `AVG` 来获取总和、最大值、最小值和平均值。
- en: I don't find `GlideAggregate` used that regularly, but it is an efficient way
    to count records.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现 `GlideAggregate` 并不经常使用，但它是一种高效的计数记录的方法。
- en: Client-side Glide classes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端 Glide 类
- en: The client-side Glide classes are for use in scripts that are run directly in
    front of the user. These include manipulating and working with form fields and
    user data and being able to call server-side scripts to return values in the database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端 Glide 类用于在用户面前直接运行的脚本中。这包括操作和与表单字段及用户数据交互，以及能够调用服务器端脚本以返回数据库中的值。
- en: GlideForm
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlideForm
- en: I would say that GlideForm or `g_form` is the most used client-side class. It
    is mainly used for getting data from the fields on the form and setting values
    to those fields as well. We can also change elements of those fields using `g_form`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我会说是 GlideForm 或 `g_form` 是最常用的客户端类。它主要用于从表单的字段中获取数据，并将值设置到这些字段中。我们还可以使用 `g_form`
    改变这些字段的元素。
- en: 'We''ll start by looking at how to get and set values from and into fields:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看看如何从字段中获取和设置值：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The string value inside the speech marks is the database name for the field.
    Make sure you use the name rather than the label when getting a value using `g_form`.
    The `getValue` method essentially puts the value of a field into a variable for
    you. This then allows you to use that variable to check against other data or
    pass as a parameter into a function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 引号内的字符串值是该字段的数据库名称。确保在用 `g_form` 获取值时使用名称而不是标签。`getValue` 方法本质上是将字段的值放入变量中供你使用。然后你可以使用这个变量来检查其他数据或将其作为参数传递给函数：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `setValue` method will immediately set the value of the field on the screen
    to what the script dictates. In this example, presuming we are on the incident
    table, the state field would change to resolved. Remember, here, we are using
    the number `6` as that is the choice value for the resolved state in ServiceNow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`setValue` 方法会立即将屏幕上字段的值设置为脚本指定的值。在这个例子中，假设我们处于事件表中，状态字段将变为已解决。记住，在这里，我们使用数字
    `6`，因为在 ServiceNow 中，这是已解决状态的选择值。'
- en: It is also worth noting that the value at this point will only have changed
    on the screen in front of the user. The field in the database will not be updated
    until the record itself is.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，此时值只会在用户面前的屏幕上发生变化。数据库中的字段只有在记录本身更新后才会更新。
- en: Using `g_form`, we can also change elements of the field itself and not just
    the value it holds. Let's have a look at how to make a field mandatory, show and
    hide a field, and make a field read-only. The best practice for these actions
    is to use a UI policy; however, the conditions in a UI policy are limited so sometimes
    we need to use a script to perform these actions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `g_form`，我们还可以改变字段本身的元素，而不仅仅是它持有的值。让我们看看如何使字段成为必填项、显示或隐藏字段，以及使字段为只读。这些操作的最佳实践是使用
    UI 策略；然而，UI 策略中的条件有限，所以有时我们需要使用脚本执行这些操作。
- en: 'We''ll start by setting a field to `mandatory`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将字段设置为 `mandatory`：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This example would set the short description field to `mandatory`. If we want
    to reverse this, we just need to change `true` to `false` in the line. This can
    be helpful when using UI actions to move through states of a record and to ensure
    certain fields are filled in before moving to the next stage. This change to the
    mandatory state of the field is just temporary; if the form is reloaded, then
    the field will go back to its original mandatory or non-mandatory state.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将短描述字段设置为 `mandatory`。如果我们想撤销此操作，只需在行中将 `true` 更改为 `false`。这在使用UI动作在记录的状态之间移动以及确保在进入下一阶段之前某些字段已填写时可能很有帮助。此更改到字段的强制状态只是临时的；如果表单重新加载，则字段将回到其原始的强制或非强制状态。
- en: 'To change whether a field is visible, we can use the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改字段的可见性，我们可以使用以下代码：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example will hide the assigned to field, but we can show it again by changing
    `false` to `true` in the line of script. This method isn't used that often as
    this action can usually be performed by a UI policy. This method will allow the
    space the field has left behind to be reclaimed by other fields. The `setVisible`
    method is very similar to the `setDisplay` method except a blank space is left
    where the field used to be, which tends to make `setDisplay` the better aesthetic
    choice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将隐藏分配到的字段，但我们可以通过在脚本行中将 `false` 更改为 `true` 来再次显示它。这个方法并不常用，因为这个动作通常可以通过UI策略来完成。此方法将允许其他字段回收该字段留下的空间。`setVisible`
    方法与 `setDisplay` 方法非常相似，除了在字段曾经存在的地方留下一个空白空间，这往往使 `setDisplay` 成为更好的美学选择。
- en: 'The method for setting a field to be read-only is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将字段设置为只读的方法如下：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding example will set the description field to read-only, meaning the
    field cannot be edited. This will only be while the current form is loaded and
    will revert back to its original state of read-only or not when the form reloads.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将描述字段设置为只读，这意味着字段不能被编辑。这将在当前表单加载期间发生，并在表单重新加载时恢复到其原始的只读或非只读状态。
- en: 'There are also some useful bits of information that `g_form` can get for you
    as well. To begin with, let''s see how you can get the unique value or `sys_id`
    of a record using `g_form`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_form` 也可以为你提供一些有用的信息。首先，让我们看看如何使用 `g_form` 获取记录的唯一值或 `sys_id`：'
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The example puts the `sys_id` of the record in the `sysID` variable. This can
    be useful if you want the `sys_id` value even before the record is saved.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将记录的 `sys_id` 放入 `sysID` 变量中。如果你想在记录保存之前就获取 `sys_id` 值，这可能会很有用。
- en: 'We can also use code to check whether the record has been saved or not yet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用代码来检查记录是否已保存：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This `isNewRecord` method allows us to write script for only new records or
    for only records that have already been saved. This can help you to decide whether
    to insert or update a record at the end of the script.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`isNewRecord` 方法允许我们只为新记录或已保存的记录编写脚本。这可以帮助你决定在脚本末尾是插入还是更新记录。'
- en: GlideUser
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GlideUser
- en: '`GlideUser` or `g_user` is a class all about the attributes of the user. It
    is not the biggest class, but some of the properties and methods can be used quite
    frequently.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`GlideUser` 或 `g_user` 是一个关于用户属性的类。它不是最大的类，但其中一些属性和方法可以相当频繁地使用。'
- en: One of the most helpful of these is being able to get the user ID, the `sys_id`
    of the user, through a property. This can be very helpful to send to another script
    so that the script knows which user is currently logged in or for getting the
    user record.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最有帮助的是能够通过属性获取用户ID，即用户的 `sys_id`。这可以非常有帮助，可以发送到另一个脚本，以便脚本知道当前登录的是哪个用户，或者用于获取用户记录。
- en: 'Let''s have a look at how to get this ID:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何获取这个ID：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the example, the `userSys_ID` variable will be the `sys_id` of the logged-in
    user.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，`userSys_ID` 变量将是登录用户的 `sys_id`。
- en: When getting a user record, it is best practice to use the `sys_id` rather than
    a name to obtain the record. This is because there is a chance users in the database
    may have the same name, whereas the `sys_id` of a user will always be unique.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取用户记录时，最佳实践是使用 `sys_id` 而不是名称来获取记录。这是因为数据库中的用户可能有相同的名称，而用户的 `sys_id` 将始终是唯一的。
- en: We can also use `g_user` to get the full name of the logged-in user. This can
    be helpful if we want to display a user's name in messages displayed to them or
    in fields.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `g_user` 来获取已登录用户的完整姓名。如果我们想在显示给用户的消息或字段中显示用户姓名，这可能会很有帮助。
- en: 'We can get a user''s full name by using the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下示例获取用户的完整姓名：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This preceding example sets the name variable to be the user's full name. Let's
    assume I am the logged-in user here. The `alert` method shows a pop-up message
    to the user, so in this scenario, it would say `The logged in user is Andrew Kindred`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将名称变量设置为用户的完整姓名。让我们假设我是这里的登录用户。`alert`方法向用户显示一个弹出消息，所以在这种情况下，它会说“登录用户是Andrew
    Kindred”。
- en: Sometimes when scripting, we want to know whether the user has a specific role
    so we can decide whether or not a piece of code should run for them or not. To
    do this on the client side, we can use the `hasRole` method. It works in a very
    similar way to the server-side `GlideSystem` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在编写脚本时，我们想知道用户是否具有特定的角色，以便我们可以决定是否为该用户运行代码。要在客户端执行此操作，我们可以使用`hasRole`方法。它的工作方式与服务器端的`GlideSystem`方法非常相似。
- en: 'Let''s look at an example of the `hasRole` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`hasRole`方法的示例：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, this code is very similar to the server-side code. We can use
    an `if` statement to ensure that we only run certain code for users with a certain
    role.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码与服务器端代码非常相似。我们可以使用`if`语句来确保只为具有特定角色的用户运行某些代码。
- en: There are a few other methods relating to basic user data and roles, but we
    have covered the most useful ones here.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与基本用户数据和角色相关的一些其他方法，但我们在这里已经涵盖了最有用的方法。
- en: Additional client-side Glide classes
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的客户端Glide类
- en: The two classes we have looked at so far are the most useful and also the easiest
    to begin with. However, there are some other helpful client-side Glide classes.
    We will look at these other Glide classes later in the book, as they tie in nicely
    with some of the types of client-side script and specific actions you may want
    to achieve with your code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止看到的两个类是最有用且最容易开始的。然而，还有一些其他有用的客户端Glide类。我们将在本书的后面部分查看这些其他Glide类，因为它们与客户端脚本的一些类型和您可能希望用代码实现的具体操作很好地结合在一起。
- en: Script examples
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本示例
- en: Now we've looked at some server- and client-side Glide classes, we can take
    a look at some examples of using these methods and properties in some slightly
    more complex blocks of code to achieve our goals in ServiceNow.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了服务器端和客户端的Glide类，我们可以看看如何在一些稍微复杂一点的代码块中使用这些方法和属性来实现ServiceNow中的目标。
- en: Let's start by having a look at some `GlideRecord` examples.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看一些`GlideRecord`的示例。
- en: This time, we'll use `GlideRecord` multiple times, one inside another. This
    is a technique you will no doubt use quite often as you progress with your scripting.
    It has certainly served me well over the years.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将多次使用`GlideRecord`，一个在另一个内部。随着您在脚本编写中不断进步，您无疑会经常使用这种技术。它确实在我多年的工作中发挥了很好的作用。
- en: 'In this example, we''ll take a look at creating a problem record for every
    critical priority incident:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将查看为每个关键优先级事件创建问题记录：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, we've found all critical incidents using a `GlideRecord`
    query. Once we find a matching incident record, we create a new problem record
    using `insert`, copying the configuration item and short description fields from
    the incident over to the problem record also. Once the problem record has been
    inserted, we store its unique value in the `newInsertedRecord` variable so that
    we can add that value into the incident record-related problem field. This ensures
    the two records are linked and that the incident will appear in the related list
    on the problem record.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`GlideRecord`查询找到了所有关键事件。一旦我们找到一个匹配的事件记录，我们就使用`insert`创建一个新的问题记录，并将配置项和简短描述字段从事件复制到问题记录中。一旦问题记录被插入，我们就将其唯一值存储在`newInsertedRecord`变量中，以便我们可以将该值添加到事件记录相关的问题字段中。这确保了两个记录之间的链接，并且事件将出现在问题记录的相关列表中。
- en: 'We can see what this script would look like in a scheduled job in the following
    screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我们可以看到这个脚本在计划任务中的样子：
- en: '![](img/ddd9fd64-a39d-4e95-a550-4a6a601a4d5d.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddd9fd64-a39d-4e95-a550-4a6a601a4d5d.png)'
- en: 'Figure 2.1: Scheduled job for creating problems from critical incidents'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：从关键事件创建问题的计划任务
- en: We will take an in-depth look at scheduled jobs in [Chapter 6](a0052657-c9a2-4b4e-93ab-6c78ecac434c.xhtml), *Advanced
    Server-Side Scripting*. This figure gives you an idea of seeing the layout of
    Glide classes in a ServiceNow script field.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](a0052657-c9a2-4b4e-93ab-6c78ecac434c.xhtml)“高级服务器端脚本”中深入探讨计划任务。此图为您提供了在ServiceNow脚本字段中查看Glide类布局的思路。
- en: Using a `GlideRecord` inside a `GlideRecord` is incredibly useful, as we can
    create, update, or search within a `GlideRecord` query `while` loop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GlideRecord` 内部使用 `GlideRecord` 非常有用，因为我们可以在 `while` 循环中创建、更新或搜索 `GlideRecord`
    查询。
- en: If we know the `sys_id` of a record, there is a shortcut called `get` we can
    use to obtain the record directly. We can use our user-based methods to show a
    quick way of getting the user record.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道记录的 `sys_id`，可以使用一个名为 `get` 的快捷方式直接获取记录。我们可以使用基于用户的方法来展示获取用户记录的快速方式。
- en: 'The following script uses this `get` method to quickly access the user record
    we require:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本使用此 `get` 方法快速访问所需的用户记录：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using the `get` method, we have quickly retrieved the currently logged-in user's
    user record, also using our `GlideSystem` method to get the user ID. We could
    also put a `sys_id` contained in quotes here for the `get` method parameter. The
    example then sets the title of the user to be a manager and saves the record.
    Running this code will make any logged-in user have a manager as their title.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `get` 方法，我们快速检索了当前登录用户的用户记录，同时使用我们的 `GlideSystem` 方法获取用户 ID。我们也可以在这里为 `get`
    方法参数放置一个包含引号的 `sys_id`。然后示例将用户的标题设置为经理并保存记录。运行此代码将使任何登录用户都将经理作为他们的标题。
- en: This technique saves us having to use a full `GlideRecord` query to get the
    user record that we need. This means not having to search through the user table,
    which saves resources and also extra lines of code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使我们不必使用完整的 `GlideRecord` 查询来获取所需的用户记录。这意味着不必搜索用户表，这节省了资源，也减少了额外的代码行。
- en: 'We can see what this example code would look like in a business rule in ServiceNow:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 ServiceNow 的业务规则中看到此示例代码的样子：
- en: '![](img/aae22bff-0d7a-4b9a-9696-7405438ae38b.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aae22bff-0d7a-4b9a-9696-7405438ae38b.png)'
- en: 'Figure 2.2: Business rule making logged-in users managers'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：使登录用户成为经理的业务规则
- en: We will take an in-depth look at business rules in [Chapter 5](612c28de-49ab-47a2-8bcd-3cadf9c0179c.xhtml),
    *Introduction to Server-Side Scripting*. They are often used for server-side scripting.
    We would also need to add a value to the table field so that our business rule
    knows which table to run this script against.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 [5章](612c28de-49ab-47a2-8bcd-3cadf9c0179c.xhtml) “服务器端脚本简介” 中深入探讨业务规则。它们通常用于服务器端脚本。我们还需要向表字段添加一个值，以便我们的业务规则知道针对哪个表运行此脚本。
- en: 'We can also use some of the techniques we''ve learned in this chapter to send
    specific messages to users. Let''s assume we want to give users a different message
    depending on what roles they have:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用本章中学到的一些技术向用户发送特定的消息。假设我们想要根据用户拥有的角色向用户提供不同的消息：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This server-side example will display an error message to a user based on what
    roles they have. This can be useful to display additional information to users
    who will understand it and it will keep the details simple for users who do not
    have as much technical expertise.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器端示例将根据用户拥有的角色向用户显示错误消息。这可以用于向理解它的用户显示附加信息，同时为技术知识较少的用户保持细节简单。
- en: This code adds error messages that are displayed to the user when the form loads
    at the top of the screen. By using the `if` statements, we will only ever display
    one message to the user and, in our example, the most suitable one for the role
    of that user.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在表单加载到屏幕顶部时向用户显示错误消息。通过使用 `if` 语句，我们只会向用户显示一条消息，在我们的示例中，这是最适合该用户角色的消息。
- en: We can also set some values on a form based on whether it is a new form or not.
    Perhaps we want to make all new incident forms have an inquiry/help category,
    but not change any incidents that already exist.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据表单是否为新表单来设置一些值。也许我们想要使所有新的事件表单都具有询问/帮助类别，但不要更改已存在的任何事件。
- en: 'We can see the script we would need for this as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下看到实现此目的所需的脚本：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this client-side script example, we would only set the category field to
    `inquiry`/`help` if it was a new record. Remember that this would only set the
    field on the screen on the client side and would not save the field as this value
    until the record was saved.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此客户端脚本示例，如果这是一个新记录，我们只会将类别字段设置为 `inquiry`/`help`。请记住，这只会设置客户端屏幕上的字段，而不会将字段保存为该值，直到记录被保存。
- en: This type of code can be very useful for setting up records in a certain way
    whilst they are being created. Sometimes it can be that fields are not shown on
    creation of a new record and are only viewed once the record has been created.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的代码在创建记录时以特定方式设置记录非常有用。有时可能是在创建新记录时字段不会显示，只有在记录创建后才会查看。
- en: 'We can see this code in a client script in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下屏幕截图中的客户端脚本中看到此代码：
- en: '![](img/83d964aa-c271-41c7-9eee-3054c7979ffc.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83d964aa-c271-41c7-9eee-3054c7979ffc.png)'
- en: 'Figure 2.3: Client script setting the incident category'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：设置事件类别的客户端脚本
- en: We will look at client scripts further in the next chapter and they are usually
    the main source of client-side scripting in an instance.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章进一步探讨客户端脚本，它们通常是实例中客户端脚本的主要来源。
- en: If we wanted to only run script when the record is not new, we can simply place
    a exclamation mark in front of the `if` condition to negate the expression and
    give us the option to add code for updating existing records.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想在记录不是新记录时运行脚本，我们可以在`if`条件前放置一个感叹号来否定表达式，并给我们添加更新现有记录代码的选项。
- en: 'The `if` statement would instead look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句将看起来像这样：'
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we can use many of the methods we saw earlier in the chapter
    together to achieve the scripting goals we are looking for.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以将本章中看到的一些方法结合起来，以实现我们寻找的脚本目标。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at using exposed JavaScript APIs and the well-used
    `GlideRecord` class. We also looked at server-side and client-side Glide classes
    and the properties and methods of each that can be used to enhance your scripting.
    Finally, we looked at some more complex examples of scripting, combining these
    properties and methods to show what can be achieved and how the properties and
    methods can be used together.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用公开的JavaScript API和常用的`GlideRecord`类。我们还探讨了服务器端和客户端的Glide类以及它们各自的属性和方法，这些属性和方法可以用来增强你的脚本。最后，我们查看了一些更复杂的脚本示例，结合这些属性和方法来展示可以实现什么，以及如何一起使用这些属性和方法。
- en: In the next chapter, we will explore the basics of client-side scripting. We
    will look at client scripts, UI policies, when to use these scripts, and how to
    test them. Plus we'll add some helpful examples to show some great ways to get
    the most out of client-side scripting.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨客户端脚本的基础知识。我们将探讨客户端脚本、UI策略、何时使用这些脚本以及如何测试它们。此外，我们还将添加一些有用的示例，展示如何充分利用客户端脚本。
