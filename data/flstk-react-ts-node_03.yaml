- en: '*Chapter 2*: Exploring TypeScript'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：探索TypeScript'
- en: In this chapter, we'll dive deeper into the TypeScript language. We'll learn
    about TypeScript's explicit type declaration syntax, as well as about the many
    built-in types in TypeScript and their purpose.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解TypeScript语言。我们将学习TypeScript的显式类型声明语法，以及TypeScript中许多内置类型及其用途。
- en: We'll also learn how to create our own types and build applications adhering
    to object-oriented principles. Finally, we'll review some of the latest features
    added to the language, such as optional chaining and nullish coalescing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何创建自己的类型，并构建遵循面向对象原则的应用程序。最后，我们将回顾语言中添加的一些最新功能，例如可选链和nullish合并。
- en: By the end of this chapter, you will have a strong understanding of the TypeScript
    language, which will allow you to read and understand existing TypeScript code
    with ease. You will also know enough about the language to produce high-quality
    code that achieves your application goals and is reliable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将对TypeScript语言有很好的理解，这将使您能够轻松阅读和理解现有的TypeScript代码。您还将了解足够多关于该语言，以便编写实现应用程序目标并且可靠的高质量代码。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What are types?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类型？
- en: Exploring TypeScript types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索TypeScript类型
- en: Understanding classes and interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类和接口
- en: Understanding inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解继承
- en: Learning generics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习泛型
- en: Learning the latest features and configuring the compiler
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习最新功能和配置编译器
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The requirements for this chapter are the same as in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017),
    *Understanding TypeScript*. You should have a basic understanding of JavaScript
    and web technologies. You will once again be using Node and **Visual Studio Code**
    (**VSCode**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与[*第1章*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017)中的*理解TypeScript*相同。您应该对JavaScript和Web技术有基本的了解。您将再次使用Node和**Visual
    Studio Code**（**VSCode**）。
- en: The GitHub repository is again at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap2` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库再次位于[https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node)。使用`Chap2`文件夹中的代码。
- en: 'Before continuing, let''s set up for this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们为本章做好准备：
- en: Go to your `HandsOnTypeScript` folder and create a new folder called `Chap2`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的`HandsOnTypeScript`文件夹并创建一个名为`Chap2`的新文件夹。
- en: Open VSCode and go to `Chap2` folder you just created. Then, select **View**
    | **Terminal** and enable the terminal window within your VSCode window.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VSCode并转到您刚创建的`Chap2`文件夹。然后，选择**视图** | **终端**并在VSCode窗口内启用终端窗口。
- en: Type the `npm init` command, as in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017),
    *Understanding TypeScript*, to initialize the project for `npm`, and accept all
    the defaults.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`npm init`命令，就像[*第1章*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017)中的*理解TypeScript*一样，来初始化`npm`项目，并接受所有默认设置。
- en: Type the `npm install typescript` command, as in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017),
    *Understanding TypeScript*, to install TypeScript.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`npm install typescript`命令，就像[*第1章*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017)中的*理解TypeScript*一样，来安装TypeScript。
- en: Now we're ready to get started.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好开始了。
- en: What are types?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类型？
- en: A **type** is a reusable set of rules. A type may include properties and functions
    (capabilities). It can also be shared and reused over and over again. When you
    reuse a type, you are creating an **instance** of it. This means that you are
    creating an example of your type that has specific values for properties. In TypeScript,
    as the name implies, types are very important. They're the main reason why the
    language was created in the first place. Let's take a look at how types work in
    TypeScript.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**是一组可重复使用的规则。类型可以包括属性和函数（能力）。它也可以被共享和重复使用。当您重用一个类型时，您正在创建它的**实例**。这意味着您正在创建您的类型的一个示例，该示例具有属性的特定值。在TypeScript中，正如其名称所示，类型非常重要。这是语言首次创建的主要原因。让我们看看TypeScript中类型是如何工作的。'
- en: How do types work?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型如何工作？
- en: As mentioned previously, JavaScript does have types. Number, string, Boolean,
    array, and so on are all types in JavaScript. However, those types are not explicitly
    set during declaration; they are only inferred at runtime. In TypeScript, types
    are normally set during declaration. It is possible to allow the compiler to infer
    your type. However, the type the compiler chooses may not be the one you desire
    since it isn't always obvious. In addition to the types supported by JavaScript,
    TypeScript has its own unique types and also allows you to create your own types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JavaScript确实具有类型。数字、字符串、布尔值、数组等在JavaScript中都是类型。然而，在声明时这些类型并没有被明确设置；它们只是在运行时被推断出来。在TypeScript中，类型通常在声明时设置。也可以允许编译器推断您的类型。然而，编译器选择的类型可能不是您想要的，因为它并不总是明显的。除了JavaScript支持的类型外，TypeScript还具有其自己独特的类型，并且还允许您创建自己的类型。
- en: The first thing to realize about types in TypeScript is that they are handled
    by their shape and not by their type name. This means the name of a type is not
    that important for the TypeScript compiler, but the properties it has and their
    types are important.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于TypeScript中类型的第一件事是，它们是由它们的形状而不是它们的类型名称处理的。这意味着类型的名称对于TypeScript编译器并不重要，但它具有的属性及其类型是重要的。
- en: 'Let''s look at an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: 'Create a file called `shape.ts` and add the following code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`shape.ts`的文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing you should notice is that we have a class called `Person` with
    a property called `name`. Below that, you see that we have a variable called `jill`
    that is of the `{ name: string }` type. This is a little weird because, as you
    can see, this type declaration is not an actual type name; it''s more like a type
    definition. But the compiler has no issues with it and does not complain. In TypeScript,
    it is possible to define and declare a type at the same time. Additionally, below
    that, you can see that we have another variable called `person` of the `Person`
    type and we set that to `jill`. Again, the compiler does not complain, and everything
    seems OK.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '您应该注意到的第一件事是，我们有一个名为“Person”的类，其中有一个名为“name”的属性。在下面，您会看到我们有一个名为“jill”的变量，它是“{
    name: string }”类型。这有点奇怪，因为您可以看到，这种类型声明不是实际的类型名称；它更像是类型定义。但是编译器没有任何问题，也没有抱怨。在TypeScript中，可以同时定义和声明类型。此外，在下面，您可以看到我们有另一个名为“person”的变量，它是“Person”类型，我们将其设置为“jill”。同样，编译器没有抱怨，一切似乎都很好。'
- en: 'Let''s compile this code and run it to see what happens. Type the following
    lines in the terminal:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译此代码并运行它，看看会发生什么。在终端中输入以下行：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you''ve run the commands, you should see the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，您应该会看到以下内容：
- en: '![Figure 2.1 – The shape.ts output'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 - shape.ts输出'
- en: '](img/Figure_2.01_B15508.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.01_B15508.jpg)'
- en: Figure 2.1 – The shape.ts output
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - shape.ts输出
- en: As you can see, the code compiles and runs without issue. This demonstrates
    that in TypeScript, the compiler looks at the shape of a type and is not concerned
    with its name at all. You will see in later chapters, as we dig more deeply into
    TypeScript types, why it is so important to be aware of this behavior.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码编译和运行都没有问题。这表明在TypeScript中，编译器查看类型的形状，并不关心其名称。在后面的章节中，当我们更深入地挖掘TypeScript类型时，您将看到了解这种行为为何如此重要。
- en: Exploring TypeScript types
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索TypeScript类型
- en: In this section, we'll look at some of the core types available in TypeScript.
    Using these types will give you error checking and compiler warnings that can
    help improve your code. They will also provide information about your intent to
    other developers that may be on your team. So, let's continue and see how these
    types work.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一些TypeScript中可用的核心类型。使用这些类型将为您提供错误检查和编译器警告，可以帮助改进您的代码。它们还将向其他可能在您团队上的开发人员提供有关您意图的信息。因此，让我们继续看看这些类型是如何工作的。
- en: The any type
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何类型
- en: The `any` type is a dynamic type that can be set to any other type. If you declare
    a variable to be of the `any` type, this means that you can set it to anything
    and reset it to anything else later as well. It is in effect no type because the
    compiler will not check it on your behalf. This is the key fact to remember about
    `any` – the compiler will not intercede and warn you of issues at development
    time. Therefore, if possible, using the `any` type should be avoided. It may seem
    weird that a language that was built to be statically typed would have such a
    feature, but it is a necessity under certain circumstances.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: “任何”类型是一种动态类型，可以设置为任何其他类型。如果将变量声明为“任何”类型，这意味着可以将其设置为任何内容，并且稍后也可以将其重置为任何其他内容。实际上，它没有类型，因为编译器不会代表您检查它。这是关于“任何”的关键事实
    - 编译器不会在开发时干预并警告您的问题。因此，如果可能的话，应避免使用“任何”类型。可能会觉得奇怪，一个旨在静态类型的语言会有这样的特性，但在某些情况下这是必要的。
- en: In a large application, it is not always possible for a developer to control
    the types that come into their code. For example, if a developer is relying on
    a web service API call to get data, that data's type may be controlled by some
    other team or even a different company entirely. This is also true during interop,
    when code relies on data from a different programming language – for example,
    when a company maintains a legacy system in another language while building out
    its new system in a different language. Situations like these require type flexibility
    and an escape hatch from the type system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序中，开发人员并不总是能够控制进入其代码的类型。例如，如果开发人员依赖于Web服务API调用来获取数据，那么数据的类型可能由其他团队或甚至完全不同的公司控制。在互操作期间，当代码依赖于来自不同编程语言的数据时，这也是真实的情况
    - 例如，当公司在另一种语言中维护遗留系统的同时，又在不同的语言中构建其新系统。这些情况需要类型的灵活性和对类型系统的逃生舱。
- en: It is important not to abuse the `any` type. You should be careful to only use
    it when you know you have no other alternative – for example, when type information
    is not clear or can change. There are a few alternatives to using the `any` type,
    however. Depending on the circumstance, you may be able to use interfaces, generics,
    unions, or the `unknown` type instead. We'll cover the rest of these possibilities
    later, but for now, let's go over the `unknown` type next.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要滥用“任何”类型。您应该小心，只有在知道没有其他选择时才使用它 - 例如，当类型信息不清晰或可能会更改时。但是，有一些替代方案可以使用“任何”类型。根据情况，您可能可以使用接口、泛型、联合类型或“未知”类型。我们将在后面涵盖其余这些可能性，但现在让我们接下来讨论“未知”类型。
- en: The unknown type
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未知类型
- en: The `unknown` type is a type released in TypeScript version 3\. It is similar
    to `any` in that once a variable of this type is declared, a value of any type
    can be set to it. That value can subsequently be changed to any other type. So,
    I could start by setting my variable to a string type and then later set it to
    number. However, you cannot call any of its members or set the variable as a value
    to another variable without first checking what its type really is. I'll show
    an example of this as follows. The only time you can set `unknown` to something
    else without first checking its type is when you set an `unknown` type to another
    `unknown` or an `any` type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: “未知”类型是在TypeScript版本3中发布的一种类型。它类似于“any”，因为一旦声明了这种类型的变量，就可以将任何类型的值设置给它。随后可以将该值更改为任何其他类型。因此，我可以首先将我的变量设置为字符串类型，然后稍后将其设置为数字。但是，您不能调用其任何成员或将变量设置为另一个变量的值，而不首先检查其真正的类型。我将如下所示地展示一个示例。您可以在不首先检查其类型的情况下将“未知”设置为其他内容的唯一时间是将“未知”类型设置为另一个“未知”或“任何”类型时。
- en: 'Let''s take a look at an example of `any` and then we''ll see why the `unknown`
    type is preferable to using the `any` type (it is in fact recommended by the TypeScript
    team over using `any`):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`any`的例子，然后我们将看到为什么`unknown`类型比使用`any`类型更可取（事实上，TypeScript团队建议使用`unknown`）：
- en: 'First, let''s take a look at an example of the issue with using `any`. Go to
    VSCode and create a file called `any.ts`, and then type the following code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看一下使用`any`存在的问题的一个例子。转到VSCode，创建一个名为`any.ts`的文件，然后输入以下代码：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run this code using the following commands, you will see the following
    result:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用以下命令运行此代码，您将看到以下结果：
- en: '![Figure 2.2 – any run result'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – any 运行结果'
- en: '](img/Figure_2.02_B15508.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.02_B15508.jpg)'
- en: Figure 2.2 – any run result
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – any 运行结果
- en: 'Since `val` is of the `any` type, we can set it to whatever we like and later
    call `push` into it since `push` is a method of `Array`. However, this is obvious
    only because we, as developers, are aware that `Array` has a method called `push`
    in it. What if we accidentally called something that does not exist on `Array`?
    Replace the previous code with the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`val`是`any`类型，我们可以将其设置为任何我们喜欢的值，然后调用`push`进入它，因为`push`是`Array`的一个方法。然而，这只是因为我们作为开发人员知道`Array`中有一个叫做`push`的方法。如果我们意外地调用了`Array`上不存在的东西会怎么样？用以下代码替换上一个代码：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, run the TypeScript compiler again:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行TypeScript编译器：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Figure 2.3 – any failing'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – any 失败'
- en: '](img/Figure_2.03_B15508.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.03_B15508.jpg)'
- en: Figure 2.3 – any failing
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – any 失败
- en: For this simple example, this error is unlikely, but in a large application,
    it is an easy error to make, even if the mistake is simply to mistype something.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的例子，这种错误不太可能发生，但在一个大型应用程序中，即使错误只是简单地拼错了一些东西，也很容易发生。
- en: 'Let''s see a similar example using `unknown`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个类似的使用`unknown`的例子：
- en: First, comment out your code inside of `any.ts` and delete the `any.js` file
    (as we will use the same variable names, if you do not, it will cause conflict
    errors).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，注释掉`any.ts`中的代码，并删除`any.js`文件（因为我们将使用相同的变量名，如果不这样做，将会导致冲突错误）。
- en: Important Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We'll learn about something called namespaces later that can eliminate these
    sorts of conflicts, but it's a little too soon to introduce them now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将学习一些称为命名空间的东西，它可以消除这些冲突，但现在介绍它们还为时过早。
- en: 'Now, create a new file called `unknown.ts` and add the following code to it:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`unknown.ts`的新文件，并将以下代码添加到其中：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will notice that VSCode gives you an error, immediately complaining about
    the `push` function. This is weird since obviously, `Array` has a method called
    `push` in it. This behavior shows how the `unknown` type works. You can consider
    the `unknown` type to be sort of like a label more than a type, and underneath
    that label is the actual type. However, the compiler cannot figure out the type
    on its own, so we need to explicitly prove the type to the compiler ourselves.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到VSCode给出了一个错误，立即抱怨`push`函数。这很奇怪，因为显然`Array`中有一个叫做`push`的方法。这种行为展示了`unknown`类型的工作原理。您可以将`unknown`类型视为一种标签，而不是一种类型，在该标签下是实际类型。然而，编译器无法自行确定类型，因此我们需要自己向编译器明确证明类型。
- en: 'We use type guards to prove that `val` is of a certain type:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用类型守卫来证明`val`是某种类型：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we've wrapped our `push` call with a test to see whether `val`
    is an instance of `Array`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们用一个测试来包装我们的`push`调用，以查看`val`是否是`Array`的一个实例。
- en: 'Once we have established this to be true, the call to `push` can proceed without
    error, as shown here:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们证明这是真的，对`push`的调用就可以继续进行，如下所示：
- en: '![Figure 2.4 – unknown'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – 未知'
- en: '](img/Figure_2.04_B15508.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.04_B15508.jpg)'
- en: Figure 2.4 – unknown
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 未知
- en: This mechanism is a bit cumbersome since we always have to test the type before
    calling members. However, it is still preferable instead of using the `any` type
    and a lot safer since it is checked by the compiler.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制有点繁琐，因为我们总是需要在调用成员之前测试类型。然而，与使用`any`类型相比，它仍然更可取，因为它由编译器检查，更安全。
- en: Intersection and union types
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交集和联合类型
- en: 'Remember when we started this section by saying that the TypeScript compiler
    focuses on type shape and not the name? This mechanism allows TypeScript to support
    what''s called `obj` that has two types associated with it. You will recall that
    in TypeScript, we can not only declare named types as a variable''s type but also
    dynamically define and declare a type at the same time. In the following code,
    each type is a distinct type, but the `&` keyword is used to merge the two into
    a single type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在本节开始时说过TypeScript编译器关注类型形状而不是名称吗？这种机制允许TypeScript支持所谓的`obj`，它与两种类型相关联。您会记得在TypeScript中，我们不仅可以将命名类型声明为变量的类型，还可以同时动态定义和声明类型。在以下代码中，每种类型都是不同的类型，但`&`关键字用于将两种类型合并为单一类型：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s try running this code and displaying the result on the console. Create
    a new file called `intersection.ts` and add the following code to it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行这段代码，并在控制台上显示结果。创建一个名为`intersection.ts`的新文件，并将以下代码添加到其中：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you compile and run this code, you will see an object that contains both
    the name and age properties together:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编译并运行此代码，您将看到一个包含名称和年龄属性的对象：
- en: '![Figure 2.5 – Intersection result'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 交集结果'
- en: '](img/Figure_2.05_B15508.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.05_B15508.jpg)'
- en: Figure 2.5 – Intersection result
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 交集结果
- en: As you can see, both IntelliSense and the compiler accept the code and the final
    object has both properties. This is an intersection type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，IntelliSense和编译器都接受了该代码，最终对象具有两个属性。这是一个交集类型。
- en: 'The other type is similar and is called the `union` type. In the case of unions,
    instead of merging types, we are using them in an "or" fashion, where it''s one
    type or another. Let''s look at an example. Create a new file called `union.ts`
    and add the following code to it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型类似，称为`union`类型。在联合的情况下，我们不是合并类型，而是以“或”的方式使用它们，即一个类型或另一个类型。让我们看一个例子。创建一个名为`union.ts`的新文件，并将以下代码添加到其中：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `unionObj` variable is declared to be of the null type or `{ name: string
    }`, by the use of the `|` character. If you compile and run this code, you''ll
    see that it accepts both type values. This means that the type value can be either
    null or an object of the `{ name: string }` type.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`unionObj`变量被声明为null类型或`{ name: string }`，通过使用`|`字符。如果编译并运行这段代码，你会看到它接受两种类型的值。这意味着类型值可以是null，也可以是`{
    name: string }`类型的对象。'
- en: Literal types
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文字类型
- en: '**Literal** types are similar to union types, but they use a set of hardcoded
    string or number values. Here''s a simple example of string literals that is fairly
    self-explanatory. As you can see, we have a bunch of hardcoded strings as the
    type. This means that only values that are the same as any of these strings will
    be accepted for the literal variable:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**文字**类型类似于联合类型，但它们使用一组硬编码的字符串或数字值。这是一个相当简单的字符串文字示例，相当容易理解。正如你所看到的，我们有一堆硬编码的字符串作为类型。这意味着只有与这些字符串中的任何一个相同的值才会被接受为文字变量：'
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the compiler is happy to receive any of the values on the list
    and even reset them. However, it will not allow the setting of a value that is
    not on the list. This will give a compile error. Let''s see an example of this.
    Update the code as shown by resetting the literal variable to `john`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，编译器很高兴接收列表中的任何值，甚至重置它们。然而，它不会允许设置不在列表中的值。这将导致编译错误。让我们看一个例子。按照将文字变量重置为`john`的方式更新代码：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we set the literal variable to `john`, and compiling gives the following
    error:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将文字变量设置为`john`，编译会出现以下错误：
- en: '![Figure 2.6 – A literal error'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – 一个文字错误'
- en: '](img/Figure_2.06_B15508.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.06_B15508.jpg)'
- en: Figure 2.6 – A literal error
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 一个文字错误
- en: A numeric literal is also possible in the same way, but the values are made
    of numbers instead of strings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数字文字也可以以相同的方式进行，但值是由数字而不是字符串组成的。
- en: Type aliases
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'Type aliases are used very frequently in TypeScript. This is simply a method
    to give a different name to a type and most of the time it is used to provide
    a shorter simpler name to some complex type. For example, here''s one possible
    usage:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，类型别名被非常频繁地使用。这只是一种为类型提供不同名称的方法，大多数情况下用于为某些复杂类型提供更短的简单名称。例如，这里是一个可能的用法：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code, we take a long numeric literal type and give it a shorter name
    of `Points`. Then, we declare `score` as the `Points` type and give it a value
    of `20`, which is one of the possible values for `Points`. And of course, if we
    tried to set score to, let's say, `99`, compilation would fail.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将一个长数字文字类型赋予一个更短的名字`Points`。然后，我们声明`score`为`Points`类型，并给它一个值`20`，这是`Points`的可能值之一。当然，如果我们试图将分数设置为，比如，`99`，编译将失败。
- en: 'Another example of aliases would be for object literal type declarations:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个别名的例子是对象文字类型声明：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since the type declaration is very long and does not have a name, as, for example,
    a class would, we use an alias instead. Type aliasing can be used for just about
    any type in TypeScript, including things such as functions and generics, which
    we'll explore further later in the chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型声明非常长并且没有名称，例如类会有的，我们使用别名。在TypeScript中，类型别名可以用于包括函数和泛型在内的几乎任何类型，我们将在本章后面进一步探讨。
- en: Function return types
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数返回类型
- en: 'For completeness'' sake, I wanted to show one example of a function return
    declaration. It''s quite similar to a typical variable declaration. Create a new
    file called `functionReturn.ts` and add this into it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我想展示一个函数返回声明的例子。它与典型的变量声明非常相似。创建一个名为`functionReturn.ts`的新文件，并将其添加到其中：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `runMore` function takes a parameter of the `number` type and returns a
    number. The parameter declaration is just like any variable declaration, but the
    function return comes after the parentheses and indicates what type is returned
    by the function. If a function returns nothing, then you can either not declare
    any type for the return or you can declare `void` to be more explicit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`runMore`函数接受`number`类型的参数并返回一个数字。参数声明就像任何变量声明一样，但是函数返回在括号之后，并指示函数返回的类型。如果函数不返回任何内容，那么可以不声明返回的类型，或者可以声明`void`以更明确。'
- en: 'Let''s look at an example of returning `void`. Comment out the `runMore` function
    and console log, and then compile and run this code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个返回`void`的例子。注释掉`runMore`函数和控制台日志，然后编译并运行这段代码：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The two functions return nothing but write their given parameters to the console,
    as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数什么都不返回，只是将它们的参数写入控制台，如下所示：
- en: '![Figure 2.7 – Function void results'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – 函数void结果'
- en: '](img/Figure_2.07_B15508.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.07_B15508.jpg)'
- en: Figure 2.7 – Function void results
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 函数void结果
- en: As you can see, their internal `console.log` statements do run. However, trying
    to grab a return value results in `undefined` since nothing is being returned.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它们的内部`console.log`语句确实运行。然而，尝试获取返回值会导致`undefined`，因为没有返回任何内容。
- en: So, function return type declaration is quite similar to variable declarations.
    Now, let's take a look at using functions as types.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数返回类型声明与变量声明非常相似。现在，让我们看看如何将函数用作类型。
- en: Functions as types
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为类型
- en: It may seem a bit odd but in TypeScript, a type can also be an entire function
    signature. That is to say that in the previous section, we saw how functions can
    accept parameters based on types and also return a type. Well, this definition
    is also known as a function signature. In TypeScript, this signature can also
    act as a type for an object's properties.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，类型也可以是整个函数签名。也就是说，在前面的部分中，我们看到函数可以接受基于类型的参数，并返回一个类型。嗯，这个定义也被称为函数签名。在TypeScript中，这个签名也可以作为对象属性的类型。
- en: 'Let''s take a look at an example of this. Create a new file called `functionSignature.ts`
    and add the following code into it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。创建一个名为`functionSignature.ts`的新文件，并将以下代码添加到其中：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first line shows us a function type that we will be using in this code.
    The `Run` type alias is only there to make it easier to reuse the long function
    signature. The actual function type is `(miles: number) => boolean`. This looks
    odd, but it''s nothing more than a slimmed-down function signature. So, the only
    things needed then are the parentheses to indicate parameters, the `=>` symbol,
    which indicates that this is a function, and then the return type.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行显示了我们将在此代码中使用的函数类型。`Run`类型别名只是为了使重用长函数签名更容易。实际的函数类型是`(miles: number) =>
    boolean`。这看起来很奇怪，但它只是一个简化的函数签名。所以，唯一需要的是用括号表示参数，`=>`符号表示这是一个函数，然后是返回类型。'
- en: 'In the code after the function definition line, you have the declaration of
    the `runner` variable as the `Run` type, which is again a function. This function
    simply checks whether the person has run more than 10 miles, and returns `true`
    if they have and `false` if they have not. Then, at the bottom of the code, the
    `console.log` statement writes out the result of the function call. You should
    see this once compiled and run:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义行之后的代码中，您可以看到`runner`变量声明为`Run`类型，这又是一个函数。这个函数简单地检查人是否跑了超过10英里，并在他们跑了超过10英里时返回`true`，否则返回`false`。然后，在代码底部，`console.log`语句输出函数调用的结果。编译和运行后，您应该能看到这个结果：
- en: '![Figure 2.8 – Function type result'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 – 函数类型结果'
- en: '](img/Figure_2.08_B15508.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.08_B15508.jpg)'
- en: Figure 2.8 – Function type result
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 函数类型结果
- en: As you can see, calling `runner` with a parameter of `9` would make the function
    return `false`, which is correct. With static typing, it is important to be able
    to type all the ways we can return data, which means not only variables but also
    functions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，使用参数`9`调用`runner`会使函数返回`false`，这是正确的。在静态类型中，能够对我们返回数据的所有方式进行类型标注是很重要的，这意味着不仅是变量，还有函数。
- en: The never type
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 永远类型
- en: This type is going to sound quite strange at first. A `never` type is used to
    indicate a function that never returns (completes), or a variable that is not
    set to anything, not even `null`. At first glance, this sounds like the `void`
    type. However, they are not at all the same. In `void`, a function does return,
    in the complete sense of the word, it just does not return any value (it returns
    `undefined`, which is no value). In the case of `never`, the function does not
    finish at all. Now, this seems totally useless but it's actually quite useful
    for indicating intent.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型一开始会听起来很奇怪。`never`类型用于指示一个永远不会返回（完成）的函数，或者一个没有设置为任何值的变量，甚至不是`null`。乍一看，这听起来像`void`类型。然而，它们根本不一样。在`void`中，函数确实返回，完全意义上的返回，它只是不返回任何值（返回`undefined`，这是没有值）。在`never`的情况下，函数根本不会完成。现在，这似乎完全没有用，但实际上它对于指示意图是非常有用的。
- en: 'Again, let''s look at an example. Create a file called `never.ts` and add the
    following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们看一个例子。创建一个名为`never.ts`的文件，并添加以下代码：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, this function returns a `union` type that is either `never`
    or a Boolean. Now, we could have only indicated the Boolean and the code would
    still work. However, in this function, we are throwing an error if the person
    is over a certain age, indicating that this is an unexpected `age` value. So,
    since encapsulation is a high-level principle for writing good-quality code, it
    is beneficial to indicate explicitly that a failure of the function to return
    could occur without needing the developer to know about the internals of how the
    function works. `never` provides that communication.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，这个函数返回一个`union`类型，要么是`never`，要么是布尔值。现在，我们只能指示布尔值，代码仍然可以工作。然而，在这个函数中，如果人的年龄超过一定年龄，我们会抛出一个错误，表明这是一个意外的`age`值。因此，由于封装是编写高质量代码的高级原则，明确指示函数可能失败而无需开发人员了解函数工作原理的内部细节是有益的。`never`提供了这种沟通。
- en: In this section, we learned about the many built-in types in TypeScript. We
    were able to see why using these types can improve our code quality and help us
    catch errors early on in the coding cycle. In the next section, we'll learn about
    how we can use TypeScript to create our own types, and also follow object-oriented
    programming principles.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了TypeScript中许多内置类型。我们能够看到为什么使用这些类型可以提高我们的代码质量，并帮助我们在编码周期的早期发现错误。在下一部分，我们将学习如何使用TypeScript来创建我们自己的类型，并遵循面向对象编程原则。
- en: Understanding classes and interfaces
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类和接口
- en: We've already briefly looked at classes and interfaces in previous sections.
    Let's take a deeper look, in this section, and see why these types can help us
    write better code. Once we complete this section, we will be better prepared to
    write more readable, reusable code with fewer bugs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的部分简要地看过类和接口。让我们在这一部分深入了解一下，并看看为什么这些类型可以帮助我们编写更好的代码。一旦我们完成了这一部分，我们将更好地准备好编写更易读、可重用的代码，bug更少。
- en: Classes
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: At a base level, classes in TypeScript look just like classes in JavaScript.
    They are a container for a related set of fields and methods that can be instantiated
    and reused. However, classes in TypeScript support extra features for encapsulation
    that JavaScript does not. Let's take a look at an example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，TypeScript中的类看起来就像JavaScript中的类。它们是一个相关字段和方法的容器，可以被实例化和重用。然而，TypeScript中的类支持JavaScript不支持的封装的额外特性。让我们看一个例子。
- en: 'Create a new file called `classes.ts` and enter the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`classes.ts`的新文件，并输入以下代码：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, this example shows a simple class that, with the exception of
    the static typing, is just like what you might see in JavaScript. Firstly, you
    have a name for the class so that it can be reused. Next, you have a constructor,
    which is used to initialize any fields that the class might have and do any other
    setup for the class instance (again, an instance is just a specific example of
    our class with its own unique values for fields). Then, you have a single variable
    called `msg` declared and a function called `speak` that writes the `msg` value
    to the console. We then create an instance of our class. Finally, we set the `msg`
    field to a value of `hello` and call the `speak` method. Now, let's look at how
    classes differ between TypeScript and JavaScript.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个例子展示了一个简单的类，除了静态类型之外，它与JavaScript中看到的类似。首先，您为类命名，以便可以重用。接下来，您有一个构造函数，用于初始化类可能具有的任何字段，并为类实例进行任何其他设置（再次，实例只是我们的类的特定示例，具有自己字段的唯一值）。然后，您声明了一个名为`msg`的变量和一个名为`speak`的函数，该函数将`msg`的值写入控制台。然后，我们创建了我们类的一个实例。最后，我们将`msg`字段设置为`hello`的值，并调用`speak`方法。现在，让我们看一看TypeScript和JavaScript之间类的区别。
- en: Access modifiers
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: 'We stated previously that one of the main principles of object-oriented development
    is encapsulation, or information hiding. Well, if we take a look at the code again
    clearly, we are not hiding the `msg` variable as it is exposed and editable outside
    of the class. So, let''s see what TypeScript allows us to do about this. Let''s
    update the code like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到面向对象开发的一个主要原则是封装，或者信息隐藏。好吧，如果我们再次清楚地看一下代码，我们并没有隐藏`msg`变量，因为它在类外是可见和可编辑的。所以，让我们看看TypeScript允许我们对此做些什么。让我们像这样更新代码：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we updated the constructor with a keyword called `private`.
    This method of declaring a constructor parameter and also adding an access modifier
    is doing several things in one line. Firstly, it is telling the compiler that
    the class has a field called `msg` of the `string` type that should be `private`.
    Normally, this sort of declaration is done in a line above or below the constructor
    separately, which is totally valid to do, but TypeScript allows us to use a shortcut
    by adding it to the constructor parameter. Additionally, by adding this to the
    constructor, you can see that it allows our `msg` field to be set at instantiation
    time with the `new Person("hello")` call.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用关键字`private`更新了构造函数。通过声明构造函数参数并添加访问修饰符，一行代码实际上做了几件事。首先，它告诉编译器类具有一个名为`msg`的`string`类型字段，应该是`private`的。通常，这种声明是在构造函数上方或下方的一行中分开完成的，这样做是完全有效的，但是TypeScript允许我们通过将其添加到构造函数参数中来使用快捷方式。此外，通过将其添加到构造函数中，您可以看到它允许我们在实例化时使用`new
    Person("hello")`调用来设置我们的`msg`字段。
- en: 'Now, what does setting something to `private` actually do? By setting the field
    to `private`, we make it inaccessible from outside of the class. The result of
    this is that `tom.msg = "hello"` no longer works and causes an error. Try removing
    the comments and compile again. You should see this message:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将某些东西设置为`private`实际上是做了什么？通过将字段设置为`private`，我们使其无法从类外部访问。其结果是`tom.msg = "hello"`不再起作用并引发错误。尝试删除注释并重新编译。您应该会看到此消息：
- en: '![Figure 2.9 – Classes error'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 - 类错误'
- en: '](img/Figure_2.09_B15508.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.09_B15508.jpg)'
- en: Figure 2.9 – Classes error
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 - 类错误
- en: As you can see, it complains that a private member, `msg`, cannot be accessed
    from outside of the class. Now, we only applied our modifier to a field, but note
    that access modifiers can be applied to any member field or function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它抱怨私有成员`msg`无法从类外部访问。现在，我们只将修饰符应用于字段，但请注意，访问修饰符可以应用于任何成员字段或函数。
- en: Important Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As mentioned previously, ECMAScript 2020 will support private fields via the
    `#` symbol. However, only fields are supported, and it is such a new standard
    that browser support is limited as of the time of writing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ECMAScript 2020将通过`#`符号支持私有字段。但是，目前浏览器对其支持有限，因为它只支持字段，并且这是一个全新的标准。
- en: 'Now, let''s learn about the `readonly` modifier. This one is relatively straightforward;
    it causes a field to become read-only after it has been set one time in the constructor.
    So, update the code as follows and add `readonly` to the declaration of the `msg`
    field:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习`readonly`修饰符。这个相对简单；它使字段在构造函数中设置一次后变为只读。因此，更新代码如下，并在`msg`字段的声明中添加`readonly`：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you do this, IntelliSense complains because, in the `speak` function, we
    are attempting to change the value of `msg` even though it has already been set
    once through the constructor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做，IntelliSense会抱怨，因为在`speak`函数中，尽管`msg`已经通过构造函数设置了一次，我们仍然试图改变`msg`的值。
- en: The `private` and `readonly` access modifiers are not the only modifiers available
    in TypeScript. There are several other types of access modifiers. However, they
    will make more sense if we explain them in the context of inheritance later.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`和`readonly`访问修饰符并不是TypeScript中唯一的修饰符。还有几种其他类型的访问修饰符。但是，如果我们稍后在继承的上下文中解释它们，它们会更有意义。'
- en: Getters and setters
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Getter和setter
- en: 'Another feature of classes is actually available in both TypeScript and JavaScript:
    **getters** and **setters**:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类的另一个特性实际上在TypeScript和JavaScript中都可用：**getter**和**setter**：
- en: '**Getter**: A property that allows modification or validation of a related
    field before returning it'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Getter**：允许在返回相关字段之前修改或验证值的属性'
- en: '**Setter**: A property that allows modification or computation of a value before
    setting to a related field'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Setter**：允许在设置到相关字段之前修改或计算值的属性'
- en: 'In some other languages, these types of properties are known as computed properties.
    Let''s look at an example. Create another file called `getSet.ts` and add the
    following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他一些语言中，这些类型的属性被称为计算属性。让我们看一个例子。创建一个名为`getSet.ts`的文件，并添加以下代码：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's a fair amount happening here, so let's go over it before compiling and
    running. First, you can see that our `message` field is not available in the constructor
    but is a `private` field, and therefore not accessible directly from outside our
    class. The only initializer the constructor takes is our `name` field. After that,
    you can see the `Message` property is a getter because its name is prefixed with
    the `get` keyword. In the getter, we test to see whether our `message` field value
    has the speaker's name in it, and if it does not, we throw an exception to indicate
    an unwanted situation. The setter, also called `Message`, is indicated by the
    `set` keyword and this property receives a string and adds the speaker's name
    if needed by checking whether it is missing from the `message` field. Note that
    although both `getter` and `setter` look like functions, they are not. When they
    are called later in code, they are called just like a field would be called without
    the parentheses. So then, toward the end of the code, the speaker object is instantiated
    to a new speaker with a name of `john` and its `Message` property is set to `hello`.
    Thereafter, the message is written to the console.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以在编译和运行之前让我们来看一下。首先，你可以看到我们的`message`字段不在构造函数中可用，而是一个`private`字段，因此不能直接从我们的类外部访问。构造函数接受的唯一初始化器是我们的`name`字段。之后，你可以看到`Message`属性是一个getter，因为它的名称前缀带有`get`关键字。在getter中，我们测试看看我们的`message`字段值是否包含说话者的名字，如果不包含，我们抛出一个异常来指示一个不需要的情况。setter，也称为`Message`，由`set`关键字指示，这个属性接收一个字符串，并通过检查`message`字段是否缺少说话者的名字来添加它。请注意，尽管`getter`和`setter`看起来像函数，但它们并不是。当它们在后面的代码中被调用时，它们被调用就像一个字段被调用一样，不带括号。因此，在代码的最后，speaker对象被实例化为一个名为`john`的新speaker，并且它的`Message`属性被设置为`hello`。此后，消息被写入控制台。
- en: Now, we want to compile this code so that we can run it, but we need to do something
    a bit differently this time. The TypeScript compiler has options that it can take
    in order to customize its behavior. In the case of this example, getters and setters
    and the `includes` function are only available in ES5 and ES6, respectively. If
    you're not familiar with it, the `includes` function checks whether a string is
    a substring of a larger string. So, let's tell the TypeScript compiler that it
    needs to compile to a newer JavaScript target than ES3, which is the default.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要编译这段代码，以便我们可以运行它，但这次我们需要做一些不同的事情。TypeScript编译器有一些选项，它可以接受以定制其行为。在这个例子中，getter和setter以及`includes`函数只在ES5和ES6中才可用。如果你对此不熟悉，`includes`函数检查一个字符串是否是另一个较大字符串的子字符串。因此，让我们告诉TypeScript编译器，它需要编译到比默认的ES3更新的JavaScript目标。
- en: 'Here''s the new compile command you''ll need (we''ll go over the `tsc` compiler
    options in more depth later, including using a configuration file):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要的新编译命令（我们稍后会更深入地讨论`tsc`编译器选项，包括使用配置文件）：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, you can run the command. Once again, it''s as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行命令。再一次，它如下所示：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, you now get the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你现在得到了以下输出：
- en: '![Figure 2.10 – getSet output'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10 – getSet输出'
- en: '](img/Figure_2.10_B15508.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.10_B15508.jpg)'
- en: Figure 2.10 – getSet output
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – getSet输出
- en: 'To drive the point home further, let''s try switching the `speaker.Message
    = "hello"` line to `speaker.message = "hello"`. If you compile, you should see
    this error:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步强调这一点，让我们尝试将`speaker.Message = "hello"`这一行切换为`speaker.message = "hello"`。如果你编译，你应该会看到这个错误：
- en: '![Figure 2.11 – Message field error'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11 – Message字段错误'
- en: '](img/Figure_2.11_B15508.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.11_B15508.jpg)'
- en: Figure 2.11 – Message field error
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – Message字段错误
- en: Can you guess why this failed? Yes, this occurred because `message` is a `private`
    field and cannot be accessed from outside our class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到为什么会失败吗？是的，这是因为`message`是一个`private`字段，不能从我们的类外部访问。
- en: You may be wondering why I mentioned `getters` and `setters` here when they
    are available in regular JavaScript too. If you look at the example, you can see
    that the `message` field is `private` and the `getter` and `setter` properties
    are `public` (note that when you are not explicitly declaring access modifiers,
    the default is `public`). So, to allow good encapsulation, it is a best practice
    to hide our field and only expose it when needed via a getter and/or setter or
    some function that allows modification of the field. Also remember, when deciding
    on an access level to your members, that you want to start with the most restrictive
    capabilities first and then become less restrictive as needed. Additionally, by
    allowing field access via accessors, we can do all sorts of checks and modifications,
    as we've done in our example, so that we have ultimate control over what comes
    in and out of our class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想为什么我在这里提到`getter`和`setter`，当它们在常规JavaScript中也是可用的。如果你看一下例子，你会发现`message`字段是`private`的，而`getter`和`setter`属性是`public`的（注意，当你没有显式声明访问修饰符时，默认为`public`）。因此，为了允许良好的封装，最好的做法是隐藏我们的字段，并且只在需要时通过getter和/或setter或一些允许修改字段的函数来暴露它。还要记住，在决定成员的访问级别时，你希望从最严格的能力开始，然后根据需要变得不那么严格。此外，通过允许通过访问器访问字段，我们可以做各种检查和修改，就像我们在例子中所做的那样，这样我们就可以对进出我们的类的内容有最终的控制。
- en: Static properties and methods
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态属性和方法
- en: Finally, let's discuss **static** properties and methods. When you mark something
    as static inside of a class, you are saying that this member is a member of the
    class type and not of the class instance. Therefore, it can be accessed without
    needing to create an instance of a class, but instead by prefixing with the class
    name.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们讨论**静态**属性和方法。当你在类内部将某些东西标记为静态时，你是在说这个成员是类类型的成员，而不是类实例的成员。因此，它可以在不需要创建类的实例的情况下访问，而是通过在类名前加上前缀来访问。
- en: 'Let''s look at an example. Create a new file called `staticMember.ts` and add
    the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。创建一个名为`staticMember.ts`的新文件，并添加以下代码：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you attempt to compile this code, it will fail, stating that `typeName`
    is a static member of the `ClassA` type. Again, static members must be called
    using the class name. Here are the fixed versions of the code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编译这段代码，它将失败，并声明`typeName`是`ClassA`类型的静态成员。再次强调，静态成员必须使用类名调用。以下是修复后的代码版本：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, we reference `typeName` with the class name. So then, the question
    is why might I want to use a static member instead of an instance member? Under
    certain circumstances, it may be useful to share data across class instances.
    For example, I might want to do something like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们用类名引用了`typeName`。那么，为什么我要使用静态成员而不是实例成员呢？在某些情况下，跨类实例共享数据可能是有用的。例如，我可能想要做这样的事情：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the case of this example, I am trying to determine the last class instance
    that has called the `run` function at any given time. This can be straightforward
    by using a static member. Another point to be aware of is that inside a class,
    static members can be called by both static members and instance members. However,
    static members cannot call instance members.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我试图确定在任何给定时间内最后调用`run`函数的类实例。通过使用静态成员，这可以很简单。还要注意的一点是，在类内部，静态成员可以被静态成员和实例成员调用。但是，静态成员不能调用实例成员。
- en: Now we have learned about classes and their features in this section. This will
    help us design our code for encapsulation, which will enhance its quality. Next,
    we will learn about interfaces and contract-based coding.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本节中学习了类及其特性。这将有助于我们为封装设计代码，从而提高其质量。接下来，我们将学习接口和基于合同的编码。
- en: Interfaces
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: In object-oriented programming design, another important principle is abstraction.
    The goal of abstraction is to reduce complexity and the tight coupling of code
    by not exposing the internal implementation (we've already covered abstraction
    in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017), *Understanding
    TypeScript*). One way of doing this is to use **interfaces** to show only the
    signature of a type, as opposed to its internal workings. An interface is also
    sometimes called a contract, since having specific types for parameters and return
    types enforces certain expectations between both the user and the creator of the
    interface. So, another way of thinking about interfaces is as strict rules about
    what can come out of and go into a type instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程设计中，另一个重要的原则是抽象。抽象的目标是通过不暴露内部实现来减少代码的复杂性和紧密耦合（我们已经在《第1章》《理解TypeScript》中涵盖了抽象）。这样做的一种方式是使用接口来仅显示类型的签名，而不是其内部工作方式。接口有时也被称为合同，因为对参数和返回类型进行特定类型的约束会强制执行接口的用户和创建者之间的某些期望。因此，对接口的另一种思考方式是对类型实例的输出和输入施加严格的规则。
- en: 'Now, interfaces are just a set of rules. In order to have working code, we
    need an implementation of those rules to get any work done. So, let''s show an
    example of an interface with implementation to get started. Create a new file
    called `interfaces.ts` and add the following interface definition:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，接口只是一组规则。为了使代码正常工作，我们需要对这些规则进行实现。因此，让我们展示一个带有实现的接口的示例以开始。创建一个名为`interfaces.ts`的新文件，并添加以下接口定义：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This interface defines an `Employee` type that we will create instances for
    later. As you can see, there is no implementation of the `getUniqueId` function,
    just its signature. The implementation comes later when we define it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口定义了我们稍后将创建实例的`Employee`类型。正如你所看到的，`getUniqueId`函数没有实现，只有其签名。实现将在我们定义它时进行。
- en: 'Now, add the implementation to the `interfaces.ts` file. Insert the following
    code, which creates two instances of the `Employee` interface:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将实现添加到`interfaces.ts`文件中。插入以下代码，创建`Employee`接口的两个实例：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So, we create an instance by instantiating an object literal called `linda`,
    setting the two field names – `name` and `id` – and then implementing the `getUniqueId`
    function. Later, we console log the `linda.getUniqueId` call. After that, we create
    another object, called `pam`, based on the same interface. However, not only does
    it have different field values, but its implementation of `getUniqueId` is also
    different than the `linda` object. This is the main use of interfaces: to allow
    for a single structure across objects but to enable different implementations.
    In this way, we provide strict rules about what the type structure is, but also
    allow some flexibility in terms of how functions go about doing their work. Here''s
    the output of our code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过实例化一个名为`linda`的对象文字来创建一个实例，设置两个字段名 - `name`和`id`，然后实现`getUniqueId`函数。稍后，我们在控制台记录`linda.getUniqueId`调用。之后，我们创建另一个对象，名为`pam`，基于相同的接口。然而，它不仅具有不同的字段值，而且其`getUniqueId`的实现也与`linda`对象不同。这是接口的主要用途：允许对象之间有一个统一的结构，但可以实现不同的实现。通过这种方式，我们对类型结构施加严格的规则，但也允许函数在执行其工作时具有一定的灵活性。以下是我们代码的输出：
- en: '![Figure 2.12 – Employee interface results'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12 - 员工接口结果'
- en: '](img/Figure_2.12_B15508.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.12_B15508.jpg)'
- en: Figure 2.12 – Employee interface results
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 - 员工接口结果
- en: Another possible use of interfaces is when using third-party APIs. Sometimes,
    the type information is not well documented and all you're getting back is untyped
    JSON or the object type is extremely large and has many fields you will never
    use. It is quite tempting, under these circumstances, to just use `any` as the
    type and be done with it. However, you should prefer providing a type declaration
    if at all possible.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的另一个可能用途是在使用第三方API时。有时，类型信息没有很好地记录，你得到的只是无类型的JSON或者对象类型非常庞大，有许多你永远不会使用的字段。在这种情况下，很容易只是使用`any`作为类型并完成它。然而，如果可能的话，你应该更倾向于提供类型声明。
- en: What you can do under these circumstances is to create an interface that has
    only the fields that you know and care about. Then, you can declare your data
    type to be of this type. At development time, TypeScript will not be able to check
    the type since for API network call's data will be coming in at runtime. But regardless,
    since TypeScript only cares about the shape of any given type, it will ignore
    the fields not mentioned in your type declaration and as long as the data comes
    in with the fields you defined in your interface, the runtime will not complain
    and you will maintain development time type safety. However, please do be careful
    to handle `null` or `undefined` fields appropriately, by allowing them to use
    unions or testing for those types.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以创建一个只包含您知道并关心的字段的接口。然后，您可以声明您的数据类型为此类型。在开发时，TypeScript 将无法检查类型，因为
    API 网络调用的数据将在运行时传入。但是，由于 TypeScript 只关心任何给定类型的形状，它将忽略未在类型声明中提到的字段，只要数据以您在接口中定义的字段传入，运行时就不会抱怨，您将保持开发时的类型安全。但是，请务必小心处理`null`或`undefined`字段，允许它们使用联合或测试这些类型。
- en: In this section, we learned about interfaces and the differences between interfaces
    and classes. We will be able to use interfaces to abstract away the implementation
    details of a class and therefore produce loose coupling between our code and therefore
    better code quality. In the next section, we will learn about how classes and
    interfaces allow us to perform inheritance and therefore code reuse.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了接口和接口与类之间的区别。我们将能够使用接口来抽象类的实现细节，从而在我们的代码之间产生松耦合，从而提高代码质量。在下一节中，我们将学习类和接口如何允许我们执行继承，从而实现代码重用。
- en: Understanding inheritance
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解继承
- en: In this section, we'll learn about **inheritance**. Inheritance in object-oriented
    programming is a method for doing code reuse. This will shrink our application
    code size and make it more readable. Also, generally, shorter code tends to have
    fewer bugs. So, all these factors will improve our app quality once we get started
    building.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习**继承**。面向对象编程中的继承是一种代码重用的方法。这将缩小我们的应用程序代码大小，并使其更易读。此外，一般来说，较短的代码往往会有更少的错误。因此，一旦开始构建，所有这些因素都将提高我们应用程序的质量。
- en: 'As stated, inheritance is primarily about allowing code reuse. Inheritance
    is also conceptually designed to be like real-life inheritance so that the logical
    flow of inheritance relationships can be intuitive and easier to understand. Let''s
    look at an example of this now. Create a file called `classInheritance.ts` and
    add the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，继承主要是允许代码重用。继承在概念上也被设计成像现实生活中的继承，以便继承关系的逻辑流可以直观且更易于理解。现在让我们看一个例子。创建一个名为`classInheritance.ts`的文件，并添加以下代码：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Important Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Quick note if you've never seen back ticks, ``, and `${}` before. It's called
    string interpolation and is simply a quick and easy way to insert string values
    inside strings by embedding objects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未见过反引号``和`${}`，这是一个快速和简单的方法，称为字符串插值，通过嵌入对象在字符串中插入字符串值。
- en: 'As you can see, there is a base class, also known as a parent, called `Vehicle`.
    This class acts as the main container for source code that is being reused later
    by whatever classes inherit from it, also known as children. The child classes
    inherit from `Vehicle` by using the `extends` keyword. One thing to notice that''s
    important is that in the constructor for each child class, you see that the first
    line of code is the call to `super`. `super` is the name of the instance of the
    parent class that a child is inheriting from. So, in this case, that would be
    the `Vehicle` class. Now, as you can see, each child is passing a different number
    of wheels to the parent''s `wheelCount` variable via the parent''s constructor.
    Then, at the end of the code, an instance of each child, `Motorcycle` and `Automobile`,
    is created and the `showNumberOfWheels` function is called. If we compile and
    run this code, we get the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一个基类，也称为父类，名为`Vehicle`。这个类充当了源代码的主要容器，稍后将被从中继承的任何类重用，也称为子类。子类使用`extends`关键字从`Vehicle`继承。一个重要的事情要注意的是，在每个子类的构造函数中，您会看到第一行代码是对`super`的调用。`super`是子类继承的父类的实例的名称。因此，在这种情况下，那将是`Vehicle`类。现在，您可以看到，每个子类通过父类的构造函数向父类的`wheelCount`变量传递了不同数量的轮子。然后，在代码的末尾，创建了每个子类的实例`Motorcycle`和`Automobile`，并调用了`showNumberOfWheels`函数。如果我们编译并运行此代码，我们会得到以下结果：
- en: '![Figure 2.13 – The classInheritance result'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13 - classInheritance结果'
- en: '](img/Figure_2.13_B15508.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.13_B15508.jpg)'
- en: Figure 2.13 – The classInheritance result
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 - classInheritance结果
- en: 'So then, each child provides a different number of wheels to the parent `wheelCount`
    variable, although they cannot access the variable directly. Now, let''s say that
    there was a reason why the child classes would want to access the `wheelCount`
    variable of the parent directly. For example, let''s say that if a flat tire occurred,
    an updated wheel count would be necessary. What could we do? Well, let''s try
    creating a function unique to each child class that tries to update `wheelCount`.
    Let''s see what happens. Update the code by adding a new function, `updateWheelCount`,
    to the `Motorcycle` class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个子类向父类的`wheelCount`变量提供了不同数量的轮子，尽管它们无法直接访问该变量。现在，假设子类希望直接访问父类的`wheelCount`变量有一个原因。例如，假设发生了爆胎，需要更新轮胎数量。我们该怎么办？好吧，让我们尝试为每个子类创建一个独特的函数，试图更新`wheelCount`。让我们看看会发生什么。通过向`Motorcycle`类添加一个新函数`updateWheelCount`来更新代码：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As a test, if we update only the `Motorcycle` class and add an `updateWheelCount`
    function as shown, we get an error. Can you guess why? It''s because we are trying
    to access a private member of the parent class. So, therefore, even when child
    classes inherit their members from a parent, they still do not have access to
    that parent''s `private` members. This is the right behavior, again to promote
    encapsulation. So then, what do we do? Well, let''s try editing the code again
    to allow this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个测试，如果我们只更新`Motorcycle`类并添加一个`updateWheelCount`函数，如下所示，我们会得到一个错误。你能猜到为什么吗？这是因为我们试图访问父类的私有成员。因此，即使子类从父类继承其成员，它们仍然无法访问父类的`private`成员。这是正确的行为，再次促进封装。那么，我们该怎么办呢？好吧，让我们再次尝试编辑代码来允许这样做：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Do you see the small change we made? That's right, we changed the `wheelCount`
    parameter on the `Vehicle` parent class constructor to be of the `protected` accessor
    type. `protected` allows the class and any inheriting classes to have access to
    the member.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到我们做的小改变了吗？没错，我们将`Vehicle`父类构造函数中的`wheelCount`参数更改为`protected`访问器类型。`protected`允许类和任何继承类访问成员。
- en: 'Before we move on to the next topic, let''s introduce the concept of `namespaces.ts`
    and add the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个主题之前，让我们介绍`namespaces.ts`的概念，并添加以下代码：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see from this code, even before compiling, VSCode IntelliSense is
    already complaining that `FirstClass` cannot be found. This is because it is hidden
    from `namespace B`, since it is only defined in `namespace A`. This is the purpose
    of namespaces, to hide information within one scope, away from other scopes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中可以看出，即使在编译之前，VSCode IntelliSense已经抱怨找不到`FirstClass`。这是因为它被隐藏在`namespace
    B`中，因为它只在`namespace A`中定义。这就是命名空间的目的，将一个范围内的信息隐藏在其他范围之外。
- en: In this section, we learned about inheriting from classes. Class inheritance
    is a very important tool for reusing code. In the next section, we'll look at
    using abstract classes, which is a more flexible way of doing inheritance.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了从类中继承。类继承是重用代码的一个非常重要的工具。在下一节中，我们将学习使用抽象类，这是一种更灵活的继承方式。
- en: Abstract classes
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: As mentioned previously, interfaces can be useful for defining contracts, but
    they have no implementation for working code themselves. Classes have working
    implementations, but sometimes only a signature is required. It is possible, for
    certain situations, that we may want to have both in one object type. For these
    types of scenarios, you would use an `abstractClass.ts` and copy and paste our
    code from our `classInheritance.ts` file into it. If you do this, you might get
    some errors, since the two files both have the same class and variable names.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，接口可以用于定义合同，但它们本身没有工作代码的实现。类有工作实现，但有时只需要一个签名。对于这种类型的情况，您将使用`abstractClass.ts`，并将我们的`classInheritance.ts`文件中的代码复制粘贴到其中。如果这样做，您可能会遇到一些错误，因为这两个文件都有相同的类和变量名。
- en: 'So, in our new `abstractClass.ts` file, we are going to update it with namespaces
    and modify the `Vehicle` class to be abstract. Add the namespace and update the
    `Vehicle` class like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的新的`abstractClass.ts`文件中，我们将使用命名空间更新它，并将`Vehicle`类修改为抽象类。添加命名空间并像这样更新`Vehicle`类：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So, to start, we've obviously wrapped all the code within a bracket called `namespace
    AbstractNamespace` (note that a namespace can have any name; it does not need
    `namespace` in the name). Again, this is merely a container that allows us to
    control scoping so that the members of our `abstractClass.ts` file do not bleed
    out into the global scope, and thereby affect other files.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们显然将所有代码包装在一个名为`namespace AbstractNamespace`的括号中（请注意，命名空间可以有任何名称；它的名称不需要在名称中包含`namespace`）。同样，这只是一个容器，允许我们控制作用域，以便我们的`abstractClass.ts`文件的成员不会泄漏到全局作用域，并影响其他文件。
- en: If you look at the new `Vehicle` code, we have a `new` keyword before the class
    called `abstract`. This is what indicates that the class will be an abstract one.
    You can also see that we have a new function called `updateWheelCount`. This function
    has an `abstract` keyword in front of it, which indicates that it will have no
    implementation within the `Vehicle` class and needs to be implemented by an inheriting
    class.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看新的`Vehicle`代码，我们在类名`abstract`之前有一个`new`关键字。这表明该类将是一个抽象类。您还可以看到我们有一个名为`updateWheelCount`的新函数。这个函数在`Vehicle`类前面有一个`abstract`关键字，这表明它在`Vehicle`类中没有实现，需要由继承类实现。
- en: 'Now, after the `Vehicle abstract` class, we want our child classes that are
    inheriting from it. So, add the `Motorcycle` and `Automobile` classes below the
    `Vehicle` class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Vehicle abstract`类之后，我们想要继承它的子类。因此，在`Vehicle`类下面添加`Motorcycle`和`Automobile`类：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After adding the classes, we instantiate them and call their respective `updateWheelCount`
    methods, as shown:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 添加类之后，我们实例化它们并调用它们各自的`updateWheelCount`方法，如下所示：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the implementation of the `abstract` member `updateWheelCount`
    is in the child classes. This is the capability that an abstract class provides.
    An abstract class can act both as a regular class, providing member implementations,
    and as an interface, providing only the rules for implementation for a child class.
    Note that since an abstract class can have abstract members, you cannot instantiate
    an abstract class.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`abstract`成员`updateWheelCount`的实现在子类中。这是抽象类提供的功能。抽象类既可以作为常规类，提供成员实现，也可以作为接口，只提供子类实现的规则。请注意，由于抽象类可以有抽象成员，您不能实例化抽象类。
- en: Furthermore, if you look at the `Automobile` class, you can see that it has
    its own implementation of `showNumberOfWheels`, even though this function is not
    abstract. This demonstrates something called **overriding**, which is the ability
    of a child's member to create a unique implementation of the parent's member.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您查看`Automobile`类，您会发现它有自己的`showNumberOfWheels`的实现，即使这个函数不是抽象的。这展示了一种称为**覆盖**的东西，即子类成员能够创建父类成员的独特实现的能力。
- en: In this section, we learned about the different kinds of class-based inheritance.
    Learning about inheritance will allow us to reuse more of our code, reducing both
    code size and potential bugs. In the next section, we'll learn about doing inheritance
    with interfaces and how it's different from class-based inheritance.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了不同类型的基于类的继承。学习继承将使我们能够重用更多的代码，减少代码大小和潜在的错误。在下一节中，我们将学习如何使用接口进行继承，以及它与基于类的继承有何不同。
- en: Interface
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: As explained earlier, **interfaces** are a way of setting agreed-upon rules
    for a type. They will allow us to separate implementation from definition and
    therefore provide abstraction, which again is a powerful object-oriented programming
    principle that will give us higher-quality code. Let's learn about how to use
    interfaces to inherit explicitly and in a well-structured way.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所解释的，**接口**是一种为类型设置约定规则的方式。它们将允许我们将实现与定义分离，从而提供抽象，这又是一个强大的面向对象编程原则，将为我们提供更高质量的代码。让我们学习如何使用接口来明确继承并以一种良好结构的方式使用。
- en: 'TypeScript interfaces provide a set of type signatures for an interface''s
    members but have no implementation themselves. Now, we did show some examples
    of using standalone interfaces, but this time, let''s see how we can use interfaces
    as a means of doing inheritance and code reuse. Create a new file called `interfaceInheritance.ts`
    and add the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript接口为接口的成员提供一组类型签名，但它们本身没有实现。现在，我们确实展示了一些使用独立接口的例子，但这次，让我们看看如何可以使用接口作为继承和代码重用的手段。创建一个名为`interfaceInheritance.ts`的新文件，并添加以下代码：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After the namespace, you can see that there is an interface called `Thing`,
    and after that, the `Vehicle` interface is defined and it inherits from `Thing`
    using the `extends` keyword. I put this into the example to show that interfaces
    can also inherit from other interfaces. The `Thing` interface has two members
    – `name` and `getFullName` – and as you can see, although `Vehicle` extends `Thing`,
    there is no mention of those members anywhere inside of `Vehicle`. This is because
    `Vehicle` is an interface and therefore cannot have any implementation. However,
    if you look at the following code, at the `Motorcycle` class, you can see that,
    since this class extends `Vehicle`, the implementations are there:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间之后，您可以看到有一个名为`Thing`的接口，之后是定义了`Vehicle`接口，并使用`extends`关键字从`Thing`继承。我将这放入示例中以表明接口也可以从其他接口继承。`Thing`接口有两个成员
    - `name`和`getFullName` - 正如您所看到的，尽管`Vehicle`扩展了`Thing`，但在`Vehicle`的任何地方都没有提到这些成员。这是因为`Vehicle`是一个接口，因此不能有任何实现。然而，如果您查看以下代码，在`Motorcycle`类中，您会发现，由于这个类扩展了`Vehicle`，实现是存在的：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So, if we compile and run this code, we get the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们编译并运行此代码，我们会得到以下结果：
- en: '![Figure 2.14 – The interfaceInheritance result'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14 – 接口继承结果'
- en: '](img/Figure_2.14_B15508.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.14_B15508.jpg)'
- en: Figure 2.14 – The interfaceInheritance result
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 接口继承结果
- en: Interfaces do not provide a means to do code reuse directly, as they have no
    implementation. However, it is still advantageous for code reuse because the structure
    of interfaces provides definite expectations around what code will receive and
    return. Hiding the implementation behind an interface is also beneficial in terms
    of doing encapsulation and abstraction, which are also important principles of
    object-oriented programming.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接口本身并不直接提供代码重用的手段，因为它们没有实现。然而，它仍然有利于代码重用，因为接口的结构提供了对代码将接收和返回什么的明确期望。将实现隐藏在接口后面也有利于进行封装和抽象，这也是面向对象编程的重要原则。
- en: Important Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When using TypeScript, take full advantage of inheritance models from object-oriented
    programming that are available to you in TypeScript. Use interfaces to abstract
    implementation details. Use `private` and `protected` to help encapsulate data.
    Remember, when the time comes to compile and convert your code into JavaScript,
    the TypeScript compiler will do any translation work for you to get things back
    into the prototypical style. But while in development mode, you should take advantage
    of all the capabilities that TypeScript provides to enhance your development experience.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用TypeScript时，充分利用面向对象编程中可用的继承模型。使用接口来抽象实现细节。使用`private`和`protected`来帮助封装数据。请记住，当编译并将您的代码转换为JavaScript时，TypeScript编译器将为您执行任何翻译工作，以将事物重新转换为原型样式。但在开发模式下，您应该充分利用TypeScript提供的所有功能，以增强您的开发体验。
- en: 'In this section, we learned about inheritance and how it can be used for code
    reuse. We learned about how to do inheritance with the three major container types:
    classes, abstract classes, and interfaces. You will see, once we begin coding
    our app, why being able to do code reuse is such a critical element in large application
    development. In the next section, we will cover generics, which will use the types
    that we learned about in this section.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了继承以及如何将其用于代码重用。我们了解了如何使用三种主要的容器类型：类、抽象类和接口进行继承。一旦我们开始编写应用程序，您将会看到为什么能够进行代码重用是大型应用程序开发中如此关键的因素。在下一节中，我们将介绍泛型，它将使用我们在本节中学到的类型。
- en: Learning generics
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习泛型
- en: '**Generics** allows a type definition to include an associated type that can
    be chosen by the user of the generic type, instead of being dictated by the type
    creator. In this way, there are structures and rules, but still some amount of
    flexibility. Generics will definitely come into play later when we code with React,
    so let''s learn about them here.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型**允许类型定义包括一个关联类型，可以由泛型类型的用户选择，而不是由类型创建者指定。这样，有一些结构和规则，但仍然有一定的灵活性。泛型在我们后面使用React编码时肯定会发挥作用，所以让我们在这里学习一下。'
- en: 'Generics can be used for functions, classes, and interfaces. Let''s look at
    an example of generics with functions. Create a file called `functionGeneric.ts`
    and add the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型可以用于函数、类和接口。让我们看一个使用函数泛型的例子。创建一个名为`functionGeneric.ts`的文件，并添加以下代码：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we start at the top, we see a function called `getLength<T>`. This function
    is using a generic that tells the compiler that wherever it sees the `T` symbol,
    it can expect any possible type. Now, internally, our function implementation
    checks to see whether the `arg` parameter has a field called `length` and then
    tries to grab it. If it does not, it just returns `0`. Finally, toward the bottom,
    you can see that the `getLength` function is called two times: once for a number
    and another time for a string. Additionally, you can see that for `number`, it
    explicitly has the `<number>` type indicator, whereas for `string`, it does not.
    This is there only to show that you can be explicit, but the compiler can usually
    figure out which type you meant based on the usage.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从顶部开始，我们会看到一个名为`getLength<T>`的函数。这个函数使用了一个泛型，告诉编译器无论它在哪里看到`T`符号，它都可以期望任何可能的类型。现在，在内部，我们的函数实现检查`arg`参数是否有一个名为`length`的字段，然后尝试获取它。如果没有，它就返回`0`。最后，在底部，您可以看到`getLength`函数被调用了两次：一次是为了一个数字，另一次是为了一个字符串。此外，您可以看到对于`number`，它明确地有`<number>`类型指示符，而对于`string`，它没有。这只是为了表明您可以明确指定类型，但编译器通常可以根据使用情况推断出您的意图。
- en: 'The thing with this example is that there''s extra code in order to check for
    the `length` field. This makes the code busy and longer than it needs to be. Let''s
    update this code to prevent calls of this function if an argument does not have
    a `length` property. First, comment out the code we just wrote and add the following
    new code below it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的问题在于为了检查`length`字段而需要额外的代码。这使得代码变得繁忙，比实际需要的代码更长。让我们更新这段代码，以防止调用这个函数如果参数没有`length`属性。首先，注释掉我们刚刚写的代码，然后在其下面添加以下新代码：
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code is quite similar except we use an `HasLength` interface to constrain
    what types are allowed. Constraining generic types is done with the `extends`
    keyword. By writing `T extends HasLength`, we are telling the compiler that whatever
    `T` is, it must inherit from or be of the `HasLength` type, which effectively
    means that it must have the `length` property. Therefore, when the two previous
    calls are made, it fails for `number` types, since they don't have a `length`
    property, but works for `string`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常相似，只是我们使用了一个`HasLength`接口来限制允许的类型。通过使用`extends`关键字来约束泛型类型。通过编写`T extends
    HasLength`，我们告诉编译器无论`T`是什么，它必须继承自`HasLength`类型，这有效地意味着它必须具有`length`属性。因此，当进行前两个调用时，对于`number`类型会失败，因为它们没有`length`属性，但对于`string`则有效。
- en: 'Now, let''s look at an example that uses interfaces and classes. Let''s create
    a file called `classGeneric.ts` and add the following code to it:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个使用接口和类的例子。让我们创建一个名为`classGeneric.ts`的文件，并向其中添加以下代码：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, we can see that we have an interface called `Wheels`, which provides wheel
    information. We can also see that the `Vehicle` interface takes a generic of type
    `T`, meaning any specific type.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到我们有一个名为`Wheels`的接口，它提供了轮子信息。我们还可以看到`Vehicle`接口采用了类型`T`的泛型，表示任何特定类型。
- en: 'Subsequently, we see that the `Automobile` class implements the `Vehicle` interface
    with the generic as the `Wheel` type, which associates `Wheel` to `Automobile`.
    Then, finally, we see that the `Chevy` class extends `Automobile`, providing some
    default values:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们看到`Automobile`类实现了具有泛型作为`Wheel`类型的`Vehicle`接口，将`Wheel`关联到`Automobile`。然后，最后，我们看到`Chevy`类扩展了`Automobile`，提供了一些默认值：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After all these types are defined, we create one instance of the `Chevy` class
    and log some output from it:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有这些类型之后，我们创建了`Chevy`类的一个实例，并从中记录了一些输出：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This code compiles and runs successfully and gives the following result:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码编译并成功运行，并给出以下结果：
- en: '![Figure 2.15 – The classGeneric.ts result'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15 – classGeneric.ts的结果'
- en: '](img/Figure_2.15_B15508.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.15_B15508.jpg)'
- en: Figure 2.15 – The classGeneric.ts result
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – classGeneric.ts的结果
- en: You can see that our inheritance hierarchy is several levels deep, but our code
    is able to successfully return a valid result. Although specific details in real-world
    code may be different, nevertheless, the multi-level type hierarchy shown here
    is something that can happen quite frequently in object-oriented programming design.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们的继承层次结构有几个级别，但我们的代码能够成功返回有效的结果。虽然现实世界代码中的具体细节可能不同，但是在这里显示的多级类型层次结构在面向对象编程设计中是经常发生的事情。
- en: In this section, we learned about using generics on both functions and class
    types. Generics are commonly used in React development, as well as some Node packages.
    So, they will be of use once we start coding in later chapters. In the next section,
    we'll take a look at several miscellaneous items to round out this chapter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在函数和类类型上使用泛型。泛型通常在React开发中使用，以及一些Node包中也会用到。因此，一旦我们在后面的章节开始编码，它们将会很有用。在下一节中，我们将看一些其他杂项内容来完成本章。
- en: Learning the latest features and configuring the compiler
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习最新功能并配置编译器
- en: In this section, we will learn about some newer features in TypeScript, as well
    as how to configure the TypeScript compiler. By learning about these newer features,
    we will be able to write cleaner and easier-to-read code, which, of course, will
    be beneficial for working with the app in a team. By using the configuration options
    of TypeScript, we can have the compiler work in the way we think is best for our
    project.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习TypeScript中一些较新的特性，以及如何配置TypeScript编译器。通过了解这些较新的特性，我们将能够编写更清晰、更易读的代码，这当然对团队中使用应用程序是有益的。通过使用TypeScript的配置选项，我们可以让编译器以我们认为最适合我们项目的方式工作。
- en: Optional chaining
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Optional chaining
- en: 'Let''s take a look at `null` objects. Let''s create a file called `optionalChaining.ts`
    and add the following code to it:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`null`对象。让我们创建一个名为`optionalChaining.ts`的文件，并将以下代码添加到其中：
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we look at this code, we can see that there are several types being used
    together. `car` has a property of `wheels`, and `wheels` has a property of `count`.
    So, later when we log, you can see that calls are being chained together. For
    example, the last `console.log` line refers to `car?.wheels?.count`. This is called
    optional chaining. The question mark indicates that the object could possibly
    be `null` or `undefined`. If it is `null` or `undefined`, then the code will end
    at that object, returning whichever value the object or property is, and not continue
    to the rest of the properties, but without causing an error.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看这段代码，我们可以看到有几种类型被一起使用。`car`有一个`wheels`属性，而`wheels`有一个`count`属性。因此，稍后当我们记录时，你可以看到调用被链接在一起。例如，最后的`console.log`行引用了`car?.wheels?.count`。这被称为可选链。问号表示对象可能是`null`或`undefined`。如果它是`null`或`undefined`，那么代码将在该对象结束，返回对象或属性的任何值，并且不继续到其余的属性，但不会导致错误。
- en: 'So, if we wrote the bottom console code the old way, we would have to do a
    great deal of code testing in order to make sure that we would not cause an error
    by calling something that is potentially `undefined`. We would use the ternary
    operation and it could look something like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们以旧的方式编写底部的控制台代码，我们将不得不进行大量的代码测试，以确保我们不会通过调用可能是`undefined`的东西而导致错误。我们将使用三元操作符，它可能看起来像这样：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Obviously, this is both difficult to write and read. So then, by using optional
    chaining, we allow the compiler to stop as soon as `null` or `undefined` is found
    and just pass that back. This saves us from writing a bunch of verbose, potentially
    error-prone code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这既难写又难读。因此，通过使用可选链，我们允许编译器在发现`null`或`undefined`时立即停止并返回。这使我们免于编写大量冗长、可能容易出错的代码。
- en: Nullish coalescing
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nullish coalescing
- en: 'Nullish coalescing is simply a shortcut of the ternary operator. So, it''s
    pretty straightforward and it looks like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Nullish coalescing是三元运算符的简化形式。因此，它非常直接，看起来像这样：
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The double question marks work from left to right. The statement means if `val1`
    is not `null` or `undefined` and has an actual value, then return that value.
    However, if `val1` does not have a value, return `val2`. So, in this case, compiling
    and running would result in `10` being written to the console.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 双问号从左到右工作。该语句的意思是，如果`val1`不是`null`或`undefined`并且有实际值，则返回该值。然而，如果`val1`没有值，则返回`val2`。因此，在这种情况下，编译和运行将导致`10`被写入控制台。
- en: You may be wondering whether this is the same thing as the `||` operator. It's
    somewhat similar but more constrained. The logical or operator, when it is used
    in this manner, is checking for "truthyness." In JavaScript, this is a concept
    where a large set of possible values can be considered "truthy" or "falsey." For
    example, `0`, `true` or `false`, `undefined`, and `""` all have true or false
    equivalency in JavaScript. However, in the case of nullish coalescing, only `null`
    or `undefined` specifically are being checked.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这是否与`||`运算符相同。它有些相似但更受限制。逻辑或运算符在这种情况下，检查“真值”。在JavaScript中，这是一个概念，其中大量可能的值可以被认为是“真值”或“假值”。例如，`0`，`true`或`false`，`undefined`和`""`在JavaScript中都有真或假的等价性。然而，在nullish
    coalescing的情况下，只有`null`或`undefined`被明确检查。
- en: TypeScript configuration
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript配置
- en: 'TypeScript configurations can be passed in via the command line or, more commonly,
    through a file called `tsconfig.json`. If you use the command line, then call
    the compiler like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript配置可以通过命令行传递，或者更常见的是通过一个名为`tsconfig.json`的文件。如果你使用命令行，那么调用编译器就像这样：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This tells TypeScript to ignore any `tsconfig.json` file and just use the command-line
    options – in this case, the `–lib` option, which states which version of JavaScript
    is being used during development, and compiles only this one file. If you just
    put `tsc` onto the command line, TypeScript will look for a `tsconfig.json` file
    and use that configuration and compile all `ts` files it finds.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉TypeScript忽略任何`tsconfig.json`文件，只使用命令行选项 - 在这种情况下，`-lib`选项，它声明在开发过程中使用的JavaScript版本，并且只编译这一个文件。如果你只在命令行上输入`tsc`，TypeScript将寻找一个`tsconfig.json`文件并使用该配置，并编译它找到的所有`ts`文件。
- en: 'There are many options, so we won''t cover all of them here. However, let''s
    review a few of the most important ones (when we start coding, I''ll provide a
    sample `tsconfig.json` file to use):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项，所以我们在这里不会涵盖所有。然而，让我们回顾一些最重要的选项（当我们开始编码时，我会提供一个示例`tsconfig.json`文件供使用）：
- en: '`--lib`: This is used to indicate which JavaScript version you will use during
    development.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--lib`：这用于指示在开发过程中将使用哪个JavaScript版本。'
- en: '`--target`: This indicates which version of JavaScript you want to emit out
    into `.js` files.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--target`：这表示你想要发射到`.js`文件中的JavaScript版本。'
- en: '`--noImplicitAny`: Does not allow the `any` type, without explicitly declaring
    it.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--noImplicitAny`：不允许`any`类型，除非显式声明它。'
- en: '`--outDir`: This is the directory where JavaScript files will be saved to.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--outDir`：这是JavaScript文件将保存到的目录。'
- en: '`--outFile`: This is the final JavaScript filename.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--outFile`：这是最终的JavaScript文件名。'
- en: '`--rootDirs`: This is an array that stores the `.ts` file source code.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--rootDirs`：这是一个存储`.ts`文件源代码的数组。'
- en: '`--exclude`: This is an array of folders and files to exclude from compilation.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--exclude`：这是一个要从编译中排除的文件夹和文件的数组。'
- en: '`--include`: This is an array of folders and files to include in compilation.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--include`：这是一个要包含在编译中的文件夹和文件的数组。'
- en: This section provided just a brief overview of some newer features of TypeScript,
    as well as some configuration-related information. Nevertheless, these newer features
    and the ability to configure TypeScript are very important and will be used extensively
    once we start writing code in later chapters.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅提供了TypeScript一些新特性的简要概述，以及一些与配置相关的信息。然而，这些新特性和配置TypeScript的能力非常重要，在我们开始编写代码的后续章节中将会被广泛使用。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the TypeScript language. We learned about
    the many different types that exist in the language and also how to create our
    own types. We also learned about how to use TypeScript to create object-oriented
    code. It was a large and complex chapter but will be absolutely necessary knowledge
    for when we begin building our app.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了TypeScript语言。我们了解了语言中存在的许多不同类型，以及如何创建我们自己的类型。我们还学习了如何使用TypeScript来创建面向对象的代码。这是一个庞大而复杂的章节，但对于我们开始构建应用程序时将是绝对必要的知识。
- en: In the next chapter, we will review some of the most important features in traditional
    JavaScript. We will also learn about some of the newer features in the latest
    versions of the language. Since TypeScript is a true superset of JavaScript, it
    is important to have an up-to-date understanding of JavaScript in order to make
    maximal usage of TypeScript.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾一些传统JavaScript中最重要的特性。我们还将了解一些最新版本语言中的新特性。由于TypeScript是JavaScript的真正超集，因此了解JavaScript的最新情况对于充分利用TypeScript非常重要。
