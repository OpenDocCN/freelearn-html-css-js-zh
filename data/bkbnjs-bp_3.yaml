- en: Chapter 3. Building a Live Data Dashboard
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：构建实时数据仪表板
- en: This is going to be a fun chapter. So far, we've created two relatively simple
    applications. In both cases, we mainly created and read data from the browser.
    While it's all browser-side stuff, it's pretty static. This time, we're going
    to do something a lot more interesting; we're going to build a table that keeps
    a track of events. In an interesting twist, though, we'll build a table that will
    automatically update based on changes made in other browsers that have our app
    open.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个有趣的章节。到目前为止，我们已经创建了两个相对简单的应用程序。在两种情况下，我们主要是在浏览器中创建和读取数据。虽然这些都是浏览器端的内容，但它相当静态。这次，我们将做一些更有趣的事情；我们将构建一个跟踪事件的表格。然而，有趣的是，我们将构建一个表格，它将根据其他打开我们应用程序的浏览器中的更改自动更新。
- en: 'The following are a couple of chapter spoilers:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些章节的剧透：
- en: We'll look at better code organization through multiple files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨通过多个文件进行更好的代码组织
- en: We'll write code to update and delete model instances
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将编写代码来更新和删除模型实例
- en: We'll build an app that polls the server to keep its collection up to date
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将构建一个轮询服务器以保持其集合更新的应用程序
- en: 'Once again, we''ll start with the project template; however, there are a few
    modifications we need to make in our last two projects. You may have noticed that
    our `app.js` file was getting a bit lengthy; this makes it tough to navigate between
    our components and to keep our code clean and manageable in general. So in this
    project, we''re going to split our Backbone code into multiple files. We''re going
    to keep our models and collections in `models.js`, our views in `views.js` and
    our router in `router.js`. You can go ahead and create these files (they''ll be
    empty for now) in the `public` folder; also, remove `app.js`. Then, in the `index.ejs`
    file, we''ll need to replace the script tag for `app.js` with script tags for
    those new files, as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次从项目模板开始；然而，在我们的最后两个项目中，我们需要做一些修改。你可能已经注意到我们的 `app.js` 文件变得有点长；这使得在组件之间导航变得困难，并且总的来说，使我们的代码保持整洁和可管理变得困难。所以在这个项目中，我们将把
    Backbone 代码拆分成多个文件。我们将把模型和集合放在 `models.js` 中，视图放在 `views.js` 中，路由器放在 `router.js`
    中。你可以继续在 `public` 文件夹中创建这些文件（它们现在将是空的）；同时，删除 `app.js`。然后，在 `index.ejs` 文件中，我们需要将
    `app.js` 的脚本标签替换为那些新文件的脚本标签，如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Planning our application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划我们的应用程序
- en: In the previous chapters, we started writing code immediately. However, in the
    real world, you're not going to have me to tell you what to write from the beginning.
    You're going to have to plan your own application. So let's take a moment and
    do that now.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们立即开始编写代码。然而，在现实世界中，你不会从一开始就有我来告诉你该写什么。你需要自己规划你的应用程序。所以让我们花点时间来做这件事。
- en: We want to build an application that will show us a list of past and upcoming
    events. An event will have a title, a description, and a date on which it occurs.
    This type of data can be nicely displayed in a table. We'll need to be able to
    create new events, but we also want to be able to edit and delete the existing
    events. We also want to periodically poll the server for changes to the set of
    events so that all the connected clients are up to date.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要构建一个应用程序，可以显示过去和即将发生的活动列表。一个活动将有一个标题、一个描述和一个发生日期。这种类型的数据可以很好地在表格中显示。我们需要能够创建新事件，但我们还希望能够编辑和删除现有事件。我们还希望定期轮询服务器以获取事件集合的更改，以便所有连接的客户端都能保持最新。
- en: As this is a pretty basic application, that will be all. Now that we've clarified
    what it needs to do, we can start thinking in terms of Backbone components. Obviously,
    we'll need an `Event` model and an `Events` collection. The table will be an `EventsView`
    instance, and each row will be an `EventView` instance. We'll need a form that
    is used for creating new events, say the `CreateEventView` class, and another
    form that is used for editing the existing events, say the `EditEventView` class.
    We don't need a whole view used for removing events; we just need a button, probably
    in the `EventView` class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个相当基础的应用，所以这就足够了。现在我们已经明确了它需要做什么，我们可以开始从 Backbone 组件的角度来思考。显然，我们需要一个 `Event`
    模型和 `Events` 集合。表格将是一个 `EventsView` 实例，每一行将是一个 `EventView` 实例。我们需要一个用于创建新事件的表单，比如
    `CreateEventView` 类，还需要另一个用于编辑现有事件的表单，比如 `EditEventView` 类。我们不需要一个用于删除事件的完整视图；我们只需要一个按钮，可能是在
    `EventView` 类中。
- en: What about routes? The whole table can be displayed at the home route, which
    is `/`. The creation form can be at `/create`, and the edit form can be at `/edit/<id>`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于路由呢？整个表格可以在主页路由`/`上显示。创建表单可以在`/create`上，而编辑表单可以在`/edit/<id>`上。
- en: And that's about it! This doesn't really represent the planning process of a
    real application, but it should make you realize that building applications is
    about much more than just writing code. There are smart processes you can follow
    to facilitate the process. If you're relatively new to programming, you should
    look into topics such as agile development or test-driven development. When you're
    starting out, these ideas may seem to make your projects take longer than necessary,
    but believe me, they will make building and maintaining big projects much simpler.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！这并不真正代表一个实际应用的规划过程，但它应该让你意识到构建应用不仅仅是编写代码。你可以遵循一些智能流程来简化这个过程。如果你是相对编程新手，你应该了解一下敏捷开发或测试驱动开发等主题。当你刚开始时，这些想法可能会让你觉得项目比必要的花费更多时间，但请相信我，它们会让构建和维护大型项目变得更加简单。
- en: Setting up precompiled templates
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置预编译模板
- en: Let's start by talking about the templates we use for our view classes. In the
    previous chapter, we've put our template source text right in the `index.ejs`
    file, inside script tags. This time we're going to do something different. We're
    going to precompile our templates. Think about the timeline of a template; it
    starts as text in a script tag. We've been getting that text and passing it to
    the `_.template` function that compiles the text into a `template` function, which
    it returns to us. Then, we pass our data to that function and get the HTML with
    our data interpolated back. All this must be done before we can display anything
    for the user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先谈谈我们用于视图类的模板。在前一章中，我们把模板源文本直接放在`index.ejs`文件中的脚本标签内。这次我们要做一些不同的事情。我们将预编译我们的模板。想想模板的时间线；它从脚本标签中的文本开始。我们一直在获取这个文本，并将其传递给`_.template`函数，该函数将文本编译成一个`template`函数，并将其返回给我们。然后，我们将数据传递给这个函数，并得到带有数据插值的HTML。所有这些都必须在我们能够向用户显示任何内容之前完成。
- en: What we want to do is cut a few steps out of this process. We want to send the
    `template` function to the browser, instead of sending the template text and having
    the browser compile it. To do this, we need to compile the templates as part of
    our development process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是从这个过程中省略几个步骤。我们希望将`template`函数发送到浏览器，而不是发送模板文本并让浏览器编译它。为了做到这一点，我们需要将模板作为我们开发过程的一部分进行编译。
- en: 'The easiest way to do this is to use Grunt, a handy build tool. First, we''ll
    need to install it, using the following commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事最简单的方法是使用Grunt，一个方便的构建工具。首先，我们需要安装它，使用以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We won't be learning Grunt in depth here. If you aren't familiar with the library,
    there are many great resources to learn about it online. Start on the home page
    [http://gruntjs.com/](http://gruntjs.com/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会深入学习Grunt。如果你不熟悉这个库，网上有很多很好的资源可以学习。从主页[http://gruntjs.com/](http://gruntjs.com/)开始。
- en: We're using npm to install both Grunt and the **JavaScript Templates** (**JST**)
    Grunt plugin. JST will do the compiling for us.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用npm安装Grunt和**JavaScript模板**（**JST**）Grunt插件。JST将为我们进行编译。
- en: 'Next, we''re going to need a `Gruntfile.js` file, which will configure this
    plugin. Put `Gruntfile.js` in the root of our project directory. In that file,
    start with the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个`Gruntfile.js`文件，该文件将配置这个插件。将`Gruntfile.js`放在我们的项目目录的根目录下。在这个文件中，从以下代码开始：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might recollect that, in the previous chapter, we used the `exports` object
    to export functions from our `signin.js` module. We can also completely overwrite
    that `exports` object; however, when we do that, we have to use its full name,
    `module.exports`. To this we assign a function that takes a `grunt` object as
    a parameter. Inside this function, then, we configure Grunt for our project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在前一章中，我们使用了`exports`对象从我们的`signin.js`模块导出函数。我们也可以完全覆盖那个`exports`对象；然而，当我们这样做的时候，我们必须使用它的全名，即`module.exports`。我们将一个函数分配给这个对象，该函数接受一个`grunt`对象作为参数。然后，在这个函数内部，我们为我们的项目配置Grunt。
- en: We start by calling the `initConfig` method, which configures all the plugins.
    After this, we register the plugin with Grunt; and finally, we can register a
    task. We're creating the default task, which will run when we call `grunt` on
    the command line. We're simply telling it to run the `jst` task.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用 `initConfig` 方法，它配置所有插件。之后，我们使用以下代码将插件注册到 Grunt 中；最后，我们可以注册一个任务。我们创建了一个默认任务，当我们在命令行上调用
    `grunt` 时将运行这个任务。我们只是简单地告诉它运行 `jst` 任务。
- en: 'Now, let''s go back to that `initConfig` method call for a second using the
    following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到之前的 `initConfig` 方法调用，使用以下代码：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We start with a `jst` property, because that's the name of the task we're configuring.
    Inside that, we create a target, which is a set of options for our task and the
    files we want to perform the task on (with those options). We're calling our target
    `templates`. The first option is the `templateSettings` object, which we've used
    in both the previous chapters; it allows us to use the curly-brace delimiter syntax.
    The second option that we're setting is a function that will name the templates.
    Our templates will be HTML files in the `templates` folder, so by default their
    names will be their file paths; something like `templates/event.html`. The `processName`
    function will convert that to just `event`. This name is how we will refer to
    them from the view code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个 `jst` 属性开始，因为那是我们配置的任务的名称。在里面，我们创建一个目标，这是一个为我们任务和想要执行任务（带有这些选项）的文件集的选项。我们称这个目标为
    `templates`。第一个选项是 `templateSettings` 对象，我们在前几章中已经使用过；它允许我们使用花括号分隔符语法。我们设置的第二个选项是一个函数，它将为模板命名。我们的模板将是
    `templates` 文件夹中的 HTML 文件，所以默认情况下它们的名称将是它们的文件路径；比如 `templates/event.html`。`processName`
    函数将把它转换成 `event`。这个名字是我们从视图代码中引用它们的方式。
- en: In `files`, we choose what files to work on. Here, we're saying that all the
    template files that match the string, `templates/*.html`, will be compiled into
    `public/templates.js`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `files` 中，我们选择要处理的文件。在这里，我们说的是所有匹配字符串 `templates/*.html` 的模板文件将被编译成 `public/templates.js`。
- en: This might seem like a lot to set up, but now all we need to do is run `grunt`
    on the command line to get precompiled templates. We'll test this out when we
    make our views.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来设置起来有点多，但现在我们只需要在命令行上运行 `grunt` 来获取预编译的模板。我们将在创建视图时测试这一点。
- en: Creating the models
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Now that we''ve set up our template-creating process, let''s begin with the
    project code. As earlier, we''ll begin with the models. These will go in `models.js`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了模板创建过程，让我们开始项目代码。像之前一样，我们从模型开始。这些将放在 `models.js` 中：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For now, this will do. We'll be coming back later to make some interesting changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 目前就这样吧。我们稍后会回来做一些有趣的变化。
- en: 'In the `server.js` file, we''ll make our route functions for the route we just
    defined in the `Events` class. Before that, though, we''ll need our database.
    We create that as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server.js` 文件中，我们将为 `Events` 类中刚刚定义的路由创建路由函数。在此之前，我们需要数据库。我们创建它的方法如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, I'm putting the database JSON file in a folder of its own; if you
    want to do this, make sure you create the `db` folder.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我将数据库 JSON 文件放在了一个单独的文件夹中；如果你要这样做，请确保你创建了 `db` 文件夹。
- en: 'But now, with the database in place, we can create the GET route. This will
    simply send all the records in our database back to the browser:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，数据库已经就位，我们可以创建 GET 路由。这个路由将简单地发送我们数据库中的所有记录回浏览器：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The POST route is where the data for new event objects will be sent. We''ll
    collect the properties into an object and insert it; our callback function can
    just send the updated record back to the browser. Here''s what that looks like:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: POST 路由是新事件对象数据发送的地方。我们将属性收集到一个对象中并插入它；我们的回调函数只需将更新后的记录发送回浏览器。下面是这个样子：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One more server method, and that''s for the root route:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 再多一个服务器方法，那就是根路由：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This route is very similar to the get-all routes in both our previous chapters.
    It will render our `index.ejs` template, sending all our event records to the
    browser.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由与我们在前几章中的 get-all 路由非常相似。它将渲染我们的 `index.ejs` 模板，并将所有事件记录发送到浏览器。
- en: Creating controls
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控件
- en: Let's begin with some controls. As we had decided, we'll need to be able to
    open a form to create new events, so let's put a button for this on a control
    bar at the top of our page.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些控件开始。正如我们之前决定的，我们需要能够打开一个表单来创建新事件，所以让我们在页面顶部的控制栏上放一个按钮。
- en: 'We can start with the template. If you haven''t yet started, create a directory
    named `templates` at the root of our project. Inside that, create a file named
    `controls.html`, and put the following code in it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从模板开始。如果你还没有开始，请在项目的根目录下创建一个名为`templates`的目录。在里面，创建一个名为`controls.html`的文件，并将以下代码放入其中：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re only going to have one control, and it doesn''t actually need to be
    a template, but this gives us the ability to easily extend it later. We can actually
    test out the precompiling now, by running `grunt` on the command line. When you
    do that, you should get a message saying that **File "public/templates.js" created**.
    Great! You can check out the content of that file if you want to:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个控制项，实际上它不需要是一个模板，但这给了我们以后轻松扩展它的能力。我们实际上可以通过在命令行上运行`grunt`来测试预编译。当你这样做的时候，你应该会收到一条消息说**文件"public/templates.js"已创建**。太好了！如果你想查看该文件的内容，可以这样做：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It''s rather messy, but it will do the job for us. The important thing to notice
    is that we can now reference this template function via `JST.controls`. The last
    step here is to include this script in our `index.ejs` file, just above our script
    tag from `views.js`, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它相当混乱，但对我们来说足够了。重要的是要注意，我们现在可以通过`JST.controls`引用这个模板函数。这里的最后一步是将这个脚本包含在我们的`index.ejs`文件中，就在`views.js`中的脚本标签之上，如下所示：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Speaking of `views.js`, we''re ready to open that up and get cracking at the
    view from this template. We''ll call it `ControlsView`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 说到`views.js`，我们已经准备好打开它并从这个模板开始处理视图。我们将称之为`ControlsView`：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As our template is a group of list items (well, a single list item), it makes
    sense that we use a `<ul>` element for this view. Then, notice that we're getting
    our template from the `templates.js` file, via `JST.controls`; handy, no? The
    `render` function is very basic. It just renders our template; we don't even need
    to pass it any data. It's more interesting that we're listening for the click
    event on our **Create Event** link. When that happens, we'll prevent the default
    behavior, which is requesting the `/create` route from the server, and instead
    we'll send it to our Backbone router.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模板是一组列表项（好吧，一个单独的列表项），所以使用`<ul>`元素来表示这个视图是有意义的。然后，注意我们是通过`JST.controls`从`templates.js`文件中获取模板的；方便，不是吗？`render`函数非常基础。它只是渲染我们的模板；我们甚至不需要传递任何数据。更有趣的是，我们正在监听**创建事件**链接上的点击事件。当发生这种情况时，我们将阻止默认行为，即从服务器请求`/create`路由，而我们将将其发送到我们的Backbone路由器。
- en: We did this in [Chapter 1](ch01.html "Chapter 1. Building a Simple Blog"), *Building
    a Simple Blog*, but we did it differently. Back then, we used the actual router
    object inside our views; we just expected it to be available as a global variable.
    That was a bad idea. This time, we're improving on that in two ways. First, we're
    expecting to receive the router as a property in our `options` object when this
    view is created. You can see in the `initialize` function that we're assigning
    `this.nav` from `options.nav`. The second improvement is that this isn't actually
    the whole router object; it's just the router's `navigate` method. This way, we
    can give select views the power to change routes, and they still can't mess with
    the rest of the router.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章. 构建一个简单的博客") *构建一个简单的博客* 中做了这件事，但我们采取了不同的方法。当时，我们在视图中使用了实际的路由对象；我们只是期望它作为一个全局变量可用。那是个坏主意。这次，我们在两个方面进行了改进。首先，当我们创建这个视图时，我们期望在`options`对象中接收到路由作为一个属性。你可以在`initialize`函数中看到，我们正在将`this.nav`从`options.nav`赋值。第二个改进是，这实际上并不是整个路由对象；它只是路由的`navigate`方法。这样，我们可以给选定的视图赋予改变路由的能力，同时它们仍然不能干扰路由的其他部分。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a software design pattern known as dependency injection. Basically,
    the router's `navigate` method is a dependency that we are injecting into our
    `ControlsView` class. This allows us to keep unrelated code separate, which can
    make updating this code in the future a simpler process. For example, if we need
    to change the way routing is done in our application, we only need to inject a
    new or an updated dependency into this class, and hopefully not change much at
    all in this class. Dependency injection is one way to follow the dependency inversion
    principle, one of the five SOLID design principles. To read more about them, start
    at the Wikipedia page [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名为依赖注入的软件设计模式。基本上，路由器的`navigate`方法是我们注入到`ControlsView`类中的一个依赖项。这允许我们将无关的代码分开，这可以使将来更新此代码的过程更加简单。例如，如果我们需要更改应用程序中路由的方式，我们只需要将新的或更新的依赖项注入到这个类中，并且希望在这个类中不进行太多更改。依赖注入是遵循依赖倒置原则的一种方式，这是五个SOLID设计原则之一。要了解更多信息，请从维基百科页面[https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)开始阅读。
- en: Lastly, you're probably wondering about the `className` property. As you perhaps
    suspect, this sets the `class` attribute on our elements. But where are these
    classes coming from? Well, in this application, we're going to be using Twitter's
    Bootstrap library, and these classes create a basic navigation/controls bar.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能想知道`className`属性。正如你可能怀疑的那样，这个属性设置了我们的元素的`class`属性。但这些类是从哪里来的呢？嗯，在这个应用程序中，我们将使用Twitter的Bootstrap库，这些类创建了一个基本的导航/控制栏。
- en: Including Bootstrap
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含 Bootstrap
- en: 'Of course, for this to work, we''ll have to add this library to our projects.
    You can head over to [http://getbootstrap.com](http://getbootstrap.com) and click
    on **Download Bootstrap**. There are a bunch of files here, but we don''t need
    them all. In our project''s `public` directory, create a folder named `css`, and
    copy the `bootstrap.min.css` file into that. We''ll also need `bootstrap.min.js`,
    which we''ll put in the `public` folder. Bootstrap also comes with the GLYPHICONS
    fonts ([http://glyphicons.com/](http://glyphicons.com/)), so you''ll have to create
    a `fonts` folder in the `public` directory, and copy the font files from Bootstrap''s
    `font` directory. With these pieces in place, we can add a link to the `stylesheet`
    tag in the head of the `index.ejs` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了使这可行，我们必须将这个库添加到我们的项目中。您可以访问[http://getbootstrap.com](http://getbootstrap.com)，点击**下载
    Bootstrap**。这里有很多文件，但我们不需要全部。在我们的项目`public`目录中，创建一个名为`css`的文件夹，并将`bootstrap.min.css`文件复制到该文件夹中。我们还需要`bootstrap.min.js`，我们将将其放在`public`文件夹中。Bootstrap还附带GLYPHICONS字体([http://glyphicons.com/](http://glyphicons.com/))，因此您需要在`public`目录中创建一个`fonts`文件夹，并将字体文件从Bootstrap的`font`目录复制过来。将这些组件放在一起，我们就可以在`index.ejs`文件的头部添加一个到`stylesheet`标签的链接：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And then, at the bottom, we link to the JavaScript portion of Bootstrap:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在底部，我们链接到Bootstrap的JavaScript部分：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you aren't familiar with **GLYPHICONS**, it's a collection of symbols that
    you can use for icons within your web applications. Usually, you have to buy a
    license, but a few of them are provided with Bootstrap, free for its users.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉**GLYPHICONS**，它是一组你可以用于你的Web应用程序中的图标的符号。通常，你必须购买许可证，但其中一些是免费提供给Bootstrap用户的。
- en: Starting the router
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动路由器
- en: 'Now, to render our controls, we need to start building our router. We have
    created a `router.js` file, so let''s open that up, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了渲染我们的控件，我们需要开始构建我们的路由器。我们已经创建了一个`router.js`文件，所以让我们打开它，如下所示：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From our `initialize` function, we can see that we expect to get our main element
    and an `Events` collection as properties of our `options` object. We're also creating
    a `nav` property; this is the `nav` method that we saw in `ControlsView`. It's
    important to realize that we can't just send `this.navigate`; we need to make
    sure that the function is bound to the router object, which we do with its `bind`
    method. When we bind a function in this way, we're creating a copy of the function
    whose value of `this` (inside the function copy) is whatever object we pass as
    a parameter to `bind`; so anywhere we call the function that is stored in `this.nav`,
    the value of `this` will be consistent. To learn more about `this` in JavaScript,
    the JavaScript Garden is a great resource and is available at [http://bonsaiden.github.io/JavaScript-Garden/#function.this](http://bonsaiden.github.io/JavaScript-Garden/#function.this).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`initialize`函数中，我们可以看到我们期望从我们的`options`对象中获取主元素和`Events`集合作为属性。我们还在创建一个`nav`属性；这是我们在`ControlsView`中看到的`nav`方法。重要的是要意识到我们不能只是发送`this.navigate`；我们需要确保这个函数绑定到路由器对象上，我们通过它的`bind`方法来实现。当我们以这种方式绑定一个函数时，我们正在创建一个函数的副本，其`this`（在函数副本内部）的值是我们传递给`bind`方法的参数对象；所以无论我们在哪里调用存储在`this.nav`中的函数，`this`的值都将保持一致。要了解更多关于JavaScript中`this`的信息，JavaScript
    Garden是一个很好的资源，可在[http://bonsaiden.github.io/JavaScript-Garden/#function.this](http://bonsaiden.github.io/JavaScript-Garden/#function.this)找到。
- en: 'Our index route is pretty simple right now. We''re just rendering our controls.
    It''s a start, however! Now, in `index.ejs`, we can instantiate the router as
    follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的索引路由非常简单。我们只是在渲染我们的控件。这是一个开始！现在，在`index.ejs`中，我们可以按照以下方式实例化路由器：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can start the server up (`npm start`) and load the page. This should
    look like what is shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动服务器（`npm start`）并加载页面。这应该看起来像以下截图所示：
- en: '![Starting the router](img/6997OS_03_01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![启动路由](img/6997OS_03_01.jpg)'
- en: 'As we now have a button, it makes sense to get that button working. Right now,
    when we click on the button, our route changes to `/create`; but nothing else
    changes, because we haven''t created that route yet. So add this to our router''s
    routes object as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在有一个按钮，让它工作起来是有意义的。目前，当我们点击按钮时，我们的路由会变为`/create`；但除此之外没有其他变化，因为我们还没有创建那个路由。所以按照以下方式将这个路由添加到我们的路由器的路由对象中：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And then add the `following` function to the router as well:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`following`函数也添加到路由器中：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We haven't created the `CreateEventView` view class yet, but you can see that
    we'll pass it our collection of events and our `nav` method. We'll render it and
    append it to the main element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有创建`CreateEventView`视图类，但你可以看到我们将传递我们的活动集合和`nav`方法。我们将渲染它并将其附加到主元素上。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might recall from the previous chapter that we didn't name the collection
    property `collection` when we weren't rendering it, so other developers reading
    our code won't confuse the purpose of giving the view a collection. However, we
    are naming it `collection` in this case because the `events` property is already
    used by Backbone to assign DOM events.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在前一章中，当我们没有渲染时，我们没有将集合属性命名为`collection`，这样其他阅读我们代码的开发者就不会混淆将集合赋予视图的目的。然而，在这种情况下，我们将其命名为`collection`，因为`events`属性已经被Backbone用于分配DOM事件。
- en: Building the CreateEventView class
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建CreateEventView类
- en: So let's create the `CreateEventView` view class. Now, let's throw a twist in;
    since we have Bootstrap on our page, why don't we use its modal component to display
    our form?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建`CreateEventView`视图类。现在，让我们来点变化；既然我们在页面上有Bootstrap，为什么不使用它的模态组件来显示我们的表单呢？
- en: 'To do this, we''ll begin by creating our template. Create `templates/createEvent.html`
    and put this in that file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先创建我们的模板。创建`templates/createEvent.html`并将以下内容放入该文件中：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It''s a lot of HTML, but you can see the form in the middle there, right? Actually,
    the Bootstrap model requires another wrapping `<div>`, but the view class will
    provide that. Here''s the first portion of that view:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有大量的HTML代码，但你能看到中间那里的表单，对吧？实际上，Bootstrap模型需要另一个包装`<div>`，但视图类会提供这个。这是视图的第一个部分：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is what we start with, and it''s a very basic view. The most important
    thing to notice here is the `className` property; these classes style the modal
    window. However, at this point, if we compile our template and click on our button,
    our modal window won''t appear. What''s up with that? If you inspect the page
    in the developer tools of your browser, you''ll see that the view''s HTML is added
    to the page, but it isn''t viewable. You can see that in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始的地方，这是一个非常基本的视图。这里最重要的要注意的是`className`属性；这些类样式化模态窗口。然而，在这个时候，如果我们编译我们的模板并点击我们的按钮，我们的模态窗口不会出现。这是怎么回事？如果你在浏览器的开发者工具中检查页面，你会看到视图的HTML被添加到页面中，但它不可见。你可以在以下屏幕截图中看到这一点：
- en: '![Building the CreateEventView class](img/6997OS_03_02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![构建CreateEventView类](img/6997OS_03_02.jpg)'
- en: 'The problem is that we need to use Bootstrap''s jQuery modal plugin, which
    we had loaded earlier (`bootstrap.min.js`). We can use this plugin to show and
    hide the modal. To show the form, it''s as easy as adding the following line of
    code to our `render` method, right after calling the `template` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们需要使用Bootstrap的jQuery模态插件，这是我们之前加载的（`bootstrap.min.js`）。我们可以使用这个插件来显示和隐藏模态。要显示表单，只需将以下代码行添加到我们的`render`方法中，在调用`template`函数之后即可：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We get the "jQuer-ified" element and call the `modal` method, passing it the
    command to show the modal window.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取“jQuery化”的元素并调用`modal`方法，传递显示模态窗口的命令。
- en: 'The next step is to add a few events to this class. There are two buttons to
    consider: the **Create Event** button (to create new `Event` model) and the **x**
    button (to close the modal window, not creating a new model):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向这个类中添加几个事件。有两个按钮需要考虑：**创建事件**按钮（用于创建新的`Event`模型）和**x**按钮（用于关闭模态窗口，不创建新模型）：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `close` method will be very simple. See the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`close`方法将非常简单。请看以下代码：'
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We prevent the default action of the button, and then hide the modal window.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们阻止按钮的默认操作，然后隐藏模态窗口。
- en: 'Now, how about writing the `create` method? We write it using the following
    code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来是编写`create`方法？我们使用以下代码来编写它：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We collect all the properties for our new event object and use the collection's
    `create` method to send the data to the server. We're passing the `wait` option
    because we'll soon have views listening for the creation of new events. This way,
    the views won't be notified until this event object has been successfully saved
    on the server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收集我们新事件对象的所有属性，并使用集合的`create`方法将数据发送到服务器。我们传递`wait`选项，因为我们很快将会有视图监听新事件的创建。这样，视图不会在事件对象成功保存到服务器之前被通知。
- en: There's one piece of this puzzle left; when either of the buttons are clicked,
    the modal is closed, but its DOM elements still exist. To get rid of the elements
    that make up the view, we need to call the view's `remove` method. This method
    gets rid of the elements and removes any event handlers connected to those elements.
    So when exactly should we call this `remove` method? Well, when we hide the modal,
    it will fade out; we need to remove the view after that. Handily, the jQuery plugin
    that we're using emits events at different points. We can listen for the `hidden.bs.modal`
    event, which will fire once the modal's fade-out sequence has completed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题还剩下一部分；当点击任意一个按钮时，模态窗口关闭，但它的DOM元素仍然存在。为了消除构成视图的元素，我们需要调用视图的`remove`方法。这个方法会消除元素并移除与这些元素连接的所有事件处理器。那么我们究竟应该在什么时候调用这个`remove`方法呢？嗯，当我们隐藏模态窗口时，它将淡出；我们需要在之后移除视图。方便的是，我们使用的jQuery插件在不同的点发出事件。我们可以监听`hidden.bs.modal`事件，该事件将在模态窗口的淡出序列完成后触发。
- en: 'So, in the view''s `initialize` method, we''ll listen for that event using
    the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在视图的`initialize`方法中，我们将使用以下代码监听该事件：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When it fires, we''ll call the `hide` method on our view. That method looks
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当它触发时，我们将在我们的视图中调用`hide`方法。这个方法看起来是这样的：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We call the view's `remove` function to get rid of the DOM and events; then,
    we use the `nav` method to send our users back to the home page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用视图的`remove`函数来消除DOM和事件；然后，我们使用`nav`方法将我们的用户送回主页。
- en: 'Now, let''s pause for a moment and think about how the user might go through
    our application. They can start on the home page and click on the **Create Event**
    button, which will take them to the `/create` route. However, it doesn''t reload
    the page; it just fades in the modal. When they close the modal window (either
    by submitting the form or closing the form), they''ll be taken back to the home
    route; the form will fade out and the control bar will still be there. However,
    it''s also possible that the user will go directly to `/create`. They''ll get
    the form, which will work fine; however, when they close the modal, they''ll be
    taken back to the home route, but the page will be blank. This is because we''re
    not triggering the router''s `index` method when we move back to that route (no
    `{trigger: true}`). Why not trigger that method?'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们暂停一下，思考一下用户可能会如何浏览我们的应用程序。他们可以从主页开始，点击**创建活动**按钮，这将带他们到`/create`路由。然而，它不会重新加载页面；它只是淡入模态框。当他们关闭模态窗口（无论是通过提交表单还是关闭表单）时，他们将被带回到主页路由；表单将淡出，控制栏仍然存在。然而，用户也可能直接访问`/create`。他们将获得表单，它将正常工作；然而，当他们关闭模态时，他们将被带回到主页路由，但页面将是空的。这是因为当我们移动回该路由时，我们没有触发路由器的`index`方法（没有`{trigger:
    true}`）。为什么不触发那个方法呢？'
- en: 'We''re not triggering it because there''s a better way here; even if the user
    goes directly to `/create`, we want to render the controls (and the table that
    will eventually be there). This means that, in the `create` router method, we
    need to check to see whether `index` has been called yet. In our case, we''ll
    do that simply by checking for the existence of the navigation. In the `create`
    method, add this just before appending the `CreateEventView` instance:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有触发它，因为这里有一个更好的方法；即使用户直接访问`/create`，我们也希望渲染控件（以及最终将出现在那里的表格）。这意味着在`create`路由方法中，我们需要检查是否已经调用了`index`。在我们的情况下，我们将通过检查导航的存在来做到这一点。在`create`方法中，在添加`CreateEventView`实例之前添加以下内容：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, if a user goes directly to the `/create` route, the router's `index` method
    will be called if it hasn't been rendered.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户直接访问`/create`路由，如果它尚未渲染，路由器的`index`方法将被调用。
- en: Creating the events table
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建活动表
- en: At this point, we're successfully creating new event records and storing them
    in our database. The next step is to display the table of events. We'll start
    with the `EventsView` class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功创建新的活动记录并将它们存储在我们的数据库中。下一步是显示活动表。我们将从`EventsView`类开始。
- en: 'Actually, we''ll start with template for this view. In `templates/events.html`,
    we''ll create the `thead` and `tbody` elements as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将从这个视图的模板开始。在`templates/events.html`中，我们将创建`thead`和`tbody`元素，如下所示：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, our table will show the five fields that our events have. We
    also have a sixth column for actions: the edit and delete actions. We have a data
    attribute on each one of the table heading elements, with names that match the
    property names of the `Event` records. We''ll use these later for sorting. You
    can go ahead and run `grunt` on the command line to compile this template function.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的表格将显示我们的活动拥有的五个字段。我们还有一个用于操作的第六列：编辑和删除操作。我们为每个表格标题元素添加了一个数据属性，其名称与`Event`记录的属性名称匹配。我们将在稍后使用这些属性进行排序。您可以在命令行上运行`grunt`来编译这个模板函数。
- en: 'Now, how about `EventsView`? We can compile this using the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于`EventsView`，我们可以使用以下代码来编译它：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We start by making the element for this view a table; we're also adding the
    class `table` to get Bootstrap's table styling. In the `initialize` method, we
    can see that we're taking the `nav` method in the `options` object so that we
    can change routes. In `render`, we're rendering the template and then calling
    `renderRows`. The `renderRows` method loops over every item in our `Events` collection
    and calls `addRow`. You might wonder why we don't put the single line of code
    in this method right in the `render` method; it's because we'll need it in its
    own method later. That `addRow` method will take a single event object as a property
    and render an `EventView` instance, placing it in that `tbody` element that we
    put in the template. We'll be coming back to this view to add and adjust things,
    but let's go over to the `EventView` class now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将这个视图的元素制作成表格；我们还添加了 `table` 类以获取 Bootstrap 的表格样式。在 `initialize` 方法中，我们可以看到我们正在从
    `options` 对象中获取 `nav` 方法，以便我们可以更改路由。在 `render` 中，我们渲染模板然后调用 `renderRows`。`renderRows`
    方法遍历我们 `Events` 集合中的每个项目并调用 `addRow`。你可能想知道为什么我们不直接在这个 `render` 方法中放置单行代码；这是因为我们稍后还需要它。那个
    `addRow` 方法将接受一个事件对象作为属性，并渲染一个 `EventView` 实例，将其放置在模板中我们放置的 `tbody` 元素中。我们将回到这个视图来添加和调整东西，但现在让我们转到
    `EventView` 类。
- en: 'As we did earlier, we''ll start with the template. The following code snippet
    should be the content of `templates/event.html`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，我们将从模板开始。以下代码片段应该是 `templates/event.html` 的内容：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first portion of the template is simple. We're just placing the properties
    of the `Event` object in the `<td>` elements. In the last `<td>` element, we've
    got two buttons; we're using Bootstrap's button and Glyphicon classes to get the
    right styling. These will be the edit and delete buttons.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的第一个部分很简单。我们只是在 `<td>` 元素中放置 `Event` 对象的属性。在最后一个 `<td>` 元素中，我们有两个按钮；我们使用 Bootstrap
    的按钮和 Glyphicon 类来获取正确的样式。这些将是编辑和删除按钮。
- en: 'The following code snippet is the start of the `EventView` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是 `EventView` 类的开始：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is similar to the other views that we''ve seen so far. The `render` method,
    however, will be slightly more involved. Before that, we need to add another third-party
    library: Moment ([http://momentjs.com/](http://momentjs.com/)). This library is
    a great tool to use for quickly formatting dates. Download the script from the
    website and add it to the `index.ejs` file, anywhere above the `views.js` file
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他我们之前看到的观点类似。然而，`render` 方法将会稍微复杂一些。在此之前，我们需要添加另一个第三方库：Moment ([http://momentjs.com/](http://momentjs.com/))。这个库是一个快速格式化日期的强大工具。从网站上下载脚本并将其添加到
    `index.ejs` 文件中，在 `views.js` 文件之上任何位置，如下所示：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With that in place, we can add a `render` method to the `EventView` class as
    follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这些之后，我们可以在 `EventView` 类中添加一个 `render` 方法，如下所示：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is easily the most complex `render` method that we've seen yet. We start
    with a few variables. We get the attributes of our model first. Then, we create
    a `moment` object and pass it the `date` property of our model. A `moment` object
    wraps a date and gives us access to several helpful date-related methods. Finally,
    we use Moment's `unix` method (which returns the time in seconds since the Unix
    Epoch) to get the difference between the time this event takes place and right
    now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是迄今为止我们见过的最复杂的 `render` 方法。我们首先定义几个变量。首先获取我们模型的属性。然后，我们创建一个 `moment` 对象，并将我们模型的
    `date` 属性传递给它。一个 `moment` 对象封装了一个日期，并为我们提供了访问几个有用的日期相关方法。最后，我们使用 Moment 的 `unix`
    方法（返回自 Unix 纪元以来的时间，以秒为单位）来获取这个事件发生的时间和现在之间的时间差。
- en: Next, we use that `date` object we just created to overwrite the default date
    value in the attribute object to be something more readable. We're using Moment's
    `calendar` method to give us a date string such as `Monday at 6:30 PM` (or `10/30/2014`
    for dates further away). Then, we replace the `createdOn` property with a different
    date string. With the Moment's `fromNow` method, we get a string such as `6 hours
    ago`. Then, we pass our updated attributes object to the `this.template` function
    for rendering.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们刚刚创建的 `date` 对象来覆盖属性对象中的默认日期值，使其更易于阅读。我们使用 Moment 的 `calendar` 方法来提供一个日期字符串，例如
    `星期一晚上6:30`（或对于更远的日期，例如 `10/30/2014`）。然后，我们将 `createdOn` 属性替换为不同的日期字符串。使用 Moment
    的 `fromNow` 方法，我们得到一个字符串，例如 `6小时前`。然后，我们将更新后的属性对象传递给 `this.template` 函数进行渲染。
- en: After rendering, we make one final adjustment. Bootstrap has a few handy classes
    used for coloring table rows, so we'll color a row differently depending on the
    time of the event. If the value of `diff` is less than 0 (which means the event
    began some time before this table was rendered), we'll add the `danger` class,
    resulting in a red row. If the event occurs within the next two days (`diff <
    172800`), we'll go with `warning` (a yellow row). If the event is in the next
    week (`diff < 604800`), the `success` class gives us a green row.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染后，我们进行最后的调整。Bootstrap有几个方便的类用于给表格行着色，所以我们将根据事件的时间来不同地着色一行。如果`diff`的值小于0（这意味着事件在表格渲染之前开始），我们将添加`danger`类，结果会变成红色的一行。如果事件在接下来的两天内发生（`diff
    < 172800`），我们将使用`warning`（黄色的一行）。如果事件在下下周内（`diff < 604800`），`success`类会给我们一个绿色的一行。
- en: 'Let''s head back to the router to put the `EventsView` and `EventView` classes
    to work. Here''s the new `index` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到路由器，让`EventsView`和`EventView`类发挥作用。以下是新的`index`方法：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this in place, we can reload the home page and see the table. If you add
    a few events, you should see something like what is shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们可以重新加载主页并看到表格。如果你添加一些事件，你应该会看到以下截图所示的内容：
- en: '![Creating the events table](img/6997OS_03_03.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![创建事件表](img/6997OS_03_03.jpg)'
- en: Things are looking pretty good at this point, you'll have to agree. However,
    there's still a lot to do before we finish this application. Let's begin by getting
    that delete button to actually delete a record.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 目前情况看起来相当不错，你也会同意这一点。然而，在我们完成这个应用程序之前，还有很多事情要做。让我们先从让那个删除按钮真正删除一条记录开始。
- en: Deleting a record
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除记录
- en: 'As the button is already in place, we just have to wire it up. In `EventView`,
    let''s add the event listener as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于按钮已经就位，我们只需将其连接起来。在`EventView`中，让我们添加如下的事件监听器：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You know what''s next. We need to create the `destroy` method in the `EventView`
    class. It can be done as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道接下来是什么。我们需要在`EventView`类中创建`destroy`方法。可以像以下这样做：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `destroy` method will call the model's `destroy` method and then call this
    view's `remove` method. Normally, that would be all, but we want to add a touch
    more. We want to fade the table row out and then remove the DOM elements. So,
    we're overwriting the default Backbone View `remove` method. We'll use jQuery
    to fade the element out. The `fadeOut` method that jQuery has takes a callback,
    a function that will be called after the fadeout is complete. We can get the usual
    Backbone View `remove` method from the `Backbone.View.prototype` object. Of course,
    we have to call it on the right view instance by binding the method to the current
    view, `this`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroy`方法将调用模型的`destroy`方法，然后调用这个视图的`remove`方法。通常情况下，这就足够了，但我们还想添加更多。我们希望表格行淡出，然后移除DOM元素。因此，我们正在覆盖默认的Backbone
    View `remove`方法。我们将使用jQuery来淡出元素。jQuery的`fadeOut`方法接受一个回调，一个在淡出完成后将被调用的函数。我们可以从`Backbone.View.prototype`对象中获取通常的Backbone
    View `remove`方法。当然，我们必须在正确的视图实例上调用它，通过将方法绑定到当前视图，`this`。'
- en: 'We haven''t called a Backbone model''s `destroy` method before, as we''re doing
    here in the view''s `destroy` method. This method sends a DELETE request to the
    server, to the route `/events/<id>`. We''ll need to create a method for this in
    our `server.js` file as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有在视图的`destroy`方法中调用Backbone模型的`destroy`方法，就像我们现在这样做。这个方法向服务器发送一个DELETE请求，到`/events/<id>`路由。我们需要在我们的`server.js`文件中创建一个方法，如下所示：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It's pretty basic; our database has a `delete` method, so we call that, passing
    it a query object with the `id` we get from the route. What we return is irrelevant,
    so we'll return an empty object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当基础；我们的数据库有一个`delete`方法，所以我们调用它，传递一个包含从路由中获取的`id`的查询对象。我们返回的内容无关紧要，所以我们将返回一个空对象。
- en: With that code in place, you can now click on the delete button in any of our
    events' table rows, and that row will fade away. Refresh the page, and you'll
    see that it's gone for good.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，你现在可以点击任何事件表格行中的删除按钮，该行将淡出。刷新页面，你会发现它已经永久消失。
- en: Editing event records
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑事件记录
- en: 'The next step is to allow users to edit their event records. Wiring up our
    edit button will be simple. First, we listen for the click in the `events` object
    of `EventView`, like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是允许用户编辑他们的事件记录。连接我们的编辑按钮将很简单。首先，我们在`EventView`的`events`对象中监听点击，如下所示：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And secondly, we navigate to the edit route for that event:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们导航到该事件的编辑路由：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We want our edit routes to act just like our create route does. If the user
    clicks on an edit button, a modal will fade in and allow editing of the event
    records. But they should also be able to go directly to the edit route and the
    table will load under the modal. This means that our router's `edit` method should
    be very similar to its `create` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的编辑路由表现得就像创建路由一样。如果用户点击编辑按钮，一个模态框会淡入，允许编辑事件记录。但他们也应该能够直接访问编辑路由，表格将在模态框下加载。这意味着我们的路由器的`edit`方法应该非常类似于其`create`方法。
- en: 'First, we''ll add the route to the router''s `route` object as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将路由添加到路由器的`route`对象中，如下所示：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, the `edit` method itself using the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`edit`方法本身使用以下代码：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We haven''t created `EditEventView` yet, but if you look back at the `create`
    method, you''ll see how similar these both are. That calls for a little refactoring
    as we have done in the following code snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有创建`EditEventView`，但如果你回顾一下`create`方法，你会看到这两个方法是多么相似。这就需要我们进行一些重构，就像我们在以下代码片段中所做的那样：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We've pulled the common code out into a `modal` method. Then, in both `create`
    and `edit`, we pass the view we want to render to that method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将公共代码提取到一个`modal`方法中。然后，在`create`和`edit`操作中，我们将要渲染的视图传递给该方法。
- en: Next, we need to create the `EditEventView` class. If you pause for a moment
    and think about this, you'll realize that since we want it to act like the `CreateEventView`
    class, it'd be great if we could somehow reuse as much of the code for that view
    as possible. Really, the main difference between the `create` and `edit` views
    is that, in the `edit` view, the current values of the record will already be
    in the form input elements. We'll also want the form heading and button text to
    be appropriately changed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`EditEventView`类。如果你稍作思考，你会意识到，由于我们希望它表现得像`CreateEventView`类一样，如果能尽可能多地重用该视图的代码就太好了。实际上，`create`视图和`edit`视图之间的主要区别在于，在`edit`视图中，记录的当前值已经存在于表单输入元素中。我们还将希望表单标题和按钮文本得到适当的更改。
- en: 'We can start with the `createEvent.html` file under `templates`. We''ll prepare
    it to take the values we need to pass to it as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`templates`下的`createEvent.html`文件开始。我们将准备它以接收我们需要传递给它的值，如下所示：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice that we're not just expecting values in the form input elements, we're
    also expecting a heading and text for the button. And, as this template will be
    used by both `CreateEventView` and `EditEventView`, let's rename it to `templates/modifyEvent.html`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不仅期望在表单输入元素中有值，还期望有标题和按钮文本。而且，由于这个模板将由`CreateEventView`和`EditEventView`共同使用，让我们将其重命名为`templates/modifyEvent.html`。
- en: Don't forget to recompile the template (`grunt`, on the command line).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记重新编译模板（使用命令行中的`grunt`）。
- en: 'Since almost all the behavior we want for the `EditEventView` class is the
    same as we created for the `CreateEventView` class, let''s extract as much as
    possible out into a `ModifyEventView` class. The following code is what we have
    come up with:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望`EditEventView`类具有的大部分行为与我们为`CreateEventView`类创建的行为相同，让我们尽可能多地将其提取到`ModifyEventView`类中。以下是我们得出的代码：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There are a few key differences between this class and the `CreateEventView`
    class. First, notice that in the `render` method, we're adding `heading` and `btnText`
    to the data that we put into the template. We'll get to where these come from
    in a minute. The other thing is that, in the `modify` method, we're calling `this.save`
    instead of `this.collection.create`. This is one of the big differences between
    creating a record and updating a record; the way we save them. So we'll need to
    create a `save` method for each, saying how exactly to do the saving.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CreateEventView`类相比，这个类有几个关键的区别。首先，注意在`render`方法中，我们正在将`heading`和`btnText`添加到我们放入模板的数据中。我们稍后会了解到这些值从何而来。另一件事是，在`modify`方法中，我们调用`this.save`而不是`this.collection.create`。这是创建记录和更新记录之间的一大区别；我们保存它们的方式。因此，我们需要为每个创建一个`save`方法，说明如何确切地执行保存操作。
- en: 'Now if this view class acts as a parent class, or a superclass, what about
    the child views? Well, the `EditEventView` is very simple as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果这个视图类作为父类或超类，那么子视图呢？嗯，`EditEventView`非常简单，如下所示：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, notice how we''re creating this view: `ModifyEventView.extend`. Backbone''s
    class-creating functionality allows us to extend our own views in the same way
    that we extend `Backbone.View`. Of course, we get access to all the methods and
    properties of `ModifyEventView`, plus whatever we add. This is where we add the
    `heading` and `btnText`, which our `render` method uses. This is also where the
    `save` method comes in. In this view, we''re just using the model''s `save` method
    to send the updated attributes back to the server. We''ll create a server method
    for this in a second. But first, we need to update our `CreateEventView` to use
    `ModifyEventView` using the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意我们是如何创建这个视图的：`ModifyEventView.extend`。Backbone的类创建功能允许我们以扩展`Backbone.View`相同的方式扩展我们自己的视图。当然，我们可以访问所有方法和属性，以及我们添加的任何内容。这就是我们添加`heading`和`btnText`的地方，这些是我们`render`方法使用的。这也是`save`方法出现的地方。在这个视图中，我们只是使用模型的`save`方法将更新后的属性发送回服务器。我们将在稍后创建一个服务器方法来完成这个任务。但首先，我们需要使用以下代码更新我们的`CreateEventView`以使用`ModifyEventView`：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Besides the `heading`, `btnText`, and `save` parts that we're familiar with,
    we're also overwriting the `initialize` method. We do call the parent class' `initialize`
    method in there, but there's something more. If you think about our template for
    a second, you'll see why. Our template expects to receive attributes to fill in
    the form inputs with, but the `CreateEventView` class doesn't have a model to
    give it; its job is to create a model! So what we're going to do is create a disposable
    `Event` object with blank attributes, so that no values are actually filled in,
    but we won't get any errors from the template function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们熟悉的`heading`、`btnText`和`save`部分之外，我们还重写了`initialize`方法。我们在那里确实调用了父类的`initialize`方法，但还有更多。如果你稍微思考一下我们的模板，你就会明白为什么。我们的模板期望接收属性来填充表单输入，但`CreateEventView`类没有模型可以提供；它的任务是创建模型！所以我们将创建一个具有空白属性的可用`Event`对象，这样实际上就不会填充任何值，但我们不会从模板函数中收到任何错误。
- en: 'However, you probably realize that a blank `Event` object won''t actually have
    any attributes. What we need to do is add default values so that the `Event` objects
    will have empty properties to pass to the template. In the `models.js` file, insert
    the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能意识到一个空白的`Event`对象实际上没有任何属性。我们需要做的是添加默认值，这样`Event`对象将具有空属性以传递给模板。在`models.js`文件中，插入以下代码：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is our updated model class. Very simple, but it solves our view problems.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的更新后的模型类。非常简单，但它解决了我们的视图问题。
- en: 'Don''t forget, we''re calling `this.model.save` in our `EditEventView` class.
    This will send the updated attributes to the server via a PUT request to `/events/<id>`.
    In `server.js`, here''s how we process those PUT requests:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，我们在`EditEventView`类中调用`this.model.save`。这将通过向`/events/<id>`发送PUT请求将更新后的属性发送到服务器。在`server.js`中，这是我们处理这些PUT请求的方式：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We'll round up the attributes into an object and pass it to our database's `update`
    method. To find the right record to update, we'll pass a query object with the
    record's ID. Then, we will return the updated record to the browser as JSON to
    complete the transaction.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把属性汇总成一个对象，并将其传递给数据库的`update`方法。为了找到要更新的正确记录，我们将传递一个包含记录ID的查询对象。然后，我们将以JSON格式将更新后的记录返回给浏览器以完成事务。
- en: Making it live
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它变得实时
- en: At this point, we have a pretty decent application. We can create events that
    show up in our table. We can update and remove these events as well. However,
    if multiple people are using the same table of events, we might want to regularly
    poll the server for changes to the dataset. This way, someone could leave the
    page open, like a dashboard of sorts, and it would always be up to date.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个相当不错的应用程序。我们可以创建显示在我们表格中的事件。我们还可以更新和删除这些事件。然而，如果多个人使用相同的事件表，我们可能希望定期轮询服务器以获取数据集的更改。这样，有人可以保持页面打开，就像某种仪表板一样，它将始终保持最新。
- en: 'This feature sounds like it might be tricky to implement, but it''s actually
    much easier than you think. The first step is to go to the `model.js` file, and
    extend our `Events` collection by adding these methods to it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能听起来可能很难实现，但实际上比你想象的要容易得多。第一步是前往`model.js`文件，并扩展我们的`Events`集合，通过向其中添加以下方法：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `refresh` method is the important one here. Mainly, we're calling the collection's
    `fetch` method. This will get the set of models from the server and set them as
    the model for collection. However, it does it in a smart way. If there are any
    new models, it will fire an `add` event; if there are any updated models, it will
    fire a `change` event; and, if any models were removed, it will fire a `remove`
    event. And it will leave any untouched models alone. Then, we set a timeout, to
    call this method again after a certain number of seconds.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`refresh` 方法在这里很重要。主要地，我们调用集合的 `fetch` 方法。这将从服务器获取模型集并将其设置为集合的模型。然而，它以智能的方式完成。如果有任何新模型，它将触发一个
    `add` 事件；如果有任何更新的模型，它将触发一个 `change` 事件；如果有任何模型被删除，它将触发一个 `remove` 事件。然后，它将保持任何未更改的模型不变。然后，我们设置一个超时，在几秒钟后再次调用此方法。'
- en: We've also added an `initialize` method to allow the option of how many seconds
    to wait between fetches. If the `options` object has a `wait` property, we'll
    use that. Otherwise, it's 10 seconds.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个 `initialize` 方法，允许选择在获取之间等待多少秒。如果 `options` 对象有一个 `wait` 属性，我们将使用它。否则，它是10秒。
- en: 'Now, in the `initialize` method for the `EventsView` class, we just have to
    call the collection''s `refresh` method like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `EventsView` 类的 `initialize` 方法中，我们只需像这样调用集合的 `refresh` 方法：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Getting the updates is that simple. Now, we need to listen for the events and
    do the right thing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更新就这么简单。现在，我们需要监听事件并做正确的事情。
- en: 'Any new records added to the collection from the update will fire an `add`
    event on the collection. Thus, in `EventsView`, we should listen for that. We
    also need to add this to its `initialize` method. So, here''s the whole `initialize`
    method, with both of these updates:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从更新中添加到集合中的任何新记录都会在集合上触发一个 `add` 事件。因此，在 `EventsView` 中，我们应该监听这个事件。我们还需要将其添加到其
    `initialize` 方法中。所以，这里是整个 `initialize` 方法，包括这两个更新：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Previously, we used the `on` method to listen to events. However, `listenTo`
    is an alternative form. It does pretty much the same thing, but it allows the
    listener—the view, in this case—to keep a track of the events it is listening
    for. This way, if we ever delete the view object, the `remove` method can detach
    those events and conserve browser memory. Here, we're telling our view to listen
    for an `add` event on the collection; when this occurs, we call `addRow`. As we
    know, this will add an `EventView` class to our table.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用了 `on` 方法来监听事件。然而，`listenTo` 是一个替代形式。它基本上做的是同样的事情，但它允许监听器——在这个例子中是视图——跟踪它正在监听的事件。这样，如果我们删除视图对象，`remove`
    方法可以断开这些事件并节省浏览器内存。在这里，我们告诉我们的视图监听集合上的 `add` 事件；当这发生时，我们调用 `addRow`。正如我们所知，这将向我们的表格添加一个
    `EventView` 类。
- en: 'That takes care of additions via AJAX updates. The `remove` and `change` events
    will be called on the event model. This means that we listen for the changes in
    our `EventView`. In its `initialize` method, we''ll listen for the events. Here''s
    the whole new `EventView` `initialize` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了通过 AJAX 更新的添加。`remove` 和 `change` 事件将在事件模型上调用。这意味着我们在 `EventView` 中监听变化。在其
    `initialize` 方法中，我们将监听这些事件。以下是整个新的 `EventView` `initialize` 方法：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We've already created the `render` and `remove` methods, so this is all that
    we need.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 `render` 和 `remove` 方法，所以我们只需要这些。
- en: And that's all! Now, you can open `http://localhost:3000` in multiple browser
    windows. Go ahead and add an event in one browser window; you should see it show
    up in the other, in less than 10 seconds. You can edit or remove an event, and
    you'll see the change in the other window. Pretty cool, eh? And it only required
    a minimal amount of code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，你可以在多个浏览器窗口中打开 `http://localhost:3000`。在其中一个浏览器窗口中添加一个事件；你应在不到10秒内看到它在另一个窗口中显示出来。你可以编辑或删除一个事件，你将在另一个窗口中看到变化。很酷，对吧？而且这只需要极少的代码。
- en: Sorting events
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序事件
- en: There's one more feature we're going to add to our application. We have a table
    of events, so why not add the ability to sort the rows by whichever field we click
    on?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要为我们的应用程序添加一个新功能。我们有一个事件表，为什么不添加按我们点击的任何字段排序行的功能呢？
- en: 'First, we need to sort the models in the collection. You already know that
    when we make a collection object, we pass it an array of model objects. We can
    have the collection sort these upon creation, by adding a comparator to the `Events`
    class. In `models.js`, add the following line to the `Events` collection class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对集合中的模型进行排序。你已经知道，当我们创建一个集合对象时，我们传递一个模型对象的数组。我们可以在创建集合时通过向 `Events` 类添加一个比较器来让集合对这些模型进行排序。在
    `models.js` 中，向 `Events` 集合类添加以下行：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Adding this line will sort the models in the collection by the `date` field.
    This will sort the models initially added to the collection, and any models subsequently
    added. However, it will not re-sort the models after one of them has been changed.
    This is important because we want our table rows to reorder if necessary when
    we edit an event record. We can implement that rather easily. However, when we
    edit a model, it will emit a `change` event, which bubbles up to the collection.
    We can listen for this in the `Events` collection''s `initialize` method as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此行将按 `date` 字段对收集中的模型进行排序。这将按最初添加到收集中和随后添加的任何模型进行排序。然而，它不会在其中一个模型被更改后重新排序模型。这很重要，因为我们希望在编辑事件记录时，如果需要，我们的表格行可以重新排序。我们可以相当容易地实现这一点。然而，当我们编辑模型时，它将发出
    `change` 事件，该事件会冒泡到收集中。我们可以在 `Events` 收集的 `initialize` 方法中监听它，如下所示：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It's as simple as listening for the `change` event on the collection itself;
    when that occurs, we manually call the `sort` method on the collection.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像在收集中监听 `change` 事件一样简单；当发生这种情况时，我们手动在收集中调用 `sort` 方法。
- en: 'However, there''s something more to do in the collection. The default `sort`
    method will only sort in one direction. We want to be able to click on a heading
    a second time and get a reverse sort. So, we''ll have to write a `reverse` method
    ourselves. Insert the following code in the `Events` collection:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在收集过程中还有更多的事情要做。默认的 `sort` 方法只会按一个方向排序。我们希望能够点击一个标题两次并得到反向排序。因此，我们必须自己编写一个
    `reverse` 方法。在 `Events` 收集中插入以下代码：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, we call `sort`; we pass it the `silent` option so that the `sort` event
    will not be fired. Then, we get the internal `models` property; this is the array
    that holds the model instances in our collection. We call the native array method
    `reverse` to reverse the order of the models in the array. We reassign this reversed
    array back to the `models` property. Finally, we trigger the `sort` event; this
    is the event that would usually be triggered by the `sort` method, but we silenced
    that one so that we could reverse the array. We pass the collection object and
    any options passed to `reverse` as parameters of the `sort` event.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用 `sort`；我们传递 `silent` 选项，以便不会触发 `sort` 事件。然后，我们获取内部的 `models` 属性；这是在收集中持有模型实例的数组。我们调用原生的数组方法
    `reverse` 来反转数组中模型的顺序。我们将这个反转后的数组重新赋值给 `models` 属性。最后，我们触发 `sort` 事件；这是通常由 `sort`
    方法触发的事件，但我们已经静音了它，以便我们可以反转数组。我们将收集体对象和传递给 `reverse` 的任何选项作为 `sort` 事件的参数。
- en: 'If our collection is sorted, when we loop over it in the `EventsView` class
    to add the record to a table, they will be added in the right order. But we want
    to be able to click on the table headings and sort the rows by the clicked heading.
    So the next step is to listen for the click event in our `EventsView` class. Add
    the following code to that class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的收集体已排序，当我们通过 `EventsView` 类遍历它以将记录添加到表格中时，它们将以正确的顺序添加。但我们要能够点击表格标题并按点击的标题对行进行排序。因此，下一步是在我们的
    `EventsView` 类中监听点击事件。向该类添加以下代码：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, we listen for a click on any of the table headings that have the `data-field`
    attributes that we put into the template. So, let''s write this `sort` method
    in `EventsView` as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们监听对任何具有我们放入模板中的 `data-field` 属性的表格标题的点击。因此，让我们在 `EventsView` 中按如下方式编写这个
    `sort` 方法：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We start by getting the element that was clicked (the `target`); we also make
    a shorter variable for the collection, just because we use it a lot in this method.
    Next, we set the new comparator on the collection. Then, we need to figure out
    which direction we're trying to sort in. We do this by another attribute on our
    table headings `data-direction`. If the attribute is `asc`, we'll do the reverse
    sort. Otherwise, if it's `desc`, we'll do a regular sort.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取被点击的元素（`target`）；我们还为收集体创建了一个更短的变量，只是因为我们在这个方法中经常使用它。接下来，我们在收集中设置新的比较器。然后，我们需要确定我们正在尝试按哪个方向排序。我们通过表格标题上的另一个属性
    `data-direction` 来做这件事。如果属性是 `asc`，我们将执行反向排序。否则，如果它是 `desc`，我们将执行常规排序。
- en: 'But where does this attribute come from? We didn''t put it in the template.
    Well, notice the `fixSortIcon` method we''re calling. This method does two things.
    First, as we expect, it will set the `data-direction` attribute on the element.
    But we''re also setting an icon; an arrow that will indicate the direction of
    the sort. Here''s that method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个属性是从哪里来的？我们没有在模板中放入它。注意我们调用的`fixSortIcon`方法。这个方法做两件事。首先，正如我们所期望的，它将在元素上设置`data-direction`属性。但我们还在设置一个图标；一个指示排序方向的箭头。以下是那个方法：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This method takes two parameters: the target element (the table heading that
    the user clicked on) and the direction (`asc` or `desc`). First, we get the name
    for the Glyphicons arrow icons: up for `desc`, down for `asc`. To show this icon,
    we''re going to need an `<i>` element. But, for anything other than the first
    sort, there''s going to be an `<i>` element from the previous sort. The next step
    is to remove those. Then, we set the attribute on the target element. The last
    step is to create the `<i>` element, add the appropriate class, and append it
    to the target element.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受两个参数：目标元素（用户点击的表格标题）和方向（`asc`或`desc`）。首先，我们获取Glyphicons箭头图标的名称：对于`desc`是向上，对于`asc`是向下。为了显示这个图标，我们需要一个`<i>`元素。但是，对于除了第一次排序之外的所有排序，将有一个来自前一次排序的`<i>`元素。下一步是移除这些元素。然后，我们在目标元素上设置属性。最后一步是创建`<i>`元素，添加适当的类，并将其追加到目标元素。
- en: 'So now, when we click on a header, the collection will sort by that property.
    But, how do we actually reorder the table rows? As you know, when the collection
    is sorted, a `sort` event will be emitted. Let''s capture that in the `EventsView`
    `initialize` method like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，当我们点击表头时，集合将按该属性排序。但是，我们实际上如何重新排列表格行？如您所知，当集合排序时，将发出一个`sort`事件。让我们在`EventsView`的`initialize`方法中捕获它，如下所示：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As we saw earlier, the `renderRows` function will add a row for each record
    in the collection. We already have rows in the table, so we have to figure out
    what to do with those. The easiest thing to do would be to simply empty the `<tbody>`
    element and make a bunch of new `EventView` instances. However, this isn''t great
    for memory management. We should properly remove the views with their `remove`
    method, to unhook event listeners, and then we could create new `EventViews` class.
    We''re going to take an alternate approach; however, we''re going to reorder the
    views that we''ve already created. This means that we need to keep references
    to the `EventView` instances. In the `EventsView` `initialize` method, let''s
    create a `children` property to keep track of these views. This can be done with
    the following little code snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，`renderRows`函数将为集合中的每条记录添加一行。我们已经在表中有了行，所以我们必须弄清楚如何处理这些行。最简单的方法就是简单地清空`<tbody>`元素，并创建大量的新`EventView`实例。然而，这对内存管理来说并不好。我们应该使用它们的`remove`方法正确地移除视图，取消事件监听器，然后我们可以创建新的`EventViews`类。我们将采取另一种方法；然而，我们将重新排列我们已创建的视图。这意味着我们需要保留对`EventView`实例的引用。在`EventsView`的`initialize`方法中，让我们创建一个`children`属性来跟踪这些视图。这可以通过以下简短的代码片段完成：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we need to change the `addRow` method so that it makes use of this property.
    It should now look like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更改`addRow`方法，使其利用这个属性。它现在应该看起来像这样：
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, this method will first check to see whether there's a property in our `children`
    object with the ID of this event. If not, we'll create a new `EventView` object,
    render it, and store it in the `children` object. Whether it's freshly created
    or not, we'll append it to `<tbody>`. The beauty of this is that even if it's
    already in `<tbody>`, this will move it to the end. After running through the
    collection, the table rows will be properly sorted.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个方法将首先检查我们的`children`对象中是否有具有此事件ID的属性。如果没有，我们将创建一个新的`EventView`对象，渲染它，并将其存储在`children`对象中。无论它是新创建的还是旧的，我们都会将其追加到`<tbody>`中。这种方法的优点是，即使它已经在`<tbody>`中，这也会将其移动到末尾。在遍历集合后，表格行将得到适当的排序。
- en: 'That''s everything in place! Now, head over to the browser and give the sorting
    feature a once around. The following screenshot shows the things in action:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的东西都已经到位！现在，前往浏览器，对排序功能进行一次全面测试。以下屏幕截图显示了实际操作的情况：
- en: '![Sorting events](img/6997OS_03_04.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![排序事件](img/6997OS_03_04.jpg)'
- en: 'And now, sorting by the ID column can be seen in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在以下屏幕截图中看到按ID列排序的情况：
- en: '![Sorting events](img/6997OS_03_05.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![排序事件](img/6997OS_03_05.jpg)'
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We''ve covered a lot in this chapter. Previously, we''d only created and read
    models on the server. Now, we know how to update and delete models on the server
    as well. This is bread-and-butter stuff for Backbone applications. Many of the
    apps you build will use all the four CRUD operations: creating, reading, updating,
    and deleting.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量的内容。之前，我们只是在服务器上创建和读取模型。现在，我们知道了如何更新和删除服务器上的模型。这对于 Backbone 应用程序来说是基础性的内容。你构建的许多应用程序都将使用所有四个
    CRUD 操作：创建、读取、更新和删除。
- en: Another important thing to take away is the way we updated the collection by
    fetching from the server. You won't do it this way in every application—regularly
    polling the server—but the events that we listened for will be the same in every
    case. In fact, there's a common Backbone convention here; listen for the `change`
    event on a model and rerender the view that shows that model. Usually, you'll
    only need to call the `render` method to do that. As the main element of the view
    is already in the DOM, there's no need to reappend it; it will update when `render`
    is called.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的重要事情是我们通过从服务器获取数据来更新集合的方式。你不会在每一个应用程序中都这样做——定期轮询服务器，但我们在每个情况下都会监听相同的事件。实际上，这里有一个常见的
    Backbone 习惯；在模型上监听 `change` 事件，并重新渲染显示该模型的视图。通常，你只需要调用 `render` 方法即可。由于视图的主要元素已经在
    DOM 中，因此不需要重新附加它；当调用 `render` 时，它将更新。
- en: Also, a notable thing in this chapter is the way we created a `view` class and
    then extended it with two child view classes. Don't forget that your models, collections,
    and views have the `extend` method, just like their Backbone parents. You can
    use this to your advantage when you find yourself creating two or more extremely
    similar components.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章中一个值得注意的事情是我们创建了一个 `view` 类，然后通过两个子视图类来扩展它。不要忘记，你的模型、集合和视图都有 `extend` 方法，就像它们的
    Backbone 父类一样。当你发现自己正在创建两个或更多极其相似组件时，你可以利用这个方法。
- en: Finally, remember that discarding views is about more than just deleting its
    DOM elements. It's important to do it properly, by calling the view's `remove`
    method. However, as we saw, it's more than just that. When listening for events
    in the view's `initialize` method, it's better to use `this.listenTo` than `this.model.on`
    or `this.collection.on`. This way, the view can unhook these events when we remove
    it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，丢弃视图不仅仅是删除其 DOM 元素。正确地调用视图的 `remove` 方法是很重要的。然而，正如我们所看到的，这不仅仅是那样。在视图的
    `initialize` 方法中监听事件时，使用 `this.listenTo` 比使用 `this.model.on` 或 `this.collection.on`
    更好。这样，当移除视图时，视图可以取消绑定这些事件。
- en: After creating this `events` dashboard, you might look at it and think that
    it makes a neat calendar. However, we can do much better for a calendar. We'll
    build that in the next chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了这个 `events` 仪表板之后，你可能会认为它看起来像一张整洁的日历。然而，对于日历，我们可以做得更好。我们将在下一章中构建它。
