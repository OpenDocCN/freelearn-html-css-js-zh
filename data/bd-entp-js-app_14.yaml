- en: Creating UI with React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React创建UI
- en: So far in this book, we have focused on the development of our back-end API;
    but our application won't be complete without an intuitive user interface (UI) our
    end-users can interact with. Thus, this chapter will focus on building a web application
    that consumes our API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们专注于后端API的开发；但如果没有直观的用户界面（UI）供我们的最终用户交互，我们的应用程序将是不完整的。因此，本章将专注于构建一个消耗我们API的Web应用程序。
- en: 'Specifically, by following this chapter, you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，通过遵循本章，你将：
- en: Understand the pros and cons of different UI frameworks and libraries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同UI框架和库的优缺点
- en: Learn about the basics of **React**, including **JSX** and **virtual DOM**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**React**的基础知识，包括**JSX**和**虚拟DOM**
- en: Bundle our code using **Webpack**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Webpack**打包我们的代码
- en: Picking a front-end framework/library
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择前端框架/库
- en: As we've already discussed in [Chapter 2](47a4c8b3-b1b3-4095-b127-621624a2fa37.xhtml), *The
    State of JavaScript*, **single-page applications** (**SPAs**) are a great improvement
    over the more traditional **multi-page applications** (**MPAs**) that uses a **client-server** architecture.
    With SPAs, a lot of the logic that was traditionally done on the server has been
    delegated to the client. This means there'll be less load on the server, and the
    application can respond more quickly to user interaction. Therefore, for our client
    application, we will be building an SPA. Now, the next step is to pick a technology
    stack for our SPA.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第2章](47a4c8b3-b1b3-4095-b127-621624a2fa37.xhtml)，“JavaScript的现状”中已讨论的，**单页应用程序**（**SPAs**）相较于更传统的使用**客户端-服务器**架构的**多页应用程序**（**MPAs**）是一个巨大的进步。在SPAs中，许多传统上在服务器上完成的逻辑已经委托给了客户端。这意味着服务器上的负载将减少，应用程序可以更快地响应用户交互。因此，对于我们的客户端应用程序，我们将构建一个SPA。现在，下一步是选择我们的SPA的技术栈。
- en: Vanilla JavaScript vs. frameworks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯JavaScript与框架
- en: SPAs are often discussed in conjunction with popular frameworks and libraries,
    such as **AngularJS**/**Angular**, **React**, **Vue.js**, **Ember**, and **Meteor**;
    but we should remember that SPAs can be written with vanilla HTML, CSS, and JavaScript
    alone. We may also choose to employ utility libraries, such as **jQuery**, to
    abstract away prickly web APIs, such as `XMLHttpRequest`, and to keep our code
    more readable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序（SPAs）通常与流行的框架和库一起讨论，例如**AngularJS**/**Angular**、**React**、**Vue.js**、**Ember**和**Meteor**；但我们应该记住，SPAs可以使用纯HTML、CSS和JavaScript编写。我们还可以选择使用实用库，例如**jQuery**，来抽象掉棘手的Web
    API，例如`XMLHttpRequest`，并使我们的代码更具可读性。
- en: 'However, without using a framework or library, we''d have to handle all the
    logic of:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果不使用框架或库，我们将不得不处理以下所有逻辑：
- en: '**Routing**: Navigating from one page to the next'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：从一个页面导航到另一个页面'
- en: '**DOM manipulation**: Adding/removing components to/from the page'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOM操作**：向页面添加/删除组件'
- en: '**Data binding:** Keeping the template updated with the data'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据绑定**：保持模板与数据的更新'
- en: This may be manageable for simply fetch-and-display applications, such as a
    user directory, whose main logic is to fetch data from an API, substitute it into
    a template, and render it. For more complicated applications, we might find ourselves
    re-implementing much of the features provided by a framework/library anyways.
    Similar to how Express abstracts low-level details to make dealing with HTTP requests
    and routing easier, these frameworks/libraries can abstract away a lot of logic
    for us.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的获取和显示应用程序，例如用户目录，其主要逻辑是从API获取数据，将其替换到模板中，并渲染它，这可能还是可以管理的。但对于更复杂的应用程序，我们可能会发现自己仍然需要重新实现框架/库提供的许多功能。类似于Express通过抽象底层细节来简化处理HTTP请求和路由的方式，这些框架/库可以为我们抽象掉很多逻辑。
- en: Choosing a framework/library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择框架/库
- en: 'There is a myriad of client-side frameworks/libraries available, including **Aurelia**,
    Ember, **Polymer**, **Backbone**, AngularJS/Angular, Vue.js, React, **Preact**, **Knockout**,
    jQuery, **Mithril**, **Inferno**, **Riot**, **Svelte**, and so on. However, three
    frameworks/libraries dominate: AngularJS/Angular, React, and Vue.js.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的客户端框架/库众多，包括**Aurelia**、Ember、**Polymer**、**Backbone**、AngularJS/Angular、Vue.js、React、**Preact**、**Knockout**、jQuery、**Mithril**、**Inferno**、**Riot**、**Svelte**等等。然而，有三个框架/库占据主导地位：AngularJS/Angular、React和Vue.js。
- en: Let us examine each one based on different factors, in order for us to make
    an informed decision as to which library/ framework is best for our use case.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据不同的因素逐一分析，以便我们能够做出明智的决定，选择最适合我们用例的库/框架。
- en: Popularity/community
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行度/社区
- en: Client-side web application frameworks, such as Knockout, Backbone, and Ember,
    existed before AngularJS was released in 2012, but AngularJS was the first to
    gain widespread adoption and has retained the title of "Most popular front-end
    framework" for many years. However, because it was the first, there were many
    rough edges that developers soon found annoying. According to the *State* *of
    JavaScript 2017* survey, out of all those who have used AngularJS (version 1),
    only 32.9% would use it again.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在2012年AngularJS发布之前，客户端Web应用程序框架，如Knockout、Backbone和Ember就已经存在，但AngularJS是第一个获得广泛采用并多年保持“最受欢迎的前端框架”称号的框架。然而，由于它是第一个，开发者很快就发现了很多令人烦恼的粗糙边缘。根据2017年*JavaScript状态*调查，在所有使用过AngularJS（版本1）的人中，只有32.9%的人会再次使用它。
- en: Therefore, when React was released in 2013, many Angular developers migrated
    to React, boosting React's popularity. Satisfaction among React developers is
    also high, with 93.1% of developers in the aforementioned survey saying they would
    use it again.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当React在2013年发布时，许多Angular开发者迁移到React，这提高了React的知名度。React开发者的满意度也很高，上述调查中有93.1%的开发者表示他们会再次使用它。
- en: In 2014, the AngularJS team attempted to respond by promising to completely
    re-write the AngularJS framework. However, the new version (now called "Angular")
    would be incompatible with the old version (now called "AngularJS"), which means
    migration from AngularJS to Angular would require a complete rewrite of the application.
    This caused much backlash in the Angular community, further pushing more developers
    toward React. To add to the woes of Angular, there were many delays in the development
    of Angular 2, and the final version was released only 2 years later, in 2016\.
    Two years is a very long period of time in the front-end ecosystem, and by then,
    React had already captured the lion's share of developers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，AngularJS团队试图通过承诺完全重写AngularJS框架来做出回应。然而，新版本（现在称为“Angular”）与旧版本（现在称为“AngularJS”）不兼容，这意味着从AngularJS迁移到Angular需要完全重写应用程序。这引发了Angular社区中的强烈反对，进一步促使更多开发者转向React。为了给Angular增添麻烦，Angular
    2的开发进度出现了许多延误，最终版本直到两年后的2016年才发布。在前端生态系统中，两年是一个非常长的时间，而那时React已经占据了开发者的大部分市场份额。
- en: Vue.js is the newest kid on the block, and is designed with the lessons learned
    from both Angular and React (Vue.js's creator, Evan You, was an architect at Google).
    Since its release in 2014, it has, in a way, made the same impact on the ecosystem
    as when React first came out. It also has a high satisfaction rate, with 91.1%
    of developers saying they would use Vue.js again.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js是最新加入的框架，它结合了从Angular和React中学到的经验（Vue.js的创造者Evan You曾是谷歌的架构师）。自2014年发布以来，它在某种程度上对生态系统产生了与React首次发布时相同的影响。它的满意度也很高，有91.1%的开发者表示他们会再次使用Vue.js。
- en: In terms of hard numbers, according to the same *State of JavaScript* survey,
    out of 23,704 respondents, 14,689 (62.0%) have used React, a slight gain from
    57.1% in 2016\. A total of 11,322 (47.8%) have used AngularJS 1, down from 63.6%
    in 2016, and 6,738 (28.4%) have used Angular 2, up from 20.5% in 2016\. The biggest
    climber has been Vue.js, with 5,101 (21.5%) of respondents saying they've used
    it, almost doubling the figure from 10.8% in 2016.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在具体数字方面，根据同一*JavaScript状态*调查，在23,704名受访者中，有14,689人（62.0%）使用过React，这一比例从2016年的57.1%略有上升。共有11,322人（47.8%）使用过AngularJS
    1，这一比例从2016年的63.6%下降，6,738人（28.4%）使用过Angular 2，这一比例从2016年的20.5%上升。最大的增长者是Vue.js，有5,101人（21.5%）表示他们使用过它，这一数字几乎是从2016年的10.8%的两倍。
- en: In terms of contributors to the source code, 1,598 developers have contributed
    to Angular, 1,177 have contributed to React, and only 187 have contributed to
    Vue.js.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码的贡献者方面，有1,598名开发者为Angular做出了贡献，1,177名开发者为React做出了贡献，而只有187名开发者对Vue.js做出了贡献。
- en: It's important to note that the most popular framework doesn't mean it is the
    best framework, and a developer should never choose a framework solely based on
    its popularity (a.k.a. **hype-driven development**). However, the more popular
    a framework is, the more developers use that framework, and thus there is likely
    to be more community support on forums and Q&A sites, such as Stack Overflow.
    From the business' perspective, it'll also make it easier to hire developers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，最受欢迎的框架并不意味着它是最好的框架，开发者永远不应该仅仅基于其知名度（即**炒作驱动的发展**）来选择框架。然而，一个框架越受欢迎，使用该框架的开发者就越多，因此在论坛和问答网站（如Stack
    Overflow）上可能会有更多的社区支持。从企业的角度来看，这也会使招聘开发者变得更加容易。
- en: Therefore, from the popularity/community/ecosystem point of view, Angular is
    in decline, Vue.js is on the rise, but React is still the obvious choice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从受欢迎程度/社区/生态系统角度来看，Angular 正在衰落，Vue.js 正在崛起，但 React 仍然是明显的选择。
- en: Features
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能
- en: When Angular first came out, it handled the routing, the (two-way) data-binding,
    and DOM manipulation. It was the first of its kind, and it set the standards of
    what a client-side web application framework should look like.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 首次推出时，它处理了路由、（双向）数据绑定和 DOM 操作。它是这一类中的第一个，并确立了客户端 Web 应用程序框架应该是什么样的标准。
- en: Then, when React came out, it redefined what that standard is. Whilst Angular
    promoted its two-way data binding as a killer feature, React shunted it and called
    it a source of bugs; instead, it promoted one-way data-binding.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当 React 推出时，它重新定义了那个标准。虽然 Angular 将双向数据绑定作为杀手级特性进行推广，但 React 则将其视为一个错误源；相反，它推广了一向数据绑定。
- en: But the biggest change in the paradigm with React is the introduction of the
    virtual DOM and JSX.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但 React 中的最大范式转变是虚拟 DOM 和 JSX 的引入。
- en: Virtual DOM
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟 DOM
- en: The virtual DOM is a simplified abstraction of the real DOM. In React, instead
    of manually manipulating the real DOM, developers should instead manipulate the
    Virtual DOM. React would then compare the old Virtual DOM state with the new one,
    and calculate the most efficient way of manipulating the real DOM.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟 DOM 是真实 DOM 的简化抽象。在 React 中，开发者应该操作虚拟 DOM 而不是手动操作真实 DOM。React 会比较旧的虚拟 DOM
    状态和新的状态，并计算出操作真实 DOM 的最有效方式。
- en: DOM manipulation is a heavy operation and humans often don't see the most efficient
    method of manipulating it. Therefore, having React automatically calculate the
    most efficient way makes updating the DOM much more efficient, and leads to a
    faster, more reactive UI.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 操作是一个重量级操作，人类往往看不到最有效的方法。因此，让 React 自动计算出最有效的方法可以使更新 DOM 更加高效，从而实现更快、更反应灵敏的
    UI。
- en: JSX
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX
- en: JSX is a new language that compiles down to JavaScript. It allows developers
    to define components of the UI in an HTML-like syntax. Instead of using `document.createElement()`, `React.createElement()`,
    or a templating engine, you can write your component in JSX. JSX is like a template,
    in the sense that you can add placeholders within the template that'll be substituted
    with real data. The difference is that JSX gets compiled down to plain JavaScript,
    which means you can use any JavaScript syntax directly inside a JSX file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是一种新的语言，它编译成 JavaScript。它允许开发者使用类似 HTML 的语法定义 UI 组件。你不需要使用 `document.createElement()`、`React.createElement()`
    或模板引擎，你可以用 JSX 编写你的组件。JSX 像一个模板，因为你可以在模板中添加占位符，这些占位符将被真实数据替换。区别在于 JSX 编译成纯 JavaScript，这意味着你可以在
    JSX 文件中直接使用任何 JavaScript 语法。
- en: If you're familiar with **CSS preprocessors**, you can think of JSX as the preprocessor
    for HTML, similar to what **Sass** does for CSS. The introduction of JSX means
    developers have a much easier way to visualize their UI components in code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 **CSS 预处理器**，你可以将 JSX 视为 HTML 的预处理器，类似于 Sass 对 CSS 所做的那样。JSX 的引入意味着开发者有了一个更简单的方式来在代码中可视化他们的
    UI 组件。
- en: Post-React
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 之后
- en: To say React revolutionized front-end development would not be an understatement.
    React introduced new concepts that other libraries and frameworks have copied.
    For instance, Vue.js also implements a Virtual DOM and supports the JSX syntax
    in its templates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 说到 React 改变了前端开发，这并不过分。React 引入了其他库和框架所复制的新概念。例如，Vue.js 也实现了虚拟 DOM 并在其模板中支持
    JSX 语法。
- en: However, Angular has very much fallen behind the pack. The Angular team have
    stuck to the "Angular way" and have not moved alongside the community. Dare I
    say, their best is past them; the best they can do is play catch-up at the moment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Angular 已经远远落后于其他框架。Angular 团队坚持“Angular 方式”，并没有与社区一起前进。我敢说，他们的最佳时期已经过去；目前他们能做的就是追赶。
- en: Flexibility
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活性
- en: Angular is a framework, which means you must commit to building the entirety
    of your application using the framework. As demonstrated when the Angular team
    rewrote Angular, changing a framework requires rewriting the entire application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是一个框架，这意味着你必须承诺使用该框架构建你应用程序的全部内容。正如 Angular 团队重写 Angular 时所展示的那样，改变一个框架需要重写整个应用程序。
- en: On the other hand, React and Vue.js are libraries, which means you can add them
    to your project and use them whenever is appropriate for you. You can also add
    additional libraries (for example, routers, state management) that will work with
    React/Vue.js.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，React 和 Vue.js 是库，这意味着你可以将它们添加到你的项目中，并在适当的时候使用它们。你还可以添加额外的库（例如，路由器、状态管理），这些库将与
    React/Vue.js 一起工作。
- en: Therefore, in terms of flexibility, React and Vue.js are the winners here.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在灵活性方面，React 和 Vue.js 是这里的赢家。
- en: Performance
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: Stefan Krause has developed and published a series of benchmarks on some basic
    operations using each framework (available at [github.com/krausest/js-framework-benchmark](https://github.com/krausest/js-framework-benchmark)).
    The results show that React is ever so slightly faster than Vue.js, especially
    in terms of making partial updates, but also consumes slightly more memory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Stefan Krause 开发并发布了一系列基准测试，使用每个框架进行一些基本操作（可在 [github.com/krausest/js-framework-benchmark](https://github.com/krausest/js-framework-benchmark)
    上找到）。结果显示，React 比 Vue.js 略快，尤其是在进行部分更新时，但也消耗了略多的内存。
- en: Angular performs about the same as React and Vue, but consumes noticeably more
    memory and has a longer initiation time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的性能与 React 和 Vue 相当，但消耗的内存明显更多，并且初始化时间更长。
- en: Cross-platform
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台
- en: A common mistake that companies make when choosing their technology stacks is
    that they are inconsistent. For instance, I have worked in a startup where we
    had four projects, and each one was using a different front-end stack:  AngularJS,
    Angular, Polymer, and React. The result was that developers working on Angular
    were unable to help with the project using React, and vice versa. Some developers
    ended up learning all of the frameworks, but the quality of the code was bad,
    as they became a "Jack of all trades, master of none". Therefore, having a consistent
    stack for all your front-end projects is important. Quite often, this might involve
    not only web applications, but also native mobile and desktop applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 公司在选择技术栈时常见的错误是他们不一致。例如，我在一家初创公司工作过，我们共有四个项目，每个项目都使用不同的前端技术栈：AngularJS、Angular、Polymer
    和 React。结果是，使用 Angular 开发的开发者无法帮助使用 React 的项目，反之亦然。一些开发者最终学习了所有框架，但代码质量很差，因为他们变成了“样样通，样样松”的人。因此，为所有前端项目保持一致的技术栈非常重要。通常，这不仅仅涉及网络应用程序，还包括原生移动和桌面应用程序。
- en: Hybrid applications with Ionic
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ionic 的混合应用程序
- en: Around 1 year after the release of AngularJS, **Ionic** was released. Ionic
    is a framework for building **hybrid** mobile applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AngularJS 发布大约 1 年后，**Ionic** 发布了。Ionic 是用于构建 **混合** 移动应用程序的框架。
- en: Essentially, you build a web application using Angular, and then Ionic will
    use another tool called **Cordova** to wrap the complete application inside a **WebView** container.
    A WebView is basically a simplified web browser that native apps can add into
    their application. Therefore, a hybrid application is basically the same as using
    your web application through a browser that is inside the native app. With a hybrid
    application, you can "write once, run anywhere".
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，你使用 Angular 构建一个网络应用程序，然后 Ionic 会使用另一个名为 **Cordova** 的工具将完整的应用程序包裹在一个 **WebView**
    容器中。WebView 实际上是一个简化的网页浏览器，原生应用程序可以将其添加到自己的应用中。因此，混合应用程序基本上就是通过原生应用程序内部的浏览器来使用你的网络应用程序。使用混合应用程序，你可以“一次编写，到处运行”。
- en: However, because there are so many layers, the response time of the UI was initially
    slow, giving the hybrid app a jittery feel.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于有很多层，UI 的响应时间最初很慢，给混合应用程序带来了一种颠簸的感觉。
- en: Native UI with React Native and Weex
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Native 和 Weex 的原生 UI
- en: When Facebook announced **React Native** for iOS and Android in 2015, it was
    big news. It meant developers could now use the same React principles and syntax
    to develop the front-end for both web and mobile applications. It also meant that
    non-platform-specific logic could be shared, which prevents multiple implementations
    of the same logic in different languages (Java for Android and Swift/Objective-C
    for iOS).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Facebook 在 2015 年宣布为 iOS 和 Android 提供 **React Native** 时，这是一个重大新闻。这意味着开发者现在可以使用相同的
    React 原则和语法来开发网络和移动应用程序的前端。这也意味着可以共享非平台特定的逻辑，从而防止在不同语言中（Java 用于 Android 和 Swift/Objective-C
    用于 iOS）对相同的逻辑进行多次实现。
- en: This was also dubbed “Learn once, write everywhere”, and allows React developers
    to easily transition between a web developer and mobile developer. Nowadays, React
    Native can even be used for building Windows applications and virtual reality
    (VR) applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称作“一次学习，到处编写”，允许 React 开发者轻松地在网页开发者和移动开发者之间切换。如今，React Native 甚至可以用来构建 Windows
    应用程序和虚拟现实（VR）应用程序。
- en: For Vue.js, they've been involved in an ongoing collaboration with the Alibaba
    Group to develop a similar cross-platform UI library called **Weex**. Soon, Vue.js
    will also support writing in **NativeScript**. However, as admitted by the Vue.js
    team themselves, Weex is still in active development and not as battle-tested
    as React Native, and NativeScript support is a community-driven effort that is
    not yet ready.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vue.js，他们已经与阿里巴巴集团进行了持续的协作，开发了一个类似的跨平台 UI 库，称为 **Weex**。不久，Vue.js 也将支持使用
    **NativeScript** 编写。然而，正如 Vue.js 团队自己承认的那样，Weex 仍在积极开发中，并且不像 React Native 那样经过实战检验，而
    NativeScript 的支持是一个社区驱动的努力，目前尚未准备好。
- en: Therefore, in terms of using the same framework/library across multiple platforms,
    React has the most mature tooling and ecosystem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在跨多个平台使用相同的框架/库方面，React 拥有最成熟的工具和生态系统。
- en: Learning curve
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习曲线
- en: 'While this may be subjective, I, and many others, have found Angular to have
    the steepest learning curve. There are many Angular-specific concepts, such as
    their **digest cycle**, that you must understand before you can be productive
    with Angular. Angular also uses a lot of tools that developers may not be familiar
    with, including:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能具有主观性，但我以及许多人发现 Angular 的学习曲线最陡峭。有许多 Angular 特有的概念，例如它们的 **digest 循环**，你必须理解这些概念才能在
    Angular 中高效工作。Angular 还使用了开发者可能不熟悉的许多工具，包括：
- en: '**TypeScript**: Provides static typing to JavaScript'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**: 为 JavaScript 提供静态类型'
- en: '**RxJS**: Allows you to write functional reactive code'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RxJS**: 允许你编写函数式响应式代码'
- en: '**SystemJS**:  A module loader'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SystemJS**: 一个模块加载器'
- en: '**karma**:  A tool for running unit tests'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**karma**: 运行单元测试的工具'
- en: '**Protractor**: An E2E test runner that allows you to run tests that interact
    with a real browser'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**量角器**: 一个端到端测试运行器，允许你运行与真实浏览器交互的测试'
- en: Although each of these tools brings a lot of value into the application, it
    no doubts adds to the already-steep learning curve for Angular.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个工具都为应用程序带来了很多价值，但它无疑增加了 Angular 已经很陡峭的学习曲线。
- en: React, on the other hand, is just a view rendering library, and so is much easier
    to understand. The basic idea is that you create components, pass in some inputs,
    and React will generate the final view and render it onto the page. You can arrange
    these components in different ways and nest them inside each other, as it's all
    composable. You may have to learn about the difference between states and props,
    and also the lifecycle methods, but that can be done in a few hours at most.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，React 只是一个视图渲染库，因此更容易理解。基本思想是创建组件，传递一些输入，React 将生成最终视图并将其渲染到页面上。你可以以不同的方式排列这些组件，并将它们嵌套在一起，因为它们都是可组合的。你可能需要了解状态和
    props 之间的区别，以及生命周期方法，但这最多只需要几个小时就可以完成。
- en: Perhaps what people are referring to when they say "React has a steep learning
    curve" is the ecosystem around it. The React ecosystem is organized in a way where
    you have many tools, each doing one specific thing. This is generally a good thing
    but it also means you'd have to spend the time to pick from the different options,
    and perhaps spend even more time debugging incompatibilities when you try to integrate
    them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 人们说“React 学习曲线陡峭”时可能指的是其生态系统。React 生态系统是有组织的，你有很多工具，每个工具都做一件特定的事情。这通常是一件好事，但也意味着你需要花时间从不同的选项中进行选择，并且在尝试集成它们时可能会花费更多时间进行调试。
- en: For instance, you may use React Router to route your pages. You'd need to learn
    Redux or MobX to manage your state. Most of the time, you'd use Webpack to bundle
    your application. However, many React developers also use libraries, such as ImmutableJS,
    Flow, TypeScript, Karma, and ESLint, which are not compulsory tools, but can often
    confuse new developers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能使用 React Router 来路由你的页面。你需要学习 Redux 或 MobX 来管理你的状态。大多数情况下，你会使用 Webpack
    来打包你的应用程序。然而，许多 React 开发者也使用像 ImmutableJS、Flow、TypeScript、Karma 和 ESLint 这样的库，这些库不是强制性的工具，但常常会让新开发者感到困惑。
- en: An alternative approach is to use a full-featured boilerplate, such as React
    Boilerplate ([reactboilerplate.com](http://www.reactboilerplate.com/)), which
    has a shallower learning curve, but you'd still have to learn the conventions
    used by the boilerplate author. Furthermore, if there's a bug/issue with the boilerplate,
    it'll be much harder for you to debug.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用功能齐全的脚手架，例如React Boilerplate ([reactboilerplate.com](http://www.reactboilerplate.com/))，它具有更平缓的学习曲线，但你仍然需要学习脚手架作者使用的约定。此外，如果脚手架存在bug/问题，调试起来会困难得多。
- en: In terms of concepts, React is much simpler than Angular. Even with the React
    ecosystem, the learning curve is still manageable. Personally, having to stitch
    your own stack together forces you to understand what each tool does, and how
    it interacts with other tools, which is a good thing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，React比Angular简单得多。即使是在React生态系统下，学习曲线仍然可控。个人而言，必须自己拼接自己的技术栈迫使你了解每个工具的作用以及它们如何与其他工具交互，这是一件好事。
- en: Vue.js boasts an even simpler learning curve. It does not use JSX, but a simpler
    template-like syntax with its own domain-specific language (DSL). It does not
    require Webpack and developers can enable Vue.js just by including a typical `<script>` tag.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js拥有更简单的学习曲线。它不使用JSX，而是使用更简单的类似模板的语法以及自己的领域特定语言（DSL）。它不需要Webpack，开发者只需包含一个典型的`<script>`标签就可以启用Vue.js。
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Therefore, it's easier for developers not using a framework to migrate to Vue.js,
    as they can more easily convert their HTML into HTML-like templates, and can incrementally
    adapt the entire application to Vue.js.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于不使用框架的开发者来说，迁移到Vue.js更容易，因为他们可以更轻松地将HTML转换为类似HTML的模板，并逐步将整个应用程序适应Vue.js。
- en: Conclusion
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In terms of community, richness, maturity of the ecosystem, features, flexibility,
    and cross-platform capabilities, React is the stand-out choice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在社区、丰富性、生态系统成熟度、功能、灵活性和跨平台能力方面，React是显而易见的选择。
- en: The one thing that Vue.js may have over React right now is the learning curve.
    In a year or two, however, we may see Vue.js overtake React in all the other factors.
    If not, another framework/library probably will.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Vue.js可能比React有优势的一点是学习曲线。然而，一两年后，我们可能会看到Vue.js在其他所有方面超过React。如果不是这样，另一个框架/库可能会做到。
- en: Angular is unlikely to disappear altogether, as there are enough early-adaptors
    and hard-core advocates of Angular remaining, meaning that we'll still see Angular
    on the market for at least a few more years. But unless they do something drastically
    different (and better), it's safe to assume Angular will fade slowly into the
    background, just as its predecessors have done before it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Angular不太可能完全消失，因为仍然有足够的早期采用者和Angular的忠实支持者，这意味着我们至少还会在市场上看到Angular几年。但除非他们做出大幅度的不同（并且更好），否则可以安全地假设Angular将缓慢地退入背景，就像它之前的先驱一样。
- en: Therefore, for all the reasons listed so far, we will develop our client-side
    web application using React.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，鉴于到目前为止所列出的所有原因，我们将使用React开发我们的客户端Web应用程序。
- en: Getting started with React
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用React
- en: As mentioned earlier, although React itself is quite simple, the ecosystem around
    it can be a little overwhelming. Tessa Thorton, a former senior front-end developer
    for Shopify, once wrote a blog post titled *How to learn web frameworks* ([ux.shopify.com/how-to-learn-web-frameworks-9d447cb71e68](https://ux.shopify.com/how-to-learn-web-frameworks-9d447cb71e68))
    In it, she reminded us that "Frameworks don’t exist to impress people or make
    your life harder. They exist to solve problems."
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，尽管React本身相当简单，但围绕它的生态系统可能会有些令人不知所措。Shopify的前高级前端开发人员Tessa Thorton曾撰写了一篇名为《如何学习Web框架》的博客文章
    ([ux.shopify.com/how-to-learn-web-frameworks-9d447cb71e68](https://ux.shopify.com/how-to-learn-web-frameworks-9d447cb71e68))。在文章中，她提醒我们：“框架的存在不是为了给人留下深刻印象或让生活变得更难。它们的存在是为了解决问题。”
- en: This reminds me of the first ever application I ever built, a clone of Amazon.
    It was built completely in vanilla JavaScript and PHP because I didn't even know
    there were frameworks available! However, there was a piece of animation I couldn't
    get right, and after Googling a lot (and finding the paradise that is Stack Overflow),
    I ended up using jQuery.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起了我第一次构建的应用程序，一个Amazon的克隆。它完全使用纯JavaScript和PHP构建，因为我甚至不知道有框架可用！然而，有一段动画我无法正确实现，经过大量的Google搜索（并找到Stack
    Overflow的天堂），我最终使用了jQuery。
- en: For learning how to program, this was not a bad strategy. It allowed me to understand
    what is possible without frameworks, and appreciate the framework more when I
    do use it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于学习如何编程来说，这不是一个坏策略。它让我理解了没有框架时可能做到的事情，并且当我使用框架时，我更加欣赏框架。
- en: Most tutorials will ask you to set up all the tools first, before explaining
    how to use them. We are going to take a different approach - we will build our
    page from scratch using the minimum set of tools, and introducing new concepts
    and tools *only when needed*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数教程都会要求你首先设置所有工具，然后再解释如何使用它们。我们将采取不同的方法——我们将从零开始构建我们的页面，使用最少的工具集，并在需要时引入新的概念和工具。
- en: In the following section, we will use this approach to build the Register page
    of our application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用这种方法来构建我们应用程序的注册页面。
- en: What is React?
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是React？
- en: 'React is a library used for building client-facing user interfaces for applications.
    In principle, it works similar to other front-end frameworks: it takes some data,
    plugs it into some sort of template, and renders the combined view onto the screen.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个用于构建面向客户端用户界面的应用程序库。原则上，它的工作方式与其他前端框架类似：它获取一些数据，将其插入某种模板中，然后将组合视图渲染到屏幕上。
- en: Components
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: In React, everything you build are *components*. Imagine a component as a LEGO
    brick; by combining components together, you get a complete UI. A button can be
    a component, an input field can be another component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，你构建的一切都是 *组件*。想象一下组件就像乐高积木；通过组合组件，你可以得到一个完整的用户界面。按钮可以是一个组件，输入字段可以是一个另一个组件。
- en: Many developers use the terms "element" and "components" interchangeably. Generally
    speaking, you should use "element" when referring to HTML elements, and "component"
    when describing React components.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者将“元素”和“组件”这两个术语互换使用。一般来说，当提到HTML元素时，你应该使用“元素”，当描述React组件时，你应该使用“组件”。
- en: Each component contains its own HTML, CSS, and JavaScript, so it is independent
    of other components. This includes methods to run when the component is first
    rendered on-screen, and methods to run when it is removed from view (collectively,
    these are called *lifecycle methods*).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都包含自己的HTML、CSS和JavaScript，因此它独立于其他组件。这包括在组件首次渲染到屏幕上时运行的函数，以及当它从视图中移除时运行的函数（这些函数统称为 *lifecycle
    methods*）。
- en: Components can be combined to form new components. For example, we can take
    two `HobnobInput` components, add an `HobnobButton` component, and then wrap them
    inside a `<form>` element, and call that the `HobnobForm` component.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以组合成新的组件。例如，我们可以取两个 `HobnobInput` 组件，添加一个 `HobnobButton` 组件，然后将它们包裹在一个 `<form>` 元素内，称之为 `HobnobForm` 组件。
- en: Every React application has a single **root component**, and you mount **child
    components** (which can have their own child components) into the root component.
    In the end, you build up a tree of components, similar to the DOM tree.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个React应用程序都有一个单一的 **根组件**，你将 **子组件** （它们可以有它们自己的子组件）挂载到根组件中。最终，你构建了一个组件树，类似于DOM树。
- en: Virtual DOM
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM
- en: React components actually exist inside a space called the *Virtual DOM*, an
    object that serves as a light-weight representation of the actual DOM. Essentially,
    when the page renders, React generates a Virtual DOM object from the data and
    the components, and then it translates this Virtual DOM into DOM elements and
    inserts them into the DOM.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: React组件实际上存在于一个称为 *虚拟DOM* 的空间中，这是一个作为实际DOM轻量级表示的对象。本质上，当页面渲染时，React从数据和组件生成一个虚拟DOM对象，然后将其转换为DOM元素并插入到DOM中。
- en: So why not just translate the React components into the DOM nodes directly?
    The answer is performance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么不直接将React组件转换为DOM节点呢？答案是性能。
- en: How Virtual DOM improves performance
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM如何提高性能
- en: HTML is a linear, string representation of the structure of a website/app. The
    string, in and of itself, conveys no information about hierarchy or structure.
    For the browser to understand and render the structure represented by the HTML,
    it parses this HTML and abstracts it into a tree-like representation called the **Document
    Object Model**, or **DOM**. Essentially, the tags in your linear HTML become nodes
    inside the DOM tree.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 是一个表示网站/应用程序结构的线性字符串表示。这个字符串本身并不传达关于层次结构或结构的信息。为了浏览器理解并渲染HTML表示的结构，它解析这个HTML并将其抽象成一个称为 **文档对象模型** 或 **DOM** 的树状表示。本质上，你的线性HTML标签变成了DOM树中的节点。
- en: However, this parsing is relatively expensive. There are many layers of nesting,
    and each node has many properties and methods associated with them. So, if your
    application contains many (nested) components, your end users may notice a delay
    in the rendering. This is also true for DOM manipulation (when you move nodes
    around in the DOM), so it's best to keep DOM manipulation to a minimum.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种解析相对昂贵。有许多层级的嵌套，每个节点都有许多与之关联的属性和方法。因此，如果你的应用程序包含许多（嵌套）组件，你的最终用户可能会注意到渲染中的延迟。这也适用于
    DOM 操作（当你移动 DOM 中的节点时），因此最好将 DOM 操作保持在最低限度。
- en: React uses the concept of a Virtual DOM to minimize DOM manipulation. In React,
    when we try to render a component, React will pass the relevant data into the `render()` method
    of your component, and generate a lightweight representation of your view, which
    forms part of the Virtual DOM. The Virtual DOM is a JavaScript object and does
    not have all the unnecessary properties and methods that the real DOM elements
    have, and so manipulating them is much faster.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用虚拟 DOM 的概念来最小化 DOM 操作。在 React 中，当我们尝试渲染一个组件时，React 会将相关数据传递到你的组件的 `render()`
    方法中，并生成你视图的轻量级表示，这构成了虚拟 DOM 的一部分。虚拟 DOM 是一个 JavaScript 对象，它没有真实 DOM 元素所具有的所有不必要的属性和方法，因此操作它们要快得多。
- en: If this is the first time the page is rendered, the Virtual DOM will be translated
    into markup and injected into the document. Whenever the input to the component
    changes, the `render()` method could be called again, which produces another representation
    of your view. React then find the differences between the previous representation
    and the current representation ("diffing" the Virtual DOM), and generates the
    minimum set of changes to apply to the DOM.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是页面第一次渲染，虚拟 DOM 将被转换为标记并注入到文档中。每当组件的输入发生变化时，`render()` 方法可能会再次被调用，这将产生你视图的另一个表示。React
    然后找出前一个表示和当前表示之间的差异（“虚拟 DOM 的差异”），并生成应用于 DOM 的最小更改集。
- en: This means that if the change in input does not require a re-render, then the
    DOM is not manipulated. Furthermore, it is often difficult to see the most efficient
    way to manipulate the DOM, especially for complex UIs. React's algorithms take
    care of that to find the most efficient way possible to achieve the new UI state.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果输入的变化不需要重新渲染，那么 DOM 就不会被操作。此外，通常很难看到操作 DOM 的最高效方式，尤其是在复杂的 UI 中。React 的算法负责找到实现新
    UI 状态的最有效方式。
- en: React is declarative
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 是声明式的
- en: 'With a traditional application, you may have to listen for changes in the data,
    process it, and update the DOM yourself using something like jQuery. This is an
    imperative style, because you are specifying what and how the DOM should change
    based on the data. For example, on the user search page, when the results come
    in, it looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的应用程序中，你可能需要监听数据的变化，处理它，并使用类似 jQuery 的工具自己更新 DOM。这是一种命令式风格，因为你基于数据指定 DOM
    应该如何变化。例如，在用户搜索页面上，当结果返回时，看起来是这样的：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In contrast, React uses a declarative style, which means you don't need to handle
    the DOM update itself. You simply declare how you want the data to be processed
    and displayed, and React will figure out a way to reach that state.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，React 使用声明式风格，这意味着你不需要自己处理 DOM 更新。你只需声明你希望如何处理和显示数据，React 将找到一种方法来实现那种状态。
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The declarative style encourages you to write deterministic UI components, whose
    job is simply to faithfully reflect the state. When done this way, the UI will
    always render in the same way when given the same state object. This makes the
    job of the developer much easier, as all he/she needs to do is to ensure the state
    has the correct values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式风格鼓励你编写确定性的 UI 组件，其工作只是忠实地反映状态。以这种方式完成时，当给定相同的状态对象时，UI 总是以相同的方式渲染。这使得开发者的工作变得容易得多，因为他/她只需要确保状态具有正确的值。
- en: For instance, in the example above, all the developer needs to do is to ensure
    the `state.users` array contains the latest list of users, and update it when
    necessary. He/she never have to manually manipulate the DOM.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上面的例子中，开发者需要做的只是确保 `state.users` 数组包含最新的用户列表，并在必要时更新它。他/她永远不需要手动操作 DOM。
- en: React summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 概述
- en: 'We have just covered everything we need to know to get started with React.
    Here''s a short summary:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了开始使用 React 所需了解的所有内容。以下是一个简短的总结：
- en: React is a front-end framework that takes in data and outputs a user interface
    (UI)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 是一个前端框架，它接收数据并输出用户界面（UI）
- en: A React application consists of components being rendered inside one another
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 React 应用程序由相互渲染的组件组成
- en: These React components correspond to real DOM nodes
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些 React 组件对应于真实的 DOM 节点
- en: React is performant because it minimizes DOM manipulation by using the Virtual
    DOM
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 性能良好，因为它通过使用虚拟 DOM 来最小化 DOM 操作
- en: React is declarative; we do not need to handle DOM manipulation ourselves
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 是声明式的；我们不需要自己处理 DOM 操作
- en: Next, we will start building our Register screen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始构建我们的注册屏幕。
- en: Starting a new repository
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始一个新的仓库
- en: Our back-end code is encapsulated and exposed only through the API. Therefore,
    our front-end web application must interact with our back-end code through this
    API. Because our back-end and front-end are well-decoupled, it makes sense for
    us to create a new repository for our front-end application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端代码被封装，并且只通过 API 暴露。因此，我们的前端 Web 应用程序必须通过这个 API 与我们的后端代码交互。由于我们的后端和前端耦合良好，为我们的前端应用程序创建一个新的仓库是有意义的。
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You may want to use ESLint to help keep your code tidy. You can use the same `eslint
    --init` wizard as before to generate the `.eslintrc` file. However, this time,
    when it asks you `Do you use React?`, pick `Yes` instead of `No`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想使用 ESLint 来帮助保持你的代码整洁。你可以使用之前相同的 `eslint --init` 向导来生成 `.eslintrc` 文件。然而，这次，当它问你
    `Do you use React?` 时，选择 `Yes` 而不是 `No`。
- en: Adding some boilerplate
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些模板代码
- en: We're now ready to get started! Inside our new project directory, create a new `index.html` file.
    Inside it, add in the following boilerplate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好开始！在我们的新项目目录中，创建一个新的 `index.html` 文件。在它里面，添加以下模板代码。
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will be using two libraries: `react` and `react-dom`. `react` is the base
    package that allows you to define components; the `react-dom` package allows you
    to translate React components in the Virtual DOM to DOM elements, and mount those
    DOM nodes into the DOM itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个库：`react` 和 `react-dom`。`react` 是一个基础包，允许你定义组件；`react-dom` 包允许你将 React
    组件在虚拟 DOM 中转换为 DOM 元素，并将这些 DOM 节点挂载到 DOM 本身。
- en: The reason they are separated into two packages is because React is not only
    used for web applications, it can also be used in Native applications with React
    Native, or inside `<canvas>` elements with React Canvas. React simply provides
    a framework to create reusable components, and is oblivious to how those components
    are used and rendered.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们分成两个包的原因是 React 不仅用于 Web 应用程序，它还可以用于 React Native 的原生应用程序，或者使用 React Canvas
    在 `<canvas>` 元素中使用。React 简单地提供了一个创建可重用组件的框架，并且对那些组件的使用和渲染方式一无所知。
- en: So, let's add those two libraries inside our `index.html`'s `<head>` tag.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在 `index.html` 的 `<head>` 标签内添加这两个库。
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This exposes `React` and `ReactDOM` as global variables, which we can use further
    down the page.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `React` 和 `ReactDOM` 作为全局变量暴露出来，我们可以在页面下方进一步使用。
- en: Open your HTML file on the browser, and open up the developer tools. In the
    console, start typing in the word `React`. You'll see that both `React` and `ReactDOM` are
    available.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开你的 HTML 文件，并打开开发者工具。在控制台中，开始输入单词 `React`。你会看到 `React` 和 `ReactDOM` 都是可用的。
- en: '![](img/b5b15d6d-337a-482a-b33e-31005bf713e6.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5b15d6d-337a-482a-b33e-31005bf713e6.png)'
- en: Creating our first component
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个组件
- en: 'Now that we have everything set up, let''s create our first component! For
    our Register form, we need to have a form element, inside of which are two input
    fields, one Register button, and an area to display errors. In React, we can create
    a new React element using the `createElement()` method, which takes three arguments:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一切，让我们创建我们的第一个组件！对于我们的注册表单，我们需要有一个表单元素，其中包含两个输入字段，一个注册按钮，以及一个显示错误信息的区域。在
    React 中，我们可以使用 `createElement()` 方法创建一个新的 React 元素，该方法接受三个参数：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `type` can be an HTML tag name (for example, `div`, `span`, `form`), a React
    component class, or a React fragment type (more on the latter two later).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 可以是一个 HTML 标签名（例如，`div`、`span`、`form`），一个 React 组件类，或者一个 React 片段类型（稍后详细介绍后两种）。'
- en: '`props` are properties that we can pass into a React element and may alter
    it in some ways. This is similar to how you can specify attributes on an HTML
    element. In fact, if the element being created is a native HTML element, these
    props are used as tag attributes. `props` should be specified as an object.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`props` 是我们可以传递给 React 元素的属性，并且可能会以某种方式改变它。这类似于你可以在 HTML 元素上指定属性的方式。实际上，如果正在创建的元素是一个原生
    HTML 元素，这些 `props` 就被用作标签属性。`props` 应该指定为一个对象。'
- en: '`children` is a list of React elements that nest within this component. In
    our case, we would create a form element, and nest our `input` and `button` elements
    inside the form.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`children`是嵌套在这个组件内部的React元素列表。在我们的例子中，我们会创建一个表单元素，并将我们的`input`和`button`元素嵌套在表单内部。'
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note how we passed in `{ type: ''email'' }` as the `props` for `emailInput`;
    this will be rendered on the DOM as `<input type="email">`. We also passed in
    the string `''Register''` into the `registerButton` element; this will cause the
    text to be rendered inside the `button` element, like `<button>Register</button>`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '注意我们是如何将`{ type: ''email'' }`作为`props`传递给`emailInput`的；这将在DOM上渲染为`<input type="email">`。我们还向`registerButton`元素传递了字符串`''Register''`；这将导致文本在`button`元素内部渲染，就像`<button>Register</button>`。'
- en: 'To display the `registerForm` element onto the page, we need to use the `ReactDOM.render()` method,
    which takes two arguments:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`registerForm`元素显示在页面上，我们需要使用`ReactDOM.render()`方法，它接受两个参数：
- en: The component to render
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要渲染的组件
- en: The DOM element to render it into
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其渲染到DOM元素中的DOM元素
- en: Therefore, we should create a new HTML element inside our body and use `ReactDOM.render` to
    render our React component into it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该在body内部创建一个新的HTML元素，并使用`ReactDOM.render`将我们的React组件渲染到其中。
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you open `index.html` in the browser, you'll see the input boxes and button
    displayed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`index.html`在浏览器中打开，你会看到输入框和按钮被显示出来。
- en: '![](img/594f88e9-ce2e-4b1d-a12d-9991cad0cde3.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/594f88e9-ce2e-4b1d-a12d-9991cad0cde3.png)'
- en: And upon a closer inspection of the HTML output, you'll see the props turning
    into HTML tag attributes, and that the children passed into `createElement()` are
    nested inside.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在更仔细地检查HTML输出后，你会发现props变成了HTML标签属性，并且传递给`createElement()`的子元素嵌套在其中。
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And because we have specified a `type` of `email`, most browsers will automatically
    validate the field for us.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了`type`为`email`，大多数浏览器会自动为我们验证字段。
- en: '![](img/265f6b6d-ec5d-4549-b72b-b716f9412a73.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/265f6b6d-ec5d-4549-b72b-b716f9412a73.png)'
- en: JSX
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX
- en: 'We have successfully rendered something on to the screen, but that was already
    a lot of code for such as simple form. And it is not going to get any better.
    To make it clear the role of each input element, we should attach a label to each
    one. If we add this label on top of the input, the code will look even more bloated:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在屏幕上成功渲染了一些内容，但对于如此简单的表单来说，这已经足够多了。而且它不会变得更好。为了使每个输入元素的作用更加清晰，我们应该给每个元素附加一个标签。如果我们在这个输入的上方添加这个标签，代码看起来会更加臃肿：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A typical web application has thousands of moving parts. Using `createElement` thousands
    of times can make the code unreadable, so let's try an alternative: *JSX*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Web应用有成千上万的动态部分。使用`createElement`成千上万次可以使代码难以阅读，所以让我们尝试一个替代方案：*JSX*。
- en: 'JSX, or **JavaScript XML**, is a syntax that allows you to create React elements
    and components in XML format. For example, our `registrationForm` element would
    look like this in JSX:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: JSX，或**JavaScript XML**，是一种语法，允许你以XML格式创建React元素和组件。例如，我们的`registrationForm`元素在JSX中看起来会是这样：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The structure of our element is now immediately more clear. But you might be
    thinking, "But that''s just HTML!", and you are not wrong. JSX is designed to
    look and work just like HTML. So let''s try to replace the `registrationForm` element
    with the new JSX syntax and see what happens:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们元素的现在结构立即变得更加清晰。但你可能会想，“但这只是HTML！”你是对的。JSX被设计成看起来和HTML一样，工作方式也类似。所以让我们尝试用新的JSX语法替换`registrationForm`元素，看看会发生什么：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we open `index.html` on the browser, it will now throw an error message
    on the console which reads:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中打开`index.html`时，现在会在控制台抛出一个错误信息，显示：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's because JSX is not valid JavaScript.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为JSX不是有效的JavaScript。
- en: Transpiling JSX
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转译JSX
- en: If you've ever used **CoffeeScript**, JSX is similar to that. You can't run
    CoffeeScript in the browser; you must first transpile it to JavaScript. Or if
    you've used a CSS preprocessor, such as Sass, JSX is also similar. Sass features
    such as `@include` or `@extend` are not valid CSS, and you must use a preprocessor
    to transform Sass to CSS. The same is true for JSX;  we must use a transpiler/preprocessor
    to transform it into plain JavaScript.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过**CoffeeScript**，JSX与它类似。你无法在浏览器中运行CoffeeScript；你必须首先将其转换为JavaScript。或者如果你使用过CSS预处理器，例如Sass，JSX也与之类似。Sass中的`@include`或`@extend`等特性在CSS中是无效的，你必须使用预处理器将Sass转换为CSS。对于JSX也是如此；我们必须使用转译器/预处理器将其转换为纯JavaScript。
- en: For JSX, the most popular transpiler is the **Babel** transpiler, which we have
    already used when developing our API. In a way, you can think of JSX in the same
    way as newer ECMAScript syntax. Some ECMAScript features are not supported in
    the browser, and therefore we must transpile it down into JavaScript that the
    browser can understand. JSX is not supported in the browser, and therefore, we
    must transpile it down to JavaScript that is supported by the browser.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JSX，最流行的转换器是 **Babel** 转换器，我们在开发 API 时已经使用过它。从某种意义上说，你可以将 JSX 视为新 ECMAScript
    语法。一些 ECMAScript 功能在浏览器中不受支持，因此我们必须将其转换为浏览器可以理解的 JavaScript。JSX 在浏览器中不受支持，因此我们必须将其转换为浏览器支持的
    JavaScript。
- en: 'To see how Babel transforms JSX into JavaScript, we can use the Babel REPL,
    available at [babeljs.io/repl/](https://babeljs.io/repl/). Open it up, and paste
    in everything inside our `<script>` tag. You should see the transpiled JavaScript
    on the right:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Babel 如何将 JSX 转换为 JavaScript，我们可以使用 Babel REPL，它可在 [babeljs.io/repl/](https://babeljs.io/repl/)
    找到。打开它，并将 `<script>` 标签内的所有内容粘贴进去。你应该在右侧看到转换后的 JavaScript：
- en: '![](img/45ef51a1-b4eb-4f9b-9a9b-21d5f467949a.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45ef51a1-b4eb-4f9b-9a9b-21d5f467949a.png)'
- en: 'On the server, we used Babel to precompile our code from the `src/` directory
    to the `dist/` directory. On the client, we can transpile JSX directly inside
    the browser itself. To do that, we need to include the Babel Standalone Library
    as a script inside the `<head>` tag:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，我们使用 Babel 将 `src/` 目录中的代码预编译到 `dist/` 目录。在客户端，我们可以在浏览器本身内部直接转换 JSX。为此，我们需要在
    `<head>` 标签内包含 Babel Standalone Library 作为脚本：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We also need to change our `<script>` tag to include the attribute `type="text/babel"`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将 `<script>` 标签更改为包含属性 `type="text/babel"`。
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `type="text/babel"` attribute tells our browser to not treat what's inside
    as JavaScript, but as plain text. This means our JSX would no longer throw an
    error. The Babel Standalone Library we included in the `<head>` element would
    then search for any script tags with the type `text/babel` and transpile it to
    JavaScript, and then execute the transpiled JavaScript.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`type="text/babel"` 属性告诉我们的浏览器不要将内部内容视为 JavaScript，而是作为纯文本。这意味着我们的 JSX 将不再抛出错误。然后，我们包含在
    `<head>` 元素中的 Babel Standalone Library 将搜索任何具有类型 `text/babel` 的脚本标签，并将其转换为 JavaScript，然后执行转换后的
    JavaScript。'
- en: Open up your browser, and you should see the same thing as we had before, but
    now we are writing in JSX!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的浏览器，你应该看到我们之前看到的东西，但现在我们正在用 JSX 编写！
- en: Defining React components
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 React 组件
- en: Although we have made our React code much clearer by using JSX, it's still not
    as clean and DRY as it could be. For instance, we are defining the same input
    element twice, even though they have the same structure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通过使用 JSX 使我们的 React 代码变得更加清晰，但它仍然不如它本可以的那样干净和 DRY。例如，我们定义了相同的输入元素两次，尽管它们具有相同的结构。
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is not ideal because of the following factors:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不理想的，以下是一些因素：
- en: It can lead to inconsistency. To achieve a consistent user experience, we should
    apply a consistent style and layout for all components, including these input
    boxes. Defining input boxes without a standard template will make it difficult
    to do this.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能会导致不一致。为了实现一致的用户体验，我们应该为所有组件应用一致的风格和布局，包括这些输入框。如果没有标准模板定义输入框将使这一过程变得困难。
- en: It is difficult to update. If the designs change and we need to update all the
    input boxes to fit this new design, it'll be difficult to find all occurrences
    of the input box and update its style. Humans are error-prone and we might miss
    one or two.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新困难。如果设计发生变化，我们需要更新所有输入框以适应新的设计，这将很难找到所有输入框的实例并更新其样式。人类容易出错，我们可能会错过一个或两个。
- en: We should ensure our React code is DRY; therefore, we should define an independent
    component that we can reuse wherever an input field is needed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该确保我们的 React 代码是 DRY 的；因此，我们应该定义一个独立的组件，我们可以在需要输入字段的地方重复使用它。
- en: Functional and class components
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式和类组件
- en: 'A React component takes in **props** (input data) and returns a React element(s).
    In React, you can define a component in two ways:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件接收**props**（输入数据）并返回 React 元素（s）。在 React 中，你可以通过两种方式定义一个组件：
- en: '**Functional components**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式组件**'
- en: '**Class components**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类组件**'
- en: For instance, we can define an `Input` React component using the functional
    component syntax.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用函数式组件语法定义一个 `Input` React 组件。
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The curly braces (`{}`) are JSX syntax. Whatever is between the braces are evaluated
    as JavaScript, and the value substituted in place.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号 (`{}`) 是 JSX 语法。大括号之间的一切都被评估为 JavaScript，并替换在原位。
- en: Alternatively, we can define the same `Input` component using the class syntax,
    which uses ES6 classes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用类语法定义相同的`Input`组件，它使用ES6类。
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Both are functionally equivalent, and can be used like this to create the `RegistrationForm` component:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在功能上是等价的，可以像这样用来创建`RegistrationForm`组件：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are passing in the `label` and `type` props into the `Input` component,
    which we then used in the component's `render` method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`label`和`type`属性传递给`Input`组件，然后我们在组件的`render`方法中使用它们。
- en: So which syntax should you use to define React components? Functional components
    are simpler to understand; after all, they are just JavaScript functions. Class
    components have a more complex syntax, but supports more features, such as holding
    a state, and can make use of different life-cycle methods, which we will cover
    soon. Therefore, if your component does not need these additional features, then
    you should prefer the functional syntax over the class syntax.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 那你应该使用哪种语法来定义React组件？函数组件更容易理解；毕竟，它们只是JavaScript函数。类组件有更复杂的语法，但支持更多功能，例如保持状态，并且可以利用不同的生命周期方法，我们很快就会介绍。因此，如果你的组件不需要这些附加功能，那么你应该优先选择函数语法而不是类语法。
- en: Pure components
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯组件
- en: 'Regardless of the syntax, all React components must be *pure*. A pure component
    is one where:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不论语法如何，所有React组件都必须是**纯的**。纯组件是这样的：
- en: The return value (the React element) is **deterministic**, based only on the
    component's input (props).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值（React元素）是**确定的**，仅基于组件的输入（属性）。
- en: The component does not produce **side-effects**. For example, a pure component
    should not mutate the props.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件不产生**副作用**。例如，纯组件不应该修改属性。
- en: Pure functions and functional components are good because they are easier to
    understand and test. Therefore, when we have a large or heavily-nested component
    like our `Form` element, it's good practice to break it down into smaller pure
    functional components, and use these components to compose the element.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数和函数组件很好，因为它们更容易理解和测试。因此，当我们有一个大型的或深度嵌套的组件，如我们的`Form`元素时，将它们分解成更小的纯函数组件，并使用这些组件来组合元素是良好的实践。
- en: 'Try turning our button into its own (simple) component. The end result should
    look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将我们的按钮转换为其自己的（简单）组件。最终结果应该看起来像这样：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Maintaining the state and listening for events
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护状态并监听事件
- en: Let's work on the `Input` component a little more. When a user types inside
    the input box, it'd be great for user experience to validate the user's input
    and display an indicator next to it. The indicator can be colored green if the
    input is valid, or red if not.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地处理`Input`组件。当用户在输入框中键入时，验证用户输入并在其旁边显示指示器将大大提升用户体验。如果输入有效，指示器可以是绿色的，如果无效，则可以是红色的。
- en: 'Therefore, our `Input` component needs to:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`Input`组件需要：
- en: Listen and handle events, so that it can validate the input when the value changes.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听和处理事件，以便在值变化时验证输入。
- en: Maintain the state, so the component can persist the result of the validation.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护状态，以便组件可以持久化验证的结果。
- en: 'Currently, our `Input` component is defined in the functional components style.
    This is preferred but it is limited in features; it cannot hold the state. Therefore,
    let''s first convert the `Input` component into a class component:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`Input`组件是以函数组件风格定义的。这是首选的，但它功能有限；它不能保持状态。因此，让我们首先将`Input`组件转换为类组件：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we can give each instance of the `Input` component a state. A state in
    React is simply a key-value store (that is, an object) that is internal (private)
    to the instance. For us, we will use the state to hold information about whether
    the input is valid.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以给`Input`组件的每个实例提供一个状态。在React中，状态简单地说是一个键值存储（即对象），它是实例内部的（私有的）。对我们来说，我们将使用状态来保存有关输入是否有效的信息。
- en: We can define an initial state of the component inside the component class' `constructor` method,
    which is a special method that is called when the class is instantiated with the `new` keyword.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在组件类的`constructor`方法中定义组件的初始状态，这是一个特殊的方法，当使用`new`关键字实例化类时会被调用。
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are setting the state property `valid` to `null`, because before the user
    has entered anything, we don't want to say that it is valid or invalid.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将状态属性`valid`设置为`null`，因为在用户输入任何内容之前，我们不想说它是有效的或无效的。
- en: Next, we need to add event listeners to the `input` HTML element. Event listeners
    in JSX are similar to the HTML ones, except that they are `camelCase` instead
    of lowercase. For instance, an `onchange` listener in HTML would be `onChange`.
    The value of the event handler prop should be an event handler function. Update
    the `input` element inside the label tag to include the `onChange` prop.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向 `input` HTML 元素添加事件监听器。JSX 中的事件监听器与 HTML 中的类似，只是它们是 `camelCase` 而不是小写。例如，HTML
    中的 `onchange` 监听器将是 `onChange`。事件处理器属性值应该是一个事件处理器函数。更新标签内的 `input` 元素以包含 `onChange`
    属性。
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, whenever the value of the input changes, `this.validate` is invoked, passing
    in the event object as its only argument. Since this method doesn't exist yet,
    we must now define it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当输入值发生变化时，`this.validate` 会被调用，并将事件对象作为其唯一的参数传递。由于此方法尚不存在，我们必须现在定义它。
- en: Handling events
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件
- en: 'Inside a class method, `this` refers to the React element (which is an instance
    of this `Input` React component type). Therefore, we can define a method called `validate` that
    will validate the user input and update the state:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在类方法内部，`this` 指的是 React 元素（它是 `Input` React 组件类型的实例）。因此，我们可以定义一个名为 `validate`
    的方法，该方法将验证用户输入并更新状态：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `validate` method gets the value of the input box from `event.target.value`,
    and then uses an external `validator` object to actually validate the value. The `validator` method
    would return `true` if the value is valid, or `false` if it is not.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate` 方法从 `event.target.value` 获取输入框的值，然后使用一个外部的 `validator` 对象来实际验证该值。如果值有效，`validator`
    方法将返回 `true`，如果无效，则返回 `false`。'
- en: Lastly, the `validate` method updates the state using the `setState` method,
    which is available for all class components.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`validate` 方法使用 `setState` 方法更新状态，该方法对所有类组件都是可用的。
- en: setState and immutability
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`setState` 和不可变性'
- en: 'You should use `setState` to update the state instead of simply modifying the
    existing state:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用 `setState` 来更新状态，而不是简单地修改现有的状态：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The end result is the same: `this.state` is changed to its new value. However,
    if we directly update the `this.state` object, then React must poll the value
    of `this.state` regularly to be notified of any changes. This is slow and inefficient,
    and not how React is implemented. Instead, by changing the state via the `this.setState` method,
    it will 'reactively' informs React that the state has changed, and React may opt
    to trigger a re-render of the view.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是相同的：`this.state` 被更改为新值。然而，如果我们直接更新 `this.state` 对象，那么 React 必须定期轮询 `this.state`
    的值以通知任何更改。这是缓慢且低效的，并且不是 React 的实现方式。相反，通过 `this.setState` 方法更改状态，它将“反应性地”通知 React
    状态已更改，React 可能会选择触发视图的重新渲染。
- en: Rendering the state
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染状态
- en: Lastly, in our `render` method, let's add an indicator component. We will read
    from the state of the component to determine the color of our indicator.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的 `render` 方法中，让我们添加一个指示组件。我们将从组件的状态中读取以确定指示器的颜色。
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, open `index.html` on your browser, and try out the input boxes. If you
    enter an invalid email, or your password is too short/long, the indicator will
    show red.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的浏览器中打开 `index.html`，并尝试输入框。如果你输入了一个无效的电子邮件，或者你的密码太短/太长，指示器将显示红色。
- en: '![](img/39555ef1-ff61-4e9c-ba7e-579c5fa9c422.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39555ef1-ff61-4e9c-ba7e-579c5fa9c422.png)'
- en: It is not very pretty, but "function over form" - let's care about the looks
    once we have the functionality in place.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来并不漂亮，但“功能优先于形式”——一旦我们有了功能，我们再关心外观。
- en: Submitting forms
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交表单
- en: Now that we have our form ready, let's take the next logical step and figure
    out how to submit the data to our API.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了表单，让我们采取下一个逻辑步骤，找出如何将数据提交到我们的 API。
- en: 'The first thing we need to do is to add an `onSubmit` event handler to the
    form. The handler is specific to the registration form, and thus should be associated
    with `RegistrationForm`. The most obvious place to define it is as a class method.
    Update `RegistrationForm` to the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为表单添加一个 `onSubmit` 事件处理器。处理器是针对注册表单的，因此应该与 `RegistrationForm` 关联。定义它的最明显的地方是作为一个类方法。将
    `RegistrationForm` 更新如下：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`this.handleRegistration` is triggered whenever the form is submitted (for
    example, when a user presses the Register button) and the event is passed in as
    its only parameter.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.handleRegistration` 在表单提交时被触发（例如，当用户按下注册按钮）并将事件作为其唯一的参数传递。'
- en: The default behavior for the form is to send an HTTP request to the URL specified
    in the `action` attribute of the form. Here, we are not specifying an `action` attribute
    because we want to handle the form differently. Thus, we are calling `event.preventDefault()` to
    stop the form from sending the request. We are also calling `event.stopPropagation()` to
    stop this event from **capturing** or **bubbling**; in other words, it prevents
    other event handlers from handling it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的默认行为是向表单 `action` 属性中指定的 URL 发送 HTTP 请求。在这里，我们没有指定 `action` 属性，因为我们想以不同的方式处理表单。因此，我们调用
    `event.preventDefault()` 来阻止表单发送请求。我们还调用 `event.stopPropagation()` 来阻止此事件被 **捕获**
    或 **冒泡**；换句话说，它阻止其他事件处理器处理它。
- en: Next, we need to figure out how to obtain the value of each input box, compose
    the request, and then send it to our API.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找出如何获取每个输入框的值，组合请求，然后将其发送到我们的 API。
- en: Uncontrolled form elements
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态表单元素
- en: Previously, we said that the state of each component is internal (private) to
    the component. However, there are no private class methods in JavaScript. Our
    only equivalent is the closure; therefore, our state isn't truly private. If we
    can obtain a reference to the React element, we can also get its state.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们说每个组件的状态是组件内部的（私有的）。然而，JavaScript 中没有私有类方法。我们唯一的等效方法是闭包；因此，我们的状态并不是真正私有的。如果我们能获取到
    React 元素的引用，我们也可以获取到其状态。
- en: React supports a feature called **ref**. We can create refs using the `React.createRef()` method,
    and then attach that ref to any child DOM element or React element. We can then
    refer to that element using the ref.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: React 支持一个名为 **ref** 的功能。我们可以使用 `React.createRef()` 方法创建 ref，然后将该 ref 附接到任何子
    DOM 元素或 React 元素上。然后我们可以通过 ref 来引用该元素。
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, in the constructor of `RegistrationForm`, we created
    two refs, which we've assigned to `this.email` and `this.password`. We then attached
    these two refs to the two `Input` elements using the `ref` prop.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在 `RegistrationForm` 的构造函数中，我们创建了两个 ref，分别赋值给 `this.email` 和 `this.password`。然后我们使用
    `ref` 属性将这两个 ref 附接到两个 `Input` 元素上。
- en: The `ref` prop is a special prop that is not passed down to the child element.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref` 属性是一个特殊的属性，它不会传递给子元素。'
- en: We can now obtain a reference to the email `Input` element using `this.email.current`.
    And we can obtain its `state` property using `this.email.current.state`. Try opening
    up the browser, type in some values in the input box and click Register; you should
    see each input box's current state in the console.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `this.email.current` 获取到电子邮件 `Input` 元素的引用。并且我们可以使用 `this.email.current.state`
    获取其 `state` 属性。尝试打开浏览器，在输入框中输入一些值并点击注册；你应该能在控制台中看到每个输入框的当前状态。
- en: Next, let's update the `handleRegistration` method to first check the state
    object, to see whether the values are valid; if they are, extract and assign them
    to a variable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新 `handleRegistration` 方法，首先检查状态对象，看看值是否有效；如果是，提取并将它们分配给一个变量。
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we need to hash the password, compose the request, and send it to our
    API server. Let's define a `register` function, which will provide a layer of
    abstract and allow our `handleRegistration` method to remain easy to read.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对密码进行散列，组合请求，并将其发送到我们的 API 服务器。让我们定义一个 `register` 函数，它将提供一个抽象层，并使我们的
    `handleRegistration` 方法保持易于阅读。
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These two functions use the **Fetch API** to send the request to our API server
    (assuming to be running on `http://localhost:8080/`).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数使用 **Fetch API** 向我们的 API 服务器发送请求（假设运行在 `http://localhost:8080/`）。
- en: Next, we need to call the `register` functions we defined earlier to actually
    authenticate the user.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调用我们之前定义的 `register` 函数来实际验证用户。
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Lastly, we are using `bcrypt.hashSync` to hash the password; therefore, we need
    to load the `bcryptjs` library, which we can get from the RawGit CDN via the following
    URL: [https://rawgit.com/dcodeIO/bcrypt.js/master/dist/bcrypt.min.js](https://rawgit.com/dcodeIO/bcrypt.js/master/dist/bcrypt.min.js).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `bcrypt.hashSync` 来对密码进行散列；因此，我们需要加载 `bcryptjs` 库，我们可以通过以下网址从 RawGit
    CDN 获取：[https://rawgit.com/dcodeIO/bcrypt.js/master/dist/bcrypt.min.js](https://rawgit.com/dcodeIO/bcrypt.js/master/dist/bcrypt.min.js)。
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Resolving CORS issues
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决 CORS 问题
- en: Now, if we reload the page, fill in our details, and press the Register button,
    we'll encounter a CORS-related error. This is because our API server is currently
    only servicing requests from our Swagger documentation page (on `http://localhost:8100`);
    requests from other websites are rejected.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新加载页面，填写我们的详细信息，并按下`Register`按钮，我们将遇到一个与CORS相关的错误。这是因为我们的API服务器目前仅服务于我们的Swagger文档页面（在`http://localhost:8100`上）；来自其他网站的请求被拒绝。
- en: To resolve this, we need to provide the Hobnob API with information about the
    location of our client. We can do this by adding a few more environment variables.
    Add the following entries to the `envs/.env` and `envs/.env.example` files in
    our Hobnob API repository.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要向Hobnob API提供有关我们客户端位置的信息。我们可以通过添加一些额外的环境变量来实现这一点。将以下条目添加到我们的Hobnob
    API存储库中的`envs/.env`和`envs/.env.example`文件中。
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we need to add the client''s origin to the list of origins our API should
    allow. We can do this by updating the CORS middleware to set the `Access-Control-Allow-Origin` header
    dynamically. Make the following change inside `src/index.js` of our Hobnob API
    repository:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将客户端的源添加到API应允许的源列表中。我们可以通过更新CORS中间件来动态设置`Access-Control-Allow-Origin`头来实现这一点。在我们的Hobnob
    API存储库的`src/index.js`内部进行以下更改：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Lastly, coming back to our client application, we need to ensure that the client
    is serving at the port we specified, and also that CORS is enabled. We can do
    this simply by using the `-p` and `--cors` flag provided by the `http-server` package.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回到我们的客户端应用程序，我们需要确保客户端正在指定的端口上提供服务，并且CORS已启用。我们可以通过使用`http-server`包提供的`-p`和`--cors`标志来实现这一点。
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, if we reload both our API server and our client, and try to register, we
    should get back a success response.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新加载我们的API服务器和客户端，并尝试注册，我们应该得到一个成功响应。
- en: Disabling the Button component
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用按钮组件
- en: To make the user experience more intuitive, let's disable the Register button
    until both the email and password fields are valid. To do that, we need to provide
    a way for the `RegistrationForm` component to not just read the values of the `Input` components
    when the form is submitted, but after each time the value has changed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用户体验更加直观，让我们在电子邮件和密码字段都有效之前禁用`Register`按钮。要做到这一点，我们需要为`RegistrationForm`组件提供一个方法，使其不仅能在表单提交时读取`Input`组件的值，还能在每次值改变后读取。
- en: A naive approach would be to poll the `valid` state of each component every
    100 ms or so, but that will not be performant. Instead, we can pass a function
    (via the `onChange` prop) into the `Input` component that will get called whenever
    the value of the `Input` changes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法是每100毫秒左右轮询每个组件的`valid`状态，但这将不会高效。相反，我们可以通过`onChange`属性传递一个函数到`Input`组件，该函数将在`Input`的值改变时被调用。
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And then inside the `validate` method of our `Input` component, we would call `this.props.onChange`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '然后在我们的`Input`组件的`validate`方法内部，我们会调用`this.props.onChange`:'
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `setState` method accepts a callback as its second parameter, which only
    gets called after the state has been updated. This ensures that when the parent
    component (`RegistrationForm`) checks the `Input` elements' states, it will be
    the updated state.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`setState`方法接受一个回调作为其第二个参数，该回调仅在状态更新后调用。这确保了当父组件（`RegistrationForm`）检查`Input`元素的当前状态时，它将得到更新后的状态。'
- en: Now, we need to define the `handleInputChange` method in `RegistrationForm`.
    It should check whether both inputs are valid, and store the result in the state
    of `RegistrationForm`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`RegistrationForm`中定义`handleInputChange`方法。它应该检查两个输入是否有效，并将结果存储在`RegistrationForm`的状态中。
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, we need to modify our `Button` component to accept a `disabled` prop,
    which should disable the button when `true`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改我们的`Button`组件以接受一个`disabled`属性，当`true`时应该禁用按钮。
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, refresh the page and play around with the inputs. The Register button should
    now be disabled until both inputs are valid (that is, both indicators are green).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新页面并尝试输入。现在，`Register`按钮应该被禁用，直到两个输入都有效（即，两个指示器都是绿色的）。
- en: Controlled form elements
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制表单元素
- en: 'You now have some experience working with props, state and refs. However, there
    are several major flaws with our current implementation:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一些使用属性、状态和引用的经验。然而，我们当前实现中存在几个主要缺陷：
- en: We are holding states in multiple places. This is hard to manage because we
    have to remember where each state is stored.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在多个地方保存状态。这很难管理，因为我们必须记住每个状态存储在哪里。
- en: We are duplicating the same states in multiple places. We are holding the `valid` state
    in both the `RegistrationForm` element as well as the `Input` elements. The `RegistrationForm`'s `valid` state
    can be derived from the states of the `Input` elements.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在多个地方重复相同的州。我们在`RegistrationForm`元素以及`Input`元素中都持有`valid`状态。`RegistrationForm`的`valid`状态可以从`Input`元素的状态中推导出来。
- en: To prevent both of these flaws, we should **lift the state** store to the closest
    common ancestor of the components that need it; for us, this will be the `RegistrationForm` component.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这两个缺陷，我们应该将需要的状态存储提升到需要它的组件最近的共同祖先；对我们来说，这将是由`RegistrationForm`组件。
- en: Here's how it would work. First, we turn the `Input` components back into stateless,
    dumb component, whose output depends solely on the props passed in. We are going
    to be passing down one new prop, `name`, which is a name that is used to identify
    the input. It is similar to the `name` attribute on a normal `input` HTML element.
    We will also change the signature of our `RegistrationForm.handleInputChange()` method
    to accept the `name` of the input as its first parameter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作方式。首先，我们将`Input`组件转换回无状态的、哑组件，其输出完全取决于传入的属性。我们将传递一个新的属性，`name`，这是一个用于识别输入的名称。它类似于正常`input`HTML元素的`name`属性。我们还将更改`RegistrationForm.handleInputChange()`方法的签名，以接受输入的`name`作为其第一个参数。
- en: '[PRE40]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our `Input` components are no longer holding any state, nor carrying out any
    validation. Instead, these tasks have been delegated to the component''s closest
    common ancestor, which is the `RegistrationForm`. So, inside RegistrationForm,
    we can:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Input`组件不再保留任何状态，也不再执行任何验证。相反，这些任务已经委托给了组件最近的共同祖先，即`RegistrationForm`组件。因此，在`RegistrationForm`内部，我们可以：
- en: Remove any references to these Input components - because they no longer hold
    any state, we have no reasons to hold on to these references
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除对这些Input组件的任何引用——因为它们不再持有任何状态，我们没有理由保留这些引用
- en: Update `this.state` to hold the values and validity information for the `Input` components.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`this.state`以保存`Input`组件的值和有效性信息。
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, update our JSX components to pass down states like `value` and `valid` to
    the `Input` components. We are also passing down a `name` prop that helps identify
    the element:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新我们的JSX组件，将`value`和`valid`等状态传递给`Input`组件。我们还传递了一个`name`属性，这有助于识别元素：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, we will completely rewrite our `handleInputChange` method of `RegistrationForm` to
    validate the input and store both the value and its validity into the state. It
    will use the `name` and `event` parameters passed by the `onChange` event handler
    of `Input`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将完全重写`RegistrationForm`的`handleInputChange`方法，以验证输入并将值及其有效性存储到状态中。它将使用`Input`组件的`onChange`事件处理程序传递的`name`和`event`参数。
- en: '[PRE43]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Lastly, we no longer need to use refs to get the values of the `Input` components
    and validate them, since they are already in the state. So, remove those lines
    from our `handleRegistration` method:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不再需要使用refs来获取`Input`组件的值并验证它们，因为它们已经在状态中。因此，从我们的`handleRegistration`方法中删除这些行：
- en: '[PRE44]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, refresh the page and everything should work as it did before.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新页面，一切应该都会像之前一样正常工作。
- en: In this section, we have lifted the state of our components and consolidated
    it into a single place. This makes our state easier to manage. However, the way
    we are changing the state is by passing down `onChange` props. Whilst this is
    fine for simple components like this, it gets much less performant once the components
    are heavily nested. A single change may invoke tens of functions and this is not
    sustainable. Therefore, as we continue to develop our application, we will use
    a state management tool, such as Redux or MobX.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经提升了组件的状态并将它们合并到单个位置。这使得我们的状态更容易管理。然而，我们更改状态的方式是通过传递`onChange`属性。虽然这对于像这样的简单组件来说是可以的，但一旦组件深度嵌套，性能就会大大降低。一次更改可能会调用数十个函数，这是不可持续的。因此，随着我们继续开发我们的应用程序，我们将使用状态管理工具，如Redux或MobX。
- en: Modularizing React
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化React
- en: But for now, we must solve another pressing issue - our code is not very modular.
    Everything is defined inside a single `<script>` tag. Not only is this hard to
    read, but it is also not maintainable. We can't define every component in one
    file!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们必须解决另一个紧迫的问题——我们的代码并不非常模块化。所有内容都定义在一个单独的`<script>`标签内。这不仅难以阅读，而且也不易于维护。我们无法在一个文件中定义所有组件！
- en: Furthermore, we are including libraries using `<script>` tags. Because some
    libraries depend on others (for example, `react-dom` depends on `react`), we must
    manually ensure our scripts are loaded in the right order.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们正在使用`<script>`标签包含库。因为一些库依赖于其他库（例如，`react-dom`依赖于`react`），我们必须手动确保我们的脚本按正确的顺序加载。
- en: 'We have already looked at CommonJS and ES6 modules when we discussed server-side
    modules. However, we must consider other factors when using modules on client-side
    code, such as:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论服务器端模块时，我们已经看到了CommonJS和ES6模块。然而，在使用客户端代码中的模块时，我们必须考虑其他因素，例如：
- en: The size of each module. Dependencies are downloaded before the application
    is run. On the server, the application is only initialized once, after which it
    will keep running for a long time (weeks to years). Therefore, the initial time
    required for downloading dependencies is a one-time cost. On the client, however,
    these dependencies need to be downloaded each time a client loads the application.
    Therefore, it is much more important to keep the file size of the application
    and its dependencies to be as low as possible.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块的大小。依赖项在应用程序运行之前下载。在服务器上，应用程序只初始化一次，之后它将长时间运行（数周到数年）。因此，下载依赖项的初始时间是一个一次性成本。然而，在客户端，每次客户端加载应用程序时都需要下载这些依赖项。因此，将应用程序及其依赖项的文件大小保持在尽可能低是非常重要的。
- en: How many separate requests are made? On the server, all dependencies reside
    on the server, and therefore importing a dependency costs virtually nothing. On
    the client, each request to the server is a new HTTP request, which requires a
    new TCP handshake. All these operations take a relatively long time, and thus
    we must ensure that as few requests are made to the server as possible.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生了多少个单独的请求？在服务器上，所有依赖项都驻留在服务器上，因此导入依赖项几乎不花费任何成本。在客户端，每次向服务器的请求都是一个新的HTTP请求，这需要一个新的TCP握手。所有这些操作都需要相对较长的时间，因此我们必须确保尽可能少地向服务器发出请求。
- en: Asynchronous. We have already looked at CommonJS modules in [Chapter 4](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml), *Setting
    Up Development Tools*. CommonJS modules are loaded synchronously, this means modules
    are loaded in the order they are required inside the file/module being run. As
    a module can have hundreds of dependencies, it means it can take a long time to
    resolve and download all dependencies. This is not a problem for server applications,
    because after the initial time requirement, the server application would run for
    a long time without interruption. On the client, if A depends on B, and B depends
    on C, C cannot be downloaded until B is downloaded, because we simply cannot know
    in advance that B depends on C.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步。我们已经在[第4章](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml)“设置开发工具”中讨论了CommonJS模块。CommonJS模块是同步加载的，这意味着模块是按照在运行中的文件/模块内被要求的顺序加载的。由于一个模块可能有数百个依赖项，这意味着解析和下载所有依赖项可能需要很长时间。这对于服务器应用程序来说不是问题，因为服务器应用程序在初始时间需求之后将长时间不间断地运行。在客户端，如果A依赖于B，而B又依赖于C，那么C必须在B下载之后才能下载，因为我们无法提前知道B依赖于C。
- en: Because of these concerns, we need to use different tools to make our client-side
    application performant on the client. So let's spend some time to review them
    now.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些担忧，我们需要使用不同的工具来确保我们的客户端应用程序在客户端的性能。因此，让我们花些时间来回顾它们。
- en: Client-side modules
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端模块
- en: When we developed our server-side code, we used packages from the [npmjs.com](https://www.npmjs.com/) registry.
    These packages were initially intended only for server-side code. Soon, front-end
    developers realized the power of all these server-side packages, and wanted to
    utilize them on the client.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发服务器端代码时，我们使用了来自[npmjs.com](https://www.npmjs.com/)注册表的包。这些包最初仅打算用于服务器端代码。很快，前端开发者意识到了所有这些服务器端包的力量，并希望在前端使用它们。
- en: This becomes an issue because CommonJS, with its synchronous loading, does not
    work well on the browser. It would take a long time to load because the modules
    that are required are not available on the client, and must be downloaded when
    the page is first accessed. So if a module has an extended dependency tree of
    over 100 modules, it'd have to download 100 modules before the page/application
    can be loaded. Since web pages are rarely kept open for a long period of time,
    the initial load would usually not be worthwhile to the end user, and they will
    abandon the site.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这成为一个问题，因为 CommonJS 的同步加载在浏览器上表现不佳。由于所需的模块在客户端不可用，必须在页面首次访问时下载，所以加载时间会很长。如果一个模块有一个超过
    100 个模块的扩展依赖树，它必须在页面/应用程序加载之前下载 100 个模块。由于网页很少长时间打开，所以初始加载通常对最终用户来说不值得，他们可能会放弃网站。
- en: 'There are two different solutions to this issue:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的解决方案来解决这个问题：
- en: Module bundling
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块打包
- en: Asynchronous module loading
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步模块加载
- en: Module bundling
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块打包
- en: Instead of the client (the browser) resolving hundreds of dependencies and downloading
    them directly from the client, we would download all dependencies on the server,
    concatenate them in the right order into a single file (or **bundle**), and send
    that to the client. The bundle contains the application and *all* dependencies,
    and can be loaded like any regular script. Because all dependencies are resolved
    ahead of time, the time required to resolve dependencies on the client are eliminated.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是客户端（浏览器）解析数百个依赖项并直接从客户端下载，我们会在服务器上下载所有依赖项，将它们按正确的顺序连接成一个单一的文件（或 **bundle**），然后发送给客户端。这个包包含了应用程序和
    **所有** 依赖项，可以像任何常规脚本一样加载。由于所有依赖项都在事先解析，因此消除了客户端解析依赖项所需的时间。
- en: But because everything is crammed into one file, the bundle may grow quite large,
    but the load time will be reduced as the client doesn't need to make hundreds
    of separate requests; now it's just one. Furthermore, if one of the external servers
    are down, it would not affect our bundled code, as this is served from our own
    server.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 但是因为所有内容都压缩到一个文件中，所以生成的包可能会变得相当大，但加载时间会减少，因为客户端不需要发出数百个单独的请求；现在只需要一个。此外，如果其中一个外部服务器宕机，它不会影响我们的打包代码，因为这是由我们自己的服务器提供的。
- en: There are four module bundlers that you'll encounter in the wild: **Browserify**, **Webpack**, **Rollup**,
    and **Parcel**.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外你会遇到四种不同的模块打包器：**Browserify**、**Webpack**、**Rollup** 和 **Parcel**。
- en: Browserify
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Browserify
- en: Browserify was the first module bundler and it changed the way frontend code
    was written. Browserify will analyze and follow the `require` calls from an entry
    point JavaScript file, build up a list of dependencies, download them, and then
    bundle everything into a single JavaScript file that can be injected using a single `<script>` tag.
    The modules are added recursively, meaning the innermost dependencies are added
    first. This ensures modules are bundled in the correct order.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify 是第一个模块打包器，它改变了前端代码的编写方式。Browserify 会从入口点 JavaScript 文件分析并跟踪 `require`
    调用，构建一个依赖项列表，下载它们，然后将所有内容打包成一个单一的 JavaScript 文件，可以通过单个 `<script>` 标签注入。模块是递归添加的，这意味着最内层的依赖项首先被添加。这确保了模块按照正确的顺序打包。
- en: To use it, you simply install the `browserify` package, and specify the entry
    point of your application as well as the location where you want the bundle to
    be placed.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，你只需安装 `browserify` 包，并指定应用程序的入口点以及你想要放置打包文件的位置。
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Webpack
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack
- en: Webpack has essentially succeeded Browserify to become the *de facto* leader.
    Whilst Browserify did only module bundling, Webpack also tries to integrate features
    from popular **task runners**, such as **Grunt** or **Gulp**. With Webpack, you
    can preprocess files (for example, minifying JavaScript and transforming Sass
    files) before/after bundling them.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 已经基本上取代了 Browserify，成为事实上的领导者。虽然 Browserify 只做模块打包，但 Webpack 还尝试整合来自流行的
    **任务运行器**（如 **Grunt** 或 **Gulp**）的功能。使用 Webpack，你可以在打包文件之前/之后预处理文件（例如，压缩 JavaScript
    和转换 Sass 文件）。
- en: 'One of the standout features of Webpack is **code splitting**. This allows
    you to split the bundle into multiple files: those that are essential to the initialization
    and function of the app, and those that can be loaded later. You can then prioritize
    the transfer of the essential code first, giving your users a faster load time,
    and a better user experience. The non-essential code can be loaded later, or only
    on-demand.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack的一个突出特点是**代码拆分**。这允许你将包拆分为多个文件：那些对应用程序的初始化和功能至关重要的文件，以及那些可以稍后加载的文件。然后你可以优先传输关键代码，为用户提供更快的加载时间，并改善用户体验。非关键代码可以稍后加载，或者仅在需要时加载。
- en: Rollup
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rollup
- en: Browserify and Webpack focus on CommonJS modules, and require a Babel plugin
    to support ES6 modules. Rollup supports native ES6 modules out of the box.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify和Webpack专注于CommonJS模块，并需要一个Babel插件来支持ES6模块。Rollup默认支持原生ES6模块。
- en: Rollup also supports **tree-shaking**, a feature that eliminates unused code
    from the bundle. Let's say you are importing a large utility library supporting
    100 functions, but are only using four of them; tree-shaking will remove the 96
    that are not required for our app. This can significantly reduce bundle size for
    applications that have a lot of dependencies.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Rollup也支持**摇树**，这是一个从包中消除未使用代码的功能。假设你正在导入一个支持100个函数的大型实用库，但你只使用了其中的四个；摇树将删除我们应用程序不需要的96个。这可以显著减少具有许多依赖的应用程序的包大小。
- en: 'Traditionally, the community consensus is to use Webpack for applications,
    and Rollup for libraries. There are two reasons for this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，社区共识是使用Webpack用于应用程序，而Rollup用于库。这有两个原因：
- en: Webpack generally produces more boilerplate and thus produces a noticeably larger
    bundle size that's unnecessary for libraries. This is especially true for earlier
    versions of Webpack, which would wrap every module inside its own function closures.
    Not only does this increase bundle size, but it also slows down performance. However,
    since Webpack 3, these modules are enclosed into one closure using a technique
    called **scope hoisting**.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack通常会产生更多的模板代码，因此产生的包大小明显更大，这对于库来说是不必要的。这对于Webpack的早期版本尤其如此，它会将每个模块包裹在其自己的函数闭包中。这不仅增加了包的大小，还降低了性能。然而，自从Webpack
    3以来，这些模块使用称为**作用域提升**（scope hoisting）的技术被封装到一个闭包中。
- en: Webpack supports code-splitting, which is useful for applications but doesn't
    really help with libraries
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack支持代码拆分，这对于应用程序很有用，但并不真正有助于库
- en: However, since their inception, Webpack has added support for tree-shaking,
    and Rollup has added support for code-splitting, and so the similarities between
    the tools are increasing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自从它们诞生以来，Webpack已经增加了对摇树（tree-shaking）的支持，而Rollup增加了对代码拆分（code-splitting）的支持，因此这些工具之间的相似性正在增加。
- en: Parcel
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Parcel
- en: Lastly, a relatively new tool called Parcel has appeared whose selling point
    is a zero-configuration setup. Whilst this may speed up initial development, having
    zero-configuration also means it's likely to support fewer features, and you'll
    have less control over the final bundle.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个相对较新的工具Parcel出现了，其卖点是无配置设置。虽然这可能加快了初始开发，但没有配置也意味着它可能支持的功能更少，并且你对最终包的控制也更少。
- en: Asynchronous module loading
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步模块加载
- en: An alternative to module bundling is to load modules asynchronously on the client.
    Asynchronous module loading means the modules that do not depend on each other
    can be loaded in parallel. This partially alleviates the slow startup time that
    clients face when using CommonJS.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 模块打包的另一种选择是在客户端异步加载模块。异步模块加载意味着不相互依赖的模块可以并行加载。这部分缓解了客户端在使用CommonJS时面临的缓慢启动时间。
- en: AMD and Require.js
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AMD和Require.js
- en: '**Asynchronous Module Definition** (**AMD**) is the most popular module specification
    that implements asynchronous module loading. AMD is actually an early fork of
    CommonJS, and also uses the `require` and `exports` syntax.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步模块定义**（**AMD**）是实现异步模块加载的最受欢迎的模块规范。AMD实际上是CommonJS的一个早期分支，并且也使用了`require`和`exports`语法。'
- en: 'Just as there are module bundlers for CommonJS modules, there are **module
    loaders** for AMD modules. These tools are called loaders because they load the
    modules from the client directly. The most popular module loader is **Require.js**.
    Require.js provides you with a `define` function, which you can use to define
    your module. You can pass in a list of dependencies as its first argument. Let''s
    look at an example:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 正如存在用于CommonJS模块的模块打包器一样，也存在用于AMD模块的**模块加载器**。这些工具被称为加载器，因为它们直接从客户端加载模块。最受欢迎的模块加载器是**Require.js**。Require.js为你提供了一个`define`函数，你可以用它来定义你的模块。你可以将依赖项列表作为其第一个参数传入。让我们看看一个例子：
- en: '[PRE46]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When the `main` module is initiated, it will first load the `greeter` module,
    and pass the object returned into the function that defines the `main` module.
    This ensures that modules are loaded in the correct order.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当`main`模块被启动时，它将首先加载`greeter`模块，并将返回的对象传递给定义`main`模块的函数。这确保了模块按正确的顺序加载。
- en: Require.js handles the loading of these modules in the background, parallelizing
    them if possible. This means downstream code execution is not blocked.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Require.js在后台处理这些模块的加载，如果可能的话，并行化它们。这意味着下游代码执行不会被阻塞。
- en: Universal Module Definition
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用模块定义
- en: '**UMD**, or **Universal Module Definition**, is a module definition format
    that aims to be compatible with both CommonJS and AMD. It also allows you to export
    the module as a global variable that you can include in your application through
    a simple `<script>` tag.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**UMD**，或**通用模块定义**，是一种旨在与CommonJS和AMD兼容的模块定义格式。它还允许你将模块导出为全局变量，你可以通过简单的`<script>`标签将其包含在你的应用程序中。'
- en: It does this by wrapping the modules in a boilerplate that checks the environment
    to detect how the module is used, and produces the correct exported object.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过将模块包裹在一个检查环境的样板代码中来实现这一点，以检测模块的使用方式，并生成正确的导出对象。
- en: 'For example, the preceding `greeter` example would look like this with UMD:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的`greeter`示例使用UMD将看起来像这样：
- en: '[PRE47]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: SystemJS and the Loader specification
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SystemJS和Loader规范
- en: The **Loader specification** ([whatwg.github.io/loader/](https://whatwg.github.io/loader/))
    is a work in progress specification that "describes the behavior of loading JavaScript
    modules from a JavaScript host environment". In other words, it describes a standard
    way to load JavaScript modules in both the browser and the server. It is developed
    by the WHATWG but not yet adopted as a living standard.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**Loader规范**([whatwg.github.io/loader/](https://whatwg.github.io/loader/))是一个正在进行的规范，它“描述了从JavaScript宿主环境加载JavaScript模块的行为”。换句话说，它描述了在浏览器和服务器上加载JavaScript模块的标准方式。它是WHATWG开发的，但尚未被采纳为活标准。'
- en: '**SystemJS** is an implementation of the Loader specification that works on
    the browser. More specifically, SystemJS is a **universal dynamic module loader**.
    Here, "universal" means it can load not only CommonJS modules, but also ES6 modules,
    AMD, and global scripts. It does this through the `SystemJS.import` method, which
    is akin to a universal `require` that works for all major module definitions.
    The code for importing an `App` component and rendering it may look like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**SystemJS**是Loader规范在浏览器上的实现。更具体地说，SystemJS是一个**通用动态模块加载器**。在这里，“通用”意味着它不仅可以加载CommonJS模块，还可以加载ES6模块、AMD和全局脚本。它是通过`SystemJS.import`方法实现的，类似于适用于所有主要模块定义的通用`require`。导入`App`组件并渲染它的代码可能看起来像这样：'
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: jspm
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jspm
- en: However, if SystemJS can import modules from any sources, how does it know where
    to find the modules? For instance, if we do `SystemJS.import('moment')`, should
    SystemJS fetch the package from the NPM registry? Or is it a custom repository?
    SystemJS can't know for sure. Therefore, to use SystemJS efficiently, we must
    use a package manager that can maintain a mapping between package names and their
    location. Luckily for us, there is **jspm**, which stands for **JavaScript Package
    Manager**.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果SystemJS可以从任何来源导入模块，它是如何知道模块的位置的呢？例如，如果我们执行`SystemJS.import('moment')`，SystemJS应该从NPM注册表获取包吗？或者是一个自定义仓库？SystemJS无法确定。因此，为了有效地使用SystemJS，我们必须使用一个包管理器，它可以维护包名和它们的位置之间的映射。幸运的是，我们有**jspm**，它代表**JavaScript包管理器**。
- en: jspm is similar to npm and yarn, but it can download modules/packages from anywhere,
    not just from npm. Furthermore, it will automatically create a SystemJS configuration
    file with all the package-to-location mapping we talked about previously.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: jspm与npm和yarn类似，但它可以从任何地方下载模块/包，而不仅仅是npm。此外，它将自动创建一个包含我们之前提到的所有包到位置的映射的SystemJS配置文件。
- en: Module bundler versus module loader
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块打包器与模块加载器
- en: After that brief overview of the tooling surrounding client-side modules, we
    are still left with the question - should we use a bundler or a loader? The status
    quo is to use a module bundler. With a loader, you may have to fire hundreds of
    HTTP requests to download all the dependencies. Even if these happen in the background,
    it can still lead to a slow load time. Therefore, using a module bundler is likely
    to allow the application to load quicker.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在对客户端模块周围的工具进行了简要概述之后，我们仍然面临着一个问题——我们应该使用打包器还是加载器？现状是使用模块打包器。使用加载器，你可能需要触发数百个
    HTTP 请求来下载所有依赖项。即使这些操作在后台进行，也可能导致加载时间变慢。因此，使用模块打包器可能会使应用程序加载更快。
- en: HTTP/2
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2
- en: However, this problem might be a non-issue once HTTP/2 becomes more widely adopted.
    With HTTP/1.1, we need to establish separate HTTP *and* TCP connections for each
    resource we want to retrieve, even when those resources reside on the same server.
    Establishing a TCP connection requires a **three-way handshake**, which is expensive.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦 HTTP/2 得到更广泛的采用，这个问题可能就不再是问题。在使用 HTTP/1.1 时，我们需要为每个我们想要检索的资源建立单独的 HTTP
    和 TCP 连接，即使这些资源位于同一服务器上。建立 TCP 连接需要三次握手，这是昂贵的。
- en: '![](img/41bca6bc-9aff-4433-8b90-0530bbf353a9.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41bca6bc-9aff-4433-8b90-0530bbf353a9.jpg)'
- en: With HTTP/2's multiplexing feature, a single TCP connection can be used to make
    multiple HTTP requests. Furthermore, multiple request and response messages can
    be sent in-flight simultaneously. Therefore, if HTTP/2 is widely adopted, making
    multiple requests would not be expensive anymore.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTP/2 的多路复用功能，单个 TCP 连接可以用来发送多个 HTTP 请求。此外，可以在飞行中同时发送多个请求和响应消息。因此，如果 HTTP/2
    得到广泛采用，发送多个请求将不再昂贵。
- en: For HTTP/2 to work, it needs to be supported for both the browser and the server.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了 HTTP/2 能够工作，它需要同时被浏览器和服务器支持。
- en: According to `caniuse.com` ([caniuse.com/#feat=http2](https://caniuse.com/#feat=http2)),
    at the time of writing, only 84.53% of browsers support HTTP/2\. And according
    to W3Techs ([w3techs.com/technologies/details/ce-http2/all/all](https://w3techs.com/technologies/details/ce-http2/all/all)),
    at the time of writing, HTTP/2 is used by only 25.3% of all websites. Therefore,
    a significant segment of browser usage is still on HTTP/1.x browsers. On those
    browsers, we'd still have to make hundreds to thousands of TCP connections on
    each page load; this is unacceptable. Therefore, until HTTP/2 support is almost
    universal, the status quo is still to use a module bundler in order to reduce
    load speed.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `caniuse.com` ([caniuse.com/#feat=http2](https://caniuse.com/#feat=http2))，在撰写本文时，只有
    84.53% 的浏览器支持 HTTP/2。根据 W3Techs ([w3techs.com/technologies/details/ce-http2/all/all](https://w3techs.com/technologies/details/ce-http2/all/all))，在撰写本文时，HTTP/2
    仅被 25.3% 的所有网站使用。因此，相当一部分浏览器使用量仍然在 HTTP/1.x 浏览器上。在这些浏览器上，我们仍然需要在每次页面加载时进行数百到数千次的
    TCP 连接；这是不可接受的。因此，直到 HTTP/2 支持几乎无处不在，现状仍然是使用模块打包器以减少加载速度。
- en: As we have mentioned, the most mature and widely-adopted module bundler is Webpack,
    and so for the rest of this chapter, we will convert our application to using
    ES6 modules, and using Webpack to process and bundle our application together.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，最成熟且广泛使用的模块打包器是 Webpack，因此在本章的剩余部分，我们将把我们的应用程序转换为使用 ES6 模块，并使用 Webpack
    来处理和打包我们的应用程序。
- en: Webpack
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webpack
- en: 'We are going to use yarn to manage our dependencies, just like we did for the
    client-side code. So let''s initiate a new configuration file and add the `webpack` package
    as a development dependency:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 yarn 来管理我们的依赖项，就像我们处理客户端代码一样。所以让我们启动一个新的配置文件，并将 `webpack` 包添加为开发依赖项：
- en: '[PRE49]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Just like Babel, Webpack will take in source files, transforms them and output
    it somewhere. Therefore, let's also create two directories to separate them.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Babel 一样，Webpack 会接收源文件，转换它们并将输出放在某个地方。因此，我们也创建两个目录来区分它们。
- en: '[PRE50]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Modularizing our components
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件模块化
- en: Next, we are going to completely gut out every JavaScript script inside our `src/index.html`.
    First, remove all the dependency `<script>` tags, such as React, ReactDOM, Babel,
    and bcryptjs. Then, we will use `yarn` to install them instead.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将完全移除 `src/index.html` 中的所有 JavaScript 脚本。首先，移除所有依赖 `<script>` 标签，例如 React、ReactDOM、Babel
    和 bcryptjs。然后，我们将使用 `yarn` 来安装它们。
- en: '[PRE51]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Babel is split into multiple smaller packages. This allows developers to use
    just the one they want, and not include unnecessary features.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 被分割成多个更小的包。这允许开发者只使用他们需要的那个，而不包括不必要的功能。
- en: We can now use these packages by importing them, just as we did with our back-end
    code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过导入它们来使用这些包，就像我们使用后端代码一样。
- en: 'Next, we will split our JavaScript code within `index.html` into separate modules.
    We will create:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `index.html` 中的 JavaScript 代码拆分为单独的模块。我们将创建：
- en: A `utils` directory to hold utility functions that can be re-used.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `utils` 目录来存放可重用的实用函数。
- en: A `components` directory to hold all our components.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `components` 目录来存放所有我们的组件。
- en: '`index.jsx` as the entry point. This will be where we import the overall `App` component
    and render it onto the DOM with `ReactDOM.render()`.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.jsx` 作为入口点。这将是我们导入整体 `App` 组件并将其使用 `ReactDOM.render()` 渲染到 DOM 上的地方。'
- en: 'Run the following on your terminal:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端上运行以下命令：
- en: '[PRE52]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We are using the `.jsx` extension here to denote that this file contains JSX
    syntax. Later on, this convention will help Webpack to efficiently determine which
    files it needs to process.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `.jsx` 扩展名来表示这个文件包含 JSX 语法。稍后，这个约定将帮助 Webpack 高效地确定它需要处理的文件。
- en: First, let's move the `validator` object from the `src/index.html` file into `src/utils/validator/index.js` and
    export it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将 `validator` 对象从 `src/index.html` 文件移动到 `src/utils/validator/index.js`
    并导出它。
- en: '[PRE53]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Do the same for the `register` function. Then, extract each component into its
    own `index.jsx`. For instance, `src/components/button/index.jsx` would contain
    the code below.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 同样对 `register` 函数做同样的处理。然后，将每个组件提取到其自己的 `index.jsx` 中。例如，`src/components/button/index.jsx`
    将包含以下代码。
- en: '[PRE54]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And `src/components/input/index.jsx` would look like this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/components/input/index.jsx` 将看起来像这样：'
- en: '[PRE55]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`react` must be imported into every module that uses React and JSX.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`react` 必须导入到每个使用 React 和 JSX 的模块中。'
- en: 'For the `RegistrationForm` component, which has external dependencies, we can `import` it
    at the top of the module:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有外部依赖的 `RegistrationForm` 组件，我们可以在模块顶部 `import` 它：
- en: '[PRE56]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, in our `src/index.jsx`, import the `RegistrationForm` component and
    render it onto the DOM:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的 `src/index.jsx` 中导入 `RegistrationForm` 组件并将其渲染到 DOM 上：
- en: '[PRE57]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Entry/output
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入口/输出
- en: As mentioned already, Webpack is a module bundler. It takes your application
    code, and all its dependencies, and bundles them into one or a small number of
    files. These files can then be transferred to the client and executed. More formally,
    it takes many source **input** files and bundles them into **output** file(s).
    With Webpack, the developer specifies one or several entry points, and Webpack
    will follow `require` or `import` statements in each file to build up a tree of
    dependencies.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Webpack 是一个模块打包器。它将你的应用程序代码及其所有依赖项打包成一个或少数几个文件。这些文件然后可以传输到客户端并执行。更正式地说，它将许多源
    **输入** 文件打包成一个或多个 **输出** 文件。使用 Webpack，开发者指定一个或多个入口点，Webpack 将遵循每个文件中的 `require`
    或 `import` 语句来构建依赖项树。
- en: Webpack's original selling point is its configurability. So let's begin by creating
    a configuration file at `webpack.config.js`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 的原始卖点是其可配置性。所以让我们首先在 `webpack.config.js` 中创建一个配置文件。
- en: '[PRE58]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In Webpack 4, sensible defaults have been set for the most common configurations.
    This means we can use Webpack without a `webpack.config.js` (they've marketed
    this as **Zero configuration JavaScript** (**0CJS**)). However, it is always better
    to be explicit rather than implicit, and so we will still maintain `webpack.config.js`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Webpack 4 中，为最常见的配置设置了合理的默认值。这意味着我们可以使用 Webpack 而不需要 `webpack.config.js`（他们将其推广为
    **零配置 JavaScript**（**0CJS**））。然而，总是明确比隐晦更好，所以我们仍然会保留 `webpack.config.js`。
- en: Let's see what happens when we run the Webpack CLI.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行 Webpack CLI 时会发生什么。
- en: '[PRE59]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The Webpack CLI is complaining that it does not understand the `import` syntax.
    This is because, by default, Webpack only fully-supports ES5 syntax, and doesn't
    support ES6 modules. To allow Webpack to understand ES6 syntax, we must use the `babel-loader` package.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack CLI 正在抱怨它不理解 `import` 语法。这是因为默认情况下，Webpack 只完全支持 ES5 语法，不支持 ES6 模块。为了使
    Webpack 能够理解 ES6 语法，我们必须使用 `babel-loader` 包。
- en: Loaders
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载器
- en: Loaders are transformation programs that run on the source files *individually*.
    For example, you'd use loaders to transform CoffeeScript/TypeScript into ES5 before
    bundling them; in our case, we use it to transform ES2015+ syntax and JSX into
    ES5\. First, let's install the loader using yarn.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器是运行在源文件上的转换程序，它们是**单独**运行的。例如，你会在打包之前使用加载器将 CoffeeScript/TypeScript 转换为 ES5；在我们的例子中，我们使用它将
    ES2015+ 语法和 JSX 转换为 ES5。首先，让我们使用 yarn 安装加载器。
- en: '[PRE60]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Next, we will update `webpack.config.js` to instruct Webpack to use the loader.
    We can do this by defining loader specifications inside the `module.rules` property.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新 `webpack.config.js` 以指示 Webpack 使用加载器。我们可以通过在 `module.rules` 属性中定义加载器规范来实现这一点。
- en: '[PRE61]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Each loader specification contains two important sub-properties:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载器规范包含两个重要的子属性：
- en: '`test` determines which files should be processed by this loader. Here, we
    are using a regular expression, `/\.jsx?$/`, to tell Webpack to use this loader
    to process all files with an extension of `.jsx`.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test` 决定了哪些文件应该由这个加载器处理。在这里，我们使用正则表达式 `/\.jsx?$/` 来告诉 Webpack 使用此加载器处理所有扩展名为
    `.jsx` 的文件。'
- en: '`use` specifies which loaders should be used to transform these files, plus
    any additional options to pass into the loaders. Here, we are instructing Webpack
    to use the `babel-loader` module we just installed, and Babel should use the React
    and `env` presets, as well as the Transform Class Properties plugin.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use` 指定了用于转换这些文件的加载器，以及传递给加载器的任何附加选项。在这里，我们指示 Webpack 使用我们刚刚安装的 `babel-loader`
    模块，Babel 应该使用 React 和 `env` 预设，以及 Transform Class Properties 插件。'
- en: Now, when we run `webpack` again, you will see that `dist/bundle.js` being created.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行 `webpack` 时，你会看到 `dist/bundle.js` 正在被创建。
- en: '[PRE62]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It may also print some warnings regarding optimizing the build. We can ignore
    these for now.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可能打印一些有关优化构建的警告。我们现在可以忽略这些警告。
- en: Now that we have `bundle.js` at the root of the `dist/` directory, we should
    update our `src/index.html` to use the bundled script. Replace the `<script type="text/babel">...</script>` block
    with `<script src="img/bundle.js"></script>`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `bundle.js` 放在 `dist/` 目录的根目录下，我们应该更新我们的 `src/index.html` 以使用捆绑的脚本。将
    `<script type="text/babel">...</script>` 块替换为 `<script src="img/bundle.js"></script>`。
- en: However, the `index.html` is not copied across from the `src/` directory to
    the `dist/` directory. This is because Webpack only processes JavaScript (`.js` / `.mjs`),
    JSON, and WebAssembly files (`.wasm`). To copy the `index.html` file across, we
    need another type of tool called a **plugin**.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`index.html` 并没有被从 `src/` 目录复制到 `dist/` 目录。这是因为 Webpack 只处理 JavaScript (`.js`
    / `.mjs`)、JSON 和 WebAssembly 文件 (`.wasm`)。要复制 `index.html` 文件，我们需要另一种类型的工具，称为
    **插件**。
- en: CSS and HTML modules are planned to be supported in Webpack 5, so some of the
    plugins we introduce here may not be necessary in the future.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 和 HTML 模块计划在 Webpack 5 中得到支持，因此我们在这里介绍的一些插件可能在未来不再必要。
- en: Plugins
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件
- en: Loaders work on transforming *individual* files, "in place", *before or during* the
    creation of the bundle. In contrast, plugins work on the output of the loaders
    and process the bundle as a whole *after* it's created.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器在创建包之前或期间对单个文件进行转换，"就地" 进行。相比之下，插件在加载器的输出上工作，并在创建后整体处理包。
- en: Copying files
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制文件
- en: To copy our `src/index.html` file across, we can use the aptly-named Copy Webpack
    plugin (`copy-webpack-plugin`). As its name suggests, this plugin copies individual
    files or entire directories to the build directory. Let's install it with yarn.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制我们的 `src/index.html` 文件，我们可以使用名为 Copy Webpack 插件 (`copy-webpack-plugin`)。正如其名所示，此插件将单个文件或整个目录复制到构建目录。让我们使用
    yarn 安装它。
- en: '[PRE63]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And add the plugin to our `webpack.config.js`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 并将插件添加到我们的 `webpack.config.js`。
- en: '[PRE64]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `CopyWebpackPlugin` constructor has the following signature:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyWebpackPlugin` 构造函数具有以下签名：'
- en: '[PRE65]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here,`patterns` specifies a set of matching files it should copy. We are simply
    specifying a single file.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`patterns` 指定了一组应复制的匹配文件。我们只是指定了一个单个文件。
- en: Run `webpack` again and you'll see both `bundle.js` and `index.html` being written
    to the `dist/` directory. We can now use the `http-server` package to serve the `dist/` directory
    statically.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `webpack`，你会看到 `bundle.js` 和 `index.html` 都被写入到 `dist/` 目录。现在我们可以使用 `http-server`
    包来静态地提供 `dist/` 目录。
- en: '[PRE66]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You should be presented with the same Registration form as before. But now our
    code is much more modular.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到与之前相同的注册表单。但现在我们的代码要模块化得多。
- en: Final steps
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后步骤
- en: Before we finish, let's also document the commands we've run into npm scripts.
    This will make building and serving our application easier in the future.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成之前，让我们也记录我们在 npm 脚本中运行的命令。这将在未来使构建和提供我们的应用程序更容易。
- en: 'In the `package.json`, define the build step with the following `scripts` property:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `package.json` 中，使用以下 `scripts` 属性定义构建步骤：
- en: '[PRE67]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we will write a script to serve our application. We''d like to specify
    the host and port of the application using environment variables (instead of hard-coding
    it), so let''s create an `.env` and an `.env.example` file, and fill them with
    the following content:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写一个脚本来提供我们的应用程序。我们希望使用环境变量（而不是硬编码）来指定应用程序的主机和端口，因此让我们创建一个 `.env` 和一个
    `.env.example` 文件，并填充以下内容：
- en: '[PRE68]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, create a Bash script at `scripts/serve.sh` and give it the execute permission:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `scripts/serve.sh` 创建一个 Bash 脚本，并赋予它执行权限：
- en: '[PRE69]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Inside the Bash script, we will simply load the environment variables, build
    the application, and use `htttp-server` to serve the bundled files:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash 脚本内部，我们将简单地加载环境变量，构建应用程序，并使用 `htttp-server` 来提供打包后的文件：
- en: '[PRE70]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we just need to run our Bash script using an npm script:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需使用 npm 脚本运行我们的 Bash 脚本：
- en: '[PRE71]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Summary
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have built a basic Registration form using React, and bundled
    it using Webpack. In the next chapter, we will look at how to perform E2E testing
    for front-end applications using **Selenium**.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 React 构建了一个基本的注册表单，并使用 Webpack 进行打包。在下一章中，我们将探讨如何使用 **Selenium** 对前端应用程序进行端到端测试。
