- en: Appendix C. Organizing Templates with AMD and Require.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C. 使用AMD和Require.js组织模板
- en: '**Asynchronous Module Definition** (**AMD**) is a JavaScript API used to define
    modules and load module dependencies asynchronously. It is a fairly new yet very
    robust concept that many developers are adopting nowadays. In [Chapter 7](ch07.html
    "Chapter 7. Organizing Backbone Applications – Structure, Optimize, and Deploy"),
    *Organizing Backbone Applications – Structure, Optimize, and Deploy*, we covered
    AMD with Require.js in detail. If you need more details on this library, we recommend
    you visit [http://requirejs.org/](http://requirejs.org/) to get a complete overview
    and then come back to this section.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步模块定义**（**AMD**）是一个用于定义模块和异步加载模块依赖的JavaScript API。这是一个相对较新但非常稳健的概念，许多开发者现在都在采用它。在[第7章](ch07.html
    "第7章. 组织Backbone应用程序 – 结构、优化和部署") *组织Backbone应用程序 – 结构、优化和部署* 中，我们详细介绍了使用Require.js的AMD。如果您需要更多关于这个库的细节，我们建议您访问[http://requirejs.org/](http://requirejs.org/)以获取完整的概述，然后回到这一节。'
- en: 'In general, Require.js treats every file''s content as JavaScript. So, we cannot
    load our template files, if they aren''t JavaScript files, in the same manner
    as JavaScript files. Fortunately for templates, there is a `text` plugin that
    allows us to load text-based dependencies. Any file that we load using this file
    will be treated as a text file and the content that we receive will be a string;
    it can be used easily with your template methods. To use this plugin, just prepend
    `text!` to the file path and the file contents will be retrieved as plain text;
    to do this, follow this example:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Require.js将每个文件的内容视为JavaScript。因此，如果我们不将模板文件作为JavaScript文件加载，我们就不能以相同的方式加载它们。幸运的是，对于模板，有一个`text`插件允许我们加载基于文本的依赖项。我们使用此文件加载的任何文件都将被视为文本文件，我们接收到的内容将是一个字符串；它可以很容易地与您的模板方法一起使用。要使用此插件，只需在文件路径前加上`text!`，文件内容将以纯文本形式检索；为此，请遵循以下示例：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The benefit of using this mechanism is that you can organize your templates
    by creating separate template files and they are automatically included in your
    modules. Since this involves asynchronous loading, the files are downloaded via
    AJAX requests, something we already decided as being a bad idea. However, Require.js
    comes with an `r.js` optimization tool that builds the modules and can save these
    extra AJAX requests by inlining these templates with their respective modules.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此机制的好处是，您可以通过创建单独的模板文件来组织您的模板，并且它们将自动包含在您的模块中。由于这涉及到异步加载，文件将通过AJAX请求下载，这是我们之前决定为不好的做法。然而，Require.js附带了一个`r.js`优化工具，它可以构建模块并可以通过内联这些模板与相应的模块来节省这些额外的AJAX请求。
- en: Precompiling with the requirejs-tpl plugin
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用requirejs-tpl插件进行预编译
- en: 'With AMD, we simplified the template organization process, but the end result
    still remains an uncompiled template string. In [Chapter 2](ch02.html "Chapter 2. Working
    with Views"), *Working with Views*, we saw how template compilation affects application
    performance every time and we also analyzed the benefits of precompiling templates.
    Won''t it be useful if we have something that will load these template files and
    provide us with an already-compiled template string instead? Fortunately, there
    are multiple `tpl` plugins available for Require.js that automate template compilation,
    and you can use these plugins directly in your module definition. Let us look
    at a similar plugin ([https://github.com/ZeeAgency/requirejs-tpl](https://github.com/ZeeAgency/requirejs-tpl))
    developed by ZeeAgency. Dependency loading is exactly the same as it is for the
    `text` plugin, you just need to use the `tpl!` plugin prefix instead of `text!`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AMD，我们简化了模板组织过程，但最终结果仍然是一个未编译的模板字符串。在[第2章](ch02.html "第2章. 与视图一起工作") *与视图一起工作*
    中，我们看到了模板编译如何每次都影响应用程序性能，我们也分析了预编译模板的好处。如果我们有一种可以加载这些模板文件并提供已编译的模板字符串的方法，那会很有用吗？幸运的是，对于Require.js有多个`tpl`插件可用于自动化模板编译，您可以直接在模块定义中使用这些插件。让我们看看由ZeeAgency开发的类似插件([https://github.com/ZeeAgency/requirejs-tpl](https://github.com/ZeeAgency/requirejs-tpl))。依赖项加载与`text`插件完全相同，您只需使用`tpl!`插件前缀而不是`text!`：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, `r.js` provides optimized and packaged precompiled templates. The `tpl!`
    plugin is surely more handy and useful than the `text!` plugin.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`r.js`提供了优化和打包的预编译模板。`tpl!`插件肯定比`text!`插件更方便和有用。
- en: Template organization with Require.js is one of the best ways to maintain templates;
    a lot of JavaScript developers are opting for it nowadays. If you are using AMD
    for your Backbone application, go for it without any hesitation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Require.js 进行模板组织是维护模板的最佳方式之一；现在很多 JavaScript 开发者都在选择这种方式。如果你正在使用 AMD 为你的
    Backbone 应用程序开发，那就毫不犹豫地选择它吧。
