- en: Using the Serverless Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Serverless Framework
- en: When developing a serverless project, you can group multiple features into a
    single big Lambda function or break each feature into its own small function.
    If you follow the second option, you will end up managing the deployment of dozens
    of different functions, each one of them with its own configuration and dependencies.
    Automating this process could be a real challenge, but it becomes an easy task
    when you use the Serverless Framework in your workflow. Besides handling the release
    process, the framework helps you architect the solution and manage different environments,
    and it provides a clean and succinct syntax for versioning the infrastructure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发无服务器项目时，你可以将多个功能组合成一个大的 Lambda 函数，或者将每个功能拆分成它自己的小函数。如果你选择第二种方案，你最终将管理数十个不同的函数的部署，每个函数都有其自己的配置和依赖。自动化这个过程可能是一个真正的挑战，但当你使用
    Serverless Framework 作为你的工作流程时，它就变得容易多了。除了处理发布过程外，该框架还帮助您构建解决方案并管理不同的环境，并为基础设施版本化提供了一种干净简洁的语法。
- en: 'In this chapter, you will learn how to configure and use the Serverless Framework.
    We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何配置和使用 Serverless Framework。我们将涵盖以下主题：
- en: How to set up and start using the framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置和使用框架
- en: Deploying a hello-world application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 hello-world 应用程序
- en: Creating endpoints and enabling CORS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建端点和启用 CORS
- en: Configuring events to trigger functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置事件以触发函数
- en: Accessing other AWS resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问其他 AWS 资源
- en: After this chapter, you'll have learned the basics of how to build the backend
    of a serverless project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将学会如何构建无服务器项目后端的基本知识。
- en: Serverless Framework
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Serverless Framework
- en: There are many tools that have been developed to help manage serverless projects.
    The Serverless Framework is currently the most popular and will be used extensively
    in this book. This section will help you configure, use, and understand how it
    will fit in your workflow.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发了许多工具来帮助管理无服务器项目。Serverless Framework 目前是最受欢迎的，本书将广泛使用它。本节将帮助你配置、使用和理解它如何融入你的工作流程。
- en: Understanding the Serverless Framework
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Serverless Framework
- en: 'The Serverless Framework is a powerful Node.js *command-line tool*, not a cloud
    service. Its objective is to help developers be more productive by simplifying
    how they can use and manage cloud resources. It provides a set of commands that
    will help you quickly start a new project, add functions, endpoints, triggers,
    configure permissions, and more. In summary, the framework will manage your project,
    automate the deployment of your code, and integrate with many different services:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework 是一个强大的 Node.js 命令行工具，而不是云服务。它的目标是帮助开发者通过简化他们使用和管理云资源的方式，提高他们的生产力。它提供了一套命令，可以帮助你快速启动一个新项目，添加函数、端点、触发器、配置权限等。总的来说，该框架将管理你的项目，自动化你的代码部署，并与许多不同的服务集成：
- en: '![](img/cdb2603f-bd1f-4950-a72d-a516fb6670ae.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cdb2603f-bd1f-4950-a72d-a516fb6670ae.png)'
- en: 'We have the following as input:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下输入：
- en: '**Integration**: Describes what and how different cloud services will trigger
    our Lambda functions'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：描述了不同的云服务将如何触发我们的 Lambda 函数'
- en: '**Configuration**: Sets permissions for Lambda functions, and defines the limits
    (timeout and RAM memory) under which they will run'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：为 Lambda 函数设置权限，并定义它们将在其下运行的限制（超时和 RAM 内存）'
- en: '**Plugins**: Extends the framework functionalities with custom code'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**：通过自定义代码扩展框架功能'
- en: 'Here is what the framework provides:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该框架提供的内容：
- en: '**Architecture**: Helps to define an architecture that will keep our project
    consistent.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构**：帮助定义一个将保持我们的项目一致性的架构。'
- en: '**Deploy**: Automates code deployment. You can deploy anytime with a single
    command.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：自动化代码部署。你可以通过一个命令随时部署。'
- en: '**Versioning**: Helps versioning the code configuration, which means versioning
    the infrastructure. Duplicating the same infrastructure into another region or
    environment is a trivial task.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本化**：帮助版本化代码配置，这意味着版本化基础设施。将相同的架构复制到另一个区域或环境是一个简单的任务。'
- en: 'Currently, it supports the following cloud providers: AWS, Microsoft Azure,
    Google Cloud Platform, and IBM OpenWhisk. Migrating from one cloud to another
    is possible, but it is not simple. The framework uses the same commands for management
    tasks and tries to use similar settings, but each one of them requires different
    configurations and setups.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它支持以下云服务提供商：AWS、Microsoft Azure、Google Cloud Platform 和 IBM OpenWhisk。从一个云迁移到另一个云是可能的，但这并不简单。该框架使用相同的命令进行管理任务，并试图使用类似的设置，但每个都需要不同的配置和设置。
- en: Another important characteristic is that the Serverless Framework is open source
    and MIT licensed, so it can be used for free, even in commercial products.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要特征是，Serverless Framework 是开源的，并拥有 MIT 许可证，因此它可以免费使用，即使在商业产品中也是如此。
- en: Other frameworks
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他框架
- en: Serverless is a concept that promotes the development of applications without
    worrying about the servers that will operate them. It's a concept and doesn't
    specify the tools that will be used, nor the cloud vendors that host the applications.
    However, taking advantage of the word's hype, the creators of **JAWS** renamed
    their project to **Serverless Framework** at the end of 2015 and bought the [serverless.com](https://serverless.com)
    domain. To further improve their open source project, they started a venture-backed
    company named *Serverless, Inc*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器是一种促进应用程序开发的概念，无需担心将运行这些应用程序的服务器。这是一个概念，并不指定将使用的工具，也不指定托管应用程序的云服务提供商。然而，利用这个词汇的热潮，**JAWS**
    的创造者在 2015 年底将他们的项目重命名为 **Serverless Framework**，并购买了 [serverless.com](https://serverless.com)
    域名。为了进一步提高他们的开源项目，他们成立了一家名为 *Serverless, Inc* 的风险投资公司。
- en: The Serverless Framework is currently the best tool to build a general-purpose
    serverless project, but **do not** confuse a product with the concept. The framework
    promotes serverless applications, but offers **only a subset** of what you can
    do with serverless. There are many other services and frameworks out there with
    different features and objectives.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Serverless Framework 是构建通用无服务器项目的最佳工具，但**不要**将产品与概念混淆。该框架推广无服务器应用程序，但仅提供您可以使用无服务器执行的部分功能。还有许多其他服务和框架，它们具有不同的功能和目标。
- en: 'For example, Apex is another framework to manage AWS Lambda functions with
    an interesting feature that provides support for Go, Rust, and Clojure, even without
    native support by Lambda. There are also dozens of other tools. For more options,
    you can take a look at this curated list: [https://github.com/anaibol/awesome-serverless](https://github.com/anaibol/awesome-serverless).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Apex 是另一个用于管理 AWS Lambda 函数的框架，它具有一个有趣的功能，即提供对 Go、Rust 和 Clojure 的支持，即使 Lambda
    本身没有原生支持。还有数十种其他工具。更多选项，您可以查看这个精选列表：[https://github.com/anaibol/awesome-serverless](https://github.com/anaibol/awesome-serverless)。
- en: Installing the framework
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装框架
- en: 'As the Serverless Framework uses Node.js, you can use npm to install it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Serverless Framework 使用 Node.js，您可以使用 npm 来安装它：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `@1.x` suffix asks npm to download a package compatible with the 1.x version.
    This restriction is suggested because this book was written following the 1.18
    specification of the framework and the examples may not be compatible with a future
    2.x version.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@1.x` 后缀指示 npm 下载与 1.x 版本兼容的包。这种限制建议是因为这本书是在框架的 1.18 规范之后编写的，示例可能不与未来的 2.x
    版本兼容。'
- en: The Serverless Framework requires Node.js v6.5 or higher. Make sure that you
    have an updated version. You can check this by running `node --version`. If you
    need to update your Node version, consider using v6.10 because this is the latest
    version that AWS uses to run Lambda functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework 需要 Node.js v6.5 或更高版本。请确保您有一个更新的版本。您可以通过运行 `node --version`
    来检查。如果您需要更新 Node 版本，请考虑使用 v6.10，因为这是 AWS 用于运行 Lambda 函数的最新版本。
- en: 'To confirm that the framework was installed successfully, you can check its
    version by running the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认框架已成功安装，您可以通过运行以下命令来检查其版本：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of using the `serverless` command, you can use the abbreviation `sls`
    for all commands. For example, `sls --version`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `serverless` 命令外，您还可以使用缩写 `sls` 来使用所有命令。例如，`sls --version`。
- en: Also, for each option that starts with two dashes, such as in `--version`, there
    will always exist a shorter alternative using just one letter, such as `-v` in
    this case.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于以两个短横线开头的每个选项，例如在 `--version` 中，总会有一个使用单个字母的更短替代选项，例如本例中的 `-v`。
- en: Configuring the framework
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置框架
- en: The Serverless Framework uses the AWS SDK to manage your account resources,
    so the configuration that is needed is to set your credentials where the SDK can
    access them. As described in [Chapter 2](246b3080-28af-4aa3-805f-5fbf9908caae.xhtml),
    *Getting Started with AWS*, we have already created a user and set its **Access
    key** and **Secret access key** into environment variables.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless框架使用AWS SDK来管理你的账户资源，因此所需的配置是将你的凭证设置在SDK可以访问它们的地方。如[第2章](246b3080-28af-4aa3-805f-5fbf9908caae.xhtml)，“AWS入门”，所述，我们已经创建了一个用户，并将其**访问密钥**和**秘密访问密钥**设置到环境变量中。
- en: What is missing here is properly restricting this user access. For learning
    purposes, it's perfectly fine to use an administrator account with full access.
    However, if you are building a real product, follow the principle of least privilege
    and set access only for what is expected to be used by the framework. In the previous
    chapter, you learned how to configure it using the IAM console ([https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里缺少的是正确限制用户访问。为了学习目的，使用具有完全访问权限的管理员账户是完全可以接受的。然而，如果你正在构建真实的产品，请遵循最小权限原则，只为框架预期使用的功能设置访问权限。在上一章中，你学习了如何使用IAM控制台配置它（[https://console.aws.amazon.com/iam](https://console.aws.amazon.com/iam)）。
- en: The minimum access requirements are **Lambda**, **CloudFormation**, **IAM**,
    and **CloudWatch**. While setting permissions, you can anticipate and give access
    that will be needed later in our sample project. The framework will also need
    access to **API Gateway**, **IoT**, **SimpleDB**, and **DynamoDB**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最小访问要求是**Lambda**、**CloudFormation**、**IAM**和**CloudWatch**。在设置权限时，你可以预测并授予我们样本项目中将来需要的访问权限。框架还需要访问**API
    Gateway**、**IoT**、**SimpleDB**和**DynamoDB**。
- en: Managing permissions in a team
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在团队中管理权限
- en: When working in a team, it's mandatory that everyone must have their own user
    for a fine-grained set of permissions. Also, it allows audit and traceability
    which are very important. Audit discourages wrongdoings by team members and traceability
    is useful for unfortunate cases, for example, if your site is compromised, you
    can discover the source of the invasion. If you want those features, you must
    configure **AWS CloudTrail** to store into S3 the log files of the AWS API usage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队工作中，每个人都必须拥有自己的用户，以便拥有细粒度的权限集合。此外，它还允许审计和可追溯性，这两者都非常重要。审计可以阻止团队成员的不当行为，而可追溯性在不幸的情况下很有用，例如，如果你的网站遭到入侵，你可以发现入侵的源头。如果你想要这些功能，你必须配置**AWS
    CloudTrail**以将AWS API使用日志文件存储到S3中。
- en: If each team member has a unique account, you can restrict access to the production
    environment for a reduced group of people. Access to production is a great responsibility
    that should only be entrusted to experienced people to avoid failures due to distraction
    or lack of knowledge.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个团队成员都有一个唯一的账户，你可以限制对生产环境的访问权限，仅限于一小群人。对生产环境的访问是一项重大的责任，应该只托付给有经验的人，以避免由于分心或知识不足而导致的失败。
- en: Creating a new project
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新项目
- en: 'Let''s start by creating a new folder to store our project data. Name it `hello-serverless`
    and set the command prompt directory to this folder. Now, run the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的文件夹来存储我们的项目数据。将其命名为`hello-serverless`并将命令提示符目录设置为该文件夹。现在，运行以下命令：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Take a look at the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的截图：
- en: '![](img/cdc49010-631f-4d66-9a14-c7e9256fcb4c.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/cdc49010-631f-4d66-9a14-c7e9256fcb4c.png)'
- en: This command creates one *service* that is used to group related functions.
    You can compare a service as a bounded context as defined in **Domain-Driven Design**
    (**DDD**). For example, in this book, the sample application is an online store.
    We can say that features that will be implemented to exhibit products and handle
    sales are part of one context. The features that handle user accounts and profile
    data are part of another context. We will discuss serverless architectures in
    [Chapter 6](a225cec3-99da-4be5-8833-f8fdaf0aa819.xhtml), *Developing the Backend*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个用于分组相关函数的*服务*。你可以将服务比作**领域驱动设计**（**DDD**）中定义的边界上下文。例如，在这本书中，样本应用是一个在线商店。我们可以说，将用于展示产品和处理销售的功能属于一个上下文。处理用户账户和配置文件数据的功能属于另一个上下文。我们将在[第6章](a225cec3-99da-4be5-8833-f8fdaf0aa819.xhtml)，“开发后端”中讨论无服务器架构。
- en: 'After executing the command, the following two files are created:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，将创建以下两个文件：
- en: The `handler.js` file
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler.js`文件'
- en: The `serverless.yml` file
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serverless.yml`文件'
- en: Let's see the context of each one and understand their role.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个配置的上下文，并了解它们的作用。
- en: The handler.js file
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: handler.js 文件
- en: 'This file contains the main function that will be executed by AWS Lambda. For
    a simple example, consider the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含将由 AWS Lambda 执行的主要函数。对于简单示例，考虑以下代码：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our `response` object has the properties `statusCode` and `body`. This schema
    is mandatory when you want to trigger Lambda functions using the API Gateway and
    when the Lambda is configured as a proxy, which is the default option selected
    in the Serverless Framework. Instead of configuring headers, status codes, and
    other parameters in the API Gateway, the Lambda proxy setting allows this configuration
    to be part of the code. This is the recommended practice for most use cases.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `response` 对象具有 `statusCode` 和 `body` 属性。当您想使用 API Gateway 触发 Lambda 函数，或者当
    Lambda 配置为代理（这是在 Serverless 框架中选择的默认选项）时，此架构是必需的。与在 API Gateway 中配置头、状态码和其他参数相比，Lambda
    代理设置允许将这些配置作为代码的一部分。这对于大多数用例是推荐的做法。
- en: 'The function named `hello` will be configured as our main entry. It receives
    three arguments such as `event`, `context`, and `callback`. The `event` variable
    is our input data, and `callback` is the function that must be executed after
    the Lambda execution finishes and it receives an error object as the first parameter
    and a `response` object as the second one, and the `context` is an object that
    provides data related to our function execution. An example of the `context` content
    is displayed in the following JSON:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `hello` 的函数将被配置为我们的主要入口。它接收 `event`、`context` 和 `callback` 三个参数。`event`
    变量是我们的输入数据，`callback` 是在 Lambda 执行完成后必须执行并接收错误对象作为第一个参数、`response` 对象作为第二个参数的函数，`context`
    是一个提供与我们的函数执行相关的数据的对象。以下是一个 `context` 内容的示例，以 JSON 格式显示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we return `status code 200 (OK)`, and the response `body` will
    return a message that uses the event as an input variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们返回 `状态码 200 (OK)`，响应 `body` 将返回一个使用事件作为输入变量的消息。
- en: The serverless.yml file
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: serverless.yml 文件
- en: This is a configuration file that uses the YAML standard, which has the aim
    of being more readable by humans. The name YAML is a recursive acronym meaning
    *YAML Ain't Markup Language*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 YAML 标准的配置文件，其目的是使人类更容易阅读。YAML 的名字是一个递归缩写，意味着 *YAML Ain't Markup Language*。
- en: 'When we created the service, we used the argument `aws-nodejs`. It creates
    a file with the following content:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建服务时，我们使用了 `aws-nodejs` 参数。它创建了一个包含以下内容的文件：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s take a look at the following settings depicted in the preceding code
    example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面代码示例中描述的以下设置：
- en: '`service`: This is just the service name that we have specified while creating
    the service.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service`: 这只是我们在创建服务时指定的服务名称。'
- en: '`provider`: This sets the cloud provider and the runtime. We have selected
    AWS and the latest Node.js version available.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provider`: 这设置了云提供商和运行时。我们选择了 AWS 和可用的最新 Node.js 版本。'
- en: '`functions`: This is where we define the Lambda functions.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functions`: 这里是我们定义 Lambda 函数的地方。'
- en: There are more options available, but we will cover them as we need them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多选项可用，但我们将根据需要介绍它们。
- en: Configuring the Lambda limits
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Lambda 限制
- en: While setting the `serverless.yml` file, you can configure your function limits.
    The RAM memory size has the default value of 1,024 MB. The possible values range
    from 128 MB to 1,536 MB in chunks of 64 MB.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `serverless.yml` 文件时，您可以配置您的函数限制。RAM 内存大小默认值为 1,024 MB。可能的值范围从 128 MB 到
    1,536 MB，以 64 MB 为增量。
- en: 'Another possible setting is the `timeout` property. If your function exceeds
    the expected time, it will be aborted. The default value is 6 seconds and the
    possible values range from 1 second to 300 seconds (5 minutes):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的设置是 `timeout` 属性。如果您的函数超过预期时间，它将被终止。默认值为 6 秒，可能的值范围从 1 秒到 300 秒（5 分钟）：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In YAML syntax, a comment begins with the hash sign (`**#**`) and continues
    until the end of the line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 YAML 语法中，注释以井号 (`#`) 开头，并持续到行尾。
- en: 'You can also change the default values by modifying the provider settings.
    These values will be used when your function doesn''t specify them:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过修改提供商设置来更改默认值。当您的函数未指定这些值时，将使用这些值：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Deploying a service
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署一个服务
- en: 'Deploying a service is a simple task. We just need to run the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 部署一个服务是一个简单的任务。我们只需要运行以下命令：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see the results in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到结果：
- en: '![](img/0a7da9ea-99c4-4739-980b-a0b4911b30af.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a7da9ea-99c4-4739-980b-a0b4911b30af.png)'
- en: By default, it will deploy your functions in a `stage` named `dev` and in the
    `region` named `us-east-1`. The `stage` is used to simulate different environments.
    For example, you can create one for development and another for `production`,
    or you can use one for `v1` and another for `v2` if you want to create versioned
    APIs. Regarding the region, it's used to identify which AWS `region` will be used
    to host your Lambda functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它将在名为`dev`的阶段和名为`us-east-1`的区域中部署您的函数。`阶段`用于模拟不同的环境。例如，您可以创建一个用于开发，另一个用于`生产`，或者如果您想创建版本化的API，您可以使用一个用于`v1`，另一个用于`v2`。至于区域，它用于标识将用于托管Lambda函数的哪个AWS`区域`。
- en: 'Here are two options to change the default values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个选项来更改默认值：
- en: 'The first one is to modify the `serverless.yml` file, as shown in the following
    code example:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是修改`serverless.yml`文件，如下面的代码示例所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second option is to use the arguments of the deploy command:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是使用部署命令的参数：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Under `provider`, you can set the configuration file to the `dev` stage, only
    when you want to deploy to `production`, you can do so using the stage argument
    with the command line. Using two different approaches for two different environments
    is a good way to avoid mistakes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`provider`下，您可以将配置文件设置为`dev`阶段，只有当您想部署到`生产`时，您可以使用命令行中的阶段参数来这样做。对于不同的环境使用两种不同的方法是一种避免错误的好方法。
- en: 'When we use the `deploy` command, it can take a couple of minutes to execute,
    even for small projects. The performance issue is related with CloudFormation,
    which needs to update the stack across AWS machines. After deploying the function
    for the first time, we can use the `deploy function` command for code updates
    because this command will simply swap the ZIP package of the function. As it doesn''t
    need to execute any CloudFormation code, this is a much faster way of deploying
    changes. The following example shows how to use this command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`deploy`命令时，即使是对于小型项目，执行也可能需要几分钟。性能问题与CloudFormation有关，它需要在AWS机器之间更新堆栈。在第一次部署函数后，我们可以使用`deploy
    function`命令进行代码更新，因为这个命令将简单地交换函数的ZIP包。由于它不需要执行任何CloudFormation代码，这是一种部署更改的更快方式。以下示例显示了如何使用此命令：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Always remember to update the function's code using the `deploy function` command
    for fast deployment. If you need to update any kind of configuration, such as
    permissions or Lambda limits, you need to run the `deploy` command (without the
    `function` part).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得使用`deploy function`命令更新函数的代码以实现快速部署。如果您需要更新任何类型的配置，例如权限或Lambda限制，您需要运行`deploy`命令（不带`function`部分）。
- en: Invoking a function
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'We just created and deployed a Lambda function. Now, let''s see how this function
    can be invoked by performing the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建并部署了一个Lambda函数。现在，让我们通过以下步骤来查看这个函数如何被调用：
- en: 'Inside your project folder, create an `event.json` file with the following
    content. This file will serve as our input data:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目文件夹中，创建一个包含以下内容的`event.json`文件。此文件将作为我们的输入数据：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step is to invoke the function and confirm that it is working as expected.
    You can do so by executing the `invoke` command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是调用函数并确认其按预期工作。您可以通过执行`invoke`命令来完成此操作：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Passing the `event.json` file as input is not mandatory. We are using it because
    our example uses the input data to create the `response` object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将`event.json`文件作为输入不是强制性的。我们之所以使用它，是因为我们的示例使用输入数据来创建`response`对象。
- en: 'The following screenshot shows the invoke result:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了调用结果：
- en: '![](img/7e2f4786-a807-477f-ac07-dc70db4bfc36.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e2f4786-a807-477f-ac07-dc70db4bfc36.png)'
- en: 'If you have functions deployed to multiple stages/regions, you can invoke them
    by specifying the stage/region explicitly. For example, take a look at the following
    command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将函数部署到多个阶段/区域，您可以通过明确指定阶段/区域来调用它们。例如，看看以下命令：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last observation is that you can invoke functions locally. This invoke
    will execute the function using your machine instead of running the function hosted
    on AWS. For this, just use the `invoke local` command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个观察结果是您可以本地调用函数。这个调用将使用您的机器执行函数，而不是运行托管在AWS上的函数。为此，只需使用`invoke local`命令：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will see later that we can give or restrict permissions to Lambda functions.
    However, if you execute the code locally, it won't use the configured roles. The
    Lambda will execute under your local SDK credentials, so testing Lambda locally
    can be useful, but you need to know that you won't be testing it with the same
    permissions that will be used when the function is hosted on AWS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将会看到，我们可以为Lambda函数授予或限制权限。然而，如果您在本地执行代码，它将不会使用配置的角色。Lambda将在您的本地SDK凭据下执行，因此本地测试Lambda可能很有用，但您需要知道您不会使用在函数托管在AWS上时将使用的相同权限来测试它。
- en: Retrieving logs
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索日志
- en: 'When a Lambda function fails due to an unhandled exception, the result will
    be a generic message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当Lambda函数由于未处理的异常而失败时，结果将是一个通用的消息：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To troubleshoot errors, we need to retrieve the execution logs. You can do
    so by appending the `--log` option to the `invoke` command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了排除错误，我们需要检索执行日志。您可以通过将`--log`选项附加到`invoke`命令来完成此操作：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It will result in an error message similar to this one:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致类似于以下错误消息的结果：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Besides using the `--log` command when invoking a function, you can retrieve
    logs from the Lambda functions that are deployed without invoking new executions.
    The command for this is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在调用函数时使用`--log`命令外，您还可以检索已部署但未调用新执行的Lambda函数的日志。此命令如下：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is a screenshot with an example of log messages:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含日志消息示例的截图：
- en: '![](img/df3592b2-dc26-4588-9874-1fafe517c916.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/df3592b2-dc26-4588-9874-1fafe517c916.png)'
- en: One problem with this feature is that you *must* specify the function name.
    You can't have a generic view of how all functions are executing, which would
    be desirable in a project with dozens of functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的一个问题是您*必须*指定函数名称。您无法以通用视图查看所有函数的执行情况，这在拥有数十个函数的项目中可能是理想的。
- en: When running in production, using the command line to watch for logs can be
    troublesome. You can reduce the amount of results using the `--filter string`
    command to show only messages that contain a specific string. This is useful in
    finding error messages, for example, using `--filter Error`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当在生产环境中运行时，使用命令行来监视日志可能会很麻烦。您可以使用`--filter string`命令来减少结果数量，只显示包含特定字符串的消息。这在查找错误消息时很有用，例如，使用`--filter
    Error`。
- en: 'The `--filter string` option is case sensitive. If you want to find error messages,
    use `--filter Error` because most exception messages will start the error word
    with an uppercase letter, for example: `ReferenceError`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`--filter string`选项是区分大小写的。如果您想查找错误消息，请使用`--filter Error`，因为大多数异常消息将以大写字母开头的错误词开始，例如：`ReferenceError`'
- en: Another option is to filter by time. You can use `--startTime time` to filter
    only the recent messages. For example, you could replace "time" with `30m` to
    see only messages that happened 30 minutes ago.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是按时间过滤。您可以使用`--startTime time`来过滤仅包含最近消息。例如，您可以将“time”替换为`30m`以查看30分钟前发生的消息。
- en: 'Take a look at the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的示例：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Also, you can add a listener that will output all new log messages received.
    In this case, you need to add the `--tail` command.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以添加一个监听器，它会输出所有接收到的新的日志消息。在这种情况下，您需要添加`--tail`命令。
- en: 'Here''s an example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding endpoints
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加端点
- en: Endpoints are the addresses that are exposed to the Internet through the API
    Gateway.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 端点是API网关暴露给互联网的地址。
- en: 'Take a look at the following steps to create an endpoint for our Lambda example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何为我们的Lambda示例创建端点：
- en: 'Endpoints are added by setting HTTP events in the `serverless.yml` file. In
    the following example, we specify that a `GET` HTTP verb used in the `my-service/resource`
    path will trigger this Lambda function:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点是通过在`serverless.yml`文件中设置HTTP事件来添加的。在以下示例中，我们指定在`my-service/resource`路径中使用的`GET`
    HTTP动词将触发此Lambda函数：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After editing the configuration file, deploy the service again using the following
    command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑配置文件后，使用以下命令再次部署服务：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Take a look at the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的截图：
- en: '![](img/41dae216-c0fe-4cc0-b6c6-521e60754489.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/41dae216-c0fe-4cc0-b6c6-521e60754489.png)'
- en: This time, in addition to the Lambda function update, the `deploy` command will
    create an API Gateway resource configured with the preceding path and method.
    In the previous chapter, we deployed an API Gateway resource that triggered a
    Lambda function, and it required a lot of steps. Do you see now how powerful the
    Serverless Framework is? If you have dozens of functions and endpoints, a single
    command is enough to deploy all of them. This automation and ease of use is what
    makes the framework so interesting.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，除了Lambda函数的更新外，`deploy`命令还将创建一个配置了先前路径和方法的API Gateway资源。在上一章中，我们部署了一个触发Lambda函数的API
    Gateway资源，这需要很多步骤。你现在看到Serverless Framework有多强大了吗？如果你有数十个函数和端点，一个命令就足以部署所有这些。这种自动化和易用性使得框架如此有趣。
- en: 'In the preceding screenshot, we can see that the framework lists the endpoint
    address that was created. It uses the following format:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到框架列出了创建的端点地址。它使用以下格式：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you use your browser to open this URL, you will see a `response` object
    containing our hello-world message. When using the API Gateway, the `event` variable
    will include much more data, adding information about headers and the request
    context. Most of this is not useful for us, but we need to use the `event` object
    to find the input data. As this is a `GET` request, we can add a query string
    to the end of the URL to pass variables values and retrieve them, looking for
    the `queryStringParameters` property inside the `event` object. Look at the following
    URL example:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用浏览器打开此URL，你将看到一个包含我们的hello-world消息的`response`对象。当使用API Gateway时，`event`变量将包含更多数据，添加有关头和请求上下文的信息。其中大部分对我们来说没有用，但我们需要使用`event`对象来找到输入数据。由于这是一个`GET`请求，我们可以在URL末尾添加一个查询字符串来传递变量值并检索它们，在`event`对象内部查找`queryStringParameters`属性。看看以下URL示例：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `?name=Serverless&foo=bar` file is the query string that will be mapped
    to a JSON object inside the `queryStringParameters` property of our `event` variable,
    as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`?name=Serverless&foo=bar`文件是映射到我们`event`变量`queryStringParameters`属性内的JSON对象的查询字符串，如下所示：'
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we are now using the API Gateway instead of invoking the Lambda function
    directly, the `event` object received will be set with different properties. In
    this case, we need to adapt our Lambda function to handle it properly. The following
    example uses `event.queryStringParameters.name` instead of `event.name`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在使用API Gateway而不是直接调用Lambda函数，接收到的`event`对象将具有不同的属性。在这种情况下，我们需要调整我们的Lambda函数以正确处理它。以下示例使用`event.queryStringParameters.name`而不是`event.name`：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To test, deploy the function again, and browse the endpoint address with the
    query string.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试，重新部署函数，并通过查询字符串浏览端点地址。
- en: We will cover other HTTP verbs in [Chapter 6](a225cec3-99da-4be5-8833-f8fdaf0aa819.xhtml),
    *Developing the Backend*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](a225cec3-99da-4be5-8833-f8fdaf0aa819.xhtml)“开发后端”中介绍其他HTTP动词。
- en: Cross-Origin Resource Sharing
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨源资源共享
- en: If you try to call this API address inside a website through an Ajax call, it
    will throw an exception. This is because **Cross-Origin Resource Sharing** (**CORS**)
    is not enabled by default in API Gateway. CORS is a mechanism that allows a resource
    to be requested from a web page hosted in another domain. By default, it is disabled
    to force administrators to give permissions for cross-domain requests only when
    it makes sense and for specific domains.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过Ajax调用在网站内部调用此API地址，它将抛出异常。这是因为API Gateway默认没有启用**跨源资源共享**（**CORS**）。CORS是一种机制，允许从另一个域托管在网页中请求资源。默认情况下，它是禁用的，以强制管理员仅在有意义且针对特定域时才为跨域请求提供权限。
- en: We are building a website that will be hosted inside AWS, but the web page will
    be accessed through our own domain, such as [www.example.com](http://www.example.com),
    and not from [www.amazonaws.com](http://www.amazonaws.com). As a result, we need
    to enable CORS to allow our frontend code to consume our services. If you have
    a Lambda function that should be accessed only by another Lambda or internal AWS
    service, CORS is not necessary.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个将托管在AWS内部的网站，但网页将通过我们自己的域名访问，例如[www.example.com](http://www.example.com)，而不是从[www.amazonaws.com](http://www.amazonaws.com)访问。因此，我们需要启用CORS，以允许我们的前端代码消费我们的服务。如果你有一个仅应由另一个Lambda或内部AWS服务访问的Lambda函数，则不需要CORS。
- en: 'To enable CORS, we need to modify our `handler.js` function to include the
    `"Access-Control-Allow-Origin"` header:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用CORS，我们需要修改我们的`handler.js`函数，以包含`"Access-Control-Allow-Origin"`头：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can add only *one* origin per function. This is a problem when we need
    to support multiple origins, and this requirement is very common. For example,
    the following addresses are considered different origins because they have different
    protocols (HTTP versus HTTPS) or different subdomains (none versus www):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为每个函数添加仅 *一个* 原因。当我们需要支持多个来源时，这是一个问题，而且这个要求非常常见。例如，以下地址被认为是不同的来源，因为它们有不同的协议（HTTP
    与 HTTPS）或不同的子域名（无与 www）：
- en: '`http://example.com`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://example.com`'
- en: '`https://example.com`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://example.com`'
- en: '`http://www.example.com`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://www.example.com`'
- en: '`https://www.example.com`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.example.com`'
- en: 'To support multiple origins, you need to use the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持多个来源，你需要使用以下命令：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Another solution, which is very common in traditional web servers, is to dynamically
    write the *response* headers based on the *request* headers that you can find
    inside the `event` object. If its origin is contained in a predefined whitelist,
    you can build the `response` object using the corresponding origin.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案，这在传统 Web 服务器中非常常见，是根据你可以在 `event` 对象中找到的 *请求* 头部动态编写 *响应* 头部。如果其来源包含在预定义的白名单中，你可以使用相应的来源构建
    `response` 对象。
- en: Removing a service
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除服务
- en: 'After finishing this example, we can delete our test function and API. The
    `remove` command will delete all AWS resources that were created, but it will
    leave the project files intact. The syntax is pretty straightforward:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此示例后，我们可以删除我们的测试函数和 API。`remove` 命令将删除创建的所有 AWS 资源，但会保留项目文件。语法相当简单：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you have deployed services to stages or regions that are not configured
    in the current version of your `serverless.yml` file, you can use the `--stage`
    and `--region` options to selectively remove them:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已将服务部署到当前 `serverless.yml` 文件版本中未配置的阶段或区域，你可以使用 `--stage` 和 `--region` 选项来选择性地删除它们：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you make a new deployment to the API Gateway, you receive an API key that
    is used to compose your API address, for example, `https://[key].execute-api.[region].amazonaws.com`.
    This key is important and will be saved into our frontend code. If you remove
    your services and recreate them again, a new key will be generated and the frontend
    key will need to be updated.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向 API Gateway 进行新的部署时，你会收到一个用于组成你的 API 地址的 API 密钥，例如，`https://[key].execute-api.[region].amazonaws.com`。这个密钥很重要，并将保存在我们的前端代码中。如果你删除服务并重新创建它们，将生成一个新的密钥，前端密钥需要更新。
- en: Going beyond the basics
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越基础
- en: In this section, we will explore what more we can do using the Serverless Framework.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨我们可以使用 Serverless Framework 做些什么。
- en: Using npm packages
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm 包
- en: When you use the Serverless Framework to deploy your Lambda function, it creates
    a ZIP file with everything that is inside your project folder. If you need to
    use a module that is not a Node.js core module or the AWS SDK, you just need to
    use Node's default workflow to add dependencies.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Serverless Framework 部署你的 Lambda 函数时，它会创建一个包含项目文件夹内所有内容的 ZIP 文件。如果你需要使用不是
    Node.js 核心模块或 AWS SDK 的模块，你只需使用 Node 的默认工作流程来添加依赖项。
- en: 'Take a look at the following steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下步骤：
- en: Create a `package.json` file to store your project dependencies and use `npm
    install <your-module> --save` to download your required module.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `package.json` 文件来存储你的项目依赖项，并使用 `npm install <your-module> --save` 下载你的所需模块。
- en: With the `node_modules` folder inside your project directory, the ZIP file will
    be deployed to AWS with the necessary dependencies.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目目录中包含 `node_modules` 文件夹时，ZIP 文件将带有必要的依赖项部署到 AWS。
- en: 'In the following example, the Lambda function of the file `handle.js` uses
    an npm module called `cat-names`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下示例中，文件 `handle.js` 的 Lambda 函数使用了一个名为 `cat-names` 的 npm 模块：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The framework will zip everything that it finds inside the project folder,
    except what you configure in the `serverless.yml` file to be ignored. The following
    example uses the `package` configuration to remove some files that are commonly
    present in a project folder, but that should never be included in the ZIP file:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 框架会压缩项目文件夹内找到的所有内容，除了你在 `serverless.yml` 文件中配置为忽略的内容。以下示例使用 `package` 配置来移除一些在项目文件夹中常见但不应包含在
    ZIP 文件中的文件：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Hidden files and folders are not included in the ZIP package by default, for
    example, the `.gitignore` file and the `.serverless` folder, which are part of
    serverless projects, don't need to be explicitly excluded.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，隐藏的文件和文件夹不包括在 ZIP 包中，例如，`.gitignore` 文件和 `.serverless` 文件夹，它们是 serverless
    项目的组成部分，不需要显式排除。
- en: 'To test, just deploy and invoke the `catNames` function by using the following
    command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试，只需使用以下命令部署并调用 `catNames` 函数：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Accessing other AWS resources
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问其他 AWS 资源
- en: By default, Lambda functions execute without any permissions. If you want to
    access S3 buckets, DynamoDB tables, or any kind of Amazon resource, your user
    must have access to them and you must give explicit permissions to your service.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Lambda 函数执行时没有任何权限。如果您想访问 S3 桶、DynamoDB 表或任何类型的 Amazon 资源，您的用户必须有权访问它们，并且您必须为您的服务明确授予权限。
- en: 'This configuration is done in the `serverless.yml` file under the `provider`
    tag. The following example shows you how to give permissions to an S3 bucket:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置在 `serverless.yml` 文件中的 `provider` 标签下完成。以下示例展示了如何为 S3 桶授予权限：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To test this statement, we can modify our `handle.js` file to write and read
    files using the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此语句，我们可以修改我们的 `handle.js` 文件，使用以下代码写入和读取文件：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, we are writing a file that contains the `Test` string to a
    bucket and, after finishing the writing, we read the same file and return its
    contents in our response.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将包含 `Test` 字符串的文件写入一个桶中，并在写入完成后，读取相同的文件并返回其内容到我们的响应中。
- en: Events
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'The Serverless Framework currently supports the following events:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework 当前支持以下事件：
- en: '**Amazon API Gateway**: This creates RESTful interfaces by triggering Lambda
    functions through HTTP messages'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon API Gateway**：通过触发 Lambda 函数通过 HTTP 消息创建 RESTful 接口'
- en: '**Amazon S3**: This triggers functions for post-processing when a new file
    is added or to take an action when a file is removed'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon S3**：当添加新文件或删除文件时触发后处理函数'
- en: '**Amazon SNS**: This handles SNS notifications with Lambda functions'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon SNS**：使用 Lambda 函数处理 SNS 通知'
- en: '**Schedule**: This triggers functions based on scheduled tasks'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Schedule**：根据计划任务触发函数'
- en: '**Amazon DynamoDB**: This triggers a function when a new entry is added to
    a table'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon DynamoDB**：当向表中添加新条目时触发函数'
- en: '**Amazon Kinesis**: This uses Lambda functions to process Kinesis streams'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon Kinesis**：使用 Lambda 函数处理 Kinesis 流'
- en: '**Amazon Alexa**: This triggers functions with Alexa Skills'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon Alexa**：使用 Alexa 技能触发函数'
- en: '**AWS IoT**: This handles messages sent to IoT topics'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS IoT**：处理发送到 IoT 主题的消息'
- en: '**Amazon CloudWatch**: This handles CloudWatch events and log messages using
    Lambda functions'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon CloudWatch**：使用 Lambda 函数处理 CloudWatch 事件和日志消息'
- en: In this list, there are only two services that we haven't seen yet. The first
    one is Amazon Kinesis, which is a service created to process and analyze streaming
    data generated by different sources, and the other one is Amazon Alexa, which
    is Amazon's intelligent personal assistant. Both of them are beyond the scope
    of this book.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中，只有两个我们尚未见过的服务。第一个是 Amazon Kinesis，这是一个创建用于处理和分析由不同来源生成的流数据的服务的服务，另一个是
    Amazon Alexa，这是亚马逊的智能个人助理。这两个服务都超出了本书的范围。
- en: 'We will not cover all event types because the list is extensive, and each one
    of them requires different configurations. You can see how to use them in the
    official documentation at [https://serverless.com/framework/docs/providers/aws/events](https://serverless.com/framework/docs/providers/aws/events).
    In this chapter, we have already exemplified the API Gateway by creating an endpoint
    for our Lambda function. Now, we will take a look at two more examples: one for
    Amazon S3, to see how easy it is to create S3 events in comparison to the example
    from the previous chapter, and the other example is to **Schedule** triggers,
    which are very useful in running scheduled tasks.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖所有事件类型，因为列表很长，并且每个都需要不同的配置。您可以在官方文档中查看如何使用它们：[https://serverless.com/framework/docs/providers/aws/events](https://serverless.com/framework/docs/providers/aws/events)。在本章中，我们已经通过为
    Lambda 函数创建端点来举例说明了 API Gateway。现在，我们将查看两个更多示例：一个用于 Amazon S3，以查看与上一章示例相比创建 S3
    事件有多容易，另一个示例是**调度**触发器，这在运行计划任务时非常有用。
- en: The S3 event
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: S3 事件
- en: 'In the previous chapter, we configured S3 to trigger a Lambda function when
    a new file is added to a bucket and its name matches certain rules. The same configuration
    can be applied here using the following configuration in our `serverless.yml`
    file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们配置了 S3，当向桶中添加新文件且其名称符合某些规则时，触发 Lambda 函数。可以使用以下配置在我们的 `serverless.yml`
    文件中应用相同的配置：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The bucket name needs to be a new one. Due to limitations, you can't add events
    to an existing bucket.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 桶名称需要是新的。由于限制，您不能向现有桶添加事件。
- en: Schedule events
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度事件
- en: 'Scheduling Lambda executions is a very important feature for many use cases.
    This setup is easily done by the framework by modifying the `serverless.yml` file
    using the `schedule` event. In the next example, the `processTask` function will
    be executed every 15 minutes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 执行的调度是一个对许多用例非常重要的功能。通过修改 `serverless.yml` 文件并使用 `schedule` 事件，这个设置可以很容易地通过框架完成。在下一个示例中，`processTask`
    函数将每15分钟执行一次：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This setting accepts either the `rate` or `cron` expression.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置接受 `rate` 或 `cron` 表达式。
- en: 'The `cron` syntax is compounded by six required fields in the following order:
    `Minutes | Hours | Day-of-month | Month | Day-of-week | Year`. In the next example,
    the `cron` expression is used to schedule a function to run from Monday to Friday
    at 9:00 am (UTC):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下顺序中，`cron` 语法由六个必需字段组成：`分钟 | 小时 | 月份中的日期 | 月份 | 星期几 | 年份`。在下一个示例中，`cron`
    表达式用于安排一个函数在星期一到星期五上午9:00（UTC）运行：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Take a look at the following link for more details about this setting:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以获取有关此设置的更多详细信息：
- en: '[http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html](http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html](http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html)'
- en: Serving HTML pages with Lambda
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lambda 提供HTML页面
- en: 'A very common misunderstanding is that Lambda was designed to serve only JSON
    data. That''s not true. As we have control over the response result, we can properly
    set the headers to serve HTML content. This is exemplified in the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的误解是 Lambda 只是为服务 JSON 数据而设计的。这并不正确。由于我们控制响应结果，我们可以正确设置头部来服务 HTML 内容。以下代码展示了这一点：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This approach can be useful for server-side rendering. In [Chapter 5](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml),
    *Building the Frontend*, we will discuss Single-Page Applications, which use client-side
    rendering, and traditional web applications, which use server-side rendering.
    Serverless supports both models and it is up to the developer to choose the option
    that best suits their use case.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于服务器端渲染非常有用。在 [第5章](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml)，*构建前端*，我们将讨论使用客户端渲染的单页应用程序和使用服务器端渲染的传统Web应用程序。Serverless
    支持这两种模型，开发者需要根据他们的用例选择最佳选项。
- en: Using configuration variables
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配置变量
- en: The Serverless Framework allows the usage of variables in our `serverless.yml`
    configuration file. This flexibility is useful in centralizing configurations
    that can be referenced at multiple places.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless 框架允许我们在 `serverless.yml` 配置文件中使用变量。这种灵活性在集中配置时非常有用，这些配置可以在多个地方引用。
- en: 'There are many options for using variables. Let''s try them out by editing
    our configuration file:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量的选项有很多。让我们通过编辑我们的配置文件来尝试它们：
- en: '**Reference environment variables**:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用环境变量**：'
- en: 'Take a look at the environment variable used in the following code snippet:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码片段中使用的环境变量：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Load variables from CLI options**:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从 CLI 选项加载变量**：'
- en: 'Take a look at the local variable used in the following code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码片段中使用的局部变量：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Store variables in another configuration file**:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将变量存储在另一个配置文件中**：'
- en: 'Take a look at the usage of a variable defined in another file in the following
    code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码片段中在其他文件中定义的变量的使用情况：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Plugins
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件
- en: An interesting feature offered by the Serverless Framework is that it is extendable
    through plugins. You can use plugins for new CLI commands or functionalities that
    will be executed by hooking into existing commands.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless 框架提供的一个有趣的功能是它可以通过插件进行扩展。您可以使用插件来创建新的 CLI 命令或功能，这些命令将通过挂钩到现有命令来执行。
- en: To show how useful they can be, we will test a serverless plugin that supports
    Lambda development with TypeScript. When we execute the `deploy` command, the
    plugin will compile the code and create a JavaScript version that will be zipped
    and used by Lambda with the Node.js runtime.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示它们如何有用，我们将测试一个支持使用 TypeScript 进行 Lambda 开发的无服务器插件。当我们执行 `deploy` 命令时，该插件将编译代码并创建一个
    JavaScript 版本，该版本将被压缩并由 Lambda 使用 Node.js 运行时使用。
- en: 'To add this plugin to our project, we need to proceed with the following steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此插件添加到我们的项目中，我们需要按照以下步骤进行：
- en: 'Install the plugin using npm:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 npm 安装插件：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the plugin reference to the end of our `serverless.yml` file:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将插件引用添加到我们的 `serverless.yml` 文件末尾：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Write a TypeScript file and save it with the name `handler.ts`, as shown in
    the following code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 TypeScript 文件，并将其保存为 `handler.ts`，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Deploy and test using the following command:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令进行部署和测试：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Showing deployment information
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示部署信息
- en: 'If you want to know what functions were deployed and their related endpoints,
    you can use the `info` command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道部署了哪些函数以及它们的相关端点，你可以使用`info`命令：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following screenshot shows this command output:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此命令的输出：
- en: '![](img/efb9f3c1-1ad9-4c71-9884-0c2c28ead25e.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efb9f3c1-1ad9-4c71-9884-0c2c28ead25e.png)'
- en: Scaffolding
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建
- en: Scaffolding is a technique that helps developers by providing a sample solution
    for a common problem. With a *boilerplate*, you can build a new project, taking
    advantage of the fact that some features are already configured, developed, and
    well tested. You start modifying the solution to meet your own requirements following
    the practices recommended by someone who has more experience than you with this
    technology and using a code that was used, tested, and improved by a lot of different
    people. This is the benefit of using open source projects. Also, it's a useful
    way to learn a new technology through *imitation*. You learn by seeing how someone
    else has solved the problem that you want to solve.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 搭建是一种帮助开发者的技术，它通过提供一个常见问题的示例解决方案来帮助开发者。使用*样板代码*，你可以构建一个新的项目，利用一些功能已经配置、开发和经过良好测试的事实。你开始修改解决方案以满足自己的需求，遵循比你在这个技术方面更有经验的人推荐的实践，并使用被许多人使用、测试和改进的代码。这是使用开源项目的优势。此外，这也是通过*模仿*学习新技术的一个有用方法。你通过观察别人如何解决你想要解决的问题来学习。
- en: 'Let''s perform the following steps to scaffold a project:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤搭建一个项目：
- en: 'To scaffold a project, run the following command:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要搭建一个项目，请运行以下命令：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For example, you can run the following command to scaffold a serverless service
    to send e-mails:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，你可以运行以下命令来搭建一个用于发送电子邮件的无服务器服务：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The Serverless Framework team maintains an extensive list of useful examples.
    Check it out by visiting [https://github.com/serverless/examples](https://github.com/serverless/examples).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器框架团队维护了一个包含大量有用示例的列表。您可以通过访问[https://github.com/serverless/examples](https://github.com/serverless/examples)来查看。
- en: 'The objective of this book is to build a sample serverless store. You can find
    all code that was developed with this objective on GitHub at [https://github.com/zanon-io/serverless-store](https://github.com/zanon-io/serverless-store).
    This project can also be scaffolded using the same command:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这本书的目标是构建一个示例无服务器商店。你可以在这个目标下在GitHub上找到所有开发的代码[https://github.com/zanon-io/serverless-store](https://github.com/zanon-io/serverless-store)。该项目也可以使用相同的命令进行搭建：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `\` (backslash) character in this command was added because the command
    doesn't fit in one line. It is optional and works for Linux and macOS. On Windows,
    the `^` (caret) is the corresponding symbol.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中添加了反斜杠（`\`）字符，因为命令无法在一行中显示。这是可选的，适用于Linux和macOS。在Windows上，相应的符号是`^`（符号）。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what the Serverless Framework is and how it will
    help us to build serverless applications. After configuring the framework, you
    have created a hello-world service, added endpoints, enabled CORS, and deployed
    it to be accessed through a public URL. You also learned how to add npm packages
    and access AWS resources.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了无服务器框架是什么以及它将如何帮助我们构建无服务器应用程序。在配置框架后，你创建了一个hello-world服务，添加了端点，启用了CORS，并将其部署为可通过公共URL访问。你还学习了如何添加npm包和访问AWS资源。
- en: In the next chapter, we will host the frontend following the serverless concept.
    This will be done using Amazon S3, and we will configure a CloudFront distribution
    to add a free TLS certificate to support HTTPS connections.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将根据无服务器概念托管前端。这将是使用Amazon S3完成的，我们将配置一个CloudFront分发，以添加一个免费的TLS证书来支持HTTPS连接。
