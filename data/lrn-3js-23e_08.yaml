- en: Chapter 8. Creating and Loading Advanced Meshes and Geometries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。创建和加载高级网格和几何形状
- en: 'In this chapter, we''ll look at a couple of different ways that you can create
    advanced and complex geometries and meshes. In [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*, and [Chapter 6](ch06.html
    "Chapter 6. Advanced Geometries and Binary Operations"), *Advanced Geometries
    and Binary Operations* ,we showed you how to create a few advanced geometries
    using the built-in objects from Three.js. In this chapter, we''ll use the following
    two approaches to create advanced geometries and meshes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几种不同的方法，您可以使用这些方法创建高级和复杂的几何形状和网格。在[第5章](ch05.html "第5章。学习与几何形状一起工作")“学习与几何形状一起工作”和[第6章](ch06.html
    "第6章。高级几何形状和二进制操作")“高级几何形状和二进制操作”中，我们向您展示了如何使用Three.js的内置对象创建一些高级几何形状。在本章中，我们将使用以下两种方法来创建高级几何形状和网格：
- en: '**Grouping and merging**: The first approach we explain uses built-in functionality
    from Three.js to group and merge existing geometries. This creates new meshes
    and geometries from existing objects.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分组和合并**: 我们解释的第一个方法使用Three.js的内置功能来分组和合并现有的几何形状。这从现有对象中创建新的网格和几何形状。'
- en: '**Loading from external**: In this section, we''ll explain how you can load
    meshes and geometries from external sources. For instance, we''ll show you how
    you can use Blender to export meshes in a format Three.js supports.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从外部加载**: 在本节中，我们将解释如何从外部来源加载网格和几何形状。例如，我们将向您展示如何使用Blender导出Three.js支持的网格格式。'
- en: We start with the *group and merge* approach. With this approach, we use the
    standard Three.js grouping and the `THREE.Geometry.merge()` function to create
    new objects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍*分组和合并*方法。使用这种方法，我们使用标准的Three.js分组和`THREE.Geometry.merge()`函数来创建新对象。
- en: Geometry grouping and merging
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何形状分组和合并
- en: 'In this section, we''ll look at two basic features of Three.js: grouping objects
    together and merging multiple meshes into a single mesh. We''ll start with grouping
    objects.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Three.js的两个基本功能：将对象分组在一起以及将多个网格合并成一个网格。我们将从分组对象开始。
- en: Grouping objects together
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象分组
- en: In some of the previous chapters, you already saw this when working with multiple
    materials. When you create a mesh from a geometry using multiple materials, Three.js
    creates a group. Multiple copies of your geometry are added to this group, each
    with their own specific material. This group is returned, so it looks like a mesh
    that uses multiple materials. In truth, however, it is a group that contains a
    number of meshes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些前面的章节中，您在处理多个材质时已经看到了这一点。当您使用多个材质从几何形状创建网格时，Three.js会创建一个组。您的几何形状的多个副本被添加到这个组中，每个副本都有其特定的材质。这个组被返回，所以它看起来像是一个使用多个材质的网格。然而，实际上，它是一个包含多个网格的组。
- en: 'Creating groups is very easy. Every mesh you create can contain child elements,
    which can be added using the add function. The effect of adding a child object
    to a group is that you can move, scale, rotate, and translate the parent object,
    and all the child objects will also be affected. Let''s look at an example (`01-grouping.html`).
    The following screenshot shows this example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组非常简单。您创建的每个网格都可以包含子元素，这些子元素可以通过add函数添加。将子对象添加到组中的效果是您可以移动、缩放、旋转和平移父对象，所有子对象也会受到影响。让我们看一个例子（`01-grouping.html`）。以下截图显示了此示例：
- en: '![Grouping objects together](img/2215OS_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![将对象分组在一起](img/2215OS_08_01.jpg)'
- en: 'In this example, you can use the menu to move the sphere and the cube around.
    If you check the **rotate** option, you''ll see these two meshes rotating around
    their center. This isn''t anything new and is not very exciting. However, these
    two objects haven''t been added to the scene directly, but have been added as
    a group. The following code encapsulates this discussion:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以使用菜单移动球体和立方体。如果您勾选**旋转**选项，您将看到这两个网格围绕它们的中心旋转。这并不是什么新东西，也不是很令人兴奋。然而，这两个对象并没有直接添加到场景中，而是作为组添加的。以下代码封装了这次讨论：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code snippet, you can see that we create `THREE.Object3D`. This is the
    base class of `THREE.Mesh` and `THREE.Scene`, but by itself, it doesn't contain
    anything or cause anything to be rendered. Note that in the latest version of
    Three.js, a new object called `THREE.Group` was introduced to support grouping.
    This object is exactly the same as a `THREE.Object3D` object, and you can replace
    `new THREE.Object3D()` in the previous code with `new THREE.Group()` for the same
    effect. In this example, we use the `add` function to add the `sphere` and `cube`
    to this object, and then we add it to the `scene`. If you look at the example,
    you can still move the cube and sphere around and scale and rotate these two objects.
    You can also do these things on the group they are in. If you look at the group
    menu, you'll see position and scale options. You can use these to scale and move
    the entire group around. The scale and position of the objects inside this group
    are relative to the scale and position of the group itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你可以看到我们创建了`THREE.Object3D`。这是`THREE.Mesh`和`THREE.Scene`的基础类，但本身并不包含任何内容或导致任何渲染。请注意，在Three.js的最新版本中，引入了一个名为`THREE.Group`的新对象来支持分组。这个对象与`THREE.Object3D`对象完全相同，你可以在之前的代码中将`new
    THREE.Object3D()`替换为`new THREE.Group()`以获得相同的效果。在这个例子中，我们使用`add`函数将`sphere`和`cube`添加到这个对象中，然后将其添加到`scene`中。如果你查看示例，你仍然可以移动立方体和球体，并缩放和旋转这两个对象。你还可以在它们所在的组上执行这些操作。如果你查看组菜单，你会看到位置和缩放选项。你可以使用这些选项来缩放和移动整个组。这个组内对象的缩放和位置相对于组的缩放和位置。
- en: 'Scale and position are very straightforward. One thing to keep in mind, though,
    is that when you rotate a group, it doesn''t rotate the objects inside it separately;
    it rotates the entire group around its own center (in our example, you rotate
    the entire group around the center of the `group` object). In this example, we
    placed an arrow using the `THREE.ArrowHelper` object at the center of the group
    to indicate the rotation point:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放和位置非常直接。不过，需要注意的是，当你旋转一个组时，它不会分别旋转组内的对象；它会围绕组自己的中心旋转整个组（在我们的例子中，你围绕`group`对象的中心旋转整个组）。在这个例子中，我们使用`THREE.ArrowHelper`对象在组的中心放置了一个箭头，以指示旋转点：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you check both the **grouping** and **rotate** checkboxes, the group will
    rotate. You''ll see the sphere and cube rotating around the center of the group
    (indicated by the arrow), as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时勾选**分组**和**旋转**复选框，该组将会旋转。你会看到球体和立方体围绕组的中心（由箭头指示）旋转，如下所示：
- en: '![Grouping objects together](img/2215OS_08_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![将对象分组在一起](img/2215OS_08_02.jpg)'
- en: When using a group, you can still refer to, modify, and position the individual
    geometries. The only thing you need to remember is that all positions, rotations,
    and translations are done relative to the parent object. In the next section,
    we'll look at merging, where you'll combine multiple separate geometries and end
    up with a single `THREE.Geometry` object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一个组时，你仍然可以引用、修改和定位单个几何体。你需要记住的唯一一点是，所有位置、旋转和平移都是相对于父对象进行的。在下一节中，我们将探讨合并，在那里你将结合多个单独的几何体，最终得到一个单一的`THREE.Geometry`对象。
- en: Merging multiple meshes into a single mesh
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多个网格合并成一个网格
- en: 'In most cases, using groups allows you to easily manipulate and manage a large
    number of meshes. When you''re dealing with a very large number of objects, however,
    performance will become an issue. With groups, you''re still working with individual
    objects that each need to be handled and rendered separately. With `THREE.Geometry.merge()`,
    you can merge geometries together and create a combined one. In the following
    example, you can see how this works and the effect it has on performance. If you
    open the `02-merging.html` example, you see a scene with a set of randomly distributed
    semitransparent cubes. With the slider in the menu, you can set the number of
    cubes you want in the scene and redraw the scene by clicking on the **redraw**
    button. Depending on the hardware you''re running on, you''ll see a performance
    degradation as the number of cubes increases. In our case, as you can see in the
    following screenshot, this happens at around 4,000 objects, where the refresh
    rate drops to around 40 fps instead of the normal 60 fps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用组可以让你轻松地操作和管理大量网格。然而，当你处理一个非常大的对象数量时，性能将成为一个问题。使用组时，你仍然是在处理单个对象，每个对象都需要单独处理和渲染。通过`THREE.Geometry.merge()`，你可以将几何体合并在一起，创建一个组合的几何体。在下面的示例中，您可以了解这是如何工作的以及它对性能的影响。如果您打开`02-merging.html`示例，您会看到一个场景，其中包含一组随机分布的半透明立方体。通过菜单中的滑块，您可以设置场景中想要的立方体数量，并通过点击**重绘**按钮重新绘制场景。根据您所运行的硬件，您会看到随着立方体数量的增加，性能会下降。在我们的案例中，如您在下面的截图中所见，这发生在大约4,000个对象时，刷新率下降到大约40
    fps，而不是正常的60 fps：
- en: '![Merging multiple meshes into a single mesh](img/2215OS_08_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![将多个网格合并成一个网格](img/2215OS_08_03.jpg)'
- en: 'As you can see, there is a certain limit to the number of meshes you can add
    to the scene. Normally, though, you probably wouldn''t need that many meshes,
    but when creating specific games (for example, something like *Minecraft*) or
    advanced visualizations, you might need to manage a large number of individual
    meshes. With `THREE.Geometry.merge()`, you can solve this problem. Before we look
    at the code, let''s run this same example, but this time, with the **combine**
    box checked. With this option flagged, we merge all the cubes into a single `THREE.Geometry`
    and add that one instead, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以添加到场景中的网格数量有一定的限制。不过，通常情况下，你可能不需要那么多网格，但在创建特定游戏（例如，类似于*我的世界*）或高级可视化时，你可能需要管理大量单独的网格。通过`THREE.Geometry.merge()`，你可以解决这个问题。在我们查看代码之前，让我们运行这个相同的示例，但这次，将**组合**框勾选上。使用这个选项标记后，我们将所有立方体合并成一个单一的`THREE.Geometry`，并添加这个单一的几何体，如下面的截图所示：
- en: '![Merging multiple meshes into a single mesh](img/2215OS_08_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![将多个网格合并成一个网格](img/2215OS_08_04.jpg)'
- en: 'As you can see, we can easily render 20,000 cubes without any drop in performance.
    To do this, we use the following couple of lines of code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们能够轻松渲染20,000个立方体而不会出现性能下降。为此，我们使用了以下几行代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code snippet, the `addCube()` function returns `THREE.Mesh`. In older
    versions of Three.js, we could use the `THREE.GeometryUtils.merge` function to
    also merge `THREE.Mesh` objects into `THREE.Geometry` objects. With the latest
    version, this functionality has been deprecated in favor of the `THREE.Geometry.merge`
    function. To make sure the merged-in `THREE.Geometry` object is positioned and
    rotated correctly, we not only provide `THREE.Geometry` to the `merge` function,
    but also its transformation matrix. When we add this matrix to the `merge` function,
    the cube we merge in will be positioned correctly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`addCube()`函数返回`THREE.Mesh`。在Three.js的旧版本中，我们可以使用`THREE.GeometryUtils.merge`函数将`THREE.Mesh`对象合并到`THREE.Geometry`对象中。在最新版本中，这个功能已经被弃用，转而使用`THREE.Geometry.merge`函数。为了确保合并的`THREE.Geometry`对象定位和旋转正确，我们不仅向`merge`函数提供了`THREE.Geometry`，还提供了其变换矩阵。当我们向`merge`函数添加这个矩阵时，合并进来的立方体将被正确定位。
- en: We do this 20,000 times and are left with a single geometry that we add to the
    scene. If you look at the code, you can probably see a couple of drawbacks of
    this approach. Since you're left with a single geometry, you can't apply a material
    to each individual cube. This, however, can be somewhat solved using `THREE.MeshFaceMaterial`.
    The biggest drawback, however, is that you lose control over the individual cubes.
    If you want to move, rotate, or scale a single cube, you can't (unless you search
    for the correct faces and vertices and position them individually).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做20,000次，最终只保留一个几何形状并将其添加到场景中。如果您查看代码，您可能可以看到这种方法的几个缺点。由于您只剩下一个几何形状，因此您不能为每个单独的立方体应用材质。然而，这可以通过使用`THREE.MeshFaceMaterial`在一定程度上解决。然而，最大的缺点是您失去了对单个立方体的控制。如果您想移动、旋转或缩放单个立方体，您不能（除非您搜索正确的面和顶点并单独定位它们）。
- en: With the grouping and merging approach, you can create large and complex geometries
    using the basic geometries provided by Three.js. If you want to create more advanced
    geometries, then using the programmatic approach provided by Three.js isn't always
    the best and easiest option. Three.js, luckily, offers a couple of other options
    to create geometries. In the next section, we'll look at how you can load geometries
    and meshes from external resources.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分组和合并方法，您可以使用Three.js提供的基本几何形状创建大型且复杂的几何形状。如果您想创建更高级的几何形状，那么使用Three.js提供的编程方法并不总是最佳和最简单的方法。幸运的是，Three.js提供了一些其他选项来创建几何形状。在下一节中，我们将探讨如何从外部资源加载几何形状和网格。
- en: Loading geometries from external resources
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从外部资源加载几何形状
- en: 'Three.js can read a number of 3D file formats and import geometries and meshes
    defined in those files. The following table shows the file formats that are supported
    by Three.js:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js可以读取多种3D文件格式，并导入那些文件中定义的几何形状和网格。以下表格显示了Three.js支持的文件格式：
- en: '| Format | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 格式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| JSON | Three.js has its own JSON format you can use to declaratively define
    a geometry or a scene. Even though this isn''t an official format, it''s very
    easy to use and comes in very handy when you want to reuse complex geometries
    or scenes. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| JSON | Three.js有其自己的JSON格式，您可以使用它声明性地定义几何形状或场景。尽管这不是一个官方格式，但它非常易于使用，当您想要重用复杂的几何形状或场景时非常有用。'
- en: '| OBJ or MTL | OBJ is a simple 3D format first developed by **Wavefront Technologies**.
    It''s one of the most widely adopted 3D file formats and is used to define the
    geometry of an object. MTL is a companion format to OBJ. In an MTL file, the material
    of the objects in an OBJ file is specified.Three.js also has a custom OBJ exporter,
    called OBJExporter.js, should you want to export your models to OBJ from Three.js.
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| OBJ或MTL | OBJ是一种简单的3D格式，最初由**Wavefront Technologies**开发。它是被广泛采用的3D文件格式之一，用于定义对象的几何形状。MTL是OBJ的配套格式。在MTL文件中，OBJ文件中对象的材质被指定。如果需要从Three.js导出模型到OBJ格式，Three.js也提供了一个自定义的OBJ导出器，称为OBJExporter.js。
    |'
- en: '| Collada | Collada is a format for defining *digital assets* in an XML-based
    format. This is also a widely used format that is supported by pretty much all
    3D applications and rendering engines. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Collada | Collada是一种基于XML格式的定义*数字资产*的格式。这也是一个广泛使用的格式，几乎所有的3D应用程序和渲染引擎都支持它。
    |'
- en: '| STL | **STL** stands for **STereoLithography** and is widely used for rapid
    prototyping. For instance, models for 3D printers are often defined as STL files.Three.js
    also has a custom STL exporter, called STLExporter.js, should you want to export
    your models to STL from Three.js. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| STL | **STL**代表**立体光刻**，广泛用于快速原型制作。例如，3D打印机的模型通常定义为STL文件。Three.js也提供了一个自定义的STL导出器，称为STLExporter.js，如果您想从Three.js导出模型到STL格式。
    |'
- en: '| CTM | CTM is a file format created by **openCTM**. It''s used as a format
    for storing 3D triangle-based meshes in a compact format. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| CTM | CTM是由**openCTM**创建的文件格式。它用作以紧凑格式存储基于3D三角形的网格的格式。 |'
- en: '| VTK | VTK is the file format defined by **Visualization Toolkit** and is
    used to specify vertices and faces. There are two formats available: a binary
    one and a text-based ASCII one. Three.js only supports the ASCII-based format.
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| VTK | VTK是由**Visualization Toolkit**定义的文件格式，用于指定顶点和面。有两种格式可供选择：一种是基于二进制的，另一种是基于文本的ASCII格式。Three.js仅支持基于ASCII的格式。
    |'
- en: '| AWD | AWD is a binary format for 3D scenes and is most often used with the
    [http://away3d.com/](http://away3d.com/) engine. Note that this loader doesn''t
    support compressed AWD files. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| AWD | AWD是3D场景的二进制格式，通常与[http://away3d.com/](http://away3d.com/)引擎一起使用。请注意，此加载器不支持压缩的AWD文件。
    |'
- en: '| Assimp | Open asset import library (also called **Assimp**) is a standard
    way to import various 3D model formats. With this loader, you can import models
    from a large range of 3D formats that have been converted using **assimp2json**,
    details of which are available at [https://github.com/acgessler/assimp2json](https://github.com/acgessler/assimp2json).
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Assimp | Open asset import library（也称为**Assimp**）是一种导入各种 3D 模型格式的标准方式。使用此加载器，你可以导入使用
    **assimp2json** 转换的多种 3D 格式的模型。详细信息请参阅 [https://github.com/acgessler/assimp2json](https://github.com/acgessler/assimp2json)。|'
- en: '| VRML | **VRML** stands for **Virtual Reality Modeling Language**. This is
    a text-based format that allows you to specify 3D objects and worlds. It has been
    superseded by the X3D file format. Three.js doesn''t support loading X3D models,
    but these models can be easily converted to other formats. More information can
    be found at [http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#).
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| VRML | **VRML**代表**虚拟现实建模语言**。这是一种基于文本的格式，允许你指定 3D 对象和世界。它已被 X3D 文件格式取代。Three.js
    不支持加载 X3D 模型，但这些模型可以轻松转换为其他格式。更多信息请参阅 [http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#)。|'
- en: '| Babylon | Babylon is a 3D JavaScript game library. It stores models in its
    own internal format. More information about this can be found at [http://www.babylonjs.com/](http://www.babylonjs.com/).
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Babylon | Babylon 是一个 3D JavaScript 游戏库。它使用自己的内部格式存储模型。更多关于这个的信息可以在 [http://www.babylonjs.com/](http://www.babylonjs.com/)
    找到。|'
- en: '| PDB | This is a very specialized format, created by **Protein Data Bank**,
    that is used to specify what proteins look like. Three.js can load and visualize
    proteins specified in this format. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| PDB | 这是一个非常专业的格式，由**蛋白质数据银行**创建，用于指定蛋白质的外观。Three.js 可以加载并可视化指定在此格式下的蛋白质。|'
- en: '| PLY | This format is called the **Polygon** file format. This is most often
    used to store information from 3D scanners. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| PLY | 这种格式被称为**多边形**文件格式。这通常用于存储来自 3D 扫描仪的信息。|'
- en: In the next chapter, we'll revisit some of these formats (and look at two additional
    ones, MD2 and glTF) when we look at animations. For now, we start with the first
    one on the list, the internal format of Three.js.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我们讨论动画时，我们将重新审视这些格式（并查看另外两种格式，MD2 和 glTF）。现在，我们首先从列表中的第一个开始，即 Three.js
    的内部格式。
- en: Saving and loading in Three.js JSON format
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Three.js JSON 格式下保存和加载
- en: You can use Three.js' JSON format for two different scenarios in Three.js. You
    can use it to save and load a single `THREE.Mesh`, or you can use it to save and
    load a complete scene.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中，你可以使用其 JSON 格式处理两种不同的场景。你可以用它来保存和加载单个 `THREE.Mesh`，或者用它来保存和加载一个完整的场景。
- en: Saving and loading THREE.Mesh
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和加载 THREE.Mesh
- en: To demonstrate saving and loading, we created a simple example based on `THREE.TorusKnotGeometry`.
    With this example, you can create a torus knot, just like we did in [Chapter 5](ch05.html
    "Chapter 5. Learning to Work with Geometries"), *Learning to Work with Geometries*,
    and using the **save** button from the **Save & Load** menu, you can save the
    current geometry. For this example, we save using the HTML5 local storage API.
    This API allows us to easily store persistent information in the client's browser
    and retrieve it at a later time (even after the browser has been shut down and
    restarted).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示保存和加载，我们创建了一个基于 `THREE.TorusKnotGeometry` 的简单示例。通过这个示例，你可以创建一个环面结，就像我们在
    [第 5 章](ch05.html "第 5 章。学习与几何体一起工作") 中所做的那样，*学习与几何体一起工作*，并使用 **Save & Load**
    菜单中的 **save** 按钮保存当前几何体。对于这个示例，我们使用 HTML5 本地存储 API 进行保存。此 API 允许我们轻松地在客户端浏览器中存储持久信息，并在稍后时间检索它（即使在浏览器关闭并重新启动之后）。
- en: 'We will look at the `03-load-save-json-object.html` example. The following
    screenshot shows this example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看 `03-load-save-json-object.html` 示例。以下截图显示了此示例：
- en: '![Saving and loading THREE.Mesh](img/2215OS_08_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![保存和加载 THREE.Mesh](img/2215OS_08_05.jpg)'
- en: 'Exporting in JSON from Three.js is very easy and doesn''t require you to include
    any additional libraries. The only thing you need to do to export `THREE.Mesh`
    as JSON is the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Three.js 导出 JSON 非常简单，不需要你包含任何额外的库。要将 `THREE.Mesh` 导出为 JSON，你需要做以下操作：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before saving it, we first convert the result from the `toJSON` function, a
    JavaScript object, to a string using the `JSON.stringify` function. This results
    in a JSON string that looks like this (most of the vertices and faces are left
    out):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存之前，我们首先使用 `JSON.stringify` 函数将 `toJSON` 函数的结果，一个 JavaScript 对象，转换为字符串。这会产生一个看起来像这样的
    JSON 字符串（大多数顶点和面都被省略了）：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, Three.js saves all the information about `THREE.Mesh`. To save
    this information using the HTML5 local storage API, all we have to do is call
    the `localStorage.setItem` function. The first argument is the key value (`json`)
    that we can later use to retrieve the information we passed in as the second argument.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Three.js 保存了关于 `THREE.Mesh` 的所有信息。要使用 HTML5 本地存储 API 保存这些信息，我们只需要调用 `localStorage.setItem`
    函数。第一个参数是键值（`json`），我们可以稍后使用它来检索我们作为第二个参数传递的信息。
- en: 'Loading `THREE.Mesh` back into Three.js also requires just a couple of lines
    of code, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `THREE.Mesh` 重新加载到 Three.js 中也只需要几行代码，如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we first get the JSON from local storage using the name we saved it with
    (`json` in this case). For this, we use the `localStorage.getItem` function provided
    by the HTML5 local storage API. Next, we need to convert the string back to a
    JavaScript object (`JSON.parse`) and convert the JSON object back to `THREE.Mesh`.
    Three.js provides a helper object called `THREE.ObjectLoader`, which you can use
    to convert JSON to `THREE.Mesh`. In this example, we used the `parse` method on
    the loader to directly parse a JSON string. The loader also provides a `load`
    function, where you can pass in the URL to a file containing the JSON definition.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用我们保存它的名称（在这种情况下是 `json`）从本地存储中获取 JSON。为此，我们使用 HTML5 本地存储 API 提供的 `localStorage.getItem`
    函数。接下来，我们需要将字符串转换回 JavaScript 对象（`JSON.parse`），并将 JSON 对象转换回 `THREE.Mesh`。Three.js
    提供了一个名为 `THREE.ObjectLoader` 的辅助对象，你可以使用它将 JSON 转换为 `THREE.Mesh`。在这个例子中，我们使用了加载器的
    `parse` 方法来直接解析 JSON 字符串。加载器还提供了一个 `load` 函数，你可以传递包含 JSON 定义的文件的 URL。
- en: As you can see here, we only saved `THREE.Mesh`. We lose everything else. If
    you want to save the complete scene, including the lights and the cameras, you
    can use `THREE.SceneExporter`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只保存了 `THREE.Mesh`。我们失去了其他所有内容。如果你想保存完整的场景，包括灯光和摄像机，你可以使用 `THREE.SceneExporter`。
- en: Saving and loading a scene
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和加载场景
- en: 'If you want to save a complete scene, you use the same approach as we saw in
    the previous section for the geometry. `04-load-save-json-scene.html` is a working
    example showing this. The following screenshot shows this example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保存一个完整的场景，你可以使用与我们在上一节中用于几何体的相同方法。`04-load-save-json-scene.html` 是一个展示这一点的有效示例。以下截图显示了此示例：
- en: '![Saving and loading a scene](img/2215OS_08_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![保存和加载场景](img/2215OS_08_06.jpg)'
- en: 'In this example, you''ve got three options: **exportScene**, **clearScene**,
    and **importScene**. With **exportScene**, the current state of the scene will
    be saved in the browser''s local storage. To test the import functionality, you
    can remove the scene by clicking on the **clearScene** button and load it from
    local storage with the **importScene** button. The code to do all this is very
    simple, but before you can use it, you have to import the required exporter and
    loader from the Three.js distribution (look at the `examples/js/exporters` and
    `examples/js/loaders` directories):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你有三个选项：**exportScene**、**clearScene** 和 **importScene**。使用 **exportScene**，当前场景的状态将被保存到浏览器的本地存储中。要测试导入功能，你可以通过点击
    **clearScene** 按钮来删除场景，然后使用 **importScene** 按钮从本地存储中加载它。执行所有这些操作代码非常简单，但在使用之前，你必须从
    Three.js 发行版中导入所需的导出器和加载器（查看 `examples/js/exporters` 和 `examples/js/loaders` 目录）：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With these JavaScript imports included in the page, you can export a scene
    with the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上包含这些 JavaScript 导入后，你可以使用以下代码导出场景：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This approach is exactly the same as we used in the previous section—only this
    time, we use `THREE.SceneExporter()` to export a complete scene. The resulting
    JSON looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与我们在上一节中使用的方法完全相同——只是这次我们使用 `THREE.SceneExporter()` 来导出完整的场景。生成的 JSON 看起来像这样：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you load this JSON again, Three.js just recreates the objects exactly
    as they were exported. Loading a scene is done like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次加载这个 JSON 时，Three.js 会精确地重新创建导出的对象。加载场景的方式如下：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The last argument passed into the loader (`'.'`) defines the relative URL. For
    instance, if you've got materials that use textures (for example, external images),
    those will be retrieved using this relative URL. In this example, where we don't
    use textures, we just pass in the current directory. Just as with `THREE.ObjectLoader`,
    you can also load a JSON file from a URL using the `load` function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给加载器（`'.'`）的最后一个参数定义了相对 URL。例如，如果你有使用纹理（例如，外部图像）的材料，这些材料将通过这个相对 URL 被检索。在这个例子中，因为我们没有使用纹理，所以我们只传递当前目录。就像使用
    `THREE.ObjectLoader` 一样，你也可以使用 `load` 函数从一个 URL 加载 JSON 文件。
- en: There are many different 3D programs you can use to create complex meshes. A
    popular open source one is Blender ([www.blender.org](http://www.blender.org)).
    Three.js has an exporter for Blender (and for Maya and 3D Studio Max) that directly
    exports to the JSON format of Three.js. In the next section, we'll walk you through
    getting Blender configured to use this exporter and show you how you can export
    a complex model in Blender and show it in Three.js.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用许多不同的3D程序来创建复杂的网格。一个流行的开源程序是Blender ([www.blender.org](http://www.blender.org))。Three.js为Blender（以及Maya和3D
    Studio Max）提供了一个导出器，可以直接导出为Three.js的JSON格式。在下一节中，我们将向您展示如何配置Blender以使用此导出器，并展示您如何在Blender中导出复杂模型并在Three.js中显示它。
- en: Working with Blender
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Blender
- en: 'Before we get started with the configuration, we''ll show the result that we''ll
    be aiming for. In the following screenshot, you can see a simple Blender model
    that we exported with the Three.js plugin and imported in Three.js with `THREE.JSONLoader`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始配置之前，我们将展示我们期望的结果。在下面的截图中，您可以看到一个简单的Blender模型，我们使用Three.js插件导出，并使用`THREE.JSONLoader`导入到Three.js中：
- en: '![Working with Blender](img/2215OS_08_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用Blender](img/2215OS_08_07.jpg)'
- en: Installing the Three.js exporter in Blender
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Blender中安装Three.js导出器
- en: 'To get Blender to export Three.js models, we first need to add the Three.js
    exporter to Blender. The following steps are for Mac OS X but are pretty much
    the same on Windows and Linux. You can download Blender from [www.blender.org](http://www.blender.org)
    and follow the platform-specific installation instructions. After installation,
    you can add the Three.js plugin. First, locate the `addons` directory from your
    Blender installation using a terminal window:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要让Blender导出Three.js模型，我们首先需要将Three.js导出器添加到Blender中。以下步骤适用于Mac OS X，但在Windows和Linux上也非常相似。您可以从[www.blender.org](http://www.blender.org)下载Blender，并遵循特定平台的安装说明。安装后，您可以添加Three.js插件。首先，使用终端窗口定位Blender安装的`addons`目录：
- en: '![Installing the Three.js exporter in Blender](img/2215OS_08_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![在Blender中安装Three.js导出器](img/2215OS_08_08.jpg)'
- en: 'On my Mac, it''s located here: `./blender.app/Contents/MacOS/2.70/scripts/addons`.
    For Windows, this directory can be found at the following location: `C:\Users\USERNAME\AppData\Roaming\Blender
    Foundation\Blender\2.7X\scripts\addons`. And for Linux, you can find this directory
    here: `/home/USERNAME/.config/blender/2.7X/scripts/addons`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Mac上，它位于这里：`./blender.app/Contents/MacOS/2.70/scripts/addons`。对于Windows，此目录可以在以下位置找到：`C:\Users\USERNAME\AppData\Roaming\Blender
    Foundation\Blender\2.7X\scripts\addons`。而对于Linux，您可以在以下位置找到此目录：`/home/USERNAME/.config/blender/2.7X/scripts/addons`。
- en: 'Next, you need to get the Three.js distribution and unpack it locally. In this
    distribution, you can find the following folder: `utils/exporters/blender/2.65/scripts/addons/`.
    In this directory, there is a single subdirectory with the name `io_mesh_threejs`.
    Copy this directory to the `addons` folder of your Blender installation.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要获取Three.js发行版并将其本地解包。在这个发行版中，您可以找到以下文件夹：`utils/exporters/blender/2.65/scripts/addons/`。在这个目录中，有一个名为`io_mesh_threejs`的单个子目录。将此目录复制到Blender安装的`addons`文件夹中。
- en: 'Now, all we need to do is start Blender and enable the exporter. In Blender,
    open **Blender User Preferences** (**File** | **User Preferences**). In the window
    that opens, select the **Addons** tab, and in the search box, type `three`. This
    will show the following screen:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要启动Blender并启用导出器。在Blender中，打开**Blender用户首选项**（**文件** | **用户首选项**）。在打开的窗口中，选择**插件**选项卡，并在搜索框中输入`three`。这将显示以下屏幕：
- en: '![Installing the Three.js exporter in Blender](img/2215OS_08_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![在Blender中安装Three.js导出器](img/2215OS_08_09.jpg)'
- en: 'At this point, the Three.js plugin is found, but it is still disabled. Check
    the small checkbox to the right, and the Three.js exporter will be enabled. As
    a final check to see whether everything is working correctly, open the **File**
    | **Export** menu option, and you''ll see Three.js listed as an export option.
    This is shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，已经找到了Three.js插件，但它仍然处于禁用状态。检查右侧的小复选框，Three.js导出器将被启用。为了最终检查一切是否正常工作，打开**文件**
    | **导出**菜单选项，你会看到Three.js被列为一个导出选项。这在上面的截图中有展示：
- en: '![Installing the Three.js exporter in Blender](img/2215OS_08_10.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![在Blender中安装Three.js导出器](img/2215OS_08_10.jpg)'
- en: With the plugin installed, we can load our first model.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 插件安装完成后，我们可以加载我们的第一个模型。
- en: Loading and exporting a model from Blender
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Blender加载和导出模型
- en: As an example, we've added a simple Blender model named `misc_chair01.blend`
    in the `assets/models` folder, which you can find in the sources for this book.
    In this section, we'll load this model and show the minimal steps it takes to
    export this model to Three.js.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们在`assets/models`文件夹中添加了一个简单的Blender模型`misc_chair01.blend`，你可以在本书的源代码中找到它。在本节中，我们将加载此模型，并展示将此模型导出到Three.js所需的最小步骤。
- en: 'First, we need to load this model in Blender. Use **File** | **Open** and navigate
    to the folder containing the `misc_chair01.blend` file. Select this file and click
    on **Open**. This will show you a screen that looks somewhat like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在Blender中加载这个模型。使用**文件** | **打开**并导航到包含`misc_chair01.blend`文件的文件夹。选择此文件并点击**打开**。这将显示一个看起来有点像这样的屏幕：
- en: '![Loading and exporting a model from Blender](img/2215OS_08_11.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![从Blender加载和导出模型](img/2215OS_08_11.jpg)'
- en: 'Exporting this model to the Three.js JSON format is pretty straightforward.
    From the **File** menu, open **Export** | **Three.js**, type in the name of the
    export file, and select **Export Three.js**. This will create a JSON file in a
    format Three.js understands. A part of the contents of this file is shown next:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将此模型导出为Three.js JSON格式相当直接。从**文件**菜单，打开**导出** | **Three.js**，输入导出文件的名称，并选择**导出Three.js**。这将创建一个Three.js可以理解的JSON文件。此文件内容的一部分如下所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, we aren''t completely done. In the previous screenshot, you can see
    that the chair contains a wooden texture. If you look through the JSON export,
    you can see that the export for the chair also specifies a material, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完全完成。在之前的屏幕截图中，你可以看到椅子包含一个木质纹理。如果你查看JSON导出，你可以看到椅子的导出也指定了一个材质，如下所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This material specifies a texture, `misc_chair01_col.jpg`, for the `mapDiffuse`
    property. So, besides exporting the model, we also need to make sure the texture
    file is also available to Three.js. Luckily, we can save this texture directly
    from Blender.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此材质指定了`mapDiffuse`属性的一个纹理，`misc_chair01_col.jpg`。因此，除了导出模型外，我们还需要确保纹理文件也对Three.js可用。幸运的是，我们可以直接从Blender中保存这个纹理。
- en: 'In Blender, open the **UV/Image Editor** view. You can select this view from
    the drop-down menu on the left-hand side of the **File** menu option. This will
    replace the top menu with the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender中，打开**UV/图像编辑器**视图。你可以从**文件**菜单选项左侧的下拉菜单中选择此视图。这将替换顶部菜单，如下所示：
- en: '![Loading and exporting a model from Blender](img/2215OS_08_12.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![从Blender加载和导出模型](img/2215OS_08_12.jpg)'
- en: Make sure the texture you want to export is selected, `misc_chair_01_col.jpg`
    in our case (you can select a different one using the small image icon). Next,
    click on the **Image** menu and use the **Save as Image** menu option to save
    the image. Save it in the same folder where you saved the model using the name
    specified in the JSON export file. At this point, we're ready to load the model
    into Three.js.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你想要导出的纹理被选中，在我们的例子中是`misc_chair_01_col.jpg`（你可以使用小图像图标选择不同的纹理）。接下来，点击**图像**菜单并使用**另存为图像**菜单选项保存图像。将其保存在与模型相同的文件夹中，使用JSON导出文件中指定的名称。到此为止，我们就可以将模型加载到Three.js中了。
- en: 'The code to load this into Three.js at this point looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段将此加载到Three.js中的代码看起来像这样：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ve already seen `JSONLoader` before, but this time, we use the `load` function
    instead of the `parse` function. In this function, we specify the URL we want
    to load (points to the exported JSON file), a callback that is called when the
    object is loaded, and the location, `../assets/models/`, where the texture can
    be found (relative to the page). This callback takes two parameters: `geometry`
    and `mat`. The `geometry` parameter contains the model, and the `mat` parameter
    contains an array of material objects. We know that there is only one material,
    so when we create `THREE.Mesh`, we directly reference that material. If you open
    the `05-blender-from-json.html` example, you can see the chair we just exported
    from Blender.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过`JSONLoader`，但这次我们使用的是`load`函数而不是`parse`函数。在这个函数中，我们指定了想要加载的URL（指向导出的JSON文件），一个在对象加载时被调用的回调函数，以及纹理可以找到的位置，`../assets/models/`（相对于页面）。这个回调函数接受两个参数：`geometry`和`mat`。`geometry`参数包含模型，而`mat`参数包含一个材质对象数组。我们知道只有一个材质，所以当我们创建`THREE.Mesh`时，我们直接引用那个材质。如果你打开`05-blender-from-json.html`示例，你可以看到我们刚刚从Blender导出的椅子。
- en: Using the Three.js exporter isn't the only way of loading models from Blender
    into Three.js. Three.js understands a number of 3D file formats, and Blender can
    export in a couple of those formats. Using the Three.js format, however, is very
    easy, and if things go wrong, they are often quickly found.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Three.js导出器并不是将模型从Blender导入到Three.js的唯一方法。Three.js理解多种3D文件格式，Blender也可以导出为这些格式中的几种。然而，使用Three.js格式非常简单，如果出现问题，通常可以快速找到。
- en: In the following section, we'll look at a couple of the formats Three.js supports
    and also show a Blender-based example for the OBJ and MTL file formats.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看Three.js支持的几种格式，并展示一个基于Blender的OBJ和MTL文件格式的示例。
- en: Importing from 3D file formats
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从3D文件格式导入
- en: At the beginning of this chapter, we listed a number of formats that are supported
    by Three.js. In this section, we'll quickly walk through a couple of examples
    for those formats. Note that for all these formats, an additional JavaScript file
    needs to be included. You can find all these files in the Three.js distribution
    in the `examples/js/loaders` directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我们列出了一些Three.js支持的格式。在本节中，我们将快速浏览这些格式的几个示例。请注意，对于所有这些格式，都需要包含一个额外的JavaScript文件。你可以在Three.js的`examples/js/loaders`目录中找到所有这些文件。
- en: The OBJ and MTL formats
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OBJ和MTL格式
- en: 'OBJ and MTL are companion formats and often used together. The OBJ file defines
    the geometry, and the MTL file defines the materials that are used. Both OBJ and
    MTL are text-based formats. A part of an OBJ file looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ和MTL是配套格式，通常一起使用。OBJ文件定义了几何形状，而MTL文件定义了使用的材质。OBJ和MTL都是基于文本的格式。OBJ文件的一部分看起来如下：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The MTL file defines materials like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MTL文件定义材料如下：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The OBJ and MTL formats by Three.js are understood well and are also supported
    by Blender. So, as an alternative, you could choose to export models from Blender
    in the OBJ/MTL format instead of the Three.js JSON format. Three.js has two different
    loaders you can use. If you only want to load the geometry, you can use `OBJLoader`.
    We used this loader for our example (`06-load-obj.html`). The following screenshot
    shows this example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js的OBJ和MTL格式被很好地理解，并且Blender也支持这些格式。因此，作为替代方案，你可以选择将Blender中的模型导出为OBJ/MTL格式，而不是Three.js的JSON格式。Three.js有两个不同的加载器你可以使用。如果你只想加载几何形状，你可以使用`OBJLoader`。我们在这个示例（`06-load-obj.html`）中使用了这个加载器。以下截图显示了此示例：
- en: '![The OBJ and MTL formats](img/2215OS_08_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![OBJ和MTL格式](img/2215OS_08_13.jpg)'
- en: 'To import this in Three.js, you have to add the OBJLoader JavaScript file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Three.js中导入此文件，你必须添加OBJLoader JavaScript文件：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Import the model like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式导入模型：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code, we use `OBJLoader` to load the model from a URL. Once the model
    is loaded, the callback we provide is called, and we add the model to the scene.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用`OBJLoader`从URL加载模型。一旦模型被加载，我们提供的回调函数将被调用，并将模型添加到场景中。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Usually, a good first step is to print out the response from the callback to
    the console to understand how the loaded object is built up. Often with these
    loaders, the geometry or mesh is returned as a hierarchy of groups. Understanding
    this makes it much easier to place and apply the correct material and take any
    other additional steps. Also, look at the position of a couple of vertices to
    determine whether you need to scale the model up or down and where to position
    the camera. In this example, we've also made the calls to `computeFaceNormals`
    and `computeVertexNormals`. This is required to ensure that the material used
    (`THREE.MeshLambertMaterial`) is rendered correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个好的第一步是将回调函数的响应打印到控制台，以了解加载的对象是如何构建的。通常，使用这些加载器时，几何形状或网格会作为组层次结构返回。理解这一点会使放置和应用正确的材质以及采取任何其他额外步骤变得容易得多。此外，查看几个顶点的位置，以确定是否需要放大或缩小模型以及如何定位相机。在这个示例中，我们还调用了`computeFaceNormals`和`computeVertexNormals`。这是确保使用的材质（`THREE.MeshLambertMaterial`）正确渲染所必需的。
- en: 'The next example (`07-load-obj-mtl.html`) uses `OBJMTLLoader` to load a model
    and directly assign a material. The following screenshot shows this example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例（`07-load-obj-mtl.html`）使用`OBJMTLLoader`来加载模型并直接分配材质。以下截图显示了此示例：
- en: '![The OBJ and MTL formats](img/2215OS_08_14.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![OBJ和MTL格式](img/2215OS_08_14.jpg)'
- en: 'First, we need to add the correct loaders to the page:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将正确的加载器添加到页面中：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can load the model from the OBJ and MTL files like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样从OBJ和MTL文件加载模型：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first thing to mention before we look at the code is that if you receive
    an OBJ file, an MTL file, and the required texture files, you''ll have to check
    how the MTL file references the textures. These should be referenced relative
    to the MTL file and not as an absolute path. The code itself isn''t that different
    from the one we saw for `THREE.ObjLoader`. We specify the location of the OBJ
    file, the location of the MTL file, and the function to call when the model is
    loaded. The model we''ve used as an example in this case is a complex model. So,
    we set some specific properties in the callback to fix some rendering issues,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看代码之前，首先要提到的是，如果您收到一个 OBJ 文件、一个 MTL 文件和所需的纹理文件，您必须检查 MTL 文件如何引用纹理。这些应该相对于
    MTL 文件进行引用，而不是作为绝对路径。代码本身与我们之前看到的 `THREE.ObjLoader` 的代码并没有太大的不同。我们指定了 OBJ 文件的位置、MTL
    文件的位置以及当模型加载时调用的函数。在这个例子中，我们使用的模型是一个复杂的模型。因此，我们在回调中设置了一些特定的属性来修复一些渲染问题，如下所示：
- en: The opacity in the source files was set incorrectly, which caused the wings
    to be invisible. So, to fix that, we set the `opacity` and `transparent` properties
    ourselves.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件中的不透明度设置不正确，导致翅膀不可见。因此，为了修复这个问题，我们自行设置了 `opacity` 和 `transparent` 属性。
- en: By default, Three.js only renders one side of an object. Since we look at the
    wings from two sides, we need to set the `side` property to the `THREE.DoubleSide`
    value.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Three.js 只渲染对象的单侧。由于我们从两个侧面查看翅膀，我们需要将 `side` 属性设置为 `THREE.DoubleSide`
    值。
- en: The wings caused some unwanted artifacts when they needed to be rendered on
    top of each other. We've fixed that by setting the `depthTest` property to `false`.
    This has a slight impact on performance but can often solve some strange rendering
    artifacts.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翅膀需要叠加渲染时，它们造成了一些不希望出现的伪影。我们通过将 `depthTest` 属性设置为 `false` 来修复了这个问题。这会对性能产生轻微影响，但通常可以解决一些奇怪的渲染伪影。
- en: But, as you can see, you can easily load complex models directly into Three.js
    and render them in real time in your browser. You might need to fine-tune some
    material properties though.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如您所见，您可以将复杂模型直接加载到 Three.js 中，并在浏览器中实时渲染。不过，您可能需要微调一些材质属性。
- en: Loading a Collada model
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载 Collada 模型
- en: Collada models (extension is `.dae`) are another very common format for defining
    scenes and models (and animations, as we'll see in the following chapter). In
    a Collada model, it is not just the geometry that is defined, but also the materials.
    It's even possible to define light sources.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Collada 模型（扩展名为 `.dae`）是定义场景和模型（以及动画，我们将在下一章中看到）的另一种非常常见的格式。在 Collada 模型中，不仅定义了几何形状，还定义了材质。甚至可以定义光源。
- en: 'To load Collada models, you have to take pretty much the same steps as for
    the OBJ and MTL models. You start by including the correct loader:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载 Collada 模型，您必须基本上采取与 OBJ 和 MTL 模型相同的步骤。您首先包括正确的加载器：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For this example, we''ll load the following model:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将加载以下模型：
- en: '![Loading a Collada model](img/2215OS_08_15.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![加载 Collada 模型](img/2215OS_08_15.jpg)'
- en: 'Loading a truck model is once again pretty simple:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 加载卡车模型再次非常简单：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The main difference here is the result of the object that is returned to the
    callback. The `result` object has the following structure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于回调函数返回的对象的结果。`result` 对象具有以下结构：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this chapter, we're interested in the objects that are in the `scene` parameter.
    I first printed out the scene to the console to look where the mesh was that I
    was interested in, which was `result.scene.children[0].children[0]`. All that
    was left to do was scale it to a reasonable size and add it to the scene. A final
    note on this specific example—when I loaded this model for the first time, the
    materials didn't render correctly. The reason was that the textures used the `.tga`
    format, which isn't supported in WebGL. To fix this, I had to convert the `.tga`
    files to `.png` and edit the XML of the `.dae` model to point to these `.png`
    files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对 `scene` 参数中的对象感兴趣。我首先将场景打印到控制台，以查看我感兴趣的网格在哪里，它是 `result.scene.children[0].children[0]`。剩下要做的就是将其缩放到合理的大小并添加到场景中。关于这个特定示例的最后一句话——当我第一次加载这个模型时，材质没有正确渲染。原因是使用的纹理格式是
    `.tga`，WebGL 不支持这种格式。为了修复这个问题，我不得不将 `.tga` 文件转换为 `.png`，并编辑 `.dae` 模型的 XML 以指向这些
    `.png` 文件。
- en: As you can see, for most complex models, including materials, you often have
    to take some additional steps to get the desired results. By looking closely at
    how the materials are configured (using `console.log()`) or replacing them with
    test materials, problems are often easy to spot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于大多数复杂的模型，包括材质，您通常需要采取一些额外的步骤才能获得期望的结果。通过仔细查看材质的配置方式（使用 `console.log()`）或用测试材质替换它们，问题通常很容易被发现。
- en: Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型
- en: 'We''re going to quickly skim over these file formats as they all follow the
    same principles:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速浏览这些文件格式，因为它们都遵循相同的原理：
- en: Include `[NameOfFormat]Loader.js` in your web page.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网页中包含 `[NameOfFormat]Loader.js`。
- en: Use `[NameOfFormat]Loader.load()` to load a URL.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `[NameOfFormat]Loader.load()` 加载一个URL。
- en: Check what the response format for the callback looks like and render the result.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查回调的响应格式并渲染结果。
- en: 'We have included an example for all these formats:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为所有这些格式都包含了一个示例：
- en: '| Name | Example | Screenshot |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 示例 | 截图 |'
- en: '| --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| STL | `08-load-STL.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_16.jpg) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| STL | `08-load-STL.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](img/2215OS_08_16.jpg)
    |'
- en: '| CTM | `09-load-CTM.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_17.jpg) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| CTM | `09-load-CTM.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](img/2215OS_08_17.jpg)
    |'
- en: '| VTK | `10-load-vtk.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_18.jpg) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| VTK | `10-load-vtk.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](img/2215OS_08_18.jpg)
    |'
- en: '| AWD | `11-load-awd.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_19.jpg) |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| AWD | `11-load-awd.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](img/2215OS_08_19.jpg)
    |'
- en: '| Assimp | `12-load-assimp.html` | ![Loading the STL, CTM, VTK, AWD, Assimp,
    VRML, and Babylon models](img/2215OS_08_20.jpg) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Assimp | `12-load-assimp.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](img/2215OS_08_20.jpg)
    |'
- en: '| VRML | `13-load-vrml.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_21.jpg) |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| VRML | `13-load-vrml.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](img/2215OS_08_21.jpg)
    |'
- en: '| Babylon | The Babylon loader is slightly different from the other loaders
    in this table. With this loader, you don''t load a single `THREE.Mesh` or `THREE.Geometry`
    instance, but with this loader, you load a complete scene, including lights.`14-load-babylon.html`
    | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models](img/2215OS_08_22.jpg)
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| Babylon | Babylon加载器与表中其他加载器略有不同。使用此加载器，您不是加载单个 `THREE.Mesh` 或 `THREE.Geometry`
    实例，而是使用此加载器加载一个完整的场景，包括灯光。`14-load-babylon.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](img/2215OS_08_22.jpg)
    |'
- en: If you look at the source code for these examples, you might see that for some
    of them, we need to change some material properties or do some scaling before
    the model is rendered correctly. The reason we need to do this is because of the
    way the model is created in its external application, giving it different dimensions
    and grouping than we normally use in Three.js.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看这些示例的源代码，可能会看到对于其中的一些，我们需要更改一些材质属性或进行一些缩放，以便正确渲染模型。我们需要这样做的原因是因为模型在其外部应用程序中的创建方式，它具有与我们通常在Three.js中使用的不同尺寸和分组。
- en: We've almost shown all the supported file formats. In the next two sections,
    we'll take a different approach. First, we'll look at how to render proteins from
    Protein Data Bank (PDB format), and finally we'll use a model defined in the PLY
    format to create a particle system.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎展示了所有支持的文件格式。在接下来的两个部分中，我们将采用不同的方法。首先，我们将探讨如何从蛋白质数据银行（PDB格式）渲染蛋白质，最后我们将使用定义在PLY格式的模型来创建粒子系统。
- en: Show proteins from Protein Data Bank
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示蛋白质数据银行的蛋白质
- en: Protein Data Bank ([www.rcsb.org](http://www.rcsb.org)) contains detailed information
    about many different molecules and proteins. Besides the explanation of these
    proteins, they also provide a way to download the structure of these molecules
    in the PDB format. Three.js provides a loader for files specified in the PDB format.
    In this section, we'll give an example of how you can parse PDB files and visualize
    them with Three.js.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋白质数据银行 ([www.rcsb.org](http://www.rcsb.org)) 包含关于许多不同分子和蛋白质的详细信息。除了对这些蛋白质的解释外，它们还提供了一种下载这些分子PDB格式结构的方法。Three.js为PDB格式的文件提供了加载器。在本节中，我们将给出一个示例，说明您如何解析PDB文件并使用Three.js可视化它们。
- en: 'The first thing we always need to do to load in a new file format is include
    the correct loader in Three.js, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 加载新文件格式的第一步，我们总是需要在 Three.js 中包含正确的加载器，如下所示：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this loader included, we''re going to create the following 3D model of
    the molecule description provided (see the `15-load-ptb.html` example):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了这个加载器后，我们将创建以下分子描述的 3D 模型（参见 `15-load-ptb.html` 示例）：
- en: '![Show proteins from Protein Data Bank](img/2215OS_08_23.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![显示来自蛋白质数据银行的蛋白质](img/2215OS_08_23.jpg)'
- en: 'Loading a PDB file is done in the same manner as the previous formats, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 PDB 文件的方式与之前的格式相同，如下所示：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see from this example, we instantiate `THREE.PDBLoader`, pass in
    the model file we want to load, and provide a callback that is called when the
    model is loaded. For this specific loader, the callback function is called with
    two arguments: `geometry` and `geometryBonds`. The vertices from the `geometry`
    argument supplied contain the positions of the individual atoms, and `geometryBounds`
    is used for the connections between the atoms.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个示例中可以看出，我们实例化 `THREE.PDBLoader`，传入我们想要加载的模型文件，并提供一个在模型加载时被调用的回调函数。对于这个特定的加载器，回调函数接收两个参数：`geometry`
    和 `geometryBonds`。`geometry` 参数提供的顶点包含单个原子的位置，而 `geometryBounds` 用于原子之间的连接。
- en: 'For each vertex, we create a sphere with the color that is also supplied by
    the model:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个顶点，我们创建一个由模型提供的颜色填充的球体：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each connection is defined like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接的定义如下：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For the connection, we first create a 3D path using the `THREE.SplineCurve3`
    object. This path is used as input for `THREE.Tube` and used to create the connection
    between the atoms. All the connections and atoms are added to a group, and this
    group is added to the scene. There are many models you can download from Protein
    Data Bank.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接，我们首先使用 `THREE.SplineCurve3` 对象创建一个 3D 路径。这个路径被用作 `THREE.Tube` 的输入，用于创建原子之间的连接。所有的连接和原子都被添加到一个组中，这个组被添加到场景中。你可以从蛋白质数据银行下载许多模型。
- en: 'The following image shows the structure of a diamond:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了钻石的结构：
- en: '![Show proteins from Protein Data Bank](img/2215OS_08_24.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![显示来自蛋白质数据银行的蛋白质](img/2215OS_08_24.jpg)'
- en: Creating a particle system from a PLY model
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 PLY 模型创建粒子系统
- en: 'Working with the PLY format isn''t that much different from the other formats.
    You include the loader, provide a callback, and visualize the model. For this
    last example, however, we''re going to do something different. Instead of rendering
    the model as a mesh, we''ll use the information from this model to create a particle
    system (see the `15-load-ply.html` example). The following screenshot shows this
    example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PLY 格式与使用其他格式并没有太大的不同。你包含加载器，提供回调函数，并可视化模型。然而，对于这个最后的例子，我们将做一些不同的事情。我们不会将模型作为网格渲染，而是将使用这个模型的信息来创建一个粒子系统（参见
    `15-load-ply.html` 示例）。以下截图展示了这个示例：
- en: '![Creating a particle system from a PLY model](img/2215OS_08_25.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![从 PLY 模型创建粒子系统](img/2215OS_08_25.jpg)'
- en: 'The JavaScript code to render the preceding screenshot is actually very simple,
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染前面截图的 JavaScript 代码实际上非常简单，如下所示：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we use `THREE.PLYLoader` to load the model. The callback returns
    `geometry`, and we use this geometry as input for `THREE.PointCloud`. The material
    we use is the same as the one we used for the last example in the previous chapter.
    As you can see, with Three.js, it is very easy to combine models from various
    sources and render them in different ways, all with a few lines of code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用 `THREE.PLYLoader` 来加载模型。回调函数返回 `geometry`，我们将这个几何体作为 `THREE.PointCloud`
    的输入。我们使用的材质与上一章最后一个示例中使用的相同。如您所见，使用 Three.js，结合来自不同来源的模型并以不同方式渲染它们非常容易，只需几行代码即可。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Using models from external sources isn't that hard to do in Three.js. Especially
    for simple models, you only have to take a few simple steps. When working with
    external models, or creating them using grouping and merging, it is good to keep
    a couple of things in mind. The first thing you need to remember is that when
    you group objects, they still remain available as individual objects. Transformations
    applied to the parent also affect the children, but you can still transform the
    children individually. Besides grouping, you can also merge geometries together.
    With this approach, you lose the individual geometries and get a single new geometry.
    This is especially useful when you're dealing with thousands of geometries you
    need to render and you're running into performance issues.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中使用外部模型并不难。特别是对于简单模型，您只需进行几个简单的步骤。当处理外部模型或使用分组和合并创建它们时，有一些事情需要记住。首先，您需要记住的是，当您分组对象时，它们仍然作为单独的对象可用。应用于父对象的变换也会影响子对象，但您仍然可以单独变换子对象。除了分组之外，您还可以合并几何体。采用这种方法，您会失去单个几何体，并获得一个单一的新几何体。当您需要渲染成千上万的几何体并且遇到性能问题时，这种方法特别有用。
- en: Three.js supports a large number of external formats. When using these format
    loaders, it's a good idea to look through the source code and log out the information
    received in the callback. This will help you to understand the steps you need
    to take to get the correct mesh and set it to the correct position and scale.
    Often, when the model doesn't show correctly, this is caused by its material settings.
    It could be that incompatible texture formats are used, opacity is incorrectly
    defined, or the format contains incorrect links to the texture images. It is usually
    a good idea to use a test material to determine whether the model itself is loaded
    correctly and log the loaded material to the JavaScript console to check for unexpected
    values. It is also possible to export meshes and scenes, but remember that `GeometryExporter`,
    `SceneExporter`, and `SceneLoader` of Three.js are still work in progress.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js支持大量外部格式。当使用这些格式加载器时，查看源代码并记录回调中接收到的信息是个好主意。这将帮助您了解获取正确网格并将其设置为正确位置和比例所需的步骤。通常，当模型显示不正确时，这可能是由于其材质设置引起的。可能是使用了不兼容的纹理格式，不透明度定义不正确，或者格式包含指向纹理图像的错误链接。通常，使用测试材质来确定模型本身是否正确加载，并将加载的材质记录到JavaScript控制台以检查意外值是个好主意。也有可能导出网格和场景，但请记住，Three.js的`GeometryExporter`、`SceneExporter`和`SceneLoader`仍在开发中。
- en: The models you worked with in this chapter, and in the previous chapters, are
    mostly static models. They aren't animated, don't move around, and don't change
    shape. In the next chapter, you'll learn how you can animate your models to make
    them come to life. Besides animations, the following chapter will also explain
    the various camera controls provided by Three.js. With a camera control, you can
    move, pan, and rotate the camera around your scene.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及前几章中，您所使用的模型大多是静态模型。它们没有动画效果，不会移动，也不会改变形状。在下一章中，您将学习如何使您的模型动起来，使其栩栩如生。除了动画之外，下一章还将解释Three.js提供的各种相机控制功能。有了相机控制，您可以移动、平移和旋转相机，使其围绕场景旋转。
