- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Adding Physics and Sounds to Your Scene
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的场景添加物理和声音
- en: In this chapter, we’ll look at Rapier, another library you can use to extend
    the basic functionality of Three.js. Rapier is a library that allows you to introduce
    physics into your 3D scene. By physics, we mean that your objects are subject
    to gravity – they can collide with one another, can be moved by applying impulses,
    and can be constrained in their movement by different types of joints. Besides
    physics, we’ll also look at how Three.js can help you with adding spatial sounds
    to your scene.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Rapier，这是另一个可以用来扩展Three.js基本功能的库。Rapier是一个库，允许您将物理引入您的3D场景。当我们提到物理时，我们指的是您的对象受到重力的影响——它们可以相互碰撞，可以通过施加冲量来移动，并且可以通过不同类型的关节来限制它们的运动。除了物理之外，我们还将探讨Three.js如何帮助您向场景添加空间声音。
- en: 'In this chapter, we’ll discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating a Rapier scene where your objects are subject to gravity and can collide
    with one another
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Rapier场景，其中您的对象受到重力影响并可以相互碰撞
- en: Showing how to change the friction and restitution (bounciness) of the objects
    in the scene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何更改场景中对象的摩擦力和恢复力（弹性）
- en: Explaining the various shapes supported by Rapier and how to use them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Rapier支持的形状及其使用方法
- en: Showing how to create compound shapes by combining simple shapes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何通过组合简单形状来创建复合形状
- en: Showing how a height field allows you to simulate a complex shape
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何通过高度场模拟复杂形状
- en: Limiting the movement of an object by using joints to connect them to other
    objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用关节将对象连接到其他对象来限制对象的运动
- en: Adding sound sources to your scene, whose sound volume and direction are based
    on the distance to the camera
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向场景添加声音源，其声音大小和方向基于与摄像机的距离
- en: Available physics engines
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的物理引擎
- en: There are a number of different open source JavaScript physics engines available.
    Most of them are not under active development though. Rapier, however, is under
    active development. Rapier is written in Rust and is cross-compiled to JavaScript,
    so you can use it in the browser. Should you choose to use any of the other libraries
    out there, the information in this chapter will still be useful since most of
    the libraries use the same approach as demonstrated in this chapter. Therefore,
    while the implementation and classes and functions used might be different, the
    concepts and setup shown in this chapter will, for the most part, be applicable
    regardless of the physics library you choose.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的开源JavaScript物理引擎可供选择。尽管大多数引擎都没有处于活跃开发状态。然而，Rapier正处于活跃开发中。Rapier是用Rust编写的，并且交叉编译成JavaScript，因此您可以在浏览器中使用它。如果您选择使用其他库，本章中的信息仍然有用，因为大多数库都使用本章中展示的相同方法。因此，尽管实现和使用的类和函数可能不同，但本章中展示的概念和设置在大多数情况下都将适用于您选择的任何物理库。
- en: Creating a basic Three.js scene with Rapier
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rapier创建基本的Three.js场景
- en: 'To get started, we created a very basic scene in which a cube drops down and
    hits a plane. You can see this example by looking at the `physics-setup.html`
    example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们创建了一个非常基本的场景，其中有一个立方体掉落并击中一个平面。您可以通过查看`physics-setup.html`示例来查看此示例：
- en: '![Figure 12.1 – Simple Rapier physics](img/Figure_12.1_B18726.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 简单的Rapier物理](img/Figure_12.1_B18726.jpg)'
- en: Figure 12.1 – Simple Rapier physics
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 简单的Rapier物理
- en: When you open this example, you’ll see the cube slowly drop down, hit the corner
    of the gray horizontal plane, and bounce off it. We could have accomplished this
    without using a physics engine by updating the position and rotation of the cube
    and programming how it should react. This is, however, rather difficult to do
    since we need to know exactly when it hits, where it hits, and how the cube should
    spin away after the hit. With Rapier, we just have to configure the physical world,
    and Rapier will calculate exactly what happens to the objects in the scene.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开此示例时，您会看到立方体缓慢掉落，击中灰色水平平面的角落，并从其上弹跳。我们可以通过更新立方体的位置和旋转以及编程其反应来实现这一点。然而，这相当困难，因为我们需要确切知道它何时击中，在哪里击中，以及立方体在击中后应该如何旋转。使用Rapier，我们只需配置物理世界，Rapier就会精确计算场景中对象的运动情况。
- en: 'Before we can configure our models to use the Rapier engine, we need to install
    Rapier in our project (we’ve already done this, so you don’t have to do this if
    you’re experimenting with the examples provided in this book):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以配置模型使用Rapier引擎之前，我们需要在我们的项目中安装Rapier（我们已安装，所以如果您在本章提供的示例中进行实验，您不需要这样做）：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once added, we need to import Rapier into our project. This is done slightly
    differently than the normal imports we’ve seen because Rapier needs to load additional
    WebAssembly resources. This is needed since the Rapier library is developed in
    the Rust language, and compiled into WebAssembly so it can also be used on the
    web. To use Rapier, we need to wrap our script like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加，我们需要将 Rapier 导入到我们的项目中。这与我们之前看到的正常导入略有不同，因为 Rapier 需要加载额外的 WebAssembly
    资源。这是必要的，因为 Rapier 库是用 Rust 语言开发的，并编译成 WebAssembly，以便也可以在网络上使用。要使用 Rapier，我们需要像这样包装我们的脚本：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This last import statement will load the Rapier library asynchronously and calls
    the callback when all the data has been loaded and parsed. In the rest of the
    code, you can just call into the `RAPIER` object to access the Rapier-specific
    functionality.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个导入语句将异步加载 Rapier 库，并在所有数据加载和解析完成后调用回调。在代码的其余部分，你只需调用 `RAPIER` 对象即可访问 Rapier
    特定的功能。
- en: 'To set up a scene with Rapier, we need to do a few things:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Rapier 设置一个场景，我们需要做一些事情：
- en: Create a Rapier `World`. This defines the physical world that we’re simulating
    and allows us to define the gravity that will be applied to objects in this world.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Rapier `World`。这定义了我们正在模拟的物理世界，并允许我们定义将应用于该世界中物体的重力。
- en: For each object you want to simulate with Rapier, you’ve got to define a `RigidBodyDesc`.
    This defines the position and rotation of an object in the scene (as well as some
    other properties). By adding this description to the `World` instance, you get
    back a `RigidBody`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于你想要用 Rapier 模拟的每个对象，你必须定义一个 `RigidBodyDesc`。这定义了场景中一个对象的位置和旋转（以及一些其他属性）。通过将这个描述添加到
    `World` 实例中，你将得到一个 `RigidBody`。
- en: Next, you can tell Rapier the shape of the object you’re adding by creating
    a `ColliderDesc` object. This will tell Rapier that your object is a cube, sphere,
    cone, or another shape; how large it is; how much friction it has with regard
    to other objects; and how bouncy it is. This description is then combined with
    the previously created `RigidBody` to create a `Collider` instance.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以通过创建一个 `ColliderDesc` 对象来告诉 Rapier 你要添加的对象的形状。这将告诉 Rapier 你的对象是一个立方体、球体、圆锥体或其他形状；它有多大；它与其他物体之间的摩擦力有多大；以及它的弹性如何。这个描述将与之前创建的
    `RigidBody` 结合，以创建一个 `Collider` 实例。
- en: In our animation loop, we can now call `world.step()`, which makes Rapier calculate
    all the new positions and rotations of the `RigidBody` objects that it is aware
    of.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的动画循环中，我们现在可以调用 `world.step()`，这将使 Rapier 计算它所了解的所有 `RigidBody` 对象的新位置和旋转。
- en: Online Rapier documentation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在线 Rapier 文档
- en: 'In this book, we’ll look at various properties of Rapier. We won’t explore
    the full set of features provided by Rapier since that could fill a book in itself.
    More information on Rapier can be found here: [https://rapier.rs/docs/](https://rapier.rs/docs/).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将查看 Rapier 的各种属性。我们不会探索 Rapier 提供的全部功能，因为那可以填满一本书。有关 Rapier 的更多信息，请参阅此处：[https://rapier.rs/docs/](https://rapier.rs/docs/)。
- en: Let’s walk through these steps and see how you combine this with the Three.js
    objects you’re already familiar with.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步走过这些步骤，看看你是如何将它们与你已经熟悉的 Three.js 对象结合起来的。
- en: Setting up the world and creating the descriptions
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置世界和创建描述
- en: 'The first thing we need to do is create the `World` we’re simulating with:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建我们正在模拟的 `World`：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is straightforward code in which we create a `World` that has a gravity
    of `-9.81` on the *y*-axis. This is similar to the gravity on Earth.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段简单的代码，我们创建了一个在 *y* 轴上有 `-9.81` 重力的 `World`。这与地球上的重力相似。
- en: 'Next, let’s define the Three.js object we saw in our example: a cube that falls
    and the floor that it hits:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义我们在示例中看到的 Three.js 对象：一个下落的立方体和它撞击的地板：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Nothing new here. We just define two `THREE.Mesh` objects and position the
    `sampleMesh` instance, the cube, above the corner of the `floor` surface. Next,
    we need to create the `RigidBodyDesc` and `ColliderDesc` objects, which represent
    the `THREE.Mesh` objects in the world of Rapier. We’ll start with the simple one,
    the floor:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的。我们只是定义了两个 `THREE.Mesh` 对象，并将 `sampleMesh` 实例，即立方体，放置在 `floor` 表面角落上方。接下来，我们需要创建
    `RigidBodyDesc` 和 `ColliderDesc` 对象，这些对象代表 Rapier 世界中的 `THREE.Mesh` 对象。我们将从简单的开始，即地板：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, first, we create a `RigidBodyDesc` with a single parameter, `RigidBodyType.Fixed`.
    A fixed rigid body means that Rapier isn’t allowed to change the position or the
    rotation of this object, so this object won’t be affected by gravity or moved
    around when another object hits it. By calling `world.createRigidBody`, we add
    it to the `world` known by Rapier so that Rapier can take this object into account
    when doing its calculations. Then, we use `setTranslation` to put `RigidBody`
    into the same position as our Three.js floor. The `setTranslation` function takes
    an optional extra parameter called `wakeUp`. If `RigidBody` is sleeping (what
    can happen if it hasn’t moved for a long time), passing in `true` for the `wakeUp`
    property makes sure that Rapier will take `RigidBody` into account when determining
    the new positions of all the objects that it is aware of.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先，我们创建一个带有单个参数的 `RigidBodyDesc`，即 `RigidBodyType.Fixed`。一个固定刚体意味着 Rapier
    不允许改变这个对象的位置或旋转，因此这个对象不会受到重力的影响，也不会在另一个对象撞击时移动。通过调用 `world.createRigidBody`，我们将它添加到
    Rapier 所知的 `world` 中，这样 Rapier 就可以在进行计算时考虑这个对象。然后，我们使用 `setTranslation` 将 `RigidBody`
    放置在与我们的 Three.js 地板相同的位置。`setTranslation` 函数有一个可选的额外参数，称为 `wakeUp`。如果 `RigidBody`
    正在睡眠（如果它长时间没有移动，可能会发生这种情况），将 `true` 传递给 `wakeUp` 属性确保 Rapier 在确定所有已知对象的新位置时将考虑
    `RigidBody`。
- en: We still need to define the shape of this object so that Rapier can tell when
    it collides with another object. For this, we use the `Rapier.ColliderDesc.cuboid`
    function in which we specify the shape. For the `cuboid` function, Rapier expects
    the shape to be defined by a half-width, a half-height, and a half-depth. The
    final step to take is to add this collider to the world and connect it to the
    floor. For this, we use the `world.createCollider` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要定义这个对象的外形，以便 Rapier 可以判断它何时与另一个对象发生碰撞。为此，我们使用 `Rapier.ColliderDesc.cuboid`
    函数来指定形状。对于 `cuboid` 函数，Rapier 预期形状由半宽、半高和半深度定义。最后一步是将这个碰撞器添加到世界中，并将其连接到地板。为此，我们使用
    `world.createCollider` 函数。
- en: 'At this point, we have defined `floor` in the Rapier world, which corresponds
    to the floor in our Three.js scene. Now, we define the cube that will fall in
    the same way:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在 Rapier 世界中定义了 `floor`，这与我们的 Three.js 场景中的地板相对应。现在，我们定义将同样下落的立方体：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code fragment is similar to the previous one – we just create the relevant
    objects for Rapier that correspond to the objects in our Three.js scene. The main
    change here is that we used a `RigidBodyType.Dynamic` instance. This means that
    this object can be completely managed by Rapier. Rapier can change its position
    or its translation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与上一个类似——我们只是创建了与我们的 Three.js 场景中的对象相对应的 Rapier 相关对象。这里的主要变化是我们使用了 `RigidBodyType.Dynamic`
    实例。这意味着这个对象可以完全由 Rapier 管理。Rapier 可以改变它的位置或平移。
- en: Additional rigid body types provided by Rapier
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Rapier 提供的附加刚体类型
- en: 'Besides the `Dynamic` and the `Fixed` rigid body types, Rapier also provides
    a `KinematicPositionBased` type, for managing the position of an object, or a
    `KinematicVelocityBased` type, for managing the velocity of an object ourselves.
    More information on this can be found here: [https://rapier.rs/docs/user_guides/javascript/rigid_bodies](https://rapier.rs/docs/user_guides/javascript/rigid_bodies).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Dynamic` 和 `Fixed` 刚体类型之外，Rapier 还提供了一个 `KinematicPositionBased` 类型，用于管理对象的位置，或者一个
    `KinematicVelocityBased` 类型，用于我们自己管理对象的速度。更多相关信息请参阅此处：[https://rapier.rs/docs/user_guides/javascript/rigid_bodies](https://rapier.rs/docs/user_guides/javascript/rigid_bodies)。
- en: Rendering the scene and simulating the world
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染场景和模拟世界
- en: 'What is left to do is render the Three.js object, simulate the world, and make
    sure that the positions of the objects managed by Rapier correspond to the position
    of the Three.js meshes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是将 Three.js 对象渲染出来，模拟世界，并确保 Rapier 管理的对象的位置与 Three.js 网格的位置相对应：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our render loop, we have the normal Three.js elements to make sure we render
    this each step using `requestAnimationFrame`. Besides that, we call the `world.step()`
    function to trigger a calculation in Rapier. This will update the position and
    rotation of all the objects that it knows of. Next, we need to make sure that
    these newly calculated positions are also reflected by the Three.js objects. To
    do this, we just get the current position of an object in the Rapier world (`rigidBody.translation()`)
    and set the position of the Three.js mesh to the result of that function. For
    the rotation, we do the same, by calling `rotation()` on `rigidBody` first, and
    then applying that rotation to our Three.js mesh. Rapier works with quaternions
    for defining rotations, so we need to make this conversion before we can apply
    that rotation to the Three.js mesh.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的渲染循环中，我们有正常的Three.js元素来确保我们使用`requestAnimationFrame`在每一步渲染。除此之外，我们调用`world.step()`函数来触发Rapier中的计算。这将更新它所知道的所有物体的位置和旋转。接下来，我们需要确保这些新计算出的位置也通过Three.js对象反映出来。为此，我们只需获取Rapier世界中一个物体的当前位置（`rigidBody.translation()`）并将Three.js网格的位置设置为该函数的结果。对于旋转，我们同样这样做，首先在`rigidBody`上调用`rotation()`，然后将该旋转应用到我们的Three.js网格上。Rapier使用四元数来定义旋转，因此在我们将旋转应用到Three.js网格之前，我们需要进行这种转换。
- en: 'And that’s all you need to do. All the examples in the following sections use
    this same approach:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要做的全部。以下各节中的所有示例都使用这种方法：
- en: Setting up the Three.js scene
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Three.js场景
- en: Setting up a similar set of objects in the Rapier world
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rapier世界中设置一组类似的对象
- en: Making sure that after each `step`, the location and rotation of both the Three.js
    scene and the Rapier world align again
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在每个`step`之后，Three.js场景和Rapier世界的位置和旋转再次对齐
- en: In the next section, we’ll expand on this example, and we’ll show you more about
    how objects interact with each other when they collide in the Rapier world.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将扩展这个示例，并展示更多关于在Rapier世界中物体如何相互作用的细节。
- en: Simulating dominos in Rapier
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rapier中模拟多米诺
- en: 'The following example is built upon the same core concepts we looked at in
    the *Setting up the world and creating the descriptions* section. The example
    can be viewed by opening up the `dominos.html` example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例建立在我们在*设置世界和创建描述*部分查看的相同核心概念之上。您可以通过打开`dominos.html`示例来查看此示例：
- en: '![Figure 12.2 – Dominos standing still when no gravity is present](img/Figure_12.2_B18726.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 没有重力时静止的多米诺](img/Figure_12.2_B18726.jpg)'
- en: Figure 12.2 – Dominos standing still when no gravity is present
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 没有重力时静止的多米诺
- en: 'Here, you can see that we’ve created a simple floor on which many dominos are
    positioned. If you look closely, you can see that the first instance of these
    dominos is tilted a little bit. If we enable gravity on the *y*-axis using the
    menu on the right, you’ll see that the first dominos falls, hits the next one,
    and so on until all the dominos have been knocked down:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们创建了一个简单的地板，许多多米诺就放置在这个地板上。如果您仔细观察，您会看到这些多米诺的第一个实例略微倾斜。如果您通过右侧菜单启用*y*轴上的重力，您会看到第一个多米诺倒下，撞到下一个，以此类推，直到所有多米诺都被撞倒：
- en: '![Figure 12.3 – Dominos falling down after the first one is toppled](img/Figure_12.3_B18726.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 第一个多米诺被推倒后多米诺倒下](img/Figure_12.3_B18726.jpg)'
- en: Figure 12.3 – Dominos falling down after the first one is toppled
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 第一个多米诺被推倒后多米诺倒下
- en: Creating this with Rapier is really straightforward. We just need to create
    the Three.js objects that represent the dominos, create the relevant Rapier `RigidBody`
    and `Collider` elements, and make sure the changes to the Rapier objects are reflected
    by the Three.js objects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Rapier创建这个示例非常直接。我们只需创建代表多米诺的Three.js对象，创建相关的Rapier `RigidBody`和`Collider`元素，并确保Rapier对象的更改通过Three.js对象反映出来。
- en: 'First, let’s have a quick look at how we create the Three.js dominos:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速看一下我们是如何创建Three.js多米诺的：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code fragment, we determine the position of the dominos with the `getPoints`
    function. This function returns a list of `THREE.Vector3` objects that represent
    the position of the individual stones. Each stone is placed along a spiral outward
    from the center. Next, these `points` are used to create a number of `THREE.BoxGeometry`
    objects at the same locations. To make sure the dominos are oriented correctly,
    we use the `lookAt` function to have them ‘look at’ the center of the circle.
    All the dominos are added to a `THREE.Group` object, which we then add to a `THREE.Scene`
    instance (this is not shown in the code fragment).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们使用`getPoints`函数确定多米诺的位置。此函数返回一个`THREE.Vector3`对象的列表，代表单个石头的位置。每个石头都沿着从中心向外螺旋排列。接下来，这些`points`被用来在相同的位置创建多个`THREE.BoxGeometry`对象。为了确保多米诺的方向正确，我们使用`lookAt`函数使它们“看向”圆的中心。所有多米诺都被添加到一个`THREE.Group`对象中，然后我们将其添加到一个`THREE.Scene`实例中（这在代码片段中没有显示）。
- en: 'Now that we have our set of `THREE.Mesh` objects, we can create the corresponding
    set of Rapier objects:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`THREE.Mesh`对象集，我们可以创建相应的Rapier对象集：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code will look familiar to the code in *Setting up the world and creating
    the descriptions* section. Here, we take the position and rotation of the passed-in
    `THREE.Mesh` instance and use that information to create the relevant Rapier objects.
    To make sure we can access the `dominoCollider` and `dominoRigidBody` instances
    in the render loop, we add them to the `userData` property of the passed-in mesh.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将与*设置世界和创建描述*部分中的代码相似。在这里，我们获取传入的`THREE.Mesh`实例的位置和旋转，并使用这些信息来创建相关的Rapier对象。为了确保我们可以在渲染循环中访问`dominoCollider`和`dominoRigidBody`实例，我们将它们添加到传入网格的`userData`属性中。
- en: 'The final step here is to update the `THREE.Mesh` objects in the render loop:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的最后一步是在渲染循环中更新`THREE.Mesh`对象：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In each loop, we tell Rapier to calculate the next state of the world (`world.step`),
    and for each domino (which are `children` of the `THREE.Group` named `dominos`),
    we update the position and rotation of the `THREE.Mesh` instance based on the
    `RigidBody` object stored in that mesh’s `userdata` information.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个循环中，我们告诉Rapier计算世界的下一个状态（`world.step`），并且对于每个多米诺（它们是名为`dominos`的`THREE.Group`的`children`），我们根据存储在该网格`userdata`信息中的`RigidBody`对象更新`THREE.Mesh`实例的位置和旋转。
- en: 'Before we move on to the most important properties provided by a collider,
    we’ll have a quick look at how gravity affects this scene. When you open this
    example, with the help of the menu on the right, you can change the gravity of
    the world. You can use this to experiment with how the dominos respond to different
    gravity settings. For instance, the following example shows the situation where,
    after all the dominos have fallen, we increased the gravity along the *x*-axis
    and *z*-axis:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续探讨碰撞体提供的重要属性之前，我们将快速查看重力如何影响这个场景。当你打开这个示例时，借助右侧的菜单，你可以改变世界的重力。你可以使用这个功能来实验多米诺对不同的重力设置的反应。例如，以下示例显示了所有多米诺都倒下后，我们增加了沿*x*轴和*z*轴的重力的情况：
- en: '![Figure 12.4 – Dominos with different gravity settings](img/Figure_12.4_B18726.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 不同重力设置的多米诺](img/Figure_12.4_B18726.jpg)'
- en: Figure 12.4 – Dominos with different gravity settings
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 不同重力设置的多米诺
- en: In the next section, we’ll show the effect that setting the friction and restitution
    has on the Rapier objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示设置摩擦和恢复系数对Rapier对象的影响。
- en: Working with restitution and friction
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理恢复和摩擦
- en: In the next example, we’ll look a bit closer at the `restitution` and `friction`
    properties of the `Collider` provided by Rapier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将更详细地查看Rapier提供的`Collider`的`恢复`和`摩擦`属性。
- en: '`restitution` is the property that defines how much energy an object keeps
    after it collides with another object. You can look at it a bit like bounciness.
    A tennis ball has high restitution, while a brick has low restitution.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`恢复`是定义物体在与另一个物体碰撞后保持多少能量的属性。你可以将其视为弹性。网球具有高恢复性，而砖块具有低恢复性。'
- en: '`friction` defines how easily an object glides on top of another object. Objects
    with high friction slow down quickly when moving on top of another object, while
    objects with low friction can easily glide. Something such as ice has low friction,
    while sandpaper has high friction.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`摩擦`定义了一个物体在另一个物体上滑动时的容易程度。具有高摩擦的物体在另一个物体上移动时会迅速减速，而具有低摩擦的物体可以轻易滑动。例如，冰具有低摩擦，而砂纸具有高摩擦。'
- en: 'We can set these properties during the construction of the `RAPIER.ColliderDesc`
    object or set it afterward when we’ve already created the collider using the `(world.createCollider(...)`
    function. Before we look at the code, we’ll have a look at the example. For the
    `colliders-properties.html` example, you’ll see a big box into which you can drop
    shapes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在构建 `RAPIER.ColliderDesc` 对象时设置这些属性，或者在我们已经使用 `(world.createCollider(...)`
    函数创建碰撞体之后设置它。在我们查看代码之前，我们先看看这个例子。对于 `colliders-properties.html` 示例，你会看到一个大的盒子，你可以将形状投入其中：
- en: '![Figure 12.5 – Empty box to drop shapes into](img/Figure_12.5_B18726.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 可将形状投入的空盒子](img/Figure_12.5_B18726.jpg)'
- en: Figure 12.5 – Empty box to drop shapes into
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 可将形状投入的空盒子
- en: With the menu on the right, you can drop in sphere and cube shapes, and set
    the friction and restitution for the added objects. For the first scenario, we’ll
    add a large number of cubes with high friction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用右侧的菜单，你可以投入球体和立方体形状，并设置添加对象的摩擦和恢复系数。对于第一个场景，我们将添加大量具有高摩擦的立方体。
- en: '![Figure 12.6 – Box with cubes with high friction](img/Figure_12.6_B18726.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 高摩擦的立方体盒子](img/Figure_12.6_B18726.jpg)'
- en: Figure 12.6 – Box with cubes with high friction
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 高摩擦的立方体盒子
- en: What you see here is that even though the box is moving around its axis, the
    cubes barely move around. This is because the cubes themselves have very high
    friction. If you try this with low friction, you’ll see that the boxes will slide
    around in the bottom of the box.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是，尽管盒子在其轴周围移动，但立方体几乎不移动。这是因为立方体本身具有非常高的摩擦。如果你用低摩擦尝试，你会看到盒子会在盒子的底部滑动。
- en: 'To set the friction, all you have to do is this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置摩擦，你只需这样做：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Rapier provides one more way of controlling friction and that is by setting
    the combine rule using the `setFrictionCombineRule` function. This tells Rapier
    how to combine the friction of the two objects that have collided (in our example,
    the bottom of the box and the cube). With Rapier, you can set this to the following
    values:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Rapier 提供了一种控制摩擦的额外方法，那就是通过使用 `setFrictionCombineRule` 函数来设置组合规则。这告诉 Rapier
    如何组合两个发生碰撞的物体的摩擦（在我们的例子中，是盒子的底部和立方体）。使用 Rapier，你可以将其设置为以下值：
- en: '`CoefficientCombineRule.Average`: The average of the two coefficients is used'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoefficientCombineRule.Average`：使用两个系数的平均值'
- en: '`CoefficientCombineRule.Min`: The minimum among the two coefficients is used'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoefficientCombineRule.Min`：使用两个系数中的最小值'
- en: '`CoefficientCombineRule.Multiply`: The product of the two coefficients is used'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoefficientCombineRule.Multiply`：使用两个系数的乘积'
- en: '`CoefficientCombineRule.Max`: The maximum among the two coefficients is used'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoefficientCombineRule.Max`：使用两个系数中的最大值'
- en: 'To explore how `restitution` works, we can use this same example (`colliders-properties.html`):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索 `restitution` 的工作原理，我们可以使用这个相同的例子（`colliders-properties.html`）：
- en: '![Figure 12.7 – Box with spheres with high restitution](img/Figure_12.7_B18726.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 高恢复系数的球体盒子](img/Figure_12.7_B18726.jpg)'
- en: Figure 12.7 – Box with spheres with high restitution
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.7 – 高恢复系数的球体盒子](img/Figure_12.7_B18726.jpg)'
- en: 'Here, we’ve increased the restitution of the spheres. The result is that they
    now bounce around in the box when added or when they hit a wall. To set the restitution,
    you use the same approach as for the friction:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们增加了球体的恢复系数。结果是，当添加球体或它们撞击墙壁时，它们现在会在盒子中弹跳。要设置恢复系数，你使用与摩擦相同的方法：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Rapier also allows you to set how the `restitution` property of the objects
    that hit each other is calculated. You can use the same values but this time,
    you use the `setRestitutionCombineRule` function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Rapier 还允许你设置如何计算相互碰撞的物体的 `restitution` 属性。你可以使用相同的值，但这次，你使用 `setRestitutionCombineRule`
    函数。
- en: 'The `Collider` has additional properties you can use to fine-tune how the collider
    interacts with the Rapier view of the world, and what happens when objects collide.
    Rapier itself provides very good documentation for this. Specifically for the
    colliders, you can find that documentation here: [https://rapier.rs/docs/user_guides/javascript/colliders#restitution](https://rapier.rs/docs/user_guides/javascript/colliders#restitution).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collider` 有一些额外的属性，你可以使用它们来微调碰撞体如何与 Rapier 的世界视图交互，以及当物体发生碰撞时会发生什么。Rapier
    本身提供了非常好的文档。特别是对于碰撞体，你可以在以下位置找到该文档：[https://rapier.rs/docs/user_guides/javascript/colliders#restitution](https://rapier.rs/docs/user_guides/javascript/colliders#restitution)。'
- en: Rapier-supported shapes
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rapier 支持的形状
- en: Rapier provides a number of shapes you can use to wrap your geometries. In this
    section, we’ll walk you through all the available Rapier shapes and demonstrate
    these meshes through an example. Note that to use these shapes you need to call
    `RAPIER.ColliderDesc.roundCuboid`, `RAPIER.ColliderDesc.ball`, and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Rapier 提供了一些你可以用来包裹你的几何形状的形状。在本节中，我们将带你了解所有可用的 Rapier 形状，并通过一个示例演示这些网格。请注意，要使用这些形状，你需要调用
    `RAPIER.ColliderDesc.roundCuboid`、`RAPIER.ColliderDesc.ball` 等等。
- en: 'Rapier provides 3D shapes and 2D shapes. We’ll only look at the 3D shapes provided
    by Rapier:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Rapier 提供了 3D 形状和 2D 形状。我们只会查看 Rapier 提供的 3D 形状：
- en: '`ball`: A ball shape, configured by setting the radius of the ball'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`球体`: 一个球形状，通过设置球体的半径来配置'
- en: '`capsule`: A capsule shape, defined by the half-height of the capsule and its
    radius'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`胶囊体`: 一个胶囊形状，由胶囊的半高和半径定义'
- en: '`cuboid`: A simple cube shape defined by passing in the half-width, half-height,
    and half-depth of the shape'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`立方体`: 通过传递形状的半宽、半高和半深度来定义的一个简单的立方体形状'
- en: '`heightfield`: A height field is a shape for which each provided value defines
    the height of a 3D plane'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`高度场`: 高度场是一个形状，其中每个提供的值定义了一个 3D 平面的高度'
- en: '`cylinder`: A cylinder shape defined by the half-height and the radius of the
    cylinder'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`圆柱体`: 一个由圆柱的半高和半径定义的圆柱形状'
- en: '`cone`: A cone shape defined by the half-height and the radius of the bottom
    of the cylinder'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`圆锥体`: 一个由圆柱底部的半高和半径定义的圆锥形状'
- en: '`convexHull`: A convex hull is the smallest shape that encompasses all the
    passed-in points'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`凸包`: 凸包是包含所有传入点的最小形状'
- en: '`convexMesh`: A convex mesh also takes a number of points, but it is assumed
    that these points already form a convex hull, so Rapier won’t make any calculations
    to determine the smaller shape'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`凸多边形网格`: 凸多边形网格也接受一定数量的点，但假设这些点已经形成一个凸包，因此 Rapier 不会进行任何计算来确定较小的形状'
- en: 'Besides these shapes, Rapier also provides an additional rounded variant for
    a few of these shapes: `roundCuboid`, `roundCylinder`, `roundCone`, `roundConvexHull`,
    and `roundConvexMesh`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些形状之外，Rapier 还为这些形状中的几个提供了额外的圆形变体：`roundCuboid`、`roundCylinder`、`roundCone`、`roundConvexHull`
    和 `roundConvexMesh`。
- en: 'We’ve provided another example in which you can what these shapes look like
    and how they interact when they collide with each other. Open up the `shapes.html`
    example to see this in action:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个另一个示例，你可以看到这些形状的外观以及它们在相互碰撞时的交互。打开 `shapes.html` 示例来查看这一功能：
- en: '![Figure 12.8 – Shapes on top of a heightfield object](img/Figure_12.8_B18726.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 在高度场对象上方的形状](img/Figure_12.8_B18726.jpg)'
- en: Figure 12.8 – Shapes on top of a heightfield object
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 在高度场对象上方的形状
- en: When you open this example, you’ll see an empty `heightfield` object. With the
    menu on the right, you can add different shapes and they’ll collide with each
    other and with the `heightfield` instance. Once again, you can set the specific
    `restitution` and `friction` values for the objects you’re adding. Since we’ve
    already explained in the previous sections how to add the shape in Rapier and
    make sure the corresponding shapes in Three.js are updated, we won’t go into detail
    here on how to create the shapes from the previous list. For the code, look at
    the `shapes.js` file in the sources for this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开这个示例时，你会看到一个空的 `heightfield` 对象。通过右侧的菜单，你可以添加不同的形状，它们会相互碰撞，并与 `heightfield`
    实例碰撞。再次强调，你可以为添加的对象设置特定的 `restitution` 和 `friction` 值。由于我们已经在前面的章节中解释了如何在 Rapier
    中添加形状并确保 Three.js 中的相应形状得到更新，所以我们不会在这里详细说明如何从之前的列表中创建形状。对于代码，请查看本章源代码中的 `shapes.js`
    文件。
- en: 'One final note before we move on to the section on joints – when we want to
    depict simple shapes (for example, balls or cubes), the way that Rapier defines
    this model and the way Three.js defines it are pretty much the same. Therefore,
    when this kind of object collides with another object, it will look correct. When
    we have more complex shapes, as, in this example, with a `heightmap` instance,
    there can be slight differences in how Three.js interprets and interpolates these
    points to a `heightmap` instance, and how Rapier does so. You can see this for
    yourself by looking at the `shapes.html` example, adding a lot of different shapes,
    and then looking at the underside of the `heightfield`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入关节部分之前，有一个最后的注意事项——当我们想要描绘简单的形状（例如，球体或立方体）时，Rapier定义这种模型的方式和Three.js定义的方式几乎相同。因此，当这种类型的物体与另一个物体碰撞时，它看起来是正确的。当我们有更复杂的形状时，例如在这个例子中的`高度图`实例，Three.js解释和插值这些点到`高度图`实例的方式以及Rapier这样做的方式可能会有细微的差异。你可以通过查看`shapes.html`示例，添加很多不同的形状，然后查看`高度场`的底部来亲自看到这一点：
- en: '![Figure 12.9 – Bottom of the heightfield](img/Figure_12.9_B18726.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 高度场的底部](img/Figure_12.9_B18726.jpg)'
- en: Figure 12.9 – Bottom of the heightfield
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 高度场的底部
- en: What you can see here is that we can see small parts of the different objects
    poking through the `heightmap`. The reason is that Rapier has a different way
    of determining the exact shape of the `heightmap` than Three.js. In other words,
    Rapier thinks that the `heightmap` looks slightly different than Three.js does.
    Therefore, when it determines where specific shapes are when they collide, it
    can result in small details such as this. However, by tuning the sizes or creating
    simpler objects, this can easily be circumvented.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里可以看到的是，我们可以看到不同物体的微小部分从`高度图`中突出出来。原因是Rapier确定`高度图`的确切形状的方式与Three.js不同。换句话说，Rapier认为`高度图`看起来略不同于Three.js。因此，当它确定特定形状在碰撞时的位置时，可能会导致这样的小细节。然而，通过调整大小或创建更简单的物体，这可以很容易地避免。
- en: So far, we’ve looked at gravity and collisions. Rapier also provides a way to
    limit the movement and rotation of rigid bodies. We’ll explain how Rapier does
    this by using joints.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了重力和碰撞。Rapier还提供了一种限制刚体运动和旋转的方法。我们将通过使用关节来解释Rapier是如何做到这一点的。
- en: Using joints to limit the movement of objects
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关节限制物体的运动
- en: 'Up until now, we’ve seen some basic physics in action. We’ve seen how various
    shapes respond to gravity, friction, and restitution, and how this affects collision.
    Rapier also provides advanced constructs that allow you to limit the movement
    of your objects. In Rapier, these objects are called joints. The following list
    gives an overview of the joints that are available in Rapier:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些基本物理现象。我们看到了各种形状如何响应重力、摩擦和恢复力，以及这如何影响碰撞。Rapier还提供了高级结构，允许您限制物体的运动。在Rapier中，这些物体被称为关节。以下列表概述了Rapier中可用的关节：
- en: '**Fixed joint**: A fixed joint makes sure that two bodies don’t move relative
    to one another. This means that the distance and rotation between these two objects
    will always be the same.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定关节**：固定关节确保两个物体相对于彼此不移动。这意味着这两个物体之间的距离和旋转始终相同。'
- en: '**Spherical joint**: A spherical joint makes sure that the distance between
    two bodies stays the same. The bodies, however, can move around one another on
    all three axes.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**球面关节**：球面关节确保两个物体之间的距离保持不变。然而，这些物体可以在所有三个轴向上围绕彼此移动。'
- en: '**Revolute joint**: With this joint, the distance between the two bodies stays
    the same, and they are allowed to rotate on a single axis – for instance, a steering
    wheel, which can only rotate around a single axis.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转关节**：使用这种关节，两个物体之间的距离保持不变，并且它们可以在一个轴上旋转——例如，方向盘，它只能围绕一个轴旋转。'
- en: '**Prismatic joint**: Similar to the revolute joint but this time, the rotations
    between the objects are fixed, and the objects can move on a single axis. This
    causes a sliding effect – for example, such as a lift moving upward.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑动关节**：与旋转关节类似，但这次，物体之间的旋转是固定的，物体可以在一个轴上移动。这会产生滑动效果——例如，如电梯向上移动。'
- en: In the following sections, we’ll explore these joints and see them in action
    in the examples.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨这些关节，并在示例中看到它们的作用。
- en: Connecting two objects with a fixed joint
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用固定关节连接两个物体
- en: The simplest of joints is a fixed joint. With this joint, you can connect two
    objects, and they’ll stay at the same distance and orientation that is specified
    when this joint is created.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的关节是固定关节。使用这个关节，你可以连接两个对象，并且它们将保持在创建关节时指定的相同距离和方向。
- en: 'This is shown in the `fixed-joint.html` example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `fixed-joint.html` 示例中显示：
- en: '![Figure 12.10 – A fixed joint connecting two joints](img/Figure_12.10_B18726.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 连接两个关节的固定关节](img/Figure_12.10_B18726.jpg)'
- en: Figure 12.10 – A fixed joint connecting two joints
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 连接两个关节的固定关节
- en: 'As you can see in this example, the two cubes move as one. This happens because
    they are connected by a fixed joint. To set this up, we first have to create the
    two `RigidBody` objects and the two `Collider` objects, as we’ve already seen
    in the previous sections. The next thing we need to do is connect these two objects.
    For this, we first need to define `JointData`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本例中可以看到的，两个立方体作为一个整体移动。这是因为它们通过固定关节连接在一起。为了设置这个，我们首先必须创建两个 `RigidBody` 对象和两个
    `Collider` 对象，就像我们在前面的章节中已经看到的那样。接下来我们需要做的是连接这两个对象。为此，我们首先需要定义 `JointData`：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This means that we connect the first object at the position of `{ x: 0.0, y:
    0.0, z: 0.0 }` (its center) to the second object, which is positioned at `{ x:
    2.0, y: 0.0, z: 0.0 }`, where the first object is rotated with a quaternion of
    `{ w: 1.0, x: 0.0, y: 0.0, z: 0.0 }` and the second object is rotated the same
    amount – `{ w: 1.0, x: 0.0, y: 0.0, z: 0.0 }`. The only thing that we need to
    do now is tell the Rapier `world` about this joint and which `RigidBody` objects
    it applies to:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '这意味着我们将第一个物体放置在 `{ x: 0.0, y: 0.0, z: 0.0 }`（其中心）的位置与第二个物体连接，第二个物体位于 `{ x:
    2.0, y: 0.0, z: 0.0 }`，其中第一个物体使用四元数 `{ w: 1.0, x: 0.0, y: 0.0, z: 0.0 }` 进行旋转，第二个物体以相同的量进行旋转
    – `{ w: 1.0, x: 0.0, y: 0.0, z: 0.0 }`。我们现在唯一需要做的是告诉 Rapier `world` 这个关节以及它应用于哪些
    `RigidBody` 对象：'
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last property here defines whether the `RigidBody` should wake up because
    of this joint. A `RigidBody` can be put to sleep when it hasn’t moved for a couple
    of seconds. For joints, it is usually best to just set this to `true` since this
    makes sure that if one of the `RigidBody` objects to which we attach the joint
    is sleeping, `RigidBody` will wake up.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最后一个属性定义了 `RigidBody` 是否因为此关节而唤醒。当 `RigidBody` 几秒钟没有移动时，它可以被置于睡眠状态。对于关节来说，通常最好将其设置为
    `true`，因为这确保了如果我们将关节附加到其中一个 `RigidBody` 对象，而该对象处于睡眠状态，则 `RigidBody` 将被唤醒。
- en: 'Another great way of seeing this joint in action is by using the following
    parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看到这个关节作用的好方法是使用以下参数：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will cause the two cubes to get caught on the floor in the center of the
    scene:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致两个立方体卡在场景中心的地上：
- en: '![Figure 12.11 – A fixed joint connecting two cubes](img/Figure_12.11_B18726.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – 连接两个立方体的固定关节](img/Figure_12.11_B18726.jpg)'
- en: Figure 12.11 – A fixed joint connecting two cubes
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 连接两个立方体的固定关节
- en: Next on our list is the spherical joint.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在我们的列表中是球形关节。
- en: Connecting objects with a spherical joint
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用球形关节连接物体
- en: 'A spherical joint allows two objects to freely move around one another while
    keeping the same distance between these objects. This can be used for ragdoll
    effects or, as we did in this example, creating a chain (`sphere-joint.html`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 球形关节允许两个物体在彼此周围自由移动，同时保持这些物体之间的相同距离。这可以用于布娃娃效果，或者就像我们在本例中所做的那样，创建一个链 (`sphere-joint.html`)：
- en: '![Figure 12.12 – Multiple spheres connected by a spherical joint](img/Figure_12.12_B18726.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 通过球形关节连接的多个球体](img/Figure_12.12_B18726.jpg)'
- en: Figure 12.12 – Multiple spheres connected by a spherical joint
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 通过球形关节连接的多个球体
- en: 'As you can see in this example, we’ve connected a large number of spheres to
    create a chain of spheres. When these spheres hit the cylinder in the middle,
    they’ll wrap around and slowly glide off this cylinder. You can see that while
    the orientation between these spheres changes based on their collisions, the absolute
    distance between the spheres stays the same. So, to set up this example, we’ve
    created a number of spheres with `RigidBody` and `Collider`, similar to the previous
    examples. For each set of two spheres, we also create a joint like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本例中可以看到的，我们已经连接了许多球体来创建一串球体。当这些球体撞击中间的圆柱体时，它们会绕着圆柱体滚动并慢慢滑离这个圆柱体。你可以看到，虽然这些球体之间的方向根据它们的碰撞而改变，但球体之间的绝对距离保持不变。因此，为了设置这个示例，我们创建了许多带有
    `RigidBody` 和 `Collider` 的球体，类似于前面的示例。对于每一对球体，我们还创建了一个类似的关节：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see that we create a joint using `RAPIER.JointData.spherical`. The
    parameters here define the position of the first object, `{ x: 0, y: 0, z: 0 }`,
    and the relative position of the second object, `{ x: xOffset, y: 0, z: 0 }`.
    We do this for all the objects and add the joints to the rapier world using `world.createImpulseJoint(params,
    thisBead,` `previousBead, true)`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以看到我们使用`RAPIER.JointData.spherical`创建了一个关节。这里的参数定义了第一个对象的位置，`{ x: 0, y: 0,
    z: 0 }`，以及第二个对象的相对位置，`{ x: xOffset, y: 0, z: 0 }`。我们对所有对象都这样做，并使用`world.createImpulseJoint(params,
    thisBead, previousBead, true)`将关节添加到Rapier世界中。'
- en: The result is that we’ve got a chain of spheres that is connected using these
    spherical joints.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是我们得到了一个通过这些球形关节连接的球体链。
- en: The next joint, the revolute joint, allows us to restrict the movement of two
    objects by specifying a single axis around which an object is allowed to rotate
    in relation to another object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个关节，转动关节，允许我们通过指定一个对象相对于另一个对象可以围绕其旋转的单轴来限制两个对象的运动。
- en: Limiting rotation with a revolute joint
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用转动关节限制旋转
- en: 'With a revolute joint, it is easy to create gear, wheel, and fan-like constructs
    that rotate around a single axis. The easiest way to explain this is by looking
    at the `revolute-joint.html` example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转动关节，很容易创建齿轮、轮子和风扇等围绕单轴旋转的结构。最容易解释这一点的方法是查看`revolute-joint.html`示例：
- en: '![Figure 12.13 – A cube before it is dropped on a rotating bar](img/Figure_12.13_B18726.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13 – 立方体在掉落在旋转条上之前](img/Figure_12.13_B18726.jpg)'
- en: Figure 12.13 – A cube before it is dropped on a rotating bar
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 立方体在掉落在旋转条上之前
- en: 'In *Figure 12**.13*, you can see a purple cube hovering above a green bar.
    When you enable gravity in the `y` direction, the cube will drop on top of the
    green bar. The center of this green bar is connected to the fixed cube in the
    middle using a revolute joint. The result is that this green bar will now slowly
    rotate because of the weight of the purple cube:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12**.13中，您可以看到一个紫色立方体悬浮在绿色条形上方。当您在`y`方向上启用重力时，立方体会掉在绿色条形上。这个绿色条形的中心通过一个转动关节与中间的固定立方体连接。结果是，这个绿色条形现在会因紫色立方体的重量而慢慢旋转：
- en: '![Figure 12.14 – The bar responding to the weight on one end](img/Figure_12.14_B18726.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14 – 条形对一端重量的反应](img/Figure_12.14_B18726.jpg)'
- en: Figure 12.14 – The bar responding to the weight on one end
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – 条形对一端重量的反应
- en: 'For a revolute joint to work, we once again need two rigid bodies. The Rapier
    part of the gray cube is defined like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使转动关节工作，我们再次需要两个刚体。灰色立方体的Rapier部分定义如下：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This means, that this `RigidBody` will always be in the same location regardless
    of any forces exerted on it. The green bar is defined like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，无论对它施加什么力，这个`RigidBody`都将始终处于相同的位置。绿色条形的定义如下：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Nothing special here, but we have introduced a new property could `angularDamping`.
    With angular damping, Rapier will slowly decrease the rotation speed of a `RigidBody`.
    In our example, this means that the bar will slowly stop rotating after a while.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处，但我们引入了一个新的属性`angularDamping`。有了角阻尼，Rapier会逐渐减小`RigidBody`的旋转速度。在我们的例子中，这意味着条形将在一段时间后慢慢停止旋转。
- en: 'And the box that we’re dropping looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在下落的盒子看起来是这样的：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, at this point, we have defined `RigidBody`. Now, we can connect the fixed
    box with the green bar:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们已经定义了`RigidBody`。现在，我们可以将固定的盒子与绿色的条形连接起来：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first two parameters determine the position at which the two rigid bodies
    are connected (following the same idea as with the fixed joint). The last parameter
    defines the vector at which the bodies can rotate in relation to one another.
    Since our first `RigidBody` is fixed, only the green bar can rotate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数确定两个刚体连接的位置（遵循与固定关节相同的思想）。最后一个参数定义了两个刚体相对于彼此可以旋转的向量。由于我们的第一个`RigidBody`是固定的，只有绿色的条形可以旋转。
- en: The last joint type supported by Rapier is the prismatic joint.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Rapier支持的最后一个关节类型是滑动关节。
- en: Limiting movement to a single axis with a prismatic joint
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用滑动关节限制运动到一个单轴
- en: 'The prismatic joint limits the movement of an object to a single axis. This
    is demonstrated in the following example (`prismatic.html`), where the movement
    of the reddish cube is limited to a single axis:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动关节将对象的运动限制到一个单轴。以下示例（`prismatic.html`）演示了这一点，其中红色立方体的运动被限制到一个单轴：
- en: '![Figure 12.15 – Red cube is limited to one axis](img/Figure_12.15_B18726.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图12.15 – 红色立方体被限制在一个轴上](img/Figure_12.15_B18726.jpg)'
- en: Figure 12.15 – Red cube is limited to one axis
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 红色立方体被限制在一个轴上
- en: In this example, we throw a cube at the green bar with the revolute joint from
    the previous example. This will cause the green bar to spin around its *y*-axis
    at the center and hit the reddish cube. This cube is limited to movement along
    a single axis, and you’ll see it moving along that axis.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用之前示例中的旋转关节将一个立方体投向绿色杆。这将导致绿色杆围绕其*y*-轴在中心旋转并击中红棕色的立方体。这个立方体仅限于沿单轴移动，您会看到它沿着该轴移动。
- en: 'To create the joint for this example, we used the following piece of code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建本例中的关节，我们使用了以下代码片段：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We once again define the position (`{ x: 0.0, y: 0.0, z: 0 }`) of `fixedCubeBody`
    first, which defines the object we’re moving in relation to. Then, we define the
    position of our cube – `{ x: 0.0, y: 0.0, z: 3 }`. Finally, we define the axis
    along which our object is allowed to move. In this case, we defined `{ x: 1, y:
    0, z: 0 }`, which means it is allowed to move along its *x*-axis.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '我们再次定义`fixedCubeBody`的位置（`{ x: 0.0, y: 0.0, z: 0 }`），这定义了我们相对于其移动的对象。然后，我们定义我们立方体的位置
    - `{ x: 0.0, y: 0.0, z: 3 }`。最后，我们定义允许我们的对象移动的轴。在这种情况下，我们定义了`{ x: 1, y: 0, z:
    0 }`，这意味着它允许沿其*x*-轴移动。'
- en: Using joint motors to move objects around their allowed axis
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关节电机在允许的轴上移动物体
- en: 'Spherical, revolute, and prismatic joints also support something called motors.
    With motors, you can move a rigid body along its allowed axis. We haven’t shown
    this in these examples but by using motors, you can add gears that move around
    automatically or create a car where you move the wheels using revolute joints
    with the help of a motor. For more information on motors, see the relevant section
    of the Rapier documentation here: [https://rapier.rs/docs/user_guides/javascript/joints#joint-motors](https://rapier.rs/docs/user_guides/javascript/joints#joint-motors).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 球形、旋转和滑动关节也支持一种称为电机的功能。使用电机，您可以在允许的轴上移动刚体。我们在这几个示例中没有展示这一点，但通过使用电机，您可以添加自动旋转的齿轮或创建一个使用电机通过旋转关节移动轮子的汽车。有关电机的更多信息，请参阅Rapier文档的相关部分：[https://rapier.rs/docs/user_guides/javascript/joints#joint-motors](https://rapier.rs/docs/user_guides/javascript/joints#joint-motors)。
- en: As we mentioned in the *Creating a basic Three.js scene with Rapier* section,
    we’ve only scratched the surface of what is possible with Rapier. Rapier is an
    extensive library with many features that allow fine-tuning and should provide
    support for most cases in which you might need a physics engine. The library is
    actively being developed, and the online documentation is very good.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*使用Rapier创建基本的Three.js场景*部分中提到的，我们只是触及了Rapier可能性的表面。Rapier是一个功能丰富的库，具有许多允许微调的特性，并且应该为可能需要物理引擎的大多数情况提供支持。该库正在积极开发中，在线文档非常好。
- en: With the examples in this chapter and the online documentation, you should be
    able to integrate Rapier into your own scenes even for the features not explained
    in this chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章中的示例和在线文档，您应该能够将Rapier集成到自己的场景中，即使对于本章未解释的功能也是如此。
- en: We’ve mainly looked at 3D models and how to render them in Three.js. However,
    Three.js also provides support for 3D sounds. In the next section, we’ll show
    you an example of how you can add directional sound to a Three.js scene.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要探讨了3D模型及其在Three.js中的渲染方法。然而，Three.js也提供了对3D声音的支持。在下一节中，我们将向您展示如何向Three.js场景添加方向性声音的示例。
- en: Adding sound sources to your scene
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向场景添加声音源
- en: 'Having discussed several relevant topics by now, we have a lot of the ingredients
    in place to create beautiful scenes, games, and other 3D visualizations. What
    we haven’t shown, however, is how to add sounds to your Three.js scene. In this
    section, we’ll look at two Three.js objects that allow you to add sources of sound
    to your scene. This is especially interesting since these sound sources respond
    to the position of the camera:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了几个相关主题，我们已经拥有了创建美丽场景、游戏和其他3D可视化的大量元素。然而，我们尚未展示如何将声音添加到您的Three.js场景中。在本节中，我们将探讨两个允许您向场景添加声音源的Three.js对象。这尤其有趣，因为这些声音源会响应摄像头的位置：
- en: The distance between the sound source and the camera determines the volume of
    the sound source
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声源与摄像头之间的距离决定了声源的音量
- en: The positions of the left-hand side and the right-hand side of the camera determine
    the sound volume of the left-hand side speaker and the right-hand side speaker,
    respectively
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像头左侧和右侧的位置分别决定了左侧扬声器与右侧扬声器的音量
- en: 'The best way to explain this is to see this in action. Open up the `audio.html`
    example in your browser, and you’ll see a scene from [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148),
    *Animations and Moving* *the Camera*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的解释方式是看到这个动作的实际效果。在你的浏览器中打开`audio.html`示例，你会看到一个来自[*第9章*](B18726_09.xhtml#_idTextAnchor148)的场景，*动画和移动*
    *相机*：
- en: '![Figure 12.16 – A scene with audio elements](img/Figure_12.16_B18726.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图12.16 – 带有音频元素的场景](img/Figure_12.16_B18726.jpg)'
- en: Figure 12.16 – A scene with audio elements
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 – 带有音频元素的场景
- en: This example uses the first-person controls we saw in [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148),
    so you can use the arrow keys in combination with the mouse to move around the
    scene. Since browsers don’t support starting audio automatically anymore, first,
    hit the `enableSounds` button in the menu on the right to turn on the sounds.
    When you do this, you’ll hear water coming from somewhere nearby – and you’ll
    be able to hear some cows and some sheep in the distance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了我们在[*第9章*](B18726_09.xhtml#_idTextAnchor148)中看到的**第一人称控制**，因此你可以使用箭头键与鼠标结合来在场景中移动。由于浏览器不再支持自动启动音频，首先，点击右侧菜单中的`enableSounds`按钮来打开声音。当你这样做时，你会听到附近有水声——你将能够听到一些远处的牛和羊。
- en: The water sounds come from the water wheel behind your starting position, the
    sounds from the sheep come from the flock of sheep to the right, and the cow sounds
    are centered on the two oxen pulling the plow. If you use the controls to move
    around the scene, you’ll notice that the sounds change based on where you are
    – the nearer you get to the sheep, the better you’ll hear them, and as you move
    to the left, the sounds of the oxen will be louder. This is something called positional
    audio, where the volume and direction are used to determine how to play the sounds.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 水声来自你起始位置后面的水车，羊群的声音来自右侧的羊群，牛的声音集中在拉犁的两头牛身上。如果你使用控制台在场景中移动，你会注意到声音会根据你的位置而改变——离羊群越近，你听到的声音就越好，当你向左移动时，牛的声音就会更响。这被称为位置音频，其中使用音量和方向来确定如何播放声音。
- en: 'Accomplishing this only takes a small amount of code. The first thing we need
    to do is define a `THREE.AudioListener` object and add it to `THREE.PerspectiveCamera`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个任务只需要很少的代码。我们首先需要做的是定义一个`THREE.AudioListener`对象并将其添加到`THREE.PerspectiveCamera`：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we need to create a `THREE.Mesh` (or a `THREE.Object3D`) instance and
    add a `THREE.PositionalAudio` object to that mesh. This will determine the source
    location of this specific sound:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个`THREE.Mesh`（或`THREE.Object3D`）实例，并将一个`THREE.PositionalAudio`对象添加到该网格中。这将确定这个特定声音的源位置：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see from this code snippet, we first create a standard `THREE.Mesh`
    instance. Next, we create a `THREE.PositionalAudio` object, which we connect to
    the `THREE.AudioListener` object that we created earlier. Finally, we add the
    audio and configure some properties, which define how the sound is played and
    how it behaves:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，我们首先创建一个标准的`THREE.Mesh`实例。接下来，我们创建一个`THREE.PositionalAudio`对象，并将其连接到我们之前创建的`THREE.AudioListener`对象。最后，我们添加音频并配置一些属性，这些属性定义了声音的播放方式和行为：
- en: '`setRefDistance`: This determines the distance from the object at which the
    sound will be reduced in volume.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRefDistance`：这决定了声音在哪个距离上会降低音量。'
- en: '`setLoop`: By default, a sound is played once. By setting this property to
    `true`, the sound loops.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLoop`：默认情况下，声音只播放一次。通过将此属性设置为`true`，声音会循环播放。'
- en: '`setRolloffFactor`: This determines how quickly the volume decreases as you
    move away from the sound source.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRolloffFactor`：这决定了当你远离声音源时音量下降的速度。'
- en: Internally, Three.js uses the Web Audio API ([http://webaudio.github.io/web-audio-api/](http://webaudio.github.io/web-audio-api/))
    to play the sound and determine the correct volume. Not all browsers support this
    specification. The best support currently is from Chrome and Firefox.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，Three.js使用Web Audio API([http://webaudio.github.io/web-audio-api/](http://webaudio.github.io/web-audio-api/))来播放声音并确定正确的音量。并非所有浏览器都支持此规范。目前最好的支持来自Chrome和Firefox。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how you can extend the basic 3D functionality of
    Three.js by adding physics. For this, we used the Rapier library, which allows
    you to add gravity to your scene and objects, have objects interact with each
    other and bounce when they collide, and use joints to limit the movement of objects
    relative to each other.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过添加物理引擎来扩展 Three.js 的基本 3D 功能。为此，我们使用了 Rapier 库，该库允许您为场景和对象添加重力，使对象能够相互交互并在碰撞时弹跳，以及使用关节来限制对象之间的相对运动。
- en: Besides that, we also showed you how Three.js supports 3D sounds. We created
    a scene where you added positional sound using the `THREE.PositionalAudio` and
    `THREE.AudioListener` objects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还向您展示了 Three.js 如何支持 3D 声音。我们创建了一个场景，您可以使用 `THREE.PositionalAudio` 和
    `THREE.AudioListener` 对象添加位置声音。
- en: Even though we’ve now covered all of the core functionalities provided by Three.js,
    there are two more chapters dedicated to exploring some external tools and libraries
    that you can use together with Three.js. In the next chapter, we’ll dive into
    Blender and see how we can use Blender’s functionality, such as baking shadows,
    editing UV maps, and exchanging models between Blender and Three.js.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在已经涵盖了 Three.js 提供的所有核心功能，但还有两个章节专门用于探索一些您可以与 Three.js 一起使用的外部工具和库。在下一章中，我们将深入探讨
    Blender，看看我们如何利用 Blender 的功能，例如烘焙阴影、编辑 UV 映射，以及在 Blender 和 Three.js 之间交换模型。
