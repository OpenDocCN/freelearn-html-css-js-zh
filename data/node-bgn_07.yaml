- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Event-Driven Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: Events are one of the most powerful ways to use Node.js. Node.js was designed
    from the ground up to build event-driven modules. Many core libraries offer an
    events interface that can be used and extended easily. Also, Node.js provides
    a powerful events library that can be used to build event-driven modules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是使用Node.js最强大的方式之一。Node.js从头开始设计就是为了构建事件驱动的模块。许多核心库提供了易于使用和扩展的事件接口。此外，Node.js还提供了一个强大的事件库，可以用来构建事件驱动的模块。
- en: In this chapter, we delve into events in Node.js. We will learn how to use events
    from the core libraries, from event listener registration to event emission, and
    handling multiple listeners for the same event.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究Node.js中的事件。我们将学习如何从核心库中使用事件，从事件监听器注册到事件发射，以及处理同一事件的多个监听器。
- en: We will build our first HTTP server using events, and we will discuss the organization
    of event listeners and the cleanup.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用事件构建我们的第一个HTTP服务器，并讨论事件监听器的组织和清理。
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是本章我们将探讨的主要主题：
- en: Introducing events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍事件
- en: Watching for file changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视文件更改
- en: The Node.js event emitter library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js事件发射器库
- en: Your first HTTP server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的第一个HTTP服务器
- en: Adding an event layer to your modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的模块添加事件层
- en: By the end of this chapter, you will know how to use events and even how to
    include an event interface in your modules.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何使用事件，甚至如何在你的模块中包含事件接口。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)找到
- en: Check out the code in action video for this chapter on [https://youtu.be/opZER2MY1Yc](https://youtu.be/opZER2MY1Yc)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本章动作视频中的代码，视频链接为[https://youtu.be/opZER2MY1Yc](https://youtu.be/opZER2MY1Yc)
- en: Introducing events
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍事件
- en: In the real world, events are occurrences. For example, when you click a button,
    a click event is triggered. When you receive a message, a message received event
    is triggered. When you save a file, a file saved event is triggered. Events are
    present everywhere. In Node.js, events are also present everywhere.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，事件是发生的事情。例如，当你点击一个按钮时，会触发一个点击事件。当你收到一条消息时，会触发一个消息接收事件。当你保存一个文件时，会触发一个文件保存事件。事件无处不在。在Node.js中，事件同样无处不在。
- en: So, when we talk about events in Node.js, we are talking about the same concept
    as in the real world. Events are occurrences, and we produce them or consume them.
    In some cases, one entity produces an event, and another entity consumes it. In
    other cases, the same entity produces and consumes the event. This can be very
    flexible; it is even possible that many entities consume the same event, or many
    entities produce the same event.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们谈论Node.js中的事件时，我们谈论的是与现实世界相同的概念。事件是发生的事情，我们产生它们或消费它们。在某些情况下，一个实体产生一个事件，另一个实体消费它。在其他情况下，同一个实体既产生又消费事件。这可以非常灵活；甚至可能许多实体消费同一个事件，或者许多实体产生同一个事件。
- en: 'If you are familiar with the frontend world, you may have implemented handlers
    when a button is clicked, something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉前端世界，你可能已经实现了当按钮被点击时的处理器，类似于这样：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, the `addEventListener` method receives two arguments, the event
    name and the callback function. The callback function will be called when the
    event is triggered. In this case, the event name is `click`, but you can subscribe
    to many other events, such as `mouseover`, `mouseout`, `keydown`, `keyup`, `change`,
    and `submit`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`addEventListener`方法接收两个参数，事件名称和回调函数。当事件被触发时，将调用回调函数。在这种情况下，事件名称是`click`，但你也可以订阅许多其他事件，例如`mouseover`、`mouseout`、`keydown`、`keyup`、`change`和`submit`。
- en: If you have worked with other programming languages, you may have heard about
    the Observer, Publish/Subscribe, and mediator patterns. In this chapter, we will
    explore how to use the Node.js events library to build event-driven modules and
    explore how the core libraries are using this architecture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与其他编程语言有过合作，你可能听说过观察者、发布/订阅和中介模式。在本章中，我们将探讨如何使用Node.js事件库构建事件驱动的模块，并探讨核心库是如何使用这种架构的。
- en: One of the best ways to get familiar with events is by using the Node.js core
    API to handle files. We can subscribe to events and react when a file is modified.
    So, in the next section, we will explore this topic in detail.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉事件的最佳方式之一是通过使用Node.js核心API来处理文件。我们可以订阅事件，并在文件被修改时做出反应。因此，在下一节中，我们将详细探讨这个主题。
- en: Watching for file changes
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视文件更改
- en: As we are already familiar with the Node.js filesystem library, let’s build
    a simple script that watches for file changes. We will use the `fs.watch` method
    to watch for file changes. This method receives two arguments, the path to the
    file to watch and a callback function that will be called when the file changes.
    The callback function receives two arguments, the event type and the filename.
    The event type can be `rename` or `change`. The `rename` event is triggered when
    the file is renamed or deleted. The change event is triggered when the file is
    modified.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经熟悉Node.js文件系统库，让我们构建一个简单的脚本，用于监视文件更改。我们将使用`fs.watch`方法来监视文件更改。此方法接收两个参数，要监视的文件的路径和当文件更改时将被调用的回调函数。回调函数接收两个参数，事件类型和文件名。事件类型可以是`rename`或`change`。当文件被重命名或删除时，会触发`rename`事件。当文件被修改时，会触发`change`事件。
- en: 'Now, we will create a simple program to detect file changes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的程序来检测文件更改：
- en: 'Let’s create a file called `watch.mjs` and add the following code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`watch.mjs`的文件，并添加以下代码：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a file called `watch.txt` and run the script with the following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`watch.txt`的文件，并使用以下命令运行脚本：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open the watch.txt file, add some text, and save the changes. You will see
    that the script prints the following output:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`watch.txt`文件，添加一些文本，并保存更改。您将看到脚本打印以下输出：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, the `change` event is triggered, and the filename is provided.
    Now, rename the file and save the changes. You will see that the script prints
    the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`change`事件被触发，并提供了文件名。现在，重命名文件并保存更改。您将看到脚本打印以下输出：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will learn how we can implement custom events inside
    of our application and how we can emit and consume them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在我们的应用程序中实现自定义事件，以及如何触发和消费它们。
- en: The Node.js event emitter library
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js事件发射器库
- en: Now that we know how to watch for file changes, let’s explore the Node.js events
    library. This library provides an `EventEmitter` class that can be used to build
    simple interface to register and unregister event listeners and emit events.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何监视文件更改，让我们探索Node.js事件库。这个库提供了一个`EventEmitter`类，可以用来构建简单的接口来注册和注销事件监听器以及触发事件。
- en: 'Let’s create a file called `event-emitter.mjs` and add the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`event-emitter.mjs`的文件，并添加以下代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we created an instance of the `EventEmitter` class and registered
    an event listener for the `message` event. Then, we emit the `message` event with
    the message `Hello world!`. If you run the script, you will see that the message
    is printed in the console.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`EventEmitter`类的实例，并为`message`事件注册了一个事件监听器。然后，我们使用消息`Hello world!`触发`message`事件。如果您运行脚本，您将看到消息在控制台中被打印出来。
- en: 'You can also register multiple event listeners and emitters for the same event;
    this is a common practice when you want to modularize code and/or you want from
    the same event to trigger multiple actions. Let’s say that you receive an incoming
    request, and you want to store a copy of that message and also notify that to
    the final user; by using events, you can handle both actions in parallel. Let’s
    modify the previous example by adding the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为同一事件注册多个事件监听器和发射器；当您想要模块化代码以及/或者您希望从同一事件触发多个操作时，这是一种常见的做法。假设您收到一个传入的请求，并且您想存储该消息的副本并通知最终用户；通过使用事件，您可以并行处理这两个操作。让我们通过添加以下代码修改之前的例子：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s analyze the code. First, we use the `setInterval` method to emit the
    `message` event every second. Then, we register an additional event listener for
    the `message` event. This event listener will be called every time the `message`
    event is emitted. Then, we register an event listener using the `once` method.
    This event listener will be called only once, but if you want to keep listening
    for more than one message, you can use `on` – for example, when you listen for
    incoming request in an HTTP server application. Finally, we use the `setTimeout`
    method to emit the `message` event after 2.5 seconds. If you run the script, you
    will see that the following output is printed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下代码。首先，我们使用`setInterval`方法每秒触发一次`message`事件。然后，我们为`message`事件注册了一个额外的监听器。每当`message`事件被触发时，都会调用此监听器。然后，我们使用`once`方法注册了一个事件监听器。此监听器只会被调用一次，但如果您想监听多个消息，可以使用`on`
    – 例如，在HTTP服务器应用程序中监听传入请求时。最后，我们使用`setTimeout`方法在2.5秒后触发`message`事件。如果您运行脚本，您将看到以下输出：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Preventing chaos by organizing the listeners
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过组织监听器来防止混乱
- en: One important thing to note is that the event listeners are called synchronously.
    This means that the event listeners are called in the same order that they are
    registered. Also, remember that you can use more channels to communicate between
    processes. In our example, we used `message`, but you can use any name you want
    or have multiple channels to better segment communication.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是事件监听器是同步调用的。这意味着事件监听器是按照它们注册的顺序被调用的。此外，请记住，您可以使用更多通道在进程之间进行通信。在我们的示例中，我们使用了`message`，但您可以使用任何您想要的名称，或者有多个通道以更好地分段通信。
- en: Removing listeners when they are not needed
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不需要时移除监听器
- en: 'The `EventEmitter` class provides `removeListener` and `off` methods that can
    be used to remove an event listener, as well as a `removeAllListeners` method
    that can be used to remove all event listeners for a given event. You can find
    more information about it in the official documentation: [https://nodejs.org/docs/latest-v20.x/api/events.html](https://nodejs.org/docs/latest-v20.x/api/events.html).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`类提供了`removeListener`和`off`方法，可以用来移除事件监听器，以及一个`removeAllListeners`方法，可以用来移除给定事件的全部事件监听器。您可以在官方文档中找到更多关于它的信息：[https://nodejs.org/docs/latest-v20.x/api/events.html](https://nodejs.org/docs/latest-v20.x/api/events.html)。'
- en: In the next section, we will create our first HTTP server with Node.js, which
    is one of the most commons ways to use events while doing web applications in
    Node.js.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用Node.js创建我们的第一个HTTP服务器，这是在Node.js中进行Web应用程序开发时使用事件的最常见方式之一。
- en: Your first HTTP server
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个HTTP服务器
- en: Now that we know how to use the `EventEmitter` class, let’s build a simple HTTP
    server. We will use the `http` core library to create the server and the `EventEmitter`
    class to handle the requests. In [*Chapter 9*](B21678_09.xhtml#_idTextAnchor244),
    we will explore in more detail how to build HTTP servers and clients, but for
    now, let’s focus on building our first HTTP server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用`EventEmitter`类，让我们构建一个简单的HTTP服务器。我们将使用`http`核心库创建服务器，并使用`EventEmitter`类来处理请求。在[*第9章*](B21678_09.xhtml#_idTextAnchor244)中，我们将更详细地探讨如何构建HTTP服务器和客户端，但到目前为止，让我们专注于构建我们的第一个HTTP服务器。
- en: 'Let’s create a file called `server.mjs` and add the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`server.mjs`的文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we created an instance of the `http.Server` class and registered
    an event listener for the `request` event. This event listener will be called
    every time a request is received. Then, we use the `writeHead` method to set the
    status code and the content type of the response. Finally, we use the `end` method
    to send the response. If you run the script, you will see that the following output
    is printed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`http.Server`类的实例，并为`request`事件注册了一个事件监听器。每当收到请求时，都会调用此事件监听器。然后，我们使用`writeHead`方法设置响应的状态码和内容类型。最后，我们使用`end`方法发送响应。如果您运行脚本，您将看到以下输出：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And if you open the URL in any browser, you will see your first HTTP server
    in action:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在任何浏览器中打开此URL，您将看到您的第一个HTTP服务器正在运行：
- en: '![Figure 7.1 – A screenshot from the application running](img/B21678_07_1.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 应用程序运行的截图](img/B21678_07_1.jpg)'
- en: Figure 7.1 – A screenshot from the application running
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 应用程序运行的截图
- en: In the next section, we will learn how to encapsulate the events in our modules
    and a lot other components to emit and consume those events easily. This technique
    is quite popular and extendable to many libraries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在我们的模块中封装事件以及许多其他组件，以便轻松地发射和消费这些事件。这种技术相当流行，并且可以扩展到许多库。
- en: Adding an event layer to your modules
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的模块添加事件层
- en: Now that we know how to use the `EventEmitter` class, let’s add an event layer
    to our modules. In this example, we will create a module that will be used to
    save files and emit an event every time a file change is saved.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用`EventEmitter`类，让我们给我们的模块添加一个事件层。在这个例子中，我们将创建一个模块，它将被用来保存文件并在每次文件更改保存时触发一个事件。
- en: 'Let’s create a file called `utils.mjs` and add the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`utils.mjs`的文件，并添加以下代码：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we created an instance of the `EventEmitter` class and exported
    the `save` function. This function will be used to save the file and emit the
    `file:saved` event. Then, we export the `on` method of the `EventEmitter` class.
    This method will be used to register event listeners for the `file:saved` event.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`EventEmitter`类的实例，并导出了`save`函数。这个函数将被用来保存文件并触发`file:saved`事件。然后，我们导出了`EventEmitter`类的`on`方法。这个方法将被用来为`file:saved`事件注册事件监听器。
- en: Important info
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: In the example, we used `bind` to check that the `this` value is correct. You
    can find more information about it in the official documentation at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
    The use of `bind` is quite advanced, so you can skip it for now.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`bind`来检查`this`值的正确性。你可以在官方文档中找到更多关于它的信息：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)。`bind`的使用相当高级，所以你现在可以跳过它。
- en: 'Now, let’s create a file called `index.mjs` and add the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`index.mjs`的文件，并添加以下代码：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you run the script, you will see that the following output is printed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行脚本，你将看到以下输出：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the `file:saved` event is emitted after the `save` function
    is completed. This means that the `save` function does not block the execution
    of the script. In previous examples in the book, we used `then` to handle the
    result of a promise; in this case, we offered an alternative, using events that
    will allow you to decouple the logic of your application more easily.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`file:saved`事件在`save`函数完成后被触发。这意味着`save`函数不会阻塞脚本的执行。在本书的前几个例子中，我们使用了`then`来处理promise的结果；在这种情况下，我们提供了一个替代方案，使用事件可以更容易地解耦应用程序的逻辑。
- en: Summary
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how to use events in Node.js. We learned about
    the `EventEmitter` class and how to use it to emit and listen to events. We also
    learned how to use events to decouple the logic of our applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Node.js中使用事件。我们学习了`EventEmitter`类以及如何使用它来发射和监听事件。我们还学习了如何使用事件来解耦我们应用程序的逻辑。
- en: Additionally, we built a script to watch for changes in files in our system,
    and we also built our first HTTP server and learned how to handle requests using
    events.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还构建了一个脚本来监视我们系统中文件的更改，并且我们还构建了我们的第一个HTTP服务器，并学习了如何使用事件来处理请求。
- en: Finally, we built a simple library that exports an event layer to decouple the
    logic of our applications. This will allow us to build more robust applications
    in future chapters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建了一个简单的库，它导出一个事件层来解耦我们应用程序的逻辑。这将允许我们在未来的章节中构建更健壮的应用程序。
- en: In the next chapter, we will learn how to add tests to our applications. This
    will help us to build more robust applications, avoid bugs, and overall, consolidate
    our knowledge about Node.js while learning it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将测试添加到我们的应用程序中。这将帮助我们构建更健壮的应用程序，避免错误，并且总体上，在学习Node.js的同时巩固我们对Node.js的知识。
- en: Further reading
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Refactoring Guru – the Mediator* *pattern*: [https://refactoring.guru/design-patterns/mediator](https://refactoring.guru/design-patterns/mediator)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构大师 – 中介* *模式*：[https://refactoring.guru/design-patterns/mediator](https://refactoring.guru/design-patterns/mediator)'
- en: '*Refactoring Guru – the Observer* *pattern*: [https://refactoring.guru/design-patterns/observer](https://refactoring.guru/design-patterns/observer)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构大师 – 观察者* *模式*：[https://refactoring.guru/design-patterns/observer](https://refactoring.guru/design-patterns/observer)'
- en: '*NodeConf Remote 2020 - Anna Henningsen - Node.js and the struggles of being
    an* *EventTarget*: [https://www.youtube.com/watch?v=SOPC3aLoD4U](https://www.youtube.com/watch?v=SOPC3aLoD4U)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NodeConf Remote 2020 - 安娜·亨宁森 - Node.js以及作为* *EventTarget* *的挑战*: [https://www.youtube.com/watch?v=SOPC3aLoD4U](https://www.youtube.com/watch?v=SOPC3aLoD4U)'
- en: '*The Node.js event* *emitter*: [https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter](https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Node.js事件发射器*: [https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter](https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter)'
