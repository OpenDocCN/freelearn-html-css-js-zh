- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Module System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块系统
- en: In *Chapter 1*, *The Node.js Platform*, we briefly introduced the importance
    of modules in Node.js. We discussed how modules play a fundamental role in defining
    some of the pillars of the Node.js philosophy and its programming experience.
    But what do we actually mean when we talk about modules and why are they so important?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*Node.js 平台*中，我们简要介绍了模块在 Node.js 中的重要性。我们讨论了模块如何在定义 Node.js 哲学和编程体验的一些支柱中扮演基础角色。但当我们谈论模块时，我们实际上指的是什么？为什么它们如此重要？
- en: In generic terms, modules are the bricks for structuring non-trivial applications.
    Modules allow you to divide the codebase into small units that can be developed
    and tested independently. Modules are also the main mechanism to enforce information
    hiding by keeping private all the functions and variables that are not explicitly
    marked to be exported.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用通用术语来说，模块是非平凡应用程序的砖块。模块允许你将代码库划分为可以独立开发和测试的小单元。模块也是通过保持所有未明确标记为导出的函数和变量私有来强制信息隐藏的主要机制。
- en: 'If you come from other languages, you have probably seen similar concepts being
    referred to with different names: **package** (Java, Go, PHP, Rust, or Dart),
    **assembly** (.NET), **library** (Ruby), or **unit** (Pascal dialects). The terminology
    is not perfectly interchangeable because every language or ecosystem comes with
    its own unique characteristics, but there is a significant overlap between these
    concepts.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自其他语言，你可能已经看到过类似的概念被不同的名称所提及：**包**（Java、Go、PHP、Rust 或 Dart）、**组件**（.NET）、**库**（Ruby）或
    **单元**（Pascal 方言）。术语并不是完全可互换的，因为每种语言或生态系统都有自己的独特特征，但这些概念之间存在显著的相似性。
- en: 'Interestingly enough, Node.js currently comes with two different module systems:
    **CommonJS** (**CJS**) and **ECMAScript modules** (**ESM** or **ES modules**).
    In this chapter, we will discuss why there are two alternatives, we will learn
    about their pros and cons, and, finally, we will analyze several common patterns
    that are relevant when using or writing Node.js modules. By the end of this chapter,
    you should be able to make pragmatic choices about how to use modules effectively
    and how to write your own custom modules.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的是，Node.js 目前有两个不同的模块系统：**CommonJS**（**CJS**）和 **ECMAScript 模块**（**ESM**
    或 **ES 模块**）。在本章中，我们将讨论为什么存在两种选择，我们将了解它们的优缺点，最后，我们将分析一些在使用或编写 Node.js 模块时相关的常见模式。到本章结束时，你应该能够做出实用的选择，关于如何有效地使用模块以及如何编写你自己的自定义模块。
- en: Getting a good grasp of Node.js' module systems and module patterns is very
    important as we will rely on this knowledge in all the other chapters of this
    book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Node.js 的模块系统和模块模式非常重要，因为我们将在这个书的其他章节中依赖这些知识。
- en: 'In short, these are the main topics we will be discussing throughout this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是我们将在本章中讨论的主要主题：
- en: Why modules are necessary and the different module systems available in Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块为什么是必要的以及 Node.js 中可用的不同模块系统
- en: CommonJS internals and module patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 内部和模块模式
- en: ES modules (ESM) in Node.js
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 中的 ES 模块（ESM）
- en: Differences and interoperability between CommonJS and ESM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 和 ESM 之间的差异和互操作性
- en: Let's begin with why we need modules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为什么我们需要模块开始。
- en: The need for modules
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的需求
- en: 'A good module system should help with addressing some fundamental needs of software
    engineering:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的模块系统应该有助于解决软件工程的一些基本需求：
- en: '*Having a way to split the codebase into multiple files*. This helps with keeping
    the code more organized, making it easier to understand but also helps with developing
    and testing various pieces of functionality independently from each other.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有一种方法可以将代码库分割成多个文件*。这有助于使代码更加有序，更容易理解，同时也便于独立开发和测试各种功能。'
- en: '*Allowing code reuse across different projects*. A module can, in fact, implement
    a generic feature that can be useful for different projects. Organizing such functionality
    within a module can make it easier to bring it into the different projects that
    may want to use it.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*允许代码在不同项目之间重用*。实际上，一个模块可以实现一个通用的功能，这可能对不同的项目都有用。在模块中组织这样的功能可以使其更容易被引入可能希望使用它的不同项目中。'
- en: '*Encapsulation* (or *information hiding*). It is generally a good idea to hide
    implementation complexity and only expose simple interfaces with clear responsibilities.
    Most module systems allow to selectively keep the *private* part of the code hidden,
    while exposing a *public* interface, such as functions, classes, or objects that
    are meant to be used by the consumers of the module.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*封装*（或 *信息隐藏*）。通常，隐藏实现复杂性并仅暴露具有明确职责的简单接口是一个好主意。大多数模块系统允许选择性地隐藏代码的 *私有* 部分，同时暴露一个
    *公共* 接口，例如函数、类或对象，这些对象旨在被模块的消费者使用。'
- en: '*Managing dependencies*. A good module system should make it easy for module
    developers to build on top of existing modules, including third-party ones. A
    module system should also make it easy for module users to import the chain of
    dependencies that are necessary for a given module to run (transient dependencies).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理依赖关系*。一个好的模块系统应该使模块开发者能够构建在现有模块之上，包括第三方模块。模块系统还应该使模块用户能够导入给定模块运行所需的依赖链（临时依赖）。'
- en: It is important to clarify the distinction between *a module* and *a module
    system*. We can define a module as the actual unit of software, while a module
    system is the syntax and the tooling that allows us to define modules and to use
    them within our projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 很重要要明确区分 *模块* 和 *模块系统*。我们可以将模块定义为实际的软件单元，而模块系统是允许我们在项目中定义模块并使用它们的语法和工具。
- en: Module systems in JavaScript and Node.js
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 和 Node.js 中的模块系统
- en: Not all programming languages come with a built-in module system, and JavaScript
    had been lacking this feature for a long time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有编程语言都内置了模块系统，JavaScript 在很长一段时间内都缺少这一功能。
- en: In the browser landscape, it is possible to split the codebase into multiple
    files and then import them by using different `<script>` tags. For many years,
    this approach was good enough to build simple interactive websites, and JavaScript
    developers managed to get things done without having a fully-fledged module system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器环境中，可以通过使用不同的 `<script>` 标签将代码库拆分为多个文件，然后通过这些标签导入它们。多年来，这种方法足以构建简单的交互式网站，JavaScript
    开发者也设法在没有完全成熟的模块系统的情况下完成任务。
- en: Only when JavaScript browser applications became more complicated and frameworks
    like *jQuery*, *Backbone*, and *AngularJS* took over the ecosystem, the JavaScript
    community came up with several initiatives aimed at defining a module system that
    could be effectively adopted within JavaScript projects. The most successful ones
    were **asynchronous module definition** (**AMD**), popularized by RequireJS ([nodejsdp.link/requirejs](http://nodejsdp.link/requirejs)),
    and later **Universal Module Definition** (**UMD** – [nodejsdp.link/umd](http://nodejsdp.link/umd)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 JavaScript 浏览器应用程序变得更加复杂，并且像 *jQuery*、*Backbone* 和 *AngularJS* 这样的框架接管了生态系统时，JavaScript
    社区才提出了几个旨在定义一个可以在 JavaScript 项目中有效采用的模块系统的倡议。其中最成功的是 **异步模块定义** (**AMD**)，由 RequireJS
    ([nodejsdp.link/requirejs](http://nodejsdp.link/requirejs)) 推广，后来是 **通用模块定义**
    (**UMD** – [nodejsdp.link/umd](http://nodejsdp.link/umd))。
- en: When Node.js was created, it was conceived as a server runtime for JavaScript
    with direct access to the underlying filesystem so there was a unique opportunity
    to introduce a different way to manage modules. The idea was not to rely on HTML
    `<script>` tags and resources accessible through URLs. Instead, the choice was
    to rely purely on JavaScript files available on the local filesystem. For its
    module system, Node.js came up with an implementation of the *CommonJS* specification
    (sometimes also referred to as *CJS*, [nodejsdp.link/commonjs](http://nodejsdp.link/commonjs)),
    which was designed to provide a module system for JavaScript in browserless environments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Node.js 被创建时，它被构想为具有直接访问底层文件系统的 JavaScript 服务器运行时，因此有独特的机遇引入一种不同的模块管理方式。这个想法不是依赖于
    HTML `<script>` 标签和通过 URL 可访问的资源。相反，选择完全依赖于本地文件系统上的 JavaScript 文件。对于其模块系统，Node.js
    提出了一种 *CommonJS* 规范（有时也称为 *CJS*，[nodejsdp.link/commonjs](http://nodejsdp.link/commonjs)）的实现，该规范旨在为无浏览器的环境提供
    JavaScript 的模块系统。
- en: CommonJS has been the dominant module system in Node.js since its inception
    and it has become very prominent also in the browser landscape thanks to *module
    bundlers* like Browserify ([nodejsdp.link/browserify](http://nodejsdp.link/browserify))
    and webpack ([nodejsdp.link/webpack](http://nodejsdp.link/webpack)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS自从Node.js诞生以来一直是Node.js中的主导模块系统，也因*模块打包器*如Browserify ([nodejsdp.link/browserify](http://nodejsdp.link/browserify))
    和webpack ([nodejsdp.link/webpack](http://nodejsdp.link/webpack))而在浏览器环境中变得非常突出。
- en: 'In 2015, with the release of *ECMAScript 6* (also called *ECMAScript 2015*
    or *ES2015*), there was finally an official proposal for a standard module system:
    *ESM* or *ECMAScript modules*. ESM brings a lot of innovation in the JavaScript
    ecosystem and, among other things, it tries to bridge the gap between how modules are
    managed on browsers and servers.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，随着*ECMAScript 6*（也称为*ECMAScript 2015*或*ES2015*）的发布，终于提出了一个标准模块系统的官方提案：*ESM*或*ECMAScript模块*。ESM为JavaScript生态系统带来了许多创新，其中之一就是试图弥合浏览器和服务器上模块管理的差距。
- en: ECMAScript 6 defined only the formal specification for ESM in terms of syntax
    and semantics, but it didn't provide any implementation details. It took different
    browser companies and the Node.js community several years to come up with solid
    implementations of the specification. Node.js ships with stable support for ESM
    starting from version 13.2.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6仅定义了ESM的语法和语义方面的正式规范，但没有提供任何实现细节。不同的浏览器公司和Node.js社区花费了几年的时间才提出了该规范的稳固实现。从版本13.2开始，Node.js提供了对ESM的稳定支持。
- en: At the time of writing, the general feeling is that ESM is going to become the
    de facto way to manage JavaScript modules in both the browser and the server landscape.
    The reality today, though, is that the majority of projects are still heavily
    relying on CommonJS and it will take some time for ESM to catch up and eventually
    become the dominant standard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，普遍的看法是ESM将成为浏览器和服务器环境中管理JavaScript模块的事实标准。然而，现实情况是，大多数项目仍然严重依赖CommonJS，ESM要赶上并最终成为主导标准还需要一段时间。
- en: To provide a comprehensive overview of module-related patterns in Node.js, in
    the first part of this chapter, we will discuss them in the context of CommonJS,
    and then, in the second part of the chapter, we will revisit our learnings using
    ESM.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个关于Node.js中模块相关模式的全面概述，在本章的第一部分，我们将以CommonJS的上下文来讨论它们，然后在章节的第二部分，我们将使用ESM回顾我们的学习成果。
- en: The goal of this chapter is to make you comfortable with both module systems,
    but in the rest of the book, we will only be using ESM for our code examples.
    The idea is to encourage you to leverage ESM as much as possible so that your
    code will be more future-proof.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是让你对这两种模块系统都感到舒适，但在本书的其余部分，我们只将使用ESM作为我们的代码示例。我们的想法是鼓励你尽可能多地利用ESM，这样你的代码将更具未来性。
- en: If you are reading this chapter a few years after its publication, you are probably
    not too worried about CommonJS, and you might want to jump straight into the ESM
    part. This is probably fine, but we still encourage you to go through the entire
    chapter, because understanding CommonJS and its characteristics will certainly
    be beneficial in helping you to understand ESM and its strengths in much more
    depth.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这本书出版几年后阅读这一章，你可能不太担心CommonJS，你可能想直接跳到ESM部分。这可能没问题，但我们仍然鼓励你通读整个章节，因为理解CommonJS及其特性无疑将有助于你更深入地理解ESM及其优势。
- en: The module system and its patterns
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块系统和其模式
- en: As we said, modules are the bricks for structuring non-trivial applications
    and the main mechanism to enforce information hiding by keeping private all the
    functions and variables that are not explicitly marked to be exported.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，模块是非平凡应用的结构基石，也是通过保持所有未明确标记为导出的函数和变量私有来强制信息隐藏的主要机制。
- en: Before getting into the specifics of CommonJS, let's discuss a generic pattern
    that helps with information hiding and that we will be using for building a simple
    module system, which is the **revealing module pattern**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨CommonJS的具体细节之前，让我们讨论一个通用的模式，这个模式有助于信息隐藏，我们将在构建简单的模块系统中使用它，即**揭示模块模式**。
- en: The revealing module pattern
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示模块模式
- en: One of the bigger problems with JavaScript in the browser is the lack of namespacing. Every
    script runs in the global scope; therefore, internal application code or third-party
    dependencies can pollute the scope while exposing their own pieces of functionality.
    This can be extremely harmful. Imagine, for instance, that a third-party library
    instantiates a global variable called `utils`. If any other library, or the application
    code itself, accidentally overrides or alters `utils`, the code that relies on
    it will likely crash in some unpredictable way. Unpredictable side effects can
    also happen if other libraries or the application code accidentally invoke a function
    of another library meant for internal use only.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在浏览器中的一个较大问题是缺乏命名空间。每个脚本都在全局作用域中运行；因此，内部应用程序代码或第三方依赖项可能会污染作用域，同时暴露它们自己的功能片段。这可能会非常有害。例如，想象一下，一个第三方库实例化了一个名为
    `utils` 的全局变量。如果任何其他库或应用程序代码意外地覆盖或修改了 `utils`，依赖于它的代码可能会以某种不可预测的方式崩溃。如果其他库或应用程序代码意外地调用了仅用于内部使用的另一个库的函数，也可能发生不可预测的副作用。
- en: In short, relying on the global scope is a very risky business, especially as
    your application grows and you have to rely more and more on functionality implemented
    by other individuals.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，依赖于全局作用域是非常危险的，尤其是在你的应用程序增长并越来越多地依赖于其他个人实现的功能时。
- en: 'A popular technique to solve this class of problems is called the *revealing
    module pattern*, and it looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这类问题的一个流行技术被称为**揭示模块模式**，其形式如下：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This pattern leverages a self-invoking function. This type of function is sometimes
    also referred to as **Immediately Invoked Function Expression** (**IIFE**) and
    it is used to create a private scope, exporting only the parts that are meant
    to be public.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式利用了自调用函数。这种类型的函数有时也被称为**立即执行函数表达式**（**IIFE**），它用于创建一个私有作用域，仅导出那些打算公开的部分。
- en: In JavaScript, variables created inside a function are not accessible from the
    outer scope (outside the function). Functions can use the `return` statement to
    selectively propagate information to the outer scope.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，函数内部创建的变量不能从外部作用域（函数外部）访问。函数可以使用 `return` 语句有选择性地将信息传播到外部作用域。
- en: This pattern is essentially exploiting these properties to keep the private
    information hidden and export only a public-facing API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式本质上是在利用这些属性来隐藏私有信息，并仅导出面向公众的 API。
- en: In the preceding code, the `myModule` variable contains only the exported API,
    while the rest of the module content is practically inaccessible from outside.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`myModule` 变量只包含导出的 API，而模块的其他内容实际上从外部几乎无法访问。
- en: 'The `log` statement is going to print something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 语句将打印出类似以下内容：'
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This demonstrates that only the `exported` properties are directly accessible
    from `myModule`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明只有 `exported` 属性可以直接从 `myModule` 访问。
- en: As we will see in a moment, the idea behind this pattern is used as a base for
    the CommonJS module system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将看到的，这种模式背后的思想被用作 CommonJS 模块系统的基础。
- en: CommonJS modules
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS 模块
- en: CommonJS is the first module system originally built into Node.js. Node.js'
    CommonJS implementation respects the CommonJS specification, with the addition
    of some custom extensions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS 是最初内置到 Node.js 中的第一个模块系统。Node.js 的 CommonJS 实现遵循 CommonJS 规范，并增加了一些自定义扩展。
- en: 'Let''s summarize two of the main concepts of the CommonJS specification:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下 CommonJS 规范的两个主要概念：
- en: '`require` is a function that allows you to import a module from the local filesystem'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require` 是一个函数，允许你从本地文件系统中导入一个模块'
- en: '`exports` and `module.exports` are special variables that can be used to export
    public functionality from the current module'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports` 和 `module.exports` 是特殊的变量，可以用来从当前模块导出公共功能。'
- en: This information is sufficient for now; we will learn more details and some
    of the nuances of the CommonJS specification in the next few sections.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这些信息已经足够了；我们将在接下来的几节中学习更多关于 CommonJS 规范的细节和一些细微差别。
- en: A homemade module loader
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个自制的模块加载器
- en: To understand how CommonJS works in Node.js, let's build a similar system from
    scratch. The code that follows creates a function that mimics a subset of the
    functionality of the original `require()` function of Node.js.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 CommonJS 在 Node.js 中的工作方式，让我们从头开始构建一个类似的系统。下面的代码创建了一个函数，它模拟了 Node.js 原始
    `require()` 函数的一部分功能。
- en: 'Let''s start by creating a function that loads the content of a module, wraps
    it into a private scope, and evaluates it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个函数，该函数加载模块的内容，将其封装在私有作用域中，并对其进行评估：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The source code of a module is essentially wrapped into a function, as it was
    for the revealing module pattern. The difference here is that we pass a list of
    variables to the module, in particular, `module`, `exports`, and `require`. Make
    a note of how the `exports` argument of the wrapping function is initialized with
    the content of `module.exports`, as we will talk about this later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的源代码本质上被封装在一个函数中，就像在揭示模块模式中一样。这里的区别在于我们向模块传递了一个变量列表，特别是`module`、`exports`和`require`。请注意，封装函数的`exports`参数是如何初始化为`module.exports`的内容的，因为我们稍后将会讨论这一点。
- en: Another important detail to mention is that we are using `readFileSync` to read
    the module's content. While it is generally not recommended to use the synchronous
    version of the filesystem APIs, here it makes sense to do so. The reason for that
    is that loading modules in CommonJS are deliberately synchronous operations. This
    approach makes sure that, if we are importing multiple modules, they (and their
    dependencies) are loaded in the right order. We will talk more about this aspect
    later in the chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要提及的重要细节是，我们正在使用`readFileSync`来读取模块的内容。虽然通常不建议使用文件系统API的同步版本，但在这里这样做是有意义的。这样做的原因是，在CommonJS中加载模块是故意同步操作。这种方法确保了，如果我们正在导入多个模块，它们（及其依赖项）将以正确的顺序加载。我们将在本章稍后讨论这个方面。
- en: Bear in mind that this is only an example, and you will rarely need to evaluate
    some source code in a real application. Features such as `eval()` or the functions
    of the `vm` module ([nodejsdp.link/vm](http://nodejsdp.link/vm)) can be easily
    used in the wrong way or with the wrong input, thus opening a system to code injection
    attacks. They should always be used with extreme care or avoided altogether.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这只是一个示例，在实际应用中你很少需要评估某些源代码。例如`eval()`或`vm`模块（[nodejsdp.link/vm](http://nodejsdp.link/vm)）的功能可能会被错误地使用或输入错误，从而打开代码注入攻击的系统。它们应该始终谨慎使用或完全避免。
- en: 'Let''s now implement the `require()` function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在实现`require()`函数：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous function simulates the behavior of the original `require()` function
    of Node.js, which is used to load a module. Of course, this is just for educational
    purposes and does not accurately or completely reflect the internal behavior of
    the real `require()` function, but it's great to understand the internals of the
    Node.js module system, including how a module is defined and loaded.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能模拟了Node.js原始`require()`函数的行为，该函数用于加载模块。当然，这只是为了教育目的，并不准确或完整地反映了真实`require()`函数的内部行为，但了解Node.js模块系统的内部结构，包括模块的定义和加载方式是非常有用的。
- en: 'What our homemade module system does is explained as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`homemade module`系统的工作原理如下所述：
- en: A module name is accepted as input, and the very first thing that we do is resolve
    the full path of the module, which we call `id`. This task is delegated to `require.resolve()`,
    which implements a specific resolving algorithm (we will talk about it later).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块名称被接受为输入，我们首先要做的事情是解析模块的完整路径，我们称之为`id`。这个任务委托给`require.resolve()`，它实现了一个特定的解析算法（我们稍后将会讨论）。
- en: If the module has already been loaded in the past, it should be available in the
    cache. If this is the case, we just return it immediately.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模块之前已经被加载过，它应该存在于缓存中。如果是这种情况，我们立即返回它。
- en: If the module has never been loaded before, we set up the environment for the
    first load. In particular, we create a `module` object that contains an `exports` property
    initialized with an empty object literal. This object will be populated by the
    code of the module to export its public API.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模块之前从未被加载过，我们为第一次加载设置环境。特别是，我们创建一个包含`exports`属性的`module`对象，该属性初始化为一个空对象字面量。这个对象将由模块的代码填充以导出其公共API。
- en: After the first load, the `module` object is cached.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一次加载后，`module`对象被缓存。
- en: The module source code is read from its file and the code is evaluated, as we
    saw before. We provide the module with the `module` object that we just created,
    and a reference to the `require()` function. The module exports its public API
    by manipulating or replacing the `module.exports` object.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块源代码从其文件中读取，并像之前看到的那样进行评估。我们向模块提供我们刚刚创建的`module`对象以及`require()`函数的引用。模块通过操作或替换`module.exports`对象来导出其公共API。
- en: Finally, the content of `module.exports`, which represents the public API of the module,
    is returned to the caller.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`module.exports` 的内容，它代表了模块的公共 API，被返回给调用者。
- en: As we can see, there is nothing magical behind the workings of the Node.js module
    system. The trick is all in the wrapper we create around a module's source code
    and the artificial environment in which we run it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Node.js 模块系统的运作并没有什么神奇之处。技巧全部在于我们围绕模块源代码创建的包装以及我们运行它的模拟环境。
- en: Defining a module
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个模块
- en: 'By looking at how our custom `require()` function works, we should now be able
    to understand how to define a module. The following code gives us an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们的自定义 `require()` 函数是如何工作的，我们现在应该能够理解如何定义一个模块。以下代码提供了一个示例：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The essential concept to remember is that everything inside a module is private
    unless it's assigned to the `module.exports` variable. The content of this variable
    is then cached and returned when the module is loaded using `require()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的基本概念是，除非被分配给 `module.exports` 变量，否则模块内部的所有内容都是私有的。当模块使用 `require()` 加载时，这个变量的内容会被缓存并返回。
- en: module.exports versus exports
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`module.exports` 与 `exports`'
- en: For many developers who are not yet familiar with Node.js, a common source of
    confusion is the difference between using `exports` and `module.exports` to expose
    a public API. The code of our custom `require()` function should again clear any
    doubt. The `exports` variable is just a reference to the initial value of `module.exports`.
    We have seen that such a value is essentially a simple object literal created
    before the module is loaded.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多还不熟悉 Node.js 的开发者来说，使用 `exports` 和 `module.exports` 来公开公共 API 的区别是一个常见的混淆来源。我们的自定义
    `require()` 函数的代码再次消除了任何疑虑。`exports` 变量只是 `module.exports` 初始值的引用。我们已经看到，这样的值本质上是在模块加载之前创建的一个简单的对象字面量。
- en: 'This means that we can only attach new properties to the object referenced
    by the `exports` variable, as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们只能向由 `exports` 变量引用的对象附加新属性，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Reassigning the `exports` variable doesn''t have any effect, because it doesn''t
    change the content of `module.exports`. It will only reassign the variable itself.
    The following code is therefore wrong:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重新分配 `exports` 变量没有任何效果，因为它不会改变 `module.exports` 的内容。它只会重新分配变量本身。因此，以下代码是错误的：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we want to export something other than an object literal, such as a function,
    an instance, or even a string, we have to reassign `module.exports` as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要导出除了对象字面量之外的内容，比如一个函数、一个实例，甚至是字符串，我们必须按照以下方式重新分配 `module.exports`：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The require function is synchronous
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`require` 函数是同步的'
- en: 'A very important detail that we should take into account is that our homemade `require()` function
    is synchronous. In fact, it returns the module contents using a simple direct
    style, and no callback is required. This is true for the original Node.js `require()` function
    too. As a consequence, any assignment to `module.exports` must be synchronous
    as well. For example, the following code is incorrect and it will cause trouble:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意的一个非常重要的细节是，我们自制的 `require()` 函数是同步的。实际上，它使用简单的直接方式返回模块内容，并且不需要回调。这同样适用于原始的
    Node.js `require()` 函数。因此，对 `module.exports` 的任何赋值都必须是同步的。例如，以下代码是不正确的，它会导致问题：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The synchronous nature of `require()` has important repercussions on the way
    we define modules, as it limits us to mostly using synchronous code during the definition
    of a module. This is one of the most important reasons why the core Node.js libraries
    offer synchronous APIs as an alternative to most of the asynchronous ones.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`require()` 的同步特性对我们定义模块的方式有重要影响，因为它限制我们在模块定义过程中主要使用同步代码。这是为什么核心 Node.js 库提供同步
    API 作为大多数异步 API 的替代方案的一个重要原因。'
- en: If we need some asynchronous initialization steps for a module, we can always
    define and export an uninitialized module that is initialized asynchronously at
    a later time. The problem with this approach, though, is that loading such a module
    using `require()` does not guarantee that it's ready to be used. In *Chapter 11*,
    *Advanced Recipes*, we will analyze this problem in detail and present some patterns
    to solve this issue elegantly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为模块添加一些异步初始化步骤，我们总是可以定义并导出一个未初始化的模块，该模块将在稍后异步初始化。然而，这种方法的问题在于，使用 `require()`
    加载这样的模块并不能保证它已经准备好使用。在 *第 11 章*，*高级技巧* 中，我们将详细分析这个问题，并提出一些优雅地解决这个问题的模式。
- en: For the sake of curiosity, you might want to know that in its early days, Node.js
    used to have an asynchronous version of `require()`, but it was soon removed because
    it was overcomplicating a functionality that was actually only meant to be used
    at initialization time and where asynchronous I/O brings more complexities than
    advantages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足好奇心，你可能想知道，在Node.js的早期阶段，它曾经有一个异步版本的`require()`，但很快就被移除了，因为它过于复杂化了一个实际上只应在初始化时使用且异步I/O带来的复杂性大于优势的功能。
- en: The resolving algorithm
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析算法
- en: The term *dependency hell* describes a situation whereby two or more dependencies
    of a program in turn depend on a shared dependency, but require different incompatible
    versions. Node.js solves this problem elegantly by loading a different version
    of a module depending on where the module is loaded from. All the merits of this
    feature go to the way Node.js package managers (such as npm or yarn) organize
    the dependencies of the application, and also to the resolving algorithm used
    in the `require()` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*依赖地狱*描述了一种情况，即两个或多个程序依赖项依次依赖于一个共享依赖项，但需要不同的不兼容版本。Node.js通过根据模块加载的位置加载模块的不同版本优雅地解决了这个问题。所有这个特性的优点都归功于Node.js包管理器（如npm或yarn）组织应用程序依赖项的方式，以及`require()`函数中使用的解析算法。
- en: 'Let''s now give a quick overview of this algorithm. As we saw, the `resolve()` function
    takes a module name (which we will call `moduleName`) as input and it returns
    the full path of the module. This path is then used to load its code and also
    to identify the module uniquely. The resolving algorithm can be divided into the
    following three major branches:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们快速概述一下这个算法。正如我们所见，`resolve()`函数接受一个模块名称（我们将称之为`moduleName`）作为输入，并返回模块的完整路径。然后使用此路径来加载其代码，并用于唯一标识该模块。解析算法可以分为以下三个主要分支：
- en: '**File modules**: If `moduleName` starts with `/`, it is already considered
    an absolute path to the module and it''s returned as it is. If it starts with `./`,
    then `moduleName` is considered a relative path, which is calculated starting
    from the directory of the requiring module.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件模块**：如果`moduleName`以`/`开头，它已经被视为模块的绝对路径，并按原样返回。如果它以`./`开头，则`moduleName`被视为相对路径，该路径从要求模块的目录开始计算。'
- en: '**Core modules**: If `moduleName` is not prefixed with `/` or `./`, the algorithm
    will first try to search within the core Node.js modules.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心模块**：如果`moduleName`不以`/`或`./`开头，算法将首先尝试在核心Node.js模块中搜索。'
- en: '**Package modules**: If no core module is found matching `moduleName`, then
    the search continues by looking for a matching module in the first `node_modules` directory
    that is found navigating up in the directory structure starting from the requiring
    module. The algorithm continues to search for a match by looking into the next `node_modules` directory
    up in the directory tree, until it reaches the root of the filesystem.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包模块**：如果没有找到与`moduleName`匹配的核心模块，则搜索将继续，通过在从要求模块开始向上导航的目录结构中查找第一个找到的匹配的`node_modules`目录中的模块来继续搜索。算法将继续在目录树中向上搜索下一个`node_modules`目录，直到达到文件系统的根目录。'
- en: 'For file and package modules, both files and directories can match `moduleName`.
    In particular, the algorithm will try to match the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件和包模块，文件和目录都可以匹配`moduleName`。特别是，算法将尝试匹配以下内容：
- en: '`<moduleName>.js`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<moduleName>.js`'
- en: '`<moduleName>/index.js`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<moduleName>/index.js`'
- en: The directory/file specified in the `main` property of `<moduleName>/package.json`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在<moduleName>/package.json的`main`属性中指定的目录/文件
- en: The complete, formal documentation of the resolving algorithm can be found at
    [nodejsdp.link/resolve](http://nodejsdp.link/resolve).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解析算法的完整、正式文档可以在[nodejsdp.link/resolve](http://nodejsdp.link/resolve)找到。
- en: 'The `node_modules` directory is actually where the package managers install
    the dependencies of each package. This means that, based on the algorithm we just
    described, each package can have its own private dependencies. For example, consider
    the following directory structure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`node_modules`目录实际上是包管理器安装每个包的依赖项的地方。这意味着，根据我们刚才描述的算法，每个包都可以有自己的私有依赖项。例如，考虑以下目录结构：'
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous example, `myApp`, `depB`, and `depC` all depend on `depA`.
    However, they all have their own private version of the dependency! Following
    the rules of the resolving algorithm, using `require(''depA'')` will load a different
    file depending on the module that requires it, for example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`myApp`、`depB` 和 `depC` 都依赖于 `depA`。然而，它们各自都有自己的依赖版本！遵循解析算法的规则，使用 `require('depA')`
    将根据请求它的模块加载不同的文件，例如：
- en: Calling `require('depA')` from `/myApp/foo.js` will load `/myApp/node_modules/depA/index.js`
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `/myApp/foo.js` 调用 `require('depA')` 将加载 `/myApp/node_modules/depA/index.js`
- en: Calling `require('depA')` from `/myApp/node_modules/depB/bar.js` will load `/myApp/node_modules/depB/node_modules/depA/index.js`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `/myApp/node_modules/depB/bar.js` 调用 `require('depA')` 将加载 `/myApp/node_modules/depB/node_modules/depA/index.js`
- en: Calling `require('depA')` from `/myApp/node_modules/depC/foobar.js` will load `/myApp/node_modules/depC/node_modules/depA/index.js`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `/myApp/node_modules/depC/foobar.js` 调用 `require('depA')` 将加载 `/myApp/node_modules/depC/node_modules/depA/index.js`
- en: The resolving algorithm is the core part behind the robustness of the Node.js
    dependency management, and it makes it possible to have hundreds or even thousands
    of packages in an application without having collisions or problems of version
    compatibility.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解析算法是 Node.js 依赖管理健壮性的核心部分，它使得在一个应用程序中拥有数百甚至数千个包而不会发生冲突或版本兼容性问题成为可能。
- en: The resolving algorithm is applied transparently for us when we invoke `require()`.
    However, if needed, it can still be used directly by any module by simply invoking `require.resolve()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `require()` 时，解析算法会透明地为我们应用。然而，如果需要，任何模块都可以通过简单地调用 `require.resolve()`
    直接使用它。
- en: The module cache
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块缓存
- en: 'Each module is only loaded and evaluated the first time it is required, since
    any subsequent call of `require()` will simply return the cached version. This
    should be clear by looking at the code of our homemade `require()` function. Caching
    is crucial for performance, but it also has some important functional implications:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块只有在第一次被 `require()` 调用时才会被加载和评估，因为任何后续的 `require()` 调用将简单地返回缓存的版本。这可以通过查看我们自制的
    `require()` 函数的代码来清楚地了解。缓存对于性能至关重要，但它也有一些重要的功能影响：
- en: It makes it possible to have cycles within module dependencies
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得模块依赖中存在循环成为可能
- en: It guarantees, to some extent, that the same instance is always returned when
    requiring the same module from within a given package
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在一定程度上保证了从给定包内部要求相同的模块时，总是返回相同的实例
- en: The module cache is exposed via the `require.cache` variable, so it is possible
    to directly access it if needed. A common use case is to invalidate any cached
    module by deleting the relative key in the `require.cache` variable, a practice
    that can be useful during testing but very dangerous if applied in normal circumstances.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 模块缓存通过 `require.cache` 变量暴露，因此如果需要可以直接访问它。一个常见的用例是通过删除 `require.cache` 变量中的相对键来使任何缓存的模块失效，这种做法在测试期间可能很有用，但在正常情况下应用则非常危险。
- en: Circular dependencies
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环依赖
- en: Many consider circular dependencies an intrinsic design issue, but it is something
    that might actually happen in a real project, so it's useful for us to know at
    least how this works with CommonJS. If we look again at our homemade `require()` function,
    we immediately get a glimpse of how this might work and what its caveats are.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为循环依赖是一个固有的设计问题，但实际上它可能在真实的项目中发生，因此了解它如何与 CommonJS 一起工作对我们来说很有用。如果我们再次查看我们的自制
    `require()` 函数，我们立即可以窥见它可能的工作方式及其注意事项。
- en: 'But let''s walk together through an example to see how CommonJS behaves when
    dealing with circular dependencies. Let''s suppose we have the scenario represented
    in *Figure 2.1*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们通过一个示例一起看看 CommonJS 在处理循环依赖时的行为。假设我们有 *图 2.1* 中表示的场景：
- en: '![02%20The%20Module%20system%20-%20Images/circular-dependency-example.png](img/B15729_02_01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![02%20The%20Module%20system%20-%20Images/circular-dependency-example.png](img/B15729_02_01.png)'
- en: 'Figure 2.1: An example of circular dependency'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：循环依赖的示例
- en: 'A module called `main.js` requires `a.js` and `b.js`. In turn, `a.js` requires
    `b.js`. But `b.js` relies on `a.js` as well! It''s obvious that we have a circular
    dependency here as module `a.js` requires module `b.js` and module `b.js` requires
    module `a.js`. Let''s have a look at the code of these two modules:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `main.js` 的模块需要 `a.js` 和 `b.js`。反过来，`a.js` 需要 `b.js`。但 `b.js` 也依赖于 `a.js`！很明显，这里有一个循环依赖，因为模块
    `a.js` 需要模块 `b.js`，而模块 `b.js` 也需要模块 `a.js`。让我们看看这两个模块的代码：
- en: 'Module `a.js`:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '模块 `a.js`:'
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Module `b.js`:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '模块 `b.js`:'
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s see how these modules are required by `main.js`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这些模块是如何被 `main.js` 引入的：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we run `main.js`, we will see the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行 `main.js`，我们会看到以下输出：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This result reveals the caveats of circular dependencies with CommonJS, that
    is, different parts of our application will have a different view of what is exported
    by module `a.js` and module `b.js`, depending on the order in which those dependencies
    are loaded. While both the modules are completely initialized as soon as they
    are required from the module `main.js`, the `a.js` module will be incomplete when
    it is loaded from `b.js`. In particular, its state will be the one that it reached
    the moment `b.js` was required.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果揭示了使用 CommonJS 的循环依赖的注意事项，即，根据加载这些依赖项的顺序，我们应用程序的不同部分将会有不同的视图，来查看模块 `a.js`
    和模块 `b.js` 导出的内容。虽然这两个模块在从 `main.js` 模块引入时都会立即完全初始化，但当从 `b.js` 加载时，`a.js` 模块将是不完整的。特别是，它的状态将是
    `b.js` 被引入时的状态。
- en: 'In order to understand in more detail what happens behind the scenes, let''s
    analyze step by step how the different modules are interpreted and how their local
    scope changes along the way:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地了解幕后发生的事情，让我们一步一步地分析不同的模块是如何被解释的，以及它们的局部作用域是如何变化的：
- en: '![](img/B15729_02_02.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15729_02_02.png)'
- en: 'Figure 2.2: A visual representation of how a dependency loop is managed in
    Node.js'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：在 Node.js 中管理依赖循环的视觉表示
- en: 'The steps are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: The processing starts in `main.js`, which immediately requires `a.js`
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理从 `main.js` 开始，它立即引入 `a.js`
- en: The first thing that module `a.js` does is set an exported value called `loaded`
    to `false`
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `a.js` 首先做的事情是将一个名为 `loaded` 的导出值设置为 `false`
- en: At this point, module `a.js` requires module `b.js`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，模块 `a.js` 引入模块 `b.js`
- en: Like `a.js`, the first thing that module `b.js` does is set an exported value
    called `loaded` to `false`
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 `a.js` 类似，模块 `b.js` 首先做的事情是将一个名为 `loaded` 的导出值设置为 `false`
- en: Now, `b.js` requires `a.js` (cycle)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`b.js` 引入 `a.js`（循环）
- en: Since `a.js` has already been traversed, its currently exported value is immediately
    copied into the scope of module `b.js`
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `a.js` 已经被遍历，它目前导出的值立即被复制到模块 `b.js` 的作用域中
- en: Module `b.js` finally changes the `loaded` value to `true`
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `b.js` 最后将 `loaded` 值更改为 `true`
- en: Now that `b.js` has been fully executed, the control returns to `a.js,` which
    now holds a copy of the current state of module `b.js` in its own scope
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 `b.js` 已完全执行，控制权返回到 `a.js`，此时 `a.js` 持有模块 `b.js` 当前状态的副本在其自己的作用域中
- en: The last step of module `a.js` is to set its `loaded` value to `true`
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `a.js` 的最后一步是将它的 `loaded` 值设置为 `true`
- en: Module `a.js` is now completely executed and the control returns to `main.js`,
    which now has a copy of the current state of module `a.js` in its internal scope
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `a.js` 现已完全执行，控制权返回到 `main.js`，此时 `main.js` 的内部作用域中有一个模块 `a.js` 当前状态的副本
- en: '`main.js` requires `b.js`, which is immediately loaded from cache'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main.js` 引入 `b.js`，它立即从缓存中加载'
- en: The current state of module `b.js` is copied into the scope of module `main.js`
    where we can finally see the complete picture of what the state of every module
    is
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `b.js` 的当前状态被复制到 `main.js` 的作用域中，在那里我们最终可以看到每个模块的状态的完整图景
- en: As we said, the issue here is that module `b.js` has a partial view of module
    `a.js`, and this partial view gets propagated over when `b.js` is required in
    `main.js`. This behavior should spark an intuition which can be confirmed if we
    swap the order in which the two modules are required in `main.js`. If you actually
    try this, you will see that this time it will be the `a.js` module that will receive
    an incomplete version of `b.js`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，这里的问题是模块 `b.js` 对模块 `a.js` 有一个部分视图，并且当在 `main.js` 中引入 `b.js` 时，这个部分视图会被传播。如果我们交换两个模块在
    `main.js` 中引入的顺序，这种行为应该会激发一种直觉，如果实际尝试这样做，你会看到这次将是 `a.js` 模块接收到 `b.js` 的一个不完整版本。
- en: We understand now that this can become quite a fuzzy business if we lose control
    of which module is loaded first, which can happen quite easily if the project
    is big enough.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白，如果我们失去了控制哪个模块先被加载，这可能会变得相当模糊，如果项目足够大，这种情况很容易发生。
- en: Later in this chapter, we will see how ESM can deal with circular dependencies
    in a more effective way. Meanwhile, if you are using CommonJS, be very careful
    about this behavior and the way it can affect your application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到 ESM 如何以更有效的方式处理循环依赖。同时，如果你正在使用 CommonJS，请非常小心这种行为及其可能对你的应用程序产生的影响。
- en: In the next section, we will discuss some patterns to define modules in Node.js.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一些在Node.js中定义模块的模式。
- en: Module definition patterns
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块定义模式
- en: The module system, besides being a mechanism for loading dependencies, is also
    a tool for defining APIs. Like any other problem related to API design, the main
    factor to consider is the balance between private and public functionality. The
    aim is to maximize information hiding and API usability, while balancing these
    with other software qualities, such as *extensibility* and *code reuse*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统除了是加载依赖项的机制外，也是定义API的工具。像任何其他与API设计相关的问题一样，需要考虑的主要因素是私有功能和公共功能之间的平衡。目标是最大化信息隐藏和API可用性，同时与其他软件质量，如*可扩展性*和*代码重用*相平衡。
- en: In this section, we will analyze some of the most popular patterns for defining
    modules in Node.js, such as named exports, exporting functions, classes and instances,
    and monkey patching. Each one has its own balance of information hiding, extensibility,
    and code reuse.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析一些在Node.js中定义模块的最流行模式，例如命名导出、导出函数、类和实例以及猴子补丁。每个模式都有其自己的信息隐藏、可扩展性和代码重用之间的平衡。
- en: Named exports
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名导出
- en: The most basic method for exposing a public API is using **named exports**,
    which involves assigning the values we want to make public to properties of the
    object referenced by `exports` (or `module.exports`). In this way, the resulting
    exported object becomes a container or namespace for a set of related functionalities.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露公共API的最基本方法是使用**命名导出**，这涉及到将我们想要公开的值分配给由`exports`（或`module.exports`）引用的对象的属性。这样，生成的导出对象就变成了相关功能集的容器或命名空间。
- en: 'The following code shows a module implementing this pattern:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了实现此模式的模块：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The exported functions are then available as properties of the loaded module,
    as shown in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的函数随后作为加载的模块的属性可用，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Most of the Node.js core modules use this pattern. However, the CommonJS specification
    only allows the use of the `exports` variable to expose public members. Therefore,
    the named exports pattern is the only one that is really compatible with the CommonJS
    specification. The use of `module.exports` is an extension provided by Node.js
    to support a broader range of module definition patterns, which we are going to
    see next.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Node.js核心模块都使用这种模式。然而，CommonJS规范只允许使用`exports`变量来公开成员。因此，命名导出模式是与CommonJS规范真正兼容的唯一模式。使用`module.exports`是Node.js提供的一种扩展，以支持更广泛的模块定义模式，我们将在下面看到。
- en: Exporting a function
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出函数
- en: 'One of the most popular module definition patterns consists of reassigning
    the whole `module.exports` variable to a function. The main strength of this pattern
    is the fact that it allows you to expose only a single functionality, which provides
    a clear entry point for the module, making it simpler to understand and use; it
    also honors the principle of *small surface* area very well. This way of defining
    modules is also known in the community as the **substack pattern**, after one
    of its most prolific adopters, James Halliday (nickname substack – [https://github.com/substack](https://github.com/substack)).
    Have a look at this pattern in the following example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的模块定义模式之一是将整个`module.exports`变量重新分配给一个函数。这种模式的主要优势在于它允许你只公开单一功能，这为模块提供了一个清晰的入口点，使其更容易理解和使用；它也很好地遵守了*小表面面积*原则。这种定义模块的方式在社区中也被称为**substack模式**，这是其最著名的采用者之一，詹姆斯·哈利戴（昵称substack
    – [https://github.com/substack](https://github.com/substack))。以下示例中看看这个模式：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A possible extension of this pattern is using the exported function as a namespace
    for other public APIs. This is a very powerful combination because it still gives
    the module the clarity of a single entry point (the main exported function) and
    at the same time it allows us to expose other functionalities that have secondary
    or more advanced use cases. The following code shows us how to extend the module
    we defined previously by using the exported function as a namespace:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的可能扩展是使用导出的函数作为其他公共API的命名空间。这是一个非常强大的组合，因为它仍然给模块提供了单一入口点（主要导出函数）的清晰性，同时允许我们公开具有次要或更高级用例的其他功能。以下代码展示了如何通过使用导出的函数作为命名空间来扩展我们之前定义的模块：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code demonstrates how to use the module that we just defined:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何使用我们刚刚定义的模块：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Even though exporting just a function might seem like a limitation, in reality,
    it''s a perfect way to put the emphasis on a single functionality, the most important
    one for the module, while giving less visibility to secondary or internal aspects,
    which are instead exposed as properties of the exported function itself. The modularity
    of Node.js heavily encourages the adoption of the **single-responsibility principle** (**SRP**):
    every module should have responsibility over a single functionality and that responsibility
    should be entirely encapsulated by the module.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只导出一个函数可能看起来像是一种限制，但实际上，这是一种将重点放在单一功能上的完美方式，这是模块最重要的功能，同时减少对次要或内部方面的可见性，这些方面作为导出函数本身的属性被暴露出来。Node.js的模块化强烈鼓励采用**单一职责原则**（**SRP**）：每个模块应该负责单一功能，并且这种责任应该完全封装在模块中。
- en: Exporting a class
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出一个类
- en: 'A module that exports a class is a specialization of a module that exports
    a function. The difference is that with this new pattern we allow the user to
    create new instances using the constructor, but we also give them the ability
    to extend its prototype and forge new classes. The following is an example of
    this pattern:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 导出类的模块是导出函数的模块的一种特殊化。区别在于，使用这种新的模式，我们允许用户使用构造函数创建新实例，同时也赋予他们扩展其原型和创建新类的权限。以下是这个模式的示例：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And, we can use the preceding module as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式使用前面的模块：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Exporting a class still provides a single entry point for the module, but compared
    to the substack pattern, it exposes a lot more of the module internals. On the
    other hand, it allows much more power when it comes to extending its functionality.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 导出一个类仍然为模块提供了一个单一的入口点，但与子栈模式相比，它暴露了更多的模块内部结构。另一方面，它允许在扩展其功能时拥有更多的权力。
- en: Exporting an instance
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出一个实例
- en: 'We can leverage the caching mechanism of `require()` to easily define stateful instances
    created from a constructor or a factory, which can be shared across different
    modules. The following code shows an example of this pattern:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`require()`的缓存机制轻松定义由构造函数或工厂创建的状态化实例，这些实例可以在不同的模块之间共享。以下代码展示了这种模式的示例：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This newly defined module can then be used as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新定义的模块可以按照以下方式使用：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Because the module is cached, every module that requires the `logger` module
    will actually always retrieve the same instance of the object, thus sharing its
    state. This pattern is very much like creating a **singleton**. However, it does
    not guarantee the uniqueness of the instance across the entire application, as
    it happens in the traditional singleton pattern. When analyzing the resolving
    algorithm, we have seen that a module might be installed multiple times inside
    the dependency tree of an application. This results in multiple instances of the
    same logical module, all running in the context of the same Node.js application.
    We will analyze the Singleton pattern and its caveats in more detail in *Chapter
    7*, *Creational Design Patterns*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块被缓存，每个需要`logger`模块的模块实际上总是检索到同一个对象实例，从而共享其状态。这种模式非常类似于创建一个**单例**。然而，它并不能保证在整个应用程序中实例的唯一性，就像传统单例模式中发生的那样。在分析解析算法时，我们注意到一个模块可能在应用程序的依赖树中被安装多次。这导致同一个逻辑模块有多个实例，所有这些实例都在同一个Node.js应用程序的上下文中运行。我们将在第7章“创建型设计模式”中更详细地分析单例模式和它的注意事项。
- en: 'One interesting detail of this pattern is that it does not preclude the opportunity
    to create new instances, even if we are not explicitly exporting the class. In
    fact, we can rely on the `constructor` property of the exported instance to construct
    a new instance of the same type:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的一个有趣细节是，它并不排除创建新实例的机会，即使我们没有明确导出类。实际上，我们可以依赖导出实例的`constructor`属性来构建相同类型的新的实例：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, by using `logger.constructor()`, we can instantiate new `Logger`
    objects. Note that this technique must be used with caution or avoided altogether.
    Consider that, if the module author decided not to export the class explicitly,
    they probably wanted to keep this class private.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，通过使用`logger.constructor()`，我们可以实例化新的`Logger`对象。请注意，这种技术必须谨慎使用，或者最好完全避免。考虑一下，如果模块作者决定没有明确导出类，他们可能希望保持这个类是私有的。
- en: Modifying other modules or the global scope
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改其他模块或全局作用域
- en: A module can even export nothing. This can seem a bit out of place; however,
    we should not forget that a module can modify the global scope and any object
    in it, including other modules in the cache. Please note that these are in general
    considered bad practices, but since this pattern can be useful and safe under
    some circumstances (for example, for testing) and it's sometimes used in real-life
    projects, it's worth knowing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块甚至可以不导出任何内容。这看起来可能有些不合适；然而，我们不应忘记，一个模块可以修改全局作用域及其中的任何对象，包括缓存中的其他模块。请注意，这些通常被认为是不良做法，但鉴于这种模式在某些情况下（例如，用于测试）可能是有用且安全的，并且有时在现实世界的项目中使用，了解这一点是值得的。
- en: We said that a module can modify other modules or objects in the global scope;
    well, this is called **monkey patching**. It generally refers to the practice
    of modifying the existing objects at runtime to change or extend their behavior
    or to apply temporary fixes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，一个模块可以修改全局作用域中的其他模块或对象；嗯，这被称为**猴子补丁**。它通常指的是在运行时修改现有对象以改变或扩展其行为或应用临时修复的做法。
- en: 'The following example shows us how we can add a new function to another module:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何向另一个模块添加一个新函数：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using our new `patcher` module is as easy as writing the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新的`patcher`模块就像编写以下代码一样简单：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The technique described here can be very dangerous to use. The main concern
    is that having a module that modifies the global namespace or other modules is
    an operation with *side effects*. In other words, it affects the state of entities
    outside their scope, which can have consequences that aren't easily predictable,
    especially when multiple modules interact with the same entities. Imagine having
    two different modules trying to set the same global variable, or modifying the
    same property of the same module. The effects can be unpredictable (which module
    wins?), but most importantly it would have repercussions on the entire application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的技术使用起来可能非常危险。主要问题是拥有一个修改全局命名空间或其他模块的模块是一种具有*副作用*的操作。换句话说，它影响了其作用域之外实体的状态，这可能导致难以预测的后果，尤其是在多个模块与同一实体交互时。想象一下有两个不同的模块试图设置相同的全局变量，或者修改同一模块的相同属性。效果可能是不可预测的（哪个模块获胜？），但更重要的是，它会对整个应用程序产生影响。
- en: So, again use this technique with care and make sure you understand all the
    possible side effects while doing so.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次谨慎使用这项技术，并确保在这样做时理解所有可能的副作用。
- en: If you want a real-life example of how this can be useful, have a look at `nock`
    ([nodejsdp.link/nock](http://nodejsdp.link/nock)), a module that allows you to
    mock HTTP responses in your tests. The way `nock` works is by monkey patching
    the Node.js `http` module and by changing its behavior so that it will provide
    the mocked response rather than issuing a real HTTP request. This allows our unit
    test to run without hitting the actual production HTTP endpoints, something that's
    very convenient when writing tests for code that relies on third-party APIs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看这个如何在实际中发挥作用，可以看看`nock`（[nodejsdp.link/nock](http://nodejsdp.link/nock)），这是一个允许你在测试中模拟HTTP响应的模块。`nock`工作的方式是通过猴子补丁Node.js的`http`模块，并改变其行为，使其提供模拟的响应而不是发出真实的HTTP请求。这允许我们的单元测试在没有触及实际生产HTTP端点的情况下运行，这在编写依赖于第三方API的代码的测试时非常方便。
- en: At this point, we should have a quite complete understanding of CommonJS and
    some of the patterns that are generally used with it. In the next section, we
    will explore ECMAScript modules, also known as ESM.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该对CommonJS及其通常使用的某些模式有一个相当完整的理解。在下一节中，我们将探讨ECMAScript模块，也称为ESM。
- en: 'ESM: ECMAScript modules'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ESM：ECMAScript模块
- en: ECMAScript modules (also known as ES modules or ESM) were introduced as part
    of the ECMAScript 2015 specification with the goal to give JavaScript an official
    module system suitable for different execution environments. The ESM specification
    tries to retain some good ideas from previous existing module systems like CommonJS
    and AMD. The syntax is very simple and compact. There is support for cyclic dependencies
    and the possibility to load modules asynchronously.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript模块（也称为ES模块或ESM）作为ECMAScript 2015规范的一部分被引入，目的是为JavaScript提供一个适用于不同执行环境的官方模块系统。ESM规范试图保留一些来自先前现有模块系统（如CommonJS和AMD）的好想法。语法非常简单且紧凑。它支持循环依赖和异步加载模块的可能性。
- en: The most important differentiator between ESM and CommonJS is that ES modules
    are *static*, which means that imports are described at the top level of every
    module and outside any control flow statement. Also, the name of the imported
    modules cannot be dynamically generated at runtime using expressions, only constant
    strings are allowed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ESM 和 CommonJS 之间最重要的区别在于 ES 模块是 **静态的**，这意味着导入在模块的顶层描述，并且不在任何控制流语句之外。此外，导入模块的名称不能在运行时通过表达式动态生成，只允许使用常量字符串。
- en: 'For instance, the following code wouldn''t be valid when using ES modules:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码在使用 ES 模块时将是不合法的：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'While in CommonJS, it is perfectly fine to write something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CommonJS 中，写如下内容是完全可行的：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At a first glance, this characteristic of ESM might seem an unnecessary limitation,
    but in reality, having static imports opens up a number of interesting scenarios
    that are not practical with the dynamic nature of CommonJS. For instance, static
    imports allow the static analysis of the dependency tree, which allows optimizations
    such as dead code elimination (tree shaking) and more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，ESM 的这一特性可能看似不必要的限制，但事实上，静态导入打开了许多与 CommonJS 的动态特性不实用的有趣场景。例如，静态导入允许对依赖关系树进行静态分析，这允许进行诸如死代码消除（摇树）等优化。
- en: Using ESM in Node.js
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Node.js 中使用 ESM
- en: Node.js will consider every `.js` file to be written using the CommonJS syntax
    by default; therefore, if we use the ESM syntax inside a `.js` file, the interpreter
    will simply throw an error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 默认会将每个 `.js` 文件视为使用 CommonJS 语法编写的；因此，如果我们在一个 `.js` 文件中使用 ESM 语法，解释器将直接抛出一个错误。
- en: 'There are several ways to tell the Node.js interpreter to consider a given
    module as an ES module rather than a CommonJS module:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以告诉 Node.js 解释器将给定的模块视为 ES 模块而不是 CommonJS 模块：
- en: Give the module file the extension `.mjs`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给模块文件添加 `.mjs` 扩展名。
- en: Add to the nearest parent `package.json` a field called "`type"` with a value
    of `"module"`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最近的父 `package.json` 中添加一个名为 "`type`" 的字段，其值为 `"module"`。
- en: Throughout the rest of this book and in the code examples provided, we will
    keep using the `.js` extension to keep the code more easily accessible to most
    text editors, so if you are copying and pasting examples straight from the book,
    make sure that you also create a `package.json` file with the `"type":"module"`
    entry.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分和提供的代码示例中，我们将继续使用 `.js` 扩展名，以便使代码更容易为大多数文本编辑器所访问，因此如果您直接从书中复制粘贴示例，请确保您也创建一个包含
    `"type":"module"` 条目的 `package.json` 文件。
- en: Let's now have a look at the ESM syntax.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 ESM 语法。
- en: Named exports and imports
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名导出和导入
- en: ESM allows us to export functionality from a module through the `export` keyword.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ESM 允许我们通过 `export` 关键字从模块中导出功能。
- en: Note that ESM uses the singular word `export` as opposed to the plural (`exports`
    and `module.exports`) used by CommonJS.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 CommonJS 使用的复数形式（`exports` 和 `module.exports`）不同，ESM 使用单数词 `export`。
- en: In an ES module, everything is private by default and only exported entities
    are publicly accessible from other modules.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES 模块中，一切都是私有的，默认情况下只有导出的实体可以从其他模块公开访问。
- en: 'The `export` keyword can be used in front of the entities that we want to make
    available to the module users. Let''s see an example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在想要向模块用户公开的实体前使用 `export` 关键字。让我们看一个例子：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we want to import entities from a module we can use the `import` keyword.
    The syntax is quite flexible, and it allows us to import one or more entities
    and even to rename imports. Let''s see some examples:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要从模块中导入实体，可以使用 `import` 关键字。语法相当灵活，允许我们导入一个或多个实体，甚至可以重命名导入。让我们看一些例子：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, we are using the `*` syntax (also called **namespace import**)
    to import all the members of the module and assign them to the local `loggerModule`
    variable. This example will output something like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `*` 语法（也称为 **命名空间导入**）来导入模块的所有成员，并将它们分配给本地的 `loggerModule` 变量。这个例子将输出类似以下内容：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see, all the entities exported in our module are now accessible in
    the `loggerModule` namespace. For instance, we could refer to the `log()` function
    through `loggerModule.log`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们模块中导出的所有实体现在都可以在 `loggerModule` 命名空间中访问。例如，我们可以通过 `loggerModule.log`
    来引用 `log()` 函数。
- en: It's very important to note that, as opposed to CommonJS, with ESM we have to
    specify the file extension of the imported modules. With CommonJS we can use either
    `./logger` or `./logger.js`, with ESM we are forced to use `./logger.js`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，与CommonJS不同，在ESM中我们必须指定导入模块的文件扩展名。在CommonJS中，我们可以使用`./logger`或`./logger.js`，而在ESM中，我们被迫使用`./logger.js`。
- en: 'If we are using a large module, most often we don''t want to import all of
    its functionality, but only one or few entities from it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个大型模块，通常我们不想导入它的所有功能，而只想导入其中的一到几个实体：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to import more than one entity, this is how we would do that:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想导入多个实体，可以这样操作：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we use this type of `import` statement, the entities are imported into
    the current scope, so there is a risk of a name clash. The following code, for
    example, would not work:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这种类型的`import`语句时，实体将被导入到当前作用域中，因此存在名称冲突的风险。例如，以下代码将无法工作：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we try to execute the preceding snippet, the interpreter fails with the
    following error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行前面的代码片段，解释器将失败并显示以下错误：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In situations like this one, we can resolve the clash by renaming the imported
    entity with the `as` keyword:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以通过使用`as`关键字重命名导入的实体来解决这个问题：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This approach can be particularly useful when the clash is generated by importing
    two entities with the same name from different modules, and therefore changing
    the original names is outside the consumer's control.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在由从不同模块导入具有相同名称的两个实体而引起的冲突时特别有用，因此更改原始名称超出了消费者的控制范围。
- en: Default exports and imports
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认导出和导入
- en: 'One widely used feature of CommonJS is the ability to export a single unnamed
    entity through the assignment of `module.exports`. We saw that this is very convenient
    as it encourages module developers to follow the single-responsibility principle
    and expose only one clear interface. With ESM, we can do something similar through
    what''s called a **default export**. A default export makes use of the `export
    default` keywords and it looks like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS广泛使用的一个特性是通过`module.exports`的赋值来导出一个未命名的实体。我们了解到这一点非常方便，因为它鼓励模块开发者遵循单一职责原则，仅暴露一个清晰的接口。在ESM中，我们可以通过所谓的**默认导出**做类似的事情。默认导出使用了`export
    default`关键字，其形式如下：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, the name `Logger` is ignored, and the entity exported is registered
    under the name `default`. This exported name is handled in a special way, and
    it can be imported as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，名称`Logger`被忽略，导出的实体在`default`名称下注册。这个导出名称以特殊方式处理，可以按以下方式导入：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The difference with named ESM imports is that here, since the default export
    is considered unnamed, we can import it and at the same time assign it a local
    name of our choice. In this example, we can replace `MyLogger` with anything else
    that makes sense in our context. This is very similar to what we do with CommonJS
    modules. Note also that we don't have to wrap the import name around brackets
    or use the `as` keyword when renaming.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与命名ESM导入的区别在于，在这里，由于默认导出被认为是未命名的，我们可以导入它，同时给它赋予我们选择的本地名称。在这个例子中，我们可以用任何在我们上下文中有意义的东西来替换`MyLogger`。这与我们处理CommonJS模块的方式非常相似。注意，我们不需要用括号包裹导入名称，也不需要在重命名时使用`as`关键字。
- en: 'Internally, a default export is equivalent to a named export with `default`
    as the name. We can easily verify this statement by running the following snippet
    of code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，默认导出等同于一个名为`default`的命名导出。我们可以通过运行以下代码片段轻松验证这个说法：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When executed, the previous code will print something like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行上述代码时，将打印出类似以下内容：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'One thing that we cannot do, though, is import the default entity explicitly.
    In fact, something like the following will fail:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法显式地导入默认实体。事实上，类似以下的内容将失败：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The execution will fail with a `SyntaxError: Unexpected reserved word` error.
    This happens because the `default` keyword cannot be used as a variable name.
    It is valid as an object attribute, so in the previous example, it is okay to
    use `loggerModule.default`, but we can''t have a variable named `default` directly
    in the scope.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '执行将因`SyntaxError: Unexpected reserved word`错误而失败。这是因为`default`关键字不能用作变量名。它可以作为一个对象的属性，所以在前面的例子中，使用`loggerModule.default`是正确的，但我们不能在作用域中直接有一个名为`default`的变量。'
- en: Mixed exports
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合导出
- en: 'It is possible to mix named exports and a default export within an ES module.
    Let''s have a look at an example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES模块中，可以混合命名导出和默认导出。让我们看看一个例子：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code is exporting the `log()` function as a default export and
    a named export for a function called `info()`. Note that `info()` can reference
    `log()` internally. It would not be possible to replace the call to `log()` with
    `default()` to do that, as it would be a syntax error (Unexpected token `default`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将 `log()` 函数作为默认导出和名为 `info()` 的命名导出导出。请注意，`info()` 可以内部引用 `log()`。不可能用
    `default()` 替换对 `log()` 的调用，因为这将会是一个语法错误（Unexpected token `default`）。
- en: 'If we want to import both the default export and one or more named exports,
    we can do it using the following format:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想导入默认导出和一个或多个命名导出，我们可以使用以下格式：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, we are importing the default export from `logger.js`
    as `mylog` and also the named export `info`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们正在从 `logger.js` 导入默认导出为 `mylog`，同时也导入了命名导出 `info`。
- en: 'Let''s now discuss some key details and differences between the default export
    and named exports:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论一下默认导出和命名导出之间的关键细节和区别：
- en: Named exports are explicit. Having predetermined names allows IDEs to support
    the developer with automatic imports, autocomplete, and refactoring tools. For
    instance, if we type `writeFileSync`, the editor might automatically add `import
    { writeFileSync } from 'fs'` at the beginning of the current file. Default exports,
    on the contrary, make all these things more complicated as a given functionality
    could have different names in different files, so it's harder to make inferences
    on which module might provide a given functionality based only on a given name.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名导出是明确的。预定的名称允许IDE为开发者提供自动导入、自动完成和重构工具的支持。例如，如果我们输入 `writeFileSync`，编辑器可能会自动在当前文件的开头添加
    `import { writeFileSync } from 'fs'`。相反，默认导出使得所有这些事情变得更加复杂，因为某个功能在不同的文件中可能有不同的名称，因此仅根据给定的名称就难以推断哪个模块可能提供该功能。
- en: The default export is a convenient mechanism to communicate what is the single
    most important functionality for a module. Also, from the perspective of the user,
    it can be easier to import the obvious piece of functionality without having to
    know the exact name of the binding.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认导出是一种方便的机制，用于传达模块最重要的单个功能。从用户的角度来看，在没有知道绑定确切名称的情况下，导入明显功能的一部分可能更容易。
- en: In some circumstances, default exports might make it harder to apply dead code
    elimination (tree shaking). For example, a module could provide only a default
    export, which is an object where all the functionality is exposed as properties
    of such an object. When we import this default object, most module bundlers will
    consider the entire object being used and they won't be able to eliminate any
    unused code from the exported functionality.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，默认导出可能会使应用死代码消除（tree shaking）变得更加困难。例如，一个模块可能只提供默认导出，这是一个所有功能都作为该对象属性暴露的对象。当我们导入这个默认对象时，大多数模块打包器都会认为整个对象都在使用中，它们将无法从导出的功能中消除任何未使用的代码。
- en: For these reasons, it is generally considered good practice to stick with named
    exports, especially when you want to expose more than one functionality, and only use
    default exports if it's one clear functionality you want to export.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，通常认为坚持使用命名导出是良好的实践，特别是当你想要暴露多个功能时，并且只有当你想要导出明确的功能时才使用默认导出。
- en: This is not a hard rule and there are notable exceptions to this suggestion.
    For instance, all Node.js core modules have both a default export and a number
    of named exports. Also, React ([nodejsdp.link/react](http://nodejsdp.link/react))
    uses mixed exports.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一条硬性规则，并且有一些值得注意的例外。例如，所有Node.js核心模块都有默认导出和多个命名导出。此外，React ([nodejsdp.link/react](http://nodejsdp.link/react))
    使用混合导出。
- en: Consider carefully what the best approach for your specific module is and what
    you want the developer experience to be for the users of your module.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑你特定模块的最佳方法以及你希望你的模块用户拥有怎样的开发者体验。
- en: Module identifiers
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块标识符
- en: '**Module identifiers** (also called *module specifiers*) are the different
    types of values that we can use in our `import` statements to specify the location
    of the module we want to load.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块标识符**（也称为*模块指定符*）是我们可以在我们的 `import` 语句中使用的不同类型的值，用于指定我们想要加载的模块的位置。'
- en: 'So far, we have seen only relative paths, but there are several other possibilities
    and some nuances to keep in mind. Let''s list all the possibilities:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了相对路径，但还有其他几种可能性，还有一些需要注意的细微差别。让我们列出所有可能性：
- en: '*Relative specifiers* like `./logger.js` or `../logger.js`. They are used to
    refer to a path relative to the location of the importing file.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相对指定符*如`./logger.js`或`../logger.js`。它们用于引用相对于导入文件位置的路径。'
- en: '*Absolute specifiers* like `file:///opt/nodejs/config.js`. They refer directly
    and explicitly to a full path. Note that this is the only way with ESM to refer
    to an absolute path for a module, using a `/` or a `//` prefix won''t work. This
    is a significant difference with CommonJS.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绝对指定符*如`file:///opt/nodejs/config.js`。它们直接且明确地指向一个完整路径。请注意，这是使用ESM引用模块绝对路径的唯一方式，使用`/`或`//`前缀将不起作用。这与CommonJS有显著不同。'
- en: '*Bare specifiers* are identifiers like `fastify` or `http`, and they represent
    modules available in the `node_modules` folder and generally installed through
    a package manager (such as npm) or available as core Node.js modules.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*裸指定符*是像`fastify`或`http`这样的标识符，它们代表在`node_modules`文件夹中可用的模块，通常通过包管理器（如npm）或作为Node.js核心模块安装。'
- en: '*Deep import specifiers* like `fastify/lib/logger.js`, which refer to a path
    within a package in `node_modules` (`fastify`, in this case).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于`fastify/lib/logger.js`的*深度导入指定符*，它指的是`node_modules`包内的一个路径（在这个例子中是`fastify`）。
- en: In browser environments, it is possible to import modules directly by specifying
    the module URL, for instance, [https://unpkg.com/lodash](https://unpkg.com/lodash).
    This feature is not supported by Node.js.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器环境中，可以通过指定模块URL直接导入模块，例如，[https://unpkg.com/lodash](https://unpkg.com/lodash)。这个特性在Node.js中不受支持。
- en: Async imports
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步导入
- en: 'As we have seen in the previous section, the `import` statement is static and
    therefore subject to two important limitations:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一小节中看到的，`import`语句是静态的，因此受到两个重要限制：
- en: A module identifier cannot be constructed at runtime
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块标识符不能在运行时构建
- en: Module imports are declared at the top level of every file and they cannot be
    nested within control flow statements
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块导入在文件的顶层声明，并且不能在控制流语句内嵌套。
- en: There are some use cases when these limitations can become a little bit too
    restrictive. Imagine, for instance, if we have to import a specific translation
    module for the current user language, or a variation of a module that depends
    on the user's operating system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这些限制可能会变得过于严格。想象一下，例如，如果我们必须为当前用户的语言导入一个特定的翻译模块，或者一个依赖于用户操作系统的模块变体。
- en: Also, what if we want to load a given module, which might be particularly heavy,
    only if the user is accessing the piece of functionality that requires that module?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们只想在用户访问需要该模块的功能时加载给定的模块，该模块可能特别庞大，该怎么办？
- en: To allow us to overcome these limitations ES modules provides *async imports*
    (also called *dynamic imports*).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够克服这些限制，ES模块提供了*异步导入*（也称为*动态导入*）。
- en: Async imports can be performed at runtime using the special `import()` operator.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 异步导入可以通过使用特殊的`import()`运算符在运行时执行。
- en: The `import()` operator is syntactically equivalent to a function that takes
    a module identifier as an argument and it returns a promise that resolves to a
    module object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`import()`运算符在语法上等同于一个接受模块标识符作为参数的函数，它返回一个解析为模块对象的承诺。'
- en: We will learn more about promises in *Chapter 5*, *Asynchronous Control Flow
    Patterns with Promises and Async/Await*, so don't worry too much about understanding
    all the nuances of the specific promise syntax for now.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第5章中学习更多关于承诺的内容，即“使用承诺和Async/Await的异步控制流模式”，所以现在不必过于担心理解特定承诺语法的所有细微差别。
- en: The module identifier can be any module identifier supported by static imports
    as discussed in the previous section. Now, let's see how to use dynamic imports
    with a simple example.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 模块标识符可以是前一小节中讨论的静态导入支持的任何模块标识符。现在，让我们通过一个简单的例子来看看如何使用动态导入。
- en: We want to build a command line application that can print "Hello World" in
    different languages. In the future, we will probably want to support many more
    phrases and languages, so it makes sense to have one file with the translations
    of all the user-facing strings for each supported language.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要构建一个命令行应用程序，该程序可以用不同的语言打印“Hello World”。在未来，我们可能会支持更多的短语和语言，因此为每种支持的语言有一个包含所有用户界面字符串的文件是有意义的。
- en: 'Let''s create some example modules for some of the languages we want to support:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们要支持的一些语言创建一些示例模块：
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now let''s create the main script that takes a language code from the command
    line and prints "Hello World" in the selected language:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个主脚本，它从命令行接收一个语言代码，并以所选语言打印“Hello World”：
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first part of the script is quite simple. What we do there is:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的第一个部分相当简单。我们在那里做的事情是：
- en: Define a list of supported languages.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个支持的语言列表。
- en: Read the selected language from the first argument passed in the command line.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行传入的第一个参数中读取所选语言。
- en: Finally, we handle the case where the selected language is not supported.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们处理所选语言不受支持的情况。
- en: 'The second part of the code is where we actually use dynamic imports:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二部分是我们实际使用动态导入的地方：
- en: First of all, we dynamically build the name of the module we want to import
    based on the selected language. Note that the module name needs to be a relative
    path to the module file, that's why we are prepending `./` to the filename.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们根据选定的语言动态构建我们想要导入的模块的名称。注意，模块名称需要是模块文件的相对路径，这就是为什么我们在文件名前添加`./`的原因。
- en: We use the `import()` operator to trigger the dynamic import of the module.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`import()`运算符来触发模块的动态导入。
- en: The dynamic import happens asynchronously, so we can use the `.then()` hook
    on the returned promise to get notified when the module is ready to be used. The
    function passed to `then()` will be executed when the module is fully loaded and
    `strings` will be the module namespace imported dynamically. After that, we can
    access `strings.HELLO` and print its value to the console.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态导入是异步发生的，因此我们可以使用返回的promise上的`.then()`钩子来通知模块何时准备好使用。传递给`then()`的函数将在模块完全加载后执行，`strings`将是动态导入的模块命名空间。之后，我们可以访问`strings.HELLO`并将其值打印到控制台。
- en: 'Now we can execute this script like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以这样执行这个脚本：
- en: '[PRE45]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And we should see *Ciao mondo* being printed to our console.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到*Ciao mondo*被打印到我们的控制台。
- en: Module loading in depth
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块加载深入探讨
- en: To understand how ESM actually works and how it can deal effectively with circular
    dependencies, we have to deep dive a little bit more into how JavaScript code
    is parsed and evaluated when using ES modules.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解ESM（ECMAScript模块）实际上是如何工作的以及它如何有效地处理循环依赖，我们必须更深入地了解在使用ES模块时JavaScript代码是如何被解析和评估的。
- en: In this section, we will learn how ECMAScript modules are loaded, we will present
    the idea of read-only live bindings, and, finally, we will discuss an example
    with circular dependencies.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何加载ECMAScript模块，我们将介绍只读活绑定（readonly live bindings）的概念，最后，我们将讨论一个具有循环依赖的例子。
- en: Loading phases
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载阶段
- en: The goal of the interpreter is to build a graph of all the necessary modules
    (a **dependency graph**).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的目标是构建所有必要模块的图（一个**依赖图**）。
- en: In generic terms, a **dependency graph** can be defined as a **directed graph**
    ([nodejsdp.link/directed-graph](http://nodejsdp.link/directed-graph)) representing
    the dependencies of a group of objects. In the context of this section, when we
    refer to a dependency graph, we want to indicate the dependency relationship between
    ECMAScript modules. As we will see, using a dependency graph allows us to determine
    the order in which all the necessary modules should be loaded in a given project.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用术语中，**依赖图**可以被定义为表示一组对象依赖关系的**有向图**（[nodejsdp.link/directed-graph](http://nodejsdp.link/directed-graph)）。在本节中，当我们提到依赖图时，我们想要表明ECMAScript模块之间的依赖关系。正如我们将看到的，使用依赖图允许我们确定在给定项目中所有必要模块应该加载的顺序。
- en: Essentially, the dependency graph is needed by the interpreter to figure out
    how modules depend on each other and in what order the code needs to be executed.
    When the `node` interpreter is launched, it gets passed some code to execute,
    generally in the form of a JavaScript file. This file is the starting point for
    the dependency resolution, and it is called the **entry point**. From the entry
    point, the interpreter will find and follow all the `import` statements recursively
    in a depth-first fashion, until all the necessary code is explored and then evaluated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，依赖图是解释器用来确定模块之间如何相互依赖以及代码需要执行的顺序的。当`node`解释器启动时，它被传递一些要执行的代码，通常是JavaScript文件的形式。这个文件是依赖解析的起点，被称为**入口点**。从入口点开始，解释器将以深度优先的方式递归地找到并跟随所有的`import`语句，直到所有必要的代码都被探索和评估。
- en: 'More specifically, this process happens in three separate phases:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，这个过程分为三个独立阶段：
- en: '**Phase 1 - Construction (or parsing)**: Find all the imports and recursively
    load the content of every module from the respective file.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一阶段 - 构建（或解析）**：找到所有导入，并递归地加载每个模块从相应文件的内容。'
- en: '**Phase 2 - Instantiation**: For every exported entity, keep a named reference
    in memory, but don''t assign any value just yet. Also, references are created
    for all the `import` and `export` statements tracking the dependency relationship
    between them (**linking**). No JavaScript code has been executed at this stage.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二阶段 - 实例化**：对于每个导出实体，在内存中保留一个命名引用，但暂时不分配任何值。此外，为所有`import`和`export`语句创建引用，跟踪它们之间的依赖关系（**链接**）。在此阶段尚未执行任何JavaScript代码。'
- en: '**Phase 3 - Evaluation**: Node.js finally executes the code so that all the
    previously instantiated entities can get an actual value. Now running the code
    from the entry point is possible because all the blanks have been filled.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三阶段 - 评估**：Node.js最终执行代码，以便所有之前实例化的实体都可以获得实际值。现在可以从入口点运行代码，因为所有空白都已经填满。'
- en: In simple terms, we could say that Phase 1 is about finding all the dots, Phase
    2 connects those creating paths, and, finally, Phase 3 walks through the paths
    in the right order.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以这样说，第一阶段是关于找到所有点，第二阶段是连接这些点以创建路径，最后，第三阶段按照正确的顺序遍历这些路径。
- en: At first glance, this approach doesn't seem very different from what CommonJS
    does, but there's a fundamental difference. Due to its dynamic nature, CommonJS
    will execute all the files while the dependency graph is explored. We have seen
    that every time a new `require` statement is found, all the previous code has
    already been executed. This is why you can use `require` even within `if` statements
    or loops, and construct module identifiers from variables.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这种方法似乎与CommonJS没有太大区别，但实际上有一个根本的区别。由于它的动态性，CommonJS会在探索依赖图时执行所有文件。我们已经看到，每次发现新的`require`语句时，所有之前的代码都已经执行。这就是为什么你可以在`if`语句或循环中使用`require`，并从变量中构造模块标识符的原因。
- en: In ESM, these three phases are totally separate from each other, no code can
    be executed until the dependency graph has been fully built, and therefore module
    imports and exports have to be static.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在ESM中，这三个阶段完全相互独立，没有代码可以在完全构建依赖图之前执行，因此模块导入和导出必须是静态的。
- en: Read-only live bindings
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读的实时绑定
- en: Another fundamental characteristic of ES modules, which helps with cyclic dependencies,
    is the idea that imported modules are effectively *read-only live bindings* to
    their exported values.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ES模块的另一个基本特征，有助于解决循环依赖，是这样一个想法：导入的模块对其导出值是有效的*只读实时绑定*。
- en: 'Let''s clarify what this means with a simple example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来澄清这意味着什么：
- en: '[PRE46]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This module exports two values: a simple integer counter called `count` and
    an `increment` function that increases the counter by one.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块导出两个值：一个简单的整数计数器，称为`count`，以及一个`increment`函数，该函数将计数器增加一。
- en: 'Let''s now write some code that uses this module:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写一些使用此模块的代码：
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What we can see in this code is that we can read the value of `count` at any
    time and change it using the `increment()` function, but as soon as we try to
    mutate the `count` variable directly, we get an error as if we were trying to
    mutate a `const` binding.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们可以看到我们可以在任何时候读取`count`的值，并使用`increment()`函数来更改它，但当我们尝试直接修改`count`变量时，我们会得到一个错误，就像我们试图修改一个`const`绑定一样。
- en: This proves that when an entity is imported in the scope, the binding to its
    original value cannot be changed (*read-only binding*) unless the bound value
    changes within the scope of the original module itself (*live binding*), which
    is outside the direct control of the consumer code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了当一个实体在作用域中被导入时，其原始值的绑定不能被更改（*只读绑定*），除非在原始模块的作用域内更改绑定值（*实时绑定*），这超出了消费者代码的直接控制。
- en: This approach is fundamentally different from CommonJS. In fact, in CommonJS,
    the entire `exports` object is copied (shallow copy) when required from a module.
    This means that, if the value of primitive variables like numbers or string is
    changed at a later time, the requiring module won't be able to see those changes.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与CommonJS在本质上不同。事实上，在CommonJS中，当从模块中请求时，整个`exports`对象被复制（浅复制）。这意味着，如果原始变量（如数字或字符串）的值在以后被更改，请求模块将无法看到这些更改。
- en: Circular dependency resolution
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环依赖解决
- en: 'Now to close the circle, let''s reimplement the circular dependency example
    we saw in the *CommonJS modules* section using the ESM syntax:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了闭合循环，让我们重新实现我们在*CommonJS模块*部分看到的循环依赖示例，使用ESM语法：
- en: '![02%20The%20Module%20system%20-%20Images/circular-dependency-example.png](img/B15729_02_03.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![02%20The%20Module%20system%20-%20Images/circular-dependency-example.png](img/B15729_02_03.png)'
- en: 'Figure 2.3: An example scenario with circular dependencies'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：循环依赖的示例场景
- en: 'Let''s have a look at the modules `a.js` and `b.js` first:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看模块`a.js`和`b.js`：
- en: '[PRE48]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And now let''s see how to import those two modules in our `main.js` file (the
    entry point):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在`main.js`文件（入口点）中导入这两个模块：
- en: '[PRE49]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that this time we are not using `JSON.stringify` because that will fail
    with a `TypeError: Converting circular structure to JSON`, since there''s an actual
    circular reference between `a.js` and `b.js`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，这次我们不是使用`JSON.stringify`，因为这将因为`TypeError: Converting circular structure
    to JSON`而失败，因为`a.js`和`b.js`之间存在实际的循环引用。'
- en: 'When we run `main.js`, we will see the following output:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`main.js`时，我们将看到以下输出：
- en: '[PRE50]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The interesting bit here is that the modules `a.js` and `b.js` have a complete
    picture of each other, unlike what would happen with CommonJS, where they would
    only hold partial information of each other. We can see that because all the `loaded`
    values are set to `true`. Also, `b` within `a` is an actual reference to the same
    `b` instance available in the current scope, and the same goes for `a` within
    `b`. That's the reason why we cannot use `JSON.stringify()` to serialize these
    modules. Finally, if we swap the order of the imports for the modules `a.js` and
    `b.js`, the final outcome does not change, which is another important difference
    in comparison with how CommonJS works
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，模块`a.js`和`b.js`对彼此有一个完整的了解，这与CommonJS的情况不同，在CommonJS中，它们只会持有彼此的部分信息。我们可以看到，因为所有的`loaded`值都被设置为`true`。此外，`a`中的`b`是对当前作用域中可用的相同`b`实例的实际引用，反之亦然。这就是为什么我们不能使用`JSON.stringify()`来序列化这些模块的原因。最后，如果我们交换模块`a.js`和`b.js`导入的顺序，最终结果不会改变，这与CommonJS的工作方式相比是另一个重要的不同点。
- en: It's worth spending some more time observing what happens in the three phases
    of the module resolution (parsing, instantiation, and evaluation) for this specific
    example.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花更多时间观察这个特定示例的模块解析（解析、实例化和评估）三个阶段中发生的情况。
- en: 'Phase 1: Parsing'
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阶段1：解析
- en: 'During the parsing phase, the code is explored starting from the entry point
    (`main.js`). The interpreter looks only for `import` statements to find all the
    necessary modules and to load the source code from the module files. The dependency
    graph is explored in a depth-first fashion, and every module is visited only once.
    This way the interpreter builds a view of the dependencies that looks like a tree
    structure, as shown in *Figure 2.4*:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析阶段，代码从入口点（`main.js`）开始探索。解释器只查找`import`语句以找到所有必要的模块并从模块文件中加载源代码。依赖图以深度优先的方式探索，每个模块只访问一次。这样，解释器构建了一个看起来像树结构的依赖视图，如图*图2.4*所示：
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependency-parsing-steps.png](img/B15729_02_04.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependency-parsing-steps.png](img/B15729_02_04.png)'
- en: 'Figure 2.4: Parsing of cyclic dependencies with ESM'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：使用ESM解析循环依赖
- en: 'Given the example in *Figure 2.4*, let''s discuss the various steps of the
    parsing phase:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*图2.4*中的示例，让我们讨论解析阶段的各种步骤：
- en: From `main.js`, the first import found leads us straight into `a.js`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`main.js`开始，第一个导入直接进入`a.js`。
- en: In `a.js` we find an import pointing to `b.js`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`a.js`中，我们发现一个指向`b.js`的导入。
- en: In `b.js`, we also have an import back to `a.js` (our cycle), but since `a.js`
    has already been visited, this path is not explored again.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`b.js`中，我们也有一个指向`a.js`的导入（我们的循环），但由于`a.js`已经被访问过，这条路径不再被探索。
- en: 'At this point, the exploration starts to wind back: `b.js` doesn''t have other
    imports, so we go back to `a.js`; `a.js` doesn''t have other `import` statements
    so we go back to `main.js`. Here we find another import pointing to `b.js`, but
    again this module has been explored already, so this path is ignored.'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，探索开始回溯：`b.js`没有其他导入，所以我们回到`a.js`；`a.js`没有其他`import`语句，所以我们回到`main.js`。在这里，我们发现另一个指向`b.js`的导入，但这个模块已经被探索过了，所以这条路径被忽略。
- en: 'At this point, our depth-first visit of the dependency graph has been completed
    and we have a linear view of the modules, as shown in *Figure 2.5*:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们对依赖图的深度优先访问已经完成，并且我们有一个模块的线性视图，如图*图2.5*所示：
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependency-parsing-result.png](img/B15729_02_05.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![02%20模块系统-%20图片/esm-circular-dependency-parsing-result.png](img/B15729_02_05.png)'
- en: 'Figure 2.5: A linear view of the module graph where cycles have been removed'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：移除循环的模块图的线性视图
- en: This particular view is quite simple. In more realistic scenarios with a lot
    more modules, the view will look more like a tree structure.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的视图相当简单。在更现实的场景中，有更多模块的情况下，视图将更像是一个树状结构。
- en: 'Phase 2: Instantiation'
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二阶段：实例化
- en: 'In the instantiation phase, the interpreter walks the tree view obtained from
    the previous phase from the bottom to the top. For every module, the interpreter
    will look for all the exported properties first and build out a map of the exported
    names in memory:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化阶段，解释器从上一阶段获得的树形视图的底部到顶部遍历。对于每个模块，解释器将首先查找所有导出属性，并在内存中构建导出名称的映射：
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependencies-instantiation-link-exports.png](img/B15729_02_06.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![02%20模块系统-%20图片/esm-circular-dependencies-instantiation-link-exports.png](img/B15729_02_06.png)'
- en: 'Figure 2.6: A visual representation of the instantiation phase'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：实例化阶段的视觉表示
- en: '*Figure 2.6* describes the order in which every module is instantiated:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.6* 描述了每个模块实例化的顺序：'
- en: The interpreter starts from `b.js` and discovers that the module exports `loaded`
    and `a`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释器从 `b.js` 开始，发现该模块导出 `loaded` 和 `a`。
- en: Then, the interpreter moves to `a.js`, which exports `loaded` and `b`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，解释器移动到 `a.js`，该模块导出 `loaded` 和 `b`。
- en: Finally, it moves to `main.js`, which does not export any functionality.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它移动到不导出任何功能的 `main.js`。
- en: Note that, in this phase, the exports map keeps track of the exported names
    only; their associated values are considered uninitialized for now.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在这个阶段，导出映射仅跟踪导出的名称；它们关联的值目前被视为未初始化。
- en: 'After this sequence of steps, the interpreter will do another pass to link
    the exported names to the modules importing them, as shown in *Figure 2.7*:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这一系列步骤后，解释器将再次遍历以将导出的名称链接到导入它们的模块，如图2.7所示：
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependencies-instantiation-link-imports.png](img/B15729_02_07.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![02%20模块系统-%20图片/esm-circular-dependencies-instantiation-link-imports.png](img/B15729_02_07.png)'
- en: 'Figure 2.7: Linking exports with imports across modules'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：模块间导出与导入的链接
- en: 'We can describe what we see in *Figure 2.7* through the following steps:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤描述图2.7中我们看到的内容：
- en: Module `b.js` will link the exports from `a.js`, referring to them as `aModule`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块 `b.js` 将链接 `a.js` 的导出，将其称为 `aModule`。
- en: In turn, `a.js` will link to all the exports from `b.js`, referring to them
    as `bModule`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相应地，`a.js` 将链接到 `b.js` 的所有导出，将其称为 `bModule`。
- en: Finally, `main.js` will import all the exports in `b.js`, referring to them
    as `b`; similarly, it will import everything from `a.js`, referring to them as
    `a`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`main.js` 将导入 `b.js` 中的所有导出，将其称为 `b`；同样，它将导入 `a.js` 中的所有内容，将其称为 `a`。
- en: Again, it's important to note that all the values are still uninitialized. In
    this phase, we are only linking references to values that will be available at
    the end of the next phase.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，所有值仍然未初始化。在这个阶段，我们只是在链接下一阶段末将可用的值的引用。
- en: 'Phase 3: Evaluation'
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第三阶段：评估
- en: 'The last step is the evaluation phase. In this phase, all the code in every
    file is finally executed. The execution order is again bottom-up respecting the
    post-order depth-first visit of our original dependency graph. With this approach,
    `main.js` is the last file to be executed. This way, we can be sure that all the
    exported values have been initialized before we start executing our main business
    logic:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是评估阶段。在这个阶段，每个文件中的所有代码最终都会被执行。执行顺序再次是自下而上的，遵循我们原始依赖图的后序深度优先遍历。采用这种方法，`main.js`
    是最后一个被执行的文件。这样，我们可以确保在开始执行我们的主要业务逻辑之前，所有导出的值都已初始化：
- en: '![02%20The%20Module%20system%20-%20Images/esm-circular-dependency-evaluation.png](img/B15729_02_08.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![02%20模块系统-%20图片/esm-circular-dependency-evaluation.png](img/B15729_02_08.png)'
- en: 'Figure 2.8: A visual representation of the evaluation phase'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：评估阶段的视觉表示
- en: 'Following along from the diagram in *Figure 2.8*, this is what happens:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图2.8中的图示进行，这是发生的情况：
- en: The execution starts from `b.js` and the first line to be evaluated initializes
    the `loaded` export to `false` for the module.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行从 `b.js` 开始，第一条要评估的语句将模块的 `loaded` 导出初始化为 `false`。
- en: Similarly, here the exported property `a` gets evaluated. This time, it will
    be evaluated to a reference to the module object representing module `a.js`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，这里导出的属性`a`将被评估。这次，它将被评估为指向表示模块`a.js`的模块对象的引用。
- en: The value of the `loaded` property gets changed to `true`. At this point, we
    have fully evaluated the state of the exports for module `b.js`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loaded`属性的值被更改为`true`。此时，我们已经完全评估了模块`b.js`的导出状态。'
- en: Now the execution moves to `a.js`. Again, we start by setting `loaded` to `false`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行流程转移到`a.js`。同样，我们首先将`loaded`设置为`false`。
- en: At this point, the `b` export is evaluated to a reference to module `b.js`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，`b`导出被评估为指向模块`b.js`的引用。
- en: Finally, the `loaded` property is changed to `true`. Now we have finally evaluated
    all the exports for `a.js` as well.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`loaded`属性更改为`true`。现在我们终于评估了`a.js`的所有导出。
- en: After all these steps, the code in `main.js` can be executed, and at this point,
    all the exported properties are fully evaluated. Since imported modules are tracked
    as references, we can be sure every module has an up-to-date picture of the other
    modules, even in the presence of circular dependencies.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些步骤之后，`main.js`中的代码可以执行，此时所有导出属性都已完全评估。由于导入的模块作为引用进行跟踪，我们可以确信每个模块都有其他模块的最新视图，即使在存在循环依赖的情况下。
- en: Modifying other modules
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改其他模块
- en: We saw that entities imported through ES modules are *read-only live bindings*,
    and therefore we cannot reassign them from an external module.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到通过ES模块导入的实体是只读的实时绑定，因此我们无法从外部模块重新分配它们。
- en: There's a caveat, though. It is true that we can't change the bindings of the
    default export or named exports of an existing module from another module, but,
    if one of these bindings is an object, we can still mutate the object itself by
    reassigning some of the object properties.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个注意事项。确实，我们不能从另一个模块更改现有模块的默认导出或命名导出的绑定，但如果这些绑定之一是对象，我们仍然可以通过重新分配一些对象属性来修改该对象本身。
- en: 'This caveat can give us enough freedom to alter the behavior of other modules.
    To demonstrate this idea, let''s write a module that can alter the behavior of
    the core `fs` module so that it prevents the module from accessing the filesystem
    and returns mocked data instead. This kind of module is something that could be
    useful while writing tests for a component that relies on the filesystem:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注意事项可以给我们足够的自由来改变其他模块的行为。为了演示这个想法，让我们编写一个可以改变核心`fs`模块行为的模块，使其防止模块访问文件系统并返回模拟数据。这种模块在编写依赖于文件系统的组件的测试时可能很有用：
- en: '[PRE51]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s review the preceding code:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码：
- en: The first thing we do is import the default export of the `fs` module. We will
    get back to this in a second, for now, just keep in mind that the default export
    of the `fs` module is an object that contains a collection of functions that allows
    us to interact with the filesystem.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入`fs`模块的默认导出。我们稍后会回到这个问题，现在只需记住`fs`模块的默认导出是一个包含允许我们与文件系统交互的函数集合的对象。
- en: We want to replace the `readFile()` function with a mock implementation. Before
    doing that, we save a reference to the original implementation. We also declare
    a `mockedResponse` value that we will be using later.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想用模拟实现来替换`readFile()`函数。在这样做之前，我们保存了对原始实现的引用。我们还声明了一个`mockedResponse`值，我们将在稍后使用它。
- en: The function `mockedReadFile()` is the actual mocked implementation that we
    want to use to replace the original implementation. This function invokes the
    callback with the current value of `mockedResponse`. Note that this is a simplified
    implementation; the real function accepts an optional `options` argument before
    the callback argument and is able to handle different types of encoding.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mockedReadFile()`函数是我们想要用来替换原始实现的实际模拟实现。这个函数使用`mockedResponse`的当前值调用回调。请注意，这是一个简化的实现；真正的函数在回调参数之前接受一个可选的`options`参数，并且能够处理不同类型的编码。'
- en: The exported `mockEnable()` function can be used to activate the mocked functionality.
    The original implementation will be swapped with the mocked one. The mocked implementation
    will return the same value passed here through the `respondWith` argument.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出的`mockEnable()`函数可以用来激活模拟功能。原始实现将被替换为模拟实现。模拟实现将通过`respondWith`参数返回传递给这里的相同值。
- en: Finally, the exported `mockDisable()` function can be used to restore the original
    implementation of the `fs.readFile()` function.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，导出的`mockDisable()`函数可以用来恢复`fs.readFile()`函数的原始实现。
- en: 'Now let''s see a simple example that uses this module:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个使用此模块的简单示例：
- en: '[PRE52]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s discuss step by step what happens in this example:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地讨论这个例子中发生了什么：
- en: The first thing that we do is import the default export of the `fs` module.
    Again, note that we are importing specifically the default export exactly as we
    did in our `mock-read-file.js` module, but more on this later.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先做的是导入`fs`模块的默认导出。再次注意，我们导入的正是默认导出，就像我们在`mock-read-file.js`模块中所做的那样，但关于这一点我们稍后再说。
- en: Here we enable the mock functionality. We want, for every file read, to simulate
    that the file contains the string "Hello World."
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里我们启用模拟功能。我们希望，对于每个读取的文件，都模拟它包含字符串“Hello World”。
- en: Finally, we read a file using a fake path. This code will print "Hello World"
    as it will be using the mocked version of the `readFile()` function. Note that,
    after calling this function, we restore the original implementation by calling
    `mockDisable()`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用一个假路径读取文件。这段代码将打印“Hello World”，因为它将使用`readFile()`函数的模拟版本。请注意，在调用此函数后，我们通过调用`mockDisable()`来恢复原始实现。
- en: This approach works, but it is very fragile. In fact, there are a number of
    ways in which this may not work.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行，但非常脆弱。实际上，有几种方式这种方法可能不起作用。
- en: 'On the `mock-read-file.js` side, we could have tried the two following imports
    for the `fs` module:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mock-read-file.js`的一侧，我们可以尝试对`fs`模块进行以下两种导入：
- en: '[PRE53]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: or
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE54]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Both of them are valid imports because the `fs` module exports all the filesystem
    functions as named exports (other than a default export which is an object with
    the same collection of functions as attributes).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种导入都是有效的，因为`fs`模块将所有文件系统函数作为命名导出（除了一个默认导出，它是一个具有相同函数集合的属性的对象）。
- en: 'There are certain issues with the preceding two `import` statements:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个`import`语句存在某些问题：
- en: We would get a read-only live binding into the `readFile()` function, and therefore,
    we would be unable to mutate it from an external module. If we try these approaches,
    we will get an error when trying to reassign `readFile()`.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们会得到一个只读的活绑定到`readFile()`函数中，因此，我们将无法从外部模块对其进行修改。如果我们尝试这些方法，尝试重新分配`readFile()`时将会得到错误。
- en: Another issue is on the consumer side within our `main.js`, where we could use
    these two alternative import styles as well. In this case, we won't end up using
    the mocked functionality, and therefore the code will trigger an error while trying
    to read a nonexistent file.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个问题出在我们的`main.js`的消费者端，我们也可以使用这两种替代的导入样式。在这种情况下，我们最终不会使用模拟功能，因此代码在尝试读取一个不存在的文件时将触发错误。
- en: The reason why using one of the two `import` statements mentioned above would
    not work is because our mocking utility is altering only the copy of the `readFile()`
    function that is registered inside the object exported as the default export,
    but not the one available as a named export at the top level of the module.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用上面提到的两种`import`语句之一不会工作，是因为我们的模拟工具只修改了作为默认导出对象内部注册的`readFile()`函数的副本，而没有修改模块顶层作为命名导出可用的那个。
- en: This particular example shows us how monkey patching could be much more complicated
    and unreliable in the context of ESM. For this reason, testing frameworks such
    as Jest ([nodejsdp.link/jest](http://nodejsdp.link/jest)) provide special functionalities
    to be able to mock ES modules more reliably ([nodejsdp.link/jest-mock](http://nodejsdp.link/jest-mock)).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子向我们展示了在ESM的上下文中，猴子补丁可能更加复杂且不可靠。因此，测试框架如Jest（[nodejsdp.link/jest](http://nodejsdp.link/jest)）提供了特殊功能，以便更可靠地模拟ES模块（[nodejsdp.link/jest-mock](http://nodejsdp.link/jest-mock)）。
- en: Another approach that can be used to mock modules is to rely on the hooks available
    in a special Node.js core module called `module` ([nodejsdp.link/module-doc](http://nodejsdp.link/module-doc)).
    One simple library that takes advantage of this module is `mocku` ([nodejsdp.link/mocku](http://nodejsdp.link/mocku)).
    Check out its source code if you are curious.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以用来模拟模块的方法是依赖于一个特殊Node.js核心模块`module`中可用的钩子（[nodejsdp.link/module-doc](http://nodejsdp.link/module-doc)）。一个利用此模块的简单库是`mocku`（[nodejsdp.link/mocku](http://nodejsdp.link/mocku)）。如果你好奇，可以查看它的源代码。
- en: 'We could also use the `syncBuiltinESMExports()` function from the `module`
    package. When this function is invoked, the value of the properties in the default
    exports object gets mapped again into the equivalent named exports, effectively
    allowing us to propagate any external change applied to the module functionality
    even to named exports:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用来自 `module` 包的 `syncBuiltinESMExports()` 函数。当这个函数被调用时，默认导出对象中属性的值会被重新映射到等效的命名导出中，从而有效地允许我们将应用于模块功能的外部更改传播到命名导出中：
- en: '[PRE55]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We could use this to make our small filesystem mocking utility a little bit
    more flexible by invoking the `syncBuiltinESMExports()` function after we enable
    the mock or after we restore the original functionality.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一点，通过在启用模拟或恢复原始功能后调用 `syncBuiltinESMExports()` 函数，使我们的小型文件系统模拟工具变得更加灵活。
- en: Note that `syncBuiltinESMExports()` works only for built-in Node.js modules
    like the `fs` module in our example.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`syncBuiltinESMExports()` 只适用于内置的 Node.js 模块，例如我们例子中的 `fs` 模块。
- en: This concludes our exploration of ESM. At this point, we should be able to appreciate
    how ESM works, how it loads modules, and how it deals with cyclic dependencies.
    To close this chapter, we are now ready to discuss some key differences and some
    interesting interoperability techniques between CommonJS and ECMAScript modules.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 ESM 的探索。到目前为止，我们应该能够欣赏 ESM 的工作方式，它如何加载模块，以及它如何处理循环依赖。为了结束这一章，我们现在准备讨论一些
    CommonJS 和 ECMAScript 模块之间的关键差异和一些有趣的互操作性技术。
- en: ESM and CommonJS differences and interoperability
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ESM 和 CommonJS 的差异与互操作性
- en: We already mentioned several important differences between ESM and CommonJS,
    such as having to explicitly specify file extensions in imports with ESM, while
    file extensions are totally optional with the CommonJS `require` function.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了 ESM 和 CommonJS 之间的一些重要差异，例如在使用 ESM 进行导入时必须显式指定文件扩展名，而 CommonJS 的 `require`
    函数中文件扩展名是完全可选的。
- en: Let's close this chapter by discussing some other important differences between
    ESM and CommonJS and how the two module systems can work together when necessary.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过讨论 ESM 和 CommonJS 之间的一些其他重要差异来结束这一章，以及当需要时这两个模块系统如何协同工作。
- en: ESM runs in strict mode
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ESM 在严格模式下运行
- en: ES modules run implicitly in strict mode. This means that we don't have to explicitly
    add the `"use strict"` statements at the beginning of every file. Strict mode
    cannot be disabled; therefore, we cannot use undeclared variables or the `with`
    statement or have other features that are only available in non-strict mode, but
    this is definitely a good thing, as strict mode is a safer execution mode.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ES 模块在隐式严格模式下运行。这意味着我们不需要在每个文件的开始处显式添加 `"use strict"` 语句。严格模式不能被禁用；因此，我们不能使用未声明的变量或
    `with` 语句，或者有其他仅在非严格模式下可用的功能，但这绝对是一件好事，因为严格模式是一种更安全的执行模式。
- en: If you are curious to find out more about the differences between the two modes,
    you can check out a very detailed article on MDN Web Docs ([https://nodejsdp.link/strict-mode](https://nodejsdp.link/strict-mode)).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇想了解更多关于两种模式之间差异的信息，你可以查看 MDN Web Docs 上的一篇非常详细的文章（[https://nodejsdp.link/strict-mode](https://nodejsdp.link/strict-mode)）。
- en: Missing references in ESM
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失的 ESM 引用
- en: 'In ESM, some important CommonJS references are not defined. These include `require`,
    `exports`, `module.exports`, `__filename`, and `__dirname`. If we try to use any
    of them within an ES module, since it also runs in strict mode, we will get a
    `ReferenceError`:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ESM 中，一些重要的 CommonJS 引用没有被定义。这些包括 `require`、`exports`、`module.exports`、`__filename`
    和 `__dirname`。如果我们尝试在 ES 模块中使用它们，由于它也在严格模式下运行，我们将得到一个 `ReferenceError`：
- en: '[PRE56]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We already discussed at length the meaning of `exports` and `module` in CommonJS;
    `__filename` and `__dirname` represent the absolute path to the current module
    file and the absolute path to its parent folder. Those special variables can be
    very useful when we need to build a path relative to the current file.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细讨论了 CommonJS 中 `exports` 和 `module` 的含义；`__filename` 和 `__dirname` 代表当前模块文件的绝对路径及其父文件夹的绝对路径。当我们需要构建相对于当前文件的相对路径时，这些特殊变量非常有用。
- en: 'In ESM, it is possible to get a reference to the current file URL by using
    the special object `import.meta`. Specifically, `import.meta.url` is a reference
    to the current module file in a format similar to `file:///path/to/current_module.js`.
    This value can be used to reconstruct `__filename` and `__dirname` in the form
    of absolute paths:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ESM 中，可以使用特殊对象 `import.meta` 来获取当前文件 URL 的引用。具体来说，`import.meta.url` 是对当前模块文件的引用，其格式类似于
    `file:///path/to/current_module.js`。此值可以用来以绝对路径的形式重建 `__filename` 和 `__dirname`：
- en: '[PRE57]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It is also possible to recreate the `require()` function as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以按照以下方式重新创建 `require()` 函数：
- en: '[PRE58]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now we can use `require()` to import functionality coming from CommonJS modules
    in the context of ES modules.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `require()` 在 ES 模块的上下文中导入来自 CommonJS 模块的功能。
- en: Another interesting difference is the behavior of the `this` keyword.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的不同之处在于 `this` 关键字的行怍。
- en: 'In the global scope of an ES module, `this` is `undefined`, while in CommonJS,
    `this` is a reference to `exports`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES 模块的全局作用域中，`this` 是 `undefined`，而在 CommonJS 中，`this` 是对 `exports` 的引用：
- en: '[PRE59]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Interoperability
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互操作性
- en: 'We discussed in the previous section how to import CommonJS modules in ESM
    by using the `module.createRequire` function. It is also possible to import CommonJS
    modules from ESM by using the standard `import` syntax. This is only limited to
    default exports, though:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了如何使用 `module.createRequire` 函数在 ESM 中导入 CommonJS 模块。也可以使用标准的 `import`
    语法从 ESM 中导入 CommonJS 模块。但这仅限于默认导出：
- en: '[PRE60]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Unfortunately, it is not possible to import ES modules from CommonJS modules.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，从 CommonJS 模块中导入 ES 模块是不可能的。
- en: 'Also, ESM cannot import JSON files directly as modules, a feature that is used
    quite frequently with CommonJS. The following `import` statement will fail:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ESM 不能直接将 JSON 文件作为模块导入，这是 CommonJS 中常用的一项功能。以下 `import` 语句将失败：
- en: '[PRE61]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It will produce a `TypeError` (`Unknown file extension: .json`).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '它将产生一个 `TypeError` (`Unknown file extension: .json`)。'
- en: 'To overcome this limitation, we can use again the `module.createRequire` utility:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一限制，我们可以再次使用 `module.createRequire` 工具：
- en: '[PRE62]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There is ongoing work to support JSON modules natively even in ESM, so we may
    not need to rely on `createRequire()` in the near future for this functionality.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 目前正在进行支持 JSON 模块原生功能的工作，即使在 ESM 中，因此我们可能不久后就不需要依赖 `createRequire()` 来实现这一功能。
- en: Summary
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored in depth what modules are, why they are useful,
    and why we need a module system. We also learned about the history of modules
    in JavaScript and about the two module systems available today in Node.js, namely
    CommonJS and ESM. We also explored some common patterns that are useful when creating
    modules or when using third-party modules.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了模块是什么，为什么它们有用，以及为什么我们需要模块系统。我们还了解了 JavaScript 中模块的历史，以及今天在 Node.js
    中可用的两种模块系统，即 CommonJS 和 ESM。我们还探讨了在创建模块或使用第三方模块时一些有用的常见模式。
- en: You should now be comfortable with understanding and writing code that takes
    advantage of the features of both CommonJS and ESM.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够舒适地理解和编写利用 CommonJS 和 ESM 特性的代码。
- en: In the rest of the book, we will rely mostly on ES modules, but you should now
    be equipped to be flexible with your choices and be able to deal with CommonJS
    effectively if necessary.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将主要依赖 ES 模块，但你现在应该能够灵活地做出选择，并在必要时有效地处理 CommonJS。
- en: In the next chapter, we will start to explore the idea of asynchronous programming
    with JavaScript, and we will examine callbacks, events, and their patterns in
    depth.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探讨使用 JavaScript 进行异步编程的概念，并深入探讨回调、事件及其模式。
