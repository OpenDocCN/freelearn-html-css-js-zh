- en: Chapter 4. Application Development with Components and Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. 使用组件和模块进行应用程序开发
- en: 'Okay, time to get back to application development. We touched briefly on this
    back in [Chapter 1](part0015_split_000.html#page "Chapter 1. Knockout Essentials"),
    *Knockout Essentials*; we will be returning to it here. This chapter is all about
    how to work with Knockout inside modern web applications. In this chapter, we
    will look at the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候回到应用程序开发上了。我们之前在 [第 1 章](part0015_split_000.html#page "第 1 章. Knockout
    基础") 简单提到了这一点，*Knockout 基础*；我们将在本章继续探讨。本章主要介绍如何在现代网页应用程序中使用 Knockout。在本章中，我们将探讨以下主题：
- en: Using modules with RequireJS
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RequireJS 的模块
- en: Creating reusable components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用组件
- en: Extending Knockout with custom component loaders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义组件加载器扩展 Knockout
- en: '**Single Page Application** (**SPA**) routing'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单页应用**（SPA）路由'
- en: Because Knockout is a library—a fact it proclaims proudly on the home page—it
    doesn't cover everything you need in complete web applications. This allows Knockout
    to specialize by focusing on a limited feature set, but it leaves the task of
    deciding how to build the rest of the application to you, the developer. The methods
    we cover in this chapter are not the only available options—we don't have that
    kind of time or space—but they should provide enough general guidance to help
    you make your own decisions while keeping in mind Knockout's strengths.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Knockout 是一个库——它在主页上自豪地宣称这一点——它并不涵盖你在完整的网页应用程序中需要的所有内容。这使得 Knockout 能够通过专注于有限的功能集来专业化，但将决定如何构建应用程序其余部分的任务留给了你，即开发者。我们本章中介绍的方法并不是唯一可用的选项——我们没有那么多时间或空间来介绍——但它们应该提供足够的通用指导，帮助你做出自己的决定，同时考虑到
    Knockout 的优势。
- en: We are also going to transform the `Contacts List` application to an SPA—an
    application that uses JavaScript to change the template of the current view, mimicking
    a page change instead of using browser navigation. This pattern has become so
    popular that most developers consider it a given when working on new JavaScript
    web clients, so it's important to understand how Knockout fits into this model
    of development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把 `联系人列表` 应用程序转换成一个单页应用（SPA）——一个使用 JavaScript 来更改当前视图模板的应用程序，模拟页面变化而不是使用浏览器导航。这种模式已经变得如此流行，以至于大多数开发者在开发新的
    JavaScript 网页客户端时都认为这是理所当然的，因此了解 Knockout 如何适应这种开发模式是很重要的。
- en: RequireJS – AMD viewmodels
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RequireJS – AMD 视图模型
- en: RequireJS ([http://requirejs.org/](http://requirejs.org/)) is a library that
    you should have at least heard of already, if not used. This is still a book about
    Knockout, and if you are planning to use RequireJS in an application, you should
    read up on it first, but I will still give you a brief overview here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS ([http://requirejs.org/](http://requirejs.org/)) 是一个你应该已经听说过的库，即使没有使用过。这本书仍然是关于
    Knockout 的，如果你计划在应用程序中使用 RequireJS，你应该先了解它，但在这里我仍会给你一个简要概述。
- en: An overview of RequireJS
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RequireJS 概述
- en: RequireJS's purpose is to allow your code to be broken into modules that declare
    their dependencies so that they can be injected at runtime. This has several important
    benefits. As RequireJS loads your JavaScript, you don't have to include each script
    with a `script` tag in your HTML. As RequireJS loads the scripts based on their
    dependencies, you don't have to worry about the order they are loaded in. As each
    module's dependencies are injected, the module can be tested easily with mocks.
    RequireJS also keeps all the objects it loads out of the global scope, which decreases
    the likelihood of namespace collisions in addition to being considered a good
    general practice.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS 的目的是允许你的代码被分割成声明其依赖关系的模块，以便在运行时注入。这有几个重要的好处。当 RequireJS 加载你的 JavaScript
    时，你不需要在 HTML 中使用 `script` 标签包含每个脚本。由于 RequireJS 根据依赖关系加载脚本，你不必担心它们加载的顺序。随着每个模块的依赖关系被注入，模块可以很容易地使用模拟进行测试。此外，RequireJS
    还将加载的所有对象保持在全局作用域之外，这除了被视为良好的通用实践外，还减少了命名空间冲突的可能性。
- en: By default, RequireJS will asynchronously load all of your scripts on demand
    at runtime. In some cases, this lazy loading is beneficial, but in production,
    you will want your code bundled into a single file most of the time. RequireJS
    provides **r.js**, its optimizer, for this. RequireJS can even combine these techniques
    by bundling multiple groups of files together and then loading these groups on
    demand at runtime. The best part is that your code won't have to change, regardless
    of which mode you work in!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，RequireJS 将在运行时按需异步加载所有脚本。在某些情况下，这种延迟加载是有益的，但在生产中，你通常希望将代码打包成一个单独的文件。为此，RequireJS
    提供了其优化器 **r.js**。RequireJS 甚至可以通过将多个文件组打包在一起，然后在运行时按需加载这些组来结合这些技术。最好的部分是，无论你处于哪种工作模式，你的代码都不需要改变！
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We won't be covering `r.js`, but if you are developing web applications, it
    might be worth investigating this (see [http://requirejs.org/docs/optimization.html](http://requirejs.org/docs/optimization.html)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会介绍 `r.js`，但如果你在开发 Web 应用程序，调查这一点可能值得（见 [http://requirejs.org/docs/optimization.html](http://requirejs.org/docs/optimization.html)）。
- en: Asynchronous Module Definitions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步模块定义
- en: '**Asynchronous Module Definitions** (**AMD**) is an important concept in RequireJS:
    it declares a function whose return value represents the module. In form, it isn''t
    too different from the **Immediately Evaluating Function Expressions** (**IEFE**)
    we saw in [Chapter 1](part0015_split_000.html#page "Chapter 1. Knockout Essentials"),
    *Knockout Essentials*. This is a typical module definition:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步模块定义（AMD**）是 RequireJS 中的一个重要概念：它声明了一个函数，其返回值表示模块。在形式上，它与我们在 [第 1 章](part0015_split_000.html#page
    "第 1 章。Knockout 基础")，*Knockout 基础* 中看到的 **立即执行函数表达式（IEFE**）并没有太大的不同。这是一个典型的模块定义：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `define` method forms the first and only top-level statement in the file.
    RequireJS actually enforces a one-module-per-file limit by ignoring multiple calls
    to `define`. The `define` call takes the following three parameters, and the first
    two are optional:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`define` 方法构成了文件中的第一个也是唯一的顶层语句。RequireJS 实际上通过忽略对 `define` 的多次调用来强制执行每个文件一个模块的限制。`define`
    调用接受以下三个参数，前两个是可选的：'
- en: '**Module name**: This parameter is often ignored, as the standard way to reference
    modules is by their path. Hence, we will not use this parameter.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块名称**：此参数通常被忽略，因为引用模块的标准方式是通过它们的路径。因此，我们不会使用此参数。'
- en: '**Dependencies**: This is an array of module names or paths that the module
    depends on. Paths do not require the `.js` suffix; RequireJS already knows it''s
    loading JavaScript.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：这是一个模块名称或路径的数组，该模块依赖于它们。路径不需要 `.js` 后缀；RequireJS 已经知道它正在加载 JavaScript。'
- en: '**Module function**: This function receives each dependency from the previous
    array as a parameter and should return the module.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块函数**：此函数接收前一个数组中的每个依赖项作为参数，并应返回模块。'
- en: When RequireJS tries to load a module, it locates the module by path or name
    and runs the `define` method it finds in that file. First, it checks whether all
    of the dependencies have been loaded; if they have not been loaded, it recursively
    loads them, asynchronously and in parallel. When all dependent modules are loaded,
    it runs the module function, passing in each dependency as a parameter in the
    same order in which they were declared as dependencies. The return value of the
    module-loading function is the value that is passed as a parameter to any modules
    that require it as a dependency.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当 RequireJS 尝试加载一个模块时，它会通过路径或名称定位该模块，并运行在该文件中找到的 `define` 方法。首先，它会检查所有依赖项是否已加载；如果尚未加载，它会递归地异步并行加载它们。当所有依赖模块加载完成后，它会运行模块函数，并将每个依赖项作为参数传入，其顺序与它们作为依赖项声明的顺序相同。模块加载函数的返回值是传递给任何需要它作为依赖项的模块的参数值。
- en: Starting RequireJS
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 RequireJS
- en: 'There are actually multiple ways to start an app using RequireJS, but by far,
    the most common way is with a `script` tag that points to the initial script of
    your application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有几种方法可以使用 RequireJS 启动应用程序，但到目前为止，最常见的方法是使用一个指向应用程序初始脚本的 `script` 标签：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `data-main` attribute indicates which script will configure RequireJS and
    start the application. Note that the `.js` suffix is not necessary, as with normal
    module paths.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-main` 属性指示哪个脚本将配置 RequireJS 并启动应用程序。请注意，与正常模块路径一样，`.js` 后缀不是必需的。'
- en: 'This `script` tag typically goes in your shell (or layout) file, and it replaces
    all of the `script` tags that RequireJS is responsible for loading. In many cases,
    this means that the only JavaScript `script` tag is the one that loads RequireJS.
    This is one of the killer features of RequireJS: as we develop, we no longer need
    to add `script` tags to our HTML code.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`script`标签通常放在你的shell（或布局）文件中，它替换了RequireJS负责加载的所有`script`标签。在许多情况下，这意味着唯一的JavaScript
    `script`标签就是加载RequireJS的那个。这是RequireJS的一个杀手级特性：在我们开发过程中，我们不再需要在HTML代码中添加`script`标签。
- en: Note that the path starts with a forward slash, which makes it an absolute path.
    It's required because the shell is used on multiple pages, and a relative path
    will not work on a URL such as `/contacts/1`, as it will look in `/contacts/app/main.js`
    for our script.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意路径以正斜杠开头，这使得它是一个绝对路径。这是必需的，因为shell被用于多个页面，相对路径在像`/contacts/1`这样的URL上不会工作，因为它会在`/contacts/app/main.js`中寻找我们的脚本。
- en: Configuration
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'The `main.js` file (the conventional name for the entry point of an AMD application)
    typically contains a configuration section before the start. Here is the configuration
    that we will be using:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js`文件（AMD应用的入口点的传统名称）通常在开始之前包含一个配置部分。以下是我们将要使用的配置：'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `paths` section allows us to map paths to module names for use in the dependency
    arrays. This is a good practice for all library code so that our application code
    can use a simple, consistent name. Again, the use of absolute paths is important.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`paths`部分允许我们将路径映射到模块名称，以便在依赖数组中使用。这对于所有库代码来说是一个好习惯，这样我们的应用程序代码就可以使用简单、一致的名字。再次强调，使用绝对路径是很重要的。'
- en: The `shim` section is necessary for loading scripts that depend on globally
    available objects. In the preceding example, the shim for `bootstrap` declares
    jQuery as a dependency and indicates that it exports `$.fn.popover`. Normally,
    you would look for a new namespace such as `$.bootstrap`, but as `bootstrap` doesn't
    create a single endpoint; we are looking for one of the plugins it adds. Any exported
    value can be used here; `popover` was just the chosen one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`shim`部分对于加载依赖于全局对象的脚本来说是必要的。在前面的例子中，`bootstrap`的shim将jQuery声明为一个依赖项，并指示它导出`$.fn.popover`。通常，你会寻找一个新的命名空间，比如`$.bootstrap`，但是因为`bootstrap`没有创建一个单一的端点；我们正在寻找它添加的插件之一。任何导出的值都可以在这里使用；`popover`只是被选中的那个。'
- en: 'Many libraries are starting to support being loaded as AMD: they look for RequireJS
    or other module loaders and use them if they are available. Not all libraries
    do this, though, and the standard model of JavaScript libraries has always been
    to just look for dependencies in the global scope. As `bootstrap` needs `jQuery`
    but does not indicate this dependency to RequireJS, it will fail if we tried to
    load it normally. The shim tells RequireJS that this library is an old global-scope
    style script and manually indicates its dependencies. The `exports` section provides
    an object that RequireJS can look for to check whether the script has finished
    loading. RequireJS will wait until the specified object exists before allowing
    any AMDs that depend on `bootstrap` to start. Essentially, the `shim` section
    is how RequireJS uses non-AMD code as an asynchronous dependency. If you need
    to use jQuery plugins or other non-AMD compatible libraries, just make a shim
    for them.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多库开始支持以AMD方式加载：它们寻找RequireJS或其他模块加载器，并在它们可用时使用它们。尽管并非所有库都这样做，但JavaScript库的标准模式一直是只在全球范围内寻找依赖项。因为`bootstrap`需要`jQuery`，但没有向RequireJS表明这个依赖项，如果我们尝试正常加载它，它将会失败。shim告诉RequireJS这个库是一个旧的全球作用域风格的脚本，并手动指示其依赖项。`exports`部分提供了一个对象，RequireJS可以查找以检查脚本是否已加载完成。RequireJS将等待指定的对象存在，然后才允许任何依赖于`bootstrap`的AMD开始。本质上，`shim`部分是RequireJS如何使用非AMD代码作为异步依赖项的方式。如果你需要使用jQuery插件或其他非AMD兼容的库，只需为它们创建一个shim即可。
- en: There are many other options for the RequireJS configuration—too many to cover
    here. If you want to learn more, check out their documentation, which is available
    at [http://requirejs.org/docs/api.html#config](http://requirejs.org/docs/api.html#config).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS配置有许多其他选项——太多以至于无法在这里全部涵盖。如果你想了解更多，请查看他们的文档，可在[http://requirejs.org/docs/api.html#config](http://requirejs.org/docs/api.html#config)找到。
- en: Starting the app
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动应用
- en: 'Now that RequireJS is configured, it''s time to start the application. The
    main script, which contains our configuration, is also where RequireJS looks for
    the initial module, which looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经配置了RequireJS，是时候启动应用程序了。包含我们配置的主要脚本也是RequireJS寻找初始模块的地方，它看起来像这样：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The main module is just like other modules, except that RequireJS will run it
    as soon as its dependencies are available. This code is the same startup code
    that used to be in the **Contacts** page's script. You might notice that the dependencies
    for this module don't match the names of the parameters being passed in. jQuery
    is being injected as `$`, Knockout as `ko`, and the **Contacts** page constructor
    as `ContactsPageViewModel`. All of these are conventional JavaScript names for
    their matching objects. The modules are injected in the order of the dependency
    array; RequireJS doesn't actually look at the name of the parameter. This is no
    different from standard functions; callers don't care about the names of parameters,
    they only care about the order. This isn't always obvious to new users, though.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 主要模块就像其他模块一样，只不过 RequireJS 会在其依赖项可用时立即运行它。这段代码就是之前在 **联系人** 页面的脚本中使用的启动代码。你可能注意到这个模块的依赖项名称与传入的参数名称不匹配。jQuery
    被注入为 `$`，Knockout 为 `ko`，**联系人** 页面构造函数为 `ContactsPageViewModel`。所有这些都是它们对应对象的常规
    JavaScript 名称。模块按照依赖项数组的顺序注入；RequireJS 实际上并不查看参数的名称。这与标准函数没有区别；调用者不关心参数的名称，只关心顺序。尽管如此，这对新用户来说并不总是显而易见的。
- en: You probably also noticed that `bootstrap` doesn't even have a parameter. This
    is because `bootstrap` doesn't get its own object; all it does is add functions
    to jQuery. However, RequireJS won't load it (or shim it, in this case) until a
    dependency requires it to. It's common to see plugin-style dependencies initialized
    in this manner, as we want them to be available as soon as the app starts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了 `bootstrap` 甚至没有参数。这是因为 `bootstrap` 没有自己的对象；它所做的只是向 jQuery 添加函数。然而，RequireJS
    不会在它被依赖项要求之前加载它（或在这种情况下模拟它）。以这种方式初始化插件式依赖项是很常见的，因为我们希望它们在应用启动时就能可用。
- en: To see the `Contacts List` application after it is converted into AMD modules,
    open the `cp4-contacts` branch. The code was already in IEFE blocks, so not much
    has changed. The `app` object is no longer required, as namespacing has been replaced
    with the dependency injection. All of the `script` tags, except for RequireJS,
    have been removed from the HTML code. The application still functions in the same
    manner, but by using RequireJS, we no longer have to worry about loading the script.
    This might seem like a minor gain now, but it will make a big difference when
    your app starts to grow.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看转换为 AMD 模块后的 `Contacts List` 应用程序，请打开 `cp4-contacts` 分支。代码已经位于 IEFE 块中，所以变化不大。`app`
    对象不再需要，因为命名空间已经被依赖注入所取代。除了 RequireJS 之外的所有 `script` 标签都已从 HTML 代码中删除。应用程序仍然以相同的方式运行，但通过使用
    RequireJS，我们不再需要担心加载脚本。现在这看起来可能是一个小的收益，但当你应用开始增长时，这将会产生很大的影响。
- en: The text plugin
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本插件
- en: 'Managing HTML templates can be tricky, because there is no native way to reference
    or embed external HTML files like there is with scripts. If you are familiar with
    the Knockout community, you might have encountered some of the plugins designed
    to solve the problem, such as *Knockout-External-Templates* (which has been discontinued).
    RequireJS solves this problem cleanly with the text plugin. The text plugin works
    much like standard modules: you declare a dependency on external text, and RequireJS
    injects it into the module just like a normal JavaScript module.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 管理HTML模板可能很棘手，因为没有原生的方式来引用或嵌入外部HTML文件，就像脚本那样。如果你熟悉Knockout社区，你可能遇到过一些旨在解决此问题的插件，例如
    *Knockout-External-Templates*（该插件已停止开发）。RequireJS 通过文本插件干净地解决了这个问题。文本插件的工作方式与标准模块非常相似：你声明对外部文本的依赖，然后
    RequireJS 就像正常 JavaScript 模块一样将其注入到模块中。
- en: 'To get started, you should add the text library to your RequireJS config. Using
    a name such as `text` is standard:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，你应该将文本库添加到你的 RequireJS 配置中。使用如 `text` 这样的名称是标准的：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the text plugin is available, you can use it in external files like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文本插件可用，你就可以在外部文件中使用它，例如：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This configuration part is optional if the text plugin is at the root of your
    app and you use the `text!` prefix for dependencies. As we have been putting our
    third-party libraries in a different folder, the configuration is necessary.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本插件位于你应用的根目录，并且你使用 `text!` 前缀为依赖项，则此配置部分是可选的。由于我们一直在不同的文件夹中放置第三方库，因此配置是必要的。
- en: In the next section, we will look at how to combine this ability with components
    in order to create reusable templates with external, isolated HTML views.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何将这种能力与组件结合，以创建具有外部、隔离的 HTML 视图的可重用模板。
- en: Components
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: In Version 3.2, Knockout added components using the combination of a template
    (view) with a viewmodel to create reusable, behavior-driven DOM objects. Knockout
    components are inspired by web components, a new (and experimental, at the time
    of writing this) set of standards that allow developers to define custom HTML
    elements paired with JavaScript that create packed controls. Like web components,
    Knockout allows the developer to use custom HTML tags to represent these components
    in the DOM. Knockout also allows components to be instantiated with a binding
    handler on standard HTML elements. Knockout binds components by injecting an HTML
    template, which is bound to its own viewmodel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 3.2 版本中，Knockout 通过将模板（视图）与视图模型结合使用来添加组件，以创建可重用、行为驱动的 DOM 对象。Knockout 组件受到了
    Web 组件的启发，这是一组新的（并且在撰写本文时是实验性的）标准，允许开发者定义与 JavaScript 配对的自定义 HTML 元素，从而创建打包的控件。与
    Web 组件类似，Knockout 允许开发者使用自定义 HTML 标签在 DOM 中表示这些组件。Knockout 还允许在标准 HTML 元素上使用绑定处理器来实例化组件。Knockout
    通过注入一个 HTML 模板来绑定组件，该模板绑定到其自己的视图模型。
- en: This is probably the single largest feature Knockout has ever added to the core
    library. The reason we started with RequireJS is that components can optionally
    be loaded and defined with module loaders, including their HTML templates! This
    means that our entire application (even the HTML) can be defined in independent
    modules, instead of as a single hierarchy, and loaded asynchronously.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是 Knockout 一直添加到核心库中的单个最大功能。我们之所以从 RequireJS 开始，是因为组件可以可选地通过模块加载器加载和定义，包括它们的
    HTML 模板！这意味着我们的整个应用程序（甚至 HTML）都可以定义在独立的模块中，而不是作为一个单一层次结构，并且异步加载。
- en: The basic component registration
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本组件注册
- en: 'Unlike extenders and binding handlers, which are created by just adding an
    object to Knockout, components are created by calling the `ko.components.register`
    function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过仅向 Knockout 添加对象来创建的扩展器和绑定处理器不同，组件是通过调用 `ko.components.register` 函数来创建的：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will create a new component named `contact-list`, which uses the object
    returned by the `viewModel` function as a binding context, and the template as
    its view. It is recommended that you use lowercase, dash-separated names for components
    so that they can easily be used as custom elements in your HTML.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `contact-list` 的新组件，它使用 `viewModel` 函数返回的对象作为绑定上下文，并将模板作为其视图。建议您使用小写、由连字符分隔的名称来命名组件，以便它们可以轻松地在
    HTML 中用作自定义元素。
- en: 'To use this newly created component, you can use a custom element or the component
    binding. All the following three tags produce equivalent results:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新创建的组件，您可以使用自定义元素或组件绑定。以下所有三个标签产生等效的结果：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Obviously, the custom element syntax is much cleaner and easier to read. It
    is important to note that custom elements cannot be self-closing tags. This is
    a restriction of the HTML parser and *cannot* be controlled by Knockout.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，自定义元素语法更干净、更容易阅读。需要注意的是，自定义元素不能是自闭合标签。这是 HTML 解析器的限制，并且**不能**由 Knockout 控制。
- en: 'There is one advantage of using the component binding: the name of the component
    can be an observable. If the name of the component changes, the previous component
    will be disposed (just like it would if a control flow binding removed it) and
    the new component will be initialized.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件绑定的一个优点是组件的名称可以是可观察的。如果组件的名称发生变化，则之前的组件将被销毁（就像控制流绑定将其移除时一样），并且将初始化新的组件。
- en: The `params` attribute of custom elements work in a manner that is similar to
    the `data-bin`d attribute. Comma-separated key/value pairs are parsed to create
    a property bag, which is given to the component. The values can contain JavaScript
    literals, observable properties, or expressions. It is also possible to register
    a component without a viewmodel, in which case, the object created by `params`
    is directly used as the binding context.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素的 `params` 属性的工作方式与 `data-bound` 属性类似。逗号分隔的键/值对被解析以创建一个属性包，并将其提供给组件。值可以包含
    JavaScript 字面量、可观察属性或表达式。还可以在不使用视图模型的情况下注册组件，在这种情况下，由 `params` 创建的对象将直接用作绑定上下文。
- en: 'To see this, we''ll convert the list of contacts into a component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这一点，我们将将联系人列表转换为组件：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The HTML code for the list is replaced with a custom element with parameters
    for the list as well as callbacks for the two buttons, which are `edit` and `delete`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的 HTML 代码被替换为一个带有列表参数以及两个按钮（`edit` 和 `delete`）的回调的自定义元素：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This component registration uses an inline template. You can see this component
    in the `cp4-inline-component` branch. Everything still looks and works the same,
    but the resulting HTML now includes our custom element.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件注册使用内联模板。您可以在`cp4-inline-component`分支中看到此组件。一切看起来和运行都相同，但生成的HTML现在包括我们的自定义元素。
- en: '![The basic component registration](img/00007.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![基本组件注册](img/00007.jpeg)'
- en: Custom elements in IE 8 and higher
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IE 8及以上版本的自定义元素
- en: IE 9 and later versions as well as all other major browsers have no issue with
    seeing custom elements in the DOM before they have been registered. However, older
    versions of IE will remove the element if it hasn't been registered. The registration
    can be done either with Knockout, with `ko.components.register('component-name')`,
    or with the standard `document.createElement('component-name')` expression statement.
    One of these must come before the custom element, either by the script containing
    them being first in the DOM, or by the custom element being added at runtime.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: IE 9及更高版本以及所有其他主要浏览器在自定义元素注册之前在DOM中看到自定义元素没有问题。然而，较旧版本的IE如果没有注册，将会移除该元素。注册可以通过Knockout，使用`ko.components.register('component-name')`，或者使用标准的`document.createElement('component-name')`表达式语句来完成。这些中的一个必须放在自定义元素之前，无论是包含它们的脚本在DOM中首先出现，还是自定义元素在运行时被添加。
- en: 'When using RequireJS, being in the DOM first won''t help as the loading is
    asynchronous. If you need to support older IE versions, it is recommended that
    you include a separate script to register the custom element names at the top
    of the `body` tag or in the `head` tag:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用RequireJS时，首先在DOM中不会有所帮助，因为加载是异步的。如果您需要支持较旧的IE版本，建议您在`body`标签顶部或`head`标签中包含一个单独的脚本以注册自定义元素名称：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once this has been done, components will work in IE 6 and higher even with custom
    elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成此操作，组件将在IE 6及以上版本中正常工作，即使有自定义元素。
- en: Template registration
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板注册
- en: 'The `template` property of the configuration sent to register can take any
    of the following formats:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到注册的配置的`template`属性可以采用以下任何一种格式：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The element ID
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素ID
- en: 'Consider the following code statement:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码语句：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you specify the ID of an element in the DOM, the contents of that element
    will be used as the template for the component. Although it isn't supported in
    IE yet, the template element is a good candidate, as browsers do not visually
    render the contents of template elements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在DOM中指定元素的ID，则该元素的内部内容将用作组件的模板。尽管在IE中尚不支持，但模板元素是一个很好的候选者，因为浏览器不会在视觉上渲染模板元素的内容。
- en: This method can be seen in the `cp4-component-id` branch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以在`cp4-component-id`分支中看到。
- en: The element instance
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素实例
- en: 'Consider the following code statement:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码语句：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can pass a real DOM element to the template to be used. This might be useful
    in a scenario where the template was constructed programmatically. Like the element
    ID method, only the contents of the elements will be used as the template:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将实际的DOM元素传递给模板以供使用。这在模板是程序性构建的场景中可能很有用。与元素ID方法一样，只有元素的内部内容将被用作模板：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method can be seen in the `cp4-component-instance` branch.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以在`cp4-component-instance`分支中看到。
- en: An array of DOM nodes
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM节点数组
- en: 'Consider the following code statement:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码语句：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you pass an array of DOM nodes to the template configuration, then the entire
    array will be used as a template and not just the descendants:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将DOM节点数组传递给模板配置，则整个数组将用作模板，而不仅仅是子节点：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This can be seen in the `cp4-component-arrray` branch.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在`cp4-component-arrray`分支中看到。
- en: Document fragments
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档片段
- en: 'Consider the following code statement:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码语句：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you pass a document fragment, the entire fragment will be used as a template
    instead of just the descendants:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您传递一个文档片段，则整个片段将用作模板，而不仅仅是子节点：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example works because template elements wrap their contents in a document
    fragment in order to stop the normal rendering. Using the content is the same
    method that Knockout uses internally when a template element is supplied. This
    example can be seen in the `cp4-component-fragment` branch.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例之所以有效，是因为模板元素将它们的内容包裹在一个文档片段中，以阻止正常的渲染。使用内容是Knockout在提供模板元素时内部使用的相同方法。此示例可以在`cp4-component-fragment`分支中看到。
- en: HTML strings
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML字符串
- en: We already saw an example for HTML strings in the previous section. While using
    the value inline is probably uncommon, supplying a string would be an easy thing
    to do if your build system provided it for you.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中看到了HTML字符串的示例。虽然直接使用值可能不太常见，但如果您的构建系统提供了它，提供字符串将是一件简单的事情。
- en: Registering templates using the AMD module
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AMD模块注册模板
- en: 'Consider the following code statement:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码语句：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If a `require` property is passed to the configuration object of a template,
    the default module loader will load the module and use it as the template. The
    module can return any of the preceding formats. This is especially useful for
    the RequireJS text plugin:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`require`属性传递给模板的配置对象，默认模块加载器将加载该模块并将其用作模板。该模块可以返回上述任何格式。这对于RequireJS文本插件特别有用：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using this method, we can extract the HTML template into its own file, drastically
    improving its organization. By itself, this is a huge benefit to development.
    An example of this can be seen in the `cp4-component-text` branch.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以将HTML模板提取到其自己的文件中，极大地提高了其组织性。仅此一点，对开发来说就是一个巨大的好处。这可以在`cp4-component-text`分支中看到示例。
- en: The viewmodel registration
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图模型注册
- en: 'Like template registration, viewmodels can be registered using several different
    formats. To demonstrate this, we''ll use a simple viewmodel of our contacts list
    components:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像模板注册一样，视图模型可以使用几种不同的格式进行注册。为了演示这一点，我们将使用我们联系列表组件的简单视图模型：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To verify that things are getting wired up properly, you'll want something interactive;
    hence, we use the fake `delete` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证事情是否正确连接，您将想要一个交互式的东西；因此，我们使用假的`delete`函数。
- en: The constructor function
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Consider the following code statement:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码语句：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you supply a function to the `viewModel` property, it will be treated as
    a constructor. When the component is instantiated, `new` will be called on the
    function, with the `params` object as its first parameter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将函数提供给`viewModel`属性，它将被视为构造函数。当组件实例化时，`new`将在该函数上调用，`params`对象作为其第一个参数：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method can be seen in the `cp4-components-constructor` branch.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以在`cp4-components-constructor`分支中看到。
- en: A singleton object
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例对象
- en: 'Consider the following code statement:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码语句：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you want all your component instances to be backed by a shared object—though
    this is not recommended—you can pass it as the `instance` property of a configuration
    object. Because the object is shared, parameters cannot be passed to the viewmodel
    using this method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望所有组件实例都由一个共享对象支持——尽管这不被推荐——您可以将其作为配置对象的`instance`属性传递。由于对象是共享的，因此不能使用此方法将参数传递给视图模型。
- en: The factory function
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂函数
- en: 'Consider the following code statement:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码语句：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This method is useful because it supplies the container element of the component
    to the second parameter on `componentInfo.element`. It also provides you with
    the opportunity to perform any other setup, such as modifying or extending the
    constructor parameters. The `createViewModel` function should return an instance
    of a viewmodel component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很有用，因为它将组件的容器元素提供给`componentInfo.element`的第二个参数。它还为您提供了执行任何其他设置的机会，例如修改或扩展构造函数参数。`createViewModel`函数应返回一个视图模型组件的实例：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example can be seen in the `cp4-component-factory` branch.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例可以在`cp4-component-factory`分支中看到。
- en: Registering viewmodels using an AMD module
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AMD模块注册视图模型
- en: 'Consider the following code statement:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码语句：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Just like templates, viewmodels can be registered with an AMD module that returns
    any of the preceding formats.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像模板一样，视图模型可以使用返回上述任何格式的AMD模块进行注册。
- en: In the `cp4-component-module` branch, you can see an example of this. The component
    registration has been moved to the `main.js` file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cp4-component-module`分支中，您可以看到一个示例。组件注册已移动到`main.js`文件。
- en: Registering AMD
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册AMD
- en: 'In addition to registering the template and the viewmodel as AMD modules individually,
    you can register the entire component with a require call:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单独将模板和视图模型注册为AMD模块外，您还可以通过require调用将整个组件注册：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The AMD module will return the entire component configuration:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: AMD模块将返回整个组件配置：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As the Knockout documentation points out, this method has several benefits:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如Knockout文档所指出的，这种方法有几个优点：
- en: The registration call is just a `require` path, which is easy to manage.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册调用只是一个`require`路径，易于管理。
- en: 'The component is composed of two parts: a JavaScript module and an HTML module.
    This provides both simple organization and clean separation.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件由两部分组成：一个JavaScript模块和一个HTML模块。这既提供了简单的组织，又实现了清晰的分离。
- en: The RequireJS optimizer, which is `r.js`, can use the text dependency on the
    HTML module to bundle the HTML code with the bundled output. This means your entire
    application, including the HTML templates, can be a single file in production
    (or a collection of bundles if you want to take advantage of lazy loading).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RequireJS优化器（`r.js`）可以使用HTML模块上的文本依赖来将HTML代码与捆绑输出捆绑在一起。这意味着你的整个应用程序，包括HTML模板，在生产中可以是一个单独的文件（或者如果你想利用懒加载，可以是一组捆绑包）。
- en: You can see an example of this in the `cp4-component-amd` branch. This is the
    recommended pattern for components and is the one that will be used for the rest
    of the examples in this chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cp4-component-amd`分支中看到这个例子。这是组件推荐的模式，也是本章其余示例将使用的一种模式。
- en: Observing changes in component parameters
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察组件参数的变化
- en: 'Component parameters will be passed via the `params` object to the component''s
    viewmodel in one of the following three ways:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 组件参数将通过以下三种方式之一通过`params`对象传递到组件的视图模型：
- en: 'No observable expression evaluation needs to occur, and the value is passed
    literally:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要发生任何观察表达式评估，值被直接传递：
- en: '[PRE30]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In all of these cases, the value is passed directly to the component on the
    `params` object. This means that changes to these values will change the property
    on the instantiating viewmodel, except for the first case (literal values). Observable
    values can be subscribed to normally.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有这些情况下，值都是直接传递到`params`对象上的组件。这意味着这些值的更改将改变实例化视图模型上的属性，除了第一种情况（字面值）。观察值可以被正常订阅。
- en: 'An observable expression needs to be evaluated, so it is wrapped in a computed
    observable:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要评估一个观察表达式，因此它被包装在一个计算观察值中：
- en: '[PRE31]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, `params.name` is not the original property. Calling `params.name()`
    will evaluate the computed wrapper. Trying to modify the value will fail, as the
    computed value is not writable. The value can be subscribed to normally.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，`params.name`不是原始属性。调用`params.name()`将评估计算包装器。尝试修改值将会失败，因为计算值是不可写的。值可以被正常订阅。
- en: 'An observable expression evaluates an observable instance, so it is wrapped
    in an observable that unwraps the result of the expression:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个观察表达式评估一个观察实例，因此它被包装在一个展开表达式结果的观察值中：
- en: '[PRE32]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, `firstName` and `lastName` are both observable properties.
    If calling `params.name()` returned the observable, you will need to call `params.name()()`
    to get the actual value, which is rather ugly. Instead, Knockout automatically
    unwraps the expression so that calling `params.name()` returns the actual value
    of either `firstNam`e or `lastName`.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，`firstName`和`lastName`都是观察属性。如果你调用`params.name()`返回的是观察值，你需要调用`params.name()()`来获取实际值，这看起来相当丑陋。相反，Knockout会自动展开表达式，使得调用`params.name()`返回`firstNam`e或`lastName`的实际值。
- en: If you need to access the actual observable instances to, for example, write
    a value to them, trying to write to `params.name` will fail, as it is a computed
    observable. To get the unwrapped value, you can use the `params.$raw` object,
    which provides the unwrapped values. In this case, you can update the name by
    calling `params.$raw.name('New')`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要访问实际的观察实例，例如写入它们的值，尝试写入`params.name`将会失败，因为它是一个计算观察值。为了获取未包装的值，你可以使用`params.$raw`对象，它提供了未包装的值。在这种情况下，你可以通过调用`params.$raw.name('New')`来更新名称。
- en: In general, this case should be avoided by removing the logic from the binding
    expression and placing it in a computed observable in the viewmodel.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，应该通过从绑定表达式中移除逻辑并将其放置在视图模型中的计算观察值中来避免这种情况。
- en: The component's life cycle
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件的生命周期
- en: When a component binding is applied, Knockout takes the following steps.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用组件绑定时，Knockout会执行以下步骤。
- en: The component loader asynchronously creates the viewmodel factory and template.
    This result is cached so that it is only performed once per component.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件加载器异步创建视图模型工厂和模板。这个结果被缓存，所以每个组件只执行一次。
- en: The template is cloned and injected into the container (either the custom element
    or the element with the component binding).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板被克隆并注入到容器中（无论是自定义元素还是具有组件绑定的元素）。
- en: If the component has a viewmodel, it is instantiated. This is done synchronously.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果组件有一个视图模型，它将被实例化。这是同步完成的。
- en: The component is bound to either the viewmodel or the `params` object.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件绑定到 viewmodel 或 `params` 对象。
- en: The component is left *active* until it is disposed.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件保持 *活动* 状态，直到它被销毁。
- en: The component is disposed. If the viewmodel has a `dispose` method, it is called,
    and then the template is removed from the DOM.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件被销毁。如果 viewmodel 有一个 `dispose` 方法，它将被调用，然后模板将从 DOM 中移除。
- en: The component's disposal
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件的销毁
- en: 'If the component is removed from the DOM by Knockout, either because of the
    name of the component binding or a control flow binding being changed (for example,
    `if` and `foreach`), the component will be disposed. If the component''s viewmodel
    has a `dispose` function, it will be called. Normal Knockout bindings in the components
    view will be automatically disposed, just as they would in a normal control flow
    situation. However, anything set up by the viewmodel needs to be manually cleaned
    up. Some examples of viewmodel cleanup include the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件因组件绑定名称或控制流绑定（例如，`if` 和 `foreach`）更改而被 Knockout 从 DOM 中移除，组件将被销毁。如果组件的 viewmodel
    有一个 `dispose` 函数，它将被调用。组件视图中的正常 Knockout 绑定将被自动销毁，就像在正常控制流情况下一样。然而，由 viewmodel
    设置的任何内容都需要手动清理。以下是一些 viewmodel 清理的示例：
- en: The `setInterval` callbacks can be removed with `clearInterval`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `clearInterval` 来移除 `setInterval` 回调。
- en: Computed observables can be removed by calling their `dispose` method. Pure
    computed observables don't need to be disposed. Computed observables that are
    only used by bindings or other viewmodel properties also do not need to be disposed,
    as garbage collection will catch them.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过调用它们的 `dispose` 方法来移除计算可观察对象。纯计算可观察对象不需要销毁。仅由绑定或其他 viewmodel 属性使用的计算可观察对象也不需要销毁，因为垃圾回收会捕获它们。
- en: Observable subscriptions can be disposed by calling their `dispose` method.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过调用它们的 `dispose` 方法来销毁可观察订阅。
- en: Event handlers can be created by components that are not part of a normal Knockout
    binding.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器可以由不属于正常 Knockout 绑定的组件创建。
- en: You can see a simple dispose handler in the `cp4-dispose` branch. It just logs
    to the console to demonstrate when it will fire; try editing a contact to make
    the control flow remove the list from the page.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `cp4-dispose` 分支中看到一个简单的销毁处理器。它只是将日志记录到控制台以演示它何时会触发；尝试编辑一个联系人以使控制流从页面上删除列表。
- en: Combining components with data bindings
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将组件与数据绑定结合使用
- en: 'There is only one restriction of `data-bind` attributes that are used on custom
    elements with the component binding: the binding handlers cannot use `controlsDescendantBindings`.
    This isn''t a new restriction; two bindings that control descendants cannot be
    on a single element, and since components control descendant bindings that cannot
    be combined with a binding handler that also controls descendants. It is worth
    remembering, though, as you might be inclined to place an `if` or `foreach` binding
    on a component; doing this will cause an error. Instead, wrap the component with
    an element or a containerless binding:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用组件绑定的自定义元素上使用的 `data-bind` 属性只有一个限制：绑定处理器不能使用 `controlsDescendantBindings`。这不是一个新的限制；控制后代的两个绑定不能在单个元素上，因为组件控制后代绑定，不能与也控制后代的绑定处理器结合。尽管如此，这仍然值得记住，因为你可能会倾向于在组件上放置一个
    `if` 或 `foreach` 绑定；这样做将导致错误。相反，用元素或无容器绑定包裹组件：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It's also worth noting that bindings such as `text` and `html` will replace
    the contents of the element they are on. When used with components, this will
    potentially result in the component being lost, so it's not a good idea.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，如 `text` 和 `html` 这样的绑定将替换它们所在元素的内容。当与组件一起使用时，这可能会导致组件丢失，因此这不是一个好主意。
- en: '**Custom component loaders**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义组件加载器**'
- en: So far, we have covered the behavior of the default component loader. It is
    quite flexible, and for many developers, it will be quite sufficient for most
    use cases. However, it is possible to implement the custom component-loading functionality.
    In fact, you can have multiple component loaders active simultaneously, each providing
    different capabilities.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了默认组件加载器的行为。它非常灵活，对于许多开发者来说，它将足够满足大多数用例。然而，可以实现自定义组件加载功能。实际上，你可以同时激活多个组件加载器，每个加载器提供不同的功能。
- en: This section will deal with creating custom component loaders. If you are satisfied
    with the functionality of the default loader, you might want to skip this section
    and continue to single page application routing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将处理创建自定义组件加载器。如果你对默认加载器的功能感到满意，你可能想跳过这一节，继续到单页应用程序路由。
- en: 'First, let''s cover how the component-loading system works. Component loading
    is only done once per component. Knockout caches the loaded components. This cache
    provides the following two public functions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下组件加载系统是如何工作的。组件加载只对每个组件执行一次。Knockout 缓存已加载的组件。此缓存提供了以下两个公共函数：
- en: '`ko.components.get(name, callback)`: This function loops through all the loaders
    until one of them returns a component. This component is cached, and then the
    callback is invoked with it.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.components.get(name, callback)`: 此函数遍历所有加载器，直到其中一个返回一个组件。此组件被缓存，然后使用它调用回调。'
- en: '`ko.components.clearCachedDefinition(name)`: This function removes the component
    from the registry.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.components.clearCachedDefinition(name)`: 此函数从注册表中删除组件。'
- en: 'Knockout maintains an array of loaders on `ko.components.loaders`. By default,
    this array only contains a single loader, which also lives on `ko.components.defaultLoader`.
    When a component binding requests a component, or you call `ko.components.get`,
    Knockout loops through the loaders, calling `getConfig` on each component until
    it gets a non-null object. This configuration is then passed to each loader until
    a valid component object is returned. The loaded component is then cached. A valid
    component object has the following properties:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 在 `ko.components.loaders` 上维护一个加载器数组。默认情况下，此数组只包含一个加载器，它也位于 `ko.components.defaultLoader`
    上。当组件绑定请求组件或你调用 `ko.components.get` 时，Knockout 会遍历加载器，对每个组件调用 `getConfig`，直到它得到一个非空对象。然后将此配置传递给每个加载器，直到返回一个有效的组件对象。加载的组件随后被缓存。一个有效的组件对象具有以下属性：
- en: '`template`: This is an array of DOM nodes'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`: 这是一个 DOM 节点数组'
- en: '`createViewModel(params, componentInfo)`: This is an optional factory method
    to build components'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createViewModel(params, componentInfo)`: 这是一个可选的工厂方法，用于构建组件'
- en: Implementing a component loader
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现组件加载器
- en: 'All of the methods are optional on a component loader, as Knockout will run
    through each method on each loader until it gets a valid response before repeating
    it on the next method. All component loader functions are asynchronous by supplying
    a callback. Remember, the result will be cached unless manually cleared with `ko.components.clearCachedDefinition(componentName)`.
    The following are the methods used to implement a component loader:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法在组件加载器上都是可选的，因为 Knockout 会遍历每个加载器上的每个方法，直到它得到一个有效响应，然后再在下一个方法上重复执行。所有组件加载器函数都是通过提供回调来异步执行的。记住，结果将被缓存，除非手动使用
    `ko.components.clearCachedDefinition(componentName)` 清除。以下是用以实现组件加载器的常用方法：
- en: '`getConfig(name, callback)`: This returns a component configuration object.
    A configuration object is anything that any loader''s `loadComponent` function
    can understand.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getConfig(name, callback)`: 这返回一个组件配置对象。配置对象是任何加载器的 `loadComponent` 函数可以理解的内容。'
- en: '`loadComponent(name, componentConfig, callback)`: This supplies a component
    object of the `{ template: domNodeArray, createViewModel(params, componentInfo)
    }` type.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadComponent(name, componentConfig, callback)`: 这提供了类型为 `{ template: domNodeArray,
    createViewModel(params, componentInfo) }` 的组件对象。'
- en: '`loadTemplate(name, templateConfig, callback)`: This supplies an array of DOM
    nodes to be used as the template.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadTemplate(name, templateConfig, callback)`: 这提供了用作模板的 DOM 节点数组。'
- en: '`loadViewModel(name, viewModelConfig, callback)`: This supplies a function
    to be used as the `createViewModel(params, componentInfo)` factory.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadViewModel(name, viewModelConfig, callback)`: 这提供了用作 `createViewModel(params,
    componentInfo)` 工厂函数的功能。'
- en: To implement a method, just include it in your loader. To have your loader skip
    a method that it has implemented, call `callback(null)`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个方法，只需将其包含在你的加载器中。若要使你的加载器跳过它已实现的方法，请调用 `callback(null)`。
- en: The last two methods are not directly called by the Knockout component system
    but by the default loader's `loadComponent` method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法不是由 Knockout 组件系统直接调用，而是由默认加载器的 `loadComponent` 方法调用。
- en: The default loader
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认加载器
- en: 'To understand how the methods on a custom loader can be made optional, you
    must understand how the default loader works. The default loader has an internal
    registry for component configurations—not to be confused with the cache for components.
    The default loader adds the following methods to the `ko.components` object in
    order to work with the component configuration registry:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使自定义加载器上的方法成为可选的，你必须了解默认加载器的工作方式。默认加载器有一个内部注册表用于组件配置——不要与组件缓存混淆。默认加载器将以下方法添加到`ko.components`对象中，以便与组件配置注册表一起工作：
- en: '`ko.components.register(name, configuration)`: This is covered in the previous
    section in detail'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.components.register(name, configuration)`: 这在前一节中已详细说明'
- en: '`ko.components.isRegistered(name)`: This returns `true` if the component configuration
    is in the registry; otherwise, it returns `false`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.components.isRegistered(name)`: 如果组件配置在注册表中，则返回`true`；否则，返回`false`'
- en: '`ko.unregister(name)`: This removes the named configuration if it exists'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.unregister(name)`: 如果存在，则移除命名配置'
- en: When Knockout tries to load a component for the first time, it calls `getConfig`
    on each loader in `ko.components.loaders` until one returns a non-null object.
    Then, it passes that configuration object to `loadComponent` on each loader until
    one returns a non-null component object. If a loader other than the default loader
    returns a component from `loadComponent`, the chain ends there.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当Knockout首次尝试加载一个组件时，它会遍历`ko.components.loaders`中的每个加载器，并对每个加载器调用`getConfig`，直到其中一个返回非空对象。然后，它将配置对象传递给每个加载器的`loadComponent`，直到其中一个返回非空组件对象。如果除了默认加载器之外的加载器从`loadComponent`返回组件，则链在此处结束。
- en: However, the default loader's `loadComponent` method calls `loadTemplate` and
    `loadViewModel` on each loader (including itself) until it gets both a template
    and a viewmodel. These calls are independent; the default loader will take the
    first template it gets and the first viewmodel it gets even if they are from different
    loaders. If your custom loader has a higher priority than the default loader,
    or if the default loader can't understand your configuration, your custom loader
    will have a chance to supply its own template and/or viewmodel by implementing
    `loadTemplate` or `loadViewModel`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，默认加载器的`loadComponent`方法会在每个加载器（包括自身）上调用`loadTemplate`和`loadViewModel`，直到它获得模板和viewmodel。这些调用是独立的；默认加载器将取它得到的第一个模板和第一个viewmodel，即使它们来自不同的加载器。如果你的自定义加载器比默认加载器具有更高的优先级，或者默认加载器无法理解你的配置，你的自定义加载器将有机会通过实现`loadTemplate`或`loadViewModel`来提供自己的模板和/或viewmodel。
- en: Registering a custom loader
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册自定义加载器
- en: 'Unlike `ko.bindingHandlers` and `ko.extenders`, which are both objects, `ko.components.loaders`
    is an array. Once you have created your custom loader, you can add it to the `loaders`
    array. The order of the `loaders` array determines the priority; Knockout always
    loops through the loaders from the first to the last:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ko.bindingHandlers`和`ko.extenders`都是对象不同，`ko.components.loaders`是一个数组。一旦你创建了自定义加载器，你可以将其添加到`loaders`数组中。`loaders`数组的顺序决定了优先级；Knockout总是从第一个到最后一个遍历加载器：
- en: For a lower priority custom loader, use `ko.components.loaders.push(loader)`
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有较低优先级的自定义加载器，使用`ko.components.loaders.push(loader)`
- en: For a higher priority custom loader, use `ko.components.loaders.unshift(loader)`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有更高优先级的自定义加载器，使用`ko.components.loaders.unshift(loader)`
- en: For a fine-grained control custom loader, use `ko.components.loaders.splice(priority,
    0, loader)`, where priority is the 0-index rank of the new loader
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于细粒度控制的自定义加载器，使用`ko.components.loaders.splice(priority, 0, loader)`，其中priority是新加载器的0索引排名
- en: If you remove the default loader from `ko.component.loaders`, then `loadTemplate`
    and `loadViewModel` will no longer be called (unless they are called by another
    custom loader). As it is possible to simply add a custom loader with a higher
    priority, there is little value in removing the default loader.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从`ko.component.loaders`中移除默认加载器，那么`loadTemplate`和`loadViewModel`将不再被调用（除非它们被另一个自定义加载器调用）。由于可以简单地添加一个具有更高优先级的自定义加载器，因此移除默认加载器的价值很小。
- en: Registering custom elements
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册自定义元素
- en: 'Custom elements work in Knockout by wrapping the component binding. There are
    two options that can be used to get Knockout to treat a custom element as a component:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素通过包装组件绑定在Knockout中工作。有两种选项可以用来让Knockout将自定义元素视为组件：
- en: Call `ko.components.register('component-name', { /* config */ }`.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`ko.components.register('component-name', { /* config */ })`.
- en: Override `ko.components.getComponentNameForNode(node)` so that it returns the
    name of a component. Components do not need to be registered as long as a loader
    that can load the name returned by this method exists. The default loader will
    only load components registered with `ko.components.register`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖`ko.components.getComponentNameForNode(node)`，使其返回组件的名称。只要存在可以加载此方法返回的名称的加载器，组件就不需要注册。默认加载器只会加载使用`ko.components.register`注册的组件。
- en: Loading components with custom configurations
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义配置加载组件
- en: 'Alright, it''s time to look at an example. This one is taken from the Knockout
    component''s documentation. Let''s say you are using our own asynchronous loading
    library for the HTML, and you want your custom loader to use it. This could be
    true for a JavaScript loader, which the documentation provides as an example,
    but it would be similar enough to be redundant here. It will use its own configuration
    property name in order to avoid confusion with the default loader:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候看看一个例子了。这个例子是从Knockout组件的文档中取出的。假设您正在使用我们自己的异步加载库来加载HTML，并且希望您的自定义加载器使用它。这可能是对JavaScript加载器的例子，文档中提供了这个例子，但在这里它足够相似，以至于可以省略。它将使用自己的配置属性名称，以避免与默认加载器混淆：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As the default loader will pass this configuration to the `loadTemplate` method
    of each loader, we can just implement that one method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认加载器将此配置传递给每个加载器的`loadTemplate`方法，我们只需实现该方法即可：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This loader will use jQuery to retrieve and parse the template if it has the
    `fromUrl` property; otherwise, it will do nothing. The only thing that''s left
    is to add the loader to Knockout:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此加载器具有`fromUrl`属性，它将使用jQuery检索和解析模板；否则，它将不执行任何操作。剩下要做的就是将加载器添加到Knockout中：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can see this custom loader in the `cp4-loader` branch; it is in the `main.js`
    file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`cp4-loader`分支中看到这个自定义加载器；它在`main.js`文件中。
- en: Knockout's default component loader is already flexible, but the ability to
    provide your own custom loader for both configuration and instantiation gives
    the Knockout component system the ability to work with whichever format you want
    to create.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout的默认组件加载器已经足够灵活，但能够提供自己的自定义加载器，用于配置和实例化，使Knockout组件系统能够与您想要创建的任何格式一起工作。
- en: Single Page Application (SPA) routing
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序（SPA）路由
- en: A big part of the appeal of Knockout (or any MV* framework) is that its template
    engine allows us to rerender parts of the page without the need to talk to the
    server. Being able to make incremental page updates on the client side means less
    latency, giving the application a much snappier feel. SPAs take this concept to
    the next level by letting the JavaScript client control navigation between pages.
    When the browser navigates, it has to rerender the whole page, which means reloading
    the JavaScript, HTML, CSS, and everything. When JavaScript *navigates*, it just
    has to change part of the HTML, which ends up being much faster in most cases.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout（或任何MV*框架）的吸引力很大一部分在于其模板引擎允许我们在不与服务器通信的情况下重新渲染页面的一部分。能够在客户端进行增量页面更新意味着更低的延迟，使应用程序感觉更加敏捷。SPA通过让JavaScript客户端控制页面间的导航，将这一概念提升到了新的水平。当浏览器导航时，它必须重新渲染整个页面，这意味着重新加载JavaScript、HTML、CSS以及一切。当JavaScript**导航**时，它只需要更改HTML的一部分，这在大多数情况下会更快。
- en: Knockout can provide this virtual page-changing functionality relatively easily,
    but an important component of SPAs is that page changes still update the URL.
    This helps the user check whether a change has occurred, but more importantly,
    it means that if the user refreshes the page or shares the link, the application
    will go to the right page. Without the URL update, the user will always end up
    on the home screen. This feature is commonly known as **routing**. Knockout does
    not provide this mechanism.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout可以相对容易地提供这种虚拟页面更改功能，但SPA的一个重要组成部分是页面更改仍然更新URL。这有助于用户检查是否发生了更改，但更重要的是，这意味着如果用户刷新页面或分享链接，应用程序将转到正确的页面。如果没有URL更新，用户将始终停留在主页。这个功能通常被称为**路由**。Knockout不提供此机制。
- en: To explore how Knockout fits into an SPA scenario, we are going to use SammyJS
    ([http://sammyjs.org/](http://sammyjs.org/)). SammyJS is a popular library used
    for routing; Knockout even uses it on its tutorial site. There are many other
    options, of course, but the concept should be very similar regardless of which
    library you use.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索Knockout如何适应SPA场景，我们将使用SammyJS ([http://sammyjs.org/](http://sammyjs.org/))。SammyJS是一个流行的用于路由的库；Knockout甚至在其教程网站上使用了它。当然，还有许多其他选项，但无论您使用哪个库，概念都应该非常相似。
- en: An overview of SammyJS
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SammyJS 概述
- en: 'SammyJS''s default routing uses hash-change navigation, which uses the URL
    hash to store the current state. As the hash is not sent to the server by the
    browser, the server always sees the URL as a request for the home page. Once the
    page loads, Sammy will inspect the hash and locate the matching route, if one
    exists. If it finds a route, it runs the callback for that route. The callback
    is responsible for performing whatever application logic is necessary for navigation.
    The following code demonstrates this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: SammyJS 的默认路由使用哈希更改导航，它使用 URL 哈希来存储当前状态。由于浏览器不会将哈希发送到服务器，服务器始终将 URL 视为对主页的请求。一旦页面加载，Sammy
    将检查哈希并定位到匹配的路由（如果存在）。如果找到路由，它将运行该路由的回调。回调负责执行导航所需的任何应用程序逻辑。以下代码演示了这一点：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a typical Sammy application configuration. The `Sammy` object is a function
    that takes an element's ID, which it will scope the handler to, and an initialization
    handler and returns the application object. Inside the initialization handler,
    this has methods for each HTTP verb that registers routes. The preceding sample
    registers a route for `#/` (a standard *home* route) and a route for `#/contacts/:id`.
    The `:id` part of the route indicates a parameter that will match any contents
    and provide the value on the `params` object inside the route's callback.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的 Sammy 应用程序配置。`Sammy` 对象是一个函数，它接受一个元素的 ID，它将作用域处理程序，并返回应用程序对象。在初始化处理程序内部，它为每个
    HTTP 动词提供了注册路由的方法。前面的示例注册了 `#/`（一个标准的 *主页* 路由）和 `#/contacts/:id` 路由。路由中的 `:id`
    部分表示一个将匹配任何内容并提供路由回调中 `params` 对象内值的参数。
- en: The application object that is returned from `Sammy()` will not start until
    `run()` is called, which should wait for the DOM to be ready. The `run()` method
    takes a default route, which will be loaded if no hash is present (such as when
    navigating to the bare domain URL).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Sammy()` 返回的应用程序对象将在调用 `run()` 之前不会启动，`run()` 方法应该等待 DOM 准备就绪。`run()` 方法接受一个默认路由，如果没有哈希（例如，当导航到裸域名
    URL 时），将加载该路由。
- en: Controlling the navigation
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制导航
- en: 'SammyJS monitors the `window.location.hash` property for any changes and runs
    the matching route handler. This can happen when a user clicks on an a tag with
    an `href` attribute containing a hash or by setting `window.location.hash` from
    JavaScript. Using the window object inside viewmodels is generally discouraged,
    as it is difficult to mock in unit tests. It would also be nice to keep the navigation
    logic centralized, just in case it needs to be changed later. To do this, we will
    encapsulate the navigation into a router module. For now, it only needs a single
    method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: SammyJS 监控 `window.location.hash` 属性的任何变化，并运行匹配的路由处理程序。这可能在用户点击带有包含哈希的 `href`
    属性的 a 标签时发生，或者通过 JavaScript 设置 `window.location.hash`。在视图中使用 window 对象通常是不推荐的，因为它在单元测试中很难模拟。如果以后需要更改，也最好将导航逻辑集中化。为此，我们将导航封装到一个路由模块中。目前，它只需要一个方法：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once injected with RequireJS, viewmodels can be navigated by calling `router.navigate`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注入了 RequireJS，可以通过调用 `router.navigate` 来导航视图模型。
- en: Creating page components
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建页面组件
- en: 'There are a lot of different ways to organize Knockout viewmodels in SPAs and
    web apps in general. As we just learned how to create components, we are going
    to look at a method used to structure each page as a component. This gives us
    a few solid advantages:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页应用（SPA）和通用网页应用中组织 Knockout 视图模型有许多不同的方法。正如我们刚刚学习了如何创建组件，我们将探讨一种将每个页面结构化为组件的方法。这给我们带来了一些明显的优势：
- en: The pages will be decoupled from each other
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面将相互解耦
- en: Each page will have its own HTML and JavaScript file, which feels natural
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个页面都将有自己的 HTML 和 JavaScript 文件，这感觉是自然的
- en: A single component binding on the shell can hold the *body* of the page while
    maintaining a static layout for the navigation bar
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在外壳上绑定单个组件可以保持页面的 *主体*，同时为导航栏保持静态布局
- en: At some point, we will need to introduce a folder structure that will keep these
    files organized, so we might as well start now.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们需要引入一个文件夹结构来组织这些文件，所以我们不妨现在就开始。
- en: '![Creating page components](img/00008.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![创建页面组件](img/00008.jpeg)'
- en: The home page (which was just a greeting) has been removed, but the placeholder
    settings page is still there so that we have at least two links to test navigation
    with. The router and mock data service have been moved into the `core` folder
    (a name I prefer because it's shorter than `common`). The rest of the code, which
    consists of the contact model and the two pages, has been moved into the `contacts`
    folder. The `main.js` starting file hasn't moved.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 主页（它只是一个问候）已经被移除，但占位符设置页面仍然存在，这样我们至少有两个链接来测试导航。路由器和模拟数据服务已经被移动到`core`文件夹（我更喜欢这个名字，因为它比`common`更短）。其余的代码，包括联系模型和两个页面，已经被移动到`contacts`文件夹。`main.js`起始文件没有移动。
- en: You can, of course, group files whichever way you want; nothing we have covered
    so far will require any specific file structure.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以以任何你想要的方式分组文件；到目前为止我们所涵盖的内容都不会要求任何特定的文件结构。
- en: The edit page
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑页面
- en: 'Previously, both pages were managed by a single viewmodel that switched between
    them using a null *editing* contact. However, it was clear that this combined
    viewmodel was serving multiple roles. Splitting the editing code should reduce
    some confusion:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，两个页面都是由一个视图模型管理的，该视图模型通过使用一个空的*编辑*联系人在这两个页面之间切换。然而，很明显，这个组合视图模型承担了多个角色。将编辑代码拆分应该会减少一些混淆：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are only three real changes here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有三个真正的变化：
- en: First, instead of clearing the `entryContact` object to indicate that editing
    is finished, the viewmodel calls `router.navigate('/')`. As we don't have a home
    page anymore, the list page will be used as the default page, which will be tied
    to the `/` route.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，而不是清除`entryContact`对象来表示编辑已完成，视图模型调用`router.navigate('/')`。由于我们不再有主页，列表页面将用作默认页面，它将绑定到`/`路由。
- en: Secondly, as editing will occur based on navigation instead of the `entryContact`
    object being set directly, the viewmodel uses the `params` component to look for
    an ID. If an ID isn't present, it is assumed that we are creating a new contact;
    if an ID is present, the contact is loaded from the data service.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，由于编辑将基于导航而不是直接设置`entryContact`对象，视图模型使用`params`组件来查找ID。如果没有ID，则假定我们正在创建一个新的联系人；如果存在ID，则从数据服务中加载联系人。
- en: Finally, a `dispose` method has been added, which will clear the `entryContact`
    object. This isn't actually necessary, but it demonstrates how the clean up will
    be done.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，添加了一个`dispose`方法，它将清除`entryContact`对象。这实际上并不是必要的，但它展示了清理将如何进行。
- en: The HTML code hasn't really changed, except that it will be in its own file
    now.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: HTML代码实际上并没有真正改变，只是现在它将位于自己的文件中。
- en: The list page
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表页面
- en: 'The list page will be the new home page. Like the edit page, it will need to
    use the router to navigate to the edit page instead of using the `entryContact`
    object. The list page doesn''t need any parameters:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表页面将成为新的主页。像编辑页面一样，它需要使用路由器导航到编辑页面，而不是使用`entryContact`对象。列表页面不需要任何参数：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here too, the HTML code hasn't changed much, except that the `contact-list`
    component has been removed, so its view has been re-added to the list page.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，HTML代码也没有发生太多变化，只是`contact-list`组件已经被移除，因此它的视图被重新添加到列表页面。
- en: Coordinating pages
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协调页面
- en: 'So far, the example server has been responsible for putting each page into
    our shell/layout HTML by performing a string replace. To get the experience of
    a real SPA, we are going to change the server to return an index file without
    performing any parsing or rendering on it:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，示例服务器负责通过执行字符串替换将每个页面放入我们的shell/layout HTML中。为了获得真实SPA的体验，我们将更改服务器以返回一个索引文件，而不会对其进行任何解析或渲染：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `appHost` element in the preceding code contains a containerless component
    binding that uses an observable `name` and `params` value. It's wrapped in an
    `if` binding that ensures that the component binding isn't active until a page
    has been selected. All the root viewmodel has to do is supply the `name` and `params`
    properties.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的`appHost`元素包含一个无容器组件绑定，该绑定使用一个可观察的`name`和`params`值。它被一个`if`绑定包裹，确保组件绑定在页面被选中之前不活跃。根视图模型只需要提供`name`和`params`属性。
- en: 'For this, our `main.js` will contain a simple viewmodel that contains each
    property. The SammyJS route handlers will set this viewmodel when the routes are
    activated. The `main.js` file will also be responsible for registering the page
    components with Knockout. It''s long, so we are going to break it up into chunks:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的 `main.js` 将包含一个简单的视图模型，其中包含每个属性。当路由被激活时，SammyJS 路由处理程序将设置此视图模型。`main.js`
    文件还将负责将页面组件注册到 Knockout。它很长，所以我们将其分成几个部分：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: SammyJS has been added as a dependency and injected in. The RequireJS configuration
    isn't shown, but it doesn't require a shim. SammyJS plays nicely as an AMD. The
    `pageVm` object is created with two observable properties and a helper method
    for setting them. The order is important because component viewmodels are instantiated
    synchronously, and the data bound to the `params` object needs to already be in
    place when the component name changes; otherwise, the component will initialize
    before the `params` objects are set.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: SammyJS 已被添加为依赖项并注入。RequireJS 的配置没有显示，但它不需要一个垫片。SammyJS 作为 AMD 运行得很好。`pageVm`
    对象通过两个可观察属性和一个用于设置它们的辅助方法创建。顺序很重要，因为组件视图模型是同步实例化的，并且当组件名称更改时，绑定到 `params` 对象的数据需要已经就绪；否则，组件将在
    `params` 对象设置之前初始化。
- en: After SammyJS has been set up, the document-ready handler starts it using a
    default route and then applies bindings with the `pageVm` object.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SammyJS 设置完成后，文档就绪处理程序使用默认路由启动它，然后使用 `pageVm` 对象应用绑定。
- en: 'One way to perform the SammyJS configuration would be to write out each component
    register and route handler, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一种执行 SammyJS 配置的方法是写出每个组件注册和路由处理程序，如下所示：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Personally, I think this ends up being a bit messy. It also duplicates the
    component name in `register` and `setRoute`. SammyJS also doesn''t allow you to
    bind multiple routes to the same handler in a single call; you have to write both
    of them out. This is especially annoying for the home page, because SammyJS treats
    an empty route and the `#/` route as different routes, even though they both conventionally
    mean *home*. To solve these, we can combine the component and route definitions
    into a page object, and then loop over them:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我认为这最终会变得有点混乱。它还在 `register` 和 `setRoute` 中重复了组件名称。SammyJS 还不允许你在单个调用中将多个路由绑定到同一个处理程序；你必须将它们都写出来。这对于主页来说尤其令人烦恼，因为
    SammyJS 将空路由和 `#/` 路由视为不同的路由，尽管它们都传统上意味着 *主页*。为了解决这些问题，我们可以将组件和路由定义组合成一个页面对象，然后遍历它们：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Much better. Now, it's easy to see how the routes and components are related,
    and defining multiple routes for a single component is simple. It also removes
    the duplicated component name.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 更好了。现在，很容易看出路由和组件之间的关系，并且为单个组件定义多个路由很简单。它还消除了重复的组件名称。
- en: The `instanceof` check lets us use an array or a string for the `page.route`
    property by always making it an array. The `params` section will include any parameters
    captured by the route handler and will pass them as the data used by the component
    binding for the `params` object.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 检查使我们能够通过始终将其作为数组来使用 `page.route` 属性。`params` 部分将包括由路由处理程序捕获的任何参数，并将它们作为组件绑定用于
    `params` 对象的数据传递。'
- en: All the code we just covered can be seen in the `cp4-spa` branch. Be sure to
    use each page on the app, and notice the URL change. If you go to a page, such
    as a specific contact, and refresh the browser, SammyJS will make sure that the
    correct page is loaded instead of always going to the home page. This gives the
    application a very natural feel. You should also notice that moving between pages
    happens with little or no delay (depending on your CPU). For comparison, try to
    view changes between the `/contacts` and `/settings` pages in the `cp4-contacts`
    branch. The SPA navigation is much faster.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的所有代码都可以在 `cp4-spa` 分支中看到。确保使用应用中的每个页面，并注意 URL 的变化。如果你访问一个页面，例如特定的联系人页面，并刷新浏览器，SammyJS
    将确保加载正确的页面而不是总是跳转到主页。这给应用程序带来了非常自然的感觉。你也应该注意到，在页面之间切换几乎没有延迟（取决于你的 CPU）。为了比较，尝试在
    `cp4-contacts` 分支中查看 `/contacts` 和 `/settings` 页面之间的变化。SPA 导航要快得多。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, you should have a good idea or two about how to structure a Knockout
    web application, specifically, a single page application. The Knockout components
    feature gives you a powerful tool that will help you create reusable, behavior-driven
    DOM elements, and writing custom loaders allows you to fully control how components
    are used. The RequireJS AMD patterns make application organization easy by splitting
    up JavaScript and HTML into independent modules. Because these modules use dependency
    injection, creating mocks for unit testing is also possible. Finally, you saw
    how SammyJS can create fast client-side JavaScript navigation with pages controlled
    by components.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对如何构建 Knockout 网络应用程序有一个或两个好的想法，特别是关于如何构建单页应用程序。Knockout 组件功能为你提供了一个强大的工具，帮助你创建可重用、行为驱动的
    DOM 元素，编写自定义加载器允许你完全控制组件的使用方式。RequireJS AMD 模式通过将 JavaScript 和 HTML 分割成独立的模块，使得应用程序的组织变得简单。因为这些模块使用依赖注入，因此创建单元测试的模拟也是可能的。最后，你看到了
    SammyJS 如何通过组件控制页面来创建快速的客户端 JavaScript 导航。
- en: In the next chapter, we will look at the Durandal framework, which will make
    the single page application development even easier.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Durandal 框架，这将使单页应用程序的开发变得更加简单。
