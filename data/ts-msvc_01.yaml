- en: Debunking Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘微服务
- en: '"If I had asked people what they wanted, they would have said faster horses."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “如果我问人们他们想要什么，他们会说更快的马。”
- en: – Henry Ford
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 亨利·福特'
- en: Whether you are a tech lead, developer, or a tech savant eager to adapt to new
    modern web standards, the preceding line represents your current life situation
    in a nutshell. Today's mantra for the successful business, fail quickly, fix and
    rise soon, quicker delivery, frequent changes, adaption to changing technologies,
    and fault-tolerant systems are some of the general daily requirements. For the
    very same reason, during recent times, the technology world has seen a quick change
    in architectural designs that have led industry leaders (such as Netflix, Twitter,
    Amazon, and so on) to move away from monolithic applications and adopt microservices.
    In this chapter, we will debunk microservices and study their anatomy, and learn
    their concepts, characteristics, and advantages. We will learn about microservice
    design aspects and see some microservice design patterns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是技术负责人、开发人员还是渴望适应新的现代网络标准的技术专家，上述内容都概括了您当前的生活状况。今天成功业务的口号是，快速失败，快速修复和迅速崛起，更快的交付，频繁的变化，适应不断变化的技术和容错系统是一些日常要求。出于同样的原因，最近技术世界已经看到了架构设计的快速变化，这导致行业领袖（如Netflix、Twitter、亚马逊等）放弃了单片应用程序，转向了微服务。在本章中，我们将揭秘微服务，研究它们的解剖学，并了解它们的概念、特点和优势。我们将了解微服务设计方面，并了解一些微服务设计模式。
- en: 'In this chapter, we will talk about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Debunking microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭秘微服务
- en: Key considerations for microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的关键考虑因素
- en: Microservice FAQs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务常见问题解答
- en: How microservices satisfy the twelve-factors of the application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务如何满足应用程序的十二因素
- en: Microservices in the current world
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前世界的微服务
- en: Microservice design aspects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计方面
- en: Microservice design patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计模式
- en: Debunking microservices
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘微服务
- en: The core idea behind microservice development is if the application is broken
    down into smaller independent units, with each group performing its functionality
    well, then it becomes straightforward to build and maintain an application. The
    overall application then just becomes the sum of individual units. Let's begin
    by debunking microservices.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发的核心思想是，如果应用程序被分解为更小的独立单元，每个组都能很好地执行其功能，那么构建和维护应用程序就变得简单。整体应用程序只是各个单元的总和。让我们开始揭秘微服务。
- en: Rise of microservices
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的崛起
- en: Today's world is evolving exponentially, and it demands an architecture that
    can satisfy the following problems that made us rethink traditional architecture
    patterns and gave rise to microservices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的世界正在呈指数级增长，并且需要一种能够满足以下问题的架构，这些问题使我们重新思考传统的架构模式，并催生了微服务。
- en: Wide selection of languages as per demand
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据需求选择多种语言
- en: There is a great need for technological independence. At any point in time,
    there is a shift in languages and adoption rates change accordingly. Companies
    such as Walmart have left the Java stack and moved towards the MEAN stack. Today's
    modern applications are not just limited to the web interface and extends its
    need for mobile and smartwatch application too. So, coding everything in one language
    is not at all a feasible option. We need an architecture or ecosystem where multiple
    languages can coexist and communicate with each other. For example, we may have
    REST APIs exposed in Go, Node.js, and Spring Boot—a gateway as the single point
    of contact for the frontend.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 技术独立性的需求非常迫切。在任何时候，语言和采用率都会发生变化。像沃尔玛这样的公司已经放弃了Java堆栈，转向了MEAN堆栈。今天的现代应用程序不仅仅局限于网络界面，还需要移动和智能手表应用程序。因此，用一种语言编写所有内容根本不是可行的选择。我们需要一种架构或生态系统，可以让多种语言共存并相互通信。例如，我们可以在Go、Node.js和Spring
    Boot中暴露REST API，一个网关作为前端的单一联系点。
- en: Easy handling of ownership
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易于处理所有权
- en: Today's applications not only include a single web interface, but go beyond
    into mobiles, smart watches, and **virtual reality** (**VR**). A separation of
    logic into individual modules helps to control everything as each team owns a
    single unit. Also, multiple things should be able to run in parallel, hence achieving
    faster delivery. Dependencies between teams should be reduced to zero. Hunting
    down the right person to get the issue fixed and get the system up and running
    demands a microservice architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的应用程序不仅包括单一的网络界面，还涉及到移动设备、智能手表和虚拟现实（VR）。将逻辑分离成单独的模块有助于控制每个团队拥有一个单独的单元。此外，多个事物应该能够并行运行，从而实现更快的交付。团队之间的依赖关系应该降低到零。追踪正确的人来解决问题并使系统重新运行需要微服务架构。
- en: Frequent deployments
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频繁的部署
- en: Applications need to constantly evolve to keep up with an evolving world. When
    Gmail started, it was just a simple mailing utility and now it has evolved into
    much more than that. These frequent changes demand frequent deployments in such
    a way that the end user doesn't even know that a new version is being released.
    By dividing into smaller units, a team can thus handle frequent deployments with
    testing and get the feature into customers hands quickly. There should be graceful
    degradation, that is, fail fast and get it over with.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要不断发展，以适应不断发展的世界。当Gmail开始时，它只是一个简单的邮件工具，现在它已经发展成了更多。这些频繁的变化要求频繁的部署，以便最终用户甚至不知道新版本正在发布。通过分成更小的单元，团队可以处理频繁的部署和测试，并迅速将功能交付给客户。应该有优雅的退化，即快速失败并解决问题。
- en: Self-sustaining development units
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我维护的开发单元
- en: A tight dependency between different modules soon cascades to the entire application
    and it goes down. This requires smaller independent units in such a way that if
    one unit is not operational, then the entire application is not affected by it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不同模块之间的紧密依赖很快就会影响整个应用程序。这就需要更小的独立单元，以便如果一个单元不可操作，整个应用程序也不会受到影响。
- en: Now let's understand in depth about microservices, their characteristics, their
    advantages, and all the challenges while implementing a microservice architecture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解微服务，它们的特点，优势以及在实施微服务架构时所面临的所有挑战。
- en: What are microservices?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: There is no universal definition of microservices. Simply stating—*a microservice
    can be any operational block or unit, which handles its single responsibility
    very efficiently*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务没有通用的定义。简单地说——*微服务可以是任何操作块或单元，它可以非常有效地处理其单一责任*。
- en: '**Microservices** are modern styles to build autonomous, self-sustaining, loosely
    coupled business capabilities that sum up as an entire system. We will look into
    the principles and characteristics of microservices, the benefit that microservices
    provide, and the potential pitfalls to keep an eye out for.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**是构建自主、自我维持、松耦合的业务能力的现代风格，这些能力汇总成一个整个系统。我们将深入了解微服务的原则和特征，微服务提供的好处，以及需要注意的潜在风险。'
- en: Principles and characteristics
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则和特征
- en: There are a few principles and characteristics that define microservices. Any
    microservice pattern would be distinguished and explained further by these points.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些原则和特征定义了微服务。任何微服务模式都可以通过这些要点进一步区分和解释。
- en: No monolithic modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有单片模块
- en: A microservice is just another new project satisfying a single operational business requirement. A
    microservice is linked with business unit changes and thus it has to be loosely
    coupled. It should be that a microservice can continuously serve the changing
    business requirements irrespective of the other business units. For other services,
    it is just a matter of consumption, the mode of consumption should not change.
    Implementations can change in the background.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务只是满足单个操作业务需求的另一个新项目。微服务与业务单元的变化相关联，因此必须松耦合。微服务应该能够持续满足不断变化的业务需求，而不受其他业务单元的影响。对于其他服务来说，只是一种消费方式，消费方式不应改变。实现可以在后台更改。
- en: Dumb communication pipes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 愚蠢的通信管道
- en: Microservices promote basic, time-tested, asynchronous communication mechanisms
    among microservices. As per this principle, the business logic should stay inside
    the endpoint and not be amalgamated with the communication channel. The communication
    channel should be dumb and just communicate in the communication protocol decided.
    HTTP is a favorable communication protocol, but a more reactive approach—queues
    is prevalent these days. **Apache Kafka**, and **RabbitMQ** are some of the prevalent
    dumb communication pipes providers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务促进基本、经过时间考验的微服务之间的异步通信机制。根据这一原则，业务逻辑应保留在端点内，而不应与通信渠道混合在一起。通信渠道应该是愚蠢的，并且只在决定的通信协议中进行通信。HTTP是一种受欢迎的通信协议，但更具反应性的方法——队列如今更为普遍。**Apache
    Kafka**和**RabbitMQ**是一些普遍的愚蠢通信管道提供者。
- en: Decentralization or self-governance
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化或自我治理
- en: While working with microservices, there is often a change of failure. A contingency
    plan that eventually stops the failure from propagating to the entire system.
    Furthermore, each microservice may have its own data storage need. Decentralization
    manages just the need for that. For example, in our shopping module we can store
    our customer and his transactions-related information in SQL databases, but since
    the product data is highly unstructured, we store it in NoSQL-related databases.
    Every service should be able to take a decision on what to do in fail case scenarios.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用微服务时，经常会出现故障。一个应急计划最终可以阻止故障传播到整个系统。此外，每个微服务可能都有自己的数据存储需求。去中心化管理了这一需求。例如，在我们的购物模块中，我们可以将客户及其交易相关信息存储在SQL数据库中，但由于产品数据高度非结构化，我们将其存储在NoSQL相关数据库中。每个服务都应该能够在故障情况下做出决策。
- en: Service contracts and statelessness
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务合同和无状态性
- en: Microservices should be well defined through service contracts. A **service
    contract** basically gives information about how to consume the service and what
    all the parameters are that need to be passed to that service. **Swagger **and **AutoRest**
    are some of the widely adopted frameworks for creating service contracts. Another
    salient characteristic is that nothing is stored and no state is maintained by
    the microservice. If there is a need to persist something, then it will be persisted
    in a cache database or some datastore.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应通过服务合同进行明确定义。**服务合同**基本上提供了有关如何使用服务以及需要传递给该服务的所有参数的信息。**Swagger**和**AutoRest**是一些广泛采用的用于创建服务合同的框架。另一个显著的特征是微服务不存储任何东西，也不维护任何状态。如果需要持久化某些东西，那么它将被持久化在缓存数据库或某些数据存储中。
- en: Lightweight
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级
- en: Microservices, being lightweight, help to replicate a setup easily in any hosting
    environment. Containers are more preferred than hypervisors. Lightweight application
    containers help us to maintain a lower footprint, thus by binding a microservice
    to some context. Well-designed microservices should perform only one function
    and do that operation well enough. Containerized microservices are easily portable,
    thus enabling easy auto-scaling.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务作为轻量级，有助于在任何托管环境中轻松复制设置。容器比虚拟化更受青睐。轻量级应用容器帮助我们保持较低的占用空间，从而将微服务绑定到某个上下文。设计良好的微服务应该只执行一个功能，并且执行得足够好。容器化的微服务易于移植，从而实现轻松的自动扩展。
- en: Polyglot
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语种
- en: Everything is abstract and unknown behind the service API in microservice architecture.
    In the preceding example of shopping cart microservices, we can have our payment
    gateway entirely as a service deployed in the cloud (serverless architecture),
    while the rest of the services can be in Node.js. The internal implementations
    are completely hidden behind the microservices and the only concern to be taken
    care of is that the communication protocol should be the same throughout.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务API后面的一切都是抽象和未知的。在前面的购物车微服务示例中，我们可以将我们的支付网关完全作为云中部署的服务（无服务器架构），而其余服务可以使用Node.js。内部实现完全隐藏在微服务后面，唯一需要关注的是通信协议在整个过程中应该是相同的。
- en: Now, let's see what advantages microservice architecture has to offer us.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看微服务架构为我们提供了哪些优势。
- en: Good parts of microservices
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的优点
- en: Adopting microservices has several advantages and benefits. We will look at
    the benefits and higher business values we get while using microservices.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微服务有许多优势和好处。我们将看看在使用微服务时获得的好处和更高的商业价值。
- en: Self-dependent teams
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主团队
- en: Microservices architecture enables us to scale any operation independently,
    have availability on demand, and introduce new services very quickly without zero
    to very few configurations. Technological dependence is also greatly reduced.
    For example, in our shopping microservice architecture, the inventory and shopping
    module can be independently deployed and worked upon. The inventory service will
    just assume that the product will exist and work accordingly. The inventory service
    can be coded in any language as long as the communication protocol between inventory
    and product service is met.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构使我们能够独立扩展任何操作，按需提供可用性，并在零到非常少的配置下非常快速地引入新服务。技术依赖也大大减少。例如，在我们的购物微服务架构中，库存和购物模块可以独立部署和处理。库存服务只会假设产品存在并相应地工作。只要库存和产品服务之间的通信协议得到满足，库存服务可以用任何语言编码。
- en: Graceful degradation of services
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务的优雅降级
- en: Failure in any system is natural, graceful degradation is a key advantage of
    microservices. Failures are not cascaded to the entire system. Microservices are
    designed in such a way that microservices adhere to agreed service level agreements;
    if the **service level agreements** (**SLAs**) are not met, then the service is
    dropped. For example, coming back to our shopping microservice example, if our
    payment gateway is down, then further requests to that service are stopped until
    the service is up and running.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 任何系统的故障都是自然的，优雅降级是微服务的一个关键优势。故障不会级联到整个系统。微服务设计成遵守约定的服务水平协议；如果服务水平协议未能达到，则服务将被丢弃。例如，回到我们的购物微服务示例，如果我们的支付网关宕机，那么对该服务的进一步请求将停止，直到服务恢复运行。
- en: Supports polyglot architecture and DevOps
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持多语言体系结构和DevOps
- en: Microservices make use of resources as per need or effectively create polyglot
    architecture. For example, in shopping microservices, you can store products and
    customer data in a relational database, but any audit or log-related data you
    can store in **Elasticsearch** or **MongoDB**. As each microservice operates in
    its bounded context, this can enable experimentation and innovation. The cost
    of change impact will be very less. Microservices enables **DevOps** to full level.
    Many DevOps tools and techniques are needed for a successful microservice architecture.
    Small microservices are easy to automate, easy to test, contaminate the failure
    if needed, and are easy to scale. **Docker** is one of the major tools for containerizing
    microservices.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务根据需要利用资源或有效地创建多语言体系结构。例如，在购物微服务中，您可以将产品和客户数据存储在关系数据库中，但任何审计或日志相关数据都可以存储在Elasticsearch或MongoDB中。由于每个微服务都在其有界上下文中运行，这可以促进实验和创新。变更影响的成本将会非常低。微服务使得DevOps达到了全面水平。成功的微服务架构需要许多DevOps工具和技术。小型微服务易于自动化，易于测试，如果需要，易于污染故障，并且易于扩展。Docker是容器化微服务的主要工具之一。
- en: Event-driven architecture
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: A well-architected microservice will support asynchronous event-driven architecture.
    Event-driven architecture helps as any event can be traced into—each action would
    be the outcome of any event, we can tap into any event to debug an issue. Microservices
    are designed with the publisher-subscriber pattern, meaning adding any other service
    that just subscribes to that event will be a mere task. For example, you are using
    a shopping site and there's a service for add to cart. Now, we want to add new
    functionality so that whenever a product is added to a cart, the inventory should
    be updated. Then, an inventory service can be prepared that just has to subscribe
    to the add to cart service.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好设计的微服务将支持异步事件驱动架构。事件驱动架构有助于追踪任何事件，每个动作都是任何事件的结果，我们可以利用任何事件来调试问题。微服务设计采用发布-订阅模式，这意味着添加任何其他服务只需订阅该事件即可。例如，您正在使用一个购物网站，有一个用于添加到购物车的服务。现在，我们想要添加新功能，以便每当产品添加到购物车时，库存应该更新。然后，可以准备一个只需订阅添加到购物车服务的库存服务。
- en: Now, we will look into the complexities that microservice architecture introduces.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将研究微服务架构引入的复杂性。
- en: Bad and challenging parts of microservices
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的不好和具有挑战性的部分
- en: With great power comes greater challenges. Let's look at the challenging parts
    of designing microservices.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 伟大的力量带来了更大的挑战。让我们看看设计微服务的具有挑战性的部分。
- en: Organization and orchestration
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织和编排
- en: It is one of the topmost challenges while adapting microservice architecture.
    This is more of a non-functional challenge wherein new organizational teams need
    to be formed and they need to be guided in adopting the microservice, agile, and
    scrum methodologies. They need to be simulated in such an environment that they
    can work independently. Their developed outcome should be integrated into the
    system in such a way that it is loosely coupled and is easily scaled.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在适应微服务架构时面临的最大挑战之一。这更多是一个非功能性挑战，新的组织团队需要被组建，并且他们需要在采用微服务、敏捷和Scrum方法论方面得到指导。他们需要在这样的环境中进行模拟，以便能够独立工作。他们开发的结果应该以松耦合的方式集成到系统中，并且可以轻松扩展。
- en: Platform
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台
- en: Creating the perfect environment needs a proper team, and a scalable fail-safe
    infrastructure across all data centers. Going to the right cloud provider (**AWS**
    or **GCP** or **Azure**), adding automation, scalability, high availability, managing
    containers, and instances of microservices are some of the key considerations.
    Further microservices demand other component needs such as an enterprise service
    bus, document databases, cache databases, and so on. Maintaining these components
    becomes an added task while dealing with microservices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完美的环境需要一个合适的团队，以及跨所有数据中心的可扩展的故障安全基础设施。选择正确的云服务提供商（**AWS**、**GCP**或**Azure**），添加自动化、可扩展性、高可用性，管理容器和微服务实例是一些关键考虑因素。此外，微服务还需要其他组件需求，如企业服务总线、文档数据库、缓存数据库等。在处理微服务时，维护这些组件成为了一个额外的任务。
- en: Testing
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Being completely independent testing out services with dependencies is extremely
    challenging. As a microservice gets introduced into the ecosystem, proper governance
    and testing are needed, otherwise it will be a single point of failure for the
    system. Several levels of testing are needed for any microservice. It should start
    from whether the service is able to access cross-cutting concerns (cache, security,
    database, logs) or not. The functionality of the service should be tested, followed
    by testing of the protocol through which it is going to communicate. Next is collaborative
    testing of the microservice with other services. After that is the scalability
    testing followed by fail-safe testing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完全独立地测试具有依赖关系的服务是极具挑战性的。当微服务引入生态系统时，需要适当的治理和测试，否则它将成为系统的单点故障。任何微服务都需要多个级别的测试。它应该从服务能否访问横切关注点（缓存、安全、数据库、日志）开始。应该测试服务的功能，然后测试它将要进行通信的协议。接下来是与其他服务协同测试微服务。之后是可扩展性测试，然后是故障安全测试。
- en: Service discovery
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: Locating services in a distributed environment can be a tedious task. Constant
    change and delivery is the dire requirement for today's constantly evolving world.
    In such situations, service discovery can be challenging as we want independent
    teams and minimal dependencies across teams. Service discovery should be such
    that a dynamic location can be provided for microservices. The location of a service
    may constantly change depending on deployments and auto-scaling or failures. Service
    discovery should also keep a lookout for services that are down or are performing
    poorly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式环境中定位服务可能是一项繁琐的任务。不断变化和交付是当今不断发展的世界的迫切需求。在这种情况下，服务发现可能具有挑战性，因为我们希望团队独立并且团队之间的依赖最小化。服务发现应该是这样的，可以为微服务提供动态位置。服务的位置可能会根据部署、自动扩展或故障而不断变化。服务发现还应该密切关注已经停止或性能不佳的服务。
- en: Microservice example
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务示例
- en: 'The following is a diagram of shopping microservices, which we are going to
    implement throughout this book. As we can see, each service is independently maintained
    and there are independent modules or smaller systems—**Billing Module**, **Customer
    Module**, **Product Module**, and **Vendor Module**. To coordinate with every
    module, we have **API Gateway** and **Service Registry**. Adding any additional
    service becomes very easy as the service registry will maintain all the dynamic
    entries and will be updated accordingly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在整本书中实施的购物微服务的图表。正如我们所看到的，每个服务都是独立维护的，有独立的模块或较小的系统——**计费模块**、**客户模块**、**产品模块**和**供应商模块**。为了与每个模块协调，我们有**API网关**和**服务注册表**。添加任何额外的服务变得非常容易，因为服务注册表将维护所有动态条目，并相应地进行更新。
- en: '![](img/44697ea7-5a19-429a-bc5d-55e975a7dd73.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44697ea7-5a19-429a-bc5d-55e975a7dd73.png)'
- en: Key considerations while adopting microservices
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用微服务时的关键考虑因素
- en: A microservice architecture introduces well-defined boundaries, which makes
    it possible to isolate failures within the boundaries. But being like other distributed
    systems, there is likely a chance of failure at the application level. To minimize
    the impact, we need to design fault-tolerant microservices, which react in a predefined
    way to certain types of failure. While adapting to microservice architecture,
    we add one more network layer to communicate with rather than in-memory method
    calls, which introduces extra latency and one more layer to manage. Given next
    are a few considerations that if handled with care while designing microservices
    for failure, will benefit the system in the long run.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构引入了明确定义的边界，这使得在边界内隔离故障成为可能。但与其他分布式系统一样，应用级别可能存在故障的可能性。为了最小化影响，我们需要设计容错的微服务，对某些类型的故障有预定义的反应。在适应微服务架构时，我们增加了一个网络层来进行通信，而不是内存中的方法调用，这引入了额外的延迟和需要管理的另一个层。以下是一些需要在设计微服务时小心处理的考虑因素，这将对系统产生长期利益。
- en: Service degradation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务降级
- en: Microservices architecture allows you to isolate failures, thus enabling you
    to isolate the failures and get graceful degradation as failures are contained
    within the boundaries of the service and are not cascaded. For example, in social
    networking sites, the messaging service may go down, but that won't stop the end
    users from using social networks. They can still browse posts, share statuses,
    check-in locations, and so on. Services should be made such that they adhere to
    certain SLAs. If a microservice stops meeting its SLA, then that service should
    be restored to back up. **Netflix's Hystrix** is based on the same principle.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构允许您隔离故障，从而使您能够隔离故障并获得优雅的降级，因为故障被包含在服务的边界内，不会被级联。例如，在社交网络网站上，消息服务可能会中断，但这不会阻止最终用户使用社交网络。他们仍然可以浏览帖子，分享状态，签到位置等。服务应该被制定以符合某些SLA。如果微服务停止满足其SLA，那么该服务应该被恢复备份。**Netflix的Hystrix**就是基于同样的原则。
- en: Proper change governance
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适当的变更治理
- en: Introducing change without any governance can be a huge problem. In a distributed
    system, services depend on each other. So when you introduce a new change, the
    utmost consideration should be given as if any side or unwanted effects are introduced,
    then its effect should be minimal. Various change management strategies and automatic
    rollout options should be available. Also, proper governance should be there in
    code management. Development should be done via TDD or BDD, and if the agreed
    percentage is met upon, only then should it be rolled out. Releases should be
    done gradually. One useful strategy is the *blue-green* or *red-black* deployment
    strategy, wherein you run two production environments. You rollout the change
    in only one environment and point out the load balancer to a newer version only
    after your change is verified. This is more likely when maintaining a staging
    environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何治理的情况下引入变化可能会是一个巨大的问题。在分布式系统中，服务相互依赖。因此，当您引入新变化时，应该给予最大的考虑，以确保不会引入任何副作用或不良影响，其影响应该是最小的。应该提供各种变更管理策略和自动部署选项。此外，代码管理中应该有适当的治理。开发应该通过TDD或BDD进行，只有在达成约定的百分比后才应该进行部署。发布应该逐渐进行。一个有用的策略是*蓝绿*或*红黑*部署策略，其中您运行两个生产环境。您只在一个环境中部署变化，并在验证变化后将负载均衡器指向更新的版本。这在维护一个分级环境时更有可能。
- en: Health checks, load balancing, and efficient gateway routing
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查、负载均衡和高效的网关路由
- en: Depending on business requirements, the microservice instance can start, restart,
    stop on some failure, run low on memory, and auto-scale, which may make it temporarily
    or permanently unavailable. Therefore, the architecture and framework should be
    designed accordingly. For example, a Node.js server, being single-threaded, stops
    immediately in the case of failure, but using graceful tools such as **PM2** forever
    keeps them running. A gateway should be introduced that will be the only point
    of contact for the microservice consumer. The gateway can be a load balancer that
    should skip unhealthy microservices instances. The load balancer should be able
    to collect health information metrics and route traffic accordingly, it should
    smartly analyze the traffic on any particular microservice, and it should trigger
    auto-scaling if needed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据业务需求，微服务实例可能会在某些故障、内存不足、自动扩展等情况下启动、重新启动、停止，这可能会使其暂时或永久不可用。因此，架构和框架应相应设计。例如，Node.js服务器是单线程的，在故障情况下会立即停止，但使用**PM2**等优雅的工具可以使其一直运行。应该引入一个网关，这将是微服务消费者的唯一联系点。网关可以是一个负载均衡器，应该跳过不健康的微服务实例。负载均衡器应该能够收集健康信息指标并相应地路由流量，它应该能够智能分析任何特定微服务上的流量，并在需要时触发自动扩展。
- en: Self-curing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自愈
- en: '**Self-curing design** can help the system to recover from disasters. Microservices
    implementation should be able to recover lost services and functionality automatically.
    Tools such as Docker restart services whenever they fail. Netflix provides wide
    tools as an orchestration layer to achieve self-healing. Eureka service registry
    and Hystrix circuit breaker are commonly used. Circuit breakers make your service
    calls more resilient. They track each microservice endpoint''s status. Whenever
    timeout is encountered, Hystrix breaks the connection, triggers the need for curing
    that microservice, and reverts to some fail-safe strategy. **Kubernates** is another
    option. If a pod or any container inside the pod goes down, Kubernates brings
    up the system and maintains the replica set intact.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**自愈设计**可以帮助系统从灾难中恢复。微服务实现应该能够自动恢复丢失的服务和功能。诸如Docker之类的工具在服务失败时会重新启动服务。Netflix提供了广泛的工具作为编排层来实现自愈。Eureka服务注册表和Hystrix断路器是常用的。断路器使您的服务调用更具弹性。它们跟踪每个微服务端点的状态。每当遇到超时时，Hystrix会断开连接，触发对该微服务的治疗需求，并恢复到一些安全策略。**Kubernates**是另一个选择。如果一个pod或者pod内的任何容器宕机，Kubernates会启动系统并保持副本集完整。'
- en: Cache for failover
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障转移缓存
- en: Failover caching helps to provide necessary data whenever there are temporary
    failures or some glitches. The cache layer should be designed so that it can smartly
    decide how long the cache can be used in a normal situation or during failover
    situations. Setting cache standard response headers in HTTP can be used. The max-age
    header specifies the amount of time a resource will be considered fresh. The stale-if-error
    header determines how long the resource should be served from the cache. You can
    also use libraries such as **Memcache**, **Redis**, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 故障转移缓存有助于在临时故障或一些故障时提供必要的数据。缓存层应设计得能够智能决定在正常情况下或故障转移情况下缓存可以使用多长时间。可以使用在HTTP中设置缓存标准响应头。max-age头部指定资源被视为新鲜的时间。stale-if-error头部确定资源应该从缓存中提供的时间。您还可以使用诸如**Memcache**、**Redis**等库。
- en: Retry until
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试直到
- en: Due to its self-healing capabilities, a microservice usually gets up and running
    in no time. Microservice architecture should have *retry logic until condition*
    capabilities, as we can expect that the service will recover or the load balancer
    will redirect the service request to another healthy instance. Frequent retries
    can also have a huge impact on the system. A general idea is increasing the waiting
    time between retries after each failure. Microservices should be able to handle
    idempotency issues; let's say you are retrying to purchase an order, then there
    shouldn't be double purchases on the customer. Now, let's take time to revisit
    the microservice concept and understand the most common questions asked about
    microservice architecture.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其自我修复能力，微服务通常可以在很短的时间内启动并运行。微服务架构应该具有*重试逻辑直到条件*的能力，因为我们可以预期服务将恢复，或者负载均衡器将将服务请求重定向到另一个健康的实例。频繁的重试也可能对系统产生巨大影响。一个常见的想法是在每次失败后增加重试之间的等待时间。微服务应该能够处理幂等性问题；比如说你正在重试购买订单，那么客户不应该出现重复购买。现在，让我们花点时间重新审视微服务的概念，并了解关于微服务架构的最常见问题。
- en: Microservice FAQs
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务常见问题
- en: 'While understanding any new terms, we often come across several questions.
    The following are some of the most frequently asked questions that we come across
    while understanding microservices:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解任何新术语时，我们经常会遇到一些问题。以下是我们在理解微服务时经常遇到的一些最常见的问题：
- en: '**Aren''t microservices just like service-oriented architecture (SOA)? Don''t
    I already have them? When should I start?**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务不就像面向服务的架构（SOA）吗？我不是已经有了吗？我应该何时开始？**'
- en: If you have been in the software industry for a long time, then seeing microservices
    would probably get you remembering SOA. Microservices does take the concept of
    modularity and message-based communication from SOA, but there are many differences
    between them. While SOA focuses more on code reuse, microservices follow the *play
    in your own bundled context* rule. Microservices are more of a subset of SOA.
    Microservices can be scaled on demand. Not all microservice implementations are
    the same. Using Netflix's implementation in your medical domain is probably a
    bad idea as any mistake in the medical report will be worth a human life. The
    simple answer for a working microservice can be to have a clear goal of the operation
    that the service is meant to perform and if it doesn't perform then what it should
    do in failures. There have been various answers to when and how to begin with microservices.
    *Martin Fowler*, one of the pioneers in microservices, states to start with the
    monolith and then gradually move to microservices. But the question here is—*is
    there enough investment to go into the same phase again in this technological
    innovation era?* The short answer is going early in microservices has huge benefits
    as it will address all concerns from the very beginning.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在软件行业工作了很长时间，那么看到微服务可能会让你想起SOA。微服务确实从SOA中借鉴了模块化和基于消息的通信的概念，但它们之间有很多不同之处。虽然SOA更注重代码重用，微服务遵循“在自己的捆绑上下文中发挥作用”的规则。微服务更像是SOA的一个子集。微服务可以根据需求进行扩展。并非所有的微服务实现都相同。在医疗领域使用Netflix的实现可能是一个坏主意，因为医疗报告中的任何错误都可能值得一个人的生命。一个有效的微服务的简单答案可能是明确服务的操作目标，如果不能执行操作，则在失败时应该做什么。关于何时以及如何开始使用微服务，有各种不同的答案。*Martin
    Fowler*，微服务的先驱之一，建议从单体架构开始，然后逐渐转向微服务。但问题是——*在这个技术创新时代，是否有足够的投资再次进行相同的阶段？*简短的答案是早期使用微服务有巨大的好处，因为它将从一开始就解决所有问题。
- en: '**How will we deal with all the parts? Who''s in charge? **'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们将如何处理所有的部分？谁负责？**'
- en: Microservices introduce localization and self-rule. Localization means that
    the huge work that was done earlier will no longer be done by the central team.
    Embracing self-rule means trusting all teams to let them make their own decisions.
    This way, software changes or even migrations becomes very easy and fast to manage.
    Having said that, it doesn't mean that there's no central body at all. With more
    microservices, the architecture becomes more complex. The central team then should
    handle all centralized controls such as security, design patterns, frameworks,
    enterprise security bus, and so on. Certain self-governance processes should be
    introduced, such as SLAs. Each microservice should adhere to these SLAs and system
    design should be smart in such a way that if SLAs are not met, then the microservice
    should be dropped.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务引入了本地化和自主规则。本地化意味着之前由中央团队完成的大量工作将不再由中央团队完成。拥抱自主规则意味着信任所有团队让他们自己做决定。这样，软件的更改甚至迁移变得非常容易和快速。话虽如此，并不意味着根本没有中央机构。随着更多的微服务，架构变得更加复杂。然后中央团队应该处理所有集中控制，如安全性、设计模式、框架、企业安全总线等。应该引入某些自我治理流程，如SLA。每个微服务都应该遵守这些SLA，系统设计应该聪明地设计，以便如果SLA未达到，那么微服务应该被丢弃。
- en: '**How do I introduce change or how do I begin with microservice development?**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我如何引入变化或者如何开始微服务开发？**'
- en: Almost all successful microservice stories have begun with a monolith that got
    too big to be managed and was broken up. Changing some part of the architecture
    all of a sudden will have a huge impact, it should be introduced as  gradually
    kind of *divide and rule*. Consider asking yourself the following questions for
    deciding which part to break in the monolith—*How is my application built and
    packaged? How is my application code written? Can I have different data sources
    and how will my application function when I introduce multiple data sources?—*Based
    on the answers of these parts, refactor that part and measure and observe the
    performance of that application. Make sure that the application stays in its bounded
    context. Another part that you can begin is the part whose performance is worst
    in the current monolithic. Finding these bottlenecks that hinder change would
    be good for organizations. Introducing centralized operations will eventually
    allow multiple things to be run in parallel and benefit the greater good of the
    company.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有成功的微服务故事都始于一个变得太大而无法管理并被分解的单体架构。突然改变架构的某个部分将产生巨大影响，应该逐渐引入一种“分而治之”的方式。考虑以下问题来决定要在单体架构中分解哪个部分——我的应用是如何构建和打包的？我的应用代码是如何编写的？我可以有不同的数据源，当我引入多个数据源时，我的应用将如何运行？——根据这些部分的答案，重构该部分并测量和观察该应用的性能。确保应用保持在其边界上下文中。另一个可以开始的部分是当前单体架构中性能最差的部分。发现阻碍变化的瓶颈对组织来说是有益的。引入集中化操作最终将允许多个事情并行运行，并使公司受益匪浅。
- en: '**What kind of tools and technologies are required? **'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要什么样的工具和技术？
- en: While designing microservice architecture, proper thought should be given to
    the technology or framework selection for any particular stage. For example, an
    ideal environment for microservice features, cloud infrastructure, and containers.
    Containers give heterogeneous and easy to port or migrate systems. Using Docker
    brings resiliency and scalability on demand in microservices. Any part of microservices,
    such as the API Gateway or the service registry should be such that it should
    be API friendly, adaptable to dynamic changes, and not be a single point of failure.
    Containers require shifting on and off to a server, track all application upgrades
    for which proper framework either—**Swarm** or **Kubernates** for orchestrating
    framework deployments. Lastly, some monitoring tools to keep health checks on
    all microservices and take actions needed. Prometheus is one such famous tool.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务架构时，应该对任何特定阶段的技术或框架选择进行适当的思考。例如，微服务特性、云基础设施和容器的理想环境。容器提供了异构和易于移植或迁移的系统。使用Docker可以在微服务中按需提供弹性和可伸缩性。微服务的任何部分，如API网关或服务注册表，都应该是API友好的，适应动态变化，而不是单点故障。容器需要在服务器上进行开关，跟踪所有应用程序升级，为此需要适当的框架，如Swarm或Kubernetes来进行框架部署。最后，一些监控工具可以对所有微服务进行健康检查并采取必要的行动。Prometheus就是这样一个著名的工具。
- en: '**How do I govern a microservices system? **'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何管理微服务系统？
- en: With lots of parallel service development going on, there is a primitive need
    to have a centralized governing policy. Not only do we need to take care of certifications
    and server audits, but also centralized concerns such as security, logging, scalability,
    and distributed concerns such as team ownership, sharing concerns between various
    services, code linters, service-specific concerns, and so on. In such a case,
    some standard guidelines can be made such as each team should provide a Docker
    configuration file that bundles the software right from getting dependencies to
    building it and producing a container that has the specifics of the service. The
    Docker image can then be run in any standard way, or using orchestration tools
    such as Amazon EC2, GCP, or Kubernates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多并行服务开发正在进行，有一个集中的管理政策是一个原始的需求。我们不仅需要关注认证和服务器审计，还需要关注集中的问题，如安全性、日志记录、可伸缩性，以及团队所有权、在各种服务之间共享问题、代码检查器、特定于服务的问题等分布式问题。在这种情况下，可以制定一些标准指南，例如每个团队应提供一个Docker配置文件，该文件从获取依赖项到构建软件并生成具有服务特定信息的容器。然后可以以任何标准方式运行Docker镜像，或者使用诸如Amazon
    EC2、GCP或Kubernetes之类的编排工具。
- en: '**Should all the microservices be coded in the same language?**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有微服务都应该用相同的语言编码吗？
- en: The generic answer to this question is it is not a prerequisite. Microservices
    interact with each other via predefined protocols such as HTTP, Sockets, Thrift,
    RPC, and so on, which we will see in much detail later on. This means different
    services can be written in completely different technological stacks. The internal
    language implementation of the microservice is not important as the external outcome,
    that is, the endpoint and API. As long as the communication protocols are maintained,
    language implementation is not important, while it is an added advantage for not
    just having one language, but adding too many languages will also result in an
    added complexity of system developers to maintain language environment needs.
    The entire ecosystem should not be a wild jungle where you grow anything.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的一般回答是这不是一个先决条件。微服务通过预定义的协议进行相互交互，例如HTTP、Sockets、Thrift、RPC等，我们稍后将更详细地看到。这意味着不同的服务可以使用完全不同的技术堆栈编写。微服务的内部语言实现并不重要，重要的是外部结果，即端点和API。只要保持通信协议，语言实现就不重要，虽然不仅拥有一种语言是一个优势，但添加太多语言也会导致系统开发人员维护语言环境需求的复杂性增加。整个生态系统不应该是一个你可以种植任何东西的野生丛林。
- en: Cloud-based systems now have a standard set of guidelines. We will look at the
    famous twelve-factor applications and how microservices adhere to those guidelines.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基于云的系统现在有一套标准的指导方针。我们将看一下著名的十二要素应用程序以及微服务如何遵循这些指导方针。
- en: Twelve-factor application of microservices
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的十二要素应用
- en: '"Good code fails when you don''t have a good process and a platform to help
    you. Good team fails when you don''t have a good culture that embraces DevOps
    and microservices."'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: “当你没有一个好的流程和平台来帮助你时，好的代码会失败。当你没有一个拥抱DevOps和微服务的良好文化时，好的团队也会失败。”
- en: '- Tim Spann'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '- Tim Spann'
- en: 'The **twelve-factor application** is a methodology for **Software as a Service (SaaS****)** or
    web applications or software deployed in the cloud. It tells us about the characteristics
    of the output expected from such applications. It essentially is just outlining
    necessities for making well-structured and scalable cloud applications:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**十二要素应用程序**是一种**软件即服务（SaaS）**或部署在云中的Web应用程序或软件的方法论。它告诉我们关于这些应用程序期望的输出特征。它基本上只是概述了制作结构良好且可扩展的云应用程序的必要条件：'
- en: '**Codebase**: We maintain a single code base here for each microservice, with
    a configuration specific to their own environments, such as development, QA, and
    prod. Each microservice would have its own repository in a version control system
    such as Git, mercurial, and so on.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码库**：我们为每个微服务维护一个单一的代码库，具有特定于它们自己的环境的配置，如开发、QA和生产。每个微服务都将在版本控制系统（如Git、mercurial等）中拥有自己的存储库。'
- en: '**Dependencies**: All microservices will have their dependencies as part of
    the application bundle. In Node.js, there is `package.json`, which mentions all
    the development dependencies and overall dependencies. We can even have a private
    repository from where dependencies will be pulled.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖关系**：所有微服务都将它们的依赖项作为应用程序包的一部分。在Node.js中，有一个`package.json`，其中列出了所有的开发依赖和总体依赖。我们甚至可以有一个私有仓库，从中获取依赖项。'
- en: '**Configs**: All configurations should be externalized, based on the server
    environment. There should be a separation of config from code. You can set environment
    variables in Node.js or use Docker compose to define other variables.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：所有配置应该是外部化的，基于服务器环境。应该将配置与代码分离。您可以在Node.js中设置环境变量，或者使用Docker compose来定义其他变量。'
- en: '**Backing services**: Any service consumed over the network such as database,
    I/O operations, messaging queries, SMTP, the cache will be exposed as microservices
    and using Docker compose and be independent of the application.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后备服务**：任何通过网络消耗的服务，如数据库、I/O操作、消息查询、SMTP、缓存，都将作为微服务暴露出来，并使用Docker compose，并独立于应用程序。'
- en: '**Build, release, and run**: We will use automated tools like Docker and Git
    in distributed systems. Using Docker we can isolate all the three phases using
    its push, pull, and run commands.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建、发布和运行**：我们将在分布式系统中使用Docker和Git等自动化工具。使用Docker，我们可以使用其推送、拉取和运行命令来隔离所有三个阶段。'
- en: '**Processes**: Microservices designed would be stateless and would share nothing,
    hence enabling zero fault tolerance and easy scaling. Volumes will be used to
    persist data thus avoiding data loss.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程**：设计的微服务将是无状态的，并且不共享任何东西，因此实现零容错和轻松扩展。卷将用于持久化数据，从而避免数据丢失。'
- en: '**Port binding**: Microservices should be autonomous and self-contained. Microservices
    should embed service listeners as part of service itself. For example— in Node.js
    application using HTTP module, service network exposing services for handling
    ports for all processes.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口绑定**：微服务应该是自治的和自包含的。微服务应该将服务监听器嵌入到服务本身中。例如，在Node.js应用程序中使用HTTP模块，服务网络公开服务以处理所有进程的端口。'
- en: '**Concurrency**: Microservices will be scaled out via replication. Microservices
    are scaled out rather than scaled up. Microservices can be scaled or shrunk based
    on the flow of workload diversity. Concurrency will be dynamically maintained.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性**：微服务将通过复制进行扩展。微服务是通过扩展而不是扩大规模的。微服务可以根据工作负载的流动进行扩展或缩小。并发性将得到动态维护。'
- en: '**Disposability**: To maximize the robustness of application with fast startup
    and graceful shutdown. Various options include restart policies, orchestration
    using Docker swarm, reverse proxy, and load balancing with service containers.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可处置性**：最大限度地提高应用程序的健壮性，实现快速启动和优雅关闭。各种选项包括重启策略，使用Docker swarm进行编排，反向代理以及使用服务容器进行负载平衡。'
- en: '**Dev/prod parity**: Keep development/production/staging environments exactly
    alike. Using containerized microservices helps via *build once, run anywhere strategy*.
    The same image is deployed across various DevOps stage.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发/生产一致性**：保持开发/生产/暂存环境完全相同。使用容器化的微服务通过*构建一次，随处运行*策略有所帮助。相同的镜像部署在各种DevOps阶段。'
- en: '**Logs**: Creating separate microservice for logs for making it centralized,
    to treat as event streams and send it to frameworks such as **elastic stack**
    (**ELK**).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：为日志创建单独的微服务，使其集中化，将其视为事件流，并将其发送到诸如**弹性堆栈**（**ELK**）之类的框架。'
- en: '**Admin processes**: Admin or any management tasks should be packed as one
    of the processes, so they can be easily executed, monitored, and managed. This
    will include tasks like database migrations, one-time scripts, fixing bad data,
    and so on.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理进程**：管理或任何管理任务应该作为其中一个进程打包，这样它们可以轻松执行、监视和管理。这将包括诸如数据库迁移、一次性脚本、修复错误数据等任务。'
- en: Microservices in the current world
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前世界中的微服务
- en: Now, let's look at the pioneer implementers of microservices in the current
    world, the advantages they have got, and the roadmap ahead. The common objective
    of why these companies adopted microservices was getting rid of monolithic hell.
    Microservices even saw its adoption at the frontend. Companies such as **Zalando**
    use microservices principles to have composition at the UI level too.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看当前世界中微服务的先驱实施者，他们获得的优势以及未来的路线图。这些公司采用微服务的共同目标是摆脱单片地狱。微服务甚至在前端看到了它的采用。像**Zalando**这样的公司也使用微服务原则在UI层面进行组合。
- en: Netflix
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix
- en: '**Netflix** is one of the front-runners in microservice adoption. Netflix processes
    billions of viewing events per day. It needed a robust and scalable architecture
    to manage and process this data. Netflix used polyglot persistence to get the
    strength of each of the technological solutions they adopted. They used **Cassandra**
    for high volume and lower latency writes operations and a hand-made model with
    tuned configurations for medium volume write operations. They have **Redis** for
    high volume and lower latency reads at the cache level. Several frameworks that
    Netflix tailor-made are now open source and available for use:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Netflix**是微服务采用的先驱之一。Netflix每天处理数十亿次观看事件。它需要一个强大和可扩展的架构来管理和处理这些数据。Netflix使用多语言持久性来获得他们采用的每种技术解决方案的优势。他们使用**Cassandra**进行高容量和较低延迟的写操作，以及具有调整配置的手工模型进行中等容量的写操作。他们在缓存级别使用**Redis**进行高容量和较低延迟的读取。Netflix定制的几个框架现在是开源的，可供使用：'
- en: '| **Netflix Zuul** | An edge server or the gatekeeper to the outside world.
    It doesn''t allow unauthorized requests to pass through. It is the only point
    of contact for the outside world. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **Netflix Zuul** | 用于外部世界的边缘服务器或门卫。它不允许未经授权的请求通过。这是外部世界的唯一联系点。'
- en: '| **Netflix Ribbon** | A load balancer that is used by service consumers to
    find services at runtime. If more than one instances of microservices are found,
    ribbon uses load balancing to evenly distribute the load. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **Netflix Ribbon** | 服务消费者用于在运行时查找服务的负载均衡器。如果找到多个微服务实例，ribbon使用负载平衡来均匀分配负载。'
- en: '| **Netflix Hystrix** | A circuit breaker that is used to keep the system up
    and running. Hystrix breaks the connection for services that are going to fail
    eventually and only joins the connection when services are up again. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **Netflix Hystrix** | 用于保持系统运行的断路器。Hystrix会断开那些最终会失败的服务的连接，只有当服务恢复正常时才会重新连接。'
- en: '| **Netflix Eureka** | Used for service discovery and registration. It allows
    services to register themselves at runtime. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **Netflix Eureka** | 用于服务发现和注册。它允许服务在运行时注册自己。'
- en: '| **Netflix Turbine** | Monitoring tool to check the health of running microservices.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **Netflix Turbine** | 用于检查运行中微服务的健康状况的监控工具。'
- en: Just checking the stars on these repositories will give an idea of the rate
    of adoption of microservices using Netflix's tools.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅检查这些存储库上的星星就可以给出使用Netflix工具采用微服务的速度的想法。
- en: Walmart
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沃尔玛
- en: Walmart is one of the most popular companies on Black Friday. During Black Friday,
    it has more than 6 million page views per minute. **Walmart** adopted to microservices
    architecture to adopt to the world of 2020 to have 100% availability with reasonable
    costs. Migrating to microservices gave a huge uplift to the company. Conversion
    rates went up by 20%. They have zero downtime on Black Friday. They saved 40%
    of their computational power and got 20-50% cost savings overall.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 沃尔玛是黑色星期五上最受欢迎的公司之一。在黑色星期五期间，每分钟有超过600万次页面浏览。**沃尔玛**采用了微服务架构，以适应2020年的世界，以合理的成本实现100%的可用性。迁移到微服务架构给公司带来了巨大的提升。转化率提高了20%。他们在黑色星期五没有停机时间。他们节省了40%的计算能力，整体节省了20-50%的成本。
- en: Spotify
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spotify
- en: '**Spotify** has 75 million active users per month with an average session length
    of 23 minutes. They adopted a microservice architecture and polyglot environment.
    Spotify is a company of 90 teams, 600 developers, and five offices across two
    continents, all working on the same product. This was a major factor in reducing
    dependencies as much as possible.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spotify**每月有7500万活跃用户，平均会话长度为23分钟。他们采用了微服务架构和多语言环境。Spotify是一个拥有90个团队、600名开发人员和两个大陆上的五个办公室的公司，所有人都在同一个产品上工作。这在尽可能减少依赖关系方面起到了重要作用。'
- en: Zalando
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zalando
- en: '**Zalando** implemented microservices at the frontend. They introduced fragments
    that served as separate services for the frontend. Fragments can be composed together
    at runtime as per the template definitions provided. Similar to Netflix, they
    have outsourced usage libraries:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**Zalando**在前端实施了微服务。他们引入了作为前端的独立服务的片段。片段可以根据提供的模板定义在运行时组合在一起。与Netflix类似，他们外包了使用库：'
- en: '| **Tailor** | It''s a layout service, which composes a page out of various
    fragments, as it does asynchronous and streams based fetching it has outstanding
    **time to the first byte** (**TTFB**). |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **Tailor** | 这是一个布局服务，它由各种片段组成页面，因为它进行异步和基于流的获取，所以具有出色的**首字节时间**（**TTFB**）。|'
- en: '| **Skipper** | HTTP router for communication, more of an HTTP interceptor,
    it has the ability to modify request and responses with filters. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **Skipper** | 用于通信的HTTP路由器，更像是HTTP拦截器，它具有修改请求和响应的能力。|'
- en: '| **Shaker** | UI components library used for providing consistent user experience
    while developing fragments across multiple teams. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **Shaker** | 用于在多个团队开发片段时提供一致用户体验的UI组件库。'
- en: '| **Quilt** | Template storage and manager with REST API. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **Quilt** | 带有REST API的模板存储和管理器。'
- en: '| **Innkeeper** | Datastores for routes. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **Innkeeper** | 路由的数据存储。'
- en: '| **Tesselate** | Server-side renderer and component tree builder. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **Tesselate** | 服务器端渲染器和组件树构建器。'
- en: It now serves more than 1500 fashion brands, generates more than $3.43 billion
    revenue, and developments are done in a team of more than 700 people.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它服务于1500多个时尚品牌，创造了超过34.3亿美元的收入，开发团队有700多人。
- en: In the next section, we will debunk microservices from the design point of view.
    We will see what components are involved in the microservices design and see widely
    prevalent microservices design patterns.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从设计的角度来揭示微服务。我们将看到微服务设计中涉及的组件，并了解广泛存在的微服务设计模式。
- en: Microservice design aspects
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务设计方面
- en: While designing microservices, various important decisions need to be taken
    such as how will the microservices communicate with each other, how we will handle
    security, how we will do data management, and so on. Let's now look at those various
    aspects involved in the microservices design and understand various options available
    to it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计微服务时，需要做出各种重要决策，例如微服务之间如何通信，如何处理安全性，如何进行数据管理等。现在让我们看看微服务设计中涉及的各种方面，并了解其可用的各种选项。
- en: Communication between microservices
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之间的通信
- en: Let's understand this aspect with a real-world example to understand the problem.
    In the shopping cart application, we have our product microservices, inventory
    microservice, check out microservice, and user microservice. Now a user opts to
    buy a product; for the user, the product should be added to their cart, the amount
    paid, on successful payment, the checkout done, and inventory updated. Now if
    payment is successfully done, then only the checkout and inventory should be updated,
    hence the services need to communicate with each other. Let's now look at some
    of the mechanisms that microservices can use to communicate with each other or
    any of the external clients.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个真实世界的例子来理解这个问题。在购物车应用程序中，我们有产品微服务、库存微服务、结账微服务和用户微服务。现在用户选择购买一个产品；对于用户来说，产品应该被添加到他们的购物车中，支付金额，在成功支付后，结账完成，并更新库存。现在如果支付成功，那么只有结账和库存应该被更新，因此服务需要相互通信。现在让我们看一些微服务可以用来相互通信或与任何外部客户端通信的机制。
- en: Remote Procedure Invocation (RPI)
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程过程调用（RPI）
- en: Briefly speaking, remote procedure call is a protocol that anyone can use to
    access services from any other providers located remotely in the network, without
    the need of understanding the network details. The client uses the protocol of
    request and replies to make requests for services and it is one of the most feasible
    solutions to REST for big data search systems. It has one of the major advantages
    of serialization time. Some of the technologies providing RPI are **Apache Thrift**
    and **Google's gRPC**. gRPC is a widely adopted library and it has more than 23,000
    downloads from Node.js per day. It has some awesome utilities such as pluggable
    authentication, tracing, load balancing, and health checking. It is used by Netflix,
    CoreOS, Cisco, and so on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，远程过程调用是一种协议，任何人都可以使用它从网络中远程访问其他提供者的服务，而无需了解网络细节。客户端使用请求和回复协议来请求服务，这是大数据搜索系统中最可行的解决方案之一。它具有序列化时间的主要优势之一。提供RPI的一些技术包括**Apache
    Thrift**和**Google的gRPC**。gRPC是一个广泛采用的库，每天从Node.js下载量超过23,000次。它具有一些很棒的实用程序，如可插拔身份验证、跟踪、负载平衡和健康检查。它被Netflix、CoreOS、Cisco等公司使用。
- en: 'This pattern of communication has the following advantages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通信模式具有以下优势：
- en: Request and reply are easy
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求和回复很容易
- en: Simple to maintain as there is no middle broker
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护简单，因为没有中间代理
- en: Bidirectional streams with HTTP/2-based transportation methods
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于HTTP/2的双向流传输方法
- en: Efficiently connecting polyglot services in microservices styled architectural
    ecosystems
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务风格的架构生态系统中高效地连接多语言服务
- en: 'This pattern has the following challenges and issues for consideration:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的通信对以下挑战和问题需要考虑：
- en: The caller needs to know the locations of service instances, that is, maintain
    a client-side registry and server-side registry
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方需要知道服务实例的位置，即维护客户端注册表和服务器端注册表
- en: It only supports the request and reply model and has no support for other patterns
    such as notifications, async responses, the publish/subscribe pattern, publish async
    responses, streams, and so on
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只支持请求和回复模式，不支持其他模式，如通知、异步响应、发布/订阅模式、发布异步响应、流等
- en: RPI uses binary rather than text to keep the payload very compact and efficient.
    These requests are multiplexed over a single TCP connection, which can allow multiple
    concurrent messages to be in flight without having to compromise for network consumption
    usage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: RPI使用二进制而不是文本来保持有效负载非常紧凑和高效。这些请求在单个TCP连接上进行多路复用，这可以允许多个并发消息在不牺牲网络消耗的情况下进行传输。
- en: Messaging and message bus
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递和消息总线
- en: This mode of communication is used when services have to handle the requests
    from various client interfaces. Services need to collaborate with each other to
    handle some specific operations, for which they need to use an inter-process communication
    protocol. Asynchronous messaging and message bus is one of them. Microservices
    communicate with each other by exchanging messages over various messaging channels.
    **Apache Kafka**, **RabbitMQ**, and **ActiveMQ**, **Kestrel** are some of the
    widely available message brokers that can be used for communication between microservices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务必须处理来自各种客户端接口的请求时，就会使用这种通信模式。服务需要相互协作来处理一些特定的操作，为此它们需要使用进程间通信协议。异步消息传递和消息总线就是其中之一。微服务通过在各种消息通道上交换消息来相互通信。**Apache
    Kafka**、**RabbitMQ**、**ActiveMQ**、**Kestrel**是一些广泛可用的消息代理，可用于微服务之间的通信。
- en: 'The message broker ultimately does the following set of functionalities:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理最终执行以下功能集：
- en: Route messages coming from various clients to different microservices destinations.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将来自各种客户端的消息路由到不同的微服务目的地。
- en: Changes messages to desired transformations as per need.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要将消息更改为所需的转换。
- en: Ability to do message aggregations, segregate a message into multiple messages,
    and send them to the destination as per need and recompose them.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够进行消息聚合，将消息分隔成多个消息，并根据需要发送到目的地并重新组合它们。
- en: Respond to errors or events.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应错误或事件。
- en: Provide content and routing using the publish-subscribe pattern.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用发布-订阅模式提供内容和路由。
- en: 'Using message bus as a means of communication between microservices has the
    following advantages:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息总线作为微服务之间的通信手段具有以下优势：
- en: The client is decoupled from the services; they don't need to discover any services.
    Loosely coupled architecture throughout.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端与服务解耦；它们不需要发现任何服务。整体上松散耦合的架构。
- en: Highly available as the message broker persists messages until the consumer
    is able to process them for operations.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息代理具有高可用性，因为它会持久保存消息，直到消费者能够对其进行操作。
- en: It has support for a variety of communication patterns, including the widely
    used request/reply, notifications, async responses, publish-subscribe, and so
    on.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持各种通信模式，包括广泛使用的请求/回复、通知、异步响应、发布-订阅等。
- en: While this mode provides several advantages, it increases the complexity of
    adding a message broker that should be made highly available, as it can become
    a single point of failure. It also implies the need for the client to discover
    the location of the message broker, the single point of contact.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种模式提供了几个优点，但增加了添加消息代理的复杂性，该代理应该具有高可用性，因为它可能成为单点故障。这也意味着客户端需要发现消息代理的位置，即联系点。
- en: Protobufs
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: protobufs
- en: '**Protocol buffers** or **protobufs** are a binary format created by Google.
    Google defines protobufs as a language and platform neutral extensive way of serializing
    structured data that can be used as one of the communication protocols. Protobufs
    also defines a set of some language rules that define the structure of messages.
    Some demonstrations effectively show that protobufs is six times faster than JSON.
    It is very easy to implement and it involves three major stages, which are creating
    message descriptors, message implementations, and parsing and serialization. Using
    protobufs in your microservices gives you the following advantages:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议缓冲区**或**protobufs**是由谷歌创建的二进制格式。谷歌将protobufs定义为一种语言和平台中立的序列化结构化数据的广泛方式，可用作通信协议之一。
    Protobufs还定义了一组定义消息结构的一些语言规则。一些演示有效地表明protobufs比JSON快六倍。它非常容易实现，包括三个主要阶段，即创建消息描述符、消息实现和解析和序列化。在微服务中使用protobufs具有以下优势：'
- en: Formats for protobufs are self-explaining—formal formats.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: protobufs的格式是自解释的-正式的格式。
- en: It has RPC support; you can declare server RPC interfaces as part of protocol
    files.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有RPC支持；您可以将服务器RPC接口声明为协议文件的一部分。
- en: It has an option for structure validation. As it has larger datatype messages
    that are serialized on protobufs, it can be validated automatically by the code
    that is responsible for exchanging them.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有结构验证的选项。由于它具有在protobufs上序列化的较大数据类型消息，因此可以由负责交换它们的代码自动验证。
- en: 'While the protobuf pattern offers various advantages, it has some drawbacks,
    which are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然protobuf模式提供了各种优势，但也有一些缺点，如下所示：
- en: It is an upcoming pattern; hence you won't find many resources or detailed documentation
    for implementation of protobuf. If you just look for the protobuf tag on Stack
    Overflow, you will merely see a mere 10,000 questions.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种新兴的模式；因此您不会找到许多资源或详细的protobuf实现文档。如果您只在Stack Overflow上搜索protobuf标签，您只会看到大约1万个问题。
- en: As it's binary format, it's non-readable when compared to JSON, which is simple
    to read and analyze on the other hand. The next generation of protobuf and flatbuffer
    is already available now.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是二进制格式，与JSON相比，它是不可读的，而JSON在另一方面是简单易读和分析的。下一代protobuf和flatbuffer现在已经可用。
- en: Service discovery
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: The next obvious aspect to take care of is the method through which any client
    interface or any microservice will discover the network location of any service
    instance. Modern applications based on microservices run in virtualized or containerized environments
    where things change dynamically, including the number of instances of services
    and their location. Also, the set of service instances changes dynamically based
    on auto-scaling, upgrades, and so on. We need an elaborate a service discovery
    mechanism. Discussed ahead are widely used patterns.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要注意的明显方面是任何客户端接口或任何微服务将发现任何服务实例的网络位置的方法。基于微服务的现代应用程序在虚拟化或容器化环境中运行，其中包括服务实例的数量和位置动态变化。此外，基于自动扩展、升级等，服务实例集会动态变化。我们需要一个详细的服务发现机制。下面讨论的是广泛使用的模式。
- en: Service registry for service-service communication
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表用于服务-服务通信
- en: Different microservices and various client interfaces need to know the location
    of service instances so as to send requests. Usually, virtual machines or containers
    have a different or dynamic IP address, for example, an EC2 group when applied
    auto-scaling, it auto adjusts the number of instances based on load. Various options
    are available to maintain a registry anywhere such as client-side or server-side
    registrations. Clients or microservices look up to that registry to find other
    microservices for communication.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的微服务和各种客户端接口需要知道服务实例的位置，以便发送请求。通常，虚拟机或容器具有不同或动态的IP地址，例如，应用自动扩展的EC2组，它根据负载自动调整实例的数量。有多种选项可用于在任何地方维护注册表，例如客户端端或服务器端注册。客户端或微服务查找该注册表以查找其他微服务进行通信。
- en: 'Let''s take the real-life example of Netflix. Netflix Eureka is a service registry
    provider. It has various options for registering and querying available service
    instances. Using the `POST API` exposed an instance of service tells about its
    network location. It must be constantly updated every 30 seconds with the `PUT
    API` exposed. Any interface can use the `GET API` to get that instance and use
    it as per demand. Some of the widely available options are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Netflix的真实例子为例。Netflix Eureka是一个服务注册提供者。它有各种选项用于注册和查询可用的服务实例。使用公开的`POST
    API`告知服务实例的网络位置。必须每30秒使用公开的`PUT API`进行不断更新。任何接口都可以使用`GET API`获取该实例并根据需求使用。一些广泛可用的选项如下：
- en: '`etcd`: A key-value store used for shared configuration and service discovery.
    Projects such as Kubernates and cloud foundry are based on `etcd` as it can be
    highly available, key-value based, and consistent.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`：用于共享配置和服务发现的键值存储。诸如Kubernates和Cloud Foundry之类的项目都基于`etcd`，因为它可以是高可用的、基于键值的和一致的。'
- en: '`consul`: Yet another tool for service discovery. It has wide options such
    as exposed API endpoints that allow the client to register and discover services
    and perform health checks to determine service availability.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consul`：另一个用于服务发现的工具。它具有广泛的选项，如公开的API端点，允许客户端注册和发现服务，并执行健康检查以确定服务的可用性。'
- en: '`ZooKeeper`: Very widely used, highly available, and a high performant coordinated
    service used in distributed applications. Originally a subproject of Hadoop, Zookeeper
    is a widely used top-level project and it comes preconfigured with various frameworks.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZooKeeper`：非常广泛使用，高可用性和高性能的协调服务，用于分布式应用程序。Zookeeper最初是Hadoop的一个子项目，是一个广泛使用的顶级项目，并且预配置了各种框架。'
- en: Some systems have implicit in-built service registry, built in as a part of
    their framework. For example, Kubernates, Marathon, and AWS ELB.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统具有隐式内置的服务注册表，作为其框架的一部分内置。例如，Kubernates、Marathon和AWS ELB。
- en: Server-side discovery
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端发现
- en: All requests made to any of the services are routed via a router or load balancers
    that run in a location known to client interfaces. The router then queries a maintained
    registry and forwards the request based on the query response. An **AWS Elastic
    load balancer** is a classic example that has the ability to handle load balancing,
    handle internal or external traffic, and act as a service registry. EC2 instances
    are registered to ELB either via exposed API calls or either through auto-scaling.
    Other options include NGINX and NGINX Plus. There are available consul templates
    that ultimately generate the `nginx.conf` file from the consul service registry
    and can configure proxying as required.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何服务的所有请求都通过已知客户端接口的位置运行的路由器或负载均衡器路由。然后，路由器查询维护的注册表，并根据查询响应转发请求。**AWS弹性负载均衡器**是一个经典示例，它具有处理负载平衡、处理内部或外部流量和作为服务注册表的能力。EC2实例可以通过公开的API调用或自动扩展注册到ELB。其他选项包括NGINX和NGINX
    Plus。还有可用的consul模板，最终从consul服务注册表生成`nginx.conf`文件，并根据需要配置代理。
- en: 'Some of the major advantages of using server-side discovery are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器端发现的一些主要优势如下：
- en: The client does not need to know the location of different microservices. They
    just need to know the location of the router and the service discovery logic is
    completely abstracted from the client so there is zero logic at the client end.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端不需要知道不同微服务的位置。他们只需要知道路由器的位置，服务发现逻辑完全抽象化，客户端端没有任何逻辑。
- en: Some environments provide this component functionality for free.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些环境免费提供此组件功能。
- en: 'While these options have great advantages, there are some drawbacks too that
    need to be handled:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些选项有很大的优势，但也有一些需要处理的缺点：
- en: It has more network hops, that is, one from the client service registry and
    another from the service registry microservice.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有更多的网络跳数，即来自客户端服务注册表和另一个来自服务注册表微服务。
- en: If the load balancer is not provided by the environment, then it has to be set
    up and managed. If not properly handled, then it can be a single point of failure.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果负载均衡器不是由环境提供的，那么就必须设置和管理它。如果处理不当，它可能成为单点故障。
- en: The selected router or load balancer must support different communication protocols
    for modes of communication.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选定的路由器或负载均衡器必须支持不同的通信协议以进行通信模式。
- en: Client-side discovery
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端发现
- en: 'Under this mode of discovery, the client is responsible for handling the network
    location of available microservices and load balancing incoming requests across
    them. The client needs to query a service registry (a database of available services
    maintained on the client side). The client then selects service instances on the
    basis of an algorithm and then makes a request. Netflix uses this pattern extensively
    and has open sourced their tools Netflix OSS, Netflix Eureka, Netflix Ribbon,
    and Netflix Prana. Using this pattern has the following advantages:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种发现模式下，客户端负责处理可用微服务的网络位置，并在它们之间负载平衡传入请求。客户端需要查询服务注册表（在客户端维护的可用服务的数据库）。然后，客户端根据算法选择服务实例，然后发出请求。Netflix广泛使用此模式，并已开源其工具Netflix
    OSS、Netflix Eureka、Netflix Ribbon和Netflix Prana。使用此模式具有以下优势：
- en: High performance and availability as there are fewer transition hops, that is,
    the client just has to invoke the registry and the registry will redirect to the
    microservice as per their needs.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能和可用性，因为转换跳数较少，也就是说，客户端只需调用注册表，注册表将根据其需求重定向到微服务。
- en: This pattern is fairly simple and highly resilient as besides the service registry
    there are no moving parts. As the client knows about available microservices,
    they can make intelligent decisions easily such as to use a hash, when to trigger
    auto-scaling, and so on.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式相当简单且高度具有弹性，因为除了服务注册表外没有其他移动部分。由于客户端了解可用的微服务，他们可以轻松地做出智能决策，例如何时使用哈希，何时触发自动扩展等。
- en: One significant drawback of using this mode of service discovery is implementation
    of client-side service discovery logic has to be done in every programming language
    of the framework that is used by the service clients. For example, Java, JavaScript,
    Scala, Node.js, Ruby, and so on.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此服务发现模式的一个重大缺点是，必须在服务客户端使用的每种编程语言的框架中实现客户端端服务发现逻辑。例如，Java、JavaScript、Scala、Node.js、Ruby等。
- en: Registration patterns – self-registration
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册模式-自注册
- en: While using this pattern, any microservice instance is responsible for registering
    and deregistering itself from the maintained service registry. To maintain health
    checks, a service instance sends heartbeat requests to prevent its registry from
    expiring. Netflix uses a similar approach and has outsourced their Eureka library,
    which handles all aspects of service registration and deregistration. It has its
    client in Java as well as Node.js. The Node.js client (`eureka-js-client`) has
    more than 12,000 downloads a month. The self-registration pattern has major benefits,
    such as any microservice instance would know its own state, hence it can implement
    or shift to other modes easily such as **Starting**, **Available**, and others.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此模式时，任何微服务实例都负责从维护的服务注册表中注册和注销自己。为了维护健康检查，服务实例发送心跳请求以防止其注册表过期。Netflix使用了类似的方法，并已外包了他们的Eureka库，该库处理了服务注册和注销的所有方面。它在Java中有自己的客户端，也有Node.js。Node.js客户端（`eureka-js-client`）每月下载量超过12,000次。自注册模式具有重大优势，例如任何微服务实例都将知道自己的状态，因此可以轻松实现或切换到其他模式，例如**启动**、**可用**等。
- en: 'However, it also has the following drawbacks:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但它也有以下缺点：
- en: It couples the service tightly to the self-service registry, which forces us
    to enable the service registration code in each language we are using in the framework
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将服务紧密耦合到自服务注册表，这迫使我们在框架中使用的每种语言中启用服务注册代码
- en: Any microservice that is in running mode, but is not able to handle requests,
    will often be unaware of which state to pursue, and will often end up forgetting
    to unregister from the registry
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何运行中但无法处理请求的微服务通常会不知道要追求哪种状态，并且通常最终会忘记从注册表中注销
- en: Data management
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据管理
- en: Another important question in microservice design aspect is the database architecture
    in a microservices application. We will see various options such as whether to
    maintain a private datastore, managing transactions, and making querying datastores
    easy in distributed systems. An initial thought can be going with a single database,
    but if we give it deep thought, we will soon see it as an unwise and unfitting
    solution because of tight coupling, different requirements, and runtime blocking
    by any of the services.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务设计方面的另一个重要问题是微服务应用程序中的数据库架构。我们将看到各种选项，例如是否维护私有数据存储，管理事务以及在分布式系统中轻松查询数据存储。最初的想法可能是使用单个数据库，但是如果我们深入思考，很快就会发现这是一个不明智且不合适的解决方案，因为它会导致紧密耦合、不同的需求以及任何服务的运行时阻塞。
- en: Database per service
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个服务一个数据库
- en: In a distributed microservices architecture, different services have needs and
    usages of different storage requirements. The relational database is a perfect
    choice when it comes to maintaining relations and having complex queries. NoSQL
    databases such as MongoDB is the best choice when there is unstructured complex
    data. Some may require graph data and thus use *Neo4j* or *GraphQL*. The solution
    is to keep each of the microservices data private to that service and get it accessible
    only via APIs. Each microservice maintains its datastore and is a private part
    of that service implementation and hence it is not directly accessible by other
    services.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式微服务架构中，不同的服务具有不同的存储需求和使用情况。关系型数据库在维护关系和进行复杂查询时是一个完美的选择。当存在非结构化复杂数据时，NoSQL数据库如MongoDB是最佳选择。有些可能需要图形数据，因此使用Neo4j或GraphQL。解决方案是将每个微服务的数据保持私有，并且只能通过API访问。每个微服务都维护其数据存储，并且是该服务实现的私有部分，因此其他服务无法直接访问。
- en: 'Some of the options you have while implementing this mode of data management
    are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施这种数据管理模式时，您可以选择以下一些选项：
- en: '**Private tables/collections per service**: Each microservice has a set of
    defined tables or collections that can only be accessed by that service'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务都有一组定义的表或集合，只能由该服务访问
- en: '**Schema per service**: Each service has a schema that can only be accessed
    via the microservice it is bound to'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都有一个模式，只能通过其绑定的微服务访问
- en: '**Database per service**: Each microservice maintains its own database as per
    its needs and requirements'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务维护自己的数据库，根据自己的需求和要求
- en: 'When thought of, maintaining a schema per service seems to be the most logical
    solution as it will have lower overhead and ownership can clearly be made visible.
    If some services have high usage and throughput and different usage, then maintaining
    a separate database is the logical option. A necessary step is to add barriers
    that will restrict any microservice from accessing data directly. Various options
    to add this barrier include assigning user IDs with restricted privileges or accessing
    control mechanisms such as grants. This pattern has the following advantages:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑到，每个服务维护一个模式似乎是最合乎逻辑的解决方案，因为它将具有较低的开销，并且所有权可以清晰可见。如果一些服务具有高使用率和吞吐量，并且具有不同的使用情况，那么维护单独的数据库是合乎逻辑的选择。一个必要的步骤是添加障碍，以限制任何微服务直接访问数据。添加此障碍的各种选项包括分配具有受限权限的用户ID或访问控制机制，例如授予。这种模式具有以下优点：
- en: Loosely coupled services that can stand on their own; changes to one service's
    datastore won't affect any other services.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合的服务可以独立运行；对一个服务的数据存储的更改不会影响任何其他服务。
- en: Each service has the liberty to select the datastore as required. Each microservice
    has the option of whether to go for relational or non-relational databases as
    per need. For example, any service that needs intensive search results on text
    may go for **Solr** or **Elasticsearch**, whereas any service where there is structured
    data may go for any SQL database.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都有自由选择所需的数据存储。每个微服务都可以根据需要选择关系型或非关系型数据库。例如，任何需要对文本进行密集搜索结果的服务可能会选择Solr或Elasticsearch，而任何需要结构化数据的服务可能会选择任何SQL数据库。
- en: 'This pattern has the following drawbacks and upcomings that need to be handled
    with care:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式具有以下需要小心处理的缺点和优点：
- en: Handling complex scenarios that involve transactions spanning across multiple
    services. The CAP theorem states that it is impossible to have more than two out
    of the following three guarantees—consistency, availability, and partitions in
    the distributed datastore, so transactions are generally avoided.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理涉及跨多个服务的事务的复杂场景。CAP定理指出，在分布式数据存储中不可能同时满足一致性、可用性和分区中的三个保证中的超过两个，因此通常避免事务。
- en: Queries ranging across multiple databases are challenging and resource consuming.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨多个数据库的查询具有挑战性且消耗资源。
- en: The complexity of managing multiple SQL and non-SQL datastores.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多个SQL和非SQL数据存储的复杂性。
- en: 'To overcome the drawbacks, the following patterns are used while maintaining
    a database per service:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服缺点，在维护每个服务的数据库时使用以下模式：
- en: '**Sagas**: A saga is defined as a batch sequence of local transactions. Each
    entry in the batch updates the specified database and moves on by publishing a
    message or triggering an event for the next entry in the batch to happen. If any
    entry in the batch fails locally or any business rule is violated, then the saga
    executes a series of compensating transactions that compensate or undo the changes
    that were made by the saga batch updates.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Saga**：一个saga被定义为一批本地事务的序列。批中的每个条目都会更新指定的数据库，并通过发布消息或触发下一个批次中的事件来继续。如果批中的任何条目在本地失败，或者违反了任何业务规则，那么saga将执行一系列补偿事务，以补偿或撤消批次更新所做的更改。'
- en: '**API Composition**: This pattern insists that the application should perform
    the join rather than the database. As an example, a service is dedicated to query
    composition. So, if we want to fetch monthly product distributions, then we first
    retrieve the products from the product service and then query the distribution
    service to return the distribution information of the retrieved products.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API组合**：这种模式坚持认为应用程序应该执行连接而不是数据库。举个例子，一个服务专门用于查询组合。因此，如果我们想要获取每月产品分布，那么我们首先从产品服务中检索产品，然后查询分布服务以返回检索到的产品的分布信息。'
- en: '**Command Query Responsibility Segregation (CQRS)**: The principle of this
    pattern is to have one or more evolving views, which usually have data coming
    from various services. Fundamentally, it splits the application into two parts—the
    command or the operating side and the query or the executor side. It is more of
    a publisher-subscriber pattern where the command side operates create/update/delete
    requests and emits events whenever the data changes. The executor side listens
    for those events and handles those queries by maintaining views that are kept
    up to date, based on the subscription of events that are emitted by the command
    or operating side.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令查询责任分离（CQRS）**：这种模式的原则是有一个或多个不断发展的视图，通常这些视图的数据来自各种服务。基本上，它将应用程序分为两部分——命令或操作方和查询或执行方。这更像是一个发布-订阅模式，其中命令方操作创建/更新/删除请求，并在数据发生变化时发出事件。执行方监听这些事件，并通过维护视图来处理这些查询，这些视图根据命令或操作方发出的事件的订阅而保持最新。'
- en: Sharing concerns
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享关注点
- en: The next big thing in distributed microservice architecture to handle is sharing
    concerns. How will general things such as API routing, security, logging, and
    configurations work? Let's look at those points one by one.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式微服务架构中的下一个重要问题是如何处理共享关注点。诸如API路由、安全性、日志记录和配置等一般事务将如何工作？让我们逐一看看这些要点。
- en: Externalized configuration
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部化配置
- en: An application usually uses one or many infrastructures third-party services
    such as a service registry, message broker, server, cloud deployment platform,
    and so on. Any service must be able to run in multiple environments without any
    modifications. It should have the ability to pick up external configurations.
    This pattern is more of a guideline that advises us to externalize all the configurations,
    including database information, environment info, network location, and so on,
    that create a startup service that reads this information and prepares the application
    accordingly. There are various options available. Node.js provides setting environment
    variables; if you use Docker, then it has the `docker-compose.yml` file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序通常会使用一个或多个基础设施的第三方服务，比如服务注册表、消息代理、服务器、云部署平台等等。任何服务都必须能够在多个环境中运行，而不需要进行任何修改。它应该具有获取外部配置的能力。这种模式更多地是一个指导方针，建议我们将所有配置外部化，包括数据库信息、环境信息、网络位置等，创建一个启动服务来读取这些信息并相应地准备应用程序。有各种可用的选项。Node.js提供设置环境变量；如果您使用Docker，那么它有`docker-compose.yml`文件。
- en: Observability
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观测性
- en: Revisiting the twelve-factor's required for an application, we observe that
    any application needs some centralized features, even if it's distributed. These
    centralized features help us to have proper monitoring and debugging in case of
    issues. Let's look at some of the common observability parameters to look out
    for.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视应用程序所需的十二要素，我们可以观察到，即使是分布式的，任何应用程序都需要一些集中的功能。这些集中的功能帮助我们在出现问题时进行适当的监控和调试。让我们看一些常见的可观测性参数。
- en: Log aggregation
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志聚合
- en: Each service instance will generate information about what it is doing in a
    standardized format, which contains logs at various levels such as errors, warning,
    info, debug, trace, fatal, and so on. The solution is to use a centralized logging
    service that collects logs from each service instance and stores them in some
    common place where the user can search and analyze the logs. This enables us to
    configure alerts for certain kinds of logs. Also, a centralized service will help
    to do audit logging, exception tracking, and API metrics. Available and widely
    used frameworks are **Elastic Stack** (Elasticsearch, Logstash, Kibana), **AWS
    CloudTrail**, and **AWS CloudWatch**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务实例都会以标准化格式生成有关其正在执行的操作的信息，其中包含各种级别的日志，如错误、警告、信息、调试、跟踪、致命等。解决方案是使用集中式日志服务，从每个服务实例收集日志并将其存储在用户可以搜索和分析日志的某个常见位置。这使我们能够为某些类型的日志配置警报。此外，集中式服务还将有助于进行审计日志记录、异常跟踪和API指标。可用且广泛使用的框架包括Elastic
    Stack（Elasticsearch、Logstash、Kibana）、AWS CloudTrail和AWS CloudWatch。
- en: Distributed tracing
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: The next big problem is to understand the behavior and application so as to
    troubleshoot problems when required. This pattern is more of a designing guideline
    that states to maintain a unique external request ID, which is maintained by a
    microservice. This external request ID needs to be passed to all services that
    are involved in handling that request and in all the log messages. Another guideline
    is to include the start time and end time of requests and operations performed
    when a microservice does the operation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重大问题是理解行为和应用程序，以便在需要时解决问题。这种模式更像是一个设计指南，指出要维护一个由微服务维护的唯一外部请求ID。这个外部请求ID需要传递给处理该请求的所有服务以及所有日志消息。另一个指南是在微服务执行操作时包括请求和操作的开始时间和结束时间。
- en: Based on the preceding design aspects, we will see common microservice design
    patterns and understand each pattern in depth. We'll see when to use a particular
    pattern, what the problems are that it solves, and what pitfalls to avoid while
    using that design pattern.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前述的设计方面，我们将看到常见的微服务设计模式，并深入了解每种模式。我们将看到何时使用特定模式，它解决了什么问题，以及在使用该设计模式时要避免的陷阱。
- en: Microservice design patterns
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务设计模式
- en: As microservices evolve, so evolves its designing principles. Here are some
    of the common design patterns that help to design an efficient and scalable system.
    Some of the patterns are followed by Facebook, Netflix, Twitter, LinkedIn, and
    so on, which provide some of the most scalable architectures.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务的发展，其设计原则也在不断发展。以下是一些常见的设计模式，可以帮助设计高效和可扩展的系统。Facebook、Netflix、Twitter、LinkedIn等公司遵循了一些模式，提供了一些最可扩展的架构。
- en: Asynchronous messaging microservice design pattern
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步消息传递微服务设计模式
- en: 'One of the most important things to consider in a distributed system is **state**.
    Although highly powerful REST APIs, it has a very primitive flaw of being synchronous
    and thus blocking. This pattern is about achieving a non-blocking state and asynchronicity
    to maintain the same state across the whole application reliably, avoid data corruption,
    and allow a faster rate of change across the application:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中需要考虑的最重要的事情之一是**状态**。尽管REST API功能强大，但它有一个非常原始的缺陷，即同步和阻塞。这种模式是关于实现非阻塞状态和异步性，以可靠地在整个应用程序中保持相同的状态，避免数据损坏，并允许应用程序快速变化的速度：
- en: '**Problem**: Speaking contextually, if we go with the principle of single responsibility,
    a model or an entity in the application can mean something different to different
    microservices. So, whenever any change occurs, we need to ensure that different
    models are in sync with those changes. This pattern helps to solve this issue
    with the help of asynchronous messaging. In order to ensure data integrity throughout,
    there is a need to replicate the state of key business data and business events
    between microservices or datastores.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：在特定上下文中，如果我们遵循单一责任原则，应用程序中的模型或实体可能对不同的微服务意味着不同的东西。因此，每当发生任何更改时，我们需要确保不同的模型与这些更改同步。这种模式通过异步消息传递来解决这个问题。为了确保整个过程中的数据完整性，需要在微服务或数据存储之间复制关键业务数据和业务事件的状态。'
- en: '**Solution**: Since it''s asynchronous communication, the client or the caller
    assumes that the message won''t be received immediately, carries on and attaches
    a callback to the service. The callback is for when the response is received what
    further operation to be carried on. A lightweight message broker (not to be confused
    with orchestrators used in SOA) is preferably used. The message broker is dumb,
    that is, they are ignorant of the application state. They communicate to services
    handling events, but they never handle events. Some of the widely adopted examples
    include RabbitMQ, the Azure bus, and so on. Instagram''s feed is powered by this
    simple RabbitMQ. Based on the complexity of the project, you can introduce either
    a single receiver or multiple receivers. While a single receiver is good, soon
    it can be the single point of failure. A better approach is going reactive and
    introducing the publish-subscribe pattern of communication. That way the communication
    from the sender will be available to subscriber microservices in one go. Practically,
    when we consider a routine scenario, an update in any of the models will trigger
    an event to all its subscribers, which may further trigger the change in their
    own models. To avoid this, event bus is generally introduced in such type of a
    pattern that can fulfill the role of inter micro service communication and act
    as the message broker. Some of the commonly available libraries are **AMQP**,
    **RabbitMQ**, **NserviceBus**, **MassTransit**, and so on for scalable architecture.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案：**由于这是异步通信，客户端或调用者假设消息不会立即收到，继续并将回调附加到服务。回调是为了在接收到响应时进行进一步操作。最好使用轻量级消息代理（不要与SOA中使用的编排器混淆）。消息代理是愚蠢的，也就是说，它们对应用程序状态一无所知。它们与处理事件的服务通信，但它们从不处理事件。一些广泛采用的示例包括RabbitMQ、Azure总线等。Instagram的动态由这个简单的RabbitMQ提供动力。根据项目的复杂性，您可以引入单个接收器或多个接收器。单个接收器虽然不错，但很快就可能成为单点故障。更好的方法是采用响应式并引入发布-订阅通信模式。这样，发送方的通信将一次性提供给订阅微服务。实际上，当我们考虑常规情况时，对模型的任何更新都将触发所有订阅者的事件，这可能进一步触发它们自己模型的更改。为了避免这种情况，事件总线通常在这种类型的模式中引入，可以充当微服务之间的通信角色并充当消息代理。一些常见的可用库包括**AMQP**、**RabbitMQ**、**NserviceBus**、**MassTransit**等，用于可扩展的架构。'
- en: Here is an example using AMQP:  [https://gist.github.com/parthghiya/114a6e19208d0adca7bda6744c6de23e](https://gist.github.com/parthghiya/114a6e19208d0adca7bda6744c6de23e).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用AMQP的示例：[https://gist.github.com/parthghiya/114a6e19208d0adca7bda6744c6de23e](https://gist.github.com/parthghiya/114a6e19208d0adca7bda6744c6de23e)。
- en: '**Take care of:** To successfully implement this design, the following aspects
    should be considered:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意：**要成功实现这个设计，应考虑以下几个方面：'
- en: When you need high scalability, or your current domain is already a message-based
    domain, then preference should be given to message-based commands over HTTP.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要高可伸缩性，或者您当前的领域已经是基于消息的领域时，应优先考虑基于消息的命令而不是HTTP。
- en: Publishing events across microservices, as well as changing the state in the
    original microservices.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务之间发布事件，以及在原始微服务中更改状态。
- en: Make sure that events are communicated across; mimicking the event would be
    a very bad design pattern.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保事件是跨越通信的；模仿事件将是一个非常糟糕的设计模式。
- en: Maintain the position of the subscriber's consumer to scale up performance.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持订阅者的消费者位置以提高性能。
- en: When to make a rest call and when to use a messaging call. As HTTP is a synchronous
    call, it should be used only when needed.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时进行REST调用，何时使用消息调用。由于HTTP是同步调用，只有在需要时才应使用。
- en: '**When to use:** This is one of the most commonly used patterns. Based on the
    following use cases, you can use this pattern or its variants as per your requirements:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时使用：**这是最常用的模式之一。根据以下用例，您可以根据自己的需求使用这种模式或其变体：'
- en: When you want to use real-time streaming, use the *Event Firehouse* pattern,
    which has *KAFKA* as one of its key components.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您想要使用实时流时，使用*Event Firehouse*模式，其中*KAFKA*是其关键组件之一。
- en: When your complex system is orchestrated in various services, one of the variants
    of this system, RabbitMQ, is extremely helpful.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您的复杂系统是由各种服务编排时，该系统的变体之一，RabbitMQ，非常有帮助。
- en: Often, instead of subscribing to services, directly subscribing to the datastore
    is advantageous. In such a case use, *GemFire* or *Apache GeoCode* following this
    pattern is helpful.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，直接订阅数据存储而不是服务订阅是有利的。在这种情况下，使用*GemFire*或*Apache GeoCode*遵循这种模式是有帮助的。
- en: '**When not to use:** In the following scenarios, this pattern is less recommended:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适用于：**在以下情况下，不推荐使用这种模式：'
- en: When you have heavy database operations during event transmission, as database
    calls are synchronous
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事件传输期间有大量数据库操作时，因为数据库调用是同步的。
- en: When your services are coupled
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您的服务是耦合的
- en: When you don't have standard ways defined to handle data conflict situations
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您没有定义处理数据冲突情况的标准方式时
- en: Backend for frontends
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端后端
- en: 'The current world demands a mobile-first approach everywhere. The service may
    respond differently to mobile where it has to show little content, as it has very
    less content. On the web, it has to show huge content as lots of space is available.
    Scenarios may differ drastically based on the device. As for example in the mobile
    app, we may allow barcode scanner, but in desktop, it is not a wise option. This
    pattern addresses these issues and helps to effectively design microservices across
    multiple interfaces:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的世界要求在任何地方都采用移动优先的方法。服务可能会对移动设备和网页作出不同的响应，在移动设备上，它可能只显示少量内容，因为内容很少。在网页上，它可能要显示大量内容，因为有很多空间。根据设备，情景可能会有很大的不同。例如，在移动应用中，我们可能允许条形码扫描，但在桌面上，这不是一个明智的选择。这种模式解决了这些问题，并有助于有效地设计跨多个接口的微服务：
- en: '**Problem**: With the advent of development of services supporting multiple
    interfaces, it becomes extremely painful to manage everything in one service.
    This constantly evolves change in any of the single interfaces; the need to keep
    services working in all interfaces can soon become a bottleneck and a pain to
    maintain.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：随着支持多个接口的服务的发展，管理一个服务中的所有内容变得非常痛苦。任何单个接口的不断变化都可能很快成为一个瓶颈和难以维护的问题。'
- en: '**Solution**: Rather than maintaining a general purpose API, design one backend
    per user experience or interface, better termed as a backend for frontend (**BFFs**).
    The BFF is tightly bound to a single interface or specific user experience and
    is maintained by their specific teams so as to easily adapt to new change. While
    implementing this pattern, one of  the common concerns that occurs is maintaining
    the number of BFFs. A more generic solution would be separating concerns and having
    each BFF handle its own responsibility.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：与维护通用API不同，为每个用户体验或接口设计一个后端，更好地称为前端的后端（**BFFs**）。BFF与单个接口或特定用户体验紧密相关，并由其特定团队维护，以便轻松适应新变化。在实施这种模式时，经常出现的一个问题是维护BFF的数量。更通用的解决方案是分离关注点，并让每个BFF处理自己的责任。'
- en: '**Take care of**: While implementing this design pattern, the following points
    should be taken care of as they are the most common pitfalls:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意**：在实施这种设计模式时，应注意以下几点，因为它们是最常见的陷阱：'
- en: A fair consideration of the amount of BFFs to be maintained. A new BFF should
    only be created when concerns across a generally available service can be separated
    out for a specific interface.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要考虑要维护的BFF数量。只有在可以将通用服务的关注点分离出特定接口时，才应创建新的BFF。
- en: A BFF should only contain client/interface-specific code to avoid code duplication.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BFF应该只包含客户端/接口特定的代码，以避免代码重复。
- en: Divide responsibilities across teams for maintaining BFFs.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在团队之间分配BFF的维护责任。
- en: This should not be confused with a **Shim**, a converter to the convert to interface-specific
    format required for that type of interface.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不应该与**Shim**混淆，它是一个转换器，用于将转换为特定接口格式所需的类型接口。
- en: '**When to use**: This pattern is extremely useful in the following scenarios:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时使用**：在以下情况下，这种模式非常有用：'
- en: There are varying differences in a general-purpose backend service across multiple
    interfaces and there are multiple updates at any point in time in a single interface.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用后端服务在多个接口之间存在差异，并且在单个接口中可能会有多个更新。
- en: You want to optimize a single interface and not disturb the utility across other
    interfaces.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望优化单个接口，而不会干扰其他接口的效用。
- en: There are various teams, and implement an alternative language for a specific
    interface and you want to maintain it separately.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有各种团队，并且要为特定接口实现另一种语言，并且希望将其单独维护。
- en: '**When not to use**: While this pattern does solve lots of issues, this pattern
    is not recommended in the following scenarios:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适用于以下情况**：虽然这种模式解决了许多问题，但在以下情况下不建议使用这种模式：'
- en: Do not use this pattern to handle generic parameter concerns such as authentication,
    security, or authorization. This would just increase latency.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用此模式来处理通用参数问题，如身份验证、安全性或授权。这只会增加延迟。
- en: If the cost of deploying an extra service is too high.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果部署额外服务的成本太高。
- en: When interfaces make the same requests and there is not much difference between
    them.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接口发出相同的请求并且它们之间没有太大的区别时。
- en: When there is only one interface and support for multiple interfaces is not
    there, a BFF won't make much sense.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当只有一个接口，不支持多个接口时，BFF就没有太多意义。
- en: Gateway aggregation and offloading
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关聚合和卸载
- en: 'Dump or move specialized, common services and functionalities to a gateway.
    This pattern can introduce simplicity by moving shared functionality into a single
    part. Shared functionality can include things such as the use of SSL certificates,
    authentication, and authorization. A gateway can further be used to join multiple
    requests into a single request. This pattern simplifies needs where a client has
    to make multiple calls to different microservices for some operation:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将专门的、常见的服务和功能转储或移动到网关。通过将共享功能移入单一部分，这种模式可以引入简单性。共享功能可以包括SSL证书的使用、身份验证和授权。网关还可以用于将多个请求合并为单个请求。这种模式简化了客户端必须对不同的微服务进行多次调用的需求：
- en: '**Problem**: Often, to perform a simple task, a client may need to make multiple
    HTTP calls to various different microservices. Too many calls to a server requires
    an increase in resources, memory, and threads, which adversely affects performance
    and scalability. Many features are commonly used across multiple services; an
    authentication service and a product checkout service are both going to use the
    log in the same way. This service requires configuration and maintenance. Also,
    these type of services need an extra set of eyes as they are essential. For example,
    token validation, HTTPS certificate, encryption, authorization, and authentication.
    With each deployment, it is difficult to manage that as it has to span across
    the whole system.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：通常，为了执行简单的任务，客户端可能需要向各种不同的微服务发出多个HTTP调用。向服务器发出太多调用会增加资源、内存和线程，从而对性能和可伸缩性产生不利影响。许多功能通常在多个服务中共同使用；身份验证服务和产品结账服务都会以相同的方式使用登录。这种服务需要配置和维护。此类服务还需要额外的关注，因为它们是必不可少的。例如，令牌验证、HTTPS证书、加密、授权和身份验证。随着每次部署，跨整个系统进行管理变得困难。'
- en: '**Solution:** The two major components in this design pattern are the gateway
    and gateway aggregator. The gateway aggregator should always be placed behind
    the gateway. Hence, single responsibility is achieved, with each component doing
    the operation they are meant to do.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：这种设计模式中的两个主要组件是网关和网关聚合器。网关聚合器应始终放置在网关后面。因此，实现了单一责任，每个组件都执行其预定的操作。'
- en: '**Gateway: **It offloads some of the common operations such as certificate
    management, authentication, SSL termination, cache, protocol translation, and
    so on to one single place. It simplifies the development and abstracts all this
    logic in one place and speeds up development in a huge organization where not
    everyone has access to the gateway, only specialized teams work on it. It maintains
    consistency throughout the application. The gateway can ensure a minimum amount
    of logging and thus help out to find the faulty microservice. It''s much like
    the facade pattern in object-oriented programming. It acts as the following:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网关：**它将一些常见操作，如证书管理，认证，SSL终止，缓存，协议转换等，转移到一个地方。它简化了开发，并将所有这些逻辑抽象到一个地方，加快了在一个大型组织中的开发，不是每个人都能访问网关，只有专门的团队才能使用它。它在整个应用程序中保持一致性。网关可以确保最少量的日志记录，从而帮助找到有问题的微服务。这很像面向对象编程中的外观模式。它的作用如下：'
- en: Filter
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器
- en: Single entry point that exposes various microservices
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露各种微服务的单一入口点
- en: Solution to a common operation such as authorization, authentication, central
    configuration, and so on, abstracting this logic into a single place
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决常见操作，比如授权，认证，中央配置等，将这些逻辑抽象成一个地方
- en: Router for traffic management and monitoring
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器用于流量管理和监控
- en: 'Netflix uses a similar approach and they are able to handle more than 50,000
    requests per hour and they open sourced **ZuuL**:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix使用了类似的方法，他们能够处理超过每小时50,000个请求，并且他们开源了ZuuL：
- en: '**Gateway aggregator**: It receives the client request, then it decides to
    which different systems it has to dispatch the client request, gets the results,
    and then aggregates and sends them back to the client. For the client, it is just
    one request. Overall round trips between client and server are reduced.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网关聚合器：**它接收客户端请求，然后决定要将客户端请求分派给哪些不同的系统，获取结果，然后将它们聚合并发送回客户端。对于客户端来说，这只是一个请求。客户端和服务器之间的总往返次数减少了。'
- en: 'Here is an example for aggregator: [https://gist.github.com/parthghiya/3f1c3428b1cf3cc6d76ddd18b4521e03.js](https://gist.github.com/parthghiya/3f1c3428b1cf3cc6d76ddd18b4521e03.js)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个聚合器的例子：[https://gist.github.com/parthghiya/3f1c3428b1cf3cc6d76ddd18b4521e03.js](https://gist.github.com/parthghiya/3f1c3428b1cf3cc6d76ddd18b4521e03.js)
- en: '**Take care of**: The following pitfalls should be properly handled in order
    to successfully implement this design pattern in microservices:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意**：为了成功实现微服务中的这种设计模式，应该正确处理以下陷阱：'
- en: Do not introduce service coupling, that is, the gateway can exist independently,
    without other service consumers or service implementers.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要引入服务耦合，也就是说，网关可以独立存在，没有其他服务消费者或服务实现者。
- en: Here, every microservice will be dependent on the gateway. Hence, the network
    latency should be as low as possible.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，每个微服务都将依赖于网关。因此，网络延迟应该尽可能低。
- en: Make sure to have multiple instances of the gateway, as only a single instance
    of the gateway may introduce it as a single point of failure.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保网关有多个实例，因为只有一个网关实例可能会引入单点故障。
- en: Each of the requests goes through the gateway. Hence, it should be ensured that
    gateway has efficient memory and adequate performance, and can be easily scaled
    to handle the load. Have one round of load testing to make sure that it is able
    to handle bulk load.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求都经过网关。因此，应该确保网关具有高效的内存和足够的性能，并且可以轻松扩展以处理负载。进行一轮负载测试，确保它能够处理大量负载。
- en: Introduce other design patterns such as bulkheads, retry, throttle, and timeout
    for efficient design.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入其他设计模式，如舱壁、重试、节流和超时，以实现高效的设计。
- en: The gateway should handle logic such as the number of retries, waiting for service
    until.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关应该处理逻辑，比如重试次数，等待服务直到。
- en: The cache layer should be handled, which can improve performance.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该处理缓存层，这可以提高性能。
- en: The gateway aggregator should be behind the gateway, as the request aggregator
    will have another. Combining them in a gateway will likely impact the gateway
    and its functionalities.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关聚合器应该在网关后面，因为请求聚合器将有另一个。将它们合并在一个网关中可能会影响网关及其功能。
- en: While using the asynchronous approach, you will find yourself smacked by too
    many promises of callback hell. Go with the reactive approach, a more declarative
    style. Reactive programming is prevalent from Java to Node.js to Android. You
    can check out this link for reactive extensions across different links: [https://github.com/reactivex](https://github.com/reactivex).
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用异步方法时，你会发现自己被太多的回调地狱所困扰。采用响应式方法，更具有声明性风格。响应式编程在从Java到Node.js到Android都很普遍。你可以查看这个链接，了解不同链接上的响应式扩展：[https://github.com/reactivex](https://github.com/reactivex)。
- en: Business logic should not be there in the gateway.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑不应该在网关中。
- en: '**When to use**: This pattern should be used in the following scenarios:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时使用**：在以下情况下应该使用这种模式：'
- en: There are multiple microservices across and a client needs to communicate with
    multiple microservices.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多个微服务，客户端需要与多个微服务通信。
- en: Want to reduce the frequent network calls when the client is in lesser range
    network or cellular network. Breaking it in one request is efficient as then the
    frontend or the gateway will only have to cache one request.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端在较小范围的网络或蜂窝网络中时，想要减少频繁的网络调用。将其分解为一个请求是有效的，因为这样前端或网关只需要缓存一个请求。
- en: When you want to encapsulate the internal structure or introduce an abstract
    layer to a large team present in your organization.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要封装内部结构或向你组织中存在的大团队引入一个抽象层时。
- en: '**When not to use**: The following scenarios are when this pattern won''t be
    a good fit:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适用于**：以下情况是这种模式不适合的情况：'
- en: When you just want to reduce the network calls. You cannot introduce a whole
    level of complexity for just that need.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你只想减少网络调用时。你不能为了满足这个需求引入整个层级的复杂性。
- en: The latency by the gateway is too much.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关的延迟太大。
- en: You don't have asynchronous options in the gateway. Your system makes too many
    synchronous calls for operations in the gateway. That would result in a blocking
    system.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在网关中没有异步选项。您的系统对网关中的操作进行了太多同步调用。这将导致阻塞系统。
- en: Your application can't get rid of coupled services.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序无法摆脱耦合的服务。
- en: Proxy routing and throttling
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理路由和节流
- en: When you have multiple microservices that you want to expose across a single
    endpoint and that single endpoint routes to service as per need. This application
    is helpful when you need to handle imminent transient failures and have a retry
    loop on a failed operation, thus improve the stability of the application. This
    pattern is also helpful when you want to handle the consumption of resources used
    by a microservice.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个微服务想要跨单个端点公开，并且该单个端点根据需要路由到服务时。当您需要处理即将发生的瞬态故障并在操作失败时进行重试循环时，这种应用是有帮助的，从而提高了应用的稳定性。当您想要处理微服务使用的资源消耗时，这种模式也是有帮助的。
- en: 'This pattern is used to meet the agreed SLAs and handle loads on resources
    and resource allocation consumption even when an increase in demand places loads
    on resources:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式用于满足约定的SLA，并在需求增加时处理资源负载和资源分配消耗：
- en: '**Problem**: When a client has to consume a multitude of microservices, challenges
    soon turn up such as client managing each endpoint and setting up separate endpoints.
    If you refactor any part of the code in any service then the client must also
    be updated as the client is directly in contact with the endpoint. Further, as
    these services are in the cloud, they have to be fault tolerant. Faults include
    temporary loss of connectivity or unavailability of services. These faults should
    be self-correcting. For example, a database service that is taking a large number
    of concurrent requests should throttle further requests until the memory load
    and resource utilization has decreased. On retrying the request, the operation
    is completed. The load on any application varies drastically on time period. For
    example, a social media chatting platform will have very less load during peak
    office hours and a shopping portal will have extreme load during festive season
    sales. For a system to perform efficiently it has to meet to agreed LSA, once
    it exceeds, subsequent requests needs to be stopped until load consumption has
    decreased.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：当客户端必须消耗大量微服务时，很快就会出现挑战，例如客户端管理每个端点并设置单独的端点。如果您重构任何服务中的任何部分，则客户端也必须更新，因为客户端直接与端点联系。此外，由于这些服务在云中，它们必须具有容错能力。故障包括临时失去连接或服务不可用。这些故障应该是自我纠正的。例如，正在处理大量并发请求的数据库服务应该在内存负载和资源利用率减少之前限制进一步的请求。在重试请求时，操作完成。任何应用程序的负载在时间段上都会有很大的变化。例如，社交媒体聊天平台在高峰办公时间负载很小，而购物门户在节日季销售期间负载很大。为了使系统高效运行，必须满足约定的LSA，一旦超过，需要停止后续请求，直到负载消耗减少。'
- en: '**Solution**: Place gateway layer in front of microservices. This layer includes
    the throttle component, as well as retry, once failed component. With the addition
    of this layer, the client needs only to interact with this gateway rather than
    interacting with each different microservice. It lets you abstract backend calls
    from the client and thus keeping the client end simple as the client only has
    to interact with the gateway. Any number of services can be added, without changing
    the client at any point in time. This pattern can also be used to handle versioning
    effectively. A new version of the microservice can be deployed parallelly and
    the gateway can route too, based on input parameters passed. New changes can be
    easily maintained by just a configuration change at the gateway level. This pattern
    can be used as an alternative strategy to auto-scaling. This layer should allow
    network requests only up to a certain limit and then throttle the request and
    retry once the resources have been released. This will help the system to maintain
    SLAs. The following points should be considered while implementing the throttle
    component:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：将网关层放置在微服务前面。该层包括节流组件以及一旦失败的重试组件。通过添加这一层，客户端只需与该网关交互，而不是与每个不同的微服务交互。它允许您将后端调用从客户端抽象出来，从而使客户端端简单，因为客户端只需与网关交互。任意数量的服务可以添加，而无需在任何时间点更改客户端。这种模式还可以用于有效处理版本控制。可以并行部署微服务的新版本，并且网关可以根据传递的输入参数进行路由。只需在网关级别进行配置更改即可轻松维护新更改。这种模式可以用作自动扩展的替代策略。该层应该仅允许网络请求达到一定限制，然后节流请求并在资源释放后进行重试。这将有助于系统维护SLA。在实施节流组件时应考虑以下几点：'
- en: One of the parameters to consider for throttling is user requests or tenant
    requests. Assuming that a specific tenant or user triggers throttle, then it can
    be safely assumed that there's some issue with the caller.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节流的考虑参数之一是用户请求或租户请求。假设特定租户或用户触发了节流，那么可以安全地假设调用者存在某些问题。
- en: Throttling doesn't essentially mean to stop the requests. Lower quality resources
    if available can be given, for example, a mobile-friendly site, a lower quality
    video, and so on. Google does the same.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节流并不一定意味着停止请求。如果有低质量的资源可用，可以提供，例如，移动友好的网站，低质量的视频等。谷歌也是这样做的。
- en: Maintaining priority over microservices. Based on the priority they can be placed
    in the retry queue. As an ideal solution, three queues can be maintained—cancel,
    retry, and retry-after sometime.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先考虑微服务。根据优先级，它们可以放置在重试队列中。作为理想的解决方案，可以维护三个队列——取消、重试和稍后重试。
- en: '**Take care of**: Given here are some of the most common pitfalls that we can
    come across while successfully implementing this pattern:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意**：在成功实施这种模式时，以下是一些常见的陷阱：'
- en: The gateway can be a single point of failure. Proper steps have to be taken
    to ensure that it has fault tolerant capabilities during development. Also, it
    should be run in multiple instances.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关可能是单点故障。在开发过程中必须采取适当的步骤，确保它具有容错能力。此外，应该运行多个实例。
- en: Gateway should have proper memory and resource allocation otherwise it will
    introduce a bottleneck. Proper load testing should be done to ensure that failures
    are not cascaded.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关应该有适当的内存和资源分配，否则会引入瓶颈。应该进行适当的负载测试，以确保故障不会级联。
- en: Routing can be done based on IP, header, port, URL, request parameter, and so
    on.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以根据IP、标头、端口、URL、请求参数等进行路由。
- en: The retry policy should be crafted very carefully based on the business requirements.
    It's okay in some places to have a please try again rather than having waiting
    periods and retrials. The retry policy may also affect the responsiveness of the
    application.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试策略应该根据业务需求非常小心地制定。在某些地方，可以选择“请重试”而不是等待一段时间和重试。重试策略也可能影响应用程序的响应性。
- en: For effective application, this pattern should be combined with **Circuit Breaker
    Application**.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了有效应用，这种模式应该与**断路器应用程序**相结合。
- en: If service is idempotent, then and only then should it be retried. Trying retrial
    on other services may have unhealthy consequences. For example, if there is a
    payment service that waits for responses from other payment gateways, the retry
    component may think it fails and may send another request and the customer gets
    charged twice.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务是幂等的，那么只有在这种情况下才应该重试。在其他服务上尝试重试可能会产生不良后果。例如，如果有一个支付服务等待其他支付网关的响应，重试组件可能会认为它失败，然后发送另一个请求，导致客户被收取两次费用。
- en: Different exceptions should handle the retry logic accordingly, based on the
    exceptions.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据异常情况，应该相应地处理重试逻辑。
- en: Retry logic should not disturb transaction management. The retry policy should
    be used accordingly.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试逻辑不应干扰事务管理。应根据重试策略使用。
- en: All failures that trigger a retry should be logged and handled properly for
    future scenarios.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有触发重试的失败都应该被记录并妥善处理，以备将来的情况。
- en: An important point to be considered is this is no replacement for exception
    handling. The first priority should be given to exceptions always, as they would
    not introduce an extra layer and add latency.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要考虑的一个重要点是，这并不是异常处理的替代品。始终应该优先考虑异常，因为它们不会引入额外的层并增加延迟。
- en: Throttling should be added early in the system as it's difficult to add once
    the system is implemented; it should be carefully designed.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限流应该尽早添加到系统中，因为一旦系统实施，就很难添加；它应该被精心设计。
- en: Throttling should be performed quickly. It should be smart enough to detect
    an increase in activity and react accordingly by taking appropriate measures.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限流应该快速执行。它应该足够智能，能够检测活动增加并采取适当措施做出相应反应。
- en: Consideration between throttling and auto-scaling should be decided based on
    business requirements.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据业务需求决定限流和自动扩展之间的考虑。
- en: The requests that are throttled should be effectively placed in a queue based
    on priority.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该根据优先级有效地将被限流的请求放入队列中。
- en: '**When to use:** This pattern is very handy in the following scenarios:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时使用：**这种模式在以下情况下非常有用：'
- en: To ensure that agreed LSAs are maintained.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保维护约定的LSA。
- en: To avoid a single microservice consuming the majority of the pool of resources
    and avoid resource depletion by a single microservice.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免单个微服务消耗大部分资源池，并避免单个微服务耗尽资源。
- en: To handle sudden bursts in consumption of microservices.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理微服务消耗突然增加的情况。
- en: To handle transient and short-lived faults.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理瞬态和短暂的故障。
- en: '**When not to use:** In the following scenarios, this pattern should not be
    used:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时不使用：**在以下情况下，不应该使用这种模式：'
- en: Throttling shouldn't be used as a means to handle exceptions.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限流不应该被用作处理异常的手段。
- en: When faults are long-lasting. If this pattern is applied in that case, it will
    severely affect the performance and responsiveness of the application.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当故障持续时间很长时。如果在这种情况下应用这种模式，它将严重影响应用程序的性能和响应性。
- en: Ambassador and sidecar pattern
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大使和边车模式
- en: This pattern is used when we want to segregate common connectivity features
    such as monitoring, logging, routing, security, authentication, authorization,
    and more. It creates helper services that act as ambassadors and sidecars that
    do the objective of sending requests on behalf of a service. It is just another
    proxy that is located outside of the process. Specialized teams can work on it
    and let other people not worry about it so as to provide encapsulation and isolation.
    It also allows the application to be composed of multiple frameworks and technologies.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要分离常见的连接功能，如监视、日志记录、路由、安全性、身份验证、授权等时，就会使用这种模式。它创建了充当大使和边车的辅助服务，以实现代表服务发送请求的目标。它只是位于进程外部的另一个代理。专门的团队可以在此上工作，让其他人不必担心它，以提供封装和隔离。它还允许应用程序由多个框架和技术组成。
- en: 'The sidecar component in this pattern acts just like a sidecar attached to
    a motorcycle. It has the same life cycle as the parent microservice, retires the
    same time a parent microservice does, and it does essential peripheral tasks:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式中的边车组件就像连接到摩托车上的边车一样。它与父微服务具有相同的生命周期，与父微服务一样退役，并且执行基本的外围任务：
- en: '**Solution:** Find a set of operations that are common throughout different
    microservices and place them inside their own container or process, thus providing
    the same interface for these common operations to all frameworks and platforms
    services in the whole system. Add an ambassador layer that acts as a proxy between
    applications and microservices. This ambassador can monitor performance metrics
    such as the amount of latency, the resource usage, and so on. Anything inside
    the ambassador can be maintained independently of the application. An ambassador
    can be deployed as a container, common process, daemon, or windows service. An
    ambassador and sidecar are not part of the microservice, but rather are connected
    to the microservice. Some of the common advantages of this pattern are as follows:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：找到一组在不同微服务中通用的操作，并将它们放在它们自己的容器或进程中，从而为整个系统中的所有框架和平台服务提供相同的接口。添加一个充当应用程序和微服务之间代理的大使层。这个大使可以监视性能指标，比如延迟量、资源使用等。大使内的任何内容都可以独立于应用程序进行维护。大使可以部署为容器、常见进程、守护进程或Windows服务。大使和侧车不是微服务的一部分，而是连接到微服务的一部分。这种模式的一些常见优势如下：'
- en: Language-independent development of the sidecar and ambassador, that is, you
    don't have to build a sidecar and ambassador for every language you have in your
    architecture.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与语言无关的开发侧车和大使，也就是说，你不必为架构中的每种语言构建侧车和大使。
- en: Just part of the host, so it can access the same resources as any other microservice
    can.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只是主机的一部分，因此它可以访问与任何其他微服务相同的资源。
- en: Due to connection with microservices, there hardly is any latency
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于与微服务的连接，几乎没有延迟
- en: 'Netflix uses a similar approach and they have open sourced their tool **Prana**
    ([https://github.com/Netflix/Prana](https://github.com/Netflix/Prana)). Take a
    look at the following diagram:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix使用了类似的方法，并且他们已经开源了他们的工具**Prana** ([https://github.com/Netflix/Prana](https://github.com/Netflix/Prana))。看一下下面的图表：
- en: '![](img/ef58f302-8dad-4ec6-8c1d-7bdd0d3b7a9b.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef58f302-8dad-4ec6-8c1d-7bdd0d3b7a9b.jpg)'
- en: '**Take care of**: The following points should be taken care of as they are
    the most common pitfalls:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意事项**：应该注意以下几点，因为它们是最常见的陷阱：'
- en: The ambassador can introduce some latency. Deep thought should be given on whether
    to use a proxy or expose common functionalities as the library.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大使可能会引入一些延迟。应该深思熟虑是否使用代理或将通用功能暴露为库。
- en: Adding generalized functionalities in ambassador and sidecar is beneficial,
    but is it required for all scenarios? For example, consider the number of retries
    to a service, it might not be common for all use cases.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大使和侧车中添加通用功能是有益的，但对于所有情况都是必需的吗？例如，考虑向服务重试的次数，这可能并不适用于所有用例。
- en: The language or framework in which ambassador and sidecar will be built, managed,
    and deployed strategy for it. The decision to create single or multiple instances
    of it based on need.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大使和侧车将构建、管理和部署的语言或框架的策略。根据需要创建单个实例或多个实例的决定。
- en: Flexibility to pass some parameters from service to ambassador and proxy and
    vice versa.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性，可以从服务传递一些参数到大使和代理，反之亦然。
- en: 'The deployment pattern: this is well suited when the ambassador and sidecar
    are deployed in containers.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署模式：当大使和侧车部署在容器中时，这是非常合适的。
- en: The inter-micro service communication pattern should be such that it is framework
    agnostic or language agnostic. This would be beneficial in the long run.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务之间的通信模式应该是框架无关或语言无关的。这在长期来看是有益的。
- en: '**When to use**: This pattern is extremely helpful in the following scenarios:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时使用**：这种模式在以下情况下非常有帮助：'
- en: When there are multiple frameworks and languages involved and you need a common
    set of general features such as client connectivity, logging, and so on throughout
    the application. An ambassador and sidecar can be consumed by any service across
    the application.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及多个框架和语言，并且您需要一组通用功能，例如客户端连接、日志记录等，贯穿整个应用程序。大使和侧车可以被应用程序中的任何服务使用。
- en: Services are owned by different teams or different organizations.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务由不同的团队或不同的组织拥有。
- en: You need independent services for handling this cross-cutting functionality
    and they can be maintained independently.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要独立的服务来处理这些横切功能，并且它们可以独立维护。
- en: When your team is huge and you want specialized teams to handle, manage, and
    maintain core cross-cutting functionalities.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您的团队庞大，您希望专门的团队来处理、管理和维护核心横切功能时。
- en: You need to support the latest connectivity options in a legacy application
    or an application that is difficult to change.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要支持遗留应用程序或难以更改的应用程序中的最新连接选项。
- en: You want to monitor resource consumption across the application and cut off
    a microservice if its resource consumption is huge.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望监视整个应用程序的资源消耗，并在其资源消耗巨大时切断微服务。
- en: '**When not to use**: While this pattern does solve many issues, this pattern
    is not recommended in the following scenarios:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适用于**：虽然这种模式解决了许多问题，但在以下情况下不建议使用这种模式：'
- en: When network latency is utmost. Introducing a proxy layer would introduce some
    overhead that will create a slight delay, which may not be good for real-time
    scenarios.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当网络延迟至关重要时。引入代理层会带来一些开销，这将导致轻微延迟，这对实时情况可能不利。
- en: When connectivity features cannot be generalized and require another level of
    integration and dependency with another service.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当连接功能无法通用化，并且需要与另一个服务进行另一级别的集成和依赖时。
- en: When creating a client library and distributing it to the microservices development
    team as a package.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建客户端库并将其作为软件包分发给微服务开发团队时。
- en: For small applications where introducing an extra layer is actually an overhead.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于引入额外层实际上是一种负担的小型应用程序。
- en: When some services need to scale independently; if so, then the better alternative
    would be to deploy it separately and independently.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一些服务需要独立扩展时；如果是这样，更好的选择是将其单独部署和独立运行。
- en: Anti-corruption microservice design pattern
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反腐微服务设计模式
- en: 'Often, we need interoperability or coexistence between legacy and modern applications.
    This design provides an easy solution for this by introducing a facade between
    modern and legacy applications. This design pattern ensures that the design of
    an application is not hampered or blocked by legacy system dependencies:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要在传统和现代应用程序之间进行互操作或共存。通过在现代和传统应用程序之间引入一个外观，这种设计为此提供了一个简单的解决方案。这种设计模式确保了应用程序的设计不会受到传统系统依赖的阻碍或阻挠：
- en: '**Problem**: New systems or systems in the process of migration often need
    to communicate with the legacy system. The new system''s model and technology
    would probably be different, considering that old systems are usually weak, but
    still, legacy resources may be needed for some operations. Often, these legacy
    systems suffer from poor design and poor schema designs. For interoperability,
    we may still need to support the old system. This pattern is about solving such
    corruption and still have a cleaner, neater, and easier to maintain microservice
    ecosystem.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题：**新系统或正在迁移过程中的系统通常需要与传统系统进行通信。新系统的模型和技术可能会有所不同，考虑到旧系统通常比较薄弱，但仍然可能需要传统资源进行某些操作。通常，这些传统系统的设计和模式设计都很差。为了实现互操作性，我们可能仍然需要支持旧系统。这种模式是为了解决这种腐败，并且仍然拥有一个更清洁、更整洁、更易于维护的微服务生态系统。'
- en: '**Solution:** To avoid using legacy code or a legacy system, design a layer
    that does the following task: acts as the only layer for communicating with legacy
    code, which prevents accessing legacy code directly wherein different people may
    deal with them differently. The core concept is to separate out a legacy or the
    corrupt application by placing an ACL with the objective of not changing the legacy
    layer, and thus avoid compromising its approach or major technological change.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案：**为了避免使用传统代码或传统系统，设计一个层，完成以下任务：作为与传统代码通信的唯一层，防止直接访问传统代码，不同的人可能以不同的方式处理它们。核心概念是通过放置一个ACL来分离传统或腐败应用程序，从而避免改变传统层，并且避免妥协其方法或主要技术变更。'
- en: 'The **anti-corruption layer** (**ACL**) should contain all the logic for translating
    as per new needs from the old model. This layer can be introduced as a separate
    service or translator component any place where needed. A general approach to
    organizing the design of the ACL is a combination of a facade, adapters, translators,
    and communicators to talk to systems. An ACL is used to prevent unexpected behavior
    of an external system from leaking in your existing context:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反腐层**（**ACL**）应该包含根据新需求从旧模型进行翻译的所有逻辑。这一层可以作为一个独立的服务或翻译器组件引入到需要的任何地方。组织ACL设计的一般方法是将外观、适配器、翻译器和通信器结合起来，以与系统进行通信。ACL用于防止外部系统的意外行为泄漏到现有上下文中：'
- en: '![](img/2df4007f-9073-418d-b73b-27df3bd2a54b.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2df4007f-9073-418d-b73b-27df3bd2a54b.png)'
- en: '**Take care of:** While effectively implementing this pattern, the following
    points should be considered as they are some of the major pitfalls:'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意：**在有效实施这种模式时，应考虑以下几点，因为它们是一些主要的陷阱：'
- en: The ACL should be properly scaled and given a better resources pool, as it will
    add latency to calls made between two systems.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACL应该被适当地扩展，并提供更好的资源池，因为它会增加两个系统之间的通话延迟。
- en: Make sure that the corruption layer you introduce is actually an improvement
    and you don't introduce yet another layer of corruption.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您引入的腐败层实际上是一种改进，而不是引入另一层腐败。
- en: The ACL adds an extra service; hence it must be effectively managed and maintained
    and scaled.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACL添加了额外的服务；因此必须进行有效的管理、维护和扩展。
- en: Effectively decide the number of ACLs. There can be many reasons to introduce
    an ACL—a means to translate undesirable formats of the object in required formats
    means to communicate between different languages, and so on.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地确定ACL的数量。引入ACL可能有很多原因——将对象的不良格式转换为所需格式的手段，在不同语言之间进行通信等等。
- en: Effective measures to make sure that transactions and data consistency are maintained
    between both systems and can be monitored.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效措施确保在两个系统之间保持事务和数据一致性，并且可以进行监控。
- en: The duration of the ACL, will it be permanent, how will the communication be
    handled.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACL的持续时间，它会是永久的吗，通信将如何处理。
- en: While an ACL should successfully handle exceptions from the corruption layer,
    it should not completely, otherwise it would be very difficult to preserve any
    information about the original error.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然ACL应该成功处理来自腐败层的异常，但不应完全处理，否则将非常难以保留有关原始错误的任何信息。
- en: '**When to use:** The anti-corruption pattern is highly recommended and extremely
    useful in the following scenarios:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时使用：**在以下情况下，强烈推荐使用反腐模式，并且极其有用：'
- en: There is a huge system up for refactoring from monolithic to microservices and
    there is a phase-by-phase migration planned instead of the big bang migration
    wherein the legacy system and new system need to coexist and communicate with
    each other.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个大型系统需要从单片到微服务进行重构，计划进行分阶段迁移，而不是一次性迁移，其中传统系统和新系统需要共存并相互通信。
- en: If the system that you are undertaking is dealing with any data source whose
    model is undesirable or not in sync with the needed model, this pattern can be
    introduced and it will do the task of translating from undesirable formats to
    needed formats.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在处理任何数据源的系统，其模型是不良的或与所需模型不同步，可以引入这种模式，并且它将完成从不良格式到所需格式的翻译任务。
- en: Whenever there is a need to link two bounded contexts, that is, a system is
    developed by someone else entirely and there is very little understanding of it,
    this pattern can be introduced as a link between systems.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当需要链接两个有界上下文时，也就是说，一个系统是由完全不同的其他人开发的，对它的理解非常有限，这种模式可以作为系统之间的链接引入。
- en: '**When not to use:** This pattern is highly not recommended in the following
    scenarios:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适用于：**在以下情况下，强烈不建议使用这种模式：'
- en: There are no major differences between new and legacy systems. The new system
    can coexist without the legacy system.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新系统和传统系统之间没有主要区别。新系统可以在没有传统系统的情况下共存。
- en: You have lots of transactional operations and maintaining data consistency between
    the ACL and the corrupt layer adds too much latency. In such case, this pattern
    can be merged with other patterns.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有大量的事务操作，并且在ACL和损坏层之间维护数据一致性会增加太多的延迟。在这种情况下，可以将此模式与其他模式合并。
- en: Your organization doesn't have extra teams to maintain and scale the ACL as
    and when needed.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的组织没有额外的团队来在需要时维护和扩展ACL。
- en: Bulkhead design pattern
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分隔设计模式
- en: 'Separate out different services in the microservices application into various
    pools such that if one of the services fails, the others will continue to function
    irrespective of failure. Create a different pool for each microservice to minimize
    the impact:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 将微服务应用程序中的不同服务分开到各种池中，以便如果其中一个服务失败，其他服务将继续运行而不受失败的影响。为每个微服务创建一个不同的池以最小化影响：
- en: '**Problem**: This pattern takes inspiration from sectioned out parts of a ship''s
    hull. If the hull of a ship is damaged, then only the damaged section would fill
    with water, which would prevent the ship from sinking. Let''s say you are connecting
    to various microservices that are using a common thread pool. If one of the services
    starts showing delay, then all pool members will be too exhausted to wait for
    responses. Incrementally, a large number of requests coming from one service would
    deplete available resources. That''s where this pattern suggests a dedicated pool
    for every single service.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：这种模式受到船体的分隔部分的启发。如果一艘船的船体受损，那么只有受损的部分会进水，这将防止船沉没。假设您正在连接各种使用共同线程池的微服务。如果其中一个服务开始显示延迟，那么所有池成员都会过度等待响应。逐渐地，来自一个服务的大量请求会耗尽可用资源。这就是这种模式建议为每个单独的服务提供专用池的地方。'
- en: '**Solution**: Separate service instances into different groups based on load
    and network usage. This allows you to isolate system failures and prevent depletion
    of resources in the connection pool. The essential advantages of this system are
    the prevention of propagating failures and ability to configure capacity of the
    resource pool. For higher priority services, you may assign higher pools.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：根据负载和网络使用情况将单独的服务实例分成不同的组。这样可以隔离系统故障并防止连接池资源耗尽。这个系统的主要优势是防止故障传播和能够配置资源池的容量。对于优先级较高的服务，可以分配更高的池。'
- en: 'For example, given is a sample file from which we can see pool allocation for
    service shopping-management: [https://gist.github.com/parthghiya/be80246cc5792f796760a0d43af935db](https://gist.github.com/parthghiya/be80246cc5792f796760a0d43af935db).'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给出了一个示例文件，我们可以看到服务购物管理的池分配：[https://gist.github.com/parthghiya/be80246cc5792f796760a0d43af935db](https://gist.github.com/parthghiya/be80246cc5792f796760a0d43af935db)。
- en: '**Take care of**: Make sure to take care of the following points to make sure
    that a proper bulkhead design is implemented:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意**：确保注意以下几点，以确保正确实施分隔设计：'
- en: Define proper independent partitions in the application based on business and
    technical requirements.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据业务和技术要求在应用程序中定义适当的独立分区。
- en: Bulkheads can be introduced in forms of thread pools and processes. Decide which
    one is suitable for your application.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分隔可以以线程池和进程的形式引入。决定哪种适合您的应用程序。
- en: Isolation in the deployment of your microservices.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务的部署中进行隔离。
- en: '**When to use:** The bulkhead pattern adds an advantage in the following scenarios:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时使用**：在以下情况下，分隔模式具有优势：'
- en: The application is huge and you want to protect it from cascading or spreading
    failures
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序庞大，您希望保护它免受级联或传播故障的影响
- en: You can isolate critical services from standard services and you can allocate
    separate pools for them
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将关键服务与标准服务隔离，并为它们分配单独的池
- en: '**When not to use:** This pattern is not advisable for the following scenarios:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时不使用**：不建议在以下情况下使用这种模式：'
- en: When you don't have that much budget for maintaining separate overheads in terms
    of cost and management
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你没有足够的预算来维护成本和管理方面的独立开销时
- en: The added level of complexity of maintaining separate pools is not necessary
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护单独的池的额外复杂性是不必要的
- en: Your resources usage is unexpected and you can't isolate your tenants and keep
    a limit on it as it is not acceptable when you would place several tenants in
    one partition
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的资源使用是意外的，您无法隔离您的租户并对其进行限制，因为当您将多个租户放在一个分区中时是不可接受的
- en: Circuit breaker
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器
- en: 'Services sometimes need to collaborate with each other when they need to handle
    requests. In such cases, there is a very high scenario that the other service
    is not available, is showing high latency, or is unusable. This pattern essentially
    solves this issue by introducing a breakage in the circuit that stops propagation
    in the whole architecture:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 有时服务需要相互协作处理请求。在这种情况下，另一个服务不可用、显示高延迟或不可用的可能性非常高。这种模式通过引入断路器来解决这个问题，停止整个架构中的传播：
- en: '**Problem**: In the microservices architecture when there is inter-services
    communication, a remote call needs to be invoked instead of an in-memory call.
    It may so happen that the remote call may fail or reach a timeout limit and hang
    without any response. Now in such cases when there are many callers, then all
    such locked threads that you can run out of resources and the whole system will
    become unresponsive.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：在微服务架构中，当服务之间进行通信时，需要调用远程调用而不是内存调用。可能会出现远程调用失败或达到超时限制而挂起没有任何响应的情况。在这种情况下，如果有很多调用者，那么所有这些被锁定的线程可能会耗尽资源，整个系统将变得无响应。'
- en: '**Solution**: A very primitive idea for solving this issue is introducing a
    wrapper for a protected function call, it monitors for failures. Now this wrapper
    can be triggered via anything such as certain threshold in failures, database
    connection fails, and so on. All further calls will return with an error and stop
    catastrophic propagation. This will trip the circuit open, and while the circuit
    is open, it will avoid making the protected call. The implementation is done in
    the following three stages just as in an electric circuit. It is in three stages:
    **Closed State**, **Open State**, and **Half-Open State**, as explained in the
    following diagram:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：解决这个问题的一个非常原始的想法是引入一个保护函数调用的包装器，它监视失败。现在，这个包装器可以通过任何触发，比如失败的特定阈值、数据库连接失败等。所有进一步的调用都将返回错误并停止灾难性的传播。这将打开断路器，并且在断路器打开时，它将避免进行受保护的调用。实现分为以下三个阶段，就像电路一样。它有三个阶段：**关闭状态**、**打开状态**和**半开状态**，如下图所示：'
- en: '![](img/001feed5-8c17-48d5-b3e8-8b3db679a254.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/001feed5-8c17-48d5-b3e8-8b3db679a254.jpg)'
- en: 'Here is an example for implementation in Node.js: Hystrix is open sourced by
    Netflix [https://gist.github.com/parthghiya/777c2b423c9c8faf0d427fd7a3eeb95b](https://gist.github.com/parthghiya/777c2b423c9c8faf0d427fd7a3eeb95b)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Node.js中实现的示例：Netflix开源了Hystrix [https://gist.github.com/parthghiya/777c2b423c9c8faf0d427fd7a3eeb95b](https://gist.github.com/parthghiya/777c2b423c9c8faf0d427fd7a3eeb95b)
- en: '**Take care of**: The following needs to be taken care of when you want to
    apply the circuit breaker pattern:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意事项**：当您想应用断路器模式时，需要注意以下事项：'
- en: Since you are invoking a remote call, and there may be many remote call invocation
    asynchronous and reactive principles for using future, promises, async, and await
    is must.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于您正在调用远程调用，并且可能有许多远程调用异步和反应性原则，因此必须使用未来、承诺、异步和等待。
- en: Maintain a queue of requests; when your queue is overcrowded, you can easily
    trip the circuit. Always monitor the circuit, as you will often need to activate
    it again for an efficient system. So, have a mechanism ready for reset and failure
    handlers.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护一个请求队列；当您的队列过度拥挤时，您可以轻松地触发断路器。始终监视断路器，因为您经常需要再次激活它以获得高效的系统。因此，准备好重置和故障处理程序的机制。
- en: You have a persistent storage and network cache such as **Memcache** or **Redis**
    to record availability.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个持久存储和网络缓存，比如**Memcache**或**Redis**来记录可用性。
- en: Logging, exception handling, and relaying failed requests.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录、异常处理和转发失败的请求。
- en: '**When to use**: In the following use cases, you can use the circuit breaker
    pattern:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时使用**：在以下用例中，您可以使用断路器模式：'
- en: When you don't want your resources to be depleted, that is, an action that is
    doomed to fail shouldn't be tried until it is fixed. You can use it to check the
    availability of external services.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您不希望耗尽资源时，也就是说，一个注定会失败的操作在修复之前不应该尝试。您可以使用它来检查外部服务的可用性。
- en: When you can compromise a bit on performance, but want to gain high availability
    of the system and not deplete resources.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您可以在性能上做出一些妥协，但希望获得系统的高可用性并且不耗尽资源。
- en: '**When not to use**: In the following scenarios, it is not advisable to introduce
    the circuit breaker pattern:'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适用的情况**：在以下情景中，不建议使用断路器模式：'
- en: You don't have an efficient cache layer that monitors and maintains states of
    services for a given time for requests across the clustered nodes.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您没有一个有效的缓存层，用于在集群节点之间维护服务状态的给定时间内的请求。
- en: For handling in-memory structures or as the substitute for handling exceptions
    in business logic. This would add overhead to performance.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理内存结构或作为业务逻辑中异常处理的替代方案。这会增加性能开销。
- en: Strangler pattern
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窒息器模式
- en: 'Today''s world is one where technology is constantly evolving. What is written
    today, is just tomorrow''s legacy code. This pattern is very helpful when it comes
    to the migration process. This pattern is about eventually migrating a legacy
    system by incrementally replacing particular parts of functionality with new microservices
    application and services. It eventually introduces a proxy that redirects either
    to the legacy or the new microservices, until the migration is complete and at
    the end, you can shut off the strangler or the proxy:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的世界是一个技术不断发展的世界。今天写的东西，明天就成了遗留代码。这种模式在迁移过程中非常有帮助。这种模式是关于通过逐步用新的微服务应用程序和服务替换特定功能的遗留系统。最终引入一个代理，将流量重定向到遗留系统或新的微服务，直到迁移完成，最后可以关闭窒息器或代理：
- en: '**Problem**: With aging systems, new evolving development tools, and hosting
    options, the evolution of cloud and serverless platforms maintaining the current
    system gets extremely painful with the addition of new features and functionalities.
    Completely replacing a system can be a huge task, for which gradual migration
    needs to be done such that the old system is still handled for the part that hasn''t
    been migrated yet. This pattern solves this very problem.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题**：随着老化系统、新兴的开发工具和托管选项，云和无服务器平台的发展，维护当前系统变得非常痛苦，因为需要增加新功能和功能。完全替换一个系统可能是一项艰巨的任务，需要逐步迁移，以便仍然处理尚未迁移的部分。这种模式解决了这个问题。'
- en: '**Solution**: The strangler solution resembles a vine that strangles a tree
    that it''s wrapped over. Over time, the migrated application strangles the original
    application until you can shut off the monolithic application. Thus, the overall
    process is as follows:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案**：窒息器解决方案类似于一根藤蔓，它缠绕在树上窒息。随着时间的推移，迁移的应用程序窒息原始应用程序，直到您可以关闭单片应用程序。因此，整个过程如下：'
- en: '**Reconstruct**: Construct a new application or site (in serverless or AWS
    cloud-based on modern principles). Incrementally reconstruct the functionalities
    in an agile manner.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：构建一个新的应用程序或站点（基于现代原则的无服务器或AWS云）。以敏捷的方式逐步重构功能。'
- en: '**Coexist**: Leave the legacy application as it is. Introduce a facade that
    eventually acts as a proxy and decides where to route the request based on the
    current migration status. This facade can be introduced at web server level or
    programming level based on various parameters such as IP address, user agent,
    or cookies.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共存**：保留旧应用程序不变。引入一个最终充当代理并根据当前迁移状态决定路由请求的外观。这个外观可以根据IP地址、用户代理或cookie等各种参数在Web服务器级别或编程级别引入。'
- en: '**Terminate**: Redirect everything to the modern migrated application and loosen
    off all the ties with the legacy application.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**：将所有内容重定向到现代迁移的应用程序，并解除与旧应用程序的所有联系。'
- en: A sample gist of `.htaccess` that acts as a facade can be found at this link: [https://gist.github.com/parthghiya/a6935f65a262b1d4d0c8ac24149ce61d](https://gist.github.com/parthghiya/a6935f65a262b1d4d0c8ac24149ce61d).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此链接找到充当外观的`.htaccess`的示例要点：[https://gist.github.com/parthghiya/a6935f65a262b1d4d0c8ac24149ce61d](https://gist.github.com/parthghiya/a6935f65a262b1d4d0c8ac24149ce61d)。
- en: The solution instructs us to create a facade or a proxy that has the ability
    to intercept the requests that are going to the backend legacy system. The facade
    or proxy then decides whether to route it to the legacy application or the new
    microservices. This is an incremental process, wherein both the systems can coexist.
    The end users won't even know when the migration process is complete. It gives
    the added advantage that if the adopted microservice approach doesn't work, there
    is a very simple way to change it.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案指示我们创建一个具有拦截请求能力的外观或代理，该请求将发送到后端旧系统。然后，外观或代理决定是将其路由到旧应用程序还是新的微服务。这是一个渐进的过程，两个系统可以共存。最终用户甚至不会知道迁移过程何时完成。它的附加优势是，如果采用的微服务方法不起作用，有一种非常简单的方法可以更改它。
- en: '**Take care of**: The following points need to be taken care of for effectively
    applying the strangulation pattern:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意**：有效应用窒息模式需要注意以下要点：'
- en: The facade or the proxy needs to be updated with the migration.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观或代理需要随着迁移而更新。
- en: The facade or the proxy shouldn't be a single point of failure or bottleneck.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观或代理不应该是单点故障或瓶颈。
- en: When the migration is complete, facade will evolve as the adapter for legacy
    applications.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移完成后，外观将作为适配器适用于旧应用程序。
- en: The new code written should be such that it can easily be intercepted, so in
    future, we can replace it in future migrations.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新编写的代码应该易于拦截，这样将来我们可以在迁移中替换它。
- en: '**When to use**: The strangler application is extremely useful when it comes
    to replacing a legacy and monolithic application with microservices. The pattern
    is used in the following cases:'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**何时使用**：当要用微服务替换旧的单片应用程序时，窒息应用程序非常有用。该模式在以下情况下使用：'
- en: When you want to follow the test-driven on behavior-driven development, and
    run fast and comprehensive tests with the accessibility of code coverages and
    adapt CI/CD.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您想要遵循测试驱动或行为驱动开发，并快速运行全面测试，以便访问代码覆盖率并适应CI/CD时。
- en: Your application can be contained bounded contexts within which a model applies
    in the region. As an example, in a shopping cart application, the product module
    would be one context.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序可以在区域内应用有界上下文。例如，在购物车应用程序中，产品模块将是一个上下文。
- en: '**When not to use**: This pattern may not be applicable in the following scenarios:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适用于**：在以下情况下，此模式可能不适用：'
- en: When you are not able to intercept the user agent request, or you are not able
    to introduce a facade in your architecture.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您无法拦截用户代理请求，或者无法在架构中引入外观时。
- en: When you think of doing a page by page migration at a time or you are thinking
    of doing it all at once.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您考虑一次一页页迁移或一次全部迁移时。
- en: When your application is more frontend-driven; that's where you have to entirely
    change and rework the interacting framework based on the way the frontend is interacting
    with services, as you don't want to expose the various ways the user agent is
    interacting with services.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您的应用程序更多地受前端驱动时；这就是您必须完全改变并重新设计基于前端与服务交互的框架的地方，因为您不希望暴露用户代理与服务交互的各种方式。
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we debunked microservices to understand the evolution of microservices,
    the characteristics of microservices, and the advantages of microservices. We
    went through various design principles of microservices, the process of refactoring
    from monolithic applications to microservices, and the various microservice design
    patterns.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们揭示了微服务，以了解微服务的演变、微服务的特点和优势。我们讨论了微服务的各种设计原则，从单片应用程序到微服务的重构过程，以及各种微服务设计模式。
- en: In the next chapter, we will start our microservice journey. We will go through
    all the setup required for our microservice journey. We will go through concepts
    related to Node.js and TypeScript, which are essential throughout the book. We
    will also create our first microservice, `Hello World`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始我们的微服务之旅。我们将了解微服务之旅所需的所有设置。我们将学习与本书始终相关的Node.js和TypeScript相关的概念。我们还将创建我们的第一个微服务`Hello
    World`。
