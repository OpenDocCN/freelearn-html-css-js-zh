- en: Packaging Types and Values Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类型和值打包在一起
- en: ReasonML has fantastic support for the software engineering practice of dividing
    programs into small, modular components that can be swapped out for each other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonML 对将程序划分为小型、模块化组件的软件工程实践提供了出色的支持，这些组件可以相互替换。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Modules and how they can be used to package types and values together
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块及其如何用于打包类型和值
- en: The difference between file modules and syntactic modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件模块和语法模块之间的区别
- en: Module signatures (both file and syntactic)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块签名（文件和语法）
- en: Using signatures to achieve information hiding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用签名实现信息隐藏
- en: Using signatures to achieve type abstraction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用签名实现类型抽象
- en: Achieving zero-cost abstraction
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现零成本抽象
- en: '**Modules** are groups of types and values accessible under a single name.
    This can be incredibly useful when you want to associate some types and operations
    together to make them easier to find and use together. They are kind of like **namespaces**
    in other languages, but more powerful because they can be composed in various
    ways.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块** 是一组类型和值，可以在单个名称下访问。当你想要将一些类型和操作关联起来以使它们更容易查找和使用时，这可以非常有用。它们在其他语言中类似于
    **命名空间**，但更强大，因为它们可以以各种方式组合。'
- en: Let's look at how to make some modules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一些模块。
- en: File modules
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件模块
- en: It turns out we've already made some modules! Reason treats the `.re` source
    files as modules, so our `src/Ch01/Ch01_Demo.re` and `src/Ch02/Ch02_Demo.re` files
    are automatically available as modules, with the names `Ch01_Demo` and `Ch02_Demo`,
    respectively. In the Reason world, these are called **implementation files***.*
    We will informally refer to them as **file modules***.*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们已经有了一些模块！Reason 将 `.re` 源文件视为模块，因此我们的 `src/Ch01/Ch01_Demo.re` 和 `src/Ch02/Ch02_Demo.re`
    文件分别自动作为模块可用，名称分别为 `Ch01_Demo` 和 `Ch02_Demo`。在 Reason 世界中，这些被称为 **实现文件**。我们将非正式地称它们为
    **文件模块**。
- en: Reason names file modules purely from their file names, ignoring their directory
    nesting. It makes every module automatically available from every other module,
    regardless of where they are physically in the project. This is why we were careful
    to name our modules with chapter prefixes; otherwise, files from different chapters
    but with the same names would confuse the compiler.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 仅根据文件名命名文件模块，忽略它们的目录嵌套。这使得每个模块都可以自动从其他模块中访问，无论它们在项目中的物理位置如何。这就是为什么我们小心翼翼地为模块命名时加上章节前缀；否则，来自不同章节但具有相同名称的文件会混淆编译器。
- en: 'Let''s take advantage of Reason''s automatic module resolution, by creating
    a new (file) module that refers to something in an existing module:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用 Reason 的自动模块解析功能，通过创建一个新的（文件）模块来引用现有模块中的内容：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here we''re defining a function that knows how to greet people with a name
    and an ID. There are a few things happening in this example (marked by the numbered
    comments):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个知道如何用姓名和 ID 欢迎人们的函数。在这个例子中发生了一些事情（用编号注释标记）：
- en: 'We assign a type to the `person` function parameter by appending a colon followed
    by the type. You can read this as "*person has type c h 0 2 demo dot person*".
    We can assign types to any function parameters in Reason; they are almost always
    optional though, because of type inference. In this case, we wanted to be explicit
    because of a subtle issue: there are actually two different record types (`person`
    and `company`) with the `name` and `id` fields in the `Ch02_Demo` module, and
    we need to distinguish between them.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在函数参数后附加冒号并跟类型来为 `person` 函数参数分配一个类型。你可以读作 "*person has type c h 0 2 demo
    dot person*"。我们可以在 Reason 中为任何函数参数分配类型；不过，由于类型推断，它们几乎总是可选的。在这种情况下，我们想要明确，因为存在一个微妙的问题：`Ch02_Demo`
    模块中实际上有两种不同的记录类型（`person` 和 `company`），它们都有 `name` 和 `id` 字段，我们需要区分它们。
- en: Function definitions have a body consisting of a single expression; this can
    also be a compound expression delimited by brackets (we'll see examples later).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数定义有一个由单个表达式组成的主体；这也可以是一个由括号分隔的复合表达式（我们将在后面看到示例）。
- en: We can have a `person` value and a `person` type–they don't clash because Reason
    stores them separately, in the static and dynamic environments.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以有一个 `person` 值和一个 `person` 类型——它们不会冲突，因为 Reason 将它们分别存储在静态和动态环境中。
- en: Reason is whitespace-insensitive; you can lay out your code any way you want,
    as long as you separate bindings with a semicolon. For most codebases, you would
    actually just use the Reason formatter tool, `refmt`, which would automatically
    take care of all formatting.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reason 对空白字符不敏感；你可以以任何你想要的方式布局你的代码，只要用分号分隔绑定即可。对于大多数代码库，你实际上会使用 Reason 格式化工具
    `refmt`，它会自动处理所有格式化。
- en: The `++` operator in Reason concatenates two strings (and nothing else!) together.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reason 中的 `++` 操作符将两个字符串（以及没有其他内容！）连接在一起。
- en: '`person.id` is an `int`, so we can''t concatenate it with its surrounding strings–unless
    we convert it to a string with the built-in `string_of_int` function. Reason has
    strict, strong typing, and doesn''t implicitly convert between types (not even
    between `int` and `float` variables).'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`person.id` 是一个 `int`，所以我们不能将其与其周围的字符串连接在一起——除非我们使用内置的 `string_of_int` 函数将其转换为字符串。Reason
    具有严格的强类型，不会在类型之间隐式转换（甚至不在 `int` 和 `float` 变量之间）。'
- en: 'To understand what Reason is doing for us, let''s look at the relevant part
    of the output JavaScript:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 Reason 为我们做了什么，让我们看看输出 JavaScript 的相关部分：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I've cleaned and rearranged the JavaScript output somewhat, without changing
    its meaning.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 JavaScript 输出进行了一些清理和重新排列，但没有改变其含义。
- en: As usual, we see the types are completely erased, and the output is concerned
    only with values. Based on the types, though, the Reason compiler knew to access
    the person's name at array index 1 and ID at index 0\. Also, it knows to ensure
    that `person[0]` gets converted into a string by using the JavaScript string constructor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们看到类型被完全删除，输出只关注值。然而，基于类型，Reason 编译器知道在数组索引 1 处访问人的姓名，在索引 0 处访问 ID。它也知道通过使用
    JavaScript 字符串构造函数将 `person[0]` 转换为字符串。
- en: In the JavaScript world, we'd say that such a conversion is unnecessary. But
    in the statically typed Reason world, the compiler keeps a tally of the types
    of all values and ensures they interact only according to the rules of their types.
    Thus we ensure that a number can't accidentally be added to a series of strings.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 世界中，我们会说这样的转换是不必要的。但在静态类型 Reason 世界中，编译器会跟踪所有值的类型，并确保它们只根据其类型的规则进行交互。因此，我们确保一个数字不会意外地添加到一系列字符串中。
- en: On a larger scale, notice that the fact that Reason files are modules is not
    directly visible in the JavaScript output code–except that the Reason files are
    directly compiled, with a one-to-one relationship, to JavaScript modules.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大规模上，请注意，Reason 文件是模块的事实在 JavaScript 输出代码中并不直接可见——除了 Reason 文件是直接编译的，与 JavaScript
    模块有一对一的关系。
- en: Syntactic modules
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法模块
- en: 'Let''s look at another way of creating modules in Reason: **syntactic modules***.*
    These are modules that are defined using Reason''s module syntax. Here''s an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 Reason 中创建模块的另一种方式：**语法模块**。这些是使用 Reason 的模块语法定义的模块。以下是一个示例：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here we define a `Domain` file module to contain two *nested* modules: `Person`
    and `Company`. These nested modules actually contain types similar to the ones
    we defined in `src/Ch02/Ch02_Demo.re`, but this time with both types named `t`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个 `Domain` 文件模块来包含两个嵌套模块：`Person` 和 `Company`。这些嵌套模块实际上包含与我们之前在 `src/Ch02/Ch02_Demo.re`
    中定义的类似类型，但这次两种类型都命名为 `t`。
- en: Let's digress a little into the type name `t`. This is a standard naming convention
    in the Reason ecosystem to mean the main type in the module. Usually, you refer
    to a module along with its main type, for example, `Person.t` or `Company.t`,
    so it's quite clear exactly which type you mean.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微偏离一下主题，谈谈类型名称 `t`。这是 Reason 生态系统中的标准命名约定，表示模块中的主类型。通常，你会指代一个模块及其主类型，例如，`Person.t`
    或 `Company.t`，这样就可以清楚地知道你指的是哪种类型。
- en: 'Syntactic modules have the following form: `module Name = {...bindings...};`
    and all the bindings are then available to outside consumers under the module
    name, for example, `Name.binding1`, and so on.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 语法模块具有以下形式：`module Name = {...bindings...};` 并且所有绑定都对外部消费者以模块名称的方式可用，例如，`Name.binding1`，等等。
- en: Earlier, we said that modules package types and values together. But in the
    preceding example, you can see that the `Ch03_Domain` file module itself contains
    two modules, `Person` and `Company`. I actually oversimplified before. Modules
    can recursively contain other modules! This is a great code organization and namespacing
    strategy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们说模块将类型和值打包在一起。但在前面的例子中，你可以看到 `Ch03_Domain` 文件模块本身包含两个模块，`Person` 和 `Company`。我之前过于简化了。模块可以递归地包含其他模块！这是一种很好的代码组织和命名空间策略。
- en: 'Let''s look at the (relevant part of the) JavaScript output to understand what
    the runtime effect of this domain module is:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看（相关部分的）JavaScript输出，以了解这个域模块的运行时效果：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Person` and `Company` modules are represented as JavaScript arrays, and
    their `t` types are completely erased, leaving the arrays almost empty. The arrays
    contain only what file-level module JavaScript output would contain: values. In
    fact, this is almost exactly how Reason represents modules when compiled to bytecode
    or native binary form.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`和`Company`模块被表示为JavaScript数组，它们的`t`类型被完全删除，使得数组几乎为空。数组中只包含文件级别模块JavaScript输出会包含的内容：值。实际上，这正是Reason在编译成字节码或原生二进制形式时表示模块的方式。'
- en: It is not, however, how you might expect a *nested module* to look in idiomatic
    JavaScript. Indeed, the BuckleScript compiler does not always emit completely
    idiomatic JavaScript output. Some of those cases can be fixed (indeed, some have
    already been); others are compromises that the compiler needs to make to efficiently
    convert Reason code into JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是你可能会期望的*嵌套模块*在惯用JavaScript中的样子。实际上，BuckleScript编译器并不总是生成完全惯用的JavaScript输出。其中一些情况可以修复（实际上，一些已经修复了）；其他则是编译器为了有效地将Reason代码转换为JavaScript而需要做出的妥协。
- en: Using a syntactic module
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用语法模块
- en: 'As you can see, modules are very cheap. They have almost no runtime effect.
    Let''s look at the payoff of arranging our types into their own nested modules.
    We''re going to try greeting a person again:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模块非常便宜。它们几乎没有任何运行时效果。让我们看看将我们的类型组织到它们自己的嵌套模块中的回报。我们将再次尝试问候一个人：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What's different from `src/Ch03/Ch03_Greet.re`?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与`src/Ch03/Ch03_Greet.re`有什么不同？
- en: We don't need to explicitly annotate the type of `person`
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要显式注释`person`的类型
- en: We need to tell Reason which module the `name` field is coming from, because,
    in order to prevent name clashes between record types that have the same field
    names, Reason doesn't automatically open up modules to look for type details
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要告诉Reason `name`字段来自哪个模块，因为为了防止具有相同字段名称的记录类型之间发生名称冲突，Reason不会自动打开模块以查找类型细节
- en: You might ask, is this really a payoff? We've just traded one kind of annotation
    (the explicit type signature) for another (the field name module prefix). While
    that is true, it's idiomatic for implementation code to have as few type annotations
    as possible and let the compiler infer as much as possible.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，这真的有回报吗？我们只是将一种注释（显式类型签名）换成了另一种（字段名模块前缀）。虽然这是真的，但在实现代码中，尽可能少地使用类型注释并让编译器尽可能多地推断是惯例。
- en: Type annotations do serve another purpose though, which is to document the types.
    In Reason, we have an explicit place to put type annotations that document our
    module types and serve some other useful purposes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注释确实还有另一个用途，那就是记录类型。在Reason中，我们有一个明确的地方可以放置类型注释，以记录我们的模块类型并服务于其他一些有用的目的。
- en: Module signatures
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块签名
- en: '**Module signatures***,* also known as **interfaces***,* are an explicit place
    to put type annotations. But they actually serve several purposes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块签名**，也称为**接口**，是一个放置类型注释的明确位置。但它们实际上有几个用途：'
- en: Export a module's public API
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出模块的公共API
- en: Document the types of a module's public API
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录模块公共API的类型
- en: Provide a place to put module documentation
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供放置模块文档的位置
- en: Hide non-public elements of a module
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏模块的非公共元素
- en: Hide implementation details of types
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏类型的实现细节
- en: Keeping in mind the points mentioned earlier, when would you *not* want to use
    a signature for your module? It's not set in stone, but my rule of thumb is to
    not use a signature when my API is experimental and still evolving (in semantic
    versioning terms, less than version 1.0.0.), or when the module is purely an application
    module and is not meant to be published as a library for others to consume (although
    the line between these is somewhat grainy).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面提到的要点，你会在什么情况下不希望为你的模块使用签名？这并不是一成不变的，但我的经验法则是，当我的API是实验性的并且仍在演变（在语义版本控制术语中，小于版本1.0.0）时，或者当模块纯粹是应用程序模块，并不打算作为库发布给其他人使用时（尽管这两者之间的界限有些模糊）不要使用签名。
- en: Signatures come in two forms–**interface files** and **syntactic signatures***,*
    corresponding to implementations. Interface files are Reason source files that
    contain signatures and nothing else. Syntactic signatures are signatures that
    are defined specifically using Reason's syntax support for signatures.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 签名有两种形式——**接口文件**和**语法签名**，*对应于实现*。接口文件是包含签名而没有其他内容的 Reason 源文件。语法签名是使用 Reason
    对签名的语法支持定义的签名。
- en: We will explore the previously mentioned points chiefly by using interface files,
    but also show examples of syntactic signatures as appropriate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用接口文件主要探索先前提到的点，但也会根据需要展示语法签名的示例。
- en: Exporting and documenting the public API
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出和记录公共 API
- en: 'Let''s look at an example of exporting and documenting a module''s public API.
    This is an interface file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看导出和记录模块公共 API 的一个例子。这是一个接口文件：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a few interesting things going on here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个有趣的事情正在进行：
- en: Interface files must have the `.rei` (Reason Interface) file extension, with
    file names corresponding to the implementation file name.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口文件必须具有 `.rei`（Reason 接口）文件扩展名，文件名与实现文件名相对应。
- en: We are using a new kind of comment, called a **documentation comment** (**doc
    comment**), to write documentation that will be publicly exported along with the
    API. Doc comments start with `/**` and end with `*/`. There are tools in the Reason
    ecosystem that can understand doc comments and format them for readers. Note that
    we usually don't use doc comments in implementation (`.re`) files because it usually
    doesn't make sense to expose implementation-specific documentation to users.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用一种新的注释类型，称为**文档注释**（**doc comment**），来编写将随 API 一起公开导出的文档。文档注释以 `/**` 开始，以
    `*/` 结束。Reason 生态系统中有工具可以理解文档注释并为读者格式化它们。请注意，我们通常不在实现文件（`.re`）中使用文档注释，因为这通常没有意义将特定于实现的文档暴露给用户。
- en: Any item in a module can be documented with doc comments.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块中的任何项目都可以使用文档注释进行记录。
- en: We use a value declaration to tell Reason to export a value from the module,
    with the given type. In this case, the type of the value is a function type–this
    one reads "*ch 0 3 domain person t arrow string*" meaning *take a chapter 3 domain
    person type as input and return a string as output*. We will cover functions in
    more detail in a future chapter.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用值声明来告诉 Reason 从模块中导出一个具有给定类型的值。在这种情况下，值的类型是函数类型——这个类型读作 "*ch 0 3 domain
    person t arrow string*"，意味着 *以第 3 章域 person 类型作为输入并返回一个字符串作为输出*。我们将在未来的章节中更详细地介绍函数。
- en: 'So, what does this interface file compile to? As it turns out: nothing. Interface
    files are purely compile-time constructs; they don''t exist at all at runtime.
    In fact, they are erased just like types because they are types. *Module interfaces
    are types.* A `.rei` file you write as an interface actually specifies the type
    of its corresponding `.re` implementation file.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个接口文件编译成什么？实际上：什么也没有。接口文件完全是编译时构造；它们在运行时根本不存在。事实上，它们就像类型一样被擦除，因为它们是类型。*模块接口是类型*。你作为接口编写的
    `.rei` 文件实际上指定了其对应的 `.re` 实现文件的类型。
- en: Syntactic module signatures
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法模块签名
- en: '**Module signatures** are also known as **module types***.* Just like other
    types, module types specify what you can and can''t do with values of their type;
    in other words, they specify the surface area of a module.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块签名**也被称为**模块类型**。*就像其他类型一样，模块类型指定了你可以对它们的类型值做什么，不能做什么；换句话说，它们指定了模块的表面区域。'
- en: 'Here''s an example of a syntactic module type and its usage:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个语法模块类型及其用法的例子：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A syntactic module type has the `module type Type = {...declarations...};` form
    and specifies exactly what will be exported from a module that conforms to the
    type. Some key points to note in the previous example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 语法模块类型具有 `module type Type = {...declarations...};` 形式，并精确指定符合该类型的模块将导出什么。在先前的例子中，需要注意的一些关键点：
- en: 'We declare a function''s (`make`) type with the `let funName: (param1Type,
    ..., paramNType) => returnType;` syntax.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们使用 `let funName: (param1Type, ..., paramNType) => returnType;` 语法声明一个函数的类型（`make`）。'
- en: We declare that a module conforms to a module type by appending a colon followed
    by the module type.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在模块类型后附加一个冒号来声明模块符合模块类型。
- en: We define a `massage` function to properly case and trim input names, but this
    function is not declared in the module type, so it's never exported (that is,
    users of this module won't be able to access `massage`).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个 `massage` 函数来正确地大小写和修剪输入名称，但这个函数在模块类型中没有声明，所以它从未被导出（也就是说，使用此模块的用户将无法访问
    `massage`）。
- en: 'We give a record field a specific expression as its value by using the `name:
    expression` syntax. We''ll cover record type syntax more fully in a later chapter.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们通过使用 `name: expression` 语法给记录字段一个特定的表达式作为其值。我们将在后面的章节中更全面地介绍记录类型语法。'
- en: 'Let''s take a look at the (relevant part of the) JavaScript output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看（相关部分的）JavaScript 输出：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Reason `String` module name is **damaged slightly** (with a `$$` prefix)
    in the output to avoid a name clash with the existing JavaScript `String` constructor.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reason 的 `String` 模块名称在输出中略有损坏（带有 `$$` 前缀）以避免与现有的 JavaScript `String` 构造函数发生名称冲突。
- en: The returned person array value doesn't call the `massage` function. In fact,
    BuckleScript doesn't even emit a `massage` function, having determined that it
    can be inlined.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回的人员数组值没有调用 `massage` 函数。实际上，BuckleScript 甚至没有发出 `massage` 函数，因为它已经确定可以内联。
- en: Module errors
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块错误
- en: The fact that modules have types naturally leads to the fact that they can also
    throw type errors. Let's look at a couple of possible type errors related to modules.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 模块具有类型的事实自然导致它们也可以抛出类型错误。让我们看看与模块相关的几个可能的类型错误。
- en: Signature mismatch
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签名不匹配
- en: 'What happens when we try to assign a module signature to a module that doesn''t
    implement that interface properly? Check out the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将模块签名分配给没有正确实现该接口的模块时会发生什么？查看以下内容：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This message means that we forgot to include the `make` function in our implementation.
    The message is slightly strange, but makes sense if you know how Reason typechecks
    modules:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这条信息意味着我们忘记在我们的实现中包含 `make` 函数。信息有点奇怪，但如果你知道 Reason 如何检查模块类型，它就有意义了：
- en: It infers what it thinks should be the module type by examining the structure
    of the actual module
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过检查实际模块的结构来推断它认为应该是的模块类型
- en: It compares the inferred type to the annotated module type, `PersonType`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将推断的类型与注解的模块类型 `PersonType` 进行比较
- en: It does not care about items that appear in the actual module but aren't declared
    in `PersonType` (it just hides those from the outside world)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不关心实际模块中出现的但未在 `PersonType` 中声明的项（它只是将这些项隐藏在外部世界之外）
- en: It does show errors on items that are declared in `PersonType` but are missing
    from the actual module
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确实显示了在 `PersonType` 中声明但实际模块中缺失的项的错误
- en: 'In short, you can''t overpromise and under-deliver. Knowing this, you can interpret
    the error message: the inferred module type is on top, and the annotated module
    type is beneath, as shown in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你不能过度承诺而不足够交付。了解这一点后，你可以解释错误信息：推断的模块类型在最上面，注解的模块类型在下面，如下面的截图所示：
- en: '![](img/e3bb0114-0483-4496-ad44-7c0ef9bea50c.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bb0114-0483-4496-ad44-7c0ef9bea50c.png)'
- en: Module type mismatch error diagram
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 模块类型不匹配错误图
- en: 'In Reason, modules are *structurally typed*: their types are made up of their
    structure, that is, by combining the types of their contained bindings in a syntactic
    form similar to the modules themselves. That''s why we''re able to write `module
    type Foo = {...declarations...};`–the `{...declarations...}` structural type is
    a first-class type by itself; we are just binding it to a name. A concrete result
    of this is that you can define a module and annotate it with a type directly,
    for example, `module Foo: {...declarations...} = {...bindings...};`. In a later
    chapter, we will examine structural typing further.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Reason 中，模块是*结构化类型化的*：它们的类型由它们的结构组成，也就是说，通过以与模块本身类似的语法形式组合其包含的绑定类型。这就是我们能够编写
    `module type Foo = {...declarations...};` 的原因 – `{...declarations...}` 结构类型本身就是一个一等类型；我们只是将其绑定到一个名称上。这一具体结果就是你可以直接定义一个模块并用类型注解它，例如，`module
    Foo: {...declarations...} = {...bindings...};`。在后面的章节中，我们将进一步探讨结构化类型。'
- en: An important thing to understand is that you can't get a signature mismatch
    by implementing types and values in a different order from that in their signatures.
    You are still restricted to declaring or defining things before you use them,
    but the compiler will understand that a module conforms to a signature even if
    their declarations and definitions don't match up in exact order. To see a small
    example of this, look at the code sample in the upcoming *Type abstraction* section.
    The ordering of the `getter` functions is slightly different between the interface
    and the implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情是要理解，你不能通过以与它们的签名不同的顺序实现类型和值来得到签名不匹配。你仍然在使用它们之前声明或定义它们，但编译器会理解一个模块符合签名，即使它们的声明和定义在顺序上不完全匹配。为了看到这个的小例子，请查看即将到来的*类型抽象*部分中的代码示例。`getter`
    函数的顺序在接口和实现之间略有不同。
- en: This ordering flexibility can be a benefit if you're trying to arrange a module
    signature in a way that's easy to understand, that is, one that presents the most
    important items first. Sometimes, you don't need that level of flexibility, but
    you can always take advantage of it later if you find you do.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种顺序灵活性在尝试以易于理解的方式安排模块签名时可能是一个好处，也就是说，首先展示最重要的项目。有时，你可能不需要这种级别的灵活性，但如果你发现你需要，你总是可以利用它。
- en: Value can't be found
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 找不到值
- en: 'What happens when we try to use something that doesn''t exist in a module?
    Check out the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试在一个模块中使用不存在的东西时会发生什么？查看以下内容：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Reason checks, at compile time, whether the type of the module (`Ch03_Greet`)
    exports the named value (`process`), and it fails the build otherwise. There is
    no way to use a value that does not exist.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 在编译时检查模块的类型（`Ch03_Greet`）是否导出了命名的值（`process`），如果没有，则构建失败。无法使用不存在的值。
- en: Type abstraction
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型抽象
- en: In Reason, you can hide the implementation of a type and reveal exactly what
    you choose to. This *type abstraction* is one of the best techniques for *preserving
    invariants* (rules that should be obeyed) in your codebase. Type abstraction also
    allows modules to be decoupled from each other's implementation details, and work
    only with the information they have from exported interfaces.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reason 中，你可以隐藏类型的实现并精确地展示你选择的内容。这种*类型抽象*是保持代码库中*不变量*（应该遵守的规则）的最佳技术之一。类型抽象还允许模块彼此解耦，只处理它们从导出接口中获取的信息。
- en: For example, look at the `Ch03_ModuleType.Person` module. It exports a `t` type
    to represent information about a person, and a `make` function to properly create
    values of the `t` type. The `make` function ensures that we properly trim and
    capitalize the names that we're given. We want to enforce the rule that names
    should have the proper casing and should not have surrounding whitespace.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看 `Ch03_ModuleType.Person` 模块。它导出 `t` 类型来表示有关人员的信息，以及一个 `make` 函数来正确创建 `t`
    类型的值。`make` 函数确保我们正确地修剪并大写我们给出的名称。我们希望强制执行规则，即名称应该有正确的格式化，并且不应该有周围的空白字符。
- en: 'The problem is we can do something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们可以这样做：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because the `Ch03.ModuleType.Person.t` definition is exported, we can bypass
    the `make` function and directly create `t` values, breaking the rules that we
    want to apply for names.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Ch03.ModuleType.Person.t` 的定义是导出的，我们可以绕过 `make` 函数并直接创建 `t` 值，打破我们想要应用于名称的规则。
- en: 'We can solve this problem by making `t` an abstract type (note that we must
    define both the interface and implementation files, as shown ahead):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `t` 定义为一个抽象类型来解决此问题（注意，我们必须定义接口和实现文件，如下所示）：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, `Ch03_AbstractPerson.t` is internally a record type just like the others,
    but it is exported as purely an abstract type with no implementation details *except*
    the operations we provide in the interface. These operations allow us to properly
    create `t` values and extract the person's ID and name from the `t` values.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`Ch03_AbstractPerson.t` 在内部是一个记录类型，就像其他类型一样，但它被导出为一个纯抽象类型，没有实现细节*除了*我们在接口中提供的操作。这些操作使我们能够正确创建
    `t` 值并从 `t` 值中提取人员的 ID 和姓名。
- en: 'We introduce two new types here: `id` and `name`, using the `type typeName
    = otherType;` syntax. This direct binding of a new type name to an existing type
    name is called a *type alias* (sometimes also called a *type abbreviation*). Type
    aliases don''t have any influence on typechecking, but they are a useful way to
    document our intentions and sometimes to shorten the names of longer type names.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里引入了两种新的类型：`id`和`name`，使用`type typeName = otherType;`语法。将新的类型名称直接绑定到现有的类型名称称为*类型别名*（有时也称为*类型缩写*）。类型别名对类型检查没有影响，但它们是记录我们的意图和有时缩短较长的类型名称的有用方式。
- en: Because we aliased `id` and `name`, we can use the shortcut that Reason provides
    when the field and type names are the same in a record type definition, called
    **punning**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们别名为`id`和`name`，我们可以使用Reason提供的快捷方式，当记录类型定义中的字段和类型名称相同时，称为**打趣**。
- en: Since we want to export the type aliases as well as the original types and operations,
    we need to repeat the same alias bindings in both the interface and the implementation.
    This bit of duplication allows Reason to double-check its inference against our
    intentions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望导出类型别名以及原始类型和操作，我们需要在接口和实现中都重复相同的别名绑定。这种重复允许Reason双重检查其推断是否符合我们的意图。
- en: Zero-allocation type abstraction
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零分配类型抽象
- en: Sometimes we need to enforce rules over types that already exist. For example,
    in `Ch03_AbstractPerson`, we have a `name` type that is just a `string`, and a `massage` function
    that takes a string and applies some rules to it to turn it into a "well-behaved"
    name. We put this type and function inside another module in a rather adhoc way,
    because we were focusing on the concept of "person" and its operations and not
    so much on "name" and its operations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要对已存在的类型强制执行规则。例如，在`Ch03_AbstractPerson`中，我们有一个`name`类型，它只是一个`string`，以及一个`massage`函数，该函数接受一个字符串并应用一些规则将其转换为“良好行为”的名称。我们以相当随意的的方式将这个类型和函数放在另一个模块中，因为我们当时专注于“人”的概念及其操作，而不是那么关注“名称”及其操作。
- en: However, we don't necessarily want to make a brand-new type for names that will
    allocate values on top of the already-allocated name strings. We'd like to preserve
    our naming rules (casing and trimming) while also being cheap with memory use.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不想为名称创建一个新的类型，该类型将在已分配的名称字符串之上分配值。我们希望在保持命名规则（大小写和修剪）的同时，还要节省内存使用。
- en: 'Let''s extract the `name` type alias and its *smart constructor* (a `make` function
    that applies the rules we want to enforce when it makes values) into a dedicated
    module (again, note that we must define both the interface and implementation
    files for the module to be complete):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`name`类型别名及其*智能构造函数*（一个应用我们想要强制执行的规则的`make`函数）提取到一个专用模块中（再次注意，我们必须定义模块的接口和实现文件，以便模块完整）：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What''s new here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新特性：
- en: 'We declare a nested `Name` module with the given module type. We''re telling
    Reason: *Ch03_Person contains a module Name that exports these items*. Note that
    the `Name` module''s `t` type is abstract.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个嵌套的`Name`模块，并指定其模块类型。我们告诉Reason：*Ch03_Person包含一个名为Name的模块，该模块导出这些项目*。请注意，`Name`模块的`t`类型是抽象的。
- en: We don't make the `id` type abstract because we don't have to enforce any rules
    about how it should be created (we might in future though).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们没有将`id`类型声明为抽象的，因为我们不需要强制执行任何关于其创建的规则（我们可能在将来会这么做）。
- en: We don't need to make the `Ch03_Person.t` type abstract anymore now, because
    we've moved the name type and creation logic into `Name`. There's no way anyone
    can create the wrong `Ch03_Person.t` values because they must still go through
    `Name.make` to get names.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经将名称类型和创建逻辑移动到`Name`中，我们不再需要将`Ch03_Person.t`类型声明为抽象的。因为任何人都无法创建错误的`Ch03_Person.t`值，因为他们必须仍然通过`Name.make`来获取名称。
- en: We make the `Ch03_Person` module functions use the `Name.t` type now.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们让`Ch03_Person`模块函数使用`Name.t`类型。
- en: The `Name.t` type is implemented as just a `string`. It will not allocate anything
    at runtime.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Name.t`类型被实现为一个`string`。它不会在运行时分配任何内容。'
- en: The `make` smart constructor will automatically enforce our rules for correct
    names. Also, we use the `ModuleName.(expression)` syntax here to temporarily *open* the
    `String` module for the scope of this one expression, bringing all its contained
    values into visibility. Opening modules temporarily in small scopes can be very
    handy to save some typing–but opening them for larger scopes can be risky because
    of potential name clashes.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`make` 智能构造函数将自动强制执行我们的命名规则。此外，我们在这里使用 `ModuleName.(expression)` 语法临时“打开” `String`
    模块，使其包含的所有值在当前表达式的作用域内可见。在小的作用域内临时打开模块可以非常方便地节省一些打字——但打开较大的作用域可能会因为潜在的名字冲突而变得有风险。'
- en: Because `Name.t` is already just a `string`, *converting it back* to a `string`
    in `toString` entails just returning the input value.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 `Name.t` 已经是 `string` 类型，所以在 `toString` 中将其转换回 `string` 只需返回输入值。
- en: 'This structuring hits a good balance:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构达到了良好的平衡：
- en: It exposes the `person` record-type definition so that users can examine and
    use their values easily
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它暴露了 `person` 记录类型定义，以便用户可以轻松地检查和使用它们的值
- en: 'It imposes control over a critical piece of `person` data: the name'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它控制了 `person` 数据的关键部分：姓名
- en: Preventing type mix-ups
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止类型混淆
- en: 'Earlier, I mentioned that we don''t need to make the `id` type abstract because
    we don''t have any rules for it right now. But there''s another good reason to
    make a simple type abstract: preventing mix-ups between the same *physical* types
    (in terms of the implementation) that represent different *logical* concepts.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到我们不需要使 `id` 类型抽象，因为我们目前没有为其制定任何规则。但有一个很好的理由使简单类型抽象：防止表示不同逻辑概念的相同物理类型（从实现的角度来看）之间的混淆。
- en: 'For example, suppose you had the following function and usage:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个以下函数和用法：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In `Ch02_Demo` we made the ID types, for both `person` and `company`, `int`.
    This can backfire if we accidentally pass function arguments in the wrong order
    and our system tries to *pay a bill* from a company to a person.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Ch02_Demo` 中，我们为 `person` 和 `company` 的 ID 类型都指定了 `int`。如果我们不小心按错误的顺序传递函数参数，并且我们的系统试图从公司向个人支付账单，这可能会产生反效果。
- en: 'We can prevent this kind of mix-up using a technique similar to the preceding
    one: make the person ID and company ID types logically distinct, while still physically
    representing them internally with just `int`. Here''s an example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与前面类似的技术来防止这种混淆：使个人 ID 和公司 ID 类型在逻辑上区分开来，同时在内部物理上仅用 `int` 表示。以下是一个示例：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, some very interesting things are happening:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一些非常有趣的事情正在发生：
- en: We define an `Id` module signature, which declares an abstract `t` type, and
    a constructor and extractor function for values of `t`
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个 `Id` 模块签名，它声明了一个抽象的 `t` 类型，以及 `t` 值的构造函数和提取函数
- en: We define an `IntId` module, with no explicit signature, which exposes a `t` type
    equal to `int`, and constructor and extractor functions of the same name as in
    the `Id` signature
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个没有明确签名的 `IntId` 模块，它暴露了一个等于 `int` 的 `t` 类型，以及与 `Id` 签名中相同的构造函数和提取函数
- en: We define two module aliases, `PersonId` and `CompanyId`, to `IntId`, and give
    them the explicit `Id` signature
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个模块别名 `PersonId` 和 `CompanyId`，将它们指定为 `IntId`，并赋予它们显式的 `Id` 签名
- en: We make `PersonId.t` and `CompanyId.t` values
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了 `PersonId.t` 和 `CompanyId.t` 值
- en: 'If we tried to compare the values, we''d get a type error:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试比较这些值，我们会得到一个类型错误：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, Reason is able to distinguish between the two types, even though they're
    physically the same type, backed by the same module (`IntId`), just because they
    were explicitly annotated with a module type (`Id`) that prevents Reason from
    "seeing" the underlying types. Because of the signature and the abstract `t` type,
    Reason can't prove that `CompanyId.t` and `PersonId.t` are the same, so trying
    to compare them is a type error.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Reason 能够区分这两种类型，尽管它们在物理上是相同的类型，由相同的模块（`IntId`）支持，只是因为它们被显式地注解为模块类型（`Id`），这阻止了
    Reason “看到”底层类型。由于签名和抽象的 `t` 类型，Reason 不能证明 `CompanyId.t` 和 `PersonId.t` 是相同的，因此尝试比较它们会导致类型错误。
- en: 'Note that making these modules, even with explicit signatures, is very cheap
    allocation-wise:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使有明确的签名，创建这些模块在分配上也是非常便宜的：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Reason reuses the same `IntId` module and distinguishes between their types
    purely at compile time. We can thus elegantly separate our concerns:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是重用了相同的 `IntId` 模块，并在编译时纯粹区分它们的类型。因此，我们可以优雅地分离我们的关注点：
- en: The `Id` signature just says that there's a `t` type that can be converted to
    and from `int`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id` 签名只是说明存在一个可以转换为 `int` 并从 `int` 转换回的 `t` 类型'
- en: '`IntId` implements a module that is compatible with the `Id` signature but
    not explicitly annotated with it; thus showing that int-backed ID modules are
    one possible implementation of the `Id` signature'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntId`实现了一个与`Id`签名兼容但未显式注解的模块；从而表明基于整数的ID模块是`Id`签名的一种可能的实现方式。'
- en: The `PersonId` and `CompanyId` modules take advantage of the combination of
    `Id` and `IntId` to achieve type safety by telling the compiler it can't assume
    that the ID types are the same (even though we know they are)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersonId`和`CompanyId`模块利用`Id`和`IntId`的组合，通过告诉编译器它不能假设ID类型相同（尽管我们知道它们是相同的）来实现类型安全。'
- en: As you can see, in Reason we have a level of fine-grained power that takes advantage
    of the compiler to achieve very lightweight code. We will see more techniques
    like this in future chapters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在Reason中，我们有一个细粒度的强大功能，利用编译器实现非常轻量级的代码。我们将在未来的章节中看到更多类似的技术。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to package types and values together with modules,
    how to specify exactly what surface area we want to expose from our modules using
    signatures, and how to keep tight control over our data types using the combination
    of modules and signatures–even to the extent of controlling the memory allocation
    of data in our modules. In Reason, you'll notice this pattern a lot–you design
    the types to ensure that certain rules are enforced, and in a lot of situations,
    they will be enforced at no runtime cost.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何将类型和值与模块一起打包，如何使用签名精确指定我们希望从模块中公开的表面区域，以及如何通过模块和签名的组合来严格控制我们的数据类型——甚至可以控制模块中数据的内存分配。在Reason中，你会注意到这种模式很多——你设计类型以确保某些规则得到执行，在很多情况下，它们将不会产生运行时成本。
- en: 'So, stay tuned—in the next chapter, we will cover some of the most important
    types that we use on a daily basis in type-driven development: product types that
    group values together for easy access.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，请保持关注——在下一章中，我们将介绍我们在类型驱动开发中每天都会使用的一些最重要的类型：将值组合在一起以便于访问的产品类型。
