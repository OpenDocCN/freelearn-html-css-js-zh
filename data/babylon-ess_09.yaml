- en: Chapter 9. Create and Play Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。创建和播放动画
- en: In the previous chapters, you learned everything that is required to create
    cool, beautiful, and complete 3D applications. This is the last chapter and the
    last thing that you need to learn is how to animate objects in your scene. Then,
    finally, you will get a fully dynamic scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您学习了创建酷炫、美观和完整的 3D 应用程序所需的所有内容。这是最后一章，您需要学习的最后一件事是如何在场景中动画化对象。然后，最终，您将获得一个完全动态的场景。
- en: 'The Babylon.js framework provides a way to create animations without managing
    them with code. For example, you want to create a rotation animation that will
    affect five objects (nodes) in your scene; Babylon.js will allow you to create
    an animation object that you can share easily between your five nodes. In this
    chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 框架提供了一种无需通过代码管理即可创建动画的方法。例如，您想创建一个旋转动画，该动画将影响场景中的五个对象（节点）；Babylon.js
    将允许您创建一个动画对象，您可以在五个节点之间轻松共享。在本章中，我们将涵盖以下主题：
- en: Creating animations using Babylon.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Babylon.js 创建动画
- en: Smooth animations using easing functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓动函数实现平滑动画
- en: Importing and managing animated models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入和管理动画模型
- en: Creating animations using Babylon.js
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Babylon.js 创建动画
- en: For this first topic, let's discuss how to simply animate a box with code and
    how to create an animation using the Babylon.js tools such as the `BABYLON.Animation`
    class. You'll quickly understand the importance of using the provided tools instead
    of handling animations with code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个主题，让我们讨论如何简单地使用代码动画化一个盒子，以及如何使用 Babylon.js 工具（如 `BABYLON.Animation` 类）创建动画。您将很快理解使用提供的工具而不是用代码处理动画的重要性。
- en: Animating an object with code
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码动画化对象
- en: 'Let''s start with the following scene (a plane and a box):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下场景开始（一个平面和一个盒子）：
- en: '![Animating an object with code](img/image_09_001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![使用代码动画化对象](img/image_09_001.png)'
- en: Let's animate the box to turn around its center (x = 0, y = 0, and z = 0). The
    process should be to increment a value (angle) in time and set the new position
    of the box.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让盒子围绕其中心（x = 0, y = 0, 和 z = 0）旋转。这个过程应该是增加一个值（角度）随时间变化，并设置盒子的新位置。
- en: Typically, (*x = Radius*Cos(angle)*, *y = 0*, and *z = Radius*Sin(angle)*).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，(*x = 半径 * Cos(角度)*, *y = 0*, 和 *z = 半径 * Sin(角度)*)。
- en: 'To perform this action, you can call a `.registerBeforeRender` function on
    the scene. This function takes an anonymous function as the parameter and this
    anonymous function will be automatically called for every frame, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，您可以在场景上调用一个 `.registerBeforeRender` 函数。此函数接受一个匿名函数作为参数，并且这个匿名函数将自动在每一帧被调用，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This function is pretty simple; however, it is applied only to the box. What
    if you want to animate another object by sharing the same code? The solution is
    simple; just pass the node as a parameter to a function that will register a new
    function at each call before render, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当简单；然而，它仅应用于盒子。如果您想通过共享相同的代码来动画化另一个对象怎么办？解决方案很简单；只需将节点作为参数传递给一个函数，该函数将在每次渲染前注册一个新的函数，如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, it is not necessarily a problem to manage the animations through
    code. The real problem occurs when you have to synchronize the animation with
    time (manage the speed of animation), stop or pause animations, and so on. These
    functions require you to create a complete manager and it is not necessary what
    you want to do.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过代码管理动画并不一定是个问题。真正的问题出现在您需要将动画与时间同步（管理动画速度）、停止或暂停动画等情况。这些功能要求您创建一个完整的管理器，而这并不是您想要做的。
- en: The next sub-topic will show you how to use the animation manager of Babylon.js
    and don't worry about the time, stop and pause functions, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子主题将向您展示如何使用 Babylon.js 的动画管理器，并且不用担心时间、停止和暂停功能等。
- en: Using the animation manager of Babylon.js
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Babylon.js 的动画管理器
- en: 'Let''s take the same scene and create a simple animation only using the animation
    manager of Babylon.js. You need to understand only one thing: the frame keys of
    an animation.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用相同的场景，仅使用 Babylon.js 的动画管理器创建一个简单的动画。您只需要理解一件事：动画的帧键。
- en: 'To create an animation, just use the `BABYLON.Animation` class and attach it
    to a node (or several nodes). The `BABYLON.Animation` class isn''t difficult to
    understand, it takes a name, a property to animate on a node (and not necessarily
    a property of a node), number of frames per second, data type, and loop mode,
    as shown in the following snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个动画，只需使用 `BABYLON.Animation` 类并将其附加到一个节点（或多个节点）上。`BABYLON.Animation` 类并不难理解，它需要一个名称，一个要在节点上动画化的属性（不一定是节点的属性），每秒帧数，数据类型和循环模式，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `rotation` parameter says that the animation manager will animate the `.rotation`
    property of the object attached to the animation. A rotation is of the `BABYLON.Vector3` type,
    this is the reason why the data type is `BABYLON.Animation.ANIMATIONTYPE_VECTOR3`.
    Finally, we want the animation to loop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotation` 参数表示动画管理器将动画化附加到动画的对象的 `.rotation` 属性。旋转是 `BABYLON.Vector3` 类型，这也是为什么数据类型是
    `BABYLON.Animation.ANIMATIONTYPE_VECTOR3` 的原因。最后，我们希望动画循环。'
- en: 'According to the property you are animating (*rotation* in the previous example
    that is a `BABYLON.Vector3` object), you have to provide a valid data type which
    can be one of the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你正在动画化的属性（在之前的例子中是 *旋转*，它是一个 `BABYLON.Vector3` 对象），你必须提供一个有效的数据类型，它可以是以下之一：
- en: '`ANIMATIONTYPE_FLOAT`: When the property is of the `float` type.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANIMATIONTYPE_FLOAT`：当属性是 `float` 类型时。'
- en: '`ANIMATIONTYPE_VECTOR2`: When the property is of the `BABYLON.Vector2` type.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANIMATIONTYPE_VECTOR2`：当属性是 `BABYLON.Vector2` 类型时。'
- en: '`ANIMATIONTYPE_VECTOR3`: When the property is of the `BABYLON.Vector3` type.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANIMATIONTYPE_VECTOR3`：当属性是 `BABYLON.Vector3` 类型时。'
- en: '`ANIMATIONTYPE_QUATERNION`: When the property is of the `BABYLON.Quaternion` type.
    A mathematical object that can be used to represent the rotation of a node (`node.rotationQuaternion`)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANIMATIONTYPE_QUATERNION`：当属性是 `BABYLON.Quaternion` 类型。这是一个可以用来表示节点旋转（`node.rotationQuaternion`）的数学对象。'
- en: '`ANIMATIONTYPE_MATRIX`: When the property is of the `BABYLON.Matrix` type.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANIMATIONTYPE_MATRIX`：当属性是 `BABYLON.Matrix` 类型时。'
- en: '`ANIMATIONTYPE_COLOR3`: When the property is of the `BABYLON.Color3` type.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANIMATIONTYPE_COLOR3`：当属性是 `BABYLON.Color3` 类型时。'
- en: In this case, we use the `Vector3` data type as the `.rotation` property is
    `BABYLON.Vector3`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `Vector3` 数据类型，因为 `.rotation` 属性是 `BABYLON.Vector3`。
- en: 'The next step consists of creating an array of keys. The keys (or key frames)
    represent the state of the animated property at specific frames. In the previously
    created animation, the number of frames per second was set to `1`. Then, each
    second, a key, in the array of keys, is reached. The keys of an animation is simply
    an array of objects, objects each composed of two properties: the frame number
    and, according to the animated property, the associated value (of type `float`,
    `BABYLON.Vector2`, or `BABYLON.Vector3`, and so on.), as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个键数组。键（或关键帧）代表动画属性在特定帧的状态。在之前创建的动画中，每秒帧数设置为 `1`。然后，每秒，键数组中的一个键被达到。动画的键是一个对象数组，每个对象由两个属性组成：帧号，以及根据动画化的属性，关联的值（类型为
    `float`，`BABYLON.Vector2`，`BABYLON.Vector3` 等），如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s create two keys that will translate the box from the position (`x =
    0`, `y = 2.5`, and `z = 0`) to (`x = 10`, `y = 10`, and `z = 10`) at frame 20,
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个键，将盒子从位置（`x = 0`，`y = 2.5`，和 `z = 0`）转换到（`x = 10`，`y = 10`，和 `z = 10`）在第
    20 帧，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the number of frames per second is set to `1`, the second key (`frame = 20`)
    means that the box position will be at (`x = 10`, `y = 10`, and `z = 10`) 20 seconds
    later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每秒帧数设置为 `1`，则第二个键（`frame = 20`）意味着盒子位置将在 20 秒后到达（`x = 10`，`y = 10`，和 `z =
    10`）。
- en: 'Let''s set the keys for the `simpleAnimation` animation manager, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `simpleAnimation` 动画管理器设置键，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, let''s attach the animation manager to the box and start the animation
    in the scene, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将动画管理器附加到盒子上，并在场景中开始动画，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result looks similar to the following at the beginning:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在开始时看起来类似于以下内容：
- en: '![Using the animation manager of Babylon.js](img/image_09_002.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Babylon.js 的动画管理器](img/image_09_002.png)'
- en: 'Finally, once the animation has finished, the result looks like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦动画完成，结果看起来如下：
- en: '![Using the animation manager of Babylon.js](img/image_09_003.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Babylon.js 的动画管理器](img/image_09_003.png)'
- en: 'To reproduce the previous example (the box that turns around the center), the
    solution is pretty simple; just add 360 keys that represent every degree of a
    circle, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要重现之前的例子（围绕中心旋转的盒子），解决方案很简单；只需添加 360 个键，代表圆的每个度数，如下所示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To control your animations (start, pause, restart, and stop), the `.beginAnimation`
    function returns an object of the `BABYLON.Animatable` type. The returned object
    is created on the fly and allows you to control your animations. Let''s consider
    the same example as earlier:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制你的动画（开始、暂停、重新开始和停止），`.beginAnimation`函数返回一个`BABYLON.Animatable`类型的对象。返回的对象是即时创建的，允许你控制你的动画。让我们考虑一个与之前相同的例子：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a simple animation
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的动画
- en: 'The first example, with only two frames, can be heavy as I know that you''ll
    quickly create a helper, once and for all. Babylon.js thought about this and provides
    a static `CreateAndStartAnimation` function that creates two frames and starts
    the animation for you. Let''s create the same animation only using the following
    function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子，只有两个帧，可能会很重，因为我知道你很快就会创建一个辅助工具，一次性和永久。Babylon.js考虑到了这一点，并提供了一个静态的`CreateAndStartAnimation`函数，该函数为你创建两个帧并开始动画。让我们只使用以下函数创建相同的动画：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can guess, this method is used by Babylon.js to create `BABYLON.InterpolateValueAction`
    ([Chapter 7](ch07.html "Chapter 7. Defining Actions on Objects"), *Defining Actions
    on Objects*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这种方法由Babylon.js用于创建`BABYLON.InterpolateValueAction`（[第7章](ch07.html "第7章。在对象上定义动作")，*在对象上定义动作*）。
- en: Managing events
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件管理
- en: 'An advanced use of the Babylon.js animations is to call a function when a specific
    frame is reached. The `BABYLON.AnimationEvent` class exists to allow you to attach
    one or more events to a specific frame. For example, consider the previous example
    (`complexAnimation`), as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js动画的高级用法之一是在达到特定帧时调用一个函数。`BABYLON.AnimationEvent`类存在是为了允许你将一个或多个事件附加到特定帧。例如，考虑之前的例子（`complexAnimation`），如下所示：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using easing functions to smooth animations
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓动函数平滑动画
- en: One of the advanced features of the Babylon.js animations management is to use
    easing functions to smooth well and add behaviors to your animations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js动画管理的先进功能之一是使用缓动函数来平滑动画并添加行为。
- en: To take a quick look at the appearance of the easing functions (we do not necessarily
    remember every type of easing functions), you should follow this link ([http://easings.net/en](http://easings.net/en)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速查看缓动函数的外观（我们不一定记得每种缓动函数），你应该点击此链接（[http://easings.net/en](http://easings.net/en)）。
- en: Applying an easing function to an animation
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将缓动函数应用于动画
- en: To apply an easing function to an animation, the method only consists of customizing
    an already created animation. You'll just have to call the `.setEasingFunction`
    method for an animation with an easing function as the parameter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要将缓动函数应用于动画，方法仅包括自定义已创建的动画。你只需为具有缓动函数的动画调用`.setEasingFunction`方法即可。
- en: 'The available easing functions are (with the associated curve in time) as shown
    in the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的缓动函数（与时间相关的曲线）如下所示：
- en: Circle ease: `BABYLON.CircleEase()`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形缓动：`BABYLON.CircleEase()`
- en: '![Applying an easing function to an animation](img/image_09_004.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_004.png)'
- en: Back ease: `BABYLON.BackEase(amplitude)`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后退缓动：`BABYLON.BackEase(amplitude)`
- en: '![Applying an easing function to an animation](img/image_09_005.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_005.png)'
- en: Bounce ease: `BABYLON.BounceEase(bounces, bounciness)`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹跳缓动：`BABYLON.BounceEase(bounces, bounciness)`
- en: '![Applying an easing function to an animation](img/image_09_006.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_006.png)'
- en: Cubic ease: `BABYLON.CubicEase()`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三次方缓动：`BABYLON.CubicEase()`
- en: '![Applying an easing function to an animation](img/image_09_007.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_007.png)'
- en: Elastic ease: `BABYLON.ElasticEase(oscillations, springiness)`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性缓动：`BABYLON.ElasticEase(oscillations, springiness)`
- en: '![Applying an easing function to an animation](img/image_09_008.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_008.png)'
- en: Exponential ease: `BABYLON.ExponentialEase(exponent)`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数缓动：`BABYLON.ExponentialEase(exponent)`
- en: '![Applying an easing function to an animation](img/image_09_009.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_009.png)'
- en: Quadratic ease:`BABYLON.QuadraticEase()`
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二次方缓动：`BABYLON.QuadraticEase()`
- en: '![Applying an easing function to an animation](img/image_09_010.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_010.png)'
- en: Quartic ease: `BABYLON.QuarticEase()`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四次方缓动：`BABYLON.QuarticEase()`
- en: '![Applying an easing function to an animation](img/image_09_011.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_011.png)'
- en: Quintic ease: `BABYLON.QuinticEase()`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 五次方缓动：`BABYLON.QuinticEase()`
- en: '![Applying an easing function to an animation](img/image_09_013.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_013.png)'
- en: Sine ease: `BABYLON.SineEase()`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正弦缓动：`BABYLON.SineEase()`
- en: '![Applying an easing function to an animation](img/image_09_012.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![将缓动函数应用于动画](img/image_09_012.png)'
- en: 'Let''s start with the following simple example (animate the .x property of
    the box''s rotation using a circle easing function):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下简单的例子开始（使用圆形缓动函数动画化盒子的旋转的.x属性）：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That''s all, the animation will now follow the formula of the circle easing
    function, as shown in the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了，动画现在将遵循圆形缓动函数的公式，如下所示：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As it is hard to represent an animation by taking screenshots, you can try the
    different easing functions by yourself. The method is the same for all the easing
    functions, except that several easing function constructors will need some arguments
    for more customization.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于很难通过截图来表示动画，您可以尝试自己使用不同的缓动函数。对于所有缓动函数，方法都是相同的，除了几个缓动函数构造函数需要一些参数以进行更多定制。
- en: 'Now, let''s modify the behavior of the easing function. An easing function
    consists of modes, as shown in the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改缓动函数的行为。缓动函数由模式组成，如下所示：
- en: '`In`, when the animation starts (enters): `BABYLON.EasingFunction.EASINGMODE_EASEIN`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`In`，当动画开始时（进入）：`BABYLON.EasingFunction.EASINGMODE_EASEIN`'
- en: '`Out`, when the animation is completed (exits): `BABYLON.EasingFunction.EASINGMODE_EASEOUT`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Out`，当动画完成时（退出）：`BABYLON.EasingFunction.EASINGMODE_EASEOUT`'
- en: '`In & Out`, when the animation starts and finishes (both enter and exit): `BABYLON.EasingFunction.EASINGMODE_EASEINOUT`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`In & Out`，当动画开始和结束时（进入和退出）：`BABYLON.EasingFunction.EASINGMODE_EASEINOUT`'
- en: By default, the easing mode is set to `In` (`BABYLON.EasingFunction.EASINGMODE_EASEIN`).
    The website [http://easings.net/en](http://easings.net/en) shows exactly how the
    easing functions look in these three modes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，缓动模式设置为`In`（`BABYLON.EasingFunction.EASINGMODE_EASEIN`）。网站[http://easings.net/en](http://easings.net/en)显示了在这三种模式下缓动函数的确切外观。
- en: 'To specify the easing mode, just call the `.setEasingMode` method on an animation,
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定缓动模式，只需在动画上调用`.setEasingMode`方法，如下所示：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating your own easing function
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您自己的缓动函数
- en: For the last sub-topic about easing functions, let's discuss how to create your
    own easing function if it is not available in Babylon.js. The process is really
    simple (except the possible difficult mathematical formula(s) associated with your
    easing function).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关于缓动函数的最后一个子主题，让我们讨论如果 Babylon.js 中没有可用的情况下如何创建自己的缓动函数。这个过程非常简单（除了可能与您的缓动函数相关的可能的困难数学公式）。
- en: 'Just create a class that inherits from the `BABYLON.EasingFunction` class that
    implements the `BABYLON.IEasingFunction` interface. The only thing to do is to
    implement the `.easeInCore(gradient: number)` function that takes the interpolated
    value as the parameter.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '只需创建一个继承自`BABYLON.EasingFunction`类并实现`BABYLON.IEasingFunction`接口的类。唯一要做的就是实现`.easeInCore(gradient:
    number)`函数，该函数接受插值值作为参数。'
- en: 'Let''s create an example with a Power easing function, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个幂缓动函数的例子来创建一个示例，如下所示：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Importing and managing animated models
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和管理动画模型
- en: To finish this chapter with a cool demo, let's discuss how to animate characters
    or 3D models, in general.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以一个酷炫的演示结束本章，让我们讨论如何动画化角色或3D模型，通常来说。
- en: How 3D animated models work
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D 动画模型是如何工作的
- en: If you remember, each vertex of a 3D model is computed to be projected on the
    screen by a vertex shader. In fact, the animated 3D models (such as a character)
    are also animated with the associated hierarchy of bones (the hierarchy is called **Skeleton**).
    Animated 3D models are also called **Skinned Meshes**. In 3D engines, the bones
    are invisible nodes that are animated (`BABYLON.Animation`) to be sent to the
    vertex shader associated with the 3D model. In other words, the transformation
    of each bone is sent to the vertex shader and is applied to the associated vertices.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，3D 模型的每个顶点都是由顶点着色器计算并投影到屏幕上的。实际上，动画的 3D 模型（如角色）也是通过相关的骨骼层次结构（该层次结构称为**骨骼**）进行动画化的。动画的
    3D 模型也称为**蒙皮网格**。在 3D 引擎中，骨骼是无形的节点，它们被动画化（`BABYLON.Animation`）并发送到与 3D 模型关联的顶点着色器。换句话说，每个骨骼的变换被发送到顶点着色器并应用于相关的顶点。
- en: 'To go further in the theory, the vertex shader contains the following two additional
    buffers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在理论方面更进一步，顶点着色器包含以下两个额外的缓冲区：
- en: The bones' matrices weights (Vector4, represents the *intensity* of the influence
    of each bone on the current vertex).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨骼的矩阵权重（Vector4，表示每个骨骼对当前顶点的*影响力*强度）。
- en: The bones' matrices indices (Vector4, until four bone influences per vertex)
    work like the indices buffer, but for bones. In other words, for each vertex,
    which bones influence the vertex (indices in the array of bones' transformations).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨骼的矩阵索引（Vector4，直到每个顶点四个骨骼影响）就像索引缓冲区一样，但用于骨骼。换句话说，对于每个顶点，哪些骨骼影响该顶点（骨骼变换数组中的索引）。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note:** The common buffers for static 3D models are the positions (required),
    indices (required), normals (not required), UVs (texture coordinates, not required),
    and colors (not required).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：静态3D模型的常用缓冲区是位置（必需）、索引（必需）、法线（非必需）、UVs（纹理坐标，非必需）和颜色（非必需）。'
- en: 'Finally, for each vertex, the formula (in GLSL) is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于每个顶点，公式（在GLSL中）如下所示：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When artists export their 3D models (animated with the tools provided by the
    modeling software), the Babylon.js exporters (3ds Max and Blender) explicitly
    write the bones' weights' buffers and the bones' matrices indices buffers in the
    exported file, which arrays of numbers. In conclusion, for animated 3D models,
    you don't have to specify the animations through code, the exporters can do everything
    for you. Let's wait until the next sub-topic to learn how to animate the 3D models.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当艺术家使用建模软件提供的工具导出他们的3D模型（带有动画）时，Babylon.js导出器（3ds Max和Blender）明确地将骨骼的权重缓冲区和骨骼的矩阵索引缓冲区写入导出文件，这些是数字数组。总之，对于动画3D模型，您不需要通过代码指定动画，导出器可以为您完成一切。让我们等到下一个子主题，学习如何动画3D模型。
- en: Importing and playing animations of an animated 3D model
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入并播放动画3D模型的动画
- en: 'To import an animated 3D model, you have to use the `BABYLON.SceneLoader` class
    for the static 3D models ([Chapter 3](ch03.html "Chapter 3. Create, Load, and
    Draw 3D Objects on the Screen"), *Create, Load, and Draw 3D Objects on the Screen*)
    to import an animated 3D model. In fact, the `.Load` (and `.Append`) function
    automatically loads the animated 3D models with the associated skeletons (hierarchy
    of nodes) with the difference that the `.ImportMesh` function''s callback provides
    the loaded meshes, particle systems, and skeletons, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入一个动画3D模型，您必须使用`BABYLON.SceneLoader`类（[第3章](ch03.html "第3章。在屏幕上创建、加载和绘制3D对象")，*创建、加载和绘制3D对象在屏幕上*）来导入动画3D模型。实际上，`.Load`（和`.Append`）函数自动加载带有相关骨骼（节点层次结构）的动画3D模型，与`.ImportMesh`函数的回调提供加载的网格、粒子系统和骨骼不同，如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Concretely, as the animated nodes are the skeletons'' bones, the target of
    the `.beginAnimation` function is only the skeleton associated with your animated
    3D model and not the node itself, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，由于动画节点是骨骼的骨骼，`.beginAnimation`函数的目标只是与您的动画3D模型关联的骨骼，而不是节点本身，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s start an example (available in the example files) using the `.ImportMesh`
    function, as shown in the following snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码片段使用`.ImportMesh`函数开始一个示例（可在示例文件中找到）：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note:** An animated 3D model can contain multiple meshes. This is the reason
    the `ImportMesh` function can return an array of multiple meshes and only one
    skeleton in the array of skeletons.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：一个动画3D模型可以包含多个网格。这就是为什么`ImportMesh`函数可以返回多个网格的数组，以及骨骼数组中只有一个骨骼的原因。'
- en: 'The result (the man is walking and the animation played from frame 0 to 150)
    is as shown in the following image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 结果（人物正在行走，动画从帧0播放到150）如下所示：
- en: '![Importing and playing animations of an animated 3D model](img/image_09_014.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![导入并播放动画3D模型的动画](img/image_09_014.png)'
- en: 'Using the `.Load` function, the method is pretty different. As the success
    callback provides only the loaded scene, you''ll have to find the skeletons stored
    in the scene. To do this, simple use the `.getSkeletonByName` function on the
    scene, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.Load`函数，方法相当不同。因为成功回调只提供加载的场景，您需要找到场景中存储的骨骼。为此，只需在场景上使用`.getSkeletonByName`函数，如下所示：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result with the `dude.babylon` scene using the `.Load` function is as shown
    in the following image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.Load`函数的`dude.babylon`场景的结果如下所示：
- en: '![Importing and playing animations of an animated 3D model](img/image_09_015.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![导入并播放动画3D模型的动画](img/image_09_015.png)'
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Creating animations using Babylon.js can really make your scenes more alive.
    As you can see, these features are also pretty simple to use, following the principle
    of Babylon.js: the KISS principle (Keep It Simple, Stupid).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Babylon.js创建动画可以使您的场景更加生动。如您所见，这些功能也相当简单易用，遵循Babylon.js的原则：KISS原则（保持简单，傻瓜）。
- en: Now, at the end of this book, you are ready to work with the artists and combine
    all the learned features of Babylon.js. Using post-processes, manage and customize
    materials, create and manage animations, load scenes, manage actions, and so on!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在本书的结尾，你已准备好与艺术家们合作，结合 Babylon.js 所学到的所有特性。使用后处理技术，管理和定制材质，创建和管理动画，加载场景，管理动作等等！
- en: To go further, you can have a look at the new features (recently released) such
    as the materials library (a library of specific easy-to-use materials like the
    standard material, such as water, terrain material, PBR, lava, and so on!). One
    of the new features should be the procedural textures automatically handled by
    Babylon.js such as fire, ground, grass, and so on. Also, to go further, you can
    take a look at the particle systems and shadows generator for specific projects
    that need to create some smoke or fire, and more beautiful (but more expansive)
    scenes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 若要更进一步，你可以查看新特性（最近发布），例如材质库（一个包含特定易于使用的材质的库，如标准材质，例如水、地形材质、PBR、熔岩等！）！其中之一的新特性应该是
    Babylon.js 自动处理的程序纹理，如火焰、地面、草地等。此外，若要更进一步，你还可以查看用于特定项目（需要创建一些烟雾或火焰，以及更美丽但更昂贵的场景）的粒子系统和阴影生成器。
- en: Have fun with Babylon.js!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Babylon.js 中享受乐趣！
