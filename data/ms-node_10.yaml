- en: Testing Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的应用程序
- en: '"When the terrain disagrees with the map, trust the terrain."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “当地形与地图不符时，请相信地形。”
- en: – Swiss Army Manual
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 瑞士军刀手册'
- en: Since Node is being built by a community fully committed to code sharing, where
    interoperability between modules is so important, it should come as no surprise
    that code testing tools and frameworks entered Node's ecosystem right after inception.
    Indeed, the normally parsimonious core Node team added the `assert` module early
    on, suggesting a recognition that testing is a fundamental part of the development
    process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node是由一个完全致力于代码共享的社区构建的，模块之间的互操作性非常重要，因此毫不奇怪的是，在Node的生态系统中，代码测试工具和框架在创立后不久就进入了。事实上，通常吝啬的核心Node团队很早就添加了`assert`模块，这表明他们认识到测试是开发过程的基本部分。
- en: Testing is not solely a bug-detecting and defect-fixing process. Test-Driven
    Development, for example, insists on having tests precede the existence of any
    code! Testing, generally, is the process of making comparisons between the existing
    behavior and desired behavior in software, where new information is continuously
    fed back into the process. In this sense, testing involves modeling expectations
    and verifying that individual functions, composed units, and implementation paths
    satisfy the expectations of every stakeholder, both within and beyond the boundaries
    of an organization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不仅仅是一个检测错误和修复缺陷的过程。例如，测试驱动开发坚持在任何代码存在之前进行测试！一般来说，测试是在软件中对现有行为和期望行为进行比较的过程，其中新信息不断地反馈到过程中。在这个意义上，测试涉及对期望进行建模，并验证单个功能、组成单元和实现路径是否满足每个利益相关者的期望，无论是在组织内部还是超出组织范围。
- en: Testing is, therefore, also about managing risk. In this way, anomalies can
    be identified and quantified, while bumps in the terrain can now usefully inform
    our current understanding of the map such that the number of missteps (or defects)
    decline and our confidence rises. Testing helps us measure when we are done.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试也是关于管理风险。通过这种方式，异常可以被识别和量化，而地形中的颠簸现在可以有用地影响我们对地图的当前理解，从而缺陷的数量减少，我们的信心提高。测试帮助我们衡量何时完成。
- en: In this chapter, we will focus on some known and useful patterns for testing
    Node applications, investigating native Node tools for code integrity testing,
    general testing with the Mocha framework, and headless browser testing, the last
    allowing for the testing of browser-based JavaScript from within a Node environment.
    We'll also be looking at the other side of the testing coin—debugging—and combine
    the two.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于一些已知和有用的测试Node应用程序的模式，调查用于代码完整性测试的原生Node工具，使用Mocha框架进行一般测试，以及无头浏览器测试，最后一种允许在Node环境中测试基于浏览器的JavaScript。我们还将看看测试的另一面——调试——并将两者结合起来。
- en: As you move through this chapter, it might be useful to keep in mind that integrating
    the philosophy of testing into a project can be difficult to do well. Writing
    the right tests is more difficult than writing some tests. Testing the right things
    is more difficult than testing everything (full code coverage seldom means nothing
    can go wrong). A good testing strategy should be implemented as early as possible—something
    to consider as you embark on your next Node project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读本章时，牢记将测试哲学融入项目可能很难做到。编写正确的测试比编写一些测试更困难。测试正确的事情比测试所有事情更困难（完整的代码覆盖很少意味着什么都不会出错）。一个好的测试策略应该尽早实施——这是您开始下一个Node项目时需要考虑的事情。
- en: Why testing is important
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么测试很重要
- en: A good testing strategy builds confidence through the accumulation of proof
    and increasing clarity. Within a company, this might mean that some criteria for
    the execution of a business strategy have been satisfied, allowing for the release
    of a new service or product. The developers within a project team gain the pleasure
    of an automated judge that confirms or denies whether changes committed to a code
    base are sound. With a good testing framework, refactoring loses its danger; the
    "if you break it you own it" caveat that once placed negative pressure on developers
    with new ideas is no longer as ominous. Given a good version control system and
    test/release process, any breaking change can be rolled back without negative
    impact, freeing curiosity and experimentation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试策略通过积累证据和增加清晰度来建立信心。在公司内部，这可能意味着某些执行业务策略的标准已经得到满足，从而允许发布新的服务或产品。项目团队内的开发人员获得了一个自动的法官，确认或否认提交到代码库的更改是否合理。有了一个良好的测试框架，重构就不再危险；曾经对具有新想法的开发人员施加负面压力的“如果你破坏了它，你就拥有它”的警告不再那么可怕。有了一个良好的版本控制系统和测试/发布流程，任何破坏性的更改都可以在没有负面影响的情况下回滚，释放好奇心和实验精神。
- en: 'Three common types of tests are: unit tests, functional tests, and integration
    tests. While our goal in this chapter is not to put forward a general theory about
    how to test applications, it will be useful to briefly summarize what unit, functional,
    and integration tests are, which members of a team are most interested in each,
    and how we might go about building up (or breaking up) a code base into testable
    units.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 三种常见的测试类型是：单元测试、功能测试和集成测试。虽然我们在本章的目标不是提出关于如何测试应用程序的一般理论，但简要总结单元测试、功能测试和集成测试是有用的，团队的哪些成员对每种测试最感兴趣，以及我们如何构建（或拆分）一个可测试的代码库。
- en: Unit tests
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: '**Unit tests** concern themselves with units of system behavior. Each unit
    being tested should encapsulate a very small set of code paths, without entanglements.
    When a unit test fails, this should, ideally, indicate that an isolated part of
    the overall functionality is broken. If a program has a well-described set of
    unit tests, the purpose and expected behavior of an entire program should be easy
    to comprehend. A unit test applies a limited perspective to small parts of a system,
    unconcerned with how those parts may be wrapped up into larger functional blocks.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**关注系统行为的单元。每个被测试的单元应该封装一个非常小的代码路径集，没有纠缠。当一个单元测试失败时，这应该理想地表明整体功能的一个孤立部分出现了问题。如果一个程序有一组明确定义的单元测试，整个程序的目的和预期行为应该很容易理解。单元测试对系统的小部分应用了有限的视角，不关心这些部分如何被包装成更大的功能块。'
- en: An example unit test might be described in this way; when the `123` value is
    passed to a `validate_phone_number()` method, the test should return false. There
    is no confusion about what this unit does, and a programmer can use it with confidence.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例单元测试可以这样描述：当“123”值传递给“validate_phone_number（）”方法时，测试应该返回false。对于这个单元的功能没有困惑，程序员可以放心使用它。
- en: Unit tests are normally written and read by programmers. Class methods are good
    candidates for unit tests, as are other service endpoints whose input signatures
    are stable and well understood, with expected outputs that can be accurately validated.
    Generally, it is assumed that unit tests run quickly. If a unit test is taking
    a long time to execute, it is likely that the code under test is much more complex
    than it should be.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常由程序员编写和阅读。类方法是良好的单元测试候选者，其他服务端点的输入签名稳定且被充分理解，预期输出可以被准确验证。通常假定单元测试运行速度快。如果一个单元测试执行时间很长，很可能是被测试的代码比应该的复杂。
- en: 'Unit tests are not concerned with how a function or method will receive its
    inputs, or how it will be used in general. A test for an `add` method shouldn''t
    be concerned with whether the method will be used in a calculator or somewhere
    else, it should simply test whether the two integer inputs (3,4) will cause the
    unit to emit a correct result (7). A unit test is not interested in where it fits
    in the dependency tree. For this reason, unit tests will often *mock* or *stub*
    data sources, such as passing two sample integers to an `add` method. As long
    as the inputs are typical, they need not be actual. Additionally, good unit tests
    are reliable: unencumbered by external dependencies, they should remain valid,
    regardless of how the system around them changes.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不关心函数或方法将如何接收其输入，或者它将如何在一般情况下被使用。对于“add”方法的测试不应该关心该方法是否将被用于计算器或其他地方，它应该简单地测试两个整数输入（3,4）是否会导致该单元产生正确的结果（7）。单元测试不关心它在依赖树中的位置。因此，单元测试通常会*模拟*或*存根*数据源，例如将两个示例整数传递给“add”方法。只要输入是典型的，它们不必是实际的。此外，良好的单元测试是可靠的：不受外部依赖的影响，它们应该保持有效，无论周围的系统如何变化。
- en: Unit tests only confirm that a single entity works in isolation. Testing whether
    units can work well when combined is the purpose of functional testing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试只确认单个实体在隔离状态下工作。测试单元能否在组合时良好工作是功能测试的目的。
- en: Functional tests
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: Where unit tests concern themselves with specific behaviors, **functional tests**
    are designed to validate pieces of functionality. The ambiguity of the root word
    *function*, especially for programmers, can lead to confusion, where *unit tests*
    are called *functional tests*, and vice versa. A functional test combines many
    units into a body of functionality, such as *when a user enters a username and
    password and clicks on send, that user will be logged into the system*. We can
    easily see that this functional group will comprise of many unit tests, one for
    validating a username, one for handling a button click, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试关注特定行为的同时，**功能测试**旨在验证功能的各个部分。根词*function*的模棱两可，特别是对程序员来说，可能会导致混淆，即*单元测试*被称为*功能测试*，反之亦然。功能测试将许多单元组合成一个功能体，例如*当用户输入用户名和密码并点击发送时，该用户将被登录到系统*。我们很容易看到这个功能组将包括许多单元测试，一个用于验证用户名，一个用于处理按钮点击，等等。
- en: Functional tests are normally the concern of those responsible for some specific
    domain within an application. While programmers and developers will remain the
    ones to implement these tests, product managers or similar stakeholders will normally
    devise them (and complain when they fail). These tests for the most part check
    whether larger product specifications are being satisfied, rather than for technical
    correctness.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试通常是应用程序中某个特定领域的负责人关心的事情。虽然程序员和开发人员将继续实施这些测试，但产品经理或类似的利益相关者通常会设计它们（并在它们失败时抱怨）。这些测试在很大程度上检查较大的产品规格是否得到满足，而不是技术上的正确性。
- en: 'The example unit test for `validate_phone_number` given earlier might form
    part of a functional test with this description: when a user enters the wrong
    phone number, display a help message that describes the right format in that user''s
    country. That an application bothers to help users who make mistakes with phone
    numbers is an abstract effort very different from simply validating a technical
    entity like a phone number. Functional tests might be thought of as abstract models
    of how well some collection of units work together to satisfy a product need.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面给出的“validate_phone_number”的示例单元测试可能构成一个功能测试的一部分，描述如下：当用户输入错误的电话号码时，在该用户的国家显示一个描述正确格式的帮助消息。一个应用程序会帮助那些在电话号码上犯错误的用户，这是一个非常抽象的努力，与简单验证电话号码这样的技术实体完全不同。功能测试可以被认为是一些单元的抽象模型，它们如何一起满足产品需求。
- en: As functional tests are made against combinations of many units, it is expected
    that, unlike an isolated unit test, executing them will involve mixing concerns
    from any number of external objects or systems. In the preceding login example,
    we see how a relatively simple functional test can cut across database, UI, security,
    and other application layers. As it is compositionally more complex, it's OK if
    functional tests take a little more time to run than unit tests. Functional tests
    are expected to change less often than unit tests, such that changes in functionality
    often represent major releases, as opposed to the minor changes unit test modifications
    usually indicate.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于功能测试是针对许多单元的组合进行的，因此可以预期，与孤立的单元测试不同，执行它们将涉及混合来自任意数量的外部对象或系统的关注点。在前面的登录示例中，我们看到一个相对简单的功能测试如何涉及数据库、UI、安全性和其他应用层。由于它的组合更复杂，功能测试花费的时间比单元测试多一点是可以接受的。功能测试预计变化不如单元测试频繁，因此功能的变化通常代表主要发布，而不是通常表示较小变化的单元测试修改。
- en: Note that, like unit tests, functional tests are themselves isolated from concerns
    about how the functional group under test, as a whole, relates to the rest of
    an application. For this reason, mock data may be used as a context for running
    functional tests, as the functional group itself is not concerned with its effect
    on general application state, which is the domain of integration tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与单元测试一样，功能测试本身与功能组在整个应用程序中的关系无关。因此，可以使用模拟数据作为运行功能测试的上下文，因为功能组本身不关心其对一般应用程序状态的影响，这是集成测试的领域。
- en: Integration tests
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: '**Integration tests** ensure that the entire system is correctly wired together,
    so that a user would feel that the application is working correctly. In this way,
    integration tests typically validate the expected functionality of an entire application,
    or one of a small set of significant product functionality.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**确保整个系统正确连接在一起，以便用户感觉应用程序正常工作。因此，集成测试通常验证整个应用程序的预期功能，或者验证一组重要产品功能中的一个。'
- en: The most important difference between integration and the other types of tests
    under discussion is that integration tests are to be executed within a realistic
    environment, on real databases with actual domain data, on servers, and other
    systems mirroring the target production environment. In this way, integration
    tests can easily break formerly passing unit and functional tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试与讨论中的其他测试类型最重要的区别在于，集成测试应在真实环境中执行，使用真实数据库和实际域数据，在服务器和其他系统上模拟目标生产环境。这样，集成测试很容易破坏以前通过的单元和功能测试。
- en: For example, a unit test for `validate_phone_number` may have given a pass to
    an input like `555-123-4567`, but during an integration test, it will fail to
    pass some real (and valid) system data like `555.123.4567`. Similarly, a functional
    test may successfully test the ability of an ideal system to open a help dialog,
    but when integrated with a new browser or other runtime, it is found that the
    expected functionality is not achieved. An application that runs well against
    a single local filesystem may fail when run against a distributed filesystem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于`validate_phone_number`的单元测试可能会通过像`555-123-4567`这样的输入，但在集成测试中，它将无法通过一些真实（且有效）的系统数据，比如`555.123.4567`。同样，功能测试可能成功测试理想系统打开帮助对话框的能力，但当与新的浏览器或其他运行时集成时，发现无法实现预期的功能。一个在单个本地文件系统上运行良好的应用程序，在分布式文件系统上运行时可能会失败。
- en: Due to this added complexity, system architects—the team members that are able
    to apply a higher-level perspective on what system correctness entails—normally
    design integration tests. These tests find errors in the wiring that isolated
    tests are not able to recognize. Not surprisingly, integration tests can often
    take a long time to run, typically designed to not only run simple scenarios but
    to imitate expected high-load, realistic environments.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于增加了这种复杂性，系统架构师——能够对系统正确性应用更高层次的视角的团队成员——通常设计集成测试。这些测试可以发现孤立测试无法识别的连接错误。毫不奇怪，集成测试通常需要很长时间才能运行，通常设计为不仅运行简单场景，而且模拟预期的高负载、真实环境。
- en: Native Node testing and debugging tools
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地节点测试和调试工具
- en: A preference for tested code has formed part of the Node community's ethos since
    its inception, reflected in the fact that most popular Node modules, even simple
    ones, are distributed with test suites. While browser-side development with JavaScript
    suffered for many years without usable testing tools, the relatively young Node
    distribution contains many. Perhaps because of this, many mature and easy-to-use
    third-party testing frameworks have been developed for Node. This leaves a developer
    no excuse for writing untested code! Let's look into some of the provided tools
    for debugging and testing Node programs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 自从诞生以来，对经过测试的代码的偏好一直是Node社区理念的一部分，这反映在大多数流行的Node模块，甚至简单的模块，都附带了测试套件。而在许多年里，没有可用的测试工具，JavaScript在浏览器端的开发一直备受困扰，而相对年轻的Node分发包含了许多测试工具。也许正因为如此，为Node开发了许多成熟且易于使用的第三方测试框架。这使得开发人员没有借口编写未经测试的代码！让我们来看看一些用于调试和测试Node程序的提供的工具。
- en: Writing to the console
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入控制台
- en: Console output is the most basic testing and debugging tool, providing a quick
    way to see what is happening at some point in a script. The globally accessible
    `console.log` is commonly used when debugging.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是最基本的测试和调试工具，提供了一个快速查看脚本中发生情况的方式。全局可访问的`console.log`通常用于调试。
- en: Node has enriched this standard output mechanism with more useful methods, such
    as `console.error(String, String…)`, which prints arguments to `stderr` rather
    than `stdout`, and `console.dir(Object)`, which runs `util.inspect` (refer to
    the following) on the provided object and writes results to `stdout`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Node已经丰富了标准输出机制，增加了更多有用的方法，比如`console.error(String, String…)`，它将参数打印到`stderr`而不是`stdout`，以及`console.dir(Object)`，它在提供的对象上运行`util.inspect`（参见下文）并将结果写入`stdout`。
- en: 'The following pattern is commonly seen when a developer wants to track how
    long a piece of code takes to execute:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员想要跟踪代码执行所需时间时，通常会看到以下模式：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `console.time` and `console.timeEnd` methods standardize this pattern:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.time`和`console.timeEnd`方法标准化了这种模式：'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ensure that you pass the same label to `timeEnd()` so that Node can find the
    measurement you started with `time()`. Node prints the stopwatch result to `stdout`.
    We will see other special console methods when discussing the assert module and
    performing stack traces later in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将相同的标签传递给`timeEnd()`，以便Node可以找到您使用`time()`开始的测量。Node将秒表结果打印到`stdout`。在本章后面讨论断言模块和执行堆栈跟踪时，我们将看到其他特殊的控制台方法。
- en: Formatting console output
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化控制台输出
- en: The preceding methods are all very useful when logging simple strings. More
    often, useful logging data may need to be formatted, either by composing several
    values into a single string, or by neatly displaying a complex data object. The
    `util.format` and `util.inspect` methods can be used to handle these cases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录简单字符串时，上述方法都非常有用。更常见的是，有用的日志数据可能需要进行格式化，可以通过将几个值组合成单个字符串，或者通过整齐地显示复杂的数据对象来处理。`util.format`和`util.inspect`方法可以用来处理这些情况。
- en: The util.format(format, [arg, arg…]) method
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`util.format(format，[arg，arg…])`方法'
- en: 'This method allows a formatting string to be composed out of placeholders,
    each of which captures and displays the additional values passed. Consider the
    following example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许将格式化字符串组成占位符，每个占位符都捕获并显示传递的附加值。考虑以下示例：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we see that the two placeholders (prefixed by `%`) are replaced in order
    by the passed arguments. Placeholders expect one of the following three types
    of values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到两个占位符（以`％`为前缀）按顺序被传递的参数替换。占位符期望以下三种类型的值之一：
- en: '`%s`: A string'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％s`：字符串'
- en: '`%d`: A number, either an integer or a float'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％d`：数字，可以是整数或浮点数'
- en: '`%j`: A JSON object'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％j`：JSON对象'
- en: 'If a greater number of arguments than placeholders is sent, the extra arguments
    are converted to strings via `util.inspect()`, and concatenated to the end of
    the output, separated by spaces:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发送的参数数量多于占位符数量，则额外的参数将通过`util.inspect()`转换为字符串，并连接到输出的末尾，用空格分隔：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If no formatting string is sent, the arguments are simply converted to strings
    and concatenated, separated by a space.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发送格式化字符串，则参数将被简单地转换为字符串并用空格分隔连接。
- en: The util.inspect(object, [options]) method
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`util.inspect(object，[options])`方法'
- en: 'Use this method when a string representation of an object is desired. Through
    the setting of various options, the look of the output can be controlled:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要对象的字符串表示时，请使用此方法。通过设置各种选项，可以控制输出的外观：
- en: '`showHidden`: Defaults to false. If true, the object''s non-enumerable properties
    will be shown.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showHidden`：默认为false。如果为true，则会显示对象的不可枚举属性。'
- en: '`depth`: An object definition, such as a JSON object, can be deeply nested.
    By default, `util.inspect` only traverses two levels into the object. Use this
    option to increase (or decrease) that depth.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depth`：对象定义（例如JSON对象）可以被深度嵌套。默认情况下，`util.inspect`只会遍历对象的两个级别。使用此选项来增加（或减少）深度。'
- en: '`colors`: Allows the colorization of the output (check out the following code
    snippet).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colors`：允许对输出进行着色（请查看以下代码片段）。'
- en: '`customInspect`: If the object being processed has an `inspect` method defined,
    the output of that method will be used instead of Node''s default `stringification`
    method (refer to the following code snippet). Defaults to true.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customInspect`：如果正在处理的对象定义了`inspect`方法，则将使用该方法的输出，而不是Node的默认`stringification`方法（参见以下代码片段）。默认为true。'
- en: 'Setting a custom inspector:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置自定义检查器：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This can be very useful when logging complex objects, or objects whose values
    are so large as to make console output unreadable. If your shell is showing pretty
    colors in your terminal, `util.inspect` will too if color is set to true. You
    can even customize which colors, and how they are used. By default, the colors
    just indicate the data type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录复杂对象或对象的值过大以至于使控制台输出无法阅读时，这可能非常有用。如果您的shell在终端中显示漂亮的颜色，如果颜色设置为true，`util.inspect`也会显示漂亮的颜色。您甚至可以自定义颜色以及它们的使用方式。默认情况下，颜色只表示数据类型。
- en: 'Here are the defaults, as set in `util.inspect.styles`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是默认设置，如在`util.inspect.styles`中设置的：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Node shows functions in cyan under the special category in the preceding code.
    These default color assignments may be swapped out with one of the supported ANSI
    color codes stored in the `util.inspect.colors` object: bold, italic, underline,
    inverse, white, grey, black, blue, cyan, green, magenta, red, and yellow. For
    example, to have the number values of objects displayed in green rather than the
    default of yellow, use the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，Node以青色显示特殊类别中的函数。这些默认颜色分配可以与`util.inspect.colors`对象中存储的支持的ANSI颜色代码之一进行交换：粗体，斜体，下划线，反向，白色，灰色，黑色，蓝色，青色，绿色，品红色，红色和黄色。例如，要将对象的数字值显示为绿色而不是默认的黄色，请使用以下代码：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Node debugger
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node调试器
- en: Most developers have used an IDE for development. A key feature of all good
    development environments is access to a debugger, which allows breakpoints to
    be set in a program in places where state or other aspects of the runtime need
    to be checked.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员都使用IDE进行开发。所有良好的开发环境的一个关键特性是可以访问调试器，它允许在程序中设置断点，以便在需要检查状态或运行时的其他方面的地方进行检查。
- en: 'V8 comes with a powerful debugger (commonly seen powering the Google Chrome
    browser''s developer tools panel), and this debugger is accessible to Node. It
    is invoked using the inspect directive:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: V8带有一个强大的调试器（通常用于Google Chrome浏览器的开发者工具面板），并且此调试器可供Node访问。它是使用inspect指令调用的：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Simple step-through and inspection debugging can now be achieved within a node
    program. Consider the following program:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在节点程序中实现简单的逐步调试和检查。考虑以下程序：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `dummyVar` will make sense in a second. For now, note the `debugger` directive.
    Executing this program without that line runs the program as you would expect:
    print `hello`, wait a second, and then print `world`. With the debugger directive,
    running inspect produces this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`dummyVar`一会儿就会有意义。现在注意`debugger`指令。在没有该行的情况下执行此程序会像您期望的那样运行：打印`hello`，等待一秒，然后打印`world`。有了调试器指令，运行inspect会产生这样的结果：'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The debugger directive creates a break point, and once hit, Node gives us a
    CLI to the debugger itself, from within which we can execute some standard debugging
    commands:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器指令创建一个断点，一旦命中，Node会给我们一个CLI来执行一些标准的调试命令：
- en: '`cont` or `c`: Continue execution from the last break point, until the next
    break point'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cont`或`c`：从上一个断点继续执行，直到下一个断点'
- en: '`step` or `s`: Step in, that is, keep running until a new source line (or break
    point) is hit, then return control to debugger'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`或`s`：步进，即继续运行直到命中新的源行（或断点），然后将控制返回给调试器'
- en: '`next` or `n`: The same as `step`, but function calls made on the new source
    line are executed without stopping'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`或`n`：与`step`相同，但在新的源行上进行的函数调用会在不停止的情况下执行'
- en: '`out` or `o`: Step out, that is, execute the remainder of the current function
    and back out to the parent function'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out`或`o`：跳出，即执行当前函数的其余部分并返回到父函数'
- en: '`backtrace` or `bt`: Trace the steps to the current execution frame'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backtrace`或`bt`：跟踪到当前执行帧的步骤'
- en: '`setBreakpoint()` or `sb()`: Set a break point on the current line'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setBreakpoint()`或`sb()`：在当前行设置断点'
- en: '`setBreakpoint(Integer)` or `sb(Integer)`: Set a break point on'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setBreakpoint(Integer)`或`sb(Integer)`：在指定行设置断点'
- en: the specified line
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定的行
- en: '`clearBreakpoint()` or `cb()`: Clear break point on the current line'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearBreakpoint()`或`cb()`：清除当前行的断点'
- en: '`clearBreakpoint(Integer)` or `cb(Integer)`: Clear a break point'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearBreakpoint(Integer)`或`cb(Integer)`：清除断点'
- en: on the specified line
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定的行
- en: '`run`: If the debugger''s script has terminated, this will start it again'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：如果调试器的脚本已终止，这将重新启动它'
- en: '`restart`: Terminates and restarts the script'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：终止并重新启动脚本'
- en: '`pause` or `p`: Pause running code'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause`或`p`：暂停运行的代码'
- en: '`kill`: Kill the running script'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill`：终止正在运行的脚本'
- en: '`quit`: Exit the debugger'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quit`：退出调试器'
- en: '`version`: Display V8 version'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：显示V8版本'
- en: '`scripts`: Lists all loaded scripts'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`：列出所有加载的脚本'
- en: To repeat the last debugger command, simply press *Enter* on your keyboard.
    Your carpal tunnels will thank you.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重复上次的调试器命令，只需在键盘上按*Enter*。你的腕管道会感谢你。
- en: 'Returning to the script we are debugging: entering `cont` into the debugger
    will result in the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们正在调试的脚本：在调试器中输入`cont`将产生以下输出：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We're now stopped at the debugger statement on line 3 (note the chevron). If
    you now, for example, type `next` (or `n`,) the debugger will step to the next
    instruction and stop at `console.log('world')`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们停在第3行的调试器语句处（注意尖括号）。例如，如果现在输入`next`（或`n`），调试器将跳到下一条指令并停在`console.log('world')`处。
- en: It is normally useful at a break point to do some state inspection, such as
    the value of variables. You can jump into the **repl** from the debugger in order
    to do that. Currently, we're paused at the `debugger` statement. What if we wanted
    to check the value of `dummyVar`?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在断点处通常有用进行一些状态检查，比如变量的值。您可以从调试器中跳转到**repl**以执行此操作。目前，我们在`debugger`语句处暂停。如果我们想要检查`dummyVar`的值怎么办？
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As an experiment, run the script again, using `next` instead of `cont`, just
    before the execution of this final context. Keep hitting Enter (which repeats
    your last command) and try to follow the code that is being executed. After a
    few steps you''ll notice that the `timers.js` script will be introduced into this
    execution context, and you''ll see something like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实验，再次运行脚本，使用`next`而不是`cont`，在最后一个上下文执行之前。不断按Enter（重复上次的命令），尝试跟踪正在执行的代码。几步之后，您会注意到`timers.js`脚本将被引入到这个执行上下文中，并且您会看到类似以下的内容：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the `scripts` command in the debugger at this point, which lists currently
    loaded scripts. You will see something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上在调试器中运行`scripts`命令，列出当前加载的脚本。您会看到类似这样的内容：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Experiment with various methods of using the powerful V8 debugger to pause,
    inspect, and navigate within your Node program. Beyond common debugging needs,
    the debugger is great at showing you what Node does at a deep level when executing
    your code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用强大的V8调试器来暂停、检查和在Node程序中进行导航的各种方法。除了常见的调试需求外，调试器在执行代码时以深层次显示Node的操作非常出色。
- en: Later in this chapter, we'll return to a discussion of other debugging and testing
    techniques and tools available to the Node developer. For now, let's consider
    the `assert` module, and how to deploy this native testing framework provided
    with Node.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将回顾其他可用于Node开发人员的调试和测试技术和工具。现在，让我们考虑`assert`模块，以及如何使用Node提供的这个本地测试框架。
- en: The assert module
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: assert模块
- en: 'Node''s `assert` module is used for simple unit testing. In many cases, it
    suffices as a basic scaffolding for tests, or is used as the assertion library
    for testing frameworks (such as Mocha, as we''ll see later). Usage is straightforward:
    we want to assert the truth of something, and throw an error if our assertion
    is not true. Consider this example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Node的`assert`模块用于简单的单元测试。在许多情况下，它足以作为测试的基本脚手架，或者用作测试框架（如Mocha，稍后我们将看到）的断言库。使用起来很简单：我们想要断言某些事情的真实性，并在我们的断言不为真时抛出错误。考虑这个例子：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the assertion were true (both values are equal), nothing would be returned:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言为真（两个值相等），则不会返回任何内容：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Following the UNIX Rule of Silence (when a program has nothing surprising, interesting,
    or useful to say, it should say nothing), assertions only return a value when
    the assertion fails. The value returned can be customized using an optional message
    argument, as seen in the preceding section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循UNIX的沉默规则（当程序没有令人惊讶、有趣或有用的内容时，它应该保持沉默），断言只有在断言失败时才返回一个值。返回的值可以使用可选的消息参数进行自定义，就像前面的部分所示的那样。
- en: 'The `assert` module API is composed of a set of comparison operations with
    identical call signatures: the actual value, the expected value, and an optional
    message to display when the comparison fails. Alternate methods functioning as
    shortcuts or handlers for special cases are also provided.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`模块API由一组具有相同调用签名的比较操作组成：实际值，期望值和可选消息（在比较失败时显示）。还提供了作为快捷方式或处理特殊情况的替代方法。'
- en: 'A distinction must be made between identity comparison (`===`) and equality
    comparison (`==`), the former often referred to as strict equality comparison
    (as is the case in the `assert` API). As JavaScript employs dynamic typing, when
    two values of different types are compared using the `==` equality operator, an
    attempt is made to coerce (or cast) one value into the other, a sort of common
    denominator operation. Take a look at this example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 必须区分身份比较（`===`）和相等比较（`==`），前者通常被称为严格相等比较（就像在`assert`API中一样）。由于JavaScript采用动态类型，当使用`==`相等运算符比较不同类型的两个值时，会尝试强制（或转换）一个值为另一个值，一种通用的操作。看看这个例子：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note the more predictable results when identity comparison is used:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用身份比较时结果更可预测：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The thing to remember is that the `===` operator does not perform type coercion
    prior to the comparison, while the equality operator compares after type coercion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的是，在比较之前，`===`运算符不执行类型强制转换，而相等运算符在类型强制转换后进行比较。
- en: Equating strings and numerals makes JavaScript a forgiving language for newcomers
    to programming, and soon after, creates a bug the now more experienced programmer
    inadvertantly hid in a larger code base. Language authors such as *Brendan Eich*
    make decisions like these, and are seldom able to change behavior so fundamental
    later on, and they have to defend their decisions through unending arguments and
    controversy as programmers bash and laud their languages because of them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串和数字相等使JavaScript成为新手编程的宽容语言，并且很快，创建了一个错误，现在更有经验的程序员无意中隐藏在更大的代码库中。像*Brendan
    Eich*这样的语言作者做出这样的决定，并且很少能够在以后改变如此基本的行为，他们必须通过无休止的争论和争议来捍卫他们的决定，因为程序员们因此而抨击和赞扬他们的语言。
- en: 'Additionally, because objects may contain the same values but not be derived
    from the same constructor, the identity of two objects with the same values is
    distinct; identity requires that both operands refer to the same object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为对象可能包含相同的值但不是由相同的构造函数派生，因此具有相同值的两个对象的身份是不同的；身份要求两个操作数引用同一对象：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, the concept of deep equality is used for object comparisons where
    identity need not be exact. Two objects are deeply equal if they both possess
    the same number of owned properties, the same prototype, the same set (though
    not necessarily the same order) of keys, and equivalent (not identical) values
    for each of their properties:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，深度相等的概念用于对象比较，其中身份不需要完全相同。如果两个对象都拥有相同数量的自有属性，相同的原型，相同的键集（尽管不一定是相同的顺序），并且每个属性的值是等效的（而不是相同的），则两个对象是深度相等的：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is useful to test your assumptions about how values are understood in comparison
    to each other by designing some assertion tests. The results may surprise you.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设计一些断言测试来测试您对值如何相互理解的假设是很有用的。结果可能会让您感到惊讶。
- en: 'Here are the functions in Node''s assert module, organized into groups based
    on how you might use them:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Node的assert模块中的函数，根据您可能使用它们的方式进行组织：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using an assert function with equal in the name follows the same rules as the
    `==` operator, while strict equal is like using `===` instead. Additionally, choose
    a function with deep in the title, or not, to pick the desired behavior we explored
    earlier. The simplest function, `assert.ok`, can be all you need if you write
    the logic of equating yourself.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有相等名称的断言函数遵循与`==`运算符相同的规则，而严格相等就像使用`===`一样。此外，选择一个标题中带有深度的函数，或者不带，以选择我们之前探索的所需行为。最简单的函数`assert.ok`，如果您自己编写逻辑来等同，可能就是您所需要的全部。
- en: 'Node''s asynchronous functions return an error object to your callback function.
    Give this object to `assert.ifError(e)` and if `e` is defined, `ifError` will
    throw it. Use `assert.fail()` when execution has reached a part of your code where
    it should never go. This is most useful when the exception is trapped by a `try`/`catch`
    block:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Node的异步函数将错误对象返回给您的回调函数。将此对象传递给`assert.ifError(e)`，如果`e`被定义，`ifError`将抛出它。当执行已经到达代码中不应该执行的部分时，使用`assert.fail()`是最有用的。当异常被`try`/`catch`块捕获时，这是最有用的：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码会产生以下输出：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A shortcut method for logging assertion results is available in the console
    API:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台API中提供了用于记录断言结果的快捷方法：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Alternatively, you can confirm that functions always throw or never throw with
    `assert.throws` and `assert.doesNotThrow`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`assert.throws`和`assert.doesNotThrow`确认函数始终抛出或从不抛出。
- en: For a more detailed explanation of how comparison is done in JavaScript, consult:[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
    [Node's assert module is strongly influenced by the CommonJS test specification,
    which can be found at:](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
    [http://wiki.commonjs.org/wiki/Unit_Testing](http://wiki.commonjs.org/wiki/Unit_Testing)[.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JavaScript中比较的详细解释，请参阅：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
    [Node的assert模块受CommonJS测试规范的强烈影响，该规范可以在以下网址找到：](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
    [http://wiki.commonjs.org/wiki/Unit_Testing](http://wiki.commonjs.org/wiki/Unit_Testing)[.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
- en: Sandboxing
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沙箱
- en: 'In some instances, you might want to run a script within a separate and more
    limited context, isolated from the scope of your larger application. For these
    situations, Node provides the `vm` module, a sandbox environment consisting of
    a new V8 instance and a limited execution context for running script blocks:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望在一个单独且更有限的上下文中运行脚本，使其与较大应用程序的范围隔离开来。对于这些情况，Node提供了`vm`模块，一个沙盒环境，包括一个新的V8实例和一个用于运行脚本块的有限执行上下文：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we see how a provided sandbox becomes the local execution scope for the
    provided script. The running script only operates within the provided sandbox
    object, and is denied access to even the standard Node globals, such as the running
    process, which we can demonstrate by changing the preceding code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到提供的沙盒成为提供的脚本的局部执行范围。运行的脚本只能在提供的沙盒对象中操作，并且甚至被拒绝访问标准的Node全局对象，例如正在运行的进程，我们可以通过更改前面的代码来进行演示：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This module does not guarantee a perfectly safe *jail* within which completely
    untrusted code can be executed safely. If this is your need, consider running
    a separate process with proper system-level permissions. As `vm` spins up a new
    V8 instance, each invocation costs some milliseconds of startup time and about
    two megabytes of memory. Use `vm` only when it's worth this performance cost.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块不能保证完全安全的*监狱*，以便可以安全地执行完全不受信任的代码。如果有这种需求，请考虑以适当的系统级权限运行一个单独的进程。由于`vm`会启动一个新的V8实例，每次调用都会耗费一些毫秒的启动时间和大约两兆字节的内存。只有在值得这种性能成本的情况下才使用`vm`。
- en: For the purpose of testing code, the `vm` module can be quite effective, in
    particular, in its ability to force code to run in a limited context. When performing
    a unit test, for example, one can create a special environment with mocked data
    simulating the environment within which the tested script will run. This can be
    better than creating an artificial call context with fake data. Additionally,
    this sandboxing will allow the execution context for new code to be better controlled,
    providing good protection against memory leaks and other unanticipated collisions
    that may bubble up while testing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试代码，`vm`模块可以非常有效，特别是在强制代码在有限上下文中运行的能力方面。例如，在执行单元测试时，可以创建一个特殊的环境，并使用模拟环境中的模拟数据来测试脚本。这比创建一个带有虚假数据的人工调用上下文要好。此外，这种沙盒化将允许更好地控制新代码的执行上下文，提供良好的内存泄漏保护和其他在测试过程中可能出现的意外冲突。
- en: Distinguishing between local scope and execution context
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分局部范围和执行上下文
- en: 'Before covering further examples, we need to distinguish between the local
    scope of a process and its execution context. The distinction will help with understanding
    the difference between the two primary `vm` methods: `vm.runInThisContext` and
    `vm.runInNewContext`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步介绍示例之前，我们需要区分进程的局部范围和其执行上下文。这种区分有助于理解两个主要`vm`方法之间的区别：`vm.runInThisContext`和`vm.runInNewContext`。
- en: At any time, V8 might have a single, or more likely, several, execution contexts.
    These contexts act as separate containers, in which V8 can execute some more JavaScript.
    When using Chrome, you can think of these execution contexts as different tabs
    navigated to different websites.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，V8可能有一个或更可能是几个执行上下文。这些上下文充当单独的容器，V8可以在其中执行一些更多的JavaScript。在使用Chrome时，您可以将这些执行上下文视为导航到不同网站的不同标签页。
- en: The script on one site can't see or mess up the script on another site. The
    execution context of a Node process represents the runtime context within V8,
    including native Node methods and other global objects (process, console, setTimeout,
    and so on).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个站点上的脚本无法看到或干扰另一个站点上的脚本。Node进程的执行上下文代表V8中的运行时上下文，包括本地Node方法和其他全局对象（process、console、setTimeout等）。
- en: A script executed through `vm.runInNewContext` has no visibility into either
    scope; its context is limited to the sandbox object to which it was passed, as
    seen earlier.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`vm.runInNewContext`执行的脚本无法访问任何范围；它的上下文限制在之前传递给它的沙盒对象中。
- en: 'A script executed through `vm.runInThisContext` has visibility into the global
    execution scope of your Node process, but not into the local scope. We can demonstrate
    this as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`vm.runInThisContext`执行的脚本可以访问Node进程的全局执行范围，但无法访问局部范围。我们可以通过以下方式进行演示：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Scripts are, therefore, run within contexts through `vm`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，脚本是通过`vm`在上下文中运行的。
- en: It is often useful to precompile contexts and scripts, in particular, when each
    will be used repeatedly. Use `vm.createContext([sandbox])` to compile an execution
    context, and pass in a key/value map. In the next section, we'll look at how to
    apply these contexts to precompiled scripts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译上下文和脚本通常很有用，特别是当每个都将被重复使用时。使用`vm.createContext([sandbox])`来编译一个执行上下文，并传入一个键/值映射。在下一节中，我们将看看如何将这些上下文应用于预编译的脚本。
- en: Using compiled contexts
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编译上下文
- en: After receiving a string of JavaScript code, the V8 compiler will do its best
    to optimize the code into a compiled version that runs more efficiently. This
    compilation step must occur each time a `vm` context method receives code as a
    string. If your code doesn't change and is reused at least once, it is better
    to use `new vm.Script(code, [filename])` to compile it once and for all.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 收到JavaScript代码字符串后，V8编译器将尽力将代码优化为更高效的编译版本。每次`vm`上下文方法接收代码字符串时，都必须进行这个编译步骤。如果您的代码不会改变并且至少被重用一次，最好使用`new
    vm.Script(code, [filename])`来编译它一次。
- en: 'We can executed these compiled scripts in the contexts inherited from `runInThisContext`
    and `runInNewContext`. Here, we run a compiled script in both contexts, demonstrating
    how the `x` and `y` variables being incremented exist in fully isolated scopes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在从`runInThisContext`和`runInNewContext`继承的上下文中执行这些编译后的脚本。在这里，我们在两个上下文中运行编译后的脚本，演示了`x`和`y`变量被递增存在于完全隔离的范围中：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Had both scripts modified the same `x` and `y` in context, the outputs would
    have been `2000 2000` instead.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个脚本都修改了相同的上下文中的`x`和`y`，输出将会是`2000 2000`。
- en: 'Note that if the `runInNewContext` script is not passed an emulation layer
    (sandbox), it will throw a `ReferenceError: x is not defined`, having access to
    neither the local nor global `x` and `y` values. Try it out.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，如果`runInNewContext`脚本没有传递仿真层（沙盒），它将抛出`ReferenceError: x is not defined`，既不能访问本地变量也不能访问全局变量`x`和`y`的值。试一下。'
- en: Now that we know something about assertions and creating test contexts, let's
    write some real tests using some common testing frameworks and tools.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了断言和创建测试上下文的一些内容，让我们使用一些常见的测试框架和工具编写一些真正的测试。
- en: Testing with Mocha, Chai, and Sinon
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mocha、Chai和Sinon进行测试
- en: One of the great benefits of writing tests for your code is that you will be
    forced to think through how what you’ve written works. A test that is difficult
    to write might indicate code that is difficult to understand.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的代码编写测试的一个巨大好处是，您将被迫思考您编写的代码是如何工作的。难以编写的测试可能表明难以理解的代码。
- en: On the other hand, comprehensive coverage with good tests helps others (and
    you) understand how an application works. In this section, we’ll look at how to
    describe your tests using the test runner **Mocha**, using **Chai** as its assertion
    library, and **Sinon** when mocking is necessary to a test. We'll use **redis**
    to demonstrate how to create tests against a simulated dataset (rather than testing
    against production databases, which would, of course, be a bad idea). We’ll use
    **npm** as a test script runner.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通过良好的测试实现全面覆盖，有助于他人（和您）了解应用程序的工作原理。在本节中，我们将看看如何使用测试运行器**Mocha**来描述您的测试，使用**Chai**作为其断言库，并在需要对测试进行模拟时使用**Sinon**。我们将使用**redis**来演示如何针对模拟数据集创建测试（而不是针对生产数据库进行测试，这当然是一个坏主意）。我们将使用**npm**作为测试脚本运行器。
- en: 'To start, set up the following folder structure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置以下文件夹结构：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, initialize a `package.json` file with `npm init` within the `/testing`
    folder. You can just press *Enter* at the prompts, but when you are asked for
    a test command, enter the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`/testing`文件夹中使用`npm init`初始化一个`package.json`文件。您可以在提示时只需按*Enter*，但当要求测试命令时，请输入以下内容：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This sets up our project for importation of the modules we'll need. We'll discuss
    what Chai does later. For now, suffice it to say that in this test command, Mocha
    is being referred to a configuration file for dependency information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们的项目设置了我们将需要的模块的导入。稍后我们将讨论Chai的作用。现在，可以说在这个测试命令中，Mocha被引用为依赖信息的配置文件。
- en: 'Go ahead and install the needed libraries into this package:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 继续安装所需的库到这个包中：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `/scripts` folder will contain the JavaScript we’ll be testing. The `/spec`
    folder will contain configuration and test files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`/scripts`文件夹将包含我们将要测试的JavaScript。`/spec`文件夹将包含配置和测试文件。'
- en: This will make more sense as we move ahead. For now, recognize that this assignation
    to npm’s `test` attribute asserts that we will be using Mocha for testing, Mocha’s
    test report will be of the `spec` type, and that tests will exist in the `/spec`
    directory. We are also requiring a configuration file for Chai, which will be
    explained as we move on. Importantly, this has now created a script declaration
    in npm that will allow you to run your test suite with the `npm test` command. Use
    that command whenever you need to run the Mocha tests we’ll be developing in what
    follows.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进展，这将变得更有意义。现在，要认识到对npm的`test`属性的分配表明我们将使用Mocha进行测试，Mocha的测试报告将是`spec`类型，并且测试将存在于`/spec`目录中。我们还需要一个Chai的配置文件，这将在我们继续进行时进行解释。重要的是，这现在已经在npm中创建了一个脚本声明，允许您使用`npm
    test`命令运行测试套件。在接下来的开发中，每当需要运行我们将要开发的Mocha测试时，请使用该命令。
- en: Mocha
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocha
- en: 'Mocha is a test runner that does not concern itself with test assertions themselves.
    Mocha is used to organize and run your tests, primarily through the use of the
    `describe` and `it` operators. Schematically, Mocha tests look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha是一个测试运行器，不关心测试断言本身。Mocha用于组织和运行您的测试，主要通过使用`describe`和`it`操作符。概括地说，Mocha测试看起来像这样：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the Mocha harness leaves open how the tests are described and
    organized, and makes no assumptions about how test assertions are designed. It
    is an organizational harness for your tests, with the additional aim of producing
    human-readable test definitions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Mocha测试套件留下了测试如何描述和组织的空间，并且不假设测试断言的设计方式。它是您测试的组织工具，另外还旨在生成可读的测试定义。
- en: 'You can set up tests that run synchronously, as described earlier, or asynchronously
    using the completion handler passed to all its callbacks:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置同步运行的测试，如前面所述，也可以使用传递给所有回调的完成处理程序异步运行：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Blocks can also be nested:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 块也可以嵌套：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, Mocha offers *hooks*, enabling you to run some code before and/or
    after tests:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Mocha提供了*hooks*，使您能够在测试之前和/或之后运行一些代码：
- en: '`beforeEach()` runs before each test in a describe block'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()`在描述块中的每个测试之前运行'
- en: '`afterEach()` runs after each test in a describe block'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach()`在描述块中的每个测试之后运行'
- en: '`before()` runs code once prior to any test—prior to any run of `beforeEach`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before()`在任何测试之前运行一次代码-在任何`beforeEach`运行之前'
- en: '`after()` runs code once after all tests have run—after any run of `afterEach`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after()`在所有测试运行后运行一次代码-在任何`afterEach`运行之后'
- en: Usually, these are used to set up test contexts, such as creating some variables
    before tests and cleaning them up prior to some other tests. This simple collection
    of tools is expressive enough to handle most testing needs. Additionally, Mocha
    provides various test reporters that offer differently formatted results. We’ll
    see those in action later as we build some realistic test scenarios.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些用于设置测试上下文，例如在测试之前创建一些变量并在其他一些测试之前清理它们。这个简单的工具集足够表达大多数测试需求。此外，Mocha提供了各种测试报告程序，提供不同格式的结果。随着我们构建一些真实的测试场景，我们将在后面看到这些。
- en: Chai
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chai
- en: 'As we saw earlier with Node’s native assert module, at its base, testing involves
    asserting what we expect some chunk of code to do, executing that code, and checking
    whether our expectations were met. Chai is an assertion library that offers a
    more expressive syntax, offering three assertion styles: `expect`, `should`, and
    `assert`. We will use Chai to provide the assertions (tests) to be wrapped within
    Mocha `it` statements, favoring the `expect` style of assertion.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在Node的原生断言模块中看到的，基本上，测试涉及断言我们期望某些代码块执行的内容，执行该代码，并检查我们的期望是否得到满足。Chai是一个断言库，提供了更具表现力的语法，提供了三种断言样式：`expect`、`should`和`assert`。我们将使用Chai来提供断言（测试），并将其包装在Mocha的`it`语句中，更青睐`expect`样式的断言。
- en: Note that while `Chai.assert` is modeled after the core Node assert syntax,
    Chai augments the object with additional methods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然`Chai.assert`是模仿核心Node断言语法的，但Chai通过附加方法来增强对象。
- en: 'To begin with, we will create a configuration file, `chai.js`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个配置文件`chai.js`：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Place this file in the `/spec/helpers` folder. This will tell Chai to display
    the full stack trace of any errors, and to expose the expect assertion style as
    a global. Similarly, Sinon is also exposed as a global (more on Sinon in the next
    section). This file will augment the Mocha test run context such that we can use
    these tools without having to redeclare them in each test file. The `expect` style
    of assertion reads like a sentence, with *sentences* composed from works like
    *to*, *be*, *is*, and more. Consider the following example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件放在`/spec/helpers`文件夹中。这将告诉Chai显示任何错误的完整堆栈跟踪，并将`expect`断言样式公开为全局。同样，Sinon也被公开为全局（更多关于Sinon的内容将在下一节中介绍）。这个文件将增强Mocha测试运行上下文，以便我们可以在每个测试文件中使用这些工具而不必重新声明它们。`expect`样式的断言读起来像一个句子，由*to*、*be*、*is*等单词组成。考虑以下例子：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To explore the extensive list of *words* available when creating expect test
    chains, consult the full docs at: [http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/).
    As stated earlier, Mocha does not have an opinion on how you create assertions.
    We will use `expect` to create assertions in the tests that follow.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索在创建期望测试链时可用的广泛单词列表，请查阅完整文档：[http://chaijs.com/api/bdd/](http://chaijs.com/api/bdd/)。正如前面所述，Mocha对于如何创建断言并没有意见。我们将在接下来的测试中使用`expect`来创建断言。
- en: 'Consider testing the capitalize function in the following object:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑测试以下对象中的capitalize函数：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We might do something like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会这样做：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This Chai assertion will be true, and Mocha will report the same. You will construct
    your entire test suite out of these blocks of descriptions and assertions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Chai断言将是真的，Mocha也会报告相同的结果。您将用这些描述和断言块构建整个测试套件。
- en: Next, we’ll look at how to add Sinon to our test process.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何将Sinon添加到我们的测试过程中。
- en: Sinon
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sinon
- en: Within a testing environment, you are typically emulating the realities of a
    production environment, as access to real users or data or other live systems
    is unsafe or otherwise undesirable. Being able to simulate environments is, therefore,
    an important part of testing. Also, you will often want to inspect more than just
    call results; you might want to test whether a given function is being called
    in the right context or with the right examples. Sinon is a tool that helps you
    simulate external services, emulate functions, track function calls, and so on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境中，您通常在模拟生产环境的现实情况，因为访问真实用户、数据或其他实时系统是不安全或不可取的。因此，能够模拟环境是测试的一个重要部分。此外，您通常希望检查的不仅仅是调用结果；您可能还想测试给定函数是否在正确的上下文中被调用或使用正确的示例。Sinon是一个帮助您模拟外部服务、模拟函数、跟踪函数调用等的工具。
- en: 'The sinon-chai module extends Chai with Sinon assertions at: [https://github.com/domenic/sinon-chai](https://github.com/domenic/sinon-chai).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: sinon-chai模块在[https://github.com/domenic/sinon-chai](https://github.com/domenic/sinon-chai)上扩展了Chai的Sinon断言。
- en: 'The key Sinon technologies are spies, stubs, and mocks. Additionally, you can
    set fake timers, create fake servers, and more (visit: [http://sinonjs.org/](http://sinonjs.org/)).
    This section focuses on the first three. Let’s go over some examples of each.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的Sinon技术是间谍、存根和模拟。此外，您可以设置虚假计时器，创建虚假服务器等等（访问：[http://sinonjs.org/](http://sinonjs.org/)）。本节重点介绍前三者。让我们看看每个的一些例子。
- en: Spies
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间谍
- en: 'From the Sinon documentation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Sinon文档：
- en: '"A test spy is a function that records arguments, returns value, the value
    of this and exception thrown (if any) for all its calls. A test spy can be an
    anonymous function, or it can wrap an existing function."'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: “测试间谍是一个记录其所有调用的参数、返回值、this的值和抛出的异常（如果有的话）的函数。测试间谍可以是一个匿名函数，也可以包装一个现有函数。”
- en: 'A spy gathers information on the function it is tracking. Take a look at this
    example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍收集了它正在跟踪的函数的信息。看看这个例子：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will log the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录以下内容：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The spy was called twice; once with `foo`, once with `bar`, and never with `baz`.
    If you're writing a test of whether a certain function was called and/or testing
    the arguments it received, spies are a great testing tool for your case.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍被叫了两次；一次用`foo`，一次用`bar`，从未用过`baz`。如果你正在测试某个函数是否被调用和/或测试它接收到的参数，间谍是你的一个很好的测试工具。
- en: 'Let’s suppose that we wanted to test whether our code properly connects to
    the pub/sub functionality of Redis:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想测试我们的代码是否正确连接到Redis的发布/订阅功能：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this example, we do more with spy and Mocha. We deploy spy to proxy the
    native subscribe method of client1, importantly setting up and tearing down the
    spy proxy (restoring the original functionality) within Mocha’s before and after
    methods. The Chai assertions prove that both `subscribe` and `nowPublish` are
    functioning correctly, and are receiving the right arguments. More information
    on spies can be found at: [http://sinonjs.org/releases/v4.1.2/spies](http://sinonjs.org/releases/v4.1.2/spies).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在spy和Mocha中做了更多。 我们使用spy代理client1的原生subscribe方法，重要的是在Mocha的before和after方法中设置和拆卸spy代理（恢复原始功能）。
    Chai断言证明`subscribe`和`nowPublish`都正常运行，并且接收到正确的参数。 有关间谍的更多信息可以在以下网址找到：[http://sinonjs.org/releases/v4.1.2/spies](http://sinonjs.org/releases/v4.1.2/spies)。
- en: Stubs
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存根
- en: Test stubs are functions (spies) with preprogrammed behavior. They support the
    full test spy API in addition to methods that can be used to alter the stub’s
    behavior. A stub, when used as a spy, can be wrapped around an existing function
    such that it can fake the behavior of that function (rather than simply recording
    function executions, as we saw earlier with spies).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 测试存根是具有预编程行为的函数（间谍）。 它们支持完整的测试间谍API，以及可用于更改存根行为的方法。 存根在用作间谍时，可以包装现有函数，以便可以伪造该函数的行为（而不仅仅是记录函数执行，就像我们之前在间谍中看到的那样）。
- en: 'Let’s assume that you have some functionality in your application that makes
    calls to some HTTP endpoint. The code may be something like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序中有一些功能会调用一些HTTP端点。 代码可能是这样的：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When successful, the call will log `Got status: 200`. Should the endpoint be
    unavailable, you’ll see something like `Got error: getaddrinfo ENOTFOUND`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '成功时，调用将记录`Got status: 200`。 如果端点不可用，您将看到类似`Got error: getaddrinfo ENOTFOUND`的内容。'
- en: It is likely that you will need to test the ability of your application to handle
    alternate status codes, and, of course, explicit errors. It may not be in your
    power to force the endpoint to emit these, yet you must prepare for them, should
    they occur. Stubs are useful here to create synthetic responses, so that your
    response handlers can be tested comprehensibly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要测试应用程序处理替代状态代码以及明确错误的能力。 您可能无法强制端点发出这些代码，但是如果发生这种情况，您必须为它们做好准备。 存根在这里非常有用，可以创建合成响应，以便可以全面地测试响应处理程序。
- en: 'We can use stubs to emulate a response without actually calling the `http.get`
    method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用存根来模拟响应，而不实际调用`http.get`方法：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This stub yields a simulated response by wrapping the original method, which
    is never called, resulting in a `404` being returned from a call that would normally
    return a status code of `200`. Importantly, note how we `restore` the stubbed
    method to its original state when done.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存根通过包装原始方法来产生模拟响应，但实际上从未调用原始方法，导致从通常返回状态代码`200`的调用中返回`404`。 重要的是，注意我们在完成后如何`restore`存根方法到其原始状态。
- en: 'For example, the following *pseudo* code describes a module that makes HTTP
    calls, parses the response, and responds with `''handled''` if everything went
    okay, and `''not handled''` if the HTTP response was unexpected:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下*伪*代码描述了一个模块，该模块进行HTTP调用，解析响应，并在一切正常时返回`'handled'`，在HTTP响应意外时返回`'not handled'`：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following Mocha test ensures that the `Caller.parseReponse` method can
    handle all response codes we need handled, using stubs to simulate the entire
    expected response range:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的Mocha测试确保`Caller.parseReponse`方法可以处理我们需要处理的所有响应代码，使用存根来模拟整个预期的响应范围：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By proxying the original `makeCall` method, we can test `parseResponse` against
    a range of status codes without the difficulty of forcing remote network behavior.
    Noting that the preceding test should fail (there is no handler for `403` codes),
    the output of this test should look something like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过代理原始的`makeCall`方法，我们可以测试`parseResponse`对一系列状态代码的处理，而无需强制远程网络行为。 请注意，前面的测试应该失败（没有`403`代码的处理程序），这个测试的输出应该看起来像这样：
- en: '![](img/1cb086b1-72f3-46bb-af64-53c20ddb1fa7.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cb086b1-72f3-46bb-af64-53c20ddb1fa7.png)'
- en: 'The full API for stubs can be seen at: [http://sinonjs.org/releases/v4.1.2/stubs/](http://sinonjs.org/releases/v4.1.2/stubs/).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 存根的完整API可以在以下网址查看：[http://sinonjs.org/releases/v4.1.2/stubs/](http://sinonjs.org/releases/v4.1.2/stubs/)。
- en: Mocks
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: Mocks (and mock expectations) are fake methods (like spies) with preprogrammed
    behavior (like stubs) as well as preprogrammed expectations. A mock will fail
    your test if it is not used as expected. Rather than checking expectations *after
    the fact*, mocks can be used to check whether the unit under test is being used
    correctly; they enforce implementation details.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟（和模拟期望）是具有预编程行为（如存根）和预编程期望的虚假方法（如间谍）。 如果未按预期使用模拟，模拟将使您的测试失败。 模拟可以用来检查被测试单元的正确使用，而不是在事后检查期望，它们强制执行实现细节。
- en: 'In the following example, we check the number of times a specific function
    is called and that it is called with specific, expected arguments. Specifically,
    we again test the `capitalize` method of Utilities, this time using mocks:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们检查特定函数被调用的次数，以及它是否以特定的预期参数被调用。 具体来说，我们再次使用模拟来测试Utilities的`capitalize`方法：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After setting up a mock on `utilities`, we map a five element array to `capitalize`,
    expecting `capitalize` to be called exactly five times, with the array’s elements
    as arguments (using `apply` to spread the array into individual arguments). The
    well-named `mock.verify` is then checked to see whether our expectations were
    satisfied. As usual, when done, we unwrap the utilities object with `mock.restore`.
    You should see true logged to your terminal.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utilities`上设置模拟之后，我们将一个五元素数组映射到`capitalize`，期望`capitalize`被调用五次，数组的元素作为参数（使用`apply`将数组展开为单独的参数）。
    然后检查名为`mock.verify`的方法，以查看我们的期望是否得到满足。 和往常一样，在完成后，我们使用`mock.restore`取消包装utilities对象。
    您应该在终端中看到true被记录。
- en: 'Now, remove one element from the tested array, frustrating expectations. When
    you run the test again, you should see the following near the top of the output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从被测试的数组中删除一个元素，使期望受挫。当您再次运行测试时，您应该在输出的顶部附近看到以下内容：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This should clarify the type of test results that mocks are designed to produce.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该澄清模拟旨在产生的测试结果类型。
- en: Note that mocked functions do not execute; `mock` overrides its target. In the
    preceding example, no array members are ever run through `capitalize`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模拟的函数不会执行；`mock`会覆盖其目标。在前面的示例中，没有任何数组成员会通过`capitalize`运行。
- en: 'Let’s revisit our earlier example testing Redis `pub/sub`, using mocks:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们之前使用模拟测试Redis `pub/sub`的示例：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Rather than checking for conclusions, here, we assert our expectation that
    the mocked `subscribe` method will receive the exact argument channel only once.
    Mocha expects `mock.verify` to return `true`. To make this test fail, add one
    more `client.subscribe(''channel'')` line, producing something like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与其检查结论，我们在这里断言我们的期望，即模拟的`subscribe`方法将仅接收一次确切的参数通道。Mocha期望`mock.verify`返回`true`。要使此测试失败，添加一行`client.subscribe('channel')`，产生类似以下的内容：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'More information on how to use mocks can be found at: [http://sinonjs.org/releases/v4.1.2/mocks/](http://sinonjs.org/releases/v4.1.2/mocks/).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用模拟的更多信息，请访问：[http://sinonjs.org/releases/v4.1.2/mocks/](http://sinonjs.org/releases/v4.1.2/mocks/)。
- en: Headless testing with Nightmare and Puppeteer
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nightmare和Puppeteer进行无头测试
- en: One way to test whether a UI is working is to pay several people to interact
    with a website via a browser and report any errors they find. This can become
    a very expensive and, ultimately, unreliable process. Also, it requires putting
    potentially failing code into production in order to test it. It's better to test
    whether browser views are rendering correctly from within the testing process
    itself, prior to releasing anything *into the wild*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 测试UI是否有效的一种方法是支付几个人通过浏览器与网站进行交互，并报告他们发现的任何错误。这可能会变得非常昂贵，最终也不可靠。此外，这需要将潜在失败的代码投入生产以进行测试。最好在发布任何内容“到野外”之前，测试浏览器视图是否在测试过程本身中正确呈现。
- en: A browser, stripped of its buttons and other controls, is at heart a program
    that validates and runs JavaScript, HTML, and CSS, and creates a view. That the
    validated HTML is rendered visually on your screen is simply a consequence of
    humans only being able to see with their eyes. A machine can interpret the logic
    of compiled code and see the results of interactions with that code without a
    visual component. Perhaps, because eyes are usually found in one's head, a browser
    run by machines on a server is typically referred to as a headless browser.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个被剥夺了按钮和其他控件的浏览器，本质上是一个验证和运行JavaScript、HTML和CSS，并创建视图的程序。验证的HTML在您的屏幕上呈现出来只是人类只能用眼睛看到的结果。机器可以解释编译代码的逻辑，并查看与该代码的交互结果，而无需视觉组件。也许是因为眼睛通常在头部，由服务器上的机器运行的浏览器通常被称为无头浏览器。
- en: 'We''ll look at two headless browser test automation libraries: **Nightmare**
    ([https://github.com/segmentio/nightmare](https://github.com/segmentio/nightmare))
    and **Puppeteer** ([https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer)).
    Nightmare uses **Electron** as its browser environment, while Puppeteer uses headless
    **Chromium**. They both provide you with a scriptable environment around a browser
    context, enabling various operations on that *page*, such as grabbing a screenshot,
    filling out and submitting a form, or pulling some content from the page based
    on a CSS selector. In keeping with our earlier work, we''ll also learn how to
    use Mocha and Chai to harness these headless browser tests.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下两个无头浏览器测试自动化库：**Nightmare** ([https://github.com/segmentio/nightmare](https://github.com/segmentio/nightmare))
    和 **Puppeteer** ([https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer))。Nightmare使用**Electron**作为其浏览器环境，而Puppeteer使用无头**Chromium**。它们都为您提供了一个可编写脚本的环境，围绕浏览器上下文，使您能够对该*页面*进行各种操作，例如抓取屏幕截图，填写并提交表单，或者根据CSS选择器从页面中提取一些内容。与我们之前的工作保持一致，我们还将学习如何使用Mocha和Chai来利用这些无头浏览器测试。
- en: Let's get familiar with both of these tools, and then look at how they can be
    integrated into your testing environment.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们熟悉这两个工具，然后看看它们如何集成到您的测试环境中。
- en: Nightmare
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nightmare
- en: 'Nightmare exposes a very expressive API for working with web content. Let''s
    jump right in with an example Mocha test that validates the document title of
    a web page:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Nightmare为处理Web内容提供了一个非常富有表现力的API。让我们立即使用一个示例Mocha测试来验证网页的文档标题：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we use Mocha's `beforeEach` and `afterEach` to anticipate many test blocks,
    creating a fresh Nightmare instance for each, and automatically cleaning up those
    instances after each test has run via `nightmare.end`. You don't necessarily have
    to do this, but it is a useful *boilerplate*. Nightmare accepts a configuration
    object reflecting Electron's **BrowserWindow** options ([https://github.com/electron/electron/blob/master/docs/api/browser-window.md#new-browserwindowoptions](https://github.com/electron/electron/blob/master/docs/api/browser-window.md#new-browserwindowoptions)),
    and here, we use the `show` attribute, which makes the rendering instance visible—the
    view *pops up* on your screen so that you can watch the page being manipulated.
    Especially with tests where navigation and UI interactions are being made, it
    can be useful to see those manipulations in action. Go ahead and try it here and
    in the tests that follow.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Mocha的`beforeEach`和`afterEach`来预期许多测试块，为每个测试创建一个新的Nightmare实例，并通过`nightmare.end`自动清理这些实例。您不一定要这样做，但这是一个有用的*样板*。Nightmare接受一个反映Electron的**BrowserWindow**选项的配置对象
    ([https://github.com/electron/electron/blob/master/docs/api/browser-window.md#new-browserwindowoptions](https://github.com/electron/electron/blob/master/docs/api/browser-window.md#new-browserwindowoptions))，在这里，我们使用`show`属性，使渲染实例可见——视图*弹出*在您的屏幕上，以便您可以观看页面的操作。特别是在进行导航和UI交互的测试中，看到这些操作是很有用的。在这里和接下来的测试中尝试一下。
- en: 'This test is easy to read. Here, we simply head to a URL, fetch the title of
    that page, and run an assertion to test that we have the right title. Note that
    Nightmare is designed to natively work with Promises, and the `Promise` chain
    you see is built on Node-native Promises. If you''d like to use another `Promise`
    library, you can do that:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很容易阅读。在这里，我们简单地前往一个URL，获取该页面的标题，并进行断言以测试我们是否有正确的标题。请注意，Nightmare被设计为与Promises原生地配合工作，你看到的`Promise`链是基于Node原生的Promises构建的。如果你想使用另一个`Promise`库，你可以这样做：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Interacting with pages is the sine qua non of headless browser testing, letting
    you write UI tests that run automatically. For example, you might want to test
    your application''s login page, or whether a search input returns the right results
    in the right order when submitted. Let''s add another test to this suite, one
    where we search for the Nightmare home page on Yahoo and query the result page
    for the link text:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与页面交互是无头浏览器测试的必不可少的部分，让你编写自动运行的UI测试。例如，你可能想测试你的应用程序的登录页面，或者当提交时搜索输入返回正确的结果和正确的顺序。让我们向这个套件添加另一个测试，一个在Yahoo上搜索Nightmare主页并查询链接文本的测试：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can see how this works. Find the search box on Yahoo's front page using
    a CSS selector, type `'nightmare.js'` into it and click on the Submit button to
    submit the form. Wait for a new element `#main` to show up, indicating that the
    result page has been rendered. We then create an `evaluate` block, which will
    execute within the browser scope. This is a good place to do custom DOM selections
    and manipulations. Here, we find the first link, and check whether it is the one
    we expected. This simple pattern can be easily modified to click links on your
    website to ensure that the links are working, for example, or indeed running several
    selectors over the resulting page to ensure that the right results were delivered.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这是如何工作的。使用CSS选择器在Yahoo的首页上找到搜索框，输入`'nightmare.js'`并点击提交按钮提交表单。等待一个新的元素`#main`出现，表示结果页面已经被渲染。然后我们创建一个`evaluate`块，它将在浏览器范围内执行。这是一个进行自定义DOM选择和操作的好地方。在这里，我们找到第一个链接，并检查它是否是我们期望的链接。这个简单的模式可以很容易地修改为点击你网站上的链接以确保链接正常工作，或者在结果页面上运行几个选择器以确保正确的结果被传递。
- en: 'In your tests, you may find repeating patterns. Imagine that extracting text
    from links targeted by selector is a common pattern in your tests. Nightmare allows
    you to turn these into custom actions. Let''s create a custom `getLinkText` action
    on Nightmare, and use that in our tests instead. To start—and prior to instantiating
    Nightmare—define a new `action`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试中，你可能会发现重复的模式。想象一下，从选择器定位的链接中提取文本是你测试中的常见模式。Nightmare允许你将这些转化为自定义操作。让我们在Nightmare上创建一个自定义的`getLinkText`操作，并在我们的测试中使用它。首先，在实例化Nightmare之前，定义一个新的`action`：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, replace the original evaluate instruction with a call to our custom action:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用我们自定义操作的调用替换原始的evaluate指令：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We have simply transposed our original instructions to an action block, with
    a custom name and function signature, and called that from our test chain. While
    this example is contrived, it is easy to imagine much more complex actions, even
    a library of them your engineers might draw on as a sort of *programming language*
    for tests. Note that `evaluate_now`, not `evaluate`, is used in the action. Nightmare
    will queue `evaluate` instructions, and since our action has already been queued
    (as part of the original test chain), we want to evaluate the command right now,
    immediately in our action, not requeue it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将我们的原始指令转换为一个操作块，使用自定义的名称和函数签名，并从我们的测试链中调用它。虽然这个例子是人为的，但很容易想象更复杂的操作，甚至是你的工程师可能会利用的操作库，作为一种测试的*编程语言*。请注意，在操作中使用`evaluate_now`而不是`evaluate`。Nightmare将排队`evaluate`指令，而我们的操作已经被排队（作为原始测试链的一部分），我们希望立即在我们的操作中评估该命令，而不是重新排队。
- en: 'For more information on Nightmare, visit: [https://github.com/segmentio/nightmare#api](https://github.com/segmentio/nightmare#api).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Nightmare的更多信息，请访问：[https://github.com/segmentio/nightmare#api](https://github.com/segmentio/nightmare#api)。
- en: Puppeteer
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppeteer
- en: 'Puppeteer is a shiny new Google project focused on creating a browser testing
    API using Chromium engine. The team is aggressively targeting the very latest
    Node versions, taking advantage of all the latest features of the Chromium engine
    (visit: [https://github.com/GoogleChrome/puppeteer/issues/316](https://github.com/GoogleChrome/puppeteer/issues/316)).
    In particular, it is designed to encourage the use of async/await patterns when
    writing your tests.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer是一个全新的Google项目，专注于使用Chromium引擎创建浏览器测试API。该团队正在积极地针对最新的Node版本，利用Chromium引擎的所有最新功能（访问：[https://github.com/GoogleChrome/puppeteer/issues/316](https://github.com/GoogleChrome/puppeteer/issues/316)）。特别是，它旨在鼓励在编写测试时使用async/await模式。
- en: 'Here''s the document title example from earlier written using Puppeteer:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是之前使用Puppeteer编写的文档标题示例：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note the `async` function wrapper. This pattern is very tight, and given how
    often tests must jump in and out of the browser context, `async`/`await` feels
    like a good fit here. We can also see how much the Puppeteer API was influenced
    by the Nightmare API. Like Nightmare, Puppeteer accepts a configuration object:
    [https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions).
    The equivalent of Nightmare''s `show` is `headless`, which places Chrome into
    headless mode. It might be a good exercise to rewrite the preceding Nightmare
    Yahoo search example in Puppeteer. Full documentation is available at: [https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`async`函数包装器。这种模式非常紧凑，考虑到测试经常必须在浏览器上下文中跳进跳出，`async`/`await`在这里感觉很合适。我们还可以看到Puppeteer
    API受到Nightmare API的影响。与Nightmare一样，Puppeteer接受一个配置对象：[https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions)。Nightmare的`show`的等价物是`headless`，它将Chrome置于无头模式。重写前面的Nightmare雅虎搜索示例为Puppeteer可能是一个很好的练习。完整的文档可在此处找到：[https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md)。
- en: 'Here''s a Mocha test using Puppeteer to read the NYTimes, intercept image rendering
    calls and cancel them, and then take a screenshot of the image-less page and write
    it to your local filesystem:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Puppeteer读取NYTimes、拦截图像渲染调用并取消它们，然后对无图像页面进行截图并将其写入本地文件系统的Mocha测试：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To create a PDF, you can just swap out the `screenshot` section with the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建PDF，您只需用以下内容替换`screenshot`部分：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It is not uncommon for developers to build test suites that take screenshots
    of the same page at various mobile device sizes, even running visual diffs to
    check whether your website is rendering correctly in all (for example, [https://github.com/mapbox/pixelmatch](https://github.com/mapbox/pixelmatch)).
    You might even create a service that selects fragments of several URLs and combines
    them into a single PDF report.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员经常构建测试套件，以在各种移动设备尺寸上对同一页面进行截图，甚至进行视觉差异检查，以检查您的网站是否在所有情况下都正确渲染（例如，[https://github.com/mapbox/pixelmatch](https://github.com/mapbox/pixelmatch)）。您甚至可以创建一个服务，选择几个URL的片段并将它们组合成一个单独的PDF报告。
- en: 'Navalia is another new framework with an interesting approach to testing with
    the headless Chrome API; you can find it at: [https://github.com/joelgriffith/navalia](https://github.com/joelgriffith/navalia).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Navalia是另一个具有有趣的使用无头Chrome API进行测试的新框架；您可以在此处找到它：[https://github.com/joelgriffith/navalia](https://github.com/joelgriffith/navalia)。
- en: You should now have enough information to start implementing UI tests for your
    applications. Some hypermodern applications even involve running Chromium on AWS
    Lambda (refer to [Chapter 9](c8e13bc3-e661-441c-9fbc-bfdf6019f5f8.xhtml), *Microservices*),
    letting you *farm out* your testing work. Both Nightmare and Puppeteer are modern,
    well-maintained, and document projects that fit very nicely into the Node testing
    ecosystem.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该有足够的信息来开始为您的应用程序实施UI测试。一些超现代的应用程序甚至涉及在AWS Lambda上运行Chromium（参见[第9章](c8e13bc3-e661-441c-9fbc-bfdf6019f5f8.xhtml)，*微服务*），让您*外包*您的测试工作。Nightmare和Puppeteer都是现代化、维护良好、有文档的项目，非常适合Node测试生态系统。
- en: Now, let's dig a little deeper into how to figure out just what is happening
    *behind the scenes *when a Node process is running, and how to be more surgical
    when testing and debugging.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解一下当Node进程运行时*幕后发生了什么*，以及在测试和调试时如何更加精确。
- en: Testing the terrain
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试地形
- en: Testing Node can also require a more scientific, experimental effort. For example,
    memory leaks are notoriously difficult bugs to track down. You will need powerful
    process profiling tools to take samples, test scenarios, and get a grip on just
    where the problem is coming from. If you are designing a log analysis and summarization
    tool that must crunch through gigabytes of data, you might want to test out various
    parsing algorithms and rank their CPU/memory usage. Whether testing the existing
    processes or being a software engineer, gathering information on resource usage
    is important. What we will look at in this section is how to take data snapshots
    of running processes, and how to draw useful information out of them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Node也可能需要更科学、更实验性的努力。例如，内存泄漏是臭名昭著的难以追踪的bug。您将需要强大的进程分析工具来取样、测试场景，并了解问题的根源。如果您正在设计一个必须处理大量数据的日志分析和总结工具，您可能需要测试各种解析算法并排名它们的CPU/内存使用情况。无论是测试现有的流程还是作为软件工程师，收集资源使用信息都很重要。本节将讨论如何对运行中的进程进行数据快照，并如何从中提取有用的信息。
- en: 'Node already provides some process information natively. Basic tracking of
    how much memory your Node process is using is easy to fetch with `process.memoryUsage()`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Node已经本地提供了一些进程信息。基本跟踪Node进程使用了多少内存很容易通过`process.memoryUsage()`获取：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can build scripts to watch these numbers and, perhaps, emit warnings when
    memory allocation exceeds some predetermined threshold. There are many companies
    that provide such monitoring services, such as **Keymetrics** ([https://keymetrics.io](https://keymetrics.io)),
    the makers and maintainers of PM2\. There are also modules like **node-report** ([https://github.com/nodejs/node-report](https://github.com/nodejs/node-report)),
    which provide a great way to generate system reports whenever your process is
    terminated via process crash, system signal, or other reason. The great module **memeye** ([https://github.com/JerryC8080/Memeye](https://github.com/JerryC8080/Memeye))
    makes it easy to create browser-based dashboards displaying this kind of system
    data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写脚本来监视这些数字，也许在内存分配超过某个预定阈值时发出警告。有许多公司提供这样的监控服务，比如**Keymetrics**（[https://keymetrics.io](https://keymetrics.io)），他们是PM2的制造商和维护者。还有像**node-report**（[https://github.com/nodejs/node-report](https://github.com/nodejs/node-report)）这样的模块，它提供了一个很好的方式，在进程崩溃、系统信号或其他原因终止时生成系统报告。伟大的模块**memeye**（[https://github.com/JerryC8080/Memeye](https://github.com/JerryC8080/Memeye)）使得创建显示这种系统数据的基于浏览器的仪表板变得容易。
- en: 'There are several native sources of information on Node processes. Visit the
    documentation at: [https://nodejs.org/api/process.html](https://nodejs.org/api/process.html).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Node进程有几个原生信息源。请访问文档：[https://nodejs.org/api/process.html](https://nodejs.org/api/process.html)。
- en: Let's start by learning how to gather more extensive memory usage statistics,
    profile running processes, gather key data profiles on how V8 is performing, and
    so on in the next few sections.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先学习如何收集更广泛的内存使用统计信息，对运行中的进程进行分析，收集关键的V8性能数据概要等等。
- en: Testing processes, memory, and CPU
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试进程、内存和CPU
- en: There are native tools for Node, enabling you to profile running V8 processes.
    These are snapshots with summaries that capture statistics on how V8 treated the
    process when compiling, and the sorts of actions and decisions it made while it
    was selectively optimizing the *hot* code as it ran. This is a powerful debugging
    technique when trying to track down the reasons why, for example, a function is
    running slowly.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Node有原生工具，可以让你对运行中的V8进程进行分析。这些是带有摘要的快照，捕获了V8在编译进程时对待进程的统计信息，以及在有选择地优化*热*代码时所做的操作和决策的类型。当尝试追踪例如一个函数运行缓慢的原因时，这是一个强大的调试技术。
- en: Any node process can have a a V8 log generated simply by passing the `--prof` (for
    profile) flag. Let's use an example to see how V8 process profiling works. Reading
    a large log file is a sufficiently non-trivial and common task that Node developers
    will come across. Let’s create a log reader and check its performance.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Node进程都可以通过简单地传递`--prof`（用于profile的标志）来生成V8日志。让我们用一个例子来看V8进程分析是如何工作的。阅读大型日志文件是Node开发人员将遇到的一个相当复杂且常见的任务。让我们创建一个日志读取器并检查其性能。
- en: Profiling processes
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程分析
- en: 'In your code bundle, there will be a `logreader.js` file under the `/profiling` directory
    for this chapter. This simply reads the `dummy.log` file also found in the code
    bundle. It’s a good example of how to use a `stream.Transform` to process large
    files:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码包中，本章的`/profiling`目录下将有一个`logreader.js`文件。这只是读取代码包中也有的`dummy.log`文件。这是一个如何使用`stream.Transform`处理大型文件的很好的例子：
- en: '[PRE58]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The important thing to note is that the main functions have been named, prefixed
    with $. This is a good practice generally—you should always name your functions,
    and the reason is specifically relevant to debugging. We want those names to show
    up in the reports we’re about to generate.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事情是，主要函数已经被命名，并以$为前缀。这通常是一个很好的做法——你应该总是给你的函数命名，原因特别与调试相关。我们希望这些名称出现在我们即将生成的报告中。
- en: 'To generate a v8 log, run this script using the `–-prof` argument:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个v8日志，可以使用`--prof`参数运行此脚本：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You should now see a V8 log file in the current working directory, named something
    like `isolate-0x103000000-v8.log`. Go ahead and take a look at it—the log is somewhat
    intimidating, but if you do a search for, say, `$reader`, you'll find instances
    of how V8 is recording its structuring of the call stack and compilation work.
    Regardless, this is clearly not meant for humans to read.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该在当前工作目录中看到一个名为`isolate-0x103000000-v8.log`的V8日志文件。继续看一下它——日志有点令人生畏，但如果你搜索一下，比如`$reader`，你会发现V8是如何记录它对调用堆栈和编译工作的结构的实例。不过，这显然不是为人类阅读而设计的。
- en: 'You can create a much more useful summary of this profile by running the following
    command against that log:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对该日志运行以下命令，可以创建这个profile的一个更有用的摘要：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After a couple of seconds, the process will finish, and a new file, profile,
    will exist in the directory. Go ahead and open that. There is a lot of information,
    and doing a deep dive into what it all means is well beyond the scope of this
    chapter. Nevertheless, you should see that the summary neatly summarizes key V8
    activity, measured with ticks (remember our discussion about the event loop in
    [Chapter 2](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml), *Understanding Asynchronous
    Event-Driven Programming*?). For example, consider this line:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，进程将完成，目录中将存在一个新文件，名为profile。继续打开它。里面有很多信息，深入研究所有含义远远超出了本章的范围。尽管如此，你应该能看到摘要清晰地总结了关键的V8活动，用ticks来衡量（还记得我们在第2章中关于事件循环的讨论吗，*理解异步事件驱动编程*？）。例如，考虑这一行：
- en: '[PRE61]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we can see that `$reader` consumed 8 ticks, was lazy compiled, and was
    optimized (*). If it had not been optimized, it would have been marked with a
    tilde(~). If you see that an unoptimized file was consuming a large number of
    ticks, you'll probably take a look and try to rewrite it in an optimal way. This
    can be a powerful way to "solve" slower parts of your application stack.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`$reader`消耗了8个ticks，进行了懒编译，并且被优化了（*）。如果它没有被优化，它将被标记为波浪线（~）。如果你发现一个未优化的文件消耗了大量的ticks，你可能会尝试以最佳方式重写它。这可以是解决应用程序堆栈中较慢部分的强大方式。
- en: Dumping the heap
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆转储
- en: As we learned earlier, a heap is essentially a large allocation of memory, and
    in this specific case, it is the memory allocated to the V8 process. By examining
    where and how memory is being used, you can track down things such as memory leaks,
    or simply find out where the most memory is being used and make adjustments to
    your code, if needed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，堆本质上是对内存的大量分配，在这种特定情况下，它是分配给V8进程的内存。通过检查内存的使用情况，你可以追踪内存泄漏等问题，或者简单地找出内存使用最多的地方，并根据需要对代码进行调整。
- en: The de-facto module for taking heap snapshots is `heapdump` ([https://github.com/bnoordhuis/node-heapdump](https://github.com/bnoordhuis/node-heapdump))
    by *Ben Noordhuis*, a core Node developer since the very beginning of the project.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 用于获取堆转储的事实模块是`heapdump`（[https://github.com/bnoordhuis/node-heapdump](https://github.com/bnoordhuis/node-heapdump)），由自项目开始以来一直是核心Node开发者的*Ben
    Noordhuis*创建。
- en: 'Go ahead and install that module and create a new file with the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 继续安装该模块并创建一个包含以下代码的新文件：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Run that file. You will that a file is generated with a name like `1512180093208.heapsnapshot`.
    It's not a human-readable file, but it contains everything you need to reconstruct
    a view on heap usage. You just need the right visualization software. Thankfully,
    you can use the Chrome web browser to do just that.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该文件。你会发现生成了一个名为`1512180093208.heapsnapshot`的文件。这不是一个可读的文件，但它包含了重建堆使用情况视图所需的一切。你只需要正确的可视化软件。幸运的是，你可以使用Chrome浏览器来做到这一点。
- en: 'Open up Chrome DevTools. Go to the Memory tab. You will see an option there
    to Load a heap snapshot:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Chrome DevTools。转到内存选项卡。你会看到一个选项来加载堆转储：
- en: '![](img/249e4621-461b-4d75-929b-8aab7bb4b670.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/249e4621-461b-4d75-929b-8aab7bb4b670.png)'
- en: 'Load the file that you just created (note that it **must** have the `.heapsnapshot` extension).
    Once loaded, click on the heap icon, and you''ll see something like the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 加载刚刚创建的文件（注意，它**必须**有`.heapsnapshot`扩展名）。加载后，点击堆图标，你会看到类似以下的内容：
- en: '![](img/c58b06f1-e7a0-4dd4-a6b4-ff0cf3fe1a3a.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c58b06f1-e7a0-4dd4-a6b4-ff0cf3fe1a3a.png)'
- en: 'Click on Summary to activate the dropdown, and select Statistics. You''ll now
    see something like the following graph:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 点击Summary以激活下拉菜单，并选择Statistics。现在你会看到类似以下的图表：
- en: '![](img/4b9a689f-4679-430d-a0a2-1e14c0eb66e5.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b9a689f-4679-430d-a0a2-1e14c0eb66e5.png)'
- en: 'Becoming familiar with how to read heap dumps is a skill useful to any Node
    developer. For a good intro on how to understand memory allocation, try: [https://developer.chrome.com/devtools/docs/memory-analysis-101](https://developer.chrome.com/devtools/docs/memory-analysis-101).
    The source code to run Chrome DevTools UI is open and free, [https://github.com/ChromeDevTools/devtools-frontend](https://github.com/ChromeDevTools/devtools-frontend),
    as is the protocol itself. Think about how you might take periodic heap dumps
    of running processes and test system health using DevTools, either as we''ve demonstrated
    or via a custom build.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉如何读取堆转储是对任何Node开发者有用的技能。要了解内存分配的好介绍，请尝试：[https://developer.chrome.com/devtools/docs/memory-analysis-101](https://developer.chrome.com/devtools/docs/memory-analysis-101)。运行Chrome
    DevTools UI的源代码是开放和免费的，[https://github.com/ChromeDevTools/devtools-frontend](https://github.com/ChromeDevTools/devtools-frontend)，协议本身也是如此。想想你可能如何定期对运行中的进程进行堆转储，并使用DevTools测试系统健康状况，无论是我们演示的方式还是通过自定义构建。
- en: While we use Chrome in our demonstrations, other tools can *hook into* this
    protocol. Check out [https://nodejs.org/en/docs/inspector/](https://nodejs.org/en/docs/inspector/) and [https://github.com/ChromeDevTools/awesome-chrome-devtools#chrome-devtools-protocol](https://github.com/ChromeDevTools/awesome-chrome-devtools#chrome-devtools-protocol).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在演示中使用Chrome，其他工具也可以*连接到*这个协议。查看[https://nodejs.org/en/docs/inspector/](https://nodejs.org/en/docs/inspector/)和[https://github.com/ChromeDevTools/awesome-chrome-devtools#chrome-devtools-protocol](https://github.com/ChromeDevTools/awesome-chrome-devtools#chrome-devtools-protocol)。
- en: The Chrome DevTools have even more functionalities useful to developers. Let's
    take a look at those now.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome DevTools有更多对开发者有用的功能。现在让我们来看看这些功能。
- en: Connecting Node to Chrome DevTools
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Node连接到Chrome DevTools
- en: The Chrome Debugging Protocol was recently *integrated* with the Node core ([https://github.com/nodejs/node/pull/6792](https://github.com/nodejs/node/pull/6792)),
    which means that you can now debug a running Node process using Chrome DevTools
    (and other tools). This includes being able to not only watch memory allocation
    but also to gather active feedback on CPU usage, along with directly debugging
    your live code—adding break points and inspecting current variable values, for
    instance. This is an essential debugging and testing tool for the professional
    Node developer. Let's dig into it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome调试协议最近与Node核心*集成*（[https://github.com/nodejs/node/pull/6792](https://github.com/nodejs/node/pull/6792)），这意味着现在可以使用Chrome
    DevTools（和其他工具）调试运行中的Node进程。这不仅包括观察内存分配，还包括收集CPU使用情况的实时反馈，以及直接调试您的活动代码——例如添加断点和检查当前变量值。这是专业Node开发者的重要调试和测试工具。让我们深入了解一下。
- en: 'For demonstration purposes, we''ll create a quick server that performs some
    significant work:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将创建一个执行一些重要工作的快速服务器：
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note the `$alloc` and `$serverHandler` named functions; these function names
    will be used to trace our process. Now, we''ll start that server up, but with
    a special `--inspect` flag indicating to Node that we plan to inspect (debug)
    the process:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`$alloc`和`$serverHandler`的命名函数；这些函数名将用于跟踪我们的进程。现在，我们将启动该服务器，但使用一个特殊的`--inspect`标志指示Node我们计划检查（调试）该进程：
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You should see something like the following displayed:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的显示：
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Looks like the debugger is active. To view it, open up a Chrome browser and
    enter the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来调试器是激活的。要查看它，打开Chrome浏览器并输入以下内容：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You should see the process you've started listed. You can inspect that process
    or simply load up an active debugging screen by clicking on Open dedicated DevTools
    for Node, which will, from now on, attach to any Node process you start with `--inspect`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到你启动的进程被列出。你可以检查该进程，或者通过点击Open dedicated DevTools for Node加载一个活动的调试屏幕，从现在开始，它将附加到你使用`--inspect`启动的任何Node进程。
- en: CPU profiling
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU分析
- en: Open up another browser window and navigate to our test server at `localhost:8080`.
    You should see I'm done displayed (if not, go back and start up `server.js`, as
    instructed earlier). Keep that open; you'll be reloading this page shortly.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个浏览器窗口中打开并导航到我们的测试服务器`localhost:8080`。您应该会看到显示“我完成了”（如果没有，请返回并启动`server.js`，如之前所述）。保持打开；您将很快重新加载此页面。
- en: Click on Memory in the debugger UI, and you'll see the interface from earlier.
    This is the *standalone* version of the debugger we saw earlier.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器UI中点击“Memory”，您会看到之前的界面。这是我们之前看到的调试器的*独立*版本。
- en: 'Now, click on Profiler, which is the interface to debug CPU behavior (execution
    time in particular), and click on Start. Go back to your browser and reload the
    I''m done page a few times. Return to the debugger and click on Stop. You should
    see something like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击“Profiler”，这是调试CPU行为（特别是执行时间）的界面，然后点击“开始”。返回到浏览器并重新加载“我完成了”页面几次。返回调试器并点击“停止”。您应该会看到类似于这样的东西：
- en: '![](img/e807cf50-37d7-4bb0-83fe-98b03f61c73e.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e807cf50-37d7-4bb0-83fe-98b03f61c73e.png)'
- en: 'Note the three larger *blocks*, which were generated by three runs of our server
    handler. Using your mouse, select one of these blocks and zoom in:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意三个较大的*块*，这些块是由我们的服务器处理程序的三次运行生成的。使用鼠标，选择其中一个块并放大：
- en: '![](img/95871298-4bd1-4a04-a930-08badabaf7f6.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95871298-4bd1-4a04-a930-08badabaf7f6.png)'
- en: 'Here, we see a full breakdown of V8 activity engaged when handling our request.
    Remember `$alloc`? By mousing over its timeline, you can inspect the total CPU
    time it consumed. If we zoom in to the send section in the bottom-right, we can
    also see that it took our server 1.9 ms to execute an HTTP response:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们看到了处理我们请求时V8活动的全面分解。还记得`$alloc`吗？通过将鼠标悬停在其时间轴上，您可以检查它消耗的总CPU时间。如果我们放大到右下角的send部分，我们还可以看到我们的服务器执行HTTP响应花费了1.9毫秒： '
- en: '![](img/a1cc07bd-0a5d-4761-b1bb-dac482f2f154.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1cc07bd-0a5d-4761-b1bb-dac482f2f154.png)'
- en: Play around with this interface. In addition to helping you find and debug the
    slower parts of your application, when developing tests, you can use this tool
    to create a mental map of what the expected behavior of a *normal* run is, and
    design health tests. For example, one of your tests might call a specific route
    handler and pass or fail based on some predetermined maximum execution time threshold.
    If these tests are *always on*, probing your live application periodically, they
    might even trigger automatic throttling behaviors, log entries, or the sending
    of urgent emails to your engineering team.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 玩弄一下这个界面。除了帮助您找到和调试应用程序中较慢的部分之外，在开发测试时，您还可以使用此工具来创建对*正常*运行预期行为的心理地图，并设计健康测试。例如，您的一个测试可能会调用特定的路由处理程序，并根据一些预定的最大执行时间阈值来判断成功或失败。如果这些测试*总是开启*，定期探测您的实时应用程序，它们甚至可能触发自动限流行为、日志条目或向工程团队发送紧急电子邮件。
- en: Live debugging
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时调试
- en: 'Perhaps, the most powerful feature of this interface is its ability to directly
    debug running code, and to test the state of live applications. Click on the Sources tab
    in the debugger. This is an interface to the actual *scripts* comprising the Node
    process. You should see the *mounted* version of our `server.js` file:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，这个界面最强大的功能是它能够直接调试运行中的代码，并测试实时应用程序的状态。在调试器中点击“Sources”。这是实际*脚本*组成Node进程的界面。您应该会看到我们的`server.js`文件的*挂载*版本：
- en: '![](img/04271b8b-7ec7-4c54-9066-777b61b9e09f.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04271b8b-7ec7-4c54-9066-777b61b9e09f.png)'
- en: 'Fun fact: here, you can see how Node actually wraps your modules so that the
    global `exports`, `require`, `module`, `__filename`, and `__dirname` variables
    are available to you.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实：在这里，您可以看到Node如何实际包装您的模块，以便全局`exports`，`require`，`module`，`__filename`和`__dirname`变量对您可用。
- en: 'Let''s set a break point on line 11\. Just click on the number; you should
    see this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在第11行设置一个断点。只需点击数字；您应该会看到这个：
- en: '![](img/6d1e61e6-7b08-4c4d-8a76-41ccb91d82b6.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d1e61e6-7b08-4c4d-8a76-41ccb91d82b6.png)'
- en: Recall our discussion about the Node debugger earlier? The same principles will
    apply here; we'll be able to use this interface to step through executing code,
    stopping execution periodically, and examining application state.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们之前关于Node调试器的讨论吗？同样的原则也适用于这里；我们将能够使用这个界面来逐步执行代码，定期停止执行，并检查应用程序状态。
- en: 'To demonstrate, let''s cause this code to be executed in our server. Go back
    to your browser and reload `localhost:8080`, calling the route and ultimately
    hitting the break point you just set. The debugger interface should pop up, and
    will look something like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，让我们导致这段代码在我们的服务器上执行。返回到您的浏览器并重新加载`localhost:8080`，调用路由并最终触发您刚刚设置的断点。调试器界面应该会弹出，并且看起来会像这样：
- en: '![](img/b86f93b5-59e6-4931-9dca-859e587007b5.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b86f93b5-59e6-4931-9dca-859e587007b5.png)'
- en: In addition to clearly indicating where we are (the line number, within the
    `$serverHandler` function), the interface is also usefully showing us the value
    of `d` in the current iteration of a `while` loop. Recall our Node debugger discussion
    earlier? The same principles apply here. If you hover over the debugging control
    icons on the right, you'll see that the second one is the *step over* function.
    We're in a loop; let's step to the next iteration. Go ahead and hit step over
    the loop several times. Did you note how the value of d is being updated while
    you step through this loop?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了清楚地指示我们所在的位置（在`$serverHandler`函数内的行号），界面还有用地显示了`while`循环的当前迭代中`d`的值。还记得我们之前关于Node调试器的讨论吗？同样的原则也适用于这里。如果您将鼠标悬停在右侧的调试控件图标上，您会看到第二个是*步进*功能。我们在一个循环中；让我们步进到下一个迭代。继续点击步进几次。您是否注意到在您通过这个循环时`d`的值是如何更新的？
- en: If you explore the interface on the right, you can dig very far into the current
    state of the program, with a full breakdown of all scope variables, globals being
    referenced, and so forth. By using the *step into* control, you can watch the
    progress of every single request through the execution stack, walking through
    the Node runtime as it executes. You will benefit from this exercise and understand
    your code (and how Node works) much more clearly. This will help you become a
    better test writer.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您探索右侧的界面，您可以深入了解程序的当前状态，全面分解所有作用域变量、全局引用等。通过使用*step into*控制，您可以观察每个请求通过执行堆栈的进展，跟踪Node运行时的执行过程。您将受益于这个练习，并更清楚地了解您的代码（以及Node的工作原理）。这将帮助您成为更好的测试编写者。
- en: 'Usefully, there is a chrome plugin that makes interacting with inspected Node
    processes as simple as point and click; it''s available at: [https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个Chrome插件，使与检查的Node进程交互变得简单，只需点一下鼠标即可；它可以在以下链接找到：[https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj)。
- en: '*Mathias Buus* has created an interesting tool, providing very useful debugging
    information for the rare but hair-pulling case of processes not ending when they
    are supposed to, and you can find it at: [https://github.com/mafintosh/why-is-node-running](https://github.com/mafintosh/why-is-node-running).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mathias Buus*创建了一个有趣的工具，为那些罕见但令人抓狂的进程不在预期结束时提供了非常有用的调试信息，您可以在以下链接找到它：[https://github.com/mafintosh/why-is-node-running](https://github.com/mafintosh/why-is-node-running)。'
- en: '*Matteo Collina''s* excellent `loopbench` ([https://github.com/mcollina/loopbench](https://github.com/mcollina/loopbench))
    and its packaged version for Node servers ([https://github.com/davidmarkclements/overload-protection](https://github.com/davidmarkclements/overload-protection))
    can be used to not only provide testing and debugging information, but for the
    development of smart, self-regulating servers than will automatically shed (or
    redirect) loads when running too hot, a nice feature in a distributed application
    architecture of independent, networked nodes.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*Matteo Collina*的出色的`loopbench` ([https://github.com/mcollina/loopbench](https://github.com/mcollina/loopbench))
    及其针对Node服务器的打包版本 ([https://github.com/davidmarkclements/overload-protection](https://github.com/davidmarkclements/overload-protection))
    不仅可用于提供测试和调试信息，还可用于开发智能、自我调节的服务器，当运行过热时会自动卸载（或重定向）负载，这是独立、联网节点的分布式应用架构中的一个很好的特性。'
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Node community has embraced testing from the beginning, and many testing
    frameworks and native tools are made available to developers. In this chapter,
    we examined why testing is so important to modern software development as well
    as something about functional, unit, and integration testing, what they are, and
    how they can be used. With the vm module, we learned how to create special contexts
    for testing JavaScript programs, and picking up some techniques for sandboxing
    untrusted code along the way.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Node社区从一开始就支持测试，并为开发人员提供了许多测试框架和本地工具。在本章中，我们探讨了为什么测试对现代软件开发如此重要，以及有关功能、单元和集成测试的一些内容，它们是什么，以及如何使用它们。通过vm模块，我们学习了如何为测试JavaScript程序创建特殊的上下文，并在此过程中掌握了一些用于沙盒化不受信任代码的技巧。
- en: In addition, we learned how to work with the extensive set of Node testing and
    error-handling tools, from more expressive console logging to Mocha and mocking
    with Sinon, onto one line tracing and debugging heaps and live code. Finally,
    we learned about two different headless browser testing libraries, learning two
    ways in which such testing might be done in each, and how these virtual browsers
    can be integrated with other testing environments.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们学习了如何使用丰富的Node测试和错误处理工具，从更具表现力的控制台日志记录到Mocha和Sinon的模拟，再到一行追踪和调试堆和实时代码。最后，我们学习了两种不同的无头浏览器测试库，学习了每种测试可能的两种方式，以及这些虚拟浏览器如何与其他测试环境集成。
- en: Now that you can test your code, go out and experiment with the power of Node.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以测试您的代码，去尝试Node的强大功能。
