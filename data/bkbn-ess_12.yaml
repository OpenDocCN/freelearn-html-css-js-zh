- en: Chapter 12. Summary and Further Reading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。总结和进一步阅读
- en: 'In this chapter, we begin by looking back over everything we''ve covered in
    the previous chapters. We then look at how Backbone is being used to power a real-world
    medical application, and finally, we look forward to how you can continue your
    Backbone education. In particular we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先回顾了前几章中我们所涵盖的所有内容。然后我们看看Backbone是如何被用来驱动一个真实世界的医疗应用的，最后，我们展望一下你如何继续你的Backbone学习。特别是我们将涵盖以下内容：
- en: Summarize the roles of various Backbone components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结各种Backbone组件的角色
- en: Learn how Backbone is being used today to power Syapse
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Backbone今天是如何被用来驱动Syapse的
- en: Consider how everything we've learned is applied to the Syapse use case
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一下我们所学的所有内容是如何应用到Syapse用例中的
- en: Look at further opportunities to learn about Backbone
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看进一步学习Backbone的机会
- en: Putting it all together
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: In the first half of this book, we examined the four Backbone classes (`Collection`,
    `Model`, `Router`, and `View`), and how each of them fit together to build a web
    application. To refresh, a Backbone-powered site starts with a `Router` class,
    which is used to map URLs to the virtual pages of the application. `Router` makes
    up half of the MVC `Controller` layer, while the `View` class makes up the other
    half. The `View` class is also responsible for the MVC `View` layer of a web application,
    as `View` classes both render the pages that make up the site and listen for and
    respond to user-generated events.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的前半部分，我们研究了四个Backbone类（`Collection`、`Model`、`Router`和`View`），以及它们如何组合在一起构建一个Web应用。为了回顾，一个由Backbone驱动的网站从`Router`类开始，该类用于将URL映射到应用的虚拟页面。`Router`构成了MVC
    `Controller`层的一半，而`View`类构成了另一半。`View`类还负责Web应用的MVC `View`层，因为`View`类不仅渲染构成网站的页面，还监听并响应用户生成的事件。
- en: Of course, a data or MVC `Model` layer is also essential for almost any application,
    and this layer is handled by the `Model` and `Collection` classes. `Model` classes,
    which represent individual data objects, are used both to manage data on the client-side
    and to send and receive data to and from the server. `Collection` classes hold
    sets of `Model` classes but are otherwise used similarly to manage data and transmit
    it to/from the server. `Model` and `Collection` classes are used primarily by
    `View` classes, which render their data into DOM elements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，数据或MVC `Model`层对于几乎任何应用都是必不可少的，这个层由`Model`和`Collection`类处理。代表单个数据对象的`Model`类，既用于管理客户端的数据，也用于向服务器发送和接收数据。`Collection`类持有`Model`类的集合，但除此之外，它们在管理数据和将其传输到/从服务器方面被用于类似的方式。`Model`和`Collection`类主要被`View`类使用，这些类将它们的数据渲染到DOM元素中。
- en: All of these classes are designed not just to be used directly but also to be
    extended into new subclasses with logic specific to your application. This same
    extension mechanism is used by third-party Backbone libraries, such as BackGrid
    and BackSupport, to provide components that further extend the capabilities of
    your application. However, Backbone-specific libraries aren't the only third-party
    libraries that you can use in your Backbone application. By wrapping non-Backbone
    components with your own custom Backbone classes, you can cleanly incorporate
    tools such as a template system or a jQuery UI widget in to your application.
    Even libraries that can't be wrapped in a Backbone class, such as Underscore,
    RequireJS, or Mocha, can be used independently to add functionality without losing
    any of the benefits of Backbone itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类不仅设计为直接使用，而且还可以扩展到具有特定于您应用程序的逻辑的新子类。第三方Backbone库，如BackGrid和BackSupport，使用相同的扩展机制来提供进一步扩展您应用程序功能的组件。然而，Backbone特定的库并不是您可以在Backbone应用程序中使用的唯一第三方库。通过将非Backbone组件包装在您自己的自定义Backbone类中，您可以干净地集成模板系统或jQuery
    UI小部件等工具到您的应用程序中。即使不能包装在Backbone类中的库，如Underscore、RequireJS或Mocha，也可以独立使用以添加功能，而不会失去Backbone本身的任何好处。
- en: This, in short, summarizes everything we've learned so far, but as we covered
    that information originally, we kept our focus on component at a time. As we finish
    this book, it would be beneficial to look at how all these pieces can be used
    together to implement a real-world use case. That use case is Syapse.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这总结了到目前为止我们所学的所有内容，但由于我们最初是逐个介绍这些信息的，所以我们一次只关注一个组件。随着这本书的完成，回顾一下所有这些部分如何共同用于实现一个真实世界的用例将是有益的。这个用例是Syapse。
- en: What's Syapse?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Syapse是什么？
- en: As mentioned in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Building a
    Single-Page Site Using Backbone"), *Building a Single-Page Site Using Backbone*,
    Syapse ([http://www.syapse.com](http://www.syapse.com)) is a Backbone-powered
    web application for requesting and providing precision medicine results. Syapse's
    customers are laboratories and hospitals that use genetic sequencing to profile
    patients with serious diseases like cancer. Once sequenced, these genetic profiles
    can be combined with large bodies of research to determine the best treatments
    and dosages for a given patient based on the patient's own DNA.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](part0015.xhtml#aid-E9OE1 "第1章。使用Backbone构建单页网站")中所述，*使用Backbone构建单页网站*，Syapse([http://www.syapse.com](http://www.syapse.com))是一个由Backbone驱动的Web应用程序，用于请求和提供精准医疗结果。Syapse的客户是使用基因测序来分析患有严重疾病（如癌症）的患者的实验室和医院。一旦测序，这些基因图谱可以与大量研究相结合，根据患者的DNA确定针对特定患者的最佳治疗和剂量。
- en: Let's take a look at how Syapse was put together.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Syapse是如何构建的。
- en: The 10,000-foot view
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 俯瞰全局
- en: 'Syapse''s client-side code is organized using Require.js (see *Dependency management
    with RequireJS* in [Chapter 11](part0095.xhtml#aid-2QJ5E1 "Chapter 11. (Not) Re-Inventing
    the Wheel – Utilizing Third-Party Libraries"), *(Not) Re-Inventing the Wheel:
    Utilizing Third-Party Libraries*). Every module is either a class, a singleton
    instance (for utility libraries), or a function (for routes). Syapse has two different
    sites, one for laboratories and the other for clinics, so we use RequireJS to
    compile separate JavaScript files for each site.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Syapse的客户端代码使用Require.js进行组织（参见[第11章](part0095.xhtml#aid-2QJ5E1 "第11章。（不）重新发明轮子
    – 利用第三方库")中的*使用RequireJS进行依赖管理*，*(不)重新发明轮子：利用第三方库*)。每个模块要么是一个类，要么是一个单例实例（用于实用库），要么是一个函数（用于路由）。Syapse有两个不同的网站，一个用于实验室，另一个用于诊所，因此我们使用RequireJS为每个网站编译单独的JavaScript文件。
- en: Each of these files has its own Backbone `Router`, allowing each site to have
    a completely distinct set of URLs and pages (see *Multiple routers* in [Chapter
    6](part0054.xhtml#aid-1JFUC1 "Chapter 6. Creating Client-side Pages with Routers"),
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些文件都有自己的Backbone `Router`，允许每个网站拥有完全不同的URL和页面集（参见[第6章](part0054.xhtml#aid-1JFUC1
    "第6章。使用路由器创建客户端页面")中的*多路由*）。
- en: '*Creating Client-Side Pages with Routers*). These `Router` classes form the
    top of the RequireJS dependency tree, bringing in (or depending on) all of the
    site''s routes. These route modules then bring in the site''s `Views` classes,
    which in turn bring in the site''s `Model` and `Collection` classes.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用路由器创建客户端页面*)。这些`Router`类构成了RequireJS依赖树的顶层，引入（或依赖于）网站的所有路由。这些路由模块随后引入网站的用户界面`Views`类，这些类反过来又引入网站的`Model`和`Collection`类。'
- en: 'There are four "base" classes that every other class in the application inherits
    from. These base classes are based on the BackSupport classes (see *Making life
    easier with BackSupport* in [Chapter 11](part0095.xhtml#aid-2QJ5E1 "Chapter 11. (Not)
    Re-Inventing the Wheel – Utilizing Third-Party Libraries"), *(Not) Re-Inventing
    the Wheel: Utilizing Third-Party Libraries*), and are used to define new features
    that are Syapse-specific. For instance, since Syapse uses the Handlebars templating
    library, the base `View` class includes the logic for rendering Handlebars templates
    (see *Templating with Handlebars* in [Chapter 11](part0095.xhtml#aid-2QJ5E1 "Chapter 11. (Not)
    Re-Inventing the Wheel – Utilizing Third-Party Libraries"), *(Not) Re-Inventing
    the Wheel: Utilizing Third-Party Libraries*).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的每个其他类都继承自四个“基础”类。这些基础类基于BackSupport类（参见[第11章](part0095.xhtml#aid-2QJ5E1
    "第11章。（不）重新发明轮子 – 利用第三方库")中的*使用BackSupport简化生活*，*(不)重新发明轮子：利用第三方库*)，并用于定义Syapse特有的新功能。例如，由于Syapse使用Handlebars模板库，基础`View`类包含了渲染Handlebars模板的逻辑（参见[第11章](part0095.xhtml#aid-2QJ5E1
    "第11章。（不）重新发明轮子 – 利用第三方库")中的*使用Handlebars进行模板化*，*(不)重新发明轮子：利用第三方库*)。
- en: Syapse uses the `Page View` pattern (see *Page views* in [Chapter 5](part0050.xhtml#aid-1FLS42
    "Chapter 5. Adding and Modifying Elements with Views"), *Adding and Modifying
    Elements With Views*) with one base `Page View` class for the laboratory interface
    and one for the clinic interface. These render all of the parts of the site that
    are shared between pages, such as the navigation menu, and both of these `Page
    View` patterns share a common base `View` class, allowing them to reuse generic
    page-rendering logic that is common to both sites.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Syapse 使用 `Page View` 模式（参见[第5章](part0050.xhtml#aid-1FLS42 "第5章。使用视图添加和修改元素")中的
    *页面视图*，*使用视图添加和修改元素*），为实验室界面使用一个基 `Page View` 类，为诊所界面使用另一个。这些渲染了网站在页面之间共享的所有部分，例如导航菜单，这两个
    `Page View` 模式共享一个共同的基 `View` 类，允许它们重用两个网站共有的通用页面渲染逻辑。
- en: The View layer
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图层
- en: 'Pages in the Syapse laboratory site are divided into three sections, each with
    their own `View` class: a left navigation section, a header area, and a main content
    area. Each of these can optionally be overwritten when the page is instantiated,
    letting each route modify only its unique section(s). For instance, most routes
    don''t change the left navigation bar, so when these routes instantiate the page
    `View` class, they simply rely on the default navigation bar of this `View` class.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Syapse 实验室网站中的页面分为三个部分，每个部分都有自己的 `View` 类：一个左侧导航部分、一个页眉区域和一个主要内容区域。在页面实例化时，这些部分可以可选地被覆盖，这样每个路由只需修改其独特的部分。例如，大多数路由不会更改左侧导航栏，因此当这些路由实例化页面
    `View` 类时，它们只是依赖于这个 `View` 类的默认导航栏。
- en: Each of the subclasses of `View` handles the rendering of its part of the page.
    Because Syapse relies on *The combined approach* (see [Chapter 5](part0050.xhtml#aid-1FLS42
    "Chapter 5. Adding and Modifying Elements with Views"), *Adding and Modifying
    Elements with Views*) to do its rendering, these `View` classes use a combination
    of Handlebars templates and other child `View` classes to generate their content.
    For particularly complex pages, this can result in not just child `View` classes
    but also grandchild, great grandchild, and sometimes, even great-great grandchild
    `View` classes. Whenever possible, Syapse uses multiple smaller `View` classes
    rather than one large one, to keep the logic for each `View` class as simple as
    possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `View` 的子类都处理页面一部分的渲染。因为 Syapse 依赖于 *The combined approach*（参见[第5章](part0050.xhtml#aid-1FLS42
    "第5章。使用视图添加和修改元素")，*使用视图添加和修改元素*) 来进行渲染，这些 `View` 类使用 Handlebars 模板和其他子 `View`
    类的组合来生成其内容。对于特别复杂的页面，这可能会导致不仅子 `View` 类，还有孙子、曾孙，有时甚至曾曾孙 `View` 类。只要可能，Syapse 都会使用多个较小的
    `View` 类而不是一个大的类，以使每个 `View` 类的逻辑尽可能简单。
- en: For consistency, all of the render methods in these `View` classes return this.
    Further, for consistency, each `View` class is designed to be re-renderable, so
    that it can easily listen and respond to change events in its `Model` classes
    (see *Other render considerations* in [Chapter 5](part0050.xhtml#aid-1FLS42 "Chapter 5. Adding
    and Modifying Elements with Views"), *Adding and Modifying Elements with Views*).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，这些 `View` 类中的所有渲染方法都返回这个结果。此外，为了保持一致性，每个 `View` 类都设计为可重新渲染的，这样它就可以轻松地监听和响应其
    `Model` 类中的更改事件（参见[第5章](part0050.xhtml#aid-1FLS42 "第5章。使用视图添加和修改元素")中的 *其他渲染考虑因素*，*使用视图添加和修改元素*）。
- en: The Data layer
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据层
- en: On the server-side, Syapse uses Python and the Django REST Framework library
    to power all of its APIs, and while this gives the server team a great deal of
    control over the API, they are still somewhat limited by the library and can't
    always make APIs that return ideal Backbone JSON. Because of this many of Syapse's
    `Model` and `Collection` classes make use of `parse` and `toJSON` method overrides
    to extract or send back the correct JSON to/from the API (see *Fetching data from
    the server* and *Saving data to the server* in [Chapter 3](part0029.xhtml#aid-RL0A1
    "Chapter 3. Accessing Server Data with Models"), *Accessing Server Data with Models*).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，Syapse 使用 Python 和 Django REST 框架库来驱动其所有 API，虽然这给了服务器团队对 API 的很大控制权，但他们仍然受到库的限制，不能总是创建返回理想
    Backbone JSON 的 API。因此，Syapse 的许多 `Model` 和 `Collection` 类都使用 `parse` 和 `toJSON`
    方法重写来从 API 中提取或发送正确的 JSON（参见[第3章](part0029.xhtml#aid-RL0A1 "第3章。使用模型访问服务器数据")中的
    *从服务器获取数据* 和 *将数据保存到服务器*，*使用模型访问服务器数据*）。
- en: 'Sometimes, Syapse''s APIs return not just the data for a given `Model` or `Collection`
    class but also supplemental information. For instance, an API that returns a patient
    `Model` class might include the ID of that patient''s doctor, but since the end
    user wants to see a name instead of an ID, the API response also includes a separate
    map of IDs to names. To keep track of this supplemental information, Syapse relies
    on a global pub/sub system (see *Publish/Subscribe* in [Chapter 7](part0069.xhtml#aid-21PMQ1
    "Chapter 7. Fitting Square Pegs in Round Holes – Advanced Backbone Techniques"),
    *Fitting Square Pegs in Round Holes: Advanced Backbone Techniques*). Whenever
    a `Model` class parses such supplemental information during a fetch, it triggers
    a special supplemental information" event with this information as an extra argument.
    This event is then listened for by one or more site-wide `Collection` caches,
    which aggregate the supplemental information and make it available for the `View`
    classes.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Syapse 的 API 不仅返回特定 `Model` 或 `Collection` 类的数据，还返回补充信息。例如，返回患者 `Model` 类的
    API 可能包括该患者医生的 ID，但由于最终用户希望看到名称而不是 ID，API 响应还包括一个 ID 到名称的单独映射。为了跟踪这些补充信息，Syapse
    依赖于一个全局的 pub/sub 系统（参见第 7 章 *将方钉嵌入圆孔 - 高级 Backbone 技巧* 中的 *发布/订阅* [Chapter 7](part0069.xhtml#aid-21PMQ1
    "第 7 章。将方钉嵌入圆孔 - 高级 Backbone 技巧")，*将方钉嵌入圆孔：高级 Backbone 技巧*）。每当 `Model` 类在获取过程中解析这样的补充信息时，它就会触发一个带有此信息作为额外参数的“补充信息”特殊事件。然后，一个或多个网站范围的
    `Collection` 缓存会监听此事件，聚合补充信息并将其提供给 `View` 类。
- en: The Support layer
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持层
- en: 'All of Syapse''s code is tested using Selenium for acceptance testing and Mocha/Sinon
    for unit testing (see *Testing? In JavaScript?* and *Selenium* in [Chapter 10](part0089.xhtml#aid-2KS221
    "Chapter 10. Keeping the Bugs Out – How to Test a Backbone Application"), *Keeping
    the Bugs Out: How to Test a Backbone Application*). By using expressive test names
    and the BDD test output style (see *TDD versus BDD: What''s the difference?* in
    [Chapter 10](part0089.xhtml#aid-2KS221 "Chapter 10. Keeping the Bugs Out – How
    to Test a Backbone Application"), *Keeping the Bugs Out: How to Test a Backbone
    Application*), we ensure that Syapse''s test output is very specific and looks
    like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Syapse 的所有代码都使用 Selenium 进行验收测试，以及 Mocha/Sinon 进行单元测试（参见第 10 章 *如何测试 Backbone
    应用程序* 中的 *Testing? In JavaScript?* 和 *Selenium* [Chapter 10](part0089.xhtml#aid-2KS221
    "第 10 章。如何排除错误 - 如何测试 Backbone 应用程序")，*如何排除错误：如何测试 Backbone 应用程序*）。通过使用表达式的测试名称和BDD
    测试输出风格（参见第 10 章 *TDD 与 BDD：有什么区别？* [Chapter 10](part0089.xhtml#aid-2KS221 "第 10
    章。如何排除错误 - 如何测试 Backbone 应用程序")，*如何排除错误：如何测试 Backbone 应用程序*），我们确保 Syapse 的测试输出非常具体，如下所示：
- en: '![The Support layer](img/image00171.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![支持层](img/image00171.jpeg)'
- en: For documentation, Syapse relies primarily on inline documentation, using JSDoc
    annotations without actually rendering documentation pages (see *The robust documentation
    approach* in [Chapter 9](part0083.xhtml#aid-2F4UM1 "Chapter 9. What Was I Thinking?
    Documenting Backbone Code"), *What Was I Thinking? Documenting Backbone Code*).
    However, Syapse also has a customer-facing JavaScript API, which is considerably
    more heavily documented than both generated JSDoc API pages and a Docco-based
    tutorial.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文档，Syapse 主要依赖于内联文档，使用 JSDoc 注释而不实际渲染文档页面（参见第 9 章 *我在想什么？记录 Backbone 代码* 中的
    *健壮的文档方法* [Chapter 9](part0083.xhtml#aid-2F4UM1 "第 9 章。我在想什么？记录 Backbone 代码")，*我在想什么？记录
    Backbone 代码*）。然而，Syapse 还有一个面向客户的 JavaScript API，其文档比生成的 JSDoc API 页面和基于 Docco
    的教程都要详细得多。
- en: Building your own Syapse
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自己的 Syapse
- en: Your application might be, like Syapse, a serious tool designed to help with
    a critical problem such as fighting cancer. Alternatively, your application might
    be something more fun, like a game or personal project. In either case, Backbone
    offers everything you need to not just build your site but also continue adding
    to and maintaining the site over its entire lifetime.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可能像 Syapse 一样，是一个旨在帮助解决关键问题（如对抗癌症）的严肃工具。或者，您的应用程序可能更有趣，比如一个游戏或个人项目。在两种情况下，Backbone
    都提供了您构建网站所需的一切，并且在整个生命周期中继续添加和维护网站。
- en: However, no book can possibly explain every possible nuance of a library that
    is as flexible and as powerful as Backbone. At its core, Backbone strives to do
    only a few important things well and leaves everything else up to you, the programmer.
    This not only means a great deal of power and flexibility, but it also means that
    you have to make a large number of decisions for yourself as to how you want to
    use Backbone. To make the correct decisions, and truly take advantage of everything
    Backbone has to offer, you will no doubt want to continue learning as much as
    you can about both Backbone in particular and web development in general.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有一本书能解释清楚像 Backbone 这样灵活且强大的库的每一个可能的细微差别。在核心上，Backbone 努力只做好几件重要的事情，并将其他所有事情留给您，即程序员。这不仅意味着巨大的力量和灵活性，还意味着您必须自己做出大量决定，以确定您想要如何使用
    Backbone。为了做出正确的决定，真正利用 Backbone 提供的一切，您无疑会想要继续尽可能多地学习关于 Backbone 以及一般网络开发的知识。
- en: Further reading
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: There are many places to learn about Backbone, but perhaps, the best place is
    Backbone's own source code. As the author of both Backbone and Docco, it's no
    surprise that Jeremy Ashkenas uses the Docco documentation tool to provide an
    annotated version of Backbone's source code, which you can find at [http://backbonejs.org/docs/backbone.html](http://backbonejs.org/docs/backbone.html).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Backbone 的地方有很多，但或许，最好的地方就是 Backbone 的自身源代码。作为 Backbone 和 Docco 的作者，杰里米·阿什肯纳斯（Jeremy
    Ashkenas）使用 Docco 文档工具提供 Backbone 源代码的注释版本，您可以在[http://backbonejs.org/docs/backbone.html](http://backbonejs.org/docs/backbone.html)找到它。
- en: However, you don't need the annotated version to read Backbone's code. In fact,
    whenever some part of Backbone seems confusing or difficult to understand, one
    of the best ways to learn more is to throw debugger statements into the Backbone
    source code itself and then, run your application using the browser's debugging
    tool. By walking through the code in the debugger, you can see the logic progress
    through Backbone's classes and methods, and because the source code is so well-written
    and readable, this task will be much less daunting than it would be with almost
    any other major JavaScript library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您不需要注释版本来阅读 Backbone 的代码。实际上，每当 Backbone 的某个部分看起来令人困惑或难以理解时，学习更多的一个最好的方法是将调试语句抛入
    Backbone 源代码本身，然后使用浏览器的调试工具运行您的应用程序。通过在调试器中遍历代码，您可以看到逻辑在 Backbone 的类和方法中逐步推进，而且由于源代码写得非常好且易于阅读，这项任务将比几乎任何其他主要的
    JavaScript 库都要简单得多。
- en: Backbone also offers a wiki at [https://github.com/jashkenas/backbone/wiki](https://github.com/jashkenas/backbone/wiki).
    In addition to basic Backbone information, this wiki includes collections of plugins
    and development tools, lists of companies that use Backbone, and a great variety
    of tutorials and informative blog posts. This latter list (which can be found
    at [https://github.com/jashkenas/backbone/wiki/Tutorials,-blog-posts-and-example-sites](https://github.com/jashkenas/backbone/wiki/Tutorials,-blog-posts-and-example-sites))
    is particularly valuable, with more than fifty different high-quality sites where
    you can learn more about Backbone.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 还提供了一个位于 [https://github.com/jashkenas/backbone/wiki](https://github.com/jashkenas/backbone/wiki)
    的维基百科。除了基本 Backbone 信息外，这个维基还包含了插件和开发工具的集合、使用 Backbone 的公司列表，以及大量的教程和信息性博客文章。这个后者列表（可在
    [https://github.com/jashkenas/backbone/wiki/Tutorials,-blog-posts-and-example-sites](https://github.com/jashkenas/backbone/wiki/Tutorials,-blog-posts-and-example-sites)
    找到）尤其有价值，有超过五十个不同的高质量网站，您可以在这些网站上了解更多关于 Backbone 的信息。
- en: 'Another great source of information on Backbone is Packt Publishing, which
    offers many great Backbone-focused books. While they do cover some of the same
    basics as this book, you might find the sample applications built in *BackboneJS
    Blueprints* by Andrew Bugess or the recipes of *Backbone.js Cookbook* by Vadim
    Mirgood to be valuable. If you''d prefer a more advanced look at useful Backbone
    patterns you can employ, then you might instead find *Backbone.js Patterns and
    Best Practices* by Swarnendu De useful. Further, if you find your interest piqued
    by [Chapter 10](part0089.xhtml#aid-2KS221 "Chapter 10. Keeping the Bugs Out –
    How to Test a Backbone Application"), *Keeping the Bugs Out: How to Test a Backbone
    Application*, then *Backbone.js Testing* by Ryan Roemer is a perfect text for
    you to learn more about Backbone testing.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 的另一个信息来源是 Packt Publishing，它提供了许多专注于 Backbone 的书籍。虽然它们确实覆盖了与本书相同的一些基础知识，但你可能会发现
    Andrew Bugess 编写的 *BackboneJS Blueprints* 中的示例应用程序或 Vadim Mirgood 编写的 *Backbone.js
    Cookbook* 中的食谱很有价值。如果你更喜欢更深入地了解你可以使用的有用 Backbone 模式，那么 Swarnendu De 的 *Backbone.js
    Patterns and Best Practices* 可能对你很有用。此外，如果你对 [第 10 章](part0089.xhtml#aid-2KS221
    "第 10 章。消除虫子 - 如何测试 Backbone 应用程序") *消除虫子：如何测试 Backbone 应用程序* 感兴趣，那么 Ryan Roemer
    的 *Backbone.js Testing* 是你学习 Backbone 测试的完美文本。
- en: However, as great as books are, they can never keep completely up-to-date with
    the very latest in emerging Backbone technologies, and that's where certain websites
    can be invaluable. One incredible resource is Stack Overflow ([http://www.stackoverflow.com](http://www.stackoverflow.com)),
    where programmers of any persuasion can find answers to their technical questions,
    including ones about Backbone. However, Stack Overflow can also be valuable when
    you don't have a specific question. Because the site has both *tags* and *votes*
    on every question, you can search for questions with the `backbone.js` tag, and
    then sort them by votes; any questions at the top will most likely be educational.
    At the time of writing, Stack Overflow featured more than 12,000 different Backbone
    questions with answers (and more than 17,000 questions in total).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管书籍很棒，但它们永远无法完全跟上新兴 Backbone 技术的最新发展，这就是某些网站可以非常有价值的地方。一个令人难以置信的资源是 Stack
    Overflow ([http://www.stackoverflow.com](http://www.stackoverflow.com))，任何倾向的程序员都可以在这里找到他们技术问题的答案，包括关于
    Backbone 的问题。然而，当你没有具体问题时，Stack Overflow 同样很有价值。因为该网站在每个问题都有 *标签* 和 *投票*，你可以搜索带有
    `backbone.js` 标签的问题，然后按投票排序；顶部的问题很可能是有教育意义的。在撰写本文时，Stack Overflow 特点了超过 12,000
    个不同的 Backbone 问题及其答案（总共有超过 17,000 个问题）。
- en: Another similar question and answer site, which isn't programming-focused, is
    Quora ([https://www.quora.com/](https://www.quora.com/)). While Stack Overflow
    limits itself exclusively to objective questions, Quora has no such limitation
    and so is perfect for more subjective questions, such as "What are the advantages
    of Backbone.js" ([http://www.quora.com/What-are-the-advantages-of-Backbone-js](http://www.quora.com/What-are-the-advantages-of-Backbone-js)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的问题和答案网站，它不是以编程为重点的是 Quora ([https://www.quora.com/](https://www.quora.com/))。虽然
    Stack Overflow 限制自己只回答客观问题，但 Quora 没有这样的限制，因此非常适合回答更主观的问题，例如“Backbone.js 的优势是什么”([http://www.quora.com/What-are-the-advantages-of-Backbone-js](http://www.quora.com/What-are-the-advantages-of-Backbone-js))。
- en: Another excellent place to learn about Backbone is the Backbone Google Group
    ([https://groups.google.com/forum/#!forum/backbonejs](https://groups.google.com/forum/#!forum/backbonejs)),
    which has an active community. If, on the other hand, you prefer to follow a stream
    of news articles, the Backbone sub-feed on Reddit ([http://www.reddit.com/r/backbonejs/](http://www.reddit.com/r/backbonejs/))
    is a great resource for keeping up to date. Finally, on a more general level,
    Hacker News ([https://news.ycombinator.com/](https://news.ycombinator.com/)),
    Lobsters ([https://lobste.rs](https://lobste.rs)), and Dzone ([http://www.dzone.com/links/index.html](http://www.dzone.com/links/index.html))
    all feature continuous feeds of various programming-related news and articles,
    including many on JavaScript in general and Backbone in particular.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个了解 Backbone 的优秀地方是 Backbone Google Group ([https://groups.google.com/forum/#!forum/backbonejs](https://groups.google.com/forum/#!forum/backbonejs))，这里有一个活跃的社区。另一方面，如果你更喜欢关注一系列新闻文章，Reddit
    上的 Backbone 子版块 ([http://www.reddit.com/r/backbonejs/](http://www.reddit.com/r/backbonejs/))
    是一个很好的资源，可以帮助你保持最新信息。最后，在更广泛的意义上，Hacker News ([https://news.ycombinator.com/](https://news.ycombinator.com/))、Lobsters
    ([https://lobste.rs](https://lobste.rs)) 和 Dzone ([http://www.dzone.com/links/index.html](http://www.dzone.com/links/index.html))
    都提供了各种编程相关新闻和文章的连续更新，包括许多关于 JavaScript（特别是 Backbone）的文章。
- en: Summary
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the previous eleven chapters and summarized patterns
    of how to use Backbone to build a robust web application. We also looked specifically
    at how Backbone was used to build the cancer-fighting application Syapse. Finally,
    we examined other places where you can learn even more about Backbone, including
    other great books from Packt Publishing. We hope you enjoyed this book, and we
    wish you the best of luck in creating powerful web applications using Backbone.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了前十一章的内容，并总结了如何使用 Backbone 构建健壮的 Web 应用的模式。我们还特别探讨了 Backbone 如何被用于构建抗癌应用
    Syapse。最后，我们考察了其他你可以学习更多关于 Backbone 的地方，包括 Packt 出版的其他优秀书籍。我们希望你喜欢这本书，并祝愿你在使用
    Backbone 创建强大的 Web 应用时一切顺利。
