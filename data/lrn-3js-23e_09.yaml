- en: Chapter 9. Animations and Moving the Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 动画和移动相机
- en: 'In the previous chapters, we have seen some simple animations, but nothing
    too complex. In [Chapter 1](ch01.html "Chapter 1. Creating Your First 3D Scene
    with Three.js"), *Creating Your First 3D Scene with Three.js*, we introduced the
    basic rendering loop, and in the chapter following that, we used that to rotate
    some simple objects and show a couple of other basic animation concepts. In this
    chapter, we''re going to look in more detail at how animation is supported by
    Three.js. We will look in detail at the following four subjects:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了一些简单的动画，但并没有太复杂。在[第1章](ch01.html "第1章 使用Three.js创建您的第一个3D场景")中，*使用Three.js创建您的第一个3D场景*，我们介绍了基本的渲染循环，在随后的章节中，我们使用它来旋转一些简单的对象并展示了一些其他的基本动画概念。在本章中，我们将更详细地探讨Three.js如何支持动画。我们将详细探讨以下四个主题：
- en: Basic animation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本动画
- en: Moving the camera
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动相机
- en: Morphing and skinning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形变和蒙皮
- en: Loading external animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载外部动画
- en: We start with the basic concepts behind animations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从动画背后的基本概念开始。
- en: Basic animations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本动画
- en: 'Before we look at the examples, let''s do a quick recap of what was shown in
    [Chapter 1](ch01.html "Chapter 1. Creating Your First 3D Scene with Three.js"),
    *Creating Your First 3D Scene with Three.js*, on the render loop. To support animations,
    we need to tell Three.js to render the scene every so often. For this, we use
    the standard HTML5 `requestAnimationFrame` functionality, as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看示例之前，让我们快速回顾一下在[第1章](ch01.html "第1章 使用Three.js创建您的第一个3D场景")中展示的内容，*使用Three.js创建您的第一个3D场景*，关于渲染循环。为了支持动画，我们需要告诉Three.js每隔一段时间渲染场景。为此，我们使用标准的HTML5
    `requestAnimationFrame`功能，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this code, we only need to call the `render()` function once when were
    done initializing the scene. In the `render()` function itself, we use `requestAnimationFrame`
    to schedule the next rendering. This way, the browser will make sure the `render()`
    function is called at the correct interval (usually around 60 times a second).
    Before `requestAnimationFrame` was added to browsers, `setInterval(function, interval)`
    or `setTimeout(function, interval)` were used. These would call the specified
    function once every set interval. The problem with this approach is that it doesn't
    take into account what else is going on. Even if your animation isn't shown or
    is in a hidden tab, it is still called and is still using resources. Another issue
    is that these functions update the screen whenever they are called, not when it
    is the best time for the browser, which means higher CPU usage. With `requestAnimationFrame`,
    we don't tell the browser when it needs to update the screen; we ask the browser
    to run the supplied function when it's most opportune. Usually, this results in
    a frame rate of about 60 fps. With `requestAnimationFrame`, your animations will
    run more smoothly and will be more CPU- and GPU-friendly, and you don't have to
    worry about timing issues yourself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们只需要在初始化场景完成后调用一次`render()`函数。在`render()`函数本身中，我们使用`requestAnimationFrame`来安排下一次渲染。这样，浏览器将确保`render()`函数在正确的间隔（通常每秒大约60次）被调用。在`requestAnimationFrame`被添加到浏览器之前，使用的是`setInterval(function,
    interval)`或`setTimeout(function, interval)`。这些方法会在设定的时间间隔内调用指定的函数一次。这种方法的缺点是它没有考虑到其他正在发生的事情。即使你的动画没有显示或者是在一个隐藏的标签页中，它仍然会被调用，并且仍然在使用资源。另一个问题是，这些函数在它们被调用时更新屏幕，而不是在浏览器认为最佳的时间，这意味着更高的CPU使用率。使用`requestAnimationFrame`，我们不是告诉浏览器何时更新屏幕；我们请求浏览器在最适合的时候运行提供的函数。通常，这会导致大约60
    fps的帧率。使用`requestAnimationFrame`，你的动画将运行得更平滑，并且对CPU和GPU更友好，你也不必担心自己处理时间问题。
- en: Simple animations
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单动画
- en: 'With this approach, we can very easily animate objects by changing their rotation,
    scale, position, material, vertices, faces, and anything else you can imagine.
    In the next render loop, Three.js will render the changed properties. A very simple
    example, based on the one we already saw in [Chapter 1](ch01.html "Chapter 1. Creating
    Your First 3D Scene with Three.js"), *Creating Your First 3D Scene with Three.js*,
    is available in `01-basic-animation.html`. The following screenshot shows this
    example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以通过改变对象的旋转、缩放、位置、材质、顶点、面以及你能想象到的任何其他属性来非常容易地动画化对象。在下一个渲染循环中，Three.js将渲染这些更改的属性。一个基于我们已经在[第1章](ch01.html
    "第1章 使用Three.js创建您的第一个3D场景")中看到的简单示例，*使用Three.js创建您的第一个3D场景*，可以在`01-basic-animation.html`中找到。以下截图显示了此示例：
- en: '![Simple animations](img/2215OS_09_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![简单动画](img/2215OS_09_01.jpg)'
- en: 'The render loop for this is very simple. Just change the properties of the
    involved meshes, and Three.js handles the rest. Here''s how we do this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个渲染循环非常简单。只需更改涉及的网格的属性，Three.js 就会处理其余部分。以下是我们的操作方法：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nothing spectacular here, but it nicely shows the concept behind the basic animations
    we discuss in this book. In the next section, we'll take a quick sidestep. Besides
    animations, an important aspect, which you'll quickly run into when working with
    Three.js in more complex scenes, is the ability to select objects on screen using
    the mouse.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处，但它很好地展示了我们在本书中讨论的基本动画背后的概念。在下一节中，我们将快速跳转一下。除了动画之外，一个重要的方面，当你使用 Three.js
    在更复杂的场景中工作时，你会很快遇到，就是使用鼠标在屏幕上选择对象的能力。
- en: Selecting objects
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择对象
- en: 'Even though not directly related to animations, since we''ll be looking into
    cameras and animations in this chapter, it is a nice addition to the subjects
    explained in this chapter. What we''ll show here is how you can select an object
    from the scene using the mouse. We''ll first look at the code required for this
    before we look at the example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这与动画没有直接关系，但由于我们将在本章中查看相机和动画，所以它是本章主题的一个很好的补充。我们将展示如何使用鼠标从场景中选择一个对象。在我们查看示例之前，我们首先将查看实现这一功能的代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code, we use `THREE.Projector` together with `THREE.Raycaster` to determine
    whether we''ve clicked on a specific object. What happens when we click on the
    screen is the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用 `THREE.Projector` 和 `THREE.Raycaster` 来确定我们是否点击了特定的对象。当我们在屏幕上点击时，发生的情况如下：
- en: First, `THREE.Vector3` is created based on the position where we've clicked
    on the screen.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，基于我们在屏幕上点击的位置创建 `THREE.Vector3`。
- en: Next, with the `vector.unproject` function, we convert the clicked position
    on screen to coordinates in our Three.js scene. In other words, we unproject from
    screen coordinates to world coordinates.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `vector.unproject` 函数，我们将屏幕上点击的位置转换为我们的 Three.js 场景中的坐标。换句话说，我们从屏幕坐标转换到世界坐标。
- en: Next, we create `THREE.Raycaster`. With `THREE.Raycaster`, we can cast rays
    into our scene. In this case, we emit a ray from the position of the camera (`camera.position`)
    to the position we clicked on in the scene.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建 `THREE.Raycaster`。使用 `THREE.Raycaster`，我们可以将射线投射到场景中。在这种情况下，我们从相机的位置
    (`camera.position`) 发射一个射线到场景中我们点击的位置。
- en: Finally, we use the `raycaster.intersectObjects` function to determine whether
    any of the supplied objects are hit by this ray.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `raycaster.intersectObjects` 函数来确定是否有任何提供的对象被这个射线击中。
- en: 'The result from this final step contains information on any object that is
    hit by this ray. The following information is provided:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步的结果包含有关任何被这个射线击中的对象的信息。以下信息被提供：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The mesh that was clicked on is the object, and `face` and `faceIndex` point
    to the face of the mesh that was selected. The `distance` value is measured from
    the camera to the clicked object, and `point` is the exact position on the mesh
    where it was clicked. You can test this out in the `02-selecting-objects.html`
    example. Any object you click on will become transparent and the details of the
    selection will be printed to the console.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 被点击的网格是对象，而 `face` 和 `faceIndex` 指向被选中的网格的面。`distance` 值是从相机到点击对象的距离，而 `point`
    是点击网格的确切位置。你可以在 `02-selecting-objects.html` 示例中测试这一点。你点击的任何对象都会变得透明，并且选择详情将被打印到控制台。
- en: 'If you want to see the path of the ray that is cast, you can enable the `showRay`
    property from the menu. The following screenshot shows the ray that was used to
    select the blue sphere:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到射出的射线路径，你可以从菜单中启用 `showRay` 属性。以下截图显示了用于选择蓝色球体的射线：
- en: '![Selecting objects](img/2215OS_09_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![选择对象](img/2215OS_09_02.jpg)'
- en: Now that we've finished this small intermission, let's get back to our animations.
    Until now, we've changed the properties in our render loop to animate an object.
    In the next section, we'll look at a small library that makes defining animations
    a lot easier.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个小休息，让我们回到我们的动画上来。到目前为止，我们通过在渲染循环中更改属性来动画化一个对象。在下一节中，我们将查看一个小型库，它使得定义动画变得容易得多。
- en: Animating with Tween.js
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Tween.js 动画
- en: Tween.js is a small JavaScript library that you can download from [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)
    and that you can use to easily define the transition of a property between two
    values. All the intermediate points between the start and end values are calculated
    for you. This process is called **tweening**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Tween.js是一个小的JavaScript库，你可以从[https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)下载，并可以使用它轻松地定义两个值之间属性的过渡。所有起始值和结束值之间的中间点都会为你计算。这个过程被称为**tweening**。
- en: 'For instance, you can use this library to change the *x* position of a mesh
    from 10 to 3 in 10 seconds, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用这个库在10秒内将网格的*x*位置从10改为3，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we've created `TWEEN.Tween`. This tween will make sure that
    the *x* property is changed from 10 to 3 over a period of 10,000 milliseconds.
    Tween.js also allows you to define how this property is changed over time. This
    can be done using linear, quadratic, or any of the other possibilities (see [http://sole.github.io/tween.js/examples/03_graphs.html](http://sole.github.io/tween.js/examples/03_graphs.html)
    for a complete overview). The way the value is changed over time is called **easing**.
    With Tween.js, you configure this using the `easing()` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了`TWEEN.Tween`。这个tween将确保*x*属性在10,000毫秒内从10变为3。Tween.js还允许你定义这个属性随时间如何变化。这可以通过线性、二次或其他任何可能性（参见[http://sole.github.io/tween.js/examples/03_graphs.html](http://sole.github.io/tween.js/examples/03_graphs.html)以获取完整概述）。随时间改变值的方式被称为**easing**。使用Tween.js，你可以通过`easing()`函数来配置这个设置。
- en: 'Using this library from Three.js is very simple. If you open up the `03-animation-tween.html`
    example, you can see the Tween.js library in action. The following screenshot
    shows a still image of the example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个Three.js库非常简单。如果你打开`03-animation-tween.html`示例，你可以看到Tween.js库在行动。以下截图显示了示例的静态图像：
- en: '![Animating with Tween.js](img/2215OS_09_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![使用Tween.js进行动画](img/2215OS_09_03.jpg)'
- en: 'In this example, we''ve taken a particle cloud from [Chapter 7](ch07.html "Chapter 7. Particles,
    Sprites, and the Point Cloud"), *Particles, Sprites, and the Point Cloud*, and
    animated all the particles down to the ground. The position of these particles
    is based on a tween created with the Tween.js library, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从[第7章](ch07.html "第7章。粒子、精灵和点云")，*粒子、精灵和点云*，取了一个粒子云，并动画化了所有粒子到地面。这些粒子的位置是基于使用Tween.js库创建的tween，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this piece of code, we create two tweens: `tween` and `tweenBack`. The
    first one defines how the position property transitions from 1 to 0, and the second
    one does the opposite. With the `chain()` function, we chain these two tweens
    to each other, so these tweens will start looping when started. The final thing
    we define here is the `onUpdate` method. In this method, we walk through all the
    vertices of the particle system and change their position according to the position
    provided by the tween (`this.pos`).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们创建了两个tween：`tween`和`tweenBack`。第一个定义了位置属性如何从1过渡到0，第二个则相反。通过`chain()`函数，我们将这两个tween链接在一起，所以这些tween在启动时将开始循环。在这里我们定义的最后一件事是`onUpdate`方法。在这个方法中，我们遍历粒子系统的所有顶点，并根据tween提供的位置（`this.pos`）改变它们的位置。
- en: 'We start the tween when the model is loaded, so at the end of the following
    function, we call the `tween.start()` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模型加载时开始tween，所以在以下函数的末尾，我们调用`tween.start()`函数：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the tween is started, we need to tell the Tween.js library when we want
    it to update all the tweens it knows about. We do this by calling the `TWEEN.update()`
    function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当tween开始时，我们需要告诉Tween.js库我们希望它在何时更新它所知道的所有tween。我们通过调用`TWEEN.update()`函数来完成这个操作：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With these steps in place, the tween library will take care of positioning the
    various points of the point cloud. As you can see, using this library is much
    easier than having to manage the transitions yourself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤到位后，tween库将负责定位点云的各个点。正如你所看到的，使用这个库比自行管理过渡要容易得多。
- en: Besides animating and changing objects, we can also animate a scene by moving
    the camera around. In the previous chapters, we already did this a couple of times
    by manually updating the position of the camera. Three.js also provides a number
    of additional ways of updating the camera.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了动画化和改变对象，我们还可以通过移动相机来动画化场景。在前几章中，我们已经手动更新相机位置来这样做了几次。Three.js还提供了一些更新相机的方法。
- en: Working with the camera
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与相机一起工作
- en: 'Three.js has a number of camera controls you can use to control the camera
    throughout a scene. These controls are located in the Three.js distribution and
    can be found in the `examples/js/controls` directory. In this section, we''ll
    look in more detail at the following controls:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一些相机控制，您可以使用这些控制来在场景中控制相机。这些控制位于Three.js发行版中，可以在`examples/js/controls`目录中找到。在本节中，我们将更详细地查看以下控制：
- en: '| Name | Description |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Name | 描述 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `FirstPersonControls` | These are controls that behave like those in first-person
    shooters. Move around with the keyboard and look around with the mouse. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `FirstPersonControls` | 这些控制的行为类似于第一人称射击游戏中的控制。使用键盘移动，使用鼠标四处查看。|'
- en: '| `FlyControls` | These are flight simulator-like controls. Move and steer
    with the keyboard and the mouse. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `FlyControls` | 这些是类似飞行模拟器的控制。使用键盘和鼠标移动和转向。|'
- en: '| `RollControls` | This is a simpler version of `FlyControls`. Allows you to
    move around and roll around the *z* axis. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `RollControls` | 这是`FlyControls`的一个简化版本。允许您在*z*轴周围移动和滚动。|'
- en: '| `TrackBallControls` | These are the most used controls, allowing you to use
    the mouse (or the trackball) to easily move, pan, and zoom around the scene. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `TrackBallControls` | 这些是最常用的控制，允许您使用鼠标（或轨迹球）轻松地在场景中移动、平移和缩放。|'
- en: '| `OrbitControls` | This simulates a satellite in orbit around a specific scene.
    This allows you to move around with the mouse and keyboard. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `OrbitControls` | 这模拟了一个围绕特定场景运行的卫星。这允许您使用鼠标和键盘移动。|'
- en: 'These controls are the most useful controls available. Besides these, Three.js
    also provides a number of additional controls you can use (but which aren''t explained
    in this book). Using these controls, however, is done in the same manner as the
    ones explained in the previous table:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制是最有用的控制。除了这些，Three.js还提供了一些额外的控制，您可以使用（但本书中未解释）。然而，使用这些控制的方式与前面表格中解释的方式相同：
- en: '| Name | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| Name | 描述 |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DeviceOrientationControls` | This controls the movement of the camera based
    on the orientation of the device. It internally uses the HTML device orientation
    API ([http://www.w3.org/TR/orientation-event/](http://www.w3.org/TR/orientation-event/)).
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `DeviceOrientationControls` | 这根据设备的方向控制相机的移动。它内部使用HTML设备方向API([http://www.w3.org/TR/orientation-event/](http://www.w3.org/TR/orientation-event/))。|'
- en: '| `EditorControls` | These are controls that are specifically created for online
    3D editors. This is used by the Three.js online editor, which you can find at
    [http://threejs.org/editor/](http://threejs.org/editor/). |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `EditorControls` | 这些是专门为在线3D编辑器创建的控制。这被Three.js在线编辑器使用，您可以在[http://threejs.org/editor/](http://threejs.org/editor/)找到它。|'
- en: '| `OculusControls` | These are controls that allow you to use an Oculus Rift
    device to look around in your scene. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `OculusControls` | 这些控制允许您使用Oculus Rift设备在场景中四处查看。|'
- en: '| `OrthographicTrackballControls` | This is the same control as `TrackBallControls`
    but specifically created to be used with `THREE.OrthographicCamera`. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `OrthographicTrackballControls` | 这与`TrackBallControls`相同，但专门创建用于与`THREE.OrthographicCamera`一起使用。|'
- en: '| `PointerLockControls` | This is a simple control that locks the mouse using
    the DOM element on which the scene is rendered. This provides basic functionality
    for a simple 3D game. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `PointerLockControls` | 这是一个简单的控制，它使用渲染场景的DOM元素锁定鼠标。这为简单的3D游戏提供了基本功能。|'
- en: '| `TransformControls` | This is an internal control used by the Three.js editor.
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `TransformControls` | 这是Three.js编辑器使用的内部控制。|'
- en: '| `VRControls` | This is a control that uses the `PositionSensorVRDevice` API
    to control the scene. More information on this standard can be found at [https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices](https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices).
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `VRControls` | 这是一个使用`PositionSensorVRDevice` API来控制场景的控制。有关此标准的更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices](https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices)。|'
- en: Besides using these camera controls, you can of course also move the camera
    yourself by setting `position` and change where it is pointed to using the `lookAt()`
    function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用这些相机控制外，您当然也可以通过设置`position`来自行移动相机，并使用`lookAt()`函数改变其指向的位置。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you've worked with an older version of Three.js, you might be missing a specific
    camera control named `THREE.PathControls`. With this control, it was possible
    to define a path (for example using `THREE.Spline`) and move the camera along
    that path. In the last version of Three.js, this control was removed because of
    code complexity. The people behind Three.js are currently working on a replacement,
    but one isn't available yet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用过 Three.js 的旧版本，您可能缺少一个名为 `THREE.PathControls` 的特定相机控制。使用这个控制，您可以定义一个路径（例如使用
    `THREE.Spline`）并将相机沿着该路径移动。在 Three.js 的最新版本中，由于代码复杂性，这个控制已被移除。Three.js 背后的团队目前正在开发一个替代品，但目前还没有可用。
- en: The first of the controls we'll look at is `TrackballControls`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个控制是 `TrackballControls`。
- en: TrackballControls
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TrackballControls
- en: 'Before you can use `TrackballControls`, you first need to include the correct
    JavaScript file into your page:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用 `TrackballControls` 之前，您首先需要将正确的 JavaScript 文件包含到您的页面中：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this included, we can create the controls and attach them to the camera,
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 包含这些后，我们可以创建控制并将其附加到相机上，如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Updating the position of the camera is something we do in the render loop,
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更新相机位置是我们渲染循环中执行的操作，如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, we see a new Three.js object, `THREE.Clock`.
    The `THREE.Clock` object can be used to exactly calculate the elapsed time that
    a specific invocation or rendering loop takes to complete. You can do this by
    calling the `clock.getDelta()` function. This function will return the elapsed
    time between this call and the previous call to `getDelta()`. To update the position
    of the camera, we call the `trackballControls.update()` function. In this function,
    we need to provide the time that has passed since the last time this update function
    was called. For this, we use the `getDelta()` function from the `THREE.Clock`
    object. You might wonder why we don't just pass in the frame rate (1/60 seconds)
    to the `update` function. The reason is that with `requestAnimationFrame`, we
    can expect 60 fps, but this isn't guaranteed. Depending on all kinds of external
    factors, the frame rate might change. To make sure the camera turns and rotates
    smoothly, we need to pass in the exact elapsed time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们看到一个新的 Three.js 对象，`THREE.Clock`。`THREE.Clock` 对象可以用来精确计算特定调用或渲染循环完成所需的时间。您可以通过调用
    `clock.getDelta()` 函数来实现这一点。此函数将返回从上次调用 `getDelta()` 到这次调用的经过时间。为了更新相机的位置，我们调用
    `trackballControls.update()` 函数。在这个函数中，我们需要提供自上次调用此更新函数以来经过的时间。为此，我们使用 `THREE.Clock`
    对象的 `getDelta()` 函数。您可能会想知道为什么我们不直接将帧率（1/60秒）传递给 `update` 函数。原因是，使用 `requestAnimationFrame`，我们期望
    60 fps，但这并不保证。根据所有各种外部因素，帧率可能会变化。为了确保相机平稳地旋转和旋转，我们需要传递确切的经过时间。
- en: 'A working example for this can be found in `04-trackball-controls-camera.html`.
    The following screenshot shows a still image of this example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于此的示例可以在 `04-trackball-controls-camera.html` 中找到。以下截图显示了此示例的静态图像：
- en: '![TrackballControls](img/2215OS_09_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![TrackballControls](img/2215OS_09_04.jpg)'
- en: 'You can control the camera in the following manner:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方式控制相机：
- en: '| Control | Action |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 操作 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left mouse button and move | Rotate and roll the camera around the scene
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 左键点击并移动 | 在场景周围旋转和滚动相机 |'
- en: '| Scroll wheel | Zoom in and zoom out |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 滚轮 | 放大和缩小 |'
- en: '| Middle mouse button and move | Zoom in and zoom out |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 中键点击并移动 | 放大和缩小 |'
- en: '| Right mouse button and move | Pan around the scene |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 右键点击并移动 | 在场景周围平移 |'
- en: There are a couple of properties that you can use to fine-tune how the camera
    acts. For instance, you can set how fast the camera rotates with the `rotateSpeed`
    property and disable zooming by setting the `noZoom` property to `true`. In this
    chapter, we won't go into detail on what each property does as they are pretty
    much self-explanatory. For a complete overview of what is possible, look at the
    source of the `TrackballControls.js` file where these properties are listed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一些属性来微调相机的行为。例如，您可以通过 `rotateSpeed` 属性设置相机旋转的速度，并通过将 `noZoom` 属性设置为 `true`
    来禁用缩放。在本章中，我们不会详细介绍每个属性的作用，因为它们基本上是自我解释的。要了解完整的概述，请查看 `TrackballControls.js` 文件源代码，其中列出了这些属性。
- en: FlyControls
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FlyControls
- en: 'The next control we''ll look at is `FlyControls`. With `FlyControls`, you can
    fly around a scene using controls also found in flight simulators. An example
    can be found in `05-fly-controls-camera.html`. The following screenshot shows
    a still image of this example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的下一种控制是`FlyControls`。使用`FlyControls`，你可以使用在飞行模拟器中也能找到的控制来在场景中飞行。一个例子可以在`05-fly-controls-camera.html`中找到。以下截图显示了该示例的静态图像：
- en: '![FlyControls](img/2215OS_09_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![FlyControls](img/2215OS_09_05.jpg)'
- en: 'Enabling `FlyControls` works in the same manner as `TrackballControls.` First,
    load the correct JavaScript file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`FlyControls`与`TrackballControls`的方式相同。首先，加载正确的JavaScript文件：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we configure the controls and attach it to the camera, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们配置控制并将其附加到相机上，如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once again, we won''t look into all the specific properties. Look at the source
    of the `FlyControls.js` file for that. Let''s just pick out the properties you
    need to configure to get this control working. The property that needs to be set
    correctly is the `domElement` property. This property should point to the element
    in which we render the scene. For the examples in this book, we use the following
    element for our output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，我们不会查看所有具体的属性。查看`FlyControls.js`文件的源代码以获取这些属性。我们只需挑选出你需要配置以使此控制工作所需的属性。需要正确设置的属性是`domElement`属性。此属性应指向我们渲染场景的元素。对于本书中的示例，我们使用以下元素作为我们的输出：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We set the property like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样设置属性：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we don't set this property correctly, moving the mouse around will result
    in strange behavior.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有正确设置此属性，鼠标在周围移动会导致奇怪的行为。
- en: 'You can control the camera with `THREE.FlyControls` in the following manner:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下方式用`THREE.FlyControls`控制相机：
- en: '| Control | Action |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 操作 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left and middle mouse button | Start moving forward |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 左键和中间鼠标按钮 | 开始向前移动 |'
- en: '| Right mouse button | Move backwards |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 右键鼠标 | 向后移动 |'
- en: '| Mouse movement | Look around |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 鼠标移动 | 环顾四周 |'
- en: '| W | Start moving forward |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| W | 开始向前移动 |'
- en: '| S | Move backwards |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| S | 向后移动 |'
- en: '| A | Move left |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| A | 向左移动 |'
- en: '| D | Move right |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| D | 向右移动 |'
- en: '| R | Move up |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| R | 向上移动 |'
- en: '| F | Move down |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| F | 向下移动 |'
- en: '| Left, right, up, and down arrows | Look left, right, up, and down |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 左右、上下箭头 | 向左、向右、向上和向下看 |'
- en: '| G | Roll left |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| G | 向左翻滚 |'
- en: '| E | Roll right |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| E | 向右翻滚 |'
- en: The next control we'll look at is `THREE.RollControls`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的下一种控制是`THREE.RollControls`。
- en: RollControls
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RollControls
- en: '`RollControls` behaves much the same as `FlyControls`, so we won''t go into
    detail here. `RollControls` can be created like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`RollControls`的行为与`FlyControls`非常相似，所以我们不会在这里详细介绍。`RollControls`可以创建如下：'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you want to play around with this control, look at the `06-roll-controls-camera.html`
    example. Note that if you only see a black screen, move the mouse to the bottom
    of your browser, and the cityscape will pan into view. This camera can be moved
    around with the following controls:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试这个控制，请查看`06-roll-controls-camera.html`示例。注意，如果你只看到一个黑色屏幕，将鼠标移到浏览器底部，城市景观就会进入视野。这个相机可以用以下控制来移动：
- en: '| Control | Action |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 操作 |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left mouse button | Move forward |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 左键鼠标 | 向前移动 |'
- en: '| Right mouse button | Move backwards |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 右键鼠标 | 向后移动 |'
- en: '| Left, right, up, and down arrows | Move left, right, forward, and backwards
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 左右、上下箭头 | 向左、向右、向前和向后移动 |'
- en: '| W | Move forward |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| W | 向前移动 |'
- en: '| A | Move left |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| A | 向左移动 |'
- en: '| S | Move backwards |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| S | 向后移动 |'
- en: '| D | Move right |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| D | 向右移动 |'
- en: '| Q | Roll left |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| Q | 向左翻滚 |'
- en: '| E | Roll right |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| E | 向右翻滚 |'
- en: '| R | Move up |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| R | 向上移动 |'
- en: '| F | Move down |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| F | 向下移动 |'
- en: The last of the basic controls we'll look at is `FirstPersonControls`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一种基本控制是`FirstPersonControls`。
- en: FirstPersonControls
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FirstPersonControls
- en: 'As the name implies, `FirstPersonControls` allows you to control the camera
    just like in a first-person shooter. The mouse is used to look around and the
    keyboard is used to walk around. You can find an example in `07-first-person-camera.html`.
    The following screenshot shows a still image of this example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`FirstPersonControls`允许你像在第一人称射击游戏中一样控制相机。鼠标用于环顾四周，键盘用于四处走动。你可以在`07-first-person-camera.html`中找到一个示例。以下截图显示了该示例的静态图像：
- en: '![FirstPersonControls](img/2215OS_09_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![FirstPersonControls](img/2215OS_09_06.jpg)'
- en: 'Creating these controls follows the same principles as the ones followed for
    other controls we''ve seen until now. The example we''ve just shown uses the following
    configuration:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些控制遵循的原则与迄今为止我们所看到的其他控制遵循的原则相同。我们刚刚显示的示例使用以下配置：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The only properties that you should carefully look at when using this control
    for yourself are the last two: the `lon` and `lat` properties. These two properties
    define where the camera is pointed at when the scene is rendered for the first
    time.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当您自己使用此控件时，您应该仔细查看的唯一属性是最后两个：`lon` 和 `lat` 属性。这两个属性定义了场景首次渲染时相机指向的位置。
- en: 'The controls for this control are pretty straightforward:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此控件的控件相当直观：
- en: '| Control | Action |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 动作 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Mouse movement | Look around |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 鼠标移动 | 四处张望 |'
- en: '| Left, right, up, and down arrows | Move left, right, forward, and backwards
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 左、右、上、下箭头 | 向左、右、前、后移动 |'
- en: '| W | Move forward |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| W | 向前移动 |'
- en: '| A | Move left |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| A | 向左移动 |'
- en: '| S | Move backwards |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| S | 向后移动 |'
- en: '| D | Move right |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| D | 向右移动 |'
- en: '| R | Move up |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| R | 向上移动 |'
- en: '| F | Move down |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| F | 向下移动 |'
- en: '| Q | Stop all movement |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Q | 停止所有移动 |'
- en: For the next control, we'll move on from this first-person perspective to the
    perspective from space.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个控件，我们将从第一个视角转向空间视角。
- en: OrbitControl
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OrbitControl
- en: 'The `OrbitControl` control is a great way to rotate and pan around an object
    in the center of the scene. With `08-controls-orbit.html`, we''ve included an
    example that shows how this control works. The following screenshot shows a still
    image of this example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrbitControl` 控件是旋转和围绕场景中心对象平移的绝佳方式。在 `08-controls-orbit.html` 中，我们包含了一个示例，展示了该控件的工作原理。以下截图显示了此示例的静态图像：'
- en: '![OrbitControl](img/2215OS_09_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![OrbitControl](img/2215OS_09_07.jpg)'
- en: 'Using `OrbitControl` is just as simple as using the other controls. Include
    the correct JavaScript file, set up the control with the camera, and use `THREE.Clock`
    again to update the control:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `OrbitControl` 与使用其他控件一样简单。包含正确的 JavaScript 文件，使用相机设置控件，然后再次使用 `THREE.Clock`
    更新控件：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The controls for `THREE.OrbitControls` are focused on using the mouse, as shown
    in the following table:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.OrbitControls` 的控件专注于使用鼠标，如下表所示：'
- en: '| Control | Action |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 动作 |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left mouse click + move | Rotate the camera around the center of the scene
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 左键点击 + 移动 | 围绕场景中心旋转相机 |'
- en: '| Scroll wheel or middle mouse click + move | Zoom in and zoom out |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 滚轮或中键点击 + 移动 | 放大和缩小 |'
- en: '| Right mouse click + move | Pan around the scene |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 右键点击 + 移动 | 在场景周围平移 |'
- en: '| Left, right, up, and down arrows | Pan around the scene |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 左、右、上、下箭头 | 在场景周围平移 |'
- en: 'That''s it for the camera and moving it around. In this part, we''ve seen a
    lot of controls that allow you to create interesting camera actions. In the next
    section, we''ll look at a more advanced way of animation: morphing and skinning.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关于相机及其移动就到这里。在本部分，我们看到了许多允许您创建有趣相机动作的控件。在下一节中，我们将探讨动画的更高级方式：变形和蒙皮。
- en: Morphing and skeletal animation
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变形和骨骼动画
- en: 'When you create animations in external programs (for instance, Blender), you
    usually have two main options to define animations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在外部程序中创建动画（例如，Blender）时，您通常有两个主要选项来定义动画：
- en: '**Morph targets**: With morph targets, you define a deformed version, that
    is, a key position, of the mesh. For this deformed target, all vertex positions
    are stored. All you need to do to animate the shape is move all the vertices from
    one position to another key position and repeat that process. The following screenshot
    shows various morph targets used to show facial expressions (the following image
    has been provided by the Blender foundation):![Morphing and skeletal animation](img/2215OS_09_09.jpg)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变形目标**：使用变形目标，您定义一个变形版本，即关键位置，的网格。对于这个变形目标，所有顶点位置都被存储。要动画化形状，您只需将所有顶点从一个位置移动到另一个关键位置，并重复此过程。以下截图显示了用于显示面部表情的各种变形目标（以下图像由
    Blender 基金会提供）：![变形和骨骼动画](img/2215OS_09_09.jpg)'
- en: '**Skeletal animation**: An alternative is using skeletal animation. With skeletal
    animation, you define the skeleton, that is, the bones, of the mesh and attach
    vertices to the specific bones. Now, when you move a bone, any connected bone
    is also moved appropriately, and the attached vertices are moved and deformed
    based on the position, movement, and scaling of the bone. The following screenshot,
    once again provided by the Blender foundation, shows an example of how bones can
    be used to move and deform an object:![Morphing and skeletal animation](img/2215OS_09_10.jpg)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼动画**：另一种选择是使用骨骼动画。使用骨骼动画时，你定义网格的骨骼，即骨头，并将顶点附着到特定的骨头上。现在，当你移动一个骨头时，任何连接的骨头也会相应地移动，并且附着的顶点会根据骨头的位置、运动和缩放进行移动和变形。以下截图，再次由Blender基金会提供，展示了如何使用骨头来移动和变形一个对象的示例：![变形和骨骼动画](img/2215OS_09_10.jpg)'
- en: Three.js supports both modes, but generally you'll probably get better results
    with morph targets. The main problem with skeletal animation is getting a good
    export from a 3D program like Blender that can be animated in Three.js. It's much
    easier to get a good working model with morph targets than it is with bones and
    skins.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js支持这两种模式，但通常你可能会得到更好的结果使用形态目标。骨骼动画的主要问题是获得一个可以从Blender等3D程序中导出并在Three.js中动画化的良好模型。使用形态目标比使用骨头和皮肤更容易获得一个良好的工作模型。
- en: In this section, we'll look at both options and additionally look at a couple
    of external formats supported by Three.js in which animations can be defined.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨这两种选项，并额外探讨Three.js支持的一些外部格式，在这些格式中可以定义动画。
- en: Animation with morph targets
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有形态目标的动画
- en: Morph targets are the most straightforward way of defining an animation. You
    define all the vertices for each important position (also called key frames) and
    tell Three.js to move the vertices from one position to the other. The disadvantage
    of this approach, though, is that for large meshes and large animations, the model
    files will become very large. The reason is that for each key position, all the
    vertex positions are repeated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 形态目标（Morph targets）是定义动画最直接的方法。你为每个重要的位置（也称为关键帧）定义所有顶点，并告诉Three.js将这些顶点从一个位置移动到另一个位置。然而，这种方法的一个缺点是，对于大型网格和大型动画，模型文件会变得非常大。原因是对于每个关键位置，所有的顶点位置都会被重复。
- en: We'll show you how to work with morph targets using two examples. In the first
    example, we'll let Three.js handle the transition between the various key frames
    (or morph targets as we'll call them from now on), and in the second one, we'll
    do this manually.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过两个示例向您展示如何使用形态目标。在第一个示例中，我们将让Three.js处理各种关键帧（或从现在起我们将称之为形态目标）之间的转换，而在第二个示例中，我们将手动进行此操作。
- en: Animation with MorphAnimMesh
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MorphAnimMesh的动画
- en: 'For our first morphing example, we''ll use a model that is also available from
    the Three.js distribution—the horse. The easiest way to understand how a morph-targets-based
    animation works is by opening up the `10-morph-targets.html` example. The following
    screenshot shows a still image of this example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个变形示例，我们将使用一个也来自Three.js分发的模型——马。理解基于形态目标动画工作原理的最简单方法是通过打开`10-morph-targets.html`示例。以下截图显示了该示例的静态图像：
- en: '![Animation with MorphAnimMesh](img/2215OS_09_11.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![带有MorphAnimMesh的动画](img/2215OS_09_11.jpg)'
- en: In this example, the horse on the right-hand side is animated and running, and
    the horse on the left-hand side is standing still. This second horse (the left-hand
    side one) is rendered from the basic model, that is, the original set of vertices.
    With the menu in the top-right corner, you can browse through all the morph targets
    that are available and see the different positions the left-hand side horse can
    take.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，右侧的马正在动画和奔跑，而左侧的马则静止不动。这第二匹马（左侧的马）是从基本模型渲染的，即原始的顶点集合。通过右上角的菜单，你可以浏览所有可用的形态目标，并看到左侧马可以采取的不同位置。
- en: 'Three.js provides a way to move from one position to the next, but this would
    mean we have to manually keep track of the current position we''re in and the
    target we want to morph into, and once we''ve reached the target position, repeat
    this for the other positions. Luckily, Three.js also provides a specific mesh,
    that is, `THREE.MorphAnimMesh`, that takes care of the details for us. Before
    we continue, here''s a quick note on another animation-related mesh provided by
    Three.js called `THREE.MorphBlendMesh`. If you look through the objects provided
    by Three.js, you might notice this object. With this specific mesh, you can do
    pretty much the same things you can do with `THREE.MorphAnimMesh`, and when you
    look at the source code, you can even see that much of it is duplicated between
    these two objects. `THREE.MorphBlendMesh`, however, seems to be deprecated and
    isn''t used in any of the official Three.js examples. Everything you could do
    with `THREE.MorhpBlendMesh` can be done with `THREE.MorphAnimMesh`, so use `THREE.MorphAnimMesh`
    for this kind of functionality. The following piece of code shows you how to load
    the model and create `THREE.MorphAnimMesh` from it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了一种从当前位置移动到下一个位置的方法，但这意味着我们必须手动跟踪当前的位置和我们想要变形到的目标，一旦我们到达目标位置，就为其他位置重复此操作。幸运的是，Three.js
    还提供了一个特定的网格，即 `THREE.MorphAnimMesh`，它会为我们处理这些细节。在我们继续之前，这里有一个关于 Three.js 提供的另一个与动画相关的网格的快速说明，即
    `THREE.MorphBlendMesh`。如果您查看 Three.js 提供的对象，您可能会注意到这个对象。使用这个特定的网格，您可以做很多事情，就像您可以使用
    `THREE.MorphAnimMesh` 一样，并且当您查看源代码时，您甚至可以看到这两个对象之间有很多重复。然而，`THREE.MorphBlendMesh`
    似乎已被弃用，并且没有在官方 Three.js 示例中使用。您可以使用 `THREE.MorphAnimMesh` 做所有 `THREE.MorhpBlendMesh`
    可以做的事情，因此请使用 `THREE.MorphAnimMesh` 来实现此类功能。以下代码片段显示了如何从模型中加载模型并创建 `THREE.MorphAnimMesh`：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the same approach we saw when loading other models. This time, however,
    the external model also contains the morph targets. Instead of creating a normal
    `THREE.Mesh` object, we create `THREE.MorphAnimMesh`. There are a couple of things
    you need to take into account when loading animations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们加载其他模型时看到的方法。然而，这次外部模型还包含形态目标。我们不是创建一个普通的 `THREE.Mesh` 对象，而是创建 `THREE.MorphAnimMesh`。在加载动画时，您需要考虑以下几点：
- en: Make sure the material you use has `THREE.morphTargets` set to `true`. If it's
    not set, your mesh won't animate.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您使用的材质已将 `THREE.morphTargets` 设置为 `true`。如果没有设置，您的网格将不会动画化。
- en: Before creating `THREE.MorphAnimMesh`, make sure to call `computeMorphNormals`
    on the geometry so that all the normal vectors for the morph targets are calculated.
    This is required for correct lighting and shadow effects.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建 `THREE.MorphAnimMesh` 之前，请确保对几何体调用 `computeMorphNormals`，以便计算所有形态目标的所有法向量。这对于正确的光照和阴影效果是必需的。
- en: It's also possible to define colors for faces of a specific morph target. These
    are available from the `morphColors` property. You can use this to morph not just
    the shape of a geometry, but also the colors of the individual faces. With the
    `morphColorsToFaceColors` helper method, we just fix the colors of the faces to
    the first set of colors in the `morphColors` array.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以为特定形态目标的表面定义颜色。这些颜色可以通过 `morphColors` 属性访问。您可以使用它来变形几何体的形状，以及单个面的颜色。使用 `morphColorsToFaceColors`
    辅助方法，我们只需将面的颜色固定在 `morphColors` 数组中的第一组颜色上。
- en: The default setting is to play the complete animation in one go. If there are
    multiple animations defined for the same geometry, you can use the `parseAnimations()`
    function together with `playAnimation(name,fps)` to play one of the defined animations.
    We'll use this approach in the last section of this chapter, where we load animations
    from an MD2 model.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认设置是一次性播放完整动画。如果有多个动画定义了相同的几何体，您可以使用 `parseAnimations()` 函数与 `playAnimation(name,fps)`
    一起使用来播放定义的动画之一。我们将在本章的最后部分使用这种方法，其中我们将从 MD2 模型中加载动画。
- en: 'All that is left to do is update the animation in the render loop. For this,
    we once again use `THREE.Clock` to calculate the delta and use it to update the
    animation, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是在渲染循环中更新动画。为此，我们再次使用 `THREE.Clock` 来计算 delta 并使用它来更新动画，如下所示：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This approach is the easiest and allows you to quickly set up an animation from
    a model that has morph targets defined. An alternative approach is to set up the
    animation manually as we show in the next section.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是最简单的，允许您快速从具有定义形态目标的模型中设置动画。另一种方法是手动设置动画，就像我们在下一节中展示的那样。
- en: Creating an animation by setting the morphTargetInfluence property
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过设置 morphTargetInfluence 属性创建动画
- en: 'We''ll create a very simple example where we morph a cube from one shape to
    another. This time, we''ll manually control which target we will morph to. You
    can find the example in `11-morph-targets-manually.html`. The following screenshot
    shows a still image of this example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常简单的示例，其中我们将一个立方体从一个形状变形到另一个形状。这次，我们将手动控制要变形到的目标。您可以在 `11-morph-targets-manually.html`
    中找到这个示例。以下截图显示了该示例的静态图像：
- en: '![Creating an animation by setting the morphTargetInfluence property](img/2215OS_09_12.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![通过设置 morphTargetInfluence 属性创建动画](img/2215OS_09_12.jpg)'
- en: 'In this example, we''ve manually created two morph targets for a simple cube,
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为简单的立方体手动创建了两个形态目标，如下所示：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you open up this example, you''ll see a simple cube. With the sliders in
    the top-right corner, you can set `morphTargetInfluences`. In other words, you
    can determine how much the initial cube should morph into the cube specified as
    `mt1` and how much it should morph into `mt2`. When you create your morph targets
    by hand, you need to take into account the fact that the morph target has the
    same number of vertices as the source geometry. You can set the influence using
    the `morphTargetInfluences` property of the mesh:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开这个示例时，您会看到一个简单的立方体。通过右上角的滑块，您可以设置 `morphTargetInfluences`。换句话说，您可以确定初始立方体应该变形到指定为
    `mt1` 的立方体的程度，以及它应该变形到 `mt2` 的程度。当您手动创建形态目标时，您需要考虑形态目标具有与源几何体相同数量的顶点这一事实。您可以使用网格的
    `morphTargetInfluences` 属性来设置影响：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the initial geometry can be influenced by multiple morph targets at
    the same time. These two examples show the most important concepts behind morph
    target animations. In the next section, we'll have a quick look at animation using
    bones and skinning.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，初始几何体可以同时受到多个形态目标的影响。这两个示例展示了形态目标动画背后的最重要的概念。在下一节中，我们将快速浏览使用骨骼和蒙皮技术的动画。
- en: Animation using bones and skinning
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用骨骼和蒙皮技术进行动画
- en: 'Morph animations are very straightforward. Three.js knows all the target vertex
    positions and only needs to transition each vertex from one position to the next.
    For bones and skinning, it becomes a bit more complex. When you use bones for
    animation, you move the bone, and Three.js has to determine how to translate the
    attached skin (a set of vertices) accordingly. For this example, we use a model
    that was exported from Blender to the Three.js format (`hand-1.js` in the `models`
    folder). This is a model of a hand, complete with a set of bones. By moving the
    bones around, we can animate the complete model. Let''s first look at how we loaded
    the model:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 形态动画非常直接。Three.js 知道所有的目标顶点位置，只需要将每个顶点从当前位置过渡到下一个位置。对于骨骼和蒙皮，这会变得稍微复杂一些。当您使用骨骼进行动画时，您移动骨骼，Three.js
    必须确定如何相应地转换附着的皮肤（一组顶点）。对于这个例子，我们使用一个从 Blender 导出为 Three.js 格式的模型（`models` 文件夹中的
    `hand-1.js`）。这是一个包含一组骨骼的手的模型。通过移动骨骼，我们可以动画化整个模型。让我们首先看看我们是如何加载模型的：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Loading a model for bone animation isn''t that different from any of the other
    models. We just specify the model file, which contains the definition of vertices,
    faces, and also bones, and based on that geometry, we create a mesh. Three.js
    also provides a specific mesh for skinned geometries like this called `THREE.SkinnedMesh`.
    The one thing you need to specify to make sure the model is updated is set the
    `skinning` property of the material you use to `true`. If you don''t set this
    to `true`, you won''t see any bone movement. The last thing we do here is that
    we set the `useQuaternion` property of all the bones to `false`. In this example,
    we''ll use a `tween` object to handle the animation. This `tween` instance is
    defined like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 加载用于骨骼动画的模型与其他模型没有太大区别。我们只需指定包含顶点、面和骨骼定义的模型文件，然后根据该几何体创建一个网格。Three.js 还为这种蒙皮几何体提供了一个特定的网格，称为
    `THREE.SkinnedMesh`。要确保模型更新，您需要将您使用的材质的 `skinning` 属性设置为 `true`。如果您不将其设置为 `true`，您将看不到任何骨骼运动。我们在这里做的最后一件事是将所有骨骼的
    `useQuaternion` 属性设置为 `false`。在这个例子中，我们将使用一个 `tween` 对象来处理动画。这个 `tween` 实例定义如下：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this tween, we transition the `pos` variable from `-1` to `0`. We've also
    set the `yoyo` property to `true`, which causes our animation to run in reverse
    the next time it is run. To make sure our animation keeps running, we set `repeat`
    to `Infinity`. You can also see that we specify an `onUpdate` method. This method
    is used to position the individual bones, and we'll look at this next.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个缓动效果，我们将`pos`变量从`-1`过渡到`0`。我们还设置了`yoyo`属性为`true`，这会导致动画在下次运行时反向播放。为了确保动画持续运行，我们将`repeat`设置为`Infinity`。您还可以看到我们指定了一个`onUpdate`方法。此方法用于定位单个骨骼，我们将在下一节中探讨这一点。
- en: 'Before we move the bones, let''s look at the `12-bones-manually.html` example.
    The following screenshot shows a still image of this example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们移动骨骼之前，让我们看看`12-bones-manually.html`的示例。下面的截图显示了该示例的静态图像：
- en: '![Animation using bones and skinning](img/2215OS_09_13.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![使用骨骼和蒙皮动画](img/2215OS_09_13.jpg)'
- en: 'When you open this example, you see the hand making a grab-like motion. We
    did this by setting the *z* rotation of the finger bones in the `onUpdate` method
    that is called from our tween animation, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开此示例时，您会看到手部做出抓取动作。我们通过在从我们的缓动动画中调用的`onUpdate`方法中设置手指骨骼的*z*旋转来实现这一点，如下所示：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Whenever this update method is called, the relevant bones are set to the `pos`
    position. To determine which bone you need to move, it is a good idea to print
    out the `mesh.skeleton` property to the console. This will list all the bones
    and their names.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用此更新方法时，相关的骨骼都会设置为`pos`位置。为了确定您需要移动哪个骨骼，将`mesh.skeleton`属性打印到控制台是一个好主意。这将列出所有骨骼及其名称。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Three.js provides a simple helper you can use to show the bones of the models.
    Add the following to the code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一个简单的辅助工具，您可以使用它来显示模型的骨骼。将以下内容添加到代码中：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The bones are highlighted. You can see an example of this by enabling the `showHelper`
    property shown in the `12-bones-manually.html` example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼被突出显示。您可以通过启用`12-bones-manually.html`示例中显示的`showHelper`属性来查看此示例。
- en: As you can see, working with bones takes a bit more effort but is much more
    flexible than the fixed morph targets. In this example, we've only moved the rotation
    of the bones; you can also move the position or change the scale. In the next
    section, we look at loading animations from external models. In that section,
    we'll revisit this example, but now, we'll run a predefined animation from the
    model instead of manually moving the bones around.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用骨骼需要更多的工作，但比固定的形态目标更加灵活。在此示例中，我们只移动了骨骼的旋转；您也可以移动位置或更改缩放。在下一节中，我们将查看从外部模型加载动画。在那个部分，我们将重新审视此示例，但现在，我们将运行模型中的预定义动画，而不是手动移动骨骼。
- en: Creating animations using external models
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部模型创建动画
- en: 'In [Chapter 8](ch08.html "Chapter 8. Creating and Loading Advanced Meshes and
    Geometries"), *Creating and Loading Advanced Meshes and Geometries*, we looked
    at a number of 3D formats that are supported by Three.js. A couple of those formats
    also support animations. In this chapter, we''ll look at the following examples:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。创建和加载高级网格和几何体")中，*创建和加载高级网格和几何体*，我们探讨了Three.js支持的一些3D格式。其中一些格式也支持动画。在本章中，我们将查看以下示例：
- en: '**Blender with the JSON exporter**: We''ll start with an animation created
    in Blender and exported to the Three.js JSON format.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blender与JSON导出器**：我们将从一个在Blender中创建并导出为Three.js JSON格式的动画开始。'
- en: '**Collada model**: The Collada format has support for animations. For this
    example, we''ll load an animation from a Collada file and render it with Three.js.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collada模型**：Collada格式支持动画。对于此示例，我们将从Collada文件中加载一个动画，并使用Three.js进行渲染。'
- en: '**MD2 model**: The MD2 model is a simple format used in the older Quake engines.
    Even though the format is a bit dated, it is still a very good format for storing
    character animations.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MD2模型**：MD2模型是一种在较老的Quake引擎中使用的简单格式。尽管格式有些过时，但它仍然是一个用于存储角色动画的非常好的格式。'
- en: We'll start with the Blender model.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Blender模型开始。
- en: Creating a bones animation using Blender
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Blender创建骨骼动画
- en: 'To get started with animations from Blender, you can load the example we''ve
    included in the models folder. You can find the `hand.blend` file there, which
    you can load into Blender. The following screenshot shows a still image of this
    example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Blender开始动画制作，您可以加载我们包含在模型文件夹中的示例。您可以在那里找到`hand.blend`文件，并将其加载到Blender中。下面的截图显示了该示例的静态图像：
- en: '![Creating a bones animation using Blender](img/2215OS_09_14.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![使用Blender创建骨骼动画](img/2215OS_09_14.jpg)'
- en: 'There isn''t room in this book to go into much detail on how to create animations
    in Blender, but there are a couple of things you need to keep in mind:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本书没有足够的空间详细介绍如何在 Blender 中创建动画，但有一些事情你需要记住：
- en: Every vertex from your model must at least be assigned to a vertex group.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的模型中的每个顶点至少必须分配到一个顶点组。
- en: The name of the vertex groups you use in Blender must correspond to the name
    of the bone that controls it. That way, Three.js can determine which vertices
    it needs to modify when moving the bones.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在 Blender 中使用的顶点组的名称必须与控制它的骨骼名称相匹配。这样，Three.js 就可以确定在移动骨骼时需要修改哪些顶点。
- en: Only the first "action" is exported. So make sure the animation you want to
    export is the first one.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只导出第一个“动作”。所以请确保你想要导出的动画是第一个。
- en: When creating key frames, it is a good idea to select all the bones even if
    they don't change.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建关键帧时，即使它们没有变化，选择所有骨骼也是一个好主意。
- en: When exporting the model, make sure the model is in its rest pose. If this is
    not the case, you'll see a very deformed animation.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导出模型时，确保模型处于其原始姿势。如果不是这样，你会看到一个非常变形的动画。
- en: 'For more information on creating and exporting animations from Blender and
    the reasons for the aforementioned pointers, you can look at the following great
    resource: [http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/](http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在 Blender 中创建和导出动画以及上述提示的原因的更多信息，你可以查看以下优秀的资源：[http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/](http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/)。
- en: 'When you''ve created the animation in Blender, you can export the file using
    the Three.js exporter we used in the previous chapter. When exporting the file
    using the Three.js exporter, you have to make sure that the following properties
    are checked:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Blender 中创建动画后，可以使用我们在上一章中使用过的 Three.js 导出器来导出文件。在导出文件时使用 Three.js 导出器，你必须确保以下属性被勾选：
- en: '![Creating a bones animation using Blender](img/2215OS_09_15.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Blender 创建骨骼动画](img/2215OS_09_15.jpg)'
- en: This will export the animation you've specified in Blender as a skeletal animation
    instead of a morph animation. With a skeletal animation, the movements of the
    bones are exported, which we can replay in Three.js.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把你在 Blender 中指定的动画导出为骨骼动画而不是形变动画。在骨骼动画中，骨骼的运动被导出，我们可以在 Three.js 中回放。
- en: 'Loading the model in Three.js is the same as we did for our previous example;
    however, now that the model is loaded, we will also create an animation, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中加载模型与我们的上一个示例相同；然而，现在模型已加载，我们还将创建一个动画，如下所示：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To run this animation, all we have to do is create a `THREE.Animation` instance
    and call the `play` method on this animation. Before we see the animation, we
    still need to take one additional step. In our render loop, we call the `THREE.AnimationHandler.update(clock.getDelta())`
    function to update the animation, and Three.js will use the bones to set the model
    in the correct position. The result of this example (`13-animation-from-blender.html`)
    is a simple waving hand.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此动画，我们只需创建一个 `THREE.Animation` 实例，并在此动画上调用 `play` 方法。在我们看到动画之前，我们还需要采取一个额外的步骤。在我们的渲染循环中，我们调用
    `THREE.AnimationHandler.update(clock.getDelta())` 函数来更新动画，Three.js 将使用骨骼将模型设置在正确的位置。此示例的结果（`13-animation-from-blender.html`）是一个简单的挥手动作。
- en: 'The following screenshot shows a still image of this example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的静态图像：
- en: '![Creating a bones animation using Blender](img/2215OS_09_16.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Blender 创建骨骼动画](img/2215OS_09_16.jpg)'
- en: Besides Three.js' own format, we can use a couple of other formats to define
    animations. The first one we'll look at is loading a Collada model.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Three.js 自身的格式外，我们还可以使用几种其他格式来定义动画。我们将首先查看的是加载 Collada 模型。
- en: Loading an animation from a Collada model
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Collada 模型加载动画
- en: 'Loading a model from a Collada file works in the same manner as for the other
    formats. First, you have to include the correct loader JavaScript file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Collada 文件加载模型的方式与其他格式相同。首先，你必须包含正确的加载器 JavaScript 文件：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we create a loader and use it to load the model file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个加载器，并使用它来加载模型文件：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A Collada file can contain much more than just a single mode; it can store
    complete scenes, including cameras, lights, animations, and more. A good way to
    work with a Collada model is to print out the result from the `loader.load` function
    to the console and determine which components you want to use. In this case, there
    was a single `THREE.SkinnedMesh` in the scene (`child`). To render and animate
    this model, all we have to do is set up the animation just like we did for the
    Blender-based model; even the render loop stays the same. Here''s how we render
    and animate the model:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Collada文件可以包含比单个模式多得多的内容；它可以存储完整的场景，包括摄像机、灯光、动画等。与Collada模型一起工作的好方法是打印出`loader.load`函数的结果到控制台，并确定您想要使用哪些组件。在这种情况下，场景中有一个单独的`THREE.SkinnedMesh`（子节点）。要渲染和动画化这个模型，我们只需像处理基于Blender的模型一样设置动画；甚至渲染循环也保持不变。以下是渲染和动画化模型的步骤：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the result for this specific Collada file looks like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的Collada文件，结果如下所示：
- en: '![Loading an animation from a Collada model](img/2215OS_09_17.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![从Collada模型加载动画](img/2215OS_09_17.jpg)'
- en: Another example of an external model, one that uses morph targets, is the MD2
    file format.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用形态目标的外部模型示例是MD2文件格式。
- en: Animation loaded from a Quake model
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Quake模型加载的动画
- en: 'The MD2 format was created to model characters from Quake, a great game from
    1996\. Even though the newer engines use a different format, you can still find
    a lot of interesting models in the MD2 format. To use files in this format, we
    first have to convert them to the Three.js JavaScript format. You can do this
    online using the following site:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: MD2格式是为了模拟1996年伟大的游戏《Quake》中的角色而创建的。尽管较新的引擎使用不同的格式，但您仍然可以在MD2格式中找到许多有趣的模型。要使用这种格式的文件，我们首先必须将它们转换为Three.js
    JavaScript格式。您可以使用以下网站在线完成此操作：
- en: '[http://oos.moxiecode.com/js_webgl/md2_converter/](http://oos.moxiecode.com/js_webgl/md2_converter/)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://oos.moxiecode.com/js_webgl/md2_converter/](http://oos.moxiecode.com/js_webgl/md2_converter/)'
- en: 'After conversion, you''ll get a JavaScript file in the Three.js format that
    you can load and render using `MorphAnimMesh`. Since we''ve already seen how to
    do this in the previous sections, we''ll skip the code where the model is loaded.
    One interesting thing though is happening in the code. Instead of playing the
    complete animation, we provide the name of the animation that needs to be played:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后，您将得到一个Three.js格式的JavaScript文件，您可以使用`MorphAnimMesh`加载和渲染它。由于我们已经在前面的部分中看到了如何做到这一点，我们将跳过加载模型的代码。不过，代码中有一个有趣的现象。我们不是播放完整的动画，而是提供需要播放的动画名称：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The reason is that an MD2 file usually contains a number of different character
    animations. Luckily, though, Three.js provides functionality to determine the
    available animations and play them using the `playAnimation` function. The first
    thing we need to do is tell Three.js to parse the animations:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是MD2文件通常包含多个不同的角色动画。幸运的是，Three.js提供了使用`playAnimation`函数确定可用动画并播放它们的功能。我们首先需要做的是告诉Three.js解析动画：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This results in a list of names for the animations that can be played using
    the `playAnimation` function. In our example, you can select the name of the animation
    from the menu in the top-right corner. The available animations are determined
    like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个可以使用`playAnimation`函数播放的动画名称列表。在我们的示例中，您可以从右上角的菜单中选择动画名称。可用的动画是这样确定的：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Whenever an animation from the menu is selected, the `mesh.playAnimation` function
    is called with the specified animation name. The example that demonstrates this
    can be found in `15-animation-from-md2.html`. The following screenshot shows us
    a still image of this example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每当从菜单中选择一个动画时，都会调用`mesh.playAnimation`函数，并传入指定的动画名称。演示这个功能的示例可以在`15-animation-from-md2.html`中找到。以下截图展示了这个示例的静态图像：
- en: '![Animation loaded from a Quake model](img/2215OS_09_18.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![从Quake模型加载的动画](img/2215OS_09_18.jpg)'
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at different ways that you can animate your scene.
    We started with some basic animation tricks, moved on to camera movement and control,
    and ended with animation models using morph targets and skeleton/bones animations.
    When you have the render loop in place, adding animations is very easy. Just change
    a property of the mesh, and in the next rendering step, Three.js will render the
    updated mesh.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了你可以用来动画化你的场景的不同方法。我们从一些基本的动画技巧开始，接着转向相机运动和控制，最后讨论了使用变形目标和解剖/骨骼动画的动画模型。当你设置了渲染循环后，添加动画变得非常简单。只需更改网格的一个属性，在下一个渲染步骤中，Three.js就会渲染更新后的网格。
- en: In previous chapters, we looked at the various materials you can use to skin
    your objects. For instance, we saw how you can change the color, shininess, and
    opacity of these materials. What we haven't discussed in detail yet, however,
    is how you can use external images (also called textures) together with these
    materials. With textures, you can easily create objects that look like they are
    made of wood, metal, stone, and much more. In the next chapter, we'll explore
    all the different aspects of textures and how they are used in Three.js.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了你可以用来为你的对象添加外观的各种材料。例如，我们看到了如何改变这些材料的颜色、光泽度和透明度。然而，我们尚未详细讨论如何将这些外部图像（也称为纹理）与这些材料结合使用。有了纹理，你可以轻松地创建出由木材、金属、石头等材料制成的对象。在下一章中，我们将探讨纹理的所有不同方面以及它们在Three.js中的使用方法。
