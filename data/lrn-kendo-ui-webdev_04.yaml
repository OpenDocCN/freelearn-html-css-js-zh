- en: Chapter 4. The Kendo MVVM Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 Kendo MVVM框架
- en: JavaScript development has come a long way since its inception and the appearance
    of rich MVVM frameworks is wonderful evidence of that evolution. These allow the
    developer to separate responsibilities within the code to better handle complexity.
    They also provide a beautifully simple syntax so that the MVVM framework itself
    is left to handle the tedious work of binding dynamic data into your web pages.
    If you have never used a JavaScript MVVM framework before, you are in for a treat
    with the Kendo MVVM framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从JavaScript的诞生以及丰富MVVM框架的出现以来，JavaScript开发已经走了很长的路，这无疑是这一演变的美好证明。这些框架允许开发者将代码中的责任分离，以更好地处理复杂性。它们还提供了一个简洁的语法，使得MVVM框架本身可以处理将动态数据绑定到网页上的繁琐工作。如果你之前从未使用过JavaScript
    MVVM框架，那么Kendo MVVM框架将为你带来一场盛宴。
- en: Understanding MVVM – basics
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解MVVM - 基础
- en: MVVM stands for **Model** (**M**), **View** (**V**), and **View-Model** (**VM**).
    It is part of a family of design patterns related to system architecture that
    separate responsibilities into distinct units. Some other related patterns are
    **Model-View-Controller** (**MVC**) and **Model-View-Presenter** (**MVP**). These
    differ on what each portion of the framework is responsible for, but they all
    attempt to manage complexity through the same underlying design principles. Without
    going into unnecessary details here, suffice it to say that these patterns are
    good for developing reliable and reusable code and they are something that you
    will undoubtedly benefit from if you have implemented them properly. Fortunately,
    the good JavaScript MVVM frameworks make it easy by wiring up the components for
    you and letting you focus on the code instead of the "plumbing".
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM代表**模型**（**M**）、**视图**（**V**）和**视图模型**（**VM**）。它是与系统架构相关的设计模式家族的一部分，将责任分离到不同的单元中。一些其他相关的模式是**模型-视图-控制器**（**MVC**）和**模型-视图-表示器**（**MVP**）。它们在框架的每个部分负责的内容上有所不同，但它们都试图通过相同的设计原则来管理复杂性。在这里不深入不必要的细节，只需说这些模式对于开发可靠和可重用的代码是好的，如果你正确实现了它们，你无疑会从中受益。幸运的是，好的JavaScript
    MVVM框架通过为你连接组件，让你专注于代码而不是“管道”工作，使得这变得容易。
- en: In the MVVM pattern for JavaScript through Kendo UI, you will need to create
    a definition for the data that you want to display and manipulate (the Model),
    the HTML markup that structures your overall web page (the View), and the JavaScript
    code that handles user input, reacts to events, and transforms the static markup
    into dynamic elements (the View-Model). Another way to put it is that you will
    have data (Model), presentation (View), and logic (View-Model).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kendo UI的JavaScript MVVM模式中，你需要为想要显示和操作的数据（模型）、结构化整个网页的HTML标记（视图）以及处理用户输入、响应事件并将静态标记转换为动态元素的JavaScript代码（视图模型）创建定义。另一种说法是，你将拥有数据（模型）、展示（视图）和逻辑（视图模型）。
- en: In practice, the Model is the most loosely-defined portion of the MVVM pattern
    and is not always even present as a unique entity in the implementation. The View-Model
    can assume the role of both Model and View-Model by directly containing the Model
    data properties within itself, instead of referencing them as a separate unit.
    This is acceptable and is also seen within ASP.NET MVC when a View uses the `ViewBag`
    or the `ViewData` collections instead of referencing a strongly-typed Model class.
    Don't let it bother you if the Model isn't as well defined as the View-Model and
    the View. The implementation of any pattern should be filtered down to what actually
    makes sense for your application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，模型是MVVM模式中最不明确的部分，甚至不一定在实现中作为一个独特的实体存在。视图模型可以直接在其内部包含模型数据属性，而不是作为单独的单元引用它们，从而承担模型和视图模型的双重角色。这是可以接受的，并且在ASP.NET
    MVC中也可以看到，当视图使用`ViewBag`或`ViewData`集合而不是引用强类型模型类时。如果模型没有像视图模型和视图那样定义得很好，请不要让它困扰你。任何模式的实现都应过滤到对您的应用程序真正有意义的内容。
- en: Simple data binding
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的数据绑定
- en: As an introductory example, consider that you have a web page that needs to
    display a table of data, and also provide the users with the ability to interact
    with that data, by clicking specifically on a single row or element. The data
    is dynamic, so you do not know beforehand how many records will be displayed.
    Also, any change should be reflected immediately on the page instead of waiting
    for a full page refresh from the server. How do you make this happen?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为入门示例，考虑您有一个需要显示数据表的网页，并且还提供用户通过单击特定的单行或元素与该数据交互的能力。数据是动态的，因此您事先不知道将显示多少条记录。此外，任何更改都应该立即反映在页面上，而不是等待从服务器完全刷新整个页面。您如何实现这一点？
- en: A traditional approach would involve using special server-side controls that
    can dynamically create tables from a data source and can even wire-up some JavaScript
    interactivity. The problem with this approach is that it usually requires some
    complicated extra communication between the server and the web browser either
    through "view state", hidden fields, or long and ugly query strings. Also, the
    output from these special controls is rarely easy to customize or manipulate in
    significant ways and reduces the options for how your site should look and behave.
    Another choice would be to create special JavaScript functions to asynchronously
    retrieve data from an endpoint, generate HTML markup within a table and then wire
    up events for buttons and links. This is a good solution, but requires a lot of
    coding and complexity which means that it will likely take longer to debug and
    refine. It may also be beyond the skill set of a given developer without significant
    research. The third option, available through a JavaScript MVVM like Kendo UI,
    strikes a balance between these two positions by reducing the complexity of the
    JavaScript but still providing powerful and simple data binding features inside
    of the page.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一种传统的方法是使用可以动态从数据源创建表格并能够连接一些JavaScript交互性的特殊服务器端控件。这种方法的问题通常是需要服务器和浏览器之间进行一些复杂的额外通信，无论是通过“视图状态”，隐藏字段，还是长而丑陋的查询字符串。此外，这些特殊控件生成的输出通常很难进行定制或以重要方式进行操作，这减少了您网站外观和行为的选择。另一个选择是创建特殊的JavaScript函数，以异步从端点检索数据，在表格内生成HTML标记，然后为按钮和链接连接事件。这是一个好的解决方案，但需要大量的编码和复杂性，这意味着调试和精炼可能需要更长的时间。这也可能超出了某些开发者没有重大研究的能力范围。第三个选项，通过JavaScript
    MVVM如Kendo UI提供，在这两种位置之间取得平衡，通过减少JavaScript的复杂性，但仍然在页面内提供强大且简单的数据绑定功能。
- en: Creating the view
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'Here is a simple HTML page to show how a view basically works:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的HTML页面，展示视图是如何基本工作的：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we have a simple `table` element with three columns but instead of the
    `body` containing any `tr` elements, there are some special HTML5 `data-*` attributes
    indicating that something special is going on here. These `data-*` attributes
    do nothing by themselves, but Kendo UI reads them (as you will see below) and
    interprets their values in order to link the View with the View-Model. The `data-bind`
    attribute indicates to Kendo UI that this element should be bound to a collection
    of objects called `people` .
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的`table`元素，包含三个列，但不是`body`包含任何`tr`元素，而是有一些特殊的HTML5 `data-*`属性，表明这里正在进行一些特殊操作。这些`data-*`属性本身并不做任何事情，但Kendo
    UI会读取它们（如下所示），并解释它们的值，以便将视图与视图模型链接起来。`data-bind`属性指示Kendo UI，这个元素应该绑定到一个名为`people`的对象集合。
- en: 'The `data-template` attribute tells Kendo UI that the `people` objects should
    be formatted using a Kendo UI template. Here is the code for the template:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-template`属性告诉Kendo UI，应该使用Kendo UI模板格式化`people`对象。以下是模板的代码：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a simple template that defines a `tr` structure for each row within
    the table. The `td` elements also have a `data-bind` attribute on them so that
    Kendo UI knows to insert the value of a certain property as the "text" of the
    HTML element, which in this case means placing the value in between `<td>` and
    `</td>` as simple text on the page.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的模板，为表格中的每一行定义了一个`tr`结构。`td`元素上也有`data-bind`属性，这样Kendo UI就知道要插入某个属性的值作为HTML元素的“文本”，在这种情况下意味着将值放置在`<td>`和`</td>`之间作为页面上简单的文本。
- en: Creating the Model and View-Model
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模型和视图模型
- en: 'In order to wire this up, we need a View-Model that performs the data binding.
    Here is the View-Model code for this View:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立这个连接，我们需要一个执行数据绑定的视图模型。以下是这个视图的视图模型代码：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A Kendo UI View-Model is declared through a call to `kendo.observable()` which
    creates an **observable object** that is then used for the data-binding within
    the View. An observable object is a special object that wraps a normal JavaScript
    variable with events that fire any time the value of that variable changes. These
    events notify the MVVM framework to update any data bindings that are using that
    variable's value, so that they can update immediately and reflect the change.
    These data bindings also work both ways so that if a field bound to an observable
    object variable is changed, the variable bound to that field is also changed in
    real time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `kendo.observable()` 来声明一个 Kendo UI 视图模型，这会创建一个 **可观察对象**，该对象用于视图中的数据绑定。可观察对象是一个特殊对象，它将一个普通的
    JavaScript 变量包装起来，并在该变量的值发生变化时触发事件。这些事件会通知 MVVM 框架更新任何使用该变量值的绑定数据，以便它们可以立即更新并反映变化。这些数据绑定也是双向的，因此如果绑定到可观察对象变量的字段发生变化，绑定到该字段的变量也会实时更改。
- en: In this case, I created an array called `people` that contains three objects
    with properties about some people. This array, then, operates as the Model in
    this example since it contains the data and the definition of how the data is
    structured. At the end of this code sample, you can see the call to `kendo.bind($("body"),
    viewModel)` which is how Kendo UI actually performs its MVVM wiring. I passed
    a jQuery selector for the `body` tag to the first parameter since this `viewModel`
    object applies to the full body of my HTML page, not just a portion of it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我创建了一个名为 `people` 的数组，其中包含三个具有关于一些人的属性的对象。这个数组在这个例子中充当模型，因为它包含了数据和数据的结构定义。在代码示例的末尾，你可以看到调用
    `kendo.bind($("body"), viewModel)`，这是 Kendo UI 实际执行 MVVM 连接的方式。我传递了一个 jQuery 选择器作为
    `body` 标签的第一个参数，因为这个 `viewModel` 对象适用于我的整个 HTML 页面，而不仅仅是其中的一部分。
- en: 'With everything combined, here is the full source for this simplified example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容组合起来，以下是这个简化示例的完整源代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is a screenshot of the page in action. Note how the data from the JavaScript
    `people` array is populated into the table automatically:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是页面动作的截图。注意 JavaScript `people` 数组中的数据是如何自动填充到表格中的：
- en: '![Creating the Model and View-Model](img/4346OT_04_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建模型和视图模型](img/4346OT_04_01.jpg)'
- en: Even though this example contains a Model, a View, and a View-Model, all three
    units appear in the same HTML file. You could separate the JavaScript into other
    files, of course, but it is also acceptable to keep them together like this. Hopefully
    you are already seeing what sort of things this MVVM framework can do for you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子包含模型、视图和视图模型，但所有三个单元都出现在同一个 HTML 文件中。当然，您可以将 JavaScript 分离到其他文件中，但将它们像这样放在一起也是可以接受的。希望您已经看到了这个
    MVVM 框架能为您做什么。
- en: Observable data binding
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察数据绑定
- en: Binding data into your HTML web page (View) using declarative attributes is
    great, and very useful, but the MVVM framework offers some much more significant
    functionality that we didn't see in the last example. Instead of simply attaching
    data to the View and leaving it at that, the MVVM framework maintains a running
    copy of all of the View-Model's properties, and keeps references to those properties
    up to date in real time. This is why the View-Model is created with a function
    called "observable". The properties inside, being observable, report changes back
    up the chain so that the data-bound fields always reflect the latest data. Let's
    see some examples.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明性属性将数据绑定到您的 HTML 网页（视图）中是非常好且非常有用的，但 MVVM 框架还提供了一些更重要的功能，我们在上一个示例中没有看到。MVVM
    框架不仅将数据附加到视图并保持不变，而且还维护了视图模型所有属性的运行副本，并实时更新这些属性的引用。这就是为什么视图模型是用名为 "observable"
    的函数创建的原因。内部属性是可观察的，它们会向上报告变化，以便数据绑定的字段始终反映最新的数据。让我们看看一些示例。
- en: Adding data dynamically
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态添加数据
- en: 'Building on the example we just saw, add this horizontal rule and form just
    below the table in the HTML page:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚看到的示例的基础上，在 HTML 页面中的表格下方添加这条水平线和表单：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This adds a form to the page so that a user can enter data for a new person
    that should appear in the table. Note that we have added some `data-bind` attributes,
    but this time we are binding the `value` of the input fields not the `text`. Note
    also that we have added a `data-bind` attribute to the `button` at the bottom
    of the form that binds the `click` event of that `button` with a function inside
    our View-Model. By binding the `click` event to the `addPerson` JavaScript method,
    the `addPerson` method will be fired every time this button is clicked.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这在页面上添加了一个表单，以便用户可以输入应出现在表格中的新人员数据。注意，我们添加了一些`data-bind`属性，但这次我们绑定的是输入字段的`value`而不是`text`。还要注意，我们在表单底部的`button`上添加了一个`data-bind`属性，将那个`button`的`click`事件与视图模型内部的函数绑定。通过将`click`事件绑定到`addPerson`JavaScript方法，每次点击这个按钮时，`addPerson`方法都会被触发。
- en: These bindings keep the value of those input fields linked with the View-Model
    object at all times. If the value in one of these input fields changes, such as
    when a user types something in the box, the View-Model object will immediately
    see that change and update its properties to match; it will also update any areas
    of the page that are bound to the value of that property so that they match the
    new data as well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定始终将那些输入字段的值与视图模型对象链接起来。如果其中一个输入字段的值发生变化，例如当用户在框中输入某些内容时，视图模型对象会立即看到这个变化，并更新其属性以匹配；它还会更新任何绑定到该属性值的页面区域，以便它们与新的数据匹配。
- en: The binding for the button is special because it allows the View-Model object
    to attach its own event handler to the click event for this element. Binding an
    event handler to an event is nothing special by itself, but it is important to
    do it this way (through the `data-bind` attribute) so that the specific running
    View-Model instance inside of the page has attached one of its functions to this
    event so that the code inside the event handler has access to this specific View-Model's
    data properties and values. It also allows for a very specific context to be passed
    to the event that would be very hard to access otherwise.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的绑定是特殊的，因为它允许视图模型对象将自身的事件处理器附加到该元素的点击事件上。将事件处理器绑定到事件本身并不是什么特别的事情，但通过这种方式（通过`data-bind`属性）进行绑定是很重要的，这样页面内的特定运行视图模型实例就能将其中的一个函数附加到该事件上，使得事件处理器内部的代码能够访问这个特定视图模型的数据属性和值。这还允许将一个非常具体的上下文传递给事件，否则将很难访问。
- en: 'Here is the code I added to the View-Model just below the `people` array. The
    first three properties that we have in this example are what make up the Model.
    They contain that data that is observed and bound to the rest of the page:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我在视图模型中添加到`people`数组下面的代码。在这个例子中，我们拥有的前三个属性构成了模型。它们包含被观察并绑定到页面其余部分的数据：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first several properties you see are the same properties that we are binding
    to in the input form above. They start with an empty value because the form should
    not have any values when the page is first loaded. It is still important to declare
    these empty properties inside the View-Model in order that their value can be
    tracked when it changes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的第一个几个属性是我们上面在输入表单中绑定的相同属性。它们以空值开始，因为当页面首次加载时，表单不应该有任何值。在视图模型内部声明这些空属性仍然很重要，以便在它们发生变化时跟踪它们的值。
- en: The function after the data properties, `addPerson` , is what we have bound
    to the click event of the button in the input form. Here in this function we are
    accessing the `people` array and adding a new record to it based on what the user
    has supplied in the form fields. Notice that we have to use the `this.get()` and
    `this.set()` functions to access the data inside of our View-Model. This is important
    because the properties in this View-Model are special observable properties so
    accessing their values directly may not give you the results you would expect.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 数据属性之后的函数`addPerson`是我们绑定到输入表单按钮点击事件的函数。在这个函数中，我们正在访问`people`数组，并根据用户在表单字段中提供的信息向其中添加一条新记录。请注意，我们必须使用`this.get()`和`this.set()`函数来访问视图模型内部的数据。这很重要，因为在这个视图模型中的属性是特殊的可观察属性，直接访问它们的值可能不会得到你预期的结果。
- en: The most significant thing that you should notice about the `addPerson` function
    is that it is interacting with the data on the page through the View-Model properties.
    It is not using jQuery, `document.querySelector`, or any other DOM interaction
    to read the value of the elements! Since we declared a `data-bind` attribute on
    the values of the input elements to the properties of our View-Model, we can always
    get the value from those elements by accessing the View-Model itself. The values
    are tracked at all times. This allows us to both retrieve and then change those
    View-Model properties inside the `addPerson` function and the HTML page will show
    the changes right as it happens. By calling `this.set()` on the properties and
    changing their values to an empty string, the HTML page will clear the values
    that the user just typed and added to the table. Once again, we change the View-Model
    properties without needing access to the HTML ourselves.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到的最重要的事情是`addPerson`函数与页面上的数据通过View-Model属性进行交互。它没有使用jQuery、`document.querySelector`或任何其他DOM交互来读取元素的值！由于我们在输入元素的值上声明了`data-bind`属性到我们的View-Model属性，我们可以通过访问View-Model本身始终从这些元素中获取值。这些值始终被跟踪。这允许我们在`addPerson`函数和HTML页面中检索并更改这些View-Model属性，HTML页面将立即显示这些更改。通过在属性上调用`this.set()`并将它们的值更改为空字符串，HTML页面将清除用户刚刚输入并添加到表格中的值。再一次，我们更改View-Model属性而不需要我们自己访问HTML。
- en: 'Here is the complete source of this example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个示例的完整源代码：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here is a screenshot of the page in action. You will see that one additional
    person has been added to the table by filling out the form. Try it out yourself
    to see the immediate interaction that you get with this code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是页面动作的截图。您会看到通过填写表格，表中已经增加了一名额外的人员。自己试一试，看看这个代码与您之间的即时交互：
- en: '![Adding data dynamically](img/4346OT_04_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![动态添加数据](img/4346OT_04_02.jpg)'
- en: Using observable properties in the View
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在View中使用可观察属性
- en: We just saw how simple it is to add new data to observable collections in the
    View-Model, and how this causes any data-bound elements to immediately show that
    new data. Let's add some more functionality to illustrate working with individual
    elements and see how their observable values can update content on the page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到在View-Model中向可观察集合添加新数据是多么简单，以及这如何导致任何数据绑定元素立即显示新数据。让我们添加一些更多功能来展示如何处理单个元素，并看看它们的可观察值如何更新页面内容。
- en: 'To demonstrate this new functionality, I have added some columns to the table:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个新功能，我在表格中添加了一些列：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first new column has no heading text but will contain a button on the page
    for each of the table rows. The second new column will be displaying the value
    of the "live data" in the View-Model for each of the objects displayed in the
    table.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列新列没有标题文本，但将在页面上为每个表格行包含一个按钮。第二列新列将显示表格中显示的每个对象的“实时数据”在View-Model中的值。
- en: 'Here is the updated row template:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的行模板：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that I have replaced all of the simple `text data-bind` attributes with
    input elements and `valuedata-bind` attributes. I also added a button with a `clickdata-bind`
    attribute and a column that displays the text of the three properties so that
    you can see the observable behavior in real time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将所有的简单`text data-bind`属性替换为输入元素和`valuedata-bind`属性。我还添加了一个带有`clickdata-bind`属性的按钮和一个显示三个属性文本的列，这样您就可以实时看到可观察行为。
- en: 'The View-Model gets a new method for the delete button:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: View-Model为删除按钮获得了一个新方法：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When this function is called through the binding that Kendo UI has created,
    it passes an event argument, here called `e`, into the function that contains
    a data property. This data property is a reference to the model object that was
    used to render the specific row of data. In this function, I created a `person`
    variable for a reference to the person in this row and a reference to the `people`
    array; we then use the index of this person to splice it out of the array. When
    you click on the **Delete** button, you can observe the table reacting immediately
    to the change.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过Kendo UI创建的绑定调用此函数时，它会传递一个事件参数，这里称为`e`，到包含数据属性的函数中。这个数据属性是对用于渲染特定数据行的模型对象的引用。在这个函数中，我创建了一个`person`变量来引用这一行的人员，以及一个对`people`数组的引用；然后我们使用这个人员的索引从数组中移除它。当您点击**删除**按钮时，您可以观察到表格立即对变化做出反应。
- en: 'Here is the full source code of the updated View-Model:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的View-Model的完整源代码：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is a screenshot of the new page:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是新的页面截图：
- en: '![Using observable properties in the View](img/4346OT_04_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![在视图中使用可观察属性](img/4346OT_04_03.jpg)'
- en: Click on the **Delete** button to see an entry disappear. You can also see that
    I have added a new person to the table and that I have made changes in the input
    boxes of the table and that those changes immediately show up on the right-hand
    side. This indicates that the View-Model is keeping track of the live data and
    updating its bindings accordingly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **删除** 按钮可以看到一个条目消失。你还可以看到我向表中添加了一个新的人，并且我在表格的输入框中做了更改，这些更改立即显示在右侧。这表明视图模型正在跟踪实时数据，并相应地更新其绑定。
- en: Making better use of observable arrays
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好地利用可观察数组
- en: In the last several examples, we have been using an array called `people` to
    show a dynamic table with Kendo UI bindings. This has worked fine so far, but
    with more complicated Models and functionality we can run into a wall, so to speak.
    For example, there is no way to have the "live data" come from the Model objects
    themselves; we had to concatenate three `span` elements in the template to form
    the final output. This could cause problems for more complicated and full-featured
    pages, where you may have an array of Model objects that need to be able to handle
    events and calculate values on their own, instead of at the View-Model level.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几个例子中，我们一直在使用一个名为 `people` 的数组来展示带有 Kendo UI 绑定的动态表格。到目前为止，这运行得很好，但随着模型和功能的更加复杂，我们可能会遇到所谓的“瓶颈”。例如，没有方法能让“实时数据”直接来自模型对象本身；我们不得不在模板中将三个
    `span` 元素连接起来以形成最终的输出。这可能会给更复杂和功能更全面的页面带来问题，在这些页面上，你可能有一个需要能够自行处理事件和计算值的模型对象数组，而不是在视图模型级别上。
- en: 'Modify the row template like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式修改行模板：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have changed the property names in the `data-bind` declaration so that they
    point to an inner property that we created for them, called `stuff`. The important
    part of the example is that we also changed the final column to point to a calculated
    value function called `dataString` . The meaning of this will become clear as
    we continue. Next, update the JavaScript block for the View-Model so that it looks
    like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `data-bind` 声明中更改了属性名称，以便它们指向我们为它们创建的内部属性，称为 `stuff`。示例中的重要部分是我们还更改了最后一列，使其指向一个名为
    `dataString` 的计算值函数。随着我们继续，这个含义将变得清晰。接下来，更新视图模型的 JavaScript 块，使其看起来像这样：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We made several changes, so let's step through them carefully. The first important
    change is right at the top, where we have replaced the static array declaration
    with the `people` property as an empty array with the bracket notation `[]`. Secondly,
    we created a new type of object called `person` and gave it a constructor function
    with its own internal observable objects. Each of these observable objects needs
    an object to manage, simple values don't work quite as well, so we made an arbitrary
    property for them called `stuff`. The only thing going on here is that the properties
    of this new `person` object type are pointing to observable objects instead of
    simple data. Why? Because if the properties are not observable, then the View-Model
    will not be notified of the change and the user interface will not be updated
    through data-binding.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了几项更改，让我们仔细地一步步来看。第一个重要的更改就在顶部，我们将静态数组声明替换为 `people` 属性作为一个空数组，使用方括号表示法 `[]`。其次，我们创建了一个新的对象类型
    `person`，并给它提供了一个构造函数，其中包含它自己的内部可观察对象。这些可观察对象中的每一个都需要一个对象来管理，简单的值并不完全适用，所以我们为它们创建了一个任意属性，称为
    `stuff`。这里发生的事情只是这个新的 `person` 对象类型的属性指向了可观察对象而不是简单数据。为什么？因为如果属性不是可观察的，那么视图模型将不会通知变化，用户界面也不会通过数据绑定进行更新。
- en: The purpose of this change is to enable calculated values local to the specific
    instance of the object, which we have done with the `dataString` function inside
    of the `person` constructor. As you can see, the `dataString` function extracts
    the values from the locally observable properties and returns them as a formatted
    string. This is significant because it means that every `person` object has its
    own copy of this function, and that the View-Model itself is not involved in this
    calculation. This means that each object inside of the View-Model's `people` array
    can observe changes specific to itself and calculate values based on those changes.
    This type of Model can become very useful for advanced scenarios.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这次变更的目的是为了使对象特定实例的计算值本地化，我们已经在`person`构造函数内部通过`dataString`函数实现了这一点。正如你所见，`dataString`函数从本地可观察的属性中提取值，并以格式化的字符串形式返回它们。这很重要，因为它意味着每个`person`对象都有其自己的函数副本，并且视图模型本身并不参与这个计算。这意味着视图模型内部的每个对象都可以观察其特定的变化，并基于这些变化计算值。这种类型的模型在高级场景中非常有用。
- en: 'After declaring the `person` constructor function, we manually added some new
    `person` objects to the `people` array and then called `kendo.bind()` as usual.
    When rendered, the page looks and behaves just as it did in the previous example,
    but now the Model objects are smarter. Here is the full source code of the updated
    View-Model:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明`person`构造函数之后，我们手动向`people`数组中添加了一些新的`person`对象，然后像往常一样调用`kendo.bind()`。当渲染时，页面看起来和表现就像上一个例子一样，但现在模型对象更智能了。以下是更新后的视图模型的完整源代码：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the output when the page is run:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 页面运行时的输出如下：
- en: '![Making better use of observable arrays](img/4346OT_04_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![更好地利用可观察数组](img/4346OT_04_04.jpg)'
- en: Data-bind properties for Kendo MVVM
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kendo MVVM的数据绑定属性
- en: There are thirteen different types of values that can be used inside of the
    `data-bind` Kendo UI attribute. Here is a summary of their definitions and uses.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data-bind` Kendo UI属性内部可以使用十三种不同的值类型。以下是它们定义和用法的总结。
- en: The attr property
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`attr`属性'
- en: The `attr` property is used to bind the value of a View-Model to a specific
    HTML attribute of a page element. For example, this is very useful for setting
    attributes such as the `src` for an image or the `href` for an anchor tag.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr`属性用于将视图模型的值绑定到页面元素的特定HTML属性。例如，这对于设置图像的`src`属性或锚点的`href`属性非常有用。'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A binding like this would guarantee that the image would change along with the
    View-Model to allow for dynamically loading or changing images on a web page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的绑定将确保图像会随着视图模型的变化而变化，从而允许在网页上动态加载或更改图像。
- en: 'Note that the `attr` property can set multiple attributes at once when they
    are separated by commas like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当属性以逗号分隔时，`attr`属性可以一次设置多个属性，如下所示：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This property can be used with any HTML element and with any valid HTML attribute
    (including custom HTML5 `data-*` attributes).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性可以与任何HTML元素以及任何有效的HTML属性（包括自定义HTML5 `data-*`属性）一起使用。
- en: The checked property
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`checked`属性'
- en: 'The `checked` property is used to bind the checked status of an input element
    with type `checkbox` or `radio`. For checkboxes, the data-bound property can be
    either a Boolean (`true`/`false`) value or an array. For radio selections, the
    property needs to be a string. For example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`checked`属性用于绑定类型为`checkbox`或`radio`的输入元素的选中状态。对于复选框，数据绑定属性可以是布尔值（`true`/`false`）或数组。对于单选选择，属性需要是字符串。例如：'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you will see later, the `checked` binding can be very useful in conjunction
    with the `visible`/`invisible` bindings so that the checkboxes or radio buttons
    on the page will dynamically show or hide other portions of the page.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你稍后所见，`checked`绑定可以与`visible`/`invisible`绑定结合使用，这样页面上的复选框或单选按钮将动态显示或隐藏页面上的其他部分。
- en: The click property
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击属性
- en: The `click` property binds the click event of a button to a function inside
    of the View-Model. It is a shortcut to the `events` binding that we will see later.
    Unlike a traditional click event wire-up, the Kendo UI framework will pass context
    data to the event handler to allow for a richer event-handling experience. For
    example, when a click event is bound within a row template, the event argument
    passed to the event handler will have access to the item from the source collection.
    This allows the event handler to operate against that Model data directly without
    any further DOM exploration and keeps all of the observable functionality in place.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`click`属性将按钮的点击事件绑定到视图模型内的一个函数。它是我们稍后将看到的`events`绑定的一种快捷方式。与传统的点击事件连接不同，Kendo
    UI框架将传递上下文数据到事件处理器，以允许更丰富的事件处理体验。例如，当在行模板内绑定点击事件时，传递给事件处理器的参数将能够访问源集合中的项目。这使得事件处理器可以直接操作该模型数据，而无需进行任何进一步的DOM探索，并保持所有可观察的功能不变。'
- en: Technically, Kendo UI supplies the DOM event wrapped in a jQuery event object
    to the event handler indicated in the binding, but it also manages the data property
    like we talked about in the previous paragraph. Since the event argument is still
    connected to the DOM event, you can call `stopPropogation()` and `preventDefault()`
    on that event argument to stop the DOM from performing any other actions in the
    page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，Kendo UI将包装在jQuery事件对象中的DOM事件传递给绑定中指定的事件处理器，但它也像我们在上一段中讨论的那样管理数据属性。由于事件参数仍然与DOM事件相关联，因此您可以在该事件参数上调用`stopPropagation()`和`preventDefault()`来阻止DOM在页面上执行任何其他操作。
- en: 'We already saw examples of the `click` binding in our code samples above so
    here are some of the snippets that we used there:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面提供的代码示例中已经看到了`click`绑定的例子，所以这里有一些我们当时使用的代码片段：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The custom property
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义属性
- en: Kendo UI allows for custom bindings so that you can create custom behaviors
    related to the View-Model of your page. An example on the Kendo UI documentation
    site uses a jQuery UI `slideDown` and `slideUp` call based on a Boolean value
    in the View-Model as a short-cut to some UI transformations. Refer to the Kendo
    UI documentation for a more detailed API reference for custom bindings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo UI允许自定义绑定，以便您可以为页面的视图模型创建与自定义行为相关的功能。Kendo UI文档站点上的一个示例使用基于视图模型中布尔值的jQuery
    UI `slideDown`和`slideUp`调用作为一些UI转换的快捷方式。有关自定义绑定的更详细API参考，请参阅Kendo UI文档。
- en: The disabled/enabled properties
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用/启用属性
- en: 'The `disabled` and `enabled` bindings work on input, select, and text area
    HTML elements. Just as their names would indicate, they disable or enable the
    bound elements respectively. These bindings are designed for use with Boolean
    properties, but for the sake of JavaScript loose-typing they will consider the
    non-Boolean values `0`, `null`, `undefined`, and `""` (empty string) as `false`
    and all other non-Boolean values as `true`. An example code is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`disabled`和`enabled`绑定作用于输入、选择和文本区域HTML元素。正如它们的名称所暗示的那样，它们分别禁用或启用绑定的元素。这些绑定是为与布尔属性一起使用而设计的，但为了JavaScript的宽松类型，它们将非布尔值`0`、`null`、`undefined`和`""`（空字符串）视为`false`，并将所有其他非布尔值视为`true`。以下是一个示例代码：'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The events property
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件属性
- en: 'The `events` binding is a convenient way to wire-up event handlers in your
    View-Model to events on HTML elements in your View. The click binding, as we saw
    above, is a specific example of this pattern and operates in exactly the same
    way. For example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`events`绑定是方便地将视图模型中的事件处理器连接到视图中的HTML元素事件的一种方式。正如我们上面看到的，点击绑定是这个模式的一个具体例子，并且以完全相同的方式运行。例如：'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The html/text properties
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: html/text属性
- en: 'The `html` binding sets the `innerHtml` content of an HTML element using the
    value of a property from the View-Model. This binding differs from the `text`
    binding in that it does not encode HTML tags before generating its output, which
    means that HTML tags in the View-Model property will be rendered as HTML instead
    of as text (which is probably what you want if you are using the `html` binding).
    An example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`html`绑定使用视图模型中属性的值设置HTML元素的`innerHTML`内容。与`text`绑定不同，它不会在生成输出之前对HTML标签进行编码，这意味着视图模型属性中的HTML标签将被渲染为HTML而不是文本（如果您使用`html`绑定，这可能是您想要的）。以下是一个示例：'
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This would generate output like this in the source of the rendered page:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在渲染页面的源代码中生成如下输出：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `text` binding works in exactly the same way as the `html` binding, except
    that it sets the simple text between element tags and it does encode HTML before
    output, so do not put HTML in the property containing the text to display unless
    you want the tags to show as part of the text output.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`text` 绑定与 `html` 绑定的工作方式完全相同，不同之处在于它设置元素标签之间的简单文本，并且在输出之前会编码HTML，因此不要在包含要显示的文本的属性中放置HTML，除非你希望标签作为文本输出的一部分显示。'
- en: The invisible/visible properties
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无形/可见属性
- en: 'The `invisible` and `visible` bindings work on HTML elements that you want
    to either show or hide dynamically. Just as their names indicate, they make the
    given element invisible or visible respectively. These bindings are designed for
    use with Boolean properties, but for the sake of JavaScript loose-typing they
    will consider the non-Boolean values `0`, `null`, `undefined`, and `""` (empty
    string) as false and all other non-Boolean values as true. An example code is
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`invisible` 和 `visible` 绑定用于HTML元素，您希望动态地显示或隐藏这些元素。正如它们的名称所表明的，它们分别使给定元素不可见或可见。这些绑定旨在与布尔属性一起使用，但为了JavaScript宽松类型，它们将非布尔值
    `0`、`null`、`undefined` 和 `""`（空字符串）视为假，并将所有其他非布尔值视为真。以下是一个示例代码：'
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As mentioned earlier, it can be very useful to connect the value of a checkbox
    or a radio button with the visible status of other elements on a page. This allows
    you to change what data is displayed on the page based on selections that the
    user makes. Here is a simple example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将复选框或单选按钮的值与页面上的其他元素的可见状态连接可能非常有用。这允许你根据用户的选择更改页面上显示的数据。以下是一个简单的示例：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code will make the checkbox control the visibility of the paragraph element
    that would contain some text that you only want displayed if the checkbox is checked.
    This is probably simpler than code you would use in a normal web application,
    but it illustrates the basic point.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将使复选框控制包含某些文本的段落元素的可见性，这些文本仅在复选框被选中时才显示。这可能比在普通Web应用程序中使用的代码要简单，但它说明了基本原理。
- en: The source property
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`source` 属性'
- en: The source binding is designed to render a Kendo UI template using the value
    of a View-Model property. If the property is an array, then the Kendo UI framework
    will render the template for each element of the array. This template is specified
    by the data-template attribute attached to the HTML element in question, and should
    indicate the template by its `id` attribute. When the templates are rendered,
    they will be placed directly beneath the element with the source attribute in
    the DOM. This is why you would place the source attribute on the `tbody` element
    of a table so that the `tr` elements in the Kendo UI template will be rendered
    and placed directly beneath it in the DOM so that they will appear as rows in
    a `table`. This binding can work on any element where it makes sense to include
    a collection of lower level elements, a `table` is just a natural example; other
    good uses would be `ul`, `ol`, and `select` elements.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 绑定旨在使用视图模型属性的值来渲染Kendo UI模板。如果该属性是数组，则Kendo UI框架将为数组的每个元素渲染模板。此模板由附加到相关HTML元素上的
    `data-template` 属性指定，并且应通过其 `id` 属性指示模板。当模板被渲染时，它们将直接放置在具有 `source` 属性的元素下方DOM中。这就是为什么你会在表格的
    `tbody` 元素上放置 `source` 属性，以便Kendo UI模板中的 `tr` 元素将被渲染并直接放置在DOM中，这样它们就会作为表格中的行出现。此绑定可以在任何合理包含一组低级元素的元素上工作，`table`
    只是一个自然的例子；其他很好的用途包括 `ul`、`ol` 和 `select` 元素。'
- en: 'We saw the source binding with a table already in our code samples. I will
    paste a little of it here as a reminder:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的代码示例中看到了 `source` 绑定。我将粘贴其中一部分作为提醒：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a good example of using the `source` binding with an array of objects.
    The `source` binding can also be used with an array of simple values, in which
    case you would use the keyword `this` inside the template instead of a property
    name inside an object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用对象数组 `source` 绑定的好例子。`source` 绑定也可以与简单值数组一起使用，在这种情况下，你会在模板内部使用关键字 `this`
    而不是对象内的属性名称：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `source` binding can also be used with a single object (as opposed to an
    array) in which case it behaves just like binding to an array with a single element.
    You can also bind to the View-Model itself if you want to access a single property
    within it as the `source,` in which case you reference the `source` as a property
    of the `this` keyword:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 绑定也可以与单个对象（而不是数组）一起使用，在这种情况下，它表现得就像绑定到一个只有一个元素的数组一样。如果您想访问 View-Model
    中的单个属性，也可以将其绑定到 View-Model 本身，在这种情况下，您将 `source` 作为 `this` 关键字的一个属性来引用：'
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how the structure is the same as if you were referencing a single object,
    but we are using the `this` keyword since we are referencing the View-Model directly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结构看起来就像您在引用一个单一对象一样，但我们使用 `this` 关键字，因为我们直接引用了 View-Model。
- en: When binding to a `select` element, note that you can use an array of simple
    values or an array of objects. If you just an array of objects, use the `data-text-field`
    to indicate which property contains the text to display within each `option,`
    and use the `data-value-field` to indicate which property contains the value within
    each `option` element.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定到 `select` 元素时，请注意，您可以使用一个简单的值数组或一个对象数组。如果您只有一个对象数组，请使用 `data-text-field`
    来指示包含要显示在每个 `option` 中的文本的属性，并使用 `data-value-field` 来指示包含每个 `option` 元素中的值的属性。
- en: The style property
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式属性
- en: 'The style binding is a great way to create a dynamic relationship between data
    in your View-Model and CSS styles on your page. It is a very simple binding that
    creates a direct relationship between the properties in your View-Model and the
    styles in your markup. An example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 样式绑定是创建您 View-Model 中的数据与页面上的 CSS 样式之间动态关系的一种极好方式。这是一个非常简单的绑定，它直接在 View-Model
    中的属性和您的标记中的样式之间建立关系。例如：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Obviously, this becomes a lot more useful if you tie some logic to the styles
    you are using in your page, such as changing the styles for alternating table
    rows or changing the color of text if it meets some special criteria (such as
    an overdrawn balance looking red).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果您将一些逻辑与页面中使用的样式绑定在一起，这将变得非常有用，例如，改变交替表格行的样式或根据某些特殊标准（如透支余额看起来是红色）改变文本颜色。
- en: Notice that we used the style property `fontWeight` which should look strange
    to you. If you need to reference styles that normally contain a hyphen (`font-weight`),
    you need to use a camel-cased version in the binding so that it works as a valid
    JavaScript property name. So `font-weight` becomes `fontWeight` in the actual
    binding statement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了 `fontWeight` 样式属性，这可能会让您感到奇怪。如果您需要引用通常包含连字符（`font-weight`）的样式，您需要在绑定中使用驼峰式版本，以便它作为一个有效的
    JavaScript 属性名称工作。因此，`font-weight` 在实际的绑定语句中变为 `fontWeight`。
- en: Finally, if you set the style value to an empty string, it will reset the value
    back to its original setting.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您将样式值设置为空字符串，它将重置值回到其原始设置。
- en: The value property
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值属性
- en: 'The `value` binding works in a very similar way to the `text` binding, except
    that it sets the value of an input element instead of the text of a display element.
    The bound value in the View-Model is updated on blur by default, such as when
    you press *Tab* to leave the input element on the page. If you want the View-Model
    property to be updated based on a different DOM event, you can set that in the
    `data-value-update` property on the same element as the binding. We have already
    seen the use of the value binding in our code samples. Here is an example of using
    the data-value-update binding to customize some behavior:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 绑定与 `text` 绑定非常相似，不同之处在于它设置输入元素的值而不是显示元素的文本。默认情况下，在 View-Model 中绑定的值在失去焦点时更新，例如，当您按下
    *Tab* 键离开页面上的输入元素。如果您想根据不同的 DOM 事件更新 View-Model 属性，您可以在具有绑定的同一元素上设置 `data-value-update`
    属性。我们已经在代码示例中看到了 `value` 绑定的使用。以下是一个使用 `data-value-update` 绑定来自定义某些行为的示例：'
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember that this is a two-way binding and is most useful for retrieving data
    from the users as they fill out a form.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是一个双向绑定，并且对于从用户那里检索数据（当他们填写表单时）非常有用。
- en: 'Much like the `checked` binding that we saw above, the `value` binding works
    with `select` elements in a similar way. By binding the `value` of a `select`
    element to a string property, it will be bound to the value of the selected `option`
    element inside of the `select` element if the options have values, or the `text`
    of the selected `option` element if no `value` is present. Here is how this would
    look in the markup:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们上面看到的 `checked` 绑定类似，`value` 绑定以类似的方式与 `select` 元素一起工作。通过将 `select` 元素的 `value`
    绑定到一个字符串属性，如果选项有值，它将绑定到 `select` 元素内部的选中 `option` 元素的值；如果没有 `value`，则绑定到选中 `option`
    元素的 `text`。以下是这种绑定在标记中的样子：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Of course, you can also bind both the `source` and the `value` of a `select`
    element to the View-Model. You are not limited to a single binding in the `data-bind`
    property. Also, as you might expect, you can bind the value of a multiple-select
    element if you are binding it to an array (instead of a simple string) so that
    it can hold multiple values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以将 `select` 元素的 `source` 和 `value` 都绑定到 View-Model。你不仅限于在 `data-bind`
    属性中只有一个绑定。同样，正如你所期望的，如果你将一个多选元素绑定到一个数组（而不是一个简单的字符串），你也可以绑定其值。
- en: Declarative widgets through Data-Role MVVM attributes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Data-Role MVVM 属性进行声明性小部件
- en: Kendo's MVVM also allows declarative initialization of widgets through the `data-role`
    attribute. Declarative initialization is a different method of creating Kendo
    widgets by using the `data-role` attribute instead of setting up the widget through
    JavaScript. This is not as flexible as the JavaScript method, but it does allow
    for a lot of functionality with almost no code at all. Here is a section of code
    taken from the Kendo UI Web website that shows some basic set up as an introduction.
    The full details for these widgets can be found there.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo 的 MVVM 还允许通过 `data-role` 属性进行声明性小部件初始化。声明性初始化是通过使用 `data-role` 属性而不是通过
    JavaScript 设置小部件来创建 Kendo 小部件的一种不同方法。这不如 JavaScript 方法灵活，但它几乎不需要代码就能实现很多功能。以下是从
    Kendo UI 网站上摘取的一段代码，展示了作为介绍的一些基本设置。这些小部件的完整细节可以在那里找到。
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a great example of using multiple bindings together, and of which bindings
    rightly pertain to which widgets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用多个绑定一起使用的绝佳例子，以及哪些绑定正确地适用于哪些小部件。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The Kendo MVVM framework brings complicated interactive JavaScript into the
    realm of simple HTML attributes, templates, and View-Model functions. It is a
    very powerful feature and is one that you are likely to become very accustomed
    to using in your web pages. Keep in mind as you develop code that Kendo is a system
    in which features can be built together very nicely; for example, you could use
    a Kendo data source object as the source binding for a `table` or `select` list.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Kendo MVVM 框架将复杂的交互式 JavaScript 带入了简单的 HTML 属性、模板和 View-Model 函数的领域。这是一个非常强大的功能，你可能会很快习惯在网页中使用它。在编写代码时请记住，Kendo
    是一个可以非常优雅地构建特性的系统；例如，你可以使用 Kendo 数据源对象作为 `table` 或 `select` 列表的源绑定。
- en: When you have powerful tools like this within your reach, you will find that
    function-rich pages become normal instead of exceptionally difficult and that
    your programming experience will be better than ever. In the next chapter, we
    will learn about the Kendo UI HTML Editor widget. This widget adds a full-featured
    HTML editing box to your web pages so that users can create content in a friendly
    input area with formatting, images, and hyperlinks. It is especially useful if
    users can contribute content on your site, such as with a blog or a forum.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你手头有这样的强大工具时，你会发现功能丰富的页面变得正常，而不是异常困难，你的编程体验将比以往任何时候都要好。在下一章中，我们将学习关于 Kendo
    UI HTML 编辑器小部件。这个小部件将一个功能齐全的 HTML 编辑框添加到你的网页中，以便用户可以在一个友好的输入区域中创建带有格式、图片和超链接的内容。如果用户可以在你的网站上贡献内容，例如通过博客或论坛，这尤其有用。
