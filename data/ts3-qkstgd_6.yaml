- en: Reusing Code Through Generic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过泛型复用代码
- en: This chapter is built from notions introduced by the previous chapters. The
    chapter built on top of notions by enhancing type by making them generic. Basic
    topics such as defining a generic class and interface are covered. Through the
    chapter, we move into more advanced topics such as generic constraints are part
    of the content. The goal of this chapter is to make your code more generic to
    increase the reusability of your classes, functions, and structures, to reduce
    the burden of duplicating code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是基于前几章引入的概念构建的。本章通过增强类型使其泛型化来构建在概念之上。本章涵盖了基本主题，如定义泛型类和接口。通过本章，我们进入更高级的主题，如泛型约束是内容的一部分。本章的目标是使你的代码更加泛型，以增加类、函数和结构的可复用性，减少代码复制的负担。
- en: 'The content in this chapter covers the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容涵盖以下内容：
- en: How generic can make your code reusable
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型如何使你的代码可复用
- en: Accepted kinds of data structure for generic type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型可接受的数据结构类型
- en: How to constrain the generic type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何约束泛型类型
- en: Generic and intersection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型和交集
- en: Default generic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认泛型
- en: Generic optional type
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型可选类型
- en: Generic constraints with a union type
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用联合类型进行泛型约束
- en: Restricting string choices with `keyof`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `keyof` 限制字符串选择
- en: Limiting the access to members of a generic type
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制对泛型类型成员的访问
- en: Reducing your type creation with a mapped type
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射类型减少类型创建
- en: Generic type in TSX file
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TSX 文件中的泛型类型
- en: Generic code to increase reusability
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型代码提高复用性
- en: Generic is available in almost all typed language. It allows transforming your
    code in a reusable fashion without having to rely on unsafe casting to retrieve
    the value stored in an object. Without generic, there are different ways to achieve
    reusability. For example, you can have an interface with an `any` type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型几乎在所有类型语言中都是可用的。它允许以可复用的方式转换你的代码，而无需依赖于不安全的类型转换来检索对象中存储的值。没有泛型，有不同方式来实现复用。例如，你可以有一个具有
    `any` 类型的接口。
- en: 'That would make the field open to receive any kind of object, hence being reusable
    for many scenarios:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会使字段能够接收任何类型的对象，因此可以在许多场景中复用：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A slightly better way would be to specify whether we want to accept primitives
    or only objects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微好一点的方法是指定我们是否想要接受原始类型或仅接受对象：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In both cases, the problem comes when we want to use the reusable field. The
    same result occurs with `any` or `object`, which is that we do not have access
    to the original variable''s member because we do not have a way to know what was
    the original type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，问题出现在我们想要使用可复用字段的时候。使用 `any` 或 `object` 也会出现相同的结果，即我们无法访问原始变量的成员，因为我们没有方法知道原始类型是什么：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code, it is impossible to use `.test` of the entity without casting
    back to the entity. In that particular type, it is an anonymous type but still
    possible:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，如果不将实体转换回原始类型，就无法使用实体的 `.test` 方法。在这个特定的类型中，它是一个匿名类型，但仍然可能：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, generic can remove this hinder to access the original type by bringing
    the type of the object into the definition of the type without tampering the type
    to be isolated with a single type. To create a generic function, interface, or
    class, you need to use the smaller or bigger sign, `< >`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，泛型可以通过将对象的类型引入类型的定义中，而不干扰要隔离的单个类型，来消除访问原始类型的障碍。要创建泛型函数、接口或类，你需要使用较小的或较大的符号
    `< >`：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The name between the brackets does not matter. In the following code, we are
    using the entity with two custom interfaces and use them as type `T`. We are also
    using a number directly. We can use all the possible types because we do not have
    a generic constraint, yet, in place:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 中括号之间的名称并不重要。在下面的代码中，我们使用两个自定义接口来使用实体，并将它们用作类型 `T`。我们还在直接使用一个数字。我们可以使用所有可能的类型，因为我们还没有设置泛型约束：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The biggest advantage is that if we access the object, the field entity is
    of a `T` type, which changes depending on how the object was created:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的优势是，如果我们访问对象，字段实体是 `T` 类型，这取决于对象是如何创建的：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Accepted kinds of data structure for generic type
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型可接受的数据结构类型
- en: 'The concept of generic spreads beyond just interfaces. Generic is available
    for types but also with classes, and it can transform a function as well. The
    disposition of the brackets that define the generic type goes right after the
    interface name, type, or the class name. We will see later that it must also go
    after the name of a function. Generic can be used to have a generic field, generic
    parameter, generic return type, and generic variable:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通用类型的概念不仅限于接口。通用类型不仅适用于类型，还适用于类，并且可以转换函数。定义通用类型的括号的位置紧接在接口名称、类型或类名称之后。我们稍后将会看到它也必须紧跟在函数名称之后。通用类型可以用于具有通用字段、通用参数、通用返回类型和通用变量：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A generic type can have many generics at the same time, allowing multiple fields
    or function parameters to have a different kind of type:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通用类型可以同时具有多个通用类型，允许多个字段或函数参数具有不同类型的类型：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Constaining a generic type
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制通用类型
- en: 'In a previous code example in this chapter, we used the type object to make
    sure no primitives were passed in an interface. The problem with the use of an
    object is that you do not get back the initial type when you get back the entity.
    The following code illustrates the problem:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前的代码示例中，我们使用了类型对象来确保在接口中没有传递原始类型。使用对象的问题在于，当你从实体返回时，你无法获得初始类型。以下代码说明了这个问题：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is possible to keep the original type and have a constraint to not allow
    a primitive with the keyword `extends`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能保持原始类型，并通过`extends`关键字约束不允许使用原始类型：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `extends` keyword allows specifying the minimum structure that must be
    present in the object passed to the generic type. In that case, we were passing
    an object. However, we could extend any minimum structure, interface, or type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends`关键字允许指定传递给通用类型的对象必须存在的最小结构。在这种情况下，我们传递了一个对象。然而，我们可以扩展任何最小结构、接口或类型：'
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous code example has two variables that do not compile. The first
    one, the variable is set to a wrong object. The third variable is set to a string,
    but the generic constraint cannot be fulfilled by the string because it doesn''t
    have the id:number field. The second variable compiles because of the entity respect
    the constraint. Finally, here is an example of having a generic with a constraint
    that is an interface:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例中有两个变量无法编译。第一个变量被设置为一个错误的对象。第三个变量被设置为一个字符串，但由于字符串没有`id:number`字段，因此无法满足通用约束。第二个变量可以编译，因为实体遵守了约束。最后，这里有一个具有约束的通用类型的示例：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Other than having access back to the full original type, generic with constraint
    allows accessing the constrain field from the class or function that implements
    the generic. The first code example, with `function`, has the constraint directly
    at the function signature. It allows accessing only the field from the constraint:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以访问完整的原始类型外，具有约束的通用类型还允许从实现通用类型的类或函数中访问约束字段。第一个代码示例，使用`function`，在函数签名中直接具有约束。它允许仅访问约束的字段：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Similarly, a class lets you use inside any of its functions, the field from
    the generic constraint. In the following code, the function loops the generic
    list of `T`. Since `T` is extending `ObjectWithId` that has `what` property and
    `id`; both are accessible:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一个类允许在其任何函数中使用通用约束的字段。在下面的代码中，函数遍历`T`的通用列表。由于`T`扩展了具有`what`属性和`id`的`ObjectWithId`，因此两者都是可访问的：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Generic and intersection
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用类型和交集
- en: 'Generic and intersection work well together. It allows the use of an undetermined
    type and creates a second one with the combination of a known type or another
    generic. In the following code, there is a generic function that takes a type
    `T` that must respect to a minimum the structure of the `User` object. The return
    type of the function is the generic type passed by a parameter intersected by
    a new `WithId` structure. It means that whatever the type passed will be enhanced
    with the new structure. In the code, the `Developer` type is passed to the function
    and the function returns `Developer+WithId`. It is a new type, not defined anywhere,
    but is still strongly typed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通用类型和交集工作得很好。它允许使用未确定类型，并通过已知类型或另一个通用类型的组合创建第二个类型。在下面的代码中，有一个通用函数，它接受一个必须至少符合`User`对象结构的类型`T`。函数的返回类型是参数传递的通用类型与新的`WithId`结构交集后的通用类型。这意味着传递的任何类型都将通过新的结构得到增强。在代码中，将`Developer`类型传递给函数，函数返回`Developer+WithId`。这是一个新类型，没有在任何地方定义，但仍然是强类型的：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code shows that we can use the return type and have all three members available.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示我们可以使用返回类型，并且所有三个成员都可用。
- en: 'It is possible to intersect many generic types together, for example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将许多通用类型组合在一起，例如：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `merge` function takes two different types and merges them using the JavaScript
    `assign` function. The function returns the intersection of both types. If we
    dig into the definition of the `Object.assign` function, we realize that this
    one is also leveraging the intersection with generic. Here is the definition file
    of `Object.assign` for ES2015:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`函数接受两种不同的类型，并使用JavaScript的`assign`函数将它们合并。该函数返回两种类型的交集。如果我们深入研究`Object.assign`函数的定义，我们会意识到它也在利用泛型的交集。以下是ES2015的`Object.assign`定义文件：'
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Default generic
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认泛型
- en: The more you work with generic, the more you may find that for a particular
    case in your system you are using always the same type. It could almost not be
    generic but be of a specific type. In that case, it is interesting to use a default
    type for your generic. A default generic type allows avoids having to specify
    a type. A default generic is also known as an optional type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多地使用泛型，你可能会发现，对于系统中的特定情况，你总是使用相同的类型。它几乎可以不是泛型，而是一个特定类型。在这种情况下，为你的泛型使用默认类型是有趣的。默认泛型类型允许避免必须指定类型。默认泛型也被称为可选类型。
- en: 'TypeScript uses the type specified in the generic signature after the equals
    sign:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript使用等于号之后泛型签名中指定的类型：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Three variables are declared. The first and second ones are exactly the same:
    they expect an object with an `id` of a `string` type. The last is a number. The
    reason the first and second are exactly the same is that the first declaration
    relies on the default type. The default type is specified in the generic definition
    of the interface after the name of the type, `T`. The use of the equals signs
    allows the assignation.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了三个变量。第一个和第二个完全相同：它们期望一个具有`string`类型`id`的对象。最后一个是一个数字。第一个和第二个完全相同的原因是第一个声明依赖于默认类型。默认类型在接口的泛型定义中指定在类型名称`T`之后，使用等号允许赋值。
- en: 'In the case of multiple defaults, only optional typing can be used if no type
    is optional afterward. The following code shows the same interface, the first
    one does not compile because it has the optional generic type before a required
    type:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个默认值的情况下，如果没有后续的可选类型，则只能使用可选类型。以下代码显示了相同的接口，第一个无法编译，因为它在所需类型之前有一个可选泛型类型：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Default generic can have constraints and it deems to respect constraint with
    its default type. The following code does not work because the default type is
    set to be a number. However, the constraint mentions that the structure must have
    an id of type `number`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认泛型可以有约束，并且它似乎尊重其默认类型的约束。以下代码无法工作，因为默认类型被设置为数字。然而，约束指出结构必须有一个类型为`number`的`id`：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, if we change the default type to be `User<number>` it compiles. The
    reason is that user interface has an `id` field of type `T`. The default type
    is not compatible with the constraint extended, which requires an `id` of a `number`
    type. This means that without explicitly mentioning the generic type of `User`
    in the default signature, the code does not compile:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将默认类型更改为`User<number>`，则可以编译。原因是用户界面有一个类型为`T`的`id`字段。默认类型与扩展约束不兼容，该约束要求`id`为数字类型。这意味着如果没有在默认签名中明确提及`User`的泛型类型，代码将无法编译：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A default type is used when a type is not explicit or when TypeScript cannot
    infer the type.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型不是显式指定或TypeScript无法推断类型时，使用默认类型。
- en: Generic optional type
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型可选类型
- en: 'A generic type can be optional in a function or a class. When optional and
    generic, the type becomes an empty object or undefined:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型可以在函数或类中是可选的。当可选且泛型时，类型变为一个空对象或未定义：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Providing a default value to an optional type changes the parameter from an
    empty object to the default type:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为可选类型提供一个默认值将参数从空对象更改为默认类型：
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Generic constraints with a union type
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型的泛型约束
- en: 'There is some room for using a union in the `extends` clause of a generic definition.
    While you cannot use `discriminator`, you can compare against an array. The following
    object allows a type and an array of the same type. You can narrow down to any
    of the two types using `instanceOf` and manipulate the parameter value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在泛型定义的`extends`子句中，使用联合类型有一些空间。虽然不能使用`discriminator`，但可以与数组进行比较。以下对象允许一个类型和相同类型的数组。您可以使用`instanceOf`缩小到任何两种类型之一，并操作参数值：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Trying to extend two different objects with a discriminator does not work at
    the moment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用区分符扩展两个不同的对象目前不起作用。
- en: Restricting string choices with keyof
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `keyof` 限制字符串选择
- en: 'The use of string in JavaScript is omnipresent. One pattern is to access a
    member of an object dynamically with the square bracket:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，字符串的使用无处不在。一种模式是使用方括号动态访问对象的成员：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The problem with the code is that `name` is a string and could be anything.
    We could set between brackets` firstname`, and the code would compile. At runtime,
    the console would show `undefined`. To avoid falling into the pitfall of selecting
    a member that does not exist, we can use `keyof`, which will return a union of
    all members of an object. The union is a `string literal` of all members' names.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的问题在于 `name` 是一个字符串，可以是任何内容。我们可以在括号中设置 `firstname`，代码就会编译。在运行时，控制台会显示 `undefined`。为了避免陷入选择不存在成员的陷阱，我们可以使用
    `keyof`，它将返回一个对象所有成员的联合。联合是所有成员名称的 `字符串字面量`。
- en: 'Before going with `keyof`, create a `function` that tries to access a property
    by a string fail, without defining an index signature (see *Index signature* in
    this book):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `keyof` 之前，创建一个尝试通过字符串访问属性失败的 `function`，而不定义索引签名（参见本书中的 *索引签名*）：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, the same function with `keyof` will work without an index signature.
    The reason is that TypeScript knows that you do not try to access a field that
    might not exist. The goal of accessing with the square bracket is to access members
    that exist:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `keyof` 的相同函数在没有索引签名的情况下也能工作。原因是 TypeScript 知道你并没有尝试访问可能不存在的字段。使用方括号访问的目标是访问存在的成员：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `keyof` allows specifying in a string format the only field from the type
    after the `keyof` keyword. In the code example before, only the string `name`,
    `birthdate` and `isHappy` can be entered without having the compiler show an error:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyof` 允许在 `keyof` 关键字之后以字符串格式指定类型中的唯一字段。在之前的代码示例中，只有字符串 `name`、`birthdate`
    和 `isHappy` 可以输入，而不会让编译器显示错误：'
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Limiting the access to members of a generic type
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制泛型类型的成员访问
- en: It is possible to use generic with `keyof` in a constraint to only specify in
    a string format member name from the generic object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在约束中使用泛型与 `keyof` 来仅指定泛型对象中的字符串格式成员名称。
- en: 'In the following code, we are passing an object in the first parameter, and
    in the second accepting only the member name of the first parameter object. The
    constraint syntax is the same using `extends` followed by `keyof` and the first
    generic type. The return type is the return type of the selected member, which
    is accessible by using the first generic with the index signature of the second
    generic:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们在第一个参数中传递一个对象，在第二个参数中只接受第一个参数对象的成员名称。约束语法与使用 `extends` 后跟 `keyof` 和第一个泛型类型相同。返回类型是所选成员的返回类型，可以通过使用第一个泛型与第二个泛型的索引签名来访问：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The syntax provides a good type safety, in terms of specifying members of an
    object that can be from a variety of potential types, and also provides safety
    in terms of the return type. If `name` changes from `string` to a rich object
    (with many members), the code consuming the return of this function will break
    at compilation time. It's the same if the name changes, the refactoring tool will
    change it. However, if the change is done without using any refactoring tool,
    the compiler will catch that the name is not a valid one.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 语法提供了良好的类型安全性，在指定对象成员方面，这些成员可以是各种潜在类型，同时也提供了关于返回类型的安全性。如果 `name` 从 `string`
    更改为一个具有许多成员的丰富对象，那么消耗此函数返回值的代码将在编译时中断。如果名称更改，重构工具也会更改它。然而，如果更改没有使用任何重构工具，编译器将捕获名称不是有效的情况。
- en: 'The following code shows how `keyof` can be used to make sure a function returns
    the name of the desired member. The first time the function is called, it returns
    `name`; however, the second invocation does not compile because the name of the
    member does not exist in the generic type:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用 `keyof` 确保函数返回所需成员的名称。函数第一次被调用时返回 `name`；然而，第二次调用不会编译，因为成员的名称不在泛型类型中：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Reducing your type creation with mapped type
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用映射类型减少类型创建
- en: When you start typing all your objects, you may fall into the situation where
    you need to have almost the same type but with some minor differences. You may
    want the exact same property but all readable, when the main type has a few read-only
    types. You may want to have all field optionals to allow partial object updates
    or you may want to seal an object by making all its properties read-only. You
    might even want to have all your properties to be a string because your form handle
    string values only, but later has the real interface or type with the good type.
    TypeScript allows creating dynamic type from an existing one. This transformation
    of the type is named *mapped type*. Mapped type allows reducing the burden of
    duplicating an object just to change a property on the type, while keeping the
    same structure of your definition.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写所有对象时，你可能会遇到需要几乎相同类型但有一些细微差异的情况。你可能想要完全相同的属性但所有可读的，当主要类型有几个只读类型时。你可能想要所有字段都是可选的，以便允许部分对象更新，或者你可能想要通过将所有属性设置为只读来密封对象。你可能甚至想要所有属性都是字符串，因为你的表单只处理字符串值，但后来有实际的接口或类型，具有良好的类型。TypeScript允许从现有类型创建动态类型。这种类型的转换被称为*映射类型*。映射类型允许减少复制对象以更改类型属性的负担，同时保持定义的结构相同。
- en: 'TypeScript comes with many mapped types that you can use without having to
    build your own mapped type. Here are two common ones:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript自带了许多可以使用的映射类型，无需自己构建映射类型。以下有两个常见的例子：
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first one, `Readonly`, takes a generic type and loops all its members and
    adds `readonly`. It also returns the same type with `T[P]`. The second one, `Partial`,
    adds the *?* character after the name, which means that every field becomes optional:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`Readonly`，接受一个泛型类型并遍历其所有成员，添加`readonly`。它还返回带有`T[P]`的相同类型。第二个，`Partial`，在名称后添加`*?*`字符，这意味着每个字段都变为可选：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we want to have the variable to be sealed and completely not editable, we
    can use `Readonly`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让变量被密封且完全不可编辑，我们可以使用`Readonly`：
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you want to allow someone to modify only a part of your entity and then
    merge the result, you can use `Partial`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让某人只能修改你的实体的一部分，然后合并结果，你可以使用`Partial`：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can create your own mapped type by using the type keyword and creating
    a name with an *in* operator to loop the member and defining the transformation.
    It is important to notice that we do not manipulate the data, only the type. It
    means that if you are changing the type that you still need to manipulate the
    object to have the expected shape that will fulfil the mapped type. Here are two
    examples of the custom type. The first one returns a string for all members. The
    second removes the `Readonly`. You can see the minus sign before the property,
    which indicates to TypeScript that the modifier of the member is taken away:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用类型关键字并创建一个带有*in*操作符的名称来创建自己的映射类型，以遍历成员并定义转换。重要的是要注意，我们不是操作数据，而是操作类型。这意味着如果你正在更改类型，你仍然需要操作对象以获得预期的形状，以满足映射类型。以下有两个自定义类型的例子。第一个为所有成员返回一个字符串。第二个移除了`Readonly`。你可以看到属性前的减号，这表示TypeScript知道成员的修饰符被移除了：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Mapped type can be stacked to create a final type that combines all mapped
    types. In the following example, we stack two mapped types:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型可以堆叠以创建一个最终类型，该类型结合了所有映射类型。在以下示例中，我们堆叠了两个映射类型：
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The code is legit but does not work. The reason is that TypeScript figures out
    that the `e1.id` is of type number and something tries to cast it into a string
    that does not occur automatically. As mentioned, a mapped type is only good as
    a cast and requires you to have the proper code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是合法的，但不起作用。原因是TypeScript推断出`e1.id`是数字类型，而有人试图将其自动转换为字符串，这是不会发生的。正如提到的，映射类型仅作为转换使用，并要求你有适当的代码。
- en: 'Here is a quick and small function that does the trick. Do not use this code
    in production, since it does not cover the transformation into a string property
    (especially with `object` and `array`), but it illustrates the required transformation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速且简单的函数可以完成这个任务。不要在生产环境中使用此代码，因为它不涵盖转换为字符串属性（特别是对于`object`和`array`），但它说明了所需的转换：
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Generic type in TSX File
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSX文件中的泛型类型
- en: 'TSX is the equivalent of JSX, the JavaScript XML extension language. For a
    long period of time, TypeScript was supporting TSX but wasn''t friendly with generic.
    The main reason is that TSX and the generic syntax share the angle brackets, which
    was causing the compiler to misinterpret the generic type when in a TSX file.
    However, the situation has changed, and TypeScript distinguishes when the square
    brackets are to explicitly define the type of a generic component. In the following
    snippet, you can see the `CallGenericComponent` that tries to render a generic
    component. The return is using an initial opening angle bracket to initialize
    the TSX component. The following and second opening angle bracket is to define
    the type:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: TSX 是 JSX（JavaScript XML 扩展语言）的等价物。在很长一段时间里，TypeScript 支持TSX，但对泛型并不友好。主要原因在于TSX和泛型语法共享了尖括号，这导致在TSX文件中编译器会错误地解释泛型类型。然而，情况已经改变，TypeScript
    区分了何时使用方括号来显式定义泛型组件的类型。在下面的代码片段中，你可以看到 `CallGenericComponent` 尝试渲染一个泛型组件。返回值使用一个初始的左尖括号来初始化TSX组件。接下来的第二个左尖括号是用来定义类型的：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The use of the angle brackets allows to avoids defining the component as a variable
    and having to instantiate it, which was not only required multiple lines but also
    to cast with any. Furthermore, the readability was compromised and the intention
    was unclear to an external pair of eyes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尖括号可以避免将组件定义为变量并实例化它，这不仅需要多行代码，还需要使用 `any` 类型进行类型转换。此外，可读性受损，外部人员难以理解其意图。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to transform your code by using generic. TypeScript
    provides constraints to limit what can be passed into generic, and we saw how
    to leverage the constraint to guide the user as to what can be passed. We also
    saw how powerful the use of `keyof` is, allowing us to dynamically get members
    from a type. We saw how to manipulate type in a generic way, with mapped type.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何通过使用泛型来转换代码。TypeScript 提供了约束来限制可以传递给泛型的内容，我们也看到了如何利用约束来指导用户传递什么内容。我们还看到了使用
    `keyof` 的强大之处，它允许我们动态地从类型中获取成员。我们还看到了如何以泛型方式操作类型，使用映射类型。
