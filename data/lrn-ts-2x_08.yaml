- en: Working with Decorators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器
- en: 'In this chapter, we are going to learn about annotations and decorators—the
    two new features based on the future ECMAScript 7 specification, but we can use
    them today with TypeScript 1.5 or higher. You will learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于注解和装饰器的内容——这两个基于未来ECMAScript 7规范的新特性，但我们可以使用TypeScript 1.5或更高版本来使用它们。你将学习以下主题：
- en: Annotations and decorators
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解与装饰器
- en: The reflection metadata API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射元数据API
- en: The decorator factory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器工厂
- en: Prerequisites
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前置条件
- en: 'The TypeScript features in this chapter require TypeScript 1.5 or higher and
    the following options to be enabled in the `tsconfig.json` file:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的TypeScript特性需要TypeScript 1.5或更高版本，并在`tsconfig.json`文件中启用以下选项：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As indicated by the experimental decorators compilation flag, the decorator's
    API is considered experimental. This doesn't mean that it is not ready for production
    usage. It means that the decorator API is subject to potential breaking changes
    in the future.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如实验装饰器编译标志所示，装饰器的API被认为是实验性的。这并不意味着它不适合生产使用。这意味着装饰器API可能会在未来面临潜在的破坏性更改。
- en: 'We are also going to need a polyfill for the `reflect–metadata` API. We need
    a polyfill because most JavaScript engines don''t support this API yet. We can
    expect that, in the long term, this polyfill will not be required but, currently,
    we can use the `reflect–metadata` npm module:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个`reflect–metadata` API的polyfill。我们需要polyfill是因为大多数JavaScript引擎目前还不支持这个API。我们可以预期，从长远来看，这个polyfill将不再需要，但当前，我们可以使用`reflect–metadata`
    npm模块：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `reflect-metadata` version was 0.1.12 at the time of writing. Please note
    that the examples are included in the companion source code. The examples can
    be executed with ts node. For example, the first example included in the companion
    source code can be executed as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect-metadata`的版本在撰写时为0.1.12。请注意，示例包含在配套源代码中。这些示例可以使用ts node执行。例如，配套源代码中的第一个示例可以按以下方式执行：'
- en: '`ts-node chapters/chapter_08/01_class_decorator.ts`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts-node chapters/chapter_08/01_class_decorator.ts`'
- en: Annotations versus decorators
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解与装饰器的比较
- en: 'Annotations are a way to add metadata to class declarations. The metadata can
    then be used by libraries and other development tools, such as inversion of control
    containers. The annotations API was originally proposed by the Google AtScript
    team, but annotations are not a standard. However, decorators are a proposed standard
    for the ECMAScript specification, to annotate and modify classes and properties
    at design time. Annotations and decorators are pretty much the same:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是一种向类声明添加元数据的方式。然后，库和其他开发工具，如控制反转容器，可以使用这些元数据。注解API最初由Google AtScript团队提出，但注解不是标准。然而，装饰器是ECMAScript规范的一个提议标准，用于在设计时注解和修改类和属性。注解和装饰器基本上是相同的：
- en: '"Annotations and decorators are nearly the same thing. From a consumer perspective,
    we have exactly the same syntax. The only thing that differs is that we don''t
    have control over how annotations are added as metadata to our code. A decorator
    is rather an interface to build something that ends up as annotation. Over a long
    term, however, we can just focus on decorators, since those are a real proposed
    standard. AtScript is TypeScript and TypeScript implements decorators".'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “注解和装饰器几乎是同一件事。从消费者角度来看，我们有完全相同的语法。唯一不同的是，我们无法控制如何将注解作为元数据添加到我们的代码中。装饰器更像是一个接口，用于构建最终成为注解的东西。然而，从长远来看，我们只需关注装饰器，因为那些是真正的提议标准。AtScript是TypeScript，TypeScript实现了装饰器”。
- en: – <q>Pascal Precht</q>, The Difference between Annotations and Decorators
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: – <q>帕斯卡尔·普雷希特</q>，《注解与装饰器的区别》
- en: 'We are going to use the following class to showcase how to work with decorators:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下类来展示如何使用装饰器：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are four types of decorators that can be used to annotate: classes, properties,
    methods, and parameters.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用四种装饰器来注解：类、属性、方法和参数。
- en: The class decorators
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类装饰器
- en: 'The official TypeScript decorator proposal defines a class decorator as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript官方装饰器提案定义类装饰器如下：
- en: A class decorator function is a function that accepts a constructor function
    as its argument, and returns either undefined, the provided constructor function,
    or a new constructor function. Returning undefined is equivalent to returning
    the provided constructor function.                                           
                                                                                 
                               – Ron Buckton, Decorators Proposal - TypeScript
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器函数是一个接受构造函数作为其参数的函数，并返回undefined、提供的构造函数或一个新的构造函数。返回undefined等同于返回提供的构造函数。  –
    朗·巴克顿，TypeScript装饰器提案
- en: 'A class decorator is used to modify the constructor of a class in some way.
    If the class decorator returns `undefined`, the original constructor remains the
    same. If the decorator returns, the return value will be used to override the
    original class constructor. The following type declares the signature of a class
    decorator:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器用于以某种方式修改类的构造函数。如果类装饰器返回`undefined`，则原始构造函数保持不变。如果装饰器返回值，则该返回值将用于覆盖原始类构造函数。以下类型声明了类装饰器的签名：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Please note that this signature is subject to change in future releases of TypeScript.
    Please refer to the `lib.d.ts` file in the TypeScript source code at [https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
    to find the current signature.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此签名可能在TypeScript的将来版本中发生变化。请参考TypeScript源代码中的`lib.d.ts`文件，以找到当前签名：[https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
- en: 'We are going to create a class decorator named `logClass`. We can start by
    defining the decorator as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建一个名为`logClass`的类装饰器。我们可以从定义装饰器开始，如下所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding class decorator does not have any logic yet, but we can already
    apply it to a class. To apply a decorator, we need to use the at (`@`) symbol:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类装饰器还没有任何逻辑，但我们已经可以将其应用于一个类。要应用装饰器，我们需要使用at（`@`）符号：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we compile the preceding code snippet into JavaScript, a function named
    `__decorate` will be generated by the TypeScript compiler. We are not going to
    examine the internal implementation of the `__decorate` function, but we need
    to understand that it is used to apply a decorator at runtime because the decorator
    syntax is not supported natively by JavaScript. We can see it in action by examining
    the JavaScript code that is generated when we compile the decorated `Person` class
    mentioned previously:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码片段编译成JavaScript，TypeScript编译器将生成一个名为`__decorate`的函数。我们不会检查`__decorate`函数的内部实现，但我们需要了解它用于在运行时应用装饰器，因为JavaScript本身不支持装饰器语法。我们可以通过检查编译前面提到的装饰过的`Person`类时生成的JavaScript代码来看到它的实际效果：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see in the preceding code snippet, the `Person` class is declared,
    but it is then passed to the `__decorate` function. The value returned by the
    `__decorate` function is re-assigned to the `Person` class. Now that we know how
    the class decorator will be invoked, let''s implement it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`Person`类被声明，但它随后被传递给`__decorate`函数。`__decorate`函数返回的值被重新分配给`Person`类。现在我们知道了类装饰器是如何被调用的，让我们来实现它：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The class decorator takes the constructor of the class being decorated as its
    only argument. This means that the argument (named `target`) is the constructor
    of the `Person` class. The decorator starts by creating a copy of the class constructor,
    then it defines a utility function (named `instanciate`) that can be used to generate
    instances of a class. Decorators are used to add some extra logic or metadata
    to the decorated element. When we try to extend the functionality of a function
    (methods or constructors), we need to wrap the original function with a new function,
    which contains the additional logic and invokes the original function. In the
    preceding decorator, we added extra logic to log in the console, the name of the
    class when a new instance is created. To achieve this, a new class constructor
    (named `newConstructor`) was declared. The new constructor invokes a function
    named `logClassName`, which implements the additional logic and uses the `instanciate`
    function to invoke the original class constructor. At the end of the decorator,
    the prototype of the original constructor function is copied to the new constructor
    function to ensure that the `instanceof` operator continues to work when it is
    applied to an instance of the decorated class. Finally, the new constructor is
    returned, and it is used to override the original class constructor. After decorating
    the class constructor, a new instance is created:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器接受被装饰的类的构造函数作为其唯一参数。这意味着参数（命名为 `target`）是 `Person` 类的构造函数。装饰器首先创建类构造函数的副本，然后定义一个名为
    `instanciate` 的实用函数，该函数可以用于生成类的实例。装饰器用于向装饰元素添加一些额外的逻辑或元数据。当我们尝试扩展函数的功能（方法或构造函数）时，我们需要用一个新的函数包装原始函数，该函数包含额外的逻辑并调用原始函数。在前面的装饰器中，我们添加了额外的逻辑来在控制台中记录创建新实例时的类名。为此，声明了一个新的类构造函数（命名为
    `newConstructor`）。新的构造函数调用一个名为 `logClassName` 的函数，该函数实现了额外的逻辑并使用 `instanciate`
    函数调用原始类构造函数。在装饰器的末尾，将原始构造函数的原型复制到新的构造函数中，以确保当 `instanceof` 操作符应用于装饰类的实例时，它仍然可以正常工作。最后，返回新的构造函数，并使用它来覆盖原始类构造函数。在装饰类构造函数后，创建了一个新的实例：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On doing so, the following text appears in the console:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作后，以下文本将在控制台中显示：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The method decorators
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法装饰器
- en: 'The official TypeScript decorator proposal defines a method decorator as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 官方装饰器提案将方法装饰器定义为如下：
- en: '"A method decorator function is a function that accepts three arguments: The
    object that owns the property, the key for the property (a string or a symbol),
    and optionally the property descriptor of the property. The function must return
    either undefined, the provided property descriptor, or a new property descriptor.
    Returning undefined is equivalent to returning the provided property descriptor".'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '"方法装饰器函数是一个接受三个参数的函数：拥有属性的实体、属性的键（一个字符串或符号），以及可选的属性描述符。该函数必须返回 undefined、提供的属性描述符，或者一个新的属性描述符。返回
    undefined 等同于返回提供的属性描述符"。'
- en: — Ron Buckton, Decorators Proposal - TypeScript
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: — Ron Buckton，装饰器提案 - TypeScript
- en: 'The method decorator is like the class decorator, but it is used to override
    a method, as opposed to using it to override the constructor of a class. The following
    type declares the signature of a method decorator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器类似于类装饰器，但它用于覆盖方法，而不是用于覆盖类的构造函数。以下类型声明了方法装饰器的签名：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Please note that this signature is subject to change in future releases of TypeScript.
    Please refer to the `lib.d.ts` file in the TypeScript source code at [https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
    to find the current signature.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此签名可能在 TypeScript 的未来版本中发生变化。请参阅 TypeScript 源代码中的 `lib.d.ts` 文件，以找到当前的签名：[https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
- en: 'The method decorator takes as arguments the class being decorated (target),
    the name of the method being decorated, and a `TypePropertyDescriptor` of the
    property being decorated. A property descriptor is an object used to describe
    the properties of a class. A property descriptor contains the following properties:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 方法装饰器接受三个参数：被装饰的类（目标）、被装饰的方法的名称，以及被装饰属性的 `TypePropertyDescriptor`。属性描述符是一个用于描述类属性的对象。属性描述符包含以下属性：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that a property descriptor is an object that can be obtained by invoking
    the `Object.getOwnPropertyDescriptor()` method. You can learn more at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性描述符是一个可以通过调用 `Object.getOwnPropertyDescriptor()` 方法获得的对象。您可以在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)
    上了解更多信息。
- en: 'If the method decorator returns a property descriptor, the returned value will
    be used to override the property descriptor of the method. Let''s declare a method
    decorator named `logMethod` without any behavior for now:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法装饰器返回一个属性描述符，则返回的值将用于覆盖方法的属性描述符。现在让我们声明一个名为 `logMethod` 的方法装饰器，暂时不添加任何行为：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can apply the decorator to one of the methods in the `Person` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将装饰器应用于 `Person` 类中的某个方法：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we compile the preceding code snippet into JavaScript, we will be able to
    observe that the method decorator is invoked using the following arguments:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码片段编译成 JavaScript，我们将能够观察到方法装饰器使用以下参数被调用：
- en: The prototype (`Person.prototype`) of the class that contains the method being
    decorated
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含被装饰方法的类的原型（`Person.prototype`）
- en: The name of the method (`saySomething`) being decorated
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被装饰的方法的名称（`saySomething`）
- en: The property descriptor of the method being decorated is `Object.getOwnPropertyDescriptor(Person.prototype,
    saySomething)`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被装饰方法的属性描述符是 `Object.getOwnPropertyDescriptor(Person.prototype, saySomething)`
- en: 'Now that we know the value of the decorator parameters, we can proceed to implement
    it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了装饰器参数的值，我们可以继续实现它：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Just like we did when we implemented the class decorator, we start by creating
    a copy of the element being decorated. Instead of accessing the method via the
    class prototype (`target[key]`), we will access it via the property descriptor
    (`descriptor.value`). We then create a new function that will replace the method
    being decorated. The new function invokes the original method but also contains
    some additional logic used to log in the console, the method name, and the value
    of its arguments every time it is invoked. After applying the decorator to the
    method, the method name and arguments will be logged in the console when it is
    invoked:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在实现类装饰器时做的那样，我们首先创建被装饰元素的副本。而不是通过类原型（`target[key]`）访问方法，我们将通过属性描述符（`descriptor.value`）来访问它。然后我们创建一个新的函数来替换被装饰的方法。新函数调用原始方法，同时包含一些额外的逻辑，用于在每次调用时在控制台记录方法名称和其参数的值。在将装饰器应用于方法后，当方法被调用时，方法名称和参数将在控制台中被记录：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On doing so, the following text appears in the console:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做后，以下文本将出现在控制台：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The property decorators
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性装饰器
- en: 'The official TypeScript decorators proposal defines a method property as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 官方装饰器提案定义方法属性如下：
- en: 'A property decorator function is a function that accepts two arguments: The
    object that owns the property and the key for the property (a string or a symbol).
    A property decorator does not return.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 属性装饰器函数是一个接受两个参数的函数：拥有属性的对象和属性的键（一个字符串或一个符号）。属性装饰器不返回。
- en: —Ron Buckton, Decorators Proposal - TypeScript
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: —Ron Buckton, TypeScript 装饰器提案
- en: 'The following type declares the signature of a property decorator:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类型声明了属性装饰器的签名：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please note that this signature is subject to change in future releases of TypeScript.
    Please refer to the `lib.d.ts file` in the TypeScript source code at [https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
    to find the current signature.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此签名可能在 TypeScript 的未来版本中发生变化。请参阅 TypeScript 源代码中的 `lib.d.ts` 文件以获取当前签名：[https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
- en: 'A property decorator is really like a method decorator. The main differences
    are that a property decorator doesn''t return a value and that the third parameter
    (the property descriptor is missing) is not passed to the property decorator.
    Let''s create a property decorator named `logProperty` to see how it works:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 属性装饰器实际上就像方法装饰器。主要区别是属性装饰器不返回值，并且第三个参数（属性描述符缺失）不会传递给属性装饰器。让我们创建一个名为 `logProperty`
    的属性装饰器来查看它是如何工作的：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use it in one of the `Person` class''s properties as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Person` 类的属性中使用它，如下所示：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we have been doing so far, we are going to implement a decorator that will
    override the decorated property with a new property that will behave exactly as
    the original one, but will perform an additional task—logging the property value
    in the console whenever it changes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们迄今为止所做的那样，我们将实现一个装饰器，该装饰器将用一个新的属性覆盖被装饰的属性，这个新属性将表现得与原始属性完全一样，但会执行一个额外的任务——每当属性值发生变化时，在控制台中记录属性值：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding decorator, we created a copy of the original property value
    and declared two functions: `getter` (invoked when we change the value of the
    property) and `setter` (invoked when we read the value of the property) respectively.
    The method decorator returned a value used to override the element being decorated.
    Because the property decorator doesn''t return a value, we can''t override the
    property being decorated, but we can replace it. We have manually deleted the
    original property (using the `delete` keyword) and created a new property using
    the `Object.defineProperty` function and the previously declared getter and setter
    functions. After applying the decorator to the `name` property, we will be able
    to observe any changes to its value in the console:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的装饰器中，我们创建了一个原始属性值的副本，并声明了两个函数：`getter`（当改变属性的值时被调用）和`setter`（当读取属性的值时被调用）分别。方法装饰器返回一个值，用于覆盖被装饰的元素。因为属性装饰器不返回值，所以我们不能覆盖被装饰的属性，但我们可以替换它。我们手动删除了原始属性（使用`delete`关键字），并使用`Object.defineProperty`函数以及之前声明的getter和setter函数创建了一个新的属性。在将装饰器应用于`name`属性后，我们将在控制台中观察到其值的变化：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The parameter decorators
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数装饰器
- en: 'The official decorators proposal defines a parameter decorator as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的装饰器提案定义参数装饰器如下：
- en: '"A parameter decorator function is a function that accepts three arguments:
    The object that owns the method that contains the decorated parameter, the property
    key of the property (or undefined for a parameter of the constructor), and the
    ordinal index of the parameter. The return value of this decorator is ignored".'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '"参数装饰器函数是一个接受三个参数的函数：拥有包含装饰参数的方法的对象、属性键（对于构造函数的参数为`undefined`）、以及参数的序号索引。这个装饰器的返回值被忽略"。'
- en: '- Ron Buckton, Decorators Proposal - TypeScript'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '- Ron Buckton，装饰器提案 - TypeScript'
- en: 'The following type declares the signature of a parameter decorator:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类型声明了参数装饰器的签名：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Please note that this signature is subject to change in future releases of TypeScript.
    Please refer to the `lib.d.ts file` in the TypeScript source code at [https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)
    to find the current signature.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个签名在TypeScript的未来版本中可能会发生变化。请参考TypeScript源代码中的`lib.d.ts`文件以找到当前的签名：[https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts)。
- en: 'The main difference between the preceding decorators and the parameter decorators
    is that we cannot use a parameter decorator to extend the functionality of a given
    class. Let''s create a parameter decorator named `addMetadata` to see how it works:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的装饰器和参数装饰器之间的主要区别是我们不能使用参数装饰器来扩展给定类的功能。让我们创建一个名为`addMetadata`的参数装饰器来查看它是如何工作的：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can apply the parameter decorator to a parameter as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将参数装饰器应用于一个参数，如下所示：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The parameter decorator doesn''t return, which means that we will not be able
    to override the original method that takes the parameter being decorated as an
    argument. We can use parameter decorators to link some metadata to the class being
    decorated. In the following implementation, we will add an array named `log_${key}_parameters`
    as a class property, where `key` is the name of the method that contains the parameter
    being decorated:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 参数装饰器不返回值，这意味着我们无法覆盖作为参数传递给装饰器的原始方法。我们可以使用参数装饰器将一些元数据链接到被装饰的类。在下面的实现中，我们将添加一个名为`log_${key}_parameters`的数组作为类属性，其中`key`是包含被装饰参数的方法的名称：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To allow more than one parameter to be decorated, we check whether the new
    field is an array. If the new field is not an array, we create and initialize
    the new field to be a new array containing the index of the parameter being decorated.
    If the new field is an array, the index of the parameter being decorated is added
    to the array. A parameter decorator is not useful on its own; it needs to be used
    with a method decorator, so the parameter decorator adds the metadata, and the
    method decorator reads it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许装饰多个参数，我们检查新字段是否为数组。如果新字段不是数组，我们创建并初始化新字段为一个包含被装饰参数索引的新数组。如果新字段是数组，则将被装饰参数的索引添加到数组中。参数装饰器本身没有用处；它需要与方法装饰器一起使用，因此参数装饰器添加元数据，而方法装饰器读取它：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following method decorator works like the method decorator that we implemented
    previously in this chapter, but it will read the metadata added by the parameter
    decorator, and instead of displaying all the arguments passed to the method in
    the console when it is invoked, it will only log the ones that have been decorated:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法装饰器的工作方式与本章先前实现的方法装饰器类似，但它将读取参数装饰器添加的元数据，并且在方法被调用时，它不会在控制台显示传递给方法的全部参数，而只会记录那些被装饰的参数：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we apply the `saySomething` method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用`saySomething`方法：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `readMetadata` decorator will display the value of the parameters and which
    indices were added to the metadata (class property named `_log_saySomething_parameters`)
    in the console by the `addMetadata` decorator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`readMetadata`装饰器将通过`addMetadata`装饰器在控制台显示参数的值以及哪些索引被添加到元数据（类属性名为`_log_saySomething_parameters`）中：'
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that in the previous example, we used a class property to store some metadata.
    However, this is not recommended practice. Later in this chapter, you will learn
    how to use the `reflection-metadata` API; this API has been designed specifically
    to generate and read metadata, and it is, therefore, recommended to use it when
    we need to work with decorators and metadata.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的例子中，我们使用类属性来存储一些元数据。然而，这不是推荐的做法。在本章的后面部分，你将学习如何使用`reflection-metadata`
    API；这个API专门设计用来生成和读取元数据，因此，当我们需要与装饰器和元数据一起工作时，推荐使用它。
- en: Decorators with arguments
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带参数的装饰器
- en: 'We can use a special kind of decorator factory to allow developers to configure
    the behavior of a decorator. For example, we could pass a string to a class decorator
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一种特殊的装饰器工厂来允许开发者配置装饰器的行为。例如，我们可以将一个字符串传递给类装饰器，如下所示：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To be able to pass some parameters to a decorator, we need to wrap the decorator
    with a function. The wrapper function takes the options of our choice and returns
    a decorator:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够向装饰器传递一些参数，我们需要用函数包装装饰器。包装函数接受我们选择的选项，并返回一个装饰器：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This can be applied to all the kinds of decorators that you learned in this
    chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以应用于本章中学到的所有类型的装饰器。
- en: It is very important to **avoid using an arrow function as the inner function**
    to prevent potential problems with the `this` operator at runtime.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是**避免在内部函数中使用箭头函数**，以防止运行时`this`操作符可能出现的潜在问题。
- en: The reflect metadata API
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射元数据API
- en: We have learned that decorators can be used to modify and extend the behavior
    of a class's methods or properties. While this is a very good way to get to understand
    decorator in depth, **it is not recommended to use a decorator to modify and extend
    the behavior of a class**. Instead, we should try to use decorators to add metadata
    to the class being decorated. The metadata can then be consumed by other tools.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到装饰器可以用来修改和扩展类的方法或属性的行为。虽然这是一种深入了解装饰器的好方法，**但不推荐使用装饰器来修改和扩展类的行为**。相反，我们应该尝试使用装饰器向被装饰的类添加元数据。然后，其他工具可以消费这些元数据。
- en: The recommendation to avoid using a decorator to modify and extend the behavior
    of a class could be reverted in the future if the TypeScript team implements a
    future known as <q>decorator mutation</q>. You can learn more about the status
    of the decorator mutation proposal at [https://github.com/Microsoft/TypeScript/issues/4881](https://github.com/Microsoft/TypeScript/issues/4881).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果TypeScript团队实现了名为“装饰器突变”的未来功能，那么避免使用装饰器修改和扩展类行为的建议可能会在未来被推翻。你可以在[https://github.com/Microsoft/TypeScript/issues/4881](https://github.com/Microsoft/TypeScript/issues/4881)了解更多关于装饰器突变提案的状态。
- en: 'The possibility of adding metadata to a class might not seem useful or exciting,
    but in my opinion, it is one of the greatest things that has happened to JavaScript
    in the past few years. As we already know, TypeScript only uses types at design
    time. However, some features, such as dependency injection, runtime type assertions,
    reflection, and automated mocking during testing are not possible when the type
    information is not available at runtime. The lack of type information at runtime
    is not a problem anymore because we can use decorators to generate metadata and
    that metadata can contain the required type information. The metadata can then
    be processed at runtime. When the TypeScript team started to think about the best
    possible way to allow developers to generate type information metadata, they reserved
    a few special decorator names for this purpose. The idea was that when an element
    was decorated using these reserved decorators, the compiler would automatically
    add the type''s information to the element being decorated. The reserved decorators
    were the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中添加元数据的可能性可能看起来并不有用或令人兴奋，但在我看来，这是过去几年JavaScript发生的最伟大的事情之一。正如我们已知的那样，TypeScript仅在设计时使用类型。然而，当运行时没有类型信息时，一些功能，如依赖注入、运行时类型断言、反射和测试期间的自动模拟都是不可能的。运行时缺少类型信息不再是问题，因为我们可以使用装饰器来生成元数据，而这些元数据可以包含所需类型信息。然后可以在运行时处理这些元数据。当TypeScript团队开始思考允许开发者生成类型信息元数据的最佳方式时，他们为这个目的保留了几个特殊的装饰器名称。想法是，当使用这些保留的装饰器装饰元素时，编译器会自动将类型信息添加到被装饰的元素中。保留的装饰器如下：
- en: '"TypeScript compiler will honor special decorator names and will flow additional
    information into the decorator factory parameters annotated by these decorators.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '"TypeScript编译器将尊重特殊的装饰器名称，并将额外的信息流入由这些装饰器注解的装饰器工厂参数中。'
- en: '@type - The serialized form of the type of the decorator target'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '@type - 装饰器目标的类型的序列化形式'
- en: '@returnType - The serialized form of the return type of the decorator target
    if it is a function type, undefined otherwise'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '@returnType - 如果装饰器目标是函数类型，则为其返回类型的序列化形式；否则为undefined'
- en: '@parameterTypes - A list of serialized types of the decorator target''s arguments
    if it is a function type, undefined otherwise'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '@parameterTypes - 如果装饰器目标是函数类型，则为其参数的序列化类型列表；否则为undefined'
- en: '@name - The name of the decorator target  "'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '@name - 装饰器目标的名称  "'
- en: – Decorators brainstorming by Jonathan Turner
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: – Jonathan Turner的装饰器头脑风暴
- en: 'Shortly after, the team TypeScript decided to use the reflection metadata API
    (one of the proposed ES7 features) instead of the reserved decorators. The idea
    is almost identical, but instead of using the reserved decorator names, we will
    use some reserved metadata keys to retrieve the metadata using the reflection
    metadata API. The TypeScript documentation defines three reserved metadata keys:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，TypeScript团队决定使用反射元数据API（ES7提议的功能之一）而不是保留装饰器。想法几乎相同，但我们将使用一些保留的元数据键，而不是使用保留的装饰器名称，通过反射元数据API来检索元数据。TypeScript文档定义了三个保留的元数据键：
- en: '**Type metadata uses the metadata key design:type.**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型元数据使用元数据键设计：type.**'
- en: '*Parameter type metadata uses the metadata key design: paramtypes.*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数类型元数据使用元数据键设计：paramtypes.*'
- en: '*Return type metadata uses the metadata key design: returntype.*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*返回类型元数据使用元数据键设计：returntype.*'
- en: '- Issue #2577 - TypeScript Official Repository at GitHub.com'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '- Issue #2577 - TypeScript官方仓库位于GitHub.com'
- en: 'We will now learn how we to use the reflection metadata API. We need to start
    by installing the `reflect-metadata` npm module:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何使用反射元数据API。我们需要首先安装`reflect-metadata`npm模块：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We don't need to install type definitions for the `reflect-metadata` npm module
    because it includes the type definitions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为`reflect-metadata`npm模块安装类型定义，因为它包含了类型定义。
- en: 'We can then import the `reflect-metadata` npm module as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式导入`reflect-metadata`npm模块：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `reflect-metadata` module **should be imported only once in your entire
    application** because the `Reflect` object is meant to be a global singleton.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect-metadata`模块**应该在整个应用程序中只导入一次**，因为`Reflect`对象旨在成为全局单例。'
- en: 'If you try to use some of the `reflect-metadata` API from a TypeScript in which
    the `reflect-metadata` module is not imported, you will need to add the following
    option to your `tsconfig.json` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在未导入`reflect-metadata`模块的TypeScript中使用`reflect-metadata` API，你需要在你的`tsconfig.json`文件中添加以下选项：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can then create a class for testing purposes. We are going to get the type
    of one of the class properties at runtime. We are going to decorate the class
    using a `property` decorator named `logType`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个用于测试的类。我们将获取类属性之一在运行时的类型。我们将使用名为`logType`的`property`装饰器来装饰这个类：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need to invoke the `Reflect.getMetadata()` method using the `design:type`
    as the metadata key. The metadata value will be returned as a function. For example,
    for the type string, the `function String(){}` function is returned. We can use
    the `function.name` property to get the type as a string:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`design:type`作为元数据键来调用`Reflect.getMetadata()`方法。元数据值将返回为一个函数。例如，对于字符串类型，返回`function
    String(){}`函数。我们可以使用`function.name`属性来获取类型作为字符串：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we compile the preceding code and run the resulting JavaScript code in a
    web browser, we will be able to see the type of the `attr1` property in the console:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译前面的代码，并在浏览器中运行生成的JavaScript代码，我们将在控制台看到`attr1`属性的类型：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Remember that to run this example, the `reflect-metadata` library must be imported
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要运行此示例，必须按照以下方式导入`reflect-metadata`库：
- en: '`import "reflect-metadata";`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`import "reflect-metadata";`'
- en: 'We can apply the other reserved metadata keys similarly. Let''s create a method
    with many parameters to use the `design:paramtypes` reserved metadata key to retrieve
    the types of the parameters:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地应用其他保留的元数据键。让我们创建一个具有许多参数的方法，并使用`design:paramtypes`保留的元数据键来检索参数的类型：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This time, we will use the `design:paramtypes` reserved metadata key. We are
    querying the types of multiple parameters, so the types will be returned as an
    array by the `Reflect.getMetadata()` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用`design:paramtypes`保留的元数据键。我们正在查询多个参数的类型，因此`Reflect.getMetadata()`函数将返回一个数组：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we compile and run the preceding code in a web browser, we will be able
    to see the types of the parameters in the console:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中编译并运行前面的代码，我们将在控制台看到参数的类型：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The types are serialized and follow some rules. We can see that functions are
    serialized as function, and object literals (`{test : string}`) and interfaces
    are serialized as object. The following table showcases how different types are
    serialized:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '类型序列化遵循一些规则。我们可以看到函数被序列化为`function`，对象字面量（`{test : string}`）和接口被序列化为`object`。下表展示了不同类型的序列化方式：'
- en: '| **Type** | **Serialized** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **Type** | **Serialized** |'
- en: '| void | Undefined |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| void | Undefined |'
- en: '| string | String |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| string | String |'
- en: '| number | Number |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| number | Number |'
- en: '| boolean | Boolean |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| boolean | Boolean |'
- en: '| symbol | Symbol |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| symbol | Symbol |'
- en: '| any | Object |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| any | Object |'
- en: '| enum | Number |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| enum | Number |'
- en: '| Class C{} | C |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| Class C{} | C |'
- en: '| Object literal {} | Object |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Object literal {} | Object |'
- en: '| interface | Object |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| interface | Object |'
- en: Note that some developers have required the possibility of accessing the type
    of interfaces and the inheritance tree of a class via metadata. This feature is
    known as **complex type serialization** and is not available at the time of writing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些开发者要求通过元数据访问接口的类型和类的继承树。这个特性被称为**复杂类型序列化**，在撰写本文时不可用。
- en: 'To conclude, we are going to create a method with a return type and use the
    `design:returntype` reserved metadata key to retrieve the types of the return
    type:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结，我们将创建一个具有返回类型的方法，并使用`design:returntype`保留的元数据键来检索返回类型的类型：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Just like in the two previous decorators, we need to invoke the `Reflect.getMetadata()`
    function passing the `design:returntype` reserved metadata key:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在前两个装饰器中一样，我们需要调用`Reflect.getMetadata()`函数，并传递`design:returntype`保留的元数据键：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we compile and run the preceding code in a web browser, we will be able
    to see the types of the return type in the console:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中编译并运行前面的代码，我们将在控制台看到返回类型的类型：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The decorator factory
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器工厂
- en: 'The official decorators proposal defines a decorator factory as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的装饰器提案定义装饰器工厂如下：
- en: A decorator factory is a function that can accept any number of arguments, and
    must return one of the types of decorator function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器工厂是一个可以接受任意数量参数的函数，并且必须返回装饰器函数的类型之一。
- en: '- Ron Buckton, Decorators Proposal - TypeScript'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '- Ron Buckton, TypeScript 装饰器提案'
- en: 'We have learned to implement class, property, method, and parameter decorators.
    However, in most cases, we will consume decorators, not implement them. For example,
    in `InversifyJS`, we use the `@injectable` decorator to declare that a class will
    be injected into other classes, but we don''t need to implement the `@injectable`
    decorator. We can use the decorator factory to make decorators easier to consume.
    Let''s consider the following code snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了实现类、属性、方法和参数装饰器。然而，在大多数情况下，我们将消费装饰器，而不是实现它们。例如，在`InversifyJS`中，我们使用`@injectable`装饰器来声明一个类将被注入到其他类中，但我们不需要实现`@injectable`装饰器。我们可以使用装饰器工厂使装饰器更容易消费。让我们考虑以下代码片段：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The problem with the preceding code is that we, as developers, need to know
    that the `logMethod` decorator can only be applied to a method. This might seem
    trivial because the decorator name used (`logMethod`) makes it easier for us.
    A better solution is to enable developers to use a decorator named `@log` without
    having to worry about using the right kind of decorator:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的问题是我们作为开发者需要知道`logMethod`装饰器只能应用于方法。这可能会显得微不足道，因为使用的装饰器名称（`logMethod`）使得它更容易识别。更好的解决方案是允许开发者使用名为`@log`的装饰器，而无需担心使用正确的装饰器类型：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can achieve this by creating a decorator factory. A decorator factory is
    a function that can identify what kind of decorator is required and return it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个装饰器工厂来实现这一点。装饰器工厂是一个函数，它可以识别所需的装饰器类型并返回它：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we can observe in the preceding code snippet, the decorator factory is a
    factory of decorators. The generated decorator uses the number and type of arguments
    passed to the decorator to identify the required kind of decorator that is appropriate
    for each case. The decorator factory can be used to create a universal decorator
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，装饰器工厂是一个装饰器的工厂。生成的装饰器使用传递给装饰器的参数的数量和类型来识别适合每种情况的所需装饰器类型。装饰器工厂可以用来创建通用装饰器如下：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to consume and implement the four available
    types of decorators (class, method, property, and parameter). We used decorators
    to mutate the original classes to understand how they work but we also learned
    that we **should avoid using decorators to mutate the prototype of a class**.
    We also learned how to create a decorator factory to abstract developers from
    the decorator types when they are consumed, how to pass configuration to a decorator,
    and how to use the reflection metadata API to access type information at runtime.
    As we have already mentioned, decorators in TypeScript are still an experimental
    feature, which doesn't mean that they are not ready for their usage in production
    systems but that their public API might be subject to breaking changes in the
    future. Please note that the future TypeScript releases will document how to get
    around these potential breaking changes if they end up happening. In the following
    chapter, we will learn how to configure an advanced TypeScript development workflow.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何消费和实现四种可用的装饰器类型（类、方法、属性和参数）。我们使用装饰器来修改原始类以理解它们的工作原理，但也了解到我们应该**避免使用装饰器来修改类的原型**。我们还学习了如何创建装饰器工厂，以便在消费时抽象开发者对装饰器类型的关注，如何向装饰器传递配置，以及如何使用反射元数据API在运行时访问类型信息。正如我们已经提到的，TypeScript中的装饰器仍然是一个实验性特性，这并不意味着它们不适合在生产系统中使用，但它们的公共API可能在将来可能会发生破坏性变化。请注意，未来的TypeScript版本将记录如何应对这些潜在的破坏性变化，如果它们最终发生的话。在下一章中，我们将学习如何配置高级TypeScript开发工作流程。
