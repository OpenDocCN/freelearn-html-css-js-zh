- en: Chapter 4. Introducing Node.js Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：介绍Node.js模块
- en: Now that we're up to speed with the syntax of the JavaScript language, we can
    start building up our application. To do this, we need to know how to structure
    our application to allow it to grow in a maintainable way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了JavaScript语言的语法，我们可以开始构建我们的应用程序。为此，我们需要知道如何构建我们的应用程序，使其能够以可维护的方式增长。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Structuring JavaScript code with modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块结构JavaScript代码
- en: Declaring and using our own modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和使用我们自己的模块
- en: Organizing modules into files and directories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块组织到文件和目录中
- en: Implementing an Express middleware module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Express中间件模块
- en: Organizing your codebase
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织你的代码库
- en: 'Most programming platforms provide several mechanisms for structuring your
    code. Consider C#/.NET or Java: you can use classes, namespaces or packages, and
    compilation units (assemblies or JAR/WAR files). Notice the range from small-scale
    organizational units (classes) to large-scale ones (assemblies). This allows you
    to make a codebase more approachable by providing order at each level of detail.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程平台都提供了几种结构代码的机制。考虑C#/.NET或Java：你可以使用类、命名空间或包，以及编译单元（程序集或JAR/WAR文件）。注意从小规模的组织单元（类）到大规模的组织单元（程序集）的范围。这允许你通过在每个细节级别提供秩序来使代码库更易于接近。
- en: Classic browser-based JavaScript development was quite unstructured. Functions
    were the only built-in language feature for organizing your code. You could split
    your code into separate script files, but these all share the same global context
    within a web page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的基于浏览器的JavaScript开发相当无结构。函数是唯一内置的语言特性，用于组织你的代码。你可以将你的代码分割成单独的脚本文件，但这些文件都在网页的相同全局上下文中共享。
- en: 'Over time, people have developed ways of organizing JavaScript code. The standard
    approach now is to use **modules**. There are a few different module systems available
    for JavaScript, but they all work in a similar way. Each module system includes
    the following aspects:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，人们已经发展出了组织JavaScript代码的方法。现在的标准做法是使用**模块**。JavaScript有几种不同的模块系统可用，但它们的工作方式相似。每个模块系统都包括以下方面：
- en: A way of declaring a module with a name and its own scope
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种通过名称和其自己的作用域声明模块的方法
- en: A way of defining functionality provided by the module
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模块提供功能的方法
- en: A way of importing a module into another script
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块导入另一个脚本的方法
- en: In each system, when you import a module, you get a plain JavaScript object
    that you can assign to a variable. For most modules, this will be an object with
    several properties containing functions. But it could be any valid JavaScript
    object, for example, a single function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个系统中，当你导入一个模块时，你会得到一个普通的JavaScript对象，你可以将其分配给一个变量。对于大多数模块，这将是一个包含多个属性和函数的对象。但它可以是任何有效的JavaScript对象，例如，一个单独的函数。
- en: Most module systems expect or at least encourage you to define each module in
    a separate file, just as you would with classes in other languages. It is also
    common for large modules to be composed of other, smaller, modules. These would
    be grouped together under the same directory. In this way, modules act more like
    namespaces or packages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数模块系统都期望或至少鼓励你将每个模块定义在单独的文件中，就像在其他语言中使用类一样。大型模块通常由其他更小的模块组成。这些模块将组合在一起放在同一个目录下。这样，模块更像命名空间或包。
- en: The flexibility of modules means that you can use them to structure your code
    at different scales. The lack of a built-in hierarchy of organizational units
    in JavaScript provides more flexibility. It also forces you to think more about
    how you structure your code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的灵活性意味着你可以使用它们以不同的规模来结构你的代码。JavaScript中缺乏内置的组织单元层次结构提供了更多的灵活性。这也迫使你更多地思考如何结构你的代码。
- en: JavaScript module systems
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript模块系统
- en: ECMAScript 2015 introduces modules as a built-in feature of the language. They
    have been common practice for a while, though. For client-side programming, this
    practice has relied on using third-party libraries to provide a module system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015将模块作为语言的一个内置特性引入。虽然这已经是一种常见的做法，但对于客户端编程来说，这种做法一直依赖于使用第三方库来提供模块系统。
- en: You may have seen RequireJS, which provides a way of using functions to define
    modules. RequireJS uses plain JavaScript and works in any environment. It is most
    useful in the browser, where additional modules may be loaded over the Internet.
    RequireJS addresses some of the pitfalls of loading additional scripts dynamically
    and asynchronously.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过 RequireJS，它提供了一种使用函数来定义模块的方法。RequireJS 使用纯 JavaScript 并在任何环境中工作。它在浏览器中最有用，因为可以通过互联网加载额外的模块。RequireJS
    解决了动态和异步加载额外脚本的一些问题。
- en: The Node.js environment has its own module system, which we will look at in
    the rest of this chapter. It makes use of the filesystem for organizing modules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 环境有其自己的模块系统，我们将在本章的剩余部分探讨。它利用文件系统来组织模块。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might come across the terms **AMD** or **CommonJS**. These are standards
    for defining modules. RequireJS is an implementation of AMD, and Node.js modules
    follow the CommonJS standard. ECMAScript 2015 modules define a new standard with
    new `export` and `import` language keywords. The syntax is quite similar, though,
    to the Node.js module system we'll be using in this book, and it is easy to switch
    between the two.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到 **AMD** 或 **CommonJS** 这样的术语。这些是定义模块的标准。RequireJS 是 AMD 的一个实现，而 Node.js
    模块遵循 CommonJS 标准。ECMAScript 2015 模块定义了一个新的标准，具有新的 `export` 和 `import` 语言关键字。虽然语法与本书中我们将使用的
    Node.js 模块系统非常相似，但两者之间切换也很容易。
- en: Creating modules in Node.js
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Node.js 中创建模块
- en: We've actually already used several Node.js modules and created some of our
    own. Let's look again at our application from [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Getting Started with Node.js"), *Getting Started with Node.js*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上已经使用了一些 Node.js 模块并创建了一些自己的。让我们再次从 [第 2 章](part0018.xhtml#aid-H5A41 "第
    2 章。Node.js 入门")，*Node.js 入门*，回顾我们的应用程序。
- en: 'The following code is from `routes/index.js and routes/users.js`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `routes/index.js` 和 `routes/users.js`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the code from `app.js`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 `app.js` 的代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each of our routes (index and users) is a module. They expose their functionality
    using the built-in `module` object, which is defined by Node.js as a variable
    scoped to each module. In the preceding example, the object provided by each of
    our route modules is an Express router instance. The `app.js` script imports these
    modules using the built-in `require` function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个路由（index 和 users）都是一个模块。它们通过 Node.js 定义的内置 `module` 对象暴露其功能，该对象是每个模块的变量作用域。在前面的例子中，我们每个路由模块提供的对象是一个
    Express 路由实例。`app.js` 脚本使用内置的 `require` 函数导入这些模块。
- en: Observe that `app.js` also imports various `npm` packages using `require`. Note
    that it uses file paths to reference our own modules, whereas `npm` modules are
    referenced by name.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `app.js` 也使用 `require` 导入了各种 `npm` 包。请注意，它使用文件路径来引用我们自己的模块，而 `npm` 模块则通过名称引用。
- en: Let's look at how Node.js modules satisfy the three aspects of JavaScript module
    functionality.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Node.js 模块是如何满足 JavaScript 模块功能的三个方面的。
- en: Declaring a module with a name and its own scope
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个具有名称和自身作用域的模块
- en: In Node.js, each separate JavaScript file is automatically treated as a new
    module. Unlike scripts loaded into a web page, each file has its own scope. The
    name of the module is the name of the file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中，每个独立的 JavaScript 文件自动被视为一个新的模块。与加载到网页中的脚本不同，每个文件都有自己的作用域。模块的名称是文件的名称。
- en: Defining functionality provided by the module
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模块提供的功能
- en: 'Node.js provides two built-in variables for exporting functionality from a
    module. These are `module.exports` and `exports`. `module.exports` is initialized
    to an empty object. `exports` is just a reference to `module.exports`. It is equivalent
    to the following appearing before your script:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 为从模块中导出功能提供了两个内置变量。这些是 `module.exports` 和 `exports`。`module.exports`
    被初始化为一个空对象。`exports` 只是 `module.exports` 的引用。它等同于以下内容出现在你的脚本之前：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Whatever is contained in the `module.exports` variable at the end of your script
    is the exported value of your module. This will be returned whenever your module
    is imported elsewhere. The following are all equivalent:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的脚本末尾包含在 `module.exports` 变量中的任何内容都是你模块的导出值。当你的模块在其他地方导入时，这将返回。以下都是等效的：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that the following is *not* the same as the previous examples. It just
    reassigns `exports`, but doesn''t alter `module.exports` at all:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下内容与之前的示例不同。它只是重新分配了 `exports`，但完全没有改变 `module.exports`：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Importing a module into another script
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模块导入到另一个脚本中
- en: 'Node.js provides another built-in variable for importing modules. This is the
    `require` function we saw in `app.js` earlier in the chapter. This function is
    provided by Node.js and always available. It takes a single argument, which is
    the name or path of the module you want to import. The following excerpts from
    `app.js` demonstrate loading a third-party module by name and one of our own modules
    by a file path:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 提供了另一个用于导入模块的内置变量。这就是我们在本章前面 `app.js` 中看到的 `require` 函数。这个函数由 Node.js
    提供，始终可用。它接受一个参数，即你想要导入的模块的名称或路径。以下是从 `app.js` 中摘录的内容，展示了如何通过名称加载第三方模块，以及通过文件路径加载我们自己的模块：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we don't need to specify the `.js` file extension for our own module.
    Node.js will automatically add this for us.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为我们的模块指定 `.js` 文件扩展名。Node.js 会自动为我们添加这个扩展名。
- en: Defining a directory-level module
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义目录级模块
- en: As mentioned at the beginning of this chapter, modules can also act more like
    namespaces. We can treat a whole directory as a module, consisting of smaller
    modules in individual files. The simplest way to do this is to create an `index.js`
    file in the directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，模块也可以更像命名空间。我们可以将整个目录视为一个模块，由单个文件中的较小模块组成。最简单的方法是在目录中创建一个 `index.js`
    文件。
- en: When calling `require('./directoryName')`, Node.js will attempt to load a file
    named `'./directoryName/index.js'` (relative to the current script). There is
    nothing special about `index.js` itself. This is just another script file that
    exposes an entry point to the module. If `directoryName` contains a `package.json`
    file, Node.js will load this file first and see if it specifies a `main` script,
    in which case Node.js will load this script instead of looking for `index.js`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `require('./directoryName')` 时，Node.js 将尝试加载一个名为 `'./directoryName/index.js'`
    的文件（相对于当前脚本）。`index.js` 本身并没有什么特殊之处。这只是一个暴露模块入口点的另一个脚本文件。如果 `directoryName` 包含一个
    `package.json` 文件，Node.js 将首先加载这个文件，并查看是否指定了一个 `main` 脚本，在这种情况下，Node.js 将加载这个脚本而不是寻找
    `index.js`。
- en: To import local modules, we use a file or directory path, that is, something
    starting with `'/'`, `'../'`, or `'./'` as in the preceding example. If we call
    `require` with a plain string, Node.js treats it as relative to the `node_modules`
    folder. The `npm` packages are just directory-level modules under this folder.
    We will look at defining our own `npm` packages in more detail in a later chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入本地模块，我们使用文件或目录路径，即以 `'/'`、`'../'` 或 `'./'` 开头，就像前面的例子一样。如果我们用纯字符串调用 `require`，Node.js
    会将其视为相对于 `node_modules` 文件夹。`npm` 包只是这个文件夹下的目录级模块。我们将在后面的章节中更详细地探讨定义我们自己的 `npm`
    包。
- en: Implementing an Express middleware module
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个 Express 中间件模块
- en: Let's return to the Node.js application we started in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Getting Started with Node.js"), *Getting Started with Node.js*. We're
    going to write an application where users can set puzzles for one another. First
    of all, we'll need a way of identifying the current user. We'll need to do this
    on most requests, making it a cross-cutting concern. This is a good use case for
    middleware.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们在 [第 2 章](part0018.xhtml#aid-H5A41 "第 2 章。Node.js 入门") 中开始的 Node.js 应用程序，*Node.js
    入门*。我们将编写一个应用程序，用户可以为彼此设置谜题。首先，我们需要一种识别当前用户的方法。我们将在大多数请求中这样做，使其成为一个跨领域关注点。这是一个中间件的好用例。
- en: For now, we will implement users in the simplest way possible, just storing
    an ID in a cookie. We will look into more robust identification in a later chapter.
    Note, however, that our use of middleware means it will be easy to alter our approach
    later on. This concern is encapsulated in our user middleware, so we only need
    to change it in one place.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以最简单的方式实现用户，只需在 cookie 中存储一个 ID。我们将在后面的章节中探讨更健壮的识别方法。然而，请注意，我们使用中间件意味着我们可以很容易地稍后更改我们的方法。这个关注点封装在我们的用户中间件中，所以我们只需要在一个地方更改它。
- en: 'First, we need a way of generating unique IDs. For this, we will use the UUID
    module from npm. We can add this to our project by running the following on the
    command line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种生成唯一 ID 的方法。为此，我们将使用 npm 中的 UUID 模块。我们可以在命令行上运行以下命令将其添加到我们的项目中：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `--save` flag stores the name of this module in our `package.json` file
    so that it will be installed automatically by `npm install`. This is useful for
    restoring our application from a clean checkout of the source code (recall that
    people commonly exclude the `node_modules` directory from source control, precisely
    because it can easily be restored in this way).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`--save` 标志将此模块的名称存储在我们的 `package.json` 文件中，以便它可以通过 `npm install` 自动安装。这对于从源代码的干净检出中恢复我们的应用程序非常有用（回想一下，人们通常会将
    `node_modules` 目录排除在源代码控制之外，正是因为它可以通过这种方式轻松恢复）。'
- en: 'Now we are ready to create our middleware, which will place under `middleware/users.js`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建我们的中间件，它将被放置在 `middleware/users.js` 下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that we use the ES2015 `const` keyword for the `uuid` module because
    this reference never changes. But we use the `let` keyword for the `userId` variable
    because this can be reassigned. Also notice that we call `next()` rather than
    returning a response, so the next middleware can continue processing the request.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 ES2015 的 `const` 关键字来引用 `uuid` 模块，因为这个引用永远不会改变。但我们使用 `let` 关键字来引用 `userId`
    变量，因为这个变量可以被重新赋值。另外，注意我们调用 `next()` 而不是返回响应，这样下一个中间件就可以继续处理请求。
- en: 'Finally, we need to add this middleware to our application in `app.js`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将此中间件添加到我们的应用程序中的 `app.js` 文件：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that this replaces the import and usage of the `./routes/users` module
    that was generated for us. This route wasn't particularly useful, but we will
    add more routes soon.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这替换了为我们生成的 `./routes/users` 模块的导入和使用。这个路由并不特别有用，但我们很快就会添加更多路由。
- en: 'We can check that our middleware works by altering our index route and view
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改我们的索引路由和视图来检查我们的中间件是否工作：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is the code `views/index.hjs`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `views/index.hjs` 的代码：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Launch the application and visit `http://localhost:3000/`. You should see a
    randomly-generated user ID. Refresh the page and you should retain the same ID.
    Open the site in a different browser (or an incognito/private browsing window).
    This separate browser session should see a different ID.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并访问 `http://localhost:3000/`。你应该看到一个随机生成的用户 ID。刷新页面，你应该保留相同的 ID。在不同的浏览器（或隐身/私密浏览窗口）中打开网站。这个单独的浏览器会话应该看到不同的
    ID。
- en: Summary
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to use Node.js modules to structure our codebase,
    and how to create an Express middleware module to implement cross-cutting concerns.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 Node.js 模块来结构化我们的代码库，以及如何创建一个 Express 中间件模块来实现跨切面关注点。
- en: Now that we have a way of structuring our codebase and a means of identifying
    users, we can get on with implementing our application's functionality. In the
    next chapter, we'll start adding some interactivity to our application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了结构化我们的代码库的方法和识别用户的方法，我们可以继续实现我们应用程序的功能。在下一章中，我们将开始向我们的应用程序添加一些交互性。
