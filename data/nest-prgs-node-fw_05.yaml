- en: Chapter 5\. TypeORM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。TypeORM
- en: Almost every time you use Nest.js in the real world, you need some kind of persistence
    for your data. That is, you need to save the data that the Nest.js app receives
    somewhere, and you need to read data from somewhere so that you can then pass
    that data as a response to the requests that the Nest.js app receives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每次在现实世界中使用Nest.js时，您都需要某种持久性来保存数据。也就是说，您需要将Nest.js应用程序接收到的数据保存在某个地方，并且您需要从某个地方读取数据，以便随后将该数据作为响应传递给Nest.js应用程序接收到的请求。
- en: That “somewhere” will be, most of the time, a database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，“某个地方”将是一个数据库。
- en: TypeORM is a Object Relational Mapping (ORM) that works with several different
    relational databases. An Object Relational Mapping is a tool that converts between
    objects (such as “Entry” or “Comment,” since we’re building a blog) and tables
    in a database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM是一个与多种不同关系数据库一起工作的对象关系映射（ORM）。对象关系映射是一个工具，用于在对象（例如“Entry”或“Comment”，因为我们正在构建一个博客）和数据库中的表之间进行转换。
- en: The result of this conversion is an entity (called Data Transfer Object) that
    knows how to read data from the database to memory (so you can use the data as
    a response for a request,) as well as how to write to the database from memory
    (so that you are able to store data for later).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换的结果是一个实体（称为数据传输对象），它知道如何从数据库中读取数据到内存（这样您就可以将数据作为请求的响应使用），以及如何从内存写入数据库（这样您就能够存储数据以备后用）。
- en: TypeORM is conceptually similar to Sequelize. TypeORM is also written in TypeScript
    and uses decorators extensively, so it’s a great match for Nest.js projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM在概念上类似于Sequelize。TypeORM也是用TypeScript编写的，并且广泛使用装饰器，因此它非常适合Nest.js项目。
- en: We will obviously focus on using TypeORM together with Nest.js, but TypeORM
    can also be used in both the browser and the server side, with traditional JavaScript
    as well as TypeScript.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然将专注于将TypeORM与Nest.js一起使用，但TypeORM也可以在浏览器和服务器端使用，使用传统的JavaScript以及TypeScript。
- en: TypeORM allows you to use both the data mapper pattern, as well as the active
    record pattern. We will focus on the active record pattern as it greatly reduces
    the amount of boilerplate code needed to use in the context of a typical Nest.js
    architecture, like the one explained throughout the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM允许您同时使用数据映射器模式和活动记录模式。我们将专注于活动记录模式，因为它大大减少了在典型Nest.js架构上使用所需的样板代码量，就像本书中所解释的那样。
- en: TypeORM can also work with MongoDB, though in this case using a dedicated NoSQL
    ORM such as Mongoose is a more common approach.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM也可以与MongoDB一起工作，不过在这种情况下，使用专门的NoSQL ORM，如Mongoose，是更常见的方法。
- en: What database to use
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用哪种数据库
- en: 'TypeORM supports the following databases:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM支持以下数据库：
- en: MySQL
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: MariaDB
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MariaDB
- en: PostgreSQL
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: MS SQL Server
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MS SQL Server
- en: sql.js
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sql.js
- en: MongoDB
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: Oracle (experimental)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle（实验性）
- en: Considering that in this book we are already using PostgreSQL with Sequelize
    and MongoDB with Mongoose, we decided to use MariaDB with TypeORM.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑到在本书中我们已经使用Sequelize和Mongoose分别使用PostgreSQL和MongoDB，我们决定使用TypeORM与MariaDB。 '
- en: About MariaDB
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于MariaDB
- en: MariaDB is an open source, community-driven project led by some of the original
    developers of MySQL. It was forked from MySQL when Oracle acquired the latter
    with the intention of keeping it free and open under the GNU General Public License.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB是一个由MySQL的一些原始开发人员领导的开源、社区驱动的项目。它是从Oracle收购后保持其自由和开放性的GNU通用公共许可证下的MySQL分支。
- en: The original idea of the project was to act as a drop-in replacement for MySQL.
    This remains largely true for version up to 5.5, while MariaDB kept its version
    numbers in sync with the MySQL ones.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的最初想法是作为MySQL的一个可替代品。这在5.5版本之前基本上是正确的，而MariaDB保持了与MySQL相同的版本号。
- en: Nevertheless, newer versions, starting with versions 10.0, have slightly diverted
    from this approach. It’s still true, though, that MariaDB still focuses on being
    highly compatible with MySQL and sharing the same API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，从10.0版本开始，较新的版本略微偏离了这种方法。不过，MariaDB仍然专注于与MySQL高度兼容，并共享相同的API。
- en: Getting started
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: TypeORM is of course distributed as an npm package. You need to run `npm install
    typeorm @nestjs/typeorm`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，TypeORM作为一个npm包进行分发。您需要运行`npm install typeorm @nestjs/typeorm`。
- en: You also need a TypeORM database driver; in this case, we will install the MySQL/MariaDB
    one with `npm install mysql`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个TypeORM数据库驱动程序；在这种情况下，我们将使用`npm install mysql`安装MySQL/MariaDB。
- en: TypeORM depends on `reflect-metadata` as well, but luckily we had it previously
    installed as Nest.js depends on it too, so there’s nothing else for us to do.
    Keep in mind that you will need to install this dependency too if you’re using
    TypeORM outside of a Nest.js context.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM还依赖于`reflect-metadata`，但幸运的是，我们之前已经安装了它，因为Nest.js也依赖于它，所以我们无需做其他事情。请记住，如果您在Nest.js上下文之外使用TypeORM，您还需要安装这个依赖。
- en: '**NOTE:** If you haven’t yet, it’s always a good idea to install Node.js: `npm
    install --save-dev @types/node`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 如果您还没有安装Node.js，现在安装是一个好主意：`npm install --save-dev @types/node`。'
- en: Start the database
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动数据库
- en: In order to get a database to connect to, we will use Docker Compose, with the
    official MariaDB Docker image, to set up our local development environment. We
    will point to the `latest` Docker image tag, which at the time of writing, corresponds
    to version 10.2.14.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到数据库，我们将使用Docker Compose，使用官方的MariaDB Docker镜像来设置我们的本地开发环境。我们将指向`latest`
    Docker镜像标签，这在撰写本文时对应于版本10.2.14。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Connect to the database
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Now that we have a database to connect TypeORM, let’s configure the connection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个连接TypeORM的数据库，让我们配置连接。
- en: We have several ways of configuring TypeORM. The most straightforward one, which
    is great for getting started, is creating a `ormconfig.json` file in the project
    root folder. This file will get grabbed automagically by TypeORM on startup.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种配置TypeORM的方式。最直接的一种是在项目根文件夹中创建一个`ormconfig.json`文件，这对于入门非常有用。这个文件将在启动时被TypeORM自动抓取。
- en: Here is an example configuration file that suits our usecase (i.e. using Docker
    Compose with the configuration previously proposed).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个适合我们用例的示例配置文件（即使用Docker Compose与之前提出的配置）。
- en: '**ormconfig.json**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**ormconfig.json**'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some notes on the configuration file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置文件的一些说明：
- en: The properties `host`, `port`, `username`, `password` and `database` need to
    match the ones specified earlier in the `docker-compose.yml` file; otherwise,
    TypeORM will not be able to connect to the MariaDB Docker image.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性`host`、`port`、`username`、`password`和`database`需要与`docker-compose.yml`文件中之前指定的属性匹配；否则，TypeORM将无法连接到MariaDB
    Docker镜像。
- en: The `synchronize` property tells TypeORM whether to create or update the database
    schema whenever the application starts, so that the schemas match the entities
    declared in the code. Setting this property to `true` can easily lead to loss
    of data, so **make sure you know what you’re doing** before enabling this property
    in production environments.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronize`属性告诉TypeORM在应用程序启动时是否创建或更新数据库模式，以便模式与代码中声明的实体匹配。将此属性设置为`true`很容易导致数据丢失，所以**在启用此属性之前，请确保你知道你在做什么**。'
- en: Initialize TypeORM
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化TypeORM
- en: Now that the database is running and you are able to successfully establish
    a connection between it and our Nest.js app, we need to instruct Nest.js to use
    TypeORM as a module.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据库正在运行，并且你能够成功地建立起它与我们的Nest.js应用之间的连接，我们需要指示Nest.js使用TypeORM作为一个模块。
- en: Thanks to the `@nest/typeorm` package we previously installed, using TypeORM
    inside our Nest.js application is as easy as importing the `TypeOrmModule` in
    our main app module (probably the `app.module.ts` file.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前安装的`@nest/typeorm`包，所以在我们的Nest.js应用程序中使用TypeORM就像在主应用程序模块（可能是`app.module.ts`文件）中导入`TypeOrmModule`一样简单。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Modelling our data
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模我们的数据
- en: 'Probably the best thing about using an ORM is that you can take advantage of
    the modelling abstraction that they provide: basically, they allow us to think
    about our data and to shape it with properties (including types and relations),
    generating “object types” (and plugging them to databases tables) that we can
    then use and manipulate as direct interfaces.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM最好的一点可能是，你可以利用它们提供的建模抽象：基本上，它们允许我们思考我们的数据，并用属性（包括类型和关系）来塑造它，生成我们可以直接使用和操作的“对象类型”（并将它们连接到数据库表）。
- en: This abstraction layer saves you from writing database-specific code like queries,
    joins, etc. A lot of people love not having to struggle with selects and the like;
    so this abstraction layer comes in handy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象层可以让你摆脱编写特定于数据库的代码，比如查询、连接等。很多人喜欢不必为选择和类似的事情而苦苦挣扎；所以这个抽象层非常方便。
- en: Our first entity
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个实体
- en: When working with TypeORM, this object abstractions are named *entities.*
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用TypeORM时，这些对象抽象被称为*实体*。
- en: An entity is basically a class that is mapped to a database table.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实体基本上是映射到数据库表的类。
- en: With that said, let’s create our first entity, which we will name `Entry`. We
    will use this entity to store entries (posts) for our blog. We will create a new
    file at `src/entries/entry.entity.ts`; that way TypeORM will be able to find this
    entity file since earlier in our configuration we specified that entity files
    will follow the `src/**/*.entity.ts` file naming convention.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们创建我们的第一个实体，我们将其命名为`Entry`。我们将使用这个实体来存储博客的条目（帖子）。我们将在`src/entries/entry.entity.ts`创建一个新文件；这样TypeORM就能够找到这个实体文件，因为在我们的配置中我们指定了实体文件将遵循`src/**/*.entity.ts`文件命名约定。
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `@Entity()` decorator from the `typeorm` npm package is used to mark the
    `Entry` class as an entity. This way, TypeORM will know that it needs to create
    a table in our database for these kinds of objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity()`装饰器来自`typeorm` npm包，用于标记`Entry`类为一个实体。这样，TypeORM就会知道它需要在我们的数据库中为这种对象创建一个表。'
- en: 'The `Entry` entity is still a bit too simple: we haven’t defined a single property
    for it. We will probably need things like a title, a body, an image and a date
    for our blog entries, right? Let’s do it!'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entry`实体还有点太简单了：我们还没有为它定义一个属性。我们可能需要像标题、正文、图片和日期这样的东西来记录博客条目，对吧？让我们来做吧！'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Not bad! Each property we define for our entity is marked with a `@Column`
    decorator. Again, this decorator tells TypeORM how to treat the property: in this
    case, we are asking for each property to be stored in a column of the database.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！我们为实体定义的每个属性都标有`@Column`装饰器。再次，这个装饰器告诉TypeORM如何处理属性：在这种情况下，我们要求每个属性都存储在数据库的一列中。
- en: Sadly, this entity will not work with this code. This is because each entity
    needs to have at least one primary column, and we didn’t mark any column as such.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，这个实体将无法使用这段代码。这是因为每个实体都需要至少一个主列，而我们没有将任何列标记为主列。
- en: Our best bet is to create an `id` property for each entry and store that on
    a primary column.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最好为每个条目创建一个`id`属性，并将其存储在主列上。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ah, that’s better! Our first entity is working now. Let’s use it!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，好多了！我们的第一个实体现在可以工作了。让我们来使用它！
- en: Using our models
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的模型
- en: When having to connect requests to data models, the typical approach in Nest.js
    is building dedicated services, which serve as the “touch point” with each model,
    and to build controllers, which link the services to the requests reaching the
    API. Let’s follow the `model -> service -> controller` approach in the following
    steps.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将请求连接到数据模型时，在Nest.js中的典型方法是构建专门的服务，这些服务作为与每个模型的“接触点”，并构建控制器，将服务与到达API的请求连接起来。让我们在以下步骤中遵循`模型
    -> 服务 -> 控制器`的方法。
- en: The service
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: In a typical Nest.js architecture, the application heavy-lifting is done by
    the services. In order to follow this pattern, create a new `EntriesService`,
    using it to interact with the `Entry` entity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Nest.js架构中，应用程序的重要工作是由服务完成的。为了遵循这种模式，创建一个新的`EntriesService`，用它来与`Entry`实体交互。
- en: 'So, let’s create a new file at: **`src/entries/entries.service.ts`**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们在这里创建一个新文件：**`src/entries/entries.service.ts`**
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The most important part of the service is creating a TypeORM repository with
    `Repository<Entry>`, and then injecting it in our constructor with `@InjectRepository(Entry)`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的最重要部分是使用`Repository<Entry>`创建TypeORM存储库，然后在构造函数中使用`@InjectRepository(Entry)`进行注入。
- en: By the way, in case you’re wondering, repositories are probably the most commonly
    used design pattern when dealing with ORMs, because they allow you to abstract
    the database operations as object collections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你在想，当处理ORM时，存储库可能是最常用的设计模式，因为它允许你将数据库操作抽象为对象集合。
- en: Coming back to the latest service code, once you have created and injected the
    Entry repository, use it to `.find()` and `.save()` entries from the database,
    among other things. These helpful methods are added when we create a repository
    for the entity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回到最新的服务代码，一旦你创建并注入了Entry存储库，就可以使用它从数据库中`.find()`和`.save()`条目，以及其他操作。当我们为实体创建存储库时，这些有用的方法会被添加进来。
- en: 'Now that we have taken care of both the data model and the service, let’s write
    the code for the last link: the controller.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经处理了数据模型和服务，现在让我们为最后一个链接编写代码：控制器。
- en: The controller
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: Let’s create a controller for exposing the Entry model to the outside world
    through a RESTful API. The code is really simple, as you can see.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为Entry模型创建一个控制器，通过RESTful API将其暴露给外部世界。代码非常简单，你可以看到。
- en: 'Go ahead and create a new file at: **`src/entries/entries.controller.ts`**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 继续，在以下位置创建一个新文件：**`src/entries/entries.controller.ts`**
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As usual, we are using Nest.js dependency injection to make the `EntryService`
    available in our `EntryController`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们使用Nest.js依赖注入使`EntryService`在`EntryController`中可用。
- en: Building a new module
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个新的模块
- en: The last step for our new entity endpoint to work is to include the entity,
    the service, and the controller in the app module. Instead of doing this directly,
    we will follow the “separated modules” approach and create a new module for our
    entries, importing all of the necessary pieces there and then importing the whole
    module in the app module.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新实体端点工作的最后一步是在应用模块中包含实体、服务和控制器。我们不会直接这样做，而是遵循“分离模块”的方法，为我们的条目创建一个新模块，在那里导入所有必要的部分，然后在应用模块中导入整个模块。
- en: 'So, let’s create a new file named: **`src/entries/entries.module.ts`**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个名为：**`src/entries/entries.module.ts`**的新文件。
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Remember when we included the `TypeOrmModule` in the `AppModule` as one of
    the first steps of this chapter? We used the `TypeOrmModule.forRoot()` formula
    there. However, we are using a different one here: `TypeOrmModule.forFeature()`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得当我们在本章的最初步骤中在`AppModule`中包含了`TypeOrmModule`吗？我们在那里使用了`TypeOrmModule.forRoot()`公式。然而，在这里我们使用了不同的公式：`TypeOrmModule.forFeature()`。
- en: This distinction coming from the Nest.js TypeORM implementation allows us to
    separate different functionalities (“features”) in different modules. This way
    you can adapt your code to some of the ideas and best practices exposed in the
    Architecture chapter of this book.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Nest.js TypeORM实现中的这种区别允许我们在不同的模块中分离不同的功能（“特性”）。这样你就可以根据本书的架构章节中提出的一些想法和最佳实践来调整你的代码。
- en: Anyway, let’s import the new `EntriesModule` into the `AppModule`. If you neglect
    this step, your main app module won’t be aware of the existence of the `EntriesModule`
    and your app will not work as intended.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们将新的`EntriesModule`导入到`AppModule`中。如果忽略了这一步，你的主应用模块将不会意识到`EntriesModule`的存在，你的应用将无法正常工作。
- en: '**`src/app.module.ts`**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/app.module.ts`**'
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s it! Now you can fire requests to `/entities` and the endpoint will invoke
    writes and reads from the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在你可以向`/entities`发送请求，端点将调用数据库的写入和读取操作。
- en: It’s time to give our database a try! We will fire some requests to the endpoints
    that we previously linked to the database and see if everything works as expected.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候让我们的数据库试试了！我们将向之前链接到数据库的端点发送一些请求，看看是否一切都按预期工作。
- en: We will start with a GET request to the `/entries` endpoint. Obviously, since
    we haven’t created any entries yet, we should receive an empty array as a response.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向`/entries`端点发送GET请求开始。显然，由于我们还没有创建任何条目，我们应该收到一个空数组作为响应。
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s create a new entry.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的条目。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Success! Let’s retrieve the new entry by ID.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！让我们通过ID检索新条目。
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Yes! Our previous POST request triggered a write in the database and now this
    last GET request is triggering a read from the database, and returning the data
    previously saved!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们之前的POST请求触发了数据库中的写入，现在这个最后的GET请求触发了对数据库的读取，并返回先前保存的数据！
- en: Let’s try to retrieve all entries once again.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次尝试检索所有条目。
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We just confirmed that requests to the `/entries` endpoint successfully executed
    reads and writes in our database. This means that our Nest.js app is usable now,
    since the basic functionality of almost any server application (that is, storing
    data and retrieving it on demand) is working properly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚确认，对`/entries`端点的请求成功执行了数据库的读写操作。这意味着我们的Nest.js应用现在可以使用，因为几乎任何服务器应用程序的基本功能（即存储数据并根据需要检索数据）都正常工作。
- en: Improving our models
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们的模型
- en: Even though we are now reading from and writing to the database through our
    entity, we only wrote a basic, initial implementation; we should review our code
    to see what can be improved.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在通过实体从数据库中读取和写入数据，但我们只编写了一个基本的初始实现；我们应该审查我们的代码，看看有什么可以改进的地方。
- en: Let’s now go back to the entity file, `src/entries/entry.entity.ts`, and figure
    out what kind of improvements we can do there.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到实体文件`src/entries/entry.entity.ts`，看看我们可以做出什么样的改进。
- en: Auto-generated IDs
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成的ID
- en: All of the database entries need to have a unique ID. At this point, we are
    simply relying on the ID sent by the client when creating the entity (when sending
    the POST request,) but this is less than desirable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的数据库条目都需要有一个唯一的ID。目前，我们只是依赖于客户端在创建实体时（发送POST请求时）发送的ID，但这并不理想。
- en: Any server-side application will be connected to multiple clients, and all of
    those clients have no way of knowing which ID’s are already in use, so it would
    be impossible for them to generate and send a unique ID with each POST request.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 任何服务器端应用程序都将连接到多个客户端，所有这些客户端都无法知道哪些ID已经在使用，因此他们无法生成并发送每个POST请求的唯一ID。
- en: TypeORM provides a couple of ways of generating unique ID’s for entities. The
    first one is using the `@PrimaryGeneratedColumn()` decorator. By using it, you
    no longer need to include an ID in the body of the POST request, nor do you need
    to manually generate an ID for an entry before saving it. Instead, the ID is automagically
    generated by TypeORM whenever you ask for a new entry to be saved to the database.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM提供了几种为实体生成唯一ID的方法。第一种是使用`@PrimaryGeneratedColumn()`装饰器。通过使用它，您不再需要在POST请求的主体中包含ID，也不需要在保存条目之前手动生成ID。相反，每当您要求将新条目保存到数据库时，TypeORM会自动为其生成ID。
- en: 'Our code looks something like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码看起来像下面这样：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It’s worth mentioning that these unique ID’s will be generated in a sequential
    way, which means that each ID will be one number higher than the highest already
    present in the database (the exact method for generating the new ID will depend
    on the database type.)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，这些唯一的ID将以顺序方式生成，这意味着每个ID将比数据库中已有的最高ID高一个数字（生成新ID的确切方法将取决于数据库类型）。
- en: 'TypeORM can go one step further, though: if you pass the `"uuid"` argument
    to the `@PrimaryGeneratedColumn()` decorator, the generated value will then look
    like a random collection of letters and numbers with some dashes, making sure
    they’re unique (at least *reasonably* unique.)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM还可以更进一步：如果将`"uuid"`参数传递给`@PrimaryGeneratedColumn()`装饰器，生成的值将看起来像一串随机的字母和数字，带有一些破折号，确保它们是唯一的（至少*相对*唯一）。
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Also, remember to change the type of `id` from `number` to `string`!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记得将`id`的类型从`number`更改为`string`！
- en: When was the entry created?
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条目是何时创建的？
- en: In the original entity definition, the `created_at` field was also expected
    to be received from the client. We can, however, improve this easily with some
    more TypeORM magic decorators.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始实体定义中，还预期从客户端接收`created_at`字段。然而，我们可以通过一些更多的TypeORM魔术装饰器轻松改进这一点。
- en: Let’s use the `@CreateDateColumn()` decorator to dynamically generate the insertion
    date for each entry. In other words, you don’t need to set the date from the client
    or create it manually before saving the entry.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`@CreateDateColumn()`装饰器为每个条目动态生成插入日期。换句话说，您不需要在保存条目之前从客户端设置日期或手动创建日期。
- en: 'Let’s update the entity:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新实体：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Nice, isn’t it? How about knowing also when the entry was last modified, as
    well as how many revisions have been done to it? Again, TypeORM makes both easy
    to do, and requires no additional code on our side.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，是吗？还想知道条目上次修改是什么时候，以及对其进行了多少次修订？同样，TypeORM使这两者都很容易实现，并且不需要我们额外的代码。
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our entity will now automagically handle for us the modification date, as well
    as the revision number, on each subsequent save operations. You can track changes
    made to each instance of the entity without having to implement a single line
    of code!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实体现在将自动为我们处理修改日期，以及每次保存操作时的修订号。您可以跟踪对实体的每个实例所做的更改，而无需实现一行代码！
- en: Column types
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列类型
- en: When defining columns in our entities using decorators, as exposed above, TypeORM
    will infer the type of database column from the used property type. This basically
    means that when TypeORM finds a line like the following
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实体中使用装饰器定义列时，如上所述，TypeORM将从使用的属性类型推断数据库列的类型。这基本上意味着当TypeORM找到以下行时
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This maps the `string` property type to a `varchar` database column type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`string`属性类型映射到`varchar`数据库列类型。
- en: This will work just fine a lot of the time, but in some occasions we might find
    ourselves in the position of being more explicit about the type of columns to
    be created in the database. Fortunately, TypeORM allows this kind of custom behavior
    with very little overhead.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会很好地工作，但在某些情况下，我们可能需要更明确地指定要在数据库中创建的列的类型。幸运的是，TypeORM允许使用非常少的开销来实现这种自定义行为。
- en: 'To customize the column type, pass the desired type as a string argument to
    the `@Column()` decorator. A specific example would be:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义列类型，请将所需类型作为字符串参数传递给`@Column()`装饰器。一个具体的例子是：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The exact column types that can be used depend on the type of database you are
    using.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的确切列类型取决于您使用的数据库类型。
- en: Column types for `mysql` / `mariadb`
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`mysql` / `mariadb`的列类型'
- en: '`int`, `tinyint`, `smallint`, `mediumint`, `bigint`, `float`, `double`, `dec`,
    `decimal`, `numeric`, `date`, `datetime`, `timestamp`, `time`, `year`, `char`,
    `varchar`, `nvarchar`, `text`, `tinytext`, `mediumtext`, `blob`, `longtext`, `tinyblob`,
    `mediumblob`, `longblob`, `enum`, `json`, `binary`, `geometry`, `point`, `linestring`,
    `polygon`, `multipoint`, `multilinestring`, `multipolygon`, `geometrycollection`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`、`tinyint`、`smallint`、`mediumint`、`bigint`、`float`、`double`、`dec`、`decimal`、`numeric`、`date`、`datetime`、`timestamp`、`time`、`year`、`char`、`varchar`、`nvarchar`、`text`、`tinytext`、`mediumtext`、`blob`、`longtext`、`tinyblob`、`mediumblob`、`longblob`、`enum`、`json`、`binary`、`geometry`、`point`、`linestring`、`polygon`、`multipoint`、`multilinestring`、`multipolygon`、`geometrycollection`'
- en: Column types for `postgres`
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`postgres`的列类型'
- en: '`int`, `int2`, `int4`, `int8`, `smallint`, `integer`, `bigint`, `decimal`,
    `numeric`, `real`, `float`, `float4`, `float8`, `double precision`, `money`, `character
    varying`, `varchar`, `character`, `char`, `text`, `citext`, `hstore`, `bytea`,
    `bit`, `varbit`, `bit varying`, `timetz`, `timestamptz`, `timestamp`, `timestamp
    without time zone`, `timestamp with time zone`, `date`, `time`, `time without
    time zone`, `time with time zone`, `interval`, `bool`, `boolean`, `enum`, `point`,
    `line`, `lseg`, `box`, `path`, `polygon`, `circle`, `cidr`, `inet`, `macaddr`,
    `tsvector`, `tsquery`, `uuid`, `xml`, `json`, `jsonb`, `int4range`, `int8range`,
    `numrange`, `tsrange`, `tstzrange`, `daterange`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`、`int2`、`int4`、`int8`、`smallint`、`integer`、`bigint`、`decimal`、`numeric`、`real`、`float`、`float4`、`float8`、`double
    precision`、`money`、`character varying`、`varchar`、`character`、`char`、`text`、`citext`、`hstore`、`bytea`、`bit`、`varbit`、`bit
    varying`、`timetz`、`timestamptz`、`timestamp`、`timestamp without time zone`、`timestamp
    with time zone`、`date`、`time`、`time without time zone`、`time with time zone`、`interval`、`bool`、`boolean`、`enum`、`point`、`line`、`lseg`、`box`、`path`、`polygon`、`circle`、`cidr`、`inet`、`macaddr`、`tsvector`、`tsquery`、`uuid`、`xml`、`json`、`jsonb`、`int4range`、`int8range`、`numrange`、`tsrange`、`tstzrange`、`daterange`'
- en: Column types for `sqlite` / `cordova` / `react-native`
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`sqlite` / `cordova` / `react-native`的列类型'
- en: '`int`, `int2`, `int8`, `integer`, `tinyint`, `smallint`, `mediumint`, `bigint`,
    `decimal`, `numeric`, `float`, `double`, `real`, `double precision`, `datetime`,
    `varying character`, `character`, `native character`, `varchar`, `nchar`, `nvarchar2`,
    `unsigned big int`, `boolean`, `blob`, `text`, `clob`, `date`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`、`int2`、`int8`、`integer`、`tinyint`、`smallint`、`mediumint`、`bigint`、`decimal`、`numeric`、`float`、`double`、`real`、`double
    precision`、`datetime`、`varying character`、`character`、`native character`、`varchar`、`nchar`、`nvarchar2`、`unsigned
    big int`、`boolean`、`blob`、`text`、`clob`、`date`'
- en: Column types for `mssql`
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`mssql`的列类型'
- en: '`int`, `bigint`, `bit`, `decimal`, `money`, `numeric`, `smallint`, `smallmoney`,
    `tinyint`, `float`, `real`, `date`, `datetime2`, `datetime`, `datetimeoffset`,
    `smalldatetime`, `time`, `char`, `varchar`, `text`, `nchar`, `nvarchar`, `ntext`,
    `binary`, `image`, `varbinary`, `hierarchyid`, `sql_variant`, `timestamp`, `uniqueidentifier`,
    `xml`, `geometry`, `geography`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`、`bigint`、`bit`、`decimal`、`money`、`numeric`、`smallint`、`smallmoney`、`tinyint`、`float`、`real`、`date`、`datetime2`、`datetime`、`datetimeoffset`、`smalldatetime`、`time`、`char`、`varchar`、`text`、`nchar`、`nvarchar`、`ntext`、`binary`、`image`、`varbinary`、`hierarchyid`、`sql_variant`、`timestamp`、`uniqueidentifier`、`xml`、`geometry`、`geography`'
- en: Column types for `oracle`
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`oracle`的列类型'
- en: '`char`, `nchar`, `nvarchar2`, `varchar2`, `long`, `raw`, `long raw`, `number`,
    `numeric`, `float`, `dec`, `decimal`, `integer`, `int`, `smallint`, `real`, `double
    precision`, `date`, `timestamp`, `timestamp with time zone`, `timestamp with local
    time zone`, `interval year to month`, `interval day to second`, `bfile`, `blob`,
    `clob`, `nclob`, `rowid`, `urowid`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`、`nchar`、`nvarchar2`、`varchar2`、`long`、`raw`、`long raw`、`number`、`numeric`、`float`、`dec`、`decimal`、`integer`、`int`、`smallint`、`real`、`double
    precision`、`date`、`timestamp`、`timestamp with time zone`、`timestamp with local
    time zone`、`interval year to month`、`interval day to second`、`bfile`、`blob`、`clob`、`nclob`、`rowid`、`urowid`'
- en: If you’re not ready to commit yourself to one specific database type and you’d
    like to keep your options open for the future, it might not be the best idea to
    use a type that’s not available in every database.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有准备好承诺使用特定的数据库类型，并且希望为将来保持选择的开放性，那么使用不是每个数据库都可用的类型可能不是最好的主意。
- en: NoSQL in SQL
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL中的NoSQL
- en: 'TypeORM has still one last trick in the hat: a `simple-json` column type that
    can be used in every supported database. With it, you can directly save Plain
    Old JavaScript Objects in one of the relational database columns. Yes, mindblowing!'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM还有一个最后的绝招：`simple-json`列类型，可以在每个支持的数据库中使用。使用它，你可以直接在关系数据库列中保存普通的JavaScript对象。是的，令人惊叹！
- en: Let’s put it to use with a new `author` property in the entity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实体中使用一个新的`author`属性。
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `simple-json` column type allows you to directly store even complex JSON
    trees without needing to define a model for them first. This can come handy in
    situations where you appreciate a bit more flexibility than the traditional relational
    database structure allows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple-json`列类型允许您直接存储甚至复杂的JSON树，而无需首先定义一个模型。在您欣赏比传统的关系数据库结构更灵活的情况下，这可能会派上用场。'
- en: Relationships between data models
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据模型之间的关系
- en: If you followed the chapter up to this point, you will have a way of saving
    new blog entries to your database through your API and then reading them back.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直跟着本章节，那么您将有一种通过API将新的博客条目保存到数据库中，然后再读取它们的方法。
- en: The next step is to create a second entity to handle comments in each blog entry
    and then create a relationship between entries and comments in such a way that
    one blog entry can have several comments that belong to it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是创建第二个实体来处理每个博客条目中的评论，然后以这样的方式创建条目和评论之间的关系，以便一个博客条目可以有属于它的多个评论。
- en: Let’s create the `Comments` entity then.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建`Comments`实体。
- en: '**`src/comments/comment.entity.ts`**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/comments/comment.entity.ts`**'
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You have probably noticed that the `Comment` entity is quite similar to the
    `Entry` entity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到`Comment`实体与`Entry`实体非常相似。
- en: The next step will be to create a “one-to-many” relationship between entries
    and comments. For that, include a new property in the `Entry` entity with a `@OneToMany()`
    decorator.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤将是在条目和评论之间创建一个“一对多”的关系。为此，在`Entry`实体中包含一个新的属性，使用`@OneToMany()`装饰器。
- en: '**`src/entries/entry.entity.ts`**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entry.entity.ts`**'
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: “One-to-many” relationships have to be bi-directional, so you need to add an
    inverse relationship “many-to-one” in the `Comment` entity. This way, both will
    get properly “tied up.”
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: “一对多”关系必须是双向的，因此您需要在`Comment`实体中添加一个反向关系“多对一”。这样，两者都将得到适当的“绑定”。
- en: '**`src/comments/comment.entity.ts`**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/comments/comment.entity.ts`**'
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second argument that we’re passing to both the `@OneToMany()` and the `@ManyToOne()`
    decorators is used to specify the inverse relationship that we’re also creating
    on the other related entity. In other words, in the `Entry` we are saving the
    related `Comment` entity in a property named `comments`. That’s why, in the `Comment`
    entity definition, we pass `entry => entry.comments` as a second argument to the
    decorator, to the point where in `Entry` the comments be stored.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`@OneToMany()`和`@ManyToOne()`装饰器的第二个参数用于指定我们在另一个相关实体上创建的逆关系。换句话说，在`Entry`中，我们将相关的`Comment`实体保存在名为`comments`的属性中。这就是为什么在`Comment`实体定义中，我们将`entry
    => entry.comments`作为第二个参数传递给装饰器的原因，直到在`Entry`中存储评论。
- en: '**NOTE:** Not all relationships *need* to be bi-directional. “One-to-one” relationships
    can very well be both uni-directional or bi-directional. In the case of uni-directional
    “one-to-one” relationships, the owner of the relationship is the one declaring
    it, and the other entity wouldn’t need to know anything about the first one.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**并非所有关系*需要*是双向的。“一对一”关系可以是单向的或双向的。在单向“一对一”关系的情况下，关系的所有者是声明它的一方，而另一个实体不需要知道关于第一个实体的任何信息。'
- en: That’s it! Now each of our entries can have several comments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们的每个条目都可以有多条评论。
- en: How to store related entities
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何存储相关实体
- en: If we talk about code, the most straightforward way of saving a comment that
    belongs to an entry would be to save the comment and then save the entry with
    the new comment included. Create a new `Comments` service to interact with the
    entity, and then modify the `Entry` controller to call that new `Comments` service.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们谈论代码，保存属于条目的评论的最直接的方法将是保存评论，然后保存包含新评论的条目。创建一个新的`Comments`服务来与实体交互，然后修改`Entry`控制器以调用该新的`Comments`服务。
- en: Let’s see how. It’s not as hard as it sounds!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看。这并不像听起来那么难！
- en: 'This would be our new service:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的新服务：
- en: '**`src/comments/comments.service.ts`**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/comments/comments.service.ts`**'
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code sure looks familiar, doesn’t it? It’s very similar to the `EntriesService`
    that we already had, since we are providing quite the same functionality for both
    comments and entries.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来确实很熟悉，不是吗？这与我们已经拥有的`EntriesService`非常相似，因为我们为评论和条目提供了相同的功能。
- en: 'This would be the modified `Entries` controller:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是修改后的`Entries`控制器：
- en: '**`src/entries/entries.controller.ts`**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entries.controller.ts`**'
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In short, the new `create()` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，新的`create()`方法：
- en: Receives both a blog entry and an array of comments that belong to that entry.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收一个博客条目和属于该条目的评论数组。
- en: Creates a new empty array property (named `comments`) inside the blog entry
    object.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在博客条目对象内创建一个新的空数组属性（名为`comments`）。
- en: Iterates over the received comments, saving each one of them and then pushing
    them one by one to the new `comments` property of `entry`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历接收到的评论，保存每一条评论，然后逐一将它们推送到`entry`的新`comments`属性中。
- en: Finally, saves the `entry`, which now includes a “link” to each comment inside
    its own `comments` property.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，保存了现在包含每条评论链接的`entry`。
- en: Saving related entities the easier way
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以更简单的方式保存相关实体
- en: The code we wrote last works, but it’s not very convenient.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上次编写的代码有效，但不太方便。
- en: 'Fortunately, TypeORM provides us with a easier way to save related entities,
    though: enabling “cascades”.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，TypeORM为我们提供了一种更简单的方法来保存相关实体：启用“级联”。
- en: Setting `cascade` to `true` in our entity will mean that we’ll no longer need
    to separately save each related entity; rather, saving the owner of the relationship
    to the database will save those related entities at the same time. This way, our
    previous code can be simplified.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体中将`cascade`设置为`true`将意味着我们将不再需要单独保存每个相关实体；相反，将关系的所有者保存到数据库将同时保存这些相关实体。这样，我们以前的代码可以简化。
- en: First of all, let’s modify our `Entry` entity (which is the owner of the relationship)
    to enable cascade.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改我们的`Entry`实体（它是关系的所有者）以启用级联。
- en: '**`src/entries/entry.entity.ts`**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entry.entity.ts`**'
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This was really easy: we just added a `{cascade: true}` object as third argument
    for the `@OneToMany()` decorator.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '这真的很简单：我们只需为`@OneToMany()`装饰器的第三个参数添加一个`{cascade: true}`对象。'
- en: Now, we will refactor the `create()` method on the `Entries` controller.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重构`Entries`控制器上的`create()`方法。
- en: '**`src/entries/entries.controller.ts`**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entries.controller.ts`**'
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Please compare the new controller with our previous implementations; we were
    able to get rid of the dependency on the `Comments` service, as well as an iterator
    on the `create()` method. This makes our code shorter and cleaner, which is always
    good as it reduces the risk of introducing bugs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请将新控制器与我们以前的实现进行比较；我们已经摆脱了对`Comments`服务的依赖，以及对`create()`方法的迭代器。这使我们的代码更短，更清晰，这总是好的，因为它减少了引入错误的风险。
- en: In this section we found out how to save entities that are related one to another,
    while saving their relationship as well. This is a crucial step for the success
    of our related entities. Nice job!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们发现了如何保存彼此相关的实体，同时保存它们的关系。这对于我们相关实体的成功至关重要。干得好！
- en: Retrieving related entities in bulk
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量检索相关实体
- en: Now that we know how to save an entity and include its relationships, we’ll
    take a look on how to read both an entity from the database, as well as all their
    related entities.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何保存一个实体并包含它的关系，我们将看看如何从数据库中读取一个实体以及它们的所有相关实体。
- en: The idea in this case is that, when we request a blog entry (only one) from
    the database, we also get the comments that belong to it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下的想法是，当我们从数据库请求博客条目（只有一个）时，我们还会得到属于它的评论。
- en: Of course, since you’re familiar with blogs in general (they’ve been around
    for a while, right?), you will be aware that not all blogs load both the blog
    entry and the comments at the same time; many of them load the comments only when
    you reach the bottom of the page.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于你对博客一般情况比较熟悉（它们已经存在一段时间了，对吧？），你会意识到并不是所有的博客都会同时加载博客文章和评论；很多博客只有在你滚动到页面底部时才加载评论。
- en: To demonstrate the functionality, however, we will assume that our blogging
    platform will retrieve both the blog entry and the comments at the same time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示功能，我们将假设我们的博客平台将同时检索博客文章和评论。
- en: We will need to modify the `Entries` service to achieve this. Again, it’s going
    to be quite easy!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`Entries`服务来实现这一点。再次强调，这将非常容易！
- en: '**`src/entries/entries.service.ts`**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entries.service.ts`**'
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We only added a `{ relations: [''comments''] }` as second argument to the `findOneById()`
    method of the `Entry` repository. The `relations` property of the options object
    is an array, so we can retrieve as many relationships we need to. Also, it can
    be used with any `find()` related method (that is, `find()`, `findByIds()`, `findOne()`
    and so on.)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '我们只在`Entry`存储库的`findOneById()`方法的第二个参数中添加了`{ relations: [''comments''] }`。选项对象的`relations`属性是一个数组，因此我们可以检索出我们需要的任意多个关系。它也可以与任何`find()`相关方法一起使用（即`find()`、`findByIds()`、`findOne()`等等）。'
- en: Lazy relationships
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰关系
- en: When working with TypeORM, regular relationships (like the ones we have written
    so far) are *eager* relationships. This means that when we read entities from
    the database, the `find*()` methods will return the related entities as well,
    without us needing to write joins or manually read them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用TypeORM时，常规关系（就像我们迄今为止写的那样）是*急切*关系。这意味着当我们从数据库中读取实体时，`find*()`方法将返回相关的实体，而无需我们编写连接或手动读取它们。
- en: We can also configure our entities to treat relationships as *lazy*, so that
    the related entities are not retrieved from the database until we say so.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以配置我们的实体将关系视为*懒惰*，这样相关的实体在我们说之前不会从数据库中检索出来。
- en: 'This is achieved by declaring the type of the field that holds the related
    entity as a `Promise` instead of a direct type. Let’s see the difference in code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将保存相关实体的字段类型声明为`Promise`而不是直接类型来实现的。让我们看看代码上的区别：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Of course, using lazy relationships means that we need to change the way we
    save our entity to the database. The next code block demonstrates how to save
    lazy relationships. Pay attention to the `create()` method.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用懒惰关系意味着我们需要改变保存实体到数据库的方式。下一个代码块演示了如何保存懒惰关系。请注意`create()`方法。
- en: '**`src/entries/entries.controller.ts`**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entries.controller.ts`**'
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We made the `create()` method “lazy” by:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式使`create()`方法变为“懒惰”：
- en: Initializing a new `resolvedComments` empty array.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个新的`resolvedComments`空数组。
- en: Going through all of the comments received in the request, saving each one and
    then adding it to the `resolvedComments` array.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历请求中收到的所有评论，保存每一条评论，然后将其添加到`resolvedComments`数组中。
- en: When all comments are saved, we assign a promise to the `comments` property
    of `entry`, and then immediately resolve it with the array of comments built in
    step 2.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有评论都被保存时，我们将一个promise分配给`entry`的`comments`属性，然后立即用第2步中构建的评论数组解决它。
- en: Save the `entry` with the related comments as an already resolved promise.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将带有相关评论的`entry`保存为已解决的promise。
- en: The concept of assigning an immediately resolved promise as value of an entity
    before saving is not easy to digest. Still, we need to resort to this because
    of the asynchronous nature of JavaScript.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存之前将一个立即解决的promise分配为实体的值的概念并不容易理解。但是，由于JavaScript的异步性质，我们仍然需要诉诸于这一点。
- en: That said, be aware that TypeORM support for lazy relationships is still in
    the experimental phase, so use them with care.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，请注意TypeORM对懒惰关系的支持仍处于实验阶段，因此请谨慎使用。
- en: Other kinds of relationships
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型的关系
- en: So far we’ve explored “one-to-many” relationships. Obviously, TypeORM supports
    “one-to-one” and “many-to-many” relationships as well.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了“一对多”的关系。显然，TypeORM也支持“一对一”和“多对多”的关系。
- en: One-to-one
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一
- en: Just in case you’re not familiar with this kind of relationships, the idea behind
    it is that one instance of an entity, and only one, belongs to one instance, and
    only one, of another entity.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以防你不熟悉这种关系，其背后的想法是一个实体的一个实例，只属于另一个实体的一个实例，而且只属于一个。
- en: To give a more specific example, let’s imagine that we were going to create
    a new `EntryMetadata` entity to store new things that we want to keep track of,
    like, let’s say, the number of likes a blog entry got from readers and a shortlink
    for each blog entry.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 举个更具体的例子，假设我们要创建一个新的`EntryMetadata`实体来存储我们想要跟踪的新事物，比如，假设博客文章从读者那里得到的喜欢数量和每篇博客文章的短链接。
- en: Let’s start by creating a new entity called `EntryMetadata`. We will put the
    file in the `/entry` folder, next to the `entry.entity.ts` file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`EntryMetadata`的新实体开始。我们将把文件放在`/entry`文件夹中，与`entry.entity.ts`文件相邻。
- en: '**`src/entries/entry_metadata.entity.ts`**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entry_metadata.entity.ts`**'
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The entity we just created is quite simple: it only has the regular `uuid`
    property, as well as two other properties for storing `likes` for an entry, and
    also a `shortlink` for it.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的实体非常简单：它只有常规的`uuid`属性，以及用于存储条目的`likes`和`shortlink`的两个其他属性。
- en: Now let’s tell TypeORM to include one instance of the `EntryMetadata` entity
    in each instance of the `Entry` entity.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们告诉TypeORM在每个`Entry`实例中包含一个`EntryMetadata`实体的实例。
- en: '**`src/entries/entry.entity.ts`**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entry.entity.ts`**'
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You might have noticed the `@JoinColumn()` decorator. Using this decorator in
    “one-to-one” relationships is required by TypeORM.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了`@JoinColumn()`装饰器。在“一对一”关系中使用这个装饰器是TypeORM所要求的。
- en: Bi-directional one-to-one relationships
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向一对一关系
- en: At this point, the relationship between `Entry` and `EntryMetadata` is uni-directional.
    In this case, it is probably enough.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`Entry`和`EntryMetadata`之间的关系是单向的。在这种情况下，这可能已经足够了。
- en: Let’s say, however, that we want to have the possibility of accessing an instance
    of `EntryMetadata` directly and then fetch the `Entry` instance it belongs to.
    Well, we can’t do that right now; not until we make the relationship bi-directional.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们想直接访问`EntryMetadata`实例，然后获取它所属的`Entry`实例的可能性。好吧，现在我们还不能做到；直到我们使关系双向为止。
- en: So, just for the sake of demonstration, we will include the inverse relationship
    in the `EntryMetadata` instance to the `Entry` instance, so that you know how
    it works.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仅出于演示目的，我们将在`EntryMetadata`实例中包含到`Entry`实例的反向关系，以便你知道它是如何工作的。
- en: '**`src/entries/entry_metadata.entity.ts`**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entry_metadata.entity.ts`**'
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Make sure you don’t include the `@JoinColumn()` decorator on this second entry.
    That decorator should only be used in the owner entity; in our case, in `Entry`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要在第二个条目中包含`@JoinColumn()`装饰器。该装饰器应该只用在拥有者实体中；在我们的情况下，就是`Entry`中。
- en: 'The second adjustment we need to make is pointing to the location of the related
    entity in our original `@OneToOne()` decorator. Remember, we just saw that this
    needs to be done by passing a second argument to the decorator, like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第二个调整是指向原始`@OneToOne()`装饰器中相关实体的位置。记住，我们刚刚看到这需要通过向装饰器传递第二个参数来完成，就像这样：
- en: '**`src/entries/entry.entity.ts`**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entry.entity.ts`**'
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That’s it! Now we have a beautiful, working bi-directional one-to-one relationship
    between the `Entry` and the `EntryMetadata` entities.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们有了一个美丽的、工作正常的`Entry`和`EntryMetadata`实体之间的双向一对一关系。
- en: 'By the way, if you’re wondering how could we save and then retrieve this two
    related entities, I’ve got good news for you: it works the same way that we saw
    with one-to-many relationships. So, either do it by hand as exposed earlier in
    this chapter, or (my personal favorite) use “cascades” for saving them, and `find*()`
    to retrieve them!'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你想知道我们如何保存然后检索这两个相关的实体，我有好消息告诉你：它的工作方式与我们在本章前面看到的一对多关系相同。因此，要么像在本章前面介绍的那样手动操作，要么（我个人的最爱）使用“级联”来保存它们，并使用`find*()`来检索它们！
- en: Many-to-many
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多
- en: The last type of relationship that we can establish for our entities is known
    as “many-to-many.” This means that multiple instances of the owning entity can
    include multiple instances of the owned entity.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的实体建立的最后一种关系类型被称为“多对多”。这意味着拥有实体的多个实例可以包含拥有实体的多个实例。
- en: A good example might be us wanting to include “tags” to our blog entries. An
    entry might have several tags, and a tag can be used in several blog entries,
    right. That makes the relationship fall under the “many-to-many” typology.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子可能是我们想要为我们的博客条目添加“标签”。一个条目可能有几个标签，一个标签可以用在几个博客条目中，对吧。这使得关系属于“多对多”类型。
- en: We will save some code here, because these relationships are declared exactly
    the same way than the “one-to-one” relationships, only changing the `@OneToOne()`
    decorator to `@ManyToMany()`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将节省一些代码，因为这些关系的声明方式与“一对一”关系完全相同，只需将`@OneToOne()`装饰器更改为`@ManyToMany()`。
- en: Advanced TypeORM
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级TypeORM
- en: Let’s take a look at security.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看安全。
- en: Security first
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首先是安全
- en: If you went through the Sequelize chapter in this same book, you might be familiar
    with the concept of lifecycle hooks. In that chapter, we are using a `beforeCreate`
    hook to encrypt the users’ passwords before we save them to our database.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在本书的Sequelize章节中阅读过，你可能对生命周期钩子的概念很熟悉。在那一章中，我们使用`beforeCreate`钩子在将用户密码保存到数据库之前对其进行加密。
- en: In case you’re wondering if such a thing exists also in TypeORM, the answer
    is yes! Though the TypeORM documentation refers to them as “listeners” instead.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道TypeORM中是否也存在这样的东西，答案是肯定的！尽管TypeORM文档将它们称为“监听器”。
- en: So, to demonstrate its functionality, let’s write a very simple `User` entity
    with a username and a password, and we will make sure to encrypt the password
    before we save it to the database. The specific listener we will be using is called
    `beforeInsert` in TypeORM.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了演示其功能，让我们编写一个非常简单的`User`实体，其中包含用户名和密码，并且在将其保存到数据库之前，我们将确保加密密码。我们将在TypeORM中使用的特定监听器称为`beforeInsert`。
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Other listeners
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他监听器
- en: 'In general, a listener is a method that gets triggered upon a specific event
    within TypeORM, be it write-related or read-related. We just learned about the
    `@BeforeInsert()` listener, but we have a few other ones we can take advantage
    of:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，监听器是在TypeORM中特定事件发生时触发的方法，无论是与写相关还是与读相关。我们刚刚了解了`@BeforeInsert()`监听器，但我们还有其他一些可以利用的监听器：
- en: '`@AfterLoad()`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AfterLoad()`'
- en: '`@BeforeInsert()`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeforeInsert()`'
- en: '`@AfterInsert()`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AfterInsert()`'
- en: '`@BeforeUpdate()`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeforeUpdate()`'
- en: '`@AfterUpdate()`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AfterUpdate()`'
- en: '`@BeforeRemove()`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeforeRemove()`'
- en: '`@AfterRemove()`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AfterRemove()`'
- en: Composing and extending entities
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合和扩展实体
- en: TypeORM offers two different ways of reducing code duplication between entities.
    One of them follows the composition pattern, while the other follows the inheritance
    pattern.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM提供了两种不同的方式来减少实体之间的代码重复。其中一种遵循组合模式，而另一种遵循继承模式。
- en: Even though a lot of authors defend favoring composition over inheritance, we
    will expose here the two possibilities and let the reader decide which one fits
    better his/her own particular needs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很多作者都支持组合优于继承，但我们将在这里介绍这两种可能性，并让读者决定哪种更适合他/她自己的特定需求。
- en: Embedded entities
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌入式实体
- en: The way of composing entities in TypeORM is using an artifact known as embedded
    entity.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeORM中组合实体的方式是使用一种称为嵌入式实体的工件。
- en: Embedded entities are basically entities with some declared table columns (properties)
    that can be included inside other bigger entities.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式实体基本上是具有一些声明的表列（属性）的实体，可以包含在其他更大的实体中。
- en: 'Let’s go with the example: after reviewing the code we wrote earlier for the
    entities of both `Entry` and `Comment`, we can easily see that there are (among
    others) three duplicated properties: `created_at`, `modified_at` and `revision`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个例子开始：在审查我们之前为`Entry`和`Comment`实体编写的代码之后，我们很容易看到（除其他外）有三个重复的属性：`created_at`，`modified_at`和`revision`。
- en: It would be a great idea to create an “embeddable” entity to hold those three
    properties and then embed them into both our original entities. Let’s see how.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个“可嵌入”实体来保存这三个属性然后将它们嵌入到我们的原始实体中会是一个很好的主意。让我们看看如何做。
- en: We will first create a `Versioning` entity (the name is not great, I know, but
    should work for you to see the idea) with those three duplicated properties.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将创建一个`Versioning`实体（名称不太好，我知道，但应该能让您看到这个想法）带有这三个重复的属性。
- en: '**`src/common/versioning.entity.ts`**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/common/versioning.entity.ts`**'
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that we’re not using the @Entity decorator in this entity. This is because
    it’s not a “real” entity. Think of it as an “abstract” entity, i.e. an entity
    that we will never instantiate directly, but we rather will use to embed it in
    other instantiable entities in order to give them some reusable functionality.
    Or, in other words, composing entities from smaller pieces.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这个实体中没有使用@Entity装饰器。这是因为它不是一个“真正”的实体。把它想象成一个“抽象”实体，即一个我们永远不会直接实例化的实体，而是我们将用它来嵌入到其他可实例化的实体中，以便为它们提供一些可重用的功能。换句话说，从较小的部分组合实体。
- en: So, now we will embed this new “embeddable” entity into our two original entities.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们将把这个新的“可嵌入”实体嵌入到我们的两个原始实体中。
- en: '**`src/entries/entry.entity.ts`**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entry.entity.ts`**'
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**`src/comments/comment.entity.ts`**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/comments/comment.entity.ts`**'
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Even in this really simple case, we’ve reduced the two original entities from
    three different properties to only one! In both the `Entry` entity and the `Comment`
    entity, the `versioning` column will be actually replaced by the properties inside
    the `Versioning` embedded entity when we invoke any of their reading or writing
    methods.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个非常简单的例子中，我们已经将两个原始实体从三个不同的属性减少到了一个！在`Entry`实体和`Comment`实体中，当我们调用它们的读取或写入方法时，`versioning`列将被`Versioning`嵌入实体内的属性实际替换。
- en: Entity inheritance
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体继承
- en: The second choice that TypeORM offers for reusing code between our entities
    is using entity inheritance.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM为在我们的实体之间重用代码提供了第二种选择，即使用实体继承。
- en: If you’re already familiar with TypeScript, entity inheritance is quite easy
    to understand (and implement) when you take into account that entities are nothing
    more (and nothing less!) than regular TS classes with some decorators on top.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉TypeScript，那么当您考虑到实体只是带有一些装饰器的常规TS类时，实体继承就很容易理解（和实现）。
- en: For this particular example, let’s imagine that our Nest.js-based blog has been
    online for some time, and that it has become quite a success. Now we would like
    to introduce sponsored blog entries so that we can make a few bucks and invest
    them in a few more books.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的例子，让我们假设我们基于Nest.js的博客已经在线上一段时间了，并且它已经相当成功。现在我们想要引入赞助博客条目，这样我们就可以赚一些钱并将它们投资到更多的书籍中。
- en: 'The thing is, sponsored entries are going to be a lot like regular entries,
    but with a couple of new properties: sponsor name and sponsor URL.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，赞助条目将与常规条目非常相似，但会有一些新属性：赞助商名称和赞助商网址。
- en: In this case, we might decide, after quite some thought, to extend our original
    `Entry` entity and create a `SponsoredEntry` out of it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，经过一番思考后，我们可能决定扩展我们的原始`Entry`实体并创建一个`SponsoredEntry`。
- en: '**`src/entries/sponsored-entry.entity.ts`**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/sponsored-entry.entity.ts`**'
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That’s about it. Any new instance we create from the `SponsoredEntry` entity
    will have the same columns from the extended `Entry` entity, plus the two new
    columns we defined for `SponsoredEntry`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们从`SponsoredEntry`实体创建的任何新实例都将具有来自扩展的`Entry`实体的相同列，以及我们为`SponsoredEntry`定义的两个新列。
- en: Caching
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: TypeORM brings a caching layer out of the box. We can take advantage of it with
    only a little overhead. This layer is specially useful if you are designing an
    API that expects a lot of traffic and/or you need the best performance you can
    get.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM默认提供了一个缓存层。我们可以利用它，只需稍微增加一点开销。如果您正在设计一个预期会有大量流量和/或您需要尽可能获得最佳性能的API，这一层将特别有用。
- en: Both cases would benefit increasingly from the cache because we use more complex
    data retrieval scenarios, such as complex `find*()` options, lots of related entities,
    etc.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都会因为使用更复杂的数据检索场景（例如复杂的`find*()`选项，大量相关实体等）而越来越受益于缓存。
- en: The caching needs to be explicitly activated when connecting to the database.
    In our case so far, this will be the `ormconfig.json` file that we created at
    the beginning of the chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接到数据库时，缓存需要显式激活。到目前为止，在我们的情况下，这将是我们在本章开头创建的`ormconfig.json`文件。
- en: '**ormconfig.json**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**ormconfig.json**'
- en: '[PRE40]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After activating the caching layer on the connection, we will need to pass
    the `cache` option to our `find*()` methods, like in the following example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接上激活缓存层之后，我们需要将`cache`选项传递给我们的`find*()`方法，就像下面的例子中那样：
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The line of code above will make the `.find()` method to return the cached value
    if it’s present and not expired, or the value from the corresponding database
    table otherwise. So, even if the method is fired three thousand times within the
    expiration time window (see below), only one database query would be actually
    executed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将使`.find()`方法在缓存值存在且未过期时返回缓存值，否则返回相应数据库表中的值。因此，即使在过期时间窗口内调用该方法三千次，实际上只会执行一次数据库查询。
- en: 'TypeORM uses a couple of defaults when dealing with caches:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM在处理缓存时使用了一些默认值：
- en: 'The default cache lifetime is 1,000 milliseconds (i.e. 1 second.) In case we
    need to customize the expiration time, we just need to pass the desired lifetime
    as value to the `cache` property of the options object. In the case above, `this.entry.find({
    cache: 60000 })` would set a cache TTL of 60 seconds.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '默认的缓存生命周期是1,000毫秒（即1秒）。如果我们需要自定义过期时间，我们只需要将所需的生命周期作为值传递给选项对象的`cache`属性。在上面的例子中，`this.entry.find({
    cache: 60000 })`将设置60秒的缓存TTL。'
- en: 'TypeORM will create a dedicated table for the cache in the same database you’re
    already using. The table will be named `query-result-cache`. This is not bad,
    but it can greatly improved if we have a Redis instance available. In that cache,
    we will need to include our Redis connection details in the `ormconfig.json` file:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeORM将在您已经使用的同一数据库中为缓存创建一个专用表。该表将被命名为`query-result-cache`。这并不是坏事，但如果我们有一个可用的Redis实例，它可以得到很大的改进。在缓存中，我们需要在`ormconfig.json`文件中包含我们的Redis连接详细信息：
- en: '**ormconfig.json**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**ormconfig.json**'
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This way we can easily improve the performance of our API under heavy load.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们可以在高负载下轻松提高API的性能。
- en: Building a query
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建查询
- en: The TypeORM’s repository methods for retrieving data from our database greatly
    isolates the complexity of querying away from us. They provide a very useful abstraction
    so that we don’t need to bother with actual database queries.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM的存储库方法极大地隔离了我们查询的复杂性。它们提供了一个非常有用的抽象，使我们不需要关心实际的数据库查询。
- en: However, apart from using these various `.find*()` methods, TypeORM also provides
    a way of manually executing queries. This greatly improves flexibility when accessing
    our data, at the cost of demanding us to write more code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了使用这些不同的`.find*()`方法之外，TypeORM还提供了手动执行查询的方法。这在访问我们的数据时极大地提高了灵活性，但代价是需要我们编写更多的代码。
- en: The TypeORM tool for executing queries is the `QueryBuilder`. A very basic example
    could involve refactoring our good old `findOneById()` method in the `EntriesService`
    so that it uses the `QueryBuilder`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM执行查询的工具是`QueryBuilder`。一个非常基本的例子可能涉及重构我们旧有的`findOneById()`方法，使其使用`QueryBuilder`。
- en: '**`src/entries/entries.service.ts`**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entries.service.ts`**'
- en: '[PRE43]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Another slightly more complex scenario would be to build a join in order to
    also retrieve the related entities. We will come back once again to the `findOneById()`
    method we just modified to include the related comments.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个稍微复杂一些的情景是构建一个连接，以便还检索相关的实体。我们将再次回到我们刚刚修改以包括相关评论的`findOneById()`方法。
- en: '**`src/entries/entries.service.ts`**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**`src/entries/entries.service.ts`**'
- en: '[PRE44]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Building our model from a existing database
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从现有数据库构建我们的模型
- en: Up until this point, we have started with a “clean” database, then created our
    models, leaving to TypeORM the task of transforming the models into database columns.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一点，我们从一个“干净”的数据库开始，然后创建我们的模型，将模型转换为数据库列的任务交给了TypeORM。
- en: This is the “ideal” situation, but... What if we found ourselves in the opposite
    situations? What if we already had a database with tables and columns populated?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“理想”的情况，但是...如果我们发现自己处于相反的情况下怎么办？如果我们已经有一个填充了表和列的数据库呢？
- en: 'There’s a nice open source project we can use for that: [typeorm-model-generator](https://github.com/Kononnable/typeorm-model-generator).
    It’s packed as a command line tool and can be run with `npx`.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很好的开源项目可以用于这个：[typeorm-model-generator](https://github.com/Kononnable/typeorm-model-generator)。它被打包为一个命令行工具，可以使用`npx`运行。
- en: '**NOTE:** In case you’re not familiar with it, `npx` is a command that comes
    out of the box with `npm` > 5.2 and that allows us to run npm modules from the
    command line without having to install them first. To use it, you just need to
    prepend `npx` to the regular commands from the tool. We would use `npx ng new
    PROJECT-NAME` on our command line, for example, if we wanted to scaffold a new
    project with Angular CLI.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**如果您对此不熟悉，`npx`是一个随`npm` > 5.2一起提供的命令，它允许我们在命令行中运行npm模块，而无需先安装它们。要使用它，您只需要在工具的常规命令之前加上`npx`。例如，如果我们想要使用Angular
    CLI在命令行中创建一个新项目，我们将使用`npx ng new PROJECT-NAME`。'
- en: When it’s executed, typeorm-model-generator will connect to the specified database
    (it supports roughly the same ones that TypeORM does) and will generate entities
    following the settings we pass as command line arguments.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当它被执行时，typeorm-model-generator将连接到指定的数据库（它支持大致与TypeORM相同的数据库），并将根据我们作为命令行参数传递的设置生成实体。
- en: Since this is a useful tool for only some very specific use cases, we will leave
    the configuration details out of this book. However, if you find yourself using
    this tool, go ahead and check [its GitHub repository](https://github.com/Kononnable/typeorm-model-generator).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个仅适用于一些非常特定用例的有用工具，我们将在本书中略去配置细节。但是，如果您发现自己在使用这个工具，请前往[其GitHub存储库](https://github.com/Kononnable/typeorm-model-generator)查看。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: TypeORM is a very useful tool and enables us to do a lot of heavy lifting when
    dealing with databases, while greatly abstracting things like data modelling,
    queries, and complex joins, thus simplifying our code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: TypeORM是一个非常有用的工具，使我们能够在处理数据库时进行大量的繁重工作，同时大大抽象了数据建模、查询和复杂的连接，从而简化了我们的代码。
- en: It’s also very suitable for being used in Nest.js-based projects thanks to the
    great support the framework provides through the `@nest/typeorm` package.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Nest.js通过`@nest/typeorm`包提供了很好的支持，因此它也非常适合用于Nest.js项目。
- en: 'Some of the things that we covered in this chapter are:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些内容包括：
- en: The database types supported by TypeORM and some hints on how to choose one.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeORM支持的数据库类型以及如何选择其中一种的一些建议。
- en: How to connect TypeORM to your database.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将TypeORM连接到您的数据库。
- en: What is an entity and how to create your first one.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是实体以及如何创建您的第一个实体。
- en: Storing and retrieving data from your database.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的数据库中存储和检索数据。
- en: Leveraging TypeORM to make it easier working with metadata (ID’s, creation and
    modification dates...).
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用TypeORM使处理元数据（ID、创建和修改日期等）更容易。
- en: Customizing the type of columns in your database to match your needs.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义数据库中列的类型以匹配您的需求。
- en: Building relationships between your different entities and how to handle them
    when reading from and writing to the database.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立不同实体之间的关系以及在从数据库读取和写入时如何处理它们。
- en: More advanced procedures like reusing code through composition or inheritance;
    hooking into lifecycle events; caching; and building queries by hand.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的程序，如通过组合或继承重用代码；连接到生命周期事件；缓存；以及手动构建查询。
- en: All in all, we really think the more familiar you grow with Nest.js, the more
    likely you start to feel comfortable writing TypeORM code, since they both look
    alike in a few aspects as their extensive use of TypeScript decorators.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们真的认为你对Nest.js越熟悉，就越有可能开始感觉写TypeORM代码更舒适，因为它们在一些方面看起来很相似，比如它们广泛使用TypeScript装饰器。
- en: In the next chapter we cover Sequelize, which is a promise-based ORM.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Sequelize，这是一个基于Promise的ORM。
