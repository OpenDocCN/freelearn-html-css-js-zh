- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Animation and Moving the Camera
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画和移动相机
- en: In the previous chapters, we saw some simple animations, but nothing too complex.
    In [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D Scene
    with Three.js*, we introduced the basic rendering loop, and in the chapters following
    that, we used that to rotate some simple objects and show a couple of other basic
    animation concepts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了一些简单的动画，但并没有什么太复杂的。在[*第1章*](B18726_01.xhtml#_idTextAnchor014)，*使用Three.js创建你的第一个3D场景*中，我们介绍了基本的渲染循环，在随后的章节中，我们使用它来旋转一些简单的对象并展示了一些其他基本的动画概念。
- en: 'In this chapter, we’re going to look in more detail at how animation is supported
    by Three.js. We will look at the following four subjects:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地探讨Three.js如何支持动画。我们将探讨以下四个主题：
- en: Basic animations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本动画
- en: Working with the camera
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与相机一起工作
- en: Morphing and skeleton animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形变和骨骼动画
- en: Creating animations using external modes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部模式创建动画
- en: We will start by covering the basic concepts behind animations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍动画背后的基本概念。
- en: Basic animations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本动画
- en: 'Before we look at the examples, let’s do a quick recap of what was shown in
    [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), on the render loop. To support
    animations, we need to tell Three.js to render the scene every so often. For this,
    we use the standard HTML5 `requestAnimationFrame` functionality, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看示例之前，让我们快速回顾一下在[*第1章*](B18726_01.xhtml#_idTextAnchor014)中展示的内容，关于渲染循环。为了支持动画，我们需要告诉Three.js每隔一段时间渲染场景。为此，我们使用标准的HTML5
    `requestAnimationFrame`功能，如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this code, we only need to call the `render()` function once we’ve initialized
    the scene. In the `render()` function itself, we use `requestAnimationFrame` to
    schedule the next rendering. This way, the browser will make sure the `render()`
    function is called at the correct interval (usually around 60 times or 120 times
    a second). Before `requestAnimationFrame` was added to browsers, `setInterval(function,
    interval)` or `setTimeout(function, interval)` was used. These would call the
    specified function once every set interval.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们只需要在初始化场景后调用一次`render()`函数。在`render()`函数本身中，我们使用`requestAnimationFrame`来安排下一次渲染。这样，浏览器将确保`render()`函数在正确的间隔（通常每秒大约60次或120次）被调用。在`requestAnimationFrame`被添加到浏览器之前，使用的是`setInterval(function,
    interval)`或`setTimeout(function, interval)`。这些会在每个设定的时间间隔调用指定的函数。
- en: The problem with this approach is that it doesn’t take into account what else
    is going on. Even if your animation isn’t shown or is in a hidden tab, it is still
    called and is still using resources. Another issue is that these functions update
    the screen whenever they are called, and not when it is the best time for the
    browser, which results in higher CPU usage. With `requestAnimationFrame`, we don’t
    tell the browser when it needs to update the screen; we ask the browser to run
    the supplied function when it’s most opportune. Usually, this results in a frame
    rate of about 60 or 120 FPS (depending on your hardware). With `requestAnimationFrame`,
    your animations will run more smoothly and will be more CPU- and GPU-friendly,
    and you don’t have to worry about timing issues.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点在于它没有考虑到其他正在发生的事情。即使你的动画没有显示或者是在隐藏的标签页中，它仍然会被调用并且仍在使用资源。另一个问题是，这些函数在每次被调用时都会更新屏幕，而不是在浏览器认为最佳的时间，这导致CPU使用率更高。使用`requestAnimationFrame`，我们不是告诉浏览器何时需要更新屏幕；而是请求浏览器在最适合的时候运行提供的函数。通常，这会导致大约60或120
    FPS（取决于你的硬件）的帧率。使用`requestAnimationFrame`，你的动画将运行得更平滑，并且对CPU和GPU更友好，你不必担心时间问题。
- en: In the next section, we’ll start with creating a simple animation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从创建一个简单的动画开始。
- en: Simple animations
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单动画
- en: 'With this approach, we can very easily animate objects by changing their `rotation`,
    `scale`, `position`, `material`, vertices, faces, and anything else you can imagine.
    In the next render loop, Three.js will render the changed properties. A very simple
    example, based on the one we already saw in [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122),
    *Points and Sprites*, is available in `01-basic-animations.html`. The following
    screenshot shows this example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以通过改变对象的`rotation`、`scale`、`position`、`material`、顶点、面以及你能想象到的任何其他内容来非常容易地动画化对象。在下一个渲染循环中，Three.js将渲染更改后的属性。一个基于我们已经在[*第7章*](B18726_07.xhtml#_idTextAnchor122)，*点和精灵*中看到的简单示例，可以在`01-basic-animations.html`中找到。以下截图显示了此示例：
- en: '![Figure 9.1 – Animation after changing its properties](img/Figure_9.1_B18726.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 更改属性后的动画](img/Figure_9.1_B18726.jpg)'
- en: Figure 9.1 – Animation after changing its properties
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 更改属性后的动画
- en: 'The render loop for this is very simple. First, we initialize the various properties
    on the `userData` object, which is a place for custom data stored in the `THREE.Mesh`
    itself, and then update these properties on the mesh, using the data we defined
    on the `userData` object. In the animation loop, just change the rotation, position,
    and the scale based on these properties, and Three.js handles the rest. Here’s
    how we do this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个渲染循环非常简单。首先，我们在`userData`对象上初始化各种属性，这是一个存储在`THREE.Mesh`本身中的自定义数据位置，然后使用我们在`userData`对象上定义的数据更新这些属性。在动画循环中，只需根据这些属性更改旋转、位置和缩放，Three.js会处理其余部分。以下是我们的操作方法：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There’s nothing spectacular here, but it nicely shows the concept behind the
    basic animations we will discuss in this book. We just change the `scale`, `rotation`,
    and `position` properties and Three.js does the rest.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处，但它很好地展示了我们将在这本书中讨论的基本动画背后的概念。我们只是更改`scale`、`rotation`和`position`属性，Three.js会处理其余部分。
- en: In the next section, we’ll take a quick sidestep. Besides animations, an important
    aspect that you’ll quickly run into when working with Three.js in more complex
    scenes is the ability to select objects on the screen using the mouse.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将快速跳转一下。除了动画之外，当你使用Three.js在更复杂的场景中工作时，你很快就会遇到的一个重要方面是使用鼠标在屏幕上选择对象的能力。
- en: Selecting and moving objects
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择和移动对象
- en: 'Even though not directly related to animations, since we’ll be looking at cameras
    and animations in this chapter, knowing how to select and move objects is a nice
    addition to the subjects explained in this chapter. Here, we will show you how
    to do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这与动画没有直接关系，但由于我们将在本章中查看相机和动画，了解如何选择和移动对象是本章所解释主题的一个很好的补充。在这里，我们将向您展示如何完成以下操作：
- en: Select an object from a scene using the mouse
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标从场景中选择一个对象
- en: Drag an object around the scene with the mouse
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标在场景中拖动一个对象
- en: We’ll start by looking at the steps you need to take to select an object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看选择对象所需的步骤。
- en: Selecting objects
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择对象
- en: 'First, open the `selecting-objects.html` example, where you’ll see the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`selecting-objects.html`示例，你会看到以下内容：
- en: '![Figure 9.2 – Randomly placed cubes that can be selected with the mouse](img/Figure_9.2_B18726.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 可以用鼠标选择的随机放置的立方体](img/Figure_9.2_B18726.jpg)'
- en: Figure 9.2 – Randomly placed cubes that can be selected with the mouse
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 可以用鼠标选择的随机放置的立方体
- en: 'When you move the mouse around the scene, you’ll see that whenever your mouse
    hits an object, that object is highlighted. You can easily create this by using
    a `THREE.Raycaster`. A raycaster will look at your current camera and cast a ray
    from the camera to your mouse’s position. Based on that, it can calculate which
    object is hit based on the position of the mouse. To accomplish this, we need
    to take the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在场景中移动鼠标时，你会看到每当你的鼠标击中一个对象时，该对象就会被突出显示。你可以通过使用`THREE.Raycaster`轻松创建这个效果。Raycaster会查看你的当前相机，并从相机位置向鼠标位置发射一条射线。基于此，它可以根据鼠标的位置计算出被击中的对象。为了完成这个任务，我们需要采取以下步骤：
- en: Create an object that keeps track of where the mouse is pointing at
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个跟踪鼠标指向位置的对象
- en: Whenever we move the mouse, update that object
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们移动鼠标时，更新那个对象
- en: In the render loop, use this updated information to see which Three.js object
    we’re pointing at
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染循环中，使用这些更新信息来查看我们指向的Three.js对象
- en: 'This is shown in the following code fragment:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的代码片段中显示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we are using `THREE.Raycaster` to determine which objects intersect the
    position of the mouse, from the point of the camera. The result (`intersects`,
    in the preceding example) contains all the cubes that intersected our mouse because
    the ray is cast from the camera’s position through to the end of the camera’s
    range. The first one in this array is the one that we’re hovering over, and the
    other values in this array (if any) point to objects behind the first mesh. `THREE.Raycaster`
    also provides other information about exactly where you hit the object:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`THREE.Raycaster`来确定哪些对象与相机点的鼠标位置相交。结果（在先前的示例中为`intersects`）包含所有与我们的鼠标相交的立方体，因为射线是从相机的位置发射到相机范围的末尾。在这个数组中的第一个是我们在悬停的对象，这个数组中的其他值（如果有）指向第一个网格后面的对象。`THREE.Raycaster`还提供了关于你击中对象的确切位置的其他信息：
- en: '![Figure 9.3 – Additional information from the raycaster](img/Figure_9.3_B18726.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – Raycaster提供的信息](img/Figure_9.3_B18726.jpg)'
- en: Figure 9.3 – Additional information from the raycaster
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 来自射线投射器的附加信息
- en: Here, we clicked on the `face` object. `faceIndex` points to the face of the
    mesh that was selected. The `distance` value is measured from the camera to the
    clicked object, and `point` is the exact position on the mesh where it was clicked.
    Finally, we have the `uv` value, which determines, when using textures, where
    the point that was clicked appears on the 2D texture (ranging from 0 to 1; more
    information on `uv` can be found in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    *Loading and Working* *With Textures*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们点击了`face`对象。`faceIndex`指向所选网格的表面。`distance`值是从相机到点击对象的距离，而`point`是点击在网格上的确切位置。最后，我们有`uv`值，当使用纹理时，它决定了点击的点在2D纹理上的位置（范围从0到1；有关`uv`的更多信息，请参阅[*第10章*](B18726_10.xhtml#_idTextAnchor171)，*加载和操作*
    *纹理*)。
- en: Dragging objects
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖动对象
- en: 'Besides selecting an object, a common requirement is being able to drag and
    move objects around. Three.js also provides default support for this. If you open
    the `dragging-objects.html` example in your browser, you’ll see a similar scene
    to the one shown in *Figure 9**.2*. This time, when you click on an object, you
    can drag it around the scene:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择对象外，一个常见的需求是能够拖动和移动对象。Three.js也为此提供了默认支持。如果你在浏览器中打开`dragging-objects.html`示例，你会看到一个类似于*图9.2*所示的场景。这次，当你点击一个对象时，你可以将其拖动到场景中：
- en: '![Figure 9.4 – Dragging an object around the scene using the mouse](img/Figure_9.4_B18726.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 使用鼠标在场景中拖动对象](img/Figure_9.4_B18726.jpg)'
- en: Figure 9.4 – Dragging an object around the scene using the mouse
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 使用鼠标在场景中拖动对象
- en: 'To support dragging objects, Three.js uses something called `DragControls`.
    This handles everything and provides convenient callbacks whenever the dragging
    starts and stops. The code to accomplish this is shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持拖动对象，Three.js使用一种称为`DragControls`的东西。它处理所有事情，并在拖动开始和停止时提供方便的回调。完成此操作的代码如下：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is as simple as that. Here, we added `DragControls` and passed in the elements
    that can be dragged (in our case, all of the randomly placed cubes). Then, we
    added two event listeners. The first one, `dragstart`, is called when we start
    dragging a cube, whereas `dragend` is called when we stop dragging an object.
    In this example, when we start dragging, we disable `OrbitControls` (which allows
    us to use the mouse to look around the scene) and change the color of the selected
    object. Once we stop dragging, we change the color of the object back and enable
    `OrbitControls` again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单。在这里，我们添加了`DragControls`并传递了可以拖动的元素（在我们的例子中，是所有随机放置的立方体）。然后，我们添加了两个事件监听器。第一个，`dragstart`，在我们开始拖动立方体时被调用，而`dragend`在我们停止拖动对象时被调用。在这个例子中，当我们开始拖动时，我们禁用了`OrbitControls`（它允许我们使用鼠标在场景周围查看）并更改了所选对象的颜色。一旦我们停止拖动，我们将对象的颜色改回并再次启用`OrbitControls`。
- en: 'There is also a somewhat more advanced version of `DragControls` available
    called `TransformControls`. We won’t go into the details of this control, but
    it allows you to use a simple UI to transform the properties of a mesh. You can
    find an example of this control when you open `transform-controls-html` in your
    browser:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种更高级的`DragControls`版本，称为`TransformControls`。我们不会深入探讨这个控制器的细节，但它允许你使用简单的UI来变换网格的属性。当你打开浏览器中的`transform-controls-html`时，你可以找到一个此控制器的示例：
- en: '![Figure 9.5 – Transform controls allow you to change the properties of a mesh](img/Figure_9.5_B18726.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 变换控制器允许你改变网格的属性](img/Figure_9.5_B18726.jpg)'
- en: Figure 9.5 – Transform controls allow you to change the properties of a mesh
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 变换控制器允许你改变网格的属性
- en: 'If you click on the various parts of this control, you can easily change the
    shape of the cube:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击这个控制器的各个部分，你可以轻松地改变立方体的形状：
- en: '![Figure 9.6 – Shape modified using transform controls](img/Figure_9.6_B18726.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 使用变换控制器修改的形状](img/Figure_9.6_B18726.jpg)'
- en: Figure 9.6 – Shape modified using transform controls
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 使用变换控制器修改的形状
- en: For the final example in this chapter, we’ll show you how you can use an alternative
    way of modifying the properties of an object (as we saw in the first example of
    this chapter) by using a tweening library.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个例子中，我们将向你展示如何使用一个替代方法来修改对象的属性（正如我们在本章的第一个例子中所见），即使用缓动库。
- en: Animating with Tween.js
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Tween.js进行动画
- en: 'Tween.js is a small JavaScript library that you can download from [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)
    and that you can use to easily define the transition of a property between two
    values. All the intermediate points between the start and end values are calculated
    for you. This process is called `x` position of a mesh from 10 to 3 in 10 seconds,
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Tween.js 是一个你可以从 [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)
    下载的小型 JavaScript 库，你可以用它轻松地定义两个值之间属性的过渡。从开始值到结束值之间的所有中间点都会为你计算。这个过程被称为将网格的 `x`
    位置从 10 移动到 3，如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, you can create a separate object and pass that into the mesh
    you want to work with:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以创建一个单独的对象并将其传递到你想要与之工作的网格中：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we’ve created `TWEEN.Tween`. This tween will make sure that
    the `x` property is changed from 10 to 3 over 10,000 milliseconds. Tween.js also
    allows you to define how this property is changed over time. This can be done
    using linear, quadratic, or any of the other possibilities (see [http://sole.github.io/tween.js/examples/03_graphs.html](http://sole.github.io/tween.js/examples/03_graphs.html)
    for a complete overview). The value is changed over time by a process called `easing()`
    function. This library also provides additional ways to control how this easing
    is done. For instance, we can set how often the easing should be repeated (`repeat(10)`)
    and whether we want a yoyo effect (this means we go from 10 to 3 and back to 10
    in this example).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了 `TWEEN.Tween`。这个缓动将确保 `x` 属性在 10,000 毫秒内从 10 变化到 3。Tween.js 还允许你定义这个属性随时间如何变化。这可以通过线性、二次或其他任何可能性（参见
    [http://sole.github.io/tween.js/examples/03_graphs.html](http://sole.github.io/tween.js/examples/03_graphs.html)
    以获取完整概述）来实现。值通过名为 `easing()` 的过程随时间变化。这个库还提供了额外的控制方式来决定如何进行缓动。例如，我们可以设置缓动应该重复的频率（`repeat(10)`）以及我们是否想要一个
    yoyo 效果（在这个例子中，这意味着我们从 10 变化到 3，然后再回到 10）。
- en: 'Using this library together with Three.js is very simple. If you open the `tween-animations.html`
    example, you will see the Tween.js library in action. The following screenshot
    shows a still image of the example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个库与 Three.js 一起使用非常简单。如果你打开 `tween-animations.html` 示例，你将看到 Tween.js 库在行动中的表现。以下截图显示了示例的静态图像：
- en: '![Figure 9.7 – Tweening a point system halfway through the action](img/Figure_9.7_B18726.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 在动作中途缓动一个点系统](img/Figure_9.7_B18726.jpg)'
- en: Figure 9.7 – Tweening a point system halfway through the action
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 在动作中途缓动一个点系统
- en: 'We’ll use the Tween.js library to move this to a single point using a specific
    `easing()`, which at a certain point looks as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Tween.js 库通过特定的 `easing()` 来移动这个点到一个单一的位置，这在某个时刻看起来如下：
- en: '![Figure 9.8 – Tweening a point when everything is merged into a single point](img/Figure_9.8_B18726.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 当所有内容合并成一个点时缓动一个点](img/Figure_9.8_B18726.jpg)'
- en: Figure 9.8 – Tweening a point when everything is merged into a single point
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 当所有内容合并成一个点时缓动一个点
- en: 'In this example, we’ve taken a point cloud from [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122),
    and created an animation where all the points slowly move down to the center.
    The position of these particles is set by using a tween created with the Tween.js
    library, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从一个点云（[*第 7 章*](B18726_07.xhtml#_idTextAnchor122)）中提取了一个点，并创建了一个动画，其中所有点都缓慢地移动到中心。这些粒子的位置是通过使用
    Tween.js 库创建的缓动来设置的，如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this piece of code, we created a tween that transitions a value from `1`
    to `0` and back again. To use the value from the tween, we have two different
    options: we can use the `onUpdate` function provided by this library to call a
    function with the updated values, whenever the tween is updated (which is done
    by calling `TWEEN.update()`), or we can directly access the updated values. In
    this example, we used the latter approach.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们创建了一个缓动，它将值从 `1` 变化到 `0` 再变回来。要使用缓动中的值，我们有两种不同的选择：我们可以使用这个库提供的 `onUpdate`
    函数来调用一个函数，该函数带有更新的值，每当缓动更新时（这是通过调用 `TWEEN.update()` 来完成的），或者我们可以直接访问更新的值。在这个例子中，我们使用了后者方法。
- en: 'Before we look at the changes we need to make in the `render` function, we
    must perform one additional step after we load the model. We want to tween between
    the original values to zero and back again. For this, we need to store the original
    positions of the vertices somewhere. We can do this by copying the starting positions
    array:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看需要在 `render` 函数中进行的更改之前，我们必须在加载模型后执行一个额外的步骤。我们想要在原始值和零之间进行缓动。为此，我们需要将顶点的原始位置存储在某个地方。我们可以通过复制起始位置数组来完成此操作：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, whenever we want to access the original position, we can look at the `originalPos`
    attribute on the geometry. Now, we can just use the value from the tween to calculate
    the new positions of each of the vertices. We can do this like so in the render
    loop:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论何时我们想要访问原始位置，我们都可以查看几何体的 `originalPos` 属性。现在，我们可以直接使用 tween 的值来计算每个顶点的新位置。我们可以在渲染循环中这样做：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With these steps in place, the tween library will take care of positioning the
    various points on the screen. As you can see, using this library is much easier
    than having to manage the transitions yourself. Besides animating and changing
    objects, we can also animate a scene by moving the camera around. In the previous
    chapters, we did this a couple of times by manually updating the position of the
    camera. Three.js also provides several additional ways of updating the camera.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤到位后， tween 库将负责处理屏幕上各个点的位置。正如你所见，使用这个库比手动管理过渡要容易得多。除了动画和改变对象，我们还可以通过移动相机来动画化场景。在前面的章节中，我们通过手动更新相机位置做了几次这样的操作。Three.js
    也提供了几种更新相机位置的方法。
- en: Working with the camera
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与相机一起工作
- en: 'Three.js has several camera controls you can use to control the camera throughout
    a scene. These controls are located in the Three.js distribution and can be found
    in the `examples/js/controls` directory. In this section, we’ll look at the following
    controls in more detail:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了几个相机控制，你可以使用它们在场景中控制相机。这些控制位于 Three.js 分发中，可以在 `examples/js/controls`
    目录中找到。在本节中，我们将更详细地查看以下控制：
- en: '`ArcballControls`: An extensive control that provides a transparent overlay
    that you can use to easily move the camera around.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArcballControls`：一个提供透明覆盖层的扩展控制，你可以用它轻松地移动相机。'
- en: '`FirstPersonControls`: These are controls that behave like those in first-person
    shooters. You can move around with the keyboard and look around with the mouse.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstPersonControls`：这些是像第一人称射击游戏中的控制方式。你可以用键盘移动，用鼠标环顾四周。'
- en: '`FlyControls`: These are flight simulator-like controls. You can move and steer
    with the keyboard and the mouse.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlyControls`：这些是类似飞行模拟器的控制。你可以用键盘和鼠标移动和操控。'
- en: '`OrbitControls`: This simulates a satellite in orbit around a specific scene.
    This allows you to move around with the mouse and keyboard.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrbitControls`：这模拟了一个围绕特定场景运行的卫星。这允许你使用鼠标和键盘移动。'
- en: '`PointerLockControls`: These are similar to the first-person controls but they
    also lock the mouse pointer to the screen, making it a great choice for simple
    games.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PointerLockControls`：这些与第一人称控制类似，但它们还会锁定鼠标指针到屏幕上，这使得它们成为简单游戏的一个很好的选择。'
- en: '`TrackBallControls`: These are the most-used controls, allowing you to use
    the mouse (or the trackball) to easily move, pan, and zoom around the scene.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TrackBallControls`：这些是最常用的控制，允许你使用鼠标（或轨迹球）轻松地移动、平移和缩放场景。'
- en: Besides using these camera controls, you can also move the camera yourself by
    setting its position and changing where it is pointed using the `lookAt()` function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用这些相机控制，你也可以通过设置其位置并使用 `lookAt()` 函数改变其指向来自行移动相机。
- en: The first control we’ll look at is `ArcballControls`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下 `ArcballControls`。
- en: ArcballControls
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ArcballControls
- en: 'The easiest way to explain how `ArcballControls` works is by looking at an
    example. If you open up the `arcball-controls.html` example, you’ll see a simple
    scene, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解释 `ArcballControls` 的工作方式最简单的方法是查看一个示例。如果你打开 `arcball-controls.html` 示例，你会看到一个简单的场景，就像这样：
- en: '![Figure 9.9 – Using ArcballControls to explore a scene](img/Figure_9.9_B18726.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 使用 ArcballControls 探索场景](img/Figure_9.9_B18726.jpg)'
- en: Figure 9.9 – Using ArcballControls to explore a scene
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 使用 ArcballControls 探索场景
- en: If you look closely at this screenshot, you will see two translucent lines crossing
    the scene. These are lines provided by `ArcballControls`, which you can use to
    rotate and pan around the scene. These lines are called **gizmos**. The left mouse
    button is used to rotate the scene, the right mouse button can be used to pan
    around, and you can zoom in with the scroll wheel.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察这张截图，你会看到两条透明的线条穿过场景。这些是由 `ArcballControls` 提供的线条，你可以使用它们来旋转和平移场景。这些线条被称为
    **gizmos**。左键用于旋转场景，右键可以用来平移，滚动鼠标滚轮可以放大。
- en: 'Besides this standard functionally, this control also allows you to focus on
    specific parts of the mesh that is shown. If you double-click on the scene, the
    camera will focus on that part of the scene. To use this control, all we need
    to do is instantiate it and pass in the `camera` property, the `domElement` property
    used by the renderer, and the `scene` property we’re looking at:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些标准功能外，此控件还允许您聚焦于显示的网格的特定部分。如果您在场景上双击，相机将聚焦于该部分场景。要使用此控件，我们只需要实例化它，并传入 `camera`
    属性、由渲染器使用的 `domElement` 属性以及我们正在查看的 `scene` 属性：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This control is a very versatile one, which can be configured through a set
    of properties. Most of these properties can be explored in this example by using
    the menu on the right of this example. For this specific control, we’ll dive a
    bit deeper into the properties and methods provided by this object since it is
    a versatile control and a good choice when you want to provide a good way for
    your users to explore your scenes. Let’s provide an overview of the properties
    and the methods provided by this control. First, let’s look at the properties:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此控件非常灵活，可以通过一系列属性进行配置。大多数这些属性可以通过使用此示例右侧的菜单在此示例中进行探索。对于这个特定的控件，我们将更深入地探讨此对象提供的属性和方法，因为它是一个多功能的控件，当您希望为用户提供一种良好的方式来探索您的场景时，它是一个很好的选择。让我们概述一下此控件提供的属性和方法。首先，让我们看看属性：
- en: '`adjustNearFar`: If this is set to `true`, this control will change the camera’s
    `near` and `far` properties when zooming in'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adjustNearFar`: 如果设置为 `true`，则此控件在放大时将更改相机的 `near` 和 `far` 属性'
- en: '`camera`: The camera that’s used when creating this control'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`camera`: 创建此控件时使用的相机'
- en: '`cursorZoom`: If set to `true`, when zooming in, the zoom will be focused on
    the position of the cursor'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cursorZoom`: 如果设置为 `true`，当放大时，缩放将聚焦于光标的位置'
- en: '`dampingFactor`: If `enableAnimations` is set to `true`, this value will determine
    how quickly an animation stops after an action'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dampingFactor`: 如果 `enableAnimations` 设置为 `true`，则此值将确定动作后动画停止的速度'
- en: '`domElement`: This element is used to list mouse events'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domElement`: 此元素用于列出鼠标事件'
- en: '`enabled`: Determines whether this control is enabled or not'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`: 确定此控件是否启用'
- en: '`enableRotate`, `enableZoom`, `enablePan`, `enableGrid`, `enableAnimations`:
    These properties enable and disable functionality provided by this control'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enableRotate`, `enableZoom`, `enablePan`, `enableGrid`, `enableAnimations`:
    这些属性启用和禁用此控件提供的功能'
- en: '`focusAnimationTime`: When we double-click and focus on part of the scene,
    this property determines the duration of the focusing animation'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focusAnimationTime`: 当我们双击并聚焦于场景的一部分时，此属性确定聚焦动画的持续时间'
- en: '`maxDistance`/`minDistance`: How far we can zoom out and in for `PerspectiveCamera`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxDistance`/`minDistance`: 对于 `PerspectiveCamera`，我们可以缩放的最远和最近距离'
- en: '`maxZoom`/`minZoom`: How far we can zoom out and in for `OrthographicCamera`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxZoom`/`minZoom`: 对于 `OrthographicCamera`，我们可以缩放的最远和最近距离'
- en: '`scaleFactor`: How fast we zoom in and out'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaleFactor`: 我们缩放和缩小的速度'
- en: '`scene`: The scene passed in the constructor'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scene`: 构造函数中传入的场景'
- en: '`radiusFactor`: The size of the “gizmo” relative to the screen’s width and
    height'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radiusFactor`: “辅助工具”相对于屏幕宽度和高度的大小'
- en: '`wMax`: How fast we’re allowed to rotate the scene'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wMax`: 我们允许场景旋转的速度'
- en: 'This control also provides several methods to interact or configure it further:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此控件还提供了一些方法来进一步交互或配置它：
- en: '`activateGizmos(bool)`: If `true`, it highlights the gizmos'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activateGizmos(bool)`: 如果为 `true`，则突出显示辅助工具'
- en: '`copyState()`, `pasteState()`: Allows you to copy and paste the state of the
    controls to the clipboard in JSON'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copyState()`, `pasteState()`: 允许您将控件的当前状态以 JSON 格式复制到剪贴板'
- en: '`saveState()`, `reset()`: Internally saves the current state and uses `reset()`
    to apply the saved state'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saveState()`, `reset()`: 内部保存当前状态，并使用 `reset()` 应用保存的状态'
- en: '`dispose()`: Removes all parts of this control from the scene, and cleans up
    any listeners and animations'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispose()`: 从场景中移除此控件的全部部分，并清理任何监听器和动画'
- en: '`setGizomsVisible(bool)`: Specifies whether to show or hide the gizmos'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setGizomsVisible(bool)`: 指定是否显示或隐藏辅助工具'
- en: '`setTbRadius(radiusFactor)`: Updates the `radiusFactor` property and redraws
    the gizmos'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTbRadius(radiusFactor)`: 更新 `radiusFactor` 属性并重新绘制辅助工具'
- en: '`setMouseAction(operation, mouse, key)`: Determines which mouse key provides
    which action'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMouseAction(operation, mouse, key)`: 确定哪个鼠标键提供哪个动作'
- en: '`unsetMouseAction(mouse, key)`: Clears an assigned mouse action'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsetMouseAction(mouse, key)`: 清除已分配的鼠标动作'
- en: '`update()`: Whenever the camera properties change, call this to apply these
    new settings to this control'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`: 当相机属性改变时，调用此函数以应用这些新设置到该控制。'
- en: '`getRayCaster()`: Provides access to `rayCaster`, which is used internally
    by these controls'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRayCaster()`: 提供对 `rayCaster` 的访问，这些控制内部使用。'
- en: '`ArcballControls` is a really useful and relatively new addition to Three.js
    that provides advanced control of the scene using the mouse. If you’re looking
    for a simpler approach, you can use `TrackBallControls`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArcballControls` 是 Three.js 中一个非常有用且相对较新的功能，它允许使用鼠标对场景进行高级控制。如果你在寻找一个更简单的方法，可以使用
    `TrackBallControls`。'
- en: TrackBallControls
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TrackBallControls
- en: 'Using `TrackBallControls` follows the same approach as we saw for `ArcballControls`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TrackBallControls` 的方法与我们在 `ArcballControls` 中看到的方法相同：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This time, we just need to pass in the `camera` and `domeElement` properties
    from the renderer. For the trackball controls to work, we also need to add a `THREE.Clock`
    and update the render loop, like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们只需要传递来自渲染器的 `camera` 和 `domeElement` 属性。为了使轨道球控制工作，我们还需要添加一个 `THREE.Clock`
    并更新渲染循环，如下所示：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we can see a new Three.js object, `THREE.Clock`.
    The `THREE.Clock` object can be used to calculate the elapsed time that a specific
    invocation or rendering loop takes to complete. You can do this by calling the
    `clock.getDelta()` function. This function will return the elapsed time between
    this call and the previous call to `getDelta()`. To update the position of the
    camera, we can call the `TrackBallControls.update()` function. In this function,
    we need to provide the time that has passed since the last time this update function
    was called. For this, we can use the `getDelta()` function from the `THREE.Clock`
    object. You might be wondering why we don’t just pass in the frame rate (1/60
    seconds) to the update function. The reason is that with `requestAnimationFrame`,
    we can expect 60 FPS, but this isn’t guaranteed. Depending on all kinds of external
    factors, the frame rate might change. To make sure the camera turns and rotates
    smoothly, we need to pass in the exact elapsed time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到一个新 Three.js 对象，`THREE.Clock`。`THREE.Clock` 对象可以用来计算特定调用或渲染循环完成所花费的经过时间。你可以通过调用
    `clock.getDelta()` 函数来实现这一点。此函数将返回从上一次调用 `getDelta()` 到这次调用的经过时间。为了更新相机的位置，我们可以调用
    `TrackBallControls.update()` 函数。在这个函数中，我们需要提供自上次调用此更新函数以来经过的时间。为此，我们可以使用 `THREE.Clock`
    对象的 `getDelta()` 函数。你可能想知道为什么我们不直接将帧率（1/60秒）传递给更新函数。原因是，使用 `requestAnimationFrame`，我们期望
    60 FPS，但这并不是保证的。根据所有各种外部因素，帧率可能会变化。为了确保相机平稳地旋转和旋转，我们需要传递确切的经过时间。
- en: 'A working example of this can be found in `trackball-controls-camera.html`.
    The following screenshot shows a still image of this example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `trackball-controls-camera.html` 中找到一个使用此功能的示例。以下截图显示了该示例的静态图像：
- en: '![Figure 9.10 – Using TrackBallControls to control a scene](img/Figure_9.10_B18726.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 使用 TrackBallControls 控制场景](img/Figure_9.10_B18726.jpg)'
- en: Figure 9.10 – Using TrackBallControls to control a scene
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 使用 TrackBallControls 控制场景
- en: 'You can control the camera in the following manner:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式控制相机：
- en: '**Left mouse button and move**: Rotate and roll the camera around the scene'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左键点击并移动**：绕场景旋转和翻滚相机。'
- en: '**Scroll wheel**: Zoom in and zoom out'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚轮**：放大和缩小。'
- en: '**Middle mouse button and move**: Zoom in and zoom out'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中键点击并移动**：放大和缩小。'
- en: '**Right mouse button and move**: Pan around the scene'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右键点击并移动**：在场景中平移。'
- en: There are a couple of properties that you can use to fine-tune how the camera
    acts. For instance, you can set how fast the camera rotates with the `rotateSpeed`
    property and disable zooming by setting the `noZoom` property to `true`. In this
    chapter, we won’t go into detail on what each property does as they are pretty
    much self-explanatory. For a complete overview of what is possible, look at the
    source of the `TrackBallControls.js` file, where these properties are listed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一些属性来微调相机的行为。例如，你可以使用 `rotateSpeed` 属性设置相机旋转的速度，并通过将 `noZoom` 属性设置为 `true`
    来禁用缩放。在本章中，我们不会详细介绍每个属性的作用，因为它们基本上是自我解释的。要了解完整的概述，请查看 `TrackBallControls.js` 文件的源代码，其中列出了这些属性。
- en: FlyControls
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FlyControls
- en: 'The next control we’ll look at is `FlyControls`. With `FlyControls`, you can
    fly around a scene using controls also found in flight simulators. An example
    can be found in `fly-controls-camera.html`. The following screenshot shows a still
    image of this example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的控制是 `FlyControls`。使用 `FlyControls`，你可以使用在飞行模拟器中找到的控制来在场景中飞行。你可以在 `fly-controls-camera.html`
    中找到一个示例。以下截图显示了该示例的静态图像：
- en: '![Figure 9.11 – Using FlyControls to fly around a scene](img/Figure_9.11_B18726.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 使用 FlyControls 在场景中飞行](img/Figure_9.11_B18726.jpg)'
- en: Figure 9.11 – Using FlyControls to fly around a scene
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 使用 FlyControls 在场景中飞行
- en: 'Enabling `FlyControls` works in the same manner as the other controls:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 `FlyControls` 与其他控制的工作方式相同：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`FlyControls` takes the camera and the renderer’s `domElement` as arguments
    and requires that you call the `update()` function with the elapsed time in the
    render loop. You can control the camera with `THREE.FlyControls` in the following
    manner:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlyControls` 将相机和渲染器的 `domElement` 作为参数，并要求你在渲染循环中调用带有经过时间的 `update()` 函数。你可以用以下方式使用
    `THREE.FlyControls` 来控制相机：'
- en: '**Left and middle mouse buttons**: Start moving forward'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左键和中间鼠标按钮**：开始向前移动'
- en: '**Right mouse button**: Move backward'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右鼠标按钮**：向后移动'
- en: '**Mouse movement**: Look around'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鼠标移动**：四处查看'
- en: '*W*: Start moving forward'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*W*：开始向前移动'
- en: '*S*: Move backward'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S*：向后移动'
- en: '*A*: Move left'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*：向左移动'
- en: '*D*: Move right'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*：向右移动'
- en: '*R*: Move up'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R*：向上移动'
- en: '*F*: Move down'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F*：向下移动'
- en: '**Left, right, up, and down arrows**: Look left, right, up, and down, respectively'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左、右、上、下箭头**：分别向左、右、上、下查看'
- en: '*G*: Roll left'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*G*：向左翻滚'
- en: '*E*: Roll right'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*：向右翻滚'
- en: The next control we’ll look at is `THREE.FirstPersonControls`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的控制是 `THREE.FirstPersonControls`。
- en: FirstPersonControls
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FirstPersonControls
- en: 'As the name implies, `FirstPersonControls` allows you to control the camera
    just like in a first-person shooter. The mouse is used to look around, and the
    keyboard is used to walk around. You can find an example in `07-first-person-camera.html`.
    The following screenshot shows a still image of this example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`FirstPersonControls` 允许你像在第一人称射击游戏中一样控制相机。鼠标用于四处查看，键盘用于移动。你可以在 `07-first-person-camera.html`
    中找到一个示例。以下截图显示了该示例的静态图像：
- en: '![Figure 9.12 – Exploring a scene using the first-person controls](img/Figure_9.12_B18726.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 使用第一人称控制探索场景](img/Figure_9.12_B18726.jpg)'
- en: Figure 9.12 – Exploring a scene using the first-person controls
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 使用第一人称控制探索场景
- en: 'Creating these controls follows the same principles as the ones followed for
    the other controls we’ve seen so far:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些控制遵循的原则与之前我们看到的其他控制相同：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The functionality provided by this control is pretty straightforward:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制提供的功能相当直接：
- en: '**Mouse movement**: Look around'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鼠标移动**：四处查看'
- en: '**Left, right, up, and down arrows**: Move left, right, forward, and backward,
    respectively'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左、右、上、下箭头**：分别向左、右、前、后移动'
- en: '*W*: Move forward'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*W*：向前移动'
- en: '*A*: Move left'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*：向左移动'
- en: '*S*: Move backward'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S*：向后移动'
- en: '*D*: Move right'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*：向右移动'
- en: '*R*: Move up'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R*：向上移动'
- en: '*F*: Move down'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F*：向下移动'
- en: '*Q*: Stop all movement'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Q*：停止所有移动'
- en: For the final control, we’ll move on from this first-person perspective to the
    perspective from space.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个控制，我们将从第一人称视角转向太空视角。
- en: OrbitControls
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OrbitControls
- en: The `OrbitControls` control is a great way to rotate and pan around an object
    in the center of the scene. This is also the control we used in the other chapters
    to provide you with a simple way to explore the models in the examples provided.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrbitControls` 控制是一种很好的方法，可以在场景中心旋转和平移对象。这也是我们在其他章节中使用的方法，为你提供了一个简单的方式来探索提供的示例中的模型。'
- en: 'With `orbit-controls-orbit-camera.html`, we’ve included an example that shows
    how this control works. The following screenshot shows a still image of this example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `orbit-controls-orbit-camera.html`，我们提供了一个示例，展示了这个控制是如何工作的。以下截图显示了该示例的静态图像：
- en: '![Figure 9.13 – OrbitControls properties](img/Figure_9.13_B18726.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – OrbitControls 属性](img/Figure_9.13_B18726.jpg)'
- en: Figure 9.13 – OrbitControls properties
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – OrbitControls 属性
- en: 'Using `OrbitControls` is just as simple as using the other controls. Include
    the correct JavaScript file, set up the control with the camera, and use `THREE.Clock`
    again to update the control:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `OrbitControls` 与使用其他控制一样简单。包含正确的 JavaScript 文件，使用相机设置控制，并再次使用 `THREE.Clock`
    来更新控制：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The controls for `OrbitControls` are focused on using the mouse, as shown in
    the following list:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrbitControls` 的控制主要依赖于鼠标操作，如下所示列表：'
- en: '**Left mouse click and move**: Rotate the camera around the center of the scene'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左键点击并移动**：围绕场景中心旋转相机'
- en: '**Scroll wheel or middle mouse click and move**: Zoom in and zoom out'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚轮或中间鼠标点击并移动**：放大和缩小'
- en: '**Right mouse click and move**: Pan around the scene'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右键点击并移动**：在场景中平移'
- en: 'That’s it for the camera and moving it around. In this section, we saw a lot
    of controls that allow you to easily interact with and move through a scene by
    changing the camera properties. In the next section, we’ll look at more advanced
    methods of animation: morphing and skinning.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于相机及其移动就到这里。在本节中，我们看到了许多允许你通过改变相机属性轻松交互和移动场景的控制。在下一节中，我们将探讨更高级的动画方法：形变和蒙皮。
- en: Morphing and skeleton animation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形变和骨骼动画
- en: 'When you create animations in external programs (for instance, Blender), you
    usually have two main options to define animations:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在外部程序（例如 Blender）中创建动画时，通常有两个主要选项来定义动画：
- en: '**Morph targets**: With morph targets, you define a deformed version – that
    is, a key position – of the mesh. For this deformed target, all vertex positions
    are stored. All you need to do to animate the shape is move all the vertices from
    one position to another key position and repeat that process. The following screenshot
    shows various morph targets used to show facial expressions (this screenshot has
    been provided by the Blender foundation):'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形变目标**：使用形变目标，你定义网格的变形版本——即关键位置。对于这个变形目标，存储了所有顶点的位置。要动画化形状，你只需将所有顶点从一个位置移动到另一个关键位置，并重复此过程。以下截图显示了用于展示面部表情的各种形变目标（此截图由
    Blender 基金会提供）：'
- en: '![Figure 9.14 – Setting up animations using morph targets](img/Figure_9.14_B18726.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 使用形变目标设置动画](img/Figure_9.14_B18726.jpg)'
- en: Figure 9.14 – Setting up animations using morph targets
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 使用形变目标设置动画
- en: '**Skeleton animation**: An alternative is using skeleton animation. With skeletal
    animation, you define the skeleton – that is, the bones – of the mesh and attach
    vertices to the specific bones. Now, when you move a bone, any connected bone
    is also moved appropriately, and the attached vertices are moved and deformed
    based on the position, movement, and scaling of the bone. The following screenshot,
    once again provided by the Blender foundation, shows an example of how bones can
    be used to move and deform an object:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼动画**：另一种选择是使用骨骼动画。在骨骼动画中，你定义网格的骨骼（即骨骼），并将顶点附着到特定的骨骼上。现在，当你移动一个骨骼时，任何连接的骨骼也会相应地移动，并且附着的顶点会根据骨骼的位置、运动和缩放进行移动和变形。以下截图，再次由
    Blender 基金会提供，展示了如何使用骨骼来移动和变形对象：'
- en: '![Figure 9.15 – Setting up animations using bones](img/Figure_9.15_B18726.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – 使用骨骼设置动画](img/Figure_9.15_B18726.jpg)'
- en: Figure 9.15 – Setting up animations using bones
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 使用骨骼设置动画
- en: Three.js supports both modes, but there can be an issue getting a good export
    when you want to work with skeleton/bones-based animations. For the best results,
    you should export or convert your model into glTF format, which is becoming the
    default for exchanging models, animations, and scenes, and has great support from
    Three.js.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 支持这两种模式，但在处理基于骨骼/骨骼的动画时，可能会遇到导出良好的问题。为了获得最佳结果，你应该将你的模型导出或转换为 glTF 格式，该格式正成为交换模型、动画和场景的默认格式，并且得到了
    Three.js 的良好支持。
- en: In this section, we’ll look at both options and also look at a couple of external
    formats supported by Three.js in which animations can be defined.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨这两种选项，并查看 Three.js 支持的几种外部格式，在这些格式中可以定义动画。
- en: Animation with morph targets
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于形变目标的动画
- en: Morph targets are the most straightforward way of defining an animation. You
    define all the vertices for each important position (also called keyframes) and
    tell Three.js to move the vertices from one position to the other.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 形变目标是定义动画最直接的方式。你为每个重要位置（也称为关键帧）定义所有顶点，并告诉 Three.js 将顶点从一个位置移动到另一个位置。
- en: We’ll show you how to work with morph targets using two examples. In the first
    example, we’ll let Three.js handle the transition between the various keyframes
    (or morph targets, as we’ll call them from now on), and in the second one, we’ll
    do this manually. Keep in mind that we are only scratching the surface of what
    is possible with animations in Three.js. As you’ll see in this section, Three.js
    has excellent support for controlling animations, supports syncing of animations,
    and provides ways to smoothly transition from one animation to another, warranting
    a book just on this subject. So, in the next couple of sections, we’ll provide
    you with the basics of animations in Three.js, which should provide you with enough
    information to get started and explore the more complex subjects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过两个例子向你展示如何使用变形目标。在第一个例子中，我们将让Three.js处理各种关键帧（或我们接下来将称之为变形目标）之间的过渡，而在第二个例子中，我们将手动完成这个操作。请记住，我们只是在Three.js动画的表面略作探讨。正如你将在本节中看到的那样，Three.js对动画控制有出色的支持，支持动画同步，并提供从一种动画平滑过渡到另一种动画的方法，这足以写一本书来专门讨论这个主题。因此，在接下来的几个部分中，我们将为你提供Three.js动画的基础知识，这应该为你提供足够的信息来开始并探索更复杂的话题。
- en: Animation with a mixer and morph targets
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用混合器和变形目标进行动画
- en: 'Before we dive into the examples, first, we’ll look at the three core classes
    that you can use to animate with Three.js. Later in this chapter, we’ll show you
    all the functions and properties provided by these objects:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入例子之前，首先，我们将探讨你可以使用Three.js进行动画的三种核心类。在本章的后面部分，我们将向你展示这些对象提供的所有函数和属性：
- en: '`THREE.AnimationClip`: When you load a model that contains animations, you
    can look in the `response` object for a field usually called `animations`. This
    field will contain a list of `THREE.AnimationClip` objects. Note that depending
    on the loader, an animation might be defined on a `Mesh`, a `Scene`, or be provided
    completely separately. A `THREE.AnimationClip` most often holds the data for a
    certain animation the model you loaded can perform. For instance, if you loaded
    a model of a bird, one `THREE.AnimationClip` would contain the information needed
    to flap the wings, and another one might be opening and closing its beak.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.AnimationClip`：当你加载包含动画的模型时，你可以在`response`对象中查找通常称为`animations`的字段。这个字段将包含一个`THREE.AnimationClip`对象的列表。请注意，根据加载器，动画可能定义在`Mesh`上、`Scene`上，或者完全独立提供。一个`THREE.AnimationClip`通常包含加载的模型可以执行的一定动画的数据。例如，如果你加载了一只鸟的模型，一个`THREE.AnimationClip`将包含拍打翅膀所需的信息，另一个可能包含张嘴和闭嘴的信息。'
- en: '`THREE.AnimationMixer`: `THREE.AnimationMixer` is used to control several `THREE.AnimationClip`
    objects. It makes sure the timing of the animation is correct and makes it possible
    to sync animations together, or cleanly move from one animation to another.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.AnimationMixer`：`THREE.AnimationMixer`用于控制多个`THREE.AnimationClip`对象。它确保动画的时间正确，并使得同步动画或从一种动画干净地过渡到另一种动画成为可能。'
- en: '`THREE.AnimationAction`: `THREE.AnimationMixer` itself doesn’t expose a large
    number of functions to control the animation, though. This is done through `THREE.AnimationAction`
    objects, which are returned when you add a `THREE.AnimationClip` to a `THREE.AnimationMixer`
    (though you can get them at a later time by using functions provided by `THREE.AnimationMixer`).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.AnimationAction`：尽管`THREE.AnimationMixer`本身并没有暴露大量的函数来控制动画，但这通过`THREE.AnimationAction`对象来完成，当你将一个`THREE.AnimationClip`添加到`THREE.AnimationMixer`时，会返回这些对象（尽管你可以通过`THREE.AnimationMixer`提供的函数在稍后获取它们）。'
- en: There is also an `AnimationObjectGroup`, which you can use to provide the animation
    state not just to a single `Mesh` but to a group of objects.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`AnimationObjectGroup`，你可以使用它来提供动画状态，不仅限于单个`Mesh`，还可以是一组对象。
- en: In the following example, you can control a `THREE.AnimationMixer` and a `THREE.AnimationAction`,
    which were created using a `THREE.AnimationClip` from the model. The `THREE.AnimationClip`
    objects used in this example morph a model into a cube and then into a cylinder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你可以控制使用模型中的`THREE.AnimationClip`创建的`THREE.AnimationMixer`和`THREE.AnimationAction`。在这个例子中，`THREE.AnimationClip`对象将模型变形为一个立方体，然后变为一个圆柱体。
- en: 'For this first morphing example, the easiest way to understand how a morph
    targets-based animation works is by opening up the `morph-targets.html` example.
    The following screenshot shows a still image of this example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个变形例子，理解基于变形目标的动画工作原理的最简单方法是通过打开`morph-targets.html`示例。以下截图显示了该示例的静态图像：
- en: '![Figure 9.16 – Animation using morph targets](img/Figure_9.16_B18726.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – 使用变形目标进行动画](img/Figure_9.16_B18726.jpg)'
- en: Figure 9.16 – Animation using morph targets
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 使用变形目标进行动画
- en: 'In this example, we’ve got a simple model (a monkey’s head), which can be transformed
    into either a cube or a cylinder using morph targets. You can easily test this
    yourself by moving the `cubeTarget` or `coneTarget` sliders, and you’ll see the
    head being morphed into a different shape. For instance, with `cubeTarget` at
    `0.5`, you will see that we’re halfway through morphing the monkey’s initial head
    into a cube. Once it is at `1`, the initial geometry is morphed completely:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个简单的模型（猴子的头部），可以使用变形目标将其转换为立方体或圆柱体。你可以通过移动 `cubeTarget` 或 `coneTarget`
    滑块轻松测试这一点，你会看到头部被变形为不同的形状。例如，当 `cubeTarget` 在 `0.5` 时，你会看到我们正在将猴子的初始头部变形为立方体的中途。一旦它达到
    `1`，初始几何形状就完全变形了：
- en: '![Figure 9.17 – Same model, but now with cubeTarget set to 1](img/Figure_9.17_B18726.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – 同样的模型，但现在将 cubeTarget 设置为 1](img/Figure_9.17_B18726.jpg)'
- en: Figure 9.17 – Same model, but now with cubeTarget set to 1
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 同样的模型，但现在将 cubeTarget 设置为 1
- en: And that’s the basics of how morph animations work. You’ve got several `morphTargets`
    (influences) you can control, and based on their value (from 0 to 1), the vertices
    move into the desired position. An animation that uses morph targets uses this
    approach. It just defines at which time certain vertex positions should occur.
    When running the animation, Three.js will make sure the right values are passed
    to the `morphTargets` property of the `Mesh` instance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是变形动画的基本原理。你有几个可以控制的 `morphTargets`（影响），根据它们的值（从 0 到 1），顶点移动到期望的位置。使用变形目标的动画使用这种方法。它只是定义了在哪个时间某些顶点位置应该发生。当运行动画时，Three.js
    将确保将正确的值传递给 `Mesh` 实例的 `morphTargets` 属性。
- en: To run the predefined animation, you can open the `AnimationMixer` menu for
    this example, and click **Play**. You’ll see that the head will first transform
    into a cube and then into a cylinder, before moving back into the shape of a head.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行预定义的动画，你可以打开此示例的 `AnimationMixer` 菜单，然后点击 **播放**。你会看到头部首先变成一个立方体，然后变成一个圆柱体，最后再变回头部形状。
- en: 'Setting up the required components to accomplish this in Three.js can be done
    using the following pieces of code. First, we have to load the model. In this
    example, we exported this example from Blender into glTF, so our `animations`
    are at the top level. We simply add these to a variable that we can access in
    the other parts of the code. We could also set this as a property on the mesh
    or add it to the `userdata` property of `Mesh`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中设置完成此操作的必要组件可以使用以下代码片段完成。首先，我们必须加载模型。在这个例子中，我们将此示例从 Blender 导出为
    glTF，因此我们的 `animations` 在顶层。我们只需将这些添加到一个变量中，我们可以在代码的其他部分访问它。我们也可以将此设置为网格的属性或添加到
    `Mesh` 的 `userdata` 属性中：
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we’ve got an animation from the loaded model, we can set up the specific
    Three.js components so that we can play them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从加载的模型中获得了动画，我们可以设置特定的 Three.js 组件，以便我们可以播放它们：
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is one final step we need to take so that the correct shape of the mesh
    is shown whenever we render something, and that is adding a single line to the
    render loop:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的最后一步是确保每次渲染时都能显示网格的正确形状，那就是在渲染循环中添加一行代码：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we used `THREE.Clock` again to determine the time that’s passed between
    now and the previous render loop, and called `mixer.update()`. This information
    is used by the mixer to determine how far it should morph the vertices to the
    next morph target (keyframe).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用了 `THREE.Clock` 来确定现在和上一个渲染循环之间经过的时间，并调用了 `mixer.update()`。这个信息被混音器用来确定它应该将顶点转换到下一个变形目标（关键帧）有多远。
- en: '`THREE.AnimationMixer` and `THREE.AnimationClip` provide several other functions
    that you can use to control the animation or create new `THREE.AnimationClip`
    objects. You can experiment with them by using the menu on the right in the examples
    for this section. We will start with `THREE.AnimationClip`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.AnimationMixer` 和 `THREE.AnimationClip` 提供了其他一些你可以用来控制动画或创建新的 `THREE.AnimationClip`
    对象的功能。你可以通过使用本节示例右侧的菜单来实验它们。我们将从 `THREE.AnimationClip` 开始：'
- en: '`duration`: The duration of this track (in seconds).'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`：此轨道的持续时间（以秒为单位）。'
- en: '`name`: The name of this clip.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：此剪辑的名称。'
- en: '`tracks`: The internal property used to keep track of how certain properties
    of the model are animated.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tracks`：用于跟踪模型某些属性如何动画化的内部属性。'
- en: '`uuid`: The unique ID of this clip. This is assigned automatically.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uuid`: 此剪辑的唯一 ID。这是自动分配的。'
- en: '`clone()`: Makes a copy of this clip.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone()`: 创建此剪辑的副本。'
- en: '`optimize()`: This optimizes `THREE.AnimationClip`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optimize()`: 优化 `THREE.AnimationClip`。'
- en: '`resetDuration()`: This determines the correct duration of this clip.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resetDuration()`: 确定此剪辑的正确持续时间。'
- en: '`toJson()`: Converts this clip into a JSON object.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toJson()`: 将此剪辑转换为 JSON 对象。'
- en: '`trim()`: This trims all the internal tracks to the duration set on this clip.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim()`: 将所有内部轨道修剪到在此剪辑上设置的持续时间。'
- en: '`validate()`: Does some minimal validation to see if this is a valid clip.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate()`: 进行一些基本的验证，以查看此剪辑是否有效。'
- en: '`CreateClipsFromMorphTargetSequences( name, morphTargetSequences,fps, noLoop)`:
    This creates a list of `THREE.AnimationClip` instances based on a set of morph
    target sequences.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateClipsFromMorphTargetSequences( name, morphTargetSequences,fps, noLoop)`:
    根据一组形变目标序列创建一系列 `THREE.AnimationClip` 实例。'
- en: '`CreateFromMorpTargetSequences( name, morphTargetSequence,fps,noLoop)`: This
    creates a single `THREE.AnimationClip` from a sequence of morph targets.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateFromMorpTargetSequences( name, morphTargetSequence,fps,noLoop)`: 从一系列形变目标中创建单个
    `THREE.AnimationClip`。'
- en: '`findByName(objectOrClipArray, name)`: Searches for a `THREE.AnimationClip`
    by name.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findByName(objectOrClipArray, name)`: 通过名称搜索 `THREE.AnimationClip`。'
- en: '`parse` and `toJson`: Allow you to restore and save a `Three.AnimationClip`
    as JSON, respectively.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parse` 和 `toJson`: 允许你分别将 `Three.AnimationClip` 作为 JSON 恢复和保存。'
- en: '`parseAnimation(animation, bones)`: Converts an `THREE.AnimationClip` into
    JSON.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parseAnimation(animation, bones)`: 将 `THREE.AnimationClip` 转换为 JSON。'
- en: 'Once you’ve got a `THREE.AnimationClip`, you can pass it into the `THREE.AnimationMixer`
    object, which provides the following functionality:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到了 `THREE.AnimationClip`，你可以将其传递给 `THREE.AnimationMixer` 对象，该对象提供以下功能：
- en: '`AnimationMixer(rootObject)`: The constructor for this object. This constructor
    takes a `THREE.Object3D` as an argument (for example, a `THREE.Mesh` of a `THREE.Group`).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimationMixer(rootObject)`: 此对象的构造函数。此构造函数接受一个 `THREE.Object3D` 参数（例如，一个
    `THREE.Mesh` 或 `THREE.Group` 的 `THREE.Mesh`）。'
- en: '`time`: The global time for this mixer. This starts at 0, at the time when
    this mixer is created.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`: 此混音器的全局时间。它从 0 开始，在创建此混音器的时间。'
- en: '`timeScale`: This can be used to speed up or slow down all the animations managed
    by this mixer. If the value of this property is set to 0, all the animations are
    effectively paused.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeScale`: 可以用来加快或减慢由此混音器管理的所有动画。如果此属性的值设置为 0，则所有动画都将被有效地暂停。'
- en: '`clipAction(animationClip, optionalRoot)`: This creates a `THREE.AnimationAction`
    that can be used to control the passed-in `THREE.AnimationClip`. If the animation
    clip is for a different object than what was provided in the constructor of `AnimationMixer`,
    you can pass that in as well.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clipAction(animationClip, optionalRoot)`: 创建一个 `THREE.AnimationAction`，可以用来控制传入的
    `THREE.AnimationClip`。如果动画剪辑是为与 `AnimationMixer` 构造函数中提供的对象不同的对象，你也可以传入它。'
- en: '`existingAction(animationClip, optionalRoot)`: This returns the `THREE.AnimationAction`
    property, which can be used to control the passed-in `THREE.AnimationClip`. Once
    again, if `THREE.AnimationClip` is for a different `rootObject`, you can also
    pass that in.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`existingAction(animationClip, optionalRoot)`: 这返回了 `THREE.AnimationAction`
    属性，可以用来控制传入的 `THREE.AnimationClip`。再次强调，如果 `THREE.AnimationClip` 是针对不同的 `rootObject`，你也可以传入它。'
- en: 'When you get `THREE.AnimationClip` back, you can use it to control the animation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你获取 `THREE.AnimationClip` 时，你可以用它来控制动画：
- en: '`clampWhenFinished`: When set to `true`, this will cause the animation to be
    paused when it reaches its last frame. The default is `false`.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clampWhenFinished`: 当设置为 `true` 时，当动画到达最后一帧时，这将导致动画暂停。默认为 `false`。'
- en: '`enabled`: When set to `false`, this will disable the current action so that
    it does not affect the model. When the action is re-enabled, the animation will
    continue where it left off.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`: 当设置为 `false` 时，这将禁用当前动作，使其不影响模型。当动作重新启用时，动画将从上次停止的地方继续。'
- en: '`loop`: This is the looping mode of this action (which can be set using the
    `setLoop` function). This can be set to the following:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`: 这是此动作的循环模式（可以使用 `setLoop` 函数设置）。可以设置为以下几种：'
- en: '`THREE.LoopOnce`: Plays the clip only one time'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LoopOnce`: 只播放一次剪辑'
- en: '`THREE.LoopRepeat`: Repeats the clip based on the number of repetitions that
    have been set'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LoopRepeat`: 根据设置的重复次数重复剪辑'
- en: '`THREE.LoopPingPong`: Plays the clip based on the number of repetitions, but
    alternates between playing the clip forward and backward'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LoopPingPong`: 根据重复次数播放剪辑，但会在正向和反向之间交替播放'
- en: '`paused`: Setting this property to `true` will pause the execution of this
    clip.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paused`: 将此属性设置为 `true` 将暂停此剪辑的执行。'
- en: '`repetitions`: The number of times the animation will be repeated. This is
    used by the `loop` property. The default is `Infinity`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repetitions`: 动画将重复的次数。这由 `loop` 属性使用。默认值为 `Infinity`。'
- en: '`time`: The time this action has been running. This is wrapped from 0 to the
    duration of the clip.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`: 此动作已运行的时间。这是从 `0` 到剪辑持续时间的包装。'
- en: '`timeScale`: This can be used to speed up or slow down this animation. If the
    value of this property is set to `0`, this animation is effectively paused.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeScale`: 这可以用来加快或减慢此动画。如果此属性的值设置为 `0`，则此动画将实际上暂停。'
- en: '`weight`: This specifies the effect this animation has on the model from a
    scale of `0` to `1`. When set to `0`, you won’t see any transformation of the
    model from this animation, and when set to `1`, you will see the full effect of
    this animation.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weight`: 这指定了动画对模型的影响程度，范围从 `0` 到 `1`。当设置为 `0` 时，您将看不到模型因该动画而产生的任何变换，而当设置为
    `1` 时，您将看到该动画的全部效果。'
- en: '`zeroSlopeAtEnd`: When set to true (which is the default), this will make sure
    there is a smooth transition between separate clips.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zeroSlopeAtEnd`: 当设置为 `true`（默认值）时，这将确保在单独的剪辑之间有一个平滑的过渡。'
- en: '`zeroSlopeAtStart`: When set to true (which is the default), this will make
    sure there is a smooth transition between separate clips.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zeroSlopeAtStart`: 当设置为 `true`（默认值）时，这将确保在单独的剪辑之间有一个平滑的过渡。'
- en: '`crossFadeFrom(fadeOutAction, durationInSeconds, warpBoolean)`: This causes
    this action to fade in, while `fadeOutAction` is faded out. The total fade takes
    `durationInSeconds`. This allows for smooth transitions between animations. When
    `warpBoolean` is set to `true`, it will apply additional smoothing of timescales.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crossFadeFrom(fadeOutAction, durationInSeconds, warpBoolean)`: 这会导致此动作淡入，同时
    `fadeOutAction` 淡出。总的淡入淡出时间为 `durationInSeconds`。这允许在动画之间进行平滑过渡。当 `warpBoolean`
    设置为 `true` 时，它将对时间尺度应用额外的平滑处理。'
- en: '`crossFadeTo(fadeInAction, durationInSeconds, warpBoolean)`: Same as `crossFadeFrom`,
    but this time, it fades in the provided action, and fades out this action.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crossFadeTo(fadeInAction, durationInSeconds, warpBoolean)`: 与 `crossFadeFrom`
    相同，但这次淡入提供的动作，并淡出此动作。'
- en: '`fadeIn(durationInSeconds)`: Increases the `weight` property slowly from `0`
    to `1` within the passed time interval.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fadeIn(durationInSeconds)`: 在指定的时间间隔内，将 `weight` 属性从 `0` 慢慢增加到 `1`。'
- en: '`fadeOut(durationInSeconds)`: Decreases the `weight` property slowly from `0`
    to `1` within the passed time interval.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fadeOut(durationInSeconds)`: 在指定的时间间隔内，将 `weight` 属性从 `0` 慢慢减少到 `1`。'
- en: '`getEffectiveTimeScale()`: Returns the effective timescale based on the currently
    running warp.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEffectiveTimeScale()`: 返回基于当前运行的扭曲的有效时间尺度。'
- en: '`getEffectiveWeight()`: Returns the effective weight based on the currently
    running fade.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEffectiveWeight()`: 返回基于当前运行的淡入淡出的有效权重。'
- en: '`getClip()`: Returns the `THREE.AnimationClip` property this action is managing.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getClip()`: 返回此动作管理的 `THREE.AnimationClip` 属性。'
- en: '`getMixer()`: Returns the mixer that is playing this action.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMixer()`: 返回播放此动作的混音器。'
- en: '`getRoot()`: Gets the root object that is controlled by this action.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRoot()`: 获取由此动作控制的基本对象。'
- en: '`halt(durationInSeconds)`: Gradually decreases `timeScale` to `0` within `durationInSeconds`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`halt(durationInSeconds)`: 在 `durationInSeconds` 内逐渐将 `timeScale` 减少到 `0`。'
- en: '`isRunning()`: Checks whether the animation is currently running.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isRunning()`: 检查动画是否当前正在运行。'
- en: '`isScheduled()`: Checks whether this action is currently active in the mixer.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isScheduled()`: 检查此动作是否当前在混音器中活动。'
- en: '`play()`: Starts running this action (starting the animation).'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play()`: 开始运行此动作（开始动画）。'
- en: '`reset()`: Resets this action. This will result in setting `paused` to `false`,
    `enabled` to `true`, and `time` to `0`.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset()`: 重置此动作。这将导致将 `paused` 设置为 `false`，`enabled` 设置为 `true`，以及 `time`
    设置为 `0`。'
- en: '`setDuration(durationInSeconds)`: Sets the duration of a single loop. This
    will change `timeScale` so that the complete animation can play within `durationInSeconds`.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDuration(durationInSeconds)`: 设置单个循环的持续时间。这将改变 `timeScale`，以便整个动画可以在 `durationInSeconds`
    内播放。'
- en: '`setEffectiveTimeScale(timeScale)`: Sets `timeScale` to the provided value.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setEffectiveTimeScale(timeScale)`: 将 `timeScale` 设置为提供的值。'
- en: '`setEffectiveWeight()`: Sets `weight` to the provided value.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setEffectiveWeight()`: 将 `weight` 设置为提供的值。'
- en: '`setLoop(loopMode, repetitions)`: Sets `loopMode` and the number of `repetitions`.
    See the `loop` property for the options and their effect.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLoop(loopMode, repetitions)`: 设置 `loopMode` 和重复次数。请参阅 `loop` 属性以了解选项及其效果。'
- en: '`startAt(startTimeInSeconds)`: Delays starting the animation for `startTimeInSeconds`.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startAt(startTimeInSeconds)`: 延迟`startTimeInSeconds`秒开始动画。'
- en: '`stop()`: Stops this action, and `reset` is applied.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop()`: 停止此动作，并应用`reset`。'
- en: '`stopFading()`: Stops any scheduled fading.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopFading()`: 停止任何计划中的淡入淡出。'
- en: '`stopWarping()`: Stops any schedule warping.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopWarping()`: 停止任何计划中的扭曲。'
- en: '`syncWith(otherAction)`: Syncs this action with the passed-in action. This
    will set this action’s `time` and `timeScale` value to the passed-in action.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syncWith(otherAction)`: 将此动作与传入的动作同步。这将设置此动作的`time`和`timeScale`值与传入的动作相同。'
- en: '`warp(startTimeScale, endTimeScale, durationInSeconds)`: Changes the `timeScale`
    property from `startTimeScale` to `endTimeScale` within the specified `durationInSeconds`.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warp(startTimeScale, endTimeScale, durationInSeconds)`: 在指定的`durationInSeconds`内将`timeScale`属性从`startTimeScale`更改为`endTimeScale`。'
- en: Besides all the functions and properties that you can use to control the animation,
    `THREE.AnimationMixer` also provides two events you can listen to by calling `addEventListener`
    on the mixer. The `"loop"` event is sent when a single loop is finished, and the
    `"finished"` event is sent when the complete action has finished.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您可以使用的所有控制动画的函数和属性之外，`THREE.AnimationMixer`还提供了两个事件，您可以通过在mixer上调用`addEventListener`来监听这些事件。当单个循环完成时，会发送`"loop"`事件，当整个动作完成时，会发送`"finished"`事件。
- en: Animation using bones and skinning
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用骨骼和皮肤进行动画
- en: 'As we saw in the *Animation with a mixer and morph targets* section, morph
    animations are very straightforward. Three.js knows all the target vertex positions
    and only needs to transition each vertex from one position to the next. For bones
    and skinning, it becomes a bit more complex. When you use bones for animation,
    you move the bone, and Three.js has to determine how to translate the attached
    skin (a set of vertices) accordingly. For this example, we will use a model that
    was exported from Blender into Three.js format (`lpp-rigging.gltf` in the `models/blender-skeleton`
    folder). This is a model of a person, complete with a set of bones. By moving
    the bones around, we can animate the complete model. First, let’s look at how
    we loaded the model:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*使用mixer和形态目标进行动画*部分所看到的，形态动画非常简单。Three.js知道所有的目标顶点位置，只需要将每个顶点从当前位置过渡到下一个位置。对于骨骼和皮肤，这会变得稍微复杂一些。当您使用骨骼进行动画时，您移动骨骼，Three.js必须确定如何相应地转换附着的皮肤（一组顶点）。对于此示例，我们将使用从Blender导出到Three.js格式的模型（`models/blender-skeleton`文件夹中的`lpp-rigging.gltf`）。这是一个包含一组骨骼的人体模型。通过移动骨骼，我们可以对整个模型进行动画。首先，让我们看看我们是如何加载模型的：
- en: '[PRE18]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ve exported the model in glTF format since the support for glTF in Three.js
    is good. Loading a model for bone animation isn’t that different than any of the
    other models. We just specify the model file and load it like any other glTF file.
    For glTF, the animations are in a separate property of the object that is loaded,
    so we simply assign it to the `animations` variable for easy access.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将模型导出为glTF格式，因为Three.js对glTF的支持很好。加载用于骨骼动画的模型与其他模型没有太大区别。我们只需指定模型文件并像其他glTF文件一样加载它。对于glTF，动画位于加载的对象的单独属性中，所以我们只需将其分配给`animations`变量以便于访问。
- en: 'In this example, we’ve added a console log, which shows what `THREE.Mesh` looks
    like once we’ve loaded it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们添加了一个控制台日志，显示了加载后`THREE.Mesh`的外观：
- en: '![Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects](img/Figure_9.18_B18726.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图9.18 – 骨骼结构反映在对象的层次结构中](img/Figure_9.18_B18726.jpg)'
- en: Figure 9.18 – The skeleton structure is reflected in the hierarchy of objects
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 骨骼结构反映在对象的层次结构中
- en: Here, you can see that the mesh consists of a tree of bones and meshes. This
    also means that if you move a bone, the relevant meshes will be moved alongside
    it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到网格由骨骼和网格的树组成。这也意味着如果您移动一个骨骼，相关的网格将与其一起移动。
- en: 'The following screenshot shows a still image of this example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的静态图像：
- en: '![Figure 9.19 – Manually changing the rotation of the arm and leg bones](img/Figure_9.19_B18726.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图9.19 – 手动改变手臂和腿骨的旋转](img/Figure_9.19_B18726.jpg)'
- en: Figure 9.19 – Manually changing the rotation of the arm and leg bones
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 – 手动改变手臂和腿骨的旋转
- en: 'This scene also contains an animation, which you can trigger by checking the
    **animationIsPlaying** checkbox. This will override the manually set bones’ positions
    and rotations, and has the skeleton kind of jumping up and down:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此场景也包含一个动画，您可以通过勾选**animationIsPlaying**复选框来触发它。这将覆盖手动设置的骨骼的位置和旋转，使骨骼上下跳动：
- en: '![Figure 9.20 – Playing a skeleton animation](img/Figure_9.20_B18726.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20 – 播放骨骼动画](img/Figure_9.20_B18726.jpg)'
- en: Figure 9.20 – Playing a skeleton animation
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – 播放骨骼动画
- en: 'To set up this animation, we must follow the same steps we saw earlier:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这个动画，我们必须遵循之前看到的相同步骤：
- en: '[PRE19]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, working with bones is just as easy as working with fixed morph
    targets. In this example, we’ve only adjusted the rotation of the bones; you can
    also move the position or change the scale. In the next section, we will look
    at loading animations from external models.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用骨骼与使用固定形态目标一样简单。在这个例子中，我们只调整了骨骼的旋转；您也可以移动位置或改变比例。在下一节中，我们将探讨从外部模型加载动画。
- en: Creating animations using external models
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部模型创建动画
- en: 'In [*Chapter 8*](B18726_08.xhtml#_idTextAnchor132), *Creating and Loading Advanced
    Meshes and Geometries*, we looked at several 3D formats that are supported by
    Three.js. A couple of those formats also support animations. In this chapter,
    we’ll look at the following examples:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B18726_08.xhtml#_idTextAnchor132) *创建和加载高级网格和几何体* 中，我们探讨了几个 Three.js
    支持的 3D 格式。其中一些格式也支持动画。在本章中，我们将探讨以下示例：
- en: '**COLLADA model**: The COLLADA format has support for animations. For this
    example, we’ll load an animation from a COLLADA file and render it with Three.js.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COLLADA 模型**：COLLADA 格式支持动画。在这个例子中，我们将从一个 COLLADA 文件中加载一个动画，并使用 Three.js
    进行渲染。'
- en: '**MD2 model**: The MD2 model is a simple format used in the older Quake engines.
    Even though the format is a bit dated, it is still a very good format for storing
    character animations.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MD2 模型**：MD2 模型是一种在较老的 Quake 引擎中使用的简单格式。尽管格式有些过时，但它仍然是一个非常好的用于存储角色动画的格式。'
- en: '**glTF models**: **GL transmission format** (**glTF**) is a format specifically
    designed for storing 3D scenes and models. It focuses on minimizing the size of
    the assets and tries to be as efficient as possible in unpacking the models.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**glTF 模型**：**GL 传输格式**（**glTF**）是一种专门设计用于存储 3D 场景和模型的格式。它专注于最小化资产的大小，并试图在解包模型时尽可能高效。'
- en: '**FBX model**: FBX is a format produced by the Mixamo tooling available at
    [https://www.mixamo.com](https://www.mixamo.com). With Mixamo, you can easily
    rig and animate models, without needing lots of modeling experience.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FBX 模型**：FBX 是由 Mixamo 工具生成的格式，可在 [https://www.mixamo.com](https://www.mixamo.com)
    找到。使用 Mixamo，您可以轻松地为模型绑定和动画，而不需要大量的建模经验。'
- en: '**BVH model**: The **Biovision** (**BVH**) format is a slightly different one
    compared to the other loaders. With this loader, you don’t load a geometry with
    a skeleton or a set of animations. With this format, which is used by Autodesk
    MotionBuilder, you just load a skeleton, which you can visualize or even attach
    to your geometry.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BVH 模型**：与其它加载器相比，**Biovision**（**BVH**）格式略有不同。使用这个加载器，您不需要与骨骼或一系列动画一起加载几何形状。使用这种格式（由
    Autodesk MotionBuilder 使用），您只需加载一个骨骼，您可以将它可视化，甚至将其附加到您的几何形状上。'
- en: We’ll start with a glTF model since this format is becoming the standard for
    exchanging models between different tools and libraries.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个 glTF 模型开始，因为这种格式正成为不同工具和库之间交换模型的标准。
- en: Using gltfLoader
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 gltfLoader
- en: 'A format that is getting more and more attention lately is the glTF format.
    This format, for which you can find a very extensive explanation at [https://github.com/KhronosGroup/glTF](https://github.com/KhronosGroup/glTF),
    focuses on optimizing size and resource usage. Using `glTFLoader` is similar to
    using the other loaders:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最近越来越受到关注的格式是 glTF 格式。这种格式，您可以在 [https://github.com/KhronosGroup/glTF](https://github.com/KhronosGroup/glTF)
    找到非常详尽的解释，专注于优化大小和资源使用。使用 `glTFLoader` 与使用其他加载器类似：
- en: '[PRE20]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This loader also loads a complete scene, so you can either add everything to
    the group or select child elements. For this example, you can view the results
    by opening `load-gltf.js`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加载器也加载了一个完整的场景，因此您可以将所有内容添加到组中，或者选择子元素。对于这个例子，您可以通过打开 `load-gltf.js` 来查看结果：
- en: '![Figure 9.21 – Animation loaded using glTF](img/Figure_9.21_B18726.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21 – 使用 glTF 加载的动画](img/Figure_9.21_B18726.jpg)'
- en: Figure 9.21 – Animation loaded using glTF
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 使用 glTF 加载的动画
- en: For the next example, we’ll use the FBX model.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个例子，我们将使用 FBX 模型。
- en: Visualizing motions captured models using fbxLoader
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 fbxLoader 可视化捕捉到的动作模型
- en: 'The Autodesk FBX format has been around for a while and is very easy to use.
    There is a great resource online where you can find many animations that you can
    download in this format: [https://www.mixamo.com/](https://www.mixamo.com/). This
    site provides 2,500 animations that you can use and customize:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Autodesk FBX 格式已经存在一段时间了，并且非常易于使用。网上有一个非常好的资源，您可以在这里找到许多可以下载的动画：[https://www.mixamo.com/](https://www.mixamo.com/)。该网站提供了
    2,500 个您可以使用和定制的动画：
- en: '![Figure 9.22 – Loading animations from mixamo](img/Figure_9.22_B18726.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22 – 从 mixamo 加载动画](img/Figure_9.22_B18726.jpg)'
- en: Figure 9.22 – Loading animations from mixamo
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – 从 mixamo 加载动画
- en: 'After downloading an animation, using it from Three.js is easy:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 下载动画后，使用 Three.js 处理它很容易：
- en: '[PRE21]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resulting animation, as you can see in `load-fbx.html`, looks great:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 `load-fbx.html` 中所见，生成的动画看起来很棒：
- en: '![Figure 9.23 – Animation loaded using fbx](img/Figure_9.23_B18726.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.23 – 使用 fbx 加载的动画](img/Figure_9.23_B18726.jpg)'
- en: Figure 9.23 – Animation loaded using fbx
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – 使用 fbx 加载的动画
- en: 'FBX and glTF are modern formats that are used a lot and are a good way to exchange
    models and animations. There are a couple of older formats around as well. An
    interesting one is a format used by the old FPS Quake: MD2.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: FBX 和 glTF 是现代格式，被广泛使用，是交换模型和动画的好方法。还有一些旧的格式。一个有趣的是老式 FPS 游戏 Quake 使用的格式：MD2。
- en: Loading an animation from a Quake model
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Quake 模型加载动画
- en: 'The MD2 format was created to model characters from Quake, a great game from
    1996\. Even though the newer engines use a different format, you can still find
    a lot of interesting models in the MD2 format. Using an MD2 file is a bit different
    than using the others we’ve seen so far. When you load an MD2 model, you get a
    geometry, so you have to make sure that you create a material as well and assign
    a skin:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: MD2 格式是为了建模 1996 年一款伟大的游戏 Quake 中的角色而创建的。尽管较新的引擎使用不同的格式，但您仍然可以在 MD2 格式中找到许多有趣的模型。使用
    MD2 文件与使用我们迄今为止看到的其他文件略有不同。当您加载 MD2 模型时，您会得到一个几何形状，因此您必须确保同时创建一个材质并将其分配给皮肤：
- en: '[PRE22]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you have this `Mesh`, setting up the animation works in the same way.
    The result of this animation can be seen here (`load-md2.html`):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了这个 `Mesh`，设置动画的方式与之前相同。这个动画的结果可以在这里看到（`load-md2.html`）：
- en: '![Figure 9.24 – Loaded Quake monster](img/Figure_9.24_B18726.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.24 – 加载的 Quake 怪物](img/Figure_9.24_B18726.jpg)'
- en: Figure 9.24 – Loaded Quake monster
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – 加载的 Quake 怪物
- en: Next up is COLLADA.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 COLLADA。
- en: Loading an animation from a COLLADA model
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 COLLADA 模型加载动画
- en: 'While the normal COLLADA models aren’t compressed (and they can get quite large),
    there is also a `KMZLoader` available in Three.js. This is a compressed COLLADA
    model, so if you run into `KMZLoader` instead of `ColladaLoader`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然正常的 COLLADA 模型未压缩（并且它们可以变得相当大），但 Three.js 中还有一个 `KMZLoader`。这是一个压缩的 COLLADA
    模型，所以如果您遇到 `KMZLoader` 而不是 `ColladaLoader`：
- en: '![Figure 9.25 – Loaded COLLADA model](img/Figure_9.25_B18726.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.25 – 加载的 COLLADA 模型](img/Figure_9.25_B18726.jpg)'
- en: Figure 9.25 – Loaded COLLADA model
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 – 加载的 COLLADA 模型
- en: For the final loader, we’ll look at `BVHLoader`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终的加载器，我们将查看 `BVHLoader`。
- en: Visualizing a skeleton with BVHLoader
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 BVHLoader 可视化骨骼
- en: '`BVHLoader` is a slightly different loader than the ones we’ve seen so far.
    This loader doesn’t return meshes or geometries with animations; instead, it returns
    a skeleton and an animation. An example of this is shown in `load-bvh.html`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`BVHLoader` 是一种与我们迄今为止看到的不同的加载器。这个加载器不返回带有动画的网格或几何形状；相反，它返回一个骨骼和一个动画。一个例子可以在
    `load-bvh.html` 中看到：'
- en: '![Figure 9.26 – Loaded BVH skeleton](img/Figure_9.26_B18726.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.26 – 加载的 BVH 骨骼](img/Figure_9.26_B18726.jpg)'
- en: Figure 9.26 – Loaded BVH skeleton
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 – 加载的 BVH 骨骼
- en: 'To visualize this, we can use a `THREE.SkeletonHelper`, as seen here. With
    a `THREE.SkeletonHelper`, we can visualize the skeleton of a mesh. BVH models
    just contain skeleton information, which we can visualize like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化这一点，我们可以使用 `THREE.SkeletonHelper`，如下所示。使用 `THREE.SkeletonHelper`，我们可以可视化网格的骨骼。BVH
    模型仅包含骨骼信息，我们可以像这样可视化：
- en: '[PRE23]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In older versions of Three.js, there was support for other kinds of animation
    file formats. Most of those are obsolete and have subsequently been removed from
    the Three.js distribution. If you do stumble upon a different format in which
    you want to show the animations, you can look at the older Three.js releases and
    possibly reuse the loaders from there.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 的旧版本中，支持其他类型的动画文件格式。其中大多数已经过时，并随后从 Three.js 发行版中删除。如果您偶然发现了一种您想要展示动画的不同格式，您可以查看旧的
    Three.js 版本，并可能重新使用那里的加载器。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at different ways you can animate your scene. We
    started with some basic animation tricks, moved on to camera movement and control,
    and ended by looking at animating models using morph targets and skeleton/bones
    animations.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了您可以为场景添加动画的不同方法。我们首先介绍了一些基本的动画技巧，然后转向摄像机运动和控制，最后通过使用形态目标以及骨骼/骨骼动画来查看如何对模型进行动画处理。
- en: When you have the render loop in place, adding simple animations is very easy.
    Just change a property of the mesh; in the next rendering step, Three.js will
    render the updated mesh. For more complex animations, you would usually model
    them in external programs and load them through one of the loaders provided by
    Three.js.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当您已经设置了渲染循环后，添加简单的动画变得非常容易。只需更改网格的一个属性；在下一个渲染步骤中，Three.js 将渲染更新后的网格。对于更复杂的动画，您通常会使用外部程序进行建模，并通过
    Three.js 提供的加载器之一加载它们。
- en: In the previous chapters, we looked at the various materials we can use to skin
    our objects. For instance, we saw how we can change the color, shininess, and
    opacity of these materials. What we haven’t discussed in detail yet, however,
    is how we can use external images (also called textures) together with these materials.
    With textures, we can easily create objects that look as if they are made out
    of wood, metal, stone, and much more. In [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    we’ll explore all the different aspects of textures and how they are used in Three.js.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了我们可以用来为对象着色的各种材质。例如，我们看到了如何更改这些材质的颜色、光泽度和透明度。然而，我们尚未详细讨论如何使用外部图像（也称为纹理）与这些材质结合使用。通过纹理，我们可以轻松创建看起来像是用木材、金属、石头等材料制成的对象。在[*第
    10 章*](B18726_10.xhtml#_idTextAnchor171)中，我们将探讨纹理的所有不同方面以及它们在 Three.js 中的使用方式。
