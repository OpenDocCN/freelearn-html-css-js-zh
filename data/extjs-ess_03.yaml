- en: Chapter 3. Reacting to User and Application Interactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。响应用户和应用交互
- en: Developing effective applications with Ext JS requires a solid understanding
    of event-driven programming and how actions are performed, based on user and application
    interactions. Ext JS is an event-driven framework and uses events to control the
    flow of the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ext JS开发有效的应用程序需要深入了解事件驱动编程以及如何根据用户和应用交互执行操作。Ext JS是一个事件驱动框架，并使用事件来控制应用程序的流程。
- en: 'Events can be raised by user input, internally by the framework or by our own
    application code. For example, when a user clicks a button with their mouse, a
    click event will be fired by the button''s instance. We can then attach a listener
    to this event and execute our handler code when it is fired. Have a look at the
    following diagram:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以通过用户输入、框架内部或我们自己的应用程序代码来触发。例如，当用户用鼠标点击按钮时，按钮的实例将触发一个点击事件。然后我们可以将监听器附加到这个事件，并在它被触发时执行我们的处理程序代码。看看下面的图示：
- en: '![Reacting to User and Application Interactions](img/6626_03_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![响应用户和应用交互](img/6626_03_01.jpg)'
- en: 'This chapter will explore in detail the events in Ext JS. The topics covered
    in this chapter include:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细探讨Ext JS中的事件。本章涵盖的主题包括：
- en: Listening for events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听事件
- en: Raising custom events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抬起自定义事件
- en: Attaching event handlers to components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件处理程序附加到组件上
- en: Listening for user input via mouse, keyboard, and touch screens
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过鼠标、键盘和触摸屏监听用户输入
- en: Background
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景
- en: Applications built with Ext JS will make use of events at numerous points throughout
    their lifecycle. Even if you're unaware of it, in the background, the framework
    will raise events when something interesting happens. As developers, we want our
    application code to respond to these events, either to process something or to
    give the user feedback on what has happened.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ext JS构建的应用程序将在其生命周期中的许多地方使用事件。即使你不知道，在后台，当发生有趣的事情时，框架将触发事件。作为开发者，我们希望我们的应用程序代码能够对这些事件做出响应，无论是处理某些事情还是向用户反馈发生了什么。
- en: Ext JS implements an `Ext.mixin.Observable` class that provides a common interface
    for publishing events. Let's look at the options we have to listen to events.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS实现了一个`Ext.mixin.Observable`类，它提供了一个发布事件的通用接口。让我们看看我们有哪些选项来监听事件。
- en: Defining event handlers in config objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置对象中定义事件处理程序
- en: A common way to define listeners is to use the `listeners` config option, which
    allows us to define an object containing event handlers. This object should be
    defined in the `config` object of the Ext JS component.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 定义监听器的一种常见方法是使用`listeners`配置选项，它允许我们定义一个包含事件处理程序的对象。这个对象应该在Ext JS组件的`config`对象中定义。
- en: Let's jump straight into the `BizDash.view.main.Main` class that was created
    automatically when we generated our application in [Chapter 1](ch01.html "Chapter 1. Getting
    to Know Ext JS"), *Getting to Know Ext JS*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接跳转到在[第1章](ch01.html "第1章。了解Ext JS")中生成我们的应用程序时自动创建的`BizDash.view.main.Main`类，*了解Ext
    JS*。
- en: 'We will bind an event listener to the `afterrender` event of the Tab Panel
    component. The function is executed when the event is fired. In this case, the
    output of the handler is a simple console message:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绑定一个事件监听器到Tab Panel组件的`afterrender`事件。当事件被触发时，该函数将被执行。在这种情况下，处理程序的输出是一个简单的控制台消息：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is also possible to attach handlers to multiple events at once. This example
    has both, a `beforerender` and `afterrender` handler for events fired by the Tab
    Panel component:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也可以将处理程序附加到多个事件上。这个例子中，Tab Panel组件触发的事件既有`beforerender`又有`afterrender`处理程序：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Button handlers
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮处理程序
- en: 'The framework provides a shortcut to define a handler to a button as it''s
    highly likely you''ll want your buttons to respond to a mouse click. The `handler`
    in this case is bound to the `onClickButton` method in the view''s ViewController,
    `BizDash.view.main.MainController`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架提供了一个快捷方式来定义一个处理程序到按钮，因为它高度可能你希望你的按钮能够响应鼠标点击。在这个情况下，`handler`被绑定到视图的`ViewController`中的`onClickButton`方法，`BizDash.view.main.MainController`：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's considered good practice to keep your business logic out of views instead
    of putting it in global controllers or ViewControllers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是一个好的实践，将业务逻辑放在视图之外，而不是将其放在全局控制器或ViewController中。
- en: The on method
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: on方法
- en: 'Alternatively, we can use the `on` method, which is an alias of the `addListener`
    method. This method comes from the mixed in `Ext.mixin.Observable` class and enables
    us to add listeners to a class, or component after the class is instantiated:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`on`方法，这是`addListener`方法的别名。这个方法来自混合的`Ext.mixin.Observable`类，并允许我们在类实例化后向类或组件添加监听器：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding example shows how to use an Ext JS Component Query to search for
    the button in our application and add a `mouseover` listener bound to the method
    `onMouseOver` in our ViewController. We will go into Component Queries in more
    detail in [Chapter 7](ch07.html "Chapter 7. Constructing Common UI Widgets"),
    *Constructing Common UI Widgets*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了如何使用Ext JS组件查询在我们的应用程序中搜索按钮，并添加一个绑定到我们ViewController中`onMouseOver`方法的`mouseover`监听器。我们将在第7章[构建常见UI小部件](ch07.html
    "第7章。构建常见UI小部件")中更详细地介绍组件查询。
- en: 'As with the listeners `config` object, the `on` method also accepts an alternative
    parameter set that allows multiple event handlers to be assigned at once. By providing
    a JavaScript object as the first parameter, with name/value pairs specifying the
    event name and its handling function, the listeners will all be assigned at once.
    By defining a `scope` property within this object, the handler functions will
    all be executed within the scope of the specified object (or what `this` will
    refer to within the function):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '与监听器的`config`对象一样，`on`方法也接受一个可选的参数集，允许一次性分配多个事件处理器。通过将一个JavaScript对象作为第一个参数提供，其中包含指定事件名称和处理函数的键值对，可以一次性分配所有监听器。通过在这个对象中定义一个`scope`属性，处理函数将在这个指定对象的范围内执行（或者在函数内部`this`所引用的对象）： '
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Scope** defaults to the object that fires the event. In our case, that would
    be the button. You can customize this with the `scope` option if you require the
    handler function to be executed in a different scope. The preceding example demonstrates
    this using the `this` reference to alter the scope to that of the `BizDash.view.main.MainController`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**作用域**默认为触发事件的那个对象。在我们的例子中，那就是按钮。如果您需要处理函数在不同的作用域中执行，可以使用`scope`选项来自定义。前面的例子展示了如何使用`this`引用来改变作用域，使其变为`BizDash.view.main.MainController`的作用域。'
- en: Listener options
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听器选项
- en: There are numerous listener options for you to configure as well. For example,
    you can buffer an event that fires in quick succession or target an event to a
    specific element rather than the entire component. Event delegation like this
    is useful during component construction to add DOM event listeners to elements
    of components, which will exist only after the component is rendered.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以配置许多监听器选项。例如，您可以缓冲连续快速触发的事件，或者将事件目标指向特定的元素而不是整个组件。在组件构建期间，这种事件委托非常有用，可以将DOM事件监听器添加到组件的元素上，这些元素将在组件渲染后存在。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example shows the `single` option added to the click event. This option
    automatically removes the click event after the first time it's fired. We've further
    enhanced the `onClickButton` method to disable the button too.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了添加到点击事件的`single`选项。此选项在第一次触发后自动删除点击事件。我们进一步增强了`onClickButton`方法，使其禁用按钮。
- en: The documentation for `Ext.mixin.Observable` contains useful examples and further
    information on configuring events. You can find it at [http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.mixin.Observable](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.mixin.Observable).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.mixin.Observable`类的文档包含有用的示例和有关配置事件的更多信息。您可以在[http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.mixin.Observable](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.mixin.Observable)找到它。'
- en: Firing events
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发事件
- en: 'The `Ext.mixin.Observable` class also provides a way to fire events, whether
    these are framework events or custom events. The `fireEvent` method will fire
    any event we require and pass parameters for consumption by the handler function.
    The following example shows us how to fire a custom `confirmed` event, passing
    the `choice` parameter on the button, and binding it to an `onConfirmed` handler:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.mixin.Observable`类还提供了一种触发事件的方法，无论是框架事件还是自定义事件。`fireEvent`方法将触发我们需要的任何事件，并将参数传递给处理函数以供消费。以下示例展示了如何触发一个自定义的`confirmed`事件，将`choice`参数传递到按钮上，并将其绑定到`onConfirmed`处理函数：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listening for events on elements
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在元素上监听事件
- en: As some events, for example click, aren't available on all components, it's
    possible to attach event handlers directly to any element. The `Ext.dom.Element`
    class, a framework class that wraps DOM elements, will relay all of the underlying
    DOM events, and its documentation contains a full list of these.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些事件，例如点击，并非所有组件都可用，因此可以直接将事件处理器附加到任何元素。`Ext.dom.Element` 类是一个框架类，它包装 DOM
    元素，并将所有底层 DOM 事件传递出去，其文档包含这些事件的完整列表。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example shows how to listen for a tap event on the entire `Viewport`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了如何在整个 `Viewport` 上监听触摸事件。
- en: Event delegation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件委托
- en: Event handlers, however, are a common cause of memory leaks and can cause performance
    degradation when not managed carefully. The more event handlers we create, the
    more likely we are to introduce such problems; so, we should try to avoid creating
    huge numbers of handlers when we don't have to.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事件处理器是内存泄漏的常见原因，如果不小心管理，可能会导致性能下降。我们创建的事件处理器越多，出现此类问题的可能性就越大；因此，当我们不需要时，应尽量避免创建大量处理器。
- en: Event delegation is a technique where a single event handler is created on a
    parent element, which leverages the fact that the browser will bubble any events
    raised on one of its children to this parent element. If the target of the original
    event matches the delegate's selector, then it will execute the event handler;
    otherwise nothing will happen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事件委托是一种技术，在父元素上创建单个事件处理器，利用浏览器会将任何在其子元素上引发的事件冒泡到父元素的事实。如果原始事件的目标与委托的选择器匹配，则将执行事件处理器；否则，不会发生任何操作。
- en: This means that instead of attaching an event handler to each individual child
    element, we only have to create a single handler on the parent element, and then,
    within the handler, query which child element was actually clicked and react appropriately.
    To achieve this, we use the delegate option available to the `listeners` config.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不需要为每个单独的子元素附加事件处理器，而只需在父元素上创建一个处理器，然后在处理器内部查询实际被点击的子元素，并相应地做出反应。为了实现这一点，我们使用
    `listeners` 配置中可用的委托选项。
- en: 'The following example shows how you might use event delegation with an element
    containing multiple links:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用包含多个链接的元素进行事件委托：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Mouse events
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: The mouse events the framework can handle are `mousedown`, `mousemove`, `mouseup`,
    `mouseover`, `mouseout`, `mouseenter`, and `mouseleave`. The `Ext.event.Event`
    class handles the cross-browser and cross-device differences for us to ensure
    our application behaves the same on all supported browsers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 框架可以处理的鼠标事件有 `mousedown`、`mousemove`、`mouseup`、`mouseover`、`mouseout`、`mouseenter`
    和 `mouseleave`。`Ext.event.Event` 类处理跨浏览器和跨设备的差异，以确保我们的应用程序在所有支持的浏览器上表现一致。
- en: Keyboard events
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘事件
- en: 'The `Ext.event.Event` class also provides a list of key constants:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.event.Event` 类还提供了一系列键常量：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can, for instance, get a reference to the enter key's code using `Ext.event.Event.ENTER`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 `Ext.event.Event.ENTER` 获取回车键的代码。
- en: KeyMap
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键盘映射
- en: 'The `Ext.util.KeyMap` class is used to bind keyboard strokes to a handling
    function. Using this, you can enable the user to control the application using
    their keyboard:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.util.KeyMap` 类用于将键盘按键绑定到处理函数。使用此功能，用户可以使用键盘控制应用程序：'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Touch events
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸事件
- en: Not only do we often have to support multiple browsers, but most of the time
    we need our applications to be device agnostic. Ext JS enables us to support users
    with other types of pointers, such as a mouse, pen, or finger.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅经常需要支持多个浏览器，而且大多数时候我们需要我们的应用程序对设备不可知。Ext JS 使我们能够支持使用其他类型指针的用户，例如鼠标、笔或手指。
- en: Ext JS 5 provides support for `touchstart`, `touchmove`, and `touchend` events.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5 提供了对 `touchstart`、`touchmove` 和 `touchend` 事件的支持。
- en: Event normalization
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件归一化
- en: To support touch-screen devices, the framework automatically translates touch-screen
    events into their equivalent mouse events for us. This is called event normalization.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持触摸屏设备，框架会自动将触摸屏事件转换为等效的鼠标事件，这称为事件归一化。
- en: As developers, we don't need to worry about the extra coding. All we have to
    do is consider the event being used by a mouse. For instance, `mousedown` will
    seamlessly be translated to `touchdown` and `pointerdown` for us.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们不需要担心额外的编码。我们只需考虑鼠标使用的事件即可。例如，`mousedown` 将无缝转换为 `touchdown` 和 `pointerdown`。
- en: Gestures
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手势
- en: While normalization saves us coding, we still need to understand the gesture
    the user carries out on our application. Ext JS does almost all the heavy lifting
    for us. It will interpret gestures such as tap, swipe, drag, and double tap on
    any element and raise events for us to listen for.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然归一化可以节省我们编码，但我们仍然需要理解用户在我们应用程序上执行的手势。Ext JS 几乎为我们做了所有繁重的工作。它将解释点击、滑动、拖动和双击等手势，并在任何元素上为我们触发事件，以便我们监听。
- en: 'In order to do this, the framework builds upon the Sencha Touch gesture system,
    which interprets the sequence and timing of three primary events: `touchstart`,
    `touchmove`, and `touchend`. Ext JS 5 translates these to the equivalent pointer
    and mouse events (for example, `pointerdown` or `mousedown`) so that gestures
    are understood regardless of the device being used for input.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，框架基于 Sencha Touch 手势系统，该系统解释了三个主要事件的序列和时机：`touchstart`、`touchmove` 和
    `touchend`。Ext JS 5 将这些转换为等效的指针和鼠标事件（例如，`pointerdown` 或 `mousedown`），以便手势无论在哪种输入设备上都能被理解。
- en: For example, gestures such as tap and swipe will work for both touch and mouse
    input.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像点击和滑动这样的手势对触摸和鼠标输入都适用。
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned how to work with events in an Ext JS application.
    You should now feel more comfortable with:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 Ext JS 应用程序中处理事件。你现在应该对以下内容感到更加熟悉：
- en: Listening for events
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听事件
- en: Raising custom events
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发自定义事件
- en: Attaching event handlers to components
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件处理器附加到组件上
- en: Listening for user input via mouse, keyboard, and touch screens
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过鼠标、键盘和触摸屏监听用户输入
- en: The next chapter builds on your knowledge of classes and events to cover the
    entire application and its architecture. Ext JS 5 now provides support for MVVM
    as well as MVC. While the chapter's focus is these paradigms, we also explore
    other considerations it's worth making early in the development cycle.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在你对类和事件的知识基础上，涵盖整个应用程序及其架构。Ext JS 5 现在提供了对 MVVM 以及 MVC 的支持。虽然本章的重点是这些范式，但我们也会探讨在开发周期早期值得考虑的其他因素。
