- en: Getting Started with Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js入门
- en: In this chapter, you will gain your first real Node.js experience. We will start
    by installing Node.js, along with some modules we will use throughout this book.
    Then, we will set up a development environment. Throughout the book, the Atom
    IDE will be used. Yes, GitHub's online editor has finally landed for desktop environment
    and is available on a platform of your preference!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将获得您的第一个真正的Node.js体验。我们将从安装Node.js开始，以及一些我们将在整本书中使用的模块。然后，我们将设置一个开发环境。在整本书中，将使用Atom
    IDE。是的，GitHub的在线编辑器终于登陆了桌面环境，并且可以在您喜欢的平台上使用！
- en: Next, we will create a workspace and start developing our first Node.js application.
    It will be a simple server application processing incoming HTTP requests. We will
    go one step further, demonstrating how to modularize and unit test our JavaScript
    code. Finally, we will deploy our first application on the Heroku Cloud Application
    platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个工作空间，并开始开发我们的第一个Node.js应用程序。这将是一个简单的服务器应用程序，用于处理传入的HTTP请求。我们将进一步演示如何将我们的JavaScript代码模块化和单元测试。最后，我们将在Heroku云应用平台上部署我们的第一个应用程序。
- en: 'To sum up, in this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在本章中，我们将涵盖以下主题：
- en: Installing Node.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: Installing the Express framework and other modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Express框架和其他模块
- en: Setting up a development environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Handling HTTP requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理HTTP请求
- en: Modularizing code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化代码
- en: Testing Node.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Node.js
- en: Deploying an application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Installing Node.js
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: 'Let''s start our journey through Node.js with a Node.js installation. Installers
    are available for both Windows and macOS at [https://nodejs.org/en/download/](https://nodejs.org/en/download/). 
    At the time of writing, Node.js 10 has just been released as the current version,
    and is about to become the next Long Term Support version, in August 2018\. Linux
    users can either build Node.js from the available Linux binaries or make use of
    their package manager, as Node.js is available with most of the popular package
    repositories for different Linux distributions. For instance, Ubuntu and other
    Debian-based distributions should first point to the latest Node.js 10 package
    and then install via the `apt-get` command from the shell:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Node.js安装开始我们的Node.js之旅。Windows和macOS都可以在[https://nodejs.org/en/download/](https://nodejs.org/en/download/)上找到安装程序。在撰写本文时，Node.js
    10刚刚发布为当前版本，并将于2018年8月成为下一个长期支持版本。Linux用户可以从可用的Linux二进制文件构建Node.js，或者利用他们的软件包管理器，因为Node.js在不同Linux发行版的大多数流行软件包存储库中都可用。例如，Ubuntu和其他基于Debian的发行版应该首先指向最新的Node.js
    10软件包，然后通过shell中的`apt-get`命令进行安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you decide to go with an installer available for macOS or Windows, a wizard
    will guide you through a rather typical installation procedure, where you will
    have to accept the Node.js license agreement and then provide an installation
    path.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用macOS或Windows可用的安装程序，向导将指导您完成一个相当典型的安装过程，您需要接受Node.js许可协议，然后提供安装路径。
- en: Linux users performing installations via package managers will need to install
    **Node Package Manager (npm)** separately; we will do that in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过软件包管理器执行安装的Linux用户需要单独安装**Node Package Manager (npm)**；我们将在下一节中进行安装。
- en: After a successful installation, you should have Node set on your `PATH` environment
    variable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，您应该已经将Node设置在您的`PATH`环境变量中。
- en: The installer will have preselected for you the Node.js runtime, npm, shortcuts
    to online documentation resources, as well as the option to add Node.js and npm
    to your operating system `PATH` environment variable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序将为您预先选择Node.js运行时、npm、在线文档资源的快捷方式，以及将Node.js和npm添加到操作系统`PATH`环境变量的选项。
- en: 'To verify that your installation was successful, execute the following from
    your shell:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的安装是否成功，请从shell中执行以下操作：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the time of writing, the latest Node.js version is 10.0.0 so, as expected,
    this version number will be the output of the version check. Node.js 10 will be
    the next Long Term Supported version, so it will stay actual for the next few
    years
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最新的Node.js版本是10.0.0，因此预期的输出版本号将是这个版本号。Node.js 10将是下一个长期支持的版本，因此在接下来的几年里它将保持最新。
- en: Npm
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Npm
- en: Node.js eases support to third-party open source-developed modules by providing **npm**.
    It allows you, as a developer, to easily install, manage, and even provide your
    own module packages. The npm package repository is available at [http://www.npmjs.org/](http://www.npmjs.org/)
    and is accessible via its command-line interface.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js通过提供**npm**来方便地支持第三方开源开发的模块。它允许您作为开发人员轻松安装、管理甚至提供自己的模块包。npm包存储库位于[http://www.npmjs.org/](http://www.npmjs.org/)，可以通过其命令行界面访问。
- en: 'If you didn''t use the installer, then you will need to install `npm` separately.
    For example, Ubuntu users can make use of their package installer as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用安装程序，那么您需要单独安装`npm`。例如，Ubuntu用户可以按照以下方式使用他们的软件包安装程序：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you upgraded your Node.js installation and you had previously installed
    npm 5.6, you would be asked to upgrade it to version 6\. To do that, just execute:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您升级了Node.js安装，并且之前安装了npm 5.6，系统会要求您将其升级到版本6。要执行此操作，只需执行：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once npm is installed, it is useful to set it permanently in your user profile''s
    `PATH` environment variable by editing the `~/.profile` file to export the path
    to npm as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了npm，通过编辑`~/.profile`文件将其永久设置在用户配置文件的`PATH`环境变量中是很有用的，以便导出npm的路径如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After a successful npm installation, use npm''s `ls` option to display the
    currently-installed Node.js modules:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装npm后，使用npm的`ls`选项来显示当前安装的Node.js模块：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Installing the Express framework and other modules
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Express框架和其他模块
- en: 'Now that we have `npm` installed, let''s make use of it and install some of
    the modules we will be using heavily throughout this book. The most important
    among them is the Express framework ([http://www.expressjs.com/](http://www.expressjs.com/)).
    It is a flexible web application framework for Node.js, providing a robust RESTful
    API for developing single or multi-page web applications. The following command
    will download the Express module from the npm repository and make it available
    for our local Node.js installation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们安装了`npm`，让我们利用它并安装一些在本书中将大量使用的模块。其中最重要的是Express框架([http://www.expressjs.com/](http://www.expressjs.com/))。它是一个灵活的Web应用程序框架，为Node.js提供了一个强大的RESTful
    API，用于开发单页或多页Web应用程序。以下命令将从npm仓库下载Express模块，并使其可用于我们的本地Node.js安装：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will find the `express` module among the results of an `npm ls` after a
    successful installation. Later in this chapter, we will learn how to write unit
    tests for our Node.js modules. We will need the `nodeunit` module for that purpose:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装后，你将在`npm ls`的结果中找到`express`模块。在本章的后面，我们将学习如何为我们的Node.js模块编写单元测试。为此，我们将需要`nodeunit`模块：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-g` option will install `nodeunit` globally. This means that the module
    will be stored at a central place on your filesystem; usually, that is either `/usr/lib/node_modules` or** `/usr/lib/node`**,
    but that can be configured to the global configuration of your Node.js. Globally
    installed modules are available to all running node applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g`选项会全局安装`nodeunit`。这意味着该模块将被存储在你的文件系统的一个中央位置；通常是`/usr/lib/node_modules`或者`/usr/lib/node`，但这可以配置到你的Node.js的全局配置。全局安装的模块对所有正在运行的node应用程序都是可用的。'
- en: Locally installed modules will be stored in a `node_modules` subdirectory of
    the current working directory of your project and will be available only to that
    single project.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本地安装的模块将存储在你项目的当前工作目录的`node_modules`子目录中，并且只对该单个项目可用。
- en: Now, coming back to the `nodeunit` module—it provides basic assert test functions
    for creating basic unit tests as well as tools for executing them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`nodeunit`模块——它提供了用于创建基本单元测试的基本断言测试函数，以及用于执行它们的工具。
- en: 'Before starting to develop with Node.js, we have one more thing to look into:
    the package descriptor file of a Node.js application.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用Node.js开发之前，我们还有一件事要了解：Node.js应用程序的包描述文件。
- en: 'All Node.js applications or modules contain a `package.json` descriptor file.
    It provides meta-information about the module, its authors, and the dependencies
    it uses. Let''s take a look at the `package.json` file of the `express` module
    we installed earlier:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Node.js应用程序或模块都包含一个`package.json`描述文件。它提供关于模块、作者和它使用的依赖的元信息。让我们来看一下我们之前安装的`express`模块的`package.json`文件：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The name and the version of the package are mandatory properties for every module.
    All other pieces of meta-information, such as the contributors list, repository
    type and location, license information, and so on, are optional. One of the most
    interesting properties, which is worth mentioning, is the `dependencies` property.
    It tells npm which modules your package depends on. Let's take a deeper look at
    how this is specified. Each dependency has a name and a version.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 包的名称和版本是每个模块的必需属性。所有其他的元信息，比如贡献者列表、仓库类型和位置、许可信息等等，都是可选的。其中一个最有趣的属性是`dependencies`属性。它告诉npm你的包依赖于哪些模块。让我们深入了解一下这是如何指定的。每个依赖都有一个名称和一个版本。
- en: This tells npm that the package depends on the `accepts` module with version
    1.3.4 and the `body-parse` module with version 1.8.2\. So, when npm installs the
    module, it will implicitly download and install the latest minor versions of the
    dependencies, in case they are not already available.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉npm该包依赖于版本为1.3.4的`accepts`模块和版本为1.8.2的`body-parse`模块。所以，当npm安装该模块时，它将隐式地下载并安装依赖的最新次要版本，如果它们尚未可用。
- en: 'The version of a dependency is specified in the following format: `major.minor.patch-version`. 
    You can specify npm if you want npm to use exactly the specified version, or you
    can have npm always download the latest available minor version, by starting the
    version with `~`; see the `accepts` dependency for reference.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖的版本是以以下格式指定的：`major.minor.patch-version`。你可以指定npm如果你想让npm使用确切指定的版本，或者你可以让npm始终下载最新可用的次要版本，通过以`~`开头的版本；参考`accepts`依赖。
- en: For more information on versioning, visit the website of the semantic versioning
    specification at [http://www.semver.org/](http://www.semver.org/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有关版本控制的更多信息，请访问语义版本规范的网站[http://www.semver.org/](http://www.semver.org/)。
- en: Depending on automatically managed version may result in backward incompatibility,
    make sure you test your application each time you switch a version.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于自动管理的版本可能导致向后不兼容，请确保每次切换版本时都测试你的应用程序。
- en: Setting up a development environment
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: JavaScript developers are rarely used to developing their projects in an IDE;
    most of them use text editors and tend to be prejudiced against anything that
    contradicts their views. GitHub has finally managed to calm most of them down
    by releasing the Atom IDE for the desktop environment. This may not solve all
    of the arguments about which is the best environment, but will at least bring
    some peace, and let people concentrate on their code, not on the tooling, which
    in the end is a matter of personal preference. The samples in this book are developed
    in the Atom IDE, but feel free to use any piece of software that can create files,
    including command-line editors such as vi or vim, if that would make you feel
    like a JS superhero, though bear in mind that superheroes are so 20^(th) century!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript开发人员很少在IDE中开发他们的项目；他们中的大多数人使用文本编辑器，并倾向于对与他们观点相矛盾的任何东西持偏见。GitHub终于通过发布桌面环境的Atom
    IDE来平息了他们中的大多数人。这可能解决不了关于哪种环境最好的争论，但至少会带来一些和平，并让人们专注于他们的代码，而不是工具，这最终是个人偏好的问题。本书中的示例是在Atom
    IDE中开发的，但请随意使用任何可以创建文件的软件，包括vi或vim等命令行编辑器，如果这样做会让您感觉像JS超级英雄，尽管请记住超级英雄已经过时了！
- en: You can download the Atom IDE from [https://ide.atom.io/](https://ide.atom.io/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://ide.atom.io/](https://ide.atom.io/)下载Atom IDE。
- en: 'It is time to start our first Node.js application, a simple web server responding
    with `Hello from Node.js`. Select a directory from your project, for example, `hello-node`,
    then open a shell Terminal from it and execute `npm init`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是启动我们的第一个Node.js应用程序的时候了，一个简单的Web服务器响应`Hello from Node.js`。从您的项目中选择一个目录，例如`hello-node`，然后从中打开一个shell终端并执行`npm
    init`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A command-line interaction wizard will ask you for your project name, its version,
    as well as some other metadata such as Git repository, your name, and so on, and
    will finally preview the `package.json` file it is to generate; when complete,
    your first Node.js project is ready to begin.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个命令行交互向导将询问您的项目名称，版本，以及一些其他元数据，如Git存储库，您的姓名等等，并最终预览要生成的`package.json`文件；完成后，您的第一个Node.js项目准备开始。
- en: Now is the appropriate time to spend some time on the code convention used in
    this book; ES6 inline anonymous functions will be used when short callback functions
    should be defined, while regular javascript function will be used when reusability
    and testability is expected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是花一些时间研究本书中使用的代码约定的合适时机；当需要定义短回调函数时，将使用ES6内联匿名函数，而当期望可重用性和可测试性时，将使用常规的javascript函数。
- en: 'Start the Atom IDE, select File | Add Project Folder..., and import the directory
    you defined the project in. Finally, after a successful import, you will see the
    generated `package.json` file in the project. Right-click on the directory, select New
    File, and create a file called `hello-node.js`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Atom IDE，选择文件|添加项目文件夹...，并导入您定义项目的目录。最后，在成功导入后，您将在项目中看到生成的`package.json`文件。右键单击目录，选择新建文件，并创建一个名为`hello-node.js`的文件：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `hello-node.js` file uses the Node.js HTTP module to start listening for
    incoming requests on port `8180`. It will reply with static `Hello from Node.JS`
    to each request and will log a hello log entry in the console. Before starting
    the application, we have to install the `http` module that creates an HTTP server
    for it. Let''s install it globally together with the `--save` option, which will
    add a dependency to it in the `package.json` file of the project. Then we can
    start the app:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello-node.js`文件使用Node.js HTTP模块开始监听端口`8180`上的传入请求。它将对每个请求回复静态的`Hello from
    Node.JS`，并在控制台中记录一个hello日志条目。在启动应用程序之前，我们必须安装创建HTTP服务器的`http`模块。让我们全局安装它以及`--save`选项，这将在项目的`package.json`文件中添加对它的依赖。然后我们可以启动应用程序：'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Opening `http://localhost:8180/` from your browser will result in sending a
    request to the server application, which will make a log entry in the console
    and will output `Hello from Node.JS` in your browser:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从浏览器打开`http://localhost:8180/`将导致向服务器应用程序发送请求，这将在控制台中记录一个日志条目，并在浏览器中输出`Hello
    from Node.JS`：
- en: '![](img/3c01bdd5-3c7e-4458-a8f3-88140949e0b4.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c01bdd5-3c7e-4458-a8f3-88140949e0b4.png)'
- en: Handling HTTP requests
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理HTTP请求
- en: Currently, our server application will behave in the same way, no matter what
    kind of HTTP request is processed. Let's extend it in such a way that it behaves
    more like an HTTP server, and start differentiating the incoming requests based
    on their type, by implementing handler functions for each type of request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的服务器应用程序无论处理什么类型的HTTP请求都会以相同的方式行为。让我们以这样的方式扩展它，使其更像一个HTTP服务器，并根据其类型开始区分传入请求，通过为每种类型的请求实现处理程序函数。
- en: 'Let''s create a new `hello-node-http-server.js` as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`hello-node-http-server.js`的新文件：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run this application, our HTTP server will recognize the `GET`, `POST`, `PUT`,
    and `DELETE` HTTP methods, and will handle them in different functions. To all
    other HTTP requests, it will gracefully respond with the `HTTP 400 BAD REQUEST`
    status code. To interact with the HTTP applications,  we will use Postman, available
    to download from [https://www.getpostman.com/](https://www.getpostman.com/). It
    is a lightweight application for sending HTTP requests to an endpoint, specifying
    HTTP headers, and providing payload. Give it a try and execute test requests for
    each of the handler functions we implemented previously:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此应用程序时，我们的HTTP服务器将识别`GET`、`POST`、`PUT`和`DELETE` HTTP方法，并将在不同的函数中处理它们。对于所有其他HTTP请求，它将以`HTTP
    400 BAD REQUEST`状态代码优雅地响应。为了与HTTP应用程序交互，我们将使用Postman，可从[https://www.getpostman.com/](https://www.getpostman.com/)下载。这是一个轻量级的应用程序，用于向端点发送HTTP请求，指定HTTP标头，并提供有效载荷。试试并执行我们之前实现的每个处理程序函数的测试请求：
- en: '![](img/46971774-7421-435b-98a2-125e36aa07f3.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46971774-7421-435b-98a2-125e36aa07f3.png)'
- en: Modularizing code
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化代码
- en: What we have developed so far is a simple HTTP server application that listens
    and processes known request types; however, it is not so well structured, as the
    functions handling the requests are not reusable. Node.js supports modules embracing
    code isolation and reusability.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们开发了一个简单的HTTP服务器应用程序，用于监听和处理已知的请求类型；但是，它的结构并不是很好，因为处理请求的函数不可重用。Node.js支持模块，支持代码隔离和可重用性。
- en: A user**-**defined module is a logical unit consisting of one or more related
    functions. The module can export one or more functions to other components while
    keeping other functions visible only to itself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的模块是一个由一个或多个相关函数组成的逻辑单元。该模块可以向其他组件导出一个或多个函数，同时将其他函数保持对自身可见。
- en: We will rework our HTTP server application in such a way that the entire request
    handling functionality will be wrapped in a module. The module will export only
    a generic handler function that will take a request object as argument and, based
    on its request type, it will delegate the handling to inner functions not visible
    outside the module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新设计我们的HTTP服务器应用程序，使整个请求处理功能都包装在一个模块中。该模块将只导出一个通用处理程序函数，该函数将以请求对象作为参数，并根据其请求类型将处理委托给模块外部不可见的内部函数。
- en: 'Let''s start by creating a new module directory within our project. We will
    refactor our previous source file by extracting the following functions to a new
    `http-module.js` file inside the newly created directory:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在项目中创建一个新的模块目录。我们将通过将以下函数提取到新创建的目录中的`http-module.js`文件中来重构我们以前的源文件：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This file creates a user-defined module that exports the `handleRequest` function,
    making it available to the other components. All the other functions are accessible
    only within the module. Although the sample exports only one function, a module
    can export as many functions as is feasible.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件创建了一个用户定义的模块，导出`handleRequest`函数，使其可用于其他组件。所有其他函数只能在模块内部访问。虽然示例只导出一个函数，但模块可以导出尽可能多的函数。
- en: 'Let''s use the new `http-module` in the `main.js` file in the `main` directory
    of our first project. We have to create an `http` server using the Node.js built-in `http`
    module, and its `createServer` will pass its `handleRequest` function as its argument.
    It will serve as a callback function that the server will invoke on each request:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的第一个项目的`main`目录中的`main.js`文件中使用新的`http-module`。我们必须使用Node.js内置的`http`模块创建一个`http`服务器，其`createServer`将其`handleRequest`函数作为参数传递。它将作为服务器在每个请求上调用的回调函数：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We separated the creation of the server socket from the business logic that
    handles the incoming requests bound to it. The `require` directive is used to
    import our module. It uses a relative path to it. Try this version as well by
    executing another test request with the Postman tooling.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建服务器套接字的创建与处理与其绑定的传入请求的业务逻辑分开。使用`require`指令导入我们的模块。它使用相对路径。也可以使用Postman工具执行另一个测试请求来尝试这个版本。
- en: Luckily, we will not be creating our own HTTP handlers when implementing our
    RESTful-enabled applications. The Express framework will do this for us. The examples
    in this chapter are meant to provide a clear example of the Node.js possibilities
    when it comes to handling HTTP requests and how user modules are implemented.
    We will take a detailed look at the Express framework in [Chapter 3](5196664d-ad9d-4430-ae89-0f514a9508f5.xhtml),
    *Building a Typical Web API*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在实现支持RESTful的应用程序时，我们不需要创建自己的HTTP处理程序。Express框架将为我们完成这些工作。本章的示例旨在清楚地展示Node.js在处理HTTP请求和实现用户模块方面的可能性。我们将在[第3章](5196664d-ad9d-4430-ae89-0f514a9508f5.xhtml)中详细了解Express框架，*构建典型的Web
    API*。
- en: Testing Node.js
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Node.js
- en: Now we will extend our project by providing a unit test for the HTTP module,
    but before diving into that, let's have a look at how Node.js supports unit testing
    in general. At the beginning of this chapter, we installed the Nodeunit module.
    Well, it's about time we started playing around with it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过为HTTP模块提供一个单元测试来扩展我们的项目，但在深入研究之前，让我们先看看Node.js如何支持单元测试。在本章的开头，我们安装了Nodeunit模块。好吧，现在是时候开始尝试一下了。
- en: First, let's create another simple Node.js module that we will use to implement
    our first unit test. Then we will move to more advanced topics, such as mocking
    JavaScript objects and using them to create unit tests for our HTTP module.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建另一个简单的Node.js模块，我们将用它来实现我们的第一个单元测试。然后我们将转向更高级的主题，比如模拟JavaScript对象并使用它们来为我们的HTTP模块创建单元测试。
- en: I have chosen to develop a simple math module that exports functions for adding
    and subtracting integer numbers, as it is straightforward enough and the results
    of each operation are strictly defined.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择开发一个简单的数学模块，导出用于添加和减去整数的函数，因为它足够简单，每个操作的结果都是严格定义的。
- en: 'Let''s start with the module and create the following `math.js` file in our
    `module` directory:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从模块开始，在我们的`module`目录中创建以下`math.js`文件：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next step will be to create a `test-math.js` file in the `test` subdirectory
    of our project:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在项目的`test`子目录中创建一个`test-math.js`文件：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, run the test module from a shell Terminal with `nodeunit test/test-math.js`.
    The output will show the results of all the test methods, specifying whether they
    passed successfully or not:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用shell终端运行`nodeunit test/test-math.js`来运行测试模块。输出将显示所有测试方法的结果，指定它们是否成功通过：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s modify `addTest` in such a way that it gets broken and to see how test
    failures are reported by the Nodeunit module:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`addTest`，使其出现故障，看看Nodeunit模块如何报告测试失败：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Executing the test this time results in a failure with some assert failure
    messages, and in the end, there is an aggregation saying how many of the executed
    tests failed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这次执行测试会导致失败，并显示一些断言失败的消息，最后会有一个汇总，显示执行的测试中有多少失败了：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We just created our Nodeunit's first unit test. However, it tests math function
    in a rather isolated way. I suppose you are wondering how we can use Nodeunit
    to test functions with complex arguments such as HTTP request and response, that
    are bound to a context. This is possible using so-called **mock objects**. They
    are a predefined version of the state of complex context-based arguments or functions,
    in objects that we want to use in our unit test in order to test the behavior
    of our module for the exact state of the object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了 Nodeunit 的第一个单元测试。但是，它以一种相对隔离的方式测试数学函数。我想你会想知道我们如何使用 Nodeunit 来测试具有复杂参数的函数，比如绑定到上下文的
    HTTP 请求和响应。这是可能的，使用所谓的**模拟对象**。它们是复杂基于上下文的参数或函数状态的预定义版本，在我们的单元测试中，我们想要使用这些对象来测试模块的行为以获取对象的确切状态。
- en: To use mock objects, we will need to install a module that supports object mocking.
    There are various types of testing tools and modules available out there. Most
    of them, however, are designed to test the JavaScript client functionality. There
    are modules such as JsMockito, a JavaScript fork of the famous Mockito framework
    for Java, and node-inspector, a module that provides a JavaScript debugger that
    starts implicitly in the Google Chrome browser.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用模拟对象，我们需要安装一个支持对象模拟的模块。那里有各种类型的测试工具和模块可用。然而，大多数都是设计用于测试 JavaScript 客户端功能。有一些模块，比如
    JsMockito，这是 Java 著名 Mockito 框架的 JavaScript 版本，还有 node-inspector，这是一个提供 JavaScript
    调试器的模块，它会在 Google Chrome 浏览器中隐式启动。
- en: Native support for the Chrome browser is logical, since Node.js is built on
    top of the Google V8 JavaScript Engine. As we are developing a server-side application,
    these are not the most convenient tools, as JsMockito is not pluggable as a Node.js
    module, and using a debugger within your browser to debug backed applications
    just doesn't seem right to me. Anyway, if you are about to dive deeper into Node.js,
    you should definitely give them a try.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Chrome 浏览器的本地支持是合理的，因为 Node.js 是构建在 Google V8 JavaScript 引擎之上的。由于我们正在开发服务器端应用程序，这些并不是最方便的工具，因为
    JsMockito 不能作为 Node.js 模块进行插件化，并且在浏览器中使用调试器来调试后端应用程序对我来说并不合适。无论如何，如果你打算深入了解 Node.js，你应该一定要试试。
- en: 'For testing server-side JavaScript modules, we will use the Sinon.JS module.
    Like all the other modules, it is available in the npm repository, so execute
    the following command to install it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试服务器端 JavaScript 模块，我们将使用 Sinon.JS 模块。像所有其他模块一样，它可以在 npm 仓库中找到，因此执行以下命令来安装它：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Sinon.JS is a very flexible JavaScript testing library providing functionality
    for mocking, stubbing, and spying on JavaScript objects. It is available at [http://sinonjs.org](http://sinonjs.org)
    and can be used with any JavaScript testing framework. Let's see what we need
    in order to test our HTTP module. It exports a single method, `handleRequest`,
    which takes the HTTP request and response objects as arguments. Based on the requested
    method, the module calls its internal functions to handle different requests.
    Each request handler writes a different output to the response.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 是一个非常灵活的 JavaScript 测试库，提供了对 JavaScript 对象进行模拟、存根和监视的功能。它可以在任何 JavaScript
    测试框架中使用，网址是 [http://sinonjs.org](http://sinonjs.org)。让我们看看我们需要什么来测试我们的 HTTP 模块。它导出一个单一方法
    `handleRequest`，该方法以 HTTP 请求和响应对象作为参数。基于请求的方法，该模块调用其内部函数来处理不同的请求。每个请求处理程序向响应写入不同的输出。
- en: To test this functionality in an isolated environment such as Nodeunit, we need
    mock objects, which will then be passed as arguments. To ensure that the module
    behaves as expected, we will need to have access to the data stored in those objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在诸如 Nodeunit 这样的隔离环境中测试此功能，我们需要模拟对象，然后将其作为参数传递。为了确保模块的行为符合预期，我们需要访问存储在这些对象中的数据。
- en: Working with mock objects
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟对象
- en: 'Here are the steps that need to be carried out when using mock objects:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟对象时需要执行的步骤如下：
- en: 'Call the `require` function with `sinon` as a parameter and export a `test`
    function from it:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sinon` 作为参数调用 `require` 函数，并从中导出一个 `test` 函数：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define an API description of the method you want to mock as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示定义要模拟的方法的 API 描述：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use `sinon` within the exported function in order to create mock objects out
    of the `api` description:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导出的函数中使用 `sinon` 来根据 `api` 描述创建模拟对象：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Set the expectations on the mock objects. Expectations are set on the mocked
    objects by describing how the mocked method should behave, what arguments it is
    supposed to take, and what value it is supposed to return. When the mocked method
    is called with a different state than what is described, the expectation will
    fail when verified later:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置模拟对象的期望。期望是在模拟对象上设置的，描述了模拟方法应该如何行为，它应该接受什么参数，以及它应该返回什么值。当模拟方法以与描述不同的状态调用时，期望在后来验证时将失败：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding sample expects that `methodX` gets called exactly once with the
    `xyz` argument, and it will force the method to return `abc`. The Sinon.JS module
    makes that possible for us.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上面的示例期望 `methodX` 被调用一次，并且带有 `xyz` 参数，它将强制该方法返回 `abc`。Sinon.JS 模块使我们能够实现这一点。
- en: The method of the description object is called and not that of the mocked object.
    The mocked object is used to set the expectations for the mocked method, and later
    to check whether those expectations have been fulfilled.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 调用描述对象的方法，而不是模拟对象的方法。模拟对象用于设置模拟方法的期望，并在后来检查这些期望是否已经实现。
- en: Use the mocked object in the test environment and, later, call its `verify()`
    method. This method will check whether the code being tested interacted correctly
    with mock, that is, how many times the method has been called and whether it has
    been called with the expected arguments. If any of the expectations is not met,
    then an error will be thrown, causing the test to fail.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试环境中使用模拟对象，然后调用其 `verify()` 方法。该方法将检查被测试代码是否与模拟对象正确交互，即该方法被调用的次数以及是否使用了预期的参数进行调用。如果任何期望未能满足，那么将抛出错误，导致测试失败。
- en: 'The exported `test` function of our test module has an argument. That argument
    provides assert methods that can be used to check test conditions. In our example,
    we mocked the method to always return `abc` when called with the `''xyz''` arguments.
    So, to complete the test, the following assert can be done, and in the end, the
    mock object needs to be verified:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的测试模块的导出`test`函数有一个参数。该参数提供了可以用来检查测试条件的断言方法。在我们的示例中，我们模拟了该方法，以便在使用`'xyz'`参数调用时始终返回`abc`。因此，为了完成测试，可以进行以下断言，并且最后需要验证模拟对象：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Try modifying the arguments passed to `methodX` such that they don't match the
    expectation, and you will see this breaking your test.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试修改传递给`methodX`的参数，使其不符合预期，您将看到这会破坏您的测试。
- en: 'Let''s put these steps into practice and create the following `test-http-module.js`
    file in the `test` directory:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这些步骤付诸实践，并在`test`目录中创建以下`test-http-module.js`文件：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start the test with Nodeunit''s `test-http-module.js` to verify that it passes
    successfully. Your next step will be to extend the test so that it covers the
    handling of all the HTTP methods in our HTTP module:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Nodeunit的`test-http-module.js`开始测试以验证其是否成功通过。您的下一步将是扩展测试，以便覆盖我们的HTTP模块中所有HTTP方法的处理：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Deploying an application
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Node.js has an event-driven, non-blocking I/O model, which makes it perfect
    for real-time applications that scale well in distributed environments, such as
    public or private cloud platforms. Each cloud platform offers tools that allow
    seamless deployment, distribution, and scaling of its hosted applications. In
    this section, we will look at two publicly available Node.js application cloud
    providers—Nodejitsu and Microsoft Azure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js具有事件驱动的、非阻塞的I/O模型，这使其非常适合在分布式环境中良好扩展的实时应用程序，例如公共或私有云平台。每个云平台都提供工具，允许其托管应用程序的无缝部署、分发和扩展。在本节中，我们将看一下两个公开可用的Node.js应用程序云提供商——Nodejitsu和Microsoft
    Azure。
- en: But first, let's spend some time on the clustering support, as it is fundamental
    for understanding why Node.js fits so well into the cloud environment. Node.js
    comes with clustering support built in to its core. Using the cluster module in
    your applications allows them to start as many workers as necessary to handle
    the load they will face. Generally, it is recommended to match the number of workers
    to the number of threads or logical cores your environment has.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们花一些时间来了解集群支持，因为这对于理解为什么Node.js非常适合云环境至关重要。Node.js内置了集群支持。在您的应用程序中使用集群模块允许它们启动尽可能多的工作进程来处理它们将面临的负载。通常建议将工作进程的数量与您的环境的线程数或逻辑核心数匹配。
- en: The heart of your application is the master process. It is responsible for keeping
    a registry of active workers and the load of the application, and how to create
    it. It also creates more workers when needed and reduces them when the load decreases.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序的核心是主进程。它负责保持活动工作进程的注册表和应用程序的负载，以及如何创建它。当需要时，它还会创建更多的工作进程，并在负载减少时减少它们。
- en: The cloud platform should also ensure that there is zero downtime when deploying
    new versions of the applications. In such cases, the master process needs to be
    notified that a newer version should be distributed. It should fork the new workers'
    new application version, and notify the workers currently running with the old
    version to close their listeners; thus, it stops accepting connections and exits
    gracefully once they finish. Thus, all the new incoming requests will be handled
    by the newly-started workers, and after the obsolete workers terminate, all the
    running workers will be running the latest version.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 云平台还应确保在部署应用程序的新版本时没有任何停机时间。在这种情况下，主进程需要被通知要分发新版本。它应该fork新的工作进程的新应用程序版本，并通知当前使用旧版本的工作进程关闭它们的监听器；因此，它停止接受连接并在完成后优雅地退出。因此，所有新的传入请求将由新启动的工作进程处理，并在过时的工作进程终止后，所有运行中的工作进程将运行最新版本。
- en: Nodejitsu
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nodejitsu
- en: Let's take a closer look at some of the Node.js **Platform as a Service** (**PaaS**)
    offerings. The first PaaS we will look at is Nodejitsu, available at [https://www.nodejitsu.com](https://www.nodejitsu.com).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一些Node.js**平台即服务**（**PaaS**）提供。我们将首先看一下Nodejitsu，可在[https://www.nodejitsu.com](https://www.nodejitsu.com)上找到。
- en: 'This allows seamless deployment of Node.js applications on the cloud, with
    many useful features for development, management, deployment, and monitoring of
    Node.js applications. To interact with jitsu, you need to install its command-line
    interface, which is available as a Node.js module:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在云上无缝部署Node.js应用程序，具有许多有用的功能，用于Node.js应用程序的开发、管理、部署和监控。要与jitsu交互，您需要安装其命令行界面，该界面可作为Node.js模块使用：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After installing jitsu and starting it with `jitsu`, you will be given a warm
    welcome, with a friendly console screen that will introduce you to the basic jitsu
    commands, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 安装jitsu并使用`jitsu`启动后，您将受到热烈欢迎，友好的控制台屏幕将向您介绍基本的jitsu命令，如下所示：
- en: '![](img/57d146c5-2355-45cd-a97c-de2762730c20.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57d146c5-2355-45cd-a97c-de2762730c20.png)'
- en: In order to interact with jitsu, you will need to sign up for it. Jitsu offers
    different pricing plans, as well as free trial services.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与jitsu交互，您需要注册。Jitsu提供不同的定价计划，以及免费试用服务。
- en: You can do that either from their website or with the `jitsu signup` command.
    Then you can start making use of the tools the command-line interface offers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从他们的网站或使用`jitsu signup`命令来执行此操作。然后，您可以开始使用命令行界面提供的工具。
- en: Microsoft Azure
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微软Azure
- en: Microsoft's cloud platform as a service, Azure, also offers hosting of Node.js
    applications. They have chosen a slightly different approach, and instead of providing
    a command-line interface to interact with their repositories, they make use of
    their Git integration; that is, you interact with Azure as you would interact
    with any other Git repository. If you are not familiar with Git, I strongly recommend
    that you learn more about this distributed source code version control system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的云平台即服务Azure也提供Node.js应用程序的托管。他们选择了一个略有不同的方法，而不是提供一个命令行界面来与他们的存储库交互，他们利用了他们的Git集成；也就是说，您与Azure的交互方式与您与任何其他Git存储库的交互方式相同。如果您对Git不熟悉，我强烈建议您了解更多关于这个分布式源代码版本控制系统的知识。
- en: If you've chosen Azure as your platform, you will find the following link very
    useful: [http://azure.microsoft.com/en-us/develop/nodejs/](http://azure.microsoft.com/en-us/develop/nodejs/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择Azure作为您的平台，您会发现以下链接非常有用：[http://azure.microsoft.com/en-us/develop/nodejs/](http://azure.microsoft.com/en-us/develop/nodejs/)。
- en: Heroku
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Heroku
- en: 'Heroku is a public cloud offering that allows you to manage, deploy, and scale
    Node.js applications. Preparing your Node application for the Heroku environment
    does not take too much effort, as long as you install its command-line interface,
    available either at [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)
    or through your package manager with the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是一个公共云服务，允许您管理、部署和扩展Node.js应用程序。准备将您的Node应用程序适应Heroku环境并不需要太多的努力，只要安装其命令行界面，可以在[https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)或通过您的包管理器获得。
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All you have to do is provide a `'start script'` element in the `package.json`
    file, push it to your relevant origin Git repository using `git push master heroku`,
    then log in and create your application, using the `heroku login` and `heroku
    create` commands.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需在`package.json`文件中提供一个`'start script'`元素，使用`git push master heroku`将其推送到相关的Git存储库，然后登录并创建您的应用程序，使用`heroku
    login`和`heroku create`命令。
- en: Self-test questions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'To get additional confidence about your newly-gained knowledge, go through
    the next set of statements and state whether they are true or false:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对您新获得的知识更有信心，浏览下一组陈述，并说明它们是真还是假：
- en: Node modules can export more than one function to outer components
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node模块可以向外部组件导出多个函数
- en: Node modules are extensible
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node模块是可扩展的
- en: Modules always need to explicitly declare their dependencies to other modules
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块总是需要明确声明它们对其他模块的依赖关系
- en: When using mocking in a test environment, the mocked method is called on the
    mocked object
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试环境中使用模拟时，模拟的方法是在模拟对象上调用的
- en: Debugging Node.js code is not as straightforward as other pieces of non-JavaScript
    code
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试Node.js代码并不像其他非JavaScript代码那样直截了当
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you gained your first Node.js experience, starting from a simple
    `Hello world` application and moving on to a more complex sample HTTP server-like
    application that handles incoming HTTP requests. Being more confident with Node.js,
    you refactored the application to use user modules, and then created unit tests
    for your module using a mocking framework to eliminate dependencies on complex
    objects in your test environment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您获得了第一个Node.js体验，从一个简单的“Hello world”应用程序开始，然后转移到一个处理传入HTTP请求的更复杂的样本HTTP服务器应用程序。更加自信地使用Node.js，您重构了应用程序以使用用户模块，然后使用模拟框架为您的模块创建了单元测试，以消除测试环境中复杂对象的依赖关系。
- en: Now that you've understood how to handle and test incoming HTTP requests, in
    the next chapter, our next step will be to define what a typical web API looks
    like and how it can be tested.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何处理和测试传入的HTTP请求，在下一章中，我们的下一步将是定义典型Web API的外观以及如何进行测试。
