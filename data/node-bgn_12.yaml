- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Data Persistence with MongoDB
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 实现数据持久化
- en: In this chapter, we will explain how MongoDB works and why it is a great starting
    point for a web application. We will learn how to install MongoDB locally using
    containers with Docker and Docker Compose and also how to use external MongoDB
    instances.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释 MongoDB 的工作原理以及为什么它是 Web 应用程序的绝佳起点。我们将学习如何使用带有 Docker 和 Docker Compose
    的容器在本地安装 MongoDB，以及如何使用外部 MongoDB 实例。
- en: We will explore how to use Mongoose to interact with MongoDB, and we will migrate
    our application to use MongoDB instead of a JSON file, we will use tests to grant
    that the migration was properly done and we didn’t introduce any regression.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用 Mongoose 与 MongoDB 交互，并将我们的应用程序迁移到使用 MongoDB 而不是 JSON 文件，我们将使用测试来确保迁移正确完成，并且没有引入任何回归。
- en: 'In summary, here are the main topics that we will explore in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，以下是本章我们将探讨的主要主题：
- en: How to set up MongoDB locally using containers with Docker and Docker Compose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Docker 和 Docker Compose 在本地设置 MongoDB
- en: How to use an **Object–relational mapping** (**ORM**) library such as Mongoose
    to interact with MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 **对象关系映射**（**ORM**）库如 Mongoose 与 MongoDB 交互
- en: How to migrate our application to use MongoDB instead of a JSON file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将我们的应用程序迁移到使用 MongoDB 而不是 JSON 文件
- en: How to test any application using MongoDB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 MongoDB 测试任何应用程序
- en: How to use environment variables to store sensitive information and how to load
    them in Node.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用环境变量存储敏感信息以及如何在 Node.js 中加载它们
- en: By the end of this chapter, you will be comfortable using MongoDB in your Node.js
    projects, and you will know how to use tests to plan more complicated features
    such as a database migration.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够舒适地在 Node.js 项目中使用 MongoDB，并且将了解如何使用测试来规划更复杂的功能，例如数据库迁移。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners)
    找到。
- en: Check out the code in action video for this chapter on [https://youtu.be/0CHOQ35c-_Y](https://youtu.be/0CHOQ35c-_Y)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本章动作视频中的代码 [https://youtu.be/0CHOQ35c-_Y](https://youtu.be/0CHOQ35c-_Y)
- en: To start working on this chapter, we need to download the project from [https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip](https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip)
    and access the `step2` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本章的工作，我们需要从 [https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip](https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip)
    下载项目并访问 `step2` 文件夹。
- en: What is MongoDB?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 MongoDB？
- en: If you are familiar with relational databases, you will find MongoDB very different.
    MongoDB is a document-oriented database, which means that it stores data in documents
    instead of tables. A document is a set of key-value pairs, and it is the basic
    unit of data in MongoDB. Documents are similar to JSON objects, and they are stored
    in a collection. A collection is a group of documents that have the same structure.
    In MongoDB, documents are stored in **Binary JSON** (**BSON**), a binary representation
    of JSON documents.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉关系型数据库，你会发现 MongoDB 非常不同。MongoDB 是一个面向文档的数据库，这意味着它以文档的形式存储数据而不是表格。文档是一组键值对，它是
    MongoDB 中的基本数据单元。文档类似于 JSON 对象，并且存储在集合中。集合是一组具有相同结构的文档。在 MongoDB 中，文档以 **二进制 JSON**（**BSON**）的形式存储，这是
    JSON 文档的二进制表示。
- en: '![Figure 12.1 – A SQL data structure compared to a MongoDB data structure](img/B21678_12_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 将 SQL 数据结构与 MongoDB 数据结构进行比较](img/B21678_12_1.jpg)'
- en: Figure 12.1 – A SQL data structure compared to a MongoDB data structure
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 将 SQL 数据结构与 MongoDB 数据结构进行比较
- en: In the preceding diagram, we can see the difference between a relational database
    and a document-oriented database more clearly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以更清楚地看到关系型数据库和面向文档的数据库之间的区别。
- en: Versions
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本
- en: There are several versions of MongoDB, but the most popular is MongoDB Community
    Server. In our project, we will also use MongoDB Community Server as well, at
    no extra cost to us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 有几个版本，但最受欢迎的是 MongoDB 社区服务器。在我们的项目中，我们也将使用 MongoDB 社区服务器，这对我们来说没有额外的成本。
- en: In [*Chapter 16*](B21678_16.xhtml#_idTextAnchor416), we will explore more versions
    of MongoDB when we deploy our application to the cloud.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 16 章*](B21678_16.xhtml#_idTextAnchor416) 中，当我们将应用程序部署到云端时，我们将探索更多 MongoDB
    的版本。
- en: 'If you want to know more about the different versions of MongoDB, you can check
    out the following link: [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于 MongoDB 不同版本的信息，您可以查看以下链接：[https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)。
- en: In the next section, we will explain how to install MongoDB locally using containers
    with Docker and Docker Compose, as well as how to use external MongoDB instances.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何使用 Docker 和 Docker Compose 在容器中本地安装 MongoDB，以及如何使用外部 MongoDB 实例。
- en: Setting up MongoDB
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 MongoDB
- en: There are several ways to install MongoDB, but we will use Docker Compose to
    install it locally. Docker Compose is a tool for defining and running multi-container
    Docker applications. With Docker Compose, we will be able to run MongoDB and our
    web application in different containers. If you are not familiar with Docker,
    there is a fantastic guide from MongoDB ([https://www.mongodb.com/compatibility/docker](https://www.mongodb.com/compatibility/docker))
    that can help you get a deeper understanding.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 MongoDB 有几种方法，但我们将使用 Docker Compose 在本地安装它。Docker Compose 是一个用于定义和运行多容器 Docker
    应用程序的工具。使用 Docker Compose，我们将能够在不同的容器中运行 MongoDB 和我们的 Web 应用程序。如果您不熟悉 Docker，MongoDB
    提供了一个出色的指南 ([https://www.mongodb.com/compatibility/docker](https://www.mongodb.com/compatibility/docker))，可以帮助您更深入地了解。
- en: Installing Docker
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: If you don’t have Docker installed, you can follow the instructions at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/),
    depending on your operating system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装 Docker，您可以按照您操作系统的说明在以下链接中操作：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。
- en: Checking the installation
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查安装
- en: 'Let’s check that Docker is installed correctly. Open a terminal and run the
    following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 Docker 是否已正确安装。打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see the version installed – in my case, 24.0.2:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到已安装的版本 - 在我的情况下，是 24.0.2：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also check that Docker Compose is installed correctly. Open a terminal
    and run the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查 Docker Compose 是否已正确安装。打开终端并运行以下命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下内容：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running MongoDB with a container
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器运行 MongoDB
- en: The beauty of Docker is that we can run MongoDB in a container. A container
    is a standard unit of software that packages up code and all its dependencies.
    That way, we can create a MongoDB container and run it on our local machine, and
    we don’t have to install MongoDB locally. When we don’t need the container anymore,
    we can stop it and remove it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的美妙之处在于我们可以在容器中运行 MongoDB。容器是一个标准的软件单元，它将代码及其所有依赖项打包在一起。这样，我们就可以创建一个
    MongoDB 容器，并在我们的本地机器上运行它，我们不需要在本地安装 MongoDB。当我们不再需要容器时，我们可以停止它并删除它。
- en: 'In our case, we will use Mongo 7.0.0, which is the latest version of MongoDB.
    We will use the official image of MongoDB, which is available on Docker Hub. You
    can find more information about this image at the following link: [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将使用 Mongo 7.0.0，这是 MongoDB 的最新版本。我们将使用 MongoDB 的官方镜像，该镜像可在 Docker
    Hub 上找到。您可以在以下链接中找到有关此镜像的更多信息：[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)。
- en: 'To run MongoDB in a container, we will use the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要在容器中运行 MongoDB，我们将使用以下命令：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command will create a container with the name `whispering-database`, and
    it will map port `27017` of the container to port `27017` of the host machine.
    The `-d` flag means that the container will run in the background.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个名为 `whispering-database` 的容器，并将容器中的端口 `27017` 映射到主机机的端口 `27017`。`-d`
    标志表示容器将在后台运行。
- en: 'The output should be something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As shown in the output, the image was not found locally, so it was downloaded
    from Docker Hub. You might get an error, if the port 2701 is already in use, as
    the container can’t take control over. You can easily check this by following
    these steps ([https://kb.vmware.com/s/article/1003971](https://kb.vmware.com/s/article/1003971)).If
    everything goes well, the container is running in the background, so we can check
    that it is running with the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，本地未找到镜像，因此它从 Docker Hub 下载。如果端口 2701 已被占用，您可能会遇到错误，因为容器无法接管。您可以通过以下步骤轻松检查：[https://kb.vmware.com/s/article/1003971](https://kb.vmware.com/s/article/1003971)。如果一切顺利，容器将在后台运行，因此我们可以使用以下命令检查它是否正在运行：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should be something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can stop the container with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令停止容器：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And you can remove the container with the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令删除容器：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you removed the container, you can always create a new container again with
    the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您删除了容器，您可以使用以下命令再次创建一个新的容器：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running MongoDB with Docker Compose
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 运行 MongoDB
- en: An alternative to running MongoDB with a container is to use Docker Compose.
    Docker Compose is a tool to define and run multi-container Docker applications
    using a YAML file. One of the advantages of using Docker Compose is that we can
    define the configuration of the container in a YAML file, so we don’t have to
    remember the commands to run the container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器运行 MongoDB 的另一种选择是使用 Docker Compose。Docker Compose 是一个工具，用于使用 YAML 文件定义和运行多容器
    Docker 应用程序。使用 Docker Compose 的一个优点是，我们可以在 YAML 文件中定义容器的配置，这样我们就不必记住运行容器的命令。
- en: 'Let’s create a `docker-compose.yml` file with the following content for our
    project:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的项目创建一个包含以下内容的 `docker-compose.yml` 文件：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this file, we define a service called `database` that uses the `mongo:7.0`
    image. We also map port `27017` of the container to port `27017` of the host machine.
    Finally, we define a volume called `db-storage` that will be used to store the
    data of the database, so we don’t lose it when we stop the container.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们定义了一个名为 `database` 的服务，它使用 `mongo:7.0` 镜像。我们还映射了容器的端口 `27017` 到主机的端口
    `27017`。最后，我们定义了一个名为 `db-storage` 的卷，它将用于存储数据库的数据，这样我们在停止容器时就不会丢失它。
- en: 'In order to run the container in the background, we have to run the following
    command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在后台运行容器，我们必须运行以下命令：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output should be something like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Your containers are now ready to use, but you can stop them by running the
    following command in the same folder:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您的容器现在已准备好使用，但您可以通过在相同文件夹中运行以下命令来停止它们：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next section, we will learn how to include the Docker-related commands
    to the `package.json` as npm scripts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将 Docker 相关的命令作为 npm 脚本添加到 `package.json` 中。
- en: Adding Docker commands to package.json
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Docker 命令添加到 package.json
- en: 'Sometimes, it is hard to remember the docker compose commands, so we can add
    them to the `package.json` file. Add the following scripts:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，记住 docker compose 命令可能会有点困难，因此我们可以将它们添加到 `package.json` 文件中。添加以下脚本：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, we can use `npm run infra:start` and `npm run infra:stop` to manage the
    project database on our local machine.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `npm run infra:start` 和 `npm run infra:stop` 在本地机器上管理项目数据库。
- en: Connecting to MongoDB
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到 MongoDB
- en: There are two ways to connect to MongoDB – using the `mongo` shell or port `27017`.
    In this section, we will explain how to connect to MongoDB using both ways.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 MongoDB 有两种方式——使用 `mongo` shell 或端口 `27017`。在本节中，我们将解释如何使用这两种方式连接到 MongoDB。
- en: 'We can connect to MongoDB using the `mongo` shell with the following command
    if we use Docker:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令通过 `mongo` shell 连接到 MongoDB，如果我们使用 Docker 的话：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see now that we are inside the container, as an alternative you can
    use directly the docker compose command to access the container `docker-compose
    exec database /bin/bash`. Now, we can connect to MongoDB with the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到我们已经在容器内部，作为替代，您可以直接使用 docker compose 命令来访问容器 `docker-compose exec database
    /bin/bash`。现在，我们可以使用以下命令连接到 MongoDB：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的内容：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This way, we can access a `mongo` shell directly if needed. In the following
    sections, we will explain how to connect to MongoDB using port `27017`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果需要，我们可以直接访问 `mongo` shell。在接下来的章节中，我们将解释如何通过端口 `27017` 连接到 MongoDB。
- en: Other ways to install MongoDB
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 MongoDB 的其他方法
- en: 'If you don’t want to use Docker Compose, you can install MongoDB locally. You
    can find the instructions for your operating system at the following link: [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用 Docker Compose，您可以在本地安装 MongoDB。您可以在以下链接找到您操作系统的说明：[https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)。
- en: Remember that you can also use MongoDB Atlas ([https://www.mongodb.com/atlas](https://www.mongodb.com/atlas))
    or any other cloud provider that offers MongoDB as a service.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您还可以使用 MongoDB Atlas ([https://www.mongodb.com/atlas](https://www.mongodb.com/atlas))
    或任何提供 MongoDB 服务的其他云提供商。
- en: Now that we have MongoDB running, we can start using it, but first, we need
    to understand how to use secrets in Node.js so that we can pass the connection
    string to the application in a safe mode. So, in the next section, we will explain
    how to load secrets in Node.js.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了MongoDB，我们可以开始使用它，但首先，我们需要了解如何在Node.js中使用秘密，以便我们可以以安全模式将连接字符串传递给应用程序。因此，在下一节中，我们将解释如何在Node.js中加载秘密。
- en: How to load secrets in Node.js
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在Node.js中加载秘密
- en: Our application will need to connect to MongoDB, so we need to store the connection
    string in a safe place. You should never store secrets in your code; a very common
    practice is to store them in environment variables. In this section, we will explain
    how to load secrets from environment variables in Node.js.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要连接到MongoDB，因此我们需要将连接字符串存储在安全的地方。你不应该在代码中存储秘密；一个非常常见的做法是将它们存储在环境变量中。在本节中，我们将解释如何在Node.js中从环境变量中加载秘密。
- en: Environment variables
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量
- en: 'Environment variables are variables that are set in the environment in which
    the process runs. They are usually set in the operating system, but we can also
    set them in the terminal. We can access the environment variables in Node.js using
    the `process.env` object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是在进程运行的环境中设置的变量。它们通常在操作系统中设置，但我们也可以在终端中设置它们。我们可以在Node.js中使用`process.env`对象访问环境变量：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can set an environment variable in the terminal with the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令在终端中设置环境变量：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, you can run your application with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下命令运行你的应用程序：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, you can set the environment variable in the same command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在同一命令中设置环境变量：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are using Windows you might need to use a different approach to handle
    environmental variables in the terminal. Read ([https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html](https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html))
    for additional information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，你可能需要使用不同的方法在终端中处理环境变量。阅读([https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html](https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html))获取更多信息。
- en: In the next section, we will learn how to use a. `.env` file to manage the secrets
    in a more ergonomic way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用`.env`文件以更便捷的方式管理秘密。
- en: The .env file
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`.env`文件'
- en: 'While using environmental varaibles directly in the terminal is a very common
    practice, it is not very convenient. We can use a file called `.env` to store
    our environment variables. We can create a `.env` file with the following content:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在终端中直接使用环境变量是一个非常常见的做法，但它并不方便。我们可以使用一个名为`.env`的文件来存储我们的环境变量。我们可以创建一个包含以下内容的`.env`文件：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then, we can use the `dotenv` package ([https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv))
    to load the environment variables from the `.env` file, but it’s worth mentioning
    that Node.js 20.6.0 introduced support for loading environment variables from
    a `.env` file, so we don’t need to use third-party packages anymore ([https://github.com/nodejs/node/releases/tag/v20.6.0](https://github.com/nodejs/node/releases/tag/v20.6.0)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`dotenv`包([https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv))从`.env`文件中加载环境变量，但值得一提的是，Node.js
    20.6.0版本引入了对从`.env`文件加载环境变量的支持，因此我们不再需要使用第三方包了([https://github.com/nodejs/node/releases/tag/v20.6.0](https://github.com/nodejs/node/releases/tag/v20.6.0))。
- en: Warning
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: We should never commit the `.env` file to the repository because it contains
    secrets. You can include the `.env` file into the `.gitignore` file to avoid commit
    the .env file along the project source code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不应该将`.env`文件提交到仓库，因为它包含秘密。你可以将`.env`文件添加到`.gitignore`文件中，以避免将.env文件与项目源代码一起提交。
- en: dotenv
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dotenv
- en: 'The most common way to load environment variables from a `.env` file is to
    use the `dotenv` package ([https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv)).
    We can install it with the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从`.env`文件加载环境变量的最常见方法是使用`dotenv`包([https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv))。我们可以使用以下命令安装它：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can load the environment variables from the `.env` file with the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码从`.env`文件中加载环境变量：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, we can do it directly using the `--``require` flag:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以直接使用`--require`标志来执行：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the next section, we will explain how to use **Object-Relational Mapping**
    (**ORM**) to interact with MongoDB and how this can make our life easier when
    building a web application for the first time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何使用 **对象关系映射**（**ORM**）与 MongoDB 交互，以及这如何使我们在第一次构建 Web 应用程序时生活更加轻松。
- en: Using an ORM – Mongoose
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ORM – Mongoose
- en: We can use MongoDB directly, but it will require a bigger understanding and
    more code to interact with the database. As the objective of this book is to learn
    Node.js, we will use an ORM to interact with MongoDB. An ORM is a library that
    allows us to interact with a database using objects instead of SQL queries. In
    this section, we will use Mongoose ([https://mongoosejs.com/](https://mongoosejs.com/)).
    Alternatively, you can use MongoDB Node.js Driver, which is the official MongoDB
    driver ([https://docs.mongodb.com/drivers/node/](https://docs.mongodb.com/drivers/node/))
    for Node.js. The official documentation can be found at [https://mongoosejs.com/docs/guide.html](https://mongoosejs.com/docs/guide.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用 MongoDB，但这将需要更深入的理解和更多的代码来与数据库交互。由于本书的目的是学习 Node.js，我们将使用 ORM 来与 MongoDB
    交互。ORM 是一个库，它允许我们使用对象而不是 SQL 查询来与数据库交互。在本节中，我们将使用 Mongoose ([https://mongoosejs.com/](https://mongoosejs.com/))。或者，您也可以使用
    MongoDB Node.js 驱动程序，这是 Node.js 的官方 MongoDB 驱动程序 ([https://docs.mongodb.com/drivers/node/](https://docs.mongodb.com/drivers/node/))。官方文档可以在
    [https://mongoosejs.com/docs/guide.html](https://mongoosejs.com/docs/guide.html)
    找到。
- en: 'Mongoose offers several features that are quite convenient for a web application:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 提供了几个对 Web 应用程序来说非常方便的功能：
- en: '**Schema validation**: We can define the schema of the documents, and Mongoose
    will validate the data before saving it to the database'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式验证**：我们可以定义文档的模式，Mongoose 会在将其保存到数据库之前验证数据'
- en: '**Model**: We can define a model for each collection, and we can use it to
    interact with the database'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：我们可以为每个集合定义一个模型，并使用它来与数据库交互'
- en: '**Middleware**: We can define middleware functions that will be executed before
    or after certain events – for example, we can define a middleware function that
    will be executed before saving a document to the database'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件**：我们可以定义在特定事件之前或之后执行的中介函数 – 例如，我们可以定义一个在将文档保存到数据库之前执行的中介函数'
- en: '**Plugins**: We can use plugins to extend the functionality of Mongoose'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**：我们可以使用插件来扩展 Mongoose 的功能'
- en: Also, if you are new to Node.js or MongoDB, you will find Mongoose easier to
    use than MongoDB directly, and there are plenty of tutorials and resources that
    you can use to get used to it quickly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你是 Node.js 或 MongoDB 的初学者，你会发现 Mongoose 比直接使用 MongoDB 更容易使用，而且有很多教程和资源可以帮助你快速熟悉它。
- en: Info
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Mongo has a huge ecosystem, and it might be a bit overwhelming at the beginning,
    but you can find a curated list of awesome MongoDB resources at [https://github.com/ramnes/awesome-mongodb](https://github.com/ramnes/awesome-mongodb).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo 拥有一个庞大的生态系统，一开始可能会有些令人感到不知所措，但你可以在 [https://github.com/ramnes/awesome-mongodb](https://github.com/ramnes/awesome-mongodb)
    找到精心挑选的 MongoDB 资源列表。
- en: Now that we have MongoDB running and are familiar with the environment variables,
    we can start using Mongoose in our project. In the next section, we will explain
    how to migrate from local file storage to MongoDB.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了 MongoDB 并熟悉了环境变量，我们可以在项目中开始使用 Mongoose。在下一节中，我们将解释如何从本地文件存储迁移到 MongoDB。
- en: Migrating a web application to MongoDB
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Web 应用程序迁移到 MongoDB
- en: We already added MongoDB to our project using Docker Compose and npm commands,
    but we have not started using it yet. In this section, we will migrate a web application
    to MongoDB.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 Docker Compose 和 npm 命令将 MongoDB 添加到我们的项目中，但我们还没有开始使用它。在本节中，我们将迁移一个 Web
    应用程序到 MongoDB。
- en: Installing dependencies
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: 'We will install the following dependencies:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装以下依赖项：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Managing the secrets
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理秘密
- en: 'We will create a `.env` file with the following content:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含以下内容的 `.env` 文件：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we will load the environment variables from the `.env` file with the
    following code into `index.js`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下代码将环境变量从 `.env` 文件加载到 `index.js` 中：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have included the `mongoose` package and have connected to MongoDB using
    the `MONGODB_URI` environment variable. We have also included the `PORT` environment
    variable to run the application in a different port.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了 `mongoose` 包，并使用 `MONGODB_URI` 环境变量连接到 MongoDB。我们还包含了 `PORT` 环境变量，以便在不同的端口上运行应用程序。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, the database must be running before we open the HTTP server
    connection. This is because we need to connect to the database to retrieve the
    information for our response to the HTTP requests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在打开 HTTP 服务器连接之前，数据库必须正在运行。这是因为我们需要连接到数据库以检索对 HTTP 请求的响应所需的信息。
- en: 'Now, we need to update the npm scripts to use `dotenv`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 npm 脚本来使用 `dotenv`：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can run the application with the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令运行应用程序：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We should see the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下输出：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the database is not running, we will see a similar error:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库没有运行，我们将看到类似的错误：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Basically, it tells us that it cannot connect to the database; you can generate
    the same errors just by running the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，它告诉我们无法连接到数据库；您可以通过运行以下命令生成相同的错误：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the next section we will start to work on the data layer migration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始对数据层进行迁移。
- en: Migrating the data layer
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移数据层
- en: We want to refactor the `store.js` file to use MongoDB instead of a JSON file.
    Just to keep things simple, we will add the schema and model to the same file,
    but this can be changed later when we introduce authentication in the next chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望重构 `store.js` 文件以使用 MongoDB 而不是 JSON 文件。为了保持简单，我们将把模式和模型添加到同一个文件中，但当我们介绍认证时，这可以稍后进行更改。
- en: 'It is considered good practice to encapsulate the database-related code in
    specific files, with the idea of providing an interface that can later be used
    by other parts of our code to make changes in the data layer, without the need
    to understand how the data layer is implemented under the hood. This kind of abstraction
    is a very popular solution and will bring you a lot of support if you decide to
    migrate or combine other storage systems in the future. So, we will create a new
    file called `database.js` and explore together in the following paragraphs how
    it is structured and what is achieved in each statement. The file content is the
    following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是一种良好的实践，将数据库相关的代码封装在特定的文件中，其理念是提供一个接口，该接口可以在将来被代码的其他部分用来对数据层进行更改，而无需了解数据层在底层是如何实现的。这种抽象是一种非常流行的解决方案，如果你决定在未来迁移或结合其他存储系统，这将为你提供很多支持。因此，我们将创建一个名为
    `database.js` 的新文件，并在接下来的段落中一起探讨其结构和每个语句所实现的内容。文件内容如下：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Creating** **the schema**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建** **模式**'
- en: 'The first step is to create the schema, which is the definition of the structure
    of the documents that we are going to store in the database. In our case, we only
    have one field called `message`, which is a string:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建模式，这是我们要存储在数据库中的文档结构的定义。在我们的例子中，我们只有一个名为 `message` 的字段，它是一个字符串：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Creating** **the model**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建** **模型**'
- en: 'The second step is to create the model, which is a class that we use to interact
    with the database. In our case, we will use the `Whisper` model to interact with
    the `whispers` collection:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是创建模型，这是一个我们用来与数据库交互的类。在我们的例子中，我们将使用 `Whisper` 模型与 `whispers` 集合交互：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Transformers**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换器**'
- en: 'One of the things that we have to do is to remove the `_id` and `__v` fields
    from the response. We can change this behavior globally so that we don’t have
    to do it for every method, using the `toJSON` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的事情之一是从响应中删除 `_id` 和 `__v` 字段。我们可以通过使用 `toJSON` 方法全局更改此行为，这样我们就不必为每个方法都做这件事：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This means we start with the following data structure:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们开始于以下数据结构：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we move on to the following data structure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续到以下数据结构：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Refactored methods**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构方法**'
- en: 'The key in this migration is to keep the same interface so that we don’t have
    to change the behavior of the functions that we export. We will use the same data
    I/O, but we will use Mongoose to interact with MongoDB:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迁移中的关键是要保持相同的接口，这样我们就不必更改我们导出的函数的行为。我们将使用相同的数据 I/O，但我们将使用 Mongoose 与 MongoDB
    进行交互：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, we keep the same input and output in every method (`getAll`,
    `getById`, `create`, `updateById`, `deleteById`), so we don’t have to change the
    behavior of the functions that we export.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在每个方法（`getAll`、`getById`、`create`、`updateById`、`deleteById`）中保持相同的输入和输出，所以我们不必更改我们导出的函数的行为。
- en: This is the effect that we discussed in the previous chapter; we can change
    the implementation of the methods, but we don’t have to change the interface.
    This is the power of abstraction.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在上一章中讨论的效果；我们可以更改方法的实现，但不必更改接口。这就是抽象的力量。
- en: So, even if you want to change the database in the future, you don’t have to
    change the interface of the methods; you just have to change the implementation
    and the code still works. This is because the business logic is not coupled to
    the database interface.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使您将来想更改数据库，您也不必更改方法的界面；您只需更改实现，代码仍然可以工作。这是因为业务逻辑没有与数据库接口耦合。
- en: '**Removing the old** **database file**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除旧的** **数据库文件**'
- en: Now, we can remove the `db.json` file because we are not using it anymore.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以删除 `db.json` 文件，因为我们不再使用它了。
- en: '**Improve** **the routes**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**改进** **路由**'
- en: In the previous chapter, we used numerical IDs, just to keep the code more simple,
    so now, we need to change the routes to use the MongoDB IDs, which are alphanumerical
    strings. We only need to remove the references to `parseInt` in the `server.js`
    file. The change is from `parseInt(req.params.id)` to `req.params.id`. You can
    even use *Find and Replace* to change all the references to `parseInt` in the
    file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了数值 ID，只是为了使代码更简单，所以现在我们需要更改路由以使用 MongoDB ID，它们是字母数字字符串。我们只需要从 `server.js`
    文件中移除对 `parseInt` 的引用。更改是从 `parseInt(req.params.id)` 到 `req.params.id`。您甚至可以使用
    *查找和替换* 来更改文件中所有对 `parseInt` 的引用。
- en: '**Running** **the application**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行** **应用程序**'
- en: 'At this point, you can just enjoy the migration by running the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您只需运行以下命令来享受迁移：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And if you go to `http://localhost:3000`, you can see the application working
    with MongoDB without any change in the interface.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问 `http://localhost:3000`，您将看到应用程序与 MongoDB 一起工作，而界面没有任何变化。
- en: Now, we are certain that the application is working as expected, but we shouldn’t
    forget to properly test these changes. So, in the next section, we will refactor
    the tests to use MongoDB, and we will be able to move to the next chapter once
    all the tests are passing (green) as the refactor will be completed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们确信应用程序按预期工作，但我们不应该忘记正确测试这些更改。因此，在下一节中，我们将重构测试以使用 MongoDB，并且一旦所有测试都通过（绿色），重构将完成，我们就可以进入下一章。
- en: Testing our MongoDB integration layer
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的 MongoDB 集成层
- en: Yes, we have made the migration and everything seems to be running fine, but
    we need to ensure that the tests work as expected. Currently, the tests use the
    filesystem to store data, so we need to change the tests to make them use MongoDB.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们已经完成了迁移，一切似乎都在正常运行，但我们需要确保测试按预期工作。目前，测试使用文件系统来存储数据，因此我们需要更改测试以使它们使用 MongoDB。
- en: Update the utilities
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新工具
- en: 'We will edit the `test/utils.js` file to use MongoDB instead of the filesystem.
    As we are now using MongoDB, we need to load the fixtures in the database to know
    the IDs. So now, the fixtures will keep the same structure, but they will be stored
    and collected in the database using `populateDb` and the new `getFixtures` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编辑 `test/utils.js` 文件，使用 MongoDB 而不是文件系统。由于我们现在使用 MongoDB，我们需要在数据库中加载 fixtures
    以了解 ID。因此，现在 fixtures 将保持相同的结构，但它们将通过 `populateDb` 和新的 `getFixtures` 函数存储和收集在数据库中：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we can delete the `test/fixtures.js` file because we are not using it anymore.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以删除 `test/fixtures.js` 文件，因为我们不再使用它了。
- en: Refactoring the test suite
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构测试套件
- en: So far, we have more tests than the ones that we really need. We can remove
    specific tests for the stores, as they are already covered by the integration
    tests, and we can remove the `test/store.test.js` file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所以到目前为止，我们的测试比实际需要的更多。我们可以删除特定于 stores 的测试，因为它们已经被集成测试覆盖，并且我们可以删除 `test/store.test.js`
    文件。
- en: 'As part of the migration, we need to make some changes in how the tests are
    prepared to be executed. As a database is an external service, we need to control
    certain aspects before we execute the test. For example, we need a proper database
    connection working before we execute any test, as this can be a failure cause
    for the tests but is not related to the code that we are testing. Also, we need
    to be sure that the database has specific data stored in it so that our tests
    can be executed independently multiple times, without polluting the execution
    context between executions with the modifications that we make in the database.
    This can be achieved by adding certain steps before any specific test is executed,
    with methods such as `beforeAll`, `beforeEach`, `afterAll`, and `afterEach`, which
    are part of the Jest methods available to us. Now, let’s update the tests to use
    the new functions. We will update the `test/server.test.js` file to use the new
    functions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为迁移的一部分，我们需要在测试准备执行的方式上做一些更改。由于数据库是一个外部服务，在执行测试之前，我们需要控制某些方面。例如，在执行任何测试之前，我们需要一个有效的数据库连接，因为这可能是测试失败的原因，但它与我们正在测试的代码无关。此外，我们需要确保数据库中存储了特定的数据，这样我们的测试就可以独立多次执行，而不会因为我们在数据库中做出的更改而污染执行上下文。这可以通过在执行任何特定测试之前添加某些步骤来实现，例如使用`beforeAll`、`beforeEach`、`afterAll`和`afterEach`方法，这些方法是我们可用的Jest方法的一部分。现在，让我们更新测试以使用新函数。我们将更新`test/server.test.js`文件以使用新函数：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next section, we will finish updating the test suite cases, as MongoDB
    introduced small differences that we need to take into account when querying data
    in the test context.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将完成测试套件案例的更新，因为MongoDB在测试上下文中查询数据时引入了一些差异，我们需要注意这些差异。
- en: Some tests must change
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些测试必须更改
- en: Just to keep it simple, for the scope of the book, some tests have to change.
    All the tests that are use store will be refactored as follows.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，对于本书的范围，一些测试必须更改。所有使用store的测试都将按以下方式重构。
- en: 'When creating or updating whispers, we will check in the database that the
    whispers are stored correctly. In order to properly compare the data, we will
    use the `normalize` function. That way, we can compare the data without the `_id`
    and `__v` fields and in a normalized way, as we do when converting data to JSON
    while sending the HTTP response:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建或更新whispers时，我们将检查数据库以确认whispers是否正确存储。为了正确比较数据，我们将使用`normalize`函数。这样，我们就可以在不比较`_id`和`__v`字段的情况下，以规范化的方式比较数据，就像我们在发送HTTP响应时将数据转换为JSON时做的那样：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When deleting a whisper, we need to check that the whisper is not in the database
    anymore. Previously, we checked that the database returned `undefined` when not
    found; using MongoDB, we will get `null` instead, so we need to change the test
    as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除whisper时，我们需要检查whisper是否不再在数据库中。之前，我们检查数据库在未找到时返回`undefined`；使用MongoDB，我们将得到`null`，因此我们需要按以下方式更改测试：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we finished to refactor the tests, it is a great moment to review the testing
    coverage. In this section we will review this in detail.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了测试的重构，现在是审查测试覆盖率的好时机。在本节中，我们将详细审查这一点。
- en: Checking the coverage
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查覆盖率
- en: 'Now, we can run the tests and check the coverage:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行测试并检查覆盖率：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output should be similar:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Basically, we have the same coverage as before, but we have removed some tests,
    and the `store.js` file is covered up to 100%.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们的覆盖率与之前相同，但我们删除了一些测试，`store.js`文件覆盖率达到了100%。
- en: 'As we can see, there is a line that is not covered (*11–12*), in `server.js`.
    In the previous chapter, we added a new route to render the template in `GET /about`,
    but we forgot to add proper tests. So, let’s add the following test:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在`server.js`中有一行未被覆盖（*11–12*）。在前一章中，我们添加了一个新的路由来渲染`GET /about`中的模板，但我们忘记添加适当的测试。所以，让我们添加以下测试：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you run the tests again, you will see that the line is covered now and the
    coverage has increased to 100%. We can also improve the scoring by removing from
    the coverage report the `tests` folder, which we can do by adding the following
    line to the `jest.config.js` file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行测试，你会看到这一行现在已被覆盖，覆盖率已增加到100%。我们还可以通过从覆盖率报告中移除`tests`文件夹来提高评分，我们可以通过在`jest.config.js`文件中添加以下行来实现：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It is very important to keep a clear scope on what files you need to track or
    not for your coverage report; otherwise, the code coverage will become just a
    metric that won’t guide you to focus on the most critical application parts. It
    is quite common to read articles about the frustration associated with a 100%
    coverage target, when, in most cases, we don’t need to aim for that big number,
    and we should be clear on what parts of the code don’t need to be tested.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的覆盖率报告中明确跟踪或不跟踪哪些文件非常重要；否则，代码覆盖率将只是一个指标，它不会引导你专注于最关键的应用程序部分。阅读关于100%覆盖率目标相关挫折的文章相当普遍，但在大多数情况下，我们不需要追求这个大数字，我们应该清楚哪些代码部分不需要进行测试。
- en: 'No matter whether you work alone or in a team, having precise metrics will
    increase the developer experience for all the humans involved in a project. As
    you can see, the coverage is now 100%, as we ignored the files that we are not
    planning to test:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是单独工作还是团队合作，精确的指标都会提高所有参与项目的开发者的体验。正如你所看到的，覆盖率现在是100%，因为我们忽略了我们不打算测试的文件：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Information
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: If you are having issues running the project in this chapter while following
    the steps, or you tried an alternative approach, you can use the `step3` folder
    from the source code that you downloaded at the beginning of the chapter to compare
    and fix possible bugs more easily.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在按照步骤运行本章的项目时遇到问题，或者你尝试了替代方法，你可以使用你在本章开头下载的源代码中的`step3`文件夹来比较和更容易地修复可能的错误。
- en: Now, that we have finished with the migration, it is time to do a recap in the
    next section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了迁移，是时候在下一节中进行回顾了。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how MongoDB is different from other databases. We
    learned how to install MongoDB locally using containers, with Docker and Docker
    Compose.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了MongoDB与其他数据库的不同之处。我们学习了如何使用容器、Docker和Docker Compose在本地安装MongoDB。
- en: Additionally, we explored how we can manage sensitive information in our application
    using environment variables and the `dotenv` package. We also learned how to use
    Mongoose to interact with MongoDB.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还探讨了如何使用环境变量和`dotenv`包来管理我们应用程序中的敏感信息。我们还学习了如何使用Mongoose与MongoDB交互。
- en: Finally, we migrated our application to use MongoDB instead of a JSON file.
    This gave us the opportunity to properly learn how to refactor and reorganize
    our previous code. This migration also made it easy to maintain and deploy the
    application, as data is stored and queried as an external source. This will help
    us to scale a lot in the future, as we can connect multiple replicas of our backend
    to the same database instance. We also learned how to test our application using
    MongoDB, and we used this testing approach to ensure that the migration was completed
    successfully.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的应用程序迁移到使用MongoDB而不是JSON文件。这给了我们一个机会，正确地学习如何重构和重新组织我们之前的代码。这次迁移还使得维护和部署应用程序变得容易，因为数据作为外部源存储和查询。这将有助于我们在未来实现大量扩展，因为我们可以将多个后端副本连接到同一个数据库实例。我们还学习了如何使用MongoDB测试我们的应用程序，并使用这种测试方法确保迁移成功完成。
- en: In the next chapter, we will introduce authentication and authorization to our
    application. We will use JWT to authenticate users and use middleware to protect
    the routes that require authentication. Also, we will refactor code to use a database
    to store users and use `bcrypt` library to hash the passwords. Finally, multiple
    users will be able to use our application, which will include private whispers.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向我们的应用程序引入身份验证和授权。我们将使用JWT进行用户身份验证，并使用中间件保护需要身份验证的路由。此外，我们将重构代码以使用数据库存储用户，并使用`bcrypt`库对密码进行散列。最后，多个用户将能够使用我们的应用程序，其中包括私密消息。
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Fireship | MongoDB in 100 Seconds: [https://www.youtube.com/watch?v=-bt_y4Loofg](https://www.youtube.com/watch?v=-bt_y4Loofg)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Fireship | 100秒内了解MongoDB: [https://www.youtube.com/watch?v=-bt_y4Loofg](https://www.youtube.com/watch?v=-bt_y4Loofg)'
- en: 'I Would Never Use an ORM, by Matteo Collina: [https://www.youtube.com/watch?v=qfRQ5zhYuJE](https://www.youtube.com/watch?v=qfRQ5zhYuJE)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Matteo Collina的《我永远不会使用ORM》: [https://www.youtube.com/watch?v=qfRQ5zhYuJE](https://www.youtube.com/watch?v=qfRQ5zhYuJE)'
- en: 'MongoDB in 5 Minutes with Eliot Horowitz: [https://www.youtube.com/watch?v=EE8ZTQxa0AM](https://www.youtube.com/watch?v=EE8ZTQxa0AM)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Eliot Horowitz的5分钟MongoDB教程: [https://www.youtube.com/watch?v=EE8ZTQxa0AM](https://www.youtube.com/watch?v=EE8ZTQxa0AM)'
- en: 'MongoDB Explained in 10 Minutes | SQL vs NoSQL | Jumpstart: [https://www.youtube.com/watch?v=RGfFpQF0NpE](https://www.youtube.com/watch?v=RGfFpQF0NpE)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10分钟内解释MongoDB | SQL vs NoSQL | 快速入门：[https://www.youtube.com/watch?v=RGfFpQF0NpE](https://www.youtube.com/watch?v=RGfFpQF0NpE)
