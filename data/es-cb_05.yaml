- en: Web Workers, Shared Memory, and Atomics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Workers、共享内存和 Atomics
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Performing work on separate threads with Web Workers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Web Workers 在单独的线程上执行工作
- en: Sending messages to and from Web Workers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 Web Workers 发送和接收消息
- en: Sending data to Web Workers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 Web Workers 发送数据
- en: Stopping workers with terminate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 terminate 停止工作线程
- en: Creating SharedArrayBuffer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 SharedArrayBuffer
- en: Sending SharedArrayBuffer to a Web Worker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 SharedArrayBuffer 发送到 Web Worker
- en: Reading SharedArray from multiple Web Workers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个 Web Workers 读取 SharedArray
- en: Using Atomics to coordinate use of shared memory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Atomics 协调共享内存的使用
- en: Using promises to provide a simple interface for a worker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺为工作提供一个简单的接口
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The capabilities and expectations of JavaScript and web applications are expanding
    every day. One of the most exciting areas this expansion has led to is parallel
    programming, which is related to, but not synonymous with, asynchronous and concurrent
    programming. Parallel programming allows for multiple operations to take place
    simultaneously rather than interleaving them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每天JavaScript和Web应用程序的能力和期望都在不断扩大。这种扩展最令人兴奋的领域之一是并行编程，它与异步和并发编程相关，但并不相同。并行编程允许同时进行多个操作，而不是交错进行。
- en: This distinction may seem small, but it is quite significant. In this chapter,
    we will see how to use the facilities available on the web platform to create
    programs that execute in parallel. Web Workers will be used to create parallel
    jobs, `SharedMemoryBuffer` to share information, and the Atomic API to coordinate
    between them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别可能看起来很小，但意义重大。在本章中，我们将探讨如何使用网络平台上的工具来创建并行执行程序。我们将使用 Web Workers 来创建并行任务，`SharedMemoryBuffer`
    来共享信息，以及 Atomic API 来协调它们之间的工作。
- en: Enabling SharedArrayBuffers in Firefox
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Firefox 中启用 SharedArrayBuffers
- en: In early 2018, the Spectre and Meltdown vulnerabilities were discovered. In
    response, browser manufacturers disabled `SharedArrayBuffer` by default. Some
    of the recipes in this chapter require this feature. This recipe demonstrates
    how to enable them in Firefox.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2018 年初，发现了 Spectre 和 Meltdown 漏洞。作为回应，浏览器制造商默认禁用了 `SharedArrayBuffer`。本章中的一些食谱需要此功能。本食谱演示了如何在
    Firefox 中启用它们。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you have an up to date version of Firefox installed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设您已安装了最新版本的 Firefox。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Firefox.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Firefox。
- en: Navigate to `about:config`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `about:config`。
- en: Click I accept the risk!
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“我接受风险！”
- en: Search for shared.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索“shared”。
- en: Double-click javascript.options.shared_memory.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `javascript.options.shared_memory`。
- en: 'This option should now have the value true:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此选项现在应具有值 true：
- en: '![](img/b8f71782-f2eb-4927-a140-519e6c163ff4.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8f71782-f2eb-4927-a140-519e6c163ff4.png)'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'By default, shared memory is disabled in Firefox, but the options let developers
    activate these (potentially insecure) features without exposing normal users to
    them. You can read more about Meltdown and Spectre at:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Firefox 中禁用了共享内存，但选项允许开发者在不向普通用户暴露的情况下激活这些（可能不安全）的功能。您可以在以下链接中了解更多关于 Meltdown
    和 Spectre 的信息：
- en: '[https://meltdownattack.com/](https://meltdownattack.com/).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://meltdownattack.com/](https://meltdownattack.com/).'
- en: You should not leave this feature enabled after you finish experimenting with
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成实验后，不应保留此功能启用。
- en: Enabling SharedArrayBuffers in Chrome
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Chrome 中启用 SharedArrayBuffers
- en: In early 2018, the Spectre and Meltdown vulnerabilities were discovered. In
    response, browser manufacturers disabled `SharedArrayBuffer` by default. Some
    of the recipes in this chapter require this feature. This recipe demonstrates
    how to enable them in Chrome.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 2018 年初，发现了 Spectre 和 Meltdown 漏洞。作为回应，浏览器制造商默认禁用了 `SharedArrayBuffer`。本章中的一些食谱需要此功能。本食谱演示了如何在
    Chrome 中启用它们。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you have an up to date version of Chrome installed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设您已安装了最新版本的 Chrome。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Chrome.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Chrome。
- en: Navigate to `chrome://flags/`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `chrome://flags/`。
- en: Click I accept the risk!
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“我接受风险！”
- en: Search for shared.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索“shared”。
- en: Select Enabled for the option Experimental enabled SharedArrayBuffer support
    in JavaScript.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选项“实验性启用 JavaScript 中的 SharedArrayBuffer 支持”设置为“启用”。
- en: 'Click RELAUNCH NOW:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“立即重新启动”：
- en: '![](img/c9d967a4-cd36-4049-ac03-e780b791fca2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9d967a4-cd36-4049-ac03-e780b791fca2.png)'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'By default, shared memory is disabled in Firefox, but the options let developers
    activate these (potentially insecure) features without exposing normal users to
    them. You can read more about Meltdown and Spectre at:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Firefox 中禁用了共享内存，但选项允许开发者在不向普通用户暴露的情况下激活这些（可能不安全）功能。你可以在以下位置了解更多关于 Meltdown
    和 Spectre 的信息：
- en: '[https://meltdownattack.com/](https://meltdownattack.com/).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://meltdownattack.com/](https://meltdownattack.com/).'
- en: You should not leave this feature enabled after you finish experimenting with
    it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成实验后，不应启用此功能。
- en: Performing work on separate threads with Web Workers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Web Workers 在单独的线程上执行工作
- en: Web Workers allow browser operations to take place outside the main thread.
    Once created, communication between threads is made by passing messages. In this
    recipe, we'll see how to create a very simple worker, and send it a message from
    the main thread.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers 允许浏览器操作在主线程之外进行。一旦创建，线程间的通信通过传递消息来实现。在这个示例中，我们将看到如何创建一个非常简单的工作者，并从主线程向其发送消息。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `05-01-performing-work-with-web-workers`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`05-01-performing-work-with-web-workers`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个名为`index.html`的文件，该文件加载并运行来自`main.js`的`main`函数。
- en: 'Create a `main.js` file with a `main` function that creates a worker from a
    file named `worker.js`. Then post a message of type `hello-message` to the `worker`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`main`函数的`main.js`文件，该函数从一个名为`worker.js`的文件创建工作者。然后向`worker`发送一个类型为`hello-message`的消息：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file named `worker.js` that logs a `Hello` message:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`worker.js`的文件，该文件记录一个`Hello`消息：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `worker.js` file, set the `onmessage` callback on the global scope.
    This function should log out the type of the message received:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`worker.js`文件中，在全局作用域上设置`onmessage`回调函数。这个函数应该记录接收到的消息的类型：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output displayed:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出显示：
- en: '![](img/3eef9de1-eb38-4516-8757-36b0d926476f.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3eef9de1-eb38-4516-8757-36b0d926476f.png)'
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Constructing the worker with the name of the worker file creates a worker on
    a new thread. By setting the `onmessage` event listener on the global context
    of the worker, we are able to receive messages from the main thread.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为工作文件名的工作者名称创建工作者将在新线程上创建一个工作者。通过在工作者全局上下文中设置`onmessage`事件监听器，我们能够从主线程接收消息。
- en: After creating the worker, the `main` function can use that reference to post
    messages to the new worker. The argument of the `postMessage` method is passed
    to the worker as the `data` attribute of the `message` property that is received.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建工作者后，`main`函数可以使用该引用向新工作者发送消息。`postMessage`方法的参数作为接收到的`message`属性的`data`属性传递给工作者。
- en: Sending messages to and from Web Workers
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 Web Workers 发送和接收消息
- en: In the previous recipe, we saw how to create and send a message to a worker
    on a background thread. That's pretty great! Before Web Workers were introduced,
    it wasn't possible for JavaScript to work with anything but the main thread. However,
    it isn't very useful if we can't get any information back.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了如何创建并向后台线程上的工作者发送消息。这非常棒！在 Web Workers 之前引入之前，JavaScript 无法与主线程以外的任何东西一起工作。然而，如果我们无法获取任何信息，这并不是很有用。
- en: In this recipe, we'll see how to wait for, and send responses back from, a Web
    Worker.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何等待 Web Worker 的响应，并从 Web Worker 发送响应。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `05-02-send-messages-to-and-from-web-workers`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`05-02-send-messages-to-and-from-web-workers`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个名为`index.html`的文件，该文件加载并运行来自`main.js`的`main`函数。
- en: 'Create a `main.js` with a function named `onMessage` that takes an argument
    `message` and logs out the `type` and `index` properties:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.js` 的文件，其中包含一个名为 `onMessage` 的函数，该函数接受一个名为 `message` 的参数并输出 `type`
    和 `index` 属性：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Set a  `WORKER_COUNT` constant:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `WORKER_COUNT` 常量：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a `main` function that creates `WORKER_COUNT` workers, sets the `onMessage`
    property, and posts the `index` to the worker:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main` 函数，该函数创建 `WORKER_COUNT` 个工作器，设置 `onMessage` 属性，并将 `index` 发送到工作器：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a `worker.js` file that assigns the current context as a `global` constant:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `worker.js` 文件，将当前上下文分配为 `global` 常量：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set the `onmessage` event listener on `global` to the global context. The function
    should take a message argument and log out the `index` and `type` properties.
    Then it should call `global.postMessage` with another message, passing back its
    `index`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在全局上下文中将 `onmessage` 事件监听器设置为 `global`。该函数应接受一个消息参数并输出 `index` 和 `type` 属性。然后它应该调用
    `global.postMessage` 并传递其 `index`：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`。'
- en: 'You should see the following output displayed:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出显示：
- en: '![](img/c1fadc84-d802-4c07-99bc-d3a61c8aa365.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1fadc84-d802-4c07-99bc-d3a61c8aa365.png)'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We've seen how the `onmessage` listener can be used to listen for messages posted
    from the main thread. Now we can see that the same evenlistener, when binding
    on the worker reference in the `main` function, can listen to messages from the
    worker. We also can see that this listener is isolated from the individual worker
    being referenced. Each worker has a unique event listener; this is useful for
    organizing communication between workers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 `onmessage` 监听器来监听从主线程发布的消息。现在我们可以看到，当在 `main` 函数中的工作器引用上绑定时，相同的监听器可以监听来自工作器的消息。我们还可以看到，这个监听器与被引用的个别工作器是隔离的。每个工作器都有一个独特的事件监听器；这对于组织工作器之间的通信很有用。
- en: Sending data to a Web Worker
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 Web Worker 发送数据
- en: Now that we've seen how to send messages back and forth, we can start to actually
    put these Web Workers to work. In this recipe, we'll see that you can send data
    to and from a Web Worker.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何发送和接收消息，我们可以开始真正使用这些 Web Workers。在这个配方中，我们将看到你可以向 Web Worker 发送和接收数据。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设你已经有了一个工作区，允许你在浏览器中创建和运行 ES 模块。如果没有，请参阅前两章。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `05-03-send-data-to-and-from-web-workers`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `05-03-send-data-to-and-from-web-workers` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` with a function named `onMessage` that takes an argument
    `message` and logs out the `type` and `index` properties:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.js` 的文件，其中包含一个名为 `onMessage` 的函数，该函数接受一个名为 `message` 的参数并输出 `type`
    和 `index` 属性：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a `main` function that creates a worker, sets the `onMessage` property,
    creates an array of random numbers, and posts two messages to the worker, one
    to sum some of the numbers and another to average them:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main` 函数，该函数创建一个工作器，设置 `onMessage` 属性，创建一个随机数字数组，并向工作器发送两条消息，一条用于求和某些数字，另一条用于计算平均值：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `worker.js` file that assigns the current context as a `global` constant:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `worker.js` 文件，将当前上下文分配为 `global` 常量：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Set the `onmessage` event listener on `global` to the context. The function
    should take a message argument and perform either a sum or average operation on
    the numbers property of `message.data`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `global` 上设置 `onmessage` 事件监听器，该函数应接受一个消息参数并对 `message.data` 的 `numbers` 属性执行求和或平均操作：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：`http://localhost:8000/`。
- en: 'You should see the following output:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/d0174fd0-836d-47be-bc70-c9838d951be4.png)x'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/d0174fd0-836d-47be-bc70-c9838d951be4.png)x'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We've seen a simple string posted to and from workers. Now we can see that more
    complex objects can be sent as well. In fact, a sizable number of types can be
    passed via `postMessage`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在工作器之间发送和接收简单的字符串。现在我们可以看到，更复杂的对象也可以发送。实际上，可以通过 `postMessage` 传递大量类型的对象。
- en: 'To see a full list of valid types, visit the link:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看有效类型的完整列表，请访问以下链接：
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)[.](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)[.](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)'
- en: By using `postMessage`, we have copied the data to the worker. This operation
    is costly, because whenever the message is posted to a new thread, the data must
    be duplicated in order to be available. For small datasets, this isn't a problem,
    but for larger sets it can be slow and memory-intensive. For future recipes in
    this chapter, we'll be using shared memory to avoid this copying.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`postMessage`，我们已经将数据复制到了工作线程。这个操作成本较高，因为每次将消息发布到新线程时，数据都必须被复制才能可用。对于小型数据集，这不是问题，但对于大型数据集，它可能会很慢且占用大量内存。在本书的后续菜谱中，我们将使用共享内存来避免这种复制。
- en: Stopping workers with terminate
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`terminate`停止工作线程
- en: Not all problems are cumulative. Some have a desired goal state; once it is
    found, then the program can exit. We've seen that workers communicate their results
    by posting messages. Now our program is completed, it would be nice to prevent
    future messages from being received, possibly polluting our results.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有问题都是累积的。有些有一个期望的目标状态；一旦找到，程序就可以退出。我们已经看到，工作线程通过发送消息来传达结果。现在我们的程序已经完成，我们希望防止未来的消息被接收，以免污染我们的结果。
- en: In this recipe, we'll see how to use `Worker.terminate` to immediately stop
    a `Worker`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用`Worker.terminate`立即停止一个`Worker`。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `05-04-stop-workers-with-terminate`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`05-04-stop-workers-with-terminate`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`文件，该文件从`main.js`加载并运行一个`main`函数。
- en: 'Create a `main.js` with a function named `onMessage` that takes a `message`
    and `workers` argument**,** logs out the `type` and `timeout` properties of `message.data`,
    and calls `terminate` on all the `workers`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.js`文件，其中包含一个名为`onMessage`的函数，该函数接受`message`和`workers`参数**，**记录`message.data`的`type`和`timeout`属性，并对所有`workers`调用`terminate`：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a `main` function that creates multiple workers, sets the `onMessage`
    property with a function that passes all the `workers` as the second argument,
    then posts a message to each with the `index`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main`函数，该函数创建多个工作线程，将带有函数的`onMessage`属性设置为将所有`workers`作为第二个参数传递，然后向每个工作线程发送带有`index`的消息：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a `worker.js` file that assigns the current context as a `global` constant:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`worker.js`文件，将当前上下文作为`global`常量：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Set a `timeout` constant to some random number between *0* and *10,000*:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个`timeout`常量，其值在*0*到*10,000*之间的随机数：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set the `onmessage` event listener on `global` to the context. The function
    should take a `message` argument and post a response message with the `index`
    and `timeout` of this worker, after the given timeout:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`global`上下文中设置`onmessage`事件监听器。该函数应接受一个`message`参数，并在给定的超时后发送一个包含此工作线程的`index`和`timeout`的响应消息：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output displayed:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出显示：
- en: '![](img/d0a30777-8e34-498f-813f-e64cf0daaf5f.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0a30777-8e34-498f-813f-e64cf0daaf5f.png)'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All 10 workers are instructed to post a message after their given timeout but,
    as you can see, only a single worker actually posts a message back to the main
    thread. This is because, after this first worker posts, we call `terminate` on
    all of the workers. This means that they will stop immediately, and unless another
    worker has already posted, it never will. So, we will almost always see a single
    message posted. It is possible that one or two other workers will post before
    being terminated.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有10个工作线程都被指示在给定的超时后发送消息，但正如你所看到的，只有一个工作线程实际上向主线程发送了消息。这是因为，在这个第一个工作线程发送消息后，我们对所有工作线程调用了`terminate`。这意味着它们将立即停止，除非另一个工作线程已经发送了消息，否则它永远不会发送。所以，我们几乎总是看到只有一个消息被发送。有可能在终止之前，一两个其他工作线程会发送消息。
- en: Creating SharedArrayBuffer
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SharedArrayBuffer
- en: So far, we've see how to send data between the main thread and workers. The
    downside of how we've done this so far is that the data is copied. This means
    that as the amount of data and number of workers increase, so does the amount
    of copying that has to be done. Luckily, there is a way to share data between
    threads with less overhead.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在主线程和工作线程之间发送数据。我们目前所做的方法的缺点是数据被复制。这意味着随着数据量和工作者数量的增加，需要复制的数量也会增加。幸运的是，有一种方法可以在线程之间以更少的开销共享数据。
- en: '`SharedArrayBuffer` can be shared between arrays without copying data. In this
    recipe, we''ll see how to create, as well as read and write, data from a `SharedArrayBuffer`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedArrayBuffer` 可以在数组之间共享，而不需要复制数据。在本例中，我们将看到如何创建、读取和写入 `SharedArrayBuffer`
    中的数据。'
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本例假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open your command-line application, and navigate to your workspace.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `05-05-creating-shared-array-buffer`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `05-05-creating-shared-array-buffer` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file with a main method that defines constants for `NUM_COUNT`,
    `BYTES_FOR_32_BIT`, `ARRAY_SIZE`, and `MAX_NUMBER`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含主方法的 `main.js` 文件，该方法定义了 `NUM_COUNT`、`BYTES_FOR_32_BIT`、`ARRAY_SIZE` 和
    `MAX_NUMBER` 的常量：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, create a `SharedArrayBuffer` that is of size `ARRAY_SIZE`, and create
    an `Int32Array` casting of it:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个大小为 `ARRAY_SIZE` 的 `SharedArrayBuffer`，并创建一个将其转换为 `Int32Array` 的实例：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Fill the `intBuffer` with random numbers between *0* and `MAX_NUMBER`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用介于 *0* 和 `MAX_NUMBER` 之间的随机数填充 `intBuffer`：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Calculate and print the sum of the values in the array:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算并打印数组中值的总和：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/412ee83c-da6d-4432-89ba-faa8b60dd894.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/412ee83c-da6d-4432-89ba-faa8b60dd894.png)'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It feels a little unnatural to be thinking about byte size when working in JavaScript,
    but it's necessary for working with `SharedArrayBuffer`. The preceding example
    creates an array of 2,048 32-bit integers. So in order to create a `SharedArray`
    buffer we have to calculate how much memory 2,048 32-bit integers will take up.
    This is done with simple multiplication. Once we have `ARRAY_SIZE` we can allocate
    the memory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中工作时考虑字节大小似乎有些不自然，但与 `SharedArrayBuffer` 一起工作却是必要的。前面的示例创建了一个包含
    2,048 个 32 位整数的数组。因此，为了创建 `SharedArray` 缓冲区，我们必须计算 2,048 个 32 位整数将占用多少内存。这是通过简单的乘法完成的。一旦我们有了
    `ARRAY_SIZE`，我们就可以分配内存。
- en: Now that we have the array, we need to cast it as some type in order to read
    and write from it. We're using `Int32Array`, so when we perform array access operations
    the values will be cast as 32-bit integers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数组，我们需要将其转换为某种类型，以便从中读取和写入。我们使用 `Int32Array`，因此当我们执行数组访问操作时，值将被转换为 32
    位整数。
- en: When filling the array, we simply loop over each number and multiply a random
    number by the `MAX_NUMBER`; the resulting value is cast as a 32-bit integer (the
    decimal value is lost). Next, summing is done with the array's `reduce` function,
    and we log out the results.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当填充数组时，我们只需遍历每个数字，将随机数乘以 `MAX_NUMBER`；得到的结果被转换为 32 位整数（十进制值丢失）。接下来，使用数组的 `reduce`
    函数进行求和，并将结果输出。
- en: A nice feature of the `Int32Array` is that it has all of the Array methods as
    well. So we can perform map, join, index, includes, and so on with the new data
    type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int32Array` 的一个优点是它具有所有数组方法。因此，我们可以使用新数据类型执行 map、join、index、includes 等操作。'
- en: Sending SharedArrayBuffer to a Web Worker
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 SharedArrayBuffer 发送到 Web Worker
- en: Now that we know how to create and use a `SharedArrayBuffer`, we can use one
    to share data between the main thread and workers. As mentioned previously, this
    has an advantage over posting JavaScript objects, in that the data doesn't need
    to be copied; it is shared.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建和使用 `SharedArrayBuffer`，我们可以使用它来在主线程和工作线程之间共享数据。如前所述，这比发布 JavaScript
    对象有优势，因为数据不需要复制；它是共享的。
- en: In this recipe, we'll see how to share a `SharedArrayBuffer` with a worker,
    and post the result back to the main thread.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何与工作线程共享`SharedArrayBuffer`，并将结果回传到主线程。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
    It also assumes that you have enabled shared memory in your browser. If you haven't
    please see the recipes at the beginning of this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱假设您已经有一个工作区，允许您在浏览器中创建和运行ES模块。如果您没有，请参阅前两章。它还假设您已在浏览器中启用了共享内存。如果您还没有，请参阅本章开头的菜谱。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application, and navigate to your workspace.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令行应用程序，并导航到您的工作区。
- en: Create a new folder named `05-06-sending-shared-array-to-worker`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`05-06-sending-shared-array-to-worker`的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个`index.html`，它加载并运行来自`main.js`的`main`函数。
- en: 'Create a `main.js` file with an `onMessage` function that logs out the `result`
    and `type` members of the received message data:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`onMessage`函数的`main.js`文件，该函数将接收到的消息数据的`result`和`type`成员打印出来：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a `main.js` file with a main method that defines constants for `NUM_COUNT`,
    `BYTES_FOR_32_BIT`, `ARRAY_SIZE`, and `MAX_NUMBER`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含主方法的`main.js`文件，定义`NUM_COUNT`、`BYTES_FOR_32_BIT`、`ARRAY_SIZE`和`MAX_NUMBER`常量：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, create a `SharedArrayBuffer` that is of size `ARRAY_SIZE`, and create
    a worker with the source in `worker.js`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个大小为`ARRAY_SIZE`的`SharedArrayBuffer`，并使用`worker.js`中的源创建一个工作线程：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Set the worker on the message event listener to the `onMessage` function, and
    post a message to the worker with the array buffer:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作线程的消息事件监听器设置为`onMessage`函数，并向工作线程发送包含数组缓冲区的消息：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Fill the array buffer with 32-bit integers with random values between *0* and
    `MAX_NUMBER`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用介于*0*和`MAX_NUMBER`之间的随机值填充数组缓冲区以32位整数：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Post messages to the worker, requesting calculations of `sum` and `average`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向工作线程发送消息，请求计算`sum`和`average`：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a `worker.js` file, assign the current context to a variable `global`,
    declare a variable named `sharedIntArray`, and assign a function to the `onmessage`
    event:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`worker.js`文件，将当前上下文赋值给变量`global`，声明一个名为`sharedIntArray`的变量，并将一个函数赋值给`onmessage`事件：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `onmessage` listener get the data component of the `message` argument,
    and `switch` on the `type` attribute:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onmessage`监听器中获取`message`参数的数据组件，并`switch`在`type`属性上：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a case for `''load-array''`, where we assign the array property of data
    to `sharedIntArray` after casting it as an `Int32Array`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`'load-array'`的情况，我们将数据数组的属性转换为`Int32Array`后赋值给`sharedIntArray`：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add a case for `''calculate-sum''` that sums all the numbers in the array and
    posts the result back to the main thread:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`'calculate-sum'`的情况，计算数组中所有数字的总和并将结果回传到主线程：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a case for `''calculate-average''` that averages all the numbers in the
    array and posts the result back to the main thread:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`'calculate-average'`的情况，计算数组中所有数字的平均值并将结果回传到主线程：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的Python网络服务器，并在浏览器中打开以下链接：`http://localhost:8000/`。
- en: 'You should see the following output:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![](img/9e09739c-db02-4442-af58-8437c5b2b86c.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e09739c-db02-4442-af58-8437c5b2b86c.png)'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As mentioned previously, `SharedArrayBuffer` is not copied between threads.
    It is shared. So, when we create the shared array buffer and pass that reference
    to a worker, the values inserted into the array by the main thread are available
    in the worker.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`SharedArrayBuffer`在线程之间不是复制的，它是共享的。因此，当我们创建共享数组缓冲区并将该引用传递给工作线程时，主线程插入到数组中的值在工作线程中也是可用的。
- en: After the worker receives messages to perform calculations, the values can be
    accumulated as they were in any other array, and the value sent back is a simple
    message.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作线程接收到执行计算的指令后，值可以像任何其他数组一样累积，回传的值是一个简单的消息。
- en: Reading SharedArray from multiple Web Workers
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从多个Web Workers读取SharedArray
- en: In the previous recipe, we saw how data can be shared between the main thread
    and a single worker. This is helpful for move long-running operations on the main
    thread, which helps keep the UI responsive. However, it isn't taking full advantage
    of parallel processing. With very large datasets, breaking up the computation
    between many workers can be advantageous.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们看到了如何在主线程和一个单独的工作器之间共享数据。这对于在主线程上执行长时间运行的操作很有帮助，这有助于保持用户界面的响应性。然而，它并没有充分利用并行处理。对于非常大的数据集，在许多工作器之间分割计算可能是优势。
- en: In this recipe, we'll see how to use multiple workers to produce portions of
    a result.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用多个工作器生成结果的部分。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `05-07-reading-shared-buffer-from-multiple-workers`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `05-07-reading-shared-buffer-from-multiple-workers` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html`，它加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file with an `onMessage` function that logs out the following
    members of the message data: `workenIndex`, `type`, `result`, `workerIndex`, `startIndex`,
    `endIndex`, and `windowSize`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件，其中包含一个 `onMessage` 函数，用于记录消息数据中的以下成员：`workenIndex`、`type`、`result`、`workerIndex`、`startIndex`、`endIndex`
    和 `windowSize`：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a `main.js` file with a main method that defines constants for `NUM_COUNT`,
    `BYTES_FOR_32_BIT`, `ARRAY_SIZE`, `WORKER_COUNT`, and `MAX_NUMBER`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.js` 的文件，其中包含一个主方法，用于定义 `NUM_COUNT`、`BYTES_FOR_32_BIT`、`ARRAY_SIZE`、`WORKER_COUNT`
    和 `MAX_NUMBER` 的常量：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, create an array of workers of size `WORKER_COUNT`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个大小为 `WORKER_COUNT` 的工作器数组：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, create a `SharedArrayBuffer` that is of size `ARRAY_SIZE`, and fill it
    with random integers:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个大小为 `ARRAY_SIZE` 的 `SharedArrayBuffer`，并用随机整数填充它：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Post these messages to each of the workers: `''load-array''`, `''load-indices''`,
    `''calculate-sum''`, and `''calculate-average''`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些消息发布到每个工作器：`'load-array'`、`'load-indices'`、`'calculate-sum'` 和 `'calculate-average'`：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a `worker.js` file, assign the current context to a variable `global`,
    and declare variables named: `sharedIntArray`, `sharedInArraySlice`, `workerIndex`,
    `workerCount`, `startIndex`, and `endIndex`. Also, assign a function to the `onmessage`
    event:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `worker.js` 文件，将当前上下文赋值给变量 `global`，并声明名为 `sharedIntArray`、`sharedInArraySlice`、`workerIndex`、`workerCount`、`startIndex`
    和 `endIndex` 的变量。此外，将一个函数赋值给 `onmessage` 事件：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `onmessage` listener, get the data component of the `message` argument
    and switch on the `type` attribute:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onmessage` 监听器中，获取 `message` 参数的数据组件并基于 `type` 属性进行切换：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add a case for `''load-array''` where we assign the array property of data
    to `sharedIntArray` after casting it as an `Int32Array`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个针对 `'load-array'` 的用例，在该用例中，我们将数据数组的属性转换为 `Int32Array` 后赋值给 `sharedIntArray`：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a case for `''load-indices''` that calculates the window of values that
    the current worker should work with, based on the current index and total number
    of workers:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个针对 `'load-indices'` 的用例，根据当前索引和总工人数计算当前工作器应处理的值窗口：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a case for `''calculate-sum''` that sums all the numbers in the array and
    posts the result back to the main thread:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个针对 `'calculate-sum'` 的用例，该用例计算数组中的所有数字并将结果回传到主线程：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add a case for `''calculate-average''` that averages all the numbers in the
    array and posts the result back to the main thread:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个针对 `'calculate-average'` 的用例，该用例计算数组中的所有数字并将结果回传到主线程：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a `sendResult` function that posts a `result`, a result type, and information
    about the current thread to the main thread:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `sendResult` 函数，用于将 `result`、结果类型和有关当前线程的信息发布到主线程：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`。'
- en: 'You should see the following output:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/d5dc6810-c15a-4488-b3d3-d1421b9f2838.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5dc6810-c15a-4488-b3d3-d1421b9f2838.png)'
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Shared array buffers can be shared across any number of worker threads. In order
    to calculate portions of the result, we need to divide the results equitably between
    the threads. That's what the `'load-indices'` case of the worker `onMessage` listener
    does.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 共享数组缓冲区可以在任何数量的工作线程之间共享。为了计算结果的部分，我们需要在线程之间公平地分配结果。这就是工作线程 `onMessage` 监听器的
    `'load-indices'` 情况所做的事情。
- en: 'We can use the size of the array and the total worker count to get the window
    size. We take the floor so that we don''t go beyond the index of the array. This
    is also because you can''t have a partial index: they are integers.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数组的大小和总工作线程数来获取窗口大小。我们取整数部分，这样就不会超过数组的索引。这也是因为不能有部分索引：它们是整数。
- en: Next, we use the current worker index to get the `startIndex` (basically picking
    up where the previous worker left off). To get the end index, we need to know
    if this is the last worker. If not, we use the window size. If it is, we need
    to take all of the remaining values.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用当前工作线程的索引来获取 `startIndex`（基本上是从上一个工作线程离开的地方继续）。为了获取结束索引，我们需要知道这是否是最后一个工作线程。如果不是，我们使用窗口大小。如果是，我们需要取所有剩余的值。
- en: Once we have our array slice, each worker calculates the sums and averages of
    those portions as they would with the entire array. Then the results and the worker
    info are posted to the main thread.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了数组切片，每个工作线程就像处理整个数组一样计算这些部分的和与平均值。然后，将结果和工作线程信息发布到主线程。
- en: Using Atomics to coordinate the use of shared memory
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Atomics 协调共享内存的使用
- en: In the previous recipe, we used multiple workers to produce portions of a result.
    We could merge these results in the main thread. While valid, this approach doesn't
    take full advantage of parallel processing. It would be preferable if the workers
    could accumulate the results themselves.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们使用了多个工作线程来生成结果的一部分。我们可以在主线程中合并这些结果。虽然这种方法是有效的，但它并没有充分利用并行处理的优势。如果工作线程能够自己累积结果，那就更好了。
- en: Mutating shared memory in multiple parallel threads exposes the possibility
    of race conditions. This is when several operations need to occur in a specific
    order that is not enforced. Luckily, we can use the Atomics API to coordinate
    these operations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个并行线程中修改共享内存会暴露出竞争条件。这是当几个操作需要按照特定顺序发生，而这种顺序没有被强制执行时。幸运的是，我们可以使用 Atomics API
    来协调这些操作。
- en: In this recipe, we'll see how to use the Atomics API to accumulate results while
    avoiding race conditions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用 Atomics API 来累积结果，同时避免竞争条件。
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `05-08-use-atomics-to-coordinate`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `05-08-use-atomics-to-coordinate` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html`，它加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file. Create three shared array buffers: an input buffer
    and two output buffers (one `safe`, the other `unsafe`). The output buffers should
    be 32 bits in size:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.js` 文件。创建三个共享数组缓冲区：一个输入缓冲区和两个输出缓冲区（一个 `safe`，另一个 `unsafe`）。输出缓冲区的大小应为
    32 位：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare a variable `workersFinishedCount` and set it to `0`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个变量 `workersFinishedCount` 并将其设置为 `0`：
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a function named `onMessage`. This function increments `workersFinished`.
    If all the workers are finished, log the output of the two output arrays and log
    out a sum calculated locally:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `onMessage` 的函数。这个函数增加 `workersFinished`。如果所有工作线程都已完成，则记录两个输出数组的结果，并记录本地计算的求和结果：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a main function that declares a `MAX_NUMBER`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个主函数，声明一个 `MAX_NUMBER`：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, create an array of workers of size `WORKER_COUNT`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个大小为 `WORKER_COUNT` 的工作线程数组。
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, fill the input shared array buffer with random integers:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将输入共享数组缓冲区填充随机整数：
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Post these messages to each of the workers: `''load-shared-input''`, `''load-shared-output''`,
    `''load-indices''`, and `''calculate-sum''`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些消息发送给每个工作线程：`'load-shared-input'`，`'load-shared-output'`，`'load-indices'`
    和 `'calculate-sum'`：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a `worker.js` file, assign the current context to a `global` variable,
    declare variables named `sharedIntArray`, `resultArray`, `unsafeResultArray`,
    and `sharedInArraySlice`, and assign a function to the `onmessage` event:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `worker.js` 文件，将当前上下文分配给一个 `global` 变量，声明名为 `sharedIntArray`、`resultArray`、`unsafeResultArray`
    和 `sharedInArraySlice` 的变量，并将一个函数分配给 `onmessage` 事件：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `onmessage` listener, get the data component of the `message` argument
    and `switch` on the `type` attribute:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onmessage` 监听器中，获取 `message` 参数的数据组件，并使用 `switch` 在 `type` 属性上：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add a case for `''load-shared-input''`, where we assign the `input` property
    of data to `sharedIntArray` after casting it as an `Int32Array`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `'load-shared-input'` 添加一个案例，我们将数据对象的 `input` 属性分配给 `sharedIntArray`，在将其转换为
    `Int32Array` 后：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add a case for `''load-shared-output''`, where we assign the `safe` and `unsafe`
    properties of data to the corresponding result arrays after casting them as a
    `Int32Array`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `'load-shared-output'` 添加一个案例，我们将数据对象的 `safe` 和 `unsafe` 属性分配给相应的结果数组，在将它们转换为
    `Int32Array` 后：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add a case for `''load-indices''` that calculates the window of values that
    the current worker should work with based on the current index and total number
    of workers:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `'load-indices'` 添加一个案例，根据当前索引和工作者总数计算当前工作者应该处理的价值范围：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add a case for `''calculate-sum''` that sums all the numbers in the array,
    updates `unsafeResultArray` directly, uses `Atomics.add` to update `resultArray`,
    and posts the result back to the main thread:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `'calculate-sum'` 添加一个案例，该案例将数组中的所有数字相加，直接更新 `unsafeResultArray`，使用 `Atomics.add`
    更新 `resultArray`，并将结果发送回主线程：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/6403a2c9-a347-4da1-aaf1-975c8c46aa50.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6403a2c9-a347-4da1-aaf1-975c8c46aa50.png)'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we can see from the results, the value of `unsafeResultArray` has been corrupted
    by a race condition. It looks as if some of the values are missing. However, looking
    at the worker it appears as if we are adding the result as a single operation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中我们可以看出，`unsafeResultArray` 的值已经被竞争条件破坏。看起来好像有些值丢失了。然而，从工作者的角度来看，我们似乎将结果作为一个单一操作添加。
- en: This isn't precisely true. The `*+**=*` operator is actually three separate
    operations, a read, an addition, and a write operation. If you imagine that multiple
    workers reach this segment at the same time (we have 256 operating at once), then
    you can imagine how a race condition can occur.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全正确。`*+**=*` 运算符实际上是三个单独的操作，一个读取操作、一个加法操作和一个写入操作。如果你想象多个工作者同时到达这个段（我们一次有
    256 个在工作），那么你可以想象竞争条件是如何发生的。
- en: Atomics prevent these errors from happening. `Atomic.add`, for example, operates
    as if *+*, *=* were a single operation. When a worker uses `Atomics.add` or any
    other method in the API, they can be sure that the values will not be written
    or read by another thread until the operation has been completed. That's why the
    safe sum always matches the sum calculated on the main thread, and the unsafe
    sum may be less.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作防止这些错误发生。例如，`Atomic.add` 操作就像 *+*, *=* 是一个单一操作。当一个工作者使用 `Atomics.add` 或
    API 中的任何其他方法时，他们可以确信，直到操作完成，值不会被另一个线程写入或读取。这就是为什么安全的总和总是与主线程上计算的总和相匹配，而不安全的总和可能会更少。
- en: Because race conditions are non-deterministic, you may have to run this recipe
    several times in order to see a discrepancy between the safe and unsafe sums.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于竞争条件是非确定性的，你可能需要多次运行这个菜谱，才能看到安全和不可安全总和之间的差异。
- en: Using promises to provide a simple interface for a worker
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺为工作者提供一个简单的接口
- en: So far, we've see how to use workers to perform a variety of tasks, but we've
    also seen that they can be cumbersome to use. This is unavoidable to some extent.
    However, we can provide nice interfaces to operations that are using workers with
    the tools we've already seen in in previous chapters.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用工作者（workers）来执行各种任务，但我们也已经看到它们的使用可能会很繁琐。这在某种程度上是不可避免的。然而，我们可以通过我们在前几章中已经看到的工具为使用工作者的操作提供良好的接口。
- en: In this recipe, we'll see how to use promises to create more familiar interfaces.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用承诺（promises）来创建更熟悉的接口。
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application, and navigate to your workspace.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，并导航到你的工作区。
- en: Create a new folder named `05-09-using-promise-for-simple-interfaces`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `05-09-using-promise-for-simple-interfaces` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` file, with an `async` function named `sumOnWorker`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.js` 的文件，其中包含一个名为 `sumOnWorker` 的 `async` 函数：
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inside `sumOnWorker`, return a new promise, wherein you create a new worker
    and bind the `onmessage` event listener, and post a message to the worker to calculate
    the sum:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sumOnWorker` 内部，返回一个新的承诺，其中你创建一个新的工作器，绑定 `onmessage` 事件监听器，并向工作器发送消息以计算总和：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Inside the `onmessage` listener, log out the `type` and `result` properties
    of the message data, and resolve the `result`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onmessage` 监听器内部，记录消息数据的 `type` 和 `result` 属性，并解析 `result`：
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create an `async` main function that creates three arrays of random numbers:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `async` 的主函数，该函数创建三个随机数字的数组：
- en: '[PRE60]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Call `sumOnWorker` with each of the arrays, and log out the results:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个数组调用 `sumOnWorker`，并记录结果：
- en: '[PRE61]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a `worker.js` file, assign the current context to a variable `global`,
    and assign a function to the `onmessage` event:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `worker.js` 文件，将当前上下文分配给变量 `global`，并将一个函数分配给 `onmessage` 事件：
- en: '[PRE62]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the `onmessage` listener, get the data component of the `message` argument
    and `switch` on the `type` attribute:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onmessage` 监听器中，获取 `message` 参数的数据组件，并根据 `type` 属性进行 `switch`：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add a case for `''calculate-sum''`, where you calculate the sum of a posted
    array. Respond with the type or operation, and the resulting value:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个针对 `'calculate-sum'` 的用例，计算已发布的数组的总和。响应类型或操作，以及结果值：
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器，并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/bf22cdc4-ab6b-4506-aafc-ea6c5aa407e0.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf22cdc4-ab6b-4506-aafc-ea6c5aa407e0.png)'
- en: How it works...
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We've seen in previous chapters how flexible composing promises and `async`
    functions can be. Doing so with workers is a natural extension. Consider an asynchronous
    AJAX request. This could be thought of as taking place in a worker. After all,
    it is being performed in a different thread of execution, but managed by the browser.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中看到了如何灵活地组合承诺和 `async` 函数。使用工作器这样做是一个自然的扩展。考虑一个异步 AJAX 请求。这可以被认为是在工作器中发生的。毕竟，它是在不同的执行线程中进行的，但由浏览器管理。
- en: As long as success error conditions are handled properly, promises and `async`
    functions can be used to provide familiar interfaces to Web Workers. Having familiar
    and simple interfaces is crucial when integrating new technology with an existing
    code base.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 只要正确处理成功和错误条件，承诺和 `async` 函数就可以用来为 Web Workers 提供熟悉的接口。当将新技术与现有代码库集成时，拥有熟悉和简单的接口至关重要。
