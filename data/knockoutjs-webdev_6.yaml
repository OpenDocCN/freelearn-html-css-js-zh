- en: Chapter 6. Packaged Elegance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章.打包优雅
- en: 'First there was HTML and JavaScript, then CSS. Next came AJAX to usher in Web
    2.0, as it is called. After that, templates drove us to a more dynamic, creative
    platform. The next advancement in web development was custom HTML components.
    KnockoutJS allows us to jump right in with some game-changing elegance for designers
    and developers. In this chapter, we will focus on:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有 HTML 和 JavaScript，然后是 CSS。接下来是 AJAX，它开启了 Web 2.0 时代，正如它所称呼的那样。之后，模板驱使我们进入了一个更加动态、富有创造性的平台。网络开发的下一个进步是自定义
    HTML 组件。KnockoutJS 允许我们以一些改变游戏规则的风格直接进入，这对于设计师和开发者来说都是一种优雅的方式。在本章中，我们将关注：
- en: An introduction to components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件简介
- en: '**Bring Your Own Tags** (**BYOT**)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自带标签**（**BYOT**）'
- en: Enhancing attribute handling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强属性处理
- en: Making your own libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的库
- en: '**Asynchronous module definition** (**AMD**)—on demand resource loading'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步模块定义**（**AMD**）——按需资源加载'
- en: Component-based **Single-Page Applications** (**SPA**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于组件的 **单页应用程序**（**SPA**）
- en: This entire chapter is about packaging your code for reuse. Using these techniques,
    you can make your code more approachable and elegant.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 整个章节都是关于打包你的代码以供重用。使用这些技术，你可以让你的代码更加易于接近和优雅。
- en: Introduction to components
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件简介
- en: 'We hope you enjoyed learning about templates in the last chapter. Perhaps the
    best explanation of a component is a packaged template with an isolated ViewModel.
    Here is the syntax we would use to declare a `like` component on the page:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你在上一章中学习模板时感到愉快。也许对组件最好的解释就是一个带有隔离 `viewModel` 的打包模板。以下是我们在页面上声明 `like`
    组件将使用的语法：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are passing no parameters through to the component, this is the correct
    syntax. If you wish to pass parameters through, you would use a JSON style structure
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有通过组件传递任何参数，这是正确的语法。如果你希望传递参数，你可以使用以下 JSON 风格的结构：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This would allow us to pass named parameters through to our custom component.
    In this case, we are passing a parameter named `approve`. This would mean we had
    a bound `viewModel` variable by the name of `like`. Look at how this would be
    coded. Create a page called `components.html` using the `_base.html` file to speed
    things up as we have done in all our other chapters. In your `script` section,
    create the following ViewModel:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们通过自定义组件传递命名参数。在这种情况下，我们传递了一个名为 `approve` 的参数。这意味着我们通过名为 `like` 的绑定 `viewModel`
    变量。看看这将如何编码。创建一个名为 `components.html` 的页面，使用 `_base.html` 文件来加快速度，就像我们在所有其他章节中做的那样。在你的
    `script` 部分，创建以下 ViewModel：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we will create our custom component. Here is the basic component we will
    use for this first component. Place the code where the comment is, as we want
    to make sure it is added before our `applyBindings` method is executed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的自定义组件。以下是我们将用于此第一个组件的基本组件。将代码放在注释处，因为我们想确保它在 `applyBindings` 方法执行之前被添加：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are two sections to our components: the `viewModel` and `template` sections.
    In the previous chapter, we learned how to use Knockout templates. In this chapter,
    we will be using those details inside the component.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件有两个部分：`viewModel` 和 `template` 部分。在前一章中，我们学习了如何使用 Knockout 模板。在本章中，我们将使用组件内部的这些细节。
- en: 'The standard Knockout component passes variables to the component using the
    `params` structure. We can either use this structure or you could optionally use
    the *self = this* approach if desired. In addition to setting the variable structure,
    it is also possible to create behaviors for our components. If we look in the
    template code, we can see we have data-bound the click event to toggle the approve
    setting in our component. Then, inside the button, by binding to the visible trait
    of the `span` element, either the thumbs up or thumbs down image will be shown
    to the user. Yes, we are using a Bootstrap icon element rather than a graphic
    here. Here is a screenshot of the initial state:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Knockout 组件使用 `params` 结构将变量传递给组件。我们可以使用这个结构，或者如果你愿意，也可以选择使用 `*self = this*`
    方法。除了设置变量结构外，还可以为我们的组件创建行为。如果我们查看模板代码，我们可以看到我们已将点击事件绑定到组件中的 `approve` 设置切换。然后，在按钮内部，通过绑定到
    `span` 元素的可见特性，将向用户显示点赞或踩不点赞的图片。是的，我们在这里使用的是 Bootstrap 图标元素而不是图形。以下是初始状态的截图：
- en: '![Introduction to components](img/1028OS_06_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![组件简介](img/1028OS_06_01.jpg)'
- en: 'When we click on the thumb image, it will toggle between the thumbs up and
    the thumbs down version. Since we also passed in the external variable that is
    bound to the page ViewModel, we see that the value in the matched span text will
    also toggle. Here is the markup we would add to the page to produce these results
    in the View section of our code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击缩略图图像时，它将在点赞和踩图之间切换。由于我们还传递了一个绑定到页面ViewModel的外部变量，因此我们可以看到匹配的span文本中的值也会切换。以下是我们在代码的视图部分添加的标记，以产生这些结果：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You could build this type of functionality with a jQuery plugin as well, but
    it is likely to take a bit more code to do two-way binding and match the tight
    functionality we have achieved here. This doesn't mean jQuery plugins are bad,
    as this is also a jQuery-related technology. What it does mean is we have ways
    to do things even better. It is this author's opinion that features like this
    would still make great additions to the core jQuery library. Yet, I am not holding
    my breath waiting for them to adopt a Knockout-type project to the wonderful collection
    of projects they have at this point, and do not feel we should hold that against
    them. Keeping focused on what they do best is one of the reasons libraries like
    Knockout can provide a wider array of options. It seems the decisions are working
    on our behalf even if they are taking a different approach than I expected.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用jQuery插件构建此类功能，但可能需要更多的代码来实现双向绑定并匹配我们在这里实现的紧密功能。这并不意味着jQuery插件不好，因为这同样是一种与jQuery相关的技术。这意味着我们有一些方法可以做得更好。这位作者认为，此类功能仍然可以很好地添加到核心jQuery库中。然而，我并不期待他们采纳类似Knockout的项目到他们目前拥有的精彩项目集合中，并且不觉得我们应该因此对他们有所偏见。专注于他们最擅长的事情是Knockout等库能够提供更广泛选项的原因之一。看起来，他们的决定正在为我们工作，即使它们采取了与我预期不同的方法。
- en: Dynamic component selection
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态组件选择
- en: 'You should have noticed when we selected the component that we did so using
    a quoted declaration. While at first it may seem to be more constricting, remember
    that it is actually a power feature. By using a variable instead of a hardcoded
    value, you can dynamically select the component you would like to be inserted.
    Here is the markup code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择组件时，我们应该已经注意到我们使用的是引号声明的。虽然一开始可能看起来更加限制，但请记住，这实际上是一个强大的功能。通过使用变量而不是硬编码的值，您可以动态选择要插入的组件。以下是标记代码：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that we are passing in both `widgetName` as well as `widgetParams`.
    Because we are binding the structure differently, we also need to show the bound
    value differently in our span. Here is the `script` part of our code that needs
    to be added to our `viewModel` code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们传递了`widgetName`以及`widgetParams`。由于我们以不同的方式绑定结构，因此我们还需要以不同的方式在我们的span中显示绑定的值。以下是需要添加到我们的`viewModel`代码中的`script`部分的代码：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will get the same visible results but notice that each of the like buttons
    is acting independent of the other. What would happen if we put more than one
    of the same elements on the page? If we do that, Knockout components will act
    independent of other components. Well, most of the time they act independent.
    If we bound them to the same variable they would not be independent. In your `viewModel`
    declaration code, add another variable called `like2` as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到相同的外观结果，但请注意，每个点赞按钮都是独立于其他按钮操作的。如果我们页面上放置多于一个相同的元素会发生什么？如果我们这样做，Knockout组件将独立于其他组件操作。嗯，大多数时候它们是独立操作的。如果我们将它们绑定到相同的变量，它们将不会独立。在你的`viewModel`声明代码中，添加另一个名为`like2`的变量，如下所示：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will add another like button to the page by copying our first like
    View code. This time, change the value from `like` to `like2` as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过复制我们的第一个点赞视图代码来向页面添加另一个点赞按钮。这次，将值从`like`更改为`like2`，如下所示：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This time when the page loads, the other likes display with a thumbs up, but
    this like will display with a thumbs down. The text will also show **false** stored
    in the bound value. Any of the like buttons will act independently because each
    of them is bound to unique values. Here is a screenshot of the third button:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当页面加载时，其他点赞显示为点赞，但这个点赞将显示为踩图。文本还将显示绑定值中存储的**false**。任何点赞按钮都将独立操作，因为每个按钮都绑定到唯一的值。以下是第三个按钮的截图：
- en: '![Dynamic component selection](img/1028OS_06_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![动态组件选择](img/1028OS_06_02.jpg)'
- en: Bring Your Own Tags (BYOT)
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带上您自己的标签（BYOT）
- en: 'What is an element? Basically, an element is a component that you reach using
    the tag syntax. This is the way it is expressed in the official documentation
    at this point and it is likely to stay that way. It is still a component under
    the hood. Depending on the crowd you are in, this distinction will be more or
    less important. Mostly, just be aware of the distinction in case someone feels
    it is important, as that will let you be on the same page in discussions. Custom
    tags are a part of the forthcoming HTML feature called Web Components. Knockout
    allows you to start using them today. Here is the View code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是元素？基本上，元素是一个使用标签语法访问的组件。这是目前官方文档中的表述方式，并且很可能会保持这种方式。它仍然是底层的组件。根据你所处的群体，这种区别可能重要也可能不重要。主要的是，要意识到这种区别，以防有人认为它很重要，这样你就可以在讨论中保持一致。自定义标签是即将到来的HTML特性Web
    Components的一部分。Knockout允许你从今天开始使用它们。以下是视图代码：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may want to code some tags with a single tag rather than a double tag, as
    in an opening and closing tag syntax. Well, at this time, there are challenges
    getting each browser to see the custom element tags when declared as a single
    tag. This means custom tags, or elements, will need to be declared as opening
    and closing tags for now.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要用单个标签而不是成对的标签（即开始和结束标签语法）来编写一些标签。然而，目前，将自定义元素标签声明为单个标签时，每个浏览器都会遇到挑战。这意味着自定义标签或元素目前需要声明为开始和结束标签。
- en: 'We will also need to create our `like3` bound variable for `viewModel` with
    the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用以下代码为`viewModel`创建`like3`绑定变量：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the code gives us the same wonderful functionality as our `data-bind`
    approach, but now we are creating our own HTML tags. Has there ever been a time
    you wanted a special HTML tag that just didn't exist? There is a chance you could
    create that now using Knockout component element-style coding.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会给我们带来与`data-bind`方法相同的功能，但现在我们正在创建自己的HTML标签。有没有什么时候你想要一个特殊但并不存在的HTML标签？现在，使用Knockout组件元素风格的编码，你有可能创建出这样的标签。
- en: Enhancing attribute handling
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强属性处理
- en: Now, while custom tags are awesome, there is just something different about
    passing everything in with a single param attribute. The reason for this is that
    this process matches how our tags work when we are using the `data-bind` approach
    to coding. In the following example, we will look at passing things in via individual
    attributes. This is not meant to work as a `data-bind` approach, but it is focused
    completely on the custom tag element component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然自定义标签很棒，但将所有内容通过单个`param`属性传递确实有一种不同的感觉。原因在于这个过程与我们在使用`data-bind`编码方法时标签的工作方式相匹配。在下面的例子中，我们将通过单个属性传递内容。这并不是要作为一个`data-bind`方法来工作，但它完全集中在自定义标签元素组件上。
- en: 'The first thing you want to do is make sure this enhancement doesn''t cause
    any issues with the normal elements. We did this by checking the custom elements
    for a standard prefix. You do not need to work through this code as it is a bit
    more advanced. The easiest thing to do is to include our Knockout components tag
    with the following `script` tag:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先想要做的是确保这个增强功能不会对正常元素造成任何问题。我们通过检查自定义元素的标准前缀来做到这一点。你不需要深入理解这段代码，因为它稍微有些复杂。最简单的方法是使用以下`script`标签包含我们的Knockout组件标签：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this tag, we have this code segment to convert the tags that start with `kom-`
    to tags that use individual attributes rather than a JSON translation of the attributes.
    Feel free to borrow the code to create libraries of your own. We are going to
    be creating a standard set of libraries on GitHub for these component tags. Since
    the HTML tags are Knockout components, we are calling these libraries "KOmponents".
    The resource can be found at [https://github.com/sosensible/komponents](https://github.com/sosensible/komponents).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个标签中，我们有一个代码段，用于将以`kom-`开头的标签转换为使用单个属性而不是属性的JSON转换的标签。你可以自由地借用这段代码来创建自己的库。我们将在GitHub上创建一组标准的库来为这些组件标签服务。由于HTML标签是Knockout组件，我们将这些库称为"KOmponents"。资源可以在[https://github.com/sosensible/komponents](https://github.com/sosensible/komponents)找到。
- en: 'Now, with that library included, we will use our View code to connect to the
    new tag. Here is the code to use in the View:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，包含了这个库之后，我们将使用我们的视图代码来连接到新的标签。以下是视图中的代码：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that in our HTML markup, the tag starts with the library prefix. This
    will also require `viewModel` to have a binding to pass into this tag as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的HTML标记中，标签以库前缀开始。这也将要求`viewModel`有一个绑定来传递给这个标签，如下所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the code for the actual "attribute-aware version" of Knockout
    components. Do not place this in the code as it is already included in the library
    in the shared directory:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是Knockout组件实际“属性感知版本”的代码。不要将此代码放入代码中，因为它已经包含在共享目录中的库中：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The tag in the View changed as we passed the information in via named attributes
    and not as a JSON structure inside a param attribute. We also made sure to manage
    these tags by using a prefix. The reason for this is that we did not want our
    fancy tags to break the standard method of passing params commonly practiced with
    regular Knockout components.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，随着我们通过命名属性传递信息而不是在参数属性内的JSON结构中传递信息，标签发生了变化。我们还确保通过使用前缀来管理这些标签。这样做的原因是我们不希望我们的花哨标签破坏与常规Knockout组件一起普遍使用的传递参数的标准方法。
- en: As we see, again we have another functional component with the added advantage
    of being able to pass the values in a style more familiar to those used to coding
    with HTML tags.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们再次有一个功能组件，它增加了能够以更熟悉HTML标签编码的方式传递值的优势。
- en: Building your own libraries
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自己的库
- en: Again, we are calling our custom components KOmponents. We will be creating
    a number of library solutions over time and welcome others to join in. Tags will
    not do everything for us, as there are some limitations yet to be conquered. That
    doesn't mean we wait for all the features before doing the ones we can for now.
    In the previous chapter, we showed a `KOmponent` tag for using templates. That
    is also included in the base KOmponent library.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们称之为自定义组件KOmponents。我们将随着时间的推移创建许多库解决方案，并欢迎其他人加入。标签不会为我们做所有事情，因为还有一些限制尚未克服。但这并不意味着我们等待所有功能都准备好后再去做我们现在能做的事情。在前一章中，我们展示了用于使用模板的`KOmponent`标签，这也包含在基本KOmponent库中。
- en: 'In this segment of the chapter, we will also be showing some tags from our
    Bootstrap `KOmponents` library. First we will need to include the Bootstrap `KOmponents`
    library:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们还将展示一些来自我们的Bootstrap `KOmponents`库的标签。首先，我们需要包含Bootstrap `KOmponents`库：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Above `viewModel` in our script, we need to add a function to make this section
    of code simpler. At times, when passing items into observables, we can pass in
    richer bound data using a function like this. Again, create this function above
    the `viewModel` declaration of the script, shown as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中`viewModel`之上，我们需要添加一个函数来使这段代码更简单。有时，在将项目传递给可观察对象时，我们可以使用这样的函数传递更丰富的绑定数据。再次，在脚本中`viewModel`声明之上创建这个函数，如下所示：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, inside `viewModel`, we will declare a set of data to pass to a Bootstrap
    style `listGroup` as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`viewModel`内部，我们将声明一组数据，以便将其传递给Bootstrap样式的`listGroup`，如下所示：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Each item in our array will have display, students, and type variables. We
    are using a number of features in Bootstrap here but packaging them all up inside
    our Bootstrap smart tag. This tag starts to go beyond the bare basics. It is still
    very implementable, but we don''t want to throw too much at you to absorb at one
    time, so we will not go into the detailed code for this tag. What we do want to
    show is how much power can be wrapped into custom Knockout tags. Here is the markup
    we will use to call this tag and bind the correct part of `viewModel` for display:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数组中的每个项目都将包含显示、学生和类型变量。在这里我们使用了Bootstrap的许多功能，但将它们全部打包在我们的Bootstrap智能标签中。这个标签开始超越最基本的功能。它仍然非常易于实现，但我们不想一次性给你太多内容去吸收，所以我们将不会深入讲解这个标签的详细代码。我们想要展示的是，可以将多少功能封装到自定义Knockout标签中。以下是我们将用来调用这个标签并绑定`viewModel`的正确部分的标记：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That is it. You should take note of a couple of special details. The data is
    passed in as a bound Knockout ViewModel. The badge field is passed in as a string
    name to declare the field on the data collection where the badge count will be
    pulled. The same string approach has been used for the type field. The type will
    set the colors as per standard Bootstrap types. The theme here is that if there
    are not enough students to hold a class, then it shows the danger color in the
    list group custom tag. Here is what it looks like in the browser when we run the
    code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。你应该注意几个特殊细节。数据作为绑定的Knockout ViewModel传递。徽章字段作为字符串名称传递，以在数据集合中声明徽章计数将被提取的字段。对于类型字段也使用了相同的字符串方法。这里的主题是，如果没有足够的学生来维持一个班级，那么在列表组自定义标签中会显示危险颜色。以下是代码在浏览器中运行时的样子：
- en: '![Building your own libraries](img/1028OS_06_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![构建自己的库](img/1028OS_06_03.jpg)'
- en: 'While this is neat, let''s jump into our browser tools console and change the
    value of one of the items. Let''s say there was a class on some cool web technology
    called jQuery. What if people had not heard of it and didn''t know what it was
    and you really wanted to take the class? Well, it would be nice to encourage a
    few others to check it out. How would you know whether the class was at a danger
    level or not? Well, we could simply use the badge and the numbers, but how awesome
    is it to also use the color coding hint? Type the following code into the console
    and see what changes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很酷，但让我们跳到我们的浏览器工具控制台，并更改其中一个项目的值。假设有一个名为jQuery的酷炫网络技术上的类。如果人们没有听说过它，不知道它是什么，而你真的很想上这个课，那会怎么样？嗯，鼓励其他人去看看会很好。你如何知道这个课程是否处于危险水平？嗯，我们可以简单地使用徽章和数字，但使用颜色编码提示有多酷？在控制台中输入以下代码，看看会发生什么变化：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because JavaScript starts counting with zero for the first item, we will get
    the following result:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript从零开始计数第一个项目，我们将得到以下结果：
- en: '![Building your own libraries](img/1028OS_06_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![构建自己的库](img/1028OS_06_04.jpg)'
- en: 'Now we know we have the right item, so let''s set the student count to nine
    using the following code in the browser console:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们找到了正确的项目，所以让我们在浏览器控制台中使用以下代码将学生计数设置为九：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice the change in the jQuery class. Both the badge and the type value have
    updated. This screenshot of the update shows how much power we can wield with
    very little manual coding:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意jQuery类的变化。徽章和类型值都已更新。此更新截图显示了我们可以用极少的手动编码发挥多大的力量：
- en: '![Building your own libraries](img/1028OS_06_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![构建自己的库](img/1028OS_06_05.jpg)'
- en: 'We should also take a moment to see how the type was managed. Using the functional
    assignment, we were able to use the Knockout computed binding for that value.
    Here is the code for that part again:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该花点时间看看如何管理类型。使用函数赋值，我们能够使用Knockout计算绑定来处理该值。以下是该部分的代码再次：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While the code is outside the `viewModel` declaration, it is still able to bind
    properly to make our code run even inside a custom tag created with Knockout's
    component binding.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码位于`viewModel`声明之外，但它仍然能够正确绑定，使我们的代码即使在用Knockout的组件绑定创建的自定义标签内也能运行。
- en: Bootstrap component example
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrap组件示例
- en: 'Here is another example of binding with Bootstrap. The general best practice
    for using modal display boxes is to place them higher in the code, perhaps under
    the `body` tag, to make sure there are no conflicts with the rest of the code.
    Place this tag right below the `body` tag as shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个使用Bootstrap进行绑定的示例。使用模态显示框的一般最佳实践是将它们放置在代码的较高位置，可能在`body`标签下，以确保不会与代码的其他部分发生冲突。将此标签放置在以下代码的`body`标签下方，如所示：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, we will need to make some declarations inside `viewModel` for this to
    work right. Enter this code into the declarations of `viewModel`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了使这个功能正常工作，我们还需要在`viewModel`内部做一些声明。将以下代码输入到`viewModel`的声明中：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will also create a button on the page to call our `viewModel`. The button
    will use the binding that is part of Bootstrap. The `data-toggle` and `data-target`
    attributes are not Knockout binding features. Knockout works side-by-side wonderfully
    though. Another point of interest is the standard ID attribute, which tells how
    Bootstrap items, like this button, interact with the modal box. This is another
    reason it may be beneficial to use KOmponents or a library like it. Here is the
    markup code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在页面上创建一个按钮来调用我们的`viewModel`。该按钮将使用Bootstrap的一部分绑定。`data-toggle`和`data-target`属性不是Knockout绑定功能。尽管如此，Knockout与它们协同工作得非常好。另一个值得关注的点是标准的ID属性，它说明了像这样的按钮如何与模态框交互。这也是使用KOmponents或类似库可能有益的另一个原因。以下是标记代码：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we click on the button, this is the requestor we see:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击按钮时，我们看到的是这个请求者：
- en: '![Bootstrap component example](img/1028OS_06_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap组件示例](img/1028OS_06_06.jpg)'
- en: 'Now, to understand the power of Knockout working with our requestor, head back
    over to your browser tools console. Enter the following command into the prompt:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了理解Knockout与我们的请求者协同工作的强大功能，请回到你的浏览器工具控制台。在提示符中输入以下命令：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following screenshot shows the change:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了变化：
- en: '![Bootstrap component example](img/1028OS_06_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap组件示例](img/1028OS_06_07.jpg)'
- en: Who knows what type of creative modular boxes we can build using this type of
    technology. This brings us closer towards creating what we can imagine. Perhaps
    it may bring us closer to building some of the wild things our customers imagine.
    While that may not be your main motivation for using Knockout, it would be nice
    to have a few less roadblocks when we want to be creative. It would also be nice
    to have this wonderful ability to package and reuse these solutions across a site
    without using copy and paste and searching back through the code when the client
    makes a change to make updates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 谁知道我们可以使用这种技术构建出什么样的创意模块化盒子。这让我们更接近于创造我们所想象的东西。也许它将使我们更接近于构建客户所想象的那些疯狂事物。虽然这可能不是你使用
    Knockout 的主要动机，但当我们想要发挥创意时，有几个障碍会更少会很好。同时，也很棒能够拥有这种将解决方案打包和跨网站重用的能力，而无需复制粘贴和搜索代码，当客户对代码进行更改以进行更新时。
- en: Again, feel free to look at the file to see how we made these components work.
    They are not extremely complicated once you get the basics of using Knockout and
    its components. If you are looking to build components of your own, they will
    help you get some insight on how to do things inside as you move your skills to
    the next level.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，你可以查看这些文件以了解我们如何使这些组件工作。一旦你掌握了使用 Knockout 及其组件的基本知识，它们并不复杂。如果你想要构建自己的组件，它们将帮助你了解如何在技能提升到下一个水平时内部实现。
- en: Understanding the AMD approach
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 AMD 方法
- en: We are going to look into the concept of what makes an AMD-style website. The
    point of this approach to sites is to pull content on demand. The content, or
    modules as they are defined here, does not need to be loaded in a particular order.
    If there are pieces that depend on other pieces, that is, of course, managed.
    We will be using the *RequireJS* library to manage this part of our code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨构成 AMD 风格网站的概念。这种网站方法的目的是按需获取内容。内容，或如在此定义的模块，不需要按特定顺序加载。如果有部分依赖于其他部分，当然，这是可以管理的。我们将使用
    *RequireJS* 库来管理我们代码的这一部分。
- en: 'We will create four files in this example, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建四个文件，如下所示：
- en: '`amd.html`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amd.html`'
- en: '`amd.config.js`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amd.config.js`'
- en: '`pick.js`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pick.js`'
- en: '`pick.html`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pick.html`'
- en: 'In our AMD page, we are going to create a configuration file for our RequireJS
    functionality. That will be the `amd.config.js` file mentioned in the aforementioned
    list. We will start by creating this file with the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 AMD 页面中，我们将为 RequireJS 功能创建一个配置文件。这就是上述列表中提到的 `amd.config.js` 文件。我们将从以下代码开始创建此文件：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We see here that we are creating some alias names and setting the paths these
    names point to for this page. The file could, of course, be working for more than
    one page, but in this case, it has specifically been created for a single page.
    The configuration in RequireJS does not need the `.js` extension on the file names,
    as you would have noted.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们正在创建一些别名并设置这些名称指向此页面的路径。当然，这个文件可以为多个页面工作，但在这个例子中，它专门为单个页面创建。在 RequireJS
    的配置中，文件名不需要 `.js` 扩展名，正如你所注意到的。
- en: Now, we will look at our `amd.html` page where we pull things together. We are
    again using the standard page we have used for this course, which you will notice
    if you preview the `done` file example of the code. There are a couple of differences
    though, because the JavaScript files do not all need to be called at the start.
    RequireJS handles this well for us. We are not saying this is a standard practice
    of AMD, but it is an introduction of the concepts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看我们的 `amd.html` 页面，在那里我们将整合所有内容。我们再次使用本课程中使用的标准页面，如果你预览代码示例中的 `done`
    文件，你会注意到这一点。尽管如此，也有一些不同之处，因为并非所有的 JavaScript 文件都需要在开始时调用。RequireJS 为我们很好地处理了这一点。我们并不是说这是
    AMD 的标准实践，但它是对这些概念的介绍。
- en: 'We will need to include the following three script files in this example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要包含以下三个脚本文件：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice that the configuration settings need to be set before calling the `require.js`
    library. With that set, we can create the code to wire Knockout binding on the
    page. This goes in our `amd.html` script at the bottom of the page:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用 `require.js` 库之前需要设置配置设置。设置好之后，我们可以创建代码来在页面上绑定 Knockout。这部分代码位于页面的底部
    `amd.html` 脚本中：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Most of this code should look very familiar. The difference is that the external
    files are being used to set the content for `viewModel` and `template` in the
    `pick` component. The `require` setting smartly knows to include the `pick.js`
    file for the `pick` setting. It does need to be passed as a string, of course.
    When we include the template, you will see that we use `text!` in front of the
    file we are including. We also declare the extension on the file name in this
    case. The text method actually needs to know where the text is coming from, and
    you will see in our `amd.config.js` file that we created an alias for the inclusion
    of the text function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分应该看起来非常熟悉。区别在于外部文件被用来设置`pick`组件中`viewModel`和`template`的内容。`require`设置智能地知道要包含`pick.js`文件以供`pick`设置使用。当然，它需要作为字符串传递。当我们包含模板时，你将看到我们在包含的文件前使用了`text!`。在这种情况下，我们还在文件名上声明了扩展名。实际上，文本方法需要知道文本的来源，你将在我们的`amd.config.js`文件中看到我们为文本函数的包含创建了一个别名。
- en: 'Now, we will create the `pick.js` file and place it in the same directory as
    the `amd.html` file. It could have been in another directory, and you would have
    to just set that in the component declaration along with the filename. Here is
    the code for this part of our AMD component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`pick.js`文件，并将其放置在与`amd.html`文件相同的目录中。它也可以放在另一个目录中，你只需在组件声明中设置该目录以及文件名即可。以下是我们的AMD组件这一部分的代码：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that our code starts with the `define` method. This is our AMD functionality
    in place. It is saying that before we try to execute this section of code we need
    to make sure the Knockout library is loaded. This allows us to do on-demand loading
    of code as needed. The code inside the `viewModel` section is the same as the
    other examples we have looked at with one exception. We return `viewModel` as
    you see at the end of the preceding code. We used the shorthand code to set the
    value for `heads` and `tails` in this example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的代码以`define`方法开始。这是我们AMD功能的具体实现。这意味着在我们尝试执行这段代码之前，我们需要确保Knockout库已加载。这允许我们按需加载所需的代码。`viewModel`部分内部的代码与我们所查看的其他示例相同，只有一个例外。我们在前一段代码的末尾返回`viewModel`。在这个例子中，我们使用了简写代码来设置`heads`和`tails`的值。
- en: 'Now, we will look at our template file, `pick.html`. This is the code we will
    have in this file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看我们的模板文件，`pick.html`。这个文件中的代码如下：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This template follows the same concepts as the ones we looked at in the previous
    chapter. There is nothing special other than the code needed to make this example
    work. The goal is to allow a custom tag to offer up heads or tails options on
    the page. We also pass in a bound variable from `viewModel`. We will be passing
    it into three identical tags.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板遵循我们在上一章中查看的概念。除了使这个例子工作所需的代码外，没有特别之处。目标是允许自定义标签在页面上提供heads或tails选项。我们还从`viewModel`传递了一个绑定变量。我们将将其传递到三个相同的标签中。
- en: 'The tags are actually going to load the content instantly in this example.
    The goal is to get familiar with how the code works. We will take it to full practice
    at the end of the chapter. Right now, we will put this code in the View segment
    of our `amd.html` page:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，标签实际上会立即加载内容。目标是熟悉代码的工作方式。我们将在本章末尾进行完整的实践。现在，我们将这段代码放在`amd.html`页面的视图部分：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice that we have included the `pick` tag three times. While we are passing
    in the bound choice item from `viewModel`, each tag will randomly choose heads
    or tails. When we run the code, this is what we will see:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们包含了`pick`标签三次。虽然我们正在从`viewModel`传递绑定选择项，但每个标签将随机选择heads或tails。当我们运行代码时，我们会看到以下内容：
- en: '![Understanding the AMD approach](img/1028OS_06_08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![理解AMD方法](img/1028OS_06_08.jpg)'
- en: 'Since we passed the same bound item into each of the three tags, when we click
    on any heads or tails set, it will immediately pass that value out to `viewModel`,
    which will in turn immediately pass the value back into the other two tag sets.
    They are all wired together through `viewModel` binding being the same variable.
    This is the result we get if we click on **Tails**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将相同的绑定项传递给了三个标签，当我们点击任何`heads`或`tails`设置时，它将立即将该值传递到`viewModel`，然后`viewModel`将立即将值传递回其他两个标签集。它们都通过`viewModel`绑定相同的变量连接在一起。这是点击**Tails**时我们得到的结果：
- en: '![Understanding the AMD approach](img/1028OS_06_09.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![理解AMD方法](img/1028OS_06_09.jpg)'
- en: Well, it is the results we got that time. Actually, the results change pretty
    much every time we refresh the page. Now, we are ready to do something extra special
    by combining our AMD approach with Knockout modules.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是我们当时得到的结果。实际上，每次刷新页面，结果都会有很大的变化。现在，我们准备通过结合我们的AMD方法和Knockout模块来做一些特别的事情。
- en: Component-based SPAs
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于组件的SPA
- en: Now, we can look at one of the fastest growing trends in web development, the
    concept of single-page applications. The name is fancier than the practice because
    it is wrapped in confusion, but we will help you get over that here.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看网络开发中增长最快的趋势之一，即单页应用的概念。这个名称比实际做法更花哨，因为它被笼罩在困惑之中，但我们将在这里帮助你克服这一点。
- en: First, think of your website as a computer or mobile device. You can put multiple
    applications on your system. The apps can work together or independently. While
    we understand this for our computing systems, we seem to get confused when we
    move to web servers. Everything is not one application, or better put, rarely
    should everything be one application. There was a day, before Windows, when your
    spreadsheet and your word processor were shipped as one application. This was
    very popular, but over time we figured out packaging two apps was smarter than
    trying to build cross functionality into one app. Thus, we created office suites.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将你的网站视为一台计算机或移动设备。你可以在系统上安装多个应用程序。这些应用程序可以协同工作或独立工作。虽然我们理解我们的计算系统，但当我们转向网络服务器时，我们似乎会感到困惑。一切并不都是一个应用程序，或者更确切地说，很少应该一切都是一个应用程序。在Windows出现之前，你的电子表格和文字处理器被作为一个应用程序一起发货。这非常受欢迎，但随着时间的推移，我们意识到将两个应用程序打包比试图将跨功能构建到一个应用程序中更明智。因此，我们创建了办公套件。
- en: Today, we are suffering from the effects of mistakes made on most server platforms.
    When our backend server languages were created, many of them created a packaging
    approach that was wrapped around the term "application". So, when you built a
    website with a shopping cart, forum, and blog, they all ran under the same application
    scope. In hindsight, we should have labeled these site scopes and sub-divided
    the shopping "application", the forum "application", and the blog "application"
    as items under the "site".
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们正遭受大多数服务器平台所犯错误的影响。当我们的后端服务器语言被创建时，其中许多创建了围绕“应用”这一术语的包装方法。因此，当你用购物车、论坛和博客构建一个网站时，它们都在同一个应用范围内运行。事后看来，我们应该将这些网站范围和将购物“应用”、论坛“应用”和博客“应用”作为“网站”下的项目进行标记。
- en: Single-page applications seem to be having the same folly. The architecture
    and naming conventions tend to cause confusion. As a fellow seasoned developer,
    let me be vain for a moment and give you my permission to think outside the box
    on this. Forget the name SPA for a moment and let's step back and just understand
    what it does. Once you understand what it does, you will be able to smartly figure
    out how to apply it. Good implementation is after all, or it should be, the goal.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用似乎也犯了一个同样的错误。其架构和命名约定往往会引起混淆。作为一个经验丰富的开发者，让我自大地给你一个时刻，允许你在这个问题上跳出思维定式。暂时忘记SPA这个名称，让我们退后一步，仅仅理解它做了什么。一旦你理解了它做了什么，你将能够明智地想出如何应用它。毕竟，良好的实现，或者它应该是，目标是。
- en: Best development strategies
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳开发策略
- en: 'There are many goals connected to the best development strategies. The truth
    is that there is no single best strategy. It is similar to the truth commonly
    shared as an answer in tech circles: it depends. This means the first thing you
    need to know is the target needs before you figure out what fits the best. Some
    people get caught up thinking bleeding-edge solutions are the best strategies.
    Sometimes they are, but not universally. It should be a heads-up, wide awake decision.
    The truth is that unless we are getting business done, technology doesn''t add
    anything to the picture.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与最佳开发策略相关的目标有很多。事实是，没有一种单一的最好策略。这类似于在技术圈中普遍分享的真理：这取决于。这意味着在你确定什么最适合之前，你需要知道目标需求。有些人陷入了认为尖端解决方案是最佳策略的误区。有时它们是，但并非普遍如此。这应该是一个提醒，要清醒地做出决定。事实是，除非我们在完成业务，否则技术不会给画面增添任何东西。
- en: Technology is powerful. Technology is about knowing. If we properly understand
    the challenges then we can better choose our technology, our methodologies, and
    our solutions. Sometimes we may choose Knockout and other times just stay with
    jQuery. Sometimes, we bring in other mixes of products such as RequireJS and more.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 技术是强大的。技术是关于知识的。如果我们正确理解了挑战，那么我们可以更好地选择我们的技术、我们的方法和我们的解决方案。有时我们可能会选择Knockout，有时则只坚持使用jQuery。有时，我们会引入其他产品的混合，如RequireJS等。
- en: Getting real
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Getting real
- en: Another thing we should avoid is trying to apply technology we have never actually
    used anywhere. This is a high-stakes gamble, and this is why I hope you have been
    doing the code examples as you go through this book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该避免的另一件事是尝试应用我们从未实际在任何地方使用过的技术。这是一个高风险的赌注，这也是为什么我希望你在阅读这本书的过程中已经做了代码示例。
- en: We are now going to create a solution, by popular name, an SPA, using Knockout
    and its components to drive the views. Because the concept is called SPA, we will
    call these dynamically loaded views "pages". We will be building on the AMD concept
    of dynamically loaded content using a few other SPA concepts as well. The goal
    here is not to teach you all the ins and outs of SPAs, but this will give you
    a pretty good launching point if you have never jumped in before.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个解决方案，通俗地说，一个SPA，使用Knockout及其组件来驱动视图。因为概念被称为SPA，我们将把这些动态加载的视图称为“页面”。我们将基于AMD动态加载内容的概念，同时使用一些其他的SPA概念。这里的目的是不是要教你所有关于SPA的细节，但如果你之前从未尝试过，这将为你提供一个相当不错的起点。
- en: Our page content, code if you prefer, will be sectioned off into a pages directory
    with each page having its template and `viewModel` in separate files. Earlier,
    we repeated the template and the ViewModel for on-page components. This time,
    we will be using components for on-page content as well as for declaring the main
    view content using components. For clarity, we have created a `components` folder
    for the non-page components; for instance, the navigation bar will be put in the
    `components` folder.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内容，如果你喜欢的话，代码，将被分成一个名为`pages`的目录，每个页面都有自己的模板和`viewModel`文件。之前，我们重复了页面组件的模板和ViewModel。这次，我们将使用组件来处理页面内容，以及使用组件来声明主视图内容。为了清晰起见，我们为非页面组件创建了一个`components`文件夹；例如，导航栏将被放在`components`文件夹中。
- en: What makes an SPA fit for the basic description of a single page is that the
    browser only loads a base page at a time. After that, all content is pulled and
    injected into the page. So it is technically correct that there be only one page.
    The display of content on the page is loaded and updated on the fly, but technically
    speaking, it is still on the original page. This will be our `index.html` file.
    If you look in your exercise root folder, you will see a subdirectory called `spa`
    and another called `myspa`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使SPA适合基本单页描述的是，浏览器一次只加载一个基本页面。之后，所有内容都被拉入并注入到页面中。因此，从技术上讲，只有一个页面是正确的。页面上内容的显示是即时加载和更新的，但从技术上讲，它仍然是在原始页面上。这将是我们`index.html`文件。如果你查看你的练习根目录，你会看到一个名为`spa`的子目录，另一个名为`myspa`。
- en: 'If you want to see a completed SPA, you can peek ahead and look at the SPA
    version. My suggestion is to build it up and take the discovery route. Only then
    compare it to the SPA version if you feel like you made a mistake. Here is a screenshot
    of our starting point with our `myspa` example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看一个完成的SPA，你可以提前看看SPA版本。我的建议是逐步构建，并采取探索的方式。只有在你觉得自己犯了错误时，才将其与SPA版本进行比较。以下是我们的起点截图，使用`myspa`示例：
- en: '![Getting real](img/1028OS_06_10.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Getting real](img/1028OS_06_10.jpg)'
- en: 'This looks rather plain, but it is actually more complex than you would think.
    Power tools often look unimpressive while sitting on the shelf. It is worth looking
    at the code of the home page. Here is the View or the template file for the page:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当简单，但实际上比你想象的要复杂。在架子上，强大的工具通常看起来不起眼。查看主页的代码是值得的。以下是页面的视图或模板文件：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Normally, when we look in Knockout for the binding data, we are looking for
    the base `viewModel` data. In this case, we are looking at the data contained
    in the `viewModel` component. Let''s look at the code of the component and see
    where it comes from by looking for our message variable:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们查看Knockout以获取绑定数据时，我们正在寻找基本的`viewModel`数据。在这种情况下，我们正在查看`viewModel`组件中的数据。让我们看看组件的代码，并查找我们的消息变量来了解它从哪里来：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We see the `define` method here again, which tells us we are taking care of
    dependencies properly using RequireJS. We see in the `myViewModel` section of
    code the `viewModel` attribute message. Remember to use the `this` type scope
    or the attributes will not be properly bound and visible on `viewModel`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里再次看到了`define`方法，它告诉我们我们正在使用RequireJS正确地处理依赖关系。我们在代码的`myViewModel`部分看到了`viewModel`属性消息。请记住使用`this`类型的作用域，否则属性将无法正确绑定并在`viewModel`中可见。
- en: We are just getting exposed to the tools of SPA sites and pages. While it may
    not be amazing yet, the beauty will present itself as you learn to use the tools
    here. It's like looking at the paint brushes of great artists. You would not have
    been able to predict the amazing paintings that came from them. It's time to teach
    you how to use the tools that create powerful SPA solutions and improve your mastery
    over web development.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚开始接触SPA网站和页面的工具。虽然现在可能还感觉不到它的神奇，但随着你对这里工具的使用，它的美将逐渐显现。就像欣赏伟大艺术家的画笔一样。你无法预见到他们创作出的惊人画作。现在是时候教你如何使用创建强大SPA解决方案的工具，并提高你对Web开发的掌握能力。
- en: Coding time
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码时间
- en: 'The first thing we will look at is our single page where everything is presented.
    Here is the code for the super-duper everything page:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看我们的单页，其中展示了所有内容。以下是超级无敌一切页面的代码：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We see two JavaScript files here. The first is a configuration file and the
    second is the RequireJS file. That is not all the JavaScript requires, but the
    RequireJS file will manage pulling in the core libraries needed for this site
    to run properly. This is contained in the configuration file. Let''s take a look
    at that file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了两个JavaScript文件。第一个是配置文件，第二个是RequireJS文件。这并不是所有需要的JavaScript文件，但RequireJS文件将负责引入使网站正常运行所需的核心库。这些库包含在配置文件中。让我们来看看这个文件：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is the same kind of logic we used in our AMD example previously. You will
    notice that we are using several libraries in our code here. RequireJS handles
    much of the loading on demand, or as needed, if you prefer to state it that way.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在AMD示例中使用的相同逻辑。你会注意到我们在代码中使用了多个库。如果你更喜欢这样表达，RequireJS处理了大部分按需加载或按需加载的工作。
- en: 'You will also notice that in the `body` section of the `index.html` page there
    is a Knockout bound `div` element like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到在`index.html`页面的`body`部分有一个Knockout绑定的`div`元素，如下所示：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is how we pull the page content and drive it to the View for the user.
    If you are new to this kind of app, there is something that will appear to be
    missing. There is another file that is actually being called that is not immediately
    apparent. Look at the `script` tag that calls `require.js` into the page:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何提取页面内容并将其驱动到用户视图的方法。如果你是这种应用的新手，可能会觉得有些东西缺失。实际上有一个文件被调用，但并不立即明显。看看调用`require.js`到页面的`script`标签：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Notice the `data-main` attribute binding. This tells the page to load in the
    `starup.js` file from the `app` folder. Let''s look at that file here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`data-main`属性绑定。这告诉页面从`app`文件夹加载`startup.js`文件。让我们来看看这个文件：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We see the `RequireJS define` method, and there is no return needed as the functionality
    here is to make sure things are bound right with Knockout. You will also see that
    it is declaring all the libraries it needs upfront, based on the array list with
    the settings in our `require.config.js` file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`RequireJS define`方法，这里不需要返回，因为这里的目的是确保与Knockout正确绑定。你还会看到它提前声明了它需要的所有库，基于我们`require.config.js`文件中的设置列表。
- en: The next thing you will see is the dynamic page components being registered.
    We only have one page at this time, so if you look in the `page`/`home` folder,
    you will see `home.js` and `view.html` as the files located there. We will look
    at those shortly, but they are the `viewModel` and `template` items for our page
    component.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你会看到动态页面组件的注册。目前我们只有一个页面，所以如果你查看`page/home`文件夹，你会看到`home.js`和`view.html`作为那里找到的文件。我们很快就会查看这些文件，但它们是我们页面组件的`viewModel`和`template`项。
- en: 'Another aspect common to most SPAs is routing. The other JavaScript libraries
    handle this, and that is what is being bound to our global binding via the `route`
    attribute. All of this working together called that "less-than-awesome" page in
    the previous screenshot. The `router` file is the last piece of core pieces we
    need to work with as we build out, expanding our SPA. Let''s look at its code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数单页应用（SPA）的共同特点之一是路由。其他JavaScript库处理这个问题，这就是通过`route`属性绑定到我们的全局绑定。所有这些共同工作，在之前的截图中被称作“不那么出色”的页面。`router`文件是我们构建SPA时需要处理的最后一个核心组件。让我们看看它的代码：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Again, we see the `define` method in action here, keeping dependencies properly
    managed. There is also the routing which includes routes, or will include routes.
    At this time, there is only one route, and that is to our home page view. This
    is where we will be handling more page views. The rest of the code here is needed
    for the routes to function, but you don't have to understand it any more than
    you have to understand jQuery core code to use jQuery. So, if you want to explore
    it, you are welcome to do so. Otherwise, just focus on what you need to know,
    which is the routes array segment of this code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们看到`define`方法在这里发挥作用，正确地管理了依赖关系。还有路由，包括路由，或者将包括路由。目前，只有一个路由，那就是我们的主页视图。这就是我们将处理更多页面视图的地方。这里的其他代码是路由功能所需的，但你不需要比理解jQuery核心代码更多地去理解它。所以，如果你想探索它，欢迎你这样做。否则，只需专注于你需要知道的内容，那就是这段代码中的路由数组部分。
- en: Adding navigation
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加导航
- en: 'We need to do two things to add the navigation. The component for navigation
    has already been created, so we are just adding it into our SPA solution. First,
    open the `startup.js` file in the `app` folder. Under the general components comment,
    add this line of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加导航，我们需要做两件事。导航组件已经创建好了，所以我们只是将其添加到我们的SPA解决方案中。首先，打开`app`文件夹中的`startup.js`文件。在通用组件注释下，添加以下代码行：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We need to register components before they are called, and this is where we
    are doing that in our SPA. Now, we will be able to add the `nav-bar` tag to the
    top of the `body` section of our body on the `index.html` file as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在调用组件之前注册它们，这就是我们在SPA中做这件事的地方。现在，我们将在`index.html`文件的`body`部分顶部添加`nav-bar`标签，如下所示：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Oh, while that does cover code, there is one more thing needed. To show our
    navigation, we need to take the content and the page view, and move it down enough
    to show the navigation. We put an ID of the page onto the element; so, open the
    `css/style.css` file and enter this code there:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，虽然那覆盖了代码，但还需要一件事。为了显示我们的导航，我们需要将内容和页面视图向下移动足够的空间以显示导航。我们在元素上放置了一个页面ID；所以，打开`css/style.css`文件并输入以下代码：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Go ahead and save and close that file as we will not need it again in this
    exercise. We now have a basic navigation bar for our SPA. This is how things look
    now:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，保存并关闭这个文件，因为我们在这个练习中不再需要它了。我们现在有了SPA的基本导航栏。现在事情看起来是这样的：
- en: '![Adding navigation](img/1028OS_06_11.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![添加导航](img/1028OS_06_11.jpg)'
- en: Adding pages
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加页面
- en: 'Let''s add an **About** page next. The **About** page will be different from
    our **Home** page because it will only contain static content. We will not be
    binding to `viewModel` this time. In the `startup.js` file, under the static page
    components comment, add this code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个**关于**页面。**关于**页面将不同于我们的**主页**，因为它将只包含静态内容。这次我们不会绑定到`viewModel`。在`startup.js`文件中，在静态页面组件注释下，添加以下代码：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Notice we are only adding in a template, with no `viewModel`. We also need
    to add the link to our navigation. The code here is based on the use of Bootstrap.
    This is the code we would add after the home link in the code in the `components/nav-bar/nav-bar.html`
    file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们只添加了一个模板，没有`viewModel`。我们还需要添加导航的链接。这里的代码基于Bootstrap的使用。这是我们在`components/nav-bar/nav-bar.html`文件中的代码之后添加的：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: I like how easy it is to manage the active setting based on whether this route
    matches this page. If you look at the component we registered and the `route().page`
    comparison, you will see that the values will make the page active when they match.
    There is one more thing we will need to have our `about` page work—the `about`
    page component itself. In the `page` folder, copy the `_base` file as `about`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢根据这个路由是否匹配这个页面来管理活动设置有多简单。如果你看看我们注册的组件和`route().page`的比较，你会看到当它们匹配时，值会使页面变得活跃。我们还需要做一件事才能让`about`页面工作——那就是`about`页面组件本身。在`page`文件夹中，将`_base`文件复制为`about`。
- en: 'The last thing to do to create a new page is to add the page to our `Router`
    array, which is in the `app`/`router.js` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新页面的最后一件事是将页面添加到我们的`Router`数组中，该数组位于`app`/`router.js`文件中：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is what our page looks like when we select the `about` navigation item.
    (If you are having problems getting it to show, reload the application to make
    it work once changes have been made.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们选择`about`导航项时页面的样子。（如果你遇到显示问题，请重新加载应用程序，一旦更改后它就会工作。）
- en: '![Adding pages](img/1028OS_06_12.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![添加页面](img/1028OS_06_12.jpg)'
- en: Notice the highlighting works wonderfully, giving the user feedback to validate
    the page they are actually viewing. The static content on this page and the dynamic
    content on the home page give us the foundation to understand how to build SPA
    sites. Yet, we can do better than that. We are going to add in a page that will
    allow us to update the Bootstrap skin that we are using to view the site.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意高亮显示工作得非常好，为用户提供反馈以验证他们实际查看的页面。本页面的静态内容和主页面的动态内容为我们理解如何构建SPA网站奠定了基础。然而，我们可以做得更好。我们将添加一个页面，允许我们更新用于查看网站的Bootstrap皮肤。
- en: Time for some custom style
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制样式的时间
- en: 'We will start off by listing the things we do when we are adding another page
    to this form of Knockout-based SPA site:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从列出我们在向这种基于Knockout的SPA网站添加另一个页面时做的事情开始：
- en: Add a page component registration to the `startup.js` file in the `app` folder.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面组件注册添加到`app`文件夹中的`startup.js`文件。
- en: Add a menu item in the `nav-bar` tag if desired.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，在`nav-bar`标签中添加一个菜单项。
- en: Add the router configuration to the `router.js` file in the `app` folder.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由配置添加到`app`文件夹中的`router.js`文件。
- en: Create a new page in the `page` folder with appropriate files for `viewModel`
    and `template` code.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`page`文件夹中创建一个新页面，并添加适当的`viewModel`和`template`代码文件。
- en: 'Here is the code for the first three steps. First is the registration code
    for the `startup.js` file. Add this right after the `home-page` component registration,
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前三个步骤的代码。首先是`startup.js`文件的注册代码。在`home-page`组件注册之后立即添加此代码，如下所示：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then we will add the following code to the `nav-bar` component:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加以下代码到`nav-bar`组件中：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Next, we will add the following code to that `router.js` file so our system
    knows how to handle the new routed item.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向那个`router.js`文件添加以下代码，以便我们的系统知道如何处理新的路由项。
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The final phase, of course, will be creating the actual page component files.
    Again, we will copy the `_base` folder. This time, rename the copy as `boostrap`.
    Inside the folder, rename the `_base.js` file as `bootstrap.js` and you will be
    ready to code. Here is the `template` code to get started. Place this code in
    the `view.html` file under the `page`/`bootstrap` folder as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最后一阶段将是创建实际的页面组件文件。再次，我们将复制`_base`文件夹。这次，将复制的文件夹重命名为`boostrap`。在文件夹内，将`_base.js`文件重命名为`bootstrap.js`，然后你就可以开始编码了。以下是开始时的`template`代码。将此代码放置在`page`/`bootstrap`文件夹下的`view.html`文件中，如下所示：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will be our `viewModel` code to place in the `boostrap.js` file under
    the `page`/`bootstrap` folder:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是放置在`page`/`bootstrap`文件夹下的`boostrap.js`文件中的`viewModel`代码：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, when we run this code, here is the view we get after clicking on the **Bootstrap**
    nav menu. Ah, wait! Before saving the screenshot, it appeared to me that the header
    of the template was not visible. My CSS had not been saved, so the offset was
    not working right. Now, with the correction made, here is the correct view. You
    should find that the other views will also show correctly now. How many of you
    caught that looking at my screenshots? Here again, we will show the screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行此代码时，点击**Bootstrap**导航菜单后，我们得到以下视图。啊，等等！在保存截图之前，我注意到模板的标题不可见。我的CSS尚未保存，因此偏移没有正确工作。现在，经过修正，以下是正确的视图。你应该会发现其他视图现在也会正确显示。有多少人在看我的截图时注意到了这一点？在这里，我们再次将截图展示出来：
- en: '![Time for some custom style](img/1028OS_06_13.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![定制样式的时间](img/1028OS_06_13.jpg)'
- en: 'That certainly looks better. It is also starting to shape up and offer a promising
    site. We need to go in and modify our ViewModel to make this page highly functional.
    Before we do that, we need to actually go back to the main `index.html` file and
    add an `id` attribute to the page style tag as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实看起来更好。它也开始成形，并呈现出一个有希望的网站。我们需要进入并修改我们的ViewModel，使这个页面功能强大。在我们这样做之前，我们需要实际回到主`index.html`文件，并给页面样式标签添加一个`id`属性，如下所示：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will allow us to use jQuery to target and update the page style for the
    page. Yes, we are using jQuery here and not Knockout. It still happens. Now, in
    the `boostrap.js` file, replace the message variable with the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们使用jQuery来定位和更新页面样式。是的，我们在这里使用jQuery而不是Knockout。这种情况仍然会发生。现在，在`boostrap.js`文件中，将消息变量替换为以下代码：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice that we have used a slash as a line break to continue coding on the next
    line. Some of us are familiar with that shortcut, but others may appreciate the
    tip if they are not.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用斜杠作为换行符来在下一行继续编码。我们中的一些人熟悉这个快捷键，但其他人如果不知道这个技巧可能会感到高兴。
- en: We then add the `theme`, `themes`, and `themesVisible` attributes to our ViewModel.
    We will also need a couple of methods added to the page. These will be the `loadThemes`
    and `changeTheme` methods.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着添加`theme`、`themes`和`themesVisible`属性到我们的ViewModel中。我们还需要在页面上添加几个方法。这些将是`loadThemes`和`changeTheme`方法。
- en: 'The `loadThemes` method will be pulling a JSON-based data file, AJAX style.
    Again, we will be using jQuery for this functionality. Here is the content of
    the JSON file. I would suggest just copying the file over from the matching SPA
    if you are not a perfect typist. This will also go into the `page`/`bootstrap`
    folder:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadThemes`方法将拉取一个基于JSON的数据文件，采用AJAX风格。我们还将使用jQuery来实现这个功能。以下是JSON文件的内容。如果你不是打字高手，我建议直接从匹配的SPA复制文件。这也会进入`page`/`bootstrap`文件夹：'
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we need to add the rest of the code to the `bootstrap.js` file in the
    `page`/`bootstrap` folder. First, we will add the `loadThemes` method. Here is
    the code for that:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将剩余的代码添加到`page`/`bootstrap`文件夹中的`bootstrap.js`文件中。首先，我们将添加`loadThemes`方法。以下是该方法的代码：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This code will pull the data and push the data right into the data-bound themes
    array. Notice that we also included some code to show a very basic concept of
    exception handling. Now, add the code for the `changeTheme` function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会将数据拉取并直接推送到数据绑定的主题数组中。请注意，我们还包含了一些代码来展示异常处理的基本概念。现在，添加`changeTheme`函数的代码：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We will be able to bind these methods in `viewModel` to handle event triggers
    in our template code. There is one extra thing though that we need to handle this
    functionality. Notice `vm.bg(data.bg)` at the end of that method. We are setting
    the value of the incoming item to set a global variable. It tells the system whether
    the background we are using is a light or dark background. We won''t be using
    that yet, but we are creating it now to be used shortly. In order to do that,
    we need to add the following bit of code to our main site `starup.js` file in
    the `app` folder:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够在`viewModel`中绑定这些方法来处理模板代码中的事件触发。不过，我们还需要处理这个功能的一个额外问题。注意方法末尾的`vm.bg(data.bg)`。我们正在设置传入项的值来设置一个全局变量。它告诉系统我们使用的背景是浅色还是深色背景。我们目前不会使用它，但现在我们正在创建它以便稍后使用。为了做到这一点，我们需要在`app`文件夹中的主站`starup.js`文件中添加以下代码段：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now we can add our template code to the `view.html` file below the existing
    code. Notice that the button visibility is managed to improve user experience.
    When our data is loaded, we make the button invisible. We are also wiring the
    click method of the images to the `changeTheme` method on our `viewModel` component.
    At this time, there is no base variable alias for the component base, so we will
    use the `$parent` alias to target the method on the parent level of this data
    structure. Take a look at the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`view.html`文件中添加我们的模板代码，位于现有代码下方。请注意，按钮的可见性被管理以改善用户体验。当我们的数据加载完成后，我们将按钮设置为不可见。我们还将图像的点击方法连接到`viewModel`组件上的`changeTheme`方法。此时，组件没有基础变量别名，因此我们将使用`$parent`别名来定位此数据结构父级的方法。看看下面的代码：
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Okay, we are all wired up now. If you have issues, compare the code to the
    code in the `SPA` folder as that is working and is from where the example code
    for this rebuild practice exercise came. Here is the initial screenshot when reloading
    and selecting the Bootstrap navigation item:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在都已经连接好了。如果你有问题，可以将代码与`SPA`文件夹中的代码进行比较，因为那里的是正常工作的，并且是这次重构练习示例代码的来源。以下是重新加载并选择Bootstrap导航项时的初始截图：
- en: '![Time for some custom style](img/1028OS_06_14.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![定制样式的时间](img/1028OS_06_14.jpg)'
- en: Oh, if you do not recognize them, these skin styles are open source styles offered
    by [bootswatch.com](http://bootswatch.com) for us to use. They also have commercial
    solutions there.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，如果你不认识它们，这些皮肤样式是由[bootswatch.com](http://bootswatch.com)为我们提供的开源样式。那里也有商业解决方案。
- en: 'Now, we will click on the button to load our themes from the JSON-based data.
    This also could have been a live dynamic server location URL. This is what we
    get after clicking on the button:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将点击按钮来从基于JSON的数据中加载我们的主题。这也可以是一个实时动态服务器位置URL。点击按钮后，我们得到以下内容：
- en: '![Time for some custom style](img/1028OS_06_15.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![定制样式时间](img/1028OS_06_15.jpg)'
- en: 'If we scroll down and click on **Superhero** and move our mouse, this is what
    we will see:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向下滚动并点击**超级英雄**，然后移动鼠标，我们会看到以下内容：
- en: '![Time for some custom style](img/1028OS_06_16.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![定制样式时间](img/1028OS_06_16.jpg)'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I'm not sure why we have to move the mouse, but that will work most of the time;
    we would figure out an instant update if it was a live website, of course.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定为什么我们必须移动鼠标，但大多数情况下这会起作用；当然，如果这是一个实时网站，我们会找出即时更新的方法。
- en: Now we are able to update the styles by choice on demand. If you move to different
    pages, you will see that the look stays. If this were a live login site, we would
    use AJAX to store the user style choices back on the server. We could also choose
    to store them in cookie variables, but then if the user goes to another machine,
    their choices will not travel with them. This is why we suggest you store them
    on a server when possible.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据需要选择性地更新样式。如果你切换到不同的页面，你会看到外观保持不变。如果这是一个实时登录网站，我们会使用AJAX将用户样式选择存储回服务器。我们也可以选择将它们存储在cookie变量中，但这样如果用户切换到另一台机器，他们的选择将不会随之移动。这就是为什么我们建议尽可能将它们存储在服务器上。
- en: Bonus item
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 奖励项目
- en: 'Oh, we have a bonus for this part of the book. This book is based on Knockout
    3.2, but there is a nice change proposed for Knockout 3.3 that will let us address
    the component code with a component alias. It is very simple to update our code
    to try that out. First, we need to go to the `require.config.js` file in the `app`
    folder and make one change. We have to change the file the Knockout alias is targeting
    like so:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这本书的这一部分有一个奖励。这本书基于Knockout 3.2，但Knockout 3.3提出了一个很好的变更，这将允许我们使用组件别名来处理组件代码。更新我们的代码以尝试这个功能非常简单。首先，我们需要前往“app”文件夹中的“require.config.js”文件并做出一个更改。我们必须更改Knockout别名所指向的文件，如下所示：
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Then, we jump back into our `view.html` file in the `bootstrap` folder and change
    the `$parent` variable to `$component`. Next, we run our code again, which should
    work fine. This is more practical code, and if the data structure in a component
    were more complex, this pragmatic alias would just keep the code as simple as
    it should.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回到“bootstrap”文件夹中的“view.html”文件，将“$parent”变量更改为“$component”。接下来，我们再次运行我们的代码，它应该可以正常工作。这是一段更实用的代码，如果组件中的数据结构更复杂，这种实用的别名将使代码尽可能简单。
- en: Building cross-page interaction
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建跨页面交互
- en: When we did our Bootstrap page, we loaded the data on demand. This means it
    did not load till the user clicked and told the themes to load. In this page,
    the data will instantly, automatically load onto the page. It seemed helpful to
    show both approaches to save you from having to figure these options out.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建Bootstrap页面时，我们按需加载数据。这意味着它不会在用户点击并告诉主题加载之前加载。在这个页面上，数据将立即、自动加载到页面上。展示这两种方法似乎很有帮助，可以让你不必自己弄清楚这些选项。
- en: We will be using a jQuery page this time. We choose that for a couple of reasons.
    Firstly, we happen to appreciate all jQuery has done for the community over the
    years. The second reason is we noticed they have dark and light logo styles. We
    borrowed their graphics to show what they would look like on a dark Boostrap theme
    as well as on a light Bootstrap theme.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将使用jQuery页面。我们选择它有几个原因。首先，我们恰好欣赏jQuery多年来为社区所做的一切。第二个原因是，我们注意到他们有深色和浅色标志样式。我们借用了他们的图形来展示它们在深色Bootstrap主题以及浅色Bootstrap主题上的样子。
- en: 'Here is the code for our jQuery page. First is the registration code for the
    `startup.js` file. Add this code after the Bootstrap registration:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是jQuery页面的代码。首先是“startup.js”文件的注册代码。在Bootstrap注册后添加此代码：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then we will add the following code to the `nav-bar` component:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将添加以下代码到“nav-bar”组件中：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we will add this code to the `router.js` file so our system knows how
    to handle the new routed item. This is the full router section of code at this
    point:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把这段代码添加到“router.js”文件中，以便我们的系统知道如何处理新的路由项。到目前为止，这是完整的路由代码部分：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The final phase, of course, will be creating the actual page component files.
    Again, we will copy the `_base` folder. This time, rename the copy as `jquery`.
    Inside the folder, rename the `_base.js` file as `jquery.js` and you will be ready
    to code. We also have files to pull over from the working version of this SPA.
    We will be pulling the `data.json` file and the `logos` folder.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最后一阶段将是创建实际的页面组件文件。再次，我们将复制`_base`文件夹。这次，将复制品重命名为`jquery`。在文件夹内，将`_base.js`文件重命名为`jquery.js`，然后你就可以开始编码了。我们还有从SPA的工作版本中拉取的文件。我们将拉取`data.json`文件和`logos`文件夹。
- en: 'We can now edit our `viewmodel` file first. Here is the code for the `jquery.js`
    file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以首先编辑我们的`viewmodel`文件。以下是`jquery.js`文件的代码：
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We again have our `defined` method, which takes the values of the two items
    and passes them into the function as parameters. The declarations are straightforward
    with one difference. This time, we are passing the results of a `jQuery JSON`
    request into the `self.project` binding. We again have a very basic exception
    handling, in case there are exceptions, as they are part of awesome coding. This
    time, the method we are creating in this component is a method to set the logo
    name. Here is our `view.html` code so we can look at how it was integrated. Note
    that inside the method, we are again using the main SPA `viewModel` binding to
    pull the light or dark background:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次有我们的`defined`方法，它接受两个项目的值并将它们作为参数传递给函数。声明很简单，只有一个区别。这次，我们将`jQuery JSON`请求的结果传递到`self.project`绑定中。我们再次有非常基本的异常处理，以防出现异常，因为它们是优秀编码的一部分。这次，我们在组件中创建的方法是设置标志名称的方法。以下是我们的`view.html`代码，这样我们可以查看它是如何集成的。注意，在方法内部，我们再次使用主要的SPA
    `viewModel`绑定来拉取浅色或深色背景：
- en: '[PRE63]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we see our template will loop through each project that was returned from
    our AJAX call to the JSON data. Notice that we are using the `$component` item
    for the logo. If you are still not using Knockout 3.3 alpha code, or need to deploy
    with something else, you should change that back to `$parent` to make sure it
    works correctly without that enhancement. Otherwise, this is standard template
    code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们的模板将遍历从我们的AJAX调用返回的每个项目。请注意，我们正在使用`$component`项作为标志。如果你还没有使用Knockout
    3.3 alpha代码，或者需要使用其他东西进行部署，你应该将其改回`$parent`以确保在没有该增强功能的情况下也能正确工作。否则，这是标准的模板代码。
- en: 'With this in place, here is what the jQuery page will look like with a fresh
    reload and selection of the jQuery navigation tab:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，以下是使用jQuery导航标签进行刷新后的jQuery页面外观：
- en: '![Building cross-page interaction](img/1028OS_06_17.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![构建跨页面交互](img/1028OS_06_17.jpg)'
- en: 'By default, the setting for the background is set to light and the logos it
    shows are the lighter logos. Now, we will jump to the Bootstrap page and select
    a darker style. This is what it will look like with the style we select:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，背景设置为浅色，显示的标志也是浅色标志。现在，我们将跳转到Bootstrap页面并选择较深的样式。以下是选择该样式后的外观：
- en: '![Building cross-page interaction](img/1028OS_06_18.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![构建跨页面交互](img/1028OS_06_18.jpg)'
- en: Now we have a very nice looking app to show off. While it may not do everything
    you have seen on any website, what it does will impress many a client or friend.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个非常漂亮的程序可以展示。虽然它可能无法做到你在任何网站上看到的所有事情，但它所做到的将会给许多客户或朋友留下深刻印象。
- en: What next?
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: There are many plugins and ways to package and advance your abilities as a developer
    using Knockout. I will be opening up a resource at [http://knockout.developers.zone](http://knockout.developers.zone)
    where we will be sharing links and tips, and hope to have a meet-up or two over
    the next year for fellow Knockout developers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多插件和方式可以包装和提升你作为Knockout开发者的能力。我将在[http://knockout.developers.zone](http://knockout.developers.zone)上开放一个资源，我们将分享链接和技巧，并希望在未来一年内为Knockout开发者举办一两次聚会。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has pulled together concepts from every chapter and shown the awesome
    power of templates working together with ViewModels within Knockout components.
    You should now have an awesome foundation to do more with less than ever before.
    You should know how to mingle your jQuery code with the Knockout code side by
    side.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本章汇集了每个章节的概念，并展示了模板与Knockout组件中的ViewModel协同工作的强大功能。你现在应该有一个坚实的基础，可以以前所未有的方式做更多的事情。你应该知道如何将jQuery代码与Knockout代码并排混合。
- en: To review, in this chapter, we learned what Knockout components are. We learned
    how to use the components to create custom HTML elements that are interactive
    and powerful. We learned how to enhance custom elements to allow variables to
    be managed using the more common attributes approach. We learned how to use an
    AMD-style approach to coding with Knockout. We also learned how to AJAX everything
    and integrate jQuery to enhance Knockout-based solutions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章内容，我们学习了Knockout组件是什么。我们学习了如何使用这些组件来创建交互性强且功能强大的自定义HTML元素。我们还学习了如何增强自定义元素，以便使用更常见的属性方法来管理变量。此外，我们还学习了如何使用AMD风格的编码方式与Knockout结合。同时，我们也学习了如何使用AJAX进行一切操作，并将jQuery集成到基于Knockout的解决方案中。
- en: Many people struggle to understand the concept of SPA or single-page application
    sites. We were able to create a single-page application that provides understanding
    and perspective. In fact, this could be the beginning of your next site.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人努力理解SPA或单页应用网站的概念。我们已经能够创建一个提供理解和视角的单页应用。实际上，这可能是你下一个网站的起点。
- en: What's next? That is up to you. One thing is for sure, the possibilities are
    broader using Knockout than they were before. Happy coding and congratulations
    on completing your study of KnockoutJS!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是什么？这取决于你。有一点可以肯定，使用Knockout的可能性比之前更广泛。祝您编码愉快，并祝贺您完成KnockoutJS的学习！
