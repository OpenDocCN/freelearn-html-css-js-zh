- en: Chapter 3. Accessing Server Data with Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：使用模型访问服务器数据
- en: 'In this chapter, you''ll learn how to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Use `Model`, Backbone's main class to work with data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Backbone 的主要类 `Model` 来处理数据
- en: Create new `Model` subclasses
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的 `Model` 子类
- en: Get and set `Model` attributes and trigger other code when these attributes
    change
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和设置 `Model` 属性，并在这些属性发生变化时触发其他代码
- en: Store these attributes to a remote server and retrieve them from the server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些属性存储到远程服务器并从服务器检索它们
- en: Use the several convenience methods that `Model` has borrowed from Underscore
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Model` 从 Underscore 借用的几个便利方法
- en: The purpose of Models
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型的目的
- en: '**Models** in Backbone are the core of all data interactions, both within the
    client code itself and when communicating with a remote server. While one can
    simply use a plain JavaScript object instead of a `Model`, Models offer three
    major advantages:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型** 在 Backbone 中是所有数据交互的核心，无论是客户端代码内部还是与远程服务器通信时。虽然可以使用普通的 JavaScript 对象代替
    `Model`，但模型提供了三个主要优势：'
- en: Models use Backbone's class system, making it easy to define methods, create
    subclasses, and so on
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型使用 Backbone 的类系统，这使得定义方法、创建子类等变得容易
- en: Models allow other code to listen for and respond to changes in the `Model`
    attributes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型允许其他代码监听并响应 `Model` 属性的变化
- en: Models simplify and encapsulate the logic used to communicate with the server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型简化并封装了与服务器通信所使用的逻辑
- en: 'As discussed in the previous chapter, we can create our own subclass of Model
    using `extend`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，我们可以使用 `extend` 创建自己的 `Model` 子类：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we''ve created that class, we can instantiate new `Model` instances using
    JavaScript''s `new` keyword, and (optionally) we can pass in an initial set of
    attributes and options, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了那个类，我们可以使用 JavaScript 的 `new` 关键字实例化新的 `Model` 对象，并且（可选地）我们可以传入一组初始属性和选项，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Attributes, options, and properties
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性、选项和属性
- en: 'When we talk about attributes in Backbone, they often sound similar to regular
    JavaScript properties. After all, both attributes and properties are key-value
    pairs stored on a `Model` object. The difference between the two is that attributes
    aren''t (in a technical sense) actually properties of a Model at all; instead,
    they are the properties of a property of a `Model`. Each `Model` class has a property
    called `attributes`, and the attributes themselves are stored as properties of
    that `attributes` property. Take an example of the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论 Backbone 中的属性时，它们通常听起来与常规 JavaScript 属性很相似。毕竟，属性和属性都是存储在 `Model` 对象上的键值对。这两者之间的区别在于，属性在技术意义上根本不是模型的属性；相反，它们是模型属性的一个属性的属性。每个
    `Model` 类都有一个名为 `attributes` 的属性，而属性本身则存储在那个 `attributes` 属性的属性中。以下是一个代码片段的例子：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Attributes versus Properties**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性与属性**'
- en: As shown in the preceding code snippet, Backbone's `Models` class can also have
    regular, nonattribute properties. If you need to store a piece of data in a Model,
    you can choose between using a property or an attribute. In general, you should
    use an attribute only when the data is going to be synced to the server or when
    you want other parts of your code to be able to listen for data changes. If your
    data doesn't meet these requirements, it's best to store it as a regular JavaScript
    property instead of as an attribute, because storing such data as an attribute
    will create more work for you when you save the `Model` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '如前述代码片段所示，Backbone 的 `Models` 类也可以有常规的非属性属性。如果您需要在模型中存储一些数据，您可以选择使用属性或属性。通常，只有当数据将要同步到服务器或您希望代码的其他部分能够监听数据变化时，才应使用属性。如果您的数据不满足这些要求，最好将其作为常规
    JavaScript 属性而不是属性存储，因为将此类数据作为属性存储将在保存 `Model` 类时给您带来更多的工作。 '
- en: On a purely conceptual level, any of the core persistent information that a
    `Model` class is designed to hold belongs in its attributes, while any information
    that is secondary or derived, or which is only designed to last until the user
    refreshes the page, should be stored as properties.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯粹的概念层面上，任何 `Model` 类设计用来存储的核心持久信息都应该属于其属性，而任何次要的或派生的信息，或者仅设计在用户刷新页面之前持续存在的信息，应该作为属性存储。
- en: 'If you want to pass in attributes when you create a new `Model` class, you
    can simply provide them as the first argument and Backbone will automatically
    add them. You can also define default attributes, which all new `Models` of that
    class will have, using the defaults property when you extend your `Model` class,
    as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在创建新的`Model`类时传递属性，你可以简单地将其作为第一个参数提供，Backbone会自动添加它们。你还可以在扩展你的`Model`类时定义默认属性，这样所有新的`Model`都将具有这些属性，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is important to remember, however, that in JavaScript, objects are passed
    by reference, which means that any object you provide in `defaults` will be shared
    with, not copied between, instances of your `Model` class. In other words, check
    out the following code snippet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要记住，在JavaScript中，对象是通过引用传递的，这意味着你提供的任何对象将与你的`Model`类的实例共享，而不是在实例之间复制。换句话说，看看以下代码片段：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since you probably don't want changes to one Model affecting your other Models,
    you should avoid setting objects in defaults. If you really need to set an object
    as a default, you can do so in the Model's `initialize` method or by using a more
    advanced function-based form of defaults, which we'll cover later on in [Chapter
    7](part0069.xhtml#aid-21PMQ1 "Chapter 7. Fitting Square Pegs in Round Holes –
    Advanced Backbone Techniques"), *Fitting Square Pegs in Round Holes – Advanced
    Backbone Techniques*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可能不希望对一个模型所做的更改影响到你的其他模型，因此你应该避免在默认设置中设置对象。如果你确实需要将一个对象作为默认值设置，你可以在模型的`initialize`方法中这样做，或者使用更高级的基于函数的默认形式，我们将在[第7章](part0069.xhtml#aid-21PMQ1
    "第7章。将方钉嵌入圆孔 - 高级Backbone技术")中介绍，*将方钉嵌入圆孔 - 高级Backbone技术*。
- en: 'While setting default attributes for Models is easy, the same cannot be said
    about adding default direct properties to a Model when it is first created. The
    best way to set these properties is to use the Model''s `initialize` method. For
    instance, if you want to set a `renderBlackAndWhite` property when you create
    a `Book` Model, you can do what is described in the following code snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然为模型设置默认属性很容易，但为模型首次创建时添加默认直接属性则不然。设置这些属性的最佳方式是使用模型的`initialize`方法。例如，如果你想在你创建`Book`模型时设置`renderBlackAndWhite`属性，你可以按照以下代码片段中描述的操作进行：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code sets the `renderBlackAndWhite` property of each newly created
    book to the `renderBlackAndWhite` option passed in when the book is created.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将每个新创建的书的`renderBlackAndWhite`属性设置为在创建书时传入的`renderBlackAndWhite`选项。
- en: Getters and setters
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: 'While the `attributes` property is (behind the scenes) just a JavaScript object,
    that doesn''t mean that we should treat it as such. For instance, you should never
    set an attribute directly by changing the *attributes* property of a `Model` class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`attributes`属性（在幕后）只是一个JavaScript对象，但这并不意味着我们应该将其视为这样的对象。例如，你永远不应该通过直接更改`Model`类的`attributes`属性来设置属性：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Instead, the attributes of Backbone''s `Models` should be set using the Model''s
    `set` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Backbone的`Model`的属性应该使用模型的`set`方法设置：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `set` method has two forms or *signatures*. The first (shown previously)
    takes two arguments: one for the data''s key and one for its value. This form
    is great if you only want to set one value at a time, but if you need to set multiple
    values, you can use the second form instead, which takes only a single argument
    containing all the values of `set`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`方法有两种形式或*签名*。第一种（之前已展示）接受两个参数：一个用于数据的键，一个用于其值。如果你只想一次设置一个值，这种形式非常好，但如果你需要设置多个值，你可以使用第二种形式，它只接受一个包含所有`set`值的参数：'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In addition, Models also have an `unset` method, which takes only a single
    *key* argument and works in a similar way as JavaScript''s `delete` statement,
    except that it also lets any code listening to the Model known about the change:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模型还有一个`unset`方法，它只接受一个*键*参数，其工作方式与JavaScript的`delete`语句类似，但除此之外，它还允许任何监听模型的代码知道这个变化：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you might have guessed, retrieving attributes through Backbone is done using
    the `get` method, which takes only a single *key* argument and returns the value
    for that key:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，通过Backbone检索属性是通过使用`get`方法完成的，它只接受一个*键*参数，并返回该键的值：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `get` method is very simple; I''d actually like to show its entire source
    code here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法非常简单；我实际上想在这里展示它的整个源代码：'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, you may be thinking, if that's all there is to get, why not just use the
    `attributes` object directly? After all, there's no difference, right?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能正在想，如果这就是`get`的全部内容，为什么不直接使用`attributes`对象呢？毕竟，它们之间没有区别，对吧？
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In fact, there are two benefits of using the `get` method, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用`get`方法有两个好处，如下所示：
- en: The first benefit is that using `get` makes your code slightly short and more
    readable as well as more consistent since your `get` calls will match your `set`
    calls.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个好处是使用`get`可以使你的代码更短，更易读，并且更一致，因为你的`get`调用将与你的`set`调用相匹配。
- en: The second benefit, and only a programmatic advantage, is that using `get` offers
    the option of future extensibility. Like many Backbone methods, `get` is not just
    designed for out of the box use but also for extension by you, the Backbone developer.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个好处，并且仅限于程序性优势，是使用`get`提供了未来可扩展性的选项。像许多Backbone方法一样，`get`不仅是为了即插即用而设计，也是为了由你，Backbone开发者，进行扩展。
- en: Let's imagine for a moment that you are building a Backbone application, and
    one day, you realize that you need to know when some piece of code accesses a
    certain attribute. Maybe, you find the need to do so as you're adding auditing
    or logging capabilities, or maybe you're just trying to debug a tricky problem.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时想象一下，你正在构建一个Backbone应用程序，有一天，你意识到你需要知道何时某些代码访问了某个属性。也许，当你添加审计或日志功能时，你需要这样做，或者你可能只是试图调试一个棘手的问题。
- en: If you've written your application to access attributes directly, you'll need
    to find every place in your code that gets an attribute and then update that code.
    However, if you have already been using the `get` method, you can simply override
    the `get` method on the relevant `Model` (or `Models`) to tap in to all of your
    existing `get` logic from a single place in the code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经编写了直接访问属性的应用程序，你需要找到代码中获取属性的所有地方，然后更新这些代码。然而，如果你已经使用`get`方法，你只需简单地覆盖相关`Model`（或`Models`）上的`get`方法，就可以从代码的单个位置访问所有现有的`get`逻辑。
- en: Listening for events
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听事件
- en: 'One of the primary advantages of using the `set` and `unset` methods, as we
    just described, is that they allow other parts of your code to listen for changes
    to a Model''s attributes. This works similar to listening for a DOM event in jQuery
    and is done using the `on` and `off` methods of the `Model`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set`和`unset`方法的主要优势之一，正如我们刚才描述的，是它们允许代码的其他部分监听Model属性的变化。这与在jQuery中监听DOM事件类似，并且使用`Model`的`on`和`off`方法来完成：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see in the preceding code, the `on` method, just like jQuery''s,
    takes two arguments: an `event` function and a `callback` function. When the event
    is triggered, Backbone invokes the `callback` function. The event listener can
    be removed using the `off` method. If you want your code to listen for multiple
    events, you can combine them with spaces, as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在前面的代码中看到的那样，`on`方法，就像jQuery一样，接受两个参数：一个`event`函数和一个`callback`函数。当事件被触发时，Backbone会调用`callback`函数。可以使用`off`方法移除事件监听器。如果你想让你的代码监听多个事件，你可以用空格将它们组合起来，如下所示：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Backbone offers one significant improvement over jQuery however, in the form
    of an optional third `context` argument. If this argument is provided, the callback
    will be bound (as if you had used the `_.bind` method mentioned in the previous
    chapter) as it''s registered:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone相较于jQuery有一个显著的改进，那就是可选的第三个`context`参数。如果提供了这个参数，回调将在注册时被绑定（就像你在上一章中提到的`_.bind`方法一样）：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous code, we define an `Author` class with a `listenForDeathOfRival`
    method, which takes a rival (another `Author` class) as an argument and sets up
    a listener for when the rival is destroyed. We pass the original author as the
    `context` argument, so when the callback resolves, its `this` method will be set
    to that author. We then call `listenForDeathOfRival` on `byron` and pass in `keats`
    so that `byron` listens for a destroy event on `keats`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们定义了一个带有`listenForDeathOfRival`方法的`Author`类，该方法接受一个对手（另一个`Author`类）作为参数，并设置一个监听器以在对手被销毁时触发。我们将原始作者作为`context`参数传递，因此当回调解决时，它的`this`方法将被设置为该作者。然后我们在`byron`上调用`listenForDeathOfRival`并传入`keats`，这样`byron`就会监听`keats`上的销毁事件。
- en: When we then trigger Keats' destruction in the final line, we trigger the event
    listener setup by `listenForDeathOfRival`, which gives the alert message. The
    message is able to include both the authors' names because when the callback resolves,
    Keats' name is available from the `rival` variable, while Byron's name is available
    as an attribute of the `Model` (because we passed his Model as the `context` argument
    when we set up the event listener).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在最后一行触发济慈的毁灭时，我们触发了由 `listenForDeathOfRival` 设置的事件监听器，这给出了警报信息。信息能够包含两位作者的名字，因为当回调解析时，济慈的名字可以从
    `rival` 变量中获取，而拜伦的名字则作为 `Model` 的一个属性可用（因为我们设置事件监听器时将他的模型作为 `context` 参数传递）。
- en: Available events
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用事件
- en: '`Models` have several different events available for you to listen to, as shown
    in the following table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Model` 有几个不同的事件可供你监听，如下表所示：'
- en: '| Event name | Trigger |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 事件名称 | 触发器 |'
- en: '| --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `change` | When any attribute of a Model changes |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `change` | 当模型的任何属性发生变化时 |'
- en: '| `change:attribute` | When the specified attribute changes |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `change:attribute` | 当指定的属性发生变化时 |'
- en: '| `destroy` | When the Model is destroyed |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `destroy` | 当模型被销毁时 |'
- en: '| `request` | When an AJAX method of the Model starts |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `request` | 当模型的 AJAX 方法开始时 |'
- en: '| `sync` | When an AJAX method of the Model has completed |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `sync` | 当模型的 AJAX 方法完成时 |'
- en: '| `error` | When an AJAX method of the Model returns an error |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `error` | 当模型的 AJAX 方法返回错误时 |'
- en: '| `invalid` | When validation triggered by a Model''s `save`/`isValid` call
    fails |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `invalid` | 当由模型的 `save`/`isValid` 调用触发的验证失败时 |'
- en: 'There are also several other events that are related to **Collection**, which
    will be explained further in the next chapter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些与 **Collection** 相关的其他事件，将在下一章中进一步解释：
- en: '| Event name | Trigger |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 事件名称 | 触发器 |'
- en: '| --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add` | When the Model is added to a Collection |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `add` | 当模型被添加到集合中时 |'
- en: '| `remove` | When the Model is removed from a Collection |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | 当模型从集合中移除时 |'
- en: '| `reset` | When a Collection that the Model belongs to is reset |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `reset` | 当模型所属的集合被重置时 |'
- en: Models also have one other, special, event called `all`. This event is triggered
    in response when any of the other `Model` events are triggered.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模型还有一个其他特殊的事件，称为 `all`。当其他 `Model` 事件被触发时，将响应触发此事件。
- en: Custom events
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义事件
- en: 'Although you are unlikely to use them very often, you may find it useful to
    create your own custom events on certain occasions. This can be done by using
    the Model''s `trigger` method, which lets you simulate an event coming from the
    `Model`, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不太可能经常使用它们，但在某些场合创建自己的自定义事件可能很有用。这可以通过使用模型的 `trigger` 方法来完成，它允许你模拟来自 `Model`
    的事件，如下所示：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can listen for these events in the way same as any other non-custom event,
    by using the `on` method. Any additional arguments passed to `trigger` (such as
    the `5` in the preceding example) will be passed as arguments to event handlers
    that listen for that event.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `on` 方法以与其他任何非自定义事件相同的方式监听这些事件。传递给 `trigger` 的任何附加参数（如前例中的 `5`）都将作为监听该事件的处理器参数传递。
- en: Server-side actions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端操作
- en: 'Once we''ve filled a `Model` class with data, we might not want to lose that
    data, and that''s where the AJAX features of Model come into play. Every Model
    has three methods to interact with the server, which can be used to generate four
    types of HTTP requests, as shown in the following table:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用数据填充了一个 `Model` 类，我们可能不想丢失这些数据，这就是模型 AJAX 功能发挥作用的地方。每个模型都有三种与服务器交互的方法，可以用来生成四种类型的
    HTTP 请求，如下表所示：
- en: '| Method | RESTful URL | HTTP method | Server action |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | RESTful URL | HTTP 方法 | 服务器操作 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `fetch` | `/books/id` | `GET` | `retrieves data` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `fetch` | `/books/id` | `GET` | 获取数据 |'
- en: '| `save` (for a new `Model`) | `/books` | `PUT` | `sends data` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `save`（对于新的 `Model`） | `/books` | `PUT` | 发送数据 |'
- en: '| `save` (for an existing `Model`) | `/books/id` | `POST` | `sends data` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `save`（对于现有的 `Model`） | `/books/id` | `POST` | 发送数据 |'
- en: '| `destroy` | `/books/id` | `DELETE` | `deletes data` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `destroy` | `/books/id` | `DELETE` | 删除数据 |'
- en: The sample URLs in the preceding table are what Backbone will generate by default
    when it tries to perform any of the three AJAX methods. Backbone works best with
    a set of server-side APIs that are organized using this RESTful architecture.
    The basic idea of a RESTful server-side API is that it is made up of URL endpoints
    that expose various resources for the client to consume.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上面表格中的示例 URL 是 Backbone 在尝试执行任何三种 AJAX 方法时默认生成的。Backbone 与使用这种 RESTful 架构组织的服务器端
    API 配合得最好。RESTful 服务器端 API 的基本思想是它由客户端可以消费的各种资源的 URL 端点组成。
- en: The different HTTP methods are used in such an architecture to control which
    action the server should take with that resource. Thus, to delete a book with
    an ID of 7, a RESTful API will expect a `DELETE` request to `/books/7`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种架构中，不同的 HTTP 方法被用来控制服务器应该对那个资源采取什么操作。因此，为了删除一个 ID 为 7 的书，RESTful API 预期一个
    `DELETE` 请求到 `/books/7`。
- en: 'Of course, Backbone won''t know that the server-side endpoint for a Book `Model`
    will be `/books` unless you tell it, which you can do by specifying a `urlRoot`
    property:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除非你通过指定一个 `urlRoot` 属性来告诉它，否则 Backbone 不会知道一个 `Book` 模型的服务器端端点将是 `/books`。你可以通过指定一个
    `urlRoot` 属性来完成：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If, for some reason, your server-side API is on a different domain, you can
    also use `urlRoot` method to specify an entirely different domain. For instance,
    to indicate that our `Book` class should use the papers endpoint of [http://www.example.com/](http://www.example.com/),
    we can set `urlRoot` of [http://www.example.com/papers](http://www.example.com/papers).
    This approach will not work on most sites, however, because of cross-site scripting
    limitations imposed by browsers; so, unless you employ special techniques (for
    instance, a server-side proxy), you will most likely want your server-side API
    to be on the same domain that serves your JavaScript files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，你的服务器端 API 在不同的域上，你也可以使用 `urlRoot` 方法来指定一个完全不同的域。例如，为了表明我们的 `Book`
    类应该使用 [http://www.example.com/](http://www.example.com/) 的 papers 端点，我们可以设置 [http://www.example.com/papers](http://www.example.com/papers)
    的 `urlRoot`。然而，由于浏览器强加的跨站脚本限制，这种方法在大多数网站上可能不起作用；因此，除非你采用特殊技术（例如，服务器端代理），否则你很可能希望你的服务器端
    API 在提供你的 JavaScript 文件的同一域上。
- en: If your server-side API isn't RESTful, you can still use Backbone's AJAX capabilities
    by overwriting its built-in `url` method. While the default version of this method
    simply combines the Model's `urlRoot` method with its ID (if any), you can redefine
    it to specify any URL that you'd prefer Backbone to use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务器端 API 不是 RESTful 的，你仍然可以通过覆盖其内置的 `url` 方法来使用 Backbone 的 AJAX 功能。虽然这个方法的默认版本只是简单地将模型的
    `urlRoot` 方法与其 ID（如果有的话）组合起来，但你可以重新定义它来指定你希望 Backbone 使用的任何 URL。
- en: 'For instance, let''s say our book Models have a `fiction` attribute and we
    want to use two different endpoints to save our books: `/fiction` for fiction
    books and `/nonfiction` for nonfiction books. We can override our `url` method
    to tell Backbone as much, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的书模型有一个 `fiction` 属性，我们想要使用两个不同的端点来保存我们的书：`/fiction` 用于小说书籍，`/nonfiction`
    用于非小说书籍。我们可以覆盖我们的 `url` 方法来告诉 Backbone，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Storing URLs on the client
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在客户端存储 URL
- en: 'As we just covered, Backbone allows you to specify any URLs you want for your
    Models. If your site is fairly complex, however, it''s a good idea to store the
    actual URL strings, or even URL-generating functions, in a separate `urls` object.
    Take an example of the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚提到的，Backbone 允许你为你的模型指定任何你想要的 URL。然而，如果你的网站相当复杂，将实际的 URL 字符串或甚至 URL 生成函数存储在单独的
    `urls` 对象中是个好主意。以下是一个代码片段的例子：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'While this is not strictly necessary (and is may be overkill on smaller sites),
    this approach has several benefits on a larger site:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是严格必要的（在较小的网站上可能过于冗余），但在较大的网站上，这种方法有几个好处：
- en: You can easily share URLs between any of your Models
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以轻松地在任何模型之间共享 URL
- en: You easily share URLs between your Models and non-Backbone AJAX calls
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在你的模型和非 Backbone AJAX 调用之间轻松共享 URL
- en: Finding existing URLs is quick and easy
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找现有 URL 快速且简单
- en: If any URL changes, you only have to edit one file
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何 URL 发生变化，你只需要编辑一个文件
- en: Identification
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别
- en: 'Up until now, we''ve avoided the question of how exactly Backbone determines
    what a Model''s ID is. As it turns out, Backbone has a very simple mechanism:
    it uses whatever attribute you specify as the `idAttribute` property of the `Model`
    class. The default `idAttribute` property is simply `id`; so, if the JSON returned
    by your server includes an `id` attribute, you don''t even need to specify an
    `idAttribute` property. However, since many APIs don''t use `id` (for example,
    some use `_id` instead), Backbone watches for changes to its attributes, and when
    it sees an attribute that matches the `idAttribute` property, it will set the
    Model''s special `id` property to that attribute''s value, as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直避免讨论 Backbone 如何确定模型（Model）的确切 ID。实际上，Backbone 有一个非常简单的机制：它使用你指定的作为
    `Model` 类的 `idAttribute` 属性的任何属性。默认的 `idAttribute` 属性仅仅是 `id`；所以，如果你的服务器返回的 JSON
    包含 `id` 属性，你甚至不需要指定 `idAttribute` 属性。然而，由于许多 API 不使用 `id`（例如，一些使用 `_id` 代替），Backbone
    会监视其属性的变化，当它看到与 `idAttribute` 属性匹配的属性时，它将设置模型的特殊 `id` 属性为此属性的值，如下所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition to telling Backbone what URL to use when saving the Model, the
    `ID` attribute also has another function: its absence tells Backbone that the
    Model is new, which you can see if you use the `isNew` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了告诉 Backbone 保存模型时要使用哪个 URL 之外，`ID` 属性还有一个功能：它的缺失告诉 Backbone 模型是新的，你可以通过使用
    `isNew` 方法看到这一点：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This method can also be overridden if you need to use some other mechanism
    to determine whether a `Model` class is new or not. There''s one other issue with
    `isNew` though: if new Models don''t have IDs, how will you identify them? For
    instance, if you were storing a set of `Models` by `ID`, what will you do with
    the new ones?'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用其他机制来确定 `Model` 类是否为新实例，此方法可以被覆盖。不过，关于 `isNew` 的问题还有另一个：如果新的模型没有 ID，你将如何识别它们？例如，如果你通过
    `ID` 存储一组 `Model`，你会如何处理新的模型？
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To get around this problem, Backbone provides a special client-side only `ID`,
    or `cid` property, on every Model. This `cid` property is guaranteed to be unique,
    but has no connection whatsoever with the Model's actual `ID` (if it even has
    one). It is also not guaranteed to be consistent; if you refresh the page, your
    Models' might have entirely different `cid` properties generated for them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Backbone 为每个模型提供了一个特殊的仅客户端的 `ID`，或 `cid` 属性。这个 `cid` 属性保证是唯一的，但与模型的实际
    `ID`（如果有的话）没有任何联系。它也不保证一致性；如果你刷新页面，你的模型可能会有完全不同的 `cid` 属性生成。
- en: 'The presence of a `cid` property allows you to use a Model''s ID for all server-related
    tasks and its `cid` for all client-side tasks, without the need to get a new ID
    from the server every time you create a new Model. By using the `cid` property,
    we can solve our previous problem and successfully index new books:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`cid` 属性的存在允许你使用模型（Model）的 ID 来执行所有与服务器相关的任务，以及使用其 `cid` 来执行所有客户端任务，而无需每次创建新模型时都从服务器获取一个新的
    ID。通过使用 `cid` 属性，我们可以解决我们之前的问题，并成功索引新的书籍：'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Fetching data from the server
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务器获取数据
- en: The first of Backbone's three AJAX methods, `fetch`, is used to retrieve the
    data of a Model from the server. The `fetch` method doesn't require any arguments,
    but it takes a single optional `options` argument. This argument can take Backbone-specific
    options, such as silent (which will prevent the Model from triggering an event
    as a result of fetch), or any options that you will normally pass to `$.ajax`,
    such as *async*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 的三个 AJAX 方法中的第一个，`fetch`，用于从服务器检索模型的数据。`fetch` 方法不需要任何参数，但它接受一个可选的
    `options` 参数。此参数可以接受 Backbone 特定的选项，例如 silent（这将防止模型在 fetch 的过程中触发事件），或者任何你通常传递给
    `$.ajax` 的选项，例如 *async*。
- en: 'You can specify what to do when the `fetch` request is finished in one of the
    two ways. First, you can specify a `success` or `error` callback in the options
    passed to `fetch`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式之一指定 `fetch` 请求完成时要执行的操作。首先，你可以在传递给 `fetch` 的选项中指定一个 `success` 或 `error`
    回调：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `fetch` method also returns a jQuery promise, which is an object that lets
    you say *when the fetch is done, do ___* or *if the fetch fails, do ___*. We can
    use promises instead of a success callback to trigger logic after the AJAX operation
    finishes, and this approach even lets us chain multiple callbacks together:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` 方法同样返回一个 jQuery 承诺（promise），这是一个对象，允许你说“当 fetch 完成时，做 ___”或“如果 fetch
    失败，做 ___”。我们可以使用承诺（promises）而不是成功回调（callback）来在 AJAX 操作完成后触发逻辑，这种方法甚至允许我们将多个回调链式调用在一起：'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While both approaches work, the promise style is slightly more powerful because
    it allows you to easily trigger multiple callbacks from a single `fetch` or trigger
    a callback only after multiple `fetch` calls complete. For instance, let''s say
    we wanted to fetch two different Models and display an alert only after they''ve
    both been returned from the server. Using the success/error approach, this can
    be awkward, but with the promise style (combined with jQuery''s `when` function),
    the problem is simple to solve:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种方法都可行，但Promise风格稍微更强大，因为它允许你轻松地从单个`fetch`操作中触发多个回调，或者只在多个`fetch`调用完成后触发回调。例如，假设我们想要获取两个不同的模型，并且只有在它们都从服务器返回后显示一个警告。使用成功/错误方法可能会有些尴尬，但使用Promise风格（结合jQuery的`when`函数），问题就简单解决了：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once a `fetch` method is complete, Backbone will take the server's response,
    assume that it's a JSON object representing the Model's attributes, and call `set`
    on that object. In other words, `fetch` is really just a `GET` request followed
    by a set of whatever comes back in the response. The `fetch` method is designed
    to work with a RESTful-style API that returns just the Model's JSON, so if your
    server returns something else, such as that same JSON wrapped inside an `envelope`
    object, you'll need to override a special `Model` method called `parse`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`fetch`方法完成，Backbone将获取服务器的响应，假设它是一个表示模型属性的JSON对象，并在该对象上调用`set`。换句话说，`fetch`实际上只是一个`GET`请求，后面跟着响应中返回的一系列内容。`fetch`方法旨在与仅返回模型JSON的RESTful风格API一起工作，因此如果你的服务器返回了其他内容，例如包裹在`envelope`对象中的相同JSON，你需要覆盖一个名为`parse`的特殊`Model`方法。
- en: When a `fetch` method finishes, Backbone passes the server's response through
    `parse` before it calls `set`, and the default implementation of the `parse` method
    simply returns the object given to it without modification. By overriding the
    `parse` method with your own logic, however, you can tell Backbone how to convert
    this response from whatever format the server sent it in into a Backbone attributes
    object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当`fetch`方法完成时，Backbone在调用`set`之前通过`parse`传递服务器的响应，并且`parse`方法的默认实现简单地返回给它的对象而不做任何修改。然而，通过用你自己的逻辑覆盖`parse`方法，你可以告诉Backbone如何将这个响应从服务器发送的任何格式转换为Backbone属性对象。
- en: 'For instance, let''s say that instead of returning the data for a book directly,
    your server returned an object with the book''s attributes contained inside a
    book key, as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你的服务器不是直接返回书籍的数据，而是返回一个包含书籍属性的对象，这些属性包含在一个名为`book`的键中，如下所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By overriding the `parse` method of our `Book` class, we can tell Backbone
    to throw out the `otherInfo` and just use the `Book` property as our book''s attribute:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过覆盖`Book`类的`parse`方法，我们可以告诉Backbone丢弃`otherInfo`并仅使用`Book`属性作为我们书籍的属性：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Saving data to the server
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据保存到服务器
- en: Once you've started creating Models, you'll no doubt find yourself wanting to
    save their data to your remote server, and that's where Backbone's `save` method
    comes in. As its name suggests, `save` allows you to send your Model's attributes
    to your server. It does so in the JSON format, at the URL specified by the `url`
    method of your Model, via an AJAX `POST` or `PUT` request. Like `fetch`, `save`
    allows you to provide `success` and `error` callback options and (also like `fetch`)
    it returns a promise, which can be used to trigger code once the `save` method
    is completed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始创建模型，你无疑会发现自己想要将它们的数据保存到远程服务器，这就是Backbone的`save`方法发挥作用的地方。正如其名所示，`save`允许你将模型的属性发送到你的服务器。它以JSON格式执行，通过模型`url`方法的指定URL，通过AJAX
    `POST`或`PUT`请求。与`fetch`一样，`save`允许你提供`success`和`error`回调选项，并且（与`fetch`类似）它返回一个promise，可以在`save`方法完成后触发代码。
- en: 'Here''s an example of `save` used with a promise-based callback:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用基于Promise的回调的`save`示例：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code reveals another problem: it will only work if our server
    is set up to receive all of the Model''s attributes in the JSON format. If we
    want to save only some of those attributes or if we want to send other JSON, such
    as a wrapping `envelope` object, Backbone''s `save` method won''t work out of
    the box. Fortunately, Backbone provides a solution in the form of its `toJSON`
    method. When you save, Backbone passes your `Models` attributes through `toJSON`,
    which (like `parse`) normally does nothing, because by default `toJSON` simply
    returns whatever is passed in to it.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码揭示了另一个问题：它只有在我们的服务器设置为接收所有模型的属性以JSON格式时才会工作。如果我们只想保存一些属性，或者如果我们想发送其他JSON，例如包装的`envelope`对象，Backbone的`save`方法将无法直接工作。幸运的是，Backbone通过其`toJSON`方法提供了一个解决方案。当你保存时，Backbone通过`toJSON`传递你的`Models`属性，而`toJSON`（就像`parse`一样）通常什么都不做，因为默认情况下`toJSON`只是简单地返回传递给它的任何内容。
- en: 'However, by overriding `toJSON`, you can gain complete control over what Backbone
    sends to your server. For instance, if we wanted to wrap our book JSON inside
    another object as a `book` property and then add some further information, we
    can override `toJSON` as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过重写`toJSON`，你可以完全控制Backbone发送到你的服务器的内容。例如，如果我们想在另一个对象中包装我们的书籍JSON作为`book`属性，并添加一些其他信息，我们可以如下重写`toJSON`：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Validation
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: 'Before you send anything to the server, it''s a good idea to make sure that
    the data you''re sending is actually valid. To solve this problem, Backbone provides
    another method for you to optionally overwrite: `validate`. The `validate` method
    is called every time you save, but its default implementation simply returns `true`.
    If you overwrite it, however, you can add whatever validation logic you want,
    and if that logic returns `false`, then the whole `save` operation will fail and
    also return `false`. For instance, let''s say we wanted to ensure that every new
    book has a minimum of 10 pages:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在你向服务器发送任何内容之前，确保你发送的数据实际上是有效的是个好主意。为了解决这个问题，Backbone为你提供了一个可选的重写方法：`validate`。`validate`方法在每次保存时都会被调用，但其默认实现只是简单地返回`true`。然而，如果你重写了它，你可以添加任何你想要的验证逻辑，如果该逻辑返回`false`，则整个`save`操作将失败并返回`false`。例如，假设我们想要确保每本新书至少有10页：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if the validation fails, Backbone will not even return a promise;
    it will just return `false`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果验证失败，Backbone甚至不会返回一个承诺；它只会返回`false`。
- en: 'As a result, if you add validation logic to your `Model` class, you will need
    to test for a failed validation case separately every time you `save`; you can''t
    simply rely on the `fail` method of the returned promise since no such promise
    will be returned. In other words, the following won''t work (and will cause an
    error since `false` has no `fail` method):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你在`Model`类中添加验证逻辑，你将需要在每次`save`时单独测试失败的验证情况；你不能仅仅依赖于返回的承诺的`fail`方法，因为不会返回这样的承诺。换句话说，以下代码将不起作用（并且会导致错误，因为`false`没有`fail`方法）：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead, you should use the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该使用以下代码片段：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you can also check the validity of your Models at any time by using
    the **isValid** method, which will only return the validation result (and not
    `save`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你还可以通过使用**isValid**方法在任何时候检查你的模型的有效性，它将只返回验证结果（而不是`save`）。
- en: Return of Underscore
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回Underscore
- en: That covers all the core functionality of `Model`, but before we move on to
    explore `Collections`, some of the convenience methods of `Model` are worth mentioning.
    In addition to requiring Underscore, Backbone alo incorporates many `Underscore`
    methods into its classes as shortcut methods, and `Model` is a perfect example.
    The main advantage of using these built-in shortcut methods, besides being a bit
    more readable, is that they operate on the Model's attributes rather than the
    `Model` itself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了`Model`的所有核心功能，但在我们继续探索`Collections`之前，值得提一下`Model`的一些便利方法。除了需要Underscore之外，Backbone还将其许多`Underscore`方法作为快捷方法纳入其类中，`Model`是一个完美的例子。使用这些内置快捷方法的主要优势，除了更易于阅读之外，是它们在模型的属性上而不是在`Model`本身上操作。
- en: 'For instance, Underscore has a method called `keys`, which you can use to get
    all the keys on an object. You can use this method directly to get all the keys
    of a Model''s attributes, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Underscore有一个名为`keys`的方法，你可以使用它来获取对象上的所有键。你可以直接使用此方法来获取模型属性的键，如下所示：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'However, if you use Model''s version of that same method instead, you can simplify
    your code slightly and make it slightly more readable:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用 Model 的那个相同方法版本，你可以稍微简化你的代码，并使其稍微易于阅读：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are a total of six of these methods on `Model`, and while we don''t have
    time to explain all of them in this book, here''s a brief summary of what each
    one does:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Model` 上总共有六个这样的方法，虽然我们没有时间在这本书中解释所有这些方法，但这里简要总结一下每个方法的作用：
- en: '| Name | What it does |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 它的作用 |'
- en: '| --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `keys` | This returns every attribute key |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `keys` | 这将返回每个属性的键 |'
- en: '| `values` | This returns every attribute value |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `values` | 这将返回每个属性的值 |'
- en: '| `pairs` | This returns an array of attribute key/value pairs |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `pairs` | 这将返回一个属性键/值对的数组 |'
- en: '| `invert` | This returns the attributes with keys and values switched; for
    instance, an attribute of `{''pages'': 20}` will become `{''20'': ''pages''}`
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `invert` | 这将返回键和值颠倒的属性；例如，属性 `{''pages'': 20}` 将变为 `{''20'': ''pages''}`
    |'
- en: '| `pick` | This returns both the keys and values of only the specified attributes;
    for instance, `book.pick(''pages'')` will return `{pages: 20}` without any title
    or other attributes |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `pick` | 这将返回仅指定属性的键和值；例如，`book.pick(''pages'')` 将返回 `{pages: 20}`，不包含任何标题或其他属性
    |'
- en: '| `omit` | This returns both the keys and values for every attribute except
    those specified; for instance, `book.omit(''pages'')` will return `{title: ''Short
    Title''}` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `omit` | 这将返回除指定属性外的每个属性的键和值；例如，`book.omit(''pages'')` 将返回 `{title: ''Short
    Title''}` |'
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Backbone's `Model` class. You learned how to use
    `get` and `set` to change attributes, how to use `on` and `off` to listen for
    events, and how to use `fetch`, `save`, and `destroy` to exchange data with a
    remote server. You also learned how you can customize Backbone to handle your
    server's API by modifying the `url`, `urlRoot`, and `idAttribute` properties and
    how to handle differently structured data with `parse` and `toJSON`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Backbone 的 `Model` 类。你学习了如何使用 `get` 和 `set` 来更改属性，如何使用 `on` 和 `off`
    来监听事件，以及如何使用 `fetch`、`save` 和 `destroy` 与远程服务器交换数据。你还学习了如何通过修改 `url`、`urlRoot`
    和 `idAttribute` 属性来自定义 Backbone 以处理你的服务器 API，以及如何使用 `parse` 和 `toJSON` 来处理不同结构的数据。
- en: In the next chapter, we'll take a look at Backbone's other data class, `Collection`.
    Collections allow you to store groups of Models together, and (just like Models)
    they allow you to listen for changes and send or retrieve data to/from the server.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Backbone 的其他数据类 `Collection`。集合允许你一起存储多个模型，并且（就像模型一样）它们允许你监听变化并向/从服务器发送或检索数据。
