- en: 14\. TypeScript and React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. TypeScript 和 React
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we'll cover the React library and how to build user interfaces
    enhanced with TypeScript. We'll look at state management solutions for React applications
    and styling solutions. Then, we will use Firebase, a serverless backend, to build
    a Hacker News-style application. By the end of this chapter, you will be able
    to bootstrap React applications using the Create React App command-line interface.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 React 库以及如何使用 TypeScript 构建增强的用户界面。我们将探讨 React 应用程序的状态管理解决方案和样式解决方案。然后，我们将使用无服务器后端
    Firebase 来构建一个 Hacker News 风格的应用程序。到本章结束时，您将能够使用 Create React App 命令行界面启动 React
    应用程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: React is a dominant force in web and mobile user interface development. Although
    it bills itself as "*A JavaScript library for building user interfaces*," what
    we often think of as React goes well beyond the core library and includes a wide
    ecosystem of plugins, components, and other tools. Many developers have chosen
    to specialize in React and it's a popular topic for code academies. Unlike Angular,
    React was not developed to use TypeScript and in fact there are a few other typing
    systems that some developers use with React. However, the popularity of both React
    and TypeScript made it inevitable that someone would want to marry the two, and
    writing React with TypeScript has become a standard way to approach user interface
    development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: React 是网络和移动用户界面开发中的主导力量。尽管它自称是“*用于构建用户界面的 JavaScript 库*”，但我们通常所认为的 React 不仅限于核心库，还包括一个广泛的插件、组件和其他工具的生态系统。许多开发者选择专注于
    React，并且它是代码学院的热门话题。与 Angular 不同，React 并非专为使用 TypeScript 而开发，实际上还有一些其他的一些开发者与
    React 一起使用的类型系统。然而，React 和 TypeScript 的流行使得将两者结合在一起变得不可避免，使用 TypeScript 编写 React
    已经成为用户界面开发的标准方法。
- en: React was developed internally by Facebook for their own use and was open sourced
    in 2013\. In contrast to some of the more full-featured frameworks, React has
    always styled itself as a view library and it relies on other libraries for necessary
    functionality, such as state management, routing, and web requests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: React 是由 Facebook 内部开发用于自身使用的，并于 2013 年开源。与一些功能更全面的框架相比，React 始终将自己定位为一个视图库，并且它依赖于其他库来实现必要的功能，例如状态管理、路由和
    Web 请求。
- en: React uses a declarative, component-based approach. Developers build components
    that represent different UI elements. These components are typically reusable
    and can be assembled in different ways to construct web views. Components can
    be made up of other components and each individual component should be rather
    simple. Thinking in terms of small, reusable components helps React developers
    write clean, maintainable code and follow the **Don't Repeat Yourself** (**DRY**)
    principle.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用声明式、基于组件的方法。开发者构建代表不同 UI 元素的组件。这些组件通常是可重用的，并且可以以不同的方式组装来构建 Web 视图。组件可以由其他组件组成，并且每个单独的组件应该相对简单。以小型、可重用组件为前提思考有助于
    React 开发者编写干净、可维护的代码，并遵循 **不要重复自己**（**DRY**）原则。
- en: Typing React
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 React 类型化
- en: Prior to the dramatic rise in the popularity of TypeScript, React programmers
    either went without any sort of type system or used libraries such as Flow or
    PropTypes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 的流行度急剧上升之前，React 程序员要么没有使用任何类型的系统，要么使用 Flow 或 PropTypes 这样的库。
- en: Flow is another library developed by Facebook with the intent of adding types
    to JavaScript. It has similar goals to TypeScript but takes a different route
    to achieve them. Instead of being a superset of JavaScript, Flow uses comments
    and type annotations checked by a language server, which are then removed by a
    transpiler such as Babel. Since both libraries were developed by Facebook, it
    was common to use them together, but the popularity of Flow has waned as TypeScript
    has emerged as the type system of choice for web developers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 是 Facebook 开发的另一个库，旨在为 JavaScript 添加类型。它具有与 TypeScript 类似的目标，但采取了不同的途径来实现。Flow
    不是一个 JavaScript 的超集，它使用由语言服务器检查的注释和类型注解，然后由 Babel 这样的转换器移除。由于这两个库都是由 Facebook
    开发的，因此通常将它们一起使用，但随着 TypeScript 成为网络开发者的首选类型系统，Flow 的流行度已经下降。
- en: PropTypes is another library for enforcing type-checking. In this case, the
    library is specifically for use with React and has the narrow focus of checking
    types on React "props," or the parameters that are passed along with components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PropTypes 是另一个用于强制类型检查的库。在这种情况下，该库专门用于与 React 一起使用，并且其焦点是检查 React 的“props”，即与组件一起传递的参数。
- en: TypeScript in React
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 中的 TypeScript
- en: While it is technically feasible to use these libraries along with TypeScript,
    it's not a good idea as they are all essentially trying to solve the same thing.
    If you're using TypeScript, it's best to avoid Flow and PropTypes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在技术上可以使用这些库与 TypeScript 一起使用，但这并不是一个好主意，因为它们本质上都在试图解决相同的问题。如果你正在使用 TypeScript，最好避免使用
    Flow 和 PropTypes。
- en: TypeScript provides many benefits to React programmers. We can achieve all the
    same aims as the PropTypes library by typing our props using interfaces, and we
    also get the full IntelliSense experience, which will let us learn more about
    components and their lifecycles and even let us read developer comments, deprecation
    notices, and so forth.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 为 React 程序员提供了许多好处。我们可以通过使用接口来为 props 类型化，从而实现与 PropTypes 库相同的目标，并且我们还能获得完整的
    IntelliSense 体验，这将让我们更深入地了解组件及其生命周期，甚至可以阅读开发者的注释、弃用通知等等。
- en: TypeScript will help ensure proper use of our components and give us that early
    feedback loop that makes development much easier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 将有助于确保我们组件的正确使用，并给我们提供那种使开发变得容易的早期反馈循环。
- en: Hello, React
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嗨，React
- en: 'There are numerous books on React alone. This one chapter in a book on TypeScript
    cannot cover all the topics relating to React. Readers who aren''t already familiar
    with React but wish to work with React professionally should seek sources beyond
    this book. That said, to give a very brief overview of how React works, components
    are written in some flavor of a compile-to-JavaScript language, such as TypeScript,
    ReasonML, or even JavaScript. The compiled script will be embedded on a web page,
    hooking into a page element such as a `div`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 仅关于 React 的书籍就有很多。这本书关于 TypeScript 的这一章节无法涵盖与 React 相关的所有主题。对于那些已经不熟悉 React
    但希望专业地使用 React 的读者，应该寻求本书以外的资源。尽管如此，为了简要概述 React 的工作原理，组件是用某种编译到 JavaScript 的语言编写的，例如
    TypeScript、ReasonML，甚至是 JavaScript。编译后的脚本将被嵌入到网页中，连接到页面上的一个元素，例如 `div`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This script will be loaded into a page with an element that has an ID of `root`
    and will then print out `Hello Matt`. There are a lot of different ways to structure
    React applications. Usually, they will be composed of many, many components, each
    of which is put in a separate file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将被加载到一个具有 `root` ID 的元素所在的页面上，然后会打印出 `Hello Matt`。React 应用程序的结构有很多种不同的方式。通常，它们将由许多组件组成，每个组件都放在一个单独的文件中。
- en: React works by keeping a copy of the **Document Object Model** (**DOM**), the
    object tree that translates JavaScript code to a rendered browser page, in memory.
    This virtual DOM is updated frequently and changes are selectively applied to
    a render of the actual web page. The virtual DOM allows for performance optimizations
    and is designed to prevent slow renders or inefficient re-renders.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React 通过在内存中保留一份 **文档对象模型**（**DOM**），即将 JavaScript 代码转换为渲染的浏览器页面的对象树，来工作。这个虚拟
    DOM 会频繁更新，并将更改有选择地应用到实际网页的渲染中。虚拟 DOM 允许进行性能优化，并设计用来防止缓慢的渲染或低效的重渲染。
- en: The Component
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: Inheritance patterns have existed in JavaScript since the beginning, first in
    the form of prototypal inheritance and then class syntax since ES2015\. Some programming
    paradigms have recommended leveraging inheritance as the primary tool for building
    complex applications. For example, if we were building a website that included
    a profile page for a pet kitten, you might think about setting up an inheritance
    chain such as `KittenProfilePage extends FelineProfilePage extends PetProfilePage
    extends ProfilePage extends Page`. Indeed, some UI frameworks have attempted to
    implement models like this. However, in practice, this kind of thinking is quickly
    revealed as overly rigid, resistant to changing requirements, and forcing you
    into strange patterns. For example, if we have implemented `whiskerCount` in `FelineProfilePage`
    and we're now implementing `RodentProfilePage`, do we copy and paste? Does `RodentProfilePage`
    inherit from `FelineProfilePage`? Should we introduce `WhiskeredPetProfilePage`
    to the chain in order to share `whiskerCount` according to our model?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 继承模式自JavaScript诞生以来就存在了，最初是以原型继承的形式，然后是ES2015以来的类语法。一些编程范式建议利用继承作为构建复杂应用程序的主要工具。例如，如果我们正在构建一个包含宠物小猫个人主页的网站，你可能会考虑设置一个继承链，如`KittenProfilePage
    extends FelineProfilePage extends PetProfilePage extends ProfilePage extends Page`。确实，一些UI框架试图实现类似这样的模型。然而，在实践中，这种思维方式很快就会暴露出过于僵化、难以适应变化的需求，并迫使你进入奇怪的模式。例如，如果我们已经在`FelineProfilePage`中实现了`whiskerCount`，我们现在正在实现`RodentProfilePage`，我们是复制粘贴吗？`RodentProfilePage`是否从`FelineProfilePage`继承？我们应该在我们的模型中引入`WhiskeredPetProfilePage`到链中以共享`whiskerCount`吗？
- en: That's not to say that modern web frameworks and libraries don't use inheritance.
    They do! But generally, we are inheriting from a generic base component provided
    by the library and our inheritance chains are very short. Instead of inheritance,
    we focus on composition. Composition is the practice of building from many reusable
    components, most of which have a more general purpose. This doesn't mean that
    every component must be used more than once, but they are built in such a way
    that they could be.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说现代Web框架和库不使用继承。它们确实使用了！但通常，我们是从库提供的通用基组件继承，并且我们的继承链非常短。我们不是关注继承，而是关注组合。组合是从许多可重用组件中构建，其中大多数具有更通用目的的实践。这并不意味着每个组件都必须使用多次，但它们是以一种可以重复使用的方式构建的。
- en: This approach is embraced wholeheartedly by React. The basic building block
    of any React application is the component. There are a few classifications of
    React component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被React完全接受。任何React应用程序的基本构建块是组件。React组件有几种类别。
- en: Stateful Components
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有状态组件
- en: Stateful components keep track of their own state. Consider a dropdown that
    tracks whether or not it is open and renders accordingly. Stateful components
    may use the `this` keyword or enclose other variables for the purpose of keeping
    the state. In React, the `setState` method may be used in stateful components.
    A stateful component's state may be set during lifecycle events.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态组件跟踪它们自己的状态。考虑一个跟踪是否打开并相应渲染的下拉菜单。有状态组件可能使用`this`关键字或包含其他变量以保持状态。在React中，有状态组件可以使用`setState`方法。有状态组件的状态可以在生命周期事件中设置。
- en: Typically, information about how a component should display can be kept within
    that component. However, more complex data, such as a user profile, will often
    require a state management solution that extends beyond the component. See *State
    Management in React* later in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关于组件应该如何显示的信息可以保存在该组件内部。然而，更复杂的数据，如用户个人资料，通常需要一个超出组件范围的状态管理解决方案。请参阅本章后面的*React中的状态管理*。
- en: Stateless Components
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态组件
- en: Stateless components never use the `this` keyword or call `setState`. They may
    re-render based on props passed in but do not track any data themselves. All normal
    lifecycle methods are available and stateless components are declared in the same
    way as stateful components, just without anything that may alter the state.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态组件从不使用`this`关键字或调用`setState`。它们可能根据传入的属性重新渲染，但不会跟踪任何数据。所有正常的生命周期方法都是可用的，无状态组件的声明方式与有状态组件相同，只是没有任何可能改变状态的内容。
- en: A dropdown or accordion component could even be stateful if we decided to manage
    that state in a central location. We typically won't do that for simple components,
    but we might have some reason, such as an expand/collapse all feature.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定在中央位置管理该状态，下拉或手风琴组件甚至可以是状态化的。我们通常不会为简单组件这样做，但可能会有某些原因，例如展开/折叠全部功能。
- en: Pure Components
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯组件
- en: Pure components are a special optimization for React. They are much like stateless
    components in terms of how we use them, but they are declared differently (by
    extending `PureComponent`). Pure components will only re-render when there is
    a change to their state or props. This is in contrast to most components, which
    will re-render when a parent component re-renders.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 纯组件是 React 的一个特殊优化。在如何使用它们方面，它们与无状态组件非常相似，但它们的声明方式不同（通过扩展 `PureComponent`）。纯组件只有在它们的
    state 或 props 发生变化时才会重新渲染。这与大多数组件不同，这些组件在父组件重新渲染时也会重新渲染。
- en: It's a good idea to experiment with pure components. They can dramatically speed
    up the rendering of a React application but may introduce some unexpected behaviors
    to those not used to working with them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用纯组件是个好主意。它们可以显著加快 React 应用的渲染速度，但可能会给不习惯与它们一起工作的开发者带来一些意外的行为。
- en: Higher-Order Components
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶组件
- en: '**Higher-order components** (**HOCs**) are not a library structure but are
    rather a pattern of wrapping one component with another without mutating the wrapped
    component. A great example of an HOC is requiring users to authenticate prior
    to interacting with our components.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**高阶组件**（**HOCs**）不是一个库结构，而是一种将一个组件包裹在另一个组件中而不修改被包裹组件的模式。一个 HOC 的好例子是要求用户在交互我们的组件之前进行认证。'
- en: Consider the case of a site with a single login page and 99 pages of sensitive
    information. Following a composition model, how can we implement this? We don't
    want to inject the details of our authentication into every component we build.
    Doing that would be sloppy and impractical. We don't want to have to wrap every
    render with `isUserAuthenticated`. It would be easy to miss one. A better solution
    to this problem is to use an HOC. Now our components can be written independently
    of our authentication model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个只有单个登录页面和 99 页敏感信息的网站。按照组合模型，我们该如何实现呢？我们不希望将我们的认证细节注入到我们构建的每个组件中。这样做会显得杂乱无章且不切实际。我们不想不得不将每个渲染都包裹在
    `isUserAuthenticated` 中。很容易遗漏一个。解决这个问题的一个更好的方案是使用 HOC。现在我们的组件可以独立于我们的认证模型来编写。
- en: HOCs are often described as `PureComponent` is an actual part of the React library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HOCs 经常被描述为 `PureComponent` 是 React 库的实际一部分。
- en: HOCs are a great example of the concept of composition over inheritance. Going
    back to the authentication example, an inheritance model would likely have us
    building components that inherit from `RequiresAuthenticationComponent`, a base
    component that has our auth model built in. However, with composition, we can
    build our components independently of our authentication system, then apply an
    HOC around them. Many programmers would see this as a better separation of concerns.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: HOCs 是组合优于继承概念的一个很好的例子。回到认证的例子，继承模型可能会让我们构建继承自 `RequiresAuthenticationComponent`
    的组件，这是一个内置了我们的认证模型的基组件。然而，使用组合，我们可以独立于我们的认证系统构建我们的组件，然后在他们周围应用 HOC。许多程序员会认为这是一种更好的关注点分离。
- en: JSX and TSX
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 和 TSX
- en: 'JSX is another innovation from Facebook. It refers to JavaScript enhanced with
    XML and practically it is JavaScript with HTML templates embedded into it. The
    following is an example of its use:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是 Facebook 的另一项创新。它指的是增强 XML 的 JavaScript，实际上它是在其中嵌入 HTML 模板的 JavaScript。以下是其使用的一个示例：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a function that returns an HTML template. We must use JSX to do this.
    Normally, this would result in a syntax error as this is not a quoted string nor
    is it any recognizable object or syntax in TypeScript. JSX allows us to mix our
    HTML templating in with our code. Some earlier view libraries would use one file
    for source code and another for templating. This was often confusing to programmers
    as they needed to flip back and forth between the two.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回 HTML 模板的函数。我们必须使用 JSX 来做这件事。通常，这会导致语法错误，因为这既不是引号字符串，也不是 TypeScript 中可识别的对象或语法。JSX
    允许我们将 HTML 模板与我们的代码混合。一些早期的视图库会使用一个文件用于源代码，另一个用于模板。这对程序员来说通常很令人困惑，因为他们需要在两个文件之间来回切换。
- en: It is possible to write React without using JSX but that is rarely done and
    won't be covered in this book. Some other languages, such as Vue, use JSX as well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能在不使用 JSX 的情况下编写 React，但这很少见，本书也不会涉及这一点。其他一些语言，如 Vue，也使用 JSX。
- en: When we want to write TypeScript in JSX, we use the `.tsx` file extension instead
    of `.jsx`. Technically, this is still JSX. To include TypeScript in JSX, all we
    need to do is set the file extension accordingly and set the `jsx` property in
    our `tsconfig.json` file to let TypeScript know we're using JSX. Valid values
    for that property are `react`, `react-native`, and `preserve`. The first two are
    for targeting a web browser or mobile app, respectively, and the last means that
    some other transpilation step will handle the JSX.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在 JSX 中编写 TypeScript 时，我们使用 `.tsx` 文件扩展名而不是 `.jsx`。技术上，这仍然是 JSX。为了在 JSX
    中包含 TypeScript，我们只需要相应地设置文件扩展名，并在我们的 `tsconfig.json` 文件中将 `jsx` 属性设置为让 TypeScript
    知道我们正在使用 JSX。该属性的合法值是 `react`、`react-native` 和 `preserve`。前两个用于针对网络浏览器或移动应用程序，最后一个意味着其他转换步骤将处理
    JSX。
- en: JSX is not a part of the JavaScript or TypeScript language, but just a language
    extension that needs to be transpiled. You wouldn't be able to run JSX in most
    web browsers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 不是 JavaScript 或 TypeScript 语言的一部分，而是一种需要被转换的语言扩展。你无法在大多数网络浏览器中运行 JSX。
- en: 'Exercise 14.01: Bootstrapping with Create React App'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.01：使用 Create React App 搭建
- en: Create React App (`create-react-app`) is a library from Facebook that helps
    developers quickly bootstrap a new React application. It includes a library called
    `react-scripts` that helps abstract a lot of the tooling that has become standard
    in web development, like a linter, a test framework, and a bundler (webpack).
    All of those dependencies are managed by Create React App and `react-scripts`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Create React App (`create-react-app`) 是来自 Facebook 的一个库，它帮助开发者快速搭建新的 React 应用程序。它包含一个名为
    `react-scripts` 的库，该库帮助抽象化了许多已成为网络开发标准的工具，如代码检查器、测试框架和打包器（webpack）。所有这些依赖项都由 Create
    React App 和 `react-scripts` 管理。
- en: 'In this exercise, we''ll bootstrap a new React application using Create React
    App. We''ll run the application, examine the developer experience, and make some
    minor edits, then see components reload. We''ll look at the production build and
    how that''s different from the development build. Then we''ll check out the built-in
    tests:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 Create React App 搭建一个新的 React 应用程序。我们将运行应用程序，检查开发者体验，进行一些小的编辑，然后看到组件重新加载。我们将查看生产构建，并了解它与开发构建的不同之处。然后我们将检查内置的测试：
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code for this exercise can be found here: [https://packt.link/hMs3v](https://packt.link/hMs3v).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码可以在以下链接找到：[https://packt.link/hMs3v](https://packt.link/hMs3v)。
- en: 'Create React App ships with a few options and has included a TypeScript option
    since 2018\. It''s very easy to create a new application. We don''t even need
    to install anything but can use `npx` to run the latest version of Create React
    App and start an application. Enter the command line and find a directory where
    you''d like to create your application and type this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Create React App 自带了一些选项，并且自 2018 年以来就包含了 TypeScript 选项。创建新应用程序非常简单。我们甚至不需要安装任何东西，只需使用
    `npx` 运行最新版本的 Create React App 并启动应用程序。进入命令行，找到你想要创建应用程序的目录，并输入以下命令：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create React App will download from the internet and set up your application,
    then install dependencies. Create React App will use the `yarn` package manager
    (also from Facebook) if you have it installed, otherwise it will use `npm`. It
    doesn''t make very much difference which of these you use for the purposes of
    this book as they provide the same functionality. If you have an old version of
    `yarn` installed, you may need to update it (`npm i -g yarn`). If you prefer not
    to use `yarn`, all of these exercises should work fine without it:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Create React App 将从互联网上下载并设置你的应用程序，然后安装依赖项。如果你已经安装了 `yarn` 包管理器（也来自 Facebook），Create
    React App 将使用 `yarn`，否则它将使用 `npm`。对于本书的目的，你使用哪一个没有太大区别，因为它们提供了相同的功能。如果你安装了旧的 `yarn`
    版本，你可能需要更新它（`npm i -g yarn`）。如果你不希望使用 `yarn`，所有这些练习在没有它的前提下也应该能正常工作：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For ease of presentation, only a section of the output is displayed here.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了便于展示，这里只显示了输出的一部分。
- en: 'The output of `npx create-react-app` will tell you what to do next. `cd` into
    the directory that was created, and type `yarn start` or `npm start`. Your application
    will automatically open in a browser window:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npx create-react-app` 的输出将告诉你下一步该做什么。进入创建的目录，并输入 `yarn start` 或 `npm start`。你的应用程序将自动在一个浏览器窗口中打开：'
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will see the following output:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you navigate to `http://localhost:3000`, you will see the following:![Figure
    14.1: Screenshot of my-app in the browser'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你导航到 `http://localhost:3000`，你会看到以下内容：![图 14.1：浏览器中的 my-app 截图
- en: '](img/B14508_14_01.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_14_01.jpg)'
- en: 'Figure 14.1: Screenshot of my-app in the browser'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.1：浏览器中的 my-app 截图
- en: 'Examine the source code that was generated in your favorite IDE. You can find
    an `index.tsx` file that attaches the React application to a `dom` node and an
    `App.tsx` file, which is the main component in your application so far. Try adding
    a new message or creating some new components as shown here:![Figure 14.2: Screenshot
    of my-app after adding App.tsx'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查在你最喜欢的集成开发环境（IDE）中生成的源代码。你可以找到一个名为 `index.tsx` 的文件，它将 React 应用程序附加到一个 `dom`
    节点，以及一个 `App.tsx` 文件，这是你应用程序到目前为止的主组件。尝试添加一条新消息或创建一些新的组件，如下所示：![图 14.2：添加 App.tsx
    后的 my-app 截图
- en: '](img/B14508_14_02.jpg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_14_02.jpg)'
- en: 'Figure 14.2: Screenshot of my-app after adding App.tsx'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.2：添加 App.tsx 后的 my-app 截图
- en: When you type `npm start`, your application will run in development mode with
    hot reloads (meaning your page refreshes when you make a change). For running
    in production, that's obviously not necessary. You can see what a production build
    looks like by running `yarn build` or `npm run build`. You'll see some output
    that tells you exactly what is happening and the transpiled JavaScript will be
    put in a `build` directory. Open the directory and look at the files there. That's
    what a production React application looks like.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你输入 `npm start` 时，你的应用程序将以开发模式运行，带有热重载（这意味着当你做出更改时页面会刷新）。对于在生产环境中运行，这显然是不必要的。你可以通过运行
    `yarn build` 或 `npm run build` 来查看生产构建的样子。你会看到一些输出，告诉你确切发生了什么，并且转译后的 JavaScript
    将被放在 `build` 目录中。打开该目录并查看那里的文件。这就是生产 React 应用程序的样子。
- en: Use *Ctrl* + *C* to stop your local server and try `yarn build` or `npm run
    build` to run the production build.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *C* 停止你的本地服务器，然后尝试 `yarn build` 或 `npm run build` 来运行生产构建。
- en: 'Production React applications often run on static servers but they can also
    run on web servers. The concept of server-side rendering in React is beyond the
    scope of this book but is another topic you may be interested in. Your build should
    produce a shortened URL that will take you to an article that includes more information
    about deploying React applications to production:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生产 React 应用程序通常运行在静态服务器上，但它们也可以运行在 Web 服务器上。React 中的服务器端渲染概念超出了本书的范围，但这也是你可能感兴趣的一个主题。你的构建应该生成一个缩短的
    URL，该 URL 将带你到一个包含更多关于将 React 应用程序部署到生产环境的信息的文章：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'File sizes after `gzip`:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gzip` 压缩后的文件大小：'
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The project was built assuming it is hosted at `/`. You can control this with
    the `homepage` field in your `package.json`.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 项目假设托管在 `/`。你可以通过 `package.json` 中的 `homepage` 字段来控制这一点。
- en: 'The `build` folder is ready to be deployed. You may serve it with a static
    server:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build` 文件夹已准备好部署。你可以使用静态服务器来提供服务：'
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Type `yarn test` or `npm t` (short for `npm test`). The Jest framework will
    run a test against your application. The test is very simple but can get you started
    writing more tests. It''s a good idea to write tests for your components as the
    tests will give you confidence that your application is working. Writing testable
    code builds strong programming habits:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `yarn test` 或 `npm t`（即 `npm test`）。Jest 框架将对你的应用程序运行一个测试。这个测试非常简单，但可以让你开始编写更多的测试。为你的组件编写测试是一个好主意，因为测试会给你信心，确保你的应用程序正在工作。编写可测试的代码可以培养良好的编程习惯：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And with that, we've covered the basics of Create React App. We've learned how
    we can quickly bootstrap a new application, looked at the developer experience
    with hot reloading, and also how to run production builds and tests.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这些，我们已经涵盖了 Create React App 的基础知识。我们学习了如何快速启动一个新应用程序，了解了带有热重载的开发者体验，以及如何运行生产构建和测试。
- en: Although Create React App gives you a lot of stuff, it's actually just the tip
    of the iceberg of what we'll see in the coming sections. For example, our application
    has no way to handle different kinds of requests or different pages. We don't
    have any routing. We also have no place to store data and no way to interact with
    any kind of backend. We'll delve into those concepts in the coming sections.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Create React App给你提供了很多东西，但实际上这只是我们将在接下来的章节中看到的内容的冰山一角。例如，我们的应用程序没有处理不同类型请求或不同页面的方法。我们没有路由。我们也没有存储数据的地方，也没有与任何后端交互的方式。我们将在接下来的章节中深入探讨这些概念。
- en: Routing
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: React doesn't include a solution for routing by default. That's because at its
    heart it is a view library. Some applications have no need for routing, but most
    will want the ability to render multiple pages at the very least. Some applications
    have complicated routing requirements that may involve "deep linking" or linking
    directly to a particular document. Request or query variables in a URL may contain
    some identifier that connects to a particular user's record.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: React 默认不包含路由解决方案。这是因为它的核心是一个视图库。一些应用程序可能不需要路由，但大多数至少会想要渲染多个页面的能力。一些应用程序可能有复杂的路由需求，可能涉及“深度链接”或直接链接到特定文档。URL
    中的请求或查询变量可能包含一些与特定用户记录相关联的标识符。
- en: While there are some alternatives, most React applications that use routing
    use React-Router, which is the official Facebook solution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一些替代方案，但大多数使用路由的 React 应用程序都使用 React-Router，这是官方的 Facebook 解决方案。
- en: 'Exercise 14.02: React Router'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.02：React Router
- en: 'In this exercise, we''ll bootstrap another application with Create React App
    and then enhance it with React Router to be able to support multiple views and
    navigate between them:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 Create React App 启动另一个应用程序，然后使用 React Router 来增强它，以便能够支持多个视图并在它们之间进行导航：
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code for this exercise can be found here: [https://packt.link/EYBcF](https://packt.link/EYBcF).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码可以在以下链接找到：[https://packt.link/EYBcF](https://packt.link/EYBcF)。
- en: 'To start, go to the command line where you can create another application:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到可以创建另一个应用程序的命令行：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To add React Router, let''s install the library and typings. If you are not
    using `yarn`, `yarn add` commands can be replaced with `npm install`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加 React Router，让我们安装库和类型定义。如果你不使用 `yarn`，则可以将 `yarn add` 命令替换为 `npm install`：
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we can start the application with `yarn start` or `npm start`. We'll be
    editing files as we add these routes and our application will just restart automatically,
    which makes for a nice developer experience.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `yarn start` 或 `npm start` 启动应用程序。当我们添加这些路由并编辑文件时，我们的应用程序将自动重新启动，这为开发者提供了一个很好的体验。
- en: We could begin by adding the router, but we currently have nothing to route
    to, so let's start by adding a few new components. Since components are the building
    blocks of a React application, a component can be a page. That same component
    could also be part of another page.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以开始添加路由器，但我们目前没有任何路由目标，所以让我们先添加一些新的组件。由于组件是 React 应用程序的构建块，一个组件可以是一个页面。相同的组件也可以是另一个页面的组成部分。
- en: Let's create a `/src/pages` subdirectory in our application to hold the new
    page components. In the `pages` subdirectory, create `Add.tsx,Home.tsx`, `SignIn.tsx`,
    and `Signup.tsx`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在应用程序中创建一个 `/src/pages` 子目录来存放新的页面组件。在 `pages` 子目录中，创建 `Add.tsx`、`Home.tsx`、`SignIn.tsx`
    和 `Signup.tsx`。
- en: To start, we'll create some very simple components to route between. In a later
    section in this chapter, we'll discuss the creation of function components.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们将创建一些非常简单的组件以在它们之间进行路由。在本章的后续部分，我们将讨论函数组件的创建。
- en: 'Create `Add.tsx` using the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用以下代码创建 `Add.tsx`:'
- en: '[PRE12]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create `Home.tsx` using the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用以下代码创建 `Home.tsx`:'
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create `SignIn.tsx` using the following code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用以下代码创建 `SignIn.tsx`:'
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create `SignUp.tsx` using the following code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用以下代码创建 `SignUp.tsx`:'
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These basic components only return some JSX, but they are sufficient to route
    between. Note that without a router, we could include the components in our main
    `App.tsx`, but we cannot navigate between pages in a traditional web app sense.
    That is the responsibility of the router.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些基本组件只返回一些 JSX，但它们足以进行路由。请注意，如果没有路由器，我们可以在我们的主 `App.tsx` 中包含这些组件，但在传统网络应用程序的意义上，我们无法在页面之间进行导航。这是路由器的责任。
- en: So, at this point, we have components that we can't yet interact with. Let's
    add routing to our `App.tsx`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们有一些我们尚不能与之交互的组件。让我们给我们的 `App.tsx` 添加路由。
- en: 'React Router exposes a few different router types that have mostly narrow use
    cases. We will focus on `BrowserRouter`. To get started, we will add a few imports
    to `App.tsx`:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: React Router公开了几种不同的路由类型，它们大多有特定的用途。我们将关注 `BrowserRouter`。为了开始，我们将向 `App.tsx`
    添加一些导入：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By convention, we are renaming `BrowserRouter` to `Router` in our import. We
    will also use `Switch`, which gives us a declarative way to shift between different
    components based on the route, and `Route`, which lets us define the component
    route.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照惯例，我们在导入时将 `BrowserRouter` 重命名为 `Router`。我们还将使用 `Switch`，它为我们提供了一个基于路由在不同组件之间切换的声明式方法，以及
    `Route`，它允许我们定义组件路由。
- en: Adding our first (default) route is pretty simple. Before doing that, make sure
    your local dev environment is running with `npm start`. You should see the spinning
    React logo in a web browser running at `http://localhost:3000`.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加第一个（默认）路由非常简单。在这样做之前，请确保您的本地开发环境正在使用 `npm start` 运行。您应该在运行在 `http://localhost:3000`
    的浏览器中看到一个旋转的 React 标志。
- en: 'Now let''s use the other components to build out the first route. We''ll remove
    all the JSX that the `App.tsx` component is currently returning and replace it
    with the routing:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用其他组件来构建第一个路由。我们将移除 `App.tsx` 组件当前返回的所有 JSX，并用路由替换它：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You will need to import the `Home` component:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要导入 `Home` 组件：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Your IDE may prompt you to automatically import `Home` as you are typing.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的 IDE 可能会在您输入时提示您自动导入 `Home`。
- en: If you've got everything working correctly, your view will refresh and you'll
    see the React logo replaced with `You are home!`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切设置正确，您的视图将刷新，您会看到 React 标志被替换为 `您已到家！`。
- en: 'Let''s add some additional routes:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们添加一些额外的路由：
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our `Home` route sets the `exact` property. Routing in React uses a regular
    expression to match the path starting from the leftmost part of the path. This
    allows for variable query and route parameters to be matched. The `exact` prop
    forces an exact match and ensures `"/add"` doesn't match to `"/"`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `Home` 路由设置了 `exact` 属性。React 中的路由使用正则表达式从路径的最左侧部分开始匹配路径。这允许匹配变量查询和路由参数。`exact`
    属性强制进行精确匹配，并确保 `"/add"` 不会匹配到 `"/"`。
- en: Now we can test the routing. Type `http://localhost:3000/add` in your browser.
    You should get the message `Add a new story`. Try visiting the other routes.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以测试路由了。在浏览器中输入 `http://localhost:3000/add`。你应该会看到消息 `添加一个新故事`。尝试访问其他路由。
- en: Of course, it isn't very natural to expect users to manually type all the URLs
    in a browser to navigate your site. Let's add some links. We can import `Link`
    from `react-router`. This component will create navigation links that connect
    to your application routing. Because of this, `Link` must always be used within `Router`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，期望用户手动在浏览器中输入所有 URL 来导航您的网站并不自然。让我们添加一些链接。我们可以从 `react-router` 中导入 `Link`。这个组件将创建连接到您的应用程序路由的导航链接。因此，`Link`
    必须始终在 `Router` 内部使用。
- en: '`Link` wraps some text and has a `to` prop, which should have the route you
    want to link to:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Link` 包裹一些文本，并有一个 `to` 属性，该属性应该有您想要链接到的路由：'
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With that, it''s pretty easy to add some navigation elements:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样一来，添加一些导航元素就非常简单了：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This should give us a nice way to move between our pages. However, pasting a
    bunch of extra JSX into `App.tsx` isn't a great way to write React, so let's write
    a `NavBar` component instead.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会给我们一种在页面之间移动的好方法。然而，将大量额外的 JSX 粘贴到 `App.tsx` 中并不是编写 React 的好方法，所以让我们编写一个
    `NavBar` 组件。
- en: 'Add a `components` directory under `src`. We''ll use this directory to hold
    components that aren''t tied to routes:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src` 下添加一个 `components` 目录。我们将使用这个目录来存放与路由无关的组件：
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can simply use this component in `App.tsx`. Here''s the finished component:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `App.tsx` 中简单地使用这个组件。这是完成的组件：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Check your browser now and you should see the simple navigation and be able
    to use it to shift between views:![Figure 14.3: List of folders in the finished
    component'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查您的浏览器，你应该会看到简单的导航，并能够用它来切换视图：![图 14.3：完成组件中的文件夹列表
- en: '](img/B14508_14_03.jpg)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_14_03.jpg)'
- en: 'Figure 14.3: List of folders in the finished component'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：完成组件中的文件夹列表
- en: Adding routing to a React application is easy to do. In this exercise, we showed
    how to add routes, navigate between them, and also how to share a common component
    across several routes. One of the real strengths of React is the ability to share
    components among other components and create reuse patterns that make putting
    together the building blocks of an application easy.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用程序中添加路由很容易。在这个练习中，我们展示了如何添加路由、在它们之间导航，以及如何共享一个通用的组件跨多个路由。React 的一个真正优势是能够在其他组件之间共享组件，并创建重用模式，这使得组合应用程序的构建块变得容易。
- en: Routing can also include path and query parameters. Be sure to read the React
    Router documentation for how to add parameters to your routes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 路由还可以包括路径和查询参数。请务必阅读 React Router 文档，了解如何向您的路由添加参数。
- en: React Components
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 组件
- en: Now let's dig into how these components work. There are several different ways
    to declare a component in React. You even have the choice to use JSX or not. This
    book will focus on creating components with function expressions, but we'll go
    over a few other patterns, so you'll know them when you see them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来深入探讨这些组件是如何工作的。在React中声明组件有几种不同的方式。你甚至可以选择是否使用JSX。本书将专注于使用函数表达式创建组件，但我们也会简要介绍其他一些模式，这样你就能在看到它们时识别出来。
- en: Class Components
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类组件
- en: 'This style of component follows a classical (that is, relating to the programming
    concept of classes) pattern of component declaration. Many older examples will
    use class components, but they have fallen largely out of fashion due to being
    more verbose than other patterns. To create a class component, we import the `Component`
    class from React and extend it while creating our own class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组件风格遵循经典的（即，与编程概念中的类相关）组件声明模式。许多较老的例子会使用类组件，但由于它们比其他模式更冗长，所以已经很大程度上过时了。要创建一个类组件，我们需要从React中导入`Component`类并在创建自己的类时扩展它：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It''s a good idea to create your own interface for props and the same can be
    done for state – for example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为属性创建自己的接口是个好主意，同样也可以为状态做同样的事情——例如：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Props are accessed via `this.props` and state via `this.state` and `this.setState`.
    This style of programming may seem comfortable and familiar to those with a background
    in Java or C++, but the `this` keyword can be troubling to work with in TypeScript
    and the class-focused declaration style doesn't fit well with some of the functional
    programming concepts in React, so other patterns have gained popularity in recent
    years. For more information about the `this` keyword, see *Chapter 3*, *Functions*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通过`this.props`访问，状态通过`this.state`和`this.setState`访问。这种编程风格对于那些有Java或C++背景的人来说可能感觉舒适和熟悉，但`this`关键字在TypeScript中可能会带来麻烦，并且以类为中心的声明风格与React中的一些函数式编程概念不太匹配，因此近年来其他模式已经变得更加流行。有关`this`关键字的更多信息，请参阅*第3章*，*函数*。
- en: Function Components (Function Declaration)
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组件（函数声明）
- en: 'It''s far more common for React components to be written as function components.
    The same simple component from the previous section, rewritten as a function component,
    could look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在React组件中，以函数组件的形式编写更为常见。上一节中的相同简单组件，重写为函数组件，可能看起来像这样：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've shaved off a couple of lines of code and come to something a bit more
    like a functional programming style. You won't use `this` very often when using
    function components, nor do you need to actually import the `Component` class.
    Props are simply the arguments passed into the function. State can't be handled
    directly here, but we will see how to manage that in the next section on React
    Hooks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经精简了几行代码，使其更接近函数式编程风格。在使用函数组件时，你不太会用到`this`，实际上也不需要真正导入`Component`类。属性只是传递给函数的参数。状态在这里不能直接处理，但下一节关于React
    Hooks的内容中我们会看到如何管理状态。
- en: Function Components (Function Expression with Arrow Functions)
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组件（使用箭头函数的表达式）
- en: 'This book prefers this pattern as a very intuitive and declarative way of creating
    components. You can even create pure function components as a one-liner. First,
    let''s write the same component again:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本书更倾向于这种模式，因为它是一种非常直观和声明式的创建组件的方式。你甚至可以创建一行代码的纯函数组件。首先，让我们再次编写相同的组件：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Scoping rules do not allow the `const` and `default` keywords to be on the same
    line (avoiding absurd code such as `export default const a=1, b=2, c=3;`, which
    would otherwise be allowed), so we need to export the component on a separate
    line.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域规则不允许`const`和`default`关键字在同一行上（避免像`export default const a=1, b=2, c=3;`这样的荒谬代码，否则这是允许的），因此我们需要在单独的一行上导出组件。
- en: 'If we really want to slim the code down, we could write it like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想进一步精简代码，可以写成这样：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is a pure function component that is stateless and has no other side effects.
    Most programmers prefer to use an interface for the props as it helps with readability,
    but that declaration can be done inline as in the preceding snippet (`{ text:
    string }`) if we really want to make the component small.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个无状态的纯函数组件，没有其他副作用。大多数程序员更喜欢使用属性接口，因为它有助于提高可读性，但如果我们真的想使组件更小，可以像前面的片段（`{
    text: string }`）那样内联声明。'
- en: No JSX
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无JSX
- en: 'Any of the preceding methods can use `createElement`. Here''s a quick example
    of why you probably don''t want to use that:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述任何一种方法都可以使用`createElement`。这里有一个快速示例，说明你可能不想使用它的原因：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The arguments to `createElement` are the element tag to create, its props, and
    its children. It doesn't take long to realize that creating nested elements with
    `createElement` would be *substantially* more difficult than using JSX, so JSX
    is almost always used. If we decide not to use JSX, we can use the `.ts` file
    extension instead of `.tsx`. This is a very small benefit!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`createElement` 的参数是要创建的元素标签、其属性和其子元素。很快就会意识到，使用 `createElement` 创建嵌套元素会比使用
    JSX 难得多，所以 JSX 几乎总是被使用。如果我们决定不使用 JSX，我们可以使用 `.ts` 文件扩展名而不是 `.tsx`。这是一个非常小的好处！'
- en: State in Function Components
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组件中的状态
- en: This book recommends function components over class components. We cannot access
    state directly in a function component, nor is there a `setState` method to call.
    However, we do have access to the excellent `useState` and so we hardly miss `this`
    or `setState` at all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本书推荐使用函数组件而不是类组件。在函数组件中，我们不能直接访问状态，也没有可调用的 `setState` 方法。然而，我们确实可以访问优秀的 `useState`，所以我们几乎不会错过
    `this` 或 `setState`。
- en: '`useState` is part of React Hooks, available since React version 16.8\. React
    Hooks introduced several functions that greatly enhance working with function
    components. Let''s start by coming up with a simple component that uses the class
    constructor, `this`, and `setState`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` 是 React Hooks 的一部分，自 React 版本 16.8 以来可用。React Hooks 引入了几种函数，这些函数极大地增强了与函数组件一起工作的能力。让我们从一个使用类构造函数、`this`
    和 `setState` 的简单组件开始：'
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''ve defined interfaces for props and state as well as an event handler to
    count up the clicks. We are using `setState` to increment our counter in the state.
    It looks a bit weird that `handleClick` uses an arrow function while `render`
    does not, yet they both refer to `this`. This is due to the strangeness of interpreting
    `this` references in TypeScript. Without an arrow function, `handleClick` will
    not find our component when accessing `this` but will instead get an `undefined`
    reference. This sort of issue has cost a lot of developers a lot of time and so
    framework authors have sought after solutions that simply avoid language constructs
    that so many find confusing. Let''s rewrite this component as a function component:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为属性、状态以及用于计数点击的事件处理程序定义了接口。我们正在使用 `setState` 在状态中增加计数器。`handleClick` 使用箭头函数而
    `render` 不使用箭头函数，看起来有点奇怪，但它们都引用了 `this`。这是由于 TypeScript 中解释 `this` 引用时的奇怪之处。如果没有箭头函数，`handleClick`
    在访问 `this` 时将找不到我们的组件，而会得到一个 `undefined` 引用。这种问题已经让许多开发者浪费了很多时间，因此框架作者寻求了简单避免许多开发者认为令人困惑的语言结构的解决方案。让我们将此组件重写为函数组件：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function component does exactly the same thing as the class component.
    Let's look at the differences. For one, we're starting to see substantial savings
    in terms of lines of code. The function component is 18 lines while the class
    component is 30.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数组件与类组件执行完全相同的功能。让我们看看它们之间的差异。首先，我们在代码行数方面开始看到实质性的节省。函数组件有 18 行，而类组件有 30
    行。
- en: Next, we are avoiding the troublesome `this` keyword. We are also avoiding having
    to define an interface for the state. It may seem counterintuitive, but this is
    actually a good thing. In class components, state, as a single object, may often
    combine several unrelated things into one state. State is really just a place
    for any and all local variables. By declaring each of these variables independently
    from the others, we can establish much better programming paradigms.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们避免了麻烦的 `this` 关键字。我们还避免了需要为状态定义接口的需要。这看起来可能有些反直觉，但实际上这是一个好事。在类组件中，状态作为一个单一的对象，可能经常将几个不相关的东西组合成一个状态。状态实际上只是一个任何和所有局部变量的地方。通过独立声明这些变量，我们可以建立更好的编程范式。
- en: The `useState` function takes an argument, which is the default state, and returns
    an array of `const` pointing to the value and a method used to update the state.
    The stateful value is `const` because it cannot be updated without re-rendering
    our component. If we call `setClicks`, the component will re-render with a newly
    initialized `const clicks`. You can have several `useState` calls in a single
    function component. Each one manages its own part of the state independently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` 函数接受一个参数，即默认状态，并返回一个指向值和用于更新状态的方法的 `const` 数组。状态值是 `const` 的，因为它不能在不重新渲染我们的组件的情况下更新。如果我们调用
    `setClicks`，组件将重新渲染，并使用新初始化的 `const clicks`。你可以在单个函数组件中调用多个 `useState`。每个 `useState`
    都独立管理其状态的一部分。'
- en: Your state can still be strongly typed when using `useState`. In our case, TypeScript
    infers the type of number for clicks, based on how we've initialized it with a
    number. However, if we wanted to, we could add a type hint such as `useState<number>(0)`
    or `useState<MyType>(0)` to handle more complex types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`useState`时，您的状态仍然可以是强类型的。在我们的例子中，TypeScript根据我们如何用数字初始化它来推断点击的类型。然而，如果我们想的话，我们可以添加一个类型提示，例如`useState<number>(0)`或`useState<MyType>(0)`来处理更复杂类型。
- en: State Management in React
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的状态管理
- en: State is a bit of an overloaded term in the UI development world. Thus far,
    the state we've been referring to is a local state inside of a component. Going
    back to the clicks example, while that value could be passed to a child component
    via the usual means (as a prop), there's no easy way to pass the value to a parent
    component or some distant "cousin" component elsewhere in the DOM tree.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI开发领域，“状态”这个词有点被过度使用了。到目前为止，我们所说的状态是组件内部的一个局部状态。回到点击的例子，虽然这个值可以通过通常的方式（作为一个prop）传递给子组件，但没有简单的方法将这个值传递给父组件或DOM树中其他地方的某个“远亲”组件。
- en: The management of global state is a problem much older than React. It's always
    been fairly simple to create some kind of widget that can internally manage its
    own data, but that widget gets extremely complicated when new requirements are
    introduced that connect the widget's data to other parts of an application. Often
    applications were written in an imperative fashion with hand-coded "events" to
    try to propagate data through some global scope. This approach can work, but bugs
    are common and managing change can be extremely difficult. A likely outcome of
    an ad hoc approach to state management is unmaintainable spaghetti code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 全局状态的管理是一个比React更老的问题。创建某种可以内部管理其自身数据的组件通常是非常简单的，但当引入新的要求将组件的数据与其他应用程序的部分连接起来时，这个组件会变得极其复杂。通常，应用程序是以命令式的方式编写的，使用手写的“事件”来尝试通过全局作用域传播数据。这种方法可能可行，但错误是常见的，管理变化可能非常困难。对状态管理采取临时方法的一个可能结果是难以维护的意大利面代码。
- en: React does have a "brute force" approach to state management, which is that
    all data is stored in some parent component and passed (along with any necessary
    methods to update the data) to all children and all of their descendants. Doing
    this in a complex application can be really challenging, with long lists of props
    that must always be passed through. For this reason, most developers choose another
    solution.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: React确实有一种“暴力”式的状态管理方法，即所有数据都存储在某个父组件中，并通过（连同更新数据所需的所有必要方法）传递给所有子组件及其所有后代。在复杂的应用程序中这样做可能会非常具有挑战性，需要传递的长列表的props总是必须传递。因此，大多数开发者会选择另一种解决方案。
- en: Redux is a popular library introduced in 2015 that aimed to solve the problem
    of state management by introducing functional programming concepts such as the
    reducer. The concept behind Redux is that an immutable state is stored somewhere
    in the application. Different parts of the application can dispatch actions that
    will produce a new state to replace the old one. Because each version of the immutable
    state can be stored and is immutable (meaning nothing outside this framework can
    change it), it is possible to time-travel through different application states,
    something that can be very useful for development but may also have use in production
    applications, such as an "undo" feature. Redux can be used with almost any web
    application and is not tied to React, but it's very common to find the two of
    them together in an application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个在2015年引入的流行库，旨在通过引入函数式编程概念（如reducer）来解决状态管理问题。Redux背后的概念是，不可变状态存储在应用程序的某个地方。应用程序的不同部分可以发出动作，这些动作将产生一个新的状态来替换旧的状态。因为每个不可变状态版本都可以存储并且是不可变的（这意味着框架外部的任何东西都不能改变它），所以可以穿越不同的应用程序状态，这在开发中非常有用，也可能在生产应用程序中有用，例如“撤销”功能。Redux几乎可以与任何Web应用程序一起使用，并且不绑定到React，但通常在应用程序中会发现两者同时存在。
- en: Redux is powerful but receives criticism for being overly complex and using
    a lot of boilerplate. It also typically requires additional libraries (such as
    `redux-saga` or `redux-thunk`) to make asynchronous calls to a backend server.
    All of these libraries can be very intimidating to newcomers and even challenging
    to use for experienced programmers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Redux功能强大，但因其过于复杂和大量使用样板代码而受到批评。它通常还需要额外的库（如`redux-saga`或`redux-thunk`）来对后端服务器进行异步调用。所有这些库都可能对新手来说非常令人畏惧，甚至对经验丰富的程序员来说使用起来也可能具有挑战性。
- en: React Hooks provides a simpler way using React context. React context allows
    us to set root-level data stores and actions and make them available to components
    deep in the DOM tree without having to pass props all the way through (sometimes
    known as "prop drilling"). The difference between Redux and context is tantamount
    to going from class components and `setState` to function components and `useState`.
    Like the prior example, we are moving from a single state object and complexity
    managing it to multiple contexts that can be managed more simply.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks 提供了一种更简单的方式，使用 React 上下文。React 上下文允许我们设置根级数据存储和操作，并将它们提供给 DOM 树中深处的组件，而无需将
    props 传递到整个路径（有时称为“prop 传递”）。Redux 和上下文之间的区别相当于从类组件和 `setState` 转到函数组件和 `useState`。像先前的例子一样，我们是从一个单一的状态对象及其复杂性管理到多个可以更简单地管理的上下文。
- en: 'Exercise 14.03: React Context'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.03：React 上下文
- en: 'Let''s get some experience with context. For this exercise, you can either
    bootstrap a new `create-react-app` instance or use the one from the previous sections.
    In this exercise, we''ll create two new components and one provider. Technically,
    providers are components too, but they are actually specialized HOCs:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过上下文获得一些经验。对于这个练习，你可以启动一个新的 `create-react-app` 实例，或者使用上一节中的实例。在这个练习中，我们将创建两个新组件和一个提供者。技术上，提供者也是组件，但它们实际上是专门的
    HOC：
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code for this exercise can be found here: [https://packt.link/rUfr4](https://packt.link/rUfr4).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码可以在以下链接找到：[https://packt.link/rUfr4](https://packt.link/rUfr4).
- en: Let's start with the provider. Create `/components` and `/providers` subdirectories
    under your `/src` directory. In the `/providers` directory, create a file called
    `ClickProvider.tsx`. This component will manage our clicks and provide its context
    to descendants.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从提供者开始。在您的 `/src` 目录下创建 `/components` 和 `/providers` 子目录。在 `/providers` 目录下，创建一个名为
    `ClickProvider.tsx` 的文件。此组件将管理我们的点击并提供其上下文给后代。
- en: 'Unlike most components, a provider will export a context and a provider. Some
    guides will create `Context` and then export `Consumer` and `Provider`. Rather
    than using `Consumer`, we will use `useContext`, another React Hook. When using
    `useContext`, the `Consumer` object is not referenced directly:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与大多数组件不同，提供者将导出一个上下文和一个提供者。一些指南会创建 `Context` 然后导出 `Consumer` 和 `Provider`。我们不会使用
    `Consumer`，而是使用另一个 React Hook，即 `useContext`。当使用 `useContext` 时，不会直接引用 `Consumer`
    对象：
- en: '[PRE32]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That''s the basic signature for creating `Context`. We will need to add a type
    hint and a default value. Let''s come to that in a moment after adding `Provider`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是创建 `Context` 的基本签名。我们需要添加一个类型提示和一个默认值。让我们在添加 `Provider` 之后稍后再来处理这个问题：
- en: '[PRE33]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This component takes some props, which are child nodes. It uses `useState` to
    create a `clicks` value and an `update` function, then it returns `Provider` with
    the value and the function.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此组件接受一些属性，即子节点。它使用 `useState` 创建一个 `clicks` 值和一个 `update` 函数，然后返回带有值和函数的 `Provider`。
- en: 'This is the basic provider we need, but it''s not yet good TypeScript. We need
    to add some more types:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们需要的基本提供者，但它还不是好的 TypeScript。我们需要添加一些更多的类型：
- en: '[PRE34]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`ClickContext` will be the type for the value our `Provider` returns and `ContextProps`
    works as a basic prop type for any HOC with children. With these types, we can
    fill out the rest of `Provider`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ClickContext` 将是 `Provider` 返回的值的类型，而 `ContextProps` 作为任何具有子组件的 HOC 的基本 prop
    类型。有了这些类型，我们可以填写 `Provider` 的其余部分：'
- en: '[PRE35]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now let''s add `Clicker.tsx` and `Display.tsx` in the `components` directory:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `components` 目录下添加 `Clicker.tsx` 和 `Display.tsx`：
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This component renders a button and uses the `setClicks` method from `Provider`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此组件渲染一个按钮并使用 `Provider` 中的 `setClicks` 方法：
- en: '[PRE37]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`Display.tsx` just grabs the `clicks` value from the context and displays it.'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Display.tsx` 只是从上下文中获取 `clicks` 值并显示它。'
- en: Now that we have a couple of simple components that work with our provider,
    let's add them to `App.tsx` and see how our app looks.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有几个与我们的提供者一起工作的简单组件，让我们将它们添加到 `App.tsx` 中，看看我们的应用看起来如何。
- en: 'Delete the default code from `App.tsx` and replace it with `Provider` and the
    new components:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `App.tsx` 中删除默认代码，并用 `Provider` 和新组件替换：
- en: '[PRE38]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the app and click the button several times. The counter will increment.
    It''s not that amazing to make a counter increment on a website, but our components
    are nicely decoupled and this approach will scale well to much larger apps:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行应用并多次点击按钮。计数器将增加。在网站上制作计数器增加并不那么令人惊叹，但我们的组件是很好地解耦的，并且这种方法可以很好地扩展到更大的应用：
- en: '![Figure 14.4: App displaying the click counter'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.4：显示点击计数的应用'
- en: '](img/B14508_14_04.jpg)'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14508_14_04.jpg](img/B14508_14_04.jpg)'
- en: 'Figure 14.4: App displaying the click counter'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：显示点击计数的应用
- en: In this exercise, we used React context to manage state in an application. We
    showed how different components can interact with the state and how it can be
    passed to components without the need for nested props.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了React上下文来管理应用中的状态。我们展示了不同的组件如何与状态交互，以及如何在不需要嵌套属性的情况下将状态传递给组件。
- en: React applications can contain multiple contexts or a single tree of data. React
    context will even keep the current state while a modified component reloads in
    development mode so you can keep coding without interrupting the application flow.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: React应用可以包含多个上下文或单一的数据树。React上下文甚至可以在开发模式下，当修改的组件重新加载时保持当前状态，这样你就可以在不中断应用流程的情况下继续编码。
- en: Firebase
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firebase
- en: Firebase is a mobile and web development platform owned by Google. Firebase
    includes a web API so you can add authentication, analytics, a database, and more
    to a web application. Firebase can be used as the backend of a modern web application,
    allowing developers to focus on user experience. It includes a free tier that
    we will use for the following exercise.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase是由谷歌拥有的移动和Web开发平台。Firebase包括一个Web API，因此你可以向Web应用添加身份验证、分析、数据库等。Firebase可以用作现代Web应用的后端，让开发者能够专注于用户体验。它包括一个免费层，我们将在以下练习中使用。
- en: 'Exercise 14.04: Getting Started with Firebase'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.04：开始使用Firebase
- en: 'In this exercise, we''ll set up a database and authentication using Firebase.
    We''ll need to register a free account. We''ll also get the required payload that
    we''ll need to complete an activity using Firebase later in this chapter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Firebase设置数据库和身份验证。我们需要注册一个免费账户。我们还将获取在本书后面部分使用Firebase完成活动所需的必要有效载荷：
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/bNMr5](https://packt.link/bNMr5).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下链接找到：[https://packt.link/bNMr5](https://packt.link/bNMr5)。
- en: Firebase requires a Google account, but using it doesn't require a credit card
    or any payment. To get started, navigate to [https://firebase.google.com/](https://firebase.google.com/)
    and click `Get started`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Firebase需要谷歌账户，但使用它不需要信用卡或任何支付。要开始，导航到[https://firebase.google.com/](https://firebase.google.com/)并点击`开始使用`。
- en: You should find yourself at the Firebase console. Click `Add project` and work
    through the wizard. You can name your project whatever you like – Firebase will
    make the name unique if you don't.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会出现在Firebase控制台中。点击`添加项目`并完成向导。你可以给你的项目命名任何你喜欢的名字——如果你不指定，Firebase会自动生成一个唯一的名字。
- en: Don't enable Google Analytics, unless you already have an account you want to use.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非你已经有一个想要使用的账户，否则不要启用Google Analytics。
- en: You'll need to wait a minute and then you'll find yourself at your project dashboard.
    There you will find several services you can deploy to help build out your application.
    We will focus only on Authentication and Firestore.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要等待一分钟，然后你将发现自己处于项目仪表板上。在那里，你会找到几个可以部署以帮助构建应用的服务。我们将只关注身份验证和Firestore。
- en: First, go to `Authentication` and click `Get Started`. Choose `Email/Password`
    and enable it. All the other authentication methods require additional setup steps.
    Go ahead and work through those steps if you like. The documentation on the Firebase
    website should be sufficient. Save your changes.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到`身份验证`并点击`开始使用`。选择`电子邮件/密码`并启用它。所有其他身份验证方法都需要额外的设置步骤。如果你喜欢，可以继续完成这些步骤。Firebase网站上的文档应该足够了。保存你的更改。
- en: Now click on `Firestore Database` and `Create database`. Choose the `Start in
    test mode` option and then choose a region to deploy to. The region doesn't really
    matter, but you probably want to choose something that is close to you for faster
    responses. Finish creating the database.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击`Firestore数据库`并`创建数据库`。选择`以测试模式开始`选项，然后选择一个部署区域。区域实际上并不重要，但你可能希望选择一个离你较近的区域以获得更快的响应。完成创建数据库。
- en: One last thing we need to do in the Firebase console is find our app config.
    The way Firebase works is that a config object with a bunch of IDs will live in
    your app and manage connections to your Firebase backend; however, the security
    rules that govern which users can affect which data are all set up in the console
    (or the CLI, which this book doesn't cover). This config is not actually secret
    because if your app is set up correctly, there's nothing a malicious user can
    do that you haven't allowed.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Firebase 控制台中，我们最后需要做的一件事是找到我们的应用程序配置。Firebase 的工作方式是，一个包含多个 ID 的配置对象将存在于您的应用程序中，并管理对
    Firebase 后端的连接；然而，控制哪些用户可以影响哪些数据的权限规则都是在控制台（或本书未涉及的 CLI）中设置的。这个配置实际上并不保密，因为如果您的应用程序设置正确，恶意用户无法执行您未允许的操作。
- en: 'To get your app config, you first must register your app. You can add an app
    either from `Project Overview` (the `</>` symbol) or via the gear next to `Project
    Overview`. Add a web app, name it anything you like, and skip the web hosting
    option. Go into your app config (gear icon) and find the config. Go with config
    over CDN (content delivery network) and you''ll find something that looks like
    this:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取您的应用程序配置，您首先必须注册您的应用程序。您可以从“项目概览”（`</>` 符号）或通过“项目概览”旁边的齿轮添加应用程序。添加一个网络应用程序，您可以给它起任何名字，并跳过网络托管选项。进入您的应用程序配置（齿轮图标）并找到配置。使用通过
    CDN（内容分发网络）的配置，您会找到类似以下的内容：
- en: '[PRE39]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Hang on to that config. We will need it later, but for now we are done in the
    Firebase console. You may wish to return to it later to view your database, manage
    your users, or even upgrade or delete your apps and projects, but you won't need
    to do so again in this chapter.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保留这个配置。我们稍后会用到它，但现在我们在 Firebase 控制台中已经完成了。您可能希望稍后返回查看您的数据库、管理您的用户，甚至升级或删除您的应用程序和项目，但在这个章节中您不需要再次这样做。
- en: Getting started with Firebase is easy. We'll be able to use Firebase to sign
    up, authenticate and track users, and store data, without having to write our
    own backend service.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Firebase 非常简单。我们将能够使用 Firebase 来注册、验证用户、跟踪用户并存储数据，而无需编写自己的后端服务。
- en: Styling React Applications
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化 React 应用
- en: A modern UI developer has a lot of different options when it comes to styling
    applications. The traditional approach of creating a few **Cascading Style Sheets**
    (**CSS**) files and including them is not great for scaling or for building a
    unified presentation layer. Modern web applications and React in particular offer
    so many different options for styling that we can't hope to cover all of them.
    Here are a few popular techniques.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到样式化应用程序时，现代 UI 开发者有很多不同的选择。创建几个 **层叠样式表**（**CSS**）文件并包含它们的传统方法对于扩展或构建统一的表示层来说并不理想。特别是现代网络应用程序和
    React 提供了如此多的样式化选项，我们无法期望涵盖所有这些选项。以下是一些流行的技术。
- en: Master Stylesheet
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主样式表
- en: We have a `styles.css` file with all the styles. Styles are global and will
    affect all components. This can work very well for a small application but has
    some serious scaling problems as you add more styles and components. When new
    styles are added, we may start to see existing components break as they are influenced
    by the new styles.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含所有样式的 `styles.css` 文件。样式是全局的，将影响所有组件。这对于小型应用程序来说可能效果很好，但随着您添加更多样式和组件，会存在一些严重的扩展问题。当添加新样式时，我们可能会看到现有组件因受新样式的影响而开始出现故障。
- en: Component-Scoped Styles
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件作用域样式
- en: With this approach, we create a style for each component that needs styling
    and use the `import` keyword to add the style to your component. A build system
    such as webpack will prefix all of the style names so they don't "pollute" the
    global scope and wind up styling other components. This is the approach you get
    out of the box with Create React App, which uses webpack internally.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们为每个需要样式的组件创建一个样式，并使用 `import` 关键字将样式添加到您的组件中。像 webpack 这样的构建系统将为所有样式名称添加前缀，这样它们就不会“污染”全局作用域，并最终影响其他组件。这是
    Create React App 默认提供的解决方案，它内部使用 webpack。
- en: This approach works well if you can effectively use plain CSS or a stylesheet
    compiler like Sass. Some developers don't like it because display elements are
    spread across CSS and JSX files.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能够有效地使用纯 CSS 或像 Sass 这样的样式表编译器，这种方法效果很好。一些开发者不喜欢它，因为显示元素分散在 CSS 和 JSX 文件中。
- en: CSS-in-JS
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS-in-JS
- en: CSS-in-JS is an approach that has produced popular libraries such as Styled
    Components and Emotion. The approach is simply that we write our CSS in our JavaScript
    (or TypeScript, in our case, as most of these libraries publish typings), thereby
    combining our styling with our display layer.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: CSS-in-JS 是一种产生了诸如 Styled Components 和 Emotion 等流行库的方法。这种方法简单来说就是我们在 JavaScript（或
    TypeScript，在我们的例子中，因为大多数这些库都发布了类型定义）中编写我们的 CSS，从而将我们的样式与显示层结合起来。
- en: This approach works well for teams that create lots of custom components. The downside
    is another build dependency to maintain.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常适合那些创建大量自定义组件的团队。但缺点是又增加了一个需要维护的构建依赖。
- en: Component Libraries
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件库
- en: Component libraries deliver fully usable components ready to be plugged into
    an application. Component libraries are great for building a nice-looking application
    very quickly. Many of them have been around for a lot of years. Some examples
    of component libraries are Twitter Bootstrap, Semantic UI, and Material-UI. All
    of these libraries publish versions designed to work with popular web systems
    such as Angular, Vue, and of course React.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 组件库提供完全可用的组件，可以直接插入到应用程序中。组件库非常适合快速构建一个外观漂亮的应用程序。许多组件库已经存在了很长时间。一些组件库的例子包括 Twitter
    Bootstrap、Semantic UI 和 Material-UI。所有这些库都发布了旨在与流行的 Web 系统（如 Angular、Vue 以及当然还有
    React）一起工作的版本。
- en: Working with a component library is a lot like working with your own components.
    You import the components and use them as you would any other component. Doing
    this can really speed up your development cycles as you have common components
    ready to go. Some teams find the components from the component library too inflexible
    and don't like to deal with the additional dependencies.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件库一起工作与使用自己的组件非常相似。你导入组件，就像使用任何其他组件一样使用它们。这样做可以真正加快你的开发周期，因为你有了现成的常用组件。有些团队发现组件库中的组件太不灵活，不喜欢处理额外的依赖。
- en: The upcoming activity will use Material-UI for a quick and attractive build.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 即将进行的活动将使用 Material-UI 进行快速且吸引人的构建。
- en: 'Activity 14.01: The Blog'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 14.01：博客
- en: Now that we have some experience with `create-react-app` and Firebase, let's
    create a blog! In this activity, we will use all the tools and techniques covered
    earlier in this chapter. We will use `create-react-app` to quickly create a React
    project. We will use Material-UI to design an attractive app and write some of
    our own function components. We will use `react-router` to enable routing between
    the different pages of our application. We'll manage state with the React context
    API. Finally, we'll use Firebase to have a backend service we can use to authenticate
    users and save and share data between visits to the blog.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 `create-react-app` 和 Firebase 有了一些经验，让我们创建一个博客！在这个活动中，我们将使用本章前面覆盖的所有工具和技术。我们将使用
    `create-react-app` 快速创建一个 React 项目。我们将使用 Material-UI 设计一个吸引人的应用程序，并编写一些我们自己的函数组件。我们将使用
    `react-router` 在应用程序的不同页面之间启用路由。我们将使用 React 上下文 API 来管理状态。最后，我们将使用 Firebase 来有一个后端服务，我们可以用它来验证用户并在博客访问之间保存和共享数据。
- en: 'Let''s go through the high-level steps for creating this blog. It sounds like
    a lot, but it won''t be all that challenging when we break it down into individual
    tasks:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建这个博客的高级步骤来了解一下。听起来好像有很多步骤，但如果我们将其分解为单个任务，就不会那么具有挑战性：
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this activity can be found here: [https://packt.link/qqIXz](https://packt.link/qqIXz).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的代码文件可以在以下位置找到：[https://packt.link/qqIXz](https://packt.link/qqIXz)。
- en: Create a new React application using `create-react-app`, as described earlier
    in this chapter. You could even reuse an application you began earlier in this
    chapter. Start your application so you can watch the implementation appear before
    your eyes.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `create-react-app` 创建一个新的 React 应用程序，正如本章前面所述。你甚至可以重用本章前面开始的应用程序。启动你的应用程序，以便你可以亲眼看到实现过程。
- en: Refer back to your Firebase application from *Exercise 14.04, Getting Started
    with Firebase*, or complete that exercise if you haven't yet. Find your config
    data in Firebase and follow the instructions to add the `firebase` dependency
    to your React application, then add the app-specific config from the Firebase
    console.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参考 *第 14.04 节，Firebase 入门* 中的 Firebase 应用程序，或者如果你还没有完成，请完成该练习。在 Firebase 中找到你的配置数据，然后按照说明将
    `firebase` 依赖项添加到你的 React 应用程序中，然后添加 Firebase 控制台中的应用程序特定配置。
- en: Implement the Firebase `auth` and `firestore` services, then add React context
    and providers for each to maintain state.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 Firebase 的 `auth` 和 `firestore` 服务，然后为每个服务添加 React 上下文和提供者以维护状态。
- en: 'Install `react-router` and `material-ui` to build some UI components and create
    some routes. Start by creating a sign-up route and page:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装 `react-router` 和 `material-ui` 来构建一些 UI 组件并创建一些路由。首先创建一个注册路由和页面：
- en: '![Figure 14.5: Landing page'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.5：首页'
- en: '](img/B14508_14_05.jpg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_14_05.jpg)'
- en: 'Figure 14.5: Landing page'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.5：首页
- en: '![Figure 14.6: Sign-up page'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 14.6：注册页面'
- en: '](img/B14508_14_06.jpg)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_14_06.jpg)'
- en: 'Figure 14.6: Sign-up page'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.6：注册页面
- en: 'Create a route to add pages and add UI components to be able to set the title
    and link for a new story:![Figure 14.7: Page for adding stories'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个添加页面的路由，并添加 UI 组件以便能够设置新故事的标题和链接：![图 14.7：添加故事页面
- en: '](img/B14508_14_07.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_14_07.jpg)'
- en: 'Figure 14.7: Page for adding stories'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 14.7：添加故事页面
- en: 'Using your React context and provider and Firebase Firestore, persist your
    data to the cloud and implement other features such as comments:![Figure 14.8:
    Commenting features'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的 React 上下文和提供者以及 Firebase Firestore，将数据持久化到云端并实现其他功能，例如评论：![图 14.8：评论功能
- en: '](img/B14508_14_08.jpg)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_14_08.jpg)'
- en: 'Figure 14.8: Commenting features'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：评论功能
- en: '![Figure 14.9: Posting a comment'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.9：发表评论'
- en: '](img/B14508_14_09.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_14_09.jpg)'
- en: 'Figure 14.9: Posting a comment'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：发表评论
- en: If this activity took some time, don't worry. If you needed to check the solution
    on GitHub, don't worry about that either. This one was particularly challenging
    because it included so many different pieces, but if you managed to pull them
    all together into a working app, that's a great step forward. You've built a full-stack
    application with an attractive UI, authentication, and a database.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这项活动花费了一些时间，请不要担心。如果你需要在 GitHub 上检查解决方案，也无需担心。这个活动尤其具有挑战性，因为它包含了如此多的不同部分，但如果你设法将它们全部整合到一个可工作的应用中，那是一个巨大的进步。你已经构建了一个具有吸引力的
    UI、身份验证和数据库的全栈应用。
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor447).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[这个链接](B14508_Solution_ePub.xhtml#_idTextAnchor447)找到。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: TypeScript is becoming a popular tool for writing web applications and while
    it wasn't always prevalent in React, it is now well supported. Developers no longer
    need to only add types to props but can gain the benefit of type safety and IntelliSense
    while working across all parts of an application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 正在成为编写 Web 应用的流行工具，尽管它过去在 React 中并不总是普遍使用，但现在它得到了很好的支持。开发者不再需要仅仅为
    props 添加类型，而可以在应用的所有部分工作中获得类型安全和智能感知的好处。
- en: React has a very rich and varied ecosystem, but many TypeScript-friendly solutions
    such as React Hooks and React context are becoming go-to choices to keep an application
    simple but powerful. With TypeScript supported in `create-react-app`, it's simple
    to get started and you can be building your app in minutes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: React 拥有一个非常丰富和多样化的生态系统，但许多 TypeScript 兼容的解决方案，如 React Hooks 和 React 上下文，正成为保持应用简单但强大的首选。由于
    `create-react-app` 支持 TypeScript，因此开始使用非常简单，你可以在几分钟内开始构建你的应用。
- en: Developers who want to know more about React will need more than just this book,
    but this chapter serves to show why you want to stay with TypeScript when you
    write applications using React.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于 React 的开发者需要的不只是这本书，但这一章节旨在展示为什么当你使用 React 编写应用时，你想要坚持使用 TypeScript。
