- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Implementing Design Patterns – The Functional Way
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以函数式方式实现设计模式
- en: In [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*, we saw
    several functional techniques to solve different problems. However, programmers
    used to employing OOP may find that we have missed some well-known formulas and
    solutions often used in imperative coding. Since design patterns are well known,
    and programmers will likely already be aware of how they are applied in other
    languages, it’s important to look at how a functional implementation would be
    done.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 10 章*](B19301_10.xhtml#_idTextAnchor188) *确保纯净性* 中，我们看到了解决不同问题的几个函数式技术。然而，习惯于使用
    OOP 的程序员可能会发现我们遗漏了一些在命令式编码中常用的一些知名公式和解决方案。由于设计模式是众所周知的，程序员可能已经了解它们在其他语言中的应用，因此了解函数式实现是如何进行的非常重要。
- en: In this chapter, we shall consider the solutions provided by **design patterns**
    that are common in OOP, to see their equivalent in FP. This will help you transition
    from OOP to a more functional approach and learn more about FP’s power and methods,
    by seeing alternative solutions to problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑 OOP 中常见的 **设计模式** 提供的解决方案，以查看其在 FP 中的等效模式。这将帮助您从 OOP 过渡到更函数式的方法，并通过查看问题的替代解决方案来了解
    FP 的力量和方法。
- en: 'In particular, we will study the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们将研究以下主题：
- en: The concept of *design patterns* and what they apply to
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计模式** 的概念及其适用范围'
- en: A few OOP standard patterns and what alternatives we have in FP if we need one
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 OOP 标准模式和如果需要我们在 FP 中有什么替代方案
- en: The *Observer* pattern, which leads to *reactive programming*, a declarative
    way of dealing with events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者模式**，它导致 **响应式编程**，一种处理事件的声明式方法'
- en: FP design patterns, not related to the OOP ones
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP 设计模式，与 OOP 模式无关
- en: In this chapter, we won’t be worrying much about typing and TypeScript because
    we’ll want to focus on the patterns, minimizing and abstracting everything else.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会过多地担心打字和 TypeScript，因为我们想专注于模式，最小化并抽象其他所有内容。
- en: Understanding design patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解设计模式
- en: 'One of the most relevant books in software engineering is *Design Patterns:
    Elements of Reusable Object-Oriented Software* (1994), written by the **Gang of
    Four** (**GoF**) – Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.
    This book presented about two dozen OOP patterns and has been recognized as highly
    important in computer science.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中最相关的书籍之一是 *《设计模式：可复用面向对象软件元素》*（1994），由 **四人帮**（**GoF**）—— Erich Gamma、Richard
    Helm、Ralph Johnson 和 John Vlissides 所著。这本书介绍了大约二十个 OOP 模式，并被认为在计算机科学中非常重要。
- en: '*Patterns* are actually a concept in architectural design, originally defined
    by an architect, Christopher Alexander. Still, in software terms, a *design pattern*
    is a generally applicable, reusable solution to a commonly-seen problem in software
    design. Rather than a specific finished and coded design, it’s a description of
    a solution (the word *template* is also used) that can solve a given problem that
    appears in many contexts. Given their advantages, design patterns are best practices
    that can be used by developers working with different kinds of systems, programming
    languages, and environments.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式** 实际上是一个建筑设计的概念，最初由建筑师 Christopher Alexander 定义。然而，在软件术语中，**设计模式** 是一种适用于软件设计中常见问题的通用、可重用解决方案。它不是具体的完成和编码的设计，而是一种描述解决方案（也用
    *模板* 一词）的描述，可以解决在许多上下文中出现的问题。鉴于它们的优点，设计模式是开发者可以用于不同类型的系统、编程语言和环境中的最佳实践。'
- en: The GoF book obviously focused on OOP, and some patterns within cannot be recommended
    for or applied in FP. Other patterns are unnecessary or irrelevant because functional
    languages already provide standard solutions to the corresponding object-oriented
    problems. Even given this difficulty, since most programmers have been exposed
    to OOP design patterns and usually try to apply them even in other contexts such
    as FP, it makes sense to consider the original problems and then take a look at
    how a new solution can be produced. The standard object-based solutions may not
    apply, but the problems can still stand, so seeing how to solve them is still
    valid.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GoF 书籍显然专注于 OOP，其中一些模式不适用于或应用于 FP。其他模式是不必要的或无关的，因为函数式语言已经为相应的面向对象问题提供了标准解决方案。即使存在这种困难，由于大多数程序员已经接触过
    OOP 设计模式，并且通常试图在其他上下文中（如 FP）应用它们，因此考虑原始问题并查看如何产生新的解决方案是有意义的。标准基于对象的解决方案可能不适用，但问题仍然存在，因此了解如何解决它们仍然有效。
- en: 'Patterns are often described in terms of four essential, basic elements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模式通常用四个基本、基本元素来描述：
- en: A simple, short *name,* used to describe the problem, its solutions, and its
    consequences. The name helps when talking with colleagues, explaining a design
    decision, or describing a specific implementation.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单、简短的**名称**，用于描述问题、解决方案及其后果。当与同事交谈、解释设计决策或描述特定实现时，名称很有帮助。
- en: The *context* to which the pattern applies – specific situations that require
    a solution, possibly with additional conditions that must be met.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式适用的**上下文** – 需要解决方案的具体情况，可能还需要满足一些附加条件。
- en: A *solution* that lists the elements (classes, objects, functions, relationships,
    and so on) that you’ll need to solve the given situation.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**解决方案**，列出解决给定情况所需的元素（类、对象、函数、关系等）。
- en: The *consequences* (results and trade-offs) if you apply the pattern. You may
    derive some gains from the solution, but it may also imply some losses.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用该模式可能产生的**后果**（结果和权衡）。你可能从解决方案中获得一些收益，但也可能意味着一些损失。
- en: In this chapter, we will assume that you are already aware of the design patterns
    we will describe and use, so we will only provide a few details about them. Rather,
    we will focus on how FP either makes a problem irrelevant (because there is an
    obvious way of applying functional techniques to solve it) or solves it in some
    fashion.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们假设你已经了解我们将描述和使用的所有设计模式，因此我们只会提供一些关于它们的细节。相反，我们将关注FP如何使问题变得无关紧要（因为应用函数式技术解决它的方法很明显）或者以某种方式解决它。
- en: Also, we won’t be going over all of the GoF patterns; we’ll just focus on the
    ones that are the most interesting, that is, those that bring out more differences
    when FP is applied compared to when OOP is applied.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不会涵盖所有GoF模式；我们只会关注那些最有趣的，也就是说，那些在应用函数式编程（FP）与面向对象编程（OOP）相比能带来更多差异的模式。
- en: Design pattern categories
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式类别
- en: 'According to their focus, design patterns are usually grouped into several
    distinct categories. The first three in the following list are the ones that appeared
    in the original GoF book, but more categories have since been added. They are
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们的焦点，设计模式通常被分为几个不同的类别。以下列表中的前三个出现在原始GoF书中，但后来又增加了更多类别。具体如下：
- en: '**Behavioral design patterns** have to do with interactions and communications
    between objects. Rather than focusing on how objects are created or built, the
    key consideration is how to connect them so that they can cooperate when performing
    a complex task, preferably in a way that provides well-known advantages, such
    as diminished coupling or enhanced cohesiveness.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为设计模式**涉及对象之间的交互和通信。与其关注对象是如何创建或构建的，关键考虑的是如何将它们连接起来，以便在执行复杂任务时能够协作，最好是以提供已知优势的方式，例如减少耦合或增强内聚性。'
- en: '**Creational design patterns** deal with ways to create objects in a manner
    suitable for the current problem. With them, you can decide between several alternative
    objects, so the program can work differently, depending on parameters that may
    be known at compilation time or runtime.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型设计模式**处理以适合当前问题的方式创建对象的方法。通过它们，你可以决定在几个替代对象之间进行选择，这样程序可以以不同的方式工作，这取决于可能在编译时或运行时已知的参数。'
- en: '**Structural design patterns** have to do with the composition of objects,
    forming larger structures from many individual parts and implementing relationships
    between objects. Some of the patterns imply inheritance or implementation of interfaces,
    whereas others use different mechanisms, all geared toward being able to dynamically
    change the way objects are composed at runtime.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构设计模式**涉及对象的组合，从许多单个部分形成更大的结构，并实现对象之间的关系。一些模式暗示了继承或接口的实现，而其他模式则使用不同的机制，所有这些机制都是为了能够在运行时动态地改变对象的组合方式。'
- en: '**Concurrency patterns** deal with multithreaded programming. Although FP is
    generally quite appropriate for this (given, for example, the lack of assignments
    and side effects), since we are working with JavaScript, these patterns are not
    very relevant to us.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发模式**处理多线程编程。尽管函数式编程（FP）通常非常合适（例如，考虑到缺乏赋值和副作用），但由于我们使用的是JavaScript，这些模式对我们来说并不非常相关。'
- en: '**Architectural patterns** are more high-level oriented, with a broader scope
    than the previous patterns we’ve listed, and provide general solutions to software
    architecture problems. As is, we aren’t considering such problems in this book,
    so we won’t deal with these either.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构模式**更倾向于高层次，比我们之前列出的模式范围更广，并为软件架构问题提供一般性解决方案。就目前而言，我们在这本书中不考虑这些问题，因此我们也不会处理这些问题。'
- en: 'The categories are not really fixed or set in stone. Fifteen years after the
    original GoF book, three of its authors (see the *Design Patterns 15 Years Later:
    An Interview with Erich Gamma, Richard Helm, and Ralph Johnson* article at [www.informit.com/articles/article.aspx?p=1404056](http://www.informit.com/articles/article.aspx?p=1404056))
    suggested a new list of categories – *Core*, *Creational* (similar to the original
    category, but adding the *Dependency Injection* pattern, which we’ll study later
    on), *Peripheral*, and *Other*.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '这些类别并不是固定不变的，或者说是不可动摇的。在GoF（Gang of Four）原始书籍出版15年后，其三位作者中的三位（参见[www.informit.com/articles/article.aspx?p=1404056](http://www.informit.com/articles/article.aspx?p=1404056)上的*Design
    Patterns 15 Years Later: An Interview with Erich Gamma, Richard Helm, and Ralph
    Johnson*文章）提出了一组新的类别列表——*核心*、*创建型*（类似于原始类别，但增加了*依赖注入*模式，我们将在稍后研究）、*外围*和*其他*。'
- en: Old good practices
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的好习惯
- en: Coupling and cohesiveness are terms that were in use even before OOP came into
    vogue; they date back to the late 1960s when the *Structured Design* book by Larry
    Constantine came out. Coupling measures the interdependence between any two modules,
    and cohesiveness has to do with the degree to which all module components really
    belong together. Low coupling and high cohesiveness are worthy goals for software
    design because they imply that related things are nearby and unrelated ones are
    separate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合和内聚是早在面向对象编程流行之前就使用的术语；它们可以追溯到20世纪60年代末，当时Larry Constantine的*结构化设计*一书出版。耦合衡量任何两个模块之间的相互依赖性，而内聚性与所有模块组件真正属于一起的程度有关。低耦合和高内聚是软件设计值得追求的目标，因为它们意味着相关的事物靠近，而不相关的事物分离。
- en: Following along these lines, you could also classify design patterns as *object
    patterns* (which concern the dynamic relationships between objects) and *class
    patterns* that deal with the relationships between classes and subclasses (which
    are defined statically at compile time). We won’t be worrying much about this
    classification because our point of view has more to do with behaviors and functions,
    rather than classes and objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这个思路，你还可以将设计模式分类为*对象模式*（涉及对象之间的动态关系）和*类模式*，它们处理类与子类之间的关系（这些关系在编译时静态定义）。我们不会过多关注这种分类，因为我们的观点更多地与行为和功能有关，而不是类和对象。
- en: As mentioned earlier, we can now readily observe that these categories are heavily
    oriented toward OOP, and the first three directly mention objects. However, without
    the loss of generality, we will look beyond the definitions, remember what problem
    we were trying to solve, and then look into analogous solutions with FP, which,
    if not 100% equivalent to the OOP ones, will in spirit solve the same problem
    in a parallel way. Let’s move on and start by considering why we want to deal
    with patterns at all!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在可以很容易地观察到这些类别高度倾向于面向对象编程（OOP），前三个类别直接提到了对象。然而，为了不失一般性，我们将超越定义，记住我们试图解决的问题，然后探讨与函数式编程（FP）类似的解决方案，这些解决方案虽然可能不是100%等同于面向对象的解决方案，但精神上将以并行的方式解决相同的问题。让我们继续前进，首先考虑我们为什么要处理模式！
- en: Do we need design patterns?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们需要设计模式吗？
- en: An interesting point of view says that design patterns are only needed to patch
    the shortcomings of programming languages. The rationale is that if you can solve
    a problem with a given programming language in a simple, direct, and straightforward
    way, then you may not need a design pattern at all. (For example, if your language
    doesn’t provide recursion, you would have to implement it on your own; otherwise,
    you can just use it without further ado.) However, studying patterns lets you
    think about different ways of solving problems, so that’s a point in their favor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的观点认为，设计模式只是为了修补编程语言的不足。其理由是，如果你可以用一种简单、直接和直截了当的方式用给定的编程语言解决问题，那么你可能根本不需要设计模式。（例如，如果你的语言不提供递归，你必须自己实现它；否则，你就可以直接使用它，无需进一步操作。）然而，研究模式让你思考解决问题的不同方式，这是它们的一个优点。
- en: In any case, it’s interesting for OOP developers to understand why FP helps
    solve some problems without needing further tools. In the next section, we shall
    consider several well-known design patterns and examine why we don’t need them
    or how we can easily implement them. It’s also a fact that we have already applied
    several patterns earlier in the text, so we’ll also point out those examples.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，对于面向对象（OOP）开发者来说，了解FP如何帮助解决某些问题而无需进一步工具是有趣的。在下一节中，我们将考虑几个知名的设计模式，并探讨为什么我们不需要它们或我们如何可以轻松实现它们。事实上，我们已经在文本中应用了几个模式，因此我们也会指出那些例子。
- en: We won’t try, however, to express or convert all design patterns into FP terms.
    For example, the Singleton pattern basically requires a single, global object,
    which is sort of opposed to everything that functional programmers are used to.
    Given our approach to FP (remember *Sorta Functional Programming* (SFP), from
    the first chapter of this book?), we won’t mind either, and if a Singleton is
    required, we may consider using it, even though FP doesn’t have an appropriate
    equivalent. (And, as we’ll see soon enough, every time you import from a module
    you’re using a Singleton!)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会尝试将所有设计模式都表达或转换为函数式编程（FP）术语。例如，单例模式基本上需要一个单一的全局对象，这在某种程度上与函数式程序员所习惯的一切相悖。鉴于我们对FP的方法（记得本书第一章中的“Sorta
    Functional Programming”（SFP）吗？），我们也不会介意，如果需要单例，我们可能会考虑使用它，即使FP没有合适的等价物。（而且，正如我们很快就会看到的，每次你从一个模块导入时，你都在使用一个单例！）
- en: Finally, it must be said that our point of view may affect what is considered
    a pattern and what isn’t. What may be a pattern to some may be considered a trivial
    detail for others. We will find some such situations, given that FP lets us solve
    some particular problems in easy ways, and we have already seen examples of that
    in previous chapters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须说的是，我们的观点可能会影响人们认为是什么模式以及不是什么模式。对某些人来说可能是模式的东西，对其他人来说可能只是微不足道的细节。鉴于FP让我们能够以简单的方式解决某些特定问题，我们已经在前几章中看到了这样的例子，我们将发现一些这样的情况。
- en: Object-oriented design patterns
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象设计模式
- en: In this section, we’ll review some of the GoF design patterns, check whether
    they are pertinent to FP, and study how to implement them. Of course, some design
    patterns don’t get an FP solution. As an example, there’s no equivalent for a
    Singleton, which implies the foreign concept of a globally accessed object. Additionally,
    while it’s true that you may no longer need OOP-specific patterns, developers
    will still think in terms of those. Also, since we’re not going fully functional,
    if some OOP pattern fits, why not use it even if it’s not fully functional?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些GoF设计模式，检查它们是否与FP相关，并研究如何实现它们。当然，有些设计模式没有FP解决方案。例如，没有单例的等价物，这暗示了全局访问对象的外来概念。此外，虽然你可能不再需要面向对象的特定模式，但开发者仍然会以这些模式为思考方式。而且，由于我们不会完全采用函数式编程，如果某些OOP模式适用，为什么不用它呢，即使它不是完全函数式的？
- en: 'We will be considering the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑以下内容：
- en: '**Façade** and **Adapter** to provide new interfaces to other code'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**门面**（Façade）和**适配器**（Adapter）为其他代码提供新的接口'
- en: '**Decorator** (also known as **Wrapper**) to add new functionality to existing
    code'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**（Decorator）（也称为**包装器**（Wrapper））向现有代码添加新功能'
- en: '**Strategy**, **Template**, and **Command** to let you fine-tune algorithms
    by passing functions as parameters'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**（Strategy）、**模板**（Template）和**命令**（Command）通过传递函数作为参数来让你微调算法'
- en: '**Dependency Injection** to help in decoupling components and simplify testing'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**（Dependency Injection）有助于解耦组件并简化测试'
- en: '**Observer**, which leads to reactive programming, a declarative way of dealing
    with events'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**（Observer），它导致响应式编程，一种声明式处理事件的方式'
- en: Other patterns that do not so fully match the corresponding OOP ones
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他不完全符合相应面向对象（OOP）模式的模式
- en: Let’s begin our study by analyzing a couple of similar patterns that let you
    use your code in somewhat different ways.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过分析几个让你以不同方式使用代码的类似模式开始我们的研究。
- en: Facade and Adapter
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 门面（Facade）和适配器（Adapter）
- en: Out of these two patterns, let’s start with the Facade or, more correctly, Façade.
    This is meant to solve the problem of providing a different interface to the methods
    of a class or to a library. The idea is to provide a new interface to a system
    that makes it easier to use. You might say that a Façade provides a better control
    panel to access certain functionalities, removing difficulties for the user.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种模式中，让我们从外观（Facade）开始，或者更准确地说，外观（Façade）。这是为了解决为类或库的方法提供不同接口的问题。想法是为系统提供一个新的接口，使其更容易使用。你可以说外观提供了一个更好的控制面板来访问某些功能，消除了用户的困难。
- en: S or K?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: S还是K？
- en: '*Façade* or *facade*? The original word is an architectural term meaning *the
    front of a building* and comes from the French language. According to this source
    and the usual sound of the cedilla (ç) character, its pronunciation is a bit like
    *fuh-sahd*. The other spelling probably has to do with the lack of international
    characters in keyboards and poses the following problem – shouldn’t you read it
    as *fah-Kade*? You may see this problem as the reverse of *Celtic*, which is pronounced
    as *Keltic*, changing the *s* sound to a *k* sound.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*外观*或*外观*？原始单词是一个建筑术语，意为“建筑物的正面”，源自法语。根据这个来源和通常的撇号（ç）字符的发音，它的发音有点像*fuh-sahd*。另一种拼写可能与国际键盘上缺少国际字符有关，并提出了以下问题——你不应该读作*fah-Kade*吗？你可能会将这个问题视为*凯尔特人*的相反，发音为*Keltic*，将*s*音变为*k*音。'
- en: The main problem we want to solve is using external code more easily. (Of course,
    if it were your code, you could handle such problems directly; we must assume
    you cannot – or shouldn’t – Insert space try to modify that other code. This would
    be the case when you use any library available over the web, for example.) The
    key is to implement a module that will provide an interface that better suits
    your needs. Your code will use your module and won’t directly interact with the
    original code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要解决的主要问题是以更简单的方式使用外部代码。（当然，如果这是你的代码，你可以直接处理这类问题；我们必须假设你无法——或者不应该——尝试修改其他代码。这通常发生在你使用任何可在网络上获得的库时，例如。）关键是实现一个模块，它将提供一个更适合你需求的接口。你的代码将使用你的模块，而不会直接与原始代码交互。
- en: 'Suppose that you want to do Ajax calls, and your only possibility is using
    some hard library with a really complex interface. With modules, you might write
    something like the following, working with an imagined, hard-to-use Ajax library:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想进行Ajax调用，而你唯一的选择是使用一些具有非常复杂界面的困难库。使用模块，你可能编写如下内容，与一个想象中的、难以使用的Ajax库一起工作：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, if you need to do `GET` or `POST`, instead of having to go through all
    of the complications of the provided complex Ajax library, you can use the new
    façade that provides a simpler way of working. Developers would write `import
    {getUrl, postUrl} from "simpleAjax"` and work more reasonably.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你需要执行`GET`或`POST`操作，你不必通过提供的复杂Ajax库的所有复杂性，可以使用提供更简单工作方式的新外观。开发者将编写`import
    {getUrl, postUrl} from "simpleAjax"`并更合理地工作。
- en: 'Nowadays, with `import`/`export` support in browsers, code will work as shown
    previously. Before that (or for backward-compatibility reasons) the implementation
    would require the usage of an **Immediately Invoked Function Expression** (**IIFE**),
    as covered in the *Immediate invocation* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, using a **revealing module** pattern. The way to
    implement the pattern would then be as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着浏览器对`import`/`export`的支持，代码将像之前显示的那样工作。在那之前（或者出于向后兼容性的原因），实现将需要使用立即执行函数表达式（**IIFE**），如[*第3章*](B19301_03.xhtml#_idTextAnchor054)中“立即调用”部分所述，*开始使用函数*，使用**揭示模块**模式。那么实现该模式的办法如下：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The reason for the *revealing module* name should now be apparent. With the
    preceding code, because of the JavaScript scope rules, the only visible attributes
    of `simpleAjax` will be `simpleAjax.getUrl` and `simpleAjax.postUrl`; using an
    IIFE lets us implement the module (and, hence, the façade) safely, making implementation
    details private.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*揭示模块*名称的原因现在应该很明显了。在先前的代码中，由于JavaScript的作用域规则，`simpleAjax`可见的属性只有`simpleAjax.getUrl`和`simpleAjax.postUrl`；使用立即执行函数表达式（IIFE）让我们能够安全地实现模块（以及，因此，外观），使实现细节保持私有。'
- en: Of modules and singletons
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模块和单例
- en: In modern JavaScript, modules are a case of the Singleton pattern. (In math,
    a “singleton” is a set with just one element.) If you import a module in several
    different places of your code, all references will be to the same object, precisely
    as the Singleton pattern requires in object-oriented code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代JavaScript中，模块是单例模式的一个例子。（在数学中，“单例”是一个只有一个元素的集合。）如果你在代码的几个不同地方导入一个模块，所有引用都将指向同一个对象，这正是单例模式在面向对象代码中要求的。
- en: Now, the Adapter pattern is similar, insofar as it is also meant to define a
    new interface. However, while Façade defines a new interface to old code, Adapter
    is used when you need to implement an old interface for new code, so it will match
    what you already have. If you are working with modules, it’s clear that the same
    type of solution that worked for Façade will work here, so we don’t have to study
    it in detail. Now, let’s continue with a well-known pattern, which we saw earlier
    in this book!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，适配器模式与之类似，因为它也是旨在定义一个新的接口。然而，虽然外观（Façade）模式定义了一个新的接口来旧代码，适配器模式用于当你需要为新代码实现旧接口时，因此它会匹配你已有的内容。如果你正在使用模块，很明显，适用于外观模式的相同类型的解决方案在这里也会起作用，所以我们不需要详细研究它。现在，让我们继续探讨一个我们在这本书中之前已经看到过的著名模式！
- en: Decorator or Wrapper
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器或包装器
- en: The Decorator pattern (also known as Wrapper) is useful when you want to add
    additional responsibilities or functionalities to an object in a dynamic way.
    Let’s consider a simple example, which we will illustrate with some React code.
    (Don’t worry if you do not know this framework; the example will be easy to understand.
    The idea of using React is because it can take advantage of this pattern very
    well. Also, we have already seen pure JavaScript higher-order function examples,
    so it’s good to see something new.) Suppose we want to show some elements on the
    screen, and for debugging purposes, we want to show a thin red border around an
    object. How can you do it?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式（也称为包装器）在你想要以动态方式向对象添加额外职责或功能时非常有用。让我们考虑一个简单的例子，我们将用一些React代码来展示它。（如果你不知道这个框架，不用担心；例子会很容易理解。使用React的想法是因为它能够很好地利用这个模式。此外，我们已经看到了纯JavaScript高阶函数的例子，所以看到一些新内容是好的。）假设我们想在屏幕上显示一些元素，并且出于调试目的，我们想在对象周围显示一个细红色的边框。你该如何做？
- en: If you were using OOP, you would have to create a new subclass with the extended
    functionality. For this particular example, you might provide some attribute with
    the name of some CSS class that would provide the required style, but let’s keep
    our focus on OOP; using CSS won’t always solve this software design problem, so
    we want a more general solution. The new subclass would know how to show itself
    with a border, and you’d use this subclass whenever you wanted an object’s border
    to be visible.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用面向对象编程（OOP），你必须创建一个新的子类来提供扩展的功能。对于这个特定的例子，你可能提供一个带有CSS类名的属性，该类名提供所需的样式，但让我们保持对面向对象编程的关注；使用CSS并不总是解决这个软件设计问题，所以我们想要一个更通用的解决方案。新的子类将知道如何显示自己带有边框，并且你将使用这个子类来显示任何你想要边框可见的对象。
- en: With our experience with higher-order functions, we can solve this differently
    by *wrapping* the original function within another one, which would provide extra
    functionality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对高阶函数的经验，我们可以通过在另一个函数中*包装*原始函数来以不同的方式解决这个问题，该函数将提供额外的功能。
- en: Note that we have already seen some examples of wrapping in the *Wrapping functions
    – keeping behavior* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions*. For example, in that section, we saw how to wrap functions
    to produce new versions that could log their input and output, provide timing
    information, or even memorize calls to avoid future delays. On this occasion,
    we are applying the concept to decorate a visual component, but the principle
    remains the same.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在[*第6章*](B19301_06.xhtml#_idTextAnchor107)“包装函数 – 保持行为”部分已经看到了一些包装的例子。例如，在该部分中，我们看到了如何包装函数以产生新的版本，这些版本可以记录输入和输出，提供计时信息，甚至记住调用以避免未来的延迟。这次，我们将这个概念应用于装饰一个视觉组件，但原则是相同的。
- en: 'Let’s define a simple React component, `ListOfNames`, that can display a heading
    and a list of people, and for the latter, we will use a `FullNameDisplay` component.
    The code for those elements would be as shown in the following fragment:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的React组件`ListOfNames`，它可以显示一个标题和一组人员名单，对于后者，我们将使用`FullNameDisplay`组件。这些元素的代码如下所示：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `ListOfNames` component uses mapping to create a `FullNameDisplay` component
    to show data for each person. The logic for our application could then be the
    following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListOfNames` 组件使用映射创建一个 `FullNameDisplay` 组件来显示每个人的数据。我们的应用程序的逻辑可能是以下这样：'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Do as I say...
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 照我说的做...
- en: In real life, you wouldn’t put all the code for every component in the same
    single source code file – and you would probably have a few CSS files. However,
    for our example, having everything in one place and using inline styles is enough,
    so bear with me and keep in mind the saying *“Do as I say, not as* *I do.”*
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，你不会把每个组件的所有代码都放在同一个源代码文件中——你可能会有一两个 CSS 文件。然而，在我们的例子中，把所有东西放在一个地方并使用内联样式就足够了，所以请耐心一点，记住这句话
    *“照我说的做，别照我做的做。”*
- en: 'We can quickly test the result in the online React sandbox at [codesandbox.io/](http://codesandbox.io/);
    google `react online sandbox` if you want other options. The interface design
    isn’t much to talk about (so please don’t criticize my poor web page!) because
    we are interested in design patterns right now; refer to *Figure 11**.1*, given
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速在 [codesandbox.io/](http://codesandbox.io/) 的在线 React 沙盒中测试结果；如果你想要其他选项，请谷歌搜索
    `react online sandbox`。界面设计没什么可说的（所以请不要批评我的糟糕网页！）因为我们现在对设计模式感兴趣；参考 *图 11.1*，如下所示：
- en: '![Figure 11.1 – The original version of our components shows a (not much to
    speak about) list of names](img/Figure_11.1_B19301.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 我们组件的原始版本显示了一个（没什么可说的）名字列表](img/Figure_11.1_B19301.jpg)'
- en: Figure 11.1 – The original version of our components shows a (not much to speak
    about) list of names
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 我们组件的原始版本显示了一个（没什么可说的）名字列表
- en: 'In React, inline components are written in JSX (inline HTML style) and compiled
    into objects, which are later transformed into HTML code to be displayed. Whenever
    the `render()` method is called, it returns a structure of objects. So, we will
    write a function that will take a component as a parameter and return a new JSX,
    a wrapped object. In our case, we’d like to wrap the original component within
    `<div>` with the required border:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，内联组件是用 JSX（内联 HTML 风格）编写的，并编译成对象，这些对象随后被转换成 HTML 代码以供显示。每当调用 `render()`
    方法时，它都会返回一个对象结构。因此，我们将编写一个函数，它将组件作为参数，并返回一个新的 JSX，一个包裹的对象。在我们的例子中，我们希望将原始组件包裹在
    `<div>` 中，并添加所需的边框：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you wish, you can make this function aware of whether it’s executing in development
    mode or production; in the latter case, it would simply return the original component
    argument without any change, but let’s not worry about that now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以让这个函数知道它是在开发模式还是生产模式下执行；在后一种情况下，它将简单地返回原始组件参数而不做任何更改，但现在我们不必担心这个问题。
- en: 'We now have to change `ListOfNames` to use wrapped components; the new version
    would be as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须将 `ListOfNames` 改为使用包裹组件；新版本如下所示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The decorated version of the code works as expected: each of the `ListOfNames`
    components is now wrapped in another component that adds the desired border to
    them; refer to *Figure 11**.2*, given as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰过的代码按预期工作：每个 `ListOfNames` 组件现在都被另一个组件包裹，为它们添加了所需的边框；参考 *图 11.2*，如下所示：
- en: '![Figure 11.2 – The decorated ListOfNames component is still nothing much to
    look at, but now it shows an added border](img/Figure_11.2_B19301.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 装饰过的 ListOfNames 组件看起来仍然没什么特别的，但现在它显示了一个添加的边框](img/Figure_11.2_B19301.jpg)'
- en: Figure 11.2 – The decorated ListOfNames component is still nothing much to look
    at, but now it shows an added border
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 装饰过的 ListOfNames 组件看起来仍然没什么特别的，但现在它显示了一个添加的边框
- en: In earlier chapters, we saw how to decorate a function, wrapping it inside of
    another function, so it would perform extra code and add a few functionalities.
    Here, we saw how to apply the same solution style to provide a *higher-order component*
    (as it’s called in React parlance), wrapped in an extra `<div>` to provide some
    visually distinctive details.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何装饰一个函数，将其包裹在另一个函数中，以便它执行额外的代码并添加一些功能。在这里，我们看到了如何将相同的解决方案风格应用于提供
    *高阶组件*（在 React 术语中称为），并包裹在额外的 `<div>` 中以提供一些视觉上的独特细节。
- en: A Redux decorator
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Redux 装饰器
- en: If you have used Redux and the `react-redux` package, you may note that the
    latter’s `connect()` method is also a decorator in the same sense; it receives
    a component class, and returns a new component class, connected to the store,
    for usage in your forms. Refer to [github.com/reduxjs/react-redux](http://github.com/reduxjs/react-redux)
    for more details.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过 Redux 和 `react-redux` 包，你可能已经注意到后者的 `connect()` 方法在相同的意义上也是一个装饰器；它接收一个组件类，并返回一个新的组件类，该类连接到存储库，以便在你的表单中使用。有关更多详细信息，请参阅
    [github.com/reduxjs/react-redux](http://github.com/reduxjs/react-redux)。
- en: Let’s move to a different set of patterns that will let us change how functions
    perform.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向另一组模式，这些模式将允许我们改变函数的执行方式。
- en: Strategy, Template, and Command
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略、模板和命令
- en: The Strategy pattern applies whenever you want to have the ability to change
    a class, method, or function, possibly in a dynamic way, by changing the way it
    actually does whatever it’s expected to do. For example, a GPS application might
    want to find a route between two places by applying different strategies if the
    person is on foot, rides a bicycle, or goes by car. In that case, the fastest
    or the shortest routes might be desired. The problem is the same, but different
    algorithms must be applied, depending on the given condition.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式适用于你想要能够通过改变方式来改变类、方法或函数，可能以动态的方式，即通过改变它实际执行预期任务的方式。例如，一个 GPS 应用程序可能需要根据人是步行、骑自行车还是开车来应用不同的策略，在两个地点之间找到一条路径。在这种情况下，可能需要最快的或最短的路线。问题是相同的，但必须根据给定条件应用不同的算法。
- en: Does this sound familiar? If so, it is because we have already met a similar
    problem. When we wanted to sort a set of strings in different ways, in [*Chapter
    3*](B19301_03.xhtml#_idTextAnchor054), *Starting Out with Functions*, we needed
    a way to specify how the ordering was to be applied or, equivalently, how to compare
    two given strings and determine which had to go first. Depending on the language,
    we had to sort applying different comparison methods.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来熟悉吗？如果是的话，那是因为我们之前已经遇到过类似的问题。当我们想要以不同的方式对一组字符串进行排序时，在 [*第 3 章*](B19301_03.xhtml#_idTextAnchor054)，*从函数开始*，我们需要一种指定应用排序方式的方法，或者说，如何比较两个给定的字符串并确定哪个应该排在前面。根据语言的不同，我们必须应用不同的比较方法来排序。
- en: 'Before trying an FP solution, let’s consider more ways of implementing our
    routing function. You could make do by having a big enough piece of code, which
    would receive an argument declaring which algorithm to use, plus the starting
    and ending points. With these arguments, the function could do a switch or something
    similar to apply the correct path-finding logic. The code would be roughly equivalent
    to the following fragment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试 FP 解决方案之前，让我们考虑更多实现我们的路由函数的方法。你可以通过编写足够大的代码片段来做到这一点，该代码片段接收一个声明要使用哪个算法的参数，以及起点和终点。有了这些参数，函数可以进行切换或类似操作，以应用正确的路径查找逻辑。代码大致相当于以下片段：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This kind of solution is not desirable, and your function is the sum of many
    distinct other functions, which doesn’t offer a high level of cohesion. If your
    language doesn’t support lambda functions (as was the case with Java, for example,
    until Java 8 came out in 2014), the OOP solution for this requires defining classes
    that implement the different strategies you may want, creating an appropriate
    object, and passing it around.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案并不理想，你的函数是许多不同函数的总和，这并不提供高度的凝聚力。如果你的语言不支持 lambda 函数（例如，Java 在 2014 年 Java
    8 发布之前就是这样），那么这个 OOP（面向对象编程）解决方案需要定义实现你可能想要的策略的不同类的类，创建一个适当的对象，并将其传递出去。
- en: 'With FP in JavaScript, implementing strategies is trivial; instead of using
    a variable such as `byMeans` to switch, you provide a route-finding function (`routeAlgorithm()`
    in the following code) that will implement the desired path logic:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中使用 FP（函数式编程），实现策略变得非常简单；你不需要使用像 `byMeans` 这样的变量来切换，而是提供一个路由查找函数（以下代码中的
    `routeAlgorithm()`），该函数将实现所需的路径逻辑：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You would still have to implement all of the desired strategies (there’s no
    way around that) and decide which function to pass to `findRoute()`, but now that
    function is independent of the routing logic, and if you wanted to add new routing
    algorithms, you wouldn’t touch `findRoute()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要实现所有期望的策略（这是不可避免的）并决定传递给 `findRoute()` 的函数，但现在这个函数与路由逻辑独立，如果你想要添加新的路由算法，你就不需要修改
    `findRoute()`。
- en: If you consider the Template pattern, the difference is that Strategy allows
    you to use completely different ways of achieving an outcome, while Template provides
    an overarching algorithm (or template) in which some implementation details are
    left to methods to be specified. In the same way, you can provide functions to
    implement the Strategy pattern; you can also provide them for a Template pattern.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑模板模式，区别在于策略允许你使用完全不同的方式来实现结果，而模板提供了一个包含一些实现细节留给方法来指定的总体算法（或模板）。同样，你可以提供实现策略模式的函数；你也可以为模板模式提供它们。
- en: Finally, the Command pattern also benefits from the ability to be able to pass
    functions as arguments. This pattern is meant to be enabled to encapsulate a request
    as an object, so for different requests, you have differently parameterized objects.
    Given that we can pass functions as arguments to other functions, there’s no need
    for the enclosing object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，命令模式还受益于能够将函数作为参数传递的能力。这种模式旨在能够将请求封装为一个对象，因此对于不同的请求，你有不同参数化的对象。鉴于我们可以将函数作为参数传递给其他函数，就没有必要有封装对象。
- en: We also saw a similar use of this pattern back in the *A React-Redux reducer*
    section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054)*, Starting Out with
    Functions*. There, we defined a table, each of whose entries was a callback that
    was called whenever needed. We could directly say that the Command pattern is
    just an **object-oriented** (OO) replacement for plain functions working as callbacks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第3章*的*“使用函数入门”*部分的*“React-Redux reducer”*部分也看到了这种模式的类似使用。[第3章](B19301_03.xhtml#_idTextAnchor054)*，*“使用函数入门”*。在那里，我们定义了一个表，其中的每个条目都是一个回调，每当需要时就会被调用。我们可以直接说命令模式只是作为回调函数工作的**面向对象**（OO）替代。
- en: Let’s now consider a related pattern, Dependency Injection, that will also let
    us change how a method or function works.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个相关的模式，依赖注入，它也将允许我们改变方法或函数的工作方式。
- en: Dependency Injection
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: In basic terms, Dependency Injection is a pattern in which an object or function
    receives any other objects or functions that it needs to do its job, leading to
    less coupling and more flexibility. With this technique, a service can work in
    multiple environments or with different configurations, and changing it may be
    achieved without having to modify its code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本术语中，依赖注入是一种模式，其中对象或函数接收它完成工作所需的任何其他对象或函数，这导致更少的耦合和更多的灵活性。使用这种技术，一个服务可以在多个环境中工作或使用不同的配置，并且改变它可能不需要修改其代码。
- en: To make things clearer, let’s consider a service, implemented in Node plus Express,
    that gets a request, interacts with other entities (maybe it queries a database,
    accesses some file buckets, posts a message to a message queue, calls some other
    services, etc.) and eventually builds a response to send back. What’s wrong with
    this? A quick answer would be “*Nothing!*” because it works, and it’s how many
    services are implemented. However, digging a bit further, we may decide the answer
    should be “*Everything*!” Why?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更清晰，让我们考虑一个服务，它使用Node和Express实现，接收一个请求，与其他实体交互（可能查询数据库，访问一些文件存储桶，向消息队列发送消息，调用其他服务等），并最终构建一个响应发送回去。这有什么问题吗？一个快速的答案可能是“*没有问题！*”因为它工作得很好，这也是许多服务实现的方式。然而，进一步挖掘，我们可能会决定答案应该是“*一切都有问题！*”为什么？
- en: 'With any piece of code, there always are three primary concerns:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何一段代码，总有三个主要关注点：
- en: '*Is it understandable?* Our service’s code may be hard to follow because it
    mixes business logic concerns with implementation details, concerning secondary
    matters such as how to query the database and access the buckets.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是否易于理解？* 我们服务的代码可能难以理解，因为它将业务逻辑关注点与实现细节混合在一起，涉及到次要问题，比如如何查询数据库和访问存储桶。'
- en: '*Is it maintainable?* If we wonder how simple it may be to change our service’s
    code, the question is how many reasons for change there may be. A change in business
    logic is always a possibility; that’s essential. However, other changes (using
    Redis instead of MySQL or adding records to a database table instead of sending
    messages to a queue) that aren’t related to the service’s business objectives
    would also require changes in code.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它是否可维护？* 如果我们想知道改变我们服务代码的简单程度，问题就变成了可能有多少种改变的理由。业务逻辑的改变始终是一个可能；这是必要的。然而，其他改变（比如使用Redis代替MySQL或者向数据库表添加记录而不是向队列发送消息）与服务的业务目标无关，也会要求代码的改变。'
- en: '*Is it testable?* We may or may not need to maintain the code (and, indeed,
    if any changes are needed, that would be in the future), but we have to test our
    code today. How would we go about it? Would it be easy?'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可测试性？* 我们可能需要也可能不需要维护代码（实际上，如果需要任何更改，那将是未来的事情），但我们今天必须测试我们的代码。我们将如何进行？这会容易吗？'
- en: The last item is the one we care about now. All the interactions with other
    entities are clearly impure functions, so we could set up our tests in three ways.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是我们现在关心的事项。与其他实体的所有交互都是明显的不纯函数，因此我们可以以三种方式设置我们的测试。
- en: We could work with separate, special environments. Each developer would need
    to have a complete environment (with databases, queues, servers, etc.) so code
    can run as in reality. To do a test, the developer should first set everything
    up in a known fashion and then check whether the database got modified correctly,
    if the right messages were sent, and so on. All this is possible but costly, hard
    to set up, and mainly slow – before each test, you have to reset everything, and
    after each test, you have to check everything.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以与独立的、特殊的环境一起工作。每个开发者都需要一个完整的环境（包括数据库、队列、服务器等），以便代码可以像现实中一样运行。为了进行测试，开发者首先应该以已知的方式设置一切，然后检查数据库是否被正确修改，是否发送了正确的消息，等等。所有这些都是可能的，但成本高昂，设置困难，而且主要很慢——在每次测试之前，你必须重置一切，在每次测试之后，你必须检查一切。
- en: We could work with fully mocked external entities. Tools such as Jest or Jasmine
    allow us to mock entities, so our code, instead of dealing with actual databases,
    queues, services, and so on would (transparently) interact with mocks that mimic
    the needed behaviors. This is much more efficient (because no real environments
    are needed, no actual databases get updated, no messages are really sent, and
    so on), but simulating all the required behaviors is still a lot of work.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用完全模拟的外部实体。像Jest或Jasmine这样的工具允许我们模拟实体，因此我们的代码，而不是处理实际的数据库、队列、服务等等，将与模拟的实体（透明地）交互，这些实体模仿了所需的行为。这要高效得多（因为不需要真实的环境，没有实际的数据库被更新，没有消息真正被发送，等等），但模拟所有所需的行为仍然是一项大量工作。
- en: We can make the service less impure first! We saw this approach back in [*Chapter
    4*](B19301_04.xhtml#_idTextAnchor069), *Behaving Properly*, which allows us to
    easily write tests.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以先让服务不那么不纯！我们之前在[*第4章*](B19301_04.xhtml#_idTextAnchor069)中看到了这种方法，*行为规范*，它允许我们轻松编写测试。
- en: Let’s now get to actual details and consider a possible service.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨实际细节，并考虑一个可能的服务。
- en: Implementing a service
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个服务
- en: Imagine we have an endpoint that responds to `GET /client/:id` requests by searching
    for the client in a database and posting a message to a queue after the search.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个端点，它通过在数据库中搜索客户并在搜索后向队列发送消息来响应`GET /client/:id`请求。
- en: We’ll code our service in terms of *ports* (interfaces) and *adapters* (interface
    implementations) that it will receive. In our case, ports will (abstractly) define
    how our service is meant to interact with other entities, and adapters will (concretely)
    implement the needed functionality. With this in mind, we will be able to provide
    different adapters, allowing flexibility for different environments. In a production
    environment, we’ll provide adapters that work, access databases, post messages,
    and so on, but for testing, we’ll be able to inject mock adapters with trivial
    “do nothing” fake implementations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据它将接收的*端口*（接口）和*适配器*（接口实现）来编写我们的服务代码。在我们的情况下，端口将（抽象地）定义我们的服务应该如何与其他实体交互，而适配器将（具体地）实现所需的功能。有了这个想法，我们将能够提供不同的适配器，为不同的环境提供灵活性。在生产环境中，我们将提供能够工作、访问数据库、发送消息等的适配器，但在测试中，我们将能够注入带有简单“什么也不做”的模拟实现。
- en: An architecture by any other name
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他名称的架构
- en: This architectural style is naturally known as “Ports and Adapters,” but it
    also goes by “Hexagonal Architecture” – a much catchier name! Don’t try to figure
    out why the word “hexagonal” is used; it just refers to hexagons being used to
    represent services in diagrams, and nothing else!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构风格自然被称为“端口和适配器”，但它也被称为“六边形架构”——一个更吸引人的名字！不要试图弄清楚为什么使用“六边形”这个词；它只是指在图中使用六边形来表示服务，没有其他含义！
- en: 'Let’s see how this would work. If our service needs to look for a client by
    its ID in a database, we must define a suitable interface, a “find client” port.
    We could define the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。如果我们的服务需要在数据库中通过其ID查找客户，我们必须定义一个合适的接口，一个“查找客户”端口。我们可以定义以下内容：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This definition says that our port will receive a numerical ID as an argument
    and return a promise that will either resolve to a `ClientType` object or `null`.
    (We cannot specify semantic aspects, but it sounds likely that the returned object
    will be the client, if found; `null` would represent a failed search.) We also
    require an actual implementation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义说明我们的端口将接收一个数值ID作为参数，并返回一个承诺，该承诺将解析为一个`ClientType`对象或`null`。（我们无法指定语义方面，但听起来返回的对象很可能是找到的客户端；`null`将代表搜索失败。）我们还需要一个实际实现：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Naming is important; the port definition does not say where the client will
    come from, but the adapter does. We could have different adapters that would look
    for clients in other places (a key store, a spreadsheet, or the filesystem), but
    they would all implement the same interface.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 命名很重要；端口定义并没有说明客户端将从哪里来，但适配器会说明。我们可以有不同的适配器，它们会在其他地方（如密钥存储、电子表格或文件系统）寻找客户端，但它们都会实现相同的接口。
- en: 'Of course, given our service definition, we’ll also need a port and adapter
    for sending messages. How would we now write our service? The code would be as
    follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，根据我们的服务定义，我们还需要一个端口和适配器来发送消息。我们该如何编写我们的服务呢？代码如下：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What are we doing? Our service receives `id` and an optional object providing
    two adapters. If this object is omitted, our service will use default adapters
    that work with a database and a message queue. In our server, the code dealing
    with the `/client/:id` endpoint would use `getClientService(req.params.id)` and,
    thus, work with an actual database and a message queue. But how will we test our
    service? That’s what we need to see now.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在做什么？我们的服务接收`id`和一个可选的对象，该对象提供两个适配器。如果省略此对象，我们的服务将使用与数据库和消息队列一起工作的默认适配器。在我们的服务器中，处理`/client/:id`端点的代码将使用`getClientService(req.params.id)`，因此与实际的数据库和消息队列一起工作。但我们如何测试我们的服务？这正是我们现在需要看到的。
- en: Testing a service
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试一个服务
- en: 'In the previous section, we saw how to call our service in production. However,
    for testing, we would do things differently, such as the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何在生产环境中调用我们的服务。然而，对于测试，我们会采取不同的做法，例如以下内容：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We would first define a couple of mock functions; `findClientMock` would simulate
    a search in the database, and `sendMsgMock` would return whatever a successful
    message-sending operation would return. We can now call our `getClientService()`
    with the mocks, and we would then verify that the (mock) adapters were used properly
    and that the service returns the correct answer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义几个模拟函数；`findClientMock`将模拟数据库中的搜索，而`sendMsgMock`将返回成功消息发送操作会返回的内容。现在我们可以用模拟调用我们的`getClientService()`，然后验证（模拟）适配器是否被正确使用，并且服务返回正确的答案。
- en: Let’s now move on to a classic pattern that implies a new term, *reactive programming*,
    which is being thrown around a lot these days.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论一个经典的模式，它引入了一个新术语，*响应式编程*，这个术语在当今被广泛使用。
- en: Observers and reactive programming
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者和响应式编程
- en: The idea of the Observer pattern is to define a link between entities so that
    when one changes, all dependent entities are updated automatically. An *observable*
    can publish changes to its state, and its observer (which subscribed to the observable)
    will be notified of such changes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式的想法是定义实体之间的联系，以便当一个实体发生变化时，所有依赖的实体都会自动更新。一个*可观察对象*可以发布其状态的变化，并且其观察者（已订阅可观察对象）将收到此类变化的通知。
- en: No observables for now
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有可观察对象
- en: There is a proposal for adding observables to JavaScript (see [github.com/tc39/proposal-observable](http://github.com/tc39/proposal-observable)),
    but as of January 2023, it’s still stuck at stage one, with no activity since
    late 2020\. Hence, for the time being, using a library will still be mandatory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个提议要将可观察对象添加到JavaScript中（见[github.com/tc39/proposal-observable](http://github.com/tc39/proposal-observable)），但截至2023年1月，它仍然处于第一阶段，自2020年末以来没有活动。因此，目前使用库仍然是强制性的。
- en: There’s an extension to this concept called **reactive programming**, which
    involves asynchronous streams of events (such as mouse clicks or keypresses) or
    data (from APIs or WebSockets), and different parts of the application subscribing
    to observe such streams by passing callbacks that will get called whenever something
    new appears.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个扩展这个概念的概念叫做**响应式编程**，它涉及到异步的事件流（如鼠标点击或按键）或数据（来自API或WebSockets），以及应用程序的不同部分通过传递回调来订阅观察这些流，这些回调将在出现新内容时被调用。
- en: We won’t be implementing reactive programming on our own; instead, we’ll use
    RxJS, a JavaScript implementation of Reactive Extensions (*ReactiveX*), initially
    developed by Microsoft. RxJS is widely used in the Angular framework and can also
    be used in other frontend frameworks, such as React or Vue, or the backend with
    Node.js. Learn more about RxJS at [rxjs-dev.firebaseapp.com](http://rxjs-dev.firebaseapp.com)
    and [www.learnrxjs.io](http://www.learnrxjs.io).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会自己实现响应式编程；相反，我们将使用RxJS，这是由微软最初开发的响应式扩展（*ReactiveX*）的JavaScript实现。RxJS在Angular框架中广泛使用，也可以用于其他前端框架，如React或Vue，或者后端使用Node.js。了解更多关于RxJS的信息，请访问[rxjs-dev.firebaseapp.com](http://rxjs-dev.firebaseapp.com)和[www.learnrxjs.io](http://www.learnrxjs.io)。
- en: 'The techniques we will be showing in these sections are, confusingly, called
    both `map()`, `filter()`, and `reduce()` to process those streams and pick which
    events to process and how. Okay, this may be confusing now, so bear with me and
    let’s see some concepts first, and after that, some examples of FRP – or whatever
    you want to call it! We will be seeing the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这些部分展示的技术，令人困惑地被称为`map()`、`filter()`和`reduce()`，用于处理这些流并选择要处理的事件以及如何处理。好吧，现在可能有些令人困惑，所以请耐心一点，我们先看看一些概念，然后是一些FRP的示例——或者你可以称它为什么！我们将看到以下内容：
- en: Several basic concepts and terms you’ll need to work with FRP
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在处理FRP时需要了解的几个基本概念和术语
- en: Some of the many available operators you’ll use
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将使用到的许多可用操作符之一。
- en: A couple of examples – detecting multi-clicks and providing typeahead searches
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个示例——检测多击并提供自动完成搜索。
- en: Let’s proceed to analyze each item, starting with the basic ideas you need to
    know.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续分析每个项目，从你需要了解的基本思想开始。
- en: Basic concepts and terms
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本概念和术语
- en: 'Using FRP requires getting used to several new terms, so let’s begin with a
    short glossary:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FRP需要习惯几个新术语，所以让我们从一份简短的词汇表开始：
- en: '`$`; see [angular.io/guide/rx-library#naming-conventions](http://angular.io/guide/rx-library#naming-conventions).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`; 请参阅[angular.io/guide/rx-library#naming-conventions](http://angular.io/guide/rx-library#naming-conventions)。'
- en: '`next()`, `error()`, and `complete()`, which will be called by the observable
    when a value is available, when there’s an error, and when the stream is ended
    respectively.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()`、`error()`和`complete()`，当有值可用时、出错时以及流结束时，`observable`会分别调用这些方法。'
- en: '`map()`, `filter()`, and so on, from [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*) that let you apply transformations to a stream in
    a declarative way.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[*第5章*](B19301_05.xhtml#_idTextAnchor084)，*声明式编程*的`map()`、`filter()`等，让你以声明式的方式对流应用转换。
- en: '`pipeline()` function we developed in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在[*第8章*](B19301_08.xhtml#_idTextAnchor148)，*连接函数*中开发的`pipeline()`函数。
- en: '`subscribe()` method, providing an observer.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe()`方法，提供一个观察者。'
- en: 'An interesting way of looking at observables is that they complete the lower
    row of this table – check it out. You will probably be quite familiar with the
    *Single* column, but maybe not with the *Multiple* one:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一个有趣的方法是它们完成了这个表格的底部一行——检查一下。你可能对*单个*列非常熟悉，但可能对*多个*列不太熟悉：
- en: '|  | **Single** | **Multiple** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  | **单个** | **多个** |'
- en: '| **Pull** | `Function` | `Iterator` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **拉** | `Function` | `Iterator` |'
- en: '| **Push** | `Promise` | `Observable` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **推** | `Promise` | `Observable` |'
- en: 'How do we interpret this table? The rows distinguish between pull (you call
    something) and push (you get called), and the columns represent how many values
    you get – one or many. With these descriptions, we can see the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解释这个表格？行区分了拉（你调用某个东西）和推（你被调用），而列表示你得到多少个值——一个或多个。有了这些描述，我们可以看到以下内容：
- en: A `function` is called and returns a single value
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`function`被调用并返回一个单一值。
- en: A `promise` calls your code (a callback in the `then()` method), also with a
    single value
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`promise`会调用你的代码（`then()`方法中的回调），也只有一个值。
- en: An `iterator` returns a new value each time it’s called – at least until the
    sequence is over
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`iterator`每次被调用时都会返回一个新的值——至少直到序列结束。
- en: An `observable` calls your code (provided you `subscribe()` to the observable)
    for each value in the stream
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`observable`会在流中的每个值上调用你的代码（前提是你已经`subscribe()`到该`observable`）。
- en: 'Observables and promises can be compared a bit more:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将`Observables`和`promises`比较一下：
- en: They are both mostly `async` in nature, and your callback will be called at
    an indefinite future time
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们本质上都是`async`的，你的回调将在不确定的未来时间被调用。
- en: Promises cannot be canceled, but you can `unsubscribe()` from an observable
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺不能被取消，但你可以从一个`observable`中`unsubscribe()`。
- en: Promises start executing the moment you create them; observables are lazy, and
    nothing happens until an observer does `subscribe()` to them
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺在创建时立即开始执行；可观察对象是惰性的，直到观察者对它们执行 `subscribe()` 操作之前，不会发生任何事情
- en: The real power of observables derives from the variety of operators you can
    use; let’s see some of them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象的真正力量来自于你可以使用的各种操作符；让我们看看其中的一些。
- en: Operators for observables
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可观察对象的操作符
- en: Basically, operators are just functions. Creation operators can be used to create
    observables out of many different sources, and pipeable operators can be applied
    to modify a stream, producing a new observable; we’ll see many families of these,
    but for complete lists and descriptions, you should access [www.learnrxjs.io/learn-rxjs/operators](http://www.learnrxjs.io/learn-rxjs/operators)
    and [rxjs.dev/guide/operators](http://rxjs.dev/guide/operators).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，操作符只是函数。创建操作符可以用来从许多不同的来源创建可观察对象，而可连接操作符可以应用于修改流，产生一个新的可观察对象；我们将看到许多这样的家族，但为了完整的列表和描述，你应该访问
    [www.learnrxjs.io/learn-rxjs/operators](http://www.learnrxjs.io/learn-rxjs/operators)
    和 [rxjs.dev/guide/operators](http://rxjs.dev/guide/operators)。
- en: Also, we won’t be covering how to install RxJS; see [rxjs.dev/guide/installation](http://rxjs.dev/guide/installation)
    for all the possibilities. In particular, in our examples, meant for a browser,
    we’ll be installing RxJS from a CDN, which creates a global `rxjs` variable, similar
    to jQuery’s `$` or Lodash’s `_` variables.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不会涵盖如何安装 RxJS；有关所有可能性，请参阅 [rxjs.dev/guide/installation](http://rxjs.dev/guide/installation)。特别是，在我们的示例中，针对浏览器，我们将从
    CDN 安装 RxJS，这会创建一个全局的 `rxjs` 变量，类似于 jQuery 的 `$` 或 Lodash 的 `_` 变量。
- en: 'Let’s begin by creating observables, and then move on to transforming them.
    For creation, some of the several operators you can use are explained in the following
    table:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建可观察对象，然后继续转换它们。对于创建，以下表格解释了你可以使用的一些几个操作符：
- en: '| **Operator** | **Usage** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **用法** |'
- en: '| `Ajax` | Creates an observable for an Ajax request, for which we’ll emit
    the response that is returned |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `Ajax` | 创建一个用于 Ajax 请求的可观察对象，我们将发出返回的响应 |'
- en: '| `from` | Produces an observable out of an array, an iterable, or a promise
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `from` | 从数组、可迭代对象或承诺中产生一个可观察对象 |'
- en: '| `fromEvent` | Turns events (for example, mouse clicks) into an observable
    sequence |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `fromEvent` | 将事件（例如鼠标点击）转换为可观察序列 |'
- en: '| `interval` | Emits values at periodic intervals |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `interval` | 以周期性间隔发出值 |'
- en: '| `of` | Generates a sequence out of a given set of values |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `of` | 从给定的一组值生成一个序列 |'
- en: '| `range` | Produces a sequence of values in a range |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `range` | 在一个范围内产生一个值的序列 |'
- en: '| `timer` | After an initial delay, emits values periodically |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `timer` | 在初始延迟后，以周期性间隔发出值 |'
- en: 'To give an elementary example, the following three observables will all produce
    a sequence of values from 1 to 10, and we’ll be seeing more practical examples
    a bit later in this chapter:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个基本的例子，以下三个可观察对象都将产生从 1 到 10 的值序列，我们将在本章稍后看到更多实际示例：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The available pipeable operators are way too many for this section, so we’ll
    just go over some families and describe their basic idea, with one or two particular
    mentions. The following table lists the most common families, with their most
    often used operators:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的可连接操作符数量太多，无法在本节中全部涵盖，所以我们只简要介绍一些家族，并描述它们的基本概念，提及一两个特定的例子。以下表格列出了最常见的家族及其最常用的操作符：
- en: '| **Family** | **Description** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **家族** | **描述** |'
- en: '| --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Combination** | These operators allow us to join information from several
    distinct observables, including the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '| **组合** | 这些操作符允许我们结合来自几个不同可观察对象的信息，包括以下内容：'
- en: '`concat()` to put observables in a queue one after the other'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat()` 用于将可观察对象依次放入队列中'
- en: '`merge()` to create a single observable out of many'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge()` 用于从多个可观察对象中创建一个单一的可观察对象'
- en: '`pairWise()` to emit the previous value and the current one as an array'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pairWise()` 用于输出前一个值和当前值作为一个数组'
- en: '`startWith()` to inject a value in an observable'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startWith()` 用于在一个可观察对象中注入一个值'
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Conditional** | These produce values depending on conditions and include
    the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '| **条件** | 这些操作符根据条件产生值，包括以下内容：'
- en: '`defaultIfEmpty()` emits a value if an observable doesn’t emit anything before
    completing'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultIfEmpty()` 如果可观察对象在完成之前没有发出任何内容，则发出一个值'
- en: '`every()` emits true if all values satisfy a predicate and emits false otherwise'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`every()` 如果所有值都满足谓词则发出 true，否则发出 false'
- en: '`iif()` subscribes to one of two observables, depending on a condition, such
    as the ternary `?` operator'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iif()` 根据条件订阅两个可观察对象之一，例如三元 `?` 操作符'
- en: '|'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Error handling** | These (obviously!) apply to error conditions and include
    the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '| **错误处理** | 这些（显然！）适用于错误条件，包括以下内容：'
- en: '`catchError()` to gracefully process an error from an observable'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catchError()` 用于优雅地处理可观察者中的错误'
- en: '`retry()` and `retryWhen()` to retry an observable sequence (most likely, one
    linked to HTTP requests)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry()` 和 `retryWhen()` 用于重试可观察者序列（最可能的是与HTTP请求相关的）'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Filtering** | Probably the most important family, providing many operators
    to process sequences by selecting which elements will get processed or dismissed,
    by applying different types of conditions for your selection. Some of the more
    common ones include the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '| **过滤** | 可能是最重要的家族，提供了许多操作符，通过选择哪些元素将被处理或忽略，并应用不同的条件类型进行选择。其中一些更常见的包括以下内容：'
- en: '`debounce()` and `debounceTime()` to deal with values too close together in
    time'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debounce()` 和 `debounceTime()` 用于处理时间上过于接近的值'
- en: '`distinctUntilChanged()` to only emit when the new value is diﬀerent from the
    last'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinctUntilChanged()` 仅在新值与最后一个值不同时发出'
- en: '`filter()` to only emit values that satisfy a given predicate'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()` 仅发出满足给定谓词的值'
- en: '`find()` to emit only the ﬁrst value that satisﬁes a condition'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find()` 仅发出满足条件的第一个值'
- en: '`first()` and `last()` to pick only the ﬁrst or last values of a sequence'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first()` 和 `last()` 用于选择序列的第一个或最后一个值'
- en: '`skip()` plus `skipUntil()` and `skipWhile()` to discard values'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip()`、`skipUntil()` 和 `skipWhile()` 用于丢弃值'
- en: '`take()` and `takeLast()` to pick a given number of values from the beginning
    or end of a sequence'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()` 和 `takeLast()` 用于从序列的开始或末尾选择给定数量的值'
- en: '`takeUntil()` and `takeWhile()` to pick values and more'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeUntil()` 和 `takeWhile()` 用于选择值等更多操作'
- en: '|'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Transforming** | The other very commonly used family, which includes operators
    to transform the values in a sequence. Some of the many possibilities include
    these:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '| **转换** | 另一个非常常用的家族，包括用于转换序列值的操作符。许多可能性中包括以下内容：'
- en: '`buffer()` and `bufferTime()` to collect values and emit them as an array'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer()` 和 `bufferTime()` 用于收集值并将它们作为数组发出'
- en: '`groupBy()` to group values together based on some property'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupBy()` 根据某些属性将值分组在一起'
- en: '`map()` to apply a given mapping function to every element in the sequence'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()` 将给定的映射函数应用于序列中的每个元素'
- en: '`partition()` to split an observable into two, based on a given predicate'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition()` 根据给定的谓词将可观察者分成两个'
- en: '`pluck()` to pick only some attributes from each element'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pluck()` 用于从每个元素中选择一些属性'
- en: '`reduce()` to reduce a sequence of values to a single one'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce()` 将值序列缩减为单个值'
- en: '`scan()` works like `reduce()` but emits all intermediate values'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan()` 与 `reduce()` 类似，但会发出所有中间值'
- en: '`toArray()` collects all values and emits them as a single array'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toArray()` 收集所有值并将它们作为单个数组发出'
- en: '|'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Utilities** | A sundry collection of operators with different functions,
    including the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '| **工具** | 一系列具有不同功能的操作符，包括以下内容：'
- en: '`tap()` to perform a side eﬀect, similar to what we saw in the *Tapping into
    a ﬂow* section in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting
    Functions*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap()` 执行副作用，类似于我们在 [*第8章*](B19301_08.xhtml#_idTextAnchor148) 的 *Tapping into
    a flow* 部分中看到的，*连接函数*'
- en: '`delay()` to delay sequence values for some time'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay()` 用于延迟序列值一段时间'
- en: '`finalize()` to call a function when an observable completes or produces an
    error'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finalize()` 在可观察者完成或产生错误时调用一个函数'
- en: '`repeat()` is just like `retry()` but for normal (that is, non-error) cases'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat()` 与 `retry()` 类似，但用于正常（即非错误）情况'
- en: '`timeout()` to produce an error if no value is produced before a given duration'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout()` 如果在给定持续时间之前没有产生值，则产生错误'
- en: '|'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Wow, that’s a lot of operators! We have excluded many, and you could even write
    your own, so be sure to look at the documentation. By the way, understanding operators
    is easier with marble diagrams; we won’t be using them here, but read [reactivex.io/documentation/observable.html](http://reactivex.io/documentation/observable.html)
    for a basic explanation, and then check out [rxmarbles.com](http://rxmarbles.com)
    for many interactive examples of operators and how they function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这有很多操作符！我们已经排除了很多，你甚至可以编写自己的操作符，所以请务必查看文档。顺便说一句，理解操作符使用宝石图会更简单；我们这里不会使用它们，但请阅读
    [reactivex.io/documentation/observable.html](http://reactivex.io/documentation/observable.html)
    以获得基本解释，然后查看 [rxmarbles.com](http://rxmarbles.com) 以了解操作符的许多交互式示例及其功能。
- en: Let’s finish this section with a couple of examples of the possibility of application
    for your own coding.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个示例来结束本节，展示这些方法在你自己的编码中的应用可能性。
- en: Detecting multi-clicks
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测多击
- en: Suppose you decided, for some reason or another, that users should be able to
    triple-click or four-click on something, and the number of clicks would somehow
    be meaningful and produce some kind of result. Browsers do very well detecting
    single- or double-clicks and letting you respond to them, but triple- (or more)
    clicks aren’t available so easily.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你出于某种原因决定，用户应该能够进行三击或四击操作，并且点击次数以某种方式具有意义并产生某种结果。浏览器在检测单击或双击并让你响应方面做得很好，但三击（或更多）点击并不容易实现。
- en: 'However, we can make do with a bit of FRP. Let’s start with a truly basic layout,
    including a text span that the user should click. The code is given here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以用一点 FRP 来凑合。让我们从一个真正基础的布局开始，包括一个用户应该点击的文本 span。代码如下：
- en: '[PRE13]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is as plain as can be; you just get a text on screen, urging you to multi-click
    it. See *Figure 11**.3*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的；你只是在屏幕上得到一些文本，敦促你进行多击。参见 *图 11**.3*：
- en: '![Figure 11.3 – A very plain screen to test detecting triple-clicks](img/Figure_11.3_B19301.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 用于检测三击的非常简单的屏幕](img/Figure_11.3_B19301.jpg)'
- en: Figure 11.3 – A very plain screen to test detecting triple-clicks
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 用于检测三击的非常简单的屏幕
- en: 'To detect these multi-clicks, we’ll need some RxJS functions, so let’s start
    with those:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测这些多击，我们需要一些 RxJS 函数，所以让我们从这些函数开始：
- en: '[PRE14]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will use these functions soon enough. How do we detect triple- (or more)
    clicks? Let’s go straight on to the code given here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会使用这些函数。我们如何检测三击（或更多）点击？让我们直接来看这里给出的代码：
- en: '[PRE15]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The logic is simple:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单：
- en: We create an observable with `fromEvent()` to listen to mouse clicks on our
    span.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `fromEvent()` 创建一个可观察对象来监听我们对 span 的鼠标点击。
- en: Now, a tricky point – we use `buffer()` to join together many events, which
    come from applying `debounceTime()` to the sequence of clicks, so all clicks that
    happen within an interval of 250 milliseconds will get grouped into a single array.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，一个棘手的问题——我们使用 `buffer()` 将来自应用 `debounceTime()` 的点击序列中的许多事件连接起来，所以所有在 250
    毫秒间隔内发生的点击都将被组合成一个数组。
- en: We then apply `map()` to transform each array of clicks into just its length
    – after all, we care about how many clicks there were, not their specific details.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们应用 `map()` 将每个点击数组转换为它的长度——毕竟，我们关心的是点击次数，而不是它们的详细信息。
- en: We finish by filtering out values under `3`, so only longer sequences of clicks
    will be processed.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过过滤掉小于 `3` 的值来完成，这样只有较长的点击序列会被处理。
- en: The subscription just logs the clicks, but in your application, it should do
    something more relevant.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅只是记录点击，但在你的应用程序中，它应该做更多相关的事情。
- en: If you wanted, you could detect multi-clicks by hand, writing your own code;
    see *Question 11.3* in the *Questions* section. Let’s finish with a longer example
    and do some typeahead searches, invoking some external API.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以手动检测多击，编写自己的代码；参见 *问题 11.3* 在 *问题* 部分。让我们用一个更长的例子来完成，并进行一些类型搜索，调用一些外部
    API。
- en: Providing typeahead searches
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供类型搜索
- en: 'Let’s do another web example: typeahead searches. The usual setup is that there
    is some sort of textbox, the user types in it, and the web page queries an API
    to provide ways of completing the search. The important thing is when and how
    to do the search, and try to avoid unnecessary calls to the backend server whenever
    possible. A (totally basic) HTML page could be as follows (see *Figure 11**.4*
    later in this section):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一个网络示例：类型搜索。通常的设置是有一个文本框，用户在其中输入，网页查询 API 以提供完成搜索的方式。重要的是何时以及如何进行搜索，并尽可能避免不必要地调用后端服务器。一个（完全基础的）HTML
    页面可能如下所示（参见本节后面的 *图 11**.4*）：
- en: '[PRE16]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We now have a single textbox in which the user will type and an area below
    that in which we’ll show whatever the API provides. We’ll use the GeoDB Cities
    API (see [geodb-cities-api.wirefreethought.com](http://geodb-cities-api.wirefreethought.com)),
    which provides many search options, to search for cities starting with whatever
    the user has typed. To get it out of our way, let’s look at the `getCitiesOrNull()`
    function, which will return a promise for search results (if something was typed
    in) or `null` (no cities, if nothing was typed in). The results of this promise
    will be used to fill the `myResults` division on the page. Let’s see how this
    works out in code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个单行文本框，用户将在其中输入，下面是我们将显示API提供的内容的区域。我们将使用GeoDB Cities API（见[geodb-cities-api.wirefreethought.com](http://geodb-cities-api.wirefreethought.com)），它提供了许多搜索选项，来搜索以用户输入内容开头的城市。为了让它不干扰我们，让我们看看`getCitiesOrNull()`函数，它将返回搜索结果的承诺（如果输入了某些内容）或`null`（如果没有输入任何内容，则没有城市）。这个承诺的结果将用于填充页面上的`myResults`分区。让我们看看代码是如何实现的：
- en: '[PRE17]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code is simple – if some text was provided, we generate the URL for the
    cities’ search and use `fetch()` to get the API data. With this done, let’s see
    how to generate the needed observable. We will need some RxJS functions, so first,
    let’s have some definitions:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单——如果提供了文本，我们生成城市搜索的URL并使用`fetch()`获取API数据。完成这个操作后，让我们看看如何生成所需的可观察对象。我们需要一些RxJS函数，所以首先，让我们有一些定义：
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will be using all of these functions later. Now, we can write the code to
    do the typeahead:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会使用所有这些函数。现在，我们可以编写代码来实现自动完成：
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This requires going step by step:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一步一步来：
- en: We use the `fromEvent()` constructor to observe input events (every time the
    user types something) from the `myText` input field.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`fromEvent()`构造函数来观察`myText`输入字段上的输入事件（每次用户输入时）。
- en: We use `map()` to get the event’s target value, the complete text of the input
    field.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`map()`来获取事件的目标值，即输入字段的完整文本。
- en: We use `debounceTime(200)` so that the observable won’t emit until the user
    has been 0.2 seconds (200 milliseconds) without typing – what’s the use of calling
    the API if the user isn’t done with their query?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`debounceTime(200)`，这样可观察对象就不会在用户停止输入0.2秒（200毫秒）内发出——如果用户没有完成他们的查询，调用API有什么用？
- en: We then use `filter()` to discard the input if it was only one, two, or three
    characters long because that’s not long enough for our search. We accept empty
    strings (so we’ll empty the results area) and strings four or more characters
    long.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着使用`filter()`来丢弃只有一、二或三个字符长的输入，因为这对我们的搜索来说不够长。我们接受空字符串（因此我们会清空结果区域）和四个或更多字符长的字符串。
- en: Then, we use `distinctUntilChanged()`, so if the search string is the same as
    before (the user possibly added a character but quickly backspaced, deleting it),
    nothing will be emitted.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`distinctUntilChanged()`，所以如果搜索字符串与之前相同（用户可能添加了一个字符但很快退格删除了它），则不会发出任何内容。
- en: Finally, we change `switchMap()` to cancel the previous subscription to the
    observable and create a new one using `getCitiesOrNull()`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`switchMap()`更改为取消对可观察对象的先前订阅，并使用`getCitiesOrNull()`创建一个新的订阅。
- en: 'How do we use this? We subscribe to the observable, and when we get results,
    we use them to display values. A possible sample code follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用它？我们订阅可观察对象，并在我们得到结果时使用它们来显示值。以下是一个可能的示例代码：
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An important point – the promise is resolved, and the final value of the sequence
    is, hence, whatever the promise produced. If the result isn’t `null`, we get an
    array of cities, and we use `map()` and `join()` to produce the (very basic!)
    HTML output; otherwise, we empty the results area.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的点——承诺被解决，因此序列的最终值就是承诺产生的值。如果结果不是`null`，我们得到一个城市数组，然后我们使用`map()`和`join()`来生成（非常基础的！）HTML输出；否则，我们清空结果区域。
- en: 'Let’s try it out. If you start typing, nothing will happen until you reach
    at least four characters and pause a bit (see *Figure 11**.4*, as follows):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。如果你开始输入，直到你输入至少四个字符并稍作停顿（见*图11**.4*，如下所示）：
- en: '![Figure 11.4 – Our search for cities doesn’t trigger for less than four characters](img/Figure_11.4_B19301.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 我们的城市搜索不会在少于四个字符时触发](img/Figure_11.4_B19301.jpg)'
- en: Figure 11.4 – Our search for cities doesn’t trigger for less than four characters
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4——我们的城市搜索不会在少于四个字符时触发
- en: 'When you reach four characters and pause for a moment, the observable will
    emit an event, and we’ll do a first search – in this case, for cities with names
    starting with `MONT` (see *Figure 11**.5*):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你达到四个字符并暂停一下时，可观察对象将发出一个事件，我们将进行第一次搜索——在这种情况下，搜索以`MONT`开头的城市（见*图11.5*）：
- en: '![Figure 11.5 – After reaching four characters, searches will be ﬁred](img/Figure_11.5_B19301.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – 达到四个字符后，将触发搜索](img/Figure_11.5_B19301.jpg)'
- en: Figure 11.5 – After reaching four characters, searches will be ﬁred
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 达到四个字符后，将触发搜索
- en: Finally, as you add more characters, new API calls will be made, refining the
    search (see *Figure 11**.6*).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，随着你添加更多字符，将进行新的API调用，细化搜索（见*图11.6*）。
- en: '![Figure 11.6 – Further characters are used to reﬁne the search](img/Figure_11.6_B19301.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 使用更多字符来细化搜索](img/Figure_11.6_B19301.jpg)'
- en: Figure 11.6 – Further characters are used to reﬁne the search
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 使用更多字符来细化搜索
- en: What can we learn from these examples? Using observables for events lets us
    achieve a good separation of concerns regarding event production and event consumption,
    and the declarative style of the stream process makes the data flow clearer. Note
    that even the HTML code has no reference to click methods or anything like that;
    the complete code is separate from that.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能从这些例子中学到什么？使用可观察对象进行事件处理，使我们能够实现关于事件生产和事件消费的良好关注点分离，流处理声明式风格使数据流更清晰。请注意，即使是HTML代码也没有引用点击方法或类似的东西；完整的代码是分开的。
- en: We have now seen most of the interesting patterns; let’s finish with some other
    ones, which may or may not be exactly equivalent to their classic OOP partners.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了大多数有趣的模式；让我们以一些其他模式结束，这些模式可能与它们的经典OOP伙伴完全相同或不完全相同。
- en: Other patterns
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他模式
- en: 'Let’s end this section by glancing at some other patterns where the equivalence
    may or may not be so good:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过简要查看一些可能或可能不如此等效的模式来结束本节。
- en: '**Currying and partial application** (which we saw in [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128),
    *Transforming Functions*: This can be seen as approximately equivalent to a *Factory*
    for functions. Given a general function, you can produce specialized cases by
    fixing one or more arguments, which is, in essence, what a Factory does – speak
    about functions and not objects.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**柯里化和部分应用**（我们在[*第7章*](B19301_07.xhtml#_idTextAnchor128)中看到，*转换函数*）：这可以被视为与函数的*工厂*大约等效。给定一个通用函数，你可以通过固定一个或多个参数来产生特殊案例，这本质上就是工厂所做的——谈论函数而不是对象。'
- en: '`map()` or `reduce()`): These can be considered an application of the Iterator
    pattern. The traversal of the container’s elements is decoupled from the container
    itself. You can also provide different `map()` methods for different objects to
    traverse all kinds of data structures.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`或`reduce()`：这些可以被视为迭代器模式的应用。容器元素的遍历与容器本身解耦。你也可以为不同的对象提供不同的`map()`方法来遍历各种数据结构。'
- en: '**Persistent data structures**: As mentioned in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188),
    *Ensuring Purity*, these allow for the implementation of the Memento pattern.
    The central idea is, given an object, to be able to go back to a previous state.
    As we saw, each updated version of a data structure doesn’t affect the previous
    one(s), so you could easily add a mechanism to provide an earlier state and *roll
    back* to it.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久数据结构**：如[*第10章*](B19301_10.xhtml#_idTextAnchor188)中提到的*确保纯净性*，这些允许实现备忘录模式。核心思想是，给定一个对象，能够回到之前的状态。正如我们所看到的，数据结构的每个更新版本都不会影响之前的版本，因此你可以轻松地添加一个机制来提供早期状态并*回滚*到它。'
- en: A `find()` to determine which processor will handle the request (the desired
    one is the first in the list that accepts the request) and then simply doing the
    required process.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`find()`来确定哪个处理器将处理请求（所需的处理器是列表中第一个接受请求的处理器），然后简单地执行所需的过程。
- en: Remember the warning at the beginning – with these patterns, the match with
    FP techniques may not be as perfect as with others that we have previously seen.
    However, the idea is to show that some common FP patterns can be applied and will
    produce the same results as the OOP solutions, despite having different implementations.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 记住开头的警告——使用这些模式时，与FP技术的匹配可能不如我们之前看到的那些完美。然而，目的是展示一些常见的FP模式可以应用，并且会产生与OOP解决方案相同的结果，尽管实现方式不同。
- en: Now, after having seen several OOP equivalent patterns, let’s move on to more
    specific FP ones.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在看过几个OOP等效模式之后，让我们转向更具体的FP模式。
- en: Functional design patterns
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式设计模式
- en: Having seen several OOP design patterns, it may seem a cheat to say that there’s
    no approved, official, or even remotely generally accepted similar list of patterns
    for FP. There are, however, several problems for which there are standard FP solutions,
    which can be considered design patterns on their own, and we have already covered
    most of them in this book.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 看过几个 OOP 设计模式后，可能会觉得说没有经过批准、官方或甚至广泛接受的类似模式列表似乎是一种欺骗。然而，确实存在一些标准 FP 解决方案，这些问题可以被视为设计模式，而且我们在这本书中已经涵盖了其中大部分。
- en: 'What are the candidates for a possible list of patterns? Let’s attempt to prepare
    one – but remember that it’s just a personal view. Also, I’ll admit that I’m not
    trying to mimic the usual style of pattern definition; I’ll just be mentioning
    a general problem and refer to the way FP in JavaScript can solve it, and I won’t
    be aiming for nice, short, and memorable names for the patterns either:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的模式列表有哪些候选人？让我们尝试准备一个——但请记住，这只是个人观点。此外，我要承认，我并不是试图模仿通常的模式定义风格；我只会提到一个一般性问题，并参考
    JavaScript 中的 FP 如何解决它，而且我不会试图为模式找到好、简短且易于记忆的名称：
- en: '`filter()`, `map()`, and `reduce()`, as we saw in this chapter and previously
    in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    is a way to remove complexity from the problem. (The usual `MapReduce` web framework
    is an extension of this concept, which allows for distributed processing among
    several servers, even if the implementation and details aren’t exactly the same.)
    Instead of performing looping and processing as a single step, you should think
    about the problem as a sequence of steps, applied in order, and doing transformations
    until obtaining the final, desired result.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`、`map()` 和 `reduce()`，正如我们在本章以及之前在 [*第 5 章*](B19301_05.xhtml#_idTextAnchor084)
    *声明式编程* 中所看到的，是一种从问题中去除复杂性的方法。（通常的 `MapReduce` 网络框架是这一概念的扩展，它允许在多个服务器之间进行分布式处理，即使实现和细节并不完全相同。）与其将循环和处理作为一个步骤执行，你应该将问题视为一系列按顺序应用的步骤，直到获得最终、所需的结果。'
- en: Looping in other ways
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以其他方式循环
- en: JavaScript also includes *iterators*, another way of looping through a collection.
    Using iterators isn’t particularly functional, but you may want to look at them,
    since they may be able to simplify some situations. Read more at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 还包括 *迭代器*，这是另一种遍历集合的方法。使用迭代器并不特别符合函数式编程，但你可能想了解一下它们，因为它们可能能够简化某些情况。更多信息请参阅
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)。
- en: '**Lazy evaluation with thunks**: The idea of lazy evaluation is not doing any
    calculations until they are actually needed. In some programming languages, this
    is built in. However, in JavaScript (and most imperative languages), *eager evaluation*
    is applied, in which an expression is evaluated as soon as it is bound to some
    variable. (Another way of saying this is that JavaScript is a *strict programming
    language*, with a *strict paradigm*, which only allows calling a function if all
    of its parameters have been completely evaluated.) This sort of evaluation is
    required when you need to specify the order of evaluation with precision, mainly
    because such evaluations may have side effects.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 thunks 进行惰性评估**：惰性评估的想法是在实际需要之前不进行任何计算。在某些编程语言中，这是内置的。然而，在 JavaScript（以及大多数命令式语言）中，采用的是
    *贪婪评估*，即表达式一旦绑定到某个变量就会立即被评估。（另一种说法是，JavaScript 是一种 *严格的编程语言*，具有 *严格的范式*，只允许在所有参数都完全评估后调用函数。）这种评估在需要精确指定评估顺序时是必要的，主要是因为这种评估可能产生副作用。'
- en: In FP, which is more declarative and pure, you can delay such evaluation with
    *thunks* (which we used in the *Trampolines and thunks* section of [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172)*,
    Designing Functions*) by passing a thunk that will calculate the needed value
    only when it’s needed, but not earlier.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在更声明式和纯的 FP 中，你可以通过传递一个 thunks（我们在 [*第 9 章*](B19301_09.xhtml#_idTextAnchor172)
    *设计函数* 中的 *Trampolines 和 thunks* 部分使用过）来延迟这种评估，这个 thunks 只在需要时计算所需值，而不会提前计算。
- en: Generating more results
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 生成更多结果
- en: You may also want to look at JavaScript generators, another way of delaying
    evaluation, though not particularly related to FP. Read more about them at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
    The combination of generators and promises is called an `async` function, which
    may be of interest to you; refer to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看JavaScript生成器，这是延迟评估的另一种方式，尽管它与FP没有特别的关系。更多关于它们的信息，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)。生成器和承诺的组合称为`async`函数，这可能对您感兴趣；请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)。
- en: '**Persistent data structures for immutability**: Having immutable data structures,
    as we saw in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*,
    is mandatory when working with certain frameworks, and in general, it is recommended
    because it helps to reason about a program or to debug it. (Earlier in this chapter,
    we also mentioned how the *Memento* OOP pattern can be implemented in this fashion.)
    Whenever you have to represent structured data, the FP solution of using a persistent
    data structure helps in many ways.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性数据结构用于不可变性**：正如我们在[*第10章*](B19301_10.xhtml#_idTextAnchor188)中看到的，*确保纯净性*，在处理某些框架时，拥有不可变的数据结构是强制性的，并且通常也是推荐的，因为它有助于对程序进行推理或调试。（在本章的早期，我们也提到了如何以这种方式实现*备忘录*面向对象（OOP）模式。）每当您需要表示结构化数据时，使用持久数据结构的FP解决方案在许多方面都有帮助。'
- en: '`null` before trying to access the corresponding object). This pattern aims
    to wrap a value within an object or function, so direct manipulation won’t be
    possible, and checks can be managed more functionally. We’ll refer to more of
    this in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building* *Better Containers*.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尝试访问相应对象之前，请检查`null`。这种模式旨在将一个值封装在对象或函数中，以便无法直接操作，并且可以更功能性地管理检查。我们将在[*第12章*](B19301_12.xhtml#_idTextAnchor221)中进一步讨论这一点，*构建更好的容器*。
- en: As we have said, the power of FP is such that, instead of having a couple of
    dozen standard design patterns (and that’s only in the GoF book; if you read other
    texts, the list grows!), there isn’t yet a standard or acknowledged list of functional
    patterns.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，函数式编程（FP）的力量在于，它没有几十种标准的设计模式（这只是在GoF书中；如果你阅读其他文本，列表会变得更长！），还没有一个标准或公认的函数式模式列表。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have made a bridge from the OO way of thinking and the usual
    patterns we use when coding that way to the FP style, by showing how we can solve
    the same basic problems but relatively more easily than with classes and objects.
    We have seen several common design patterns, and we’ve seen that the same concepts
    apply in FP, even if implementations may vary, so now you have a way to apply
    those well-known solution structures to your JavaScript coding.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过展示如何以比使用类和对象更简单的方式解决相同的基本问题，将面向对象（OO）的思维方式和我们通常在编码时使用的模式与FP风格连接起来。我们看到了几个常见的设计模式，并且我们已经看到，即使在实现可能有所不同的情况下，相同的概念也适用于FP，因此现在您有了一种将那些众所周知的解决方案结构应用于JavaScript编码的方法。
- en: In [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*,
    we will be working with a potpourri of FP concepts, giving you even more ideas
    about tools you can use. I promised that this book wouldn’t be deeply theoretical
    but, rather, more practical, and we’ll try to keep it this way, even if some of
    the presented concepts may seem abstruse or remote.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B19301_12.xhtml#_idTextAnchor221)中，*构建更好的容器*，我们将处理一系列FP概念，为您提供更多关于可以使用工具的想法。我承诺这本书不会过于理论化，而是更实用，我们将努力保持这种风格，即使一些展示的概念可能看起来有些抽象或遥远。
- en: Questions
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '11.1 **Decorating methods, the future way**: In [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we wrote a decorator to enable logging for any function.
    Currently, method decorators are being considered for upcoming versions of JavaScript:
    refer to [tc39.github.io/proposal-decorators](http://tc39.github.io/proposal-decorators)
    for more information on that. (A Stage 2 Draft means that inclusion of this feature
    in the standard is likely, although there may be some additions or small changes.
    TypeScript provides decorators today, but warns that *“Decorators are an experimental
    feature that may change in future releases”*; see more at [www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html).)
    Study the following code and take a look at what makes the next code tick:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 11.1 **装饰方法，未来的方式**：在[*第6章*](B19301_06.xhtml#_idTextAnchor107)，*生成函数*中，我们编写了一个装饰器来为任何函数启用日志记录。目前，方法装饰器正在考虑纳入
    JavaScript 的未来版本：有关更多信息，请参阅 [tc39.github.io/proposal-decorators](http://tc39.github.io/proposal-decorators)。（第二阶段草案意味着该功能很可能被纳入标准，尽管可能会有一些添加或小的变化。TypeScript
    现在提供装饰器，但警告说 *“装饰器是一个可能在未来版本中更改的实验性功能”*；更多信息请参阅 [www.typescriptlang.org/docs/handbook/decorators.html](http://www.typescriptlang.org/docs/handbook/decorators.html)。）研究以下代码，看看是什么让接下来的代码运行起来：
- en: '[PRE21]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A working example would be as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作示例如下：
- en: '[PRE22]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following are some questions about the code for `logging()`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于 `logging()` 代码的问题：
- en: What’s the need for the `savedMethod` variable?
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要 `savedMethod` 变量？
- en: Why do we use `function()` when assigning a new `descriptor.value`, instead
    of an arrow function?
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在分配新的 `descriptor.value` 时使用 `function()` 而不是箭头函数？
- en: Why is `.``bind()` used?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用 `.bind()`？
- en: What is `descriptor`?
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 `descriptor`？
- en: '11.2 `addBar()` function, which will add some mixins to the `Foo` class so
    that the code will run as shown. The created `fooBar` object should have two attributes
    (`fooValue` and `barValue`) and two methods (`doSomething()` and `doSomethingElse()`)
    that simply show some text and properties, as shown here:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 11.2 `addBar()` 函数，它将为 `Foo` 类添加一些混合，使得代码能够按所示运行。创建的 `fooBar` 对象应该有两个属性（`fooValue`
    和 `barValue`）和两个方法（`doSomething()` 和 `doSomethingElse()`），这些方法简单地显示一些文本和属性，如下所示：
- en: '[PRE23]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Could you include a third mixin, `addBazAndQux()`, so that `addBazAndQux(addBar(Foo))`
    would add even more attributes and methods to `Foo`?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你能包括一个第三个混合函数 `addBazAndQux()`，使得 `addBazAndQux(addBar(Foo))` 能够为 `Foo` 添加更多的属性和方法吗？
- en: '11.3 **Multi-clicking by hand**: Can you write your own multi-click detection
    code, which should work exactly as in our example?'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 11.3 **手动多击**：你能编写自己的多击检测代码，使其工作方式与我们的示例完全相同吗？
- en: 11.4 `false` values first and `true` values last?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 11.4 首先使用 `false` 值，然后使用 `true` 值？
- en: '11.5 **Finding routes, objectively**: Working in an object-oriented fashion,
    the route-finding problem would have been solved in another way, involving classes
    and subclasses. How? (Tip: the answer to this question is a pattern we have mentioned
    in this chapter.)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 11.5 **客观地寻找路线**：以面向对象的方式工作，路线寻找问题可能会以另一种方式解决，涉及类和子类。如何？（提示：这个问题的答案是我们在本章中提到的一个模式。）
