- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Persisting to Databases
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化到数据库
- en: In the world of application development, being able to save and retrieve data
    is essential. Imagine you’re building a game where you need to keep scores or
    a social media application where users need to save their profiles and posts.
    A lot of the time, a traditional relational database is what you need for this.
    It’s like an organized filing system where everything has its place in neat tables,
    and these tables can relate to each other in specific ways. For instance, one
    table might store information about books while another stores information about
    authors, and links between the two can show which author wrote which book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用开发的世界里，能够保存和检索数据是至关重要的。想象一下，你正在构建一个游戏，需要记录分数，或者一个社交媒体应用，用户需要保存他们的个人资料和帖子。很多时候，传统的关系型数据库正是你所需要的。它就像一个有组织的文件系统，其中每一项内容都有其所在的位置，并且这些表格可以以特定的方式相互关联。例如，一个表格可能存储关于书籍的信息，而另一个表格存储关于作者的信息，两者之间的链接可以显示哪个作者写了哪本书。
- en: But what if your data doesn’t fit into this structured format? What if you’re
    dealing with something more flexible or unpredictable, such as posts on a social
    media feed where some posts have images, some have videos, and others have just
    text? This is where non-relational, or NoSQL, databases come in. They’re designed
    to handle a wide variety of data structures, from simple key-value pairs to more
    complex documents or graphs. This makes them a great choice for modern applications
    that require flexibility and scalability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你的数据不适合这种结构化格式怎么办？如果你处理的是更灵活或不可预测的事物，比如社交媒体上的帖子，其中一些帖子有图片，一些有视频，而另一些只有文本呢？这就是非关系型，或
    NoSQL，数据库发挥作用的地方。它们被设计来处理各种数据结构，从简单的键值对到更复杂的文档或图。这使得它们成为现代应用程序的理想选择，这些应用程序需要灵活性和可扩展性。
- en: Important note
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This chapter will focus on interacting with these databases in Node.js. As such,
    some elementary knowledge of databases and **Structured Query Language** ( **SQL**
    ) is assumed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于在 Node.js 中与这些数据库交互。因此，假设您对数据库和 **结构化查询语言**（**SQL**）有一些基本知识。
- en: We’ll start with setting up a simple SQL database to understand the fundamentals
    of database operations. Then, we’ll explore the dynamic world of NoSQL databases,
    learning how to interact with them to handle more flexible data structures. By
    the end of this chapter, you’ll have a foundation in using diverse types of databases
    in your Node.js applications, giving you the flexibility to choose the right storage
    solution for your projects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置一个简单的 SQL 数据库开始，以了解数据库操作的基本原理。然后，我们将探索 NoSQL 数据库的动态世界，学习如何与它们交互以处理更灵活的数据结构。到本章结束时，你将在
    Node.js 应用程序中使用不同类型的数据库方面打下基础，这将为你提供选择适合你项目的正确存储解决方案的灵活性。
- en: 'This chapter will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Connecting and persisting to a MySQL database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到并持久化到 MySQL 数据库
- en: Connecting and persisting to a PostgreSQL database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到并持久化到 PostgreSQL 数据库
- en: Connecting and persisting to MongoDB
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到并持久化到 MongoDB
- en: Persisting data with Redis
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redis 持久化数据
- en: Exploring GraphQL
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 GraphQL
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Throughout this chapter, we will use Docker to provision databases in containers.
    Using a database container is common when building scalable and resilient architectures
    – particularly when using a container orchestrator such as Kubernetes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Docker 在容器中提供数据库。在构建可扩展和弹性架构时，使用数据库容器是常见的做法——尤其是在使用容器编排器如 Kubernetes
    时。
- en: However, the main reason why we’ll be using Docker containers throughout this
    chapter is to save us from having to manually install each of the database **command-line
    interfaces** ( **CLIs** ) and servers onto our system. In this chapter, we will
    be using Docker to provision containerized MySQL, PostgreSQL, MongoDB, and Redis
    data stores.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将在本章中使用 Docker 容器的主要原因是为了避免手动在我们的系统上安装每个数据库的 **命令行界面**（**CLIs**）和服务器。在本章中，我们将使用
    Docker 来提供容器化的 MySQL、PostgreSQL、MongoDB 和 Redis 数据存储。
- en: It is recommended to install Docker Desktop from [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 建议从 [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)
    安装 Docker Desktop。
- en: If you are unable to install Docker, then you can still complete the recipes,
    but you will need to manually install the specific databases for each recipe or
    connect to a remote database service.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法安装 Docker，你仍然可以完成这些食谱，但你将需要手动为每个食谱安装特定的数据库或连接到远程数据库服务。
- en: Note that this chapter will not cover how to enable persistent data storage
    from Docker containers, as this requires knowledge of Docker that is out of scope
    for a Node.js tutorial. Therefore, once the containers are destroyed or removed,
    the data accrued during the tutorials will be lost.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章不会介绍如何从Docker容器中启用持久数据存储，因为这需要超出Node.js教程范围的Docker知识。因此，一旦容器被销毁或删除，教程期间积累的数据将会丢失。
- en: 'It will also be worthwhile cleaning up and removing your database containers
    once you’ve completed each recipe by following these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 完成每个配方后，也可以通过以下步骤清理并删除你的数据库容器：
- en: Enter **$ docker ps** in your terminal to list your Docker containers.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端中输入 **$ docker ps** 以列出你的Docker容器。
- en: From there, locate the container identifier and pass this to the **$ docker
    stop <ContainerID>** command to stop the container.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，找到容器标识符，并将其传递给 **$ docker stop <ContainerID>** 命令以停止容器。
- en: Follow it up with **$ docker rm --force <ContainerID>** to remove the container.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **$ docker rm --force <ContainerID>** 来删除容器。
- en: 'Alternatively, you can use the following command to remove all Docker containers:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下命令来删除所有Docker容器：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Take caution when using this command if you have other Docker containers, unrelated
    to the recipes in this book, running on your device.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备上运行着与本书配方无关的其他Docker容器，使用此命令时要小心。
- en: Important note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Docker refers to both the virtualization technology and the company Docker Inc.
    that created the technology. Docker allows you to build applications and services
    into packages named containers. Refer to [*Chapter 11*](B19212_11.xhtml#_idTextAnchor353)
    for more detailed information about the Docker technology.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Docker既指代虚拟化技术，也指代创建了这项技术的公司Docker Inc.。Docker允许你将应用程序和服务打包成名为容器的包。有关Docker技术的更详细信息，请参阅[*第11章*](B19212_11.xhtml#_idTextAnchor353)。
- en: In several of the recipes, we will also make use of the **dotenv** module (
    [https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv) ).
    The **dotenv** module loads environment variables from a **.env** file into the
    Node.js process. Where necessary, we will be storing example database credentials
    in a **.env** file and then using the **dotenv** module to parse these into our
    Node.js process.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个配方中，我们还将使用**dotenv**模块（[https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv)）。**dotenv**模块将环境变量从**.env**文件加载到Node.js进程中。在需要的情况下，我们将把示例数据库凭据存储在**.env**文件中，然后使用**dotenv**模块将这些解析到我们的Node.js进程中。
- en: You will also need to have Node.js installed, preferably the latest version,
    Node.js 22, and access to an editor and browser of your choice. The code samples
    produced for this chapter are available on GitHub at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter07** directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装Node.js，最好是最新版本，Node.js 22，以及你选择的编辑器和浏览器。本章生成的代码示例可在GitHub上的[https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)的**Chapter07**目录中找到。
- en: Connecting and persisting to a MySQL database
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到MySQL数据库并持久化
- en: SQL is a standard for communicating with relational databases. Both MySQL (
    [https://www.mysql.com/](https://www.mysql.com/) ) and PostgreSQL ( [https://www.postgresql.org/](https://www.postgresql.org/)
    ) are popular open source **relational database management systems** ( **RDBMSs**
    ). There are many implementations of SQL databases, and each of them has its extensions
    and proprietary features. However, there is a base set of commands for storing,
    updating, and querying data implemented across all these SQL databases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: SQL是用于与关系型数据库通信的标准。MySQL ([https://www.mysql.com/](https://www.mysql.com/))
    和 PostgreSQL ([https://www.postgresql.org/](https://www.postgresql.org/)) 都是流行的开源**关系型数据库管理系统**（**RDBMSs**）。SQL数据库有许多实现，每个都有其扩展和专有功能。然而，所有这些SQL数据库都实现了存储、更新和查询数据的基本命令集。
- en: In this recipe, we’re going to communicate with a MySQL database from Node.js
    using the **mysql2** ( [https://www.npmjs.com/package/mysql2](https://www.npmjs.com/package/mysql2)
    ) module.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用**mysql2**模块（[https://www.npmjs.com/package/mysql2](https://www.npmjs.com/package/mysql2)）从Node.js与MySQL数据库进行通信。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, we need to get a MySQL database running locally. To do this, and for
    the other databases in this chapter, where possible, we will use Docker. MySQL
    provides a Docker official image on Docker Hub ( [https://hub.docker.com/_/mysql](https://hub.docker.com/_/mysql)
    ). This recipe assumes some, but minimal, prior knowledge of SQL and relational
    databases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在本地运行一个 MySQL 数据库。为此，以及在本章中的其他数据库，尽可能使用 Docker。MySQL 在 Docker Hub 上提供了一个官方镜像（[https://hub.docker.com/_/mysql](https://hub.docker.com/_/mysql)）。本食谱假设您对
    SQL 和关系型数据库有一些，但最少量的先验知识。
- en: Important note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this tutorial, we will use the **mysql2** package from **npm** for interacting
    with MySQL databases in Node.js due to its compatibility with the latest MySQL
    features and its support for promises. The choice of **mysql2** over the previously
    used **mysql** package is driven by it being more up to date, allowing us to leverage
    newer features and capabilities such as the **Promise** and **async** / **await**
    syntax.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用来自 **npm** 的 **mysql2** 包来与 Node.js 中的 MySQL 数据库交互，因为它与最新的 MySQL
    功能兼容，并支持承诺。选择 **mysql2** 而不是之前使用的 **mysql** 包的原因是它更更新，使我们能够利用新的功能和功能，如 **Promise**
    和 **async** / **await** 语法。
- en: 'To set up a MySQL database using Docker and prepare your project, follow these
    steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Docker 设置 MySQL 数据库并准备您的项目，请按照以下步骤操作：
- en: 'In a terminal window, type the following command to start a MySQL database
    listening on port **3306** :'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，输入以下命令以启动一个监听在端口 **3306** 的 MySQL 数据库：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **--publish 3306:3306** option in a Docker command maps port **3306** on
    the host machine to port **3306** on the Docker container, allowing external access
    to the container’s service running on that port.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 命令中的 **--publish 3306:3306** 选项将主机机器上的端口 **3306** 映射到 Docker 容器上的端口 **3306**，允许外部访问在该端口上运行的服务器。
- en: 'If you do not have the images locally, then Docker will first pull down the
    image from Docker Hub. While Docker is pulling down the image, expect to see output
    like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有本地镜像，那么 Docker 将首先从 Docker Hub 下载镜像。当 Docker 正在下载镜像时，您可能会看到如下输出：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **--detach** argument indicates that we wish to start the container in detached
    mode – this means that the container is running in the background. Omitting the
    **--detach** argument would mean your terminal window would be held by the container.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**--detach** 参数表示我们希望以分离模式启动容器——这意味着容器将在后台运行。省略 **--detach** 参数将意味着您的终端窗口将被容器占用。'
- en: 'Next, we will create a new directory for this recipe:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为这个食谱创建一个新的目录：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we will be installing modules from **npm** , we also need to initialize
    our project:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将要安装来自 **npm** 的模块，因此我们还需要初始化我们的项目：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ll also prepare two files for use in the recipe. The first will be a script
    named **setupDb.mjs** to create the database; the second will be a script to add
    a new task to the database, named **task.mjs** . While we’re here, let’s also
    create a **.env** file ready to store our database credentials:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还将准备两个用于食谱的文件。第一个将是一个名为 **setupDb.mjs** 的脚本，用于创建数据库；第二个将是一个名为 **task.mjs**
    的脚本，用于向数据库添加新任务。在此期间，让我们也创建一个 **.env** 文件，以便存储我们的数据库凭据：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the example credentials for our MySQL instance to the **.** **env** file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们 MySQL 实例的示例凭据添加到 **.env** 文件中：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Be aware these are example credentials for simplicity – you should use stronger
    credentials in your applications. Also, be sure not to accidentally commit **.env**
    files to **version control systems** ( **VCSs** , such as Git) as this can lead
    to leaking of sensitive credentials.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，这些示例凭据是为了简化而设置的——您应该在您的应用程序中使用更强的凭据。此外，请确保不要意外地将 **.env** 文件提交到 **版本控制系统**（**VCSs**，如
    Git），因为这可能导致敏感凭据泄露。
- en: Now that we have the MySQL database running and our project initialized, we’re
    ready to move on to the recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了 MySQL 数据库并初始化了项目，我们就可以继续进行食谱了。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we’ll be focusing on how to install the **mysql2** module from
    **npm** , connect to a MySQL database, and perform basic SQL queries. We’ll use
    a straightforward task list example to illustrate these concepts. We’ll also be
    using **ECMAScript Modules** ( **ESM** ) syntax, covered in the *Using ECMAScript
    modules* recipe of [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139) .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将关注如何从 **npm** 安装 **mysql2** 模块，连接到 MySQL 数据库，并执行基本的 SQL 查询。我们将使用一个简单的任务列表示例来说明这些概念。我们还将使用
    **ECMAScript 模块**（**ESM**）语法，这在 [*第 5 章*](B19212_05.xhtml#_idTextAnchor139) 的
    *使用 ECMAScript 模块* 食谱中有介绍。
- en: This approach should help you understand the practical application of managing
    and manipulating data with SQL in a MySQL database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法应该有助于您了解在MySQL数据库中管理和管理数据的实际应用。
- en: 'First, we need to install the **dotenv** module, for parsing environment variable
    configuration, and the **mysql2** module:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装**dotenv**模块，用于解析环境变量配置，以及**mysql2**模块：
- en: '[PRE7]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We’ll start by writing a script to set up our task list database. To do this,
    we’ll first need to import and load our credentials using the **dotenv** module
    and import the **mysql2** module. Add the following to **setupDb.mjs** to do that:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先编写一个脚本来设置我们的任务列表数据库。为此，我们首先需要使用**dotenv**模块导入和加载我们的凭据，并导入**mysql2**模块。将以下内容添加到**setupDb.mjs**以执行此操作：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s scaffold a **main()** function. We will add the logic to this function
    as we progress through the tutorial steps. Add the following to **setupDb.mjs**
    :'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个**main()**函数。我们将随着教程步骤的进行向此函数中添加逻辑。将以下内容添加到**setupDb.mjs**：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s start adding our connection logic, and we’ll wrap this in a **try**
    / **catch** / **finally** structure where **finally** will close the database
    connection. Within the **main()** function, add the following:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始添加我们的连接逻辑，我们将将其包装在**try** / **catch** / **finally**结构中，其中**finally**将关闭数据库连接。在**main()**函数中，添加以下内容：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can run this file in our terminal to test the connection:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在我们的终端中运行此文件以测试连接：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let’s add our logic to create tables. To do this, we’ll use two separate
    SQL statements. The first will create a database and instruct the connection to
    use it. The second will create a **tasks** database table. Add the following to
    the **main()** function, below the **console.log(''Connected as ...** line:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加我们的逻辑来创建表。为此，我们将使用两个独立的SQL语句。第一个将创建一个数据库并指示连接使用它。第二个将创建一个**tasks**数据库表。在**main()**函数中，在**console.log('Connected
    as ...**行下方添加以下内容：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the program in your terminal with the following command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在您的终端中运行程序：
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can implement our logic in **tasks.mjs** to input some data into our
    table, again via a SQL query. Start by copying the same connection logic we used
    in **setupDb.mjs** :'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在**tasks.mjs**中实现我们的逻辑，将一些数据输入到我们的表中，同样通过SQL查询。首先，复制我们在**setupDb.mjs**中使用的相同连接逻辑：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we end the connection to our MySQL database using **connection.end()**
    .
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用**connection.end()**结束与MySQL数据库的连接。
- en: 'Now, we can add some logic to receive the task details from the command line.
    Add the following logic below the **console.log(''Connected** **as** … line :'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一些逻辑来从命令行接收任务详情。在**console.log('Connected** **as** …**行下方添加以下逻辑：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s add a query that will obtain the contents of the **tasks** table:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个查询，以获取**tasks**表的内容：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, run the program with the following command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令运行程序：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each time we run the program, our insert query will be executed, meaning a new
    entry will be made in the **tasks** table.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次我们运行程序时，我们的插入查询都会被执行，这意味着在**tasks**表中将创建一个新的条目。
- en: How it works…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The **createConnection()** method exposed from the **mysql2** module establishes
    a connection to the MySQL server based on the configuration and credentials passed
    to the method. In the recipe, we passed the **createConnection()** method the
    username and password for our database using environment variables. The **mysql2**
    module defaults to looking for a MySQL database at **localhost:3306** , which
    is where the MySQL Docker container that we created in the *Getting ready* section
    of the recipe was exposed. The **mysql2** module from **npm** aims to provide
    equivalent functionality to the preceding **mysql** module from **npm** . A complete
    list of options that can be passed to the **createConnection()** method is available
    in the **mysql** module API documentation at [https://github.com/mysqljs/mysql#connection-options](https://github.com/mysqljs/mysql#connection-options)
    .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从**mysql2**模块暴露的**createConnection()**方法根据传递给方法的配置和凭据建立与MySQL服务器的连接。在配方中，我们使用环境变量将数据库的用户名和密码传递给**createConnection()**方法。**mysql2**模块默认在**localhost:3306**查找MySQL数据库，这是我们创建的MySQL
    Docker容器在配方中“准备就绪”部分暴露的位置。**npm**中的**mysql2**模块旨在提供与先前的**npm**模块中的**mysql**模块等效的功能。可以在**mysql**模块API文档中找到传递给**createConnection()**方法的完整选项列表，网址为[https://github.com/mysqljs/mysql#connection-options](https://github.com/mysqljs/mysql#connection-options)。
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Connection pools can also be utilized to minimize the time needed to connect
    to the MySQL server by reusing existing connections instead of closing them after
    use. This approach enhances query latency by eliminating the overhead associated
    with setting up new connections. Such a strategy is crucial for the development
    of large-scale applications. For more details, consult the API documentation at
    [https://sidorares.github.io/node-mysql2/docs#using-connection-pools](https://sidorares.github.io/node-mysql2/docs#using-connection-pools)
    .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池也可以被利用，通过重用现有连接而不是使用后关闭它们来最小化连接到MySQL服务器所需的时间。这种方法通过消除设置新连接相关的开销来提高查询延迟。这种策略对于大规模应用的开发至关重要。更多详情，请参阅[https://sidorares.github.io/node-mysql2/docs#using-connection-pools](https://sidorares.github.io/node-mysql2/docs#using-connection-pools)的API文档。
- en: Throughout the recipe, we used the **query()** method to send SQL statements
    to the MySQL database. The SQL statements in the **setupDb.mjs** file created
    a **tasks** database and a **tasks** table. The **task.mjs** file included SQL
    to insert a single task into the **tasks** table. The final SQL statement we sent
    to the database using the **query()** method was a **SELECT** statement, which
    returned the contents of the **tasks** table.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个食谱中，我们使用了**query()**方法将SQL语句发送到MySQL数据库。**setupDb.mjs**文件中的SQL语句创建了一个**tasks**数据库和一个**tasks**表。**task.mjs**文件包含了将单个任务插入到**tasks**表的SQL语句。我们使用**query()**方法发送到数据库的最后一个SQL语句是一个**SELECT**语句，它返回了**tasks**表的内容。
- en: Each of the SQL statements is queued and executed asynchronously. It is possible
    to pass a callback function as a parameter to the **query()** method, but we instead
    leverage the **async** / **await** syntax.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SQL语句都会排队并异步执行。可以将回调函数作为参数传递给**query()**方法，但我们利用了**async** / **await**语法。
- en: The **end()** method, as the name suggests, ends the connection to the database.
    The **end()** method ensures that there are no queries still queued or processing
    before ending the connection. There’s another method, **destroy()** , that will
    immediately terminate the connection to the database, ignoring the state of any
    pending or executing queries.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**end()**方法结束与数据库的连接。**end()**方法确保在结束连接之前没有查询仍在排队或正在处理。还有一个方法，**destroy()**，会立即终止与数据库的连接，忽略任何挂起或正在执行的查询的状态。
- en: One of the common types of attacks on user-facing web applications that it is
    necessary to be aware of is SQL injection attacks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 需要意识到的一种常见的针对面向用户的Web应用的攻击类型是SQL注入攻击。
- en: A SQL injection is where an attacker sends malicious SQL statements to your
    database. This is often achieved by inserting the malicious SQL statement into
    a web page input field. This is not a Node.js-specific problem; it also applies
    to other programming languages where the SQL query is created through string concatenation.
    The way to mitigate against any of these attacks is to sanitize or escape user
    input such that our SQL statements cannot be maliciously manipulated.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入是指攻击者向您的数据库发送恶意SQL语句。这通常是通过将恶意SQL语句插入到网页输入字段中实现的。这不是Node.js特有的问题；它也适用于其他编程语言，其中SQL查询是通过字符串连接创建的。减轻这些攻击的方法是对用户输入进行清理或转义，以确保我们的SQL语句不能被恶意操纵。
- en: 'You can manually escape user-supplied data directly by using **connection.escape()**
    . In the recipe, however, we used the placeholder ( **?** ) syntax in our SQL
    query to achieve the same:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用**connection.escape()**手动转义用户提供的直接数据。然而，在食谱中，我们使用占位符（**?**）语法在我们的SQL查询中实现相同的效果：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The **mysql2** module handles the sanitizing of user input for us if we pass
    our input values to the query via the second parameter of the **query** function.
    Multiple placeholders ( **?** ) are mapped to values in the SQL query in the order
    they are supplied.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将输入值通过**query**函数的第二个参数传递给查询，**mysql2**模块会为我们处理用户输入的清理。在SQL查询中，多个占位符（**?**）按照提供的顺序映射到值。
- en: There’s more…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Building on the basics of interacting with MySQL with Node.js, this section
    introduces how to create a REST API using Fastify in conjunction with MySQL. We’ll
    walk through essential steps such as setting up the project, starting a Fastify
    server, connecting it to MySQL with the **@fastify/mysql** plugin ( [https://www.npmjs.com/package/@fastify/mysql](https://www.npmjs.com/package/@fastify/mysql)
    ), and creating routes to handle **create, read, update, delete** ( **CRUD** )
    operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将基于使用Node.js与MySQL交互的基础，介绍如何结合MySQL使用Fastify创建REST API。我们将逐步讲解设置项目、启动Fastify服务器、使用**@fastify/mysql**插件（[https://www.npmjs.com/package/@fastify/mysql](https://www.npmjs.com/package/@fastify/mysql)）连接MySQL以及创建处理**创建、读取、更新、删除**（**CRUD**）操作的路线。
- en: Ensure you have a MySQL database available. For this, we will reuse the database
    we created in the main recipe steps.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您有一个MySQL数据库可用。为此，我们将重用主配方步骤中创建的数据库。
- en: 'First, we will create a new directory for the **fastify-mysql** project and
    initialize it with **npm** :'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为**fastify-mysql**项目创建一个新的目录，并使用**npm**初始化它：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Install **fastify** and the **@fastify/mysql** plugin using **npm** :'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**npm**安装**fastify**和**@fastify/mysql**插件：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a file named **server.js** in your project root. This file will configure
    the Fastify server, connect to the MySQL database, and define the routes:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目根目录下创建一个名为**server.js**的文件。此文件将配置Fastify服务器，连接到MySQL数据库，并定义路由：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Start by requiring Fastify – we’ll also enable logging:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先引入Fastify – 我们也将启用日志记录：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can register the **@fastify/mysql** plugin we installed earlier:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以注册之前安装的**@fastify/mysql**插件：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the connection string contains the credentials of our MySQL database
    – ideally, this connection string should be stored in a **.env** file as covered
    in previous recipes.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，连接字符串包含我们MySQL数据库的凭据 – 理想情况下，此连接字符串应存储在之前配方中提到的**.env**文件中。
- en: 'Now, let’s register a route to return all tasks in the database:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们注册一个路由以返回数据库中的所有任务：
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we’ll add the logic to run the server:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加运行服务器的逻辑：
- en: '[PRE25]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s start the Fastify MySQL application:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们启动Fastify MySQL应用程序：
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To test your API, open a new terminal window while your server is running and
    use **curl** :'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试您的API，在服务器运行时打开一个新的终端窗口，并使用**curl**：
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This tutorial provided a basic introduction to creating a REST API with Fastify
    and MySQL, covering project setup, initializing the server, connecting to the
    database, and retrieving items from the database. Fastify provides equivalent
    plugins for the other databases utilized in this recipe.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程提供了使用Fastify和MySQL创建REST API的基本介绍，涵盖了项目设置、初始化服务器、连接到数据库以及从数据库检索项目。Fastify为在此配方中使用的其他数据库提供了等效的插件。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Connecting and persisting to a PostgreSQL database* recipe in this chapter
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*连接并持久化到PostgreSQL数据库*配方
- en: The *Connecting and persisting to MongoDB* recipe in this chapter
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*连接并持久化到MongoDB*配方
- en: The *Persisting data with Redis* recipe in this chapter
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用Redis持久化数据*配方
- en: '[*Chapter 9*](B19212_09.xhtml#_idTextAnchor274)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19212_09.xhtml#_idTextAnchor274)'
- en: Connecting and persisting to a PostgreSQL database
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到并持久化到PostgreSQL数据库
- en: PostgreSQL, first introduced in 1996, is a powerful open source object-relational
    database system that has stood the test of time due to its reliability, feature
    robustness, and performance. One of PostgreSQL’s standout features is its ability
    to be utilized as both a traditional relational database, where data is stored
    in tables with relationships among them, and as a document database, such as NoSQL
    databases, where data can be stored in JSON format. This flexibility allows developers
    to choose the most appropriate data storage model based on their application’s
    requirements.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL首次于1996年推出，是一个强大的开源对象关系型数据库系统，由于其可靠性、功能健壮性和性能而经受住了时间的考验。PostgreSQL的突出特点之一是它既可以作为传统的数据库使用，其中数据存储在具有相互关系的表中，也可以作为文档数据库使用，例如NoSQL数据库，其中数据可以以JSON格式存储。这种灵活性允许开发者根据其应用程序的需求选择最合适的数据存储模型。
- en: Throughout this tutorial, we will explore the basics of interacting with a PostgreSQL
    database from a Node.js application. We’ll use the **pg** module, a popular and
    comprehensive PostgreSQL client for Node.js. The **pg** module simplifies connecting
    to and executing queries against a PostgreSQL database.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个教程中，我们将探索从Node.js应用程序与PostgreSQL数据库交互的基础。我们将使用**pg**模块，这是一个流行的、功能全面的PostgreSQL客户端，适用于Node.js。**pg**模块简化了连接到并执行针对PostgreSQL数据库的查询。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, we will need a PostgreSQL server to connect to. We will use
    Docker to provision a containerized PostgreSQL database. Refer to the *Technical
    requirements* section of this chapter for more information about using Docker
    to provision databases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要一个 PostgreSQL 服务器来连接。我们将使用 Docker 来配置一个容器化的 PostgreSQL 数据库。有关使用 Docker
    配置数据库的更多信息，请参阅本章的 *技术要求* 部分。
- en: We will be using the Docker official PostgreSQL image from [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)
    .
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Docker 官方的 PostgreSQL 镜像，[https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)。
- en: 'The following steps will initialize our PostgreSQL server and prepare our project
    directory:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将初始化我们的 PostgreSQL 服务器并准备我们的项目目录：
- en: 'In a terminal window, type the following to provision a **postgres** container:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，键入以下命令以配置一个 **postgres** 容器：
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Assuming you do not have a copy of the PostgreSQL image locally, expect to
    see the following output while Docker downloads the image:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设您没有本地 PostgreSQL 镜像的副本，在 Docker 下载镜像时，您可能会看到以下输出：
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We should now have a PostgreSQL database listening on port **5432** .
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在应该有一个在端口 **5432** 上监听的 PostgreSQL 数据库。
- en: 'Next, we’ll set up a directory and files ready for our PostgreSQL application:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置一个目录和文件，为我们的 PostgreSQL 应用程序做好准备：
- en: '[PRE30]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As we’ll be using a third-party module, we’ll also need to use **npm** to initialize
    a project. Let’s just accept the defaults:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用第三方模块，我们还需要使用 **npm** 来初始化一个项目。让我们只接受默认设置：
- en: '[PRE31]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, we’re ready to move on to the recipe, where we will be using the **pg**
    module to interact with our PostgreSQL database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进入菜谱，我们将使用 **pg** 模块与我们的 PostgreSQL 数据库进行交互。
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe, we will be installing the **pg** module to interact with our
    PostgreSQL database using Node.js. We will also send some simple queries to our
    database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将安装 **pg** 模块，使用 Node.js 与我们的 PostgreSQL 数据库进行交互。我们还将向数据库发送一些简单的查询。
- en: 'First, we need to install the third-party **pg** module:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装第三方 **pg** 模块：
- en: '[PRE32]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ll also be using the **dotenv** module in this recipe; install that with
    the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们还将使用 **dotenv** 模块；使用以下命令安装它：
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’ll also use the **.env** file to store our PostgreSQL database credentials
    and use the **dotenv** module to pass them to our program. Add the following credentials
    to **.env** :'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将使用 **.env** 文件来存储我们的 PostgreSQL 数据库凭据，并使用 **dotenv** 模块将它们传递给我们的程序。将以下凭据添加到
    **.env** 文件中：
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Open **tasks.js** and import our environment variables using the **dotenv**
    module:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **tasks.js** 并使用 **dotenv** 模块导入我们的环境变量：
- en: '[PRE35]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, in **tasks.js** , we need to import the **pg** module and create a PostgreSQL
    client:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 **tasks.js** 中，我们需要导入 **pg** 模块并创建一个 PostgreSQL 客户端：
- en: '[PRE36]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let’s allow our program to handle input via a command-line argument:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们允许我们的程序通过命令行参数处理输入：
- en: '[PRE37]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we’ll define the SQL queries we’re going to be using as constants. This
    will improve the readability of our code later:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们将要使用的 SQL 查询作为常量。这将提高我们代码的可读性：
- en: '[PRE38]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The **SELECT * FROM tasks;** SQL query returns all tasks in the **tasks** table.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**SELECT * FROM tasks;** SQL 查询返回 **tasks** 表中的所有任务。'
- en: 'Next, we’ll add the following code to connect to our database. Create a **tasks**
    table if it doesn’t already exist, insert a task, and finally, list all tasks
    stored in the database:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加以下代码来连接到我们的数据库。如果尚不存在，则创建一个 **tasks** 表，插入一个任务，最后列出数据库中存储的所有任务：
- en: '[PRE39]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we’ll create our **listTasks()** function, which will use **GET_TASKS_SQL**
    . This function will also end the connection to our database:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建我们的 **listTasks()** 函数，该函数将使用 **GET_TASKS_SQL** 。此函数还将结束与数据库的连接：
- en: '[PRE40]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run **tasks.js** , passing a task as a command-line argument. The task will
    be inserted into the database and listed out before the program ends:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 **tasks.js**，传递一个任务作为命令行参数。任务将被插入到数据库中，并在程序结束前列出：
- en: '[PRE41]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also run the program without passing a task. When we run **tasks.js**
    with no **task** parameter, the program will output the tasks stored in the database:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以不传递任务来运行程序。当我们不带 **task** 参数运行 **tasks.js** 时，程序将输出数据库中存储的任务：
- en: '[PRE42]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: By following these steps, you’ve gained an understanding of how to integrate
    PostgreSQL with Node.js.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，您已经了解了如何将 PostgreSQL 与 Node.js 集成。
- en: How it works…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In the *Getting ready* section of this recipe, we provisioned a containerized
    PostgreSQL database using the Docker official image from Docker Hub. The provisioned
    PostgreSQL database was provisioned in a Docker container named **node-postgres**
    . By default, the PostgreSQL Docker image creates a user and database named **postgres**
    . The Docker command we used to provision the database instructed the container
    to make the PostgreSQL database available at **localhost:5432** with a placeholder
    password of **PASSWORD** .
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱的 *准备就绪* 部分，我们使用 Docker Hub 上的 Docker 官方镜像配置了一个容器化的 PostgreSQL 数据库。配置的 PostgreSQL
    数据库是在名为 **node-postgres** 的 Docker 容器中配置的。默认情况下，PostgreSQL Docker 镜像创建了一个名为 **postgres**
    的用户和数据库。我们用于配置数据库的 Docker 命令指示容器在 **localhost:5432** 上使 PostgreSQL 数据库可用，并使用占位符密码
    **PASSWORD**。
- en: The configuration information required for a connection to our PostgreSQL database
    was specified in the **.env** file. We used the **dotenv** module to load this
    configuration information as environment variables to our Node.js process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到我们的 PostgreSQL 数据库所需配置信息已在 **.env** 文件中指定。我们使用 **dotenv** 模块将此配置信息作为环境变量加载到我们的
    Node.js 进程中。
- en: 'Notice that we didn’t have to directly pass any of the environment variables
    to the client. This is because the **pg** module automatically looks for specifically
    named variables ( **PGHOST** , **PGPORT** , and **PGUSER** ). However, if we wanted,
    we could specify the values when we create the client, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不必直接将任何环境变量传递给客户端。这是因为 **pg** 模块会自动查找特定命名的变量（**PGHOST**、**PGPORT** 和 **PGUSER**）。然而，如果我们想，我们可以在创建客户端时指定这些值，如下所示：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We use the **connect()** method to connect to our PostgreSQL database. We provide
    this method with a callback function to be executed once the connection attempt
    is complete. We added error handling within our callback function so that if the
    connection attempt fails, then an error is thrown.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **connect()** 方法连接到我们的 PostgreSQL 数据库。我们向此方法提供一个回调函数，以便在连接尝试完成后执行。我们在回调函数中添加了错误处理，以便如果连接尝试失败，则抛出错误。
- en: Throughout the remainder of the program, we use the **query()** method provided
    by the **pg** module to execute SQL queries against the PostgreSQL database. Each
    of our calls to the **query()** method is supplied with a callback function to
    be executed upon completion of the query.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的剩余部分，我们使用 **pg** 模块提供的 **query()** 方法对 PostgreSQL 数据库执行 SQL 查询。我们对 **query()**
    方法的每次调用都提供了一个回调函数，以便在查询完成后执行。
- en: There’s more…
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As well as storing traditional relational data, PostgreSQL also provides the
    ability to store object data. This enables the storing of relational data alongside
    document storage.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储传统的关联数据，PostgreSQL 还提供了存储对象数据的能力。这使得可以在文档存储的同时存储关联数据。
- en: We can adapt the program we created in the *Connecting and persisting to a PostgreSQL
    database* recipe to handle both relational and object data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们在 *连接和持久化到 PostgreSQL 数据库* 菜谱中创建的程序进行修改，以处理关联数据和对象数据。
- en: 'Copy the **postgres-app** directory to a directory called **postgres-object-app**
    :'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **postgres-app** 目录复制到名为 **postgres-object-app** 的目录中：
- en: '[PRE44]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we’ll edit our SQL queries to create a new table named **task_docs** that
    stores document data. Change your SQL query constants to the following in our
    **tasks.js** file:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编辑我们的 SQL 查询以创建一个名为 **task_docs** 的新表，用于存储文档数据。在 **tasks.js** 文件中将您的 SQL
    查询常量更改为以下内容：
- en: '[PRE45]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, when we run our application, we can pass it JSON input to represent the
    task. Note that we will need to wrap the JSON input in single quotes, and then
    use double quotes for the key-value pairs:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们运行应用程序时，我们可以传递 JSON 输入来表示任务。请注意，我们需要将 JSON 输入用单引号括起来，然后为键值对使用双引号：
- en: '[PRE46]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The **doc** field was created with the **jsonb** type, which represents the
    JSON binary type. PostgreSQL provides two JSON data types: **json** and **jsonb**
    . The **json** data type is like a regular text input field but with the addition
    that it validates the JSON. The **jsonb** type is structured and facilitates queries
    and indexes within the document objects. You’d opt for the **jsonb** data type
    over the **json** data type when you require the ability to query or index the
    data.'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**doc** 字段是用 **jsonb** 类型创建的，它表示 JSON 二进制类型。PostgreSQL 提供了两种 JSON 数据类型：**json**
    和 **jsonb**。**json** 数据类型类似于常规的文本输入字段，但增加了验证 JSON 的功能。**jsonb** 类型是结构化的，便于在文档对象中进行查询和索引。当您需要查询或索引数据时，您会选择
    **jsonb** 数据类型而不是 **json** 数据类型。'
- en: 'Based on this example, a **jsonb** query would look as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个示例，一个 **jsonb** 查询看起来如下所示：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that we’re able to query against the **task** property within the document
    object. For more information about the **jsonb** data type, refer to the official
    PostgreSQL documentation at [https://www.postgresql.org/docs/9.4/datatype-json.html](https://www.postgresql.org/docs/9.4/datatype-json.html)
    .
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以在文档对象内的 **task** 属性上进行查询。有关 **jsonb** 数据类型的信息，请参阅官方 PostgreSQL 文档，网址为
    [https://www.postgresql.org/docs/9.4/datatype-json.html](https://www.postgresql.org/docs/9.4/datatype-json.html)。
- en: See also
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Connecting and persisting to a MySQL database* recipe in this chapter
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *连接和持久化到 MySQL 数据库* 菜谱
- en: The *Connecting and persisting to MongoDB* recipe in this chapter
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *连接和持久化到 MongoDB* 菜谱
- en: The *Persisting data with Redis* recipe in this chapter
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用 Redis 持久化数据* 菜谱
- en: Connecting and persisting to MongoDB
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接和持久化到 MongoDB
- en: MongoDB is a NoSQL database management system built around a document-oriented
    model. Data is stored in flexible, JSON-like documents called **Binary JSON**
    ( **BSON** ), which are organized into **collections** , analogous to tables in
    relational databases. Each document within a collection can have a different structure,
    allowing for dynamic schemas and easy modification of data models.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个围绕文档模型构建的 NoSQL 数据库管理系统。数据存储在灵活的、类似 JSON 的文档中，称为 **Binary JSON**
    ( **BSON** )，这些文档组织成 **集合**，类似于关系数据库中的表。集合中的每个文档都可以有不同的结构，允许动态模式并易于修改数据模型。
- en: MongoDB supports powerful querying capabilities using its query language, which
    includes various operators and methods for filtering, sorting, and manipulating
    data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 支持使用其查询语言进行强大的查询功能，包括用于过滤、排序和操作数据的各种运算符和方法。
- en: This recipe will use a book/author example using the MongoDB Node.js driver
    directly. We’ll write functions to create and find authors and books within our
    MongoDB database. This script will illustrate basic CRUD operations without the
    use of a web framework, focusing purely on database interactions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱将使用 MongoDB Node.js 驱动程序直接使用 book/author 示例。我们将编写函数来创建和查找 MongoDB 数据库中的作者和书籍。此脚本将展示基本的
    CRUD 操作，不使用任何 Web 框架，纯粹关注数据库交互。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To set up a MongoDB database with Docker and get your project directory ready
    for the application, follow these steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 设置 MongoDB 数据库并准备好项目目录以供应用程序使用，请按照以下步骤操作：
- en: 'As with the other databases in this chapter, we will be using Docker to provision
    a MongoDB database using the MongoDB Docker image available at [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)
    :'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与本章中的其他数据库一样，我们将使用 Docker 通过 MongoDB Docker 镜像提供 MongoDB 数据库，该镜像可在 [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)
    找到：
- en: '[PRE48]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Assuming you do not have a copy of the MongoDB image locally, expect to see
    the following output while Docker downloads the image:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设您没有 MongoDB 镜像的本地副本，在 Docker 下载镜像时，您可能会看到以下输出：
- en: '[PRE49]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We’ll also create a directory for the MongoDB Node.js application:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将为 MongoDB Node.js 应用程序创建一个目录：
- en: '[PRE50]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this recipe, we will need to install modules from the **npm** registry,
    so we need to initialize our project with **$** **npm init** :'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们需要从 **npm** 注册表中安装模块，因此我们需要使用 **$ npm init** 初始化我们的项目：
- en: '[PRE51]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a file named **index.js** ; this will contain our application code that
    interacts with MongoDB:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **index.js** 的文件；这将包含与 MongoDB 交互的应用程序代码：
- en: '[PRE52]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we have our database running and the project initialized, we’re ready
    to move on to the recipe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了数据库并初始化了项目，我们可以继续进行菜谱。
- en: How to do it…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this recipe, we will be using the **mongodb** module to demonstrate how we
    can interact with our MongoDB database.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 **mongodb** 模块来演示我们如何与我们的 MongoDB 数据库进行交互。
- en: 'Start by installing the **mongodb** module:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装 **mongodb** 模块：
- en: '[PRE53]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'First, we’ll add the logic to the **index.js** file to establish a connection
    to our MongoDB database:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将向 **index.js** 文件添加逻辑以连接到我们的 MongoDB 数据库：
- en: '[PRE54]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we will craft a function to insert an author into the **authors** collection:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数将作者插入到 **authors** 集合中：
- en: '[PRE55]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a function to insert a book into the **books** collection:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数将书籍插入到 **books** 集合中：
- en: '[PRE56]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a function to find all authors in the **authors** collection:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数以查找 **authors** 集合中的所有作者：
- en: '[PRE57]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create a function to find all books and populate them with author details using
    an aggregation pipeline:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数以查找所有书籍并使用聚合管道填充作者详细信息：
- en: '[PRE58]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we will use the **createAuthor()** , **createBook()** , **findAllAuthors()**
    , and **findAllBooksWithAuthors()** functions in the **main()** function to perform
    the operations in sequence:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在 **main()** 函数中使用 **createAuthor()**、**createBook()**、**findAllAuthors()**
    和 **findAllBooksWithAuthors()** 函数按顺序执行操作：
- en: '[PRE59]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Run the script:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本：
- en: '[PRE60]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this recipe, we built a Node.js script that serves as a functional interface
    to interact with a MongoDB database.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们构建了一个Node.js脚本，它作为与MongoDB数据库交互的功能接口。
- en: How it works…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In the recipe, we begin by importing the necessary modules, notably the **MongoClient**
    class from **npm** ’s **mongodb** module. Setting up the MongoDB connection involves
    defining a URI to connect to the local MongoDB server and initializing a **MongoClient**
    instance with this URI. In our case, our database was hosted on the typical default
    host and port for MongoDB: **mongodb://localhost:27017** .'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们首先导入必要的模块，特别是来自 **npm** 的 **mongodb** 模块的 **MongoClient** 类。设置MongoDB连接涉及定义一个连接到本地MongoDB服务器的URI，并使用此URI初始化一个
    **MongoClient** 实例。在我们的案例中，我们的数据库托管在MongoDB的典型默认主机和端口上：**mongodb://localhost:27017**。
- en: Note that MongoDB does not enable authentication by default when using Docker,
    so no authentication parameters were needed in the connection string.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用Docker时，MongoDB默认不启用身份验证，因此在连接字符串中不需要任何身份验证参数。
- en: The **connectToMongoDB()** function asynchronously attempts to establish a connection
    to the MongoDB server, logging success or failure messages accordingly and returning
    a reference to the specified database if successful.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**connectToMongoDB()** 函数异步尝试连接到MongoDB服务器，相应地记录成功或失败消息，并在成功时返回指定数据库的引用。'
- en: The **mongodb** module from **npm** exposes a vast range of CRUD methods to
    interact with the MongoDB collections in your MongoDB database. The term *CRUD*
    is used to represent the basic functions for persistent storage. In this recipe,
    we used the **find()** and **insertOne()** CRUD methods. A full list of available
    methods is defined in the Node.js MongoDB driver API documentation ( [https://mongodb.github.io/node-mongodb-native/6.5/](https://mongodb.github.io/node-mongodb-native/6.5/)
    ).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm** 的 **mongodb** 模块公开了大量的CRUD方法，以与MongoDB数据库中的MongoDB集合进行交互。术语 *CRUD*
    用于表示持久存储的基本功能。在这个配方中，我们使用了 **find()** 和 **insertOne()** CRUD方法。可用方法的完整列表定义在Node.js
    MongoDB驱动程序API文档中（[https://mongodb.github.io/node-mongodb-native/6.5/](https://mongodb.github.io/node-mongodb-native/6.5/)）。'
- en: We also used the **aggregate()** method in the **findAllBooksWithAuthors()**
    function. An aggregation pipeline can contain one or more stages to create a flow
    of operations that processes, transforms, and returns results.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 **findAllBooksWithAuthors()** 函数中使用了 **aggregate()** 方法。聚合管道可以包含一个或多个阶段，以创建一个处理、转换并返回结果的流程。
- en: The **main()** function orchestrates the execution flow, starting with connecting
    to the MongoDB database. Upon successful connection, it proceeds to create an
    author document for **Richard Adams** and a corresponding book document titled
    **Watership Down** , associating them together. Subsequently, it retrieves all
    authors and books with their associated author details using the defined functions.
    Error handling is implemented throughout the script using **try** / **catch**
    blocks to handle any potential errors that may arise during execution. Finally,
    the script concludes by closing the MongoDB client connection.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**main()** 函数协调执行流程，首先连接到MongoDB数据库。连接成功后，它继续为 **理查德·亚当斯** 创建一个作者文档，以及一个标题为
    **《风车山》** 的相应书籍文档，并将它们关联起来。随后，它使用定义的函数检索所有作者和书籍及其关联的作者详细信息。在整个脚本中，使用 **try** /
    **catch** 块实现错误处理，以处理执行过程中可能出现的任何潜在错误。最后，脚本通过关闭MongoDB客户端连接来结束。'
- en: Overall, this script serves as a practical example of how to utilize Node.js
    and the **mongodb** package to perform CRUD operations on a MongoDB database,
    demonstrating basic functionalities such as connecting to the database, inserting
    documents, querying collections, and handling errors effectively.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这个脚本作为一个实用的示例，展示了如何利用Node.js和 **mongodb** 包在MongoDB数据库上执行CRUD操作，演示了基本功能，如连接到数据库、插入文档、查询集合和有效处理错误。
- en: See also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Connecting and persisting to a MySQL database* recipe in this chapter
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *连接并持久化到MySQL数据库* 的配方
- en: The *Connecting and persisting to a PostgreSQL database* recipe in this chapter
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *连接并持久化到PostgreSQL数据库* 的配方
- en: The *Persisting data with Redis* recipe in this chapter
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *使用Redis持久化数据* 的配方
- en: Persisting data with Redis
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redis 持久化数据
- en: Redis is an open source in-memory key-value data store. Used in the correct
    setting, Redis can be a fast-performing data store. It is often used to provide
    caching in applications but can also be used as a database.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个开源的内存键值数据存储。在正确的设置下，Redis 可以成为一个高性能的数据存储。它通常用于提供应用程序的缓存，但也可以用作数据库。
- en: '**Redis** , an acronym for **Remote Dictionary Server** , is an in-memory data
    structure store, often used as a database, cache, and message broker. It excels
    in scenarios requiring high speed and efficiency, such as caching, session management,
    real-time analytics, and message queuing. Redis’s ability to support various data
    structures, combined with its atomic operations and **publish/subscribe** ( **pub/sub**
    ) messaging capabilities, makes it a powerful tool for enhancing the performance
    and scalability of Node.js applications. Its in-memory nature ensures rapid access
    to data, significantly reducing latency compared to traditional disk-based databases,
    making it ideal for applications where speed is critical.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis**，即 **远程字典服务器** 的缩写，是一个内存数据结构存储，通常用作数据库、缓存和消息代理。它在需要高速和效率的场景中表现出色，如缓存、会话管理、实时分析和消息队列。Redis
    支持各种数据结构的能力，结合其原子操作和 **发布/订阅**（**pub/sub**）消息能力，使其成为增强 Node.js 应用程序性能和可扩展性的强大工具。其内存特性确保了数据的快速访问，与传统基于磁盘的数据库相比，显著降低了延迟，使其适用于速度至关重要的应用程序。'
- en: In the context of Node.js, Redis is particularly valuable for managing session
    data in web applications, enabling quick data retrieval, and improving user experience.
    It’s also widely used for implementing caching mechanisms, reducing the load on
    databases, and speeding up response times. Moreover, its pub/sub messaging system
    facilitates the development of real-time applications, such as chat applications
    or live notifications, by allowing efficient communication between clients and
    servers. Whether you’re looking to optimize your application’s performance, scale
    efficiently, or build feature-rich real-time interactions, integrating Redis with
    Node.js offers a robust solution to meet these needs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 的上下文中，Redis 特别适用于管理 Web 应用程序中的会话数据，实现快速数据检索并提高用户体验。它也被广泛用于实现缓存机制，减轻数据库负载并加快响应时间。此外，其
    pub/sub 消息系统通过允许客户端和服务器之间的高效通信，促进了实时应用程序（如聊天应用程序或实时通知）的开发。无论您是想优化应用程序的性能、高效扩展还是构建功能丰富的实时交互，将
    Redis 与 Node.js 集成都提供了一个强大的解决方案来满足这些需求。
- en: Getting ready
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before diving into Redis module integration, it’s essential to note that we’ll
    be using ESM for compatibility. For more information on modules, refer to [*Chapter
    5*](B19212_05.xhtml#_idTextAnchor139) .
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究 Redis 模块集成之前，重要的是要注意我们将使用 ESM 以确保兼容性。有关模块的更多信息，请参阅 [*第 5 章*](B19212_05.xhtml#_idTextAnchor139)
    。
- en: 'As with the previous databases in this chapter, we will use Docker to provision
    a Redis database, based on the Docker image available at [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)
    . Run the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与本章中之前提到的数据库一样，我们将使用 Docker 来部署 Redis 数据库，基于可在 [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)
    找到的 Docker 镜像。运行以下命令：
- en: '[PRE61]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: By default, the containerized Redis database will be available at **localhost:6379**
    .
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，容器化的 Redis 数据库将在 **localhost:6379** 上可用。
- en: 'We will also create a new folder named **redis-app** containing a file named
    **tasks.mjs** :'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建一个名为 **redis-app** 的新文件夹，其中包含一个名为 **tasks.mjs** 的文件：
- en: '[PRE62]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this recipe, we will be making use of third-party **npm** modules; therefore,
    we need to initialize our project:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用第三方 **npm** 模块；因此，我们需要初始化我们的项目：
- en: '[PRE63]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that we have Redis running and our project set up, we’re ready to move on
    to the recipe.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了 Redis 并设置了我们的项目，我们可以继续进行下一步了。
- en: How to do it…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe, we will be using the **redis** module to interact with our Redis
    data store.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 **redis** 模块与我们的 Redis 数据存储进行交互。
- en: 'Start by installing the third-party **redis** module:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装第三方 **redis** 模块：
- en: '[PRE64]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We now need to import and create a Redis client in **tasks.mjs** :'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在 **tasks.mjs** 中导入并创建一个 Redis 客户端：
- en: '[PRE65]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We’ll also accept command-line input for our task:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将接受命令行输入以执行我们的任务：
- en: '[PRE66]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, we’ll add an **error** event handler to catch any errors that occur on
    our Redis client:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个 **错误** 事件处理器来捕获 Redis 客户端上发生的任何错误：
- en: '[PRE67]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We need to initialize the connection:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要初始化连接：
- en: '[PRE68]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we’ll add a statement that will control the flow of our program. If a
    task is passed as input to our program, we will add this task and then list the
    tasks stored in Redis. If no task is supplied, then we will just list the stored
    tasks:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个语句来控制我们程序的流程。如果将任务作为输入传递给我们的程序，我们将添加此任务并列出存储在Redis中的任务。如果没有提供任务，则只列出存储的任务：
- en: '[PRE69]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Below this **if** statement, we will create our **addTask()** function:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此**if**语句下方，我们将创建我们的**addTask()**函数：
- en: '[PRE70]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, after the **addTask()** function, we’ll add our **listTasks()** function:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**addTask()**函数之后，我们将添加我们的**listTasks()**函数：
- en: '[PRE71]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we can run the program with a task passed as command-line input. The task
    will be stored in Redis and subsequently printed via the **listTasks()** function:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将任务作为命令行输入运行程序。该任务将被存储在Redis中，然后通过**listTasks()**函数打印出来：
- en: '[PRE72]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We’ve now persisted data in our Redis data store using the **redis** module.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已使用**redis**模块在我们的Redis数据存储中持久化了数据。
- en: How it works…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The **createClient()** method initializes a new client connection. This method
    will default to configuration for a Redis instance at **localhost:6379** , where
    **6379** is the conventional port for Redis. In previous versions of the **redis**
    module from **npm** , the **createClient()** method would automatically connect
    to the server. However, it’s now necessary to explicitly call **client.connect()**
    to establish a connection.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**createClient()**方法初始化一个新的客户端连接。此方法将默认配置为连接到**localhost:6379**上的Redis实例，其中**6379**是Redis的传统端口。在**npm**的**redis**模块的早期版本中，**createClient()**方法会自动连接到服务器。然而，现在需要显式调用**client.connect()**来建立连接。'
- en: Within our **addTask()** function, we generate a random string, or hash, to
    append to our task key. This ensures that each task key is unique, while still
    having a specifier indicating that it is a task to aid debugging. This is a common
    convention when using Redis.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的**addTask()**函数中，我们生成一个随机字符串或哈希，并将其附加到我们的任务键上。这确保了每个任务键都是唯一的，同时仍然有一个指定器表明它是一个任务，以帮助调试。这是使用Redis时的常见约定。
- en: The **hSet()** method sets the key and value in Redis; this is what stores our
    task in Redis. If we supplied a key that already existed, this method would overwrite
    the contents.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**hSet()**方法在Redis中设置键和值；这正是我们在Redis中存储任务的方式。如果我们提供了一个已存在的键，此方法将覆盖其内容。'
- en: Important note
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The legacy **hmset()** method is considered deprecated in newer versions of
    Redis. The **hSet()** method used in the recipe should be used for setting hash
    values.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redis的新版本中，传统的**hmset()**方法被认为是过时的。在配方中使用的**hSet()**方法应用于设置哈希值。
- en: In the **listTasks()** function, we use the **keys()** method to search for
    all keys stored in our Redis data store that match the **Tasks:*** wildcard. We’re
    leveraging the **keys()** method to list all tasks we have stored in Redis. Note
    that the **keys()** method in real applications should be used with caution. This
    is because, in applications with many keys, searching could have negative performance
    implications.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在**listTasks()**函数中，我们使用**keys()**方法搜索所有存储在我们的Redis数据存储中且与**Tasks:***通配符匹配的键。我们正在利用**keys()**方法列出我们存储在Redis中的所有任务。请注意，在实际应用中，**keys()**方法应谨慎使用。这是因为，在具有许多键的应用程序中，搜索可能会产生负面的性能影响。
- en: Once we have all our task keys, we use the **hGetAll()** method to return the
    value at each key. Once obtained, we print this value to **STDOUT** using **console.log()**
    .
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所有任务键，我们使用**hGetAll()**方法返回每个键的值。一旦获取，我们使用**console.log()**将其打印到**STDOUT**。
- en: The **redis** module **npm** provides a one-to-one mapping of all available
    Redis commands. Refer to [https://redis.io/commands](https://redis.io/commands)
    for a complete list of Redis commands.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**redis**模块提供的**npm**将所有可用的Redis命令进行了一对一的映射。请参阅[https://redis.io/commands](https://redis.io/commands)以获取Redis命令的完整列表。'
- en: There’s more…
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: The Redis instance you’re interacting with may require authentication. Let’s
    look at how we can connect to a Redis instance that requires a password.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你交互的Redis实例可能需要身份验证。让我们看看如何连接到一个需要密码的Redis实例。
- en: Authenticating with Redis
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Redis进行身份验证
- en: To connect to a Redis client that requires authentication, we can supply the
    credentials via the **createClient()** method.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到需要身份验证的Redis客户端，我们可以在**createClient()**方法中提供凭证。
- en: 'We can, again, use Docker to create a password-protected Redis instance. This
    Redis container will be available at **localhost:6380** :'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次可以使用Docker来创建一个密码保护的Redis实例。这个Redis容器将在**localhost:6380**上可用：
- en: '[PRE73]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Copy the **tasks.mjs** file into a new file named **tasks-auth.mjs** :'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **tasks.mjs** 文件复制到一个名为 **tasks-auth.mjs** 的新文件中：
- en: '[PRE74]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we need to pass the new Redis instance’s configuration information to
    the **createClient()** method:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将新 Redis 实例的配置信息传递给 **createClient()** 方法：
- en: '[PRE75]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, as before, we can run the program with a task passed as command-line input:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就像之前一样，我们可以通过命令行输入传递任务来运行程序：
- en: '[PRE76]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that as we’re pointing to a different Redis instance, it will not contain
    the tasks we added in the main recipe.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为我们指向的是不同的 Redis 实例，它将不会包含我们在主菜谱中添加的任务。
- en: Transactions with Redis
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis 事务
- en: The **redis** module exposes a method named **multi()** that can be used to
    create a **transaction** . A transaction is a series of commands that are queued
    and then executed as a single unit.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**redis** 模块公开了一个名为 **multi()** 的方法，可以用来创建 **事务**。事务是一系列排队并作为单个单元执行的命令。'
- en: 'For example, we could use the following to update a task as a transaction by
    executing a **get()** , **set()** , **get()** sequence:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下命令作为事务更新任务，通过执行一个 **get()**、**set()**、**get()** 序列：
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Each of the tasks is queued until the **exec()** method is executed. If any
    command fails to be queued, none of the commands in the batch are executed. During
    the **exec()** method, all commands are executed in order.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务都会排队，直到执行 **exec()** 方法。如果任何命令未能排队，则批处理中的所有命令都不会执行。在 **exec()** 方法期间，所有命令按顺序执行。
- en: See also
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Connecting and persisting to a MySQL database* recipe in this chapter
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *连接和持久化到 MySQL 数据库* 菜谱
- en: The *Connecting and persisting to a PostgreSQL database* recipe in this chapter
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *连接和持久化到 PostgreSQL 数据库* 菜谱
- en: The *Connecting and persisting to MongoDB* recipe in this chapter
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *连接和持久化到 MongoDB* 菜谱
- en: Exploring GraphQL
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 GraphQL
- en: GraphQL serves as a query language for APIs and provides a runtime environment
    for executing queries. Unlike REST, which relies on rigid endpoint structures,
    GraphQL allows clients to request exactly what they need and nothing more, making
    it efficient for fetching data. This flexibility reduces the amount of data transferred
    over the network and allows for more precise and optimized queries.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 作为 API 的查询语言，并提供执行查询的运行时环境。与依赖于严格端点结构的 REST 不同，GraphQL 允许客户端请求他们确切需要的内容，而不需要更多，这使得它对于获取数据非常高效。这种灵活性减少了通过网络传输的数据量，并允许进行更精确和优化的查询。
- en: In projects where your application deals with complex, interrelated data structures,
    such as social networks, e-commerce platforms, or **content management systems**
    ( **CMSs** ), GraphQL’s ability to query deeply nested data in a single request
    makes it a perfect match with Node.js. This combination reduces the need for multiple
    REST endpoints and minimizes data over-fetching, optimizing both the network performance
    and the developer experience.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些你的应用程序处理复杂、相互关联的数据结构的项目中，例如社交网络、电子商务平台或 **内容管理系统**（**CMSs**），GraphQL 能够在单个请求中查询深度嵌套的数据，这使得它与
    Node.js 完美匹配。这种组合减少了多个 REST 端点的需求，并最小化了数据过取，优化了网络性能和开发者体验。
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this tutorial, we will create a simple GraphQL API with a book and author
    relationship using Fastify and Mercurius ( [http://npmjs.com/package/mercurius](http://npmjs.com/package/mercurius)
    ), a GraphQL adapter for Fastify. This tutorial will guide you through setting
    up your Node.js project, installing dependencies, defining your GraphQL schema,
    implementing resolvers, and running your server. We’ll use a simple in-memory
    data structure to simulate a database for authors and books.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用 Fastify 和 Mercurius（[http://npmjs.com/package/mercurius](http://npmjs.com/package/mercurius)），一个
    Fastify 的 GraphQL 适配器，创建一个简单的 GraphQL API，其中包含书籍和作者关系。本教程将指导你设置 Node.js 项目、安装依赖项、定义你的
    GraphQL 模式、实现解析器和运行你的服务器。我们将使用一个简单的内存数据结构来模拟作者和书籍的数据库。
- en: Before diving into the creation of a GraphQL API using Fastify and Mercurius,
    you’ll need to set up your development environment.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入使用 Fastify 和 Mercurius 创建 GraphQL API 之前，你需要设置你的开发环境。
- en: 'Start by creating a new directory for your project:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先为你的项目创建一个新的目录：
- en: '[PRE78]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Initialize the Node.js project with **npm** :'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **npm** 初始化 Node.js 项目：
- en: '[PRE79]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: With your environment ready and dependencies installed, let’s move on to the
    recipe steps.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的环境准备就绪且已安装依赖项后，让我们继续到菜谱步骤。
- en: How to do it…
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We’re now ready to build the core functionality of our Fastify GraphQL API.
    This part of the process involves defining our data models, setting up a GraphQL
    schema, writing resolvers to handle data fetching, and finally, starting our server.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建Fastify GraphQL API的核心功能。这个过程的一部分涉及定义我们的数据模型，设置GraphQL模式，编写解析器来处理数据获取，最后启动我们的服务器。
- en: 'Let’s start by installing the necessary modules. Our GraphQL server will need
    a few dependencies to run. Specifically, we will be using Fastify as the web framework
    and Mercurius as the GraphQL adapter. Install these by running the following command:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先安装必要的模块。我们的GraphQL服务器需要一些依赖项才能运行。具体来说，我们将使用Fastify作为Web框架，使用Mercurius作为GraphQL适配器。通过运行以下命令来安装这些模块：
- en: '[PRE80]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we need to create some mock data to work with. This will help us test
    our GraphQL API without needing a database. In your project folder, create a file
    named **data.js** . This file will contain arrays of authors and books, establishing
    a simple relationship between them where each book is linked to an author:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一些模拟数据来工作。这将帮助我们测试GraphQL API，而无需数据库。在你的项目文件夹中，创建一个名为**data.js**的文件。此文件将包含作者和书籍的数组，建立它们之间简单的关系，其中每本书都与一个作者相关联：
- en: '[PRE81]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, add the following to **data.js** to populate some author and book data:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下内容添加到**data.js**中，以填充一些作者和书籍数据：
- en: '[PRE82]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next, we need to create a GraphQL schema to represent our author and book relationship
    and queries. Create a file named **schema.graphql** :'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个GraphQL模式来表示我们的作者和书籍关系以及查询。创建一个名为**schema.graphql**的文件：
- en: '[PRE83]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, add the following GraphQL schema to **schema.graphql** :'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，将以下GraphQL模式添加到**schema.graphql**中：
- en: '[PRE84]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, create a file named **resolvers.js** . This file will contain functions
    to handle the logic for fetching the data:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为**resolvers.js**的文件。此文件将包含处理数据获取逻辑的函数：
- en: '[PRE85]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To implement our GraphQL resolvers, add the following code to **resolvers.js**
    :'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现我们的GraphQL解析器，将以下代码添加到**resolvers.js**中：
- en: '[PRE86]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, we can create our Fastify server:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以创建我们的Fastify服务器：
- en: '[PRE87]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Add the following to **server.js** :'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下内容添加到**server.js**中：
- en: '[PRE88]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Start your Fastify server:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Fastify服务器：
- en: '[PRE89]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Open your browser and navigate to **http://localhost:3000/graphiql** to access
    the GraphiQL interface. You should expect to see an interface like this:![Figure
    7.1 – GraphiQL interface showing query result](img/B19212_07_01.jpg)
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的浏览器并导航到**http://localhost:3000/graphiql**以访问GraphiQL界面。您应该期望看到一个类似这样的界面：![图7.1
    – 显示查询结果的GraphiQL界面](img/B19212_07_01.jpg)
- en: Figure 7.1 – GraphiQL interface showing query result
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 显示查询结果的GraphiQL界面
- en: 'Try crafting some queries in the GraphiQL interface. For example, try executing
    the following query to fetch all books with their authors:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在GraphiQL界面中构建一些查询。例如，尝试执行以下查询以获取所有书籍及其作者：
- en: '[PRE90]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Expect to see this output:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 期望看到以下输出：
- en: '![Figure 7.2 – GraphiQL interface showing query result](img/B19212_07_02.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 显示查询结果的GraphiQL界面](img/B19212_07_02.jpg)'
- en: Figure 7.2 – GraphiQL interface showing query result
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 显示查询结果的GraphiQL界面
- en: This tutorial provides you with a foundation for creating a GraphQL API using
    Fastify and Mercurius. From here, you can extend your API by adding more complex
    types, queries, and mutations or by integrating a database for persistent storage.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程为您提供了使用Fastify和Mercurius创建GraphQL API的基础。从这里，您可以通过添加更复杂的数据类型、查询和突变来扩展您的API，或者通过集成数据库来实现持久化存储。
- en: How it works…
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the tutorial, we explore the creation of a GraphQL API using Fastify and
    Mercurius by defining data models, establishing a GraphQL schema, implementing
    resolvers for data fetching, and setting up a Fastify server.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们通过定义数据模型、建立GraphQL模式、实现数据获取的解析器和设置Fastify服务器，探讨了使用Fastify和Mercurius创建GraphQL
    API的过程。
- en: By creating mock data in **data.js** , we simulate a backend data store that
    contains authors and books. This approach allows us to focus on the GraphQL setup
    without the complexity of integrating an actual database. The data represents
    a basic relationship between books and their authors, serving as the foundation
    for our GraphQL queries.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在**data.js**中创建模拟数据，我们模拟了一个包含作者和书籍的后端数据存储。这种方法允许我们专注于GraphQL设置，而不必处理集成实际数据库的复杂性。这些数据代表了书籍和它们作者之间基本的关系，为我们GraphQL查询提供了基础。
- en: The GraphQL schema defined in **schema.graphql** acts as a contract between
    the server and the client. It specifies the types of queries that can be made,
    the types of data that can be fetched, and the relationships between different
    data types. In our case, the schema outlines how to query books and authors and
    indicates that each book is linked to an author and vice versa. This structure
    allows clients to understand and predict the shape of the data returned by the
    API.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **schema.graphql** 中定义的 GraphQL 模式充当服务器和客户端之间的合同。它指定了可以进行的查询类型、可以获取的数据类型以及不同数据类型之间的关系。在我们的案例中，该模式概述了如何查询书籍和作者，并指出每本书都与一个作者相关联，反之亦然。这种结构允许客户端理解和预测
    API 返回的数据形状。
- en: The resolvers in **resolvers.js** are functions that handle the logic for fetching
    the data for each type specified in the schema. They connect the GraphQL queries
    to the underlying data, essentially telling the server where and how to retrieve
    or modify the data. In the recipe, resolvers fetch books and authors from the
    mock data and resolve the relationships between them, such as finding an author
    for a book or listing all books written by an author.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**resolvers.js** 中的解析器是处理在模式中指定的每个类型的获取数据逻辑的函数。它们将 GraphQL 查询连接到底层数据，本质上告诉服务器在哪里以及如何检索或修改数据。在本食谱中，解析器从模拟数据中获取书籍和作者，并解决它们之间的关系，例如找到一个书籍的作者或列出一位作者所写的所有书籍。'
- en: Finally, setting up the Fastify server and integrating Mercurius allows us to
    serve our GraphQL API over HTTP. The server listens for requests on a specified
    port and uses the schema and resolvers to process GraphQL queries.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置 Fastify 服务器并集成 Mercurius 允许我们在 HTTP 上提供我们的 GraphQL API。服务器监听指定端口上的请求，并使用模式和解析器来处理
    GraphQL 查询。
- en: Upon running the server, you can navigate to the GraphiQL interface to visually
    construct and execute queries against your API. This interactive environment is
    useful for testing and debugging queries.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器后，您可以导航到 GraphiQL 界面，以可视化地构建和执行针对您的 API 的查询。这个交互式环境对于测试和调试查询非常有用。
- en: Whether GraphQL is the appropriate architecture for your project is a vast topic
    that goes well beyond the basics covered in this recipe. It involves deep considerations
    such as optimizing query performance, ensuring security, efficient data loading
    to avoid over- or under-fetching, and integrating with different databases or
    APIs. While we’ve laid the groundwork with Fastify and Mercurius, diving into
    these more complex aspects is essential for developing sophisticated, production-ready
    GraphQL services.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 是否 GraphQL 是您项目的适当架构是一个广泛的话题，它远远超出了本食谱中涵盖的基本内容。它涉及深入考虑，如优化查询性能、确保安全性、高效加载数据以避免过度或不足获取，以及与不同的数据库或
    API 集成。虽然我们已经使用 Fastify 和 Mercurius 打下了基础，但深入研究这些更复杂的方面对于开发复杂的、生产就绪的 GraphQL 服务至关重要。
- en: See also
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B19212_06.xhtml#_idTextAnchor178)'
- en: '[*Chapter 11*](B19212_11.xhtml#_idTextAnchor353)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 11 章*](B19212_11.xhtml#_idTextAnchor353)'
