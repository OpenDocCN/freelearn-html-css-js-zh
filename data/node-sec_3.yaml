- en: Chapter 3. Application Considerations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。应用考虑
- en: Now it's time to deal with real-world applications! As mentioned before, one
    of Node.js platform's killer features is the wealth of modules and rapidly moving
    community. It is still important to audit every module that you use for security,
    but using modules is likely going to become an indispensable part of your workflow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候处理真实世界的应用程序了！正如之前提到的，Node.js平台的杀手功能之一是丰富的模块和快速发展的社区。审计您使用的每个模块以确保安全仍然很重要，但使用模块很可能会成为工作流程中不可或缺的一部分。
- en: Because of its immense popularity, I will be writing my code examples to specifically
    targeting **Express** applications. This should cover the vast majority of Node.js
    applications out there today, but many of the concepts we will cover apply to
    any platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其巨大的流行度，我将专门编写我的代码示例以针对**Express**应用程序。这应该涵盖今天大多数Node.js应用程序，但我们将涵盖的概念适用于任何平台。
- en: Introduction to Express
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express简介
- en: Express is a minimal web development framework for Node.js that focuses on remaining
    small, yet robust. It is built on top of another framework called **Connect**,
    which is a platform for writing HTTP servers with small plugins known as middleware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Express是一个专注于保持小巧但强大的Node.js最小化Web开发框架。它是建立在另一个称为**Connect**的框架之上的，这是一个用于编写带有小插件（称为中间件）的HTTP服务器的平台。
- en: The architecture of Connect and Express allows you to use only what you require,
    and nothing else. This works very nicely into the security discussion, as you
    aren't incorporating lots of functionality that you don't use, which leaves the
    doors open for security vulnerabilities that may go unchecked.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Connect和Express的架构允许您仅使用您需要的内容，而不是其他。这非常好地融入了安全讨论中，因为您不会整合大量不使用的功能，这为可能未经检查的安全漏洞敞开了大门。
- en: 'Connect is bundled with over 20 commonly used middleware, adding capabilities,
    such as logging, sessions, cookie parsing, request body parsing, and more. While
    defining a Connect or Express app, you simply add the middleware that you intend
    to use as shown in the following code:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Connect捆绑了20多个常用的中间件，增加了日志记录、会话、cookie解析、请求体解析等功能。在定义Connect或Express应用程序时，只需按照以下代码添加要使用的中间件：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we are creating an application with three middleware: `favicon`, `basicAuth`,
    and a custom one of our own. The first two are provided by Connect, and they can
    each take configuration to specify their exact behavior.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个具有三个中间件的应用程序：`favicon`，`basicAuth`和我们自己的自定义中间件。前两个由Connect提供，它们都可以进行配置以指定其确切的行为。
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Middleware is always executed in the order it was attached, which is something
    to keep in mind while you are determining what and when to attach.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件总是按照附加的顺序执行，这是在确定何时以及何时附加时要记住的事情。
- en: Connect uses continuation-passing style, which means that each middleware function
    is given control, and must pass control to the next middleware in the continuation
    when it has completed. In terms of our application here, each middleware is given
    the request and response object and has full control over the life cycle of the
    request.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Connect使用传递风格，这意味着每个中间件函数都被赋予控制权，并且在完成后必须将控制传递给继续中的下一个中间件。在我们这里的应用程序方面，每个中间件都被赋予请求和响应对象，并且对请求的生命周期具有完全控制权。
- en: 'Since they are executed in order, let us examine how a request/response cycle
    operates for this application. Since middleware has full control, it can take
    one of the following three main courses of action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们按顺序执行，让我们来看看这个应用程序的请求/响应循环是如何运作的。由于中间件具有完全控制权，它可以采取以下三种主要行动之一：
- en: Respond to the request outright, ending the continuation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接响应请求，结束继续
- en: Modify the request or response object for other middleware in the continuation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改请求或响应对象以供继续中间件使用
- en: Do nothing and simply initiate the next layer of middleware
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不做任何操作，只需启动下一层中间件
- en: Luckily for us, we have examples of all the three right here! First, when an
    application comes into this server, it is run through the `favicon` middleware.
    It checks the **uniform resource identifier** (**URI**), and if it matches `/favicon.ico`,
    it responds with a `favicon` icon for the browser. If the URI does not match,
    it simply passes over to the next middleware.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们在这里有所有三个的例子！首先，当一个应用程序进入这个服务器时，它会通过`favicon`中间件运行。它检查**统一资源标识符**（**URI**），如果匹配`/favicon.ico`，它会为浏览器响应一个`favicon`图标。如果URI不匹配，它就会简单地传递给下一个中间件。
- en: Next up, if the request proceeds, is the `basicAuth` middleware. This prompts
    the user to provide a username and password combination using **HTTP Basic Authentication**
    . If the user does not provide the correct credentials, the server responds with
    **401 (Unauthorized)** and ends the request. If the user successfully provides
    the correct username and password, the request object is modified to include the
    user's information and then the next middleware is initiated.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果请求继续，就是`basicAuth`中间件。这会提示用户使用**HTTP基本身份验证**提供用户名和密码组合。如果用户未提供正确的凭据，服务器将以**401（未经授权）**响应并结束请求。如果用户成功提供了正确的用户名和密码，请求对象将被修改以包含用户信息，然后启动下一个中间件。
- en: Last up is our custom middleware, which is probably the simplest one you could
    have. All it does is send **Hello World** as the response body. This means that
    no matter what URI we request (other than `/favicon.ico` of course), and as long
    as we provide the correct credentials, we will see **Hello World**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是我们的自定义中间件，这可能是您可能拥有的最简单的中间件。它的作用只是将**Hello World**作为响应主体发送。这意味着无论我们请求什么URI（当然除了`/favicon.ico`），只要我们提供正确的凭据，我们就会看到**Hello
    World**。
- en: 'Now that you have a basic understanding of how middleware works, let''s move
    on to Express, and what it adds to Connect. Express adds routing, HTTP helpers,
    a view system, content negotiation, and other features using the Connect system.
    In fact, an Express app looks very similar to a Connect app as shown in the following
    code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对中间件的工作原理有了基本的了解，让我们继续学习Express以及它对Connect的增强。Express通过Connect系统添加了路由、HTTP助手、视图系统、内容协商和其他功能。事实上，Express应用程序看起来与Connect应用程序非常相似，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Express automatically includes the Connect middleware within its own namespace,
    so you can use them without needing to explicitly require Connect. In addition,
    it adds some powerful features of its own, notably the routing feature we are
    using here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Express自动在其自己的命名空间中包含Connect中间件，因此您可以在不需要显式要求Connect的情况下使用它们。此外，它还添加了一些自己的强大功能，特别是我们在这里使用的路由功能。
- en: Express was heavily inspired by the **Sinatra** web framework for **Ruby** .
    Each HTTP verb (`GET`, `POST`, and so on) has a corresponding function on the
    app object. Here, we are saying that an HTTP `GET` request for the URL `/` will
    send **Hello World**. Any other URL will get a **404 (Not Found)** error, except
    `/favicon.ico`, which is covered by the favicon middleware.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Express受到了**Ruby**的**Sinatra** Web框架的启发。每个HTTP动词（`GET`，`POST`等）在应用对象上都有一个相应的函数。在这里，我们说URL`/`的HTTP
    `GET`请求将发送**Hello World**。任何其他URL都将得到**404（未找到）**错误，除了`/favicon.ico`，它由favicon中间件处理。
- en: Express is minimalistic and remains out of your way to develop your application
    as you see fit. It doesn't lock you into an MVC framework, or a particular view
    engine, and allows you to include whatever npm modules you like to power your
    application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Express是一种极简主义的方法，可以按照您的意愿开发应用程序。它不会将您锁定在MVC框架或特定的视图引擎中，并允许您包含任何npm模块来为您的应用程序提供动力。
- en: Authentication
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: Authentication is a process of determining that a user is who they claim to
    be, when they are attempting to perform some action through your application.
    There are many ways to accomplish this, and I will cover some of the more common
    ones here. With a few exceptions, my examples will boil down to a couple of available
    npm modules. You are more than welcome to use others to accomplish the same goals.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是确定用户在尝试通过您的应用程序执行某些操作时是否是他们声称的用户的过程。有许多方法可以实现这一点，我将在这里介绍一些更常见的方法。除了一些例外，我的示例将归结为几个可用的npm模块。您可以随时使用其他模块来实现相同的目标。
- en: HTTP Basic Authentication
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP基本身份验证
- en: The first is the **HTTP Basic Authentication**, and it is one of the simplest
    techniques available. It allows a username and password to be submitted along
    with an HTTP request, and allows the server to restrict access if the expected
    credentials are not sent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是**HTTP基本身份验证**，它是可用的最简单的技术之一。它允许在HTTP请求中提交用户名和密码，并允许服务器在未发送预期凭据时限制访问。
- en: While using a web browser, a page that requires the HTTP Basic Authentication
    will prompt the user with a dialog box asking for their username and password.
    After the user enters their information, the browser typically stores those credentials
    for a set period of time, rather than constantly prompting the user on each page.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Web浏览器时，需要HTTP基本身份验证的页面将提示用户输入用户名和密码的对话框。用户输入信息后，浏览器通常会在一段时间内存储这些凭据，而不是在每个页面上不断提示用户。
- en: The main advantage of this method is that it is very simple to implement. In
    fact, it can be done in as little as one line with Connect. In addition, this
    method is completely stateless and requires no out-of-band information with the
    request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要优点是非常简单实现。事实上，使用Connect可以在一行代码中完成。此外，这种方法完全是无状态的，不需要请求中的任何带外信息。
- en: There are a number of important disadvantages, first of which is that it is
    not confidential. In other words, a basic HTTP request includes the username and
    password in plain text. Technically it is encoded as `base64`, but that is not
    an encryption method. As a result, this technique must be combined with some sort
    of encryption, such as HTTPS. Otherwise, the request can be intercepted by packet
    sniffers, and the credentials are no longer secret.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的缺点，首先是它不是保密的。换句话说，基本的HTTP请求包括明文的用户名和密码。从技术上讲，它被编码为`base64`，但这不是一种加密方法。因此，这种技术必须与某种加密方法结合使用，例如HTTPS。否则，请求可以被数据包嗅探器拦截，凭据就不再是秘密了。
- en: Also, the efficiency of this method is less than ideal. When a request is made
    for a page that requires the HTTP Basic Authentication, the server effectively
    has to process that first request twice. On the first attempt, the request is
    denied, and the user needs to supply their credentials. On the second attempt,
    the credentials are sent with the request itself, and the server has to process
    the authentication again. Depending on how the username and password are validated,
    this can be an unacceptable delay that is incurred for each request.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法的效率不太理想。当请求页面需要HTTP基本身份验证时，服务器实际上必须处理第一次请求两次。在第一次尝试中，请求被拒绝，用户需要提供他们的凭据。在第二次尝试中，凭据与请求一起发送，服务器必须再次处理身份验证。根据用户名和密码的验证方式，这可能是每个请求都会产生不可接受的延迟。
- en: In addition, there is no implemented way for browsers to log out while using
    this method, aside from closing the browser itself. The credentials are stored
    by the browser, and the user is not prompted to control how long it is stored,
    or when it should expire. To my understanding, only Internet Explorer provides
    such a feature, but it requires JavaScript in order to be triggered.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用此方法时，浏览器没有实现注销的方式，除非关闭浏览器本身。凭据由浏览器存储，用户不会被提示控制存储时间的长短，或者何时应该过期。据我了解，只有Internet
    Explorer提供了这样的功能，但它需要JavaScript才能触发。
- en: Last, as a developer, you have no control over the appearance of the login screen;
    it is entirely up to the browser. While this could boil down to simple aesthetics,
    it could be argued that it is more secure than a custom solution. If you desire
    to implement it, it is very easy to do so. One of the bundled middleware that
    Connect (and by extension, Express) affords is for this very purpose. It is called
    the `basicAuth` middleware, and it can be configured in several ways.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为开发者，你无法控制登录界面的外观；这完全取决于浏览器。虽然这可能归结为简单的美学，但可以说它比自定义解决方案更安全。如果你想要实现它，这是非常容易做到的。Connect（以及Express）提供的捆绑中间件之一就是为了这个目的。它被称为`basicAuth`中间件，可以以多种方式进行配置。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While using middleware, remember the order is very important! Make sure to place
    your authentication middleware early in the chain so you are authenticating all
    your requests, and not running unnecessary processing before verifying your user's
    identity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用中间件时，记住顺序非常重要！确保将身份验证中间件尽早放置在链中，这样你就可以对所有请求进行身份验证，而不是在验证用户身份之前运行不必要的处理。
- en: 'First, you can simply provide a single username and password to the middleware,
    giving you a single valid set of credentials for your application as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以简单地向中间件提供一个用户名和密码，为你的应用程序提供一个有效的凭据集，如下所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have set up our application to require the username `"admin"` and the
    password `"123456"` via the HTTP Basic Authentication. This is the simplest method
    of adding this authentication method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了我们的应用程序需要通过HTTP基本认证来要求用户名为`"admin"`，密码为`"123456"`。这是添加这种认证方法的最简单方法。
- en: 'A more advanced usage is to provide a synchronous callback function that can
    perform a slightly more sophisticated authentication scheme, for example, you
    can include a JavaScript object with username and password combinations that you
    can use to perform an in-memory lookup. This is illustrated in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的用法是提供一个同步回调函数，可以执行稍微复杂的身份验证方案，例如，你可以包含一个包含用户名和密码组合的JavaScript对象，以便执行内存查找。这在以下代码中有所体现：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have set up `basicAuth` to check our `users` object for a corresponding username
    and password combination that is valid. If the callback function returns `true`,
    the authentication was successful. Otherwise, the authentication fails and the
    server responds appropriately.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置`basicAuth`来检查我们的`users`对象是否有相应的用户名和密码组合是有效的。如果回调函数返回`true`，则认证成功。否则，认证失败，服务器会做出相应的响应。
- en: 'Both of the methods we just used require some sort of hardcoding of credentials
    within our application''s source code. The last method is more than likely the
    method you will employ if you use the HTTP Basic Authentication. This is asynchronous
    callback verification. This allows you to validate the request against some external
    source, such as a text file or database. Refer the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用的两种方法都需要在应用程序源代码中硬编码凭据。最后一种方法很可能是你会使用的方法，如果你使用HTTP基本认证的话。这是异步回调验证。这允许你对请求进行验证，例如根据文本文件或数据库等外部来源。参考以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we have a similar configuration in that we are using a function
    parameter. This function, unlike the previous example, has three arguments. It
    receives the username and password as before, but also receives a callback function
    that it needs to execute, when it has finished validating the credentials. For
    the sake of brevity, I have not included specific implementation details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个类似的配置，我们使用了一个函数参数。这个函数，与之前的例子不同，有三个参数。它接收用户名和密码，但也接收一个回调函数，当它完成验证凭据时需要执行。出于简洁起见，我没有包括具体的实现细节。
- en: The point is that you can perform the action asynchronously, and the callback
    function takes two parameters of its own. In Node.js fashion, the first parameter
    is an `Error` object, if the authentication fails. The second parameter is the
    user's information that will be added to `req.user` by the middleware, allowing
    the user's information to be accessed by later middleware functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是你可以异步执行操作，回调函数有自己的两个参数。按照Node.js的风格，如果认证失败，第一个参数是一个`Error`对象。第二个参数是用户的信息，将由中间件添加到`req.user`中，允许后续中间件函数访问用户的信息。
- en: After all is said and done, HTTP Basic Authentication is likely to be insufficient
    for most applications. Next, we will discuss **HTTP Digest Authentication** ,
    which was originally designed to be the successor to HTTP Basic Authentication.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 说到底，HTTP基本认证可能对大多数应用程序来说是不够的。接下来，我们将讨论**HTTP摘要认证**，它最初被设计为HTTP基本认证的继任者。
- en: HTTP Digest Authentication
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP摘要认证
- en: HTTP Digest Authentication aims to be more secure than the HTTP Basic Authentication
    by not sending the credentials as plain text. Instead, it employs the **MD5**
    one-way hashing algorithm to encrypt the user's authentication information. It
    is worth noting that MD5 is no longer considered a safe algorithm, which is one
    strike against this particular mechanism.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP摘要认证旨在比HTTP基本认证更安全，因为它不会以明文形式发送凭据。相反，它使用MD5单向哈希算法来加密用户的认证信息。值得注意的是，MD5不再被认为是一种安全的算法，这是这种特定机制的一个缺点。
- en: I am including this explanation simply for the sake of completeness. It is not
    popular and seldom recommended for use today, so I will not include any further
    details or examples.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是为了完整起见才包括这个解释。它并不受欢迎，今天很少推荐使用，所以我不会再包括任何更多的细节或例子。
- en: It operates in the same way as the HTTP Basic Authentication in several ways.
    First, the initial request by the client is rejected when authentication is required,
    and the server indicates that the client needs to use the HTTP Digest Authentication.
    The client computes a hash of the user's credentials and the server's authentication
    realm. There are optional features available according to the specification for
    improving the hashing algorithms and preventing hijacking by malicious agents.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它以与HTTP基本认证相同的方式运作。首先，当需要认证时，客户端的初始请求被拒绝，服务器指示客户端需要使用HTTP摘要认证。客户端计算用户凭据和服务器认证领域的哈希值。根据规范，还有一些可选的功能可用于改进哈希算法并防止被恶意代理劫持。
- en: The one advantage that the HTTP Digest Authentication has is that the password
    is not transmitted over the network in plain text. This authentication method
    was devised in an era, where running HTTPS/SSL for all network transactions was
    prohibitively expensive both in terms of money and processing power. Now that
    era has passed, and you should be using HTTPS consistently through your application.
    With that being the case, the advantages of the HTTP Digest Authentication over
    the HTTP Basic Authentication are practically nonexistent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP摘要认证的一个优点是密码不以明文形式在网络上传输。这种认证方法是在一个时代设计的，在那个时代，对所有网络事务运行HTTPS/SSL是非常昂贵的，无论是在金钱还是处理能力方面。现在那个时代已经过去，你应该在整个应用程序中一直使用HTTPS。在这种情况下，HTTP摘要认证相对于HTTP基本认证的优势几乎不存在。
- en: Introducing Passport.js
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Passport.js
- en: Now, I will be introducing a project that is a very popular authentication layer
    for Connect and Express applications. The project is Passport.js ([http://passportjs.org/](http://passportjs.org/)),
    and it is actually a collection of modules that aim to provide a consistent API
    for authenticating, using many different methods and providers. The rest of the
    examples for this section will use the Passport.js API, and I will explain some
    of the more common protocols along the way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将介绍一个非常受欢迎的用于Connect和Express应用程序的认证层项目。该项目是Passport.js ([http://passportjs.org/](http://passportjs.org/))，实际上是一个旨在提供一致的API来进行认证的模块集合，使用许多不同的方法和提供者。本节的其余示例将使用Passport.js
    API，并且我将在其中解释一些更常见的协议。
- en: 'To use Passport.js in your application, you will need to configure the following
    three pieces:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中使用Passport.js，你需要配置以下三个部分：
- en: Authentication strategies
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证策略
- en: Application middleware
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序中间件
- en: Sessions (optional)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会话（可选）
- en: Passport.js uses the term "strategies" to refer to a method of authenticating
    a request. This could be a username and password, even third-party authentication,
    such as OpenID, or OAuth. This is the first thing you will configure, and it will
    depend on what methods of authentication you choose to support.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Passport.js使用术语“策略”来指代认证请求的一种方法。这可以是用户名和密码，甚至第三方认证，比如OpenID或OAuth。这是你将要配置的第一件事情，它将取决于你选择支持的认证方法。
- en: 'As a starting example, we''ll look at the local strategy, where you take an
    HTTP `POST` request with a username and password in the body to authenticate against
    your own data store as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个起始示例，我们将看一下本地策略，其中你可以接受一个HTTP `POST`请求，其中包含身份验证所需的用户名和密码，然后根据以下代码对其进行验证：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the sake of simplicity, this does not wire into our application, this just
    demonstrates Passport.js middleware''s API. What we are doing here is configuring
    a local strategy. This strategy takes a single verify callback that has three
    arguments: the username, password, and a callback function to be called once the
    authentication is complete. (Passport.js handles extracting the username and password
    from the `POST` request) The callback function takes three arguments of its own:
    an `Error` object (if applicable), the user''s information (if applicable, false
    if the authentication fails), and an options hash.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，这不会连接到我们的应用程序，这只是演示了Passport.js中间件的API。我们在这里配置了一个本地策略。这个策略接受一个验证回调，有三个参数：用户名、密码和一个回调函数，一旦认证完成就会被调用。（Passport.js处理从`POST`请求中提取用户名和密码）回调函数有它自己的三个参数：一个`Error`对象（如果适用），用户的信息（如果适用，如果认证失败则为false），以及一个选项哈希。
- en: 'In this case, the verify callback calls some sort of user API (the specifics
    of that are not important) to find a user matching the supplied username, then
    it proceeds with that data into the following checks:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，验证回调调用某种用户API（具体内容并不重要）来查找与提供的用户名匹配的用户，然后继续进行以下检查：
- en: If a fatal error occurs (such as the database is down, or the network is disconnected),
    then the callback is issued with that `Error` object as its only argument, which
    will be passed outside of Passport.js to be handled by your application.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生致命错误（比如数据库宕机，或者网络断开连接），那么回调将发出`Error`对象作为它唯一的参数，这将被传递到Passport.js之外，由你的应用程序处理。
- en: If that username does not exist, or the password is invalid, then the callback
    is issued with null as the first argument (since no error occurred), `false` as
    its second argument (since the authentication itself failed), and an object with
    a single `message` property that we can use to display a message to the user (this
    third argument is optional).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该用户名不存在，或者密码无效，那么回调将以`null`作为第一个参数（因为没有错误发生），`false`作为第二个参数（因为认证本身失败了），以及一个具有单个`message`属性的对象，我们可以用它来向用户显示消息（这第三个参数是可选的）。
- en: If the user passes these checks, then the authentication was successful. The
    callback is issued with `null` first and the user's information object second.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户通过了这些检查，那么认证就成功了。回调函数首先发出`null`，然后是用户的信息对象。
- en: The use of a callback in this fashion allows Passport.js to remain completely
    unaware of the underlying implementation. Now, let's move onto the middleware
    configuration step. Passport.js was specifically designed to use in Connect and
    Express applications, but it will work in anything that uses the same middleware
    style.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用回调允许Passport.js完全不知道底层实现。现在，让我们继续进行中间件配置步骤。Passport.js专门设计用于在Connect和Express应用程序中使用，但它也适用于使用相同中间件风格的任何应用程序。
- en: 'After configuring Passport.js and your strategies, you will need to attach
    at least one middleware to initialize Passport.js in your application as shown
    in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Passport.js和您的策略后，您需要附加至少一个中间件来在应用程序中初始化Passport.js，如下所示的代码：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a basic Express application, and we are attaching two Passport-related
    middleware: the initialization and the optional session support. Remember, the
    order is important, so you to initialize Passport.js after middleware like `bodyParser`
    and `session`, but before your application router.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的Express应用程序，我们附加了两个与Passport相关的中间件：初始化和可选的会话支持。请记住，顺序很重要，所以您需要在像`bodyParser`和`session`这样的中间件之后初始化Passport.js，但在应用程序路由之前。
- en: 'The session-support middleware is optional, but recommended for most applications,
    as it is a very common use case, and it must be attached after Express'' own `session`
    middleware. Last, we will configure the session support itself as shown in the
    following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 会话支持中间件是可选的，但对于大多数应用程序来说是建议的，因为这是一个非常常见的用例，并且必须在Express自己的`session`中间件之后附加。最后，我们将配置会话支持本身如下所示的代码：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Storing all of the available user data, especially as the number of concurrent
    users increases, can be costly. As a result, Passport.js gives developers a way
    to configure what is stored into the session, as well as the ability to retrieve
    the user's data for a single request (rather than holding it constantly in memory).
    This is by no means required, as using a shared database to store your session
    information can alleviate this problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 存储所有可用的用户数据，特别是随着并发用户数量的增加，可能会很昂贵。因此，Passport.js为开发人员提供了一种配置存储到会话中的内容以及检索用户数据的能力的方式（而不是在内存中持续保留）。这并不是必需的，因为使用共享数据库存储会话信息可以缓解这个问题。
- en: The `serializeUser` function in the preceding example receives a callback that
    is executed, when the session is being initialized. Here, we are storing only
    the user's ID into the session, keeping it as light as possible, while still giving
    us the information we need to find their information later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`serializeUser`函数接收一个回调，当会话被初始化时执行。在这里，我们只将用户的ID存储到会话中，使其尽可能轻量，同时仍然为我们提供查找他们信息所需的信息。
- en: The corresponding `deserializeUser` function is called on each subsequent request,
    and adds the corresponding user's data to the request object. In this case, we
    are using a generic API to find a user, based on their ID, and issuing the callback
    with that data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`deserializeUser`函数在每个后续请求上被调用，并将相应的用户数据添加到请求对象中。在这种情况下，我们使用一个通用API来查找用户，基于他们的ID，并使用该数据发出回调。
- en: As you can see, configuring and using Passport.js is easy and it fits right
    into the Connect and Express methodology. There are over 120 strategies available
    for Passport.js, and you can find much more documentation and examples on their
    website ([http://passportjs.org/](http://passportjs.org/)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，配置和使用Passport.js非常简单，并且完全符合Connect和Express的方法论。Passport.js有超过120种策略可用，您可以在他们的网站上找到更多文档和示例（[http://passportjs.org/](http://passportjs.org/)）。
- en: OpenID
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenID
- en: 'OpenID is an open standard for authentication on the Web by the use of a third-party
    service. The aim is to allow users to have a single identity on the Web that they
    can then use with many applications, rather than needing to register with each
    individual application. OpenID has no central authority, each provider is independent,
    and the user may choose any provider that he trusts. There are many major providers
    out there today, including: Google, Yahoo!, PayPal, and many others.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID是一种用第三方服务在网络上进行身份验证的开放标准。其目的是允许用户在网络上拥有一个单一的身份，然后可以在许多应用程序中使用，而不需要在每个单独的应用程序中注册。OpenID没有中央管理机构，每个提供商都是独立的，用户可以选择任何他信任的提供商。今天有许多主要的提供商，包括：Google、Yahoo！、PayPal等。
- en: 'The OpenID authentication process operates something like this (this is a simplified
    explanation): a user is presented with an OpenID login form by a consumer. The
    user enters their provider''s URL. The consumer redirects the user to their provider,
    the provider authenticates the user, and asks the user what information, if any,
    should be shared with the consumer. The provider then redirects the user back
    to the consumer, and the consumer allows the user to use their service.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID身份验证过程的操作大致如下（这是一个简化的解释）：用户由消费者呈现一个OpenID登录表单。用户输入他们提供商的URL。消费者将用户重定向到他们的提供商，提供商对用户进行身份验证，并询问用户是否应与消费者共享任何信息。然后提供商将用户重定向回消费者，消费者允许用户使用他们的服务。
- en: 'To include OpenID in your application, we will use the `passport-openid` module.
    This module is a first class module of the Passport.js project, and it gives you
    a strategy for implementing a generic OpenID authentication process. First, let''s
    look at the following Passport.js configuration required:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中包含OpenID，我们将使用`passport-openid`模块。这个模块是Passport.js项目的一流模块，它为您提供了一种实现通用OpenID身份验证过程的策略。首先，让我们看看以下所需的Passport.js配置：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have included the `passport` and `passport-openid` modules, and have configured
    the OpenID strategy. The configuration object (first argument) has two required
    properties:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了`passport`和`passport-openid`模块，并配置了OpenID策略。配置对象（第一个参数）有两个必需属性：
- en: '`returnURL`: This is the URL that the OpenID provider will redirect the user
    back to in your application'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returnURL`：这是OpenID提供商将用户重定向回您的应用程序的URL。'
- en: '`realm`: This is what the provider will show to the user to identify your application'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`领域`：这是提供者将向用户显示的内容，以识别您的应用程序'
- en: 'The second argument is the verify callback, which only takes two arguments:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是验证回调，只接受两个参数：
- en: '`identifier`: This is how the user identifies himself with your application'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符：这是用户如何在您的应用程序中标识自己
- en: '`done`: This is the callback your application issues after looking up the user
    based on the identifier'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`完成`：这是您的应用程序根据标识符查找用户后发出的回调'
- en: 'Now, you will need to configure the Express routes that you need to process
    the login requests, as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要配置Express路由，以处理登录请求，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have two configured routes, the first one takes the user's login request
    via `POST`, and Passport.js takes care of redirecting the user to the provider.
    The provider has been configured to send the user back to the `returnURL`, which
    corresponds to the second route we have configured earlier.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了两个路由，第一个路由通过`POST`接收用户的登录请求，Passport.js负责将用户重定向到提供者。提供者已配置为将用户发送回`returnURL`，该URL对应于我们之前配置的第二个路由。
- en: 'Next, you will need an HTML form on your login page that `POST` to the route,
    we configured earlier. This is illustrated in the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要在登录页面上添加一个HTML表单，该表单`POST`到我们之前配置的路由。如下面的代码所示：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only required HTML input is one that has the name `"openid_identifier"`.
    Each strategy has its own requirements, so make sure to read the documentation
    for each one as you are implementing them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要的HTML输入是一个具有名称`"openid_identifier"`的输入。每种策略都有自己的要求，因此在实施它们时，请务必阅读每种策略的文档。
- en: What we have configured here is a basic implementation of OpenID authentication
    using Passport.js. Now, we will move onto configuring a basic OAuth implementation
    for authentication as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里配置的是使用Passport.js的基本OpenID身份验证实现。现在，我们将继续配置基本的OAuth实现以进行身份验证。
- en: Where OpenID aims to allow your identity to be authenticated by a trusted third-party,
    OAuth aims to allow users to share information between different applications
    without needing to give up their credentials to each separate party. If you need
    shared data with another service in your application, it is likely that you will
    be consuming an OAuth API from that particular service. If all you need is to
    verify an identity, OpenID will likely be the mechanism of choice for that service.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID旨在允许您的身份由受信任的第三方进行身份验证，而OAuth旨在允许用户在不需要向每个单独的方提供凭据的情况下，在不同的应用程序之间共享信息。如果您的应用程序需要与另一个服务共享数据，那么您很可能会从该特定服务中使用OAuth
    API。如果您只需要验证身份，OpenID可能是该服务的首选机制。
- en: OAuth
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth
- en: OAuth allows a user to share resources from one application to another without
    needing to share their username and password with both services. In addition,
    it also has the added capability of giving limited access. This limitation can
    be time-based, where access is revoked after a certain amount of time elapses.
    It could also restrict access to only a particular set of data, and potentially
    give the user more control over what they decide to share.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth允许用户在不需要向两个服务共享其用户名和密码的情况下，从一个应用程序共享资源到另一个应用程序。此外，它还具有附加功能，可以提供有限的访问权限。此限制可以基于时间，即在经过一定时间后撤销访问权限。它还可以限制对特定数据集的访问，并可能使用户更多地控制他们决定分享什么。
- en: This process works by using a few different sets of keys (three to be more precise).
    Each stage of the authorization process builds upon the previous set of keys to
    construct the keys for the next step. In addition, between each step the user
    is redirected between the other applications, ensuring that the user only gives
    each application the minimum amount of information needed. The explanation I will
    give here is simplified, and does not cover the more technical details about topics
    like encryption and signatures.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程通过使用几组不同的密钥（更精确地说是三组）来完成。授权过程的每个阶段都建立在前一组密钥的基础上，以构建下一步的密钥。此外，在每个步骤之间，用户在其他应用程序之间进行重定向，确保用户只向每个应用程序提供所需的最少信息。我在这里给出的解释是简化的，并没有涵盖诸如加密和签名等技术细节。
- en: The best metaphor for what OAuth does is like a "valet key". Some luxury cars
    have a special key that is limited in access. What I mean is that this special
    key only allows the car to be driven for a short distance, and only allows the
    valet driver to access the car as long as they have that key. This is very similar
    to what OAuth accomplishes, it allows the owner to give temporary and limited
    access to a resource that they own, while never giving up full control of that
    resource.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth的最佳隐喻是“代客泊车钥匙”。一些豪华汽车配有一把特殊的钥匙，其访问权限受限。我的意思是，这把特殊的钥匙只允许汽车行驶一小段距离，并且只允许代客泊车司机在拥有该钥匙的情况下访问汽车。这与OAuth所实现的非常相似，它允许所有者对他们拥有的资源进行临时和有限的访问，同时不放弃对该资源的完全控制。
- en: 'There are usually three parties involved: a `client`, a `server`, and a `resource
    owner`. The client is going to be requesting resources from the server on behalf
    of the resource owner.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常涉及三方：`客户端`、`服务器`和`资源所有者`。客户端将代表资源所有者向服务器请求资源。
- en: To use the same real-world example that the OAuth specification uses, imagine
    Jane has uploaded some personal photos to a photo-sharing site and wishes to have
    them printed by another online service.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用OAuth规范使用的相同真实世界示例，想象一下简已经将一些个人照片上传到一个照片共享网站，并希望通过另一个在线服务将它们打印出来。
- en: In order for the print service (the client) to access the photos stored with
    the photo service (the server), they will need approval from Jane (the resource
    owner). First, any client application will need to register themselves with any
    server application in order to obtain the first set of keys, the client keys.
    These keys are known by both the client and server, and allow the server to validate
    the client's identity first and foremost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印服务（客户端）能够访问存储在照片服务（服务器）中的照片，他们将需要来自Jane（资源所有者）的批准。首先，任何客户端应用程序都需要向任何服务器应用程序注册自己，以获取第一组密钥，即客户端密钥。这些密钥被客户端和服务器都知道，并允许服务器首先验证客户端的身份。
- en: Jane is ready to get her photos printed, so she visits the print service to
    begin the process. She wishes to have her photos pulled from the photo service
    rather than needing to upload them to another service, so she tells the print
    service that she would like photos from the photo service to be used.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Jane准备好打印她的照片，所以她访问打印服务开始这个过程。她希望从照片服务中获取她的照片，而不是需要将它们上传到另一个服务，所以她告诉打印服务她希望使用照片服务的照片。
- en: Now, the printer service sends their client keys to the photo service (through
    a secured HTTPS request) to retrieve a set of temporary keys. These keys are used
    to identify a specified authorization request throughout the various redirects
    that take place.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印服务通过安全的HTTPS请求将他们的客户端密钥发送给照片服务，以检索一组临时密钥。这些密钥用于在各种重定向中标识指定的授权请求。
- en: Once the temporary keys are retrieved, the print service redirects Jane to the
    photo service. While there, Jane needs to verify her identity through whatever
    methods the photo service uses. In addition, the photo service can present Jane
    with options to limit the duration and scope of the authorization.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检索到临时密钥，打印服务将Jane重定向到照片服务。在那里，Jane需要通过照片服务使用的任何方法验证她的身份。此外，照片服务可以向Jane提供选项，以限制授权的持续时间和范围。
- en: Once this verification is complete, Jane is redirected back to the print service
    with the temporary tokens. She has authorized the print service access to the
    photo service, which now exchanges the temporary keys for the last set of keys,
    the token keys.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成此验证，Jane将被重定向回打印服务，并获得临时令牌。她已经授权打印服务访问照片服务，后者现在将临时密钥交换为最后一组密钥，即令牌密钥。
- en: This "access token" can now be used by the print service to request information
    from the photo service under the parameters that Jane has allowed, and can be
    revoked at any time by Jane or the photo service. Rather than using the generic
    `passport-oauth` module in the following examples I will stick to the Facebook
    module that uses OAuth v2.0\. I have chosen this path to avoid needing to show
    all the variations of OAuth in use today, since each implementation may have their
    own variations. In addition, the examples here will give enough of an introduction
    to Passport's API that you can apply the approach to any other provider.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印服务可以使用这个“访问令牌”根据Jane允许的参数从照片服务请求信息，并且可以随时由Jane或照片服务撤销。在下面的示例中，我将坚持使用Facebook模块，该模块使用OAuth
    v2.0，而不是使用通用的`passport-oauth`模块。我选择这条路线是为了避免需要展示当今使用的所有OAuth变体，因为每个实现可能都有自己的变体。此外，这里的示例将为您提供足够的Passport
    API介绍，以便您可以将这种方法应用到任何其他提供者。
- en: 'First, we will need to install the `passport-facebook` module, and then we
    will configure the Passport.js strategy as shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装`passport-facebook`模块，然后根据以下代码配置Passport.js策略：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to use Facebook authentication, you will need to create and register
    an application account with Facebook Developers ([https://developers.facebook.com/](https://developers.facebook.com/)).
    This will likely be a similar process for other services; you will need some sort
    of registration on their side in order to coordinate safely with their users.
    From there, you can obtain a `clientID` and a `clientSecret`, which you put into
    the preceding configuration. You will also need to specify a `callbackURL`, which
    behaves very much like the OpenID `returnURL`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Facebook身份验证，您需要在Facebook开发者（[https://developers.facebook.com/](https://developers.facebook.com/)）注册并创建一个应用程序帐户。这对其他服务可能是类似的过程；您需要在他们那边进行某种注册，以便安全地与他们的用户协调。从那里，您可以获取`clientID`和`clientSecret`，并将其放入前面的配置中。您还需要指定一个`callbackURL`，它的行为非常类似于OpenID的`returnURL`。
- en: 'Next, you will need to configure routes for your Express application as shown
    in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要根据以下代码为您的Express应用程序配置路由：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is very similar to the routes we set up for OpenID, but with one major
    difference. The initial route is not an HTML form `POST`; it is a simple HTTP
    `GET`. This means you can just set up a simple HTML anchor that will point them
    to this route as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们为OpenID设置的路由非常相似，但有一个主要区别。初始路由不是HTML表单`POST`；它是一个简单的HTTP`GET`。这意味着您可以设置一个简单的HTML锚点，将它们指向这个路由，如下所示：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Passport will send the user off to Facebook for authentication. When Facebook
    is finished, it will redirect back to the second route, where you can redirect
    the user as needed (just like the OpenID implementation).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Passport将用户发送到Facebook进行身份验证。当Facebook完成后，它将重定向回第二个路由，您可以根据需要重定向用户（就像OpenID实现一样）。
- en: Passport.js is a great API for abstracting all of your authentication needs,
    so dig into its API documentation ([http://passportjs.org/](http://passportjs.org/))
    and leverage any combination of the over 120 strategies they have available.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Passport.js是一个很好的API，可以抽象出所有您的身份验证需求，所以深入研究它的API文档（[http://passportjs.org/](http://passportjs.org/)），并利用他们提供的120多种策略的任意组合。
- en: Authorization
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: Authorization is determining what access a user has to the restricted resources
    or actions in your application. Authentication deals specifically with who the
    user is, whereas authorization assumes we know who they are and must determine
    what they can do. Express gives us an elegant way of adding authorization built
    right into our routes, which is usually the layer where authorization takes place.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是确定用户对应用程序中受限资源或操作的访问权限。身份验证专门处理用户是谁，而授权假设我们知道他们是谁，并且必须确定他们可以做什么。Express为我们提供了一种优雅的方式，将授权直接构建到我们的路由中，这通常是授权发生的地方。
- en: 'What many do not realize at first about express routing is that you are able
    to pass multiple handlers while defining a route. Each of them behaves like any
    other middleware as shown in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人最初没有意识到的是，关于express路由的是，您可以在定义路由时传递多个处理程序。它们中的每一个都像任何其他中间件一样，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our restrict function checks for user data (assume it is set by our authentication
    layer), and if the user is valid, it allows the chain to proceed. If the user
    is not logged in, it will simply respond with **403 (Forbidden)**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的限制函数检查用户数据（假设它由我们的身份验证层设置），如果用户有效，则允许链继续进行。如果用户未登录，它将简单地响应**403（禁止）**。
- en: The point here is that you can use multiple route handlers as an opportunity
    to handle pre-conditions, such as checking the user's authentication status, their
    roles, or any other rules regarding access. Much of this is highly dependent on
    how you structure your application, and how you determine what the user has access
    to.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，您可以使用多个路由处理程序作为处理预条件的机会，例如检查用户的身份验证状态、他们的角色或关于访问的任何其他规则。其中许多内容高度依赖于您如何构建应用程序以及您如何确定用户可以访问什么。
- en: 'One of the more popular authorization schemes is role-based authorization.
    A user can have any number of roles, such as: `"member"`, `"moderator"` or `"admin"`.
    Each of these roles can be used to determine what access they have on a per-action
    basis.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个更受欢迎的授权方案是基于角色的授权。用户可以拥有任意数量的角色，例如："member"，"moderator"或"admin"。这些角色中的每一个都可以用来确定他们在每个操作上的访问权限。
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we have a list of available users. Assuming we have an
    authentication layer in place that loads a user profile data when logged in, let's
    look at the two middleware, we have defined.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有一个可用用户的列表。假设我们已经有一个身份验证层，当用户登录时加载用户配置数据，让我们看一下我们定义的两个中间件。
- en: First, `loadUser` is a simple middleware function that loads the user for the
    specified route (this may be a different user from the logged in user). Here,
    we just have a hard-coded list, but it could be a database call that we make asynchronously.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`loadUser`是一个简单的中间件函数，用于为指定的路由加载用户（这可能是与登录用户不同的用户）。在这里，我们只有一个硬编码的列表，但它可以是我们异步进行的数据库调用。
- en: Second, the `requireRole` middleware is a bit sophisticated if you are not familiar
    with closure or first-class functions. What we are doing here is returning the
    middleware function, rather than simply using a named one. Through closure, we
    have access to the `role` argument inside the returned function. This middleware
    function ensures that the authenticated user has the role we are requiring.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`requireRole`中间件对于不熟悉闭包或一级函数的人来说有点复杂。我们在这里做的是返回中间件函数，而不是简单地使用命名函数。通过闭包，我们可以在返回的函数内部访问`role`参数。这个中间件函数确保经过身份验证的用户具有我们要求的角色。
- en: We have two routes, the first (showing user data) is public, so it simply loads
    the user data via middleware and does no authorization check. The second route
    (deleting a user) requires that the authenticated user is an admin. If that check
    passes, the user's data is loaded and the route proceeds as expected.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个路由，第一个（显示用户数据）是公开的，因此它只是通过中间件加载用户数据，不进行授权检查。第二个路由（删除用户）要求经过身份验证的用户是管理员。如果检查通过，用户的数据将被加载，并且路由将按预期进行。
- en: There are many authorization methods available to you, with many good modules
    to pick from. Role-based authorization, as we have demonstrated here, is easy
    to implement in Express and it's generally easy to understand logically. As with
    authentication, your implementation depends on how you end up structuring your
    application. My main intent here is to define authorization and show you some
    examples to help you keep that mechanism as distinct as possible from the rest
    of your application logic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多授权方法可供选择，有许多好的模块可供选择。基于角色的授权，正如我们在这里所展示的，易于在Express中实现，并且在逻辑上通常易于理解。与身份验证一样，您的实现取决于您最终如何构建应用程序。我在这里的主要目的是定义授权并向您展示一些示例，以帮助您尽可能将该机制与应用程序的其余部分区分开来。
- en: Security logging
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全日志记录
- en: Another important aspect of security is logging, or recording various events
    within your application so that they can be analyzed for anomalies. These anomalies
    could be reviewed to detect places where attackers are attempting to bypass your
    security methods, and by detecting these activities before an actual intrusion,
    further steps can be taken to mitigate those risks. Beyond just security, logging
    can also help to detect cases in your program that cause problems for your users,
    and allow you to more easily reproduce and fix those problems.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的另一个重要方面是日志记录，或者记录应用程序中的各种事件，以便对异常进行分析。这些异常可以被审查，以便检测攻击者试图绕过安全方法的地方，并且在实际入侵之前检测到这些活动，可以采取进一步的步骤来减轻这些风险。除了安全之外，日志记录还可以帮助检测程序中为用户造成问题的情况，并允许您更轻松地重现和解决这些问题。
- en: Your specific application and environment will be what drives your logging methods.
    By methods, I mean how your logs are recorded and stored, such as the use of flat
    files in your filesystem, using some sort of database or even using third-party
    logging services. While these may differ greatly from project to project, the
    types of events recorded and the related information to save should be fairly
    consistent across the board.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您特定的应用程序和环境将驱动您的日志记录方法。通过方法，我指的是记录和存储日志的方式，例如在文件系统中使用平面文件，使用某种数据库，甚至使用第三方日志记录服务。虽然这些方法在项目之间可能有很大的不同，但记录的事件类型和相关信息应该在整个范围内保持相对一致。
- en: 'The **Open Web Application Security Project** (**OWASP**) has a great guide
    for determining a logging strategy on their website (visit [https://www.owasp.org/index.php/Logging_Cheat_Sheet](https://www.owasp.org/index.php/Logging_Cheat_Sheet)
    for further information). They recommend the following recording logs for these
    specific types of events:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放式网络应用安全项目**（**OWASP**）在其网站上有一个关于确定日志记录策略的很好的指南（访问[https://www.owasp.org/index.php/Logging_Cheat_Sheet](https://www.owasp.org/index.php/Logging_Cheat_Sheet)
    获取更多信息）。他们建议为以下特定类型的事件记录日志：'
- en: Input validation failures (for example, protocol violations, unacceptable encodings,
    invalid parameter names, and values)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证失败（例如，协议违规，不可接受的编码，无效的参数名称和值）
- en: Output validation failures (for example, database record set mismatch and invalid
    data encoding)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出验证失败（例如，数据库记录集不匹配和无效数据编码）
- en: Authentication successes and failures
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证成功和失败
- en: Authorization failures
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权失败
- en: Session management failures (for example, cookie session identification value
    modification)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话管理失败（例如，cookie会话标识值修改）
- en: Application errors and system events (for example, syntax and runtime errors,
    connectivity problems, performance issues, third party service error messages,
    file system errors, file upload virus detection, and configuration changes
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序错误和系统事件（例如，语法和运行时错误，连接问题，性能问题，第三方服务错误消息，文件系统错误，文件上传病毒检测，以及配置更改）
- en: Application and related systems start-ups and shut-downs, and logging initialization
    (starting and stopping)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序和相关系统的启动和关闭，以及日志初始化（启动和停止）
- en: Use of higher-risk functionality (for example, network connections, addition
    or deletion of users, changes to privileges, assigning users to tokens, adding
    or deleting tokens, use of administrative privileges, access by application administrators,
    access to payment cardholder data, use of data encrypting keys, key changes, creation
    and deletion of system-level objects, data import and export including screen-based
    reports, and submission of user-generated content especially file uploads)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更高风险功能（例如，网络连接，添加或删除用户，权限更改，将用户分配给令牌，添加或删除令牌，使用管理权限，应用管理员访问，访问付款卡持有人数据，使用数据加密密钥，密钥更改，创建和删除系统级对象，数据导入和导出，包括基于屏幕的报告，以及提交用户生成的内容，特别是文件上传）
- en: Legal and other opt-ins (for example, permissions for mobile phone capabilities,
    terms of use, terms and conditions, personal data usage consent, and permission
    to receive marketing communications)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法律和其他选择（例如，移动电话功能的权限，使用条款，条款和条件，个人数据使用同意，以及接收营销通讯的许可）
- en: 'In addition to their recommendations, OWASP also presents the following events
    as optional:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了他们的建议，OWASP还将以下事件作为可选事件呈现：
- en: Sequencing failure
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序失败
- en: Excessive use
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用
- en: Data changes
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据更改
- en: Fraud and other criminal activities
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欺诈和其他犯罪活动
- en: Suspicious, unacceptable, or unexpected behavior
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可疑，不可接受或意外行为
- en: Modifications to configuration
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置修改
- en: Application code file and/or memory changes
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序代码文件和/或内存更改
- en: 'While determining what data to store for logs, OWASP recommends avoiding the
    following types of data:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定要存储的日志数据时，OWASP建议避免以下类型的数据：
- en: Application source code
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序源代码
- en: Session identification values (consider replacing with a hashed value if needed
    to track session specific events)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话标识值（如果需要跟踪特定会话事件，则考虑替换为哈希值）
- en: Access tokens
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌
- en: Sensitive personal data and some forms of personally identifiable information
    (PII)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏感个人数据和某些形式的个人身份信息（PII）
- en: Authentication passwords
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证密码
- en: Database connection strings
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接字符串
- en: Encryption keys
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密密钥
- en: Bank account or payment card holder data
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 银行账户或付款卡持有人数据
- en: Data of a higher security classification than the logging system is allowed
    to store
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比日志系统允许存储的更高安全级别的数据
- en: Commercially-sensitive information
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业敏感信息
- en: Information it is illegal to collect in the relevant jurisdiction
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相关司法管辖区内收集的非法信息
- en: Information a user has opted out of collection, or not consented to, for example,
    use of do not track, or where consent to collect has expired
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户选择退出收集的信息，或者未同意收集的信息，例如使用不跟踪，或者同意收集已过期
- en: 'In some cases, the following information can be useful during investigations,
    but should be carefully reviewed before including it in application logs:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，以下信息在调查过程中可能有用，但在包含在应用程序日志中之前应仔细审查：
- en: File paths
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件路径
- en: Database connection strings
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接字符串
- en: Internal network names and addresses
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部网络名称和地址
- en: Non sensitive personal data (for example, personal names, telephone numbers,
    e-mail addresses)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非敏感个人数据（例如，个人姓名，电话号码，电子邮件地址）
- en: Because each application and environment is different, the approaches logging
    can be equally diverse. The npm module we will look at here aims to provide a
    consistent API across many different methods, in addition to allowing you to use
    more than one at a time depending on the context.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个应用程序和环境都不同，日志记录的方法也可以多种多样。我们将在这里看一下的npm模块旨在提供一个统一的API，可以使用多种不同的方法，同时取决于上下文，允许您同时使用多种方法。
- en: The winston module ([https://github.com/flatiron/winston](https://github.com/flatiron/winston))
    provides a clean and easy to use API for writing logs. In addition, it supports
    many methods of logging, including the capability for adding your own custom transports.
    A transport can be described as the storage or display mechanism for a given set
    of logs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`winston`模块（[https://github.com/flatiron/winston](https://github.com/flatiron/winston)）提供了一个清晰易用的API，用于编写日志。此外，它支持许多日志记录方法，包括添加自定义传输的功能。传输可以被描述为给定一组日志的存储或显示机制。'
- en: The `winston` module has built-in transports (as known as core modules) for
    logging to the console, logging to a file and sending logs over HTTP. Beyond the
    core modules, there are officially supported modules for transports, such as `CouchDB`,
    `Redis`, `MongoDB`, `Riak`, and `Loggly`. Lastly, there is a vibrant community
    using the `winston` API as well, with over 23 different custom transports out
    there today, including an e-mail transport and various cloud services like Amazon's
    **SimpleDB** and **Simple Notification Service** (**SNS**). The point is, it is
    likely that whatever transport you may require for your logging, there may be
    a module already available, and of course you are always able to write your own
    as well.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`winston`模块具有内置传输（也称为核心模块），用于将日志记录到控制台、将日志记录到文件以及通过HTTP发送日志。除了核心模块外，还有官方支持的传输模块，例如`CouchDB`、`Redis`、`MongoDB`、`Riak`和`Loggly`。最后，`winston`
    API也有一个充满活力的社区，目前有超过23种不同的自定义传输，包括电子邮件传输和各种云服务，如亚马逊的**SimpleDB**和**Simple Notification
    Service**（**SNS**）。重点是，您可能需要的任何传输，可能已经有可用的模块，当然您也可以自己编写。'
- en: 'To get started with `winston`, install in via npm and you can use it right
    away using the "default logger" as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`winston`，请通过npm安装它，然后您可以立即使用“默认记录器”，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is by far the easiest way to get started quickly with `winston`, but it
    only uses the console transport by default. While the default logger can be extended
    with more transports and configuration, the more flexible approach is to create
    your own instances of `winston` that you can use in various contexts within your
    application. This can be done as shown in the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是最快速开始使用`winston`的方法，但默认情况下只使用控制台传输。虽然默认记录器可以通过更多传输和配置进行扩展，但更灵活的方法是创建自己的`winston`实例，可以在应用程序中的各种上下文中使用。如下面的代码所示：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Within your application code, I typically place the boilerplate code for such
    modules in their own file. From there, you can export a pre-configured object
    that can be imported and used throughout your application, for example, you can
    create a file called `lib/logger.js` that looks like the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序代码中，我通常将此类模块的样板代码放在它们自己的文件中。从那里，您可以导出一个预配置的对象，可以在整个应用程序中导入和使用，例如，您可以创建一个名为`lib/logger.js`的文件，看起来像下面的内容：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then within other parts of your application, you can include the logger and
    use it easily as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在应用程序的其他部分中，您可以包含记录器并轻松使用它，如下所示：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In addition, `winston` also includes other advanced features, such as custom
    log levels, additional transport configuration, and dealing with unhandled exceptions.
    Also, `winston` is not the only logging API available for Node.js, there are other
    alternatives that you can consider depending on your own needs. This is not even
    to mention developing your own custom solution to give you complete control.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`winston`还包括其他高级功能，如自定义日志级别、额外的传输配置和处理未处理的异常。此外，`winston`并不是Node.js中唯一可用的日志记录API，还有其他可供您考虑的替代方案，具体取决于您自己的需求。更不用说开发自己的定制解决方案来完全控制了。
- en: Error handling
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: One of the important aspects of any application is how it handles errors. As
    mentioned before, uncaught exceptions can crash your application, so being able
    to handle errors properly is an important part of your development cycle.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的重要方面之一是如何处理错误。如前所述，未捕获的异常可能会导致应用程序崩溃，因此能够正确处理错误是开发周期的重要部分。
- en: Responding to errors within your own application is the key, so refer back to
    [Chapter 2](ch02.html "Chapter 2. General Considerations"), *General Considerations*,
    for a general introduction to how to deal with errors in Node.js. Here, we will
    deal specifically with Connect and Express.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对自己应用程序中的错误做出响应是关键，因此请参阅[第2章](ch02.html "第2章.一般注意事项")，*一般注意事项*，了解如何处理Node.js中的错误的一般介绍。在这里，我们将专门处理Connect和Express。
- en: 'First, do not throw errors directly in your route handlers. While Express is
    smart enough to try/catch errors directly on the route handler, this will not
    help you if you are performing some sort of asynchronous operation (this is the
    case most of the time), as shown in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在路由处理程序中不要直接抛出错误。虽然Express足够聪明，可以直接在路由处理程序上尝试/捕获错误，但如果您正在执行某种异步操作（这在大多数情况下都是如此），则这对您没有帮助，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both of the preceding handlers throw exceptions. As mentioned before, Express
    will execute your handler in a `try/catch` to handle exceptions thrown in the
    handler itself. However, asynchronous code, such as the second route does not
    work with typical try/catch and end up becoming uncaught exceptions. In short,
    don't use `throw` while handling errors!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前面两个处理程序都会抛出异常。如前所述，Express将在`try/catch`中执行处理程序，以处理处理程序本身中抛出的异常。但是，异步代码（例如第二个路由）无法使用典型的try/catch，最终会变成未捕获的异常。简而言之，在处理错误时不要使用`throw`！
- en: 'In addition to the request and response objects passed to your handlers, there
    is a third argument you can utilize like any other middleware. This is commonly
    named the "next" callback, and you use it like you would in middleware, to pass
    along to the next item in the continuation. This is illustrated in the following
    code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传递给处理程序的请求和响应对象之外，还有第三个参数可以像其他中间件一样使用。这通常被称为“next”回调，并且您可以像在中间件中一样使用它，传递给连续中的下一个项目。如下面的代码所示：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you execute the next callback with an `Error` object as the first argument,
    then Connect will take that error and delegate to any error-handling middleware
    that you have configured. When you set up a middleware that takes four arguments,
    it is always treated as error-handling middleware.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`Error`对象作为第一个参数执行下一个回调，那么Connect将接管该错误并委托给您配置的任何错误处理中间件。当您设置一个接受四个参数的中间件时，它总是被视为错误处理中间件。
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This special error-handling middleware goes last in your application stack,
    and you are able to set up more than one if that is necessary. You can pass along
    control via next like any other middleware, in case you set up multiple layers
    of error-handling, for example, one layer can send an e-mail, one can log to a
    file, and one (the last one) can send a response to the user.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的错误处理中间件放在应用程序堆栈的最后，如果有必要，您可以设置多个。您可以像其他中间件一样通过next传递控制，例如，设置多层错误处理，其中一层可以发送电子邮件，一层可以记录到文件，最后一层可以向用户发送响应。
- en: 'Connect also has a special middleware that you can utilize to deal with errors
    without needing to hard code your own middleware. This is the `errorHandler` middleware,
    and it will automatically respond with either plain text, JSON, or HTML (depending
    on the client''s headers) when an error occurs. This middleware is expressed as
    follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Connect还有一个特殊的中间件，您可以利用它来处理错误，而无需硬编码自己的中间件。这是`errorHandler`中间件，当发生错误时，它将自动响应纯文本、JSON或HTML（取决于客户端的标头）。这个中间件表达如下：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Typically, this helper is just for development use, as your production application
    likely has more work to do when dealing with errors you need to be in complete
    control of.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个辅助程序只用于开发，因为您的生产应用程序可能在处理错误时需要更多的工作，您需要完全控制。
- en: In summary, always use the "next" callback function in your route handlers to
    communicate errors, never use throw. In addition, always configure some sort of
    error-handling middleware by adding a middleware function with four arguments.
    Use the built-in handler from Connect for development, and have your own place
    for production.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，始终在路由处理程序中使用“next”回调函数来传达错误，永远不要使用throw。此外，始终通过添加一个带有四个参数的中间件函数来配置某种错误处理中间件。在开发中使用Connect的内置处理程序，并为生产环境设置自己的位置。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined high-level security considerations that apply to
    applications in general, such as authentication, authorization, and error-handling.
    In the next chapter, we will examine vulnerabilities that appear during the request
    phase of your applications.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了适用于应用程序的高级安全性考虑因素，如身份验证、授权和错误处理。在下一章中，我们将研究应用程序请求阶段出现的漏洞。
