- en: Accessing the Blockchain through an API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过API访问区块链
- en: Building a BlockchainIn the previous chapter, we built the beginnings of our
    blockchain data structure. In this chapter, we're going to be building an API
    that will allow us to interact with our blockchain. To build the API, we will
    be creating a server using the Express.js library, and then we will be building
    three different endpoints that will allow us to interact with our blockchain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建区块链在上一章中，我们构建了我们的区块链数据结构的开端。在本章中，我们将构建一个API，允许我们与我们的区块链进行交互。为了构建API，我们将使用Express.js库创建一个服务器，然后我们将构建三个不同的端点，这些端点将允许我们与我们的区块链进行交互。
- en: 'Let''s get started and build our API from scratch. In this chapter, we are
    going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始从头构建我们的API。在本章中，我们将涵盖以下主题：
- en: Setting up Express.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Express.js
- en: Building the API foundation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建API基础
- en: Installing Postman and body-parser
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Postman和body-parser
- en: Building the `/blockchain` endpoint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`/blockchain`端点
- en: Building the `/transaction` endpoint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`/transaction`端点
- en: Building the `/mine` endpoint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`/mine`端点
- en: Testing the endpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试端点
- en: Setting up Express.js
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Express.js
- en: 'Let''s start building our API or our server to interact with our blockchain
    data structure. We will be building our API in a new file that we will put into
    our `dev` folder. Let''s create a new file and call it `api.js`; this is where
    we will build our entire API:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的API或我们的服务器来与我们的区块链数据结构进行交互。我们将在一个新文件中构建我们的API，并将其放入我们的`dev`文件夹中。让我们创建一个新文件并将其命名为`api.js`；这就是我们将构建整个API的地方：
- en: '![](img/418a386b-6fe0-4556-bf50-a72ef42cfb8b.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/418a386b-6fe0-4556-bf50-a72ef42cfb8b.png)'
- en: Installing Express.js
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Express.js
- en: 'Now, we are going to use a library called `Express.js` to build a server or
    an API. Let''s follow the below mentioned steps to install it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用一个名为`Express.js`的库来构建一个服务器或API。让我们按照下面提到的步骤来安装它：
- en: 'So, head over to Google, search for `Express.js npm`, and click on the first
    link ( [https://www.npmjs.com/package/express](https://www.npmjs.com/package/express)
    ). This should take you to the following page:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，前往Google，搜索`Express.js npm`，并点击第一个链接（[https://www.npmjs.com/package/express](https://www.npmjs.com/package/express)）。这将带您到以下页面：
- en: '![](img/97d810b1-7148-424e-9170-78940bc18516.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97d810b1-7148-424e-9170-78940bc18516.png)'
- en: 'We have to install it as a dependency, so we must run the following command
    in our terminal:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将其安装为依赖项，因此我们必须在终端中运行以下命令：
- en: '![](img/39ae1b21-f1b8-4402-8234-f7034c436bda.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39ae1b21-f1b8-4402-8234-f7034c436bda.png)'
- en: Now we have the Express library as a dependency in our project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在项目中有Express库作为依赖项。
- en: Using Express.js
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express.js
- en: 'Using Express is pretty straightforward: lets see how to use it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Express非常简单：让我们看看如何使用它：
- en: 'Simply copy the example code that is present in the documentation and paste
    it into our `api.js` file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需复制文档中的示例代码，并将其粘贴到我们的`api.js`文件中：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, at the top of our file, we are requiring `express`, the library
    that we just downloaded, and then we are creating an `app`. This `app` will help
    us handle different endpoints or different routes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在我们的文件顶部，我们正在要求`express`，这是我们刚刚下载的库，然后我们正在创建一个`app`。这个`app`将帮助我们处理不同的端点或不同的路由。
- en: For example, we have a `get` endpoint, which is just `/`. With this endpoint,
    we are sending back the response of `Hello World`. This whole server is listening
    on port `3000`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个`get`端点，它只是`/`。通过这个端点，我们发送`Hello World`的响应。整个服务器都在端口`3000`上监听。
- en: 'To start this server, we go over to our terminal and run the following command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动此服务器，我们转到终端并运行以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now our server should be running. We can test this by hitting the `get` endpoint
    route in our browser, and this route will simply be a localhost on port `3000`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的服务器应该正在运行。我们可以通过在浏览器中点击`get`端点路由来测试这一点，这个路由将简单地是一个端口为`3000`的本地主机。
- en: 'Open a new tab in your browser and enter `localhost:3000`. Here you will see
    the text Hello World:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开一个新标签，并输入`localhost:3000`。在这里你会看到文本Hello World：
- en: '![](img/89f476ff-ec18-4e5e-9c86-008e8d49e4bc.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89f476ff-ec18-4e5e-9c86-008e8d49e4bc.png)'
- en: 'This is the response that was sent to us from the endpoint. We can change the
    text to whatever we want, so let''s change `Hello World` to `Hello Coding JavaScript!`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是从端点发送给我们的响应。我们可以将文本更改为任何我们想要的，所以让我们将`Hello World`更改为`Hello Coding JavaScript!`：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now save that and restart the server by running the following command again
    in the terminal:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存并重新启动服务器，通过在终端中再次运行以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Refresh the browser tab and you will see the following output:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新浏览器标签，您将看到以下输出：
- en: '![](img/ceb988cd-1f4c-4a15-946b-f3369d81f104.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ceb988cd-1f4c-4a15-946b-f3369d81f104.png)'
- en: There you go! Using Express is pretty straightforward and pretty easy. We're
    going to build all of our endpoints using the Express.js library.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！使用Express非常简单和容易。我们将使用Express.js库构建所有端点。
- en: Building the API foundation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建API基础
- en: 'We are going to continue building our blockchain API in this section, and then
    we''re going to build the following three endpoints in our API to start with:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续构建我们的区块链API，然后我们将首先构建以下三个端点：
- en: The first endpoint is `/blockchain`, which allows us to fetch our entire blockchain
    so that we can look at the data that's inside of it.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个端点是`/blockchain`，它允许我们获取整个区块链，以便我们可以查看其中的数据。
- en: The second endpoint is `/transaction`, which allows us to create a new transaction.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个端点是`/transaction`，它允许我们创建一个新的交易。
- en: The third endpoint is `/mine`, which will allow us to mine a new block by using
    the `proofOfWork` method that we made in the last chapter. This is going to be
    a pretty powerful endpoint, and it will be fun to build.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个端点是`/mine`，它将允许我们使用我们在上一章中制作的`proofOfWork`方法来挖掘一个新的区块。这将是一个非常强大的端点，也将很有趣。
- en: 'This is basically going to be the foundation of our blockchain API. In the
    `dev/networkNode.js` file, let''s define these endpoints as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上将成为我们的区块链API的基础。在`dev/networkNode.js`文件中，让我们定义这些端点如下：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, one more thing that we want to do is make some modifications to the `listen`
    method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还要做的一件事是对`listen`方法进行一些修改：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have added another parameter to this method, which is a function. Inside
    of this function, we are simply going to print out the `Listening on port 3000` string. The
    reason that we do this is just so that when our port is actually running, we will
    see this text. Let''s go to our terminal and run our `api.js` file again:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向这个方法添加了另一个参数，即一个函数。在这个函数内部，我们只是打印出`Listening on port 3000`字符串。我们这样做的原因只是为了当我们的端口实际运行时，我们会看到这个文本。让我们去我们的终端，再次运行我们的`api.js`文件：
- en: '![](img/792cf9c8-0202-4775-b407-ffdd1cfbc256.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/792cf9c8-0202-4775-b407-ffdd1cfbc256.png)'
- en: As you can see, the preceding screenshot shows us that we are listening to port
    `3000`. Whenever we see this text, we know that our servers are running.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，上面的截图显示我们正在监听端口`3000`。每当我们看到这个文本时，我们知道我们的服务器正在运行。
- en: Installing Postman and body-parser
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Postman和body-parser
- en: 'In this section, we''re going to work on our environment to make our development
    process a little bit easier. The first thing that we''re going to do is install
    a new package called `nodemon`. In our `blockchain` directory in our terminal,
    we will write the `npm i nodemon --save` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将在我们的环境中工作，使我们的开发过程变得更容易一些。我们要做的第一件事是安装一个叫做`nodemon`的新包。在我们的终端中的`blockchain`目录中，我们将写入`npm
    i nodemon --save`命令：
- en: '![](img/5968fff1-e3a4-4233-8d87-eede8d1cce1f.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5968fff1-e3a4-4233-8d87-eede8d1cce1f.png)'
- en: Whenever we make a change in one of our files and save it, this nodemon library
    will automatically restart our server for us so that we don't have to go back
    and forth from the terminal to our code to restart the server every time we make
    a change.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们对文件进行更改并保存时，这个nodemon库会自动为我们重新启动服务器，这样我们就不必每次更改都要回到终端和代码之间来重新启动服务器。
- en: 'To use nodemon, we are going to open up our `package.json` file. Where it says
    `"scripts"`, we''re going to add a new script:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用nodemon，我们将打开我们的`package.json`文件。在`"scripts"`处，我们将添加一个新的脚本：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have added `"start": "nodemon --watch dev -e js dev/api.js"`. This means
    that when we run the `start` command, we want `nodemon` to watch our `dev` folder
    and keep an eye on all of our JavaScript files. Whenever one of these JS files
    is changed and saved, we want nodemon to restart our `dev/api.js` file for us. Save
    the `package.json` file. Now, whenever we make a change inside of our `dev` folder
    and save it, our server will restart itself. Let''s test this out.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经添加了`"start": "nodemon --watch dev -e js dev/api.js"`。这意味着当我们运行`start`命令时，我们希望`nodemon`监视我们的`dev`文件夹，并关注我们所有的JavaScript文件。每当这些JS文件中的一个被更改并保存时，我们希望nodemon为我们重新启动`dev/api.js`文件。保存`package.json`文件。现在，每当我们在`dev`文件夹中进行更改并保存时，我们的服务器将自动重启。让我们测试一下。'
- en: 'Let''s go to our terminal. Our server should now be using nodemon:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去我们的终端。我们的服务器现在应该正在使用nodemon：
- en: '![](img/47f2c8f5-a9d7-4772-baac-29a9606a9def.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47f2c8f5-a9d7-4772-baac-29a9606a9def.png)'
- en: 'We have started the server by using the `npm start` command. You can see that
    this is listening on port `3000`.  Whenever we make a change in one of our JS
    files and save it, we will see that our server restarts itself:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`npm start`命令启动了服务器。您可以看到它正在监听端口`3000`。每当我们更改我们的JS文件并保存时，我们会看到我们的服务器会自动重启：
- en: '![](img/455346c7-ff50-4824-8520-574eb858ce55.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/455346c7-ff50-4824-8520-574eb858ce55.png)'
- en: As you can see, the server is listening to port `3000` again. This is just a
    tool that we use to make development slightly easier for us. Now, one other tool
    that we want to use is called Postman.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，服务器再次监听端口`3000`。这只是一个工具，我们用它来让开发对我们来说稍微容易一些。现在，我们想要使用的另一个工具叫做Postman。
- en: Installing Postman
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Postman
- en: 'The Postman tool allows us to make calls to any of our post endpoints, as well
    as send data into these endpoints with our requests. Let''s understand how to
    install it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Postman工具允许我们调用任何我们的post端点，并通过我们的请求将数据发送到这些端点。让我们了解如何安装它：
- en: Head over to [https://www.getpostman.com](https://www.getpostman.com) and download
    the app. Once you have downloaded the app, we can run through a little test trial
    of how we can use this Postman app to hit our `/transaction` endpoint.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://www.getpostman.com](https://www.getpostman.com)并下载该应用程序。下载应用程序后，我们可以运行一些小测试，看看如何使用这个Postman应用程序来访问我们的`/transaction`端点。
- en: 'Open the Postman app after downloading it. You will see something similar to
    the following screenshot:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Postman应用程序后打开它。您将看到类似以下截图的内容：
- en: '![](img/72ba3dea-426e-4216-a1c6-ecc5a4cd4e87.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72ba3dea-426e-4216-a1c6-ecc5a4cd4e87.png)'
- en: 'Now, in the Postman app we''re going to make a post request to `http://localhost:3000/transaction`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在Postman应用程序中，我们将向`http://localhost:3000/transaction`发出post请求：
- en: '![](img/3b86b437-349e-427a-999c-d5aff285f942.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b86b437-349e-427a-999c-d5aff285f942.png)'
- en: 'To test that the `/transaction` endpoint is working, let''s send something
    back in the output. In our `/transaction` endpoint, we have added the following
    line:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试`/transaction`端点是否工作，让我们在输出中发送一些东西。在我们的`/transaction`端点中，我们添加了以下行：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s save the file, and now when we hit this endpoint, we should get the
    text `It works!!!` returned to us. Click on the Send button, and you will get
    the output, as shown in the following screenshot:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，现在当我们访问这个端点时，我们应该得到文本`It works!!!`的返回。点击发送按钮，您将得到输出，如下面的截图所示：
- en: '![](img/109ae641-2a75-41fe-ad41-09b65930b7ba.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/109ae641-2a75-41fe-ad41-09b65930b7ba.png)'
- en: 'Now, most of the time we hit a `post` endpoint in our API, we are going to
    want to send data to it. For example, when we hit the `/transaction` endpoint,
    we want to create a new transaction. Consequently, we have to send the transaction
    data, such as the amount for the transaction, the sender, and the recipient to
    the `/transaction` endpoint. We can do this by using Postman, and it''s actually
    pretty straightforward. What we''re going to do here is send some information
    in the body of our post request. You can do that by clicking on the Body tab:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，大多数情况下，当我们在API中访问`post`端点时，我们都希望向其发送数据。例如，当我们访问`/transaction`端点时，我们希望创建一个新的交易。因此，我们必须向`/transaction`端点发送交易数据，比如交易金额、发送者和接收者。我们可以使用Postman来做到这一点，而且实际上非常简单。我们要做的是在我们的post请求的正文中发送一些信息。你可以通过点击Body选项卡来实现：
- en: '![](img/44f794e7-5400-448d-be08-beacc53be751.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44f794e7-5400-448d-be08-beacc53be751.png)'
- en: Next, make sure that the raw option is checked and JSON (application/json) is
    selected from the dropdown list. You can also see that we have made a JSON object
    and put some data in it. We have added the `amount` as `20` bitcoins, the address
    of `sender`, and the address of `recipient`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保选中了原始选项，并从下拉列表中选择了JSON（application/json）。你还可以看到我们已经创建了一个JSON对象，并放入了一些数据。我们已经将`amount`设置为`20`比特币，发送者的地址和接收者的地址。
- en: Remember that everything has to be in JSON format, so we need all of our quotations to
    be in double quotes or the terms won't work.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有内容都必须以JSON格式呈现，因此我们需要将所有引号都用双引号括起来，否则术语将无法工作。
- en: 'To test whether or not we are receiving all of this information inside of our
    endpoint, we are going to print out the entire `req.body`. The `req.body` is simply
    the information that we created in the JSON object:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们是否在端点内收到了所有这些信息，我们将打印整个`req.body`。`req.body`就是我们在JSON对象中创建的信息：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we have also sent some different information back in the response. We
    have added a sentence in back ticks, and we also did some string interpolation
    with `${req.body.amount}`, which will return just the `amount`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们还在响应中发送了一些不同的信息。我们在反引号中添加了一个句子，并且还使用了`${req.body.amount}`进行了一些字符串插值，这将返回`amount`。
- en: 'Now, for `${req.body.amount}` to work, we need to install another library in
    order to access this information. Let''s go back in our terminal; we''re going
    to quit the current process where we were listening to port `3000` and we''re
    going to install a package called `body-parser`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了使`${req.body.amount}`起作用，我们需要安装另一个库以访问这些信息。让我们回到终端；我们将退出当前监听端口`3000`的进程，并安装一个名为`body-parser`的包：
- en: '![](img/d3b60653-9e7c-4a06-8bf1-77a733fb2257.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3b60653-9e7c-4a06-8bf1-77a733fb2257.png)'
- en: Now let's start our server up again with `npm start`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们再次用`npm start`启动我们的服务器。
- en: 'When it comes to using `body-parser`, we simply want to import this at the
    top of our file after the line where we imported `app`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`body-parser`时，我们只需在文件顶部导入它：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To use this `body-parser` library, we have added the next two lines. All these
    two lines is doing are stating that if a request comes in with JSON data or with
    form data, we simply want to parse that data so that we can access it in any of
    the endpoints. So, with any endpoint we hit, our data is first going to go through
    the `body-parser` so that we can access the data and is then used in whichever
    endpoint will be receiving it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`body-parser`库，我们添加了下面两行。这两行代码的作用是说明如果请求中带有JSON数据或表单数据，我们只需解析这些数据，以便在任何端点中访问。因此，无论我们访问哪个端点，我们的数据都会首先经过`body-parser`，以便我们可以访问数据，然后在接收数据的端点中使用。
- en: 'Now that we''re using `body-parser`, we should be able to access the amount.
    Let''s save the `api.js` file and try to send the request, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用了`body-parser`，我们应该能够访问这个金额。让我们保存`api.js`文件，并尝试发送请求，如下所示：
- en: '![](img/8b3cd1e5-b80a-4193-927a-012d555ffdf1.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b3cd1e5-b80a-4193-927a-012d555ffdf1.png)'
- en: It worked! We got the string returned, which states that The amount of the transaction
    is 20 bitcoin.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们得到了返回的字符串，其中说明交易金额为20比特币。
- en: 'In our terminal, since we logged out of the entire `req.body`, we can see that
    the entire information regarding the amount, sender, and recipient is displayed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的终端中，由于我们记录了整个`req.body`，我们可以看到关于金额、发送者和接收者的所有信息都被显示出来：
- en: '![](img/b895ca0d-903f-4b37-8730-b6fd14848d98.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b895ca0d-903f-4b37-8730-b6fd14848d98.png)'
- en: Great! Now, one more important thing to note is that throughout the rest of
    this chapter, you should always have your server running, which means you should
    always run the `npm start` command so that we can use our API, hit the different
    endpoints, and test it to see if it works.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，还有一件重要的事情要注意，那就是在本章的其余部分，你应该始终保持服务器运行，这意味着你应该始终运行`npm start`命令，这样我们才能使用我们的API，访问不同的端点，并测试它是否有效。
- en: Building the /blockchain endpoint
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/blockchain端点
- en: 'Let''s continue building our blockchain API. In this section, we are going
    to interact with our `/blockchain` endpoint. This means that we will have to import
    our blockchain from our `blockchain.js` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建我们的区块链API。在这一部分，我们将与我们的`/blockchain`端点进行交互。这意味着我们将不得不从我们的`blockchain.js`文件中导入我们的区块链：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have now imported our blockchain data structure or our blockchain constructor
    function. Next, we want to make an instance of our blockchain. We can do that
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经导入了我们的区块链数据结构或区块链构造函数。接下来，我们要创建一个区块链的实例。我们可以这样做：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we have an instance of our blockchain constructor function and we have called
    it `bitcoin`. You can call this whatever you want, but I'm just going to call
    it `bitcoin` to keep it simple.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的区块链构造函数的一个实例，并且我们将其称为`bitcoin`。你可以自己决定叫什么，但我会简单地称其为`bitcoin`。
- en: 'Let''s build on our `/blockchain` endpoint. All this endpoint is going to do is
    send our entire blockchain back to whoever called this endpoint. To do that, we
    are going to add a line that will send the response:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`/blockchain`端点上继续构建。这个端点将会将整个区块链发送回给调用它的人。为了做到这一点，我们将添加一行代码来发送响应：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Believe it or not, that's all we're going to do for this endpoint.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这就是我们为这个端点要做的全部。
- en: Testing the /blockchain endpoint
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试/blockchain端点
- en: 'Now we can test whether or not this endpoint works by using it in our browser:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过在浏览器中使用它来测试这个端点是否工作：
- en: 'Let''s go to our browser and hit `localhost:3000/blockchain`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到我们的浏览器并访问`localhost:3000/blockchain`：
- en: '![](img/503448a4-018c-4402-acd9-ffb44f94f206.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/503448a4-018c-4402-acd9-ffb44f94f206.png)'
- en: 'As you can see, we get our entire blockchain back. Now, you might have noticed
    that this is a little bit difficult to read, so to make it readable, let''s download
    a Chrome extension called **JSON formatter**. You can Google this and add the
    extension to your Chrome browser. Once installed, refresh the page again and you
    will get the following output:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们得到了整个区块链。现在，你可能已经注意到这有点难以阅读，所以为了使其可读，让我们下载一个名为**JSON格式化程序**的Chrome扩展。你可以在谷歌上搜索并将该扩展添加到你的Chrome浏览器中。安装完成后，再次刷新页面，你将得到以下输出：
- en: '![](img/2d76eacc-200d-4d26-a56e-6ff6b5e62555.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d76eacc-200d-4d26-a56e-6ff6b5e62555.png)'
- en: As you can see, we get our data back in a much more readable format, which is
    in JSON format. You can see that we have `chain`, which has one item in it – our
    genesis block – and we also have the `pendingTransaction` block. This is pretty
    cool, and we can tell that our `/blockchain` endpoint is working because we get
    our entire blockchain back.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们以更易读的JSON格式得到了我们的数据。你可以看到我们有`chain`，其中有一项 - 我们的创世区块 - 以及`pendingTransaction`区块。这很酷，我们可以知道我们的`/blockchain`端点正在工作，因为我们得到了整个区块链。
- en: Building the /transaction endpoint
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/transaction端点
- en: 'In this section, we are going to build our transaction endpoint. Let''s follow
    the below mentioned steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将构建我们的交易端点。让我们按照下面提到的步骤进行：
- en: Before we start, please make sure that whenever you are working on our blockchain
    you have your server running. We can do that by running the `npm start` command
    in our terminal.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，请确保在处理我们的区块链时，你的服务器正在运行。我们可以通过在终端中运行`npm start`命令来做到这一点。
- en: Let's head over to our `api.js` file and build our transaction endpoint. First
    of all, take out the example code that we added earlier in the `/transaction`
    endpoint and create a new transaction in our blockchain. To do that, we are going
    to use our `createNewTransaction` method in the `blockchain.js` file that we built
    in [Chapter 2](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml), *Building a Blockchain*.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到我们的`api.js`文件并构建我们的交易端点。首先，去掉我们之前在`/transaction`端点中添加的示例代码，并在我们的区块链中创建一个新的交易。为此，我们将使用我们在[第2章](430b96b1-9a43-402e-9e3a-07bc2b4f514d.xhtml)中构建的`blockchain.js`文件中的`createNewTransaction`方法，*构建区块链*。
- en: 'As you know, our `createNewTransaction` method takes in three parameters: `amount`,
    `sender`, and `recipient`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所知，我们的`createNewTransaction`方法接受三个参数：`amount`，`sender`和`recipient`：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method returns the block number or the index that our new transaction
    will be added to. This is all that we need in order to create a transaction, so
    in our `/transaction` endpoint, we are going to add the following line:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法返回我们新交易将被添加到的区块编号或索引。这就是我们创建交易所需的一切，所以在我们的`/transaction`端点中，我们将添加以下行：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our endpoint, we''re going to assume that all of this data is being sent
    in with the `req.body` from whoever is calling this endpoint. The result will
    be saved in `blockIndex`, and that is what we are going to send back to whoever
    calls this endpoint. We will be sending it back as a `note`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的端点中，我们假设所有这些数据都是通过`req.body`从调用这个端点的人那里发送过来的。结果将保存在`blockIndex`中，这就是我们将发送回给调用这个端点的人的内容。我们将把它作为一个`note`发送回去：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the note will tell us which block the transaction will be added
    to. We have used string interpolation to pass the `blockIndex` value. Let's save
    this file and test this endpoint using Postman.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个注释将告诉我们交易将被添加到哪个区块。我们使用了字符串插值来传递`blockIndex`的值。让我们保存这个文件并使用Postman测试这个端点。
- en: Testing the /transaction endpoint
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试/transaction端点
- en: 'Now let''s head over to Postman and apply settings similar to the ones that
    we set earlier:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到Postman并应用与我们之前设置的类似的设置：
- en: '![](img/2e18b623-0efa-4793-8b9d-4588c791ea3c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e18b623-0efa-4793-8b9d-4588c791ea3c.png)'
- en: We have selected the POST request, and we are targeting the `/transaction` endpoint.
    In the Body tab, we have checked raw, and the text has been selected to JSON format.
    We have passed in the values for `amount`, `sender`, and `recipient` in the JSON
    object, which will be our `req.body`, and on this object we will send all of our
    transaction data. With the help of `req.body`, which was mentioned in our `/transaction`
    endpoint, we can access the amount, the address of the sender, and the recipient.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经选择了POST请求，并且我们的目标是`/transaction`端点。在Body选项卡中，我们已经勾选了raw，并且文本已经选择为JSON格式。我们在JSON对象中传入了`amount`，`sender`和`recipient`的值，这将成为我们的`req.body`，并且我们将发送所有的交易数据到这个对象上。借助于我们在`/transaction`端点中提到的`req.body`，我们可以访问金额、发送者的地址和接收者。
- en: 'Now let''s test this endpoint:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试这个端点：
- en: '![](img/a32bfbbb-8d3d-4490-967c-392cf1ea74d4.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a32bfbbb-8d3d-4490-967c-392cf1ea74d4.png)'
- en: As you can see, when we clicked on the Send button on Postman, we got the output
    as Transaction will be added in block 2\. The reason we got block 2 here is that
    one block had already been created when we initiated our blockchain, which created
    the genesis block. Consequently, this transaction got added to block 2.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当我们在Postman上点击发送按钮时，我们得到了交易将被添加到第2个区块的输出。我们之所以在这里得到第2个区块，是因为在我们初始化区块链时已经创建了一个区块，这就创建了创世区块。因此，这个交易被添加到了第2个区块。
- en: 'One other way that we can test to make sure that this endpoint worked correctly
    is by hitting our `/blockchain` endpoint. When we hit this endpoint, we should
    expect to get our entire blockchain returned to us. In that blockchain, there
    should be a single block – our genesis block – and there should be one pending transaction,
    which is the transaction that we just created. Let''s head over to the browser
    and go to `localhost:3000/blockchain`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试确保这个端点工作正确的另一种方法是访问我们的`/blockchain`端点。当我们访问这个端点时，我们应该期望得到我们整个的区块链。在那个区块链中，应该有一个单独的区块
    - 我们的创世区块 - 还应该有一个待处理的交易，这就是我们刚刚创建的交易。让我们转到浏览器，访问`localhost:3000/blockchain`：
- en: '![](img/c049edde-9d4e-414e-a974-17a774777378.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c049edde-9d4e-414e-a974-17a774777378.png)'
- en: As you can see, the entire object is our whole blockchain – the first part is
    our chain that has the genesis block, and the second part is our pending transaction,
    which we just created. Our `/transaction` endpoint works perfectly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，整个对象就是我们整个的区块链 - 第一部分是我们的链，其中包含创世区块，第二部分是我们的待处理交易，我们刚刚创建。我们的`/transaction`端点完美地工作。
- en: Building the /mine endpoint
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/mine端点
- en: 'Let''s build the final endpoint for our blockchain API: the mine endpoint,
    this will mine and create a new block:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的区块链API的最终端点：挖矿端点，这将挖矿并创建一个新的区块：
- en: 'To create a new block, we are going to use our `createNewBlock` method, which
    we already defined in our `blockchain.js` file. Let''s go to our `api.js` file
    and create a new block inside the `/mine` endpoint:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个新的区块，我们将使用我们在`blockchain.js`文件中已经定义的`createNewBlock`方法。让我们转到我们的`api.js`文件，并在`/mine`端点中创建一个新的区块：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This `createNewBlock` method takes in three parameters: `nonce`, `previousBlockHash`,
    and `hash`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`createNewBlock`方法接受三个参数：`nonce`，`previousBlockHash`和`hash`：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we have to do calculations to get all these three pieces of data, so let''s
    do that. Let''s start by getting the previous block so that we can get its hash:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须进行计算，以获得所有这三个数据，所以让我们开始。让我们从获取上一个区块开始，以便我们可以获取它的hash：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we have created `lastBlock`, which is the last block in our
    chain – or the previous block to our new block. To get the last block's `hash`,
    we have created `previousBlockHash`. With that, we can now have our `previousBlockHash`,
    which is one of the parameters that we need for our `createNewBlock` method next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经创建了`lastBlock`，它是我们链中的最后一个区块 - 或者是我们新区块的上一个区块。为了获取上一个区块的`hash`，我们创建了`previousBlockHash`。有了这个，我们现在可以有我们的`previousBlockHash`，这是我们`createNewBlock`方法下一个需要的参数之一。
- en: 'Next, let''s get our `nonce`. To produce a `nonce` for our block, we need to
    generate a `proofOfWork`, which we created in the `blockchain.js` file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们获取我们的`nonce`。为了为我们的区块生成一个`nonce`，我们需要生成一个`proofOfWork`，这是我们在`blockchain.js`文件中创建的：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our `/mine` endpoint, we will add the following line:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`/mine`端点，我们将添加以下行：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, from our `proofOfWork` method we will get a `nonce` returned to us. let''s save
    that as our `nonce` variable. Our `proofOfWork` method takes in two parameters:
    `previousBlockHash`, which we already have, and `currentBlockData`. Let''s define
    our `currentBlockData`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，从我们的`proofOfWork`方法中，我们将得到一个`nonce`返回给我们。让我们将其保存为我们的`nonce`变量。我们的`proofOfWork`方法接受两个参数：`previousBlockHash`，我们已经有了，和`currentBlockData`。让我们定义我们的`currentBlockData`：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have our `currentBlockData` as an object, and this consists of the data.
    This data will simply consist of the `transactions` in this block, and also an
    `index`, which is the index of the new block that we are going to create; the
    index of our `lastBlock` plus 1. The `currentBlockData` object is simply going
    to be the `transactions` that are present in this new block and its `index`. With
    this, we can now calculate our `nonce`, as we have with our `previousBlockHash`
    and `currentBlockData`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的`currentBlockData`作为一个对象，其中包含数据。这些数据将简单地包括这个区块中的`transactions`，还有一个`index`，这是我们将要创建的新区块的索引；我们的`lastBlock`的索引加1。`currentBlockData`对象将简单地是这个新区块中存在的`transactions`和它的`index`。有了这个，我们现在可以计算我们的`nonce`，就像我们用我们的`previousBlockHash`和`currentBlockData`一样。
- en: 'Now, the final parameter that our `createNewBlock` method has to take in is
    a `hash` of this new block, so let''s calculate that now. To create a hash of
    this new block, we are going to use our `hashBlock` method. We are going to add
    the following line in our `/mine` endpoint:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的`createNewBlock`方法必须接受的最后一个参数是这个新区块的`hash`，所以让我们现在计算一下。为了创建这个新区块的`hash`，我们将使用我们的`hashBlock`方法。我们将在我们的`/mine`端点中添加以下行：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you know, we have already created the `hashBlock` method in the `blockchain.js`
    file. This method accepts three parameters: `previousBlockHash`, `currentBlockData`,
    and `nonce`. We already have all of these parameters, so we are calling it and
    saving the results in a variable called `blockHash`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，我们已经在`blockchain.js`文件中创建了`hashBlock`方法。这个方法接受三个参数：`previousBlockHash`，`currentBlockData`和`nonce`。我们已经有了所有这些参数，所以我们正在调用它，并将结果保存在一个名为`blockHash`的变量中。
- en: 'We now have all of the parameters that we need to run our `createNewBlock`
    method, so let''s assign those:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有了我们运行`createNewBlock`方法所需的所有参数，所以让我们分配这些参数：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What's happening here is pretty awesome. As you can see, there are a lot of
    different calculations that go into creating this new block, and we are able to
    make all of these calculations by using our blockchain data structure. This is
    a pretty powerful data structure, and our blockchain can now mine new blocks by
    using `proofOfWork`, which is similar to how many other blockchains function as
    well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情非常棒。正如你所看到的，有很多不同的计算涉及到创建这个新区块，我们能够通过使用我们的区块链数据结构来进行所有这些计算。这是一个非常强大的数据结构，我们的区块链现在可以通过使用`proofOfWork`来挖掘新的区块，这与许多其他区块链的功能类似。
- en: 'At this point, we have created our new block, and all we really have left to
    do is send the response back to whoever mined this block. Next, we will be adding
    the following line in our `/mine` endpoint:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经创建了我们的新区块，我们真正需要做的就是将响应发送给挖掘这个区块的人。接下来，我们将在我们的`/mine`端点中添加以下行：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are simply sending back a note that says New block mined successfully, as
    well as stating the `newBlock` that we just created. Now, sending back this `newBlock`
    is not going to affect our blockchain in any way. We are sending back the `newBlock` so
    that the person who created or mined this new block knows what it looks like.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是简单地发送一个说明新块挖掘成功的消息，以及我们刚刚创建的`newBlock`。现在，发送这个`newBlock`不会以任何方式影响我们的区块链。我们发送`newBlock`是为了让创建或挖掘这个新块的人知道它的样子。
- en: 'Now there is one thing left that we have to do: Every time someone mines a
    new block, they get a reward for creating that new block. All we have to do is
    make a transaction and send the person who mined this new block a little bit of
    bitcoin as their reward. To do that, inside the `/mine` endpoint, we are going
    to create a new transaction:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只剩下一件事情要做：每当有人挖掘一个新块，他们都会得到一个奖励。我们所要做的就是创建一个交易，给挖掘这个新块的人发送一点比特币作为奖励。为此，在`/mine`端点内部，我们将创建一个新的交易：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Currently, in 2018, there is a 12.5 bitcoin reward for mining a new block in
    the real bitcoin blockchain. Just to stay consistent with the real bitcoin, we're
    going to make our reward `12.5` bitcoin too. As a sender address, we have put
    the value `00`,. This way, whenever we are looking at transactions on our network,
    we know that if a transaction is made from the address `00`, it is a mining reward.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在2018年，真正的比特币区块链中挖掘新块的奖励是12.5比特币。为了保持与真正的比特币一致，我们的奖励也将是`12.5`比特币。作为发送者地址，我们已经放入了值`00`。这样，每当我们在我们的网络上查看交易时，我们知道如果有一个交易是从地址`00`发出的，那就是一个挖矿奖励。
- en: Now all we need is a recipient's address, `nodeAddress`. We need to send `12.5`
    bitcoins to whoever mined a new block – but how can we find that? Well, we're
    going to be sending this reward to the current node that we are on, which is this
    whole API file that we are working on. We can treat this entire API as a network
    node in the bitcoin blockchain.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要一个接收者的地址，`nodeAddress`。我们需要把`12.5`比特币发送给挖掘新块的人，但是怎么找到呢？嗯，我们将把这个奖励发送给我们当前所在的节点，也就是我们正在使用的整个API文件。我们可以把整个API都当作比特币区块链中的一个网络节点。
- en: In future chapters, we're going to have multiple instances of our API, and they
    are going to act as different network nodes in the big clean blockchain. Right
    now, whenever we hit any of the endpoints we created, we are always only communicating
    with this one network node. However, since we know that all blockchain technology
    is decentralized and hosted across many different network nodes, we are going
    to be creating more network nodes as we proceed further. But for now, our entire
    blockchain is hosted solely on this one network node.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的章节中，我们将拥有我们API的多个实例，并且它们将作为大型干净区块链中的不同网络节点。现在，每当我们访问我们创建的任何端点时，我们总是只与这一个网络节点进行通信。然而，由于我们知道所有的区块链技术都是分散的，并且托管在许多不同的网络节点上，随着我们进一步进行，我们将创建更多的网络节点。但是现在，我们整个的区块链只托管在这一个网络节点上。
- en: Now, any time we hit the `/mine` endpoint, we want to reward this node for mining
    the new block. To give this node the `12.5` bitcoin reward that it deserves, we
    need an address to send the bitcoin to, so let's create an address for this node
    now.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们访问`/mine`端点时，我们都希望奖励这个节点挖掘新块。为了给这个节点应得的`12.5`比特币奖励，我们需要一个地址来发送比特币，所以让我们现在为这个节点创建一个地址。
- en: 'To create an address for this node, we are going to import a new library called
    `uuid` using our terminal:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为这个节点创建一个地址，我们将使用我们的终端导入一个叫做`uuid`的新库：
- en: '![](img/6288cd40-7b48-478d-9e51-c41be1352ef2.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6288cd40-7b48-478d-9e51-c41be1352ef2.png)'
- en: Once you have typed in the `npm i uuid --save` command and hit *Enter*, the
    package will be added. You can start the server again with the `npm start `command.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入了`npm i uuid --save`命令并按下*Enter*，包就会被添加。你可以使用`npm start`命令重新启动服务器。
- en: 'Now let''s import our new `uuid` library at the top section of our `api.js`
    file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`api.js`文件的顶部部分导入我们的新的`uuid`库：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, we have imported version 1 of the `uuid` library. This library creates
    a unique random string for us, and we''re going to use that string as this network
    node''s address. For that, we are going to add the following line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经导入了`uuid`库的第1个版本。这个库为我们创建了一个唯一的随机字符串，我们将使用这个字符串作为这个网络节点的地址。为此，我们将添加以下行：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One thing that we want to alter about the string that we get from this library
    is that there are a couple of dashes present – we don't want any dashes in our
    address. Here, we're simply going to split that string on all of the dashes and
    then rejoin it with an empty string that's been passed in. The `nodeAddress` that
    we are going to get is a random string that is guaranteed to be unique to a very high
    percentage. We really want this string to be unique because we don't want to have
    two nodes with the same address, otherwise we would end up sending bitcoin to
    the wrong people and that wouldn't be good. Now we can simply pass this `nodeAddress`
    variable into our `createNewTransaction` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们从这个库得到的字符串，我们想要改变的一件事是，它里面有一些破折号——我们不希望地址里有任何破折号。在这里，我们只是简单地将该字符串在所有的破折号上分割，然后用一个空字符串重新连接。我们将得到的`nodeAddress`是一个随机字符串，保证是独一无二的。我们真的希望这个字符串是独一无二的，因为我们不希望有两个节点有相同的地址，否则我们会把比特币发送给错误的人，那就不好了。现在我们只需将这个`nodeAddress`变量传递给我们的`createNewTransaction`方法。
- en: In the next section, we will test our `/mine` endpoint, along with our `/transaction` and
    `/blockchain` endpoints, to make sure that they all work and interact correctly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将测试我们的`/mine`端点，以及我们的`/transaction`和`/blockchain`端点，以确保它们都能正确地工作和互动。
- en: Testing the endpoints
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试端点
- en: In this section, we're going to be testing our `/mine` endpoint, along with
    our `/transaction` and `/blockchain` endpoints, to make sure that everything works
    well together.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将测试我们的`/mine`端点，以及我们的`/transaction`和`/blockchain`端点，以确保一切都能很好地协同工作。
- en: Before we test, it would be a good idea to take out the `console.log` statement in
    the `proofOfWork` method. This is because having it will just make your program work
    harder, and it will therefore take more time to calculate things.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试之前，最好将`proofOfWork`方法中的`console.log`语句删除。这是因为有它只会让你的程序工作更加艰难，因此计算所需的时间会更长。
- en: /mine endpoint testing
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /mine端点测试
- en: 'First, let''s test the `/mine` endpoint that we just built in our last section.
    Let''s head over to our browser and hit `localhost:3000/blockchain`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们测试我们在上一节中构建的`/mine`端点。让我们转到浏览器，访问`localhost:3000/blockchain`：
- en: '![](img/27159860-0515-4ad1-b755-cfc39e6f70dc.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27159860-0515-4ad1-b755-cfc39e6f70dc.png)'
- en: Right now, we have our entire blockchain, in which the chain has one block in
    it – our genesis block – and we also have no pending transactions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有整个区块链，链中有一个区块 - 我们的创世区块 - 也没有待处理交易。
- en: 'Now let''s open another tab and hit our `/mine` endpoint. This should mine
    and create a new block for us:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开另一个标签页，点击我们的`/mine`端点。这应该为我们挖矿并创建一个新的区块：
- en: '![](img/8a3c1bae-7c6a-4f15-a9e9-912ee486e2b1.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a3c1bae-7c6a-4f15-a9e9-912ee486e2b1.png)'
- en: We got our note that says New block mined successfully. We also got our new
    block back, and we can see all of the data that's on our block. It has a hash
    in it, and it also has the hash of the previous block, which is the genesis block,
    and one transaction in it. You might be thinking, we didn't create a transaction,
    so where did this transaction come from? This transaction is actually the mining
    reward that we put into our endpoint, which has the `12.5` bitcoin mining reward
    transaction. It looks like our mining endpoint worked well.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了一条新的区块成功挖掘的消息。我们还收到了我们的新区块，并且我们可以看到区块上的所有数据。它里面有一个哈希，还有前一个区块的哈希，即创世区块，以及一个交易。也许你会想，我们并没有创建交易，那么这笔交易是从哪里来的呢？实际上，这笔交易是我们放入端点的挖矿奖励，即`12.5`比特币的挖矿奖励交易。看起来我们的挖矿端点运行良好。
- en: Testing the / blockchain endpoint
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试/blockchain端点
- en: 'To test and ensure that we did create this new block, we can head back over
    to our `/blockchain` endpoint and refresh the page:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试并确保我们确实创建了这个新区块，我们可以转回到我们的`/blockchain`端点并刷新页面：
- en: '![](img/b973345b-7a12-47b2-9cd6-10a03ce396ff.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b973345b-7a12-47b2-9cd6-10a03ce396ff.png)'
- en: 'It worked. We now have two blocks in our chain: one is the genesis block and
    the other is the one we just created. The second block also has the transaction
    in it, which has the reward.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了。我们现在的链中有两个区块：一个是创世区块，另一个是我们刚刚创建的区块。第二个区块中也有交易，其中包括奖励。
- en: 'Let''s mine another block to test that again. Head over to our `/mine` endpoint
    and refresh it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再挖掘一个区块来再次测试。转到我们的`/mine`端点并刷新页面：
- en: '![](img/62c65840-d91e-4324-864e-3b800ce08803.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62c65840-d91e-4324-864e-3b800ce08803.png)'
- en: 'We just mined another block, which is our third block. We can see that we get
    the `timestamp`, and another transaction, which is the mining reward, and also we
    have the rest of our data. Now let''s head back to our `/blockchain` endpoint
    and refresh it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚挖掘了另一个区块，这是我们的第三个区块。我们可以看到我们得到了`timestamp`和另一笔交易，即挖矿奖励，还有我们的其他数据。现在让我们转回到我们的`/blockchain`端点并刷新页面：
- en: '![](img/f551127f-285d-44b3-8f00-52d320304f15.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f551127f-285d-44b3-8f00-52d320304f15.png)'
- en: As you can see, we have all three blocks. Block 3 is the one that we just created,
    and it has our mining reward transaction in it. One more thing to notice is that
    our `previousBlockHash` actually aligns with our block 2's `hash`. This is helping
    to secure our blockchain, which is good.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有三个区块。区块3是我们刚刚创建的区块，里面有我们的挖矿奖励交易。还有一件事要注意的是，我们的`previousBlockHash`实际上与我们的区块2的`hash`对齐。这有助于保护我们的区块链，这很好。
- en: Testing the /transaction endpoint
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试/transaction端点
- en: 'Now let''s create some transactions with our `/transaction` endpoint. For this,
    head over to Postman, make sure that the settings are the same as before, and
    make the following changes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们的`/transaction`端点创建一些交易。为此，请转到Postman，确保设置与之前相同，并进行以下更改：
- en: '![](img/b9b13fa5-473f-4b01-a561-a5f54f307980.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9b13fa5-473f-4b01-a561-a5f54f307980.png)'
- en: We have set the `amount` to `1000` bitcoins. We'll leave the sender and the
    recipient address as they are, but you can change it to whatever you want. Once
    we post to the `/transaction` endpoint, in return we should get the text transaction
    that will be added in block 4, which we did. This transaction got added to block
    4 because we already have three blocks in our chain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`amount`设置为`1000`比特币。我们将保留发送方和接收方地址不变，但你可以根据需要进行更改。一旦我们提交到`/transaction`端点，我们应该得到文本交易的响应，该交易将被添加到第4个区块中，我们确实得到了这个响应。这笔交易被添加到第4个区块，因为我们的链中已经有了三个区块。
- en: 'Let''s make another example transaction. Here we will change the `amount` to
    `50` bitcoins, and we will make some changes to the address of the sender and
    the recipient. So when we send this request, we should get the same response: Transaction
    will be added in block 4. This occurs because we haven''t mined a new block yet. Let''s
    try this out:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行另一个示例交易。在这里，我们将`amount`更改为`50`比特币，并对发送方和接收方的地址进行一些更改。因此，当我们发送此请求时，我们应该得到相同的响应：交易将被添加到第4个区块。这是因为我们还没有挖掘新的区块。让我们试一试：
- en: '![](img/ad5f9a4a-5d5f-487f-b92f-8773b8e4ef06.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad5f9a4a-5d5f-487f-b92f-8773b8e4ef06.png)'
- en: 'That worked. Now let''s head over and get our entire blockchain again. This
    time, we should expect to get the same blockchain and the two pending transactions
    that we just created. Let''s refresh the page and see the output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有效。现在让我们再次获取整个区块链。这次，我们应该期望得到与我们刚刚创建的相同的区块链和两笔待处理交易。让我们刷新页面并查看输出：
- en: '![](img/a56bf39c-d051-43ed-94fd-7b8ecc38ecb0.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a56bf39c-d051-43ed-94fd-7b8ecc38ecb0.png)'
- en: 'You will notice that this has three blocks and two pending transactions. Now,
    if we head over to our `/mine` endpoint and refresh the page, these two pending
    transactions will be added to block 4:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这里有三个区块和两笔待处理交易。现在，如果我们转到我们的`/mine`端点并刷新页面，这两笔待处理交易将被添加到第4个区块中：
- en: '![](img/a5584741-a1fa-4161-a36c-2348cca735ca.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5584741-a1fa-4161-a36c-2348cca735ca.png)'
- en: 'We have successfully mined a new block. It''s got our data, and it also has
    three transactions. The first two transactions are the ones we created in Postman,
    and the third one is our mining reward transaction. Now, if we go back to our
    `/blockchain` endpoint and refresh it, we will see that the two pending transactions
    are gone and that they have been added to block 4:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功挖掘了一个新的区块。它包含我们的数据，也有三笔交易。前两笔交易是我们在Postman中创建的，第三笔是我们的挖矿奖励交易。现在，如果我们回到我们的`/blockchain`端点并刷新它，我们会看到两笔待处理的交易已经消失，并且它们已被添加到第4个区块中。
- en: '![](img/74d7086d-490a-4234-9463-78585bbd3250.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74d7086d-490a-4234-9463-78585bbd3250.png)'
- en: As you can see, block 4 has all three transactions, and our `pendingTransactions`
    is empty now. It worked out well. Now, I would encourage you to create a couple
    more transactions and mine another block just to make sure that everything is
    working properly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，第4个区块包含了所有三笔交易，我们的`pendingTransactions`现在为空。效果很好。现在，我鼓励您创建更多的交易并挖掘另一个区块，以确保一切都正常工作。
- en: By building this whole API and blockchain and really understanding how the code
    works, it becomes a lot easier to understand how the blockchain technology actually
    works, and you also realize that a lot of it isn't actually so complicated.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建整个API和区块链，并真正理解代码的工作原理，更容易理解区块链技术的实际运作方式，您也会意识到其中很多实际上并不那么复杂。
- en: At any point while you are testing these endpoints, if you make changes to a
    file and save it, then the server will restart. This will result in a new instance
    of blockchain, which means that everything you have created so far will be cleared
    out.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这些端点的任何时候，如果您对文件进行更改并保存，服务器将重新启动。这将导致区块链的新实例，这意味着到目前为止创建的所有内容都将被清除。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to set up Express.js in our project, as well
    as how to use it to build our API/Server. Then we installed Postman and understood
    how to use it to test our endpoints. After this, we moved on to build various
    endpoints of our server and tested those to verify whether or not they were working
    properly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在项目中设置Express.js，以及如何使用它来构建我们的API/服务器。然后我们安装了Postman，并了解了如何使用它来测试我们的端点。之后，我们继续构建了服务器的各种端点，并测试它们以验证它们是否正常工作。
- en: In the next chapter, we will be creating a network of nodes or a decentralized
    network to host our blockchain, just like the ones that are hosted in the real
    world.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个节点网络或去中心化网络来托管我们的区块链，就像在现实世界中托管的那些一样。
