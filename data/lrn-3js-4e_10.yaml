- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Loading and Working with Textures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和使用纹理
- en: 'In [*Chapter 4*](B18726_04.xhtml#_idTextAnchor056), *Working with Three.js
    Materials*, we introduced you to the various materials that are available in Three.js.
    However, we didn’t discuss applying textures to the material that’s used when
    creating a mesh. In this chapter, we’ll look at that subject. Specifically, we’ll
    discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18726_04.xhtml#_idTextAnchor056) *使用Three.js材质* 中，我们向您介绍了Three.js中可用的各种材质。然而，我们没有讨论将纹理应用于创建网格时使用的材质。在本章中，我们将探讨这个主题。具体来说，我们将讨论以下主题：
- en: Loading textures in Three.js and applying them to a mesh
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Three.js中加载纹理并将其应用于网格
- en: Using bump, normal, and displacement maps to apply depth and detail to a mesh
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用凹凸、法线和位移图来为网格应用深度和细节
- en: Creating fake shadows using a lightmap and an ambient occlusion map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光照图和环境遮挡图创建假阴影
- en: Using specular, metalness, and roughness maps to set the shininess of specific
    parts of a mesh
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光泽度、金属度和粗糙度图来设置网格特定部分的光泽度
- en: Applying an alpha map for partial transparency of an object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为物体的部分透明度应用alpha图
- en: Adding detailed reflections to a material using an environment map
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境图向材质添加详细的反射
- en: Using the HTML5 Canvas and video element as input for a texture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5 Canvas和视频元素作为纹理的输入
- en: Let’s start with a basic example, where we will show you how to load and apply
    a texture.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的例子开始，我们将向您展示如何加载和应用纹理。
- en: Using textures in materials
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在材质中使用纹理
- en: There are different ways that textures can be used in Three.js. You can use
    them to define the colors of the mesh, but you can also use them to define shininess,
    bumps, and reflections. The first example we will look at, though, is very basic,
    wherein we will use a texture to define the colors of the individual pixels of
    a mesh. This is often called a color map or a diffuse map.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中，纹理可以使用不同的方式。您可以使用它们来定义网格的颜色，但您也可以使用它们来定义光泽度、凹凸和反射。我们将首先查看一个非常基础的例子，其中我们将使用纹理来定义网格各个像素的颜色。这通常被称为颜色图或漫反射图。
- en: Loading a texture and applying it to a mesh
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载纹理并将其应用于网格
- en: 'The most basic usage of a texture is when it’s set as a map on a material.
    When you use this material to create a mesh, the mesh will be colored based on
    the supplied texture. Loading a texture and using it on a mesh can be done in
    the following manner:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理最基本的使用方式是将其设置为材质上的映射。当您使用这种材质创建网格时，网格将根据提供的纹理进行着色。加载纹理并将其应用于网格可以按以下方式完成：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code sample, we are using an instance of `THREE.TextureLoader` to load
    an image file from a specific location. Using this loader, you can use PNG, GIF,
    or JPEG images as input for a texture (later in this chapter, we’ll show you how
    to load other texture formats). Note that textures are loaded asynchronously:
    if it is a large texture and you render the scene before the texture is completely
    loaded, you’ll see your meshes without a texture applied for a short time. If
    you want to wait until a texture has been loaded, you can provide a callback to
    the `textureLoader.load()` function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们使用`THREE.TextureLoader`的一个实例从特定位置加载一个图像文件。使用此加载器，您可以将PNG、GIF或JPEG图像作为纹理的输入（在本章的后面部分，我们将向您展示如何加载其他纹理格式）。请注意，纹理是异步加载的：如果纹理很大，并且在纹理完全加载之前渲染场景，您将短暂地看到没有应用纹理的网格。如果您想等待纹理加载完成，可以向`textureLoader.load()`函数提供一个回调：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the `load` function takes three additional functions as parameters:
    `onLoadFunction` is called when the texture is loaded, `onProgressFunction` can
    be used to track how much of the texture is loaded, and `onErrorFunction` is called
    when something goes wrong while loading or parsing the texture. Now that the texture
    has been loaded, we can add it to the mesh:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`load`函数接受三个额外的函数作为参数：`onLoadFunction`在纹理加载时被调用，`onProgressFunction`可用于跟踪纹理加载的进度，而`onErrorFunction`在加载或解析纹理时出错时被调用。现在纹理已经加载，我们可以将其添加到网格中：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the loader also provides a `loadAsync` function, which returns a `Promise`
    instead, just like we saw in the previous chapter when loading models.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，加载器还提供了一个`loadAsync`函数，它返回一个`Promise`，就像我们在上一章加载模型时看到的那样。
- en: You can use pretty much any image you’d like as a texture. However, you’ll get
    the best results by using a square texture whose dimensions are a power of 2\.
    So, dimensions such as 256 x 256, 512 x 512, 1,024 x 1,024, and so on work the
    best. If the texture isn’t a power of two, Three.js will scale down the image
    to the closest power of 2 value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以使用任何你想要的图像作为纹理。然而，使用边长为2的幂的平方纹理将获得最佳结果。例如，256 x 256、512 x 512、1,024 x 1,024等尺寸工作得最好。如果纹理不是2的幂，Three.js将把图像缩小到最接近的2的幂值。
- en: 'One of the textures we’ll be using in the examples in this chapter looks like
    this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的示例中使用的其中一个纹理看起来是这样的：
- en: '![Figure 10.1 – The color texture of a brick wall](img/Figure_10.1_B18726.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 砖墙的颜色纹理](img/Figure_10.1_B18726.jpg)'
- en: Figure 10.1 – The color texture of a brick wall
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 砖墙的颜色纹理
- en: 'The pixels of a texture (also called texels) usually don’t map one-to-one on
    the pixels of the face. If the camera is very close, we need to magnify the texture,
    and if we’re zoomed out, we probably need to shrink the texture. For this purpose,
    WebGL and Three.js offer a couple of different options to resize this image. This
    is done through the `magFilter` and `minFilter` properties:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的像素（也称为纹理像素）通常不会一对一地映射到面的像素上。如果相机非常靠近，我们需要放大纹理，如果我们缩小了视图，我们可能需要缩小纹理。为此，WebGL和Three.js提供了一些不同的选项来调整图像大小。这是通过`magFilter`和`minFilter`属性来完成的：
- en: '`THREE.NearestFilter`: This filter uses the color of the nearest texel that
    it can find. When used for magnification, this will result in blockiness, and
    when used for minification, the result will lose a lot of detail.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.NearestFilter`: 这个过滤器使用它能够找到的最近纹理像素的颜色。当用于放大时，这会导致块状感，而当用于缩小，结果会丢失很多细节。'
- en: '`THREE.LinearFilter`: This filter is more advanced; it uses the color values
    of the four neighboring texels to determine the correct color. You’ll still lose
    a lot of detail in minification, but the magnification will be much smoother and
    less blocky.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LinearFilter`: 这个过滤器更高级；它使用四个相邻的纹理像素的颜色值来确定正确的颜色。在缩小操作中，你仍然会丢失很多细节，但放大将会更加平滑，且块状感更少。'
- en: 'Aside from these basic values, we can also use a **MIP map**. A MIP map is
    a set of texture images, each half the size of the previous one. These are created
    when you load the texture and allow for much smoother filtering. So, when you
    have a square texture (as a power of 2), you can use a couple of additional approaches
    for better filtering. The properties can be set using the following values:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本值之外，我们还可以使用**MIP贴图**。MIP贴图是一组纹理图像，每个图像的大小是前一个图像的一半。这些图像在加载纹理时创建，允许进行更平滑的过滤。因此，当你有一个平方纹理（作为2的幂）时，你可以使用一些额外的策略来获得更好的过滤效果。可以使用以下值来设置属性：
- en: '`THREE.NearestMipMapNearestFilter`: This property selects the MIP map that
    best maps the required resolution and applies the nearest filter principle, which
    we discussed in the previous list. Magnification is still blocky, but minification
    looks much better.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.NearestMipMapNearestFilter`: 这个属性选择最佳的MIP贴图来映射所需的分辨率，并应用最近邻滤波原理，这是我们之前列表中讨论过的。放大时仍然会有块状感，但缩小看起来要好得多。'
- en: '`THREE.NearestMipMapLinearFilter`: This property selects not just a single
    MIP map but the two nearest MIP map levels. On both of these levels, the nearest
    filter is applied, to get two intermediate results. These two results are passed
    through a linear filter to get the final result.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.NearestMipMapLinearFilter`: 这个属性不仅选择单个MIP贴图，还选择两个最近的MIP贴图级别。在这两个级别上，都应用最近邻滤波器，以获得两个中间结果。这两个结果通过线性滤波器处理以获得最终结果。'
- en: '`THREE.LinearMipMapNearestFilter`: This property selects the MIP map that best
    maps the required resolution and applies the linear filter principle, which was
    discussed in the previous list.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LinearMipMapNearestFilter`: 这个属性选择最佳的MIP贴图来映射所需的分辨率，并应用线性滤波原理，这在我们之前的列表中已经讨论过。'
- en: '`THREE.LinearMipMapLinearFilter`: This property selects not a single MIP map,
    but the two nearest MIP map levels. On both of these levels, a linear filter is
    applied, to get two intermediate results. These two results are passed through
    a linear filter to get the final result.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.LinearMipMapLinearFilter`: 这个属性不仅选择单个MIP贴图，还选择两个最近的MIP贴图级别。在这两个级别上，都应用线性滤波器，以获得两个中间结果。这两个结果通过线性滤波器处理以获得最终结果。'
- en: If you don’t specify the `magFilter` and `minFilter` properties explicitly,
    Three.js uses `THREE.LinearFilter` as the default for the `magFilter` property
    and `THREE.LinearMipMapLinearFilter` as the default for the `minFilter` property.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有明确指定`magFilter`和`minFilter`属性，Three.js将使用`THREE.LinearFilter`作为`magFilter`属性的默认值，并将`THREE.LinearMipMapLinearFilter`作为`minFilter`属性的默认值。
- en: 'In our examples, we’ll just use the default texture properties. An example
    of such a basic texture used as a map for a material can be found in `texture-basics.html`.
    The following screenshot shows this example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将仅使用默认的纹理属性。一个这样的基本纹理作为材料映射的例子可以在`texture-basics.html`中找到。以下截图显示了此示例：
- en: '![Figure 10.2 – Model with a simple wood texture](img/Figure_10.2_B18726.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 带有简单木纹的模型](img/Figure_10.2_B18726.jpg)'
- en: Figure 10.2 – Model with a simple wood texture
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 带有简单木纹的模型
- en: In this example, you can change the models and select a couple of textures from
    the menu on the right. You can also change the default material properties to
    see how the material, in combination with a color map, is affected by the different
    settings.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以更改模型并从右侧菜单中选择几个纹理。你还可以更改默认的材料属性，以查看材料在结合颜色图的情况下如何受到不同设置的影响。
- en: In this example, you can see that the textures wrap nicely around the shapes.
    When you create geometries in Three.js, it makes sure that any texture that is
    used is applied correctly. This is done through something called UV mapping. With
    UV mapping, we can tell the renderer which part of a texture should be applied
    to a specific face. We’ll get into the details of UV mapping in [*Chapter 13*](B18726_13.xhtml#_idTextAnchor227),
    *Working with Blender and Three.js*, where we will show you how you can easily
    use Blender to create custom UV mappings for Three.js.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到纹理很好地包裹在形状周围。当你使用Three.js创建几何体时，它会确保任何使用的纹理都正确应用。这是通过称为UV映射的方法完成的。通过UV映射，我们可以告诉渲染器纹理的哪个部分应该应用到特定的面上。我们将在[*第13章*](B18726_13.xhtml#_idTextAnchor227)“使用Blender和Three.js”的详细内容中介绍UV映射，我们将向你展示如何轻松使用Blender为Three.js创建自定义UV映射。
- en: Aside from the standard image formats that we can load with `THREE.TextureLoader`,
    Three.js also provides a couple of custom loaders you can use to load textures
    provided in different formats. If you’ve got a specific image format, you can
    check out the `loaders` folder from the Three.js distribution ([https://github.com/mrdoob/three.js/tree/dev/examples/jsm/loaders](https://github.com/mrdoob/three.js/tree/dev/examples/jsm/loaders))
    to see whether the image format can be loaded directly by Three.js or whether
    you need to manually convert it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们可以使用`THREE.TextureLoader`加载的标准图像格式之外，Three.js还提供了一些自定义加载器，你可以使用这些加载器加载不同格式的纹理。如果你有特定的图像格式，你可以查看Three.js发行版的`loaders`文件夹（[https://github.com/mrdoob/three.js/tree/dev/examples/jsm/loaders](https://github.com/mrdoob/three.js/tree/dev/examples/jsm/loaders)），以查看该图像格式是否可以直接由Three.js加载，或者你是否需要手动转换它。
- en: Aside from these normal images, Three.js also supports HDR images.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些普通图像之外，Three.js还支持HDR图像。
- en: Loading HDR images as textures
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将HDR图像作为纹理加载
- en: 'An HDR image captures a higher range of luminance levels than standard images,
    and can more closely match what we see with the human eye. Three.js supports the
    `EXR` and `RGBE` formats. If you’ve got an HDR image, you can fine-tune how Three.js
    renders the HDR image since an HDR image contains more luminance information than
    can be shown on a display. This can be done by setting the following properties
    in `THREE.WebGLRenderer`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HDR图像捕捉了比标准图像更高的亮度级别，可以更接近我们用肉眼看到的效果。Three.js支持`EXR`和`RGBE`格式。如果你有一个HDR图像，你可以通过在`THREE.WebGLRenderer`中设置以下属性来微调Three.js渲染HDR图像的方式，因为HDR图像包含比显示器上显示的更多亮度信息。
- en: '`toneMapping`: This property defines how to map the colors from the HDR image
    to the display. Three.js provides the following options: `THREE.NoToneMapping`,
    `THREE.LinearToneMapping`, `THREE.ReinhardToneMapping`, `THREE.Uncharted2ToneMapping`,
    and `THREE.CineonToneMapping`. The default is `THREE.LinearToneMapping`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toneMapping`：此属性定义了如何将HDR图像的颜色映射到显示。Three.js提供了以下选项：`THREE.NoToneMapping`、`THREE.LinearToneMapping`、`THREE.ReinhardToneMapping`、`THREE.Uncharted2ToneMapping`和`THREE.CineonToneMapping`。默认为`THREE.LinearToneMapping`。'
- en: '`toneMappingExposure`: This is the exposure level of `toneMapping`. This can
    be used to fine-tune the colors of the rendered texture.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toneMappingExposure`：这是`toneMapping`的曝光级别。这可以用来微调渲染纹理的颜色。'
- en: '`toneMappingWhitePoint`: This is the white point used for `toneMapping`. This
    can also be used to fine-tune the colors of the rendered texture.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toneMappingWhitePoint`：这是用于 `toneMapping` 的白点。这也可以用来微调渲染纹理的颜色。'
- en: 'If you want to load an EXR or RGBE image and use it as a texture, you can use
    `THREE.EXRLoader` or `THREE.RGBELoader`. This works in the same way as we’ve seen
    for `THREE.TextureLoader`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要加载一个 EXR 或 RGBE 图像并将其用作纹理，你可以使用 `THREE.EXRLoader` 或 `THREE.RGBELoader`。这与我们所看到的
    `THREE.TextureLoader` 的方式相同：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `texture-basics.html` example, we showed you how the texture can be used
    to apply colors to a mesh. In the next section, we’ll look at how to use a texture
    to make a model look more detailed by applying fake height information to the
    mesh.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `texture-basics.html` 示例中，我们向你展示了如何使用纹理将颜色应用到网格上。在下一节中，我们将探讨如何通过将假高度信息应用到网格上来使用纹理使模型看起来更加详细。
- en: Using a bump map to provide extra details to a mesh
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用凹凸贴图向网格提供额外细节
- en: 'A bump map is used to add more depth to a material. You can see this in action
    by opening `texture-bump-map.html`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 凹凸贴图用于向材质添加更多深度。你可以通过打开 `texture-bump-map.html` 来看到这个效果：
- en: '![Figure 10.3 – Model with a bump map](img/Figure_10.3_B18726.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 带凹凸贴图的模型](img/Figure_10.3_B18726.jpg)'
- en: Figure 10.3 – Model with a bump map
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 带凹凸贴图的模型
- en: 'In this example, you can see that the model looks much more detailed and seems
    to have more depth. This was done by setting an additional texture, a so-called
    bump map, on the material:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到模型看起来更加详细，似乎有更多的深度。这是通过在材质上设置一个额外的纹理，即所谓的凹凸贴图来实现的：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code, you can see that aside from setting the map property, we have
    also set the `bumpMap` property to a texture. Additionally, with the `bumpScale`
    property, which is available through the menu in the previous example, we can
    set the height (or depth, if set to a negative value) of the bumps. The textures
    used in this example are shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你可以看到，除了设置映射属性外，我们还设置了 `bumpMap` 属性到一个纹理。此外，通过前一个示例中的菜单，我们可以使用 `bumpScale`
    属性设置凹凸的高度（或如果设置为负值，则为深度）。本例中使用的纹理在此处显示：
- en: '![Figure 10.4 – Textures used for the bump map](img/Figure_10.4_B18726.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 用于凹凸贴图的纹理](img/Figure_10.4_B18726.jpg)'
- en: Figure 10.4 – Textures used for the bump map
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 用于凹凸贴图的纹理
- en: The bump map is a grayscale image, but you can also use a color image. The intensity
    of the pixels defines the height of the bump. A bump map only contains the relative
    height of a pixel. It doesn’t say anything about the direction of the slope. So,
    the level of detail and perception of depth that you can reach with a bump map
    is limited. For more detail, you can use a normal map.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 凹凸贴图是一个灰度图像，但你也可以使用彩色图像。像素的强度定义了凹凸的高度。凹凸贴图只包含像素的相对高度。它没有说明斜坡的方向。因此，使用凹凸贴图可以达到的细节水平和深度感知是有限的。对于更详细的信息，你可以使用法线贴图。
- en: Achieving more detailed bumps and wrinkles with a normal map
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用法线贴图实现更详细的凹凸和皱纹
- en: 'In a normal map, the height (displacement) is not stored, but the direction
    of the normal for each pixel is stored. Without going into too much detail, with
    normal maps, you can create very detailed-looking models that use only a small
    number of vertices and faces. For instance, take a look at the `texture-normal-map.html`
    example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在法线贴图中，高度（位移）没有存储，但每个像素的法线方向被存储。不深入细节的话，使用法线贴图，你可以创建看起来非常详细的模型，而这些模型只使用了少量顶点和面。例如，看看
    `texture-normal-map.html` 示例：
- en: '![Figure 10.5 – A model using a normal map](img/Figure_10.5_B18726.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 使用法线贴图的模型](img/Figure_10.5_B18726.jpg)'
- en: Figure 10.5 – A model using a normal map
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 使用法线贴图的模型
- en: 'In the preceding screenshot, you can see a very detailed-looking model. And
    as the model moves around, you can see that the texture is responding to the light
    it receives. This provides a very realistic-looking model and only requires a
    very simple model and a couple of textures. The following code fragment shows
    how to use a normal map in Three.js:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到一个看起来非常详细的模型。当模型移动时，你可以看到纹理正在响应它接收到的光线。这提供了一个看起来非常逼真的模型，并且只需要一个非常简单的模型和几个纹理。以下代码片段展示了如何在
    Three.js 中使用法线贴图：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This involves the same approach as the one we used for the bump map. This time,
    though, we set the `normalMap` property to the normal texture. We can also define
    how pronounced the bumps look by setting the `normalScale` property (`mat.normalScale.set(1,1)`).
    With this property, you can scale along the *X* and *Y* axes. The best approach,
    though, is to keep these values the same. In this example, you can play around
    with these values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到与我们用于凹凸贴图相同的方法。不过，这次我们将 `normalMap` 属性设置为正常纹理。我们还可以通过设置 `normalScale` 属性（`mat.normalScale.set(1,1)`）来定义凹凸的明显程度。使用这个属性，你可以沿着
    *X* 和 *Y* 轴进行缩放。然而，最好的方法是将这些值保持相同。在这个例子中，你可以尝试调整这些值。
- en: 'The following figure shows what the normal map we used here looks like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图展示了我们使用的正常贴图的样子：
- en: '![Figure 10.6 – Normal texture](img/Figure_10.6_B18726.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 正常纹理](img/Figure_10.6_B18726.jpg)'
- en: Figure 10.6 – Normal texture
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 正常纹理
- en: The problem with normal maps, however, is that they aren’t very easy to create.
    You need to use specialized tools, such as Blender or Photoshop. These programs
    can use high-resolution renderings or textures as input and can create normal
    maps from them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正常贴图的问题在于它们并不容易创建。你需要使用专门的工具，如 Blender 或 Photoshop。这些程序可以使用高分辨率的渲染或纹理作为输入，并从中创建正常贴图。
- en: With a normal or bump map, you don’t change the shape of the model; all of the
    vertices stay in the same location. These maps just use the lights from the scene
    to create fake depth and details. However, Three.js provides a third method that
    you can use to add details to a model using a map, which does change the positions
    of the vertices. This is done through a displacement map.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正常或凹凸贴图时，你不会改变模型的形状；所有的顶点都保持在相同的位置。这些贴图只是使用场景中的灯光来创建假深度和细节。然而，Three.js 提供了第三种方法，你可以使用它通过贴图添加细节到模型中，这种方法会改变顶点的位置。这是通过位移图实现的。
- en: Using a displacement map to alter the position of vertices
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用位移图来改变顶点的位置
- en: 'Three.js also provides a texture that you can use to change the positions of
    the vertices of your model. While the bump map and the normal map give an illusion
    of depth, with a displacement map, we change the model’s shape, based on the information
    from the texture. We can use a displacement map in the same way as we use other
    maps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 还提供了一个纹理，你可以用它来改变模型顶点的位置。虽然凹凸贴图和正常贴图可以产生深度错觉，但使用位移图时，我们根据纹理信息改变模型的形状。我们可以像使用其他贴图一样使用位移图：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code fragment, we loaded a displacement map, which looks as
    follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们加载了一个位移图，其外观如下：
- en: '![Figure 10.7 – Displacement map](img/Figure_10.7_B18726.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 位移图](img/Figure_10.7_B18726.jpg)'
- en: Figure 10.7 – Displacement map
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 位移图
- en: 'The brighter the color, the more a vertex is displaced. When you run the `texture-displacement.html`
    example, you will see that the result of the displacement map is a model where
    the shape of the model is changed based on the information from the map:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色越亮，顶点的位移就越大。当你运行 `texture-displacement.html` 示例时，你会看到位移贴图的结果是一个模型，其形状基于贴图中的信息发生变化：
- en: '![Figure 10.8 – Model using a displacement map](img/Figure_10.8_B18726.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 使用位移图建模](img/Figure_10.8_B18726.jpg)'
- en: Figure 10.8 – Model using a displacement map
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 使用位移图建模
- en: Aside from setting the `displacementMap` texture, we can also use `displacementScale`
    and `displacementOffset` to control how pronounced the displacement is. One final
    thing to mention about using a displacement map is that it will only have good
    results if your mesh contains a large number of vertices. If not, the displacement
    won’t look like the provided texture, since there are too few vertices to represent
    the required displacement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置 `displacementMap` 纹理外，我们还可以使用 `displacementScale` 和 `displacementOffset`
    来控制位移的明显程度。关于使用位移图还有一点要提，那就是它只有在你的网格包含大量顶点时才会得到良好的效果。如果不是这样，位移看起来就不会像提供的纹理，因为顶点太少，无法表示所需的位移。
- en: Adding subtle shadows with an ambient occlusion map
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境遮蔽贴图添加微妙的阴影
- en: In the previous chapters, you learned how you can use shadows in Three.js. If
    you set the `castShadow` and `receiveShadow` properties of the correct meshes,
    add a couple of lights, and configure the shadow camera of the lights correctly,
    Three.js will render shadows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何在 Three.js 中使用阴影。如果你设置了正确网格的 `castShadow` 和 `receiveShadow` 属性，添加了一些灯光，并正确配置了灯光的阴影相机，Three.js
    将渲染阴影。
- en: 'Rendering shadows, however, is a rather expensive operation that is repeated
    for every render loop. If you have lights or objects that are moving around, this
    is necessary, but often, some of the lights or models are fixed, so it would be
    great if we could calculate the shadows once, and then reuse them. To accomplish
    this, Three.js offers two different maps: the ambient occlusion map and a lightmap.
    In this section, we’ll look at the ambient occlusion map, and in the next section,
    we’ll look at the lightmap.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，渲染阴影是一个相对昂贵的操作，它会在每个渲染循环中重复进行。如果你有移动的灯光或对象，这是必要的，但通常，一些灯光或模型是固定的，所以如果我们能计算一次阴影并重复使用它们，那就太好了。为了实现这一点，Three.js提供了两种不同的图：环境光遮蔽图和光照图。在本节中，我们将探讨环境光遮蔽图，在下一节中，我们将探讨光照图。
- en: 'Ambient occlusion is a technique used to determine how much each part of a
    model is exposed to the ambient lighting in a scene. In tools such as Blender,
    ambient light is often modeled through a hemisphere light or a directional light,
    such as the Sun. While most parts of a model will receive some of this ambient
    lighting, not all of the parts will receive the same. If, for instance, you model
    a person, the top of the head will receive more ambient lighting than the bottom
    of the arms. This difference in lighting – the shadows – can be rendered (baked,
    as shown in the following screenshot) into a texture, and we can then apply that
    texture to our models to give them shadows, without having to calculate the shadows
    every time:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光遮蔽是一种技术，用于确定模型每个部分在场景中的环境光照中暴露的程度。在Blender等工具中，环境光通常通过半球光或方向光，如太阳光来模拟。虽然模型的大部分区域都会接收到一些这种环境光照，但并非所有部分都会接收到相同的光照。例如，如果你建模一个人，头顶会比手臂底部接收到更多的环境光照。这种光照差异——即阴影——可以被渲染（烘焙，如以下截图所示）成纹理，然后我们可以将这个纹理应用到我们的模型上，以给它们添加阴影，而不必每次都计算阴影：
- en: '![Figure 10.9 – Ambient occlusion map baked in Blender](img/Figure_10.9_B18726.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 在Blender中烘焙的环境光遮蔽图](img/Figure_10.9_B18726.jpg)'
- en: Figure 10.9 – Ambient occlusion map baked in Blender
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 在Blender中烘焙的环境光遮蔽图
- en: 'Once you have an ambient occlusion map, you can assign it to the `aoMap` property
    of the material, and Three.js will take this information into account when applying
    and calculating how much the lights in the scene should be applied to that specific
    part of the model. The following code fragment shows how to set the `aoMap` property:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了环境光遮蔽图，你可以将其分配给材质的`aoMap`属性，Three.js将考虑这个信息在应用和计算场景中灯光应该应用到模型特定部分的程度。以下代码片段显示了如何设置`aoMap`属性：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like the other kinds of texture maps, we just use `THREE.TextureLoader`
    to load the texture and assign it to the correct property of the material. And
    like with many of the other maps, we can also tune how much the map affects the
    lighting of the model by setting the `aoMapIntenisty` property. In this example,
    you can also see that we needed to set the `flipY` property of `aoMap` to false.
    Sometimes, external programs store the material in a texture slightly different
    than Three.js expects. With this property, we flip the orientation of the texture.
    This is usually something you’ll notice by trial and error when working with the
    model.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他类型的纹理图一样，我们只需使用`THREE.TextureLoader`来加载纹理并将其分配给材质的正确属性。并且像许多其他图一样，我们也可以通过设置`aoMapIntensity`属性来调整地图对模型光照的影响程度。在这个例子中，你还可以看到我们需要将`aoMap`的`flipY`属性设置为false。有时，外部程序以Three.js期望的纹理略有不同的方式存储材质。使用这个属性，我们可以翻转纹理的方向。这通常是在与模型一起工作时通过试错法注意到的事情。
- en: 'To make an ambient occlusion map work, we will (usually) need one additional
    step. We have already mentioned UV mappings (stored in the `uv` attribute). These
    define which part of a texture is mapped to a specific face of the model. For
    the ambient occlusion map, and also for the lightmap in the following example,
    Three.js uses a separate set of UV mappings (stored in the `uv2` attribute) because,
    often, the other textures need to be applied differently than the shadow and lightmap
    textures. For our example, we are just copying the UV mappings from the model;
    remember that when we use the `aoMap` property or the `lightMap` property, Three.js
    will use the value of the `uv2` attribute, instead of the `uv` attribute. If this
    attribute isn’t present in the model you load, most often, just copying the `uv`
    map property works as well since we didn’t do anything to optimize the ambient
    occlusion map, which might require a different set of UVs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使环境遮挡贴图生效，我们通常需要额外一步。我们已经提到了 UV 映射（存储在 `uv` 属性中）。这些定义了纹理的哪一部分被映射到模型的特定面。对于环境遮挡贴图，以及以下示例中的光照贴图，Three.js
    使用一组独立的 UV 映射（存储在 `uv2` 属性中），因为通常其他纹理需要以不同于阴影和光照贴图纹理的方式应用。在我们的示例中，我们只是复制了模型的 UV
    映射；记住，当我们使用 `aoMap` 属性或 `lightMap` 属性时，Three.js 将使用 `uv2` 属性的值，而不是 `uv` 属性的值。如果加载的模型中没有这个属性，通常只需复制
    `uv` 映射属性即可，因为我们没有对环境遮挡贴图进行任何优化，这可能需要不同的 UV 集合：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will provide two examples where we use an ambient occlusion map. In the
    first one, we are showing the model from *Figure 10**.9* with `aoMap` applied
    (`texture-ao-map-model.html`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供两个示例，展示我们如何使用环境遮挡贴图。在第一个示例中，我们展示了应用了 `aoMap` 的 *图 10.9* 中的模型（`texture-ao-map-model.html`）：
- en: '![Figure 10.10 – Ambient occlusion map baked in Blender and then applied to
    a model](img/Figure_10.10_B18726.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 在 Blender 中烘焙的环境遮挡贴图然后应用于模型](img/Figure_10.10_B18726.jpg)'
- en: Figure 10.10 – Ambient occlusion map baked in Blender and then applied to a
    model
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 在 Blender 中烘焙的环境遮挡贴图然后应用于模型
- en: 'You can use the menu on the right to set `aoMapIntensity`. The higher this
    value is, the more shadows you’ll see from the loaded `aoMap` texture. As you
    can see, it is really useful to have an ambient occlusion map as it provides great
    details for the model, and makes it look much more lifelike. Some of the textures
    we’ve seen in this chapter already also provide an additional `aoMap` that you
    can use. If you open `texture-ao-map.html`, you will get a simple brick-like texture,
    but this time with `aoMap` added as well:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用右侧的菜单设置 `aoMapIntensity`。此值越高，您将看到从加载的 `aoMap` 纹理中产生的阴影就越多。如您所见，拥有环境遮挡贴图非常有用，因为它为模型提供了丰富的细节，并使其看起来更加逼真。在本章中我们已经看到的一些纹理也提供了额外的
    `aoMap`，您可以使用它。如果您打开 `texture-ao-map.html`，您将得到一个简单的砖块状纹理，但这次添加了 `aoMap`：
- en: '![Figure 10.11 – Ambient occlusion map combined with color and normal maps](img/Figure_10.11_B18726.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 环境遮挡贴图与颜色和法线贴图结合](img/Figure_10.11_B18726.jpg)'
- en: Figure 10.11 – Ambient occlusion map combined with color and normal maps
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 环境遮挡贴图与颜色和法线贴图结合
- en: While an ambient occlusion map changes the amount of light received by certain
    parts of the model, Three.js also supports `lightmap`, which do the opposite (approximately)
    by specifying a map that adds extra lighting to certain parts of the model.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当环境遮挡贴图改变模型某些部分接收到的光照量时，Three.js 还支持 `lightmap`，它通过指定一个映射来为模型的某些部分添加额外的光照，从而产生相反的效果（大约是这样）。
- en: Creating fake lighting using a lightmap
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用光照贴图创建假光照
- en: 'In this section, we’ll use a lightmap. A lightmap is a texture that contains
    information about how much the lights in the scene will affect the model. In other
    words, the effect of the lights is baked into a texture. Lightmaps are baked in
    3D software, such as Blender, and contain the light values of each part of the
    model:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用光照贴图。光照贴图是一种包含场景中灯光对模型影响程度信息的纹理。换句话说，灯光的效果被烘焙到纹理中。光照贴图在 3D 软件中烘焙，如
    Blender，并包含模型每个部分的光照值：
- en: '![Figure 10.12 – Lightmap baked in Blender](img/Figure_10.12_B18726.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 在 Blender 中烘焙的光照贴图](img/Figure_10.12_B18726.jpg)'
- en: Figure 10.12 – Lightmap baked in Blender
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 在 Blender 中烘焙的光照贴图
- en: 'The lightmap that we’ll use in this example is shown in *Figure 10**.12*. The
    right part of the edit window shows a baked lightmap for the ground plane. You
    can see that the whole ground plane is illuminated with white light, and parts
    of it receive less light because there is also a model in the scene. The code
    for using a lightmap is similar to that of an ambient occlusion map:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中我们将使用的光照贴图如图*图10.12*所示。编辑窗口的右侧显示了地平面的烘焙光照贴图。你可以看到整个地平面都被白色光照亮，而其中一部分接收到的光线较少，因为场景中还有一个模型。使用光照贴图的代码与使用环境遮挡贴图的代码类似：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once again, we need to provide Three.js with an additional set of `uv` values
    called `uv2` (not shown in the code), and we must use `THREE.TextureLoader` to
    load the textures – in this case, a simple texture is used for the colors of the
    floor and the lightmap created for this example in Blender. The result looks as
    follows (`texture-light-map.html`):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '一次又一次，我们需要为Three.js提供一组额外的`uv`值，称为`uv2`（代码中未显示），并且我们必须使用`THREE.TextureLoader`来加载纹理——在这种情况下，使用了一个简单的纹理来表示地板的颜色和Blender为这个示例创建的光照贴图。结果如下（`texture-light-map.html`）:'
- en: '![Figure 10.13 – Using a lightmap for false shadows](img/Figure_10.13_B18726.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 使用光照贴图创建假阴影](img/Figure_10.13_B18726.jpg)'
- en: Figure 10.13 – Using a lightmap for false shadows
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 使用光照贴图创建假阴影
- en: If you look at the preceding example, you will see that the information from
    the lightmap is used to create a very nice-looking shadow, which seems to be cast
    by the model. It is important to remember that baking shadows, lights, and ambient
    occlusion works great in static scenes with static objects. As soon as objects
    or light sources change or start to move, you will have to calculate the shadows
    in real time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看前面的示例，你会看到光照贴图的信息被用来创建一个非常漂亮的阴影，这个阴影看起来像是模型投射的。重要的是要记住，烘焙阴影、灯光和环境遮挡在静态场景和静态物体中效果很好。一旦物体或光源发生变化或开始移动，你就必须实时计算阴影。
- en: Metalness and roughness maps
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金属度和粗糙度贴图
- en: 'When discussing the materials available in Three.js, we mentioned that a good
    default material to use is `THREE.MeshStandardMaterial`. You can use this to create
    shiny, metal-like materials, but also to apply roughness, to make the mesh look
    more like wood or plastic. By using the metalness and roughness properties of
    the material, we can configure the material to represent the material that we
    want. Aside from these two properties, you can also configure these properties
    by using a texture. So, if we have a rough object and we want to specify that
    a certain part of that object is shiny, we can set the `metalnessMap` property
    of `THREE.MeshStandardMaterial`, and if we want to indicate that some parts of
    the mesh should be seen as scratched or rougher, we can set the `roughnessMap`
    property. When you use these maps, the value of the texture for a specific part
    of the model is multiplied by either the `roughness` property or the `metalness`
    property, and that determines how that specific pixel should be rendered. First,
    we will look at the `metalness` property in `texture-metalness-map.html`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论Three.js中可用的材质时，我们提到一个好的默认材质是`THREE.MeshStandardMaterial`。你可以使用它来创建闪亮的金属材质，也可以应用粗糙度，使网格看起来更像木材或塑料。通过使用材质的金属度和粗糙度属性，我们可以配置材质以表示我们想要的材质。除了这两个属性之外，你还可以通过使用纹理来配置这些属性。因此，如果我们有一个粗糙的物体，并且我们想要指定该物体的某个部分是闪亮的，我们可以设置`THREE.MeshStandardMaterial`的`metalnessMap`属性，如果我们想要表明网格的某些部分应该被视为刮痕或更粗糙，我们可以设置`roughnessMap`属性。当你使用这些贴图时，模型特定部分的纹理值将被乘以`粗糙度`属性或`金属度`属性，这决定了该特定像素应该如何渲染。首先，我们将查看`texture-metalness-map.html`中的`金属度`属性：
- en: '![Figure 10.14 – Metalness texture applied to a model](img/Figure_10.14_B18726.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 应用到模型上的金属度纹理](img/Figure_10.14_B18726.jpg)'
- en: Figure 10.14 – Metalness texture applied to a model
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 应用到模型上的金属度纹理
- en: 'In this example, we’ve skipped ahead a bit and have also used an environment
    map, which allows us to render reflections from the environment on top of the
    objects. An object with a high metalness reflects more, and an object with a high
    roughness diffuses the reflection more. For this model, we’ve used `metalnessMap`;
    you can see that the object itself is shiny where the `metalness` property from
    the texture is high and that some parts are rough where the `metalness` property
    from the texture is low. When looking at `roughnessMap`, we can see pretty much
    the same but inverted:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们提前了一步，并且还使用了一个环境贴图，这允许我们在对象上渲染来自环境的反射。具有高金属度的对象反射更多，而具有高粗糙度的对象则更多地散射反射。对于此模型，我们使用了
    `metalnessMap`；您可以看到，当纹理中的 `metalness` 属性值高时，物体本身是闪亮的，而当 `metalness` 属性值低时，某些部分是粗糙的。当查看
    `roughnessMap` 时，我们可以看到几乎相同但相反的情况：
- en: '![Figure 10.15 – Roughness texture applied to a model](img/Figure_10.15_B18726.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 应用到模型上的粗糙度纹理](img/Figure_10.15_B18726.jpg)'
- en: Figure 10.15 – Roughness texture applied to a model
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 应用到模型上的粗糙度纹理
- en: As you can see, based on the provided texture, certain parts of the model are
    rougher or more scratched than other parts. For `metalnessMap`, the value of the
    material is multiplied by the `metalness` property of the material; for `roughnessMap`,
    the same applies, but in that case, the value is multiplied by the `roughness`
    property.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，基于提供的纹理，模型的某些部分比其他部分更粗糙或更刮痕。对于 `metalnessMap`，材料的值乘以材料的 `metalness` 属性；对于
    `roughnessMap`，同样适用，但在此情况下，值乘以 `roughness` 属性。
- en: 'Loading these textures and setting them to the material can be done like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 加载这些纹理并将它们设置为材质可以这样做：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next up is the alpha map. With the alpha map, we can use a texture to change
    the transparency of parts of the model.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 Alpha 映射。使用 Alpha 映射，我们可以使用纹理来改变模型部分的不透明度。
- en: Using an alpha map to create transparent models
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Alpha 映射创建透明模型
- en: 'An alpha map is a way to control the opacity of the surface. If the value of
    the map is black, that part of the model will be fully transparent, and if it
    is white, it will be fully opaque. Before we look at the texture and how to apply
    it, we’ll first look at the example (`texture-alpha-map.html`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha 映射是一种控制表面不透明度的方法。如果映射的值为黑色，则该模型的部分将完全透明，如果为白色，则将完全不透明。在我们查看纹理及其应用方法之前，我们首先来看一个示例（`texture-alpha-map.html`）：
- en: '![Figure 10.16 – Alpha map used to give partial transparency](img/Figure_10.16_B18726.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 用于提供部分透明度的 Alpha 映射](img/Figure_10.16_B18726.jpg)'
- en: Figure 10.16 – Alpha map used to give partial transparency
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 用于提供部分透明度的 Alpha 映射
- en: In this example, we’ve rendered a cube and set the `alphaMap` property of the
    material. If you open this example, make sure to set the `transparency` property
    of the material to `true`. You’ll probably notice that you can only see the front-facing
    part of the cube, unlike the preceding screenshot, where you can look through
    the cube and see the other side. The reason is that, by default, the side property
    of the used material is set to `THREE.FrontSide`. To render the side that is normally
    hidden, we have to set the side property of the material to `THREE.DoubleSide`;
    you will see that the cube is rendered as shown in the preceding screenshot.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们渲染了一个立方体并设置了材质的 `alphaMap` 属性。如果您打开这个示例，请确保将材质的 `transparency` 属性设置为
    `true`。您可能会注意到，您只能看到立方体的正面部分，与前面的截图不同，您可以通过立方体看到另一面。原因是，默认情况下，使用的材质的侧面属性设置为 `THREE.FrontSide`。要渲染通常隐藏的侧面，我们必须将材质的侧面属性设置为
    `THREE.DoubleSide`；您将看到立方体被渲染成前面的截图所示的样子。
- en: 'The texture that we used in this example is a very simple one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中我们使用的纹理是一个非常简单的：
- en: '![Figure 10.17 – Texture used to create a transparent model](img/Figure_10.17_B18726.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – 用于创建透明模型的纹理](img/Figure_10.17_B18726.jpg)'
- en: Figure 10.17 – Texture used to create a transparent model
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – 用于创建透明模型的纹理
- en: 'To load it, we must use the same approach as that of the other textures:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载它，我们必须使用与其他纹理相同的方法：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code fragment, you can also see that we’ve set the `wrapS`, `wrapT`,
    and `repeat` properties of the texture. We’ll explain these properties in more
    detail later in this chapter, but these properties can be used to determine how
    often we want to repeat the texture on the mesh. If set to `(1, 1)`, the whole
    texture won’t be repeated when applied to the mesh; if set to higher values, the
    texture will shrink and will be repeated multiple times. In this case, we repeated
    it in both directions four times.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你还可以看到我们设置了纹理的`wrapS`、`wrapT`和`repeat`属性。我们将在本章后面更详细地解释这些属性，但可以使用这些属性来确定我们希望在网格上重复纹理的频率。如果设置为`(1,
    1)`，则整个纹理在应用于网格时不会重复；如果设置为更高的值，则纹理会缩小并重复多次。在这种情况下，我们在两个方向上重复了四次。
- en: Using an emissive map for models that glow
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为发光模型使用发射贴图
- en: 'The emissive map is a texture that can be used to make certain parts of the
    model glow, just like the `emissive` property does for the whole model. Just as
    for the `emissive` property, using an emissive map doesn’t mean this object is
    emitting light – it just makes the part of the model where this texture is applied
    seem to glow. This is easier to understand by looking at an example. If you open
    up the `texture-emissive-map.html` example in your browser, you will see a lava-like
    object:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 发射贴图是一种可以用来使模型的某些部分发光的纹理，就像发射属性对整个模型所做的那样。就像发射属性一样，使用发射贴图并不意味着这个物体正在发光——它只是使应用了此纹理的模型部分看起来像在发光。通过查看一个例子可以更容易地理解这一点。如果你在浏览器中打开`texture-emissive-map.html`示例，你会看到一个类似火山的物体：
- en: '![Figure 10.18 – Lava-like object using an emissive map](img/Figure_10.18_B18726.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18 – 使用发射贴图的类似火山物体](img/Figure_10.18_B18726.jpg)'
- en: Figure 10.18 – Lava-like object using an emissive map
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – 使用发射贴图的类似火山物体
- en: 'When you look closely, though, you might see that while the objects seem to
    glow, the objects themselves don’t emit light. This means that you can use this
    to enhance objects, but the objects themselves don’t contribute to the lighting
    of the scene. For this example, we used an emissive map that looks as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你仔细观察时，你可能会发现，尽管物体看起来在发光，但物体本身并不发光。这意味着你可以用这个方法来增强物体，但物体本身并不对场景的照明做出贡献。在这个例子中，我们使用了一个看起来如下所示的发射贴图：
- en: '![Figure 10.19 – Lava texture](img/Figure_10.19_B18726.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图10.19 – 火山纹理](img/Figure_10.19_B18726.jpg)'
- en: Figure 10.19 – Lava texture
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 – 火山纹理
- en: 'To load and use an emissive map, we can use a `THREE.TextureLoader` to load
    one and assign it to the `emissiveMap` property (together with some other maps
    to get the model shown in *Figure 10**.18*):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载和使用发射贴图，我们可以使用`THREE.TextureLoader`加载一个并将其分配给`emissiveMap`属性（以及一些其他贴图以显示*图10.18*中的模型）：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since the color from `emissiveMap` is modulated with the emissive property,
    make sure that you set the `emissive` property of the material to something other
    than black.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`emissiveMap`中的颜色与发射属性相调制，请确保将材质的`emissive`属性设置为非黑色。
- en: Using a specular map to determine shininess
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用反射贴图确定闪亮度
- en: 'In the previous examples, we mostly used `THREE.MeshStandardMaterial`, and
    the different maps supported by that material. `THREE.MeshStandardMaterial` is
    often your best choice if you need a material since it can be easily configured
    to represent a large number of different types of real-world materials. In older
    versions of Three.js, you had to use `THREE.MeshPhongMaterial` for shiny materials
    and `THREE.MeshLambertMaterial` for non-shiny materials. The specular map used
    in this section can only be used together with `THREE.MeshPhongMaterial`. With
    a specular map, you can define which parts of the model should be shiny, and which
    parts of them should be rough (similar to `metalnessMap` and `roughnessMap`, which
    we saw earlier). In the `texture-specular-map.html` example, we’ve rendered the
    Earth and used a specular map to make the oceans shinier than the landmasses:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们主要使用了`THREE.MeshStandardMaterial`，以及该材质支持的不同贴图。如果你需要材质，`THREE.MeshStandardMaterial`通常是你的最佳选择，因为它可以轻松配置以表示大量不同类型的真实世界材质。在Three.js的旧版本中，你必须使用`THREE.MeshPhongMaterial`来创建闪亮的材质，使用`THREE.MeshLambertMaterial`来创建非闪亮的材质。本节中使用的反射贴图只能与`THREE.MeshPhongMaterial`一起使用。使用反射贴图，你可以定义模型的哪些部分应该是闪亮的，以及哪些部分应该是粗糙的（类似于我们之前看到的`metalnessMap`和`roughnessMap`）。在`texture-specular-map.html`示例中，我们渲染了地球，并使用反射贴图使海洋比陆地更闪亮：
- en: '![Figure 10.20 – Specular map showing reflecting oceans](img/Figure_10.20_B18726.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图10.20 – 显示反射海洋的反射贴图](img/Figure_10.20_B18726.jpg)'
- en: Figure 10.20 – Specular map showing reflecting oceans
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 – 显示反射海洋的镜面图
- en: 'By using the menu at the top right, you can play around with the specular color
    and the shininess. As you can see, these two properties affect how the oceans
    reflect light, but they don’t change the landmasses’ shininess. This is because
    we’ve used the following specular map:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用右上角的菜单，你可以调整镜面颜色和亮度。正如你所看到的，这两个属性会影响海洋反射光的方式，但它们不会改变陆地部分的亮度。这是因为我们使用了以下镜面图：
- en: '![Figure 10.21 – Specular map texture](img/Figure_10.21_B18726.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图10.21 – 镜面图纹理](img/Figure_10.21_B18726.jpg)'
- en: Figure 10.21 – Specular map texture
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21 – 镜面图纹理
- en: In this map, the black color means that those parts of the map have a shininess
    of 0%, and the white parts have a shininess of 100%.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，黑色表示图中这些部分的亮度为0%，而白色部分亮度为100%。
- en: 'To use a specular map, we must use `THREE.TextureLoader` to load the map and
    assign it to the `specularMap` property of a `THREE.MathPhongMaterial`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用镜面图，我们必须使用`THREE.TextureLoader`来加载图并将其分配给`THREE.MathPhongMaterial`的`specularMap`属性：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the specular map, we’ve discussed most of the basic textures that you can
    use to add depth, color, transparency, or additional light effects to your model.
    In the next two sections, we’ll look at one more type of map, which will allow
    you to add environment reflections to your model.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过镜面图，我们已经讨论了你可以用来为你的模型添加深度、颜色、透明度或额外光照效果的大多数基本纹理。在接下来的两个部分中，我们将探讨另一种类型的图，这将允许你为你的模型添加环境反射。
- en: Creating fake reflections using an environment map
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境图创建伪造的反射
- en: 'Calculating environment reflections is very CPU-intensive, and it usually requires
    a ray tracer approach. If you want to use reflections in Three.js, you can still
    do that, but you’ll have to fake it. You can do so by creating a texture of the
    environment the object is in and applying it to the specific object. First, we’ll
    show you the result that we’re aiming for (see `texture-environment-map.html`,
    which is shown in the following screenshot):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 计算环境反射非常耗费CPU资源，通常需要使用光线追踪方法。如果你想在Three.js中使用反射，你仍然可以这样做，但你需要伪造它。你可以通过创建一个包含对象所在环境的纹理并将其应用到特定对象上来实现这一点。首先，我们将向您展示我们期望的结果（参见`texture-environment-map.html`，如下截图所示）：
- en: '![Figure 10.22 – Environment map showing the inside of a car](img/Figure_10.22_B18726.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图10.22 – 显示汽车内部的纹理图](img/Figure_10.22_B18726.jpg)'
- en: Figure 10.22 – Environment map showing the inside of a car
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22 – 显示汽车内部的纹理图
- en: 'In the preceding screenshot, you can see that the sphere reflects the environment.
    If you move your mouse around, you will also see that the reflection corresponds
    with the camera angle, concerning the environment you see. To create this example,
    perform the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到球体反射了环境。如果你移动鼠标，你也会看到反射与相机角度相对应，考虑到你所看到的环境。要创建这个示例，请执行以下步骤：
- en: Create a `CubeTexture` object. A `CubeTexture` is a set of six textures that
    can be applied to each side of a cube.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`CubeTexture`对象。`CubeTexture`是一组可以应用于立方体每个面的六个纹理。
- en: Set the skybox. When we have a `CubeTexture`, we can set it as the background
    of the scene. If we do this, we effectively create a very large box, inside of
    which the cameras and objects are placed, so that when we move the camera around,
    the background of the scene also changes correctly. Alternatively, we could also
    create a very large cube, apply `CubeTexture`, and add it to the scene ourselves.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置天空盒。当我们有一个`CubeTexture`时，我们可以将其设置为场景的背景。如果我们这样做，我们实际上创建了一个非常大的盒子，其中放置了摄像机和对象，这样当我们移动摄像机时，场景的背景也会正确地改变。或者，我们也可以创建一个非常大的立方体，应用`CubeTexture`，并将其添加到场景中。
- en: Set the `CubeTexture` object as a texture of the `cubeMap` property of the material.
    The same `CubeTexture` object that we used to simulate the environment should
    be used as a texture on the meshes. Three.js will make sure it looks like a reflection
    of the environment.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CubeTexture`对象设置为材质的`cubeMap`属性的纹理。用于模拟环境的同一个`CubeTexture`对象应作为网格的纹理使用。Three.js将确保它看起来像环境的反射。
- en: 'Creating a `CubeTexture` is pretty easy, once you have the source material.
    What you will need are six images that, together, make up a complete environment.
    So, you will need the following pictures:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`CubeTexture`相当简单，一旦你有了源材质。你需要的是六张图片，它们共同组成一个完整的环境。因此，你需要以下图片：
- en: Looking forward (`posz`)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上看（`posz`）
- en: Looking backward (`negz`)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后看（`negz`）
- en: Looking up (`posy`)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上看（`posy`）
- en: Looking down (`negy`)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向下看（`negy`）
- en: Looking right (`posx`)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向右看（`posx`）
- en: Looking left (`negx`)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左看（`negx`）
- en: 'Three.js will patch these together to create a seamless environment map. There
    are several sites where you can download panoramic images, but they are often
    in a spherical equirectangular format, which looks as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js会将这些拼接在一起以创建一个无缝的环境贴图。有几个网站可以下载全景图像，但它们通常是以球形等距圆环形格式，如下所示：
- en: '![Figure 10.23 – Equirectangular format cube map](img/Figure_10.23_B18726.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图10.23 – 等距圆环形格式立方体贴图](img/Figure_10.23_B18726.jpg)'
- en: Figure 10.23 – Equirectangular format cube map
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23 – 等距圆环形格式立方体贴图
- en: 'There are two ways you can use these kinds of maps. First, you can convert
    it into a cube map format consisting of six separate files. You can convert this
    online using the following site: [https://jaxry.github.io/panorama-to-cubemap/](https://jaxry.github.io/panorama-to-cubemap/).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两种方式使用这些类型的贴图。首先，你可以将其转换为包含六个单独文件的立方体贴图格式。你可以使用以下网站在线转换：[https://jaxry.github.io/panorama-to-cubemap/](https://jaxry.github.io/panorama-to-cubemap/)。
- en: Alternatively, you can use a different way to load this texture into Three.js,
    which we’ll show later in this section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用不同的方法将这种纹理加载到Three.js中，我们将在本节稍后展示。
- en: 'To load a `CubeTexture` from six separate files, we can use `THREE.CubeTextureLoader`,
    like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要从六个单独的文件中加载`CubeTexture`，我们可以使用`THREE.CubeTextureLoader`，如下所示：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, you can see that we’ve loaded a `cubeMap` out of several different images.
    Once loaded, we assign the texture to the `envMap` property of a material. Finally,
    we must inform Three.js of which kind of mapping we want to use. If you load a
    texture using `THREE.CubeTextureLoader`, you can use `THREE.CubeReflectionMapping`
    or `THREE.CubeRefractionMapping`. The first one will make your object show reflections
    based on the loaded `cubeMap`, while the second one will turn your model into
    a more translucent glass-like object that refracts the lights slightly, once again
    based on the information from `cubeMap`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们已经从几幅不同的图像中加载了一个`cubeMap`。一旦加载，我们将纹理分配给材料的`envMap`属性。最后，我们必须通知Three.js我们想要使用哪种类型的映射。如果你使用`THREE.CubeTextureLoader`加载纹理，你可以使用`THREE.CubeReflectionMapping`或`THREE.CubeRefractionMapping`。第一个将使你的对象根据加载的`cubeMap`显示反射，而第二个将使你的模型变成一个更透明的类似玻璃的对象，它稍微折射光线，再次基于`cubeMap`中的信息。
- en: 'We can also set this `cubeMap` as a background for the scene, like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这个`cubeMap`设置为场景的背景，如下所示：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you’ve got a single image, the process isn’t much different:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只有一张图片时，过程并没有太大不同：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, we used the normal texture loader, but by specifying a different
    `mapping`, we can inform Three.js how to render this texture. When using this
    approach, you can set the mapping to either `THREE.EquirectangularRefractionMapping`
    or `THREE.EquirectangularReflectionMapping`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用了正常的纹理加载器，但通过指定不同的`mapping`，我们可以通知Three.js如何渲染这个纹理。当使用这种方法时，你可以将映射设置为`THREE.EquirectangularRefractionMapping`或`THREE.EquirectangularReflectionMapping`。
- en: 'The result of both these approaches is a scene where it looks like we’re standing
    in a wide, outdoor environment, where the meshes reflect the environment. The
    menu on the side allows you to set the properties of the material:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的结果都是一个看起来我们站在一个宽敞的户外环境中的场景，其中网格反射环境。侧边菜单允许你设置材料的属性：
- en: '![Figure 10.24 – Using refraction to create glass-like objects](img/Figure_10.24_B18726.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图10.24 – 使用折射创建类似玻璃的对象](img/Figure_10.24_B18726.jpg)'
- en: Figure 10.24 – Using refraction to create glass-like objects
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24 – 使用折射创建类似玻璃的对象
- en: 'Aside from reflection, Three.js also allows you to use a `cubeMap` object for
    refraction (glass-like objects). The following screenshot shows this (you can
    test this yourself by using the menu on the right):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了反射之外，Three.js还允许你使用`cubeMap`对象进行折射（类似玻璃的对象）。以下截图展示了这一点（你可以通过使用右侧菜单来亲自测试）：
- en: '![Figure 10.25 – Using refraction to create glass-like objects](img/Figure_10.25_B18726.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图10.25 – 使用折射创建类似玻璃的对象](img/Figure_10.25_B18726.jpg)'
- en: Figure 10.25 – Using refraction to create glass-like objects
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25 – 使用折射创建类似玻璃的对象
- en: 'To get this effect, we only need to set the mapping property of `cubeMap` to
    `THREE.CubeRefractionMapping` (the default is the reflection, which can also be
    set manually by specifying `THREE.CubeReflectionMapping`):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到这种效果，我们只需要将`cubeMap`的映射属性设置为`THREE.CubeRefractionMapping`（默认是反射，也可以通过指定`THREE.CubeReflectionMapping`手动设置）：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, we used a static environment map for the meshes. In other
    words, we only saw the environment’s reflection and not the other meshes in the
    environment. In the following screenshot, you can see that, with a little bit
    of work, we can show the reflections of other objects as well:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为网格使用了静态环境贴图。换句话说，我们只看到了环境的反射，而没有看到环境中的其他网格。在下面的屏幕截图中，你可以看到，通过一点工作，我们也可以显示其他物体的反射：
- en: '![Figure 10.26 – Using a cubeCamera to create dynamic reflections](img/Figure_10.26_B18726.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图10.26 – 使用cubeCamera创建动态反射](img/Figure_10.26_B18726.jpg)'
- en: Figure 10.26 – Using a cubeCamera to create dynamic reflections
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26 – 使用cubeCamera创建动态反射
- en: 'To also show reflections from the other objects in the scene, we need to use
    some other Three.js components. The first of them is an additional camera called
    `THREE.CubeCamera`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示场景中其他物体的反射，我们需要使用一些其他的Three.js组件。其中第一个是一个额外的相机，称为`THREE.CubeCamera`：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will use `THREE.CubeCamera` to take a snapshot of the scene with all of the
    objects rendered and use that to set up a `cubeMap`. The first two arguments define
    the near and far properties of the camera. So, in this case, the camera only renders
    what it can see from 0.1 to 1.0\. The last property is the target to which we
    want to render the texture. For that, we’ve created an instance of a `THREE.WebGLCubeRenderTarget`.
    The first parameter is the size of the render target. The higher the value, the
    more detailed the reflection will look. The other two properties are used to determine
    how the texture is scaled up and down when you zoom in.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`THREE.CubeCamera`来捕捉场景中所有物体渲染后的快照，并使用它来设置一个`cubeMap`。前两个参数定义了相机的近处和远处属性。因此，在这种情况下，相机只渲染它从0.1到1.0可以看到的内容。最后一个属性是我们想要渲染纹理的目标。为此，我们创建了一个`THREE.WebGLCubeRenderTarget`的实例。第一个参数是渲染目标的大小。值越高，反射看起来越详细。其他两个属性用于确定在缩放时纹理如何放大和缩小。
- en: You need to make sure that you position this camera at the exact location of
    `THREE.Mesh` on which you want to show the dynamic reflections. In this example,
    we copied the position from the mesh so that the camera is positioned correctly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保将这个相机放置在你想要显示动态反射的`THREE.Mesh`的确切位置。在这个例子中，我们复制了网格的位置，以便相机正确定位。
- en: 'Now that we have `CubeCamera` set up correctly, we need to make sure that what
    `CubeCamera` sees is applied as a texture to the cube in our example. To do this,
    we must set the `envMap` property to `cubeCamera.renderTarget`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确设置了`CubeCamera`，我们需要确保`CubeCamera`所看到的内容被应用到我们示例中的立方体上。为此，我们必须将`envMap`属性设置为`cubeCamera.renderTarget`：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we have to make sure that `cubeCamera` renders the scene so that we can
    use that output as input for the cube. For this, we must update the render loop
    as follows (or if the scene doesn’t change, we can just call this once):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须确保`cubeCamera`渲染场景，这样我们就可以将输出用作立方体的输入。为此，我们必须更新渲染循环如下（或者如果场景没有变化，我们只需调用一次）：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, first, we disable the visibility of `mesh`. We do this because
    we only want to see reflections from the other objects. Next, we render the scene
    using `cubeCamera` by calling the `update` function. After that, we make `mesh`
    visible again and render the scene as normal. The result is that, in the reflection
    of `mesh`, you can see the cubes that we added. For this example, every time you
    click on the `updateCubeCamera` button, the `envMap` property of the mesh will
    be updated.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，首先，我们禁用了`mesh`的可见性。我们这样做是因为我们只想看到其他物体的反射。接下来，我们通过调用`update`函数使用`cubeCamera`渲染场景。之后，我们再次使`mesh`可见并正常渲染场景。结果是，在`mesh`的反射中，你可以看到我们添加的立方体。对于这个例子，每次你点击`updateCubeCamera`按钮时，网格的`envMap`属性都会被更新。
- en: Repeat wrapping
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复包装
- en: 'When you apply a texture to a geometry created by Three.js, Three.js will try
    to apply the texture as optimally as possible. For instance, for cubes, this means
    that each side will show the complete texture, and for spheres, the complete texture
    is wrapped around the sphere. However, there are situations where you won’t want
    the texture to spread around a complete face or the complete geometry, but rather
    have the texture repeat itself. Three.js provides functionality that allows you
    to control this. An example where you can play around with the repeat properties
    is provided in `texture-repeat-mapping.html`. The following screenshot shows this
    example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将纹理应用到由Three.js创建的几何体上时，Three.js会尽可能地优化纹理的应用。例如，对于立方体，这意味着每个面都会显示完整的纹理，而对于球体，完整的纹理会被包裹在球体上。然而，有些情况下你可能不希望纹理在整个面或整个几何体上扩散，而是希望纹理重复自身。Three.js提供了允许你控制这一点的功能。一个可以让你玩转重复属性的例子在`texture-repeat-mapping.html`中提供。以下截图展示了这个例子：
- en: '![Figure 10.27 – Repeat wrapping on a sphere](img/Figure_10.27_B18726.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图10.27 – 球体上的重复包裹](img/Figure_10.27_B18726.jpg)'
- en: Figure 10.27 – Repeat wrapping on a sphere
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27 – 球体上的重复包裹
- en: 'Before this property has the desired effect, you need to make sure that you
    set the wrapping of the texture to `THREE.RepeatWrapping`, as shown in the following
    code snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在此属性产生预期效果之前，你需要确保将纹理的包裹设置为`THREE.RepeatWrapping`，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `wrapS` property defines how you want the texture to wrap along its *X*-axis,
    and the `wrapT` property defines how the texture should be wrapped along its *Y*-axis.
    Three.js provides three options for this, which are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapS`属性定义了纹理沿其*X*轴如何包裹，而`wrapT`属性定义了纹理应沿其*Y*轴如何包裹。Three.js为此提供了三种选项，如下所示：'
- en: '`THREE.RepeatWrapping` allows the texture to repeat itself'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.RepeatWrapping`允许纹理重复自身'
- en: '`THREE.MirroredRepeatWrapping` allows the texture to repeat itself, but each
    repetition is mirrored'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.MirroredRepeatWrapping`允许纹理重复自身，但每次重复都是镜像的'
- en: '`THREE.ClampToEdgeWrapping` is a default setting where the texture doesn’t
    repeat as a whole; only the pixels at the edge are repeated'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.ClampToEdgeWrapping`是一个默认设置，其中纹理不会整体重复；只有边缘的像素会被重复'
- en: 'In this example, you can play around with the various repeat settings and `wrapS`
    and `wrapT` options. Once the wrapping type has been selected, we can set the
    `repeat` property, as shown in the following code fragment:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以玩转各种重复设置以及`wrapS`和`wrapT`选项。一旦选择了包裹类型，我们就可以设置`repeat`属性，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `repeatX` variable defines how often the texture is repeated along its *X*-axis,
    and the `repeatY` variable defines the same for the *Y*-axis. If these values
    are set to 1, the texture won’t repeat itself; if they are set to a higher value,
    you’ll see that the texture will start to repeat. You can also use values lower
    than 1\. In that case, you’ll zoom in on the texture. If you set the repeat value
    to a negative value, the texture will be mirrored.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeatX`变量定义了纹理沿其*X*轴重复的频率，而`repeatY`变量定义了沿*Y*轴的相同频率。如果这些值设置为1，纹理不会重复；如果它们设置为更高的值，你会看到纹理开始重复。你也可以使用小于1的值。在这种情况下，你会放大纹理。如果你将重复值设置为负值，纹理将被镜像。'
- en: 'When you change the `repeat` property, Three.js will automatically update the
    textures and render them with this new setting. If you change from `THREE.RepeatWrapping`
    to `THREE.ClampToEdgeWrapping`, you will have to explicitly update the texture
    using `mesh.material.map.needsUpdate =` `true;`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改`repeat`属性时，Three.js会自动更新纹理并使用这个新设置进行渲染。如果你从`THREE.RepeatWrapping`更改为`THREE.ClampToEdgeWrapping`，你必须显式地使用`mesh.material.map.needsUpdate
    = true;`来更新纹理：
- en: '![Figure 10.28 – Clamp to edge wrapping on a sphere](img/Figure_10.28_B18726.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图10.28 – 球体上的边缘包裹](img/Figure_10.28_B18726.jpg)'
- en: Figure 10.28 – Clamp to edge wrapping on a sphere
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28 – 球体上的边缘包裹
- en: So far, we’ve only used static images for our textures. However, Three.js also
    has the option to use the HTML5 canvas as a texture.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只为纹理使用了静态图像。然而，Three.js也有使用HTML5画布作为纹理的选项。
- en: Rendering to a canvas and using it as a texture
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将渲染输出到画布并用作纹理
- en: In this section, we will look at two different examples. First, we will look
    at how you can use the canvas to create a simple texture and apply it to a mesh;
    after that, we’ll go one step further and create a canvas that can be used as
    a bump map, using a randomly generated pattern.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看两个不同的示例。首先，我们将查看如何使用 `canvas` 创建一个简单的纹理并将其应用于网格；之后，我们将更进一步，创建一个可以用作凹凸映射的
    `canvas`，使用随机生成的图案。
- en: Using the canvas as a color map
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用canvas作为颜色映射
- en: 'In this first example, we’ll render a fractal to an HTML `Canvas` element and
    use that as a color map for our mesh. The following screenshot shows this example
    (`texture-canvas-as-color-map.html`):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们将渲染一个分形到HTML `Canvas` 元素上，并将其用作我们的网格的颜色映射。以下截图显示了此示例（`texture-canvas-as-color-map.html`）：
- en: '![Figure 10.29 – Using an HTML canvas as a texture](img/Figure_10.29_B18726.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图10.29 – 使用HTML canvas作为纹理](img/Figure_10.29_B18726.jpg)'
- en: Figure 10.29 – Using an HTML canvas as a texture
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29 – 使用HTML canvas作为纹理
- en: 'First, we’ll look at the code required to render the fractal:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看渲染分形所需的代码：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We won’t go into too much detail, but this library requires a `div` element
    as input and will create a `canvas` element inside that `div`. The preceding code
    will render the fractal, as you can see in the previous screenshot. Next, we need
    to assign this canvas to the `map` property of our material:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地深入细节，但这个库需要一个 `div` 元素作为输入，并在其中创建一个 `canvas` 元素。前面的代码将渲染分形，正如您在前面的截图中所看到的。接下来，我们需要将这个
    `canvas` 分配给我们的材质的 `map` 属性：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we just create a new `THREE.Texture` and pass in the reference to the
    `canvas` element. The only thing we need to do is set `material.map.needsUpdate`
    to `true`, which will trigger Three.js to get the latest information from the
    `canvas` element, at which point we will see it applied to the mesh.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是创建一个新的 `THREE.Texture` 并传入 `canvas` 元素的引用。我们唯一需要做的是将 `material.map.needsUpdate`
    设置为 `true`，这将触发Three.js从 `canvas` 元素获取最新信息，此时我们将看到它应用于网格。
- en: We can, of course, use this same idea for all of the different types of maps
    that we’ve seen so far. In the next example, we’ll use the canvas as a bump map.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以使用这个相同的概念来处理我们迄今为止看到的所有不同类型的映射。在下一个示例中，我们将使用 `canvas` 作为凹凸映射。
- en: Using the canvas as a bump map
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用canvas作为凹凸映射
- en: As you saw earlier in this chapter, we can add height to our model using a bump
    map. The higher the intensity of a pixel in this map, the higher the wrinkling.
    Since a bump map is just a simple black-and-white image, nothing keeps us from
    creating it on a canvas and using that canvas as an input for the bump map.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本章前面所见，我们可以使用凹凸映射给我们的模型添加高度。在这个映射中，像素的强度越高，皱纹就越高。由于凹凸映射只是一个简单的黑白图像，没有什么阻止我们在
    `canvas` 上创建它，并使用该 `canvas` 作为凹凸映射的输入。
- en: 'In the following example, we will use a canvas to generate a Perlin noise-based
    grayscale image, and we will use that image as input for the bump map that we
    apply to the cube. See the `texture-canvas-as-bump-map.html` example. The following
    screenshot shows this example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用 `canvas` 生成基于Perlin噪声的灰度图像，并将其用作我们应用于立方体的凹凸映射的输入。请参阅 `texture-canvas-as-bump-map.html`
    示例。以下截图显示了此示例：
- en: '![Figure 10.30 – Using an HTML canvas as a bump map](img/Figure_10.30_B18726.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图10.30 – 使用HTML canvas作为凹凸映射](img/Figure_10.30_B18726.jpg)'
- en: Figure 10.30 – Using an HTML canvas as a bump map
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30 – 使用HTML canvas作为凹凸映射
- en: 'The approach for this is pretty much the same as we saw in the previous canvas
    example. We need to create a canvas element and fill that canvas with some noise.
    To do so, we must use Perlin noise. Perlin noise generates a very natural-looking
    texture, as you can see in the preceding screenshot. More information on Perlin
    noise and other noise generators can be found here: [https://thebookofshaders.com/11/](https://thebookofshaders.com/11/).
    The code to accomplish this is shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法基本上和我们在之前的 `canvas` 示例中看到的方法相同。我们需要创建一个 `canvas` 元素，并在其中填充一些噪声。要做到这一点，我们必须使用Perlin噪声。Perlin噪声生成一个非常自然的外观纹理，正如您在前面的截图中所看到的。有关Perlin噪声和其他噪声生成器的更多信息，请参阅此处：[https://thebookofshaders.com/11/](https://thebookofshaders.com/11/)。完成此操作的代码如下所示：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We use the `generator.noise.perlin2` function to create a value from 0 to 1,
    based on the `x` and `y` coordinates of the `canvas` element. This value is used
    to draw a single pixel on the `canvas` element. Doing this for all the pixels
    creates the random map that you can see in the top-left corner of the preceding
    screenshot. This map can then be used as a bump map:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`generator.noise.perlin2`函数根据`canvas`元素的`x`和`y`坐标创建一个0到1之间的值。这个值用于在`canvas`元素上绘制单个像素。对所有像素执行此操作将创建你可以在前一个截图的左上角看到的随机地图。这个地图然后可以用作凹凸贴图：
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using a THREE.DataTexture for a dynamic texture
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用THREE.DataTexture创建动态纹理
- en: 'In this example, we rendered Perlin noise using an HTML `canvas` element. Three.js
    also provides an alternative way to dynamically create a texture: you can create
    a `THREE.DataTexture` texture, where you can pass in a `Uint8Array` where you
    can directly set the RGB values. More information on how to use a `THREE.DataTexture`
    can be found here: [https://threejs.org/docs/#api/en/textures/DataTexture](https://threejs.org/docs/#api/en/textures/DataTexture).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用HTML `canvas`元素渲染了Perlin噪声。Three.js还提供了一个动态创建纹理的替代方法：你可以创建一个`THREE.DataTexture`纹理，其中你可以传递一个`Uint8Array`，你可以直接设置RGB值。有关如何使用`THREE.DataTexture`的更多信息，请参阅此处：[https://threejs.org/docs/#api/en/textures/DataTexture](https://threejs.org/docs/#api/en/textures/DataTexture)。
- en: 'The final input that we use for the texture is another HTML element: the HTML5
    video element.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于纹理的最终输入是另一个HTML元素：HTML5视频元素。
- en: Using the output from a video as a texture
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视频输出作为纹理
- en: 'If you read the preceding section on rendering to a canvas, you may have thought
    about rendering video to a canvas and using that as input for a texture. That’s
    one way to do it, but Three.js already has direct support to use the HTML5 video
    element (through WebGL). Check out `texture-canvas-as-video-map.html`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了关于将渲染到canvas的前一节，你可能已经考虑过将视频渲染到canvas上，并使用它作为纹理的输入。这是其中一种方法，但Three.js已经直接支持使用HTML5视频元素（通过WebGL）。查看`texture-canvas-as-video-map.html`：
- en: '![Figure 10.31 – Using an HTML video as a texture](img/Figure_10.31_B18726.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图10.31 – 使用HTML视频作为纹理](img/Figure_10.31_B18726.jpg)'
- en: Figure 10.31 – Using an HTML video as a texture
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.31 – 使用HTML视频作为纹理
- en: 'Using video as input for a texture is easy, just like using the canvas element.
    First, we need a video element to play the video:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将视频作为纹理的输入非常简单，就像使用canvas元素一样。首先，我们需要一个视频元素来播放视频：
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This creates a basic HTML5 `video` element, by setting the HTML string directly
    to the `innerHTML` property of the `div` element. While this works great for testing,
    frameworks and libraries usually provide better options for this. Next, we can
    configure Three.js to use the video as an input for a texture, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接将HTML字符串设置到`div`元素的`innerHTML`属性中，创建了一个基本的HTML5 `video`元素。虽然这对于测试来说效果很好，但框架和库通常提供更好的选项。接下来，我们可以配置Three.js使用视频作为纹理的输入，如下所示：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The result can be seen in the `texture-canvas-as-video-map.html` example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在`texture-canvas-as-video-map.html`示例中看到。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, we have completed this chapter on textures. As you’ve seen, a lot
    of textures are available in Three.js, each with a different use. You can use
    any image in PNG, JPG, GIF, TGA, DDS, PVR, TGA, KTX, EXR, or RGBE format as a
    texture. Loading these images is done asynchronously, so remember to either use
    a rendering loop or add a callback when you load a texture. With the different
    types of textures available, you can create great-looking objects from low-poly
    models.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了关于纹理的这一章。正如你所看到的，Three.js中有许多纹理可供使用，每种纹理都有不同的用途。你可以使用任何PNG、JPG、GIF、TGA、DDS、PVR、TGA、KTX、EXR或RGBE格式的图像作为纹理。加载这些图像是异步进行的，所以记得在加载纹理时使用渲染循环或添加回调。有了不同类型的纹理，你可以从低多边形模型创建出外观出色的对象。
- en: With Three.js, it is also easy to create dynamic textures, using either the
    HTML5 `canvas` element or the `video` element – just define a texture with these
    elements as the input, and set the `needsUpdate` property to `true` whenever you
    want the texture to be updated.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Three.js，创建动态纹理也很容易，可以使用HTML5 `canvas`元素或`video`元素——只需定义一个以这些元素为输入的纹理，并在需要更新纹理时将`needsUpdate`属性设置为`true`。
- en: 'With this chapter out of the way, we’ve pretty much covered all of the important
    concepts of Three.js. However, we haven’t looked at an interesting feature that
    Three.js offers: postprocessing. With postprocessing, you can add effects to your
    scene after it has been rendered. You can, for instance, blur or colorize your
    scene, or add a TV-like effect using scan lines. In [*Chapter 11*](B18726_11.xhtml#_idTextAnchor192),
    *Render Postprocessing*, we’ll look at postprocessing and how you can apply it
    to your scene.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们基本上已经涵盖了Three.js的所有重要概念。然而，我们还没有探讨Three.js提供的一个有趣特性：后处理。通过后处理，你可以在场景渲染后添加效果。例如，你可以模糊或着色你的场景，或者使用扫描线添加类似电视的效果。在[*第11章*](B18726_11.xhtml#_idTextAnchor192)，*渲染后处理*中，我们将探讨后处理以及如何将其应用于你的场景。
- en: 'Part 4: Post-Processing, Physics, and Sounds'
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：后处理、物理和声音
- en: In this final part, we’ll look at a couple of more advanced topics. We’ll explain
    how you can set up a post-processing pipeline, which can be used to add different
    kinds of effects to the final rendered scene. We’ll also introduce the Rapier
    physics engine, and explain how you can use Three.js and Blender together. We
    end this part with information on how Three.js can be used together with React,
    TypeScript, and the Web-XR standard.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一部分，我们将探讨一些更高级的主题。我们将解释如何设置一个后处理管道，它可以用来向最终渲染的场景添加不同类型的特效。我们还将介绍Rapier物理引擎，并解释如何将Three.js和Blender结合使用。本部分结束时，我们将提供关于如何将Three.js与React、TypeScript和Web-XR标准结合使用的信息。
- en: 'In this part, there are the following chapters:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，有以下章节：
- en: '[*Chapter 11*](B18726_11.xhtml#_idTextAnchor192), *Render Postprocessing*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18726_11.xhtml#_idTextAnchor192)，*渲染后处理*'
- en: '[*Chapter 12*](B18726_12.xhtml#_idTextAnchor212), *Adding Physics and Sounds
    to Your Scene*'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18726_12.xhtml#_idTextAnchor212)，*为你的场景添加物理和声音*'
- en: '[*Chapter 13*](B18726_13.xhtml#_idTextAnchor227), *Working with Blender and
    Three.js*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18726_13.xhtml#_idTextAnchor227)，*与Blender和Three.js一起工作*'
- en: '[*Chapter 14*](B18726_14.xhtml#_idTextAnchor240), *Three.js Together with React,
    Typescript, and Web-XR*'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18726_14.xhtml#_idTextAnchor240)，*Three.js与React、TypeScript和Web-XR结合使用*'
