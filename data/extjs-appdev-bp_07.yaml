- en: Chapter 7. Practical – an E-mail Client
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 实践 - 邮件客户端
- en: Our past two applications have been fairly straightforward examples, but ones
    that are useful to illustrate how to create a strong foundation for a future,
    more extensive product. In this chapter, we'll build a fully featured webmail
    client that will provide a tailored experience for users of both desktop browsers
    and smaller devices such as tablets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过去两个应用程序是相当直接的例子，但它们对于说明如何为未来的更广泛产品创建一个强大的基础是有用的。在本章中，我们将构建一个功能齐全的Web邮件客户端，将为桌面浏览器和较小设备（如平板电脑）的用户提供定制体验。
- en: 'Everyone knows the traditional e-mail interface, but we''ll try and at the
    same time show how Ext JS technologies can be used to make short work of building
    such an application. Here''s the breakdown of what we''ll be doing in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道传统的电子邮件界面，但我们将尝试同时展示如何使用Ext JS技术快速构建此类应用程序。以下是本章我们将要执行的操作分解：
- en: Establishing essential requirements for the application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确立应用程序的基本需求
- en: Coming up with an ideal user interface for each form factor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个形态因子提出理想的用户界面
- en: Analyzing the issues that may arise on a smaller screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析在小屏幕上可能出现的問題
- en: Designing the view and controller structure to present and orchestrate it all
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计视图和控制器的结构以呈现和协调所有内容
- en: Evaluating the design of our application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估我们应用程序的设计
- en: Along the way we'll reinforce our knowledge of routing and view models, as well
    as undertaking constant re-evaluation of our work to ensure the quality of the
    code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将加强我们对路由和视图模型的知识，并不断重新评估我们的工作以确保代码的质量。
- en: We'll also take a little more time to finish the design of this application,
    dipping our toe in the water of Ext JS theming. While we won't be building a full
    replacement theme, we'll touch on some of the places where the theming system
    should be used in order to improve the maintainability of your application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将花更多的时间来完成这个应用程序的设计，涉足Ext JS主题化的领域。虽然我们不会构建一个完整的替代主题，但我们会触及一些应该使用主题化系统来提高您应用程序可维护性的地方。
- en: Form factors
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形态因子
- en: This application will adapt to a variety of devices, from desktop browsers to
    tablets and mobile phones. The size of these devices is often called the "form
    factor" and Ext JS provides several mechanisms that allow you to customize the
    user experience depending on the form factor of the device being used.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将适应各种设备，从桌面浏览器到平板电脑和手机。这些设备的尺寸通常被称为“形态因子”，Ext JS提供了几种机制，允许您根据所使用的设备的形态因子来定制用户体验。
- en: In this chapter, we'll focus on `responsiveConfig`, an option available when
    you include the `Ext.mixin.Responsive` class in your views. In a standard desktop
    application, we might have two components side by side in the viewport, since
    desktop screen sizes are generally wider than they are tall. On a mobile phone,
    users will often be in portrait orientation, so this is no longer true; the screen
    is taller than it is wide. In this case, we can use `responsiveConfig` to override
    the original side-by-side configuration and use different layouts, items, and
    component widths—in fact any aspect of the original viewport configuration—and
    change the appearance and behavior of the application for a taller screen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注`responsiveConfig`，这是在您的视图中包含`Ext.mixin.Responsive`类时可用的一项选项。在标准桌面应用程序中，我们可能在视口中并排放置两个组件，因为桌面屏幕的宽度通常大于高度。在手机上，用户通常会处于纵向模式，因此这不再成立；屏幕的高度大于宽度。在这种情况下，我们可以使用`responsiveConfig`来覆盖原始的并排配置，并使用不同的布局、项目和组件宽度——实际上可以是原始视口配置的任何方面——并改变应用程序在更高屏幕上的外观和行为。
- en: This one feature provides us with an exceptionally powerful means to deliver
    an experience that is tailored to a particular form factor. In this chapter, we'll
    see some practical examples of implementing `responsiveConfig`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这一项特性为我们提供了一种异常强大的方式，以提供针对特定形态因子的定制体验。在本章中，我们将看到一些实现`responsiveConfig`的实际示例。
- en: Application design
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序设计
- en: 'What features do we expect from an e-mail client? At a minimum:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望从电子邮件客户端中获得哪些功能？至少：
- en: '**Login**: This helps to gain access to your own account'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录**：这有助于获取对您自己的账户的访问权限'
- en: '**Inbox**: This is a list of our e-mails'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收件箱**：这是我们的电子邮件列表'
- en: '**Sent**: This is a list of e-mails we''ve sent in the past'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已发送**：这是我们过去发送的电子邮件列表'
- en: '**Archive**: This is a list of e-mails we''ve disposed of'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存档**：这是我们已处理的电子邮件列表'
- en: '**Composer**: This helps to write e-mails'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撰写器**：这有助于撰写电子邮件'
- en: '**Search**: This helps to find archived e-mails'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：这有助于找到归档电子邮件'
- en: 'The final version of the app looks something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的最后版本看起来大致如下：
- en: '![Application design](img/5308OT_07_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计](img/5308OT_07_01.jpg)'
- en: The thread view on the left and messages from the selected thread on the right
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的线程视图和右侧所选线程的消息
- en: 'What do we need to do to get to this point? Let''s sketch out a design:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做什么才能达到这个阶段？让我们绘制一个设计草图：
- en: '![Application design](img/5308OT_07_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计](img/5308OT_07_02.jpg)'
- en: 'The login page is pretty standard. We''ll want to validate user input, check
    the e-mail address, and ensure the password isn''t blank, but there really isn''t
    anything out of the ordinary here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面相当标准。我们希望验证用户输入，检查电子邮件地址，并确保密码不为空，但这里并没有什么特别之处：
- en: '![Application design](img/5308OT_07_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计](img/5308OT_07_03.jpg)'
- en: Here's the main interface for the application. We'll be implementing threaded
    e-mail; we have a list of threads on the left with an excerpt of the most recent
    message showing as the description of the thread. The date of the last message
    is shown on the left-hand side of each thread. On the right-hand side, we show
    the selected message thread, most recent message last. Each message has its received
    date on its left. The thread has a **Reply** button and a dropdown to allow the
    thread to be tagged, more on this shortly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的主要界面。我们将实现线程化电子邮件；我们在左侧有一个线程列表，显示最近消息的摘录作为线程的描述。每个线程的最后一封消息的日期显示在每个线程的左侧。在右侧，我们显示所选的消息线程，最新的消息在最后。每条消息在其左侧显示接收日期。线程有一个**回复**按钮和一个下拉菜单，允许对线程进行标记，稍后会有更多介绍。
- en: At the top of the screen we have a logo (from left to right), an icon for the
    **Contacts** section, a **search** bar, a button to create a new e-mail, and finally,
    a dropdown to filter threads by tag.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕顶部，我们有一个标志（从左到右），**联系人**部分的图标，一个**搜索**栏，一个创建新电子邮件的按钮，最后是一个下拉菜单，用于按标签筛选线程。
- en: The **search** bar will cause matching message threads to appear below (in the
    same style as the **Inbox** view).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索**栏会导致匹配的消息线程出现在下方（与**收件箱**视图相同的样式）。'
- en: Rather than having separate screens for archived e-mail, sent e-mail, and so
    on, we make the assumption that **Inbox** threads are just untagged threads. When
    they are tagged—either automatically as "sent" or by some other arbitrary tag
    such as "home" or "work"—then they are removed from the **Inbox** view, as shown
    in the following screenshot. This concept is found in many e-mail clients, for
    example, Gmail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是为归档电子邮件、已发送电子邮件等设置单独的屏幕，我们假设**收件箱**线程只是未标记的线程。当它们被标记——无论是自动标记为“已发送”还是其他任意的标签，如“主页”或“工作”——它们就会从**收件箱**视图中移除，如下面的截图所示。这个概念在许多电子邮件客户端中都有，例如Gmail。
- en: '![Application design](img/5308OT_07_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序设计](img/5308OT_07_04.jpg)'
- en: When composing new e-mails, it takes place in the right-hand position. As there
    is no selected thread at this time, the space is clear to be occupied by a panel
    that contains a combo box to choose a recipient for the e-mail, a basic HTML editor
    for the e-mail itself, and a **Send** button.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写新电子邮件时，它位于右侧位置。由于此时没有选择任何线程，因此空间清晰，可以由包含组合框以选择电子邮件收件人、电子邮件本身的简单HTML编辑器和**发送**按钮的面板占用。
- en: Replying to an e-mail works in a similar way; the composer panel appears under
    the messages and allows the user to write a response.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回复电子邮件的方式类似；作曲面板出现在消息下方，允许用户撰写回复。
- en: 'A couple more items to note are that the user will start off with a number
    of default tags:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的另一些事项是，用户将开始时有一系列默认标签：
- en: Draft
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 草稿
- en: Archive
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档
- en: Spam
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾邮件
- en: Work
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作
- en: Home
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页
- en: When selecting a tag for a thread, the user can easily add another by typing
    in the combo box.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当为线程选择标签时，用户可以通过在组合框中输入轻松添加另一个标签。
- en: I require to admire
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我需要表示钦佩
- en: As architects of a product, we always need to consider how to make our product
    exemplary, how to make sure the user experience is a good one, how to exceed the
    expectations of our stakeholders. The starting step is to work out in exacting
    detail the facets on the product we'd like to build.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为产品的架构师，我们始终需要考虑如何使我们的产品成为典范，如何确保用户体验良好，如何超越利益相关者的期望。第一步是详细规划我们想要构建的产品各个方面的细节。
- en: Technically speaking
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术上讲
- en: How do the requirements we've spelled out translate into the underlying tech?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确提出的这些需求如何转化为底层技术？
- en: We want to display a login form with a "remember me" feature, so we need some
    kind of persistent storage
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望显示一个带有“记住我”功能的登录表单，因此我们需要某种持久存储
- en: We want to display thread data in a custom format
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望以自定义格式显示线程数据
- en: We want to display full message threads in a custom format
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望以自定义格式显示完整的消息线程
- en: We want a basic HTML editor for message bodies
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个基本的 HTML 编辑器用于消息正文
- en: We need an autocomplete box for recipients
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个自动完成框用于收件人
- en: We need to display search results in the same format as message threads
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要以与消息线程相同的格式显示搜索结果
- en: We need an autocomplete box for tags to be used in various locations
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个自动完成框用于在各个位置使用标签
- en: 'Let''s translate each of these into Ext JS features:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些翻译成 Ext JS 功能：
- en: We can use cookies or local storage to hold login information between systems
    (either using native browser methods or an Ext JS-powered session class)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 cookie 或本地存储在系统之间（使用原生浏览器方法或 Ext JS 驱动的会话类）保存登录信息
- en: We can use an Ext JS DataView to create a templated view of thread data
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 Ext JS DataView 创建线程数据的模板视图
- en: We can use an Ext JS DataView to create a templated view of message data
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 Ext JS DataView 创建消息数据的模板视图
- en: Ext JS provides an HTML editor widget
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 提供了一个 HTML 编辑器小部件
- en: The Ext JS combo box can be powered by a store that retrieves remote contact
    data
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 组合框可以由一个检索远程联系人数据的存储提供支持
- en: We can reuse the message thread DataView with a different store
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用不同的存储来重用消息线程 DataView
- en: We can use the `editable:true` option of the Ext JS combo box in cases where
    we need to add new tags
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要添加新标签的情况下，我们可以使用 Ext JS 组合框的 `editable:true` 选项
- en: There are a couple of gray areas there that we'll review later, but it does
    look like Ext JS can provide all of the features we're going to need to build
    this application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个灰色区域，我们稍后会进行审查，但看起来 Ext JS 可以提供我们构建此应用程序所需的所有功能。
- en: Responding to the situation
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对情况的响应
- en: 'There''s another requirement in this project: a responsive design that works
    on devices with smaller screens. Well, it turns out that the UI we''ve come up
    with already looks pretty good on a tablet, with one caveat. You have to be holding
    the device in landscape mode. This is a problem that you don''t really have to
    consider on the desktop, but it becomes critical with mobile devices.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此项目中还有一个要求：适用于较小屏幕设备的响应式设计。好吧，事实证明，我们提出的 UI 在平板电脑上看起来已经相当不错，只有一个缺点。你必须以横向模式握持设备。这是一个在桌面上你不必真正考虑的问题，但在移动设备上变得至关重要。
- en: From an architectural standpoint, we need to understand how the layout of the
    application will differ between screen sizes in order to decide how to assemble
    the application. In the designs so far, there are two panes side by side; there
    simply won't be enough screen space to allow for this on a portrait phone or tablet.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构角度来看，我们需要了解应用程序在不同屏幕尺寸下的布局差异，以便决定如何组装应用程序。在设计到目前为止，有两个面板并排；在竖屏手机或平板电脑上根本不会有足够的屏幕空间来允许这样做。
- en: Instead, we'll hide or show the "left" and "right" panes depending on user actions.
    If they click on a thread of messages or the **New Message** button, the threads
    will be hidden and the correct right-hand pane will appear.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将根据用户操作隐藏或显示“左侧”和“右侧”面板。如果他们点击消息线程或**新消息**按钮，线程将被隐藏，并显示正确的右侧面板。
- en: 'The only other issue with a portrait screen is the application header; there
    are too many components in there to fit in the width of a smaller screen. Instead,
    we''ll show a menu button when in portrait mode that hides some controls when
    toggled and shows others. This gives us a second level of menu that''s only shown
    when the user needs it. Here''s a mockup of some of these ideas:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在竖屏模式下，唯一的另一个问题是应用程序标题栏；其中包含太多组件，无法适应较小屏幕的宽度。相反，我们将显示一个菜单按钮，在竖屏模式下切换时隐藏一些控件并显示其他控件。这为我们提供了一个仅在用户需要时才显示的二级菜单。以下是这些想法的一些原型：
- en: '![Responding to the situation](img/5308OT_07_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![对情况的响应](img/5308OT_07_07.jpg)'
- en: When clicking on one of the messages in the left screenshot, the list is replaced
    by the message thread seen in the right-hand side screenshot.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击左侧截图中的其中一条消息时，列表被右侧截图中的消息线程所取代。
- en: In an HTML-based responsive website, CSS media queries can be used to style
    the page in a fashion appropriate for any screen and orientation. While we can
    obviously still make use of CSS alongside Ext JS to do customization, our requirements
    are more complex; can Ext JS provide any extra features to assist?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于HTML的响应式网站上，可以使用CSS媒体查询以适合任何屏幕和方向的样式来设计页面。虽然我们显然仍然可以使用CSS与Ext JS一起进行定制，但我们的需求更为复杂；Ext
    JS 能提供任何额外的功能来协助吗？
- en: 'The `responsive` plugin allows developers to tailor any component configuration
    based on a set of rules relating to the current device screen. Here are a few
    example scenarios in a theoretical responsive application:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`responsive`插件允许开发者根据与当前设备屏幕相关的规则集定制任何组件配置。以下是在一个理论上的响应式应用中的几个示例场景：'
- en: If the screen is less than 500 pixels wide, collapse the sidebar panel by default
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果屏幕宽度小于500像素，默认折叠侧边栏面板
- en: If the screen is in landscape mode, show a new column of data
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果屏幕处于横幅模式，显示新的数据列
- en: If the device is an iOS tablet, apply a different CSS class
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设备是iOS平板，应用一个不同的CSS类
- en: 'In the webmail application, we''ve already mentioned showing and hiding header
    items. This can be done something like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络邮件应用中，我们已经提到过显示和隐藏标题项。这可以这样做：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There's a built-in rule called "portrait" that allows you to specify a configuration
    object that will only be applied when the rule is in effect. As architects, we
    must carefully consider the best way of making use of this feature without ending
    up with lots of messy configuration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个内置的规则称为“portrait”，它允许你指定一个配置对象，该对象仅在规则生效时应用。作为架构师，我们必须仔细考虑如何最好地利用这个特性，而不会导致大量混乱的配置。
- en: In the desktop version of the application we have two panes side by side. For
    this, we can use the `hbox` layout. However, for the portrait orientation, we'd
    like to be able to switch between one pane and another. This seems like a good
    use of the card layout. We'll also have to consider how to trigger the switch
    of the panes and have this code run in portrait orientation only.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的桌面版本中，我们有两个并排的窗格。为此，我们可以使用`hbox`布局。然而，对于纵向模式，我们希望能够在一个窗格和另一个窗格之间切换。这似乎是卡片布局的一个很好的应用。我们还得考虑如何触发窗格的切换，并确保这段代码只在纵向模式下运行。
- en: The important takeaway is that the responsive plugin—in a similar fashion to
    view models—allows you to avoid writing lots of glue code that responds to the
    state of the application environment, and instead lets us declare our intentions
    at configuration time. After this, Ext JS takes care of most of the rest.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的收获是，响应式插件——类似于视图模型——允许你避免编写大量响应应用环境状态的粘合代码，而是让我们在配置时声明我们的意图。之后，Ext JS 会处理大部分剩余的工作。
- en: This is another example in which analyzing the requirements with a strong understanding
    of the available technology can result in a simpler architecture and a clearer
    code base.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是另一个例子，通过深入理解现有技术，分析需求可以导致更简单的架构和更清晰的代码库。
- en: Input required
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必须输入
- en: In previous chapters, we've gone into detail about the API we're going to be
    communicating with. There's no denying that it's one of the key parts of any application
    design; in fact many projects can live or die based on the quality of the API
    they're integrating with, but we've discussed this in the past two chapters and
    we've still got a lot to cover. From here on, we're generally going to assume
    that we're working with a well-designed RESTful API that works well with Ext JS.
    This'll give us some room to concentrate on some new ideas.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经详细介绍了我们将要与之通信的API。不可否认的是，它是任何应用设计的关键部分；事实上，许多项目能否成功或失败取决于它们集成的API的质量，但我们已经在过去两章中讨论过这个问题，我们还有很多内容要覆盖。从现在开始，我们将一般假设我们正在与一个设计良好的RESTful
    API一起工作，它与Ext JS配合良好。这将给我们一些空间来集中精力考虑一些新的想法。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: That's not to say you can skip over the API when designing your application.
    It is very rare you'll be working with a perfect backend, so keep analyzing whether
    the server is providing the endpoints you need.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说在设计应用时可以跳过API。你很少会与一个完美的后端一起工作，所以请持续分析服务器是否提供了你需要的端点。
- en: 'We''ll move on to looking at the rest of the application, but in a different
    way to previous chapters; once the data''s been pulled down from the server, we''ll
    try and consider how it''s going to move through our app. We''ll also look at
    two other facets of the design in more detail: routing and events. Why this change
    in direction compared to previous chapters?'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续查看应用程序的其余部分，但与之前的章节不同；一旦从服务器拉取了数据，我们将尝试考虑它将如何通过我们的应用程序。我们还将更详细地查看设计的两个其他方面：路由和事件。与之前的章节相比，为什么会有这样的方向变化？
- en: 'As our applications become more complicated, we have to continually think about
    how to keep that complexity under control. These three features: view models,
    events, and routing, all allow a "fire and forget" attitude, wire up some basic
    configuration, trigger an action at the source, and this bit of code is done.
    Somewhere else in the application will subscribe to this action—be it a view model
    binding, a routing change or the firing of an event—and consume it accordingly.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序变得更加复杂，我们必须不断思考如何保持这种复杂性在可控范围内。这三个功能：视图模型、事件和路由，都允许一种“发射后不管”的态度，配置一些基本设置，在源处触发一个动作，这段代码就完成了。在应用程序的某个地方将订阅这个动作——无论是视图模型绑定、路由更改还是事件的触发——并相应地消费它。
- en: We'll first identify our views and controllers as we have in the past and look
    at how this will inform the routing, view models and events that will power the
    functionality of our application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先识别我们的视图和控制器，就像我们过去做的那样，并查看这将如何影响路由、视图模型和事件，它们将推动我们应用程序的功能。
- en: A view to a thrill
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一览众山小
- en: 'Let''s break down the major views that will make up the main screen of the
    application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解构成应用程序主屏幕的主要视图：
- en: '![A view to a thrill](img/5308OT_07_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![一览众山小](img/5308OT_07_05.jpg)'
- en: '1: header view, 2: thread view, 3: message view, and 4: composer view; main
    view encompasses views 1 - 4'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 1：标题视图，2：线程视图，3：消息视图，4：编辑器视图；主视图包含视图1-4
- en: The login view is the simplest; a self-contained view, view controller, and
    a view model to bind with the values of the login form. It's not shown in the
    preceding mockup because it's the only one on the screen at the time, almost standalone.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 登录视图是最简单的；一个自包含的视图、视图控制器和视图模型来绑定登录表单的值。它在上面的原型图中没有显示，因为它在那时是屏幕上唯一的视图，几乎是独立的。
- en: There's a caveat to this. For the first time, we'll be using an over-arching
    controller to deal with the interactions between views. In the previous chapter,
    this was left to the "main" view controller, since the "main" view was the container
    for every part of our application. Here, the login view and the rest of the application
    are effectively independent from each other and so it makes sense to have a "third
    party" helping them to work together.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个注意事项。对于第一次，我们将使用一个总控制器来处理视图之间的交互。在前一章中，这被留给了“主要”视图控制器，因为“主要”视图是包含我们应用程序所有部分的容器。在这里，登录视图和应用程序的其余部分实际上是相互独立的，因此有“第三方”帮助他们一起工作是有意义的。
- en: 'We''ll call this top-level controller our "root" controller. It''s not a view
    controller, but a completely self-contained class that is responsible for showing
    the login view and reacting to a successful login. To formalize this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个顶级控制器称为我们的“根”控制器。它不是一个视图控制器，而是一个完全自包含的类，负责显示登录视图并对成功的登录做出反应。为了正式化这一点：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The login view controller is responsible for processing a login attempt and
    after doing so, it will fire off the appropriate actions. Along with its view
    and view model, it looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 登录视图控制器负责处理登录尝试，并在这样做之后，将触发适当的动作。连同其视图和视图模型，它看起来像这样：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Assuming the `onLoginClick` method is successful, we'll move on to the main
    screen of the application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`onLoginClick`方法成功，我们将继续到应用程序的主屏幕。
- en: Mainly harmless
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要无害
- en: 'As in previous chapters, the main view is the viewport that contains the other
    views in the application, such as the application header and the list of threads.
    According to our design, the view should look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，主要视图是包含应用程序中其他视图的视口，例如应用程序标题和线程列表。根据我们的设计，视图应该看起来像这样：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A couple of things to note here, the primary views that make up our application
    are mentioned here: header, threads, messages and, composer. We''re also doing
    a bit of forward thinking regarding our design, in that the composer and messages
    views are enclosed in a separate container.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的事项，组成我们应用程序的主要视图在这里被提及：头部、线程、消息和，作曲家。我们也在设计上做了一些前瞻性的思考，即作曲家和消息视图被包含在一个单独的容器中。
- en: 'This will allow us to more easily work with the Ext JS layout system, having
    the threads view and this anonymous container in an `hbox` arrangement. The view
    model looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够更轻松地与Ext JS布局系统一起工作，将线程视图和这个匿名容器以`hbox`排列。视图模型看起来如下：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It''s just convenient for a few pieces of state that need to be shared between
    the views contained in the main view. The view controller looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了方便在主视图中的视图之间共享一些需要共享的状态。视图控制器看起来如下：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first method (`onLogout`) will handle clicks on a logout button. The next
    four methods on the main view controller will be triggered by routing, and will
    be responsible for setting changes in the state of the application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法（`onLogout`）将处理退出按钮的点击。主视图控制器上的下一个四个方法将由路由触发，并将负责设置应用程序状态的变化。
- en: Remember that the main view and its associated classes don't really have any
    functionality of their own; they're responsible for orchestrating all of the other
    application parts contained within.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，主视图及其相关类实际上并没有自己的功能；它们负责协调所有包含在其中的其他应用程序部分。
- en: Full steam ahead
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全速前进
- en: 'The first child view of the main viewport is the header view, containing a
    number of components that are available anywhere in the application as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 主视口的第一个子视图是头部视图，其中包含一些在任何地方都可以使用的组件，如下所示：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s actually a surprising amount happening here. We also have to bear
    in mind that this is the target for one of our portrait orientation pieces of
    functionality, so there will be some usage of the responsive plugin in our implementation,
    as shown in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这里发生了很多令人惊讶的事情。我们还要考虑到这是我们的纵向功能之一的目标，因此我们的实现中将会使用响应式插件，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These methods are event listeners that will in turn trigger further functionality.
    You might wonder why we don''t have handlers to toggle the menu open and closed
    or to choose an item from the combo box. Think about data binding. If we bind
    the state of the menu button and the combo box to a view model, other components
    can bind to the values in the view model and will receive updates without us having
    to write any glue code. To this end, the header view model will look like:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是事件监听器，进而触发进一步的功能。你可能想知道为什么我们没有处理菜单打开和关闭或从组合框中选择项的处理程序。考虑数据绑定。如果我们把菜单按钮和组合框的状态绑定到视图模型，其他组件可以绑定到视图模型中的值，并且会在我们不需要编写任何粘合代码的情况下接收更新。为此，头部视图模型看起来如下：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Nothing more than a store to populate the tag filter combo box. We'll talk about
    this use of data binding further when we come to implement the header.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅是一个用于填充标签筛选组合框的存储。我们将在实现头部时进一步讨论这种数据绑定的用法。
- en: Threading our way
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程化我们的方式
- en: 'A thread is just a fancy way of saying "a collection of e-mail messages". We''re
    going to use `Ext.DataView` for this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 线程只是“一组电子邮件消息”的时髦说法。我们将使用`Ext.DataView`来实现这一点：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We're going to support HTML e-mails in this application, but to prevent the
    thread view from looking messy, we'll strip out this HTML before presenting it
    to the user. Other than this, it's a normal implementation of DataView.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本应用中支持HTML电子邮件，但为了防止线程视图看起来杂乱，我们将在将其展示给用户之前移除这些HTML。除此之外，它是对DataView的正常实现。
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The view model contains the thread store that powers the view as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型包含以下内容的线程存储：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's only a single method here, one that is triggered by the `itemclick`
    event on the thread DataView. It'll be responsible for redirecting the user to
    a list of messages in this thread.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一个方法，它是由线程DataView上的`itemclick`事件触发的。它将负责将用户重定向到该线程的消息列表。
- en: Send me a message
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送给我一条消息
- en: The message view is responsible for showing the messages that make up a thread.
    As such, it's mainly based on DataView. It's a little more complicated than this
    though because DataView doesn't inherit from `Ext.Panel`; it can't have its own
    child items or docked toolbar.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 消息视图负责显示构成线程的消息。因此，它主要基于DataView。但这比这要复杂一些，因为DataView不继承自`Ext.Panel`；它不能有自己的子项或停靠工具栏。
- en: 'In this case, we need to have some tools at the bottom of the message list
    in order to change the thread tag and send a reply. Therefore, we wrap the DataView
    in a panel:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要在消息列表底部添加一些工具，以便更改线程标签并发送回复。因此，我们将DataView包裹在一个面板中：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the view model, we need two stores: one for the messages in the thread,
    and one for the tags that are available to choose from.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图模型中，我们需要两个存储库：一个用于线程中的消息，另一个用于可供选择的标签。
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The view controller has a couple of event handlers to manage the user''s interactions
    with the message view:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器有几个事件处理器来管理用户与消息视图的交互：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's now only one missing piece to this application—how do we write new messages?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个应用程序只剩下一个缺失的部分——我们如何编写新消息？
- en: Stay composed
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持冷静
- en: 'The composer view is responsible for writing new messages and writing replies.
    It needs several UI components to accomplish this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 编写视图负责撰写新消息和回复。为此，它需要几个UI组件：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Recipients and subject won''t be used if the composer is replying to an existing
    thread. It will only be used when creating a new thread:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编写视图正在回复现有的线程，则不会使用收件人和主题。它只会在创建新线程时使用：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have a store of contacts to power the recipients'' field, and an object
    to store the form values as the user enters them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个存储联系人信息的存储库来为收件人字段供电，以及一个对象来存储用户输入的表单值：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The view controller will be responsible for saving the message to the server,
    which in turn would send it to the designated recipients.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器将负责将消息保存到服务器，然后服务器会将它发送到指定的收件人。
- en: We don't exactly have an address book in this application; instead, any previously
    used e-mail addresses are just saved and are available to pick in future messages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们并没有一个地址簿；相反，任何之前使用的电子邮件地址都只是保存下来，并在未来的消息中可供选择。
- en: Design overview
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计概述
- en: We skipped over a lot of the data layer design this time around because it was
    very "boilerplate" in nature and we'd discussed such things in previous chapters.
    Why go through the class design process for the views and their associated view
    controllers and view models then? We've done this in previous chapters as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们跳过了很多数据层设计，因为它本质上是“样板”式的，我们已经在之前的章节中讨论过这类事情。那么为什么还要为视图及其关联的视图控制器和视图模型进行类设计过程呢？我们已经在之前的章节中这样做过了。
- en: Clearly, every application is different. Breaking it down in this way helps
    us flesh out the code we're going to write without actually writing any code.
    This is important, because we'll avoid thinking too hard about the details of
    the implementation and have a better understanding of the shape of the larger
    pieces in the puzzle.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每个应用程序都是不同的。以这种方式分解有助于我们在实际编写代码之前完善将要编写的代码。这很重要，因为我们将避免过度思考实现的细节，并更好地理解拼图中更大组件的形状。
- en: The next step is to revisit routes, events, and data flow and see how these
    large pieces will work together.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是重新审视路由、事件和数据流，看看这些大型组件将如何协同工作。
- en: Application state
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序状态
- en: First up is routing. We said in [Chapter 6](ch06.html "Chapter 6. Practical
    – Monitoring Dashboard"), *Practical – Monitoring Dashboard*, that the route is
    a way of keeping part of the application's state in the URL. Another way of looking
    at this is that as the application changes through its various states, you are
    walking through the screens that the user would see as they interact with the
    interface.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是路由。我们在[第6章](ch06.html "第6章。实践 - 监控仪表板")*实践 - 监控仪表板*中提到，路由是一种将应用程序的部分状态保存在URL中的方式。另一种看待这个问题的方式是，随着应用程序通过其各种状态的变化，你正在走过用户在与其界面交互时看到的屏幕。
- en: By working out the various high-level states of our application, we can better
    visualize the user flow and establish the routes that we can employ in our code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确定我们应用程序的各种高级状态，我们可以更好地可视化用户流程并确定我们可以在代码中使用的路由。
- en: Home screen/initial load
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主屏幕/初始加载
- en: 'This is displayed straight after login and represents the default state of
    the main screen of the application before the user interacts with it. It looks
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在登录后立即显示的，代表了应用程序主屏幕在用户与之交互之前的默认状态。它看起来如下：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The views will have the following state:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 视图将具有以下状态：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we're in portrait view, we'll use a card layout.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在纵向视图，我们将使用卡片布局。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '"Card" is one of the build-Ext JS layouts, which allows you to easily switch
    out one component for another. It''s also the basis for the `Ext.TabPanel` component.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: “卡片”是构建 Ext JS 布局之一，它允许您轻松地切换一个组件为另一个组件。它也是 `Ext.TabPanel` 组件的基础。
- en: 'This means that the home state of the application needs to have the thread
    view as the active item:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着应用程序的初始状态需要将线程视图作为活动项：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the initial state on a normal device, the user has neither selected a message
    nor has chosen to compose a new message. Therefore, there's nothing showing in
    the right-hand pane.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常设备上的初始状态下，用户既没有选择消息也没有选择编写新消息。因此，在右侧面板中没有显示任何内容。
- en: New thread
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新线程
- en: 'The route that handles requests for a new thread is displayed in the following
    command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 处理请求新线程的路径如下所示：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the user presses the new message button, they are shown the composer view.
    The overall state changes as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下新消息按钮时，他们会看到编辑器视图。整体状态变化如下：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember that changing route doesn't mean that the state reverts to the initial
    state and then changes; we need to reset all things that could potentially have
    been shown by another route. In this case, if the user previously selected a thread,
    then the messages view would be showing, and we need to hide it when creating
    a new message.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，更改路由并不意味着状态会重置到初始状态然后改变；我们需要重置所有可能由其他路由显示的东西。在这种情况下，如果用户之前选择了一个线程，那么消息视图就会显示，我们需要在创建新消息时将其隐藏。
- en: Show thread
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示线程
- en: 'The route to handle requests for a specific message thread is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 处理特定消息线程请求的路径如下：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It''s triggered when the user selects a thread as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择线程时，会触发此操作：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Pretty much the opposite of a new message in which the messages are shown and
    the composer is hidden. The thread that was selected needs to be made available
    to the components that require it, in this case, the message view, so it can load
    the required messages.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎与新的消息相反，其中显示消息而隐藏了编辑器。需要选择线程的组件，在这种情况下，是消息视图，以便它可以加载所需的消息。
- en: New message/reply
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新消息/回复
- en: 'The route to handle requests for a new message thread is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 处理请求新消息线程的路径如下：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the final route in our application, and is used when a thread has been
    selected and then the user clicks on the "reply" button.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的应用程序中的最后一个路由，用于在用户选择了一个线程然后点击“回复”按钮时使用。
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Similar to the "show thread" route, except that the composer is shown as well
    as the messages view.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与“显示线程”路由类似，除了显示编辑器和消息视图。
- en: Routing overview
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由概述
- en: Examining the paths a user can take through your application can be a very valuable
    way of making sure nothing is missing from your design. It also gives the site
    the benefit of understanding the state of your application at various points on
    the path and allows you to translate this into routes to restore that state.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 检查用户可以通过您的应用程序采取的路径可以是非常有价值的方式来确保您的设计中没有遗漏任何内容。这也使网站能够了解应用程序在路径上的各个点的状态，并允许您将这些状态转换为恢复这些状态的路径。
- en: A binding agreement
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定协议
- en: Some of the state of the application is held in the URL, but other transient
    state is held in view models. We're going to look at an example of how data flows
    through this application in order to better understand how powerful data binding
    can be.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的一些状态存储在 URL 中，但其他瞬态状态存储在视图模型中。我们将通过查看数据如何通过此应用程序的示例来更好地理解数据绑定可以多么强大。
- en: 'In portrait mode, our application has a menu button that toggles the visibility
    of various other components. The pseudocode for this could be:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在纵向模式下，我们的应用程序有一个菜单按钮，可以切换其他各种组件的可见性。这个伪代码可能是这样的：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Code like this isn''t complicated, but it''s lengthy and error prone, a chore
    to write. Instead, we can use data binding to avoid this type of code and set
    up the behavior during configuration, something like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码并不复杂，但很长且容易出错，编写起来很麻烦。相反，我们可以使用数据绑定来避免这种类型的代码，并在配置期间设置行为，类似于以下内容：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are a couple of things to understand here: firstly that a button will
    "publish" the state of its `pressed` value. Whenever `pressed` changes, either
    programmatically or because the user clicked on the button, the value will be
    pushed to the view model for this button. Secondly, if a component has its `reference`
    set, this will be available to access its published values in the view model.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个要点需要理解：首先，一个按钮会“发布”其`pressed`值的当前状态。每当`pressed`值发生变化，无论是通过编程方式还是因为用户点击了按钮，这个值都会被推送到该按钮的视图模型中。其次，如果一个组件设置了其`reference`，那么就可以在视图模型中访问其发布的值。
- en: Combine both of these and the bind configuration on the search field becomes
    clear; bind the value of `hidden` on the search field to the value of `pressed`
    on the menu button. If `pressed` is `true`, the search field will be hidden.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这两者以及搜索字段的绑定配置，搜索字段的`hidden`值绑定到菜单按钮的`pressed`值。如果`pressed`为`true`，则搜索字段将被隐藏。
- en: While we've covered data binding and view models in some detail in previous
    chapters, this is the first time we've looked at this particular approach. It's
    not even necessary to specify any configuration on the view model itself as long
    as one is available somewhere in the component hierarchy, this will work.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在前面的章节中已经详细介绍了数据绑定和视图模型，但这是我们第一次探讨这种特定方法。只要在组件层次结构中的某个地方有可用的视图模型，就无需在视图模型本身上指定任何配置，这样就可以正常工作。
- en: This is another weapon in the armory of tools that allow us to simplify our
    code. Using this kind of declarative approach, where we specify what we'd like
    to happen, but don't have to say how it happens, we can avoid writing methods
    like the pseudocode earlier and use a standardized approach that Ext JS provides.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是工具库中另一个简化我们代码的武器。使用这种声明式方法，我们指定我们希望发生什么，但不必说明它是如何发生的，我们可以避免编写像之前的伪代码那样的方法，并使用Ext
    JS提供的标准化方法。
- en: The tricky part is fully embracing data binding and the view model concept.
    By thinking up-front about the dependencies between components and channeling
    data through view models, powerful interactions can be created with very little
    code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分是充分理解数据绑定和视图模型的概念。通过提前考虑组件之间的依赖关系并通过视图模型传递数据，我们可以用很少的代码创建强大的交互。
- en: An eventful application
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个充满事件的应用程序
- en: An interesting observation about both routing and data binding is that they
    are built around events. When a route changes, an event is fired and a controller
    listens to it, setting the application's state accordingly. When a property is
    data bound, Ext JS publishes its changes and other properties listen for these
    changes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于路由和数据绑定的一个有趣观察是，它们都是围绕事件构建的。当路由发生变化时，会触发一个事件，控制器监听它，并相应地设置应用程序的状态。当一个属性被数据绑定时，Ext
    JS会发布其更改，其他属性会监听这些更改。
- en: We're also familiar with events, such as `click`, `select`, `show`, and so on,
    that are fired from the various Ext JS components. It would seem that as events
    are being used everywhere in an Ext JS application, we might as well make use
    of them ourselves!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也熟悉事件，如`click`、`select`、`show`等，这些事件是由各种Ext JS组件触发的。看起来，由于事件在Ext JS应用中被广泛使用，我们最好也利用它们！
- en: 'We can use `fireEvent` from every `Observable` class in Ext JS. This allows
    you to fire a custom event from pretty much anywhere in our application. In previous
    versions of Ext JS, you needed to define events beforehand using an `addEvent`
    method, but this is no longer the case. However, what use is this? Does it offer
    a real-world advantage? Let''s look at some bad code to demonstrate:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Ext JS中每个`Observable`类的`fireEvent`方法。这允许你在我们应用的几乎任何地方触发一个自定义事件。在Ext JS的早期版本中，你需要使用`addEvent`方法事先定义事件，但现在不再是这样了。然而，这有什么用呢？它提供了真正的实际优势吗？让我们通过一些糟糕的代码来展示：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We save a message record. Then, in the callback, reload a list store, show a
    message in the viewport, and hide an editor component.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存一个消息记录。然后，在回调中，重新加载列表存储，在视口中显示消息，并隐藏编辑器组件。
- en: 'That''s three separate things, only one of which—hiding the editor—is probably
    in the right place. The others should be handled by their own view controllers.
    This code would be much better:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这有三件事情，其中只有一件——隐藏编辑器——可能放在了正确的位置。其他的事情应该由它们自己的视图控制器来处理。这段代码会更好：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, any code anywhere in the application can listen for a `messagesaved` event
    and proceed accordingly. The key benefit this brings is that this example message
    view controller doesn't have to know anything about any other views, controllers,
    or even anything about the rest of the application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序中的任何代码都可以监听`messagesaved`事件并相应地执行。这个例子带来的关键好处是，这个消息视图控制器不必了解任何其他视图、控制器，甚至不必了解应用程序的其余部分。
- en: This makes the messages view and view controller much more resistant to any
    changes in the rest of the system and much easier to test. In theory, it could
    be pulled out of the application and tested standalone.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得消息视图和视图控制器对整个系统中的任何变化都更加有抵抗力，并且更容易测试。在理论上，它可以从应用程序中提取出来并单独测试。
- en: Events and you
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件与您
- en: Let's go back to our webmail application. There's no point in adding events—or
    indeed anything—to our code base unless we're going to use them. A lot of places
    where we could use custom events will be rendered unnecessary by data binding
    and rendered unnecessary by routing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的网络邮件应用程序。除非我们打算使用它们，否则在代码库中添加事件或任何其他内容都没有意义。我们可以在很多地方使用自定义事件，但数据绑定和路由将使这些地方变得不必要。
- en: 'There is one place that a custom event will be useful: when creating a reply.
    The composer controller is responsible for this, but when the reply''s been saved
    we also need to refresh the messages view so that we can see the reply. This is
    a perfect place to make use of a custom event. We''ll see how this is implemented
    shortly.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个地方自定义事件将非常有用：在创建回复时。作曲控制器负责这个任务，但是当回复保存后，我们还需要刷新消息视图，以便我们可以看到回复。这是一个利用自定义事件的完美地方。我们很快就会看到它是如何实现的。
- en: Coding – it's been a long time
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码 – 已经很久了
- en: We've spent a lot of time examining this proposed application and thinking about
    the techniques we can use to create it in an elegant way. Now, it's time to start
    building it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了很多时间检查这个提议的应用程序，并思考我们可以用来优雅地创建它的技术。现在，是时候开始构建它了。
- en: 'We mentioned that the data layer for this application is very straightforward
    with lots of boilerplate code and nothing that is unexpected based on the knowledge
    we''ve gained in previous chapters. Let''s jump straight in:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，这个应用程序的数据层非常直接，有很多样板代码，并且基于我们在前几章中获得的知识，没有什么是出乎意料的。让我们直接进入：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Four models: `Contact`, `Tag`, `Message`, and `Thread`, all extend a `BaseModel`
    class that contains our data schema. Note that the `BaseModel` class specifies
    a rest proxy, so we know what to expect from the load and save behavior on our
    models. This is completely standard and very familiar from our previous example
    applications. The stores are correspondingly straightforward:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 四个模型：`Contact`、`Tag`、`Message`和`Thread`，都扩展了包含我们的数据模式的`BaseModel`类。请注意，`BaseModel`类指定了一个REST代理，因此我们知道我们可以在模型上期望什么样的加载和保存行为。这是完全标准的，并且与我们之前的示例应用程序非常熟悉。存储相应地简单：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is one store for each model class; everything apart from messages will
    load automatically because we need them across the application and they don't
    require any parameters to be passed to them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型类都有一个存储；除了消息之外，所有内容都将自动加载，因为我们需要在应用程序中使用它们，并且它们不需要传递任何参数。
- en: It's under control
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它在控制之下
- en: 'The data fundamentals are in place, so let''s look at a feature we''ll be using
    for the first time in this application: the `Controller`. Not a view controller
    this time, but the over-arching application controller we talked about in our
    design:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 数据基础已经到位，让我们看看在这个应用程序中我们将首次使用的一个功能：`Controller`。这次不是视图控制器，而是我们在设计中提到的整体应用程序控制器：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In previous examples, `app/Application.js` has been responsible for creating
    the viewport that represents the main view of the application. In this case, the
    root controller takes on this role. We override its `onLaunch` method to detect
    whether the user is logged in, regardless of the route they are on. It also specifies
    the default URL for the application (just an empty string) and again checks for
    a valid login.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，`app/Application.js`负责创建代表应用程序主要视图的视口。在这种情况下，根控制器承担这个角色。我们覆盖其`onLaunch`方法以检测用户是否已登录，无论他们处于哪个路由。它还指定了应用程序的默认URL（只是一个空字符串），并再次检查有效的登录。
- en: When a valid login is detected, the main view is shown, otherwise the login
    is shown. This is a super-simple mechanism to create a crude login system.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到有效登录时，显示主要视图，否则显示登录视图。这是一个创建原始登录系统的超级简单机制。
- en: Login view
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录视图
- en: 'The login view is a window centered in the screen that contains a number of
    fields. Their values are bound to a login object on the view model, as shown in
    the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 登录视图是一个位于屏幕中央的窗口，其中包含多个字段。它们的值绑定到视图模型上的登录对象，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note the `controller` and `ViewModel` configuration options and the prefix
    of the bind values that links to the login object on the view model. Speaking
    of which:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`controller`和`ViewModel`配置选项以及绑定值的前缀，它链接到视图模型上的登录对象。说到这个：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Nothing is happening here other than defining this login object. Let''s move
    on to the view controller:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有发生任何事情，只是定义了这个登录对象。让我们继续到视图控制器：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The view controller does nothing more than listen for the `click` event on the
    login form's button and then fake a successful login. For simplicity, this application
    doesn't do any validation of user details, so we just instantly fire a redirect
    to the home route.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器所做的只是监听登录表单按钮上的`click`事件，然后模拟一个成功的登录。为了简单起见，这个应用程序不对用户详情进行任何验证，所以我们只是立即触发重定向到主页路由。
- en: We saw earlier that the root controller handles the home token, which removes
    the login view and creates the main view. Let's move on and take a look at that
    now.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，根控制器处理主页令牌，这会移除登录视图并创建主视图。让我们继续前进，现在就看看那个视图。
- en: Main force
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主力
- en: 'Looking back at our design, the main view is the container for the rest of
    the UI in our application. It looks like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的设计，主视图是我们应用程序中其余UI的容器。它看起来像这样：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There''s a lot going on here, but only a couple of new concepts. Note that
    we have added a couple of plugins to this class: `viewport` and `responsive`.
    As we didn''t let our application auto create a view as a `viewport`, adding the
    `viewport` plugin will do just that. The `responsive` plugin allows you to use
    the `responsiveConfig` option, which we discussed earlier in the chapter.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行，但只有几个新概念。注意，我们向这个类添加了几个插件：`viewport`和`responsive`。因为我们没有让我们的应用程序自动创建一个作为`viewport`的视图，所以添加`viewport`插件就会做到这一点。`responsive`插件允许你使用我们之前在章节中讨论过的`responsiveConfig`选项。
- en: In this instance, on screens that are tall, that is, higher than they are wide,
    such as portrait screens, we use a card layout. On screens that are wide, that
    is, wider than they are high, we use an `hbox` layout because there's a lot more
    horizontal space. This simple declarative way of setting up a responsive view
    has allowed us to make very distinct changes to our application with only a few
    lines of configuration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对于高屏，即高度大于宽度的屏幕，例如竖屏，我们使用卡片布局。对于宽屏，即宽度大于高度的屏幕，我们使用`hbox`布局，因为这里有更多的水平空间。这种简单的声明性设置响应视图的方式使我们能够仅通过几行配置就对应用程序进行非常显著的变化。
- en: We've added a utility method to this view to help with manipulating our responsive
    setup; the `isCard` view will let us neatly determine whether this view is using
    a `card` layout or `hbox` layout.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向这个视图添加了一个实用方法来帮助我们操作响应设置；`isCard`视图将使我们能够整洁地确定这个视图是否正在使用`card`布局或`hbox`布局。
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Syntactic sugar is an alternative way of writing something that makes it easier
    to read or allows it to better express its intent. The `isCard` method is an example
    of this, not strictly necessary, but it makes the calling code shorter and easier
    to understand.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 语法糖是一种更易于阅读或更好地表达其意图的写作方式。`isCard`方法就是这样一个例子，虽然不是必需的，但它可以使调用代码更短且更容易理解。
- en: 'The rest of this configuration should be very familiar: two `dockedItems`,
    one is the application header view and another supplying a logout button, and
    the three other views of this application in the items array.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置的其余部分应该非常熟悉：两个`dockedItems`，一个是应用程序标题视图，另一个提供注销按钮，以及应用程序在项目数组中的其他三个视图。
- en: Main ViewModel
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主ViewModel
- en: 'On first glance, the code for this will look pretty standard, but when you
    look back at the code for the main view itself, you notice that `currentTag` or
    `searchTerm` is not going to be used anywhere. So, why define them if they''re
    not going to be used? Refer to `ViewModel` in the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这段代码看起来很标准，但当你回顾主视图本身的代码时，你会注意到`currentTag`或`searchTerm`将不会被用到。那么，为什么定义它们如果它们不会被使用呢？参考以下代码中的`ViewModel`：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In Ext JS, we have the concept of parent and child view models. The main view
    model, configured on the main view, will become available to all child components
    of the main view. This means that subviews can get data on the main view and also
    pass information back up to it. This is a fantastic way of passing data between
    two child components.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS中，我们有父视图模型和子视图模型的概念。配置在主视图上的主视图模型将可供主视图的所有子组件使用。这意味着子视图可以获取主视图的数据，也可以将其信息传递回主视图。这是在两个子组件之间传递数据的一种极好的方式。
- en: Main ViewController
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主视图控制器
- en: 'Refer to `ViewController` in the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中参考`ViewController`：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The most interesting thing happening in here is the route handlers; we're giving
    several routes to the `showRightPane` handler. Looking back at our examination
    of user flow and routes in our application, many of the routes need us to ensure
    that the right-hand panel is in view. This only applies to the responsive portrait
    view, so we only change the active panel if the portrait view's card layout is
    available.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最有趣的事情是路由处理程序；我们给`showRightPane`处理程序提供了几个路由。回顾一下我们对我们应用程序中用户流程和路由的考察，许多路由需要我们确保右侧面板是可见的。这仅适用于响应式纵向视图，所以我们只有在纵向视图的卡片布局可用时才更改活动面板。
- en: The interesting part is that we've got route handlers that only do part of what
    we'd expect. Where are the bits that pass IDs and show subviews? Don't worry,
    we'll revisit this shortly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是，我们有一些只完成我们预期部分的路由处理程序。传递ID并显示子视图的部分在哪里？不用担心，我们很快就会重新访问这个问题。
- en: The head of the family
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 家庭的头部
- en: 'Refer to the `Header.js` file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下`Header.js`文件：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Wow! That's actually a lot of code for a header bar! Look back at our original
    class design for this view and we did say there was "a surprising amount happening",
    so we weren't wrong.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这实际上是一个标题栏的很多代码！回顾一下我们最初对这个视图的类设计，我们确实说过“发生了很多令人惊讶的事情”，所以我们并没有错。
- en: In the section, *A binding agreement* we discussed a cut-down example of what
    is happening in this class. The `reference` option on the menu button is used
    to allow the other header components to bind to the menu's pressed value; look
    at the previous code and you'll see this approach used in various places to show
    or hide components when the menu button is toggled.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在*绑定协议*这一节中，我们讨论了该类中发生的事情的一个简化示例。菜单按钮上的`reference`选项用于允许其他标题组件绑定到菜单的按下值；查看前面的代码，你会看到这种方法在各种地方被用来在菜单按钮切换时显示或隐藏组件。
- en: We're not only using the responsive plugin again mostly to set the initial hidden
    state of the header components, but also using it to make sure the hidden config
    is only bound when the viewport is tall. This avoids issues with initial visibility
    of other components when the menu button isn't even in use. This kind of conditional
    binding opens up some exciting possibilities.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅再次使用响应式插件来设置标题组件的初始隐藏状态，而且还使用它来确保隐藏配置仅在视口高度时绑定。这避免了当菜单按钮甚至未被使用时其他组件初始可见性的问题。这种条件绑定开辟了一些令人兴奋的可能性。
- en: 'A couple more things of note: we mentioned the main view model had some values
    that seemed unused. Well, here they are, bound to the values of the tag filter
    combo and the search text field. When these values change, they''ll be passed
    up to the main view model and available for use by other components.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的还有两件事：我们提到主视图模型中有些值看起来没有被使用。好吧，现在它们就在这里，与标签过滤器组合和搜索文本字段的值绑定。当这些值发生变化时，它们将被传递到主视图模型，并可供其他组件使用。
- en: 'There''s a final item of note: a mysterious home-button component. The code
    for this looks like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是最后一项：一个神秘的主页按钮组件。这个代码看起来是这样的：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We're using this as a fake button, extending the simple container to fire a
    `click` event. This allows you to get a lightweight, unstyled, and clickable component
    to use as a home button.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其用作一个假按钮，扩展简单容器以触发`click`事件。这允许你获得一个轻量级、无样式且可点击的组件，用作主页按钮。
- en: Header ViewModel
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题视图模型
- en: 'Refer to `ViewModel` in the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中参考`ViewModel`：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This `ViewModel` class supplies the tags to populate the tag filter combo. We
    use a session to make sure that we're using the same tag instances across the
    application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ViewModel`类提供了填充标签过滤器组合的标签。我们使用会话来确保在整个应用程序中使用相同的标签实例。
- en: Header ViewController
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题视图控制器
- en: 'Refer to `ViewController` in the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中参考`ViewController`：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There are two component event listeners, one on the new message button and one
    on the home button. Both redirect to routes that will be consumed by other controllers.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个组件事件监听器，一个在新的消息按钮上，一个在主页按钮上。两者都重定向到其他控制器将消费的路由。
- en: There's also a controller listener that waits for a `tagadded` event and refreshes
    the tag store on `ViewModel`. This is great because we don't have to worry about
    where this event comes from or which component issued it; we just consume it in
    isolation and perform the action we're interested in.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个控制器监听器，等待 `tagadded` 事件，并在 `ViewModel` 上刷新标签存储。这很好，因为我们不必担心这个事件来自哪里或哪个组件发出的；我们只需独立消费它并执行我们感兴趣的操作。
- en: The reverse applies too, meaning the issuer of the `tagadded` event doesn't
    need to work out how to refresh the tag filter combo; instead, it can just declare
    that a tag was added and rest easy.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也适用，这意味着 `tagadded` 事件的发出者不需要弄清楚如何刷新标签筛选组合；相反，它只需声明添加了一个标签，然后放心。
- en: Unravel the thread
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解开线程
- en: 'A thread is a collection of e-mail messages, and the thread view makes up the
    left-hand pane of our application. It looks something like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一系列电子邮件消息的集合，线程视图构成了我们应用程序的左侧面板。它看起来像这样：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We knew from our design work that we would use a DataView for this class and
    its implementation turns out to be fairly straightforward. We're binding its store
    to the threads store on the view model itself also called as threads.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的设计工作中我们知道我们会使用 DataView 来实现这个类，其实现结果相当直接。我们在视图模型本身（也称为 threads）上也绑定了其 store。
- en: Look back at the design and you'll see that we anticipated a method to strip
    HTML from the message body and here it is; a little bit of trickery that uses
    a temporary DOM element to let the browser do the work for us.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾设计，你会发现我们预计会有一个方法来从消息体中删除 HTML，现在它就在这里；一点小技巧，使用一个临时的 DOM 元素让浏览器为我们完成工作。
- en: Thread ViewModel
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程视图模型
- en: 'Refer to `ViewModel` in the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码中的 `ViewModel`：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is actually the most complicated view model in the whole application and
    most of this complexity should be familiar from [Chapter 6](ch06.html "Chapter 6. Practical
    – Monitoring Dashboard"), *Practical – Monitoring Dashboard*. The filter array,
    along with the `remoteFilter` setting, will be responsible for sending a JSON
    object containing a filter definition through to the server. In this case, we
    see that we are consuming values from the main view model as broadcast up by the
    tag picker combo and search field in the header.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是整个应用程序中最复杂的视图模型，其中大部分复杂性应该从第 6 章 [实用 - 监控仪表板](ch06.html "第 6 章。实用 - 监控仪表板")中熟悉。过滤器数组，连同
    `remoteFilter` 设置，将负责通过服务器发送包含筛选定义的 JSON 对象。在这种情况下，我们看到我们正在消费来自主视图模型作为标签选择组合和头部搜索字段广播的值。
- en: We talked about this before, but it's worth highlighting again. The data flows
    from the header view to the main view model and then into the thread view. This
    is an incredibly simple way of communicating between parts of an application without
    these parts needing to be aware of each other.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过这个问题，但再次强调一下。数据从头部视图流向主视图模型，然后进入线程视图。这是在不让这些部分相互了解的情况下，在应用程序的部分之间进行通信的一种极其简单的方式。
- en: Thread ViewController
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程视图控制器
- en: 'Refer to `ViewController` in the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码中的 `ViewController`：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: More of these event listeners, and so on. We knew they'd come in handy, but
    they're everywhere! In the thread view controller, we listen for the DataView's
    `itemclick` event and simply redirect the application off so that another controller's
    route can take care of it. Fire and forget.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的事件监听器，等等。我们知道它们会派上用场，但它们无处不在！在线程视图控制器中，我们监听 DataView 的 `itemclick` 事件，并简单地重定向应用程序，以便另一个控制器的路由来处理它。发射并忘记。
- en: In turn, we listen for a `threadschanged` event, which is issued when a thread
    is added. This allows you to refresh the DataView's store in the view model to
    see the effects of the added thread. We don't know or care where `threadschanged`
    came from.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们监听 `threadschanged` 事件，当添加线程时发出。这允许你刷新视图模型中 DataView 的存储，以查看添加的线程的效果。我们不知道或关心
    `threadschanged` 来自哪里。
- en: I am the best message
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我是最好的消息
- en: 'Refer to the `Messages.js` file in the following code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码中的 `Messages.js` 文件：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In an ideal situation, the code should flow out of your team as the culmination
    of the design process. Any difficult classes or methods should have been part
    of a code spike. Your data layer would have been designed on top of your backend
    API. User interface has been described in wireframes, user stories provide routing,
    and so on.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，代码应该作为设计过程的最终成果从你的团队流出。任何困难的类或方法都应该是一个代码激增的一部分。你的数据层应该是在你的后端API之上设计的。用户界面已经在线框图中描述，用户故事提供了路由，等等。
- en: This is what we're seeing now. As seasoned Ext JS developers, we know how to
    configure a combo box and a store. This book is not here to help with that. We're
    going to continue to focus on the design and the decisions that make your code
    simple.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们现在看到的情况。作为经验丰富的Ext JS开发者，我们知道如何配置组合框和存储。这本书并不是为了帮助做这件事。我们将继续关注设计和那些使你的代码简单化的决策。
- en: Look at the previous class. The design of the messages view with its DataView
    nested inside a panel allows you to use a `bbar`; we knew about this before we
    even wrote a line of code. This is the crux of a good design. With developers
    who understand the technology they are working with, implementations become easy
    and predictable because it's all been thought about in advance.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 看看之前的类。消息视图的设计，其DataView嵌套在面板内，允许你使用`bbar`；我们在写代码之前就知道这一点。这是良好设计的核心。对于理解他们所使用技术的开发者来说，实现变得容易且可预测，因为所有的事情都已经在事先考虑过了。
- en: Messages ViewModel
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息视图模型
- en: 'Refer to `ViewModel` in the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码中的`ViewModel`：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: See! With an up-front design, you can pass the documentation over to a developer
    and have them create the messages view model. There's little scope for error because
    the shape of the class has already been decided.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 看吧！有了前置设计，你可以将文档交给一个开发者，让他们创建消息视图模型。由于类的形状已经决定，所以出错的可能性很小。
- en: Messages ViewController
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息视图控制器
- en: 'Having said that, there are times when the code is lengthy, so a breakdown
    of what''s happening really helps as shown here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有时代码会很长，所以真正了解发生了什么非常有帮助，如下所示：
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As usual, we have our event listeners. Let's look at the component ones; firstly
    the one that handles the reply button's `click` event as it's straightforward.
    It just redirects to a route that will take care of setting up the application
    to reply to a thread.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，我们有我们的事件监听器。让我们看看组件监听器；首先是一个处理回复按钮的`click`事件的监听器，因为它很简单。它只是重定向到一个将负责设置应用程序以回复线程的路由。
- en: Next, there's the `onTagChange` method that handles a click on the "set tag"
    button. This will get the selected value from the tag combo box and set it as
    the tag for the first message in the thread. Then, it saves that message to the
    server.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是处理点击“设置标签”按钮的`onTagChange`方法。这将从标签组合框中获取选定的值并将其设置为线程中第一条消息的标签。然后，它将那条消息保存到服务器。
- en: Note the callback for this save request (it fires off two events that we've
    seen before). One (`threadschanged`) notifies the application that threads have
    changed in some way; in this case, it's a thread's tag that has changed, so a
    thread list may need to be refreshed. The other (`tagadded`) signifies that there
    may be a new tag and any interested classes should refresh their tag data accordingly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个保存请求的回调（它触发了我们之前见过的两个事件）。一个（`threadschanged`）通知应用程序线程以某种方式发生了变化；在这种情况下，是一个线程的标签发生了变化，因此可能需要刷新线程列表。另一个（`tagadded`）表示可能有一个新的标签，任何感兴趣的类都应该相应地刷新它们的标签数据。
- en: The next two handlers are for routes, but there's something to note here. These
    routes have already been handled by the main view controller! This is a powerful
    feature; we can handle routes in multiple locations so that the classes that are
    interested in this route can do their own thing. This avoids us having to do all
    of the work in the main view controller, for example, the messages view controller
    can take care of loading the messages rather than doing so in the main view controller.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个处理程序是用于路由的，但这里有一些需要注意的地方。这些路由已经被主视图控制器处理过了！这是一个强大的功能；我们可以在多个位置处理路由，这样对这条路由感兴趣的类就可以做它们自己的事情。这避免了我们不得不在主视图控制器中做所有的工作，例如，消息视图控制器可以负责加载消息，而不是在主视图控制器中这样做。
- en: Compare using routes in this way to using events. They're very similar; we can
    redirect to a route, fire this redirect and forget about it, or else, where in
    the application a controller will handle this route. With routes, you get the
    added benefit of keeping state in the URL, thus enabling bookmark support. With
    events, you can send complex data in the event arguments. Both have their strengths.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用路由的方式与使用事件的方式进行比较。它们非常相似；我们可以重定向到一个路由，触发这个重定向然后忘记它，或者，在应用程序中控制器将处理这个路由的地方。使用路由，你可以获得在URL中保持状态的额外好处，从而实现书签支持。使用事件，你可以在事件参数中发送复杂的数据。两者都有其优势。
- en: A composed finish
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合完成
- en: Now, we come to the view that allows you to actually send e-mails, a pretty
    important part of this application!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了允许你实际发送电子邮件的视图，这是本应用中一个相当重要的部分！
- en: '[PRE50]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Another straightforward component definition, with the values of the form fields
    being bound to the `newMessage` object in the view model for later use. There''s
    another view model trick here, that is, if this `newMessage` object has a `parentId`
    value, we know that we''re replying to an existing thread. This means that we
    can hide the subject and recipient form fields, so we bind the `parentId` to their
    hidden value, making this step automatic as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个直接的组件定义，表单字段的值绑定到视图模型中的`newMessage`对象，以供以后使用。这里还有一个视图模型技巧，即如果这个`newMessage`对象有一个`parentId`值，我们知道我们正在回复一个现有的线程。这意味着我们可以隐藏主题和收件人表单字段，因此我们将`parentId`绑定到它们的隐藏值，使这一步自动如下：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have the contacts store that corresponds to the one in the view that was
    bound to the recipient's combo and then an empty definition for the `newMessage`
    object discussed previously.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个与绑定到收件人组合框的视图相对应的联系人存储，然后是对之前讨论过的`newMessage`对象的空定义。
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In component listeners, we handle the `click` event of the send button with
    the `onSendClick` method. This creates a new record on the current session and
    saves it to the server. In the `callback` method, we dispatch the application
    to the route that shows thread messages, but note that we'll use the ID of the
    new message in the event of it being a brand new thread and the `parentID` of
    the new message if it's a reply.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件监听器中，我们使用`onSendClick`方法处理发送按钮的`click`事件。这将在当前会话中创建一个新的记录并将其保存到服务器。在`callback`方法中，我们将应用程序调度到显示线程消息的路由，但请注意，如果这是一个全新的线程，我们将使用新消息的ID，如果它是一个回复，我们将使用新消息的`parentID`。
- en: In terms of handling routes, there's one (`hideComposer`) that hides the composer
    when viewing the messages in a thread because there's no need for it to be visible
    at that point. Then, there's a second (`showComposer`) that sets the `parentId`
    on the `newMessage` and shows the composer. For new threads, there's no ID captured
    by the route, so the `parentId` argument will be undefined and `newMessage.parentId`
    will be set as such. This enables the automatic viewing and hiding of the recipient
    and subject back in the composer view itself. Back when designing the app, we
    referred to this as `currentThreadId`, but we can see now that it makes sense
    to incorporate it in the `newMessage` object and pass this to the server when
    we save the new record.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理路由方面，有一个（`hideComposer`）在查看线程中的消息时隐藏编辑器，因为在这个时候没有必要让它可见。然后，还有一个第二个（`showComposer`）在`newMessage`上设置`parentId`并显示编辑器。对于新线程，路由没有捕获ID，所以`parentId`参数将是未定义的，`newMessage.parentId`将被设置为这样的值。这使编辑器视图本身中的收件人和主题的自动显示和隐藏成为可能。在设计应用程序时，我们将其称为`currentThreadId`，但现在我们可以看到将其纳入`newMessage`对象并在保存新记录时将其传递到服务器是有意义的。
- en: Deciding on a theme
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定主题
- en: 'We''ve covered all of the parts of this application apart from one: the way
    it looks. Cast your mind back to the screenshot of the app in action earlier in
    the chapter. In fact, have a look at the login screen to see how it differs from
    a standard Ext JS app:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了除外观之外的所有应用部分。回想一下本章前面展示的应用程序截图。实际上，看看登录屏幕，看看它与标准的Ext JS应用程序有何不同：
- en: '![Deciding on a theme](img/5308OT_07_06.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![决定主题](img/5308OT_07_06.jpg)'
- en: 'We''ve changed key things such as the font and color of the window frame, but
    take a look at the code to perform this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经改变了诸如窗口框架的字体和颜色等关键事项，但请查看执行此操作的代码：
- en: '[PRE53]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Ext JS themes provide an extensive range of variables designated by the dollar
    sign in front of them. By defining our own, such as `$body-font-family`, and overriding
    existing ones, we can easily shape the look of our application to suit different
    requirements.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS主题提供了一系列由它们前面的美元符号指定的变量。通过定义我们自己的，例如`$body-font-family`，并覆盖现有的变量，我们可以轻松地调整应用的外观以适应不同的需求。
- en: 'Not only this, but from a maintenance point of view, it''s far preferable to
    set a few variables than it''s to write a swathe of CSS rules to override theme
    style sheets. We can avoid problems like CSS precedence and finding the correct
    selectors to use and get on with making our app stand out. However, if we need
    to, we can drop down to use SASS, the CSS-like compiler that Ext JS uses for theming.
    Take a look at the styling for the thread view:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅于此，从维护的角度来看，设置几个变量远比编写一大堆CSS规则来覆盖主题样式表要优越得多。我们可以避免像CSS优先级和找到正确的选择器这样的问题，并继续努力让我们的应用脱颖而出。然而，如果我们需要的话，我们可以降级使用SASS，这是Ext
    JS用于主题的类似CSS的编译器。看看线程视图的样式：
- en: '[PRE54]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The thread view is a DataView, meaning its template can contain any custom HTML.
    Writing new SASS rules makes sense here, but Ext JS allows you to do this in a
    modular and reusable way, similar to the features it provides to write JavaScript
    classes. In the next few chapters, we'll discuss this and other features of theming
    in more depth.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 线程视图是一个DataView，这意味着其模板可以包含任何自定义HTML。在这里编写新的SASS规则是有意义的，但Ext JS允许你以模块化和可重用的方式来做这件事，类似于它提供编写JavaScript类的功能。在接下来的几章中，我们将更深入地讨论这个和其他主题功能。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've taken a different approach to designing and implementing this application.
    Rather than discussing the same details we have in previous chapters, we've avoided
    retreading old ground and talked about a higher level of architecture.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设计并实现这个应用时采取了不同的方法。而不是讨论我们在前几章中已有的相同细节，我们避免了重复旧地，而是讨论了一个更高层次的架构。
- en: By implementing routes, view model bindings, and events more extensively than
    ever before, we've shown how a declarative approach to Ext JS can simplify our
    code and make it incredibly easy to understand. At the same time, components that
    issue and listen to events are more decoupled, leading to fewer bugs and increased
    testability.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比以往更广泛地实现路由、视图模型绑定和事件，我们展示了声明式方法如何简化Ext JS的代码，并使其理解起来极其容易。同时，发出和监听事件的组件更加解耦，导致错误更少，可测试性更高。
- en: We also touched on theming, showing how a few lines of code can dramatically
    affect the look of an app and how we can write custom style rules to create brand
    new components.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涉及了主题，展示了几行代码如何极大地影响应用的外观，以及我们如何编写自定义样式规则来创建全新的组件。
- en: In the next chapter, we'll continue to explore the architectural ideas we've
    used already, but expanding them to look at how to make best use of them in the
    design phase. We'll look at how Ext JS architecture applies to theming and how
    we can continue to improve our code reuse all across our application.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索我们已经使用的架构思想，但将它们扩展到设计阶段如何最好地使用它们。我们将探讨Ext JS架构如何应用于主题，以及我们如何继续在整个应用中提高代码的重用性。
