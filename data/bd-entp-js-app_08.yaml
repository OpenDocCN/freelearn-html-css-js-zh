- en: Writing Unit/Integration Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元/集成测试
- en: We have now done as much as we can to modularize our code base, but how much
    confidence do we have in each of the modules? If one of the E2E tests fails, how
    would we pinpoint the source of the error? How do we know which module is faulty?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尽可能地对代码库进行了模块化，但我们有多少信心可以放在每个模块上？如果一个端到端测试失败，我们将如何定位错误的来源？我们如何知道哪个模块有缺陷？
- en: We need a lower level of testing that works at the module level to ensure they
    work as distinct, standalone units—we need **unit**** tests**. Likewise, we should
    test that multiple units can work well together as a larger logical unit; to do
    that, we need to also implement some **integration tests**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个更低级别的测试，它在模块级别工作，以确保它们作为独立的单元工作——我们需要**单元测试**。同样，我们也应该测试多个单元能否作为一个更大的逻辑单元良好地协同工作；为了做到这一点，我们需要实现一些**集成测试**。
- en: 'By following this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本章，您将能够做到以下事情：
- en: Write unit and integration tests using **Mocha**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Mocha**编写单元和集成测试
- en: Record function calls with **spies**, and simulate behavior with **stubs**,
    both provided by the **Sinon** library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Sinon**库中的**spies**记录函数调用，并使用**stubs**模拟行为
- en: Stub out dependencies in unit tests using **dependency injection** (**DI**)
    or **monkey patching**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**依赖注入**（**DI**）或**monkey patching**在单元测试中模拟依赖
- en: Measuring **test coverage** with **Istanbul**/**nyc**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Istanbul**/**nyc**测量**测试覆盖率**
- en: Picking a testing framework
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择测试框架
- en: While there's only one *de facto* testing framework for E2E tests for JavaScript
    (Cucumber), there are several popular testing frameworks for unit and integration
    tests, namely Jasmine ([jasmine.github.io](https://jasmine.github.io/)), Mocha
    ([mochajs.org](https://mochajs.org/)), Jest ([jestjs.io](https://jestjs.io/)),
    and AVA ([github.com/avajs/ava](https://github.com/avajs/ava)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于JavaScript的端到端测试只有一个**事实上的**测试框架（Cucumber），但有几个流行的单元和集成测试框架，包括Jasmine ([jasmine.github.io](https://jasmine.github.io/))、Mocha
    ([mochajs.org](https://mochajs.org/))、Jest ([jestjs.io](https://jestjs.io/))和AVA
    ([github.com/avajs/ava](https://github.com/avajs/ava))。
- en: 'We will be using Mocha for this book, but let''s understand the rationale behind
    that decision. As always, there are pros and cons for each choice:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这本书中使用Mocha，但让我们了解这个决定背后的理由。像往常一样，每个选择都有其优缺点：
- en: '**Maturity**: Jasmine and Mocha have been around for the longest, and for many
    years were the only two viable testing frameworks for JavaScript and Node. Jest
    and AVA are the new kids on the block. Generally, the maturity of a library correlates
    with the number of features and the level of support.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成熟度**：Jasmine和Mocha存在时间最长，多年来一直是JavaScript和Node的唯一两个可行的测试框架。Jest和AVA是新生力量。一般来说，库的成熟度与功能数量和支持水平相关。'
- en: '**Popularity**: Generally, the more popular a library is, the larger the community,
    and the higher likelihood of receiving support when things go awry. In terms of
    popularity, let''s examine several metrics (correct as of September 7, 2018):'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流行度**：一般来说，一个库越受欢迎，社区就越大，当事情出错时获得支持的可能性就越高。在流行度方面，让我们检查几个指标（截至2018年9月7日正确）：'
- en: GitHub stars@ Jest (20,187), Mocha (16,165), AVA (14,633), Jasmine (13,816)
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub stars@ Jest（20,187），Mocha（16,165），AVA（14,633），Jasmine（13,816）
- en: Exposure (percentage of developers who have heard of it): Mocha (90.5%), Jasmine
    (87.2%), Jest (62.0%), AVA (23.9%)
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曝光度（听说过它的开发者百分比）：Mocha（90.5%），Jasmine（87.2%），Jest（62.0%），AVA（23.9%）
- en: 'Developer satisfaction (percentage of developers who have used the tool *and
    would use it again*): Jest (93.7%), Mocha (87.3%), Jasmine (79.6%), AVA (75.0%).'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者满意度（使用过该工具并愿意再次使用的开发者百分比）：Jest（93.7%），Mocha（87.3%），Jasmine（79.6%），AVA（75.0%）。
- en: '**Parallelism**: Mocha and Jasmine both run tests serially (meaning one after
    the other), which means they can be quite slow. Instead, AVA and Jest, by default,
    run unrelated tests in parallel, as separate processes, making tests run faster
    because one test suite doesn''t have to wait for the preceding one to finish in
    order to start.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行性**：Mocha和Jasmine都按顺序串行运行测试（意味着一个接一个），这意味着它们可能相当慢。相反，AVA和Jest默认情况下并行运行无关的测试，作为单独的进程，这使得测试运行更快，因为一个测试套件不需要等待前一个测试套件完成才能开始。'
- en: '**Backing**: Jasmine is maintained by developers at Pivotal Labs, a software
    consultancy from San Francisco. Mocha was created by TJ Holowaychuk and is maintained
    by several developers; although it is not maintained by a single company, it is
    backed by larger companies such as Sauce Labs, Segment, and Yahoo!. AVA was started
    in 2015 by Sindre Sorhus and is maintained by several developers. Jest is developed
    by Facebook, and so has the best backing of all the frameworks.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背景**：Jasmine 由旧金山的软件咨询公司 Pivotal Labs 的开发者维护。Mocha 由 TJ Holowaychuk 创建，并由几位开发者维护；尽管它不是由单个公司维护，但它得到了
    Sauce Labs、Segment 和 Yahoo! 等大公司的支持。AVA 由 Sindre Sorhus 于 2015 年启动，并由几位开发者维护。Jest
    由 Facebook 开发，因此它拥有所有框架中最好的支持。'
- en: '**Composability**: Jasmine and Jest have different tools bundled into one framework,
    which is great to get started quickly, but it means we can''t see how everything
    fits together. Mocha and AVA, on the other hand, simply run the tests, and you
    can use other libraries such as `Chai`, `Sinon`, and `nyc` for assertions, mocking,
    and coverage reports, respectively.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合性**：Jasmine 和 Jest 将不同的工具捆绑在一个框架中，这对于快速入门来说很棒，但这意味着我们无法看到所有东西是如何结合在一起的。另一方面，Mocha
    和 AVA 只是简单地运行测试，你可以使用其他库，如 `Chai`、`Sinon` 和 `nyc`，分别用于断言、模拟和覆盖率报告。'
- en: The exposure and developer satisfaction figures are derived from The State of
    JavaScript survey, 2017 ([2017.stateofjs.com/2017/testing/results](https://2017.stateofjs.com/2017/testing/results/)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露和开发者满意度数据来自 2017 年的《JavaScript 状态调查》([2017.stateofjs.com/2017/testing/results](https://2017.stateofjs.com/2017/testing/results/))。
- en: We have chosen to use Mocha for this book, as it allows us to compose a custom
    testing stack. By doing this, it allows us to examine each testing tool individually,
    which is beneficial for your understanding. However, once you understand the intricacies
    of each testing tool,  I do encourage you to try Jest, as it is easier to set
    up and use.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用 Mocha 来编写这本书，因为它允许我们构建自定义的测试栈。通过这样做，它允许我们单独检查每个测试工具，这对你的理解有益。然而，一旦你了解了每个测试工具的复杂性，我确实鼓励你尝试
    Jest，因为它更容易设置和使用。
- en: Installing Mocha
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Mocha
- en: 'First, let''s install Mocha as a development dependency:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将 Mocha 作为开发依赖项安装：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will install an executable, `mocha`, at `node_modules/mocha/bin/mocha`,
    which we can execute later to run our tests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `node_modules/mocha/bin/mocha` 安装一个可执行文件 `mocha`，我们稍后可以执行它来运行我们的测试。
- en: Structuring our test files
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化我们的测试文件
- en: 'Next, we are going to write our unit tests, but where should we put them? There
    are generally two approaches:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写我们的单元测试，但应该把它们放在哪里呢？通常有两种方法：
- en: Placing all tests for the application in a top-level `test/` directory
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序的所有测试放置在顶级 `test/` 目录中
- en: Placing the unit tests for a module of code next to the module itself, and using
    a generic `test` directory only for application-level integration tests (for example,
    testing integration with external resources such as databases)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码模块的单元测试放置在模块本身旁边，仅使用通用 `test` 目录进行应用程序级别的集成测试（例如，测试与外部资源如数据库的集成）
- en: 'The second approach (as shown in the following example) is better as it keeps
    each module *truly* separated in the filesystem:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法（如下例所示）更好，因为它在文件系统中真正地将每个模块分开：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Furthermore, we're going to use the `.test.js` extension to indicate that a
    file contains tests (although using `.spec.js` is also a common convention). We
    will be even more explicit and specify the *type* of test in the extension itself;
    that is, using `unit.test.js` for unit test, and `integration.test.js` for integration
    tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用 `.test.js` 扩展名来表示一个文件包含测试（尽管使用 `.spec.js` 也是一个常见的约定）。我们将更加明确，并在扩展名本身中指定测试的
    *类型*；也就是说，使用 `unit.test.js` 进行单元测试，使用 `integration.test.js` 进行集成测试。
- en: Writing our first unit test
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个单元测试
- en: 'Let''s write unit tests for the `generateValidationErrorMessage` function.
    But first, let''s convert our `src/validators/errors/messages.js` file into its
    own directory so that we can group the implementation and test code together in
    the same directory:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `generateValidationErrorMessage` 函数编写单元测试。但首先，让我们将 `src/validators/errors/messages.js`
    文件转换为其自己的目录，这样我们就可以在同一个目录中将实现和测试代码分组在一起：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, in `index.unit.test.js`, import the `assert` library and our `index.js`
    file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `index.unit.test.js` 中，导入 `assert` 库和我们的 `index.js` 文件：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we are ready to write our tests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写我们的测试了。
- en: Describing the expected behavior
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述预期的行为
- en: When we installed the `mocha` npm package, it provided us with the `mocha` command
    to execute our tests. When we run `mocha`, it will inject several functions, including `describe` and `it`, as
    global variables into the test environment. The `describe` function allows us
    to group relevant test cases together, and the `it` function defines the actual
    test case.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装了 `mocha` npm 包时，它为我们提供了 `mocha` 命令来执行我们的测试。当我们运行 `mocha` 时，它将注入几个函数，包括
    `describe` 和 `it`，作为全局变量注入到测试环境中。`describe` 函数允许我们将相关的测试用例分组在一起，而 `it` 函数定义了实际的测试用例。
- en: 'Inside `index.unit.tests.js`, let''s define our first `describe` block:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.unit.tests.js` 中，让我们定义我们的第一个 `describe` 块：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both the `describe` and `it` functions accept a string as their first argument,
    which is used to describe the group/test. The description has no influence on
    the outcome of the test, and is simply there to provide context for someone reading
    the tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 和 `it` 函数都接受一个字符串作为它们的第一个参数，该参数用于描述组/测试。描述对测试结果没有影响，它只是简单地在那里，为阅读测试的人提供上下文。'
- en: The second argument of the `it` function is another function where you'd define
    the assertions for your tests. The function should throw an `AssertionError` if
    the test fails; otherwise, Mocha will assume that the test should pass.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`it` 函数的第二个参数是另一个函数，您将在其中定义测试的断言。如果测试失败，函数应该抛出 `AssertionError`；否则，Mocha 将假设测试应该通过。'
- en: In our test, we have created a dummy `errors` array that mimics the `errors`
    array, which is typically generated by Ajv. We then passed the array into the `generateValidationErrorMessage` function
    and capture its returned value. Lastly, we compare the actual output with our
    expected output; if they match, the test should pass; otherwise, it should fail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们创建了一个模拟的 `errors` 数组，它模仿了 Ajv 通常生成的 `errors` 数组。然后我们将数组传递给 `generateValidationErrorMessage`
    函数，并捕获其返回值。最后，我们将实际输出与预期输出进行比较；如果它们匹配，则测试应该通过；否则，它应该失败。
- en: Overriding ESLint for test files
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖测试文件的 ESLint
- en: 'The preceding test code should have caused some ESLint errors. This is because
    we violated three rules:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试代码应该已经引起了一些 ESLint 错误。这是因为我们违反了三条规则：
- en: '`func-names`: Unexpected unnamed function'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func-names`: 非预期的未命名函数'
- en: '`prefer-arrow-callback`: Unexpected function expression'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefer-arrow-callback`: 非预期的函数表达式'
- en: '`no-undef`: `describe` is not defined'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-undef`: `describe` 未定义'
- en: Let's fix them before we continue.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们来修复这些问题。
- en: Understanding arrow functions in Mocha
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Mocha 中的箭头函数
- en: We have already encountered the `func-names` and `prefer-arrow-callback` rules
    before when we wrote our E2E tests with `cucumber-js`. Back then, we needed to
    keep using function expressions instead of arrow functions because `cucumber-js`
    uses `this` inside each function to maintain context between different steps of
    the same scenario. If we'd used arrow functions, `this` would be bound, in our
    case, to the global context, and we'd have to go back to using file-scope variables
    to maintain state between steps.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在用 `cucumber-js` 编写 E2E 测试时已经遇到了 `func-names` 和 `prefer-arrow-callback` 规则。当时，我们需要继续使用函数表达式而不是箭头函数，因为
    `cucumber-js` 在每个函数内部使用 `this` 来维护同一场景不同步骤之间的上下文。如果我们使用了箭头函数，`this` 将被绑定，在我们的情况下，绑定到全局上下文，我们就不得不回到使用文件作用域变量来在步骤之间维护状态。
- en: 'As it turns out, Mocha also uses `this` to maintain a "context". However, in
    Mocha''s vocabulary, a "context" is not used to persist state between steps; rather,
    a Mocha context provides the following methods, which you can use to control the
    flow of your tests:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Mocha 也使用 `this` 来维护一个“上下文”。然而，在 Mocha 的术语中，“上下文”并不是用来在步骤之间持久化状态的；相反，Mocha
    的上下文提供了以下方法，您可以使用这些方法来控制测试的流程：
- en: '`this.timeout()`: To specify how long, in milliseconds, to wait for a test
    to complete before marking it as failed'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.timeout()`: 指定在将测试标记为失败之前，等待测试完成的毫秒数'
- en: '`this.slow()`: To specify how long, in milliseconds, a test should run for
    before it is considered "slow"'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.slow()`：指定测试在被认为是“慢”之前应该运行多长时间'
- en: '`this.skip()` : To skip/abort a test'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.skip()`：跳过/中止测试'
- en: '`this.retries()`: To retry a test a specified number of times'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.retries()`：重试测试指定次数'
- en: It is also impractical to give names to every test function; therefore, we should
    disable both the `func-names` and `prefer-arrow-callback` rules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 给每个测试函数命名也不切实际；因此，我们应该禁用 `func-names` 和 `prefer-arrow-callback` 规则。
- en: So, how do we disable these rules for our test files? For our E2E tests, we
    created a new `.eslintrc.json` and placed it inside the `spec/` directory. This
    would apply those configurations to all files under the `spec/` directory. However,
    our test files are not separated into their own directory, but interspersed between
    all our application code. Therefore, creating a new `.eslintrc.json` won't work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何禁用这些规则以适用于我们的测试文件？对于我们的端到端测试，我们在 `spec/` 目录中创建了一个新的 `.eslintrc.json`
    文件，并将其放置在其中。这将将这些配置应用于 `spec/` 目录下的所有文件。然而，我们的测试文件并没有被分到自己的目录中，而是散布在我们所有应用程序代码之间。因此，创建一个新的
    `.eslintrc.json` 文件将不起作用。
- en: 'Instead, we can add an `overrides` property to our top-level `.eslintrc.json`,
    which allows us to override rules for files that match the specified file glob(s).
    Update `.eslintrc.json` to the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以在顶层 `.eslintrc.json` 中添加一个 `overrides` 属性，这允许我们覆盖匹配指定文件 glob 的文件规则。更新
    `.eslintrc.json` 为以下内容：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are indicating that files with the extension `.test.js` should have
    the `func-names` and `prefer-arrow-callback` rules turned off.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们指示具有 `.test.js` 扩展名的文件应关闭 `func-names` 和 `prefer-arrow-callback` 规则。
- en: Specifying ESLint environments
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定 ESLint 环境
- en: However, ESLint will still complain that we are violating the `no-undef` rule.
    This is because when we invoke the `mocha` command, it will inject the `describe`
    and `it` functions as global variables. However, ESLint doesn't know this is happening
    and warns us against using variables that are not defined inside the module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ESLint 仍然会抱怨我们违反了 `no-undef` 规则。这是因为当我们调用 `mocha` 命令时，它将 `describe` 和 `it`
    函数作为全局变量注入。然而，ESLint 并不知道这件事，并警告我们不要使用在模块内部未定义的变量。
- en: 'We can instruct ESLint to ignore these undefined globals by specifying an **environment**. An
    environment defines global variables that are predefined. Update our overrides
    array entry to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指示 ESLint 通过指定一个 **环境** 来忽略这些未定义的全局变量。一个环境定义了预定义的全局变量。更新我们的覆盖数组条目为以下内容：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, ESLint should not complain anymore!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，ESLint 应该不会再抱怨了！
- en: Running our unit tests
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的单元测试
- en: 'To run our test, we''d normally just run `npx mocha`. However, when we try
    that here, we get a warning:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的测试，我们通常会运行 `npx mocha`。然而，当我们在这里尝试这样做时，我们得到了一个警告：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is because, by default, Mocha will try to find a directory named `test` at
    the root of the project and run the tests contained inside it. Since we placed
    our test code next to their corresponding module code, we must inform Mocha of
    the location of these test files. We can do this by passing a **glob** matching
    our test files as the second argument to `mocha`. Try running the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，默认情况下，Mocha 将尝试在项目根目录下找到一个名为 `test` 的目录并运行其中的测试。由于我们将测试代码放置在与它们对应的模块代码旁边，我们必须通知
    Mocha 这些测试文件的位置。我们可以通过将匹配我们的测试文件的 **glob** 作为 `mocha` 的第二个参数来做到这一点。尝试运行以下命令：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We got another error. We had already encountered this when we worked with `cucumber-js`.
    This error occurs because Mocha is not using Babel to transpile our test code
    before running it. With `cucumber-js`, we used the `--require-module` flag to
    require the `@babel/register` package, which ??. We can do the same with Mocha
    using its `--require` flag:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了另一个错误。我们在使用 `cucumber-js` 的时候已经遇到过这个问题。这个错误发生是因为 Mocha 在运行测试代码之前没有使用 Babel
    进行转译。在使用 `cucumber-js` 时，我们使用了 `--require-module` 标志来引入 `@babel/register` 包，我们做了同样的事情。我们可以使用
    Mocha 的 `--require` 标志来做到这一点：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you've forgotten about the different Babel packages (for example, `@babel/node`, `@babel/register`, `@babel/polyfill`,
    and so on), refer back to [Chapter 6](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml), *Setting
    Up Development Tools*, under the *Different faces of Babel* section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经忘记了不同的 Babel 包（例如，`@babel/node`、`@babel/register`、`@babel/polyfill` 等），请参考
    *不同版本的 Babel* 部分的 *设置开发工具* 章节中的 [第 6 章](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml)。
- en: Note that the test description we passed into `describe` and `it` is displayed
    in the test output.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们传递给 `describe` 和 `it` 的测试描述将在测试输出中显示。
- en: Running unit tests as an npm script
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将单元测试作为 npm 脚本运行
- en: 'Typing out the full `mocha` command each time can be tiresome. Therefore, we
    should create an npm script just like we did with the E2E tests. Add the following
    to the scripts object inside our `package.json` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每次都输入完整的 `mocha` 命令可能会很麻烦。因此，我们应该创建一个与端到端测试相同的 npm 脚本。将以下内容添加到 `package.json`
    文件中的 scripts 对象内：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Furthermore, let''s also update our existing `test` npm script to run all our
    tests (both unit and E2E):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们也更新现有的 `test` npm 脚本来运行所有测试（单元测试和端到端测试）：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can run our unit tests by running `yarn run test:unit`, and run all
    our tests with `yarn run test`. We have now completed our first unit test, so
    let''s commit the changes and move on to writing even more tests:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过运行 `yarn run test:unit` 来运行我们的单元测试，并通过 `yarn run test` 运行所有测试。我们已经完成了第一个单元测试，所以让我们提交更改并继续编写更多的测试：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Completing our first unit test suite
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的第一个单元测试套件
- en: 'We have only covered a single scenario with our first unit test. Therefore,
    we should write more tests to cover every scenario. Try completing the unit test
    suite for `generateValidationErrorMessage` yourself; once you are ready, compare
    your solution with the following one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用第一个单元测试覆盖了一个场景。因此，我们应该编写更多的测试来覆盖每个场景。尝试自己完成 `generateValidationErrorMessage`
    的单元测试套件；一旦你准备好了，比较你的解决方案与以下方案：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the tests again, and note how the tests are grouped under the `describe` block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，并注意测试是如何在 `describe` 块下分组的：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have now completed the unit tests for `generateValidationErrorMessage`,
    so let''s commit it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了 `generateValidationErrorMessage` 的单元测试，所以让我们提交它：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unit testing ValidationError
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试 ValidationError
- en: 'Next, let''s focus on testing the `ValidationError` class. Once again, we will
    move the `validation.js` file into its own director:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于测试 `ValidationError` 类。同样，我们将把 `validation.js` 文件移动到它自己的目录中：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, create a new file at `src/validators/errors/validation-error/index.unit.test.js` to
    house our unit tests:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `src/validators/errors/validation-error/index.unit.test.js` 创建一个新文件来存放我们的单元测试：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the tests and make sure they pass. Then, commit it into the repository:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并确保它们通过。然后，将其提交到仓库：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unit testing middleware
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试中间件
- en: 'Next, we are going to test our middleware functions, starting with the `checkEmptyPayload` middleware.
    Like we did previously, move the middleware module into its own directory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试我们的中间件函数，从 `checkEmptyPayload` 中间件开始。像之前一样，将中间件模块移动到它自己的目录中：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, inside `src/middlewares/check-content-type.js/index.unit.test.js`, lay
    out the skeleton of our first test:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `src/middlewares/check-content-type.js/index.unit.test.js` 中，构建我们第一个测试的框架：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The purpose of the `checkEmptyPayload` middleware is to ensure that the `POST`,
    `PATCH`, and `PUT` requests always carry a non-empty payload. Therefore, if we
    pass in a request with a different method, say `GET`, we should be able to assert
    the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkEmptyPayload` 中间件的目的确保 `POST`、`PATCH` 和 `PUT` 请求始终携带非空负载。因此，如果我们传递一个不同方法的请求，比如说
    `GET`，我们应该能够断言以下内容：'
- en: That the `res` object is not modified
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res` 对象没有被修改'
- en: That the `next` function is invoked once
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next` 函数被调用一次'
- en: Asserting deep equality
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言深度相等
- en: To assert that the `res` object has not been modified, we need to perform a
    deep comparison of the `res` object before and after `checkEmptyPayload` has been
    called.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要断言 `res` 对象没有被修改，我们需要在调用 `checkEmptyPayload` 之前和之后对 `res` 对象进行深度比较。
- en: Instead of implementing this function ourselves, we can save time by using existing
    utility libraries. For instance, Lodash provides the `cloneDeep` method ([lodash.com/docs/#cloneDeep](https://lodash.com/docs/#cloneDeep)) for
    deep cloning, and the `isEqual` method ([lodash.com/docs/#isEqual](https://lodash.com/docs/#isEqual)) for
    deep object comparison.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是自己实现这个函数，我们可以通过使用现有的实用库来节省时间。例如，Lodash 提供了 `cloneDeep` 方法（[lodash.com/docs/#cloneDeep](https://lodash.com/docs/#cloneDeep)）用于深度克隆，以及
    `isEqual` 方法（[lodash.com/docs/#isEqual](https://lodash.com/docs/#isEqual)）用于深度对象比较。
- en: To use these methods in our code, we can install the `lodash` package from npm,
    which contains hundreds of utility methods. However, we won't be using most of
    these methods in our project; if we install the entire utility library, most of
    the code would be unused. We should always try to be as lean as possible, minimizing
    the number, and size, of our project's dependencies.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的代码中使用这些方法，我们可以从 npm 安装 `lodash` 包，它包含数百个实用方法。然而，我们不会在我们的项目中使用这些方法中的大多数；如果我们安装整个实用库，大部分代码将不会被使用。我们应该始终尽量保持尽可能精简，最小化项目的依赖数量和大小。
- en: 'Fortunately, Lodash provides a separate npm package for each method, so let''s
    add them to our project:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Lodash 为每个方法提供了一个独立的 npm 包，所以让我们把它们添加到我们的项目中：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can use an online tool called Bundlephobia ([bundlephobia.com](https://bundlephobia.com/))
    to find out the file size of an npm package, without downloading it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个名为 Bundlephobia 的在线工具（[bundlephobia.com](https://bundlephobia.com/)）来找出
    npm 包的文件大小，而无需下载它。
- en: For example, we can see from [bundlephobia.com/result?p=lodash@4.17.10](https://bundlephobia.com/result?p=lodash@4.17.10)
    that the `lodash` package is 24.1 KB in size after it's been minified and gzipped.
    Similarly, the `lodash.isequal` and `lodash.clonedeep` packages have a size of
    3.7 KB and 3.3 KB, respectively. Therefore, by installing the more specific packages,
    we have reduced the amount of unused code in our project by 17.1 KB.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以从[bundlephobia.com/result?p=lodash@4.17.10](https://bundlephobia.com/result?p=lodash@4.17.10)中看到，经过压缩和gzip处理后，`lodash`包的大小为24.1
    KB。同样，`lodash.isequal`和`lodash.clonedeep`包的大小分别为3.7 KB和3.3 KB。因此，通过安装更具体的包，我们已经减少了项目中未使用的代码量17.1
    KB。
- en: Now, let's use the `deepClone` method to clone the `res` object before passing
    it to `checkEmptyPayload`. Then, after `checkEmptyPayload` has been called, use `deepEqual`
    to compare the `res` object and its clone, and assert whether the `res` object
    has been modified or not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`deepClone`方法在传递给`checkEmptyPayload`之前克隆`res`对象。然后，在`checkEmptyPayload`被调用后，使用`deepEqual`来比较`res`对象及其克隆，并断言`res`对象是否已被修改。
- en: 'Have a go at implementing it yourself, and compare your solution with ours,
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己实现它，并将你的解决方案与我们的进行比较，如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we need a way to assert that the `next` function has been called once.
    We can do that by using test **spies**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来断言`next`函数已被调用一次。我们可以通过使用测试间谍来实现这一点。
- en: Asserting function calls with spies
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用间谍断言函数调用
- en: A spy is a function that records information about every call made to it. For
    example, instead of assigning an empty function to `next`, we can assign a spy
    to it. Whenever `next` is invoked, information about each invocation is stored
    inside the spy object. We can then use this information to determine the number
    of times the spy has been called.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是一个记录对它每次调用信息的函数。例如，我们不必将空函数分配给`next`，而是可以分配一个间谍给它。每当`next`被调用时，每次调用的信息都会存储在间谍对象中。然后我们可以使用这些信息来确定间谍被调用的次数。
- en: 'The *de facto* spy library in the ecosystem is Sinon ([sinonjs.org](http://sinonjs.org/)),
    so let''s install it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 生态系统中的*de facto*间谍库是Sinon([sinonjs.org](http://sinonjs.org/))，所以让我们安装它：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, in our unit test, import the `spy` **named export** from the `sinon`
    package:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的单元测试中，从`sinon`包中导入`spy`**命名导出**：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, in our test function, instead of assigning an empty function to `next`,
    assign it a new spy:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的测试函数中，不要将空函数分配给`next`，而是分配一个新的间谍：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When the spy function is called, the spy will update some of its properties
    to reflect the state of the spy. For example, when it''s been called once, the
    spy''s `calledOnce` property will be set to `true`; if the spy function is invoked
    again, the `calledOnce` property will be set to `false` and the `calledTwice`
    property will be set to `true`. There are many other useful properties such as
    `calledWith`, but let''s update our `it` block by checking the `calledOnce` property
    of our spy:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当间谍函数被调用时，间谍会更新其一些属性以反映间谍的状态。例如，当它被调用一次时，间谍的`calledOnce`属性将被设置为`true`；如果间谍函数再次被调用，`calledOnce`属性将被设置为`false`，而`calledTwice`属性将被设置为`true`。还有许多其他有用的属性，例如`calledWith`，但让我们通过检查我们的间谍的`calledOnce`属性来更新我们的`it`块：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we''ll define more tests to examine what happens when `req.method` is
    one of `POST`, `PATCH`, or `PUT`. Implement the following tests, which test what
    happens when the `content-length` header is not `0`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义更多的测试来检查当`req.method`是`POST`、`PATCH`或`PUT`之一时会发生什么。实现以下测试，这些测试检查当`content-length`头不是`0`时会发生什么：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`beforeEach` is another function that is injected into the global scope by
    Mocha. `beforeEach` will run the function passed into it, prior to running each
    `it` block that resides on the same or lower level as the `beforeEach` block.
    Here, we are using it to invoke `checkEmptyPayload` before each assertion.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`是另一个由Mocha注入到全局作用域的函数。`beforeEach`将在运行与`beforeEach`块相同或更低级别的每个`it`块之前运行传入它的函数。在这里，我们使用它来在每个断言之前调用`checkEmptyPayload`。'
- en: '`beforeEach` is a type of **hook** function. There are also `afterEach`, `before`,
    and `after`. See how you can use them by referring to the documentation at [mochajs.org/#hooks](https://mochajs.org/#hooks).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`是一种**钩子**函数。还有`afterEach`、`before`和`after`。通过参考[mochajs.org/#hooks](https://mochajs.org/#hooks)文档，了解如何使用它们。'
- en: 'Next, when the `content-type` header is `0`, we want to assert that the `res.status`,
    `res.set`, and `res.json` methods are called correctly:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当`content-type`头为`0`时，我们想要断言`res.status`、`res.set`和`res.json`方法被正确调用：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Lastly, we need to test that `checkEmptyPayload` will return the output of `res.json()`.
    To do that, we need to use another test construct called **stubs**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要测试`checkEmptyPayload`是否会返回`res.json()`的输出。为了做到这一点，我们需要使用另一个测试构造，称为**模拟对象**。
- en: Simulating behavior with stubs
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟对象模拟行为
- en: Stubs are functions that simulate the behavior of another component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象是模拟其他组件行为的函数。
- en: In Sinon, stubs are an extension to spies; this means that all the methods that
    are available to spies are also available to stubs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sinon中，模拟对象是间谍对象的扩展；这意味着间谍对象所有可用的方法也同样适用于模拟对象。
- en: 'In the context of our tests, we don''t really care about the returned value
    of `res.json()` – we only care that our `checkEmptyPayload` middleware function
    relays this value back faithfully. Therefore, we can turn our `res.json` spy into
    a stub, and make it return a reference to an object:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试上下文中，我们并不关心`res.json()`返回的值——我们只关心我们的`checkEmptyPayload`中间件函数能够忠实地将这个值传递回去。因此，我们可以将我们的`res.json`间谍对象转换为模拟对象，并使其返回一个对象的引用：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can then add another assertion step to compare the value returned by the `checkEmptyPayload` function,
    and the value returned by our `res.json` stub; they should be strictly identical:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加另一个断言步骤来比较`checkEmptyPayload`函数返回的值和我们的`res.json`模拟对象返回的值；它们应该是严格相同的：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the unit tests by executing `yarn run test:unit`, fix any errors that cause
    the tests to fail, and then commit the unit tests to the repository:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行`yarn run test:unit`来运行单元测试，修复导致测试失败的任何错误，然后将单元测试提交到仓库：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Testing all middleware functions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试所有中间件函数
- en: Now, it's time for you to write some unit tests yourself. Try following the
    same approach to test the `checkContentTypeIsJson`, `checkContentTypeIsSet`, and `errorHandler`
    middleware functions. Refer to the code bundle for help if needed. As always,
    run the tests and commit your code!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，轮到你自己编写一些单元测试了。尝试遵循相同的方法来测试`checkContentTypeIsJson`、`checkContentTypeIsSet`和`errorHandler`中间件函数。如有需要，请参考代码包。像往常一样，运行测试并提交你的代码！
- en: Once all of our middleware functions have been unit tested, we will move on
    to testing the request handlers and the engine.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的所有中间件函数都经过了单元测试，我们将继续测试请求处理器和引擎。
- en: Unit testing the request handler
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试请求处理器
- en: First, we'll move the `src/handlers/users/create.js` module into its own directory.
    Then, we will correct the file paths specified in the `import` statements to point
    to the correct file. Lastly, we will create an `index.unit.test.js` file next
    to our module to house the unit tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`src/handlers/users/create.js`模块移动到它自己的目录中。然后，我们将更正`import`语句中指定的文件路径，使其指向正确的文件。最后，我们将在我们的模块旁边创建一个`index.unit.test.js`文件来存放单元测试。
- en: 'Let''s take a look at the `createUser` function inside our request handler
    module. It has the following structure:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们请求处理器模块中的`createUser`函数。它具有以下结构：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, it will call the `create` function that was imported from `src/engines/users/create/index.js`.
    Based on the result, it will invoke either the `onFulfilled` or `onRejected` callbacks
    inside the `then` block.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它将调用从`src/engines/users/create/index.js`导入的`create`函数。根据结果，它将在`then`块内部调用`onFulfilled`或`onRejected`回调。
- en: Although our `createUser` function depends on the `create` function, when writing
    a unit test, our test should test only the relevant unit, not its dependencies.
    Therefore, if the result of our tests relies on the `create` function, we should
    use a stub to control its behavior. Otherwise, our test would, in fact, be an
    *integration test*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的`createUser`函数依赖于`create`函数，但在编写单元测试时，我们的测试应该只测试相关的单元，而不是它的依赖项。因此，如果我们的测试结果依赖于`create`函数，我们应该使用模拟对象来控制其行为。否则，我们的测试实际上将是一个*集成测试*。
- en: Stubbing create
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟`create`
- en: 'We can create different stubs that return different results, each mimicking
    the possible return values of the `create` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建不同的模拟对象，它们返回不同的结果，每个模拟对象都模仿`create`函数可能的返回值：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, if we invoke `createStubs.success()`, it will always resolve to the `{
    _id: ''foo''}` object; therefore, we can use this stub to test for scenarios where
    the `req` object we pass into the `createUser` function is valid. Likewise, we
    can use `createStubs.validationError()` to mimic a situation where the `req` object
    causes `createUser` to reject with `ValidationError`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，如果我们调用`createStubs.success()`，它将始终解析为`{ _id: ''foo''}`对象；因此，我们可以使用这个模拟对象来测试传递给`createUser`函数的`req`对象是否有效。同样，我们可以使用`createStubs.validationError()`来模拟一个情况，其中`req`对象导致`createUser`拒绝并抛出`ValidationError`。'
- en: Now, we know how to stub out the `create` function, but how do we actually replace
    it inside the `createUser` function? When testing the `createUser` function, the
    only variables we can change in our test are the parameters we pass into the function,
    and the `createUser` method accepts only three parameters: `req`, `res`, and `db`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何存根`create`函数，但我们如何在`createUser`函数内部实际替换它？在测试`createUser`函数时，我们可以在测试中更改的唯一变量是我们传递给函数的参数，而`createUser`方法只接受三个参数：`req`、`res`和`db`。
- en: There are two approaches to this: **dependency injection** and **monkey patching**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以实现这一点：**依赖注入**和**猴子补丁**。
- en: Dependency injection
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: The idea of dependency injection is to make every dependency a parameter of
    the function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的想法是将每个依赖项都作为函数的参数。
- en: 'At the moment, our `createUser` function relies on entities outside of its
    parameters; this includes the `create` function and the `ValidationError` class.
    If we were to use dependency injection, we''d modify our `createUser` function
    to have the following structure:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`createUser`函数依赖于其参数之外的实体；这包括`create`函数和`ValidationError`类。如果我们使用依赖注入，我们会修改我们的`createUser`函数，使其具有以下结构：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we would be able to inject the following dependencies from our tests:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就可以从我们的测试中注入以下依赖项：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Monkey patching
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猴子补丁
- en: An alternative approach to dependency injection is monkey patching, where we
    dynamically modify the system at runtime. In our example, we might want to replace
    the `create` function with our stub functions, but *only* when we are running
    our tests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的另一种方法是猴子补丁，它可以在运行时动态修改系统。在我们的例子中，我们可能想要用我们的存根函数替换`create`函数，但**仅**在我们运行测试时。
- en: Implementations of monkey patching libraries tend to be hacky and usually involves
    reading the module code into a string, injecting custom code into the string,
    and then loading it. Thus, the entities being monkey patched would be modified
    in some way.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 猴子补丁库的实现通常很复杂，通常涉及将模块代码读入字符串，向字符串中注入自定义代码，然后加载它。因此，被猴子补丁修改的实体将按某种方式被修改。
- en: There are several libraries that allow us to apply monkey patches when running
    tests; the most popular library is `rewire` ([npmjs.com/package/rewire](https://www.npmjs.com/package/rewire)).
    It also has a Babel plugin equivalent called `babel-plugin-rewire` ([github.com/speedskater/babel-plugin-rewire](https://github.com/speedskater/babel-plugin-rewire)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个库允许我们在运行测试时应用猴子补丁；最受欢迎的库是`rewire`（[npmjs.com/package/rewire](https://www.npmjs.com/package/rewire)）。它还有一个名为`babel-plugin-rewire`的Babel插件等价物（[github.com/speedskater/babel-plugin-rewire](https://github.com/speedskater/babel-plugin-rewire)）。
- en: 'This plugin will add the `__set__`, `__get__`, and `__with__` methods to every
    top-level file-scoped entity in the module being "rewired". Now, we can use the `__set__` method
    of our `createUser` module to monkey patch our `create` function, like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件将为正在“重连”的模块中的每个顶级文件作用域实体添加`__set__`、`__get__`和`__with__`方法。现在，我们可以使用`createUser`模块的`__set__`方法来猴子补丁我们的`create`函数，如下所示：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `__set__` method returns a function that we can use to revert the `create` function
    back to its original state. This is useful when you want to run tests using different
    variants of `create`. In that case, you'd simply `revert` the create function
    after each test run, and patch it again at the beginning of the next run.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`__set__`方法返回一个函数，我们可以使用它来将`create`函数恢复到其原始状态。当你想使用`create`的不同变体运行测试时，这很有用。在这种情况下，你只需在每个测试运行后简单地`revert`创建函数，然后在下一次运行开始时再次补丁它。'
- en: Dependency injection versus monkey patching
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入与猴子补丁
- en: Both approaches have their pros and cons, so let's compare their differences
    and see which one is the most appropriate for our use case.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有其优缺点，所以让我们比较它们的差异，看看哪一种最适合我们的用例。
- en: Modularity
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化
- en: Dependency injection has the benefit of keeping every module as decoupled as
    possible, as modules do not have predefined dependencies; every dependency is
    passed in (injected) at runtime. This makes unit testing a lot easier, as we can
    replace any dependencies with stubs, keeping our unit tests truly unit tests.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的好处是尽可能地将每个模块解耦，因为模块没有预定义的依赖；每个依赖项都在运行时传递（注入）。这使得单元测试变得容易得多，因为我们可以用存根替换任何依赖项，使我们的单元测试真正成为单元测试。
- en: Readability
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性
- en: With dependency injection, every dependency must be a parameter of the function.
    Thus, if the module has 20 dependencies, it'll need to have 20 parameters. This
    can make the module hard to read.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入（dependency injection）时，每个依赖都必须是函数的参数。因此，如果模块有20个依赖项，它将需要20个参数。这可能会使模块难以阅读。
- en: Often, you'll have a single root file where every dependency is imported, instantiated,
    and injected; these dependencies would then be passed down to child functions,
    and their child functions, and so on. This means for a developer to find the source
    of the dependency, he/she would have to follow the trail of function calls leading
    up to the root where the dependency is originally injected. This could be three
    or four function calls, or it might be a dozen.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会有一个单一的根文件，其中每个依赖都被导入、实例化和注入；然后这些依赖会被传递到子函数，以及它们的子函数，依此类推。这意味着为了找到依赖的来源，开发者必须追踪从根函数到原始注入依赖的函数调用链。这可能是三四个函数调用，也可能是十几个。
- en: Generally speaking, the more abstraction layers there are in a project, the
    harder it is for developers to read the code, but this is especially true when
    using the dependency injection approach.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，一个项目中抽象层的数量越多，开发者阅读代码就越困难，但使用依赖注入方法时尤其如此。
- en: With monkey patching, the signature of the module functions can be much leaner.
    Only dynamic dependencies would be included in the function parameters list; utility
    functions and static dependencies can be imported at the top of the file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用猴子补丁，模块函数的签名可以更加简洁。只有动态依赖会被包含在函数参数列表中；实用函数和静态依赖可以在文件顶部导入。
- en: For instance, the `req`, `res`, and `db` parameters of the `createUser` function
    are dynamic – `req` and `res` would be different for each request, and `db` is
    only instantiated at startup. On the other hand, the `create` function and `ValidationError`
    class are static – you know their exact value before you run the code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`createUser`函数的`req`、`res`和`db`参数是动态的——`req`和`res`对每个请求都不同，而`db`仅在启动时实例化。另一方面，`create`函数和`ValidationError`类是静态的——在运行代码之前，你知道它们的确切值。
- en: Therefore, using monkey patching can improve the readability of our application
    code, at the expense of making our test code a bit more complicated.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用猴子补丁（monkey patching）可以提高我们应用程序代码的可读性，但代价是使我们的测试代码变得稍微复杂一些。
- en: Reliance on third-party tools
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖第三方工具
- en: Dependency injection is a simple concept to implement and does not require any
    third-party tools. On the other hand, monkey patching is hard to implement and
    you'd normally use `babel-plugin-rewire` or a similar library. This means that
    our test would now have to depend on the `babel-plugin-rewire` package.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一个简单的概念，实现它不需要任何第三方工具。另一方面，猴子补丁（monkey patching）难以实现，你通常会使用`babel-plugin-rewire`或类似的库。这意味着我们的测试现在将不得不依赖于`babel-plugin-rewire`包。
- en: This can become an issue if `babel-plugin-rewire` becomes unmaintained, or if
    maintenance is slow. At the time of writing this book, the `babel-plugin-rewire` plugin
    still lacks support for Babel 7\. If a developer is using the `babel-plugin-rewire` plugin,
    he/she won't be able to upgrade their Babel version, and for developers who are
    already using Babel 7, they won't be able to monkey patch until support is implemented.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`babel-plugin-rewire`不再维护，或者维护缓慢，这可能会成为一个问题。在撰写本书时，`babel-plugin-rewire`插件仍然缺乏对Babel
    7的支持。如果一个开发者正在使用`babel-plugin-rewire`插件，他将无法升级他们的Babel版本，而对于已经使用Babel 7的开发者来说，他们无法进行猴子补丁，直到支持实现。
- en: Following the dependency injection pattern
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循依赖注入模式
- en: From the preceding discussion, it seems like dependency injection is the better
    choice. Readability should not be too much of an issue, as we only have two layers
    of abstraction – handlers and engines. Therefore, let's migrate our code to use
    the dependency injection pattern.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的讨论来看，依赖注入似乎是一个更好的选择。可读性不应该成为太大的问题，因为我们只有两层抽象——处理程序（handlers）和引擎（engines）。因此，让我们将我们的代码迁移到使用依赖注入模式。
- en: 'First, remove the `import` statements from `src/handlers/users/create/index.js` and
    change the signature of the `createUser` function to include the `create` engine
    function and the `ValidationError` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`src/handlers/users/create/index.js`中删除`import`语句，并将`createUser`函数的签名更改为包括`create`引擎函数和`ValidationError`类：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we need to inject these dependencies into the handler. In `src/index.js`,
    we are already using the `injectHandlerDependencies` function to inject the database
    client into the handler, so let's modify it to also inject the corresponding engine
    function and `ValidationError` class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将这些依赖项注入到处理器中。在 `src/index.js` 中，我们已经在使用 `injectHandlerDependencies`
    函数将数据库客户端注入到处理器中，所以让我们修改它以同时注入相应的引擎函数和 `ValidationError` 类。
- en: 'First, let''s import all the dependencies inside `src/index.js`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `src/index.js` 中导入所有依赖项：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, let''s create a mapping of handler functions to engine functions, and
    call it `handlerToEngineMap`. We will pass this `handlerToEngineMap` function
    into the `injectHandlerDependencies` function, so that it knows which engine to
    inject:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个处理器函数到引擎函数的映射，并将其称为 `handlerToEngineMap`。我们将这个 `handlerToEngineMap`
    函数传递给 `injectHandlerDependencies` 函数，这样它就知道要注入哪个引擎：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are using the `Map` object, which was introduced in ECMAScript 2015 (ES6).
    A `Map` is a key-value store, where the keys and values can be of any type – primitives,
    objects, arrays, or functions (the last two are just special types of object).
    This is unlike an object literal, where the keys must be either a string or a
    Symbol. Here, we are storing the handler function as the key, and the engine function
    as the value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `Map` 对象，它在 ECMAScript 2015（ES6）中引入。`Map` 是一个键值存储，其中键和值可以是任何类型——原始类型、对象、数组或函数（后两者是特殊类型的对象）。这与对象字面量不同，其中键必须是字符串或
    Symbol。在这里，我们将处理器函数作为键，将引擎函数作为值存储。
- en: 'All that''s left to do in `src/index.js` is to add `handlerToEngineMap` and
    `ValidationError` into `injectHandlerDependencies`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/index.js` 中剩下的所有事情就是将 `handlerToEngineMap` 和 `ValidationError` 添加到 `injectHandlerDependencies`
    中：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, update the `injectHandlerDependencies` function to relay these dependencies
    into the handler:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新 `injectHandlerDependencies` 函数以将这些依赖项传递给处理器：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ve made a lot of changes in many files, so you should run all of our existing
    tests again to make sure that we didn''t break anything. You may also want to
    commit these changes to the Git repository:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在许多文件中做了很多修改，所以你应该再次运行我们所有的现有测试，以确保我们没有破坏任何东西。你可能还希望将这些更改提交到 Git 仓库：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Promises and Mocha
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺和 Mocha
- en: We're now ready to get back to our original task – writing unit tests for our
    Create User request handler! You should have enough understanding to implement
    the unit tests for the handler yourself, but we'd like to first give you some
    hints with regards to promises.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好回到我们的原始任务——为我们的创建用户请求处理器编写单元测试！你应该有足够的知识来自行实现处理器的单元测试，但我们在给出有关承诺的一些提示之前，想先给你一些提示。
- en: 'If the function we are testing perform asynchronous operations, there''s no
    guarantee that the asynchronous operations would complete before our assertion
    code is run. For instance, if our `create` engine function is actually very slow
    to resolve, like so:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在测试的函数执行异步操作，没有保证异步操作会在我们的断言代码运行之前完成。例如，如果我们的 `create` 引擎函数实际上非常慢，如下所示：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then the following test would fail:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 那么以下测试将失败：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Mocha can deal with asynchronous code in two ways – using callbacks or promises.
    Since we'd generally avoid using callbacks, let's focus on working with promises.
    In Mocha, if we return a promise in the preceding `beforeEach` block, Mocha will
    wait for the promise to settle before running the relevant `describe` and `it`
    blocks. Therefore, when writing functions that involve asynchronous operations,
    we should *always return a promise*. Not only does it make the function easier
    to test, but it also allows you to chain multiple promises together should you
    have that need in the future.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 可以通过两种方式处理异步代码——使用回调或承诺。由于我们通常会避免使用回调，让我们专注于与承诺一起工作。在 Mocha 中，如果我们返回一个承诺在先前的
    `beforeEach` 块中，Mocha 将等待承诺解决后再运行相关的 `describe` 和 `it` 块。因此，在编写涉及异步操作的功能时，我们应该*始终返回一个承诺*。这不仅使函数更容易测试，还允许你在将来有需要时将多个承诺链接在一起。
- en: 'Therefore, we must update our `createUser` function to a promise:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须将我们的 `createUser` 函数更新为一个承诺：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, make sure that all of our `beforeEach` blocks also return a promise:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，确保所有的 `beforeEach` 块也返回一个承诺：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Dealing with rejected promises
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理拒绝的承诺
- en: 'However, another limitation of Mocha is that you cannot return a rejected promise
    inside the hook functions. If you do, Mocha will think the test has failed. In
    those cases, you should move the function that you expect to fail inside the `it`
    block, and make any assertions inside a `catch` block:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Mocha的另一个限制是，你无法在钩子函数中返回一个拒绝的承诺。如果你这样做，Mocha会认为测试失败了。在这种情况下，你应该将你期望失败的函数移动到`it`块中，并在`catch`块中进行任何断言：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Completing the unit tests
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成单元测试
- en: You now have enough understanding of unit tests, Mocha, and working with promises
    to complete the unit tests for the Create User handler. Have a go at implementing
    this yourself, referring back to the reference code sample only if you need to.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对单元测试、Mocha以及处理承诺有了足够的了解，可以完成创建用户处理器的单元测试。尝试自己实现它，只有在需要时才参考参考代码示例。
- en: 'As always, don''t forget to run the unit and E2E tests to make sure you haven''t
    introduced any regression, and then commit the changes to our repository:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，别忘了运行单元和端到端测试，以确保你没有引入任何回归，然后将更改提交到我们的仓库：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Unit testing our engine
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对我们的引擎进行单元测试
- en: 'Next, let''s test our `create` engine function. Like our previous `createUser`
    request handler, the `src/engines/users/create/index.js` module contains two `import`
    statements, which makes it difficult to test. Therefore, just like before, we
    must pull these dependencies out, and import them back into `src/index.js`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试我们的`create`引擎函数。就像我们之前的`createUser`请求处理器一样，`src/engines/users/create/index.js`模块包含两个`import`语句，这使得测试变得困难。因此，就像之前一样，我们必须将这些依赖项提取出来，并将它们重新导入到`src/index.js`中：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, update the `injectHandlerDependencies` function to inject the validator
    function into the handler:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新`injectHandlerDependencies`函数，将验证器函数注入到处理器中：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, inside the handler, relay the validator function and `ValidationError`
    class into the engine function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在处理器内部，将验证器函数和`ValidationError`类传递给引擎函数：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, update the unit tests to cater for this change. Once all tests pass,
    commit this change to Git:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新单元测试以适应这一变化。一旦所有测试通过，将这一更改提交到Git：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once that''s committed, let''s move on to writing the unit tests themselves.
    There are only two cases to test for – when the validator returns with a `ValidationError`,
    or when it returns with `undefined`. Again, because we don''t want our unit tests
    to depend on the validator, and so we will use stubs to simulate its functionality.
    Attempt to implement it yourself and compare it with our implementation, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交，让我们继续编写单元测试本身。只有两种情况需要测试——当验证器返回`ValidationError`时，或者当它返回`undefined`时。同样，因为我们不希望我们的单元测试依赖于验证器，所以我们将使用存根来模拟其功能。尝试自己实现它，并与我们的实现进行比较，如下所示：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As always, run the tests and commit the code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，运行测试并提交代码：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Integration testing our engine
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对我们的引擎进行集成测试
- en: So far, we have been retrofitting our code with unit tests, which test each
    unit individually, independent of external dependencies. However, it's also important
    to have confidence that different units are compatible with each other. This is
    where integration tests are useful. So, let's add some integration tests to our
    User Create engine that'll test its interaction with the database.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在用单元测试改造我们的代码，这些单元测试单独测试每个单元，独立于外部依赖。然而，了解不同的单元之间是否兼容也同样重要。这就是集成测试发挥作用的地方。所以，让我们为我们的用户创建引擎添加一些集成测试，以测试其与数据库的交互。
- en: 'First, let''s update our npm scripts to include a `test:integration` script.
    We''ll also update the glob file in our `test:unit` npm to be more specific and
    select only unit tests. Lastly, update the `test` script to run the integration
    tests after the unit tests:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新我们的npm脚本以包括一个`test:integration`脚本。我们还将更新`test:unit` npm中的glob文件，使其更加具体，仅选择单元测试。最后，更新`test`脚本，在单元测试之后运行集成测试：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `dotenv mocha` part will run Mocha after loading all the environment variables.
    We are then using a double dash (`--`) to signify to our *bash* shell that this
    is the end of the options for the `dotenv` command; anything after the double
    dash is passed into the `mocha` command, like it did previously.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotenv mocha`部分将在加载所有环境变量后运行Mocha。我们随后使用双横线（`--`）来向我们的*bash* shell指示这是`dotenv`命令选项的结束；双横线之后的所有内容都将传递到`mocha`命令中，就像之前一样。'
- en: 'You write your integration tests in the same way as your unit tests, the only
    difference being instead of stubbing everything, you supply the unit you''re testing
    with genuine parameters. Let''s take a look at the signature of our create function
    once again:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你以与单元测试相同的方式编写集成测试，唯一的区别是，你不需要存根一切，而是向你要测试的单元提供真实参数。让我们再次看看我们创建函数的签名：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Previously, we used stubs to simulate the real `db` object and `createUserValidator`
    function. For an integration test, you''d actually import the real validator function
    and instantiate a real Elasticsearch JavaScript client. Once again, try to implement
    the integration tests yourself, and check back here for our solution:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用了存根来模拟真实的 `db` 对象和 `createUserValidator` 函数。对于集成测试，你实际上会导入真实的验证函数并实例化一个真实的
    Elasticsearch JavaScript 客户端。再次尝试自己实现集成测试，并在此处查看我们的解决方案：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Again, run all the tests to make sure they all pass, then commit these changes
    to the repository:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行所有测试以确保它们全部通过，然后将这些更改提交到仓库：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Adding test coverage
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加测试覆盖率
- en: At the beginning of our TDD process, we wrote E2E tests first and used them
    to drive development. However, for unit and integration tests, we actually retrofitted
    them back into our implementation. Therefore, it's very likely that we missed
    some scenarios that we should have tested for.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 TDD 流程开始时，我们首先编写了端到端测试，并使用它们来驱动开发。然而，对于单元和集成测试，我们实际上将它们重新整合到我们的实现中。因此，我们很可能错过了我们应该测试的一些场景。
- en: To remedy this practical problem, we can summon the help of **test coverage**
    tools. A test coverage tool will run your tests and record all the lines of code
    that were executed; it will then compare this with the total number of lines in
    your source file to return a percentage coverage. For example, if my module contains
    100 lines of code, and my tests only ran 85 lines of my module code, then my test
    coverage is 85%. This may mean that I have dead code or that I missed certain
    use cases. Once I know that some of my tests are not covering all of my code,
    I can then go back and add more test cases.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以召唤测试覆盖率工具的帮助。测试覆盖率工具将运行你的测试并记录所有已执行的代码行；然后，它将与此源文件中的总行数进行比较，以返回一个覆盖率百分比。例如，如果我的模块包含
    100 行代码，而我的测试只运行了 85 行模块代码，那么我的测试覆盖率是 85%。这可能意味着我有一些死代码，或者我错过了某些用例。一旦我知道我的某些测试没有覆盖所有代码，我就可以回过头来添加更多的测试用例。
- en: 'The *de facto* test coverage framework for JavaScript is `istanbul` ([github.com/gotwarlost/istanbul](https://github.com/gotwarlost/istanbul)).
    We will be using istanbul via its command line interface, `nyc` ([github.com/istanbuljs/nyc](https://github.com/istanbuljs/nyc)).
    So, let''s install the `nyc` package:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的**事实上的**测试覆盖率框架是 `istanbul` ([github.com/gotwarlost/istanbul](https://github.com/gotwarlost/istanbul))。我们将通过其命令行界面
    `nyc` ([github.com/istanbuljs/nyc](https://github.com/istanbuljs/nyc)) 使用 istanbul。所以，让我们安装
    `nyc` 包：
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, add the following npm script to `package.json`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下 npm 脚本添加到 `package.json`：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we can run `yarn run test:unit:coverage` to get a report of our code coverage.
    Because we specified the `--reporter=text` option, `nyc` which will print the
    results to stdout in a text table format:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `yarn run test:unit:coverage` 来获取我们的代码覆盖率报告。因为我们指定了 `--reporter=text`
    选项，`nyc` 将以文本表格格式将结果打印到标准输出：
- en: '![](img/8b292ab9-3c72-40fc-82e7-f2de0962bfd6.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b292ab9-3c72-40fc-82e7-f2de0962bfd6.png)'
- en: The `--reporter=html` flag will also instruct `nyc` to create an HTML report,
    which is stored at a new `coverage` directory at the root of the project.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`--reporter=html` 标志还会指示 `nyc` 创建一个 HTML 报告，该报告存储在项目根目录下的新 `coverage` 目录中。'
- en: Reading a test coverage report
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读测试覆盖率报告
- en: 'Inside the `coverage` directory, you should find an `index.html` file; open
    it up in a web browser to continue:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `coverage` 目录中，你应该找到一个 `index.html` 文件；在网页浏览器中打开它以继续：
- en: '![](img/4850beca-4bde-4ce5-b632-41320b7ac81c.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4850beca-4bde-4ce5-b632-41320b7ac81c.png)'
- en: 'At the top, you can see different percentages of test coverage. Here''s what
    they mean:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，你可以看到不同的测试覆盖率百分比。以下是它们的含义：
- en: '**Lines**: Percentage of the total lines of code (LoC) that were run.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行数**：已运行的代码行数占总代码行数（LoC）的百分比。'
- en: '**Statements**: Percentage of total statements that were executed. If you always
    use a separate line for each statement (as is the case in our project), then Statements
    and Lines would have the same value. If you have multiple statements per line
    (for example, `if (condition) { bar = 1; }`), then there''ll be more statements
    than lines, and the Statements coverage may be lower. The Statements coverage
    is more useful than Lines coverage; the Lines coverage exists for interoperability
    with line-oriented coverage tools like `lcov`. Note that you can use ESLint to
    enforce having one statement per line by enabling the `max-statements-per-line`
    rule.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句**：执行的总语句的百分比。如果你总是为每条语句使用单独的一行（正如在我们的项目中那样），那么语句和行将具有相同的值。如果你每行有多个语句（例如，`if
    (condition) { bar = 1; }`），那么语句将多于行，语句覆盖率可能会更低。语句覆盖率比行覆盖率更有用；行覆盖率存在是为了与以行为单位的覆盖率工具（如`lcov`）兼容。请注意，您可以通过启用`max-statements-per-line`规则来使用ESLint强制每行只有一个语句。'
- en: '**Branches**: Imagine our code as a set of paths – if certain conditions are
    met, the execution of our program will follow a certain path; when a different
    set of conditions is employed, the execution will follow a different path. These
    paths diverge at conditional statements into *branches*. The branch coverage indicates
    how many of these branches are covered.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支**：将我们的代码想象成一组路径——如果满足某些条件，程序的执行将遵循某个路径；当使用不同的条件集时，执行将遵循不同的路径。这些路径在条件语句中分化成*分支*。分支覆盖率表示这些分支中有多少被覆盖。'
- en: '**Functions** : The percentage of total functions that were called.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：被调用的总函数的百分比。'
- en: We can see that our overall Statements coverage is 91.84%, which is pretty good
    already. However, our `handlers/users/create/index.js` file seems to have only
    66.67% coverage. Let's investigate why!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的整体语句覆盖率是 91.84%，这已经相当不错了。然而，我们的`handlers/users/create/index.js`文件似乎只有
    66.67% 的覆盖率。让我们调查一下原因！
- en: 'Click on the handlers/users/create link until you arrive at the screen showing
    the source code of the file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 handlers/users/create 链接，直到到达显示文件源代码的屏幕：
- en: '![](img/90679309-0891-4780-847b-ec29341915c0.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90679309-0891-4780-847b-ec29341915c0.png)'
- en: A green bar on the left-hand side indicates that the line is covered. Furthermore,
    `nyc` will give you a count for how many times that line was executed over the
    entire run of our unit test suite. For example, the preceding `res.status(201)`
    line has been executed 8 times.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的绿色条表示该行已被覆盖。此外，`nyc`将给出该行在整个单元测试套件运行中被执行次数的计数。例如，前面的`res.status(201)`行已被执行了8次。
- en: 'A red bar indicates that the line has not been executed. This can mean one
    of a few things:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 红色条表示该行尚未执行。这可能意味着以下几种情况之一：
- en: Our tests are insufficient and do not test all possible scenarios
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们测试不足，没有测试所有可能的情况
- en: There's unreachable code in our project
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的项目中有不可达的代码
- en: Any other gaps in the coverage are indicated in the code itself as a letter
    enclosed inside a black box; when you hover over it, it will provide a more descriptive
    reason. In our case, there's a letter E, which stands for "else path not taken",
    meaning there's no test that covers what happens when the `create` function rejects
    with an error that is *not* an instance of `ValidationError`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他覆盖率缺口都在代码本身中以黑色框内的字母表示；当您悬停在它上面时，它将提供更详细的解释。在我们的情况下，有一个字母E，代表“未执行的else路径”，意味着没有测试覆盖到`create`函数拒绝时返回的不是`ValidationError`实例的情况。
- en: In our case, it actually highlights an error in our code. Inside the `onRejected`
    function of our `then` block, we are returning `undefined` if the error is not
    an instance of `ValidationError`. This will, in effect, return a resolved promise,
    and thus the `catch` block will never catch the error. Furthermore, we are also
    not testing for the case where the `create` function returns a generic error.
    Therefore, let's increase the test coverage for this module by fixing these two
    issues.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这实际上突显了我们代码中的一个错误。在我们的`then`块的`onRejected`函数内部，如果错误不是`ValidationError`的实例，我们将返回`undefined`。这将实际上返回一个已解决的承诺，因此`catch`块将永远不会捕获到错误。此外，我们也没有测试`create`函数返回通用错误的情况。因此，让我们通过修复这两个问题来提高这个模块的测试覆盖率。
- en: 'Before we do, let''s commit our existing changes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，让我们提交现有的更改：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Improving test coverage
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: 'First, inside the `/home/dli/.d4nyll/.beja/final/code/9/src/handlers/users/create/index.js`
    file, change the `return undefined;` statement to propagate the error down the
    promise chain:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `/home/dli/.d4nyll/.beja/final/code/9/src/handlers/users/create/index.js`
    文件中，将 `return undefined;` 语句更改为向下传递错误到承诺链：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, add unit tests to `src/handlers/users/create/index.unit.test.js` to cover
    this missed scenario:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向 `src/handlers/users/create/index.unit.test.js` 添加单元测试以覆盖这个遗漏的场景：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, when we run our `test:unit:coverage` script and look at the report again,
    you will be glad to see that coverage is now 100%!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 `test:unit:coverage` 脚本并再次查看报告时，你会很高兴地看到覆盖率现在是100%！
- en: '![](img/3e3f73fe-4f42-4530-b43a-095629bbb786.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e3f73fe-4f42-4530-b43a-095629bbb786.png)'
- en: 'Now, commit this refactoring step into your repository:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这个重构步骤提交到你的仓库中：
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Code coverage versus test quality
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率与测试质量
- en: As illustrated in the preceding section, code coverage tools can help you uncover
    mistakes in your code. However, they should be used as a diagnostic tool only;
    you shouldn't be chasing after 100% code coverage as a goal in itself.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，代码覆盖率工具可以帮助你发现代码中的错误。然而，它们应该仅作为诊断工具使用；你不应该将追求100%代码覆盖率作为一个目标本身。
- en: 'This is because code coverage has no relation to the quality of your tests.
    You can define test cases that cover 100% of your code, but if the assertions
    are wrong, or if the tests have errors in it, then the perfect coverage means
    nothing. For instance, the following test block will always pass, even though
    one of the assertions suggests it would fail:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为代码覆盖率与测试质量无关。你可以定义覆盖100%代码的测试用例，但如果断言是错误的，或者测试中存在错误，那么完美的覆盖率毫无意义。例如，以下测试块总是会通过，即使其中一个断言表明它应该失败：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This highlights the point that *code coverage cannot detect bad tests*. Instead,
    you should focus on writing meaningful tests that will actually show bugs when
    they arise; if you do that, the test coverage will naturally remain high, and
    you can use the reports to improve whatever you've missed in your tests.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这强调了代码覆盖率不能检测到坏测试的观点。相反，你应该专注于编写有意义的测试，这样当出现问题时，它们实际上会显示出错误；如果你这样做，测试覆盖率自然会保持高，你可以使用报告来改进你在测试中遗漏的内容。
- en: You don't have to test everything, all the time
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你不必总是测试一切
- en: 'After we updated our unit tests to cover the missed `catch` block, our Statements
    coverage is now 100%. However, if we examine our code, we''ll find two modules
    that still lack unit tests:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新了单元测试以覆盖遗漏的 `catch` 块之后，我们的语句覆盖率现在是100%。然而，如果我们检查我们的代码，我们会发现还有两个模块缺少单元测试：
- en: '`validate`: User validation function at `src/validators/users/create.js`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate`：位于 `src/validators/users/create.js` 的用户验证函数'
- en: '`injectHandlerDependencies`: Utility function at `src/utils/inject-handler-dependencies.js`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`injectHandlerDependencies`：位于 `src/utils/inject-handler-dependencies.js` 的实用函数'
- en: They did not show up in the coverage report because the unit tests never imported
    those files. But do we need to write unit tests for every unit? To answer this
    question, you should ask yourself – "Do I have confidence that this block of code
    works?" If the answer is "yes", then writing additional tests may be unnecessary.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 它们没有出现在覆盖率报告中，因为单元测试从未导入过这些文件。但我们是否需要为每个单元编写单元测试呢？为了回答这个问题，你应该问自己——“我对这段代码的工作有信心吗？”如果答案是“是”，那么编写额外的测试可能是不必要的。
- en: Code coverage for a unit should not be analyzed based on unit tests alone, since
    there may be integration and E2E tests that use that unit. If these other tests
    cover what the unit tests don't, and the tests are passing, then that should give
    you confidence that your unit is working as intended.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 单元的代码覆盖率不应仅基于单元测试来分析，因为可能还有使用该单元的集成和端到端测试。如果这些其他测试覆盖了单元测试没有覆盖的内容，并且测试通过，那么这应该让你有信心你的单元按预期工作。
- en: Therefore, a more useful metric is to analyze the code coverage of *all tests*,
    not just unit tests.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个更有用的指标是分析所有测试的代码覆盖率，而不仅仅是单元测试。
- en: Unifying test coverage
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一测试覆盖率
- en: 'Therefore, let''s add coverage scripts for integration and E2E tests:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加集成和端到端测试的覆盖率脚本：
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, when we run the `test:e2e:coverage` script, the coverage report shows
    results for compiled files in the `dist/` directory, rather than the source files
    from `src/`. This is because our E2E test script (`scripts/e2e.test.sh`) is running the
    `serve` npm script, which transpiles our code before running it. To fix this,
    let''s add a new `test:serve` script, which uses `babel-node` to directly run
    our code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们运行 `test:e2e:coverage` 脚本时，覆盖率报告显示的是 `dist/` 目录下编译文件的覆盖率结果，而不是 `src/`
    目录下的源文件。这是因为我们的端到端测试脚本 (`scripts/e2e.test.sh`) 在运行之前会执行 `serve` npm 脚本，将我们的代码进行转换。为了解决这个问题，让我们添加一个新的
    `test:serve` 脚本，该脚本使用 `babel-node` 直接运行我们的代码：
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, update `scripts/e2e.test.sh` to use this modified script instead of `serve`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新 `scripts/e2e.test.sh` 脚本，使用这个修改后的脚本而不是 `serve`：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now, when we run the `test:coverage` or `test:e2e:coverage` again, it will show
    coverage for files under `src/` instead of `dist/`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行 `test:coverage` 或 `test:e2e:coverage` 脚本时，它将显示 `src/` 目录下文件的覆盖率，而不是
    `dist/` 目录下的文件。
- en: Ignoring files
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略文件
- en: 'However, you may have also noticed that our step definitions are showing up
    in our coverage report. Istanbul is not smart enough to figure out that our step
    definition files are part of the tests, and not the code; therefore, we need to
    manually instruct Istanbul to ignore them. We can do with by adding a `.nycrc`
    file and specifying the `exclude` option:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能也注意到我们的步骤定义出现在了覆盖率报告中。Istanbul 还不够智能，无法判断我们的步骤定义文件是测试的一部分，而不是代码；因此，我们需要手动指导
    Istanbul 忽略它们。我们可以通过添加一个 `.nycrc` 文件并指定 `exclude` 选项来实现：
- en: '[PRE69]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, when we run the `test:coverage` script, the step definition files are excluded
    from the results. All that's left to do is commit our code!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 `test:coverage` 脚本时，步骤定义文件被排除在结果之外。剩下要做的就是提交我们的代码！
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Finishing up
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成工作
- en: 'We have now modularized and tested the code for the Create User feature. Therefore,
    now is a good time to merge our current `create-user/refactor-modules` branch
    into the `create-user/main` branch. Since this also completes the Create User
    feature, we should merge the `create-user/main` feature branch back into the `dev`
    branch:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经模块化了 Create User 功能的代码，并对其进行了测试。因此，现在是合并我们当前的 `create-user/refactor-modules`
    分支到 `create-user/main` 分支的好时机。由于这也完成了 Create User 功能，我们应该将 `create-user/main`
    功能分支合并回 `dev` 分支：
- en: '[PRE71]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of the preceding three chapters, we have shown you how to write
    E2E tests, use them to drive the development of your feature, modularize your
    code wherever possible, and then increase confidence in your code by covering
    modules with unit and integration tests.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个章节中，我们向您展示了如何编写端到端测试，使用它们来推动您功能的开发，尽可能地对代码进行模块化，然后通过单元测试和集成测试覆盖模块来增加您对代码的信心。
- en: In the next chapter, you will be tasked with implementing the rest of the features
    by yourself. We will outline some principles of API design that you should follow,
    and you can always reference our sample code bundle, but the next chapter is where
    you truly get to practice this process independently.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将需要自己实现剩余的功能。我们将概述一些您应该遵循的 API 设计原则，您始终可以参考我们的示例代码包，但下一章是您真正独立练习这个过程的时刻。
- en: '"Learning is an active process. We learn by doing. Only knowledge that is used
    sticks in your mind."'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: “学习是一个积极的过程。我们通过实践来学习。只有被使用的知识才能留在你的脑海中。”
- en: '- Dale Carnegie, author of the book How to Win Friends and Influence People'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '- 戴尔·卡耐基，著有《如何赢得朋友与影响他人》一书'
