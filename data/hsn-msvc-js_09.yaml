- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Securing Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护微服务
- en: In today’s digital world, many applications are built from smaller, independent
    services working together. These *microservices* offer flexibility and scalability,
    but keeping them secure is crucial. Imagine a microservice as a small shop on
    a busy street. You want to ensure that only authorized customers can enter (authentication)
    and only those with permission can access specific areas (authorization). Likewise,
    you’d encrypt sensitive information such as credit card details (data encryption).
    By constantly monitoring for suspicious activity and keeping the shops updated
    (patching), you can maintain a safe and secure shopping experience. This chapter
    will guide you through securing your microservices using similar practical strategies
    and more!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的数字世界中，许多应用程序是由较小的、独立的服务共同构建而成的。这些*微服务*提供了灵活性和可扩展性，但保持它们的安全至关重要。想象一下，微服务就像繁忙街道上的一家小商店。您希望确保只有授权的客户可以进入（身份验证）并且只有那些有权限的人可以访问特定区域（授权）。同样，您会加密敏感信息，如信用卡详情（数据加密）。通过不断监控可疑活动并保持商店更新（打补丁），您可以保持一个安全且安全的购物体验。本章将指导您使用类似实用的策略来保护您的微服务，并介绍更多内容！
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Security, authentication, and authorization in microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务中的安全、身份验证和授权
- en: Getting started with JSON Web Tokens
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用JSON Web Tokens
- en: Implementing an Authentication Microservice
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现身份验证微服务
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow along in the chapter, you need to have installed an IDE (we prefer
    Visual Studio Code), Postman, Docker, and a browser of your choice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，您需要安装一个IDE（我们更喜欢Visual Studio Code）、Postman、Docker以及您选择的浏览器。
- en: It is preferable to download our repository from [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09)
    to easily follow our code snippets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最好从[https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch09)下载我们的存储库，以便轻松跟随我们的代码片段。
- en: Security, authentication, and authorization in microservices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的安全、身份验证和授权
- en: In a microservices architecture, ensuring robust security, authentication, and
    authorization is crucial due to the distributed nature of the system. Implementing
    these mechanisms properly protects microservices from unauthorized access, ensuring
    data integrity and confidentiality across the system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，由于系统的分布式特性，确保强大的安全性、身份验证和授权至关重要。正确实施这些机制可以保护微服务免受未经授权的访问，确保整个系统中的数据完整性和机密性。
- en: Understanding security
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解安全性
- en: In microservices, **security** refers to the measures and practices used to
    protect the system’s components, data, and communication channels from unauthorized
    access, breaches, and attacks. It involves securing each service individually,
    as well as the interactions between services, ensuring data is safe both in transit
    and at rest. Security in microservices typically includes mechanisms such as encryption,
    authentication, authorization, and monitoring to safeguard the system against
    vulnerabilities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，**安全**指的是用于保护系统组件、数据和通信通道免受未经授权访问、违规和攻击的措施和实践。它包括对每个服务进行单独的安全保护，以及服务之间的交互，确保数据在传输和静止状态下都是安全的。微服务中的安全通常包括加密、身份验证、授权和监控等机制，以保护系统免受漏洞的侵害。
- en: Microservices, while offering advantages in flexibility and scalability, introduce
    unique security challenges. Unlike monolithic applications with a single attack
    surface, microservices create a distributed system with many potential entry points
    for attackers. That is why security becomes even more important compared to monolithic
    applications. A security breach in one microservice can quickly compromise the
    entire system. Before deploying our services, we should provide a properly tested
    and fully functional security layer over our microservices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务虽然提供了灵活性和可扩展性的优势，但也引入了独特的安全挑战。与具有单一攻击面的单体应用不同，微服务创建了一个具有许多潜在攻击入口点的分布式系统。这就是为什么与单体应用相比，安全性变得更加重要。一个微服务的安全漏洞可以迅速危及整个系统。在我们部署服务之前，我们应该在我们的微服务上提供一个经过充分测试且完全功能的安全层。
- en: Exploring authentication
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索身份验证
- en: '**Authentication** is a process of verifying a user’s or service’s identity,
    and it plays a critical role in securing microservice applications. In a world
    of distributed systems with numerous access points, authentication ensures that
    only authorized users and services can interact with your microservices.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证**是一个验证用户或服务身份的过程，它在确保微服务应用程序安全中起着关键作用。在一个拥有众多访问点的分布式系统世界中，身份验证确保只有授权用户和服务可以与您的微服务交互。'
- en: 'But why is authentication valuable in microservices? Let’s answer this question
    here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么身份验证在微服务中很有价值呢？让我们在这里回答这个问题：
- en: '**Enhanced security**: Microservices create a distributed attack surface. Robust
    authentication acts as a gatekeeper, preventing unauthorized access and potential
    breaches.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强安全性**：微服务创建了一个分布式攻击面。强大的身份验证充当守门人，防止未经授权的访问和潜在的违规行为。'
- en: '**Granular control**: Authentication allows you to define access levels for
    different users and services. This ensures that only authorized entities can perform
    specific actions within each microservice.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度控制**：身份验证允许您为不同的用户和服务定义访问级别。这确保了只有授权实体可以在每个微服务内执行特定操作。'
- en: '**Improved trust**: By implementing strong authentication, you build trust
    with users and external systems relying on your microservices. They can be confident
    their data is secure.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强信任**：通过实施强身份验证，您与依赖您的微服务的用户和外部系统建立信任。他们可以确信他们的数据是安全的。'
- en: '**Microservice communication security**: Authentication secures communication
    between microservices themselves. This prevents unauthorized services from impersonating
    legitimate ones and gaining access to sensitive data.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务通信安全**：身份验证确保了微服务之间的通信安全。这阻止了未经授权的服务冒充合法服务并访问敏感数据。'
- en: Applying authentication is not hard thanks to the packages of Node.js but there
    are some microservice and authentication challenges you should consider before
    starting to apply it. We will discuss two of them in this section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js的包，应用身份验证并不困难，但在开始应用之前，您应该考虑一些微服务和身份验证挑战。我们将在本节中讨论其中的两个。
- en: 'The first challenge is choosing either a **centralized** or **decentralized**
    authentication service. Deciding on a centralized authentication service or embedding
    it within each microservice can be a challenge. There’s a trade-off between simplicity
    and potential bottlenecks. Let’s look at both of these types of services here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首个挑战是选择一个**集中式**或**分布式**的身份验证服务。决定采用集中式身份验证服务或将其嵌入到每个微服务中可能是一个挑战。在简单性和潜在的瓶颈之间存在着权衡。让我们在这里看看这两种类型的服务：
- en: A centralized authentication service, also known as an **Identity Provider**
    (**IdP**), is a trusted third-party system that manages the authentication process
    for users across multiple applications or microservices. Instead of each microservice
    handling authentication independently, the IdP takes on this responsibility, offering
    a consistent, secure, and streamlined authentication mechanism.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式身份验证服务，也称为**身份提供者**（**IdP**），是一个受信任的第三方系统，它管理着跨多个应用程序或微服务的用户身份验证过程。而不是每个微服务独立处理身份验证，IdP承担这一责任，提供一致、安全和简化的身份验证机制。
- en: A decentralized authentication service involves each microservice independently
    managing its own authentication process. Unlike a centralized system where a single
    IdP handles authentication, decentralized services allow each microservice to
    have its own embedded authentication logic, providing greater autonomy and flexibility
    to each service but introducing complexity in maintaining consistency.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式身份验证服务涉及每个微服务独立管理其自身的身份验证过程。与集中式系统不同，其中单个身份提供者（IdP）处理身份验证，分布式服务允许每个微服务拥有自己的嵌入式身份验证逻辑，为每个服务提供更大的自主性和灵活性，但同时也引入了维护一致性的复杂性。
- en: When choosing between centralized and decentralized authentication, consider
    factors such as application complexity, scalability needs, security tolerance,
    and development resources, as a centralized IdP simplifies security enforcement
    but adds complexity, while decentralized options require more development effort
    per microservice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择集中式和分布式身份验证之间，考虑因素如应用复杂性、可扩展性需求、安全容忍度和开发资源，因为集中式IdP简化了安全执行但增加了复杂性，而分布式选项需要每个微服务更多的开发工作。
- en: If you cannot pick one or the other, a *hybrid* approach might be more suited
    for your case. A hybrid approach can be a good option in some cases. A central
    IdP can handle user authentication and issue tokens, while individual microservices
    validate those tokens independently. This offers a balance between security, flexibility,
    and resilience. As we mentioned before, there’s no one-size-fits-all solution.
    Evaluate your specific requirements and choose the approach that best aligns with
    your security goals and development needs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法选择其中之一，那么一种*混合*方法可能更适合您的案例。在某些情况下，混合方法可能是一个不错的选择。中央身份提供者（IdP）可以处理用户身份验证并颁发令牌，而各个微服务可以独立验证这些令牌。这种方法在安全、灵活性和弹性之间提供了平衡。正如我们之前提到的，没有一种适合所有情况的解决方案。评估您的具体需求，并选择与您的安全目标和开发需求最佳匹配的方法。
- en: The second challenge can be session management. Traditional session management
    techniques might not be ideal for the stateless nature of microservices. Alternatives
    such as **JSON Web Tokens** (**JWTs**) are often preferred. We will talk about
    JWTs in more detail later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个挑战可能是会话管理。传统的会话管理技术可能不适合微服务的无状态特性。**JSON Web Tokens**（**JWTs**）等替代方案通常更受欢迎。我们将在本章后面更详细地讨论JWTs。
- en: Defining authorization
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义授权
- en: '**Authorization** in microservices is critical for several reasons, primarily
    focusing on security, resource management, and compliance. It ensures that only
    users or services with the appropriate permissions can access or perform actions
    on specific resources or data. This prevents unauthorized access and potential
    misuse. By *enforcing* strict access controls, the potential attack surface is
    minimized. Unauthorized users are restricted from accessing sensitive parts of
    the system, reducing the risk of data breaches and other malicious activities.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中，**授权**至关重要，原因有几个，主要关注安全、资源管理和合规性。它确保只有具有适当权限的用户或服务才能访问或对特定资源或数据进行操作。这防止了未经授权的访问和潜在的滥用。通过*执行*严格的访问控制，潜在的攻击面被最小化。未经授权的用户被限制访问系统的敏感部分，从而降低了数据泄露和其他恶意活动的风险。
- en: Microservices often deal with a wide range of functionalities and data. Authorization
    allows for granular control over who can access which service and what operations
    they can perform, ensuring resources are used appropriately. By *defining* clear
    access controls, resources are allocated and utilized more efficiently, preventing
    unauthorized consumption of resources that could degrade system performance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常处理广泛的职能和数据。授权允许对谁可以访问哪些服务以及他们可以执行哪些操作进行细粒度控制，确保资源得到适当使用。通过*定义*明确的访问控制，资源分配和利用更加高效，防止未经授权的资源消耗，这可能会降低系统性能。
- en: In a microservice architecture, each microservice is designed to perform a specific
    function. Authorization ensures that each service has access only to the data
    and operations it requires, promoting the principle of least privilege. This minimizes
    potential security risks and helps to maintain a secure, efficient system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个微服务都被设计来执行特定的功能。授权确保每个服务只能访问它所需的数据和操作，促进了最小权限原则。这最小化了潜在的安全风险，并有助于保持一个安全、高效的系统。
- en: Centralized authorization management can further streamline this process by
    defining and enforcing access policies uniformly across all services. This approach
    simplifies the maintenance and updating of access controls, making it easier to
    ensure consistency across the microservices ecosystem.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在所有服务中统一定义和执行访问策略，集中式授权管理可以进一步简化此过程。这种方法简化了访问控制的维护和更新，使得确保微服务生态系统的一致性变得更加容易。
- en: There are various ways to implement authorization, such as **Role-Based Access
    Control** (**RBAC**), **Attribute-Based Access Control** (**ABAC**), and **Policy-Based
    Access Control** (**PBAC**). While these are out of the scope of this book, by
    adopting the appropriate method, you can ensure that your system’s security policies
    are both robust and adaptable to your specific requirements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实施授权有多种方式，例如**基于角色的访问控制**（**RBAC**）、**基于属性的访问控制**（**ABAC**）和**基于策略的访问控制**（**PBAC**）。虽然这些内容超出了本书的范围，但通过采用适当的方法，您可以确保您的系统安全策略既强大又适应您的具体需求。
- en: Best practices for authorization
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权的最佳实践
- en: 'Best practices are essential to ensure robust security, consistency, and efficiency
    in managing access controls and authorization across microservices. Let’s look
    at some of these best practices here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践对于确保在微服务中管理访问控制和授权的稳健性、一致性和效率至关重要。让我们在这里看看一些这些最佳实践：
- en: '**Least privilege principle**: Give only the permissions that users or services
    need to do their jobs, which helps reduce the chance of unauthorized access.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小权限原则**: 只授予用户或服务完成工作所需的权限，这有助于减少未经授权访问的机会。'
- en: '**Centralized authorization management**: Use a single system to manage who
    can access what across all microservices, making it easier to maintain and ensure
    security.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式授权管理**: 使用单一系统来管理所有微服务中谁可以访问什么，使其更容易维护并确保安全性。'
- en: '**Regular audits and reviews**: Check and review who has access to what regularly
    to make sure everything is safe and up to date.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**• 定期审计和审查**: 定期检查和审查谁有权访问什么，以确保一切安全且保持最新。'
- en: '**Reserve access**: Set permissions based on roles so users and services only
    have access to what matches their responsibilities.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预留访问**: 根据角色设置权限，确保用户和服务只能访问与其职责相匹配的内容。'
- en: '**Token expiration and revocation**: Use tokens that expire quickly and have
    a way to cancel them if needed, to lower the risk if a token is compromised.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌过期和撤销**: 使用快速过期的令牌，并在需要时有一种取消它们的方法，以降低令牌被泄露的风险。'
- en: We delved into the critical importance of authorization in microservices and
    its role in maintaining security, resource management, and compliance. Now, let’s
    differentiate between authorization and authentication.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了授权在微服务中的关键重要性及其在维护安全、资源管理和合规性中的作用。现在，让我们区分授权和认证。
- en: Difference between authentication and authorization
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证与授权的区别
- en: In microservices architectures, authorization plays a critical role in securing
    access to resources and data. Before diving into details, we need to understand
    and differentiate between the terms **authentication** and **authorization**.
    Authentication verifies the identity of a user or service trying to access the
    system. It typically involves checking credentials such as usernames and passwords,
    API keys, or tokens issued by an authorization server. It is similar to checking
    your ID at the entrance of a building.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，授权在确保资源和数据访问安全方面发挥着关键作用。在深入细节之前，我们需要了解并区分术语**认证**和**授权**。认证验证试图访问系统的用户或服务的身份。它通常涉及检查凭证，如用户名和密码、API密钥或授权服务器发行的令牌。这类似于在建筑物的入口处检查您的身份证。
- en: On the other hand, authorization determines what actions a verified user or
    service can perform within the system. It Involves enforcing predefined rules
    based on user roles, permissions, or attributes associated with the request. It
    is similar to how, once you’re verified to enter the building (authentication),
    your access card determines which floors or areas you can enter (authorization).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，授权确定经过验证的用户或服务可以在系统中执行哪些操作。它涉及根据用户角色、权限或与请求关联的属性执行预定义规则。这类似于一旦您被验证可以进入建筑物（认证），您的访问卡就决定了您可以进入哪些楼层或区域（授权）。
- en: 'Here are the key differences between authentication and authorization:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是认证和授权之间的关键区别：
- en: '**Objective**: Authentication answers *Who are you?*, while authorization answers
    *What can* *you do?*.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**: 认证回答“你是谁？”，而授权回答“你能做什么？”。'
- en: '**Timing**: Authentication typically happens first, followed by authorization
    checks on specific actions.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**: 认证通常首先发生，然后是对特定操作的授权检查。'
- en: '**Focus**: Authentication deals with identity verification, while authorization
    focuses on access control.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重点**: 认证处理身份验证，而授权侧重于访问控制。'
- en: '**Microservices and authorization**:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务和授权**:'
- en: 'In monolithic systems, authorization is often centralized. But microservices,
    with their distributed nature, require a more distributed approach to authorization.
    Here are some common strategies:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体系统中，授权通常是集中的。但微服务，由于其分布式特性，需要一种更分布式的授权方法。以下是一些常见的策略：
- en: '**• Per-service authorization**: Each microservice manages authorization for
    its resources and data.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**• 服务级授权**: 每个微服务管理其资源和数据的授权。'
- en: '**• API gateway**: A central API gateway can handle authorization checks before
    routing requests to individual services'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**• API网关**: 一个中央API网关可以在将请求路由到单个服务之前处理授权检查。'
- en: '**• Dedicated authorization service**: A separate service manages authorization
    policies and enforces them across all microservices'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**• 专用授权服务**：一个独立的服务管理授权策略并在所有微服务中强制执行'
- en: Which one to select? Well, choosing the right approach depends on factors such
    as the complexity of your system, security requirements, and scalability needs.
    As we mentioned before, let’s learn about the JWT together. A JWT is widely used
    for authentication and authorization purposes in distributed systems such as microservices
    because it is stateless, meaning the server does not need to store session data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应该选择哪一个？嗯，选择正确的方法取决于诸如系统复杂性、安全要求和可扩展性需求等因素。正如我们之前提到的，让我们一起来了解 JWT。JWT 在分布式系统中广泛用于身份验证和授权目的，如微服务，因为它是无状态的，这意味着服务器不需要存储会话数据。
- en: Getting started with JWTs
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 JWT
- en: The real world is constantly changing, and programs need to be adaptable to
    handle different situations. The elements of programs are also evaluated. The
    technique you used 10 years ago may not be valid nowadays.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 真实世界不断变化，程序需要能够适应处理不同的情况。程序元素也会被评估。你 10 年前使用的技巧可能现在不再有效。
- en: Years ago, we used to use **session-based authorization**, which was simple,
    popular, easy to grasp, and easy to adapt. It is still a topic for discussion
    but we mostly prefer to use different types of authentication techniques that
    are more secure. Before switching to JWT, it is helpful to talk about session-based
    authentication.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我们曾经使用过**基于会话的授权**，它简单、流行、易于理解且易于适应。它仍然是一个讨论的话题，但我们更倾向于使用更安全的不同类型的身份验证技术。在切换到
    JWT 之前，讨论基于会话的授权是有帮助的。
- en: In this type of authentication, you enter your username and password. The server
    checks whether your credentials are valid. If valid, the server creates a session
    with a unique identifier (session ID). This session ID might be stored in a cookie
    on your browser. With each request to the website during that session, your browser
    sends the session ID back to the server. The server checks the session ID and
    grants access if it’s valid, allowing you to stay logged in. The session expires
    after a period of inactivity (e.g., 30 minutes) or when you log out. This invalidates
    the session ID.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种类型的身份验证中，你输入用户名和密码。服务器检查你的凭据是否有效。如果有效，服务器会创建一个带有唯一标识符（会话 ID）的会话。这个会话 ID 可能会被存储在你的浏览器上的
    cookie 中。在会话期间对网站的每次请求，你的浏览器都会将会话 ID 发送回服务器。服务器检查会话 ID，如果有效，则授予访问权限，允许你保持登录状态。会话在一段时间的不活动后（例如，30
    分钟）或当你登出时过期。这会使会话 ID 无效。
- en: On the other hand, **token-based authentication** offers several advantages
    over session-based authentication. Your sessions rely on the server storing information
    about each active user. This can become burdensome for applications with a large
    user base. Tokens, stored on the client side, alleviate this pressure on the server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**基于令牌的身份验证**与基于会话的身份验证相比具有几个优势。你的会话依赖于服务器存储有关每个活跃用户的信息。对于拥有大量用户的程序，这可能会变得负担沉重。存储在客户端的令牌减轻了服务器上的这种压力。
- en: The second important difference is that session-based authentication requires
    the server to maintain session data for each user. Token-based authentication
    is stateless, meaning the server only verifies the token itself, not referencing
    any stored user data. This simplifies server architecture and potentially improves
    performance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要的区别是，基于会话的身份验证要求服务器为每个用户维护会话数据。基于令牌的身份验证是无状态的，这意味着服务器只验证令牌本身，而不引用任何存储的用户数据。这简化了服务器架构并可能提高性能。
- en: From the security perspective, tokens can be self-contained, including information
    such as expiry time and user roles. This reduces reliance on cookies, which can
    be vulnerable to theft. Additionally, tokens can be configured for short lifespans,
    minimizing the window of opportunity if compromised.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，令牌可以自包含，包括诸如过期时间和用户角色等信息。这减少了依赖于容易受到盗窃的 cookie 的依赖。此外，令牌可以被配置为短寿命，以最小化被破坏的机会。
- en: 'Another important feature of tokens is flexibility. Tokens, such as JWTs, can
    embed additional data beyond just user identity. This allows for more granular
    control over access and simplifies authorization processes. Tokens can also be
    used for API calls between different services, whereas sessions are typically
    tied to a specific web application. JWTs are a compact, URL-safe means of representing
    claims to be transferred between two parties. It is commonly used for authorization
    purposes. A JWT is composed of three parts: header, payload, and signature. These
    parts are separated by dots (`.`) and encoded in Base64 URL format.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的另一个重要特性是灵活性。令牌，如JWT，可以嵌入除用户身份之外的其他数据。这允许对访问进行更细粒度的控制，并简化授权过程。令牌还可以用于不同服务之间的API调用，而会话通常与特定的Web应用程序相关联。JWT是一种紧凑、URL安全的表示声明的方式，用于在双方之间传输。它通常用于授权目的。JWT由三部分组成：头部、有效载荷和签名。这些部分由点（`.`）分隔，并以Base64
    URL格式编码。
- en: 'The **header** typically consists of two parts: the type of token (JWT) and
    the signing algorithm being used, such as *HMAC*-*SHA256* or *RSA*. Here is an
    example of a header:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**头部**通常由两部分组成：令牌类型（JWT）和正在使用的签名算法，例如*HMAC*-*SHA256*或*RSA*。下面是一个头部的示例：'
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The **payload** contains the claims. **Claims** are statements about an entity
    (typically, the user) and additional data. There are three types of claims:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效载荷**包含声明。**声明**是关于实体（通常是用户）及其附加数据的陈述。有三种类型的声明：'
- en: '`iss` (issuer), `exp` (expiration time), `sub` (subject), and `aud` (audience).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`（发行者），`exp`（过期时间），`sub`（主题）和`aud`（受众）。'
- en: '**Public claims**: Custom claims that can be defined by users. They should
    be collision-resistant names, such as using a URI or a namespace to avoid conflicts.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共声明**：用户可以定义的自定义声明。它们应该是具有抗碰撞性的名称，例如使用URI或命名空间以避免冲突。'
- en: '**Private claims**: Custom claims are created to share information between
    parties that agree to use them.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有声明**：创建自定义声明以在同意使用它们的各方之间共享信息。'
- en: 'Here is an example of a payload:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个有效载荷的示例：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last element is the **signature**. To create the signature part, you have
    to take the encoded header, the encoded payload, a secret, and the algorithm specified
    in the header. The signature is used to verify that the sender of the JWT is who
    it says it is and to ensure that the message wasn’t changed along the way.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个元素是**签名**。要创建签名部分，您需要取编码后的头部、编码后的有效载荷、一个密钥以及头部中指定的算法。签名用于验证JWT的发送者是否为它所声称的人，并确保消息在传输过程中未被更改。
- en: 'For example, if you use the *HMAC-SHA256* algorithm, the signature will be
    created as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您使用*HMAC-SHA256*算法，签名将按以下方式创建：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output of the algorithm is three Base64-URL strings joined by dots that
    can be easily passed in HTML and HTTP environments.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的输出是三个由点连接的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递。
- en: 'Here is an example of *HMAC-SHA256* output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个*HMAC-SHA256*输出的示例：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have understood the various components of a JWT, let’s look at how
    it works in authentication with the help of the preceding example. A user logs
    in using their credentials. The server verifies the credentials and issues a JWT
    signed with a secret key. The client (usually a browser) stores the JWT (typically
    in local storage or a cookie).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JWT的各个组成部分，让我们通过前面的示例来看看它在身份验证中的工作原理。用户使用其凭据登录。服务器验证凭据并颁发一个使用密钥签名的JWT。客户端（通常是浏览器）将JWT（通常在本地存储或cookie中）存储起来。
- en: 'The client sends the JWT in the `Authorization` header of each subsequent request
    to access protected resources:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在后续请求的`Authorization`头中发送JWT以访问受保护资源：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, it does token verification where the server verifies the token’s signature
    and checks its validity (expiration, issuer, etc.). If the token is valid, the
    server processes the request. Before moving on, it’s important to note that JWTs
    are stateless, compact, and self-contained, making them efficient for securely
    transmitting user information without server-side session storage. When using
    JWTs, ensure the secret key is secure, always transmit tokens over HTTPS, and
    use short-lived tokens with periodic refreshes to mitigate security risks. Now
    we know that JWTs are a powerful and flexible way to handle authentication and
    authorization in modern web applications, providing both security and convenience.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它进行令牌验证，其中服务器验证令牌的签名并检查其有效性（过期时间、发行者等）。如果令牌有效，服务器将处理请求。在继续之前，重要的是要注意 JWTs
    是无状态的、紧凑的且自包含的，这使得它们在不需要服务器端会话存储的情况下安全地传输用户信息非常有效。当使用 JWTs 时，确保密钥安全，始终通过 HTTPS
    传输令牌，并使用短期令牌以及定期刷新来降低安全风险。现在我们知道 JWTs 是处理现代网络应用程序中认证和授权的一种强大且灵活的方式，它提供了安全和便利。
- en: Now that we’ve covered the theory, let’s move on to the practical part and implement
    the authentication microservice together.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了理论部分，接下来让我们进入实践环节，一起实现认证微服务。
- en: Implementing an Authentication microservice
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现认证微服务
- en: 'In microservices development, it’s a common practice to develop a separate
    microservice for authentication and authorization (often referred to as an Auth
    service). Here’s why it’s valuable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务开发中，为认证和授权（通常称为 Auth 服务）开发一个独立的微服务是一种常见的做法。以下是它的价值所在：
- en: '**Centralized security management**: Having a dedicated Auth service allows
    us to manage authentication and authorization logic in one place. This simplifies
    updates and security audits and ensures consistent rules across all microservices.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式安全管理**：拥有一个专门的 Auth 服务允许我们在一个地方管理认证和授权逻辑。这简化了更新和安全审计，并确保所有微服务之间的一致性规则。'
- en: '**Scalability**: The Auth service can be scaled independently based on its
    load, separate from other microservices with different resource requirements.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：Auth 服务可以根据其负载独立扩展，与其他具有不同资源需求的微服务分开。'
- en: '**Reusability**: The Auth service can be reused by all your other microservices,
    reducing code duplication and promoting consistency.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：Auth 服务可以被所有其他微服务重用，减少代码重复并促进一致性。'
- en: '**Improved maintainability**: Isolating authentication logic makes it easier
    to maintain and update the security aspects of your system.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可维护性**：将认证逻辑隔离出来，使得维护和更新系统的安全方面变得更加容易。'
- en: '**Separation of concerns**: Decoupling authentication and authorization from
    other microservices keeps their responsibilities focused, promoting cleaner code
    and better maintainability.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：将认证和授权从其他微服务中解耦，使它们的职责更加集中，促进代码的整洁性和更好的可维护性。'
- en: '**Flexibility**: A dedicated Auth service can be designed to support different
    authentication flows (e.g., OAuth, JWT) and authorization strategies (e.g., RBAC),
    providing a flexible foundation for your microservices architecture.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：专门的 Auth 服务可以被设计成支持不同的认证流程（例如 OAuth、JWT）和授权策略（例如 RBAC），为你的微服务架构提供一个灵活的基础。'
- en: 'Let’s implement our Auth microservice together. We will use a classical approach
    to develop our new microservice via ExpressJS as we did before. Most of the things
    are the same. You should open/create a new folder anywhere you want on your computer
    and type `npm init -y` to initialize start our project. Throughout our development
    process, we will use the following libraries: `bcryptjs`, `dotenv`, `express`,
    `joi`, `jsonwebtoken`, and `mongoose`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起实现我们的 Auth 微服务。我们将使用之前所做的方式，通过 ExpressJS 开发我们的新微服务。大部分事情都是相同的。你应该在你的电脑上任何你想创建的位置打开/创建一个新的文件夹，并输入
    `npm init -y` 来初始化我们的项目。在整个开发过程中，我们将使用以下库：`bcryptjs`、`dotenv`、`express`、`joi`、`jsonwebtoken`
    和 `mongoose`。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `npm init -y` command does not automatically generate the scripts section
    in `package.json`. You’ll need to add it manually to simplify running the application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm init -y` 命令不会自动在 `package.json` 中生成脚本部分。你需要手动添加它以简化应用程序的运行。'
- en: 'Let’s walk through our `package.json` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览一下我们的 `package.json` 文件：
- en: '`bcryptjs`: This library provides secure password hashing and comparison functionalities.
    It allows you to store passwords securely in your database and verify user login
    attempts against the hashed passwords.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bcryptjs`: 这个库提供了安全的密码散列和比较功能。它允许您在数据库中安全地存储密码，并验证用户登录尝试与散列密码。'
- en: '`dotenv`: This library helps you load environment variables from a `.env` file.
    This is a secure way to store sensitive information such as API keys, database
    credentials, and your JWT secret key, keeping them out of your code.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotenv`: 这个库帮助您从`.env`文件中加载环境变量。这是一种安全地存储敏感信息（如API密钥、数据库凭据和您的JWT密钥）的方法，将它们从代码中排除。'
- en: '`express`: This is a popular Node.js web framework that helps you build web
    applications and APIs. It provides a structured approach for handling requests,
    routing, middleware, and responses.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express`: 这是一个流行的Node.js网络框架，它帮助您构建Web应用程序和API。它提供了一种结构化的方法来处理请求、路由、中间件和响应。'
- en: '`joi`: This library offers schema validation for data coming into your application.
    You can define validation rules for request bodies and ensure that the data received
    adheres to your expected format and structure, improving data integrity and preventing
    potential errors.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joi`: 这个库为进入您应用程序的数据提供模式验证。您可以为请求体定义验证规则，并确保接收到的数据符合您期望的格式和结构，从而提高数据完整性并防止潜在错误。'
- en: '`jsonwebtoken` (JWT): This library helps you work with JWTs. It allows you
    to generate tokens for authentication purposes, containing user information in
    a secure and verifiable format. You can use JWTs to authorize users for access
    to protected resources in your microservices.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonwebtoken` (JWT): 这个库帮助您处理JWT。它允许您生成用于身份验证的令牌，以安全且可验证的格式包含用户信息。您可以使用JWT在您的微服务中授权用户访问受保护资源。'
- en: '`mongoose`: This is an **Object Data Modeling** (**ODM**) library for MongoDB
    in Node.js. It provides a convenient way to interact with your MongoDB database
    by mapping your application data models to MongoDB documents. It simplifies data
    manipulation and retrieval.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongoose`: 这是一个Node.js中MongoDB的**对象数据建模（ODM**）库。它通过将您的应用程序数据模型映射到MongoDB文档，提供了一个方便的方式来与MongoDB数据库交互。它简化了数据操作和检索。'
- en: We need a secure way to store user information, and a database is commonly used
    for this purpose. The `mongoose` package will help us to work with the database.
    To connect and disconnect from the database, create a new file called `index.js`
    under the `src/db` folder with the same content as we have in [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个安全的方式来存储用户信息，数据库通常用于此目的。`mongoose`包将帮助我们与数据库交互。为了连接和断开与数据库的连接，在`src/db`文件夹下创建一个名为`index.js`的新文件，其内容与[*第5章*](B09148_05.xhtml#_idTextAnchor074)中的内容相同。
- en: 'Under the `src/models` folder, create a new file called `user.js` with the
    following code block:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/models`文件夹下，创建一个名为`user.js`的新文件，包含以下代码块：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can extend this schema with additional information but to demo authentication
    and authorization, we need only these fields.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以扩展此模式以包含更多信息，但为了演示身份验证和授权，我们只需要这些字段。
- en: We have already talked about `mongoose` in our previous chapters and that is
    why we will bypass already known details. The only new logic here is working with
    a hash password. When we create a user via API, we will provide an email and password.
    For security reasons, we need to hash passwords before storing them in our database.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中讨论了`mongoose`，这就是为什么我们将跳过已知细节。这里唯一的新逻辑是与散列密码一起工作。当我们通过API创建用户时，我们将提供一个电子邮件和密码。出于安全原因，我们需要在将密码存储到数据库之前对其进行散列。
- en: The code that starts with `userSchema.pre("…")` is a `mongoose` middleware function
    that is executed before a user document is saved to the database. This middleware
    ensures that passwords are never stored in plain text in our database. It securely
    hashes passwords before saving them, making it computationally infeasible to recover
    the original password from the stored hash.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以`userSchema.pre("…")`开始的代码是一个`mongoose`中间件函数，它在用户文档保存到数据库之前执行。这个中间件确保我们的数据库中永远不会以纯文本形式存储密码。在保存之前，它会安全地散列密码，使得从存储的散列中恢复原始密码在计算上是不切实际的。
- en: 'Now, we need to provide a service layer that interacts with the database. For
    simplicity, you can bypass this layer, but to provide a full picture, we will
    have it. Under the `src/services` folder, create a new file called `user.js` with
    the following code block:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要提供一个与数据库交互的服务层。为了简单起见，您可以跳过这一层，但为了提供一个完整的画面，我们将包括它。在`src/services`文件夹下，创建一个名为`user.js`的新文件，包含以下代码块：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To make things simple, we haven’t implemented full CRUD operations. To demo
    our functionality, we only need a few of them such as `create` and `get user`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们没有实现完整的 CRUD 操作。为了演示我们的功能，我们只需要其中的一些，例如 `create` 和 `get user`。
- en: 'Now, let’s switch to our controller and see how we create a user. Under the
    `src/controllers` folder, create a new file called `user.js` with the following
    code block:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换到我们的控制器，看看我们如何创建一个用户。在 `src/controllers` 文件夹下，创建一个名为 `user.js` 的新文件，并包含以下代码块：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code snippet defines an asynchronous function named `createUser` that
    handles user registration in your Node.js application. Here are the details:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段定义了一个名为 `createUser` 的异步函数，用于处理 Node.js 应用程序中的用户注册。以下是详细信息：
- en: '`const createUser = async (req, res) => { ... }`: This defines an asynchronous
    function named `createUser` that takes two arguments, `req` (request object) and
    `res` (response object).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const createUser = async (req, res) => { ... }`：这定义了一个名为 `createUser` 的异步函数，它接受两个参数，`req`（请求对象）和
    `res`（响应对象）。'
- en: '`const { email, password } = req.body;`: This extracts the `email` and `password`
    properties from the request body (`req.body`). These are assumed to be sent by
    the client in the registration request.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const { email, password } = req.body;`：这从请求体（`req.body`）中提取了 `email` 和 `password`
    属性。这些属性假设由客户端在注册请求中发送。'
- en: '`const existingUser = await userService.getUserByEmail(email);`: This calls
    a function from `userService` (to check whether a user with the provided email
    already exists. It awaits the result (`existingUser`).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const existingUser = await userService.getUserByEmail(email);`：这调用 `userService`
    中的一个函数（用于检查是否已存在提供电子邮件的用户。它等待结果（`existingUser`）。'
- en: '`if (existingUser) { ... }`: If `existingUser` is not `null` (meaning a user
    with the email exists), it returns a `400 Bad Request` response with a message
    indicating the email conflict.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (existingUser) { ... }`：如果 `existingUser` 不是 `null`（表示存在具有该电子邮件的用户），则返回一个包含表示电子邮件冲突的消息的
    `400 Bad Request` 响应。'
- en: '`const user = await userService.createUser({ email, password });`: If the email
    is unique, it calls another function from `userService` (likely for user creation)
    with an object containing the extracted email and password. It awaits the result
    (`user`), which is the newly created user document.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const user = await userService.createUser({ email, password });`：如果电子邮件是唯一的，它调用
    `userService` 中的另一个函数（可能是用于用户创建的函数），传递一个包含提取的电子邮件和密码的对象。它等待结果（`user`），这是新创建的用户文档。'
- en: '`.status(201).json({ message: ''User created successfully'', user: user });`:
    If user creation is successful, it sends a `201 Created` response with a message
    and the newly created user object (`user`) in the response body.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.status(201).json({ message: ''User created successfully'', user: user });`：如果用户创建成功，它发送一个包含消息和新生成的用户对象（`user`）的
    `201 Created` 响应。'
- en: 'A `try...catch` block: This wraps the core logic in a `try`-`catch` block to
    handle any potential errors during the registration process.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `try...catch` 块：这将核心逻辑包裹在一个 `try`-`catch` 块中，以处理注册过程中可能出现的任何潜在错误。
- en: '`res.status(500).json({ message: ''Server error'' });`: This sends a generic
    `500 Internal Server Error` response in case of any errors.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.status(500).json({ message: ''Server error'' });`：在出现任何错误的情况下，它发送一个通用的
    `500 Internal Server Error` 响应。'
- en: '`createUser`: This function provides a basic structure for user registration
    in our application. It checks for email conflicts, delegates user creation logic
    to a separate service, and handles successful and error scenarios with appropriate
    responses.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createUser`：此函数为我们应用程序中的用户注册提供了一个基本结构。它检查电子邮件冲突，将用户创建逻辑委托给单独的服务，并使用适当的响应处理成功和错误情况。'
- en: 'But creating a user is not enough. We need to implement sign-in/log-in functionality.
    In the same file, we have the following code to log in:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但创建用户还不够。我们需要实现登录/登录功能。在同一个文件中，我们有以下代码用于登录：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code defines an asynchronous function named `loginUser` that handles user
    login in your Express.js application. Here’s a breakdown of what it does:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个名为 `loginUser` 的异步函数，该函数用于处理 Express.js 应用程序中的用户登录。以下是它的功能分解：
- en: '`const loginUser = async (req, res) => { ... }`: This defines an asynchronous
    function named `loginUser` that takes two arguments, `req` (request object) and
    `res` (response object).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const loginUser = async (req, res) => { ... }`：这定义了一个名为 `loginUser` 的异步函数，它接受两个参数，`req`（请求对象）和
    `res`（响应对象）。'
- en: '`const { email, password } = req.body;`: This extracts the `email` and `password`
    properties from the request body (`req.body`). These are assumed to be sent by
    the client in the login request.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const { email, password } = req.body;`：这从请求体（`req.body`）中提取了 `email` 和 `password`
    属性。这些属性假设由客户端在登录请求中发送。'
- en: '`const user = await userService.getUserByEmail(email);`: This calls a function
    from `userService` (likely another module) to fetch a user with the provided email.
    It awaits the result (`user`).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const user = await userService.getUserByEmail(email);`：这调用 `userService`（可能是另一个模块）中的函数来获取具有提供的电子邮件的用户。它等待结果（`user`）。'
- en: '`if (!user) { ... }`: If `user` is `null` (meaning no user found with the email),
    it returns a `401 Unauthorized` response with a message indicating invalid credentials.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (!user) { ... }`：如果 `user` 是 `null`（表示没有找到具有该电子邮件的用户），则返回一个包含表示凭据无效的消息的
    `401 未授权` 响应。'
- en: '`const isMatch = await bcrypt.compare(password, user.password);`: This uses
    `bcrypt.compare` to compare the provided password with the hashed password stored
    in the fetched user document (`user.password`). It awaits the result (`isMatch`),
    which is a boolean indicating whether the passwords match.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const isMatch = await bcrypt.compare(password, user.password);`：这使用 `bcrypt.compare`
    将提供的密码与从获取的用户文档（`user.password`）中存储的散列密码进行比较。它等待结果（`isMatch`），这是一个布尔值，指示密码是否匹配。'
- en: '`if (!isMatch) { ... }`: If `isMatch` is `false` (meaning passwords don’t match),
    it returns a `401 Unauthorized` response with a message indicating invalid credentials.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (!isMatch) { ... }`：如果 `isMatch` 是 `false`（表示密码不匹配），则返回一个包含表示凭据无效的消息的 `401
    未授权` 响应。'
- en: '`const configPath = path.join(__dirname, ''../../configs/.env'');`: This constructs
    the path to the environment variable file (assuming it’s located four folders
    above the current file).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const configPath = path.join(__dirname, ''../../configs/.env'');`：这构建了环境变量文件的路径（假设它位于当前文件上方四个文件夹处）。'
- en: '`const appConfig = createConfig(configPath);`: This calls a function to read
    and parse the environment variables from the `.``env` file.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const appConfig = createConfig(configPath);`：这调用一个函数来读取和解析 `.env` 文件中的环境变量。'
- en: '`const payload = { userId: user._id };`: This creates a payload object for
    the JWT containing the user’s ID. Include only essential user data here.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const payload = { userId: user._id };`：这为 JWT 创建一个包含用户 ID 的有效载荷对象。这里只包含必要用户数据。'
- en: '`const jwtSecret = appConfig.jwt.access_token;`: This retrieves the JWT access
    token secret from the parsed environment configuration.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const jwtSecret = appConfig.jwt.access_token;`：这从解析后的环境配置中检索 JWT 访问令牌秘密。'
- en: '`const accessToken = await jwt.sign(payload, jwtSecret, { expiresIn: ''1h''
    });`: This uses `jsonwebtoken` to sign the JWT with the payload, secret, and an
    expiration time of one hour (`expiresIn: ''1h''`). It awaits the generated token
    (`accessToken`).'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const accessToken = await jwt.sign(payload, jwtSecret, { expiresIn: ''1h''
    });`：这使用 `jsonwebtoken` 使用有效载荷、密钥和一小时过期时间（`expiresIn: ''1h''`）来对 JWT 进行签名。它等待生成的令牌（`accessToken`）。'
- en: '`res.status(200).json({ accessToken: accessToken });`: If login is successful,
    it sends a `200 OK` response with the generated `accessToken` in the response
    body.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res.status(200).json({ accessToken: accessToken });`：如果登录成功，它发送一个包含生成的 `accessToken`
    的 `200 OK` 响应体。'
- en: Overall, the login function provides a secure login flow using JWT authentication.
    It fetches the user, validates credentials, generates a JWT with a secret key,
    and sends it back to the client for subsequent authorized access.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，登录函数使用 JWT 认证提供了一个安全的登录流程。它获取用户、验证凭据、使用秘密密钥生成 JWT，并将其发送回客户端以进行后续的授权访问。
- en: In order to have a fully functional login functionality, we need to provide
    the secret access token. In JWT, the secret access token plays a vital role in
    ensuring the integrity and authenticity of the token. When a JWT is created, a
    cryptographic hash algorithm (e.g., HMAC-SHA256) signs the header and payload
    (containing user information) using a secret access token. This secret key is
    like a password known only to the server that issued the JWT and the party verifying
    it. When a client sends a JWT in an authorization header to access a protected
    resource, the server receives the token.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有一个完全功能的登录功能，我们需要提供秘密访问令牌。在 JWT 中，秘密访问令牌在确保令牌的完整性和真实性方面起着至关重要的作用。当创建 JWT
    时，使用秘密访问令牌通过加密散列算法（例如 HMAC-SHA256）对头部和有效载荷（包含用户信息）进行签名。这个秘密密钥就像一个只有签发 JWT 的服务器和验证它的方才知道的密码。当客户端在授权头中发送
    JWT 以访问受保护资源时，服务器接收该令牌。
- en: 'The server uses the same secret access token to verify the signature of the
    received JWT. This verification process ensures the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用相同的秘密访问令牌来验证接收到的 JWT 的签名。此验证过程确保以下内容：
- en: The token has not been tampered with in transit.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该令牌在传输过程中未被篡改。
- en: The token was indeed issued by a trusted source (the server that knows the secret).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该令牌确实是由一个可信的来源（知道秘密的服务器）签发的。
- en: If the secret access token is compromised (e.g., leaked or stolen), anyone with
    the secret can forge valid-looking JWTs, potentially impersonating legitimate
    users and gaining unauthorized access to resources. Therefore, the secret access
    token is critical for maintaining the security of JWT-based authentication. Never
    store the secret access token in your code or within the application itself. Use
    environment variables or a dedicated secret management service to keep it confidential.
    Choose a cryptographically strong random string (ideally, at least 256 bits) for
    your secret access token to make it difficult to guess or crack. Consider rotating
    your secret access token periodically to mitigate the impact of a potential compromise.
    By following these practices, you can leverage the benefits of JWTs for secure
    authentication in your application while minimizing the risks associated with
    secret access tokens.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果秘密访问令牌被泄露（例如，泄露或被盗），任何拥有秘密的人都可以伪造看起来有效的JWT，可能冒充合法用户并获取对资源的未授权访问。因此，秘密访问令牌对于维护基于JWT的认证的安全性至关重要。永远不要在代码或应用程序内部存储秘密访问令牌。使用环境变量或专门的秘密管理服务来保持其机密性。为您的秘密访问令牌选择一个密码学上强大的随机字符串（理想情况下，至少256位），使其难以猜测或破解。考虑定期轮换您的秘密访问令牌以减轻潜在泄露的影响。通过遵循这些实践，您可以在应用程序中利用JWT的益处进行安全的认证，同时最大限度地减少与秘密访问令牌相关的风险。
- en: When implementing access tokens, be careful to not to generate long-lived access
    tokens. Long-lived access tokens pose security risks because, if stolen, they
    allow attackers prolonged access, and revoking them is difficult. In contrast,
    refresh tokens offer better security by allowing short-lived access tokens to
    be issued, limiting potential damage. They also enable more granular control,
    as compromised tokens can be individually blacklisted without affecting other
    tokens, reducing the need for frequent authentication and lowering server load.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现访问令牌时，请注意不要生成长期有效的访问令牌。长期有效的访问令牌存在安全风险，因为如果被盗，它们允许攻击者长时间访问，并且撤销它们是困难的。相比之下，刷新令牌通过允许发行短期访问令牌提供更好的安全性，限制了潜在的损害。它们还允许更细粒度的控制，因为泄露的令牌可以单独列入黑名单，而不会影响其他令牌，减少了频繁认证的需求并降低了服务器负载。
- en: Refresh tokens provide a good balance between user convenience (avoiding frequent
    logins) and security. Even though they have longer expirations compared to access
    tokens, their use is limited to obtaining new, short-lived access tokens.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新令牌在用户便利性（避免频繁登录）和安全之间提供了一个良好的平衡。尽管与访问令牌相比，它们的过期时间更长，但它们的使用仅限于获取新的、短期有效的访问令牌。
- en: 'Before implementing our refresh token, consider providing limited time for
    access tokens as short-lived access tokens reduce the risk of misuse if they are
    compromised, minimizing the window of opportunity for attackers. In this example,
    we set it to `5` minutes. After five minutes, the given access token will expire
    and we should send our refresh token to a new endpoint to obtain a new short-lived
    access token. First of all, let’s modify our login endpoint to return a refresh
    token:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施我们的刷新令牌之前，考虑为访问令牌提供有限的时间，因为短期访问令牌在泄露的情况下减少了滥用的风险，最小化了攻击者的机会窗口。在这个例子中，我们将它设置为`5`分钟。五分钟后，给定的访问令牌将过期，我们应该将刷新令牌发送到新的端点以获取新的短期访问令牌。首先，让我们修改我们的登录端点以返回刷新令牌：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use the same method to get both tokens. For refresh tokens, we set a bit
    longer period such as such as seven days. We will create a new endpoint to return
    new access tokens and that is why we need a new functionality in our controller:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的方法来获取两个令牌。对于刷新令牌，我们设置一个稍长的周期，例如七天。我们将创建一个新的端点来返回新的访问令牌，这就是为什么我们需要在我们的控制器中添加新的功能：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function lets users get a new access token (key to access resources) by
    providing a refresh token (like a spare key). It checks whether the refresh token
    is valid using a secret key. If valid, it can generate a new, short-lived access
    token (with a 5-minute expiration by default) for the user. This way, users don’t
    need to log in frequently but still maintain security with short-lived access
    tokens.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能允许用户通过提供刷新令牌（类似于备用钥匙）来获取新的访问令牌（访问资源的密钥）。它使用密钥检查刷新令牌是否有效。如果有效，它可以生成一个新的、短期有效的访问令牌（默认过期时间为5分钟）供用户使用。这样，用户不需要频繁登录，但仍然可以通过短期访问令牌保持安全性。
- en: 'The best practice for storing refresh tokens involves a balance between security
    and user convenience. Here is what you need to know:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 存储刷新令牌的最佳实践涉及安全性和用户便利性之间的平衡。以下是你需要了解的内容：
- en: Refresh tokens should not be stored in browser cookies due to their accessibility
    to JavaScript and potential theft through XSS attacks.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于JavaScript的可访问性和通过XSS攻击的潜在盗窃，刷新令牌不应存储在浏览器cookie中。
- en: If using cookies, opt for `HttpOnly` cookies with the `Secure` flag set. This
    prevents JavaScript access and mitigates XSS attacks. However, this approach has
    limitations (e.g., not supported by all browsers in cross-site context).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用cookie，请选择带有`Secure`标志设置的`HttpOnly` cookie。这阻止JavaScript访问并减轻XSS攻击。然而，这种方法有局限性（例如，在跨站上下文中，不是所有浏览器都支持）。
- en: On the other hand, local storage is a viable option, but implement security
    measures such as encryption at rest and in transit to protect the token if compromised.
    Evaluate libraries or frameworks that provide secure local storage mechanisms.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，本地存储是一个可行的选项，但实施安全措施，如静态和传输中的加密，以保护令牌在泄露时。评估提供安全本地存储机制的库或框架。
- en: In some scenarios, you might consider storing refresh tokens on the server side
    (e.g., database) for added security or centralized management. However, this is
    not always necessary and adds complexity.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些场景中，你可能考虑将刷新令牌存储在服务器端（例如，数据库）以增加安全性或集中管理。然而，这并不总是必要的，并且会增加复杂性。
- en: While refresh tokens have longer expirations than access tokens (e.g., days
    or weeks), avoid excessively long durations to minimize potential damage if compromised.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然刷新令牌的过期时间比访问令牌长（例如，几天或几周），但应避免过长的持续时间，以最大限度地减少泄露时的潜在损害。
- en: Implement a mechanism to blacklist refresh tokens after a period of inactivity
    (e.g., a week) or upon user logout. This prevents attackers from using stolen
    tokens indefinitely.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施一种机制，在一段时间的不活跃期（例如，一周）或用户登出后，将刷新令牌列入黑名单。这阻止攻击者无限期地使用被盗令牌。
- en: Consider refresh token rotation. When a new access token is issued using a refresh
    token, generate a new refresh token and store it. This reduces the risk of a single
    refresh token being compromised for an extended period.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑刷新令牌轮换。当使用刷新令牌颁发新的访问令牌时，生成一个新的刷新令牌并存储它。这减少了单个刷新令牌在较长时间内被泄露的风险。
- en: If performance and fast access are top priorities, consider using Redis for
    its speed and automatic handling of expiration times. However, address potential
    persistence concerns if necessary.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果性能和快速访问是首要任务，考虑使用Redis的速度和自动处理过期时间。然而，如果需要，解决潜在的持久性问题。
- en: If data durability and integration with your existing database are crucial,
    storing refresh tokens in a database can be an option. However, evaluate potential
    performance impacts compared to Redis.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据持久性和与现有数据库的集成至关重要，可以将刷新令牌存储在数据库中作为选项。然而，与Redis相比，评估潜在的性能影响。
- en: 'To access our new controller functionality, let provide a route for it. Open
    the `routes/v1/users/index.js` file and add the following line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问我们新的控制器功能，为它提供一个路由。打开`routes/v1/users/index.js`文件并添加以下行：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That is all. Now we have endpoints to register, log in, and retrieve a new access
    token.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。现在我们有了注册、登录和检索新访问令牌的端点。
- en: 'We store secret tokens and refresh tokens in an `.env` file. Create a `configs`
    folder on the same level as the `src` folder and add an `.env` file with the following
    content:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将秘密令牌和刷新令牌存储在`.env`文件中。在`src`文件夹同一级别创建一个`configs`文件夹，并添加一个包含以下内容的`.env`文件：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In order to generate refresh and secret tokens, do the following operations:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成刷新和秘密令牌，执行以下操作：
- en: Open the terminal and type `node`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并输入`node`。
- en: In the given input window, type `require('crypto').randomBytes(64).toString('hex')`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在给定的输入窗口中，输入`require('crypto').randomBytes(64).toString('hex')`。
- en: 'The following figure show how easily you can do it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了你可以多么容易地完成它：
- en: '![Figure 9.1: Generating secret tokens](img/B09148_09_001.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：生成秘密令牌](img/B09148_09_001.jpg)'
- en: 'Figure 9.1: Generating secret tokens'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：生成秘密令牌
- en: You will get a different generated result every time you call the last command.
    Just copy the value and paste it to the `.env` file to be paired with `SECRET_ACCESS_TOKEN`.
    Try the same comment a second time to get a completely different value and paste
    it for `SECRET_REFRESH_TOKEN`. The refresh token and secret token must have different
    values.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用最后一个命令时，你都会得到一个不同的生成结果。只需复制该值并将其粘贴到`.env`文件中，与`SECRET_ACCESS_TOKEN`配对。尝试第二次使用相同的注释以获取一个完全不同的值，并将其粘贴为`SECRET_REFRESH_TOKEN`。刷新令牌和秘密令牌必须具有不同的值。
- en: As you already know, we have the `src/config` folder with `config.js` that can
    read `.env` files programmatically. We add token reading functionality to it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，我们有一个 `src/config` 文件夹，其中包含 `config.js`，它可以以编程方式读取 `.env` 文件。我们向其中添加了读取令牌的功能。
- en: 'Here is what it looks like:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个样子：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code provides an object called `jwt` to access refresh and secret tokens.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码提供了一个名为 `jwt` 的对象，用于访问刷新和密钥令牌。
- en: 'As you might guess, we haven’t validated user-provided data directly. We need
    to validate the data, and that is why we plan to use the same structure that we
    used for the account microservice. Under the `src/middlewares` folder, we have
    the same `validate.js` file to validate our schema. That is the main reason why
    we haven’t implemented validation per endpoint. It is time to provide rules for
    email and password validation. Create `user.js` under the `src/validation` folder
    with the following code block:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测，我们尚未直接验证用户提供的数据。我们需要验证数据，这就是为什么我们计划使用与账户微服务相同的结构。在 `src/middlewares` 文件夹下，我们有相同的
    `validate.js` 文件来验证我们的模式。这就是我们没有在每个端点实施验证的主要原因。现在是时候为电子邮件和密码验证提供规则了。在 `src/validation`
    文件夹下创建 `user.js`，并包含以下代码块：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code snippet uses `Joi` to define a validation schema specifically for
    login requests in your application. It focuses on the request body, ensuring it
    contains a valid email address and password that meets the minimum length requirement
    (defined as six characters in this example). The schema also provides informative
    custom error messages for missing or invalid email and password, improving the
    user experience by guiding them toward proper credential format. By implementing
    this validation, you can prevent malformed login requests from reaching your backend
    logic and enhance the overall security of your application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段使用 `Joi` 定义了一个针对应用程序中登录请求的特定验证模式。它专注于请求体，确保它包含一个有效的电子邮件地址和密码，该密码满足最小长度要求（在本例中定义为六个字符）。该模式还提供了关于缺失或无效电子邮件和密码的详细自定义错误消息，通过引导用户到正确的凭据格式来改善用户体验。通过实施此验证，您可以防止格式错误的登录请求到达后端逻辑，并增强应用程序的整体安全性。
- en: 'We can directly provide routing in our controllers but we will follow the same
    convention we did before when we implemented the account microservice. So, under
    the `routes/v1/users` folder, create an `index.js` file with the following content:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在我们的控制器中提供路由，但我们将遵循我们在实现账户微服务之前所遵循的相同约定。因此，在 `routes/v1/users` 文件夹下，创建一个包含以下内容的
    `index.js` 文件：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The code defines two endpoints. One for registration (`/register`) and the
    other for the login (`/login`) functionality. The `routes/v1` folder also contains
    the `index.js` file with the following content:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了两个端点。一个用于注册（`/register`），另一个用于登录（`/login`）功能。`routes/v1` 文件夹还包含一个包含以下内容的
    `index.js` 文件：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we use the same code we used in our account microservice. We
    just changed the route to `users`. Now, users can access our endpoints using `v1/user/{endpoint_name}`.
    The last elements in our microservice are `app.js` and the root `index.js` file,
    which are the same as our already implemented account microservice.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了我们在账户微服务中使用的相同代码。我们只是将路由更改为 `users`。现在，用户可以使用 `v1/user/{endpoint_name}`
    访问我们的端点。我们微服务的最后元素是 `app.js` 和根 `index.js` 文件，它们与我们的已实现的账户微服务相同。
- en: 'Let’s test our Auth microservice’s endpoints. Run `npm start` from the terminal
    and let’s prepare our `POST` request to create a user:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的身份验证微服务的端点。从终端运行 `npm start`，并准备我们的 `POST` 请求来创建用户：
- en: Open the Postman application.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Postman 应用程序。
- en: Create a new Postman request window.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Postman 请求窗口。
- en: Change **GET** to **POST**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **GET** 改为 **POST**。
- en: Provide the endpoint URL (it is `http://localhost:3006/v1/users/register` for
    us).
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供端点 URL（对我们来说它是 `http://localhost:3006/v1/users/register`）。
- en: Go to **Body**, select **raw**, and select **JSON**.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **Body**，选择 **raw**，然后选择 **JSON**。
- en: Provide a payload and click **Send** (*Figure 9**.2*).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个有效载荷并点击 **Send**（*图 9**.2*）。
- en: '![Figure 9.2: Successful registration](img/B09148_09_002.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2：成功的注册](img/B09148_09_002.jpg)'
- en: 'Figure 9.2: Successful registration'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：成功的注册
- en: 'The user is ready. Now, we can get a JWT. Here are the steps to get a JWT:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 用户已准备好。现在，我们可以获取 JWT。以下是获取 JWT 的步骤：
- en: Create a new Postman request window.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Postman 请求窗口。
- en: Change **GET** to **POST**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **GET** 改为 **POST**。
- en: Provide the endpoint URL (it is `http://localhost:3006/v1/users/login` for us).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供端点 URL（对我们来说它是 `http://localhost:3006/v1/users/login`）。
- en: Go to **Body**, select **raw**, and select **JSON**.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **Body**，选择 **raw**，然后选择 **JSON**。
- en: Provide a payload and click **Send** (*Figure 9**.3*).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供有效载荷并点击 **发送**（*图 9**.3*）。
- en: '![Figure 9.3: Successful login](img/B09148_09_003.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3：成功登录](img/B09148_09_003.jpg)'
- en: 'Figure 9.3: Successful login'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：成功登录
- en: The generated access token will expire in a given time slot (*Figure 9**.4*).
    After expiration, we do not need to provide an email and password to get a new
    access token. We can simply use a refresh token to refresh and to get a new access
    token.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的访问令牌将在给定的时间段内过期（*图 9**.4*）。过期后，我们不需要提供电子邮件和密码来获取新的访问令牌。我们可以简单地使用刷新令牌来刷新并获取新的访问令牌。
- en: '![Figure 9.4: Message about expired token](img/B09148_09_004.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4：关于过期令牌的消息](img/B09148_09_004.jpg)'
- en: 'Figure 9.4: Message about expired token'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：关于过期令牌的消息
- en: 'But what if you want a new access token based on a refresh token? That is easy.
    Here’s how:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要基于刷新令牌的新访问令牌呢？这很简单。下面是如何做的：
- en: Open a new window on Postman and set the request type to `v1/users/token` endpoint.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Postman 的新窗口中，将请求类型设置为 `v1/users/token` 端点。
- en: Open the **Body** section and provide a refresh token. Click the **Send** button
    (*Figure 9**.5*).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **正文** 部分，提供刷新令牌。点击 **发送** 按钮（*图 9**.5*）。
- en: '![Figure 9.5: Getting a new access token based on the refresh token](img/B09148_09_005.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5：基于刷新令牌获取新的访问令牌](img/B09148_09_005.jpg)'
- en: 'Figure 9.5: Getting a new access token based on the refresh token'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：基于刷新令牌获取新的访问令牌
- en: Now you can use this access token to access our account microservice resources.
    Well, that is simply it. It is time to test the JWT in our account microservice.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这个访问令牌来访问我们的账户微服务资源。嗯，就是这样。现在是时候在我们的账户微服务中测试 JWT 了。
- en: Integrating token-based authentication for the account microservice
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成基于令牌的认证到账户微服务
- en: 'The microservices we implemented so far don’t have authentication and authorization
    functionalities. As homework, you can start to integrate these into them, and
    for learning purposes, we will implement JWT for the account microservice. Open
    the account microservice we developed so far. To use the same access token from
    the Auth microservice, the account microservice should use the same secret token.
    Open the `configs/.env` file and add the following line:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止实现的微服务还没有认证和授权功能。作为作业，你可以开始将它们集成进去，为了学习目的，我们将为账户微服务实现 JWT。打开我们迄今为止开发的账户微服务。为了使用来自
    Auth 微服务的相同访问令牌，账户微服务应该使用相同的密钥令牌。打开 `configs/.env` 文件并添加以下行：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the `config/config.js` file and make the following changes in order to
    read the secret token configuration field:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `config/config.js` 文件，按照以下步骤修改以读取密钥令牌配置字段：
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only real functionality we need to add to the account microservice is a
    middleware to verify our token.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到账户微服务的唯一真正功能是一个用于验证我们的令牌的中间件。
- en: 'Under the `src/middlewares` folder, create a file called `verify.js` with the
    following content:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/middlewares` 文件夹下，创建一个名为 `verify.js` 的文件，内容如下：
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code defines a middleware function named `verifyJWT` for Express.js applications.
    It handles JWT verification for incoming requests. It checks if the authorization
    header exists in the request and starts with `Bearer`. If not, it returns a `401
    Unauthorized` response indicating a missing JWT.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个名为 `verifyJWT` 的中间件函数，用于 Express.js 应用程序。它处理传入请求的 JWT 验证。它检查请求中是否存在授权头，并且以
    `Bearer` 开头。如果没有，它将返回一个 `401 未授权` 响应，表明缺少 JWT。
- en: If the header is present and formatted correctly, it extracts the JWT itself
    from the authorization header. Our middleware constructs the path to the environment
    variable file containing the JWT secret key. It calls a function (likely from
    a separate `config` module) to read and parse the configuration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果头部存在并且格式正确，它将从授权头中提取 JWT 本身。我们的中间件构建了包含 JWT 密钥的环境变量文件的路径。它调用一个函数（可能来自一个单独的
    `config` 模块）来读取和解析配置。
- en: 'Then, we use `jsonwebtoken.verify()` to verify the extracted token against
    the secret key retrieved from the configuration. If verification fails (`err`),
    it checks the error type:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `jsonwebtoken.verify()` 函数来验证从配置中检索到的密钥密钥提取的令牌。如果验证失败（`err`），它将检查错误类型：
- en: '`JsonWebTokenError`: Indicates invalid token format, returning `401` with a
    specific message'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonWebTokenError`：表示无效的令牌格式，返回带有特定信息的 `401`'
- en: '`TokenExpiredError`: Indicates an expired token, returning `401` with a specific
    message'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TokenExpiredError`：表示令牌已过期，返回带有特定信息的 `401`'
- en: Other errors (e.g., signature verification failure) are logged and a generic
    `500 Internal Server Error` response is sent for security reasons
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他错误（例如签名验证失败）被记录，并出于安全原因发送通用的 `500 内部服务器错误` 响应。
- en: If verification is successful (`!err`), it attaches the decoded user information
    from the JWT to the `req.user` object for further access within your application
    logic.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证成功（`!err`），它将 JWT 中解码的用户信息附加到 `req.user` 对象中，以便在您的应用程序逻辑中进行进一步访问。
- en: Finally, it calls `next()` to allow the request to proceed to the intended route
    handler.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它调用 `next()` 以允许请求继续到预期的路由处理程序。
- en: Overall, this middleware acts as a gatekeeper, ensuring that only requests with
    valid JWTs can access protected resources in your application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这个中间件充当守门人，确保只有具有有效 JWTs 的请求才能访问您应用程序中的受保护资源。
- en: 'In order to use our middleware, we import it in our `app.js` file and use it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的中间件，我们在 `app.js` 文件中导入它并使用它：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code imports our middleware and uses it. Now, let’s run the account microservice
    and try to get all account information. Do the following operations:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 代码导入我们的中间件并使用它。现在，让我们运行账户微服务并尝试获取所有账户信息。执行以下操作：
- en: Navigate to the `Ch09/accountservice` folder.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `Ch09/accountservice` 文件夹。
- en: To run the account microservice properly, you also need to run the `docker-compose`
    file from the root folder using the `docker-compose up -``d` command.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确运行账户微服务，您还需要从根目录运行 `docker-compose` 文件，使用 `docker-compose up -``d` 命令。
- en: After executing both `docker-compose` setups, start the account microservice
    by running the `npm` `start` command.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行完两个 `docker-compose` 设置后，通过运行 `npm start` 命令启动账户微服务。
- en: Open Postman and send a `GET` request to `v1/accounts` (in our case, it is `http://localhost:3001/v1/accounts`).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Postman 并向 `v1/accounts` 发送一个 `GET` 请求（在我们的例子中，它是 `http://localhost:3001/v1/accounts`）。
- en: You will get a message about an unauthorized request (*Figure 9**.6*).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将收到一个关于未授权请求的消息（*图 9**.6*）。
- en: '![Figure 9.6: Unauthorized access](img/B09148_09_006.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6: 未授权访问](img/B09148_09_006.jpg)'
- en: 'Figure 9.6: Unauthorized access'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9.6: 未授权访问'
- en: Now, run our Authentication microservice and do the steps we mentioned in the
    Auth microservice to get an access token (*Figure 9**.3*). For the same query
    for the account microservice, just open the **Authorization** section from Postman,
    change the type of authorization to **Bearer Token**, and paste the token you
    get from the Authentication service into the input (*Figure 9**.7*).
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行我们的身份验证微服务，并按照我们在身份验证微服务中提到的步骤操作以获取访问令牌（*图 9**.3*）。对于对账户微服务的相同查询，只需从 Postman
    中打开 **授权** 部分，将授权类型更改为 **Bearer Token**，并将从身份验证服务中获得的令牌粘贴到输入框中（*图 9**.7*）。
- en: '![Figure 9.7: Accessing the account microservice](img/B09148_09_007.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7: 访问账户微服务](img/B09148_09_007.jpg)'
- en: 'Figure 9.7: Accessing the account microservice'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9.7: 访问账户微服务'
- en: 'Press the **Send** button and here we are:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **发送** 按钮，我们就可以开始了：
- en: '![Figure 9.8: Getting account microservice resources](img/B09148_09_008.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8: 获取账户微服务资源](img/B09148_09_008.jpg)'
- en: 'Figure 9.8: Getting account microservice resources'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '图 9.8: 获取账户微服务资源'
- en: If you’ve followed the steps correctly, you should now be able to retrieve account
    data. In the next chapter, we’ll dive into observability and explore how to implement
    it using the ELK stack.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确地遵循了步骤，现在您应该能够检索账户数据。在下一章中，我们将深入了解可观察性，并探讨如何使用 ELK 堆栈来实现它。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored the fundamental security concepts of authentication, authorization,
    and their role in securing microservices. We clarified the importance of verifying
    user identities (authentication) and determining access permissions (authorization)
    for robust system protection.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了身份验证、授权的基本安全概念及其在保护微服务中的作用。我们阐明了验证用户身份（身份验证）和确定访问权限（授权）对于系统安全性的重要性。
- en: To achieve this, we implemented a dedicated microservice for issuing access
    tokens (JWTs) and refresh tokens. JWTs grant temporary access, while refresh tokens
    allow users to obtain new access tokens without re-entering credentials. A practical
    demonstration showcased how this microservice interacts with another microservice,
    the account microservice.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们实现了一个专门的微服务来颁发访问令牌（JWTs）和刷新令牌。JWTs 授予临时访问权限，而刷新令牌允许用户在不重新输入凭据的情况下获取新的访问令牌。一个实际演示展示了该微服务如何与另一个微服务，即账户微服务交互。
- en: In our next chapter, we will explore the monitoring of microservices and its
    significance in microservice architectures. We will implement logging functionality
    within the account microservice and integrate it with the **Elasticsearch, Logstash,
    and Kibana** (**ELK**) stack. This will establish a centralized logging system,
    enabling efficient log collection, analysis, and visualization.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的章节中，我们将探讨微服务的监控及其在微服务架构中的重要性。我们将在账户微服务中实现日志记录功能，并将其与**Elasticsearch、Logstash和Kibana**（**ELK**）堆栈集成。这将建立一个集中式日志系统，实现高效的日志收集、分析和可视化。
