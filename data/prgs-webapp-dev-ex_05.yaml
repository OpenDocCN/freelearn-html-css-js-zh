- en: The Service Worker Life Cycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者生命周期
- en: The service worker life cycle is one of the most important concepts you must
    master in order to create proper service workers. This part of the service worker
    discipline is often overlooked and leads to many questions and frustrations expressed
    on sites such as Stack Overflow. But mastering the service worker life cycle allows
    you to seamlessly register and update service workers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者生命周期是您必须掌握的最重要的概念之一，以便创建适当的服务工作者。服务工作者学科的这个部分通常被忽视，导致在Stack Overflow等网站上出现许多问题和挫败感。但掌握服务工作者生命周期可以使您无缝注册和更新服务工作者。
- en: I think developers overlook the life cycle because it is not obvious until they
    hit an obstacle due to not understanding the service worker lifespan. The issue
    that confuses most developers is when a service worker becomes active.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为开发者忽视了生命周期，因为它直到他们遇到由于不了解服务工作者生命周期而造成的障碍时才变得明显。大多数开发者感到困惑的问题是服务工作者何时变得活跃。
- en: Service workers obey a known life cycle that allows a new service worker to
    get itself ready without disrupting the current one. The life cycle is designed
    for the best user experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者遵循一个已知的生命周期，允许新的服务工作者在不干扰当前服务工作者的情况下准备自己。生命周期旨在提供最佳的用户体验。
- en: When a service worker is registered, it does not immediately seize control of
    the client. There are rules designed to minimize errors due to differences in
    code versions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务工作者被注册时，它不会立即接管客户端。有一些规则旨在最小化由于代码版本差异而导致的错误。
- en: If a new service worker just took control of a client's context, there could
    be issues if the client or page is expecting the previous version. Even though
    the service worker operates on a separate thread, the UI code could have dependencies
    on service worker logic or cached assets. If the new version breaks the frontend,
    your user experience could go sideways.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个新的服务工作者刚刚接管了客户端的上下文，如果客户端或页面期望的是之前的版本，可能会出现问题。尽管服务工作者在单独的线程上运行，但UI代码可能依赖于服务工作者逻辑或缓存资源。如果新版本破坏了前端，用户体验可能会受到影响。
- en: 'The life cycle is designed to ensure that an in-scope page or task is controlled
    by the same service worker (or no service worker) throughout its session:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期旨在确保在整个会话期间，处于范围内的页面或任务由同一个服务工作者（或没有服务工作者）控制：
- en: '![](img/00063.jpeg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00063.jpeg)'
- en: The life cycle consists of the registration, installation, and activation steps.
    The installation and activation events can have handlers bound to them so that
    they perform specific tasks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期包括注册、安装和激活步骤。安装和激活事件可以绑定处理程序，以便它们执行特定任务。
- en: The life cycle also covers service worker updates, maybe the most important
    life cycle step, and unregistration. These last two tasks may not be used as often,
    but developers should still be familiar with how they work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期还涵盖了服务工作者更新，可能是最重要的生命周期步骤，以及注销。这两个任务可能不常用，但开发者仍然应该熟悉它们的工作方式。
- en: Each stage can be used for different process phases to manage the service worker,
    cached assets, and possibly state data. This chapter goes into details about the
    life cycle and how each phase can be used to make your application more performant
    and easier to manage.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都可以用于不同的处理阶段来管理服务工作者、缓存资源和可能的状态数据。本章将详细介绍生命周期以及每个阶段如何被用来使您的应用程序性能更优、更易于管理。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Registering a service worker
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册服务工作者
- en: Service worker clients
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者客户端
- en: Updating a service worker
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新服务工作者
- en: Service worker scope
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者作用域
- en: Service worker updates
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者更新
- en: Service worker events
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者事件
- en: When a service worker is registered, the script is downloaded and then installed.
    At this point, it does not take over any active clients, including the page that
    registers the service worker. This is by design, to ensure that the client experience
    is not at risk of breaking due to changes in service worker code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务工作者被注册时，脚本会被下载并安装。在这个时候，它不会接管任何活跃的客户端，包括注册服务工作者的页面。这是设计上的，以确保客户端体验不会因为服务工作者代码的变化而中断。
- en: When a service worker becomes active, it claims or controls any clients within
    the worker's scope. Since there could be a previous worker controlling the clients,
    a new version does not automatically take over. This could lead to all sorts of
    trouble if there are logical differences between the two versions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务工作者变为活跃时，它会声明或控制工作者范围内的任何客户端。由于可能存在控制客户端的先前工作者，新版本不会自动接管。如果两个版本之间存在逻辑差异，这可能会导致各种问题。
- en: 'To avoid potential error states, the service worker specification errs on the
    side of caution. You can call the `skipWaiting` function in the install event
    handler to cause the new version to become active. When calling `skipWaiting`,
    you may still need to claim active clients:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免潜在的错误状态，服务工作者规范倾向于谨慎行事。你可以在安装事件处理程序中调用`skipWaiting`函数，使新版本变为活跃状态。在调用`skipWaiting`时，你可能仍然需要声明活跃的客户端：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you use `skipWaiting`, it is best to call the method before you proceed to
    any pre-cache activities, because they may take a while. This is why the pre-cache
    logic is wrapped in a `waitUntil` method.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`skipWaiting`，最好在你进行任何预缓存活动之前调用该方法，因为它们可能需要一段时间。这就是为什么预缓存逻辑被封装在`waitUntil`方法中。
- en: The `waitUntil` method holds the event handler open until the tasks have finished
    processing. Think about holding an elevator door open until everyone gets on or
    off the car. If you have extending processing, the service worker will not shut
    down.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitUntil`方法在任务完成处理之前保持事件处理程序打开。想想看，直到每个人都上或下电梯，你才关闭电梯门。如果你有扩展处理，服务工作者将不会关闭。'
- en: If the service worker is idle for a long period of time, the active service
    worker is terminated to reduce CPU load and other resources it might otherwise
    consume. This is a good thing because continuous service workers would drain your
    devices battery if it ran continuously.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务工作者长时间空闲，活跃的服务工作者将被终止以减少CPU负载和其他可能消耗的资源。这是好事，因为持续运行的服务工作者会耗尽你的设备电池。
- en: Beware, if you force a new service worker to become active, you need to make
    sure that it will not break your application. Users don't like it when the user
    experience breaks and error messages are displayed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕，如果你强制新的服务工作者变为活跃，你需要确保它不会破坏你的应用程序。当用户体验中断并显示错误消息时，用户不喜欢这种情况。
- en: A best practice is to execute some sort of testing to verify the integrity of
    your application. You may also want to warn the user that the application has
    been updated, possibly encouraging a manual refresh.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最佳实践是执行某种测试以验证应用程序的完整性。你可能还希望警告用户应用程序已被更新，可能鼓励手动刷新。
- en: Never automatically refresh the page without warning the visitor as this could
    be confusing. The messaging API can be used to communicate with the user to coordinate
    the update.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在没有警告访客的情况下自动刷新页面，因为这可能会造成困惑。消息API可以用来与用户通信以协调更新。
- en: If there are any errors during the service worker installation, the registration
    will fail and its life cycle will end. After installation, the service worker
    can become active. Once active, it can respond to function events such as `fetch`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在服务工作者安装过程中出现任何错误，注册将失败，其生命周期将结束。安装后，服务工作者可以变为活跃。一旦活跃，它可以响应如`fetch`之类的功能事件。
- en: A common error during the installation handler is the cache. The `addAll` method
    may receive a 404 Not Found response. When this happens, the `addAll` method throws
    an exception. Since the install event cannot determine the error severity or context,
    it rolls back. The service worker never installs. This is represented by the red
    error block in the following flow chart.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安装处理程序期间的一个常见错误是缓存。`addAll`方法可能会收到404未找到的响应。当这种情况发生时，`addAll`方法会抛出异常。由于安装事件无法确定错误严重性或上下文，它会回滚。服务工作者永远不会安装。这在下图中表示为红色错误块。
- en: You can catch exceptions and handle them gracefully. You can still make individual
    requests and cache those results. This requires a little more code, but gives
    you some insulation against a single request, causing the service worker install
    to fail. You can also make sure that good responses are cached, even when one
    fails.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以捕获异常并优雅地处理它们。你仍然可以发出单独的请求并缓存这些结果。这需要更多的代码，但可以为你提供一些对单个请求导致服务工作者安装失败的防护。你还可以确保即使有一个失败，好的响应也会被缓存。
- en: 'The following flow chart demonstrates the core life cycle, but does not visualize
    how a service worker becomes active:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的流程图演示了核心生命周期，但不会可视化服务工作者如何变为活跃：
- en: '![](img/00064.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00064.jpeg)'
- en: Registering a service worker
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册服务工作者
- en: 'Service workers must be registered from a web page. This is done in a normal
    UI script. Before you call the `register` method, you should feature detect service
    worker support. If supported, the `navigator` object has a `serviceWorker` property:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者必须从网页中进行注册。这通常在一个常规的UI脚本中完成。在调用 `register` 方法之前，你应该检测浏览器是否支持服务工作者。如果支持，`navigator`
    对象将有一个 `serviceWorker` 属性：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the browser supports service workers, you can then safely register your
    service worker. The `serviceWorker` object has a `register` method, so you need
    to supply a URL reference to the service worker script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器支持服务工作者，您就可以安全地注册您的服务工作者。`serviceWorker` 对象有一个 `register` 方法，因此您需要提供一个服务工作者脚本的URL引用：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `serviceWorker.register("sw path"[, options])` function accepts two parameters.
    The first is the path to the service worker. This path is relative to the site
    origin or root folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`serviceWorker.register("sw path"[, options])` 函数接受两个参数。第一个是服务工作者的路径。此路径相对于网站源或根文件夹。'
- en: The second parameter is optional, and is an object containing registration options.
    For now, the only option available is `scope`. An object was used to afford future
    modifications to the `register` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是可选的，它是一个包含注册选项的对象。目前，唯一可用的选项是 `scope`。使用对象是为了允许对 `register` 函数进行未来的修改。
- en: 'The `scope` option is a string reference to the path that is relative to the
    site''s root the service worker is allowed to control. In the following example,
    a service worker is being registered for the human resources department. The same
    code would be used from the site''s root domain or the `hr` subfolder because
    all paths are relative to the site''s root:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`scope` 选项是一个字符串引用，指向服务工作者允许控制的相对于网站根目录的路径。在以下示例中，正在为人力资源部门注册一个服务工作者。相同的代码可以从网站的根域名或
    `hr` 子文件夹中使用，因为所有路径都是相对于网站根目录的：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You could register a service worker for any path within the site from anywhere.
    The scope is still limited to where the service worker physically resides. This
    means you could also register the marketing and finance service workers from the
    HR application. However, HR would not have the ability to manipulate anything
    in those applications and vice versa.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从网站的任何路径注册服务工作者，作用域仍然限制在服务工作者实际所在的位置。这意味着您也可以从人力资源应用程序中注册营销和财务服务工作者。然而，人力资源部门无法操纵那些应用程序中的任何内容，反之亦然。
- en: 'A script can be stored at any level at or above its designated scope. For example,
    if all of your application''s service workers were located in the site''s root
    folder, they would each need a different `scope` value:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以存储在其指定作用域的任何级别或以上。例如，如果您的应用程序的所有服务工作者都位于网站的根目录中，它们将需要不同的 `scope` 值：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding example demonstrates how the HR department's service worker is
    stored in the domain's root folder. Setting the scope to `/hr/` limits its scope
    to the `hr` folder and below.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了如何将人力资源部门的客服人员存储在域的根目录中。将作用域设置为 `/hr/` 限制了其作用域仅限于 `hr` 文件夹及其以下。
- en: Misunderstanding scope is one of the most common mistakes new service worker
    developers make. The first step is to accept that service workers are different
    from the client-side JavaScript we have been authoring for the past two decades.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对作用域的误解是新服务工作者开发者最常见的错误之一。第一步是接受服务工作者与我们过去二十年来编写的客户端JavaScript是不同的。
- en: You should make an effort to separate your service worker scripts from your
    traditional client script files. Place the service worker file of your register
    in your application's root folder. You can still import scripts from other folders,
    giving you the freedom to reuse code across application scopes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该努力将服务工作者脚本与传统的客户端脚本文件分开。将您注册的服务工作者文件放在应用程序的根目录中。您仍然可以从其他文件夹导入脚本，这使您能够在应用程序作用域之间重用代码。
- en: '**Scope** is a valuable feature that guards against bad things happening due
    to external service providers or sites your customer may visit. You can think
    about it as a way to silo your logical business units. It is also a way to protect
    your applications from potential security threats if one application on your domain
    becomes compromised.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**作用域**是一个有价值的特性，可以防止由于外部服务提供商或客户可能访问的网站而发生的糟糕事情。您可以将它视为隔离您的逻辑业务单元的一种方式。它也是保护您的应用程序免受潜在安全威胁的一种方式，如果您的域上的一个应用程序被破坏。'
- en: By default, a service worker is scoped to the folder the script resides in.
    The service worker is not allowed to control pages hosted at a higher folder level
    or in a sibling folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务工作者的作用域限于脚本所在的文件夹。服务工作者不允许控制位于更高文件夹级别或同级文件夹中的托管页面。
- en: Service worker clients
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者客户端
- en: I have mentioned the service worker clients several times in this chapter. The
    obvious definition is a browser tab with a site's page open. While this will be
    the case in most situations, it is not the only client type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中多次提到了服务工作者客户端。明显的定义是打开网站页面的浏览器标签页。虽然这将在大多数情况下成立，但它不是唯一的客户端类型。
- en: Because service workers execute in a separate context from a browser tab's UI
    thread, they can service multiple clients. This includes multiple tabs, push notifications,
    and background sync events. The latter two are clients without a traditional user
    interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务工作者在浏览器标签页的UI线程之外执行，它们可以为多个客户端提供服务。这包括多个标签页、推送通知和后台同步事件。后两者是没有传统用户界面的客户端。
- en: 'The service worker specification says ([https://w3c.github.io/ServiceWorker/#service-worker-client-concept](https://w3c.github.io/ServiceWorker/#service-worker-client-concept)):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者规范说明（[https://w3c.github.io/ServiceWorker/#service-worker-client-concept](https://w3c.github.io/ServiceWorker/#service-worker-client-concept)）：
- en: '"A service worker client is an environment."'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '"服务工作者客户端是一个环境。"'
- en: It goes on to define a series of potential client types. The concept of a service
    worker client is designed not to account for the obvious browser tab, but any
    process that might trigger a service worker event. For now, this includes push
    notifications and background sync events. The future is open as more features
    are being standardized to use the service worker infrastructure
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它继续定义了一系列潜在的客户类型。服务工作者客户端的概念设计不是为了考虑明显的浏览器标签页，而是任何可能触发服务工作者事件的进程。目前，这包括推送通知和后台同步事件。随着更多功能被标准化以使用服务工作者基础设施，未来是开放的。
- en: 'The following screenshot shows the Chrome developer tools listing three different
    tabs that are open from the same site:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Chrome开发者工具列出了来自同一网站的三不同标签页：
- en: '![](img/00065.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00065.jpeg)'
- en: Each tab is a unique client. You can click the focus link to the right of any
    of the clients to immediately display the corresponding browser tab.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签页都是一个唯一的客户端。你可以点击任何客户端右侧的焦点链接，立即显示相应的浏览器标签页。
- en: 'The following code allows you to check all of the service worker registrations
    for the current scope:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码允许你检查当前作用域下的所有服务工作者注册：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You may be asking, why is there a `getRegistrations` method when you can only
    have a single service worker registered for a scope? The `getRegistrations` function
    returns a list of all registered service workers within the domain.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么当只能为一个作用域注册单个服务工作者时，还有`getRegistrations`方法？`getRegistrations`函数返回域内所有已注册服务工作者的列表。
- en: 'The `getRegistration` method works in a similar fashion but only returns the
    registered service worker for the current scope:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRegistration`方法以类似的方式工作，但只返回当前作用域的已注册服务工作者：'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `getRegistration` method has an optional parameter where you can specify
    a URL and it returns the service worker registration for the worker that controls
    the URL's scope. For example, if you supplied `/marketing/`, the `registration.scope` would
    return `{domain}/marketing/`, assuming that you have a service worker registered
    for that scope.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRegistration`方法有一个可选参数，你可以指定一个URL，它将返回控制URL作用域的服务工作者注册。例如，如果你提供了`/marketing/`，则`registration.scope`将返回`{domain}/marketing/`，前提是你已为该作用域注册了服务工作者。'
- en: The service worker registration object
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者注册对象
- en: Registering a service worker creates an entry in a service worker registry that's
    maintained by the user agent. When you register or call the `getRegistration`
    or `getRegistrations` methods, they return a reference to the matching registration
    object(s).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注册服务工作者会在用户代理维护的服务工作者注册表中创建一个条目。当你注册或调用`getRegistration`或`getRegistrations`方法时，它们会返回匹配的注册对象（们）的引用。
- en: 'The registration object contains the following members:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注册对象包含以下成员：
- en: '**Properties**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**'
- en: '`scope`: The service worker''s scope'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`：服务工作者的作用域'
- en: '`installing`: If the service worker is installing, it returns a `ServiceWorker`
    object, otherwise it returns undefined'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`installing`：如果服务工作者正在安装，它返回一个`ServiceWorker`对象，否则返回undefined'
- en: '`waiting`: If the service worker is waiting, it returns a `ServiceWorker` object,
    otherwise it returns undefined'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waiting`: 如果服务工作者正在等待，它返回一个`ServiceWorker`对象，否则返回undefined'
- en: '`active`: If the service worker is active or activating, it returns a `ServiceWorker`
    object, otherwise it returns undefined'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active`: 如果服务工作者是活动状态或正在激活，它返回一个`ServiceWorker`对象，否则返回undefined'
- en: '`navigationPreLoad`: Returns a reference to the service worker''s `preLoadManager`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navigationPreLoad`: 返回服务工作者`preLoadManager`的引用'
- en: '`periodicSync`: Returns a reference to the service worker''s `PeriodicSyncManager`
    for background synchronization'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`periodicSync`: 返回服务工作者`PeriodicSyncManager`的引用，用于后台同步'
- en: '`pushManager`: Returns a reference to the service worker''s `pushManager`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pushManager`: 返回服务工作者`pushManager`的引用'
- en: '`sync`: Returns a reference to the service worker''s `syncManager`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`: 返回服务工作者`syncManager`的引用'
- en: '**Methods**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**'
- en: '`update`: Programmatically checks for a service worker update, bypassing caches'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`: 以编程方式检查服务工作者更新，绕过缓存'
- en: '`unregister`: Programmatically removes the service worker'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unregister`: 以编程方式移除服务工作者'
- en: '`getNotifications`: Returns a promise that resolves an array of notifications
    for the service worker'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNotifications`: 返回一个解析为服务工作者通知数组的承诺'
- en: '`showNotifications`: Displays a notification identified by the title'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showNotifications`: 显示由标题标识的通知'
- en: '**Event**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**'
- en: '`onupdatefound`: Triggered any time there is a new service worker'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onupdatefound`: 任何有新服务工作者时都会触发'
- en: 'The following is an example of how the `updatefound` event might be handled.
    When it triggers, there should be a `serviceworker` object present in the registration''s
    installing property. Here, the `serviceworker` object (`newWorker`) has had its
    state property interrogated:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何处理`updatefound`事件的示例。当它触发时，注册的安装属性中应该有一个`serviceworker`对象。在这里，`serviceworker`对象（`newWorker`）已经对其状态属性进行了查询：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This event could be used to perform a series of logic to prepare the client
    for updating, including notifying the user to reload the browser to take advantage
    of the newer version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件可以用来执行一系列逻辑，为客户端更新做准备，包括通知用户重新加载浏览器以利用新版本。
- en: The `update` and `unregister` methods will be covered in [Chapter 6](part0123.html#3L9L60-f12cdcca08b54960b3d271452dc7667d),
    *Mastering the Cache API – Managing Web Assets in a Podcast Application*. Let's
    take a moment to see how push notifications work.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`和`unregister`方法将在[第6章](part0123.html#3L9L60-f12cdcca08b54960b3d271452dc7667d)中介绍，*掌握Cache
    API – 在播客应用程序中管理Web资源*。让我们花点时间看看推送通知是如何工作的。'
- en: Updating a service worker
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新服务工作者
- en: 'The following diagrams show the sequence a service worker goes through during
    a replacement cycle. The first diagram shows how a new service worker is registered
    and lives *next to* an existing service worker. The new service worker is not
    active, but hangs around, waiting for all active clients to close:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了服务工作者在替换周期中经历的序列。第一个图表显示了如何注册新的服务工作者，并使其与现有服务工作者并存。新的服务工作者不是活动的，而是在等待所有活动客户端关闭：
- en: '![](img/00066.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.jpeg)'
- en: 'Once the clients are closed, the initial service worker dies and the new service
    worker begins its new active role:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端关闭，初始服务工作者死亡，新的服务工作者开始其新的活动角色：
- en: '![](img/00067.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.jpeg)'
- en: 'After the new service worker becomes active, it is the only service worker
    that''s alive:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的服务工作者变为活动状态后，它是唯一存活的服务工作者：
- en: '![](img/00068.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: Service worker scope
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者作用域
- en: As mentioned earlier, service workers are limited to a single domain. The domain
    is your site's address, such as [https://podcast.love2dev.com/](https://podcast.love2dev.com/).
    This is a security feature. Limiting a service worker is known as the **service
    worker's scope**. This prevents external scripts from doing bad things to your
    site.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，服务工作者限制在单个域。域是您网站的地址，例如[https://podcast.love2dev.com/](https://podcast.love2dev.com/)。这是一个安全特性。限制服务工作者被称为**服务工作者作用域**。这防止外部脚本对你的网站进行恶意操作。
- en: Imagine if your customer also visits your competition's web site, which installs
    a service worker. Without limits on service worker scope, they could conceivably
    manipulate your content or spy on you and your customer's private data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你的客户也访问了你的竞争对手的网站，该网站安装了一个服务工作者。如果没有对服务工作者作用域的限制，他们可能理论上会操纵你的内容或监视你和你客户的私人数据。
- en: In fact, a third-party script cannot register a service worker from a page on
    your site. This should keep external scripts and service providers from using
    service workers in conjunction with your domain.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，第三方脚本不能从你网站上的页面注册服务工作者。这应该阻止外部脚本和服务提供商使用服务工作者与你的域名结合使用。
- en: A service worker is limited to the origin domain, and it is also limited to
    the folder in which it is physically located. This means you can register a service
    worker in any subfolder within the site's domain. The child script would control
    any request originating from its folder and below.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者限于原始域名，并且也限于其物理位置所在的文件夹。这意味着你可以在网站域名内的任何子文件夹中注册服务工作者。子脚本将控制来自其文件夹及其以下的任何请求。
- en: If another service worker were to register at a lower folder, then it would
    take control from that folder down and so on. Another way to think about a service
    worker's scope of control is downward, but not upward. A script residing in a
    subfolder does not execute in response to events triggered at the site's root.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个服务工作者在较低文件夹中注册，那么它将控制从该文件夹向下，依此类推。另一种思考服务工作者控制范围的方式是向下，而不是向上。位于子文件夹中的脚本不会对网站根目录触发的事件做出响应。
- en: Be careful about where your service worker file is located. The common practice
    is to store JavaScript files under a `/js` folder. This is fine for traditional
    UI JavaScript, but often leads to confusion when the service worker file is stored
    under the `js` folder. The best practice is to locate the service worker in your
    site's root folder or root folder of the scope it controls.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你的服务工作者文件的位置。常见的做法是将JavaScript文件存储在`/js`文件夹下。这对于传统的UI JavaScript来说是可行的，但当服务工作者文件存储在`js`文件夹下时，往往会引起混淆。最佳实践是将服务工作者放在你网站的根文件夹或其控制的范畴的根文件夹中。
- en: The scope determines which pages are controlled by the service worker. Once
    a page is controlled by a service worker, all HTTP requests originating from the
    page, regardless of the request URL, will trigger the service worker's fetch event.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴决定了哪些页面受服务工作者控制。一旦页面受服务工作者控制，来自该页面的所有HTTP请求（无论请求URL如何），都将触发服务工作者的fetch事件。
- en: Most of the time, this means that your service worker is located in the top
    folder of your domain's website. But there are many scenarios where this would
    not be the case. Large sites and corporate intranet sites are often collections
    of different, isolated applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这意味着你的服务工作者位于你域名网站的最高文件夹中。但有许多场景下情况并非如此。大型网站和公司内部网站通常是不同、隔离应用的集合。
- en: In architectures where there are different application islands, each application
    can have its own service worker. For example, an enterprise might have sibling
    sites for HR, finance, and marketing. Each one can have a separate service worker.
    The different service workers are isolated from each other and cannot access the
    other applications' scope.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在有不同应用岛屿的架构中，每个应用都可以有自己的服务工作者。例如，一个企业可能有HR、财务和营销的兄弟网站。每个都可以有单独的服务工作者。不同的服务工作者彼此隔离，不能访问其他应用的范畴。
- en: Each of these service workers could be registered anywhere within the site's
    root domain. This means you can register a child application's service worker
    from another scope. Each service worker is still limited in scope to the folder
    in which it resides and below.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务工作者可以在网站根域名内的任何位置注册。这意味着你可以从另一个范畴注册子应用的服务工作者。每个服务工作者仍然限于其所在的文件夹及其以下。
- en: 'The following screenshot shows that four service workers can be registered
    for a single site, each controlling their own scope:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示，可以为单个网站注册四个服务工作者，每个控制自己的范畴：
- en: '![](img/00069.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00069.jpeg)'
- en: Service worker updates
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者更新
- en: Updating the service worker file can be a tricky concept as well. There are
    several factors that determine when your service worker is updated. The update
    cycle does not start until the browser determines that there is a new service
    worker file available.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更新服务工作者文件也是一个复杂的概念。有几个因素决定何时更新你的服务工作者。更新周期只有在浏览器确定有新的服务工作者文件可用时才会开始。
- en: Once a service worker is registered, the browser treats the file like any other
    file when determining if there is a new version available. It makes a request
    to the server, which triggers a well-known cycle.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务工作者注册，浏览器在确定是否有新版本可用时，会像对待任何其他文件一样对待该文件。它向服务器发出请求，这触发了已知的周期。
- en: First, there is the local browser cache (not the service worker cache) for the
    file. If there is a local version available that has not become stale, it is retrieved.
    Next, the request is sent across the network to the server. If the server responds
    with a 304, it means that the browser has the most current version. If the file
    has not changed, then the service worker update cycle does not start. If there
    is a newer version, the service worker is updated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是本地浏览器缓存（不是service worker缓存）中的文件。如果有可用的本地版本且尚未过时，它将被检索。接下来，请求通过网络发送到服务器。如果服务器响应304，这意味着浏览器拥有最新版本。如果文件没有更改，则不会启动service
    worker更新周期。如果有新版本，则更新service worker。
- en: The one exception to the basic update flow is a built-in guard against large
    Cache-Control header values. The browser will always retrieve the service worker
    from the server if it has not been updated within the past 24 hours.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 基本更新流程的一个例外是内置的防止大Cache-Control头值的保护措施。如果服务工作者在过去24小时内没有更新，浏览器将始终从服务器检索服务工作者。
- en: Cache-Control headers tell the browser how long to persist a copy of a file
    in browser storage. For most assets, you want a long time to cache, for example,
    a year, because they don't change often. This could lead to a bad situation where
    your application is not updated.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Cache-Control头告诉浏览器在浏览器存储中保留文件副本的时间长度。对于大多数资产，你希望缓存时间较长，例如一年，因为它们不经常更改。这可能导致你的应用程序无法更新的糟糕情况。
- en: For static assets such as style sheets and images, a common practice is to name
    them using a file hash generated value and assign a very long lifetime to them.
    This means any updates use a new file name and trigger a new request. You can
    certainly employ this strategy with service workers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态资产，如样式表和图像，常见的做法是使用由文件哈希生成的值来命名它们，并给它们分配一个非常长的生命周期。这意味着任何更新都会使用新的文件名并触发新的请求。你当然可以使用这种策略与service
    workers一起使用。
- en: If you use the same service worker file name, then you should set a short lifetime.
    This can vary from a few minutes to a few hours. Anything over 24 hours will be
    ignored by the browser.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用相同的service worker文件名，那么你应该设置一个短的生命周期。这可以从几分钟到几小时不等。超过24小时的内容将被浏览器忽略。
- en: If the browser has not checked for a new service worker version within the past
    24 hours, it will force a server-side check. This was added to the spec as a safety
    precaution just in case you deploy a service worker that causes major problems
    and you cannot force an update programmatically.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器在过去24小时内没有检查新的service worker版本，它将强制进行服务器端检查。这被添加到规范中作为安全预防措施，以防你部署了一个可能导致重大问题的service
    worker，而你无法通过编程方式强制更新。
- en: This scenario could play out if you have a long cache time specified for the
    pages in your site that register the service worker and have done the same for
    the service worker script. This means that the worst-case scenario you would experience
    would a full day from the time the bad service worker was installed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能会发生，如果你为你的网站中注册了service worker的页面指定了较长的缓存时间，并且对service worker脚本也做了同样的处理。这意味着你可能会经历的最坏情况是从有缺陷的service
    worker安装之日起整整一天。
- en: Not the best solution to a bad problem, but at least there is an ultimate fail-safe
    to bail you out. If you find yourself in this situation, you can still deploy
    the update immediately and users that have not installed the buggy version will
    be spared.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是解决糟糕问题的最佳方案，但至少有一个终极的安全措施来帮助你。如果你发现自己处于这种情况，你仍然可以立即部署更新，而尚未安装有缺陷版本的用戶将免受影响。
- en: Service worker events
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Service worker事件
- en: 'There are two types of service worker events: core and functional. Core messages
    are fundamental to what makes a service worker a service worker. Functional events
    can be thought of as extensions to the central service worker backbone:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者事件有两种类型：核心和功能。核心消息是使服务工作者成为服务工作者基本要素的。功能事件可以被视为对中央服务工作者骨干的扩展：
- en: '**Core Events**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**核心事件**:'
- en: Install
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Install
- en: Activate
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Activate
- en: Message
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息
- en: '**Functional Events**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能事件**:'
- en: '`fetch`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch`'
- en: '`sync`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`'
- en: '`push`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`'
- en: Each of these events can be used to trigger processing. The install and activate
    events are part of the life cycle. In [Chapter 7](part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d), *Service
    Worker Caching Patterns*, we will dive into different caching patterns. The install
    and activate events are very useful to manage pre-caching assets and cleaning
    up your cache model.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件中的每一个都可以用来触发处理。安装和激活事件是生命周期的一部分。在第 7 章，*服务工作者缓存模式*（[Chapter 7](part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d)），我们将深入研究不同的缓存模式。安装和激活事件对于管理预缓存资源和清理你的缓存模型非常有用。
- en: When a new service worker is registered, the install event immediately triggers.
    The activate event triggers when the service worker becomes active. This means
    that any existing service worker is replaced with the new service worker.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册新的服务工作者时，安装事件立即触发。激活事件在服务工作者变得活跃时触发。这意味着任何现有的服务工作者都会被新的服务工作者替换。
- en: The message event triggers when a message is sent from the client using the
    `postMessage` method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端使用 `postMessage` 方法发送消息时，会触发消息事件。
- en: Functional events are triggered in response to external actions. We have already
    looked at push and background sync. In Chapter 6, *Mastering the Cache API – Managing
    Web Assets in a Podcast Application*, we will review how the Fetch API works and
    start down the path of caching strategies.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性事件是对外部动作的响应而触发的。我们已经探讨了推送和后台同步。在第 6 章，*掌握 Cache API – 在播客应用程序中管理网络资源*，我们将回顾
    Fetch API 的工作原理，并开始探讨缓存策略。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The service worker life cycle looks simple until you start working with service
    workers. Understanding how the life cycle executes is helpful so that you can
    understand what the state of your service worker is.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者生命周期看起来很简单，直到你开始与它们一起工作。了解生命周期如何执行有助于你理解服务工作者的状态。
- en: The service worker life cycle is designed to help us avoid situations where
    you upgrade and could potentially break the application. A new service worker
    can be registered, but wait for any existing clients to close. When safe, you
    could use the `skipWaiting` method to allow a new service worker to immediately
    take control.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者（service worker）的生命周期旨在帮助我们避免在升级过程中可能破坏应用程序的情况。可以注册一个新的服务工作者，但需要等待任何现有的客户端关闭。当安全时，你可以使用
    `skipWaiting` 方法允许新的服务工作者立即接管控制。
- en: More complex applications may also have multiple service workers with different
    scopes. This allows larger applications to silo control across the different sub
    applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的应用程序也可能有多个具有不同作用域的服务工作者。这允许大型应用程序在不同子应用程序之间实现隔离控制。
- en: Now that you have a foundation in how to use the service worker and the service
    worker life cycle, in the next chapter, you will see how to use the Fetch and
    Cache APIs to make the Podstr app work offline and save episodes to listen to
    anywhere, anytime.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用服务工作者和服务工作者生命周期，在下一章中，你将看到如何使用 Fetch 和 Cache API 使 Podstr 应用程序离线工作，并将剧集保存到任何地方、任何时间都可以收听。
