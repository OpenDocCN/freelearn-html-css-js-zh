- en: Chapter 2. General Considerations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章.一般考虑
- en: Building secure Node.js applications will require an understanding of the many
    different layers that it is built upon. Starting from the bottom, we have the
    language specification that defines what JavaScript consists of. Next, the virtual
    machine executes your code and may have differences from the specification. Following
    that, the Node.js platform and its API have details in their operation that affect
    your applications. Lastly, third-party modules interact with our own code and
    need to be audited for secure programming practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建安全的Node.js应用程序将需要理解它所构建的许多不同层次。从底层开始，我们有定义JavaScript组成的语言规范。接下来，虚拟机执行你的代码，并且可能与规范有所不同。在此之后，Node.js平台及其API在操作上有细节会影响你的应用程序。最后，第三方模块与我们自己的代码交互，并且需要进行安全编程实践的审计。
- en: First, JavaScript's official name is ECMAScript. The international **European
    Computer Manufacturers Association** (**ECMA)** first standardized the language
    as **ECMAScript** in 1997\. This ECMA-262 specification defines what comprises
    JavaScript as a language, including its features, and even some of its bugs. Even
    some of its general quirkiness has remained unchanged in the specification to
    maintain backward compatibility. While I won't say the specification itself is
    required reading, I will say that it is worth considering.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，JavaScript的官方名称是ECMAScript。国际**欧洲计算机制造商协会**（**ECMA**）在1997年首次将这种语言标准化为**ECMAScript**。这个ECMA-262规范定义了JavaScript作为一种语言的组成，包括它的特性，甚至一些它的错误。甚至一些它的一般古怪之处在规范中保持不变，以保持向后兼容性。虽然我不会说规范本身是必读的，但我会说它是值得考虑的。
- en: Second, Node.js uses Google's **V8** virtual machine to interpret and execute
    your source code. While developing for the browser, you have to consider all the
    other virtual machines (not to mention versions), when it comes to available features.
    In a Node.js application, your code only runs on the server, so you have much
    more freedom, and you can use all the features available to you in V8\. Additionally,
    you can also optimize for the V8 engine exclusively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Node.js使用Google的**V8**虚拟机来解释和执行你的源代码。在为浏览器开发时，你需要考虑所有其他虚拟机（更不用说版本了），以及可用的功能。在Node.js应用程序中，你的代码只在服务器上运行，因此你有更多的自由，并且可以使用V8中可用的所有功能。此外，你还可以专门为V8引擎进行优化。
- en: Next, Node.js handles setting up the event loop, and it takes your code to register
    callbacks for events and executes them accordingly. There are some important details
    regarding how Node.js responds to exceptions and other errors that you will need
    to be aware of while developing your applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Node.js处理设置事件循环，并且它会接受你的代码来注册事件的回调并相应地执行它们。在开发应用程序时，你需要注意Node.js对异常和其他错误的响应的一些重要细节。
- en: Atop Node.js is the developer API. This API is written mostly in JavaScript
    which allows you, as a JavaScript developer, to read it for yourself, and understand
    how it works. There are many provided modules that you will likely end up using,
    and it's important for you to know how they work, so you can code defensively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js之上是开发者API。这个API主要用JavaScript编写，允许你作为JavaScript开发者自己阅读它，并理解它的工作原理。有许多提供的模块可能会被你使用，了解它们的工作原理对你来说很重要，这样你就可以进行防御性编码。
- en: Last, but not least, the third-party modules that npm gives you access to, are
    in great abundance, which can be a double-edged sword. On one hand, you have many
    options to pick from that suit your needs. On the other hand, having a third-party
    code is a potential security liability, as you will be expected to support and
    audit each of these modules (in addition to their own dependencies) for security
    vulnerabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，npm提供给你访问的第三方模块数量众多，这可能是一把双刃剑。一方面，你有很多选项可以满足你的需求。另一方面，拥有第三方代码可能是一个潜在的安全责任，因为你需要支持和审计每一个这些模块（以及它们自己的依赖项）以寻找安全漏洞。
- en: JavaScript security
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript安全
- en: 'One of the biggest security risks in JavaScript itself, both on the client
    and now on the server, is the use of the `eval()` function. This function, and
    others like it, takes a string argument, which can represent an expression, statement,
    or a series of statements, and it is executed as any other JavaScript source code.
    This is demonstrated in the following code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript本身最大的安全风险之一，无论是在客户端还是现在在服务器端，就是使用`eval()`函数。这个函数，以及类似它的其他函数，接受一个字符串参数，它可以表示一个表达式、语句或一系列语句，并且会像其他JavaScript源代码一样被执行。这在下面的代码中有所展示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code has full access to the current scope, and can even affect the global
    object, giving it an alarming amount of control. Let''s look at the same code,
    but imagine if someone malicious sent arbitrary JavaScript code instead of a simple
    number. The result is shown in the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以完全访问当前作用域，甚至可以影响全局对象，给它带来了令人担忧的控制权。让我们看看相同的代码，但想象一下如果有人恶意发送任意的JavaScript代码而不是一个简单的数字。结果如下所示：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Due to how `eval()` is exploited here, we are witnessing a "remote code execution"
    attack! When executed directly on the server, an attacker could gain access to
    server files and databases. There are a few cases where `eval()` can be useful,
    but if the user input is involved in any step of the process, it should likely
    be avoided at all costs!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里`eval()`的滥用，我们正在目睹一次“远程代码执行”攻击！当直接在服务器上执行时，攻击者可能会访问服务器文件和数据库。`eval()`有一些情况下可能会有用，但如果用户输入涉及到任何步骤，那么最好尽量避免使用！
- en: 'There are other features of JavaScript that are functional equivalents to `eval()`,
    and should likewise be avoided unless absolutely necessary. First is the `Function`
    constructor that allows you to create a callable function from strings, as shown
    in the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还有其他与`eval()`功能等效的功能，除非绝对必要，否则也应该避免使用。首先是`Function`构造函数，它允许你从字符串创建一个可调用的函数，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While very similar to the `eval()` function, it is not exactly the same. This
    is because it does not have access to the current scope. However, it does still
    have access to the global object, and should be avoided whenever a user input
    is involved.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与`eval()`函数非常相似，但并非完全相同。这是因为它无法访问当前范围。但是，它仍然可以访问全局对象，并且在涉及用户输入时应避免使用。
- en: If you find yourself in a situation where there is an absolute need to execute
    an arbitrary code that involves user input, you do have one secure option. Node.js
    platform's API includes a **vm** module that is meant to give you the ability
    to compile and run code in a sandbox, preventing manipulation of the global object
    and even the current scope.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现自己处于需要执行涉及用户输入的任意代码的情况下，确实有一个安全选项。Node.js平台的API包括一个旨在让您能够在沙盒中编译和运行代码的**vm**模块，以防止操纵全局对象甚至当前范围。
- en: It should be noted that the vm module has many known issues and edge cases.
    You should read the documentation, and understand all the implications of what
    you are doing to make sure you don't get caught off-guard.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，vm模块存在许多已知问题和边缘情况。您应该阅读文档，并了解您所做的一切可能带来的影响，以确保您不会措手不及。
- en: ES5 features
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES5功能
- en: 'ECMAScript5 included an extensive batch of changes to JavaScript, including
    the following changes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript5对JavaScript进行了广泛的更改，包括以下更改：
- en: Strict mode for removing unsafe features from the language.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 严格模式用于从语言中删除不安全的功能。
- en: Property descriptors that give you control over object and property access.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性描述符可控制对象和属性访问。
- en: Functions for changing object mutability.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改对象可变性的功能。
- en: Strict mode
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式
- en: Strict mode changes the way JavaScript code runs in select cases. First, it
    causes errors to be thrown in cases that were silent before. Second, it removes
    and/or change features that made optimizations for JavaScript engines either difficult
    or impossible. Lastly, it prohibits some syntax that is likely to show up in future
    versions of JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式改变了JavaScript代码在某些情况下的运行方式。首先，它会在以前是静默的情况下抛出错误。其次，它会删除和/或更改使JavaScript引擎优化变得困难或不可能的功能。最后，它禁止了一些可能出现在未来版本JavaScript中的语法。
- en: Additionally, strict mode is opt-in only, and can be applied either globally
    or for an individual function scope. For Node.js applications, to enable strict
    mode globally, add the `–use_strict` command line flag, while executing your program.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，严格模式仅适用于选择加入，并且可以全局应用或应用于单个函数范围。对于Node.js应用程序，要全局启用严格模式，请在执行程序时添加`-use_strict`命令行标志。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While dealing with third-party modules that may or may not be using strict mode,
    this can potentially have negative side effects on your overall application. With
    that said, you could potentially make strict mode compliance a requirement for
    any audits on third-party modules.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理可能使用严格模式的第三方模块时，这可能会对整个应用程序产生负面影响。话虽如此，您可能会要求第三方模块的审核符合严格模式的要求。
- en: 'Strict mode can be enabled by adding the `"use strict"` pragma at the beginning
    of a function, before any other expressions as shown in the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数开头添加`"use strict"`指示符，可以启用严格模式，在任何其他表达式之前，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Node.js, all the required files are wrapped with a function expression that
    handles the `CommonJS` module API. As a result, you can enable strict mode for
    an entire file, by simply putting the directive at the top of the file. This will
    not enable strict mode globally, as it would in an environment like the browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，所有所需的文件都包装在一个处理`CommonJS`模块API的函数表达式中。因此，您可以通过简单地将指令放在文件顶部来为整个文件启用严格模式。这不会像在浏览器等环境中那样全局启用严格模式。
- en: Strict mode makes many changes to the syntax and runtime behavior, but for the
    sake of brevity we will only discuss changes relevant to application security.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式对语法和运行时行为进行了许多更改，但为了简洁起见，我们只讨论与应用程序安全相关的更改。
- en: 'First, scripts run via `eval()` in strict mode cannot introduce new variables
    to the enclosing scope. This prevents leaking new and possibly conflicting variables
    into your code, when you run `eval()` as shown in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在严格模式下，通过`eval()`运行的脚本无法向封闭范围引入新变量。这可以防止在运行`eval()`时泄漏新的可能会与现有变量冲突的变量，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In addition, the code run via `eval()` is not given access to the global object
    through its context. This is similar, if not related, to other changes for function
    scope, which will be explained shortly, but this is specifically important for
    `eval()`, as it can no longer use the global object to perform additional black
    magic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过`eval()`运行的代码无法通过其上下文访问全局对象。这与其他函数范围的更改类似，不过稍后将对此进行解释，但对于`eval()`来说，这是特别重要的，因为它不能再使用全局对象执行其他黑魔法。
- en: 'It turns out that the `eval()` function is able to be overridden in JavaScript.
    It can be accomplished by creating a new global variable called `eval`, and assigning
    something else to it, which could be malicious. Strict mode prohibits this type
    of operation. It is treated more like a language keyword than a variable, and
    attempting to modify it will result in a syntax error as shown in the following
    code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`eval()`函数可以在JavaScript中被覆盖。可以通过创建一个名为`eval`的新全局变量，并为其分配其他内容来实现。严格模式禁止了这种操作。它更像是一个语言关键字而不是一个变量，尝试修改它将导致语法错误，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, the function objects are more tightly secured. Some common extensions
    to ECMAScript add the `function.caller` and `function.arguments` references to
    each function, after it is invoked. Effectively, you can "walk" the call stack
    for a specific function by traversing these special references. This potentially
    exposes information that would normally appear to be out of scope. Strict mode
    simply makes these properties throw a `TypeError` remark, while attempting to
    read or write them, as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，函数对象更加安全。ECMAScript 的一些常见扩展为每个函数添加了 `function.caller` 和 `function.arguments`
    引用，这些引用在函数调用后出现。实际上，您可以通过遍历这些特殊引用来“遍历”特定函数的调用堆栈。这可能会暴露通常看起来超出范围的信息。严格模式只是在尝试读取或写入这些属性时抛出
    `TypeError` 备注，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, `arguments.callee` is removed in strict mode (such as `function.caller`
    and `function.arguments` shown previously). Normally, `arguments.callee` refers
    to the current function, but this magic reference also exposes a way to "walk"
    the call stack, and possibly reveal information that previously would have been
    hidden or out of scope. In addition, this object makes certain optimizations difficult
    or impossible for JavaScript engines. Thus, it also throws a `TypeError` exception,
    when an access is attempted, as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在严格模式下移除了 `arguments.callee`（例如前面显示的 `function.caller` 和 `function.arguments`）。通常，`arguments.callee`
    指的是当前函数，但这个神奇的引用也暴露了一种“遍历”调用堆栈的方式，可能会揭示以前隐藏或超出范围的信息。此外，这个对象使得某些优化对 JavaScript
    引擎来说变得困难或不可能。因此，当尝试访问时，它也会抛出 `TypeError` 异常，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, functions executed with `null` or `undefined` as the context no longer
    coerce the global object as the context. This applies to `eval()` as we saw earlier,
    but goes further to prevent arbitrary access to the global object in other function
    invocations, as shown in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `null` 或 `undefined` 作为上下文执行的函数不再将全局对象强制转换为上下文。这适用于之前看到的 `eval()`，但更进一步地阻止了在其他函数调用中对全局对象的任意访问，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Strict mode can help make the code far more secure than before, but ECMAScript
    5 also includes access control through the property descriptor APIs. A JavaScript
    engine has always had the capability to define property access, but ES5 includes
    these APIs to give that same power to application developers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式可以帮助使代码比以前更加安全，但 ECMAScript 5 也通过属性描述符 API 包括了访问控制。JavaScript 引擎一直具有定义属性访问的能力，但
    ES5 包括了这些 API，将同样的权力赋予应用程序开发人员。
- en: Object property descriptors
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象属性描述符
- en: 'Object properties have the following three hidden attributes that determine
    what mutations can occur to them:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对象属性具有以下三个隐藏属性，确定对它们可以进行哪些变化：
- en: '`writable`: If this is `false` means the property value cannot be changed (in
    other words, read only)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writable`：如果这是 `false`，意味着属性值不能被更改（换句话说，只读）'
- en: '`enumerable`: If this is `false` means the property will not come up during
    for in loops'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerable`：如果这是 `false`，意味着该属性在 for in 循环中不会出现'
- en: '`configurable`: If this is `false` means the property cannot be deleted'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configurable`：如果这是 `false`，意味着该属性不能被删除'
- en: While defining an object property with an object literal or through assignment,
    which is the most common method, each of these three hidden properties defaults
    to `true`. This makes the property completely open to modification in every respect.
    However, there are a few new functions that allow application developers to set
    these property attributes on their own, restricting access to certain object properties.
    The property descriptor API is completely opt-in, and the default behavior of
    object properties does not change, even in ES5.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用对象字面量或赋值定义对象属性时，这是最常见的方法，这三个隐藏属性的默认值都是 `true`。这使得属性在各个方面完全开放修改。然而，有一些新函数允许应用程序开发人员自行设置这些属性，限制对某些对象属性的访问。属性描述符
    API 是完全自选的，即使在 ES5 中，对象属性的默认行为也不会改变。
- en: 'First, the `Object.defineProperty()` function allows you to specify a single
    property and its accessor descriptor on a specified object. It takes three arguments:
    the target object, the name of the new property, and the descriptor object mentioned
    earlier. An accessor descriptor is just an object that contains specified properties
    corresponding to the attributes listed earlier.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Object.defineProperty()` 函数允许您在指定的对象上指定单个属性及其访问器描述符。它接受三个参数：目标对象、新属性的名称和前面提到的描述符对象。访问器描述符只是一个包含指定属性的对象，这些属性对应于前面列出的属性。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The accessor descriptor tells JavaScript engine, the access level to give to
    our new property. While using `Object.defineProperty()` and its related functions,
    it is important to note that all the descriptor attributes value are by default
    set to `false`. This is the opposite effect when compared to basic assignment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器描述符告诉 JavaScript 引擎，要给我们的新属性赋予的访问级别。在使用 `Object.defineProperty()` 及其相关函数时，重要的是要注意，所有描述符属性值默认设置为
    `false`。这与基本赋值相比产生了相反的效果。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Both of these statements have the same result, and the latter is much more
    verbose. However, traditional assignment cannot affect any of the descriptors,
    unlike the latter. Let''s see what it takes to create a "locked down" property:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个语句具有相同的结果，后者更加冗长。然而，传统赋值不能影响任何描述符，与后者不同。让我们看看创建“锁定”属性需要什么：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we have just done is created a property that cannot be written, deleted,
    or enumerated, making it immutable. This allows application developers to control
    data access, even while sharing objects across various code boundaries.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的是创建了一个不能被写入、删除或枚举的属性，使其不可变。这允许应用程序开发人员控制数据访问，即使在各种代码边界之间共享对象。
- en: 'One last capability afforded by accessor descriptors is to allow developers
    to create getter and setter functions for specific properties. A getter is a function
    that returns the data when a property is accessed, and a setter stores the data
    that is sent via an assignment. This is illustrated in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器描述符提供的最后一个功能是允许开发人员为特定属性创建getter和setter函数。getter是一个在访问属性时返回数据的函数，setter存储通过赋值发送的数据。以下是示例代码：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code creates a property that contains data from two other properties on
    the same object, and it is computed dynamically. The same could be accomplished
    with a function in many cases, but this enables more separation between the two
    operations, without needing two separate functions on the object itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个包含来自同一对象上的两个其他属性的数据的属性，并且是动态计算的。在许多情况下，可以使用函数来实现相同的效果，但这样可以更好地分离这两个操作，而不需要在对象本身上使用两个单独的函数。
- en: 'The next function, `Object.defineProperties()`, is similar. This one, however,
    only takes two arguments, the host object and another object that is a hash of
    multiple properties, where the property values are all accessor descriptors. This
    is seen in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数`Object.defineProperties()`类似。然而，这个函数只接受两个参数，宿主对象和另一个对象，该对象是多个属性的哈希，其中属性值都是访问器描述符。以下是示例代码：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This allows us to condense multiple property definitions into a single function
    call, which is more about convenience than anything else. Next up is the most
    powerful of them all: the `Object.create()` function. This function creates a
    completely new object from scratch, and also assigns it a prototype. This is reflective
    of the prototypal nature of JavaScript, and we will not take time to discuss that
    further, as it is not particularly relevant to this discussion.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以将多个属性定义压缩成一个函数调用，这更多的是为了方便。接下来是其中最强大的函数：`Object.create()`函数。这个函数从头开始创建一个全新的对象，并为其分配一个原型。这反映了JavaScript的原型性质，我们不会花时间进一步讨论这一点，因为它与本讨论并不特别相关。
- en: 'This function only takes two arguments, the prototype for the new object (or
    `null` to assign no inheritance at all), and a properties object just like we
    use in `Object.defineProperties()`, as shown in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只接受两个参数，新对象的原型（或`null`以完全不继承）和一个属性对象，就像我们在`Object.defineProperties()`中使用的那样，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By setting the prototype as `null`, instead of some other object, we have created
    a completely plain object that inherits nothing, not even from the `Object.prototype`
    object. This is desirable as even modifications to `Object.prototype` (which is
    a bad idea anyway) will not adversely affect objects created with this method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将原型设置为`null`，而不是其他对象，我们创建了一个完全普通的对象，它不继承任何东西，甚至不继承自`Object.prototype`对象。这是可取的，因为即使对`Object.prototype`的修改（这本来就是一个坏主意）也不会对使用这种方法创建的对象产生不利影响。
- en: 'There are a few other special functions for changing an object''s accessibility.
    First is the `Object.preventExtensions()` function, which prevents new properties
    from being added to the object specified, as shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他特殊的函数用于改变对象的可访问性。首先是`Object.preventExtensions()`函数，它防止向指定的对象添加新属性，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, this allows you to configure an object so that nobody else can
    create additional properties on your object. If you include strict mode in the
    mix, the last assignment will throw an error rather than failing silently. Also,
    it should be noted that this operation cannot be reversed once it has occurred.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这允许你配置一个对象，以便其他人无法在你的对象上创建额外的属性。如果在混合中包括严格模式，最后的赋值将抛出错误，而不是悄无声息地失败。另外，应该注意的是，这个操作一旦发生就无法逆转。
- en: Next is the `Object.seal()` function which takes an object, and prevents properties
    from being deleted, in addition to the effects of the `Object.preventExtensions()`
    function. In other words, this takes all the existing properties and sets their
    configurable property attributes to `false`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Object.seal()`函数，它接受一个对象，并防止属性被删除，除了`Object.preventExtensions()`函数的效果。换句话说，这将获取所有现有属性，并将它们的可配置属性设置为`false`。
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is powerful because we can preserve the structure of an object, but still
    allow property values to change. Like before, this operation cannot be reversed.
    In addition, adding the strict mode causes an exception to be thrown, rather than
    allowing the operation to fail silently.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这很强大，因为我们可以保留对象的结构，但仍然允许属性值发生变化。与之前一样，这个操作是不可逆的。此外，添加严格模式会导致抛出异常，而不是允许操作悄无声息地失败。
- en: 'Last up is the most powerful of them all, the `Object.freeze()` function. This
    function applies all the same effects as `Object.seal()`, and also completely
    locks down all the properties. No values can be changed (that is, all writable
    attributes are set to `false`), and the property descriptors are all unmodifiable.
    This makes the object effectively immutable, and prevents all other attempts to
    change anything about the object, as shown in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是其中最强大的`Object.freeze()`函数。这个函数应用了与`Object.seal()`相同的效果，并完全锁定了所有属性。没有值可以被改变（即所有可写属性都设置为`false`），并且属性描述符都是不可修改的。这使得对象实际上是不可变的，并阻止所有其他尝试改变对象的任何操作，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Freezing an object is, like the other operations, irreversible. In strict mode,
    errors will be thrown during any attempt to write or change the object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结对象与其他操作一样，是不可逆转的。在严格模式下，任何尝试写入或更改对象的操作都会引发错误。
- en: Static program analysis
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态程序分析
- en: Keeping a track of all the things we have discussed here can be overwhelming.
    The problem is compounded, when a team of people are working on the same project.
    Tools that perform static analysis take your source code (without executing it),
    and check for specific code patterns that you can configure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪我们在这里讨论的所有事情可能会让人不知所措。当一个团队的人在同一个项目上工作时，问题会变得更加复杂。执行静态分析的工具会获取你的源代码（而不是执行它），并检查你可以配置的特定代码模式。
- en: For example, you can configure **JSHint** to forbid the use of `eval()` and
    require strict mode for all your functions. By letting it examine your source
    code, it will alert you when these rules are violated. This can be used in conjunction
    with version control to prevent insecure code from being added to your project's
    repository. In addition, it can also be used prior to releases to ensure that
    all the code is secured before heading out to production.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以配置**JSHint**禁止使用`eval()`并要求所有函数使用严格模式。通过让它检查你的源代码，当违反这些规则时，它会提醒你。这可以与版本控制结合使用，以防止不安全的代码被添加到项目的代码库中。此外，它也可以在发布之前使用，以确保所有代码在进入生产环境之前都是安全的。
- en: JSHint is a community-driven fork of the **JSLint** project. JSLint is opinionated
    and it is not as configurable as many desired, so JSHint was created to fill that
    gap. Both are great tools, and I highly recommend you adopt either one for your
    JS projects. While static analysis will not catch everything, it will help ensure
    a higher quality of code through automation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JSHint是**JSLint**项目的社区驱动分支。JSLint持有主观意见，不像许多人所期望的那样可配置，因此创建了JSHint来填补这一空白。两者都是很好的工具，我强烈建议你为你的JS项目采用其中之一。虽然静态分析不会捕捉一切，但它将通过自动化帮助确保代码的更高质量。
- en: Considerations for Node.js
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的注意事项
- en: JavaScript has exceptions built into the language as an error-handling construct.
    When an exception is thrown, there needs to be some code to detect that error
    and handle it appropriately. However, if an exception remains uncaught, it will
    trigger a show-stopping error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言内置了异常作为错误处理的构造。当抛出异常时，需要一些代码来检测错误并适当处理。然而，如果异常未被捕获，它将触发一个致命的错误。
- en: In the browser, an uncaught exception immediately halts any execution that takes
    place. This will not cause your web page to crash, but it has the potential to
    leave your application in an unstable place.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，未捕获的异常会立即停止任何执行。这不会导致网页崩溃，但有可能使应用程序处于不稳定的状态。
- en: In Node.js, an uncaught exception will terminate the application thread. This
    is very different from other server-side programming languages like PHP, where
    a similar error only causes a single request to fail. Now, you must contend with
    your entire server and application being abruptly halted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，未捕获的异常将终止应用程序线程。这与其他服务器端编程语言（如PHP）非常不同，那里类似的错误只会导致单个请求失败。现在，你必须应对整个服务器和应用程序被突然停止的情况。
- en: Callback errors
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调错误
- en: The first step you can take is to make sure you throw errors in an expected
    and predicable way, so they can be effectively caught later. In Node.js, the convention
    for asynchronous actions that use a callback is to send an `Error` object, to
    that callback function, as the first argument. This is the standard convention
    used in Node.js core, and it has been widely adopted by the community.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取的第一步是确保以一种预期和可预测的方式抛出错误，以便以后能够有效地捕获。在Node.js中，使用回调进行异步操作的惯例是将一个`Error`对象作为第一个参数发送给回调函数。这是Node.js核心使用的标准惯例，并且已被社区广泛采用。
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code simply reads a file into a string. This operation has a callback
    that takes two arguments. The first is an `Error` object, but only if an error
    occurred during this I/O operation, such as the file not existing. By simply passing
    the error object as a function argument, this does not technically "throw" an
    exception. Your application should still handle these errors, by correcting them,
    if possible. If an unexpected error occurs, or if it cannot be corrected directly,
    you should throw that error yourself, rather than swallowing errors quietly, and
    creating hard-to-debug scenarios for yourself later.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是将一个文件读取为字符串。这个操作有一个回调，接受两个参数。第一个是一个`Error`对象，但只有在这个I/O操作期间发生错误时才会有，比如文件不存在。通过简单地将错误对象作为函数参数传递，这在技术上并不会"抛出"异常。你的应用程序仍然应该处理这些错误，如果可能的话进行纠正。如果发生意外错误，或者无法直接纠正，你应该自己抛出错误，而不是悄悄地吞噬错误，为自己以后创建难以调试的场景。
- en: EventEmitter error handling
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EventEmitter错误处理
- en: The Node.js core has a widely used utility object called the `EventEmitter`.
    This is an object that can be instantiated or inherited from that allows for binding
    to and emitting events for asynchronous actions. When an error is encountered
    by an `EventEmitter` object, the convention is to emit an error event with an
    `Error` object as a parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js核心有一个广泛使用的实用对象叫做`EventEmitter`。这是一个可以实例化或继承的对象，允许绑定和发出异步操作的事件。当`EventEmitter`对象遇到错误时，惯例是使用`Error`对象作为参数发出一个错误事件。
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code simply makes an HTTP request to [http://nodejs.org/](http://nodejs.org/).
    The resulting object is an `EventEmitter` object that represents the HTTP response.
    It emits multiple data events, as it receives data from the server, and if an
    error occurs during transmission (similar to a network disconnection) then an
    `error` event is emitted.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是向[http://nodejs.org/](http://nodejs.org/)发出一个HTTP请求。结果对象是一个代表HTTP响应的`EventEmitter`对象。它会发出多个数据事件，当从服务器接收数据时，如果传输过程中发生错误（类似于网络断开连接），则会发出一个`error`事件。
- en: It should be noted that the `EventEmitter` object has a very specific behavior
    regarding the `error` event. If you have an `EventEmitter` object that emits an
    `error` event, but has no attached listeners to respond to the event, then the
    corresponding `Error` object is thrown, and will likely become an uncaught exception.
    This means that any unhandled error events will crash your application, so always
    bind an `error` event handler, while using the `EventEmitter` object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，`EventEmitter`对象在处理`error`事件时有非常特定的行为。如果你有一个`EventEmitter`对象发出了一个`error`事件，但没有附加的监听器来响应这个事件，那么相应的`Error`对象会被抛出，并且很可能成为一个未捕获的异常。这意味着任何未处理的错误事件都会导致应用程序崩溃，所以在使用`EventEmitter`对象时，始终要绑定一个`error`事件处理程序。
- en: Uncaught exceptions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未捕获的异常
- en: 'When an uncaught exception does occur, Node.js will print the current stack
    trace, and then terminate the thread. There is a global object available to all
    Node.js applications called `process`. It is an `EventEmitter` object with a special
    event called `"uncaughtException"` that gets emitted, when an uncaught exception
    is brought up to the main event loop. By binding to this event you can set up
    custom behavior, such as sending an email, or writing to a special log file. This
    can be seen in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生未捕获的异常时，Node.js将打印当前堆栈跟踪，然后终止线程。所有Node.js应用程序都可以使用一个名为`process`的全局对象。它是一个带有特殊事件`"uncaughtException"`的`EventEmitter`对象，当未捕获的异常被带到主事件循环时会被触发。通过绑定到此事件，您可以设置自定义行为，例如发送电子邮件或写入特殊的日志文件。以下代码中可以看到这一点：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, I've simply done what Node.js does by default. As I mentioned
    before, you can implement your own error-logging procedures. You need to make
    sure to terminate the process yourself via the `process.exit()` function, if you
    are using a custom handler.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我只是简单地做了Node.js默认的事情。如我之前提到的，您可以实现自己的错误记录程序。如果您使用自定义处理程序，需要确保通过`process.exit()`函数自行终止进程。
- en: While it is possible to continue the application after an uncaught exception,
    it is not recommended! By definition, an uncaught exception has interrupted the
    normal flow of your application, leaving it in an unstable and unreliable state.
    If you simply swallow the error, and continue processing, then you are wandering
    into a dangerous territory. The Node.js documentation equates this with unplugging
    a computer to shut it down. You can get away with it a few times, but if it keeps
    happening repeatedly, the system will become increasingly unstable and unpredictable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在发生未捕获的异常后继续应用是可能的，但不建议这样做！根据定义，未捕获的异常中断了应用程序的正常流程，使其处于不稳定和不可靠的状态。如果您简单地忽略错误并继续处理，那么您就会陷入危险的境地。Node.js文档将此视为拔掉计算机的电源来关闭它。您可能可以做几次，但如果这种情况不断重复，系统将变得越来越不稳定和不可预测。
- en: Domains
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域
- en: While the `uncaughtException` event allows us to handle errors, it is still
    rather crude. You lose much of the original context from where the error originates,
    which makes it a bit more difficult to debug later. As of Node.js v0.8, there
    is a new error-handling mechanism available, called **Domains**. They are a way
    to group different I/O operations together so that in the event of an error, the
    domain object is notified instead of the process object via the `uncaughtException`
    event. This allows you to preserve the context of the error itself, and helps
    you to prepare for and correct the error in future.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`uncaughtException`事件允许我们处理错误，但它仍然相当粗糙。您会失去错误来源的大部分原始上下文，这使得以后调试变得更加困难。从Node.js
    v0.8开始，有一种新的错误处理机制可用，称为**域**。它们是一种将不同的I/O操作组合在一起的方式，以便在发生错误时，通过`uncaughtException`事件通知域对象而不是进程对象。这允许您保留错误本身的上下文，并帮助您为将来准备和纠正错误。
- en: In addition to preserving context, domains also allows you to gracefully shut
    down related services in the event of an error. If you have an HTTP server running,
    and an error occurs for one of your users, simply shutting down the server will
    immediately interrupt any other users that are currently using the server at the
    same time. This isn't fair to those users, so we need to be able to shut down
    our server more gracefully. We should stop the server from accepting new connections,
    and let the current requests be fulfilled before shutting down the server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保留上下文，域还允许您在发生错误时优雅地关闭相关服务。如果您运行着一个HTTP服务器，并且一个用户发生了错误，简单地关闭服务器将立即中断当前正在同时使用服务器的其他用户。这对这些用户是不公平的，因此我们需要能够更优雅地关闭我们的服务器。我们应该停止服务器接受新连接，并在关闭服务器之前让当前请求得到满足。
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code sets up a simple HTTP server that will respond four times
    before an error occurs. For each request, a domain is created, which can be passed
    around to all the various pieces of our request handler, and any asynchronous
    operations can be run in the domain's context. On request number `4`, we will
    throw an `Error` object. The domain has an error event handler that outputs the
    error information, a stack trace, and then proceeds to shut down the server. First,
    it sends the current request an error message, then it stops accepting new requests,
    and finishes serving all the current requests it has in its queue. Once this is
    completed, the process itself is terminated.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码设置了一个简单的HTTP服务器，在发生错误之前会响应四次。对于每个请求，都会创建一个域，可以将其传递给请求处理程序的各个部分，并且可以在域的上下文中运行任何异步操作。在第4个请求时，我们将抛出一个`Error`对象。域有一个错误事件处理程序，它输出错误信息、堆栈跟踪，然后继续关闭服务器。首先，它发送当前请求一个错误消息，然后停止接受新请求，并完成服务其队列中的所有当前请求。完成后，进程本身被终止。
- en: We could technically implement what I demonstrated here with the `uncaughtException`
    event. However, if you are running multiple servers (for example, an HTTP server
    and a WebSocket server) side by side in your application (or even running multiple
    processes with the cluster module), that event handler won't necessarily give
    you the context you need to handle those errors specific to the server that encountered
    the error. In fact, you won't even be able to distinguish between different requests
    with the `uncaughtException` event, as that context is lost as well. With domains,
    you can handle errors more gracefully, without losing context.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们可以使用`uncaughtException`事件来实现我在这里演示的内容。但是，如果您在应用程序中并行运行多个服务器（例如，一个HTTP服务器和一个WebSocket服务器），或者使用集群模块运行多个进程，那么该事件处理程序不一定会给您处理特定于遇到错误的服务器的上下文。事实上，您甚至无法区分`uncaughtException`事件中的不同请求，因为该上下文也会丢失。使用域，您可以更优雅地处理错误，而不会丢失上下文。
- en: Node.js has a module called **cluster**, which allows you to take advantage
    of multiple core environments. It does this by spawning multiple worker processes
    that share the same server port, and the `cluster` module handles message passing
    between those processes for you. If an error happens in one of those workers,
    a domain would allow you to easily shut down only that single server and worker
    process, while letting the others continue operating normally. Once that process
    finishes cleaning up and exiting, you can spawn a brand new one to take its place,
    and your application will experience zero downtime as a result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有一个名为**cluster**的模块，它允许你利用多核环境。它通过生成多个工作进程来实现这一点，这些工作进程共享相同的服务器端口，而`cluster`模块会为你处理这些进程之间的消息传递。如果其中一个工作进程出现错误，域将允许你轻松关闭只有单个服务器和工作进程，同时让其他工作进程继续正常运行。一旦该进程完成清理并退出，你可以生成一个全新的进程来取代它，你的应用程序将因此经历零停机时间。
- en: Process monitoring
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程监视
- en: With that said, stuff is going to go wrong. You shouldn't ignore uncaught exceptions
    as your application will be unstable, and will leak references and memory. The
    only safe way to deal with uncaught exceptions is to stop that process. The implication
    here is that your server will be unavailable to other users. This means that if
    a malicious user can figure out a way to trigger an uncaught exception on your
    server, they are effectively executing a denial of service attack against your
    other users.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，事情可能会出错。你不应该忽略未捕获的异常，因为你的应用程序会变得不稳定，并且会泄漏引用和内存。处理未捕获异常的唯一安全方式是停止该进程。这意味着你的服务器将无法提供给其他用户使用。这意味着，如果一个恶意用户能够找到一种方法在你的服务器上触发未捕获的异常，他们实际上正在对其他用户发起拒绝服务攻击。
- en: The solution is to have a process monitor that can watch your application process
    and automatically restart it whenever it is stopped. There are many options out
    there, including ones that are platform-specific. Some available process monitors
    include forever, mon, and upstart. The point is you should implement some sort
    of process monitoring, so you do not have to manually restart your applications,
    if something goes wrong.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是拥有一个可以监视你的应用程序进程并在停止时自动重新启动它的进程监视器。有很多选择，包括一些特定于平台的选项。一些可用的进程监视器包括forever、mon和upstart。关键是你应该实现某种进程监视，这样当出现问题时就不必手动重新启动你的应用程序。
- en: Once you have a process monitor in place, be sure to configure it to log errors
    somewhere so that you can keep a track, in order to correct harmful and fatal
    errors in your application. It is also wise to monitor how often your application
    crashes, and correct errors as fast as possible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个进程监视器，一定要配置它将错误记录在某个地方，这样你就可以跟踪，以便纠正应用程序中的有害和致命错误。监视你的应用程序崩溃频率，并尽快纠正错误也是明智的。
- en: npm modules (third-party code)
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm模块（第三方代码）
- en: As mentioned before, one of the biggest features of Node.js is its vibrant community
    and fast-growing registry of modules. Because the Node.js core API is intentionally
    small and focused, you are likely to incorporate other modules, so you don't have
    to write a lot from scratch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，Node.js最大的特点之一是其充满活力的社区和快速增长的模块注册表。因为Node.js核心API故意保持小而集中，你可能会整合其他模块，这样你就不必从头开始编写很多东西。
- en: Just as you will take efforts to audit your code for security practices, you
    should also take an active role in monitoring the npm modules; you end up including
    in your project. Many projects out there on npm are completely open source, and
    often available on GitHub or other similar online resources. This makes it easy
    to look through the source manually for things that stand out. As a last resort,
    you can inspect the local packages that npm downloads while installing dependencies,
    although you are not guaranteed to get everything that is part of the package's
    development environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你会努力审查你的代码以确保安全实践一样，你也应该积极参与监控你在项目中包含的npm模块。npm上有许多完全开源的项目，通常可以在GitHub或其他类似的在线资源上找到。这使得手动查看源代码以寻找突出问题变得很容易。作为最后的手段，你可以检查npm在安装依赖时下载的本地包，尽管不能保证获得包的开发环境中的所有内容。
- en: While picking out modules to adopt, look for the ones that include a test suite
    of some sort. If they have running tests, it will be easier for you to know for
    certain that functionality is working as designed. Second, look for projects that
    incorporate some static analysis, which will usually come in the form of JSHint
    or JSLint. Look at their style guide or static analysis configuration to understand
    what rules they abide by. Many projects of this type have some sort of build process,
    which likely will include a way to run automated tests, static analysis, and other
    related tools.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要采用的模块时，寻找包含某种测试套件的模块。如果它们有运行测试，那么你就更容易确定功能是否按设计工作。其次，寻找那些包含一些静态分析的项目，这通常以JSHint或JSLint的形式出现。查看它们的样式指南或静态分析配置，了解它们遵守的规则。许多这类项目都有某种构建过程，其中可能包括运行自动化测试、静态分析和其他相关工具的方法。
- en: One of the focuses that Node.js developers place into their modules is to make
    them small, highly-focused, and composable (that is, they are easily interoperable
    with other modules). As such, they usually are very small in terms of lines of
    code and complexity, making it much easier to write securely and in a testable
    fashion. This works greatly to Node.js platform's advantage when it comes to application
    security.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js开发人员在他们的模块中注重的一个重点是使它们小巧、高度集中和可组合（即它们很容易与其他模块互操作）。因此，它们通常在代码行数和复杂性方面非常小，这使得编写安全和可测试的代码变得更加容易。这在涉及应用程序安全时对Node.js平台非常有利。
- en: There is an up-and-coming undertaking called the **Node Security Project**,
    which can be found at [http://nodesecurity.io/](http://nodesecurity.io/). Their
    goal is to audit every single npm module for security vulnerabilities. They are
    in need of Node.js developers and security researchers to assist them, as they
    have a monumental task ahead of them. If you are interested in securing your own
    applications already, you can likely contribute the time you spend auditing modules
    that you end up using to this team for their own registry. This is a great way
    to accomplish your own goals, as well as contributing to the Node.js community
    as a whole.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个正在崛起的项目叫做**Node Security Project**，可以在[http://nodesecurity.io/](http://nodesecurity.io/)找到。他们的目标是审计每一个npm模块，以查找安全漏洞。他们需要Node.js开发人员和安全研究人员来帮助他们，因为他们面临着一项艰巨的任务。如果你已经对保护自己的应用程序感兴趣，你可以将你用来审计你最终使用的模块的时间贡献给这个团队的注册表。这是实现你自己目标的一个很好的方式，同时也为整个Node.js社区做出贡献。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined the security features that applied generally to
    the language of JavaScript itself, including how to use static code analysis to
    check for many of the aforementioned pitfalls. Also, we looked at some of the
    inner workings of a Node.js application, and how it differs from typical browser
    development, when it comes to security. Lastly, we briefly discussed the npm module
    ecosystem, and the Node Security Project, which aims to audit each and every module
    for security purposes. In the next chapter, we will look at security considerations
    for applications in general.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了适用于JavaScript语言本身的安全功能，包括如何使用静态代码分析来检查前面提到的许多问题。此外，我们还研究了Node.js应用程序的一些内部工作原理，以及在安全性方面与典型的浏览器开发有何不同。最后，我们简要讨论了npm模块生态系统和Node
    Security Project，该项目旨在为安全目的审计每一个模块。在下一章中，我们将讨论应用程序的安全考虑。
