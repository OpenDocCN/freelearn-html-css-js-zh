- en: Chapter 2. The JavaScript Execution Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 JavaScript执行模型
- en: The first chapter of this book explored the state of JavaScript concurrency.
    Generally speaking, dealing with concurrency in JavaScript applications is anything
    but a trivial matter. There's a lot to think about when writing concurrent JavaScript
    code, and the kind of solutions that we come up with are often unorthodox. There's
    a lot of callbacks, and wading through all of them is enough to drive a person
    insane. We also caught a glimpse of how our pattern of writing concurrent JavaScript
    code has started to change with existing concurrency components. Web workers have
    started to mature, and JavaScript language concurrency constructs have only just
    been introduced.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一章探讨了JavaScript并发的状态。一般来说，处理JavaScript应用程序中的并发并不是一件简单的事情。在编写并发JavaScript代码时有很多事情要考虑，我们提出的解决方案通常是非正统的。有很多回调，浏览它们足以让人发疯。我们还瞥见了我们的并发JavaScript代码编写模式如何随着现有的并发组件而开始改变。Web
    Workers已经开始成熟，而JavaScript语言的并发结构刚刚被引入。
- en: The language and the runtime environment only get us partway there. We need
    to think about concurrency at the design level, rather than after the fact. Concurrency
    should be the default. This is easy to say and very difficult to do. Throughout
    this book, we're going to explore all that the JavaScript concurrency features
    have to offer, and how we can best use them to our advantage as design tools.
    But, before we do this, we need to go into depth on what's really happening when
    our JavaScript runs. This knowledge is an essential input to designing concurrent
    applications, because we'll know exactly what to expect when choosing one concurrency
    mechanism over another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 语言和运行环境只能带我们走一半的路。我们需要在设计层面考虑并发，而不是事后。并发应该是默认的。这话说起来容易，做起来却非常困难。在这本书中，我们将探讨JavaScript并发特性所能提供的一切，以及我们如何最好地利用它们作为设计工具。但是，在我们这样做之前，我们需要深入了解JavaScript运行时真正发生的事情。这种知识是设计并发应用程序的必要输入，因为我们将确切知道在选择一种并发机制而不是另一种机制时可以期待什么。
- en: In this chapter, we'll start with the browser environment, by looking at all
    the subsystems that our code touches—such as the JavaScript interpreter, the task
    queue, and the DOM itself. Then we'll walk through some code that will shed some
    light on what's really happening behind the scenes to orchestrate our code. We'll
    close the chapter with a discussion on the challenges that we face with this model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从浏览器环境开始，通过查看我们的代码所触及的所有子系统——例如JavaScript解释器、任务队列以及DOM本身。然后我们将通过一些代码来揭示幕后真正发生的事情，以编排我们的代码。我们将以对这个模型所面临的挑战的讨论来结束本章。
- en: Everything is a task
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都是任务
- en: When we visit a web page, a whole environment is created for us within the browser.
    This environment has several subsystems that enable the webpage we're looking
    at to look and behave as it should according to **World Wide Web Consortium**
    (**W3C**) specs. Tasks are the fundamental abstraction inside a web browser. Anything
    that happens is either a task itself, or a smaller part of a larger task.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问一个网页时，浏览器为我们创建了一个整个环境。这个环境有几个子系统，使得我们查看的网页能够根据**万维网联盟**（**W3C**）规范看起来和表现如它应该的样子。任务是在网页浏览器内部的基本抽象。任何发生的事情要么是一个任务本身，要么是更大任务的一部分。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're reading any of the W3C specifications, the term "user agent" is used
    instead of "web browser". In 99.9% of cases, the major browser vendors are what
    we're reading about.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读任何W3C规范，术语“用户代理”将用于代替“网页浏览器”。在99.9%的情况下，我们阅读的是主要浏览器供应商。
- en: In this section, we'll look at the major components of these environments, and
    how task queues and event loops facilitate the communication between these components,
    to realize the overall appearance and behavior of the web page.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看这些环境的主要组件，以及任务队列和事件循环如何促进这些组件之间的通信，以实现网页的整体外观和行为。
- en: Meet the players
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识参与者
- en: 'Let''s introduce some terminology that will help us throughout the various
    sections in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一些术语，这些术语将帮助我们贯穿本章的各个部分：
- en: '**Execution environment**: This container gets created whenever a new web page
    is opened. It''s the all-encompassing environment, which has everything that our
    JavaScript code will interact with. It also serves as a sandbox—our JavaScript
    code can''t reach outside of this environment.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行环境**：每当打开一个新的网页时，就会创建这个容器。这是一个包罗万象的环境，其中包含我们的JavaScript代码将与之交互的一切。它还充当一个沙盒——我们的JavaScript代码无法超出这个环境。'
- en: '**JavaScript interpreter**: This is the component that''s responsible for parsing
    and executing our JavaScript source code. It''s the browser''s job to augment
    the interpreter with globals, such as `window`, and `XMLHttpRequest`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript解释器**：这是负责解析和执行我们的JavaScript源代码的组件。浏览器的工作是向解释器添加全局变量，例如`window`和`XMLHttpRequest`。'
- en: '**Task queue**: Tasks are queued whenever something needs to happen. An execution
    environment has at least one of these queues, but typically, it has several of
    them.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务队列**：每当需要发生某些事情时，就会将任务排队。执行环境至少有一个这样的队列，但通常有几个。'
- en: '**Event loop**: An execution environment has a single event loop that''s responsible
    for servicing all task queues. There''s only one event loop, because there''s
    only one thread.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件循环**：执行环境有一个负责服务所有任务队列的单个事件循环。只有一个事件循环，因为只有一个线程。'
- en: Take a look at the following visualization of an execution environment created
    within a web browser. The task queues are the entry points for anything that happens
    in the browser. For example, one task can be used to execute a script by passing
    it to the JavaScript interpreter, while another task is used to render pending
    DOM changes. Now we'll dig into the parts that make up the environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下在网页浏览器中创建的以下执行环境可视化。任务队列是浏览器中发生任何事情的入口点。例如，一个任务可以通过传递给JavaScript解释器来执行一个脚本，而另一个任务用于渲染挂起的DOM更改。现在我们将深入了解构成环境的各个部分。
- en: '![Meet the players](img/B05133_02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![遇见参与者](img/B05133_02_01.jpg)'
- en: The Execution environment
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行环境
- en: Perhaps the most revealing aspect of the web browser execution environment is
    the relatively minor role played by our JavaScript code and the interpreter that
    executes it. Our code is simply a cog in a much larger machine. There's certainly
    a lot going on within these environments, because the platform that browsers implement
    serve an enormous purpose. It's not simply a matter of rendering elements on the
    screen, then enhancing these elements with style properties. The DOM itself is
    similar to a micro platform, just as networking facilities, file access, security,
    and so on. All these pieces are essential for a functioning web economy of sites,
    and more recently, applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器执行环境中最能揭示其本质的方面可能是我们的JavaScript代码及其解释器所扮演的相对较小的角色。我们的代码只是在一个更大机器中的一个齿轮。在这些环境中，确实有很多事情在进行，因为浏览器实现的平台具有巨大的作用。这不仅仅是在屏幕上渲染元素，然后通过样式属性增强这些元素。DOM本身就像一个微型平台，就像网络设施、文件访问、安全等。所有这些部分对于网站功能的网络经济和最近的应用程序都是必不可少的。
- en: In a concurrency context, we're mostly interested in the mechanics that tie
    all these platform pieces together. Our application is written mainly in JavaScript,
    and the interpreter knows how to parse and run it. But, how does this ultimately
    translate into visual changes on the page? How does the networking component of
    the browser know to make an HTTP request, and how does it invoke the JavaScript
    interpreter once the response has arrived?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发上下文中，我们主要对将所有这些平台部件联系在一起的机制感兴趣。我们的应用程序主要用JavaScript编写，解释器知道如何解析和运行它。但是，这最终如何转化为页面上的视觉变化？浏览器的网络组件如何知道发起一个HTTP请求，以及如何在响应到达后调用JavaScript解释器？
- en: It's the coordination of these moving parts that restricts our concurrency options
    in JavaScript. These restrictions are necessary, because without them, programming
    web applications would become too complex.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这些运动部件的协调限制了JavaScript中的并发选项。这些限制是必要的，因为没有它们，编写网络应用程序将变得过于复杂。
- en: Event loops
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: Once an execution environment is in place, the event loop is one of the first
    components to start. Its job is to service one or more task queues in the environment.
    Browser vendors are free to implement queues as they see fit, but there has to
    be at least one queue. Browsers can place every task in one queue if they please,
    and treat every task with equal priority. The problem with doing so would mean
    that if the queue is getting backlogged, tasks that must receive priority, such
    as mouse or keyboard events, are stuck in line.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行环境建立，事件循环就是最先启动的组件之一。它的任务是处理环境中的一个或多个任务队列。浏览器厂商可以自由地根据需要实现队列，但至少必须有一个队列。如果浏览器愿意，可以将每个任务都放在一个队列中，并给予每个任务相同的优先级。这样做的问题在于，如果队列出现拥堵，必须优先处理的任务，如鼠标或键盘事件，就会陷入等待。
- en: 'In practice, it makes sense to have a handful of queues, if for no other reason
    than to separate tasks by priority. This is all the more important because there''s
    only one thread of control—meaning only one CPU—that will process these queues.
    Here''s what an event loop that services several queues by varying levels of priorities
    looks like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，拥有几个队列是有意义的，至少可以按优先级分离任务。这一点尤为重要，因为只有一个控制线程——意味着只有一个CPU——会处理这些队列。以下是一个通过不同优先级级别服务多个队列的事件循环的示例：
- en: '![Event loops](img/B05133_02_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![事件循环](img/B05133_02_02.jpg)'
- en: Even though the event loop is started along with the execution environment,
    this doesn't mean that there's always tasks for it to consume. If there were always
    tasks to process, there would never be any CPU time for the actual application.
    The event loop will sit and wait for more tasks, and the queue with the highest
    priority gets serviced first. For example, with the queues used in the preceding
    image, the *interactive* queue will always be serviced first. Even if the event
    loop is making its way through the *render* queue tasks, if an *interactive* task
    is queued, the event loop will handle this task before resuming with render tasks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管事件循环与执行环境同时启动，但这并不意味着它总是有任务可以处理。如果总是有任务需要处理，那么实际应用将没有CPU时间。事件循环会等待更多任务，并且优先级最高的队列会首先得到服务。例如，使用前面图像中使用的队列，*交互*队列将始终首先得到服务。即使事件循环正在处理*渲染*队列的任务，如果有一个*交互*任务被排队，事件循环也会先处理这个任务，然后再继续处理渲染任务。
- en: Task queues
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务队列
- en: The concept of queued tasks is essential to understand how web browsers work.
    The term browser is actually misleading. We used them to browse static web pages
    in an earlier, sparser web. Now, large and complex applications run in browsers—it's
    really more of a web platform. The task queues and event loops that service them
    are probably the best design to handle so many moving parts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理解队列任务的概念对于理解浏览器的工作方式至关重要。实际上，“浏览器”这个术语是有误导性的。我们曾用它们来浏览早期、较为稀疏的静态网页。现在，大型和复杂的应用程序在浏览器中运行——它实际上更像是一个网络平台。服务这些任务的任务队列和事件循环可能是处理这么多动态部分的最佳设计。
- en: 'We saw earlier in this chapter that the JavaScript interpreter, along with
    the code that it parses and runs, is really just a black box when viewed from
    the perspective of an execution environment. In fact, invoking the interpreter
    is itself a task, and is reflective of the run-to-completion nature of JavaScript.
    Many tasks involve the invocation of the JavaScript interpreter, as visualized
    here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面看到，从执行环境的视角来看，JavaScript解释器以及它解析和运行的代码实际上只是一个黑盒。事实上，调用解释器本身就是一个任务，这也反映了JavaScript的运行至完成特性。许多任务都涉及到调用JavaScript解释器，如图所示：
- en: '![Task queues](img/B05133_02_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![任务队列](img/B05133_02_03.jpg)'
- en: Any one of these events—the user clicking an element, a script loading in the
    page, or data from a prior API call arriving in the browser—creates a task that
    invokes the JavaScript interpreter. It tells the interpreter to run a specific
    piece of code, and it'll continue to run it until it completes. This is the run-to-completion
    nature of JavaScript. Next, we'll dig into the execution contexts created by these
    tasks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些事件——用户点击一个元素、页面中加载脚本，或者从之前的API调用中到达浏览器中的数据——都会创建一个调用JavaScript解释器的任务。它告诉解释器运行特定的代码片段，并且它会继续运行直到完成。这就是JavaScript的运行至完成特性。接下来，我们将深入探讨由这些任务创建的执行上下文。
- en: Execution contexts
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行上下文
- en: Now it's time to look at the JavaScript interpreter itself—the component that
    takes over from other browser components when events take place and code needs
    to run. There's always an active JavaScript context, and within the interpreter,
    we'll find a stack of contexts. This is similar to many programming languages
    where stacks control the active context.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看JavaScript解释器本身了——当事件发生且需要运行代码时，它从其他浏览器组件接管。始终有一个活动的JavaScript上下文，在解释器内部，我们会找到一个上下文堆。这类似于许多编程语言，其中堆控制活动上下文。
- en: Think of the active context as a snapshot of what's happening right now in our
    JavaScript code. A stack structure is used because the active context can change
    to something else, such as when a function is called. When this happens, a new
    snapshot is pushed onto the stack, becoming the active context. When it's done
    running, it's popped from the stack, leaving the next context as the active context.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将活动上下文视为我们JavaScript代码当前发生情况的快照。使用堆结构是因为活动上下文可以改变为其他内容，例如当函数被调用时。当这种情况发生时，一个新的快照会被推入堆中，成为活动上下文。当它运行完成后，它会被从堆中弹出，留下下一个上下文作为活动上下文。
- en: In this section, we'll take a look at how the JavaScript interpreter handles
    context switching, and the internal job queue that manages the context stack.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨JavaScript解释器如何处理上下文切换，以及管理上下文堆的内部工作队列。
- en: Maintaining execution state
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护执行状态
- en: 'The stack of contexts within the JavaScript interpreter isn''t a static structure—it''s
    constantly changing. There''s two important things that happen throughout the
    lifetime of this stack. First, at the top of the stack, we have the active context.
    This is the code that currently executes as the interpreter moves through its
    instructions. Here''s an idea of what a JavaScript execution context stack looks
    like with the active context always at the top:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript解释器内的上下文堆不是一个静态结构——它是不断变化的。在整个堆的生命周期中，有两件重要的事情发生。首先，在堆的顶部，我们有活动上下文。这是解释器在执行其指令时当前执行的代码。以下是一个JavaScript执行上下文堆的示例，其中活动上下文始终位于顶部：
- en: '![Maintaining execution state](img/B05133_02_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![维护执行状态](img/B05133_02_04.jpg)'
- en: The other important responsibility of the call stack is to bookmark the state
    of an active context when it's deactivated. For example, let's say that after
    a few statements, `func1()` calls `func2()`. At this point, the context is bookmarked
    to the spot directly after the call to `func2()`. Then, it's replaced with the
    new active context—`func2()`. When it completes, the process is repeated and `func1()`again
    becomes the active context.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 调用堆的其他重要职责是在活动上下文被停用时标记其状态。例如，假设在几个语句之后，`func1()`调用`func2()`。在这个点上，上下文被标记为`func2()`调用之后的直接位置。然后，它被新的活动上下文——`func2()`所取代。当它完成时，这个过程会重复，`func1()`再次成为活动上下文。
- en: This kind of context switching happens all over our code. For example, there's
    a global context, which is the entry point into our code, there's the functions
    themselves which have their own context. There are also more recent additions
    to the language, which have their own contexts, such as modules and generators.
    Next, we'll look at the job queues responsible for creating new execution contexts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种上下文切换在我们的代码中到处发生。例如，有一个全局上下文，它是我们代码的入口点，有函数本身，它们有自己的上下文。还有语言中较新的添加，它们也有自己的上下文，例如模块和生成器。接下来，我们将查看负责创建新执行上下文的工作队列。
- en: Job queues
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务队列
- en: Jobs queues are similar to the task queues that we looked at earlier. The difference
    is that job queues are specific to the JavaScript interpreter. That is, they're
    encapsulated within the interpreter—the browser doesn't interact directly with
    these queues. However, when the interpreter is invoked by the browser, in response
    to a loaded script or event callback task for example, new jobs are created by
    the interpreter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任务队列类似于我们之前查看的任务队列。区别在于任务队列是针对JavaScript解释器的。也就是说，它们被封装在解释器中——浏览器不会直接与这些队列交互。然而，当解释器被浏览器调用，例如响应加载的脚本或事件回调任务时，解释器会创建新的任务。
- en: '![Job queues](img/B05133_02_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![任务队列](img/B05133_02_05.jpg)'
- en: The job queues within the JavaScript interpreter are actually much more straightforward
    than the task queues that are used to coordinate all the web browser components.
    There are only two essential queues. One is for creating new execution context
    stacks (call stacks). The other is specific to promise resolution callback functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 解释器中的作业队列实际上比用于协调所有网络浏览器组件的任务队列要简单得多。只有两个基本队列。一个是用于创建新的执行上下文堆栈（调用堆栈）。另一个是针对承诺解析回调函数的特定队列。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll go into more depth on how the promise resolution callback job works in
    the next chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更深入地探讨如何让承诺解析回调作业工作。
- en: Given the restricted responsibilities of these internal JavaScript job queues,
    one might draw the conclusion that they're unnecessary—an act of over engineering.
    That's not true, because while today there's limited responsibilities found in
    these jobs, the job queue design allows for much easier expansion and refinement
    of the language. In particular, the job queue mechanism is favorable when considering
    new concurrency constructs in future versions of the language.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些内部 JavaScript 作业队列的责任限制，人们可能会得出结论，它们是不必要的——过度工程化的行为。但这并不正确，因为虽然今天在这些工作中找到了有限的责任，但作业队列的设计使得语言的扩展和改进变得更加容易。特别是，在考虑语言未来版本的新的并发构造时，作业队列机制是有利的。
- en: Creating tasks using timers
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计时器创建任务
- en: So far in this chapter, we've had a look at all the inner workers of the web
    browser environment, and where the JavaScript interpreter fits in this environment.
    What does all this have to do with applying concurrency principles to our code?
    With the knowledge of what's happening under the hood, we have a greater insight
    into what's happening when a given chunk of our code is run. Particularly, we
    know what's happening relative to other code chunks; time ordering is a crucial
    concurrency property.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经了解了网络浏览器环境中的所有内部工作者，以及 JavaScript 解释器在这个环境中的位置。所有这些与将并发原则应用于我们的代码有什么关系呢？通过了解底层发生的事情，我们对代码运行时发生的事情有了更深入的了解。特别是，我们知道相对于其他代码块发生的事情；时间顺序是并发的一个重要属性。
- en: This being said, let's actually write some code. In this section, we'll use
    timers to explicitly add tasks to the task queue. We'll also learn when and where
    the JavaScript interpreter jumps in and starts executing our code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们实际编写一些代码。在本节中，我们将使用计时器显式地将任务添加到任务队列中。我们还将了解 JavaScript 解释器何时何地介入并开始执行我们的代码。
- en: Using setTimeout()
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `setTimeout()`
- en: 'The `setTimeout()` function is staple in any JavaScript code. It''s used to
    execute code at some point in the future. New JavaScript programmers often trip
    over the `setTimeout()` function because it''s a timer. At a set point in the
    future, say 3 seconds from now, a callback function will be invoked. When we call
    `setTimeout()`, we will get the `atimer` ID in return, which can be cleared later
    on using `clearTimeout()`. Here''s what the basic usage of `setTimeout()` looks
    like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()` 函数是任何 JavaScript 代码中的基本组成部分。它用于在未来的某个时间点执行代码。新 JavaScript 程序员经常遇到
    `setTimeout()` 函数，因为它是一个计时器。在未来的某个设定点，比如说 3 秒后，将调用一个回调函数。当我们调用 `setTimeout()`
    时，我们会得到一个 `atimer` ID，稍后可以使用 `clearTimeout()` 清除它。以下是 `setTimeout()` 的基本用法：'
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here's the part that's misunderstood by JavaScript newcomers; it's a best effort
    timer. The only guarantee we have when using `setTimeout()` is that our callback
    function will never be called sooner than the allotted time that we pass it. So
    if we said call this function in 300 milliseconds, it'll never call it in 275
    milliseconds. Once the 300 milliseconds have elapsed, a new task is queued. If
    there's nothing waiting in line before this task, the callback is run right on
    time. Even if there are a few things in the queue in front of it, the effects
    are hardly noticeable—it appears to run at the correct time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 JavaScript 新手容易误解的部分；它是一个尽力而为的计时器。当我们使用 `setTimeout()` 时，我们唯一可以保证的是我们的回调函数不会被调用得比我们传递给它的分配时间早。所以如果我们说在
    300 毫秒后调用这个函数，它永远不会在 275 毫秒时调用它。一旦 300 毫秒过去，就会排队一个新的任务。如果在这个任务之前没有其他任务等待，回调就会准时运行。即使在其前面有少量任务在队列中，影响几乎不明显——它看起来是在正确的时间运行的。
- en: 'But as we''ve seen, JavaScript is single threaded and run-to-completion. This
    means that once the JavaScript interpreter starts, it doesn''t stop until it''s
    finished; even if there''s a task waiting for a timer event callback. So, it''s
    entirely possible that even though we asked the timer to execute the callback
    in 300 milliseconds, it executes it in 500 milliseconds. Let''s take a look at
    an example to see how this is possible:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们所见，JavaScript是单线程的，并且是运行到完成的。这意味着一旦JavaScript解释器开始，它不会停止，直到完成；即使有任务等待计时器事件回调。所以，即使我们要求计时器在300毫秒后执行回调，它也可能在500毫秒后执行。让我们看看一个例子，看看这是如何可能的：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using setInterval()
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`setInterval()`
- en: The cousin of `setTimeout()` is the `setInterval()` function. As the name suggests,
    it accepts a callback function that's to be called at a regular interval. In fact,
    `setInterval()` takes the exact same arguments as `setTimeout()`. The only difference
    is that it will keep calling the function every x milliseconds until the timer
    is cleared using `clearInterval()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`的表亲是`setInterval()`函数。正如其名所示，它接受一个在固定时间间隔被调用的回调函数。实际上，`setInterval()`与`setTimeout()`接受完全相同的参数。唯一的区别是，它将每隔x毫秒调用该函数，直到使用`clearInterval()`清除计时器。'
- en: This function is handy when we want to keep calling the same function, over
    and over. For example, if we poll an API endpoint, `setInterval()` is a good candidate
    solution. However, keep in mind that the scheduling of the callbacks is fixed.
    That is, once we call `setInterval()` with, say, 1000 milliseconds, there's no
    changing that 1000 milliseconds without first clearing the timer. For cases where
    the interval needs to be dynamic, using `setTimeout()` works better. The callback
    schedules the next interval, which allows the interval to be dynamic. For example,
    backing off from polling an API too frequently by increasing the interval.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要反复调用同一个函数时，这个函数很有用。例如，如果我们轮询API端点，`setInterval()`是一个很好的候选解决方案。然而，请记住，回调的调度是固定的。也就是说，一旦我们用1000毫秒调用`setInterval()`，就不能在不先清除计时器的情况下更改这1000毫秒。对于需要动态间隔的情况，使用`setTimeout()`效果更好。回调安排下一个间隔，这使得间隔可以动态调整。例如，通过增加间隔来减少对API轮询的频率。
- en: 'In the `setTimeout()` example that we last looked at, we saw how running JavaScript
    code can mess with the event loop. That is, it prevents the event loop from consuming
    the task that invokes the JavaScript interpreter with our callback function. This
    allows us to defer code execution till some point in the future, but with no promises
    of accuracy. Let''s see what happens when we schedule tasks using `setInterval()`.
    There''s also some blocking JavaScript code that runs afterward:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前看到的`setTimeout()`示例中，我们看到了运行JavaScript代码如何会干扰事件循环。也就是说，它阻止事件循环消耗调用JavaScript解释器并带有我们的回调函数的任务。这允许我们将代码执行推迟到未来的某个点，但没有保证准确性。让我们看看使用`setInterval()`安排任务会发生什么。之后还有一些阻塞的JavaScript代码运行：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Responding to DOM events
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应DOM事件
- en: In the preceding section, we saw how to schedule JavaScript code to run at a
    later time. This is done explicitly by other JavaScript code. Most of the time,
    our code runs in response to user interactions. In this section, we'll look at
    the common interface that's used not only by DOM events, but also by things such
    as network and web worker events. We'll also look at a technique for dealing with
    large volumes of similar events—called debouncing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何安排JavaScript代码在将来某个时间运行。这是通过其他JavaScript代码显式完成的。大多数时候，我们的代码是响应用户交互而运行的。在本节中，我们将探讨不仅由DOM事件使用，而且由网络和web
    worker事件等使用的一个通用接口。我们还将探讨一种处理大量类似事件的技术——称为防抖。
- en: Event targets
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件目标
- en: The `EventTarget` interface is used by many browser components, including DOM
    elements. It's how we dispatch events to elements as well as listen to events
    and respond by executing a callback function. It's actually a very straightforward
    interface that's easy to follow. This is crucial since many different types of
    components use this same interface for event management. We'll see as we progress
    through the book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventTarget`接口被许多浏览器组件使用，包括DOM元素。它是我们向元素派发事件以及通过执行回调函数来监听事件和响应的方式。实际上，这是一个非常直接且易于理解的接口。这对于许多不同类型的组件使用此相同接口进行事件管理至关重要。随着我们继续阅读本书，我们将看到这一点。'
- en: 'The same task queue mechanisms that execute the callback functions for the
    timers that we used in the preceding section are relevant for `EventTarget` events.
    That is, if an event has taken place, a task to invoke the JavaScript interpreter
    with the appropriate callback is queued. The same limitations faced with using
    `setTimeout()` are imposed here. Here''s what a task queue looks like when there''s
    long-running JavaScript code that''s blocking user events:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们介绍了用于执行定时器的回调函数的任务队列机制，这与`EventTarget`事件相关。也就是说，如果发生了事件，就会排队一个任务来调用JavaScript解释器并执行适当的回调。这里面临的与使用`setTimeout()`相同的限制也适用于此。以下是当存在长时间运行的阻塞用户事件的JavaScript代码时任务队列的样子：
- en: '![Event targets](img/B05133_02_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![事件目标](img/B05133_02_06.jpg)'
- en: 'In addition to attaching listener functions to event targets that react to
    user interaction, we can trigger these events manually, as the following code
    illustrates:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将监听器函数附加到对用户交互做出反应的事件目标外，我们还可以手动触发这些事件，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's good practice to name functions that are used in callbacks where possible.
    This way, when our code breaks, it's much easier to trace down the problem. It's
    not impossible with anonymous functions, it's just more time consuming. On the
    other hand, arrow functions are more concise and have more binding flexibility.
    Choose your trade-offs wisely.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，给用于回调的函数命名是一个好习惯。这样，当我们的代码出错时，追踪问题会容易得多。使用匿名函数并非不可能，只是更耗时。另一方面，箭头函数更简洁，具有更多的绑定灵活性。明智地权衡你的选择。
- en: Managing event frequency
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理事件频率
- en: One challenge with user interaction events is that there can be lots of them,
    in a very short amount of time. For instance, when the user moves the mouse around
    on the screen, hundreds of events are dispatched. If we had event targets listening
    for these events, the task queue would quickly fill up, and the user experience
    would bog down.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 用户交互事件的一个挑战是，在非常短的时间内可能会有很多事件。例如，当用户在屏幕上移动鼠标时，会触发数百个事件。如果我们有监听这些事件的事件目标，任务队列会很快填满，用户体验会变得缓慢。
- en: Even when we do have event listeners in place for high frequency events, such
    as mouse moves, we don't necessarily need to respond to all of them. For example,
    if there's 150 mouse move events that take place in 1-2 seconds, chances are,
    we only care about the last move—the most recent position of the mouse pointer.
    That is, the JavaScript interpreter is being invoked with our event callback code
    149 times more than it needs to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在高频事件（如鼠标移动）上已经设置了事件监听器，我们也不一定需要响应所有这些事件。例如，如果有150次鼠标移动事件在1-2秒内发生，那么很可能是我们只关心最后一次移动——鼠标指针的最新位置。也就是说，JavaScript解释器调用我们的事件回调代码的次数比实际需要的多149次。
- en: 'To deal with these types of event frequency scenarios, we can utilize a technique
    called *debouncing*. A debounced function means that if it''s called in succession
    more than once within a given time frame, only the last call is actually used
    and the earlier calls are ignored. Let''s walk through an example of how we can
    implement this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些类型的事件频率场景，我们可以利用一种称为“防抖”的技术。防抖函数意味着如果在给定的时间框架内连续多次调用，则实际上只使用最后一次调用，而忽略之前的调用。让我们通过一个例子来看看我们如何实现这一点：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the debounce technique to avoid giving the CPU more work than necessary
    is an example of the conserve principle in action. By ignoring 149 events, we
    save (conserve) the CPU instructions that would otherwise be executed and provide
    no real value. We also save on any kind of memory allocation that would otherwise
    happen in these event handlers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用防抖技术来避免给CPU带来不必要的额外工作，是节约原则在起作用的一个例子。通过忽略149个事件，我们节省了（节约）了本应执行但没有任何实际价值的CPU指令。我们还节省了在这些事件处理程序中可能发生的任何类型的内存分配。
- en: The JavaScript concurrency principles were introduced at the end of [Chapter
    1](ch01.html "Chapter 1. Why JavaScript Concurrency?"), *Why JavaScript Concurrency?*,
    and they'll be pointed out throughout the code examples in the remainder of the
    book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript并发原则在[第1章](ch01.html "第1章。为什么JavaScript并发？")的末尾介绍，即“为什么JavaScript并发？”，并在本书剩余部分的代码示例中会指出。
- en: Responding to network events
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应网络事件
- en: Another critical piece of any front-end application is network interactions,
    fetching data, issuing commands, and so forth. Since network communications are
    an inherently asynchronous activity, we have to rely on events—the `EventTarget`
    interface to be precise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任何前端应用中的另一个关键部分是网络交互，获取数据，发布命令等等。由于网络通信本质上是一种异步活动，我们必须依赖于事件——具体来说是`EventTarget`接口。
- en: We'll start by looking at the generic mechanism that hooks up our callback functions
    with requests and getting responses from the back-end. Then, we'll look at how
    trying to synchronize several network requests creates a seemingly hopeless concurrency
    scenario.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将探讨将我们的回调函数与请求和从后端获取响应连接起来的通用机制。然后，我们将看看尝试同步多个网络请求是如何创建一个看似无望的并发场景的。
- en: Making requests
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发起请求
- en: 'To interact with the network, we create a new instance of `XMLHttpRequest`.
    We then tell it the type of request that we want to make—GET versus POST and the
    request endpoint. These request objects also implement the `EventTarget` interface
    so that we can listen for data arriving from the network. Here''s an example of
    what this code looks like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与网络交互，我们创建一个新的`XMLHttpRequest`实例。然后我们告诉它我们想要发起的请求类型——GET还是POST以及请求端点。这些请求对象也实现了`EventTarget`接口，这样我们就可以监听来自网络的数据。以下是一个示例代码：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see here that there are a number of possible states for network requests.
    The successful path is the server responding with the data we need and we're able
    to parse it as JSON. The error state is when something went wrong, maybe the server
    isn't reachable. The final state that we're concerned with here is when the request
    is cancelled or aborted. This means that we no longer care about the successful
    path because something in our application changed while the request was in flight.
    The user navigated to another section, for example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，网络请求有几种可能的状态。成功的路径是服务器响应我们所需的数据，并且我们能够将其解析为JSON。错误状态是当出现问题时，比如服务器不可达。我们在这里关心的最后一个状态是请求被取消或中止。这意味着我们不再关心成功的路径，因为在我们请求进行过程中，我们的应用程序中发生了某些变化。例如，用户导航到了另一个部分。
- en: While the previous code was easy enough to use and understand, it's not always
    the case. We're looking at a single request and a few callbacks. Very seldom do
    our application components consist of a single network request.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前的代码足够容易使用和理解，但并非总是如此。我们正在查看单个请求和一些回调。我们的应用程序组件通常不会只包含一个网络请求。
- en: Coordinating requests
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协调请求
- en: In the preceding section, we saw what the basic interaction with `XMLHttpRequest`
    instances looks like for making a network request. The challenge surfaces when
    there are several requests. Most of the time, we make multiple network requests
    so that we have the data necessary for rendering a UI component. The responses
    from the back-end will all arrive at different times, and are likely dependent
    on one another.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了使用`XMLHttpRequest`实例进行网络请求的基本交互。当有多个请求时，挑战就会出现。大多数时候，我们发起多个网络请求，以便我们有渲染UI组件所需的数据。后端的所有响应都将在不同时间到达，并且可能相互依赖。
- en: 'Somehow, we need to synchronize the responses of these asynchronous network
    requests. Let''s take a look at how we can go about doing this using the `EventTaget`
    callback functions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 某种程度上，我们需要同步这些异步网络请求的响应。让我们看看我们可以如何使用`EventTarget`回调函数来完成这项工作：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's a lot of extra bits to consider when there's more than one request.
    Since they all arrive at different times, we need to store the parsed responses
    in an array, and with the arrival of every response, we need to check if we have
    everything we expect. This simplified example doesn't even take into consideration
    failed or cancelled requests. As this code alludes, the callback function approach
    to synchronization is limiting. In the coming chapters, we'll learn how to overcome
    this limitation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当有多个请求时，需要考虑很多额外的因素。由于它们都在不同时间到达，我们需要在数组中存储解析后的响应，并且每当有响应到达时，我们需要检查我们是否已经得到了我们期望的一切。这个简化的例子甚至没有考虑到失败的或取消的请求。正如这段代码所暗示的，回调函数方法在同步方面是有限的。在接下来的章节中，我们将学习如何克服这一限制。
- en: Concurrency challenges with this model
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 此模型下的并发挑战
- en: We'll wrap this chapter up with a discussion on the challenges that this execution
    model poses with JavaScript concurrency. There are two fundamental obstacles.
    The first is the fact that no matter what, any JavaScript code that runs will
    block anything else from happening. The second obstacle is trying to synchronize
    asynchronous actions with callback functions, leading to callback hell.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章结束于对JavaScript并发执行模型所面临的挑战的讨论。有两个基本障碍。第一个是无论什么情况，任何运行的JavaScript代码都会阻塞其他任何事情的发生。第二个障碍是尝试使用回调函数同步异步操作，导致回调地狱。
- en: Limited opportunity for parallelism
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行性有限
- en: It used to be that the lack of parallelism in JavaScript wasn't really an issue.
    Nobody missed it because JavaScript was viewed as a progressive enhancement tool
    for HTML pages. This changed when the front-end started taking on more responsibilities.
    These days, the majority of the application actually resides in the front-end.
    This allows back-end components to focus on problems that can't be solved by JavaScript
    (from a browser perspective, NodeJS is another matter entirely that we'll look
    at later in the book).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，JavaScript缺乏并行性并不是真正的问题。没有人会想念它，因为JavaScript被视为HTML页面的渐进增强工具。当前端开始承担更多责任时，这种情况发生了变化。如今，应用程序的大部分实际上都驻留在前端。这使得后端组件能够专注于JavaScript（从浏览器角度来看，NodeJS完全是另一回事，我们将在本书稍后讨论）无法解决的问题。
- en: For example, mapping and reducing API data sources into some representation
    required by a feature can be implemented in the back-end. This means that the
    front-end JavaScript code just needs to query for this endpoint. The problem is
    that this API endpoint is created for some specific UI feature, not as an essential
    supporting pillar of our data model. If we can perform these tasks in the front-end,
    we keep the UI features and the data transformations they need, tightly coupled
    together. This frees up the back-end to stay focused on more pressing issues like
    replication and load balancing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将映射和减少API数据源到某个功能所需的表示形式可以在后端实现。这意味着前端JavaScript代码只需要查询这个端点。问题是这个API端点是针对某些特定的UI功能创建的，而不是作为我们数据模型的基本支持支柱。如果我们能在前端执行这些任务，我们就将UI功能和它们所需的数据转换紧密耦合在一起。这使后端能够专注于更紧迫的问题，如复制和负载均衡。
- en: We can perform these types of data transformations in the front-end, but they
    wreak havoc on the usability of the interface. This is largely due to all the
    moving parts competing for the same compute resource. This model, in other words,
    makes it impossible for us to implement the parallelize principle and take advantage
    of more than one resource. We will overcome this web browser limitation with the
    help of Web workers, covered in further chapters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前端执行这些类型的数据转换，但它们会破坏界面的可用性。这主要是因为所有移动部件都在争夺相同的计算资源。换句话说，这种模型使我们无法实现并行化原则并利用多个资源。我们将通过后续章节中介绍的Web
    workers克服这种网络浏览器的限制。
- en: Synchronization through callbacks
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过回调进行同步
- en: Synchronization through callbacks is hard to implement and doesn't scale well.
    It's callback hell, which is a term popular among JavaScript programmers. Needless
    to say, endless synchronization through callbacks in our code creates problems.
    We often have to create some kind of state tracking mechanism, such as global
    variables. And when problems do arise, a nest of callback functions is very time
    consuming to traverse mentally.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回调进行同步难以实现且扩展性不佳。这是回调地狱，一个在JavaScript程序员中流行的术语。不用说，代码中无尽的回调同步会引发问题。我们经常不得不创建某种状态跟踪机制，例如全局变量。当问题确实出现时，一大堆回调函数在心理上非常耗时去遍历。
- en: Generally speaking, the callback approach to synchronizing multiple asynchronous
    actions requires a lot of overhead. That is, the boilerplate code that exists
    for the sole purpose of dealing with asynchronous actions. The synchronize concurrency
    principle is about writing concurrent code that doesn't embed the main goal in
    a maze of synchronization handling logic. Promises help us write concurrent code
    consistently throughout our application by lessening the use of callback functions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，同步多个异步操作的回调方法需要大量的开销。也就是说，存在只是为了处理异步操作而存在的样板代码。同步并发原则是关于编写不将主要目标嵌入到同步处理逻辑迷宫中的并发代码。通过减少回调函数的使用，Promise帮助我们在整个应用程序中一致地编写并发代码。
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: The focus of this chapter has been the web browser platform and JavaScript's
    place within it. There are a lot of events taking place whenever we view and interact
    with web pages. These are processed as tasks, taken from queues. One such task
    is invoking the JavaScript interpreter with code to run.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点一直是网络浏览器平台以及JavaScript在其中所处的位置。在我们查看和与网页互动时，总会有很多事件发生。这些事件被处理为任务，从队列中取出。其中一项任务就是使用代码调用JavaScript解释器来运行。
- en: When the JavaScript interpreter runs, it contains an execution context stack.
    A function, a module, and global script code—these are all examples of JavaScript
    execution contexts. The interpreter also has it's own internal job queues; one
    is used to create new execution context stacks, and another is used for calling
    promise resolution callback functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript解释器运行时，它包含一个执行上下文栈。函数、模块和全局脚本代码——这些都是JavaScript执行上下文的例子。解释器还有它自己的内部作业队列；一个用于创建新的执行上下文栈，另一个用于调用承诺解析回调函数。
- en: We wrote some code that manually created tasks using the `setTImeout()` function
    and explicitly demonstrated how long-running JavaScript code can be problematic
    for these tasks. We then looked at the `EventTarget` interface, used to listen
    to DOM events, and to network requests, amongst other things we didn't look at
    in this chapter, like web workers and file readers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一些代码，使用`setTImeout()`函数手动创建任务，并明确展示了长时间运行的JavaScript代码对这些任务可能造成的问题。然后我们研究了`EventTarget`接口，该接口用于监听DOM事件，以及网络请求，以及其他我们没有在本章中探讨的内容，如web
    workers和文件读取器。
- en: We wrapped up with a look at some of the challenges that JavaScript programmers
    face when using this model. In particular, it's hard to follow our JavaScript
    concurrency principles. We can't parallelize, and trying to synchronize using
    nothing but callbacks is a nightmare.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总结了JavaScript程序员在使用此模型时面临的挑战。特别是，遵循我们的JavaScript并发原则很难。我们无法并行化，而仅使用回调函数来尝试同步则是一场噩梦。
- en: In the next chapter, we'll look at a new way of thinking about synchronization
    using promises. This will allow us to start designing and building concurrent
    JavaScript applications in earnest.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一种使用承诺（promises）来思考同步的新方法。这将使我们能够真正开始设计和构建并发JavaScript应用程序。
