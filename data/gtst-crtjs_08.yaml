- en: Chapter 8. Utilizing Vector Masks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：利用向量蒙版
- en: In this chapter, we will talk about utilizing vector masks in CreateJS and how
    to develop animation or drawings using vector masks. First off, we should know
    what a vector mask is and what it does. With vector masks, we can control which
    parts of the parent layer are hidden or revealed. We can even add a special effect
    to the vector mask to make that part of the parent layer different from the rest.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在 CreateJS 中使用向量蒙版以及如何使用向量蒙版开发动画或绘图。首先，我们应该了解什么是向量蒙版以及它做什么。使用向量蒙版，我们可以控制父层中哪些部分被隐藏或显示。我们甚至可以向向量蒙版添加特殊效果，使父层的那部分与其它部分不同。
- en: 'In this chapter we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Learning about vector masks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习向量蒙版
- en: Adding a vector mask to an existing `DisplayObject` object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将向量蒙版添加到现有的 `DisplayObject` 对象
- en: Applying vector masks to pictures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将向量蒙版应用于图片
- en: Animating the mask layer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画蒙版层
- en: Learning about vector masks
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习向量蒙版
- en: Vector masking is a useful feature in EaselJS that enables developers to create
    awesome animations or drawings easily. There is a `mask` property for every `DisplayObject`
    object, with which you can apply a mask layer, or in other words; create a layer
    over an existing shape or picture. After applying the mask layer and updating
    the `stage` event, you will see that a new layer masks the existing layer. In
    other words, you can control what part of the parent layer is hidden or revealed
    with vector masks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 向量蒙版是 EaselJS 中一个有用的功能，它允许开发者轻松地创建令人惊叹的动画或绘图。每个 `DisplayObject` 对象都有一个 `mask`
    属性，您可以使用它来应用蒙版层，换句话说；在现有形状或图片上创建一个层。在应用蒙版层并更新 `stage` 事件后，您将看到新层覆盖了现有层。换句话说，您可以使用向量蒙版控制父层中隐藏或显示的部分。
- en: '![Learning about vector masks](img/0260OS_08_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![学习向量蒙版](img/0260OS_08_01.jpg)'
- en: Furthermore, mask layers are also shapes, so you can change the mask layer properties
    continuously to create animations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，蒙版层也是形状，因此您可以连续更改蒙版层的属性以创建动画。
- en: 'Here is an example of using a vector mask in EaselJS:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 EaselJS 中向量蒙版的示例：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As with other examples in this book, we first get the `canvas` element from
    the page and then create the `Stage` object. Then, we create a simple circle using
    the `Shape` class and the `drawCircle` function. For the default position, we
    set both `x` and `y` to `100`. This circle is our vector mask layer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他示例一样，我们首先从页面中获取 `canvas` 元素，然后创建 `Stage` 对象。然后，我们使用 `Shape` 类和 `drawCircle`
    函数创建一个简单的圆形。对于默认位置，我们将 `x` 和 `y` 都设置为 `100`。这个圆形是我们的向量蒙版层。
- en: Then, we create a `bg` variable that contains a rectangle filled with the color
    red. After that, we assign the first shape—that is, the circle—to the `mask` property
    of the `bg` variable. Finally, we add the `bg` variable to stage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `bg` 变量，它包含一个填充红色的矩形。之后，我们将第一个形状（即圆形）分配给 `bg` 变量的 `mask` 属性。最后，我们将
    `bg` 变量添加到舞台中。
- en: 'Here is the output of the preceding source code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面源代码的输出：
- en: '![Learning about vector masks](img/0260OS_08_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![学习向量蒙版](img/0260OS_08_02.jpg)'
- en: For you to understand the example better, look at the following screenshot.
    It is what the output will be after removing the mask layer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解示例，请查看以下截图。这是移除蒙版层后的输出。
- en: '![Learning about vector masks](img/0260OS_08_03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![学习向量蒙版](img/0260OS_08_03.jpg)'
- en: As you can see in the first example, our mask layer is seen only in the circular
    shape, but in the next example, the whole rectangle is seen because there is no
    mask layer anymore.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在第一个示例中所见，我们的蒙版层仅在圆形形状中可见，但在下一个示例中，整个矩形都可见，因为没有蒙版层了。
- en: 'The following screenshot shows the mask layer independently:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了独立的蒙版层：
- en: '![Learning about vector masks](img/0260OS_08_04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![学习向量蒙版](img/0260OS_08_04.jpg)'
- en: After assigning the mask layer to the parent layer (the red rectangle), the
    only visible part of the rectangle will be the visible part of the mask layer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在将蒙版层分配给父层（红色矩形）后，矩形唯一可见的部分将是蒙版层的可见部分。
- en: In the next section, we will look at a drag-and-drop example with mask layers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看一个带有蒙版层的拖放示例。
- en: Using a vector mask with Bitmap images
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位图图像的向量蒙版
- en: In this section, you will learn to use the vector mask, filters, and a `Bitmap`
    class with an example. The `Bitmap` class is a subset of `DisplayObject`; thus,
    it has almost all the properties of the `Shape` class, such as `filters`, `mask`,
    and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将通过示例学习如何使用矢量蒙版、滤镜和`Bitmap`类。`Bitmap`类是`DisplayObject`的子集；因此，它几乎具有`Shape`类的所有属性，例如`filters`、`mask`等。
- en: 'Here is an example of using a vector mask with a `Bitmap` class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`Bitmap`类与矢量蒙版的示例：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first line, we created the `canvas` variable that refers to our `canvas`
    element on the page. Then, we initiated the `stage` variable with the `Stage`
    class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了指向页面上的`canvas`元素的`canvas`变量。然后，我们使用`Stage`类初始化了`stage`变量。
- en: In the next line, we initiated a `mask` variable using the `Shape` class. This
    shape is our mask layer, and it's a circle. For the mask layer coordinates, we
    used `img.width / 2` and `img.height / 2` to place the mask layer in the center
    of the picture. Then, we created the circle using the `drawCircle` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们使用`Shape`类初始化了一个`mask`变量。这个形状是我们的蒙版层，它是一个圆形。对于蒙版层的坐标，我们使用了`img.width
    / 2`和`img.height / 2`将蒙版层放置在图片的中心。然后，我们使用`drawCircle`方法创建了圆形。
- en: Then we created the `bg` variable, which refers to our image. We initiated this
    variable using the `Bitmap` class; the first parameter of the `Bitmap` class is
    the `Image` class. We already loaded the image using the `Image` class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了`bg`变量，它指向我们的图像。我们使用`Bitmap`类初始化了这个变量；`Bitmap`类的第一个参数是`Image`类。我们已使用`Image`类加载了图像。
- en: 'Here is an example of loading an image and using an `onload` event:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个加载图像并使用`onload`事件的示例：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can use the same approach to load images and pass them to the `Bitmap` class
    in EaselJS.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的方法在EaselJS中加载图像并将它们传递给`Bitmap`类。
- en: Then, we added a blur filter to the picture filters and cached the shape using
    the `cache` method.We used the original image dimensions for the `cache` method.
    Then we assigned the mask layer to the `bg` variable using the `mask` property.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在图片滤镜中添加了一个模糊滤镜，并使用`cache`方法缓存了形状。我们使用原始图像尺寸作为`cache`方法的参数。然后我们使用`mask`属性将蒙版层赋值给`bg`变量。
- en: Finally, we added the `bg` variable to the `stage` event and updated this event
    to apply the changes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`bg`变量添加到`stage`事件中，并更新了这个事件以应用更改。
- en: In order to understand the differences better, look at the following output
    screenshot of the `bg` variable without the `mask` property. This is the `Bitmap`
    class without the mask layer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解差异，请查看以下没有`mask`属性的`bg`变量的输出截图。这是没有蒙版层的`Bitmap`类。
- en: '![Using a vector mask with Bitmap images](img/0260OS_08_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![使用矢量蒙版与位图图像](img/0260OS_08_05.jpg)'
- en: 'The following image shows the vector mask separately:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了矢量蒙版单独的情况：
- en: '![Using a vector mask with Bitmap images](img/0260OS_08_06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![使用矢量蒙版与位图图像](img/0260OS_08_06.jpg)'
- en: 'The following screenshot illustrates the final result of our example with the
    mask layer:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了带有蒙版层的最终示例结果：
- en: '![Using a vector mask with Bitmap images](img/0260OS_08_07.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用矢量蒙版与位图图像](img/0260OS_08_07.jpg)'
- en: As you can see, the whole image is visible in the first screenshot. However,
    the only visible part in the third image is our mask layer, that is the circle.
    That's the way vector masks work with pictures and shapes. You can create any
    shape and mask an existing layer, such as a picture with this shape.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第一张截图显示了整个图像。然而，第三张图中唯一可见的部分是我们的蒙版层，即圆形。这就是矢量蒙版与图片和形状一起工作的方式。您可以创建任何形状，并用这个形状蒙版一个现有的层，例如一个图片。
- en: In the next example, we will create a drag-and-drop interaction using vector
    masks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将创建一个使用矢量蒙版的拖放交互。
- en: Playing with vector masks
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转矢量蒙版
- en: 'Now, we will complete our previous example to create a simple drag-and-drop
    example using vector masks. The idea is to change the x and y coordinates of the
    mask layer on the `mousemove` event of the parent layer so that we can only see
    the masked layer over the existing shape. It will seem that only a circular shape
    is being dragged, but what''s actually happening is that our mask layer is changing
    continuously. The source code of our example is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将完成之前的示例，使用矢量蒙版创建一个简单的拖放示例。想法是在父层的`mousemove`事件中更改蒙版层的x和y坐标，这样我们只能看到覆盖现有形状的蒙版层。看起来就像只有圆形形状被拖动，但实际上我们的蒙版层正在不断变化。我们示例的源代码如下：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As in the previous example, we created a mask layer in the shape of a circle
    in the first line. We specified the default coordinates for the mask layer with
    `x=100` and `y=100`. Then, we created a `bg` variable that contains the background
    or parent layer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，我们在第一行创建了一个圆形的遮罩层。我们使用 `x=100` 和 `y=100` 指定了遮罩层的默认坐标。然后，我们创建了一个 `bg`
    变量，它包含背景或父层。
- en: Because we need the coordinates of the mask layer to change continuously as
    we move the mouse cursor, we bound a callback function to both `mousedown` and
    `mousemove` events. Then, inside the `mousemove` callback function, we changed
    the co-ordination of the mask layer and updated the stage.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要遮罩层的坐标随着鼠标光标的移动而连续变化，所以我们为 `mousedown` 和 `mousemove` 事件绑定了回调函数。然后，在 `mousemove`
    回调函数内部，我们改变了遮罩层的坐标并更新了舞台。
- en: The result will look like a drag-and-drop ball over the stage, but actually,
    it's our mask layer that keeps changing with every mouse move.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像是在舞台上拖放的一个球，但实际上，是随着鼠标的每一次移动而不断变化的遮罩层。
- en: '![Playing with vector masks](img/0260OS_08_08.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![玩转矢量遮罩](img/0260OS_08_08.jpg)'
- en: Summary
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The vector mask feature is one of the most useful features for drawing and developing
    animations, not only in CreateJS but in all other tools. In this chapter, we learned
    how to create vector mask layers in EaselJS and also how to enhance them to create
    animations. This feature also comes handy when you need to apply a different filter
    to a specific part of an existing shape or picture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量遮罩功能是绘制和开发动画中最有用的功能之一，不仅限于 CreateJS，还适用于所有其他工具。在本章中，我们学习了如何在 EaselJS 中创建矢量遮罩层，以及如何增强它们来创建动画。当您需要将不同的过滤器应用于现有形状或图片的特定部分时，这个功能也非常有用。
- en: In the next chapter, we will wrap up everything to create a complete UI from
    scratch using all the CreateJS features that we have already talked about.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将总结所有内容，从头开始使用我们已讨论过的所有 CreateJS 功能来创建一个完整的 UI。
