- en: Chapter 12\. Command Query Responsibility Separation (CQRS)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。命令查询职责分离（CQRS）
- en: 'Up to this point in this book, we have worked to put together a simple blog
    application using the CRUD pattern: Create, Retrieve, Update, and Delete. We have
    done an excellent job of ensuring services are handling our business logic and
    our controllers are simply gateways into those services. The controllers take
    care of validating the request and then pass the request to the service for processing.
    In a small application like this, CRUD works wonderfully.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们已经努力使用CRUD模式构建了一个简单的博客应用程序：创建、检索、更新和删除。我们已经非常好地确保服务处理我们的业务逻辑，而我们的控制器只是这些服务的网关。控制器负责验证请求，然后将请求传递给服务进行处理。在这样一个小型应用程序中，CRUD非常有效。
- en: But what happens when we are dealing with a large scale application that may
    have unique and complex business logic for saving data? Or maybe we would like
    to initiate some logic in the background so the UI is able to call APIs without
    having to wait for all the business logic to finish. These are areas where CQRS
    makes sense. CQRS can be used to isolate and break apart complex business logic,
    initiate that business logic synchronously or asynchronously, and compose the
    isolated pieces to solve new business problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们处理可能具有独特和复杂业务逻辑的大型应用程序时会发生什么？或者也许我们希望在后台启动一些逻辑，以便UI能够调用API而无需等待所有业务逻辑完成。这些是CQRS有意义的领域。CQRS可以用于隔离和分解复杂的业务逻辑，同步或异步地启动该业务逻辑，并组合这些隔离的部分来解决新的业务问题。
- en: 'Nest.js implements this pattern by providing two separate streams for processing
    the command aspect of CQRS: a command and an event bus, with some sugar in the
    form of sagas. In this chapter, we will tackle the problem of adding keyword metadata
    to our blog entries. We could certainly do this using the CRUD pattern, but having
    the UI make multiple API calls to store a blog entry and all it’s keywords, or
    even having our blog entry module perform this, would complicate the business
    logic of the UI and our application.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Nest.js通过提供两个单独的流来实现CQRS的命令方面：一个命令总线和一个事件总线，还有一些sagas的糖。在本章中，我们将解决向博客条目添加关键字元数据的问题。我们当然可以使用CRUD模式来做到这一点，但是让UI进行多个API调用来存储博客条目及其所有关键字，甚至让我们的博客条目模块执行这一操作，都会使UI和我们的应用程序的业务逻辑变得复杂。
- en: 'Instead, we will convert the blog entry module to use CQRS commands, and the
    command `bus` to perform all data persistance, removing it from the service in
    the blog entry module. A new entity and module will be created for our keywords.
    The keyword entity will maintain a last updated timestamp and a reference to all
    associated entries. Two new APIs will be created: one to provide a list of “hot
    keywords” and one to provide a list of all entries associated with a keyword.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将转换博客条目模块以使用CQRS命令，并使用命令`总线`来执行所有数据持久化，将其从博客条目模块中的服务中移除。我们将为我们的关键字创建一个新的实体和模块。关键字实体将维护最后更新的时间戳和所有关联条目的引用。将创建两个新的API：一个提供“热门关键字”的列表，另一个提供与关键字关联的所有条目的列表。
- en: 'To ensure the UI does not suffer any performance loss, all keyword entity operations
    will be done asynchronously. Keywords will be stored on the blog entry entity
    as a string to provide the UI a quick reference without having to query the keyword
    table in the database. Before getting started, be sure you ran `npm install @nestjs/cqrs`
    in your project. To see a working example, remember you can clone the accompanying
    Git repository for this book:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保UI不会遭受任何性能损失，所有关键字实体操作将以异步方式进行。关键字将以字符串形式存储在博客条目实体上，以便UI可以快速引用而无需查询数据库中的关键字表。在开始之前，请确保在项目中运行了`npm
    install @nestjs/cqrs`。要查看一个工作示例，记住你可以克隆本书的附带Git存储库：
- en: '`git clone https://github.com/backstopmedia/nest-book-example.git`'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/backstopmedia/nest-book-example.git`'
- en: Entry module commands
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入口模块命令
- en: To make the business logic around changes to entry models easier to extend,
    we will first need to extract out the methods in the module’s services that update
    the database as individual commands. Let’s start with converting the blog entry
    `create` method to a command in Nest.js CQRS fashion.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使围绕入口模型的业务逻辑更容易扩展，我们首先需要将模块服务中更新数据库的方法提取为单独的命令。让我们首先将博客条目的`create`方法转换为Nest.js
    CQRS风格的命令。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our command is a simple object that implemented the `ICommand` interface. The
    `ICommand` interface is used internally by Nest.js to indicate an object is a
    command. This file is typically created in a sub-directory of our module with
    a pattern similar to `commands/impl/`. Now that we have one example done, let’s
    finish up the remaining commands for the comment module.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的命令是一个简单的对象，实现了`ICommand`接口。`ICommand`接口在Nest.js内部用于指示对象是一个命令。这个文件通常在我们模块的子目录中创建，模式类似于`commands/impl/`。现在我们已经完成了一个示例，让我们完成评论模块的其余命令。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice some differences with the update and delete commands? For the update
    command, we need to know which database model we are updating. Likewise, for the
    delete command, we only need to know the id of the database model we are deleting.
    In both cases, having the `userId` does not make sense since a blog entry can
    never be moved to another user and the `userId` has no influence on the deletion
    of a blog entry.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意更新和删除命令的一些区别？对于更新命令，我们需要知道正在更新的数据库模型。同样，对于删除命令，我们只需要知道要删除的数据库模型的id。在这两种情况下，拥有`userId`是没有意义的，因为博客条目永远不会移动到另一个用户，并且`userId`对博客条目的删除没有影响。
- en: Command handlers
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令处理程序
- en: Now that we have commands for our database write operations, we need some command
    handlers. Each command should have an accompanying handler in a one-to-one fashion.
    The command handler is much like our current blog entry service. It will take
    care of all the database operations. Typically, the command handlers are placed
    in a sub-directory of the module similar to `commands/handlers`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用于数据库写操作的命令，我们需要一些命令处理程序。每个命令应该以一对一的方式有一个相应的处理程序。命令处理程序很像我们当前的博客条目服务。它将负责所有数据库操作。通常，命令处理程序放在模块的子目录中，类似于`commands/handlers`。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Command handlers are simple classes with a single method, `execute`, that is
    responsible for handling the command. Implementing the `ICommandHandler<CreateEntryCommand>`
    interface helps ensure we write our command handler correctly. Nest.js uses the
    `@CommandHandler` annotation in our example to know this class is meant to handle
    our new `CreateEntryCommand` command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理程序是简单的类，具有一个名为`execute`的方法，负责处理命令。实现`ICommandHandler<CreateEntryCommand>`接口有助于确保我们正确编写命令处理程序。在我们的示例中，Nest.js使用`@CommandHandler`注解来知道这个类是用来处理我们的新`CreateEntryCommand`命令的。
- en: Since the command handler is going to be a drop-in replacement for our module’s
    service, the command handler will also need access to our database. This may differ
    depending on what ORM you are using and how your application is configured. Our
    command handler doesn’t actually do anything at this point. In fact, using it
    would break the application since we have not implemented the details of the `execute`
    method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令处理程序将成为模块服务的替代品，因此命令处理程序还需要访问我们的数据库。这可能会有所不同，取决于您使用的ORM以及应用程序的配置方式。实际上，我们的命令处理程序目前并没有做任何事情。事实上，使用它会破坏应用程序，因为我们还没有实现`execute`方法的细节。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you are following along with the example project, you may notice our `execute`
    method looks almost like the `create` method of the blog entry service. In fact,
    almost all of the code for the command handler is a direct copy from the blog
    entry service. The big difference is that we do not return a value. Instead, the
    `execute` method of all command handlers takes a callback method as their second
    argument.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在跟随示例项目，您可能会注意到我们的`execute`方法几乎与博客条目服务的`create`方法相似。实际上，命令处理程序的几乎所有代码都是直接从博客条目服务复制而来的。最大的区别是我们不返回一个值。相反，所有命令处理程序的`execute`方法都将回调方法作为它们的第二个参数。
- en: Nest.js allows us to do a couple of different things with the callback it provides
    to the `execute` method. In our example, we use the ORM to create and persist
    a new blog entry. Once the transaction resolves, we call the `resolve` callback
    to let Nest.js know our command is done executing. If this looks familiar, it
    is because behind the scenes Nest.js is wrapping our `execute` in a Promise and
    passing in the promise’s own `resolve` callback as the second argument to our
    `execute` method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Nest.js允许我们对提供给`execute`方法的回调执行几种不同的操作。在我们的示例中，我们使用ORM来创建和保存新的博客条目。一旦事务解决，我们调用`resolve`回调来让Nest.js知道我们的命令已经执行完毕。如果这看起来很熟悉，那是因为在幕后，Nest.js正在将我们的`execute`包装在一个Promise中，并将promise自己的`resolve`回调作为我们的`execute`方法的第二个参数传递进去。
- en: Notice that we do not get a `reject` callback passed to our command handler.
    Nest.js does not perform any type of error handling when invoking command handlers.
    Since our command handler is invoking our ORM to store data in a database, it
    is very possible that an exception could be thrown. If this happens with the way
    our command handler is currently wrote, depending on the version of NodeJS being
    used, an `UnhandledPromiseRejectionWarning` warning being logged to the console
    and the UI will be stuck waiting for the API to return until it times out. To
    prevent this, we should wrap our command handler logic in a `try...catch` block.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的命令处理程序没有传递`reject`回调。Nest.js在调用命令处理程序时不执行任何类型的错误处理。由于我们的命令处理程序正在调用ORM将数据存储在数据库中，很可能会抛出异常。如果我们当前的命令处理程序发生这种情况，根据使用的NodeJS版本，控制台可能会记录`UnhandledPromiseRejectionWarning`警告，并且UI将一直等待API返回直到超时。为了防止这种情况，我们应该将命令处理程序逻辑包装在`try...catch`块中。
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice we invoke the `resolve` callback in the `finally` block. This is done
    to ensure that, no matter the outcome, the command handler will complete execution
    and the API will finish processing. But what happens when an exception is thrown
    from our ORM. The blog entry wasn’t saved to the database, but since the API controller
    did not know an error occurred, it will return a 200 HTTP status to the UI. To
    prevent this, we can catch the error and pass that as an argument to the `resolve`
    method. This might break with the CQRS pattern but it is better to let the UI
    know something went wrong than assume the blog entry was saved.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`finally`块中调用`resolve`回调。这是为了确保无论结果如何，命令处理程序都将完成执行，API都将完成处理。但是当我们的ORM抛出异常时会发生什么呢？博客条目没有保存到数据库中，但由于API控制器不知道发生了错误，它将向UI返回一个200的HTTP状态。为了防止这种情况，我们可以捕获错误并将其作为参数传递给`resolve`方法。这可能会违反CQRS模式，但是让UI知道发生了错误要比假设博客条目已保存更好。
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Note:** Nest.js does not provide any stipulation for when the callback method
    must be invoked. We could invoke the callback at the beginning of the `execute`
    method. Nest.js would return processing back to the controller so the UI is immediately
    updated and process the remaining pieces of the `execute` method afterwards.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** Nest.js没有规定回调方法必须在何时被调用。我们可以在`execute`方法的开头调用回调。Nest.js会将处理返回给控制器，因此UI会立即更新，并在之后处理`execute`方法的其余部分。'
- en: Let’s finish converting our blog entry module to CQRS by creating commands to
    handle updating and deleting blog entries from the database.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建命令来处理更新和删除数据库中的博客条目，完成将我们的博客条目模块转换为CQRS。
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The command handler for our `UpdateEntryCommand` command needs a couple changes
    from what we have in the blog entry service. Since our command contains all of
    the data for the blog entry being updated, including the `id`, we need to strip
    out the `id` and apply the remaining values in the command to the entity before
    saving it back to the database. Just like our last command handler, we use a `try...catch`
    to handle errors and pass any thrown exceptions back as an argument to the `resolve`
    callback.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`UpdateEntryCommand`命令的命令处理程序需要对博客条目服务中的内容进行一些更改。由于我们的命令包含了要更新的博客条目的所有数据，包括`id`，我们需要剥离`id`并将命令中的其余值应用到实体中，然后将其保存回数据库。就像我们上一个命令处理程序一样，我们使用`try...catch`来处理错误，并将任何抛出的异常作为参数传递回`resolve`回调函数。
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The command handler for our `DeleteEntryCommand` is pretty much a copy of the
    `delete` method in the blog entry service. We now have three new commands and
    their accompanying handlers. All that’s left is to hook them up and begin using
    them. Before we can do that, we must decide on where we are going to invoke these
    new commands.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DeleteEntryCommand`的命令处理程序基本上是博客条目服务中`delete`方法的副本。我们现在有了三个新的命令及其相应的处理程序。剩下的就是将它们连接起来并开始使用它们。在我们这样做之前，我们必须决定在哪里调用这些新命令。
- en: Invoking command handlers
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用命令处理程序
- en: Documentation and the general consensus around separation of concerns within
    NodeJS applications would probably dictate that we invoke our commands from the
    blog entry service. Doing so would leave the controller as simple as it is now
    but would not simplify the service at all. Alternatively, the approach we will
    be taking is to reduce the complexity of our service so it is used strictly for
    data retrieval and invoke our commands from the controller. No matter the route
    taken, the first step in making use of the new commands is to inject the Nest.js
    `CommandBus`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文档和NodeJS应用程序中关于关注点分离的一般共识可能会指示我们从博客条目服务中调用我们的命令。这样做会使控制器像现在这样简单，但不会简化服务。或者，我们将采取的方法是减少服务的复杂性，使其严格用于数据检索，并从控制器中调用我们的命令。无论采取哪种路线，利用新命令的第一步是注入Nest.js的`CommandBus`。
- en: '**Note:** Where you plan to use your commands, whether it be the controller
    or service, makes no difference for the implementation. Feel free to experiment.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**您计划在哪里使用您的命令，无论是控制器还是服务，对于实现都没有影响。请随意尝试。'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The above example incorporates two key changes. First, we have added `commandBus`
    to the constructor. Nest.js will take care of injecting an instance of the `CommandBus`
    into this variable for us. The last change is to the `create` controller method.
    Instead of invoking the `create` method in the blog entry service, we create and
    execute a new `CreateEntryCommand` using the command bus. The remaining implementation
    details for the blog entry controller follow almost the same pattern as the `create`
    method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子包含了两个关键更改。首先，我们已经将`commandBus`添加到构造函数中。Nest.js会为我们注入一个`CommandBus`的实例到这个变量中。最后一个更改是`create`控制器方法。我们不再调用博客条目服务中的`create`方法，而是使用命令总线创建和执行一个新的`CreateEntryCommand`。博客条目控制器的其余实现细节几乎与`create`方法的模式相同。
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see from the example that the controller has been updated so the blog
    entry service is only used for retrievals and all modification methods now dispatch
    commands on the command bus. The last thing we need to configure is the blog entry
    module. To make this easier, let’s first setup a Typescript barrel to export all
    our handlers as a single variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，控制器已经更新，所以博客条目服务只用于检索，所有修改方法现在都在命令总线上分发命令。我们需要配置的最后一件事是博客条目模块。为了使这更容易，让我们首先设置一个Typescript
    barrel来将所有处理程序导出为一个单一变量。
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Import the barrel into the blog entry module and hook up the module to the command
    bus.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将barrel导入到博客条目模块中，并将模块连接到命令总线。
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To hook up our module to the command bus, we import `CQRSModule` into our module
    definition and inject the `ModuleRef` and `CommandBus` into the module class constructor.
    The module class also needs to implement the `OnModuleInit` interface. Finally,
    the magic happens in the `onModuleInit` lifecycle hook. Nest.js will execute this
    method immediately after instantiating our module class. Inside the method, we
    use `setModuleRef` and `register` to register the blog entry command handlers
    to the command bus that was created for this module.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的模块连接到命令总线，我们将`CQRSModule`导入到我们的模块定义中，并将`ModuleRef`和`CommandBus`注入到模块类构造函数中。模块类还需要实现`OnModuleInit`接口。最后，在`onModuleInit`生命周期钩子中发生了魔术。Nest.js将在实例化我们的模块类后立即执行此方法。在方法内部，我们使用`setModuleRef`和`register`将博客条目命令处理程序注册到为该模块创建的命令总线中。
- en: '**Note:** If you followed along and implemented the invocation of the commands
    in the controller, you can remove the `create`, `update`, and `delete` methods
    from the comment service.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**如果您跟随并在控制器中实现了命令的调用，您可以从评论服务中删除`create`、`update`和`delete`方法。'
- en: '![CQRS Comments Flow](img/CQRSFlow001.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![CQRS Comments Flow](img/CQRSFlow001.png)'
- en: The above diagram provides a visual representation of how the command and query
    aspects of the entry controller have been divided. When a user sends a request
    to the `create` controller method, processing is executed through the CQRS command
    bus, but still uses the ORM to update the database. When the users wishes to retrieve
    all the entries, the entry controller makes use of the `EntryService` that then
    uses the ORM to query the database. All commands, the `C` in CQRS, are now processed
    through the command bus while all queries, the `Q` in CQRS, are continue to be
    processed through the entry service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图表提供了入口控制器的命令和查询方面如何被划分的可视化表示。当用户发送请求到`create`控制器方法时，处理是通过CQRS命令总线执行的，但仍然使用ORM来更新数据库。当用户希望检索所有条目时，入口控制器使用`EntryService`，然后使用ORM来查询数据库。所有命令（CQRS中的`C`）现在都通过命令总线处理，而所有查询（CQRS中的`Q`）仍然通过入口服务处理。
- en: Linking keywords with events
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将关键字与事件链接起来
- en: Now that we have shown the basics of creating commands and using the command
    bus in Nest.js CQRS, we need to tackle storing keywords that are associated with
    a blog entry. Keywords can be added when a blog entry is created and removed later.
    We could create a new entity for our keywords and have the entry entity maintain
    a one-to-many relationship with the keyword entity. This would, however, require
    our database lookups to pull in more data from more tables and the response sent
    back to the UI would become larger. Instead, let’s start off with just storing
    the keywords as a JSON string on the blog entry entity. To do this, we will need
    to update the blog entry entity and add a new field.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了在Nest.js CQRS中创建命令并使用命令总线的基础知识，我们需要解决存储与博客条目关联的关键字。关键字可以在创建博客条目时添加，并在以后删除。我们可以为关键字创建一个新实体，并使条目实体维护与关键字实体的一对多关系。然而，这将需要我们的数据库查找从更多的表中拉取更多的数据，并且发送回UI的响应将变得更大。相反，让我们从只将关键字作为JSON字符串存储在博客条目实体上开始。为此，我们需要更新博客条目实体并添加一个新字段。
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The ORM definition for the new database column will depend on the ORM and database
    server you are using. Here, we are using the `TEXT` data type. This data type
    is widely supported in many different database servers and offers a large limit
    to the amount of data we can store. For example, Microsoft SQL Server limits this
    field to a maximum of 2^30 - 1 characters, while Postgres does not impose a limit.
    Since we are using an ORM with migrations, we will also need to create a migration
    script. If you are unsure of how to do this, reference back to the TypeORM or
    Sequelize chapters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 新数据库列的ORM定义将取决于您正在使用的ORM和数据库服务器。在这里，我们使用`TEXT`数据类型。这种数据类型在许多不同的数据库服务器中得到广泛支持，并提供了存储数据量的大限制。例如，Microsoft
    SQL Server将此字段限制为最多2^30-1个字符，而Postgres则不施加限制。由于我们正在使用具有迁移功能的ORM，因此我们还需要创建迁移脚本。如果您不确定如何操作，请参考TypeORM或Sequelize章节。
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you are following along, your entries database table should now have a keywords
    column. Testing the `index` API in the blog entries controller should now return
    objects with a keywords value. We still need to update the blog entry commands,
    command handlers, and controller to process keywords for new and updated blog
    entries.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在跟进，您的条目数据库表现在应该有一个关键字列。测试博客条目控制器中的`index` API现在应返回带有关键字值的对象。我们仍然需要更新博客条目命令、命令处理程序和控制器，以处理新的和更新的博客条目的关键字。
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The blog entry controller will accept the keywords as an array of strings. This
    will help keep the UI simple and prevent the UI from having to perform arbitrary
    string parsing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 博客条目控制器将接受关键字作为字符串数组。这将有助于保持UI简单，并防止UI执行任意字符串解析。
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `CreateEntryCommand` and `UpdateEntryCommand` commands are updated to accept
    a new property `keywords`. We maintain the string array type so the processing
    of the commands is offloaded to the command handler.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateEntryCommand`和`UpdateEntryCommand`命令已更新以接受新属性`keywords`。我们保持字符串数组类型，以便将命令的处理转移到命令处理程序。'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both the `CreateEntryCommandHandler` and `UpdateEntryCommandHandler` command
    handlers have been updated to convert the keywords string array into a JSON string.
    Keywords also need to be stored individually in their own table with a list of
    blog entries they apply to and the last updated date. To do this, we will need
    to make a new Nest.js module with an entity. We will come back later to add more
    functionality. First, create the new entity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateEntryCommandHandler`和`UpdateEntryCommandHandler`命令处理程序已更新为将关键字字符串数组转换为JSON字符串。关键字还需要单独存储在自己的表中，其中包含它们适用于的博客条目列表和最后更新日期。为此，我们需要创建一个新的Nest.js模块和实体。我们稍后将回来添加更多功能。首先，创建新实体。'
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `BelongsToMany` decorator is used to connect keywords to many different
    blog entries. We will not be placing a `BelongsToMany` column in the blog entry
    table since we are using a string column to keep lookups fast. The `() => KeywordEntry`
    parameter tells the ORM that we will be using the `KeywordEntry` entity to store
    the association. We will need to create the entity as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`BelongsToMany`装饰器用于将关键字连接到许多不同的博客条目。由于我们使用字符串列来保持查找速度，因此我们不会在博客条目表中放置`BelongsToMany`列。`()
    => KeywordEntry`参数告诉ORM我们将使用`KeywordEntry`实体来存储关联。我们还需要创建实体。'
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our ORM will use the `@ForeignKey` decorators to link entries in this database
    table to the `keywords` and `entries` tables. We are also adding a `createdAt`
    column to help us find the latest keywords that have been linked to a blog entry.
    We will use this to create our list of “hot keywords.” Next, create the migration
    script to add the new tables to the database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的ORM将使用`@ForeignKey`装饰器将此数据库表中的条目链接到`keywords`和`entries`表。我们还添加了一个`createdAt`列，以帮助我们找到最新链接到博客条目的关键字。我们将使用此功能创建我们的“热门关键字”列表。接下来，创建迁移脚本以将新表添加到数据库中。
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our migration script includes a unique constraint in the `keywords_entries`
    table to ensure we do not link the same keyword and blog entry more than once.
    The `ON DELETE CASCADE` portion of the `entryId` column definition will ensure
    that when we delete a blog entry, the keyword links will also be deleted. This
    means we do not have to create any code to handle unlinking keywords when blog
    entries are deleted. Be sure to add the new database entities to the database
    provider.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的迁移脚本在`keywords_entries`表中包括一个唯一约束，以确保我们不会将相同的关键字和博客条目链接超过一次。`entryId`列定义的`ON
    DELETE CASCADE`部分将确保当我们删除博客条目时，关键字链接也将被删除。这意味着我们不必创建任何代码来处理删除博客条目时取消关键字的链接。请务必将新的数据库实体添加到数据库提供程序中。
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, create the keyword provider and module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建关键字提供程序和模块。
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have a working keyword module, we can begin to think about how we
    want to construct the the application logic for storing keywords. To stay within
    the CQRS pattern, we could create new commands and command handlers in the keyword
    module. However, Nest.js imposes module isolation on all instances of the command
    bus. This means that the command handlers must be registered within the same module
    where the commands are executed. For example, if we attempted to execute a keyword
    command from the blog entry controller, Nest.js would throw an exception indicating
    there is no handler registered for the command. This is where events within Nest.js
    CQRS come to the rescue. The event bus is not isolated. In fact, the event bus
    allows events to be executed from any module, whether there is a handler registered
    for them or not.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可工作的关键字模块，我们可以开始考虑如何构建存储关键字的应用程序逻辑。为了保持在CQRS模式内，我们可以在关键字模块中创建新的命令和命令处理程序。然而，Nest.js对命令总线的所有实例都施加了模块隔离。这意味着命令处理程序必须在执行命令的同一模块中注册。例如，如果我们尝试从博客条目控制器执行关键字命令，Nest.js将抛出异常，指示没有为该命令注册处理程序。这就是Nest.js
    CQRS中的事件发挥作用的地方。事件总线不是隔离的。事实上，事件总线允许从任何模块执行事件，无论是否为它们注册了处理程序。
- en: Keyword events
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键事件
- en: Events can be thought of as commands with a few differences. Outside of not
    being module scoped, they are also asynchronous, they are typically dispatched
    by models or entities, and each event can have any number of event handlers. This
    makes them perfect for handling background updates to the keywords database table
    when blog entries are created and updated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以被视为具有一些不同之处的命令。除了不是模块范围之外，它们还是异步的，通常由模型或实体分发，并且每个事件可以有任意数量的事件处理程序。这使它们非常适合处理在创建和更新博客条目时对关键字数据库表进行后台更新。
- en: Before we start writing code, let’s give some thought to how we want our application
    to work. When a new blog entry is created, the application needs to inform the
    keyword module that a blog entry has been associated with a keyword. We should
    leave it up to the keyword module to determine if the keyword is new and needs
    to be created or already exists and simply needs to be updated. The same logic
    should apply to updates made to blog entries but we can make our blog entry update
    process simpler if we do not try to determine which keywords are new and which
    have been removed. To support both scenarios, we should create a generic event
    to update all keyword links for the blog entry.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，让我们考虑一下我们希望应用程序如何工作。当创建新的博客条目时，应用程序需要通知关键字模块，博客条目已与关键字关联。我们应该让关键字模块决定关键字是否是新的，需要创建，还是已经存在，只需要更新。相同的逻辑应该适用于对博客条目的更新，但是如果我们不尝试确定哪些关键字是新的，哪些已被删除，我们可以使我们的博客条目更新过程更简单。为了支持这两种情况，我们应该创建一个通用事件来更新博客条目的所有关键字链接。
- en: Now that we have a basic understanding of the logic we are trying to accomplish,
    we can build the event classes. Just like commands, the CQRS events feature requires
    basic classes for the events. Event files are typically created in a sub-directory
    of our module with a pattern similar to `events/impl/`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对我们要完成的逻辑有了基本的理解，我们可以构建事件类。就像命令一样，CQRS事件功能需要事件的基本类。事件文件通常在我们模块的子目录中创建，模式类似于`events/impl/`。
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The event classes should look pretty similar to the command classes we wrote
    earlier in this chapter. The difference is the event classes implement the `IEvent`
    interface to let Nest.js know instances of these classes are CQRS events. We also
    need to setup handlers for these events. Just like command handlers, our event
    handlers will take care of all the database operations. Typically, the event handlers
    are placed in a sub-directory of the module similar to `events/handlers`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类应该看起来与我们在本章前面编写的命令类非常相似。不同之处在于事件类实现了`IEvent`接口，让Nest.js知道这些类的实例是CQRS事件。我们还需要为这些事件设置处理程序。就像命令处理程序一样，我们的事件处理程序将负责所有数据库操作。通常，事件处理程序放在模块的子目录中，类似于`events/handlers`。
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Event handlers are simple classes with a single method, `handle`, that is responsible
    for handling the event. Implementing the `IEventHandler<UpdateKeywordLinksEvent>`
    interface helps ensure we write our event handler correctly. Nest.js uses the
    `@EventsHandler` annotation in our example to know this class is meant to handle
    our new `UpdateKeywordLinksEvent` event.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序是简单的类，只有一个方法`handle`，负责处理事件。实现`IEventHandler<UpdateKeywordLinksEvent>`接口有助于确保我们正确编写事件处理程序。在我们的示例中，Nest.js使用`@EventsHandler`注解来知道这个类是用来处理我们的新`UpdateKeywordLinksEvent`事件的。
- en: One of the key differences in our event handlers compared to command handlers
    is that the event handler do not get a callback method as a second argument. Nest.js
    will invoke the `handle` method asynchronously. It will not wait for it to finish,
    it will not attempt to capture any return values, and it will not catch or handle
    any errors that may result from invoking our `handle` method. That’s not to say
    we shouldn’t still use a `try...catch` to prevent any kind of errors causing issues
    iss with NodeJS.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件处理程序与命令处理程序相比的一个关键区别是，事件处理程序不会作为第二个参数得到一个回调方法。Nest.js将异步调用`handle`方法。它不会等待它完成，也不会尝试捕获任何返回值，也不会捕获或处理调用`handle`方法可能导致的任何错误。这并不是说我们不应该仍然使用`try...catch`来防止任何错误导致与NodeJS的问题。
- en: For the update links event handler, we should split out the logic into separate
    methods to make the class a little easier to read and manage. Let’s write the
    `handle` method so it loops through all the keywords and ensures the keyword exists
    and the blog entry is associated with the keyword. Finally, we should ensure the
    blog entry is not associated with any keywords that are not in the event `keywords`
    array.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新链接事件处理程序，我们应该将逻辑拆分成单独的方法，以使类更容易阅读和管理。让我们编写`handle`方法，使其循环遍历所有关键字，并确保关键字存在，并且博客条目与关键字关联。最后，我们应该确保博客条目不与事件`keywords`数组中不存在的任何关键字关联。
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The event handler logic starts with finding all keywords the blog entry is currently
    linked to. We loop through those and pull out any that are not in the new keywords
    array. To find all new keywords, we loop trough the keywords array in the event
    to find those that are not in the `keywordEntities` array. The new keywords are
    processing through the `ensureKeywordLinkExists` method. The `ensureKeywordLinkExists`
    uses `ensureKeywordExists` to create or find the keyword in the keywords database
    table and adds the blog entry to the keywords entries array. The `$add` and `$remove`
    methods are provided by `sequelize-typescript` and are used to quickly add and
    remove blog entries without having to query for the blog entry. All processing
    is done using transactions to ensure any errors will cancel all database updates.
    If an error does happen, the database will become out of sync, but since we are
    dealing with metadata, it’s not a big deal. We log the error out so application
    admins will know they need to re-sync the metadata.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序逻辑从查找博客条目当前链接到的所有关键字开始。我们循环遍历这些关键字，并提取出不在新关键字数组中的任何关键字。为了找到所有新关键字，我们循环遍历事件中的关键字数组，找到不在`keywordEntities`数组中的关键字。新关键字通过`ensureKeywordLinkExists`方法进行处理。`ensureKeywordLinkExists`使用`ensureKeywordExists`来在关键字数据库表中创建或查找关键字，并将博客条目添加到关键字条目数组中。`$add`和`$remove`方法由`sequelize-typescript`提供，用于快速添加和删除博客条目，而无需查询博客条目。所有处理都使用事务来确保任何错误都将取消所有数据库更新。如果发生错误，数据库将变得不同步，但由于我们处理的是元数据，这并不是什么大问题。我们记录错误，以便应用管理员知道他们需要重新同步元数据。
- en: Even though we only have one event handler, we should still create a Typescript
    barrel to export it in an array. This will ensure adding new events later is a
    simple process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们只有一个事件处理程序，我们仍然应该创建一个Typescript barrel来将其导出为数组。这将确保以后添加新事件是一个简单的过程。
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Import the barrel in the keyword module and connect the event bus.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键字模块中导入barrel并连接事件总线。
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the module, import the `CQRSModule` and add `ModuleRef` and `EventBus` as
    constructor params. Implement the `OnModuleInit` interface and create the `onModuleInit`
    method. In the `onModuleInit` method, we set the module reference of event bus
    to the current module using `setModuleRef` and use `register` to register all
    of the event handlers. Remember to also add the event handlers to the `components`
    array or Nest.js will not be able to instantiate the event handlers. Now that
    we have our event and event handler written and linked in our keyword module,
    we are ready to start invoking the event to store and update keyword links in
    the database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中，导入`CQRSModule`并将`ModuleRef`和`EventBus`添加为构造函数参数。实现`OnModuleInit`接口并创建`onModuleInit`方法。在`onModuleInit`方法中，我们使用`setModuleRef`将事件总线的模块引用设置为当前模块，并使用`register`注册所有事件处理程序。记得也将事件处理程序添加到`components`数组中，否则Nest.js将无法实例化事件处理程序。现在，我们已经编写并链接了关键字模块中的事件和事件处理程序，我们准备开始调用事件以存储和更新数据库中的关键字链接。
- en: Invoking event handlers
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用事件处理程序
- en: Event handlers are invoked from data models. Data models are typically simple
    classes that represent data stored in a database. The one stipulation Nest.js
    places on data models is they must extend the `AggregateRoot` abstract class.
    Depending on which ORM you are using and how it is configured, you may or may
    not be able to re-use your existing data models for this purpose. Since our example
    is using Sequelize, the `sequelize-typescript` package requires our data models
    extend the `Model` class. In Typescript, classes can only extend one other class.
    We will need to create a separate data model for invoking our event handlers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序是从数据模型中调用的。数据模型通常是表示存储在数据库中的数据的简单类。Nest.js对数据模型的唯一规定是它们必须扩展`AggregateRoot`抽象类。根据您使用的ORM以及其配置方式，您可能能够重用现有的数据模型来实现此目的，也可能不能。由于我们的示例使用Sequelize，`sequelize-typescript`包要求我们的数据模型扩展`Model`类。在Typescript中，类只能扩展另一个类。我们需要为调用我们的事件处理程序创建一个单独的数据模型。
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create our data model in the blog entry module since we will be invoking
    our events when blog entries are created and updated. The data model contains
    a single method, `updateKeywordLinks,` for refreshing blog entry keyword links
    when a blog entry is created or updated. If new events are needed, we will add
    more methods to the model to handle invoking those events. The `updateKeywordLinks`
    method instantiates the event we created and call the `apply` method found in
    the `AggregateRoot` abstract class with the event instance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在博客条目模块中创建我们的数据模型，因为我们将在创建和更新博客条目时调用我们的事件。数据模型包含一个名为`updateKeywordLinks`的方法，用于在创建或更新博客条目时刷新博客条目关键字链接。如果需要新的事件，我们将向模型添加更多方法来处理调用这些事件。`updateKeywordLinks`方法实例化了我们创建的事件，并调用了`AggregateRoot`抽象类中的`apply`方法来应用事件实例。
- en: With commands, we used the command bus directly to `execute` our commands. With
    events, we take a less direct approach and use the `EventPublisher` to link our
    data model to the event bus and then call the method we created in our data model
    to `apply` an event. Let’s update the `CreateEntryCommandHandler` to get a better
    idea of what’s going on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令，我们直接使用命令总线来`execute`我们的命令。对于事件，我们采取了一种不太直接的方法，使用`EventPublisher`将我们的数据模型链接到事件总线，然后调用我们在数据模型中创建的方法来`apply`事件。让我们更新`CreateEntryCommandHandler`以更好地了解发生了什么。
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The command handler constructor has been updated to have an instance of the
    Nest.js `EventPublisher` injected. The `EventPublisher` has two methods that we
    care about: `mergeClassContext` and `mergeObjectContext`. Both methods can be
    used to achieve the same outcome, just in different ways. In our example, we are
    using `mergeObjectContext` to merge a new instance of our data model with the
    event bus. This provides the data model instance with a `publish` method that
    is used inside the abstract `AggregateRoot` class to `publish` new events on the
    event bus.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理程序构造函数已更新为注入Nest.js的`EventPublisher`的实例。`EventPublisher`有两个我们关心的方法：`mergeClassContext`和`mergeObjectContext`。这两种方法都可以用来实现相同的结果，只是方式不同。在我们的例子中，我们使用`mergeObjectContext`将我们的数据模型的新实例与事件总线合并。这为数据模型实例提供了一个`publish`方法，该方法在抽象的`AggregateRoot`类中用于在事件总线上`publish`新事件。
- en: Events are never dispatched immediately. When we call `updateKeywordLinks`,
    the event that is created is placed in a queue. The event queue gets flushed when
    we call the `commit` method on our data model. If you ever find that your event
    handlers are not firing, check to make sure you have called the `commit` method
    on your data model.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事件永远不会立即分发。当我们调用`updateKeywordLinks`时，创建的事件将被放入队列中。当我们在我们的数据模型上调用`commit`方法时，事件队列将被刷新。如果您发现您的事件处理程序没有触发，请确保您已经在您的数据模型上调用了`commit`方法。
- en: We could have accomplished the same functionality using `mergeClassContext`
    method on the event publisher.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用事件发布者的`mergeClassContext`方法来实现相同的功能。
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The same updates need to be made to the `UpdateEntryCommandHandler` command
    handler so keyword links are updated when blog entries are updated.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateEntryCommandHandler`命令处理程序也需要进行相同的更新，以便在更新博客条目时更新关键词链接。'
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you have followed along in your own project, you should now be able to create
    or update a blog entry with new or existing keywords and see the keyword links
    being created, updated, and deleted in the database. Of course, we could make
    these changes easier to view by adding a new API to return all the keywords and
    blog entries they are linked to.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在自己的项目中跟随了这些步骤，现在您应该能够创建或更新一个博客条目，使用新的或现有的关键词，并且在数据库中看到关键词链接被创建、更新和删除。当然，我们可以通过添加一个新的API来返回所有关键词和它们链接到的博客条目，使这些更改更容易查看。
- en: '![CQRS Keywords Flow](img/CQRSFlow002.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![CQRS Keywords Flow](img/CQRSFlow002.png)'
- en: The above diagram provides a visual representation of how the entry command
    handlers work to keep the keywords updated. Notice how the flow of control is
    unidirectional. The command handler invokes the event using the entry model and
    then forgets about it. This is the asynchronous nature of the event bus in Nest.js
    CQRS.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上图提供了一个视觉表示，说明了条目命令处理程序如何工作以保持关键词的更新。请注意控制流的单向性。命令处理程序使用条目模型调用事件，然后忘记它。这是Nest.js
    CQRS中事件总线的异步性质。
- en: Retrieving keywords APIs
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索关键词API
- en: We will need to create a new controller and service in the keyword module to
    support retrieving keywords. We want to allow the UI to list all keywords, get
    a specific keyword, and get a list of “hot keywords.” Let’s create the service
    first.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在关键词模块中创建一个新的控制器和服务，以支持检索关键词。我们希望允许UI列出所有关键词，获取特定关键词，并获取“热门关键词”的列表。让我们先创建服务。
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `findAll` method takes an optional search string and limit that can be used
    to filter the keywords. The UI can use this to support keyword search autocomplete.
    If the limit is not specified when searching, the service will automatically limit
    the results to 10 items. The `findById` method will support loading all information
    for a single keyword, including the associated entries. The methods are relatively
    basic and mimic methods in the services of the other modules. The `findHotLinks`
    method, however, is a bit more complex.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`findAll`方法接受一个可选的搜索字符串和限制，可以用来过滤关键词。UI可以使用这个来支持关键词搜索自动完成。如果在搜索时未指定限制，服务将自动将结果限制为10个项目。`findById`方法将支持加载单个关键词的所有信息，包括关联的条目。这些方法相对基本，并模仿其他模块的服务中的方法。然而，`findHotLinks`方法稍微复杂一些。'
- en: The `findHotLinks` method is responsible for returning the latest used keywords
    and the keywords with the most linked blog entries. To do this, we need to incorporate
    the ORM provider for the joining table, the `KeywordEntry` data model. The joining
    table contains the actual link between keywords and blog entries as well as the
    date they we joined. For the `latest5`, we order the list by the maximum `createdAt`
    date to get a list of keywords with the newest first. The `biggest5` is ordered
    by the count of `entryId` to produce a list containing the keywords with the most
    linked blog entries first. In both lists, we group by the `keywordId` to produce
    a list of unique keywords and limit the results to the top five. To ensure we
    do not produce a list with overlaps, the `biggest5` also contains a where clause
    to not include any keywords that were already included in the `latest5` list.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`findHotLinks`方法负责返回最近使用的关键词和具有最多链接的博客条目的关键词。为了做到这一点，我们需要将ORM提供程序与连接表`KeywordEntry`数据模型结合起来。连接表包含关键词和博客条目之间的实际链接，以及它们加入的日期。对于`latest5`，我们按最大的`createdAt`日期对列表进行排序，以获取最新的关键词列表。`biggest5`按`entryId`的计数进行排序，以产生一个包含最多链接的博客条目的关键词列表。在这两个列表中，我们按`keywordId`进行分组，以产生一个唯一关键词的列表，并将结果限制为前五个。为了确保我们不产生重叠的列表，`biggest5`还包含一个where子句，以不包括已经包含在`latest5`列表中的任何关键词。'
- en: Once we have the two lists, we reuse the service’s `findById` method to load
    the complete data record for all the found keywords. This list is then returned
    with the keywords that have the newest links first, ordered newest to oldest,
    followed by the keywords with the most links, order most to least. All that remains
    is to create a controller so the UI can take advantage of our new query methods.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这两个列表，我们就可以重用服务的`findById`方法来加载所有找到的关键词的完整数据记录。然后返回这个列表，其中具有最新链接的关键词首先按最新到最旧的顺序排列，然后是具有最多链接的关键词，按最多到最少的顺序排列。现在剩下的就是创建一个控制器，这样UI就可以利用我们的新查询方法。
- en: '**Note:** Take note of the `as IFindOptions<any>`. This was required to resolve
    a linting error caused by `sequelize-typescript`. You may or may not need this
    in your application.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**请注意`as IFindOptions<any>`。这是为了解决`sequelize-typescript`引起的linting错误而需要的。您的应用程序可能需要或不需要这个。'
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The controller contains three methods that correspond to the three query methods
    in the service. In all three, we call the appropriate method in the service and
    return the results as JSON. Take note that the `hot` method is listed before the
    `show` method. If this order was reversed, calling the `/keywords/hot` API would
    result in the `show` method executing. Since Nest.js is running on top of ExpressJS,
    the order in which we declare our controller methods matter. ExpressJS will always
    execute the first route controller that matches the path requested by the UI.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器包含三种方法，对应于服务中的三种查询方法。在所有三种方法中，我们调用服务中的适当方法，并将结果作为JSON返回。请注意，`hot`方法在`show`方法之前列出。如果更改此顺序，调用`/keywords/hot`
    API将导致执行`show`方法。由于Nest.js运行在ExpressJS之上，我们声明控制器方法的顺序很重要。ExpressJS将始终执行与UI请求的路径匹配的第一个路由控制器。
- en: We now have an application that is using Nest.js CQRS to break apart business
    logic and implements pieces of it in an asynchronous manor. The application is
    capable of reacting to blog entry creations and updates to alter the keyword metadata.
    This is all made possible through the use of events. But there is another way
    to accomplish the same goal using sagas instead of the event handler we created.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个应用程序，它使用Nest.js CQRS来拆分业务逻辑，并以异步方式实现其中的一部分。该应用程序能够对博客条目的创建和更新做出反应，以改变关键字元数据。所有这些都是通过事件的使用变得可能的。但是还有另一种方法可以实现相同的目标，即使用传奇而不是我们创建的事件处理程序。
- en: Linking keywords with sagas
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用传奇链接关键字
- en: 'A saga can be thought of as a special event handler that returns commands.
    Sagas do this by leveraging RxJS to receive and react to all events published
    to the event bus. Using the `UpdateKeywordLinksEvent` event handler, we can logically
    partition the work into two separate commands: one to create keyword links and
    one to remove them. Since sagas return commands, the saga and command must be
    created in the same module. Otherwise, command module scoping will become a problem
    and Nest.js will throw an exception when our saga attempts to return a command
    found in a different module. To get started, we will need setup the commands and
    command handlers that will be replacing our single event handler.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 传奇可以被视为返回命令的特殊事件处理程序。传奇通过利用RxJS来接收和对事件总线发布的所有事件做出反应。使用`UpdateKeywordLinksEvent`事件处理程序，我们可以将工作逻辑上分为两个单独的命令：一个用于创建关键字链接，一个用于删除它们。由于传奇返回命令，因此传奇和命令必须在同一个模块中创建。否则，命令模块作用域将成为一个问题，当我们的传奇尝试返回在不同模块中找到的命令时，Nest.js将抛出异常。要开始，我们需要设置将替换我们的单一事件处理程序的命令和命令处理程序。
- en: Keyword saga commands
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键词传奇命令
- en: Just because we are using sagas to execute our new commands does not change
    how we write those commands and command handlers. We will split the `UpdateKeywordLinksEvent`
    into two separate commands within the keyword module.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为我们使用传奇来执行我们的新命令并不会改变我们编写这些命令和命令处理程序的方式。我们将在关键字模块中将`UpdateKeywordLinksEvent`拆分为两个单独的命令。
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The commands take two properties: a `keyword` and an `entryId`. The commands
    take a simple `keyword` string because the command handler should not assume the
    keyword already exists in the database. The `entryId` is already known to exist
    since it is a parameter of the `UpdateKeywordLinksEvent` event.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 命令有两个属性：`keyword`和`entryId`。命令采用简单的`keyword`字符串，因为命令处理程序不应假设关键字已经存在于数据库中。`entryId`已知存在，因为它是`UpdateKeywordLinksEvent`事件的参数。
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `LinkKeywordEntryCommandHandler` command handler takes care of ensuring
    the keyword exists in the database and then uses the `$add` method provided by
    `sequelize-typescript` to link a blog entry to the keyword by it’s id.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkKeywordEntryCommandHandler`命令处理程序负责确保关键字存在于数据库中，然后使用`sequelize-typescript`提供的`$add`方法，通过其id将博客条目链接到关键字。'
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `UnlinkKeywordEntryCommandHandler` command handler takes care of ensuring
    the keyword exists in the database and then uses the `$remove` method provided
    by `sequelize-typescript` to remove the link of a blog entry to the keyword by
    its id. These commands are substantially simpler than `UpdateKeywordLinksEventHandler`
    event handler was. They have a single purpose, link or unlink a keyword and blog
    entry. The heavy lifting of determining which keywords to link and unlink is reserved
    for the saga. Don’t forget to hook up the command handlers in the keyword module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnlinkKeywordEntryCommandHandler`命令处理程序负责确保关键字存在于数据库中，然后使用`sequelize-typescript`提供的`$remove`方法，通过其id删除博客条目与关键字的链接。这些命令比`UpdateKeywordLinksEventHandler`事件处理程序简单得多。它们有一个单一的目的，即链接或取消链接关键字和博客条目。确定要链接和取消链接的关键字的繁重工作是由传奇保留的。不要忘记在关键字模块中连接命令处理程序。'
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Just like the entry module, we created a Typescript barrel to export the command
    handlers as an array. That gets imported into the module definition and registered
    to the command bus using the `register` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就像条目模块一样，我们创建了一个Typescript桶来将命令处理程序导出为数组。这将被导入到模块定义中，并使用`register`方法注册到命令总线。
- en: Keyword saga
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键词传奇
- en: Sagas are always written as public methods inside component classes to allow
    for Dependency Injection. Typically, you would create a single saga class for
    each module you wish to implement sagas in, but multiple classes would make sense
    when breaking up complex business logic. For the update keyword saga, we will
    need a single saga method that accepts the `UpdateKeywordLinksEvent` event and
    outputs multiple `LinkKeywordEntryCommand` and `UnlinkKeywordEntryCommand` commands.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 传奇始终以组件类内的公共方法编写，以允许依赖注入。通常，您会为希望在其中实现传奇的每个模块创建一个单独的传奇类，但在拆分复杂的业务逻辑时，创建多个类是有意义的。对于更新关键字传奇，我们将需要一个接受`UpdateKeywordLinksEvent`事件并输出多个`LinkKeywordEntryCommand`和`UnlinkKeywordEntryCommand`命令的单一传奇方法。
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `KeywordSagas` class contains a single saga `updateKeywordLinks` and uses
    Dependency Injection to get a reference to the keyword repository and Sequelize
    instance. The parameter passed to the `updateKeywordLinks` saga is provided by
    the Nest.js CQRS event bus. `EventObservable` is a special observable provided
    by Nest.js CQRS that contains the `ofType` method. We use this method to filter
    the `events$` observable so our saga will only handle the `UpdateKeywordLinksEvent`
    event. If you forget to use the `ofType` method, your saga will be fired for every
    event published in your application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeywordSagas`类包含一个单独的saga `updateKeywordLinks`，并使用依赖注入来获取关键字存储库和Sequelize实例的引用。传递给`updateKeywordLinks`
    saga的参数由Nest.js CQRS事件总线提供。`EventObservable`是Nest.js CQRS提供的一个特殊observable，其中包含`ofType`方法。我们使用这个方法来过滤`events$`
    observable，这样我们的saga只会处理`UpdateKeywordLinksEvent`事件。如果忘记使用`ofType`方法，你的saga将对应用程序中发布的每个事件都触发。'
- en: 'The remaining pieces to our saga is strictly RxJS functionality. You are free
    to use any RxJS operator, as long as the saga emits one or more CQRS commands.
    For our saga, we will be using `mergeMap` to flatten an inner observable stream
    of commands. Do not use `switchMap` here or commands could be lost if the API
    is under heavy load due to how `switchMap` is cancelled when the outer observable
    fires multiple times. The inner observable is a merging of two different observable
    streams: `this.getUnlinkCommands(event)` is a stream of `UnlinkKeywordEntryCommand`
    commands and `this.getLinkCommands(event)` is a stream of `LinkKeywordEntryCommand`
    commands.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们saga的剩余部分严格是RxJS功能。你可以自由使用任何RxJS操作符，只要saga发出一个或多个CQRS命令。对于我们的saga，我们将使用`mergeMap`来展平命令的内部observable流。不要在这里使用`switchMap`，否则由于`switchMap`在外部observable多次触发时会被取消，命令可能会丢失，因为内部observable是两个不同observable流的合并：`this.getUnlinkCommands(event)`是一个`UnlinkKeywordEntryCommand`命令流，`this.getLinkCommands(event)`是一个`LinkKeywordEntryCommand`命令流。
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `getUnlinkCommands` and `getLinkCommands` methods start off with getting
    a list of existing keyword blog entry links. We use `Observable.fromPromise` since
    we need to return an observable from these methods. The difference between the
    two commands is how the filtering works. In `getUnlinkCommands`, we need to filter
    the list of existing keyword blog entry links to find those that do not exist
    in the keywords array of the event. We reverse the logic in `getLinkCommands`
    and filter the list of keywords in the event to find those that are not already
    linked to the blog entry. Finally, we map the arrays to commands and use `switchMap(commands
    => Observable.of(...commands))` so our observable stream emits all the commands
    instead of an array of commands. Since the only difference is the filtering, we
    could clean this up so the database is not queried as much.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUnlinkCommands`和`getLinkCommands`方法首先获取现有关键字博客条目链接的列表。我们使用`Observable.fromPromise`，因为我们需要从这些方法返回一个observable。两个命令之间的区别在于过滤的方式。在`getUnlinkCommands`中，我们需要过滤现有关键字博客条目链接的列表，以找到那些不在事件的关键字数组中的链接。我们在`getLinkCommands`中颠倒逻辑，并过滤事件中的关键字列表，以找到那些尚未链接到博客条目的关键字。最后，我们将数组映射到命令，并使用`switchMap(commands
    => Observable.of(...commands))`，这样我们的observable流会发出所有命令，而不是一组命令。由于唯一的区别是过滤，我们可以清理一下，这样就不会频繁查询数据库。'
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now our saga only queries the database for the existing keyword blog entry links
    once and the `getUnlinkCommands` and `getLinkCommands` methods have been drastically
    simplified. These methods now take the event and list of existing keyword blog
    entry links and returns an array of commands that need to be executed. The heavy
    lifting of retrieving the existing keyword blog entry links has been offloaded
    to `compileKeywordLinkCommands` method. This method uses `switchMap` to project
    the results from the database into `getUnlinkCommands` and `getLinkCommands`.
    `Observable.of` is still used to take the array of commands and emit them one
    at a time. Creating and updating blog entries will now process all keyword linking
    and unlinked through the saga and keyword commands.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的saga只查询数据库中现有的关键字博客条目链接一次，`getUnlinkCommands`和`getLinkCommands`方法已经大大简化。这些方法现在接受事件和现有关键字博客条目链接列表，并返回需要执行的命令数组。检索现有关键字博客条目链接的繁重工作已经转移到`compileKeywordLinkCommands`方法。这个方法使用`switchMap`将数据库中的结果投影到`getUnlinkCommands`和`getLinkCommands`中。仍然使用`Observable.of`来逐个发出命令数组。现在，创建和更新博客条目将通过saga和关键字命令处理所有关键字链接和取消链接。
- en: '![CQRS Event Sagas Flow](img/CQRSFlow003.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![CQRS事件sagas流程](img/CQRSFlow003.png)'
- en: The above diagram provides a visual representation of how our new sagas hand
    off processing of database updates back to the command bus in the keyword module.
    Once an event to update keyword links is executed, the saga queries the database
    to determine the keywords to be linked and unlinked and finally returns the appropriate
    commands. Remember command handlers contain a callback method so it is not explicitly
    asynchronous. However, since they are called from the event bus, any response
    is never passed back to the sage or the entry command bus.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上图提供了一个视觉表示，展示了我们的新sagas如何将数据库更新的处理交还给关键字模块中的命令总线。一旦执行更新关键字链接的事件，saga会查询数据库以确定要链接和取消链接的关键字，最后返回适当的命令。请记住，命令处理程序包含一个回调方法，因此它并不是显式地异步的。然而，由于它们是从事件总线调用的，任何响应都不会传递回sage或入口命令总线。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: CQRS is not just a Nest.js package. It is a pattern for designing and laying
    out your application. It requires that you split the command, creation and update
    of data, from the query, the retrieving of data, and aspects of your application.
    For small applications, CQRS can add a lot of unnecessary complexity so it’s not
    for every application. For medium and large applications, CQRS can help break
    apart complex business logic into more manageable pieces.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS不仅仅是一个Nest.js的包。它是一种设计和布局应用程序的模式。它要求你将数据的命令、创建和更新与数据的查询以及应用程序的方面分开。对于小型应用程序，CQRS可能会增加许多不必要的复杂性，因此并非适用于每个应用程序。对于中型和大型应用程序，CQRS可以帮助将复杂的业务逻辑分解为更易管理的部分。
- en: Nest.js provides two means of implementing the CQRS pattern, the command and
    event bus, and with some sugar in the form of sagas. The command bus isolates
    command execution to each module meaning a command can only be executed in the
    same module it is registered. Command handlers are not always asynchronous and
    limits other parts of the application from reacting to change. For this, Nest.js
    provides the event bus. The event bus is not isolated to a single module and provides
    a way for different modules of the same application to react to events published
    by other modules. In fact, events can have any number of handlers allowing business
    logic to easily scale without changing the existing code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Nest.js提供了两种实现CQRS模式的方法，即命令总线和事件总线，以及一些saga形式的糖。命令总线将命令执行隔离到每个模块，这意味着命令只能在注册它的同一模块中执行。命令处理程序并不总是异步的，并且限制了应用程序的其他部分对变化的反应。因此，Nest.js提供了事件总线。事件总线不局限于单个模块，并提供了一种让同一应用程序的不同模块对其他模块发布的事件做出反应的方式。事实上，事件可以有任意数量的处理程序，使业务逻辑可以轻松扩展而无需更改现有代码。
- en: Sagas are a different way of reacting to events within a module. Sagas are simple
    function that listen for events on the event bus and react by returning a command
    to execute. While seemingly simple, sagas allow you to use the power of RxJS to
    determine if and how your application should react to events. As we did with our
    example application, sagas are not limited to returning just one or even one type
    of command.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Saga是对模块内部事件做出反应的一种不同方式。Saga是一个简单的函数，它监听事件总线上的事件，并通过返回要执行的命令来做出反应。虽然看似简单，但saga允许您利用RxJS的强大功能来确定应用程序对事件做出反应的方式。就像我们在示例应用程序中所做的那样，saga并不局限于仅返回一个或一种类型的命令。
- en: The next time you find yourself writing complex code to perform some business
    logic based on how the user is interacting with your application, consider giving
    the CQRS pattern a try. The complexity of the pattern may be offset by the complexity
    or eventual complexity of your applications business logic.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下次当您发现自己在编写复杂的代码来执行一些基于用户与应用程序交互的业务逻辑时，请考虑尝试使用CQRS模式。模式的复杂性可能会被应用程序业务逻辑的复杂性或最终复杂性所抵消。
- en: 'In the next chapter we examine the architecture for two different types of
    projects: A server application, and an app using `Angular universal` with Nest.js
    and Angular 6.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究两种不同类型项目的架构：一个服务器应用程序，以及一个使用`Angular universal`与Nest.js和Angular 6的应用程序。
