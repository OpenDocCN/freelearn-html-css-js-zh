- en: Introducing TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 TypeScript
- en: This book aims to provide you with a broad overview of TypeScript's features,
    its limitations, and its ecosystem. You will learn about the TypeScript language,
    development tools, design patterns, and recommended practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在为您提供 TypeScript 的功能、其限制和其生态系统的广泛概述。您将了解 TypeScript 语言、开发工具、设计模式和推荐实践。
- en: This chapter will give you an overview of the history behind TypeScript and
    introduce you to some of its basics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您概述 TypeScript 的历史，并介绍其一些基础知识。
- en: 'In this chapter, you will learn about the following concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下概念：
- en: The TypeScript architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 架构
- en: Type annotations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型注释
- en: Variables and primitive data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和原始数据类型
- en: Operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: Flow control statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程控制语句
- en: Functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Interfaces
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Namespaces
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: The TypeScript architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 架构
- en: In this section, we will focus on TypeScript's internal architecture and its
    original design goals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注 TypeScript 的内部架构和其原始设计目标。
- en: Design goals
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计目标
- en: 'The following list describes the main design goals and architectural decisions
    that shaped the way the TypeScript programming language looks today:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了主要的设计目标和架构决策，这些决策塑造了 TypeScript 编程语言今天的外观：
- en: '**Statically identify JavaScript constructs that are likely to be errors**:
    The engineers at Microsoft decided that the best way to identify and prevent potential
    runtime issues was to create a strongly-typed programming language and perform
    static type checking at compile time. The engineers also designed a language services
    layer to provide developers with better tools.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态识别可能产生错误的 JavaScript 构造**：微软的工程师决定，识别和防止潜在运行时问题的最佳方式是创建一个强类型编程语言，并在编译时进行静态类型检查。工程师还设计了一个语言服务层，为开发者提供更好的工具。'
- en: '**High compatibility with existing JavaScript code**: TypeScript is a superset
    of JavaScript; this means that any valid JavaScript program is also a valid TypeScript
    program (with a few small exceptions).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与现有 JavaScript 代码高度兼容**：TypeScript 是 JavaScript 的超集；这意味着任何有效的 JavaScript
    程序也是有效的 TypeScript 程序（有一些小的例外）。'
- en: '**Provide a structuring mechanism for larger pieces of code**: TypeScript adds
    class-based object-orientation, interfaces, namespaces, and modules. These features
    will help us to structure our code in a much better way. We will also reduce potential
    integration issues within our development team and our code will become easier
    to maintain and scale by adhering to the best object-oriented principles and recommended
    practices.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为较大的代码块提供结构化机制**：TypeScript 添加了基于类的面向对象、接口、命名空间和模块等功能。这些特性将帮助我们以更好的方式结构化代码。我们还将通过遵循最佳面向对象原则和推荐实践来减少开发团队内部潜在集成问题，并使代码更容易维护和扩展。'
- en: '**Impose no runtime overhead on emitted programs**: It is common to differentiate
    between design time and execution time when thinking about TypeScript. We use
    the term *design time* or *compile time* to refer to the TypeScript code that
    we write while designing an application, while we use the term *execution time*
    or *runtime* to refer to the JavaScript code executed after compiling some TypeScript
    code.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不对输出程序产生运行时开销**：在考虑 TypeScript 时，区分设计时间和执行时间是常见的。我们使用术语 *设计时间* 或 *编译时间* 来指代我们在设计应用程序时编写的
    TypeScript 代码，而使用术语 *执行时间* 或 *运行时* 来指代编译某些 TypeScript 代码后执行的 JavaScript 代码。'
- en: TypeScript adds some features to JavaScript, but those features are only available
    at design time. For example, we can declare interfaces in TypeScript, but since
    JavaScript doesn't support interfaces, the TypeScript compiler will not declare
    or try to emulate this feature at runtime (in the output JavaScript code).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 为 JavaScript 添加了一些功能，但这些功能仅在设计时可用。例如，我们可以在 TypeScript 中声明接口，但由于 JavaScript
    不支持接口，TypeScript 编译器在运行时（在输出 JavaScript 代码中）不会声明或尝试模拟此功能。
- en: The Microsoft engineers provided the TypeScript compiler with some mechanisms,
    such as **code transformations** (converting TypeScript features into plain JavaScript
    implementations) and **type erasure** (removing static type notation), to generate
    clean JavaScript code. Type erasure removes not only the type annotations, but
    also all the TypeScript-exclusive language features such as interfaces.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 微软工程师为 TypeScript 编译器提供了一些机制，例如**代码转换**（将 TypeScript 特性转换为纯 JavaScript 实现）和**类型擦除**（移除静态类型注释），以生成干净的
    JavaScript 代码。类型擦除不仅移除了类型注释，还移除了 TypeScript 独有的所有语言特性，如接口。
- en: Furthermore, the generated code is highly compatible with web browsers as it
    targets the ECMAScript 3 specification by default, but it also supports ECMAScript
    5 and ECMAScript 6\. In general, we can use the TypeScript features when compiling
    to any of the available compilation targets, but sometimes some features will
    require ECMAScript 5 or a higher version as the compilation target.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，生成的代码与网络浏览器高度兼容，因为它默认针对 ECMAScript 3 规范，但也支持 ECMAScript 5 和 ECMAScript 6。一般来说，我们可以在编译到任何可用的编译目标时使用
    TypeScript 功能，但有时某些功能可能需要 ECMAScript 5 或更高版本作为编译目标。
- en: '**Align with current and future ECMAScript proposals**: TypeScript is not just
    compatible with existing JavaScript code; it is also compatible with some future
    versions of JavaScript. At first glance, we may think that some TypeScript features
    make it quite different from JavaScript, but the reality is that all the features
    available in TypeScript (except the type system features) follow the ECMAScript
    proposals, which means that many of the TypeScript files will eventually be available
    as native JavaScript features.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与当前和未来的 ECMAScript 提案保持一致**：TypeScript 不仅与现有的 JavaScript 代码兼容；它还与一些未来的 JavaScript
    版本兼容。乍一看，我们可能会认为一些 TypeScript 功能使其与 JavaScript 相差甚远，但实际情况是，TypeScript 中可用的所有功能（除了类型系统功能）都遵循
    ECMAScript 提案，这意味着许多 TypeScript 文件最终将成为原生 JavaScript 功能。'
- en: '**Be a cross-platform development tool**: Microsoft released TypeScript under
    the open source Apache license and it can be installed and executed in all major
    operating systems.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成为跨平台开发工具**：微软在 Apache 许可下发布了 TypeScript，它可以在所有主要操作系统上安装和执行。'
- en: TypeScript components
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 组件
- en: 'The TypeScript language has three main internal layers. Each of these layers
    is, in turn, divided into sublayers or components. In the following diagram, we
    can see the three layers (three different shades of gray) and each of their internal
    components (boxes):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 语言有三个主要的内部层。每一层又依次分为子层或组件。在下面的图中，我们可以看到这三个层（三种不同灰度的层次）以及它们各自的内部组件（方框）：
- en: '![](img/7a5b02ad-cdc4-4ec9-a3cb-2982bb15ef2f.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a5b02ad-cdc4-4ec9-a3cb-2982bb15ef2f.png)'
- en: In the preceding diagram, the acronym **VS** refers to Microsoft's Visual Studio,
    which is the official family of **integrated development environments** (**IDEs**)
    for all Microsoft products (including TypeScript). We will learn more about this
    and the other IDEs in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，缩写**VS**指的是微软的 Visual Studio，它是所有微软产品（包括 TypeScript）的官方**集成开发环境**（**IDE**）系列。我们将在第
    9 章*自动化您的开发工作流程*中了解更多关于这个和其他 IDE 的信息。[第 9 章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)。
- en: 'Each of these main layers has a different purpose:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个主要层都有不同的用途：
- en: '**Language**: Features the TypeScript language elements.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言**：包含 TypeScript 语言元素。'
- en: '**Compiler** Performs the parsing, type checking, and transformation of your
    TypeScript code to JavaScript code.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器**负责解析、类型检查和将您的 TypeScript 代码转换为 JavaScript 代码。'
- en: '**Language services**: Generates information that helps editors and other tools
    provide better assistance features, such as IntelliSense or automated refactoring.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言服务**：生成信息，帮助编辑器和其他工具提供更好的辅助功能，例如 IntelliSense 或自动化重构。'
- en: '**IDE integration (VS Shim)**: The developers of the IDEs and text editors
    must perform some integration work to take advantage of the TypeScript features.
    TypeScript was designed to facilitate the development of tools that help to increase
    the productivity of JavaScript developers. Because of these efforts, integrating
    TypeScript with an IDE is not a complicated task. A proof of this is that the
    most popular IDEs these days include good TypeScript support.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDE 集成（VS Shim）**：IDE 和文本编辑器的开发者必须进行一些集成工作，以利用 TypeScript 功能。TypeScript 被设计用来促进开发帮助提高
    JavaScript 开发者生产力的工具。由于这些努力，将 TypeScript 与 IDE 集成并不复杂。这一点的证明是，目前最流行的 IDE 都包括良好的
    TypeScript 支持。'
- en: In other books and online resources, you may find references to the term *transpiler*
    instead of *compiler*. A **transpiler** is a type of compiler that takes the source
    code of a programming language as its input and outputs the source code into another
    programming language with a similar level of abstraction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他书籍和在线资源中，您可能会找到将术语*transpiler*而不是*compiler*的引用。**transpiler**是一种编译器，它将编程语言的源代码作为输入，并将源代码输出为具有相似抽象级别的另一种编程语言的源代码。
- en: We will learn more about the TypeScript language services and the TypeScript
    compiler in [Chapter 15](9cc3e5f2-72c1-4f3c-9ed8-ba2760eae2d8.xhtml), *Working
    with the TypeScript Compiler and the Language Services*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 15 章 [Chapter 15](9cc3e5f2-72c1-4f3c-9ed8-ba2760eae2d8.xhtml) 中学习更多关于
    TypeScript 语言服务和 TypeScript 编译器的内容，*使用 TypeScript 编译器和语言服务*。
- en: TypeScript language features
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 语言特性
- en: Now that you have learned about the purpose of TypeScript, it's time to get
    our hands dirty and start writing some code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 TypeScript 的用途，是时候动手编写一些代码了。
- en: 'Before you can start learning how to use some of the basic TypeScript building
    blocks, you will need to set up your development environment. The easiest and
    fastest way to start writing some TypeScript code is to use the online editor,
    available on the official TypeScript website at [https://www.typescriptlang.org/play/index.html](https://www.typescriptlang.org/play/index.html):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '在你开始学习如何使用一些基本的 TypeScript 构建块之前，你需要设置你的开发环境。开始编写一些 TypeScript 代码最简单、最快的方式是使用在线编辑器，它可以在
    TypeScript 官方网站上找到，网址为 [https://www.typescriptlang.org/play/index.html](https://www.typescriptlang.org/play/index.html):'
- en: '![](img/683b2ade-87db-499a-97f6-9dc9f1743a7c.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/683b2ade-87db-499a-97f6-9dc9f1743a7c.png)'
- en: The preceding screenshot shows the appearance of the TypeScript playground.
    If you visit the playground, you will be able to use the text editor on the left-hand
    side of the screen to write TypeScript code. The code will then be automatically
    compiled into JavaScript. The output code will be inserted in the text editor
    located on the right-hand side of the screen. If your TypeScript code is invalid,
    the JavaScript code on the right-hand side will not be updated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了 TypeScript 操场的样子。如果你访问操场，你将能够使用屏幕左侧的文本编辑器编写 TypeScript 代码。然后代码将被自动编译成
    JavaScript。输出代码将被插入到屏幕右侧的文本编辑器中。如果你的 TypeScript 代码无效，右侧的 JavaScript 代码将不会更新。
- en: Alternatively, if you prefer to be able to work offline, you can download and
    install the TypeScript compiler. If you work with a Visual Studio version older
    than Visual Studio 2015, you will need to download the official TypeScript extension
    from [https://marketplace.visualstudio.com/](https://marketplace.visualstudio.com/).
    If you are working with a version of Visual Studio released after the 2015 version
    (or Visual Studio Code), you will not need to install the extension, as these
    versions includes TypeScript support by default.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你更喜欢能够离线工作，你可以下载并安装 TypeScript 编译器。如果你使用的是 Visual Studio 2015 之前的版本，你需要从
    [https://marketplace.visualstudio.com/](https://marketplace.visualstudio.com/)
    下载官方 TypeScript 扩展。如果你使用的是 2015 版本之后的 Visual Studio 版本（或 Visual Studio Code），你不需要安装扩展，因为这些版本默认包含
    TypeScript 支持。
- en: There are TypeScript plugins available for many popular editors such as Sublime
    ([https://github.com/Microsoft/TypeScript-Sublime-Plugin](https://github.com/Microsoft/TypeScript-Sublime-Plugin))
    or Atom ([https://atom.io/packages/atom-typescript](https://atom.io/packages/atom-typescript)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的编辑器，如 Sublime ([https://github.com/Microsoft/TypeScript-Sublime-Plugin](https://github.com/Microsoft/TypeScript-Sublime-Plugin))
    或 Atom ([https://atom.io/packages/atom-typescript](https://atom.io/packages/atom-typescript))，都提供了
    TypeScript 插件。
- en: You can also use TypeScript from the command-line interface by downloading it
    as an `npm` module. Don't worry if you are not familiar with npm. For now, you
    only need to know that it stands for **node package manager** and is the default
    Node.js package manager. Node.js is an open source, cross-platform JavaScript
    runtime environment for executing JavaScript code server-side. To be able to use
    npm, you will need to install Node.js in your development environment. You will
    be able to find the Node.js installation files on the official website at [https://nodejs.org/](https://nodejs.org/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过将其作为 `npm` 模块下载来从命令行界面使用 TypeScript。如果你不熟悉 npm，不要担心。现在，你只需要知道它代表 **node
    package manager**，是 Node.js 的默认包管理器。Node.js 是一个开源的、跨平台的 JavaScript 运行时环境，用于在服务器端执行
    JavaScript 代码。要能够使用 npm，你需要在你的开发环境中安装 Node.js。你可以在官方网站 [https://nodejs.org/](https://nodejs.org/)
    上找到 Node.js 的安装文件。
- en: 'Once you have installed Node.js in your development environment, you will be
    able to run the following command in a console or Terminal:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在你的开发环境中安装了 Node.js，你将能够在控制台或终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unix-based operating systems may require the use of the `sudo` command when
    installing global (`-g`) npm packages. The `sudo` command will prompt the user
    credentials and install the package using administrative privileges:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Unix 的操作系统在安装全局（`-g`）npm 包时可能需要使用 `sudo` 命令。`sudo` 命令将提示用户输入凭证，并使用管理员权限安装包：
- en: '`sudo npm install -g typescript`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo npm install -g typescript`'
- en: 'Create a new file named `test.ts`, and add the following code to it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `test.ts` 的新文件，并将以下代码添加到其中：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save the file into a directory of your choice and open a command-line interface.
    Navigate to the directory in which you saved the file and execute the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存到您选择的目录中，并打开命令行界面。导航到保存文件的目录，并执行以下命令：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If everything goes well, you will find a file named `test.js` in the same directory
    in which the `test.ts` file is located. Now you know how to compile your TypeScript
    code into JavaScript code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将在 `test.ts` 文件所在的同一目录中找到一个名为 `test.js` 的文件。现在您已经知道如何将 TypeScript 代码编译成
    JavaScript 代码。
- en: 'You can execute the output JavaScript code using Node.js:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Node.js 执行输出 JavaScript 代码：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we know how to compile and execute TypeScript source code, we can start
    learning about some of the TypeScript features.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何编译和执行 TypeScript 源代码，我们可以开始学习一些 TypeScript 的特性。
- en: You will be able to learn more about editors, compiler options, and other TypeScript
    tools in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)*,* *Automating
    Your Development Workflow*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 [第 9 章](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)*自动化您的开发工作流程*中了解更多关于编辑器、编译器选项和其他
    TypeScript 工具的信息。
- en: Types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: As we have already learned, TypeScript is a typed superset of JavaScript. TypeScript
    added a static type system and optional static type annotations to JavaScript
    to transform it into a strongly-typed programming language.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，TypeScript 是 JavaScript 的一个类型超集。TypeScript 通过添加静态类型系统和可选的静态类型注解到 JavaScript
    中，将其转换为一个强类型编程语言。
- en: TypeScript's type analysis occurs entirely at compile time and adds no runtime
    overhead to program execution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的类型分析完全在编译时进行，不会给程序执行增加运行时开销。
- en: Type inference and optional static type annotations
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断和可选的静态类型注解
- en: The TypeScript language service is great at automatically detecting the type
    of a variable. However, there are certain cases where it is not able to automatically
    detect a type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 语言服务在自动检测变量的类型方面做得很好。然而，在某些情况下，它无法自动检测类型。
- en: When the type inference system is not able to identify the type of a variable,
    it uses a type known as the *any* type. The any type is a value that represents
    all the existing types, and as a result, it is too flexible and unable to detect
    most errors, which is not a problem because TypeScript allows us to explicitly
    declare the type of a variable using what is known as **optional static type annotations**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型推断系统无法识别变量的类型时，它使用一个称为 *any* 类型的类型。any 类型代表所有现有的类型，因此它过于灵活，无法检测大多数错误，这不是问题，因为
    TypeScript 允许我们使用所谓的 **可选的静态类型注解**显式声明变量的类型。
- en: The optional static type annotations are used as constraints on program entities
    such as functions, variables, and properties so that compilers and development
    tools can offer better verification and assistance (such as IntelliSense) during
    software development.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的静态类型注解被用作对程序实体（如函数、变量和属性）的约束，以便编译器和开发工具在软件开发期间提供更好的验证和辅助（如 IntelliSense）。
- en: Strong typing allows programmers to express their intentions in their code,
    both to themselves and to others in the development team.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型允许程序员在代码中表达他们的意图，既是对自己，也是对开发团队中的其他人。
- en: 'For a variable, a type notation comes preceded by a colon after the name of
    a variable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个变量，类型注解位于变量名称之后的冒号之前：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have used the `let` keyword instead of the `var` keyword. The `let` keyword
    is a newer JavaScript construct that TypeScript makes available. We'll discuss
    the details later, but some common problems in JavaScript can be solved by using
    `let`, so, you should use `let` instead of `var` whenever possible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `let` 关键字而不是 `var` 关键字。`let` 关键字是 TypeScript 提供的一个较新的 JavaScript 构造。我们稍后会讨论细节，但使用
    `let` 可以解决 JavaScript 中的一些常见问题，因此，在可能的情况下，您应该使用 `let` 而不是 `var`。
- en: As you can see, we declare the type of a variable after its name; this style
    of type notation is based on type theory and helps to reinforce the idea of types
    being optional.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在变量名之后声明变量的类型；这种类型表示法风格基于类型理论，有助于加强类型是可选的观点。
- en: When no type annotations are available, TypeScript will try to guess the type
    of the variable by examining the assigned values. For example, in the second line,
    in the preceding code snippet, we can see that the variable counter has been identified
    as a numeric variable, because its value is a numeric value. There is a process
    known as **type inference** that can automatically detect and assign a type to
    a variable. The any type is used as the type of a variable when the type inference
    system is not able to detect its type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有类型注解可用时，TypeScript 会通过检查分配的值来尝试猜测变量的类型。例如，在第二行，在前面代码片段中，我们可以看到变量 counter
    被识别为数值变量，因为它的值是数值。有一个称为 **类型推断** 的过程可以自动检测并分配一个类型给变量。当类型推断系统无法检测其类型时，将使用 `any`
    类型作为变量的类型。
- en: 'Please note that the companion source code might be slightly different from
    the code presented during the chapters. The companion source code uses namespaces
    to isolate each demo from all the other demos and sometimes appends numbers to
    the name of the variables to prevent naming conflicts. For example, the preceding
    code is included in the companion source code as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，配套源代码可能与章节中展示的代码略有不同。配套源代码使用命名空间来隔离每个演示与其他所有演示，有时还会在变量名后附加数字以防止命名冲突。例如，前面的代码包含在配套源代码中如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will be able to learn more about the TypeScript type system in [Chapter
    2](7211d7ea-dc2f-4ff0-bb19-14400bb911bc.xhtml), *Working with Types*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 [第 2 章](7211d7ea-dc2f-4ff0-bb19-14400bb911bc.xhtml)，*与类型一起工作* 中了解更多关于 TypeScript
    类型系统的信息。
- en: Variables, basic types, and operators
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量、基本类型和运算符
- en: 'The basic types are boolean, number, string, array, tuple, Object, object,
    null, undefined, {}, void, and enumerations. Let''s learn about each of these
    basic types:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型包括布尔值、数字、字符串、数组、元组、对象、空对象、`null`、`undefined`、`{}`、`void` 和枚举。让我们了解这些基本类型中的每一个：
- en: '| **Data type** | **Description** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **描述** |'
- en: '| Boolean | Whereas the string and number data types can have a virtually unlimited
    number of different values, the boolean data type can only have two. They are
    the literals: `true` and `false`. A boolean value is a truth value; it specifies
    whether the condition is true or not:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '| 布尔值 | 与字符串和数字数据类型可以有几乎无限数量的不同值不同，布尔数据类型只能有两个。它们是文字：`true` 和 `false`。布尔值是一个真值；它指定条件是真是假：'
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Number | As in JavaScript, all numbers in TypeScript are floating-point values.
    These floating-point numbers get the type `number`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '| 数字 | 与 JavaScript 一样，TypeScript 中的所有数字都是浮点值。这些浮点数具有 `number` 类型：'
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| String | We use the `string` data type to represent text in TypeScript. You
    include string literals in your scripts by enclosing them in single or double
    quotation marks. Double quotation marks can be contained in strings surrounded
    by single quotation marks and single quotation marks can be contained in strings
    surrounded by double quotation marks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '| 字符串 | 在 TypeScript 中，我们使用 `string` 数据类型来表示文本。您可以通过将字符串文字用单引号或双引号括起来来在脚本中包含字符串文字。双引号可以包含在单引号包围的字符串中，单引号可以包含在双引号包围的字符串中：'
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Array | We use the `array` data type to represent a collection of values.
    The `array` type can be written using two different syntax styles. We can use
    the type of the elements in the array followed by brackets `[]` to annotate a
    collection of that element type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| 数组 | 我们使用 `array` 数据类型来表示值的集合。`array` 类型可以使用两种不同的语法风格来编写。我们可以使用数组中元素的类型，后跟方括号
    `[]` 来注释该元素类型的集合：'
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second syntax style uses a generic array type named `Array<T>`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种语法风格使用名为 `Array<T>` 的泛型数组类型：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Tuple | Tuple types can be used to represent an array with a fixed number
    of elements with different types where the type is known. For example, we can
    represent a value as a pair of a string and a number:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '| 元组 | 元组类型可用于表示具有已知不同类型的固定数量元素的数组。例如，我们可以将一个值表示为一个字符串和数字的配对：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Enum | We use enumerations to add more meaning to a set of values. Enumerations
    can be numeric or text-based. By default, numeric enumerations assign the value
    0 to the first member in the enumeration and increase it by one for each of the
    members in the enumeration:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '| 枚举 | 我们使用枚举为值集添加更多意义。枚举可以是数字或基于文本的。默认情况下，数字枚举将值 0 分配给枚举中的第一个成员，并为枚举中的每个成员增加
    1：'
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Any | All types in TypeScript are subtypes of a single top type called the
    **any** **type**. The `any` keyword references this type. The any type eliminates
    most of the TypeScript type checks and represents all the possible types:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '| Any | TypeScript 中的所有类型都是单个顶级类型 `**any** **type**` 的子类型。`any` 关键字引用了这个类型。`any`
    类型消除了大多数 TypeScript 类型检查，并代表所有可能的类型：'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `any` type can be useful while migrating existing JavaScript code to TypeScript,
    or when we know some details about a type but we don''t know all its details.
    For example, when we know that a type is an array, but we don''t know the type
    of the elements in such an array:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 类型在将现有的 JavaScript 代码迁移到 TypeScript 或当我们对某个类型的某些细节有所了解但不知道所有细节时非常有用。例如，当我们知道一个类型是数组，但我们不知道数组中元素的类型时：'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| object (lowercase) | The `object` type represents any non-primitive type.
    The following types are considered to be primitive types in JavaScript: boolean,
    number, string, symbol, null, and undefined. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 对象（小写） | `object` 类型代表任何非原始类型。以下类型在 JavaScript 中被认为是原始类型：布尔值、数字、字符串、符号、null
    和 undefined。|'
- en: '| Object (uppercase) | In JavaScript, all objects are derived from the `Object`
    class. `Object` (uppercase) describes functionality that is common to all JavaScript
    objects. That includes the `toString()` and the `hasOwnProperty()` methods, for
    example. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 对象（大写） | 在 JavaScript 中，所有对象都是 `Object` 类的派生。`Object`（大写）描述了所有 JavaScript
    对象共有的功能。这包括 `toString()` 和 `hasOwnProperty()` 方法等。|'
- en: '| Empty object type {} | This describes an object that has no members of its
    own. TypeScript issues a compile-time error when you try to access arbitrary properties
    of such an object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '| 空对象类型 `{}` | 这描述了一个没有任何自身成员的对象。当你尝试访问此类对象的任意属性时，TypeScript 会发出编译时错误：'
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Null and undefined | In TypeScript, both undefined and null are types. By
    default, null and undefined are subtypes of all other types. That means you can
    assign null and undefined to something like a number.However, when using the `--strictNullChecks`
    flag, null and undefined are only assignable to void and their respective types.
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| Null 和 undefined | 在 TypeScript 中，undefined 和 null 都是类型。默认情况下，null 和 undefined
    是所有其他类型的子类型。这意味着你可以将 null 和 undefined 赋值给类似数字的东西。然而，当使用 `--strictNullChecks` 标志时，null
    和 undefined 只能赋值给 void 和它们各自的类型。'
- en: '| Never | The `never` type is used in the following two places:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '| Never 类型 | `never` 类型在以下两个地方使用：'
- en: As the return type of functions that never return
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为永远不会返回的函数的返回类型
- en: As the type of variables under type guards that are never true
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为永远不会为真的类型守卫下的变量类型
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Void | In some ways the opposite of `any` is  `void`, the absence of having
    any type at all. You will see this as the return type of functions that do not
    return a value:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '| Void | 在某些方面，`any` 的对立面是 `void`，即没有任何类型的缺失。你将看到这是不返回值的函数的返回类型：'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In TypeScript and JavaScript, undefined is a property in the global scope that
    is assigned as a value to variables that have been declared but have not yet been
    initialized. The value `null` is a literal (not a property of the global object)
    and it can be assigned to a variable as a representation of no value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 和 JavaScript 中，undefined 是全局作用域中的一个属性，它被分配给已声明但尚未初始化的变量。值 `null`
    是一个字面量（不是全局对象的属性），它可以被分配给变量，作为没有值的表示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Variable scope (var, let, and const)
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量作用域（var, let 和 const）
- en: 'When we declare a variable in TypeScript, we can use the `var`, `let`, or `const`
    keywords:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 TypeScript 中声明一个变量时，我们可以使用 `var`、`let` 或 `const` 关键字：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Variables declared with `var` are scoped to the nearest function block (or global,
    if outside a function block).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 声明的变量作用域是最近的函数块（或全局，如果不在函数块中）。
- en: Variables declared with `let` are scoped to the nearest enclosing block (or
    global, if outside any block), which can be smaller than a function block.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `let` 声明的变量作用域是最近的封闭块（或全局，如果不在任何块中），这可以小于函数块。
- en: The `const` keyword creates a constant that can be global or local to the block
    in which it is declared. This means that constants are block-scoped.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 关键字创建了一个可以是全局的或局部于其声明块的常量。这意味着常量是块作用域的。'
- en: You will learn more about scopes in [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime.*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 [第 6 章](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml) 中了解更多关于作用域的内容，*理解运行时*。
- en: Arithmetic operators
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '| 算术运算符'
- en: 'TypeScript supports the following arithmetic operators. We must assume that
    variable `A` holds `10` and variable `B` holds `20` to understand the following
    examples:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持以下算术运算符。我们必须假设变量 `A` 包含 `10`，变量 `B` 包含 `20`，以理解以下示例：
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** |'
- en: '| `-` | Subtracts the second operand from the first. | *A - B* will give `-10`
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 从第一个操作数中减去第二个操作数。 | *A - B* 将给出 `-10` |'
- en: '| `+` | Adds two operands. | *A + B* will give `30` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 将两个操作数相加。 | *A + B* 将给出 `30` |'
- en: '| `*` | Multiplies both the operands. | *A * B* will give `200` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘以两个操作数。 | *A * B* 将给出 `200` |'
- en: '| `**` | Multiplies the first operand by itself a number of times which is
    indicated by the second operand. | *A ** B* will give *1e+20* |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `**` | 将第一个操作数乘以自身，次数由第二个操作数指示。 | *A ** B* 将给出 *1e+20* |'
- en: '| `%` | This is the modulus operator and remainder after an integer division.
    | *B % A* will give `0` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 这是取模运算符，是整数除法后的余数。 | *B % A* 将给出 `0` |'
- en: '| `/` | Divides the numerator by the denominator. | *B / A* will give `2` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 将分子除以分母。 | *B / A* 将给出 `2` |'
- en: '| `--` | Decreases an integer value by one. | *A--* will give `9` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `--` | 将整数值减一。 | *A--* 将给出 `9` |'
- en: '| `++` | Increases an integer value by one. | *A++* will give `11` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `++` | 将整数值加一。 | *A++* 将给出 `11` |'
- en: Comparison operators
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '| 比较运算符'
- en: 'TypeScript supports the following comparison operators. To understand the examples,
    you must assume that variable `A` holds `10` as value and variable `B` holds `20`
    as value:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持以下比较运算符。为了理解示例，你必须假设变量 `A` 的值为 `10`，变量 `B` 的值为 `20`：
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** |'
- en: '| `==` | Checks whether the values of two operands are equal or not. This operator
    uses type coercion. If yes, then the condition becomes `true`. | *(A == B)* is
    false. A == "10" is true. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 检查两个操作数的值是否相等。此运算符使用类型强制转换。如果相等，则条件变为 `true`。 | *(A == B)* 是 `false`。A
    == "10" 是 `true`。 |'
- en: '| `===` | Checks whether the value and type of two operands are equal or not.
    This operator doesn''t use type coercion. If yes, then the condition becomes `true`.
    | A === B is false. A === "10" is false. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `===` | 检查两个操作数的值和类型是否相等。此运算符不使用类型强制转换。如果相等，则条件变为 `true`。 | A === B 是 `false`。A
    === "10" 是 `false`。 |'
- en: '| `!=` | Checks whether the value of two operands are equal or not. If the
    values are not equal, then the condition becomes `true`. This operator uses type
    coercion. | (A != B) is true. A != "10" is false. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 检查两个操作数的值是否相等。如果不相等，则条件变为 `true`。此运算符使用类型强制转换。 | (A != B) 是 `true`。A
    != "10" 是 `false`。 |'
- en: '| `!==` | Checks whether the value of two operands are equal or not. If the
    values are not equal, then the condition becomes `true`. This operator doesn''t
    use type coercion. | A !== B is true. A !== "10" is true. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `!==` | 检查两个操作数的值是否相等。如果不相等，则条件变为 `true`。此运算符不使用类型强制转换。 | A !== B 是 `true`。A
    !== "10" 是 `true`。 |'
- en: '| `>` | Checks whether the value of the left operand is greater than the value
    of the right operand. If yes, then the condition becomes `true`. | (A > B) is
    false. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 检查左操作数的值是否大于右操作数的值。如果是，则条件变为 `true`。 | (A > B) 是 `false`。 |'
- en: '| `<` | Checks whether the value of the left operand is less than the value
    of the right operand. If yes, then the condition becomes `true`. | (A < B) is
    true. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 检查左操作数的值是否小于右操作数的值。如果是，则条件变为 `true`。 | (A < B) 是 `true`。 |'
- en: '| `>=` | Checks whether the value of the left operand is greater than or equal
    to the value of the right operand. If yes, then the condition becomes `true`.
    | (A >= B) is false. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 检查左操作数的值是否大于或等于右操作数的值。如果是，则条件变为 `true`。 | (A >= B) 是 `false`。 |'
- en: '| `<=` | Checks whether the value of the left operand is less than or equal
    to the value of the right operand. If yes, then the condition becomes `true`.
    | (A <= B) is true. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 检查左操作数的值是否小于或等于右操作数的值。如果是，则条件变为 `true`。 | (A <= B) 是 `true`。 |'
- en: Logical operators
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '| 逻辑运算符'
- en: 'TypeScript supports the following logical operators. To understand the examples,
    you must assume that variable `A` holds `10` and variable `B` holds `20`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持以下逻辑运算符。为了理解示例，你必须假设变量 `A` 包含 `10`，变量 `B` 包含 `20`：
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** |'
- en: '| `&&` | Known as the logical `AND` operator. If both the operands are nonzero,
    then the condition becomes `true`. | (A && B) is true. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 被称为逻辑“与”操作符。如果两个操作数都不为零，则条件变为“真”。| (A && B) 是 true. |'
- en: '| `&#124;&#124;` | Known as the logical `OR` operator. If any of the two operands
    are nonzero, then the condition becomes `true`. | (A &#124;&#124; B) is true.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 被称为逻辑“或”操作符。如果两个操作数中的任何一个不为零，则条件变为“真”。| (A &#124;&#124;
    B) 是 true. |'
- en: '| `!` | Known as the logical `NOT` operator. It is used to reverse the logical
    state of its operand. If a condition is `true`, then the logical `NOT` operator
    will make it `false`. | !(A && B) is false. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 被称为逻辑“非”操作符。它用于反转其操作数的逻辑状态。如果条件为“真”，则逻辑“非”操作符将使其变为“假”。| !(A && B) 是
    false. |'
- en: Bitwise operators
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'TypeScript supports the following bitwise operators. To understand the examples,
    you must assume that variable `A` holds `2` as value and variable `B` holds `3`
    as value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持以下位运算符。要理解这些示例，你必须假设变量 `A` 的值为 `2`，变量 `B` 的值为 `3`：
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** |'
- en: '| `&` | Known as the bitwise `AND` operator, it performs a boolean `AND` operation
    on each bit of its integer arguments. | (A & B) is 2 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 被称为位运算符的“与”操作符，它对其整数参数的每个位执行布尔“与”操作。| (A & B) 是 2 |'
- en: '| `&#124;` | Known as the bitwise `OR` operator, it performs a boolean `OR`
    operation on each bit of its integer arguments. | (A &#124; B) is 3. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 被称为位运算符的“或”操作符，它对其整数参数的每个位执行布尔“或”操作。| (A &#124; B) 是 3. |'
- en: '| `^` | Known as the bitwise `XOR` operator, it performs a boolean exclusive
    `OR` operation on each bit of its integer arguments. Exclusive `OR` means that
    either operand one is true or operand two is true, but not both. | (A ^ B) is
    1. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 被称为位运算符的“异或”操作符，它对其整数参数的每个位执行布尔独占“或”操作。独占“或”意味着操作数一为真或操作数二为真，但不能同时为真。|
    (A ^ B) 是 1. |'
- en: '| `~` | Known as the bitwise `NOT` operator, it is a unary operator and operates
    by reversing all bits in the operand. | (~B) is -4 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 被称为位运算符的“非”操作符，它是一个一元操作符，通过反转操作数中的所有位来操作。| (~B) 是 -4 |'
- en: '| `<<` | Known as the bitwise shift-left operator. It moves all bits in its
    first operand to the left by the number of places specified in the second operand.
    New bits are filled with zeros. Shifting a value left by one position is equivalent
    to multiplying by two, shifting two positions is equivalent to multiplying by
    four, and so on. | (A << 1) is 4 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 被称为位运算符左移操作符。它将其第一个操作数的所有位向左移动由第二个操作数指定的位数。新位用零填充。将值左移一位相当于乘以二，左移两位相当于乘以四，依此类推。|
    (A << 1) 是 4 |'
- en: '| `>>` | Known as the bitwise shift-right with sign operator. It moves all
    bits in its first operand to the right by the number of places specified in the
    second operand. | (A >> 1) is 1 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 被称为带符号的位运算符右移操作符。它将其第一个操作数的所有位向右移动由第二个操作数指定的位数。| (A >> 1) 是 1 |'
- en: '| `>>>` | Known as the bitwise shift-right with zero operators. This operator
    is just like the `>>` operator, except that the bits shifted from the left are
    always zero. | (A >>> 1) is 1 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `>>>` | 被称为带零的位运算符右移操作符。这个操作符与 `>>` 操作符类似，但左移出的位总是零。| (A >>> 1) 是 1 |'
- en: One of the main reasons to use bitwise operators in languages such as C++, Java,
    or C# is that they're extremely fast. However, bitwise operators are often considered
    not that efficient in TypeScript and JavaScript. The bitwise operators are less
    efficient in JavaScript, because it is necessary to cast from floating-point representation
    (how JavaScript stores all of its numbers) to a 32-bit integer to perform the
    bit manipulation and back.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++、Java 或 C# 等语言中使用位运算符的主要原因是它们非常快。然而，位运算符通常被认为在 TypeScript 和 JavaScript
    中并不那么高效。JavaScript 中的位运算符效率较低，因为必须将浮点表示（JavaScript 存储所有数字的方式）转换为 32 位整数以执行位操作，然后再转换回来。
- en: Assignment operators
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'TypeScript supports the following assignment operators:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 支持以下赋值运算符：
- en: '| **Operator** | **Description** | **Example** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** | **示例** |'
- en: '| `=` | Assigns the values from the right-side operands to the left-side operand.
    | C = A + B will assign the value of A + B into C |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 将右侧操作数的值赋给左侧操作数。| C = A + B 将 A + B 的值赋给 C |'
- en: '| `+=` | Adds the right operand to the left operand and assigns the result
    to the left operand. | C += A is equivalent to C = C + A |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `+=` | 将右操作数加到左操作数上，并将结果赋值给左操作数。| C += A 等价于 C = C + A |'
- en: '| `-=` | Substracts the right operand from the left operand and assigns the
    result to the left operand. | C -= A is equivalent to C = C - A |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `-=` | 从左侧操作数减去右侧操作数，并将结果赋值给左侧操作数。 | C -= A 等价于 C = C - A |'
- en: '| `*=` | Multiplies the right operand by the left operand and assigns the result
    to the left operand. | C *= A is equivalent to C = C * A |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `*=` | 将右侧操作数乘以左侧操作数，并将结果赋值给左侧操作数。 | C *= A 等价于 C = C * A |'
- en: '| `/=` | Divides the left operand by the right operand and assigns the result
    to the left operand. | C /= A is equivalent to C = C / A |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `/=` | 将左侧操作数除以右侧操作数，并将结果赋值给左侧操作数。 | C /= A 等价于 C = C / A |'
- en: '| `%=` | Calculates the modulus using two operands and assigns the result to
    the left operand. | C %= A is equivalent to C = C % A |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `%=` | 使用两个操作数计算模数，并将结果赋值给左侧操作数。 | C %= A 等价于 C = C % A |'
- en: Spread operator
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展运算符
- en: 'The spread operator can be used to initialize arrays and objects from another
    array or object:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符可以用来从另一个数组或对象初始化数组和对象：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code snippet showcases the usage of the spread operator with
    arrays, while the following code snippet showcases its usage with object literals:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了扩展运算符在数组上的使用，而以下代码片段展示了其在对象字面量上的使用：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The spread operator can also be used to expand to an expression into multiple
    arguments (in function calls), but we will skip that use case for now.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符还可以用来将表达式扩展为多个参数（在函数调用中），但我们现在将跳过这个用例。
- en: We will learn more about the spread operator in [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml),
    *Working with Functions* and [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml),
    *Object-Oriented Programming with TypeScript*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 3 章 [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml)，*与函数一起工作*
    和第 4 章 [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)，*使用 TypeScript
    进行面向对象编程* 中了解更多关于扩展运算符的内容。
- en: Flow control statements
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制语句
- en: This section describes the decision-making statements, the looping statements,
    and the branching statements supported by the TypeScript programming language.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了 TypeScript 编程语言支持的决策语句、循环语句和分支语句。
- en: The single-selection structure (if)
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单重选择结构（if）
- en: 'The following code snippet declares a variable of type boolean and name `isValid`.
    Then, an `if` statement will check whether the value of `isValid` is equal to
    `true`. If the statement turns out to be `true`, the `Is valid!` message will
    be displayed on the screen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `isValid` 的布尔类型变量。然后，一个 `if` 语句将检查 `isValid` 的值是否等于 `true`。如果该语句为
    `true`，则将在屏幕上显示消息 `Is valid!`：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The double-selection structure (if...else)
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双重选择结构（if...else）
- en: 'The following code snippet declares a variable of type boolean and name `isValid`.
    Then, an `if` statement will check whether the value of `isValid` is equal to
    `true`. If the statement turns out to be `true`, the message `Is valid!` will
    be displayed on the screen. On the other hand, if the statement turns out to be
    `false`, the message `Is NOT valid!` will be displayed on the screen:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `isValid` 的布尔类型变量。然后，一个 `if` 语句将检查 `isValid` 的值是否等于 `true`。如果该语句为
    `true`，则将在屏幕上显示消息 `Is valid!`。另一方面，如果该语句为 `false`，则将在屏幕上显示消息 `Is NOT valid!`：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The inline ternary operator (?)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行内三元运算符 (?)
- en: 'The inline ternary operator is just an alternative way of declaring a double-selection
    structure:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 行内三元运算符只是声明双重选择结构的一种替代方式：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code snippet declares a variable of type boolean and name `isValid`.
    Then, it checks whether the variable or expression on the left-hand side of the
    operator `?` is equal to `true`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个名为 `isValid` 的布尔类型变量。然后，它检查操作符 `?` 左侧的变量或表达式是否等于 `true`。
- en: If the statement turns out to be `true`, the expression on the left-hand side
    of the character will be executed and the message `Is valid!` will be assigned
    to the message variable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该语句为 `true`，则将在字符左侧执行表达式，并将消息 `Is valid!` 赋值给消息变量。
- en: On the other hand, if the statement turns out to be `false`, the expression
    on the right-hand side of the operator will be executed and the message, `Is NOT
    valid!` will be assigned to the message variable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果该语句为 `false`，则操作符右侧的表达式将被执行，并将消息 `Is NOT valid!` 赋值给消息变量。
- en: Finally, the value of the message variable is displayed on the screen.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，消息变量的值将在屏幕上显示。
- en: The multiple-selection structure (switch)
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重选择结构（switch）
- en: The `switch` statement evaluates an expression, matches the expression's value
    to a case clause, and executes statements associated with that case. Switch statements
    and enumerations are often used together to improve the readability of the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句评估一个表达式，将表达式的值与一个case子句匹配，并执行与该case关联的语句。switch语句和枚举通常一起使用，以提高代码的可读性。'
- en: In the following example, we declare a function that takes an enumeration named
    `AlertLevel`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们声明了一个函数，该函数接受一个名为`AlertLevel`的枚举。
- en: You will learn more about enumerations in [Chapter 2](7211d7ea-dc2f-4ff0-bb19-14400bb911bc.xhtml),
    *Working with Types.*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第2章](7211d7ea-dc2f-4ff0-bb19-14400bb911bc.xhtml)，“与类型一起工作”中了解更多关于枚举的内容。
- en: 'Inside the function, we will generate an array of strings to store email addresses
    and execute a `switch` structure. Each of the options of the enumeration is a
    case in the `switch` structure:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们将生成一个字符串数组来存储电子邮件地址，并执行一个`switch`结构。枚举的每个选项都是`switch`结构中的一个case：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The value of the `level` variable is tested against all the cases in the `switch`.
    If the variable matches one of the cases, the statement associated with that case
    is executed. Once the `case` statement has been executed, the variable is tested
    against the next case.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`level`变量的值会在`switch`中的所有case中进行测试。如果变量与其中一个case匹配，则执行与该case关联的语句。一旦执行了`case`语句，变量将再次与下一个case进行测试。'
- en: Once the execution of the statement associated with a matching case is finalized,
    the next case will be evaluated. If the `break` keyword is present, the program
    will not continue the execution of the following `case` statement.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行与匹配的case关联的语句完成，将评估下一个case。如果存在`break`关键字，程序将不会继续执行后面的`case`语句。
- en: If no matching case clause is found, the program looks for the optional `default`
    clause, and if found, it transfers control to that clause and executes the associated
    statements.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到匹配的case子句，程序将查找可选的`default`子句，如果找到，则将控制权转移到该子句并执行相关的语句。
- en: If no `default` clause is found, the program continues execution at the statement
    following the end of switch. By convention, the `default` clause is the last clause,
    but it does not have to be so.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到`default`子句，程序将继续执行switch结束后的语句。按照惯例，`default`子句是最后一个子句，但不必总是如此。
- en: The expression is tested at the top of the loop (while)
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式在循环的顶部（while）进行测试
- en: 'The `while` expression is used to repeat an operation while a certain requirement
    is satisfied. For example, the following code snippet declares a numeric variable
    `i`. If the requirement (the value of `i` is less than `5`) is satisfied, an operation
    takes place (increase the value of `i` by one and display its value in the browser
    console). Once the operation has completed, the accomplishment of the requirement
    will be checked again:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`表达式用于在满足一定要求的情况下重复操作。例如，以下代码片段声明了一个名为`i`的数字变量。如果满足要求（`i`的值小于`5`），则执行操作（将`i`的值增加一并在浏览器控制台显示其值）。一旦操作完成，将再次检查是否满足要求：'
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a `while` expression, the operation will take place only if the requirement
    is satisfied.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`表达式中，只有当满足要求时才会执行操作。
- en: The expression is tested at the bottom of the loop (do...while)
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式在循环的底部（do...while）进行测试
- en: 'The `do...while` expression can be used to repeat an instruction until a certain
    requirement is not satisfied. For example, the following code snippet declares
    a numeric variable `i` and repeats an operation (increase the value of `i` by
    `one` and display its value in the browser console) for as long as the requirement
    (the value of `i` is less than `five`) is satisfied:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`do...while`表达式可用于重复指令，直到不满足某个要求。例如，以下代码片段声明了一个名为`i`的数字变量，并在满足要求（`i`的值小于`five`）的情况下重复操作（将`i`的值增加`one`并在浏览器控制台显示其值）：'
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unlike the `while` loop, the `do...while` expression will execute at least once,
    regardless of the tested expression, as the operation will take place before checking
    whether a certain requirement is satisfied or not.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`循环不同，`do...while`表达式至少会执行一次，无论测试的表达式如何，因为操作会在检查是否满足某些要求之前进行。
- en: Iterate on each object's properties (for...in)
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历每个对象的属性（for...in）
- en: 'The `for...in` statement by itself is not a *bad practice*; however, it can
    be misused, for example, to iterate over arrays or array-like objects. The purpose
    of the `for...in` statement is to enumerate over object properties:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...in`语句本身并不是一种*坏做法*；然而，它可能会被误用，例如，用于迭代数组或类似数组的对象。`for...in`语句的目的是枚举对象属性：'
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The following code snippet will go up in the prototype chain, also enumerating
    the inherited properties. The `for...in` statement iterates the entire prototype
    chain, also enumerating the inherited properties. When you want to enumerate only
    the object's properties that aren't inherited, you can use the `hasOwnProperty`
    method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将向上遍历原型链，同时枚举继承的属性。`for...in`语句迭代整个原型链，同时枚举继承的属性。当你只想枚举对象自身的属性而不是继承的属性时，你可以使用`hasOwnProperty`方法。
- en: Iterate values in an iterable (for...of)
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`for...of`循环迭代可迭代对象中的值
- en: In JavaScript, some built-in types are built-in iterables with a default iteration
    behavior. To be an iterable, an object must implement the `@@iterator` method,
    meaning that the object (or one of the objects in its prototype chain) must have
    a property with a `@@iterator` key, which is available via constant `Symbol.iterator`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，一些内置类型是具有默认迭代行为的内置可迭代类型。要成为可迭代对象，一个对象必须实现`@@iterator`方法，这意味着对象（或其原型链中的某个对象）必须有一个具有`@@iterator`键的属性，该属性通过`Symbol.iterator`常量可用。
- en: 'The `for...of` statement creates a loop iterating over iterable objects (including
    array, map, set, string, arguments object, and so on):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...of`语句创建一个循环，迭代可迭代对象（包括数组、映射、集合、字符串、arguments对象等）：'
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will learn more about iterables in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,
    Object-Oriented Programming with TypeScript*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第4章](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*，使用TypeScript进行面向对象编程*中了解更多关于可迭代对象的内容。
- en: Counter-controlled repetition (for)
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数控制的重复（for）
- en: 'The `for` statement creates a loop that consists of three optional expressions,
    enclosed in parentheses and separated by semicolons, followed by a statement or
    a set of statements executed in the loop:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句创建一个包含三个可选表达式（用括号括起来，由分号分隔）的循环，后面跟着在循环中执行的语句或语句集：'
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code snippet contains a `for` statement. It starts by declaring
    the variable `i` and initializing it to `0`. It checks whether `i` is less than
    `9`, performs the two succeeding statements, and increments `i` by one after each
    pass through the loop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段包含一个`for`语句。它首先声明变量`i`并将其初始化为`0`。它检查`i`是否小于`9`，执行接下来的两个语句，并在每次循环迭代后递增`i`。
- en: Functions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Just as in JavaScript, TypeScript functions can be created either as a named
    function or as an anonymous function, which allows us to choose the most appropriate
    approach for an application, whether we are building a list of functions in an
    API or a one-off function to hand over to another function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如JavaScript一样，TypeScript函数可以创建为命名函数或匿名函数，这允许我们根据应用选择最合适的方法，无论是构建API中的函数列表还是传递给另一个函数的单次函数：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see in the preceding code snippet, in TypeScript, we can add types
    to each of the parameters and then to the function itself to add a return type.
    TypeScript can infer the return type by looking at the `return` statements, so
    we can also optionally leave this off in many cases.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以在前面的代码片段中看到的那样，在TypeScript中，我们可以为每个参数以及函数本身添加类型，然后添加返回类型。TypeScript可以通过查看`return`语句来推断返回类型，因此我们也可以在许多情况下省略这一点。
- en: 'There is an alternative syntax for functions that use the `=>` operator after
    the return type and don''t use the `function` keyword:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用返回类型后的`=>`运算符且不使用`function`关键字的函数，存在一种替代语法：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have learned about this alternative syntax, we can return to the
    previous example, in which we were assigning an anonymous function to the `greet`
    variable. We can now add the type annotations to the `greet` variable to match
    the anonymous function signature:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这种替代语法，我们可以回到之前的例子，其中我们将匿名函数赋值给`greet`变量。现在我们可以为`greet`变量添加类型注解，以匹配匿名函数签名：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Keep in mind that the arrow function (`=>`) syntax changes the way the `this`
    keyword works when working with classes. We will learn more about this in the
    upcoming chapters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，箭头函数（`=>`）语法会改变在类中工作时`this`关键字的运作方式。我们将在接下来的章节中了解更多关于这一点。
- en: 'Now you know how to add type annotations to force a variable to be a function
    with a specific signature. The usage of this kind of annotation is really common
    when we use a callback (functions used as an argument of another function):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何添加类型注解来强制一个变量成为一个具有特定签名的函数。这种注解的使用在调用回调（作为另一个函数的参数使用的函数）时非常常见：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, we are declaring a function named `add` that takes
    two numbers and a `callback` as a function. The type annotations will force the
    callback to return `void` and take a number as its only argument.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们声明了一个名为 `add` 的函数，它接受两个数字和一个 `callback` 作为函数。类型注解将强制回调返回 `void` 并接受一个数字作为其唯一参数。
- en: We will focus on functions in [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml)*,*
    *Working with Functions*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 3 章 [函数的使用](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml)*,* 中关注函数。
- en: Classes
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: ECMAScript 6, the next version of JavaScript, adds class-based object-orientation
    to JavaScript and, since TypeScript includes all the features available in ES6,
    developers are allowed to use class-based object orientation today, and compile
    them down to JavaScript that works across all major browsers and platforms, without
    having to wait for the next version of JavaScript.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 6，JavaScript 的下一个版本，为 JavaScript 添加了基于类的面向对象特性，由于 TypeScript 包含了
    ES6 中所有可用的特性，因此开发者现在可以使用基于类的面向对象特性，并将它们编译成可以在所有主要浏览器和平台上运行的 JavaScript，而无需等待 JavaScript
    的下一个版本。
- en: 'Let''s take a look at a simple TypeScript class definition example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的 TypeScript 类定义示例：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding example, we have declared a new class, `Character`. This class
    has three members: a property called `fullname`, a `constructor`, and a method
    `greet`. When we declare a class in TypeScript, all the methods and properties
    are public by default. We have used the `public` keyword to be more explicit;
    being explicit about the accessibility of the class members is recommended but
    it is not a requirement.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们声明了一个新的类，`Character`。这个类有三个成员：一个名为 `fullname` 的属性、一个 `constructor`
    和一个方法 `greet`。当我们使用 TypeScript 声明一个类时，所有方法和属性默认都是公共的。我们使用了 `public` 关键字来更加明确；明确类成员的可访问性是推荐的，但不是必需的。
- en: You'll notice that when we refer to one of the members of the class (from within
    itself), we prepend the `this` operator. The `this` operator denotes that it's
    a member access. In the last lines, we construct an instance of the `Character`
    class using a `new` operator. This calls into the constructor we defined earlier,
    creating a new object with the `Character` shape and running the constructor to
    initialize it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当我们从类内部引用其成员时，我们会使用 `this` 操作符作为前缀。`this` 操作符表示这是一个成员访问。在最后一行，我们使用 `new`
    操作符构造了一个 `Character` 类的实例。这调用我们之前定义的构造函数，创建了一个具有 `Character` 形状的新对象，并运行构造函数来初始化它。
- en: TypeScript classes are compiled into JavaScript functions in order to achieve
    compatibility with ECMAScript 3 and ECMAScript 5.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 类被编译成 JavaScript 函数，以实现与 ECMAScript 3 和 ECMAScript 5 的兼容性。
- en: We will learn more about classes and other object-oriented programming concepts
    in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,* *Object-Oriented
    Programming with TypeScript*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 4 章 [面向对象编程与 TypeScript](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,*
    中学习更多关于类和其他面向对象编程概念。
- en: Interfaces
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'In TypeScript, we can use interfaces to ensure that a class follows a particular
    specification:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，我们可以使用接口来确保一个类遵循特定的规范：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, we have defined an interface `LoggerInterface` and
    a class `Logger`, which implements it. TypeScript will also allow you to use interfaces
    to declare the type of an object. This can help us to prevent many potential issues,
    especially when working with object literals:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个接口 `LoggerInterface` 和一个实现它的类 `Logger`。TypeScript 还允许你使用接口来声明对象的类型。这可以帮助我们预防许多潜在的问题，尤其是在处理对象字面量时：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We will learn more about interfaces and other object-oriented programming concepts
    in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,* *Object-Oriented
    Programming with TypeScript*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 4 章 [面向对象编程与 TypeScript](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,*
    中学习更多关于接口和其他面向对象编程概念。
- en: Namespaces
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'Namespaces, also known as **internal modules**, are used to encapsulate features
    and objects that share a certain relationship. Namespaces will help you to organize
    your code. To declare a namespace in TypeScript, you will use the `namespace`
    and `export` keywords:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间，也称为**内部模块**，用于封装具有某种关系的特性和对象。命名空间将帮助你组织代码。要在 TypeScript 中声明一个命名空间，你将使用
    `namespace` 和 `export` 关键字：
- en: In older versions of TypeScript, the keyword to define an internal module was
    `module` instead of `namespace`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 的旧版本中，定义内部模块的关键字是 `module` 而不是 `namespace`。
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code snippet, we have declared a namespace that contains the
    classes `vector2D` and `vector3D` and the interfaces `VectorInterface`, `Vector2DInterface`,
    and `Vector3DInterface`. Note that the first interface is missing the keyword
    `export`. As a result, the interface `VectorInterface` will not be accessible
    from outside the module's scope.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个包含类 `vector2D` 和 `vector3D` 以及接口 `VectorInterface`、`Vector2DInterface`
    和 `Vector3DInterface` 的命名空间。请注意，第一个接口缺少关键字 `export`。因此，接口 `VectorInterface` 将无法从模块的作用域外部访问。
- en: Namespaces are a good way to organize your code; however, they are **not the
    recommended way to organize your code** in a TypeScript application. We will not
    get into more details about this topic for now, but we will learn more about internal
    and external modules and we'll discuss when each is appropriate and how to use
    them in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*, Object-Oriented
    Programming with TypeScript.*
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是组织代码的好方法；然而，在 TypeScript 应用程序中，**它们并不是组织代码的推荐方式**。我们现在不会深入探讨这个话题的更多细节，但我们将学习更多关于内部和外部模块的知识，我们将在[第
    4 章](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*，使用 TypeScript 进行面向对象编程*中讨论何时使用它们以及如何使用它们。
- en: Putting everything together
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切整合起来
- en: 'Now that we have learned how to use the basic TypeScript building blocks individually,
    let''s take a look at a final example in which we will use modules, classes, functions,
    and type annotations for each of these elements:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何单独使用基本的 TypeScript 构建块，让我们来看一个最终的例子，我们将为这些元素中的每一个使用模块、类、函数和类型注解：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding example is just a small portion of a basic 3D engine written in
    JavaScript. In 3D engines, there are a lot of mathematical calculations involving
    matrices and vectors. As you can see, we have defined a module `Geometry` that
    will contain some entities; to keep the example simple, we have only added the
    class `Vector2D`. This class stores two coordinates (`x` and `y`) in 2D space
    and performs some operations on the coordinates. One of the most widely used operations
    in vectors is normalization, which is one of the methods in our `Vector2D` class.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子只是用 JavaScript 编写的基本 3D 引擎的一个小部分。在 3D 引擎中，有很多涉及矩阵和向量的数学计算。正如你所见，我们定义了一个包含一些实体的模块
    `Geometry`；为了使示例简单，我们只添加了类 `Vector2D`。这个类在 2D 空间中存储两个坐标（`x` 和 `y`）并执行一些坐标上的操作。向量中最常用的操作之一是归一化，这是我们的
    `Vector2D` 类中的方法之一。
- en: 3D engines are complex software solutions, and as a developer, you are much
    more likely to use a third-party 3D engine than create your own. For this reason,
    it is important to understand that TypeScript will not only help you develop large-scale
    applications but also interact with complex libraries.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 引擎是复杂的软件解决方案，作为开发者，你更有可能使用第三方 3D 引擎而不是自己创建。因此，了解 TypeScript 不仅可以帮助你开发大型应用程序，还可以与复杂的库交互是很重要的。
- en: 'In the following code snippet, we will use the module declared earlier to create
    a `Vector2D` instance:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将使用之前声明的模块来创建一个 `Vector2D` 实例：
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The type-checking and IntelliSense features will help us create a `Vector2D`
    instance, normalize its value, and convert it into an array to finally show its
    value on the screen with ease:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查和智能感知功能将帮助我们创建一个 `Vector2D` 实例，归一化其值，并将其转换为数组，最后轻松地在屏幕上显示其值：
- en: '![](img/dc7c2a1d-a52d-41e2-9d8a-fdfcafe3026c.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc7c2a1d-a52d-41e2-9d8a-fdfcafe3026c.png)'
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you have learned about the purposes of TypeScript. You have
    also learned about some of the design decisions made by the TypeScript engineers
    at Microsoft.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了 TypeScript 的用途。你还了解了一些微软的 TypeScript 工程师做出的设计决策。
- en: Toward the end of this chapter, you learned a lot about the basic building blocks
    of a TypeScript application, and we started to write some TypeScript code for
    the first time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，你学习了 TypeScript 应用程序的基本构建块，并且我们第一次开始编写 TypeScript 代码。
- en: We now know the basics of type annotations, variables, primitive data types,
    operators, flow control statements, functions, interfaces, classes, and namespaces.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了类型注解、变量、原始数据类型、运算符、流程控制语句、函数、接口、类和命名空间的基础知识。
- en: In the next chapter, we will learn more about the TypeScript type system.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于 TypeScript 类型系统的内容。
