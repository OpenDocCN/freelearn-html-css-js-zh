- en: Chapter 1. Working with Responsive Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 与响应式图像一起工作
- en: '"A picture tells a thousand words…"'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “一张图片胜过千言万语……”
- en: These words used in an advert dating from 1913 for the Piqua Auto Supply House
    of Piqua, Ohio, still ring true over a hundred years later. The only difference
    is the advent of technology—with the increasing use of mobile phones, tablets,
    and portable devices comes a need to display content on smaller devices. While
    text might be easy to display, images are less so, but are still just as important.
    Throughout this chapter, we're going to look at some of the tips and tricks you
    need to learn in order to display images of the right size and quality on a variety
    of different devices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些词用于1913年俄亥俄州皮夸的皮夸汽车供应公司的广告中，至今仍具有现实意义。唯一的区别是技术的出现——随着手机、平板电脑和便携式设备的日益普及，需要在较小的设备上显示内容。虽然文本可能很容易显示，但图像则不然，但它们仍然同样重要。在本章中，我们将探讨一些你需要学习的技巧和窍门，以便在多种不同的设备上以正确的大小和质量显示图像。
- en: 'Creating responsive images can be as easy or complex as needed. In this chapter,
    we will cover a host of topics, which include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 创建响应式图像可以像所需的那样简单或复杂。在本章中，我们将涵盖一系列主题，包括：
- en: Working with fluid images, icons, and sprites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与流体图像、图标和精灵一起工作
- en: Catering to vendor prefixes, image formats, and different platforms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应供应商前缀、图像格式和不同平台
- en: Catering to HD/Retina images and using the `<picture>` tags
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应高清/视网膜图像并使用`<picture>`标签
- en: Determining an available viewport for use
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定可用的视口以供使用
- en: Working out media queries using CSS, JavaScript, or data tags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS、JavaScript或数据标签解决媒体查询
- en: Building a responsive carousel and creating responsive maps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建响应式轮播图和创建响应式地图
- en: Curious? Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇吗？让我们开始吧！
- en: Getting started
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'Throughout this chapter, we''ll work using a project area. Before we get started,
    it is strongly recommended that you create a project folder. For the purposes
    of this chapter, I will assume it is called `code`; inside it, you will need to
    create four folders: `css`, `js`, `font`, and `img`, as shown in this screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用项目区域进行操作。在我们开始之前，强烈建议你创建一个项目文件夹。为了本章的目的，我将假设它叫做`code`；在其内部，你需要创建四个文件夹：`css`、`js`、`font`和`img`，如截图所示：
- en: '![Getting started](img/6968OT_01_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![开始](img/6968OT_01_01.jpg)'
- en: We will refer to the folders created here throughout the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中引用创建的文件夹。
- en: Beginning with fluid images
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从流体图像开始
- en: How many times have you created web pages only to find that a viewer complains
    that they look poor on a mobile device? I'll bet that one possible reason for
    this is image content. The image is set with fixed sizes, so it doesn't resize
    well in smaller browsers, right?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次创建了网页，却发现观众抱怨它们在移动设备上看起来很差？我敢打赌，这可能是图像内容的一个可能原因。图像被设置为固定大小，所以在较小的浏览器中无法很好地调整大小，对吧？
- en: In this tutorial, we will take a look at the basics needed to move away from
    fixed images to those that adapt when a browser window has been resized or content
    is being viewed on a mobile device.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将探讨从固定图像转向在浏览器窗口调整大小或移动设备上查看内容时自动调整大小的图像所需的基本知识。
- en: 'For this exercise, I''ve created a dummy page about Lake Peyto in Canada—a
    truly stunning part of Canada if you are fortunate to be able to visit! Throughout
    this tutorial, we''re going to make some changes to help make the image react
    better when resized in a browser window. These steps will guide you through the
    exercise:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个练习，我创建了一个关于加拿大派尤托湖的示例页面——如果你有幸能去参观，那将是加拿大真正令人惊叹的一部分！在本教程中，我们将进行一些更改，以帮助使图像在浏览器窗口调整大小时更好地响应。以下步骤将指导你完成练习：
- en: Let's start by cracking open a copy of the code download and extracting `simplefluid1.html`
    and `simplefluid1.css`. This a simple web page about Lake Peyto, Canada.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先打开代码下载的副本，并提取`simplefluid1.html`和`simplefluid1.css`。这是一个关于加拿大派尤托湖的简单网页。
- en: Try resizing the browser window. Notice how it doesn't resize any of the content?
    Let's fix that by making two small changes to our code.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试调整浏览器窗口的大小。注意它并没有调整任何内容？让我们通过对我们代码进行两个小的更改来解决这个问题。
- en: 'Alter the two lines in `simplefluid1.css` as shown in these lines of code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`simplefluid1.css`中的两行，如以下代码所示：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The three changes we just performed are all that is required to make the content
    responsive and adapt to fit the resized window. We''ve used `max-width` to control
    the size of the image and the use of `height: auto` helps to keep the aspect ratio
    of the image to prevent it from looking distorted.'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们刚刚进行的三个更改就是使内容响应式并适应调整大小窗口所需的所有内容。我们使用了`max-width`来控制图像的大小，而使用`height: auto`有助于保持图像的宽高比，防止其看起来扭曲。'
- en: One might think that this is enough, right? Well no, not quite; try resizing
    the content to a smaller size and we can see the image is starting to spill over
    the border.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有些人可能会认为这就足够了，对吧？嗯，并不完全是这样；尝试将内容调整到更小的尺寸，我们可以看到图像开始溢出边界。
- en: To make the image truly adaptive, we need to convert the sizes to their percentage
    equivalents; for this, we can use the formula *target ÷ context = result*. Let's
    put this into practice. Consider `443px` (width of image) / `800px` (original
    size of box) * 100 = 55.375 percent.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使图像真正适应，我们需要将尺寸转换为它们的百分比等效值；为此，我们可以使用公式 *目标 ÷ 上下文 = 结果*。让我们将其付诸实践。考虑 `443px`（图像宽度）
    / `800px`（原始框大小） * 100 = 55.375%。
- en: 'Using this formula, go ahead and modify the `img` rule as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个公式，继续修改 `img` 规则如下：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If all is well when resizing the image, the content will adjust but remain
    within the confines of the `#peytoe` div, as shown in this screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调整图像大小时一切顺利，内容将进行调整，但仍然保持在 `#peytoe` div 的范围内，如本截图所示：
- en: '![Beginning with fluid images](img/6968OT_01_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![从流体图像开始](img/6968OT_01_02.jpg)'
- en: It should be noted that this approach may not work for all sites. For example,
    it may be preferable to crop it first using the background position before scaling
    it down to a smaller size. It will depend on your design as well as the type and
    quantity of images used; this is something that needs to be considered during
    design.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这种方法可能并不适用于所有网站。例如，在将其缩小到更小尺寸之前，可能更倾向于先使用背景位置对其进行裁剪。这取决于你的设计以及所使用的图像类型和数量；这是在设计过程中需要考虑的事情。
- en: Now that we've seen the basics of making images responsive, let's move on and
    take a look at how we can improve on this by using higher quality images on supported
    devices. Before we do this though, it is worth covering a couple of key points
    about responsive design, namely relating to the use of vendor prefixes and image
    formats.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了使图像响应式的基础知识，让我们继续前进，看看我们如何通过在支持的设备上使用更高质量的图像来改进这一点。但在我们这样做之前，值得介绍一些关于响应式设计的要点，特别是与使用供应商前缀和图像格式相关的内容。
- en: Catering to vendor prefixes and image formats
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商前缀和图像格式
- en: 'We''ll start this section with a question. Hands up if you thought that creating
    responsive content requires special image formats or lots of vendor prefixes?
    If you think yes is the answer, then think again—two to three years ago, you may
    have had to work with something like the following lines of code as an example
    media query:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个问题开始本节。如果你认为创建响应式内容需要特殊的图像格式或大量的供应商前缀，请举手。如果你认为答案是肯定的，那么再想想——两到三年前，你可能不得不使用以下代码行作为示例媒体查询：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, all you need to cater to most modern browsers (that is, versions released
    within the last 12 to 18 months) is this—not a vendor prefix in sight:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需要考虑大多数现代浏览器（即在过去12到18个月内发布的版本）的是这个——没有看到任何供应商前缀：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A similar principle applies for images—there is no need for a special format
    that needs to be used solely for media queries, or a need to use lots of different
    formats to cater to different devices. We only need to choose one format—any format
    will work. The exception here is that while using PNG or JPG images will produce
    results, you will find that the quality will begin to suffer in some instances
    as these formats do not scale up well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图像来说，也有一个类似的原则适用——不需要专门用于媒体查询的特殊格式，也不需要使用许多不同的格式来满足不同设备的需求。我们只需要选择一个格式——任何格式都可以。这里的例外是，虽然使用PNG或JPG图像会产生结果，但你可能会发现，在某些情况下，由于这些格式不适合放大，质量开始下降。
- en: Instead, it is better to use the SVG format when working responsively. This
    is effectively XML, which can be edited using tools such as Inkscape or Illustrator;
    it even can be edited in a text editor! The key to using SVG though is that it
    scales perfectly; irrespective of the size of the browser window, the image quality
    will be unaffected. It's an ideal format for logos, patterns, icons, and so on,
    but not for photographs, where the lossy format will not scale well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在响应式设计中使用SVG格式会更好。这实际上是XML，可以使用Inkscape或Illustrator等工具进行编辑；甚至可以在文本编辑器中编辑！不过，使用SVG的关键是它能够完美缩放；无论浏览器窗口的大小如何，图像质量都不会受到影响。它是标志、图案、图标等理想的格式，但不适用于照片，因为有损格式在缩放时表现不佳。
- en: Catering to different platforms
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应不同平台
- en: 'At this point, you may hopefully be asking yourself, "What about mobile devices?"—it''s
    a good question after all: the whole point of responsive design is to cater to
    mobile devices! Most of the tips and tricks we will encounter throughout this
    chapter will work on a mobile platform, although there are some useful guidelines
    that are worth noting:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能希望问自己，“关于移动设备怎么办？”毕竟，这是一个很好的问题：响应式设计的全部目的就是为了适应移动设备！我们将在本章中遇到的大部分技巧和窍门都适用于移动平台，尽管也有一些值得注意的有用指南：
- en: Shrink the images. Use any online service such as TinyPNG or XnConvert; they
    need to be made as small as possible without sacrificing too much quality.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩小图片。使用任何在线服务，如TinyPNG或XnConvert；它们需要尽可能小，同时不要牺牲太多质量。
- en: Be careful with retina images. Memory usage for these can vary dramatically
    between different mobile devices, so ensure you set your media queries appropriately.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理视网膜图片时要小心。这些图片在不同移动设备上的内存使用量可能会有很大差异，因此请确保适当地设置你的媒体查询。
- en: If you're using jQuery to provide fallback support, then consider using conditional
    loading to only call jQuery when needed and not by default.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用jQuery提供回退支持，那么考虑使用条件加载，仅在需要时调用jQuery，而不是默认调用。
- en: Make sure that different sized versions of the same image have been created.
    There is no point in forcing a mobile user to download a huge file when a small
    one will do! To get help with this, look online for tools such as Andi Smith's
    Responsive Images tool at [http://www.andismith.com/grunt-responsive-images/](http://www.andismith.com/grunt-responsive-images/),
    which can help automate the process.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保已创建同一图片的不同尺寸版本。如果小尺寸图片足够，就没有必要强迫移动用户下载大文件！要获取帮助，请在网上寻找类似Andi Smith的响应式图片工具[http://www.andismith.com/grunt-responsive-images/](http://www.andismith.com/grunt-responsive-images/)，它可以帮助自动化此过程。
- en: Test in an online applet such as the Responsive tool available at [http://coolestguidesontheplanet.com/responsive/](http://coolestguidesontheplanet.com/responsive/),
    as there is no substitute for testing! It is much better to test thoroughly now
    and fix errors before going live than to suffer the embarrassment at a later date.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线应用程序中测试，例如在[http://coolestguidesontheplanet.com/responsive/](http://coolestguidesontheplanet.com/responsive/)可用的响应式工具，因为没有替代品可以测试！现在彻底测试并修复错误，比以后上线时遭受尴尬要好得多。
- en: Work in a mobile first capacity. Mobile devices need to be set to download the
    smallest images first; browsers will handle the replacement with larger images
    automatically if the media queries have been created within the site.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以移动优先的方式进行工作。移动设备需要设置为首先下载最小的图片；如果网站内已创建媒体查询，浏览器将自动处理替换为较大图片。
- en: Consider using something similar to the Network API ([http://code.tutsplus.com/tutorials/html5-network-information-api--cms-21598](http://code.tutsplus.com/tutorials/html5-network-information-api--cms-21598))
    or Modernizr ([http://www.modernizr.com](http://www.modernizr.com)) to determine
    whether the visitor is using a mobile platform; we can link these to jQuery/JavaScript
    based media queries if required to determine which image should be served.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用类似网络API([http://code.tutsplus.com/tutorials/html5-network-information-api--cms-21598](http://code.tutsplus.com/tutorials/html5-network-information-api--cms-21598))或Modernizr([http://www.modernizr.com](http://www.modernizr.com))的东西来确定访问者是否在使用移动平台；如果需要，我们可以将这些链接到基于jQuery/JavaScript的媒体查询，以确定应该提供哪张图片。
- en: 'Don''t use display: none to hide images, serve them in media queries. Using
    the former approach still downloads them even if they are hidden.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '不要使用`display: none`来隐藏图片，使用媒体查询来提供。使用前者方法即使图片被隐藏，仍然会下载它们。'
- en: Tip
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Remember this sentence from RevUnit''s Seth Waite: "1 in 4 people abandon a
    web page that takes more than four seconds to load." This becomes more critical
    with mobile devices; loading a large image will blow this straight out of the
    water! You can see his original article at [http://sethwaite.com/2012/08/how-slow-website-speed-destroys-your-conversion-rates/](http://sethwaite.com/2012/08/how-slow-website-speed-destroys-your-conversion-rates/).'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住RevUnit的Seth Waite说的这句话：“1/4的人会放弃加载时间超过四秒的网页。”在移动设备上，这一点变得更加关键；加载大图像会直接导致加载时间过长！你可以在他的原始文章中看到更多[http://sethwaite.com/2012/08/how-slow-website-speed-destroys-your-conversion-rates/](http://sethwaite.com/2012/08/how-slow-website-speed-destroys-your-conversion-rates/)。
- en: Now that the theory is out of the way, let's get coding! We're going to begin
    with one of the key elements of working with responsive media—catering to **high-resolution**
    (**hi-res**) or retina-based images.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在理论部分已经讲完，让我们开始编码！我们将从响应式媒体工作的关键元素之一开始——适应**高分辨率**（**hi-res**）或基于视网膜的图像。
- en: Catering to HD or retina images
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应高清或视网膜图像
- en: How often have you used a mobile device, such as an iPad, only to find images
    of poor quality? With the advent of retina displays on devices such as iPads,
    it is becoming more important to ensure your images are of sufficient quality
    on high-resolution screens.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次使用移动设备，比如iPad，却发现图像质量很差？随着在iPad等设备上视网膜显示屏的出现，确保你的图像在高分辨率屏幕上有足够的质量变得越来越重要。
- en: '**Retina display** is a proprietary marketing term coined by Apple, rather
    than a scientific term. To some it might evoke images of a complex scientific
    process; in reality it is just double resolution where pixels have been very closely
    packed to give higher quality and resolution. As an example, the pixel count can
    be anywhere from 220 **pixels per inch** (**PPI**) for third generation Mac Book
    Pros to 401 PPI for iPhone 6 Plus!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**视网膜显示屏**是苹果公司创造的专有营销术语，而不是科学术语。对一些人来说，它可能唤起复杂科学过程的画面；实际上，它只是双倍分辨率，其中像素被非常紧密地排列，以提供更高的质量和分辨率。例如，像素计数可以从第三代MacBook
    Pro的220 **每英寸像素**（PPI）到iPhone 6 Plus的401 PPI不等！'
- en: 'Adding retina support to our code is easy. There are several options open to
    us:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将视网膜支持添加到我们的代码中很容易。我们有几种选择：
- en: 'We can set images as the background image using `background-size: cover` to
    ensure it covers the full display. Images can then be swapped out with higher
    resolution ones using CSS media queries.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以使用`background-size: cover`将图像设置为背景图像，以确保它覆盖整个显示。然后可以使用CSS媒体查询用更高分辨率的图像替换它们。'
- en: 'We can resize images as larger retina images then use CSS to resize them on
    screen; this results in a larger file but not necessarily twice as large due to
    the way JPEG compression works. We may need to use `-ms-interpolation-mode: bicubic`
    to ensure the compression level is as efficient as possible in some browsers though!'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以将图像调整为大视网膜图像，然后使用CSS在屏幕上调整它们的大小；这会导致文件更大，但不一定是两倍大，因为JPEG压缩的方式。尽管如此，我们可能需要使用`-ms-interpolation-mode:
    bicubic`来确保在某些浏览器中压缩级别尽可能高效！'
- en: We can always set our code to display high-resolution images; however, there
    is a cost in displaying these images in the form of a bigger file size; the quality
    will be lost on **low-resolution** (**low-res**) devices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以将我们的代码设置为显示高分辨率图像；然而，显示这些图像的成本在于更大的文件大小；在**低分辨率**（**low-res**）设备上，质量将会丢失。
- en: 'Instead, we could use a plugin, such as Retina JS, to tell browsers to serve
    hi-res images only when needed. Let''s take a look at using one in action:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用插件，如Retina JS，告诉浏览器仅在需要时提供高分辨率图像。让我们看看它是如何实际使用的：
- en: 'Start by adding the following code to a new file, saving it as `retina.html`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下代码添加到一个新文件中，将其保存为`retina.html`：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we need to download the RetinaJS library—this is available at [https://github.com/imulus/retinajs/releases/download/1.3.0/retina-1.3.0.zip](https://github.com/imulus/retinajs/releases/download/1.3.0/retina-1.3.0.zip)
    (at the time of writing of this book, the latest version is 1.3.0). Extract `retina.min.js`
    and drop it into a subfolder called `js` within your project folder.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要下载RetinaJS库——这个库可以在[https://github.com/imulus/retinajs/releases/download/1.3.0/retina-1.3.0.zip](https://github.com/imulus/retinajs/releases/download/1.3.0/retina-1.3.0.zip)（在撰写本书时，最新版本是1.3.0）找到。提取`retina.min.js`并将其放入项目文件夹中的`js`子文件夹中。
- en: 'We also need two images: one needs to be of a higher resolution than the other;
    for this example, I will use two PNG files that are available in the code download:
    `mothorchid.png` and `mothorchid@2x.png`. Note that the second file must have
    `@2x` at the end of the filename; this is the key to making Retina JS work.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要两个图像：一个需要比另一个具有更高的分辨率；在这个例子中，我将使用代码下载中可用的两个PNG文件：`mothorchid.png`和`mothorchid@2x.png`。请注意，第二个文件必须在文件名末尾有`@2x`；这是使Retina
    JS工作的关键。
- en: To preview the results, it is recommended to use Google Chrome. We can easily
    simulate changing the device pixel ratio setting; change it from `1` to `2` and
    refresh the screen to see the change from the low-res image to the one of higher
    quality. We will cover how to create media queries that support hi-res images
    later in this chapter in the *Working out media queries* section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预览结果，建议使用Google Chrome。我们可以轻松地模拟更改设备像素比设置；将其从`1`更改为`2`并刷新屏幕，以查看从低分辨率图像到高分辨率图像的变化。我们将在本章的*确定媒体查询*部分介绍如何创建支持高分辨率图像的媒体查询。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are plenty of examples online of plugins that can provide retina support—two
    of the examples are: `responsImg`, which you can download from [http://etiennetalbot.github.io/responsImg/](http://etiennetalbot.github.io/responsImg/).
    Alternatively, you can use Grunt to do the heavy work with Andi Smith''s responsive
    images plugin for Grunt at [http://mattstow.com/experiment/responsive-images/responsive-images.html](http://mattstow.com/experiment/responsive-images/responsive-images.html).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有很多插件示例可以提供视网膜支持——两个示例是：`responsImg`，您可以从[http://etiennetalbot.github.io/responsImg/](http://etiennetalbot.github.io/responsImg/)下载。或者，您可以使用Grunt通过Andi
    Smith的Grunt响应式图像插件来完成这项繁重的工作，请参阅[http://mattstow.com/experiment/responsive-images/responsive-images.html](http://mattstow.com/experiment/responsive-images/responsive-images.html)。
- en: Using sprites to display responsive images
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用精灵显示响应式图像
- en: 'So far, our examples all have something in common: they work with individual
    images. This is fine for those that may only appear once or twice at the most,
    but what if they appear frequently throughout your site? It seems pointless to
    have to call them each time. Fortunately, we can get around this with the use
    of image sprites.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的示例都有一个共同点：它们与单个图像一起工作。这对于那些最多只出现一次或两次的情况来说是可以的，但如果你在整个网站上频繁地使用它们呢？每次都调用它们似乎是没有意义的。幸运的是，我们可以通过使用图像精灵来解决这个问题。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a discussion on how image sprites work, take a look at a useful article
    by Chris Coyier at [http://css-tricks.com/css-sprites/](http://css-tricks.com/css-sprites/).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于图像精灵如何工作的讨论，请参阅Chris Coyier在[http://css-tricks.com/css-sprites/](http://css-tricks.com/css-sprites/)发表的有用文章。
- en: 'For the uninitiated, image sprites are a way of combining lots of (ideally,
    small) images into one larger one then using CSS style rules to display the relevant
    part of that image. We typically might use `background-position` to position the
    image; using values in pixels, this works perfectly well. We can use the same
    principle with responsive sprites but with one key difference: we use percentage
    values instead, not pixels! Let''s take a look at how to do it using some battery
    icons as an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，图像精灵是将许多（理想情况下，较小的）图像组合成一个大图像，然后使用CSS样式规则显示该图像的相关部分的方法。我们通常可能会使用`background-position`来定位图像；使用像素值，这可以完美工作。我们可以使用相同的原理来处理响应式精灵，但有一个关键的区别：我们使用百分比值而不是像素！让我们以一些电池图标为例来看看如何实现：
- en: Start by extracting a copy of `imagesprites.html` from the code download that
    accompanies this book. It contains some simple markup with `<img>` references
    to some battery icons that we will use in our demo.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从本书附带的代码下载中提取`imagesprites.html`的副本。它包含一些简单的标记，其中包含对我们将用于演示的电池图标的`<img>`引用。
- en: Note
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, you may notice the long string of random characters—these are
    data URIs; they were generated using the responsive sprite image creator service
    at [http://responsive-css.spritegen.com/](http://responsive-css.spritegen.com/).
    For now, it's enough to know that these are the images converted into a format
    that reduces the need to continually request images from the server.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到一串随机的字符——这些是数据URI；它们是使用响应式精灵图像创建服务在[http://responsive-css.spritegen.com/](http://responsive-css.spritegen.com/)生成的。目前，只需知道这些是将图像转换为减少从服务器不断请求图像所需格式的图像即可。
- en: 'In a separate file, add the following code, saving it as `imagesprites.css`
    in the `css` subfolder of our project folder:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的文件中，添加以下代码，并将其保存为项目文件夹中的`css`子文件夹下的`imagesprites.css`：
- en: '[PRE5]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the code download, extract a copy of `index.png` from the `img` folder.
    This is our sprite image that has been premade using the CSS Sprites service from
    earlier in this exercise. Save it in the `img` subfolder of the project folder.
    The battery icons used were from [http://www.fatcow.com/free-icons](http://www.fatcow.com/free-icons).
    If you have others you would prefer to use, please alter the code accordingly.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码下载中，从 `img` 文件夹中提取 `index.png` 的副本。这是我们之前在这个练习中使用的 CSS Sprites 服务预先制作好的精灵图像。将其保存在项目文件夹的
    `img` 子文件夹中。所使用的电池图标来自 [http://www.fatcow.com/free-icons](http://www.fatcow.com/free-icons)。如果您有其他更愿意使用的图标，请相应地修改代码。
- en: If we preview the results, we should expect to see our responsive sprite image
    appear. If we resize the screen, it automatically updates the position of the
    image as shown in this screenshot:![Using sprites to display responsive images](img/6968OT_01_03.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们预览结果，我们应该期望看到我们的响应式精灵图像出现。如果我们调整屏幕大小，它将自动更新图像的位置，如本截图所示：![使用精灵显示响应式图像](img/6968OT_01_03.jpg)
- en: 'However, there are some drawbacks that we need to be aware of when using this
    approach:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用这种方法时，有一些缺点我们需要注意：
- en: If we try to decode the base64 URIs given in the code, it doesn't appear to
    produce a valid image—what gives?
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们尝试解码代码中给出的 base64 URI，它似乎没有生成有效的图像——这是怎么回事？
- en: The use of long URIs in HTML makes it harder to read
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 HTML 中使用长 URI 使得其难以阅读
- en: It makes it very difficult, if not impossible, to adapt this code for use with
    `@media` queries or to use retina-based images
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得如果可能的话，很难甚至不可能将此代码用于 `@media` 查询或使用基于视网膜的图像
- en: To see how awkward it is and to see the resulting changes in code required to
    remove the use of data URIs from the HTML markup, take a look at `imagesprites2.html`
    and `imagesprites2.css` in the code download that accompanies this book. Notice
    how the CSS has significantly changed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这种方法的尴尬之处以及从 HTML 标记中移除使用 data URI 所需的代码更改，请查看随本书附带的代码下载中的 `imagesprites2.html`
    和 `imagesprites2.css`。注意 CSS 如何发生了显著变化。
- en: Let's change tack—a key concept of responsive design is to determine the available
    viewport we can use when displaying content. Let's see what this means, when working
    with images.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变方向——响应式设计的一个关键概念是确定在显示内容时我们可以使用的可用视口。让我们看看这意味着什么，当我们与图像一起工作时。
- en: Determining the available viewport for use
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定可用的视口以供使用
- en: Viewport? Surely you mean screen estate or perhaps resolution? In this instance,
    no. When designing responsively, we have to cater to screens of all different
    shapes and sizes; it's not enough to simply design for a certain screen resolution.
    Instead, we have to allow for the fact that the available space in a browser window
    (or viewport) might be smaller; we have to design our breakpoints to fit this
    available space.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 视口？您肯定是指屏幕空间或分辨率？在这种情况下，不是的。在设计响应式布局时，我们必须考虑到各种形状和大小的屏幕；仅仅针对特定的屏幕分辨率设计是不够的。相反，我们必须考虑到浏览器窗口（或视口）中的可用空间可能更小；我们必须设计我们的断点以适应这个可用空间。
- en: 'A good reference point to see the available viewport on a host of devices is
    [http://viewportsizes.com/](http://viewportsizes.com/) and then navigating to
    [http://viewportsizes.com/mine/](http://viewportsizes.com/mine/). This will display
    the current space available to us. There are two ways to set the available viewport
    for use: one using CSS/HTML markup and the other using jQuery or JavaScript. We''ll
    take a look at using the CSS method first.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看在多种设备上的可用视口，一个好的参考点是 [http://viewportsizes.com/](http://viewportsizes.com/)，然后导航到
    [http://viewportsizes.com/mine/](http://viewportsizes.com/mine/)。这将显示当前可用的空间。有两种方式可以设置可用的视口以供使用：一种是通过
    CSS/HTML 标记，另一种是通过 jQuery 或 JavaScript。我们将首先查看使用 CSS 方法。
- en: Using CSS to set our viewport
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CSS 设置我们的视口
- en: This is probably one of the simplest settings to add to any responsive design,
    yet it has the potential to open up a hornet's nest of problems! Setting the viewport
    using CSS is a one-line piece of code; the difficulty is in working out the CSS
    styling needed to position the elements correctly once the viewport has been set.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是添加到任何响应式设计中最简单的设置之一，但它有可能引发一系列问题！使用 CSS 设置视口是一行代码；困难之处在于确定设置视口后正确定位元素的 CSS
    样式。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For this demo, it is recommended that you use Google Chrome. It has a built-in
    device emulation facility that makes it easy to test our results in different
    viewports. I will assume for the purposes of this demo that you have it installed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，建议您使用Google Chrome。它有一个内置的设备模拟功能，这使得在不同视口中测试我们的结果变得容易。我将假设在这个演示中您已经安装了它。
- en: 'We''ll begin with setting the markup first, so we can at least see what happens
    when the viewport has not been set in CSS:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置标记，这样我们至少可以看到当在CSS中没有设置视口时会发生什么：
- en: 'We''ll start, as always, by preparing our markup. From the code download, extract
    the files: `viewport-css.html`, `viewport-css.css`, and `pixel-grid.png`; save
    them into the `css` subfolder and `img` subfolder respectively.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样，首先准备我们的标记。从代码下载中提取文件：`viewport-css.html`、`viewport-css.css`和`pixel-grid.png`；分别将它们保存到`css`子文件夹和`img`子文件夹中。
- en: We've used the PT Sans font for decorative purposes. This is available from
    [http://www.fontsquirrel.com/fonts/PT-Sans](http://www.fontsquirrel.com/fonts/PT-Sans);
    you will need to download it and extract the fonts into a `fonts` subfolder within
    your project area.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了PT Sans字体进行装饰。这个字体可以从[http://www.fontsquirrel.com/fonts/PT-Sans](http://www.fontsquirrel.com/fonts/PT-Sans)获取；您需要下载它并将字体提取到项目区域内的`fonts`子文件夹中。
- en: Open Google Chrome and set the **Emulation** facility to emulate the Sony Xperia
    S, Ion devices, within the Developer Toolbar.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Google Chrome，并在开发者工具栏中将**模拟**功能设置为模拟索尼Xperia S、Ion设备。
- en: 'At this point, it is worth previewing the results in a browser; if all is well,
    we should see a result similar to this screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得在浏览器中预览结果；如果一切顺利，我们应该看到类似于以下截图的结果：
- en: '![Using CSS to set our viewport](img/6968OT_01_04.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![使用CSS设置我们的视口](img/6968OT_01_04.jpg)'
- en: 'The keen-eyed among you will have noticed that something is clearly amiss.
    Our screen has not resized properly and text is being chopped off the right edge
    of the window. Let''s fix that now using the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 留意的人会发现显然有问题。我们的屏幕没有正确调整大小，文本被切掉了窗口的右边缘。现在让我们使用以下步骤来修复它：
- en: 'In `viewport-css.html`, add the following line as indicated:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`viewport-css.html`中，按照指示添加以下行：
- en: '[PRE6]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Resave the file and then refresh the screen in Chrome. If all is well, we can
    now see the results of our change with the text correctly sized and no overlap:![Using
    CSS to set our viewport](img/6968OT_01_05.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新保存文件，然后在Chrome中刷新屏幕。如果一切顺利，我们现在可以看到我们的更改结果，文本大小正确，没有重叠：![使用CSS设置我们的视口](img/6968OT_01_05.jpg)
- en: In this example, we've used `<meta name="viewport" content="width=360">`, which
    sets a very specific width of 360 px. For a more general setting where no specific
    width is used `<meta name="viewport" content="width=device-width, initial-scale=1">`
    can be set instead.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`<meta name="viewport" content="width=360">`，这设置了一个非常具体的宽度为360像素。对于没有使用特定宽度的更通用设置`<meta
    name="viewport" content="width=device-width, initial-scale=1">`可以设置代替。
- en: When using media queries, we can always set the size of elements within our
    query. It's worth setting the viewport too so that items don't disappear off the
    page when resizing the browser window.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用媒体查询时，我们总可以为查询内的元素设置大小。设置视口大小也很值得，这样在调整浏览器窗口大小时，项目就不会从页面上消失。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a good discussion on using the viewport `meta` tag, it is worth checking
    out an article by Paul Underwood, which is available at [http://www.paulund.co.uk/understanding-the-viewport-meta-tag](http://www.paulund.co.uk/understanding-the-viewport-meta-tag).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用视口`meta`标签的深入讨论，值得查看Paul Underwood的一篇文章，该文章可在[http://www.paulund.co.uk/understanding-the-viewport-meta-tag](http://www.paulund.co.uk/understanding-the-viewport-meta-tag)找到。
- en: Getting the viewport using JavaScript
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript获取视口
- en: The alternative to using the CSS `<meta viewport>` tag is to use JavaScript
    (or we could equally use jQuery). In this instance, we can work out what the values
    are and use these as a basis for our design, rather than simply set specific sizes
    as we did in the previous example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CSS `<meta viewport>`标签的替代方法是使用JavaScript（或者我们也可以同样使用jQuery）。在这种情况下，我们可以计算出这些值，并以此为基础进行设计，而不是像上一个例子中那样简单地设置特定的大小。
- en: 'Let''s dig in and take a look to see how we can get our sizes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨，看看我们如何获取这些大小：
- en: 'We''ll begin with adding the following markup to a new file, saving it as `viewport-js.html`
    in the root of our project folder:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将以下标记添加到一个新文件中，将其保存为项目文件夹根目录下的`viewport-js.html`：
- en: '[PRE7]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, add this JavaScript to a new file, saving it as `viewport-js.js` in the
    `js` subfolder in the project folder:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下JavaScript添加到一个新文件中，并将其保存为项目文件夹中`js`子文件夹下的`viewport-js.js`：
- en: '[PRE8]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need some basic styling, so go ahead and add the following to `viewport-js.css`,
    saving it to the `css` subfolder in our project folder:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一些基本的样式，所以请继续在`viewport-js.css`文件中添加以下内容，并将其保存到我们项目文件夹中的`css`子文件夹：
- en: '[PRE9]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册以直接将文件通过电子邮件发送给您。
- en: If we preview the results in a browser, we'll see the size of our available
    viewport area displayed along with the current user agent string being used by
    our browser, as shown in this screenshot:![Getting the viewport using JavaScript](img/6968OT_01_06.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中预览结果，我们会看到当前浏览器使用的用户代理字符串以及可用的视口区域大小，如图所示：![使用JavaScript获取视口](img/6968OT_01_06.jpg)
- en: There are plenty of good examples online to show us how to determine the available
    viewport area; we've used a modified version of one produced by Matt Stow at [http://viewportsizes.com/](http://viewportsizes.com/).
    In it, he also has an extensive list of viewport sizes for a variety of devices.
    We could of course use something like Modernizr to perform the same function,
    but this is at the expense of depending on an outside solution; our example here
    is written in vanilla JavaScript, removing any dependencies and keeping the code
    concise.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有很多很好的例子可以展示我们如何确定可用的视口区域；我们使用了Matt Stow在[http://viewportsizes.com/](http://viewportsizes.com/)制作的修改版。在其中，他还列出了各种设备的视口尺寸的详细列表。我们当然可以使用类似Modernizr的工具来执行相同的功能，但这是以依赖外部解决方案为代价的；我们这里的示例是用纯JavaScript编写的，消除了任何依赖，并使代码简洁。
- en: Working out media queries
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决媒体查询
- en: Now that we've worked out how much space we have to work with, we can now work
    out what happens to elements when we hit the limits of our available space. This
    is particularly relevant if we want to display hi-res images for example. After
    all, we don't want to show a high quality image if it chokes the available bandwidth
    of our device!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了我们可以使用的空间大小，我们现在可以确定当达到可用空间的极限时元素会发生什么。如果我们想显示hi-res图片，这尤其相关。毕竟，我们不想展示高质量图片，如果它会耗尽我们设备的可用带宽！
- en: 'Let''s take a look at how we can use media queries to switch between lo-res
    and hi-res versions of a single image:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用媒体查询在单个图片的lo-res和hi-res版本之间切换：
- en: We will start with setting up the markup we need for our demo. From the code
    bundle for this book, extract a copy of `min-resolution.html` and save it to the
    root of the project folder.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从设置我们演示所需的结构开始。从本书的代码包中提取`min-resolution.html`的副本，并将其保存到项目文件夹的根目录。
- en: 'In a new file, add these style rules and save it as `min-resolution.css` in
    the `css` subfolder of our project folder. This is where the magic happens, that
    is, switching from the lo-res to hi-res versions of our image:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件中添加以下样式规则，并将其保存为项目文件夹中`css`子文件夹下的`min-resolution.css`。这里发生魔法，即从lo-res版本切换到我们的图片的hi-res版本：
- en: '[PRE10]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the code download that accompanies this book, extract and save copies of
    `mothorchid.png` and `mothorchid@2x.png` into the `img` subfolder of our project
    folder.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的代码下载中提取并保存`mothorchid.png`和`mothorchid@2x.png`的副本到我们项目文件夹的`img`子文件夹。
- en: If we preview the results of our work, we will first see the standard resolution
    image `mothorchid.png`.![Working out media queries](img/6968OT_01_07.jpg)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们预览我们的工作结果，我们首先会看到标准分辨率的图片`mothorchid.png`。![解决媒体查询](img/6968OT_01_07.jpg)
- en: However, if we resize the image by zooming in to at least 133 percent, we will
    see it switch to its hi-res equivalent.![Working out media queries](img/6968OT_01_08.jpg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果我们通过至少放大133%来调整图片大小，我们会看到它切换到其hi-res等价版本。![解决媒体查询](img/6968OT_01_08.jpg)
- en: Click on the **–** button to reset back to 100 percent and we will see the image
    revert back to the standard resolution version.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**–**按钮将重置回100%，我们会看到图片恢复到标准分辨率版本。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Using Google Chrome?**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Google Chrome？**'
- en: We can achieve the same effect using Chrome's Developer Toolbar. Press *Ctrl*
    + *Shift* + *I* to display it and then click on the drawer icon. Now, switch to
    the **Screen** tab and change the Device pixel ratio setting from `1` to `2` to
    show the hi-res image. For more details, please visit [https://developer.chrome.com/devtools/docs/device-mode](https://developer.chrome.com/devtools/docs/device-mode).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Chrome 的开发者工具栏实现相同的效果。按 *Ctrl* + *Shift* + *I* 显示它，然后点击抽屉图标。现在，切换到 **屏幕**
    选项卡，将设备像素比设置从 `1` 更改为 `2` 以显示高分辨率图像。更多详情请访问 [https://developer.chrome.com/devtools/docs/device-mode](https://developer.chrome.com/devtools/docs/device-mode)。
- en: 'At this point, we can use this trick to display any hi-res image we need; the
    key is to ensure we have two images, one of a standard resolution, while the other
    is of a higher quality. A small word of note though—if you spend any time researching
    different types of media queries, then you may come across something akin to these
    lines of code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以使用这个技巧来显示我们需要的任何高分辨率图像；关键是确保我们有两个图像，一个是标准分辨率，另一个是更高品质的。不过，有一个小提醒——如果你花时间研究不同类型的媒体查询，你可能会遇到类似以下代码的内容：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While still perfectly usable, the initial `–webkit-min-device-pixel-ratio` setting
    has been deprecated in favor of min-resolution; there is no need to use it unless
    you have to cater to really old browsers!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仍然可以使用，但最初的 `–webkit-min-device-pixel-ratio` 设置已被弃用，取而代之的是 min-resolution；除非你需要为非常旧的浏览器提供支持，否则不需要使用它！
- en: Now, we could easily use CSS queries in all of our projects, but there may still
    be occasions where standard queries might not work. A good example is for a navigation
    that behaves differently at different sizes. Fortunately, there is a solution
    for this—we can achieve a similar effect using the `breakpoints.js` library. Let's
    delve in now and take a look.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在所有项目中轻松使用 CSS 查询，但仍然可能存在标准查询无法工作的情况。一个很好的例子是导航在不同尺寸下表现不同。幸运的是，我们有一个解决方案——我们可以使用
    `breakpoints.js` 库来实现类似的效果。现在让我们深入探讨并查看一下。
- en: Using pure JS to determine page breakpoints
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯 JavaScript 确定页面断点
- en: 'So far, we''ve worked mainly with modern browsers. These handle media queries
    effectively, allowing us to display the right image at the right time. What if
    we had to support old IE browsers, for example, that can''t handle media queries
    without some form of help? No problem—enter `breakpoints.js`, one of the many
    JavaScript/jQuery libraries available to help us mimic media queries. I feel an
    exercise coming on, so let''s make a start building an example to see how it works:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要与现代浏览器合作。它们有效地处理媒体查询，允许我们在正确的时间显示正确的图像。如果我们不得不支持老版本的 IE 浏览器，例如，没有某种形式的帮助就无法处理媒体查询，怎么办？没问题——进入
    `breakpoints.js`，这是许多 JavaScript/jQuery 库之一，可以帮助我们模拟媒体查询。我感觉有一个练习即将到来，所以让我们开始构建一个示例来看看它是如何工作的：
- en: 'We''ll begin with setting up our markup for the demo. This contains some simple
    textboxes set to show in a group. For this, we need to extract copies of `breakpoints.html`
    and `breakpoints.css` from the code download that accompanies this book. Save
    them both into the project folder: the HTML file at the root and the CSS file
    within the `css` subfolder.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始设置演示的标记。这包含了一些简单的文本框，设置为在组中显示。为此，我们需要从本书附带的代码下载中提取 `breakpoints.html` 和
    `breakpoints.css` 的副本。将它们都保存到项目文件夹中：HTML 文件在根目录下，CSS 文件在 `css` 子文件夹中。
- en: We need a copy of jQuery 2.x—there should already be one in our project folder
    from earlier demos; if not, extract a copy from the code download that accompanies
    this book or from [http://code.jquery.com](http://code.jquery.com).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个 jQuery 2.x 的副本——从之前演示的项目文件夹中应该已经有了；如果没有，可以从本书附带的代码下载中提取一个副本，或者从 [http://code.jquery.com](http://code.jquery.com)
    提取。
- en: Note
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although `breakpoints.js` is a few years old, I've tested it with jQuery 2.1.1
    with no noticeable issues seen.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然 `breakpoints.js` 已经有几年历史了，但我已经用 jQuery 2.1.1 测试过，没有发现任何明显的问题。
- en: Next comes the all important `breakpoints.js` library. Go ahead and extract
    a copy from the code download that accompanies this book and save it to the `js`
    subfolder of our project folder. Newer versions will be available at [http://xoxco.com/projects/code/breakpoints/](http://xoxco.com/projects/code/breakpoints/).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是至关重要的 `breakpoints.js` 库。请从本书附带的代码下载中提取一个副本，并将其保存到项目文件夹的 `js` 子文件夹中。新版本将在
    [http://xoxco.com/projects/code/breakpoints/](http://xoxco.com/projects/code/breakpoints/)
    上提供。
- en: 'We need to add the call to initialize our breakpoints, so go ahead and add
    this code in between the empty `<script>` tags:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加初始化断点的调用，所以请继续在空 `<script>` 标签之间添加以下代码：
- en: '[PRE12]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save your work. If all is well, we should see these three boxes when previewing
    our work in a browser session:![Using pure JS to determine page breakpoints](img/6968OT_01_09.jpg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的工作。如果一切顺利，我们应该在浏览器会话中预览到这三个框：![使用纯 JS 确定页面断点](img/6968OT_01_09.jpg)
- en: At this point, try resizing the browser window. Notice how each of the text
    boxes resize. We're using image placeholders from the Placehold.it service at
    [http://placehold.it/](http://placehold.it/); these automatically resize in the
    same manner.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，尝试调整浏览器窗口的大小。注意每个文本框是如何调整大小的。我们正在使用 Placehold.it 服务的图像占位符[http://placehold.it/](http://placehold.it/)；这些占位符会自动以相同的方式调整大小。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a working example of this exercise available on the code download for
    this book—extract `breakpoints-finished.html` and `breakpoints-finished.css`,
    along with jQuery and `breakpoints.js`, then rename the HTML and CSS files to
    `breakpoints.html` and `breakpoints.css` to view the demo. You will need to store
    them in the appropriate subfolder of our project folder for them to work correctly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码下载中有一个此练习的工作示例——提取 `breakpoints-finished.html` 和 `breakpoints-finished.css`，以及
    jQuery 和 `breakpoints.js`，然后将 HTML 和 CSS 文件重命名为 `breakpoints.html` 和 `breakpoints.css`
    以查看演示。您需要将它们存储在项目文件夹的适当子文件夹中，以便它们能够正确工作。
- en: But hold on! A closer look at the CSS shows no media queries. This is the beauty
    of `breakpoints.js`; it allows us to replicate media queries for those browsers
    that don't support them natively. Sure, it's a little extra overhead; we can get
    around this using conditional comments (or Modernizr), so the overhead only appears
    when needed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！仔细查看 CSS，你会发现没有媒体查询。这就是 `breakpoints.js` 的美妙之处；它允许我们为那些原生不支持媒体查询的浏览器复制媒体查询。当然，这会带来一点额外的开销；我们可以使用条件注释（或
    Modernizr）来解决这个问题，这样开销只会在需要时出现。
- en: Tip
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are other examples available online that you may prefer to use. Take a
    look at [http://www.responsivejs.com](http://www.responsivejs.com) or search through
    GitHub to find alternatives.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 网上还有其他示例可供选择。请查看[http://www.responsivejs.com](http://www.responsivejs.com)或通过
    GitHub 搜索以找到替代方案。
- en: Let's move forward and take a look at a different method of switching images;
    so far we've used media queries to handle which image should be displayed. However,
    we're not limited to using them. We can use an alternative method in the form
    of source shuffling.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看切换图像的不同方法；到目前为止，我们已经使用了媒体查询来处理应该显示哪个图像。然而，我们并不局限于使用它们。我们可以使用源代码混洗的替代方法。
- en: Source shuffling uses both jQuery and CSS—if JavaScript is disabled, then CSS
    media queries will kick in and perform a similar function instead. Let's dig into
    an example to see how it works and why this could potentially provide the best
    of both solutions to us.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码混洗同时使用了 jQuery 和 CSS —— 如果禁用了 JavaScript，那么 CSS 媒体查询将启动并执行类似的功能。让我们通过一个示例来了解它是如何工作的，以及为什么这可能会为我们提供两种解决方案的最佳结合。
- en: Using data tags to allow bandwidth constraints
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据标签允许带宽限制
- en: 'The title of this exercise is a real mouthful, but serves to highlight an interesting
    experiment: "What if we could use data tags to switch images?"'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的标题听起来很复杂，但它旨在强调一个有趣的实验：“如果我们能够使用数据标签来切换图像呢？”
- en: The immediate benefit of source shuffling is that it keeps CSS media queries
    out of the HTML markup (to see what I mean, take a look at the HTML code used
    in *Working with the <picture> tags* in the next section.)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码混洗的直接好处是它将 CSS 媒体查询从 HTML 标记中分离出来（要了解我的意思，请查看下一节中 *使用 <picture> 标签* 所使用的
    HTML 代码。）
- en: 'It''s an interesting concept and one you may want to consider using; to see
    how it works, we''ll use an adapted version of an example created by the UX designer
    Jordan Moore. This uses JavaScript-based Conditional CSS library by Jeremy Keith
    to great effect. To see what I mean, let''s get going on a demo to see how it
    works:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的概念，你可能希望考虑使用；为了了解它是如何工作的，我们将使用 UX 设计师 Jordan Moore 创建的一个示例的修改版。这个示例使用了
    Jeremy Keith 的基于 JavaScript 的条件 CSS 库，效果显著。为了说明我的意思，让我们开始一个演示来看看它是如何工作的：
- en: 'Our journey through this demo starts with setting up the markup needed. In
    a new file, add the following and save it as `datatags.html` in the root of our
    project area:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的演示之旅从设置所需的标记开始。在一个新文件中，添加以下内容并将其保存为项目区域的根目录下的 `datatags.html`：
- en: '[PRE13]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We now need a handful of accompanying files. From the code bundle, extract `small.jpg`,
    `medium.jpg`, and `large.jpg` and save these to the `img` subfolder in our project
    folder.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要一些配套的文件。从代码包中提取 `small.jpg`、`medium.jpg` 和 `large.jpg` 并将它们保存到项目文件夹的 `img`
    子文件夹中。
- en: 'Next comes the three JavaScript files that we need: `jquery.min.js`, `onmediaquery.min.js`,
    and `datatags.js` should be extracted from the code download and saved into the
    `js` subfolder of our project area.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是三个我们需要用到的JavaScript文件：`jquery.min.js`、`onmediaquery.min.js`和`datatags.js`应从代码下载中提取，并保存到我们的项目区域的`js`子文件夹中。
- en: 'Finally, we need some styling. In a new file, add the following and save it
    as `datatags.css` in our `css` subfolder:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一些样式。在一个新文件中，添加以下内容，并将其保存为`css`子文件夹中的`datatags.css`：
- en: '[PRE14]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We're all set. If all is well, we should see our small image appear first followed
    immediately by either of the large ones, depending on the size of our browser
    window.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好了。如果一切顺利，我们应该首先看到我们的小图像，紧接着是任意一个大图像，这取决于浏览器窗口的大小。
- en: The key to note in this demo is that we will only see the `small.jpg` image
    on mobile devices where the viewport is already smaller. On larger devices and
    desktops, either the `medium.jpg` or `large.jpg` images will be shown instead
    as dictated by the media query in effect.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中需要注意的关键是，我们只能在视口已经较小的移动设备上看到`small.jpg`图像。在更大的设备和桌面电脑上，将根据有效的媒体查询显示`medium.jpg`或`large.jpg`图像。
- en: Working with the <picture> tags
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与<picture>标签一起工作
- en: When working in responsive design, we frequently have to provide different images
    and use a series of media queries to display the right ones at the appropriate
    time. This works fine, but is a little labor intensive. Instead, we can use the
    upcoming `<picture>` tag to produce a neater effect.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式设计中工作的时候，我们经常需要提供不同的图像，并使用一系列媒体查询在适当的时候显示正确的图像。这没问题，但有点费时费力。相反，我们可以使用即将推出的`<picture>`标签来产生更整洁的效果。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Support for the `<picture>` tag is still somewhat early; we have to use a polyfill
    to provide support for the tag for some browsers. For more details, it's worth
    checking the CanIUse.com site at [http://caniuse.com/#feat=picture](http://caniuse.com/#feat=picture).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对`<picture>`标签的支持仍然相对较新；我们必须使用polyfill来为某些浏览器提供对标签的支持。更多详情，值得查看CanIUse.com网站[http://caniuse.com/#feat=picture](http://caniuse.com/#feat=picture)。
- en: 'Let''s dive in and take a look at how we can use the tag using these steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨，看看我们如何使用以下步骤来使用这个标签：
- en: We'll start, as always, with setting up the markup for our demo. From the code
    download that accompanies this book, extract copies of the `picturefill.html`,
    `picturefill.css`, and `picturefill.js` files; save these into the root, `css`,
    and `js` subfolders of our project area, respectively.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样，从本书附带的代码下载中提取`picturefill.html`、`picturefill.css`和`picturefill.js`文件的副本；将这些文件分别保存到我们的项目区域的根目录、`css`和`js`子文件夹中。
- en: 'In the code download, there are three images we also need: `small.jpg`, `medium.jpg`,
    and `large.jpg`; these need to go into the `img` subfolder as well.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码下载中，我们还需要三个图像：`small.jpg`、`medium.jpg`和`large.jpg`；这些图像也需要放入`img`子文件夹中。
- en: Now, we have our demo set up. Next, try resizing the browser window smaller
    or larger. Notice how the two images change, albeit at different response points.
    The key to this is the use of the `picturefill.js` polyfill created by Scott Jehl.
    This aims to replicate the functionality of `<picture>` until such time as the
    browser supports it natively and we can remove the fall back.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了我们的演示。接下来，尝试调整浏览器窗口的大小，注意这两张图像如何改变，尽管它们在不同的响应点。这个问题的关键是使用Scott Jehl创建的`picturefill.js`
    polyfill。这旨在复制`<picture>`的功能，直到浏览器原生支持它，我们才能移除回退。
- en: 'The library is called using this script block—`document.createElement` is used
    to create a dummy `picture` fallback element, as it doesn''t exist yet at this
    point:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该库通过以下脚本块调用——使用`document.createElement`创建一个虚拟的`picture`回退元素，因为在这个阶段它还不存在：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then provide the fallback code as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后提供以下回退代码：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is followed by the native <picture> element, which will be supported by
    Firefox, Opera, and Chrome within the next few versions of each browser:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这随后是原生的<picture>元素，它将在每个浏览器的下一个几个版本中得到Firefox、Opera和Chrome的支持：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It's worth getting to know the `<picture>` element. While it means that we have
    to have our CSS media queries in-line, it produces a cleaner result as we don't
    need to use individual media queries in a separate style sheet.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 值得了解`<picture>`元素。虽然这意味着我们必须将CSS媒体查询内联，但它会产生更干净的结果，因为我们不需要在单独的样式表中使用单独的媒体查询。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rather than using plain PNG or JPG images, you may like to look at using WebP
    images instead. They are technically similar but provide a better compression
    rate. You may need to get additional support added to use them in applications
    such as GIMP (visit [http://registry.gimp.org/node/25874](http://registry.gimp.org/node/25874)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用普通的 PNG 或 JPG 图像相比，您可能更喜欢使用 WebP 图像。它们在技术上相似，但提供了更好的压缩率。您可能需要为 GIMP 等应用程序添加额外的支持才能使用它们（访问
    [http://registry.gimp.org/node/25874](http://registry.gimp.org/node/25874)）。
- en: Maintaining the <picture> tag in our code
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的代码中维护 `<picture>` 标签
- en: 'A small word of warning: the `<picture>` tag is still very new, so expect there
    to be changes to the overall design before it is finalized. It may raise some
    important questions about whether using it is right for your needs and how it
    should be maintained within your code; for example, are you happy to use it, but
    accept that not every browser might support it yet? Are your needs such that you
    can''t use it yet, but can live with using a polyfill as an interim measure?'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小小的警告：`<picture>` 标签仍然非常新，所以在它最终确定之前，预计会有一些整体设计上的变化。它可能会提出一些重要的问题，关于是否使用它适合您的需求以及如何在您的代码中维护它；例如，您是否愿意使用它，但接受并非每个浏览器可能都支持它？您的需求是否如此，以至于您现在还不能使用它，但可以接受使用
    polyfill 作为临时措施？
- en: If you do decide to use it, it will require careful planning in terms of implementing
    it. Thankfully, Scott Jehl's implementation (as used in this chapter), is close
    to the intended final version of `<picture>`; this should make the switchover
    relatively painless.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实决定使用它，那么在实施过程中需要仔细规划。幸运的是，Scott Jehl 的实现（如本章所述），接近 `<picture>` 的预期最终版本；这应该会使转换相对容易。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To get an up-to-date picture (pun intended!) of the latest state of play with
    the `<picture>` tag and its use for responsive images, it's worth taking a look
    at the Responsive Image Community Group's site at [http://responsiveimages.org/](http://responsiveimages.org/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得关于 `<picture>` 标签及其在响应式图片中使用状态的最新情况（有意为之！），值得查看响应式图片社区小组的网站：[http://responsiveimages.org/](http://responsiveimages.org/)。
- en: In the last exercise, we mentioned some different formats and that something
    similar to WebP is a better alternative; we can do even better by using SVG, when
    working responsively. How? Let me reveal all with a look at using it for improved
    scalability.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个练习中，我们提到了一些不同的格式，以及类似于 WebP 的更好替代品；当进行响应式工作时，我们可以通过使用 SVG 来做得更好。如何？让我通过查看它如何用于改进可伸缩性来揭示一切。
- en: Working with the SVG image format for scalability
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SVG 图像格式以实现可伸缩性
- en: If you have spent any time working with media in a responsive capacity, no doubt
    you will find that some image formats don't resize well. To get around it, it
    may be necessary to provide several different versions of our image and set the
    code to pick the right one at the appropriate point.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在响应式媒体方面投入过任何时间，毫无疑问您会发现某些图像格式无法很好地缩放。为了解决这个问题，可能需要提供我们图像的几个不同版本，并设置代码在适当的点选择正确的版本。
- en: 'Do we want to be doing that all the time? Somehow I don''t think so. It''s
    a real pain to produce all those different versions! There''s a better way to
    achieve the same result if we switch to using the vector-based SVG format, which
    will resize smoothly without loss of quality. Let''s delve into an example to
    see how it works:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的想一直这样做吗？我 somehow 不这么认为。制作所有这些不同版本真的很痛苦！如果我们切换到基于矢量的 SVG 格式，就可以以不损失质量的方式平滑缩放，这将是一个更好的方法来实现相同的结果。让我们通过一个例子来深入了解它是如何工作的：
- en: We'll start with preparing the images that we will use for the purposes of this
    demo. We'll use the dark modern LCD display SVG image that is available from the
    XOO.me website at [http://xoo.me/template/details/12636-dark-modern-lcd-display-vector](http://xoo.me/template/details/12636-dark-modern-lcd-display-vector).
    If you prefer to use an alternative, then please alter the code accordingly; we
    will need PNG and SVG versions of the same image.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从准备我们将用于此演示目的的图像开始。我们将使用来自 XOO.me 网站的深色现代 LCD 显示 SVG 图像，网址为 [http://xoo.me/template/details/12636-dark-modern-lcd-display-vector](http://xoo.me/template/details/12636-dark-modern-lcd-display-vector)。如果您想使用替代品，请相应地更改代码；我们需要同一图像的
    PNG 和 SVG 版本。
- en: 'Add this code to a new file and save it as `svgfallback.html` in the root of
    our project folder:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到新文件中，并将其保存为 `svgfallback.html`，位于我们的项目文件夹根目录下：
- en: '[PRE18]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add the following CSS styles to a new file and save it as `svgfallback.css`
    in the `css` subfolder of our project folder:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下 CSS 样式添加到新文件中，并将其保存为 `svgfallback.css`，位于我们的项目文件夹 `css` 子文件夹中：
- en: '[PRE19]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's see what happens when we preview the results in most browsers; it will
    show the SVG image of our LCD monitor. Let's first look at the source code of
    our page in a DOM inspector where we can see both PNG and SVG ticked as shown
    in this screenshot; the latter takes precedence:![Working with the SVG image format
    for scalability](img/6968OT_01_10.jpg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看在大多数浏览器中预览结果时会发生什么；它将显示我们液晶显示器的SVG图像。让我们首先在DOM检查器中查看我们页面的源代码，在那里我们可以看到PNG和SVG都勾选了，如截图所示；后者优先：![使用SVG图像格式进行可扩展性处理](img/6968OT_01_10.jpg)
- en: To prove it works, the following is the SVG image in all its glory:![Working
    with the SVG image format for scalability](img/6968OT_01_11.jpg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了证明它有效，以下是在所有荣耀中的SVG图像：![使用SVG图像格式进行可扩展性处理](img/6968OT_01_11.jpg)
- en: To force our demo to display the PNG fallback, we need to emulate a browser
    that doesn't support SVG images natively; IE8 is a perfect candidate for this.
    I recommend using a recent version of IE, such as 9 or 10\. We can use its Emulation
    mode to force it to display in IE8 mode, and therefore choose the PNG image instead:![Working
    with the SVG image format for scalability](img/6968OT_01_12.jpg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要强制我们的演示显示PNG回退，我们需要模拟一个不支持SVG图像的原生浏览器；IE8是这一点的完美候选人。我建议使用IE的较新版本，例如9或10。我们可以使用其模拟模式来强制它在IE8模式下显示，因此选择PNG图像：![使用SVG图像格式进行可扩展性处理](img/6968OT_01_12.jpg)
- en: 'The beauty of using SVG is that we can actually edit the content of the image
    using a text editor; SVG images are after all just plain XML files! SVG images
    are great for several reasons:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SVG的美丽之处在于，我们实际上可以使用文本编辑器编辑图像的内容；毕竟，SVG图像只是普通的XML文件！SVG图像有几个优点：
- en: They are small file sizes that compress well
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小小，压缩效果好
- en: They scale to any size without losing clarity (except very tiny)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以缩放到任何大小而不会失去清晰度（除了非常小）
- en: They look great on retina display
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视网膜显示屏上看起来很棒
- en: They design control like interactivity and filters
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们设计控制，如交互性和过滤器
- en: Using standard images such as PNGs or JPGs will work, but they won't resize
    properly beyond their native resolution; instead, we are likely to need several
    versions of the same image in order to view them properly. It's worth spending
    time getting to know the SVG format. There is a useful article by Nick Salloum
    at [http://callmenick.com/2014/04/02/svg-fallback-with-png/](http://callmenick.com/2014/04/02/svg-fallback-with-png/),
    which extols different mechanisms we can use to provide fallback for SVG images.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准图像，如PNG或JPG，将有效，但它们不会在其原生分辨率之外正确调整大小；相反，我们可能需要同一图像的几个版本才能正确查看它们。花时间了解SVG格式是值得的。有一篇有用的文章由Nick
    Salloum撰写，可在[http://callmenick.com/2014/04/02/svg-fallback-with-png/](http://callmenick.com/2014/04/02/svg-fallback-with-png/)找到，它赞扬了我们可以用来为SVG图像提供回退的不同机制。
- en: If you really want to get into editing SVG images, take a look at [http://css-tricks.com/using-svg/](http://css-tricks.com/using-svg/).
    It's a great article by Chris Coyier that shows us how we can edit the content
    to really alter its appearance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想深入了解编辑SVG图像，看看[http://css-tricks.com/using-svg/](http://css-tricks.com/using-svg/)。这是Chris
    Coyier写的一篇很好的文章，展示了我们如何编辑内容以真正改变其外观。
- en: Using image icons for scalability
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图像图标进行可扩展性
- en: 'One of the major problems we have when creating responsive content is the use
    of icons: their bitmap format doesn''t scale well when resizing them. This is
    often the same for icon sprites; for example, if you resize the battery icons
    demo from earlier in the chapter, then you will soon notice how pixelated it becomes
    when anti-aliasing kicks in!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建响应式内容时遇到的一个主要问题是使用图标：它们的位图格式在调整大小时扩展性不好。这通常也适用于图标精灵；例如，如果你调整本章早期演示的电池图标大小，那么你很快就会注意到当抗锯齿启动时它变得多么像素化！
- en: To get around this, designers may simply drop the use of icons; the alternative
    is to replace them with vector-based web fonts, such as the Font Awesome icons,
    available at [http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/).
    There is an excellent article online by Jason Cranford Teague at [http://webstandardssherpa.com/reviews/responsive-webfont-icons](http://webstandardssherpa.com/reviews/responsive-webfont-icons),
    extolling the benefits of using them in the main due to their scalability with
    no loss of fidelity.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，设计师可能只是简单地放弃使用图标；另一种选择是用基于矢量的网络字体替换它们，例如在[http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/)可用的Font
    Awesome图标。在线有一篇由Jason Cranford Teague撰写的优秀文章[http://webstandardssherpa.com/reviews/responsive-webfont-icons](http://webstandardssherpa.com/reviews/responsive-webfont-icons)，赞扬了它们在可扩展性无失真的主要优点。
- en: To see how they work in action, we're going to use some social media icons from
    Entypo, created by Daniel Bruce and available at [http://www.entypo.com](http://www.entypo.com).
    For this tutorial, we're going to use a simplified version of an example created
    by Teague, which uses a number of icons. You can see the original article at [http://webstandardssherpa.com/reviews/responsive-webfont-icons](http://webstandardssherpa.com/reviews/responsive-webfont-icons).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到它们在实际中的工作情况，我们将使用来自Entypo的一些社交媒体图标，由Daniel Bruce创建，可在[http://www.entypo.com](http://www.entypo.com)找到。在这个教程中，我们将使用Teague创建的一个简化示例版本，它使用了许多图标。您可以在[http://webstandardssherpa.com/reviews/responsive-webfont-icons](http://webstandardssherpa.com/reviews/responsive-webfont-icons)上看到原始文章。
- en: 'Perform these steps for this tutorial:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个教程执行以下步骤：
- en: Let's start by extracting a copy of `webicons.html` and `webicons.css` from
    the code download that accompanies this book. Instead of building this up (particularly
    as it uses a fair bit of CSS), we're going to take a look at some of the key concepts
    in use. Store the `webicons.css` file in the `css` subfolder of our project folder,
    while the `webicons.html` file should be stored at the root.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先从这本书附带的代码下载中提取`webicons.html`和`webicons.css`的副本。我们不会从头开始构建（尤其是因为它使用了大量的CSS），而是要看看一些关键概念。将`webicons.css`文件存储在我们的项目文件夹的`css`子文件夹中，而`webicons.html`文件应存储在根目录。
- en: If we preview the file in a browser window, we will see a range of icons displayed;
    the screenshot shows them resized in Firefox at 67 percent:![Using image icons
    for scalability](img/6968OT_01_13.jpg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在浏览器窗口中预览该文件，我们将看到一系列图标显示；截图显示了在Firefox中调整到67%大小的它们：![使用图像图标进行可伸缩性](img/6968OT_01_13.jpg)
- en: Try zooming in and out. Notice how the icons increase and decrease in size without
    any apparent loss of quality? We've used web fonts, in place of standard images;
    this principle works beautifully for simple icons such as the logos used in our
    example. The key to this is the use of the `rem` sizes or root `em`. This sizes
    each character to the font size of the HTML element not the parent, which is used
    by `em`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试放大和缩小。注意图标的大小是如何增加和减少，同时没有明显的质量损失吗？我们使用了网络字体，而不是标准图像；这个原则在我们的例子中用于简单的图标，如标志，效果非常好。这个问题的关键在于使用`rem`尺寸或根`em`尺寸。这个尺寸将每个字符的大小设置为HTML元素的字体大小，而不是父元素，这是`em`所使用的。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There's a useful article by Jonathan Snook that explains how `rem` and `em`
    work, available at [http://snook.ca/archives/html_and_css/font-size-with-rem](http://snook.ca/archives/html_and_css/font-size-with-rem).
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Jonathan Snook有一篇有用的文章解释了`rem`和`em`是如何工作的，可在[http://snook.ca/archives/html_and_css/font-size-with-rem](http://snook.ca/archives/html_and_css/font-size-with-rem)找到。
- en: Notice the use of the format set for each icon? This is the **Unicode Private
    Use** area of the font; instead of using `t` from the font (which represents the
    Twitter icon), we can use this private use area. It achieves the same result.
    The only difference being that the letter `t` is not displayed when using the
    private area.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意每个图标所设置的格式？这是字体的**Unicode私有用途**区域；我们不是使用字体中的`t`（代表Twitter图标），而是可以使用这个私有用途区域。它达到了相同的效果。唯一的区别在于，当使用私有区域时，字母`t`不会显示。
- en: Note
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about Unicode Private Use Areas, take a look at the article
    on Wikipedia at [http://en.wikipedia.org/wiki/Private_Use_Areas](http://en.wikipedia.org/wiki/Private_Use_Areas).
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于Unicode私有用途区域的更多信息，请查看维基百科上的文章[http://en.wikipedia.org/wiki/Private_Use_Areas](http://en.wikipedia.org/wiki/Private_Use_Areas)。
- en: Let's move on and take a look at a couple of examples of real-world applications
    of responsive design, beginning with *Building a responsive carousel*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，看看一些响应式设计的实际应用示例，首先是*构建一个响应式轮播图*。
- en: Building a responsive carousel
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个响应式轮播图
- en: So far we've covered a lot of different techniques to help us produce responsive
    content. Most of it has been simple examples in a development context. It's time
    to take a look at a couple of examples of real-world applications where responsive
    functionality has been put to good use. Our first example is in the form of a
    responsive carousel. There are dozens of example libraries online that can be
    used to create one, so there is no need to build from scratch!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了很多不同的技术，帮助我们生成响应式内容。大多数都是在开发环境中的简单示例。现在是时候看看一些实际应用中的示例，其中响应式功能得到了很好的利用。我们的第一个例子是一个响应式轮播图。网上有数十个示例库可以用来创建一个，所以没有必要从头开始构建！
- en: Let's take a look at one of my favorites—`ResponsiveSlides.js`; it's a simple
    library that provides a useful solution, but doesn't try to achieve everything.
    We'll borrow one of their examples to see how it works.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我最喜欢的之一——`ResponsiveSlides.js`；这是一个简单的库，提供了一个有用的解决方案，但并不试图做到一切。我们将借鉴他们的一个示例来看看它是如何工作的。
- en: As always, we need to start somewhere. Let's begin by downloading the `ResponsiveSlides`
    library from [http://responsiveslides.com/](http://responsiveslides.com/); the
    current version is 1.5.4 at the time of writing. Save this in the `js` subfolder
    of our project folder.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要从某个地方开始。让我们先从下载`ResponsiveSlides`库开始，网址是[http://responsiveslides.com/](http://responsiveslides.com/)；写作时的当前版本是1.5.4。将其保存到我们项目文件夹的`js`子文件夹中。
- en: We also need the styling file for `ResponsiveSlides`, along with a copy of the
    jQuery library. Extract a copy of `carousel.css`, saving it in the `css` subfolder
    of our project folder; then do the same for jQuery in the `js` subfolder.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要`ResponsiveSlides`的样式文件以及jQuery库的副本。从代码下载中提取`carousel.css`的副本，并将其保存到我们项目文件夹的`css`子文件夹中；然后以相同的方式在`js`子文件夹中对jQuery进行操作。
- en: Note
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ResponsiveSlides` package comes with jQuery 1.8.3; I've tested it with
    Version 2.1.1 of jQuery with no apparent ill effects.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ResponsiveSlides`包附带jQuery 1.8.3；我已经用jQuery 2.1.1的版本测试过，没有出现明显的不良影响。'
- en: 'Next, extract a copy of `carousel.html` from the code download that accompanies
    this book; add the following code between the empty `<script>` tags immediately
    below the link to the `responsiveslides.js` library:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从本书附带的代码下载中提取`carousel.html`的副本；在`responsiveslides.js`库链接下面的空`<script>`标签之间添加以下代码：
- en: '[PRE20]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Save the file. If we preview the results in a browser, we will see our carousel
    appear.![Building a responsive carousel](img/6968OT_01_14.jpg)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。如果我们在一个浏览器中预览结果，我们会看到我们的轮播图出现。![构建响应式轮播图](img/6968OT_01_14.jpg)
- en: Try resizing the browser window now. We should see the carousel reduce in size
    but continue to scroll through the images with no loss of quality.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试调整浏览器窗口的大小。我们应该看到轮播图的大小减小，但继续滚动图片时不会损失质量。
- en: There are plenty of examples of responsive carousels available online—two such
    examples are WOW Slider at [http://wowslider.com/](http://wowslider.com/), with
    an example of what is possible at [http://www.wowslider.com/responsive-image-gallery-glass-collage.html](http://www.wowslider.com/responsive-image-gallery-glass-collage.html),
    Owl Carousel ([http://www.owlgraphic.com/owlcarousel](http://www.owlgraphic.com/owlcarousel))
    and BXSlider, available at [http://bxslider.com/](http://bxslider.com/). It is
    a matter of trying a selection and choosing the one that suits your requirements.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有很多响应式轮播图的例子——两个这样的例子是WOW Slider在[http://wowslider.com/](http://wowslider.com/)，以及[http://www.wowslider.com/responsive-image-gallery-glass-collage.html](http://www.wowslider.com/responsive-image-gallery-glass-collage.html)上的一个可能实现示例，Owl
    Carousel ([http://www.owlgraphic.com/owlcarousel](http://www.owlgraphic.com/owlcarousel))
    和 BXSlider，可在[http://bxslider.com/](http://bxslider.com/)找到。这完全取决于尝试选择一个并选择一个符合你需求的。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a prebuilt working example on the code download that accompanies this
    book. Extract copies of `carousel-finished.html` and `carousel-finished.css`,
    then rename them to `carousel.html` and `carousel.css`. You will need to extract
    the accompanying libraries, as outlined in this exercise, for it to operate correctly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带的代码下载中有一个预构建的工作示例。提取`carousel-finished.html`和`carousel-finished.css`的副本，然后将它们重命名为`carousel.html`和`carousel.css`。你需要提取本练习中概述的配套库，以便它能够正确运行。
- en: Creating responsive maps using Google Maps
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Google Maps创建响应式地图
- en: 'In the second of our two real-world examples, we''re going to look at making
    a responsive map using Google Maps. Responsive maps, I hear you ask? Surely this
    should come automatically, right? Well no, it doesn''t, which makes its use a
    little awkward on mobile devices. Fortunately, we can easily fix this; the great
    thing about it is that it only requires a little additional CSS:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的两个真实世界示例中的第二个，我们将探讨如何使用Google Maps制作响应式地图。响应式地图，你可能会问？这应该自动完成，对吧？嗯，不是的，这使它在移动设备上的使用有些尴尬。幸运的是，我们可以轻松解决这个问题；它的好处是，它只需要一点额外的CSS：
- en: Let's make a start by browsing to [http://maps.google.com](http://maps.google.com),
    then entering the zip code of our chosen location. In this instance, I will use
    the UK office of Packt Publishing, which is B3 2PB.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从浏览到[http://maps.google.com](http://maps.google.com)开始，然后输入我们选择的位置的邮政编码。在这个例子中，我将使用Packt
    Publishing的英国办公室，邮编为B3 2PB。
- en: Click on the cog, then select **Share and embed map**:![Creating responsive
    maps using Google Maps](img/6968OT_01_15.jpg)
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击齿轮图标，然后选择**共享和嵌入地图**：![使用谷歌地图创建响应式地图](img/6968OT_01_15.jpg)
- en: In the dialog box that appears, switch to the **Embed map** tab, then copy the
    contents of the text field starting with `<iframe src=…`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的对话框中，切换到**嵌入地图**选项卡，然后复制以`<iframe src=…`开头的文本字段内容。
- en: In a copy of the code download that accompanies this book, extract a copy of
    `googlemaps.html` in your favorite text editor and add the `<iframe>` code in
    between the `google-maps div` tags.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随本书附带的代码下载副本中，使用您最喜欢的文本编辑器提取`googlemaps.html`的副本，并在`google-maps div`标签之间添加`<iframe>`代码。
- en: 'Next, add this CSS styling to a new file and save it as `googlemaps.css`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下CSS样式添加到新文件中，并将其保存为`googlemaps.css`：
- en: '[PRE21]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If all is well, we will see a Google Maps image of Birmingham with our office
    marked accordingly:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将看到带有我们办公室标记的伯明翰的谷歌地图图像：
- en: '![Creating responsive maps using Google Maps](img/6968OT_01_16.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![使用谷歌地图创建响应式地图](img/6968OT_01_16.jpg)'
- en: At this point, try resizing the browser window. You will see that the map resizes
    automatically; the CSS styling that we've added has overridden the standard styles
    used within Google Maps to make our map responsive and accessible from any device
    we care to use.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，尝试调整浏览器窗口的大小。您将看到地图会自动调整大小；我们添加的CSS样式已覆盖了谷歌地图中使用的标准样式，使我们的地图能够适应任何我们想要使用的设备。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow! We've certainly covered a lot over the last few pages! Let's take a moment
    to recap and let what we've learned sink in.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！在过去的几页中，我们确实覆盖了很多内容！让我们花点时间回顾一下，让所学的内容深入人心。
- en: We began with a look at creating basic fluid images, which are a key to responsive
    design and should form the mainstay for any responsively designed site. We then
    covered some key points in the form of what image formats to use, as well as whether
    we need to use any vendor prefixes in our code. Next up came a discussion on some
    useful tips to cater to mobile devices. We saw how many are common sense, but
    particularly apply when designing for mobile devices.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建基本流体图像开始，这是响应式设计的关键，应该成为任何响应式设计网站的基础。然后我们讨论了一些关键点，包括使用哪些图像格式，以及我们是否需要在代码中使用任何供应商前缀。接下来是关于如何为移动设备提供一些有用的技巧的讨论。我们看到许多都是常识，但特别适用于为移动设备设计。
- en: Our first coding example came in the form of a look at catering to high-definition
    or retina images; we then moved on to examining how we can also use sprites to
    add responsive media to our projects. We then moved on to looking at sizing our
    available viewport space using both jQuery and CSS; these we can then use to determine
    what our media queries should look like. We also covered off how you can use JavaScript
    to define media queries as well, in the event we need to provide fallback support
    in our sites.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个编码示例是查看如何满足高清或视网膜图像的需求；然后我们转向检查我们如何也可以使用精灵为我们的项目添加响应式媒体。然后我们转向使用jQuery和CSS来调整可用视口空间的大小；然后我们可以使用这些来决定我们的媒体查询应该是什么样子。我们还介绍了如何使用JavaScript来定义媒体查询，以防我们需要在我们的网站上提供回退支持。
- en: Moving on, next up we covered a couple of examples of how to switch images responsively—the
    first using data tags and the second using the upcoming `<picture>` tags. We also
    looked at a trick whereby we can provide two images at the same time but rely
    on the browser to pick which one it can support. We finished our look at using
    images in the form of a peek at how we can use web icons to serve content responsively
    and that these scale beautifully without any loss of quality. We then finished
    of the chapter with a look at two real-world examples in the form of building
    a responsive carousel and creating responsive maps.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了如何响应式地切换图像的几个示例——第一个使用数据标签，第二个使用即将推出的`<picture>`标签。我们还查看了一个技巧，我们可以同时提供两张图片，但依赖于浏览器选择它能够支持的图片。我们通过查看如何使用网络图标来提供响应式内容并保持高质量缩放来完成对图像的探讨。然后我们通过查看两个实际案例来结束本章，这些案例是构建响应式轮播图和创建响应式地图。
- en: In the next chapter, we'll take a look at the other major element of media content
    and how to add videos responsively to our sites.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨媒体内容的另一个主要元素，以及如何将视频响应式地添加到我们的网站上。
