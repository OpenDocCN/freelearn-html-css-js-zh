- en: Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: JavaScript has classes that provide a much simpler and clearer syntax for creating
    constructors and dealing with inheritance. Until now, JavaScript never had the
    concept of classes, although it's an object-oriented programming language. Programmers
    from other programming language backgrounds often found it difficult to understand
    JavaScript's object-oriented model and inheritance due to the lack of classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有类，它们提供了创建构造函数和处理继承的更简单、更清晰的语法。直到现在，JavaScript 从来没有类的概念，尽管它是一种面向对象的编程语言。来自其他编程语言背景的程序员常常因为缺乏类而发现理解
    JavaScript 的面向对象模型和继承很困难。
- en: 'In this chapter, we will learn about object-oriented JavaScript using classes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过类学习面向对象的 JavaScript：
- en: JavaScript data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 数据类型
- en: Creating objects the classical way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以传统方式创建对象
- en: The constructors of the primitive types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型的构造函数
- en: What are classes?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类？
- en: Creating objects using classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类创建对象
- en: Inheritance in classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的继承
- en: The features of classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的特性
- en: Understanding object-oriented JavaScript
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向对象的 JavaScript
- en: Before we proceed with ES6 classes, let's refresh our knowledge of JavaScript
    data types, constructors, and inheritance. While learning classes, we will be
    comparing the syntax of  constructors and prototype-based inheritance with the
    syntax of classes. Therefore, it is important to have a good grasp of these topics.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续学习 ES6 类之前，让我们回顾一下 JavaScript 数据类型、构造函数和继承的知识。在学习类的同时，我们将比较基于构造函数和原型继承的语法与类的语法。因此，对这些主题有良好的掌握是很重要的。
- en: The JavaScript data types
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 数据类型
- en: 'JavaScript variables hold (or store) data (or values). The type of data variables
    that they hold is called the data type. In JavaScript, there are seven different
    data types: number, string, Boolean, null, undefined, symbol, and object.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 变量持有（或存储）数据（或值）。变量持有的数据类型称为数据类型。在 JavaScript 中，有七种不同的数据类型：number、string、Boolean、null、undefined、symbol
    和 object。
- en: When it comes to holding objects, variables hold the object reference (that
    is, the memory address) instead of the object itself. If you're coming from a
    C/C++ background, you can relate them to pointers, but not exactly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到存储对象时，变量持有对象引用（即内存地址）而不是对象本身。如果你来自 C/C++ 背景，你可以将它们与指针联系起来，但并不完全一样。
- en: All data types other than objects are called primitive data types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对象之外的所有数据类型都称为原始数据类型。
- en: The arrays and functions are actually the JavaScript objects. A lot of things
    are objects under the hood.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和函数实际上是 JavaScript 对象。很多事物在底层都是对象。
- en: Creating objects
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'There are two ways of creating an object in JavaScript: using the `object`
    literal, or using a `constructor`. The `object` literal is used when we want to
    create fixed objects, whereas a `constructor` is used when we want to create objects
    dynamically at runtime.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中创建对象有两种方式：使用 `object` 字面量，或使用 `constructor`。当我们需要创建固定对象时使用 `object`
    字面量，而当我们想要在运行时动态创建对象时使用 `constructor`。
- en: 'Let''s consider a case where we may need to use the `constructor` instead of
    the `object` literal. Here is a code example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个可能需要使用 `constructor` 而不是 `object` 字面量的情况。以下是一个代码示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we created a `student` object using the `object` literal, that is, the
    `{}` notation. This works well when you just want to create a single `student`
    object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `object` 字面量创建了一个 `student` 对象，即 `{}` 符号。当你只想创建单个 `student` 对象时，这很有效。
- en: But the problem arises when you want to create multiple `student` objects. Obviously,
    you don't want to write the previous code multiple times to create multiple `student`
    objects. This is where `constructor` comes into use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题出现在你想要创建多个 `student` 对象时。显然，你不想多次编写之前的代码来创建多个 `student` 对象。这就是 `constructor`
    发挥作用的地方。
- en: 'A `function` acts like a `constructor` when invoked using the `new` keyword.
    A `constructor` creates and returns an object. The `this` keyword inside a `function`,
    when invoked as a `constructor`, points to the new object instance, and once the
    `constructor` execution is finished, the new object is automatically returned.
    Consider this example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `new` 关键字调用时，`function` 作为一个 `constructor`。`constructor` 创建并返回一个对象。在作为 `constructor`
    调用时的 `function` 内部的 `this` 关键字指向新的对象实例，一旦 `constructor` 执行完成，新的对象就会自动返回。考虑以下示例：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, to create multiple `student` objects, we invoked the `constructor` multiple
    times instead of creating multiple `student` objects using the `object` literals.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了创建多个`student`对象，我们多次调用了`constructor`，而不是使用`object`字面量创建多个`student`对象。
- en: To add methods to the instances of the `constructor`, we didn't use the `this`
    keyword; instead, we used the `prototype` property of `constructor`. We will learn
    more about why we did it this way, and what the `prototype` property is, in the
    next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`constructor`的实例添加方法，我们没有使用`this`关键字；相反，我们使用了`constructor`的`prototype`属性。我们将在下一节中了解更多关于为什么这样做，以及`prototype`属性是什么。
- en: 'Actually, every object must belong to a `constructor`. Every object has an
    inherited property named `constructor`, pointing to the object''s `constructor`.
    When we create objects using the `object` literal, the `constructor` property
    points to the global `Object` of the `constructor`. Consider this example to understand
    this behavior:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个对象都必须属于一个`constructor`。每个对象都有一个继承属性名为`constructor`，指向对象的`constructor`。当我们使用`object`字面量创建对象时，`constructor`属性指向全局的`Object`的`constructor`。考虑以下示例来理解这种行为：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Understanding the prototypal inheritance model
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解原型继承模型
- en: Each JavaScript object has an internal `[[prototype]]` property pointing to
    another object called its prototype. This prototype object has a prototype of
    its own, and so on, until an object is reached with null as its prototype. null
    has no prototype, and it acts as a final link in the prototype chain.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个JavaScript对象都有一个指向另一个对象的内嵌`[[prototype]]`属性，这个对象被称为其原型。这个原型对象有自己的原型，以此类推，直到遇到原型为null的对象。null没有原型，并且作为原型链中的最后一个链接。
- en: When trying to access a property of an object, and if the property is not found
    in the object, then the property is searched for in the object's prototype. If
    still not found, then it's searched for in the prototype of the prototype object.
    It keeps on going until null is encountered in the prototype chain. This is how
    inheritance works in JavaScript.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试访问一个对象属性时，如果该属性在对象中找不到，那么就会在对象的原型中搜索该属性。如果仍然找不到，那么就会在原型对象的原型中搜索。这个过程会一直持续到原型链中遇到null。这就是JavaScript中继承的工作方式。
- en: As a JavaScript object can have only one prototype, JavaScript supports only
    a single inheritance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript对象只能有一个原型，JavaScript只支持单继承。
- en: While creating objects using the `object` literal, we can use the special `__proto__`
    property or the `Object.setPrototypeOf()` method to assign a prototype of an object.
    JavaScript also provides an `Object.create()` method, with which we can create
    a new object with a specified prototype, as `__proto__` lacks browser support,
    and the `Object.setPrototypeOf()` method seems a little odd.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`object`字面量创建对象时，我们可以使用特殊的`__proto__`属性或`Object.setPrototypeOf()`方法来为对象分配一个原型。JavaScript还提供了一个`Object.create()`方法，我们可以使用它来创建一个具有指定原型的新的对象，因为`__proto__`在浏览器中不受支持，而`Object.setPrototypeOf()`方法看起来有点奇怪。
- en: 'Here is a code example that demonstrates different ways to set the prototype
    of an object while creating that particular object using the O`bject` literal:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了在创建特定对象时使用`Object`字面量设置对象原型的不同方法：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `{age:24}` object is referred to as a base object, super object, or
    parent object as it's being inherited. And the `{name:"Eden"}` object is referred
    to as the derived object, subobject, or the child object, as it inherits another
    object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`{age:24}`对象被称为基对象、超对象或父对象，因为它正在被继承。而`{name:"Eden"}`对象被称为派生对象、子对象或子对象，因为它继承另一个对象。
- en: 'If you don''t assign a prototype to an object while creating it using the `object`
    literal, then the prototype points to the `Object.prototype` property. The prototype
    of `Object.prototype` is null, therefore leading to the end of the prototype chain.
    Here is an example to demonstrate this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用`object`字面量创建对象时没有为其分配原型，那么原型将指向`Object.prototype`属性。`Object.prototype`的原型是null，因此导致原型链的结束。以下是一个示例来演示这一点：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While creating objects using a `constructor`, the prototype of the new objects
    always points to a property named prototype of the `function` object. By default,
    the `prototype` property is an object with one property named the `constructor`.
    The `constructor` property points to the `function` itself. Consider this example
    to understand this model:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`constructor`创建对象时，新对象的原型始终指向一个名为`prototype`的属性，该属性属于`function`对象。默认情况下，`prototype`属性是一个具有一个名为`constructor`的属性的对象。`constructor`属性指向该函数本身。考虑以下示例以理解此模型：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To add new methods to the instances of a `constructor`, we should add them to
    the `prototype` property of the `constructor`, as we did earlier.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`constructor`的实例添加新方法，我们应该像之前做的那样，将它们添加到`constructor`的`prototype`属性中。
- en: 'The reason why we didn''t add the methods to the `constructor` using `this` previously
    is that every instance of the `constructor` will have a copy of the methods, and
    this isn''t very memory-efficient. By attaching methods to the `prototype` property
    of a `constructor`, there is only one copy of each function that all the instances
    share. To understand this, consider this example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有使用`this`将方法添加到`constructor`中的原因是因为每个`constructor`的实例都将有一个方法副本，这并不非常节省内存。通过将方法附加到`constructor`的`prototype`属性，每个函数只有一个副本，所有实例都共享。为了理解这一点，请考虑以下示例：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `s1` and `s2` share the same `printName` function that reduces the use
    of memory, whereas `s3` and `s4` contain two different functions called `printName`
    that make the program use more memory. This is unnecessary, as both the functions
    do the same thing. Therefore, we add methods for the instances to the `prototype`
    property of the `constructor`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s1`和`s2`共享相同的`printName`函数，这减少了内存的使用，而`s3`和`s4`包含两个不同的`printName`函数，使得程序使用更多的内存。这是不必要的，因为这两个函数执行的是相同的事情。因此，我们将实例的方法添加到`constructor`的`prototype`属性中。
- en: Implementing the inheritance hierarchy in the `constructor` is not as straightforward
    as for `object` literals. This is because the child `constructor` needs to invoke
    the parent `constructor` for the parent constructor's initialization logic to
    take place, and we need to add the methods of the `prototype` property of the
    parent `constructor` to the `prototype` property of the child `constructor` so
    that we can use them with the objects of the child `constructor`. There is no
    predefined way to do all this. Developers and JavaScript libraries have their
    own ways of doing this. I will show you the most common way of doing it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`constructor`中实现继承层次结构并不像在`object`字面量中那样直接。这是因为子`constructor`需要调用父`constructor`以执行父构造函数的初始化逻辑，并且我们需要将父`constructor`的`prototype`属性的函数添加到子`constructor`的`prototype`属性中，以便我们可以使用它们与子`constructor`的对象一起使用。没有预定义的方法来完成所有这些。开发人员和JavaScript库有他们自己的方法来做这件事。我将向您展示最常见的方法。
- en: 'Here is an example to demonstrate how to implement inheritance while creating
    objects using the constructors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何在创建对象时实现继承：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we invoked the parent `constructor` using the `call` method of the `function`
    object. To inherit the methods, we created an instance of the parent `constructor`
    and assigned it to the child constructor's `prototype` property.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用函数对象的`call`方法调用了父`constructor`。为了继承方法，我们创建了一个父`constructor`的实例并将其赋值给子构造函数的`prototype`属性。
- en: This is not a foolproof way of implementing inheritance in the constructors,
    as there are lots of potential problems. For example, if the parent `constructor`
    does something other than just initialize properties, such as DOM manipulation,
    then assigning a new instance of the parent `constructor` to the `prototype` property
    of the child `constructor` can cause problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是在构造函数中实现继承的万无一失的方法，因为这里存在许多潜在的问题。例如，如果父`constructor`执行的操作不仅仅是初始化属性，比如DOM操作，那么将父`constructor`的新实例赋值给子`constructor`的`prototype`属性可能会导致问题。
- en: Therefore, classes provide a better and easier way to inherit existing constructors
    and classes. We will see more on this later in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类提供了更好的、更简单的方式来继承现有的构造函数和类。我们将在本章后面看到更多关于这一点的内容。
- en: The constructors of primitive data types
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型的构造函数
- en: Primitive data types, such as Boolean, string, and number, have their constructor
    counterparts. These counterpart constructors behave like wrappers for these primitive
    types. For example, the `String` constructor is used to create a string object
    that contains an internal `[[PrimitiveValue]]` property that holds the actual
    primitive value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据类型，如布尔值、字符串和数字，都有它们的构造函数对应物。这些对应构造函数的行为就像这些原始类型的包装器。例如，`String` 构造函数用于创建一个包含内部
    `[[PrimitiveValue]]` 属性的字符串对象，该属性持有实际的原始值。
- en: 'At runtime, wherever necessary, the primitive values are wrapped with their
    `constructor` counterparts, and the counterpart objects are treated as primitive
    values so that the code works as expected. Consider this example code to understand
    how it works:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时， wherever necessary，原始值会被它们的 `constructor` 对应物所包裹，而对应对象则被当作原始值来处理，这样代码才能按预期工作。考虑以下示例代码来理解它是如何工作的：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `s1` is a primitive type, and `s2` is an object although applying the
    `==` operator on them gives us a true result. s1 is a primitive type but still
    we are able to access the length property even though primitive types shouldn't
    have any properties.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s1` 是一个原始类型，而 `s2` 是一个对象，尽管对它们应用 `==` 操作符会得到一个真值。`s1` 是一个原始类型，但我们仍然能够访问长度属性，尽管原始类型不应该有任何属性。
- en: 'All this is happening because the previous code was converted into this at
    run-time:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在运行时将之前的代码转换为以下内容发生的：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we can see how the primitive value was wrapped with its `constructor`
    counterpart, and how the object counterpart was treated as a primitive value where
    necessary. Therefore, the code works as expected.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到原始值是如何被包裹在其 `constructor` 对应物中的，以及对象对应物在必要时是如何被当作原始值处理的。因此，代码按预期工作。
- en: Primitive types introduced from ES6 onwards won't allow their counterpart functions
    to be invoked as constructors, that is, we can't explicitly wrap them using their
    object counterparts. We saw this behavior while learning symbols.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ES6 开始引入的原始类型不会允许它们的对应函数作为构造函数被调用，也就是说，我们不能使用它们的对象对应物显式地包裹它们。我们在学习符号时看到了这种行为。
- en: The null and undefined primitive types don't have any counterpart constructors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 和 `undefined` 原始类型没有对应的构造函数。'
- en: Using classes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类
- en: We saw that JavaScript's object-oriented model is based on constructors and
    prototype-based inheritance. Well, ES6 classes are just a new syntax for the existing
    model. Classes do not introduce a new object-oriented model to JavaScript.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，JavaScript 的面向对象模型是基于构造函数和基于原型的继承。嗯，ES6 类只是现有模型的一种新语法。类并没有为 JavaScript
    引入一个新的面向对象模型。
- en: ES6 classes aim to provide a much simpler and clearer syntax for dealing with
    the constructors and inheritance.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 类旨在提供一种更简单、更清晰的语法来处理构造函数和继承。
- en: In fact, classes are functions. Classes are just a new syntax for creating functions
    that are used as constructors. Creating functions using classes that aren't used
    as constructors doesn't make any sense, and offers no benefits.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，类是函数。类只是创建用作构造函数的函数的一种新语法。使用类创建不作为构造函数使用的函数没有任何意义，也不提供任何好处。
- en: Rather, it makes your code difficult to read, as it becomes confusing. Therefore,
    use classes only if you want to use them to construct objects. Let's have a look
    at classes in detail.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这会让你的代码难以阅读，因为它变得混乱。因此，只有当你想使用类来构建对象时才使用类。让我们详细看看类。
- en: Defining a class
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个类
- en: 'Just as there are two ways of defining functions, function declarations and
    function expressions, there are two ways to define a class: using the class declaration
    and the class expression.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如定义函数有两种方式，函数声明和函数表达式一样，定义类也有两种方式：使用类声明和类表达式。
- en: The class declaration
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类声明
- en: To define a class using the `class` declaration, you need to use the `class`
    keyword and a name for the `class`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `class` 声明来定义一个类，你需要使用 `class` 关键字并为 `class` 提供一个名称。
- en: 'Here is a code example to demonstrate how to define a class using the `class`
    declaration:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示如何使用 `class` 声明来定义一个类：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we created a `class` named `Student`. Then, we defined a `constructor`
    method in it. Finally, we created a new instance of the class—an object, and logged
    the name property of the object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `Student` 的 `class`。然后，我们在其中定义了一个 `constructor` 方法。最后，我们创建了该类的一个新实例——一个对象，并记录了该对象的名字属性。
- en: The body of a `class` is in the curly brackets, that is, `{}`. This is where
    we need to define methods. Methods are defined without the `function` keyword,
    and a comma is not used in between the methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类的主体在花括号 `{}` 中。这是我们定义方法的地方。方法定义时不使用 `function` 关键字，方法之间不用逗号分隔。
- en: Classes are treated as functions; internally the class name is treated as the
    function name, and the body of the `constructor` method is treated as the body
    of the function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类被视为函数；内部上，类名被视为函数名，`constructor` 方法的主体被视为函数的主体。
- en: There can only be one `constructor` method in a `class`. Defining more than
    one `constructor` will throw the `SyntaxError` exception.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `class` 中只能有一个 `constructor` 方法。定义多个 `constructor` 将会抛出 `SyntaxError` 异常。
- en: All the code inside a class body is executed in strict mode, by default.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类主体内的所有代码都在严格模式下执行。
- en: 'The previous code is the same as this code when written using a `function`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `function` 编写时，前面的代码与以下代码相同：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To prove that a `class` is a `function`, consider this code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明一个 `class` 是一个 `function`，考虑以下代码：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we can see that a `class` is a `function`. It's just a new syntax for
    creating a function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到 `class` 是一个 `function`。它只是创建函数的新语法。
- en: The class expression
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类表达式
- en: A class expression has a similar syntax to a `class` declaration. However, with
    `class` expressions, you are able to omit the class name. The body and behavior
    remain the same both ways.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类表达式具有与类声明类似的语法。然而，使用类表达式时，您可以省略类名。两种方式下的主体和行为都保持不变。
- en: 'Here is a code example to demonstrate how to define a `class` using a `class`
    expression:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示如何使用类表达式定义一个 `class`：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we stored a reference of the `class` in a variable and used it to construct
    the objects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将 `class` 的引用存储在一个变量中，并使用它来构造对象。
- en: 'The previous code is the same as this code when written using a `function`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `function` 编写时，前面的代码与以下代码相同：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The prototype methods
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型方法
- en: All the methods in the body of the `class` are added to the `prototype` property
    of the class. The `prototype` property is the prototype of the objects created
    using `class`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类主体中的所有方法都被添加到类的 `prototype` 属性中。`prototype` 属性是使用 `class` 创建的对象的原型。
- en: 'Here is an example that shows how to add methods to the `prototype` property
    of a `class`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示如何向 `class` 的 `prototype` 属性添加方法：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we can see that the `printProfile` method was added to the `prototype`
    property of the `class`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到 `printProfile` 方法被添加到了 `class` 的 `prototype` 属性中。
- en: 'The previous code is the same as this code when written using a `function`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `function` 编写时，前面的代码与以下代码相同：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Getters and setters
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: Earlier, to add accessor properties to objects we had to use the `Object. defineProperty()`
    method. From ES6 onwards, there are get and set prefixes for methods. These methods
    can be added to `object` literals and classes to define the get and set attributes
    of the accessor properties.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，为了向对象添加访问器属性，我们必须使用 `Object.defineProperty()` 方法。从 ES6 开始，有 `get` 和 `set`
    前缀用于方法。这些方法可以被添加到对象字面量和类中，以定义访问器属性的获取和设置属性。
- en: When get and `set` methods are used in a `class` body, they are added to the
    `prototype` property of the class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当在类主体中使用 `get` 和 `set` 方法时，它们会被添加到类的 `prototype` 属性中。
- en: 'Here is an example to demonstrate how to define the `get` and `set` methods
    in a `class`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何在 `class` 中定义 `get` 和 `set` 方法：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we created an accessor property to encapsulate the `_name_` property.
    We also logged some other information to prove that `name` is an accessor property that
    is added to the `prototype` property of the `class`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个访问器属性来封装 `_name_` 属性。我们还记录了一些其他信息来证明 `name` 是一个添加到 `class` 的 `prototype`
    属性的访问器属性。
- en: The generator method
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`generator` 方法'
- en: To treat a concise method of an `object` literal as the `generator` method,
    or to treat a method of a `class` as the `generator` method, we can simply prefix
    it with the `*` character.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个对象的简洁方法视为 `generator` 方法，或者将一个类的方法视为 `generator` 方法，我们只需在它前面加上 `*` 字符。
- en: The `generator` method of a class is added to the `prototype` property of the
    class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类的 `generator` 方法被添加到类的 `prototype` 属性中。
- en: 'Here is an example to demonstrate how to define a `generator` method in the
    `class`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何在 `class` 中定义 `generator` 方法：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Static methods
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: The methods that are added to the body of the `class` with the `static` prefix
    are called `static` methods. The `static` methods are the class' own methods; that
    is, they are added to the class itself rather than the `prototype` property of
    the `class`. For example, the `String.fromCharCode()` method is a `static` method
    of the string `constructor`, that is, `fromCharCode` is the property of the `String`
    function itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `static` 前缀添加到 `class` 体内的方法称为 `static` 方法。`static` 方法是类的自身方法；也就是说，它们是添加到类本身而不是类的
    `prototype` 属性。例如，`String.fromCharCode()` 方法是字符串构造函数的 `static` 方法，即 `fromCharCode`
    是 `String` 函数本身的属性。
- en: The `static` methods are often used to create utility functions for an application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 方法通常用于创建应用程序的实用函数。'
- en: 'Here is an example to demonstrate how to define and use a `static` method in
    a `class`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何在 `class` 中定义和使用 `static` 方法：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Implementing inheritance in classes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类中实现继承
- en: Earlier in this chapter, we saw how difficult it was to implement inheritance
    hierarchies in functions. Therefore, ES6 aims to make it easy by introducing the
    `extends` clause and the `super` keyword for classes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们看到了在函数中实现继承层次结构的难度。因此，ES6 通过引入 `extends` 子句和 `class` 的 `super` 关键字来简化这一点。
- en: By using the `extends` clause, a `class` can inherit static and non-static properties
    from another `constructor` (which may or may not be defined using a class).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `extends` 子句，一个 `class` 可以从另一个 `constructor`（可能使用类定义，也可能不是）继承静态和非静态属性。
- en: 'The super keyword is used in two ways:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`super` 关键字有两种用法：'
- en: It's used in a class `constructor` method to call the parent `constructor`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于类 `constructor` 方法中调用父 `constructor`
- en: When used inside the methods of a `class`, it references the static and non-static
    methods of the parent `constructor`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在 `class` 的方法中使用时，它引用父 `constructor` 的静态和非静态方法
- en: 'Here is an example to demonstrate how to implement an inheritance hierarchy
    in constructors using the `extends` clause, and the `super` keyword:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何使用 `extends` 子句和 `super` 关键字在构造函数中实现继承层次结构：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `A` is a function `constructor`; `B` is a `class` that inherits `A`; `C`
    is a `class` that inherits `B`; and as `B` inherits `A`, therefore `C` also inherits
    `A`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`A` 是一个函数构造函数；`B` 是继承 `A` 的 `class`；`C` 是继承 `B` 的 `class`；由于 `B` 继承了 `A`，因此
    `C` 也继承了 `A`。
- en: As a class can inherit a function `constructor`, we can also inherit prebuilt
    function constructors, such as string and array, and also custom function constructors
    using the classes instead of the alternative hacky ways that we used to use.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类可以继承函数构造函数，我们也可以通过类继承预构建的函数构造函数，例如字符串和数组，以及使用类而不是我们以前使用的替代性笨拙方法来创建自定义函数构造函数。
- en: The previous example also shows how and where to use the `super` keyword. Remember
    that, inside the `constructor` method, you need to use the `super` keyword before
    using the `this` keyword. Otherwise, an exception is thrown.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例还展示了如何以及在哪里使用 `super` 关键字。记住，在 `constructor` 方法内部，在使用 `this` 关键字之前需要使用
    `super` 关键字。否则，会抛出异常。
- en: If a child class doesn't have a `constructor` method, then the default behavior
    will invoke the `constructor` method of the parent class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子类没有 `constructor` 方法，则默认行为将调用父类的 `constructor` 方法。
- en: Computed method names
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算方法名称
- en: 'You can also decide the name of static and non-static methods of a `class`
    and concise methods of an `object` literal at run-time; that is, you can define
    method name via expressions. Here is an example to demonstrate this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在运行时决定 `class` 的静态和非静态方法以及对象字面量的简洁方法名称；也就是说，你可以通过表达式定义方法名称。下面是一个示例来演示这一点：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Computed property names also allow you to use symbols as keys for the methods.
    Here is an example to demonstrate this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性名称还允许你使用符号作为方法的键。下面是一个示例来演示这一点：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The attributes of properties
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性的属性特征
- en: 'When using a class, the attributes of the static and non-static properties
    of the `constructor` are different from when declared using a function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `class` 时，静态和非静态属性的属性与使用函数声明的属性不同：
- en: The `static` methods are writable and configurable, but not enumerable
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 方法是可写的和可配置的，但不可枚举'
- en: The `prototype` property and the `prototype.constructor` property of a `class`
    are not writable, enumerable, or configurable
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class` 的 `prototype` 属性和 `prototype.constructor` 属性是不可写的、不可枚举的或不可配置的'
- en: The properties of the `prototype` property are writable and configurable, but
    not enumerable
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prototype` 属性的属性是可写和可配置的，但不是可枚举的'
- en: Classes are not hoisted!
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类不会被提升！
- en: You can call a function before it's defined; that is, function calls can be
    made before the function definition. But, you cannot use a `class` before it's
    defined. Trying to do so in classes will throw the `ReferenceError` exception.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在定义函数之前调用它；也就是说，可以在函数定义之前调用函数调用。但是，你无法在定义之前使用 `class`。在类中尝试这样做将抛出 `ReferenceError`
    异常。
- en: 'Here is an example to demonstrate this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例来演示这一点：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Overriding the result of the constructor method
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖构造函数方法的返回结果
- en: The `constructor` method, by default, returns the new instance if there is no
    return statement in it. If there is a return statement, then any value in the
    return statement is returned. This might seem a little weird if you're coming
    from a language like C++ as you cannot usually return any value from the `constructor` there.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`constructor` 方法如果没有返回语句，则返回新实例。如果有返回语句，则返回语句中的任何值。如果你来自像 C++ 这样的语言，这可能会显得有些奇怪，因为在那里通常不能从
    `constructor` 返回任何值。
- en: 'Here is an example to demonstrate this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例来演示这一点：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Symbol.species static accessor property
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Symbol.species 静态访问器属性
- en: The `@@species` static accessor property is optionally added to a child `constructor` in
    order to notify the methods of the parent `constructor` about what the `constructor`
    should use if the parent constructor's methods are returning new instances. If
    the `@@species` static accessor property is not defined on a child `constructor`,
    then the methods of the parent `constructor` can use the default `constructor`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`@@species` 静态访问器属性可选地添加到子 `constructor` 中，以便通知父 `constructor` 的方法，如果父构造函数的方法返回新的实例，则构造函数应该使用什么。如果子
    `constructor` 上未定义 `@@species` 静态访问器属性，则父 `constructor` 的方法可以使用默认的 `constructor`。'
- en: Consider this example to understand the use of `@@species`—the `map()` method
    of the array objects returns a new Array instance. If we call the `map()` method
    of an object that inherits an `Array` object, then the `map()` method returns
    a new instance of the child `constructor` instead of the `Array` constructor,
    which is not what we always want. The `@@species` property, which provides a way
    to signal such kinds of functions, uses a different `constructor` instead of the
    default `constructor`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例以了解 `@@species` 的使用——数组对象的 `map()` 方法返回一个新的数组实例。如果我们调用继承自 `Array` 对象的对象的
    `map()` 方法，那么 `map()` 方法将返回子 `constructor` 的新实例而不是 `Array` 构造函数，这通常不是我们想要的。提供此类函数信号方式的
    `@@species` 属性使用不同的 `constructor` 而不是默认的 `constructor`。
- en: 'Here is a code example to demonstrate how to use the `@@species` static accessor
    property:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例来演示如何使用 `@@species` 静态访问器属性：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is recommended that, if you are creating a JavaScript library, then the
    methods of the constructors in your library should always look for the `@@species`
    property while returning new instances. Here is an example to demonstrate this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在创建 JavaScript 库，建议你的库中的构造函数方法在返回新实例时始终查找 `@@species` 属性。以下是一个示例来演示这一点：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you don't want to define a default `@@species` property in parent constructors,
    then you can use the `if…else` conditional to check whether the `@@species` property
    is defined or not, but the previous pattern is preferred. The built-in `map()`
    method also uses the previous pattern.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在父构造函数中定义默认的 `@@species` 属性，则可以使用 `if…else` 条件语句检查 `@@species` 属性是否已定义，但首选的模式是之前的模式。内置的
    `map()` 方法也使用之前的模式。
- en: All the built-in methods of the JavaScript constructors from ES6 look for a
    `@@species` property if they return a new instance. For example, the methods of
    `Array`, `Map`, `ArrayBuffer`, `Promise`, and other such constructors look for
    the `@@species` property if they return new instances.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ES6 开始，JavaScript 构造函数的所有内置方法在返回新实例时都会查找 `@@species` 属性。例如，`Array`、`Map`、`ArrayBuffer`、`Promise`
    和其他此类构造函数的方法在返回新实例时会查找 `@@species` 属性。
- en: The new.target implicit parameter
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`new.target` 隐式参数'
- en: 'The default value of new.target is undefined, but when a function is invoked
    as a constructor, the value of the new.target parameter depends on the following
    conditions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`new.target` 的默认值是 `undefined`，但当一个函数作为构造函数被调用时，`new.target` 参数的值取决于以下条件：'
- en: If a constructor is invoked using a new operator, then new.target points to
    this constructor
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `new` 运算符调用构造函数，则 `new.target` 指向此构造函数
- en: If a constructor is invoked via the super keyword, then the value of new.target
    in it is the same as the value of new.target of the constructor that is called
    super.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过super关键字调用构造函数，那么其中的new.target的值与被调用super的构造函数的new.target的值相同。
- en: Inside an arrow function, the value of new.target is the same as the value for
    the `new.target` of the surrounding non-arrow function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数内部，new.target的值与周围非箭头函数的`new.target`的值相同。
- en: 'Here is example code to demonstrate this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是演示此功能的示例代码：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using super in object literals
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在对象字面量中使用super
- en: The super keyword can also be used in concise methods of object literals. The
    super keyword in concise methods of the object literals has the same value as
    the `[[prototype]]` property of the object defined by the object literal.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: super关键字也可以在对象字面量的简洁方法中使用。对象字面量简洁方法中的super关键字具有与该对象字面量定义的对象的`[[prototype]]`属性相同的值。
- en: In object literals, super is used to access overridden properties by the child
    object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象字面量中，super用于通过子对象访问重写的属性。
- en: 'Here is an example to demonstrate how to use super in object literals:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来展示如何在对象字面量中使用super：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'ES.next proposal includes adding support for truly private properties in classes
    using the hash (#) symbol. #myProp inside a class will be private to that class.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ES.next提案包括通过使用hash（#）符号在类中添加对真正私有属性的支持。类内部的#myProp将是该类的私有属性。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we first learned the basics of Object-Oriented Programming
    using a traditional function approach. Then, we jumped to classes and learned
    how they make it easy for us to read and write object-oriented JavaScript code.
    We also learned about some miscellaneous features such as the `new.target` and
    accessor methods. Let us now move on to the web, a place where we can implement
    what we've learned so far!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先使用传统函数方法学习了面向对象编程的基础。然后，我们转向类，学习了它们如何使我们更容易阅读和编写面向对象的JavaScript代码。我们还了解了一些其他特性，如`new.target`和存取器方法。现在，让我们继续前进到网络，一个我们可以实现所学内容的地方！
