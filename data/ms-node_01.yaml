- en: Understanding the Node Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解节点环境
- en: Introduction – JavaScript as a systems language
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 - JavaScript作为系统语言
- en: 'When *John Bardeen*, *Walter Brattain*, and *William Shockley* invented the
    transistor in 1947, they changed the world in ways we are still discovering today.
    From their revolutionary building block, engineers could design and manufacture
    digital circuits far more complex than those possible earlier. Each decade that
    followed has seen a new generation of these devices: smaller, faster, and cheaper,
    often by orders of magnitude.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当John Bardeen、Walter Brattain和William Shockley于1947年发明了晶体管时，他们以至今仍在发现的方式改变了世界。从他们的革命性基石开始，工程师可以设计和制造比之前可能的数字电路复杂得多的数字电路。随后的每一个十年都见证了这些设备的新一代：更小、更快、更便宜，通常是数量级的提升。
- en: By the 1970s, corporations and universities could afford mainframe computers
    small enough to fit in a single room, and powerful enough that they could serve
    multiple users simultaneously. The minicomputer, a new and different kind of device,
    needed new and different kinds of technologies to help users get the most out
    of the machine. *Ken Thompson* and *Dennis Ritchie* at Bell Labs developed the
    operating system Unix, and the programming language **C** to write it. They built
    constructs into their system, like processes, threads, streams, and the hierarchical
    filesystem. Today, these constructs are so familiar, that it's hard to imagine
    a computer working any other way. However, they're just constructs, made up by
    these pioneers, with the goal of helping people like us understand the otherwise
    inscrutable patterns of data in memory and storage inside the machine.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到了20世纪70年代，公司和大学能够负担得起足够小以适合单个房间的大型计算机，并且足够强大，可以同时为多个用户提供服务。小型计算机是一种新的、不同类型的设备，需要新的和不同类型的技术来帮助用户充分利用这台机器。贝尔实验室的Ken
    Thompson和Dennis Ritchie开发了Unix操作系统和编程语言C来编写它。他们在系统中构建了进程、线程、流和分层文件系统等结构。今天，这些结构是如此熟悉，以至于很难想象计算机以其他方式工作。然而，它们只是由这些先驱者构建的结构，旨在帮助像我们这样的人理解内存和存储器中的数据模式。
- en: 'C is a systems language, and it is a safe and powerful shorthand alternative
    for developers familiar with keying in assembly instructions. Given its familiar
    setting of a microprocessor, C makes low-level system tasks easy. For instance,
    you can search a block of memory for a byte of a specific value:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C是一种系统语言，对于熟悉输入汇编指令的开发人员来说，它是一种安全且功能强大的简写替代方案。在微处理器的熟悉环境中，C使得低级系统任务变得容易。例如，你可以搜索一个内存块以找到特定值的字节。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By the 1990s, what we could build with transistors had evolved again. A p*ersonal
    computer (PC)* was light and cheap enough to be found on workplace and dormitory
    desktops. Increased speed and capacity allowed users to boot from a character-only
    teletype to graphical environments, with pretty fonts and color images. And with
    an Ethernet card and cable, your computer got a static IP address on the internet,
    where network programs could connect to send and receive data with any other computer
    on the planet.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到了20世纪90年代，我们可以用晶体管构建的东西再次发生了变化。个人电脑（PC）足够轻便和便宜，可以在工作场所和宿舍的桌面上找到。提高的速度和容量使用户可以从仅字符的电传打印机引导到具有漂亮字体和彩色图像的图形环境。通过以太网卡和电缆，你的计算机可以在互联网上获得静态IP地址，网络程序可以连接并与地球上的任何其他计算机发送和接收数据。
- en: 'It was within this landscape of technology that *Sir Tim Berners-Lee* invented
    the *World Wide Web,* and *Brendan Eich* created **JavaScript**. Designed for
    coders familiar with HTML tags, JavaScript was a way to move beyond static pages
    of text with animation and interactivity. Given its familiar setting of a webpage,
    JavaScript makes high-level tasks easy. Web pages are filled with text and tags,
    so combining two strings is easy:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这样的技术背景下，Sir Tim Berners-Lee发明了万维网，Brendan Eich创建了JavaScript。JavaScript是为熟悉HTML标签的程序员设计的，它是一种超越静态文本页面的动画和交互的方式。在网页的熟悉环境中，JavaScript使得高级任务变得容易。网页充满了文本和标签，因此合并两个字符串很容易。
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s port each program to the other language and platform. First, from
    the preceding `combine-text.js`, let''s write `combine-text.c`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将每个程序移植到另一种语言和平台。首先，从之前的`combine-text.js`，让我们编写`combine-text.c`：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The two string literals are easy to define, but after that, it gets a lot harder. Without
    automatic memory management, it's your responsibility as a developer to determine
    how much memory you need, allocate it from the system, write to it without overwriting
    the buffer, and then free it afterwards.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字符串文字很容易定义，但之后就变得更加困难。没有自动内存管理，作为开发人员，你需要确定需要多少内存，从系统中分配内存，写入数据而不覆盖缓冲区，然后在之后释放它。
- en: 'Secondly, let''s attempt the reverse: from the `find-byte.c` code prior, let''s
    write `find-byte.js`. Before Node, it was not possible to use JavaScript to search
    a block of memory for a specific byte. In the browser, JavaScript can''t allocate
    a buffer, and doesn''t even have a type for byte. But with Node, it''s both possible
    and easy:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们尝试相反的操作：从之前的`find-byte.c`代码，让我们编写`find-byte.js`。在Node之前，不可能使用JavaScript来搜索特定字节的内存块。在浏览器中，JavaScript无法分配缓冲区，甚至没有字节类型。但是在Node中，这既可能又容易。
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Emerging from generations of computing decades apart, when both computers and
    what people were doing with them were wildly different, there's no real reason
    the design, purpose, or use that drives these two languages, C and JavaScript,
    should necessarily come together. But they did, because in 2008 Google released
    Chrome, and in 2009, *Ryan Dahl* wrote **Node.js.**
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从相隔几十年的计算机和人们使用它们的方式的计算机世代中出现，驱动这两种语言C和JavaScript的设计、目的或用途本来没有必然要结合在一起的真正原因。但它们确实结合在一起了，因为在2008年谷歌发布了Chrome，2009年Ryan
    Dahl编写了Node.js。
- en: Applying design principles previously only considered for operating systems.
    Chrome uses multiple processes to render different tabs, ensuring their isolation.
    Chrome was released open source and built on WebKit, but one part inside was completely
    new. Coding from scratch in his farmhouse in Denmark, *Lars Bak*'s V8 used hidden
    class transitions, incremental garbage collection, and dynamic code generation
    to execute (not interpret) JavaScript faster than ever before.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用之前仅用于操作系统的设计原则。Chrome使用多个进程来渲染不同的标签，确保它们的隔离。Chrome是开源发布的，构建在WebKit上，但其中的一部分是全新的。在丹麦的农舍里从头开始编码，Lars
    Bak的V8使用隐藏类转换、增量垃圾收集和动态代码生成来执行（而不是解释）比以往更快的JavaScript。
- en: 'With V8 under the hood, how fast can Node run JavaScript? Let''s write a little
    program to show execution speed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在V8的支持下，Node可以多快地运行JavaScript？让我们编写一个小程序来展示执行速度：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the output for `speed-loop.js`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`speed-loop.js`的输出：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's no code in the body of the `for` loop, but your processor is busy incrementing
    `i`, comparing it to `cycles`, and repeating the process. It's late 2017 as I
    write this, typing on a MacBook Pro with a 2.8 GHz Intel Core i7 processor. Node
    v9.3.0 is current, and takes *less than a second* to loop a *billion* times.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的主体中没有代码，但是您的处理器正在忙于递增`i`，将其与`cycles`进行比较，并重复这个过程。我写这篇文章时已经是2017年末了，我用的是一台配备2.8
    GHz英特尔酷睿i7处理器的MacBook Pro。Node v9.3.0是当前版本，循环*十亿*次只需要*不到一秒*。
- en: 'How fast is pure C? Let''s see:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 纯C有多快？让我们看看：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output for `speed-loop.c`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`speed-loop.c`的输出：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For additional comparison, let''s try an interpreted language, like Python:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行额外的比较，让我们尝试一种解释性语言，比如Python：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output for `speed-loop.py`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`speed-loop.py`的输出：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Node runs code fast enough so that you don't have to worry that your application
    might be slowed down by the execution speed. You'll still have to think about
    performance, of course, but constrained by factors beyond language and platform
    choice, such as algorithms, I/O, and external processes, services, and APIs. As
    V8 compiles JavaScript rather than interpreting it, Node lets you enjoy high-level
    language features like automatic memory management and dynamic types, without
    having to give up the performance of a natively-compiled binary. Earlier, you
    had to choose one or the other; but now, you can have both. It's great.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Node运行的速度足够快，以至于您不必担心您的应用程序可能会因执行速度而变慢。当然，您仍然需要考虑性能，但受到语言和平台选择以外的因素的限制，比如算法、I/O和外部进程、服务和API。由于V8编译JavaScript而不是解释它，Node让您享受高级语言特性，如自动内存管理和动态类型，而无需放弃本地编译二进制的性能。以前，您必须选择其中一个；但现在，您可以两者兼得。这太棒了。
- en: Computing in the 1970s was about the microprocessor, and computing in the 1990s
    was about the web page. Today, in 2017, another new generation of physical computing
    technology has once again changed our machines. The smartphone in your pocket
    communicates wirelessly with scalable, pay-as-you-go software services in the
    cloud. Those services run on virtualized instances of Unix, which in turn run
    on physical hardware in data centers, some of which are so large they were strategically
    placed to draw current from a neighboring hydroelectric dam. With such new and
    different machines as these, we shouldn't be surprised that what's possible for
    users and what's necessary for developers is also new and different, once again.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪70年代的计算是关于微处理器的，20世纪90年代的计算是关于网页的。今天，2017年，另一代新的物理计算技术再次改变了我们的机器。您口袋里的智能手机通过无线方式与云中的可扩展的按需付费软件服务进行通信。这些服务在Unix的虚拟化实例上运行，Unix又在数据中心的物理硬件上运行，其中一些数据中心非常大，被策略性地放置在附近的水电站中获取电流。有了这样新颖和不同的机器，我们不应该感到惊讶，用户的可能性和开发人员的必要性也是新的和不同的，再次。
- en: Node.js imagines JavaScript as a systems language, like C. On the page, JavaScript
    can manipulate headers and styles. As a systems language, JavaScript can manipulate
    memory buffers, processes and streams, and files and sockets. This anachronism,
    made possible by the performance V8 gives the language, sends it back two decades,
    transplanting it from the web page to the microprocessor die.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js将JavaScript想象成一个类似于C的系统语言。在网页上，JavaScript可以操作头部和样式。作为系统语言，JavaScript可以操作内存缓冲区、进程和流、文件和套接字。这种时代错位是由V8的性能所可能的，它将语言发送回20年前，将其从网页移植到微处理器芯片上。
- en: '"Node''s goal is to provide an easy way to build scalable network programs."'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: “Node的目标是提供一种简单的方式来构建可扩展的网络程序。”
- en: – Ryan Dahl, creator of Node.js
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '- Node.js的创始人Ryan Dahl'
- en: In this book, we will study the techniques professional Node developers use
    to tackle the software challenges of today. By mastering Node, you are learning
    how to build the next generation of software. In this chapter, we will explore
    how a Node application is designed, the shape and texture of its footprint on
    a server, and the powerful base set of tools and features Node provides for developers. Throughout,
    we will examine progressively more intricate examples demonstrating how Node's
    simple, comprehensive, and consistent architecture solves many difficult problems
    well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将学习专业Node开发人员用来解决当今软件挑战的技术。通过掌握Node，您正在学习如何构建下一代软件。在本章中，我们将探讨Node应用程序的设计方式，以及它在服务器上的印记的形状和质地，以及Node为开发人员提供的强大的基本工具和功能集。在整个过程中，我们将逐渐探讨更复杂的示例，展示Node简单、全面和一致的架构如何很好地解决许多困难的问题。
- en: The Unix design philosophy
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix的设计哲学
- en: 'As a network application scales, the volume of information it must recognize,
    organize, and maintain increases. This volume, in terms of I/O streams, memory
    usage, and processor load, expands as more clients connect. This expansion of
    information volume also burdens the software developer. Scaling issues appear,
    usually demonstrating a failure to accurately predict the behavior of a large
    system from the behavior of its smaller predecessors:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络应用程序规模的扩大，它必须识别、组织和维护的信息量也在增加。这种信息量，以I/O流、内存使用和处理器负载的形式，随着更多的客户端连接而扩大。这种信息量的扩大也给软件开发人员带来了负担。通常出现扩展问题，通常表现为无法准确预测大型系统的行为，从而导致其较小的前身的行为失败：
- en: Can a data layer designed for storing a few thousand records accommodate a few
    million?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个为存储几千条记录设计的数据层能容纳几百万条记录吗？
- en: Are the algorithms used to search a handful of records efficient enough to search
    many more?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于搜索少量记录的算法是否足够高效，可以搜索更多记录吗？
- en: Can this server handle 10,000 simultaneous client connections?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个服务器能处理10000个同时的客户端连接吗？
- en: The edge of innovation is sharp and cuts quickly, presenting less time for deliberation
    precisely when the cost of error is magnified. The shape of objects comprising
    the whole of an application becomes amorphous and difficult to understand, particularly
    as ad hoc modifications are made, reactively, in response to dynamic tension in
    the system. What is described in a specification as a small subsystem may have
    been patched into so many other systems, that its actual boundaries are misunderstood.
    When this happens, it becomes impossible to accurately trace the outline of the
    composite parts of the whole.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 创新的边缘是锋利的，切割迅速，给人更少的时间来思考，特别是当错误的代价被放大时。构成应用程序整体的对象的形状变得模糊且难以理解，特别是当对系统中的动态张力做出反应性的临时修改时。在规范中描述为一个小子系统的东西可能已经被补丁到了许多其他系统中，以至于其实际边界被误解。当这种情况发生时，准确追踪整体复合部分的轮廓就变得不可能了。
- en: Eventually, an application becomes unpredictable. It is dangerous when one cannot
    predict all future states of an application, or the side effects of change. Any
    number of servers, programming languages, hardware architectures, management styles,
    and so on, have attempted to subdue the intractable problem of risk following
    growth, of failure menacing success. Oftentimes, systems of even greater complexity
    are sold as the cure. The hold that any one person has on information is tenuous.
    Complexity follows scale; confusion follows complexity. As resolution blurs, errors
    happen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，一个应用程序变得不可预测。当一个人无法预测应用程序的所有未来状态或变化的副作用时，这是危险的。许多服务器、编程语言、硬件架构、管理风格等等，都试图克服随着增长而带来的风险问题，失败威胁着成功。通常情况下，更复杂的系统被作为解决方案出售。任何一个人对信息的掌握都是脆弱的。复杂性随着规模而增加；混乱随着复杂性而来。随着分辨率变得模糊，错误就会发生。
- en: 'Node chose clarity and simplicity instead, echoing a philosophy from decades
    earlier:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Node选择了清晰和简单，回应了几十年前的一种哲学：
- en: '"Write programs that do one thing and do it well.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '"编写程序，做一件事，并且做得很好。'
- en: Write programs to work together.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序以便协同工作。
- en: Write programs to handle text streams, because that is a universal interface."
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编写处理文本流的程序，因为这是一个通用的接口。
- en: -Peter H. Salus, A Quarter-Century of Unix, 1994
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: -Peter H. Salus，《Unix四分之一世纪》，1994
- en: 'From their experiences creating and maintaining Unix, *Ken Thompson* and *Dennis
    Ritchie* came up with a philosophy for how people should best build software. Using
    this philosophy as his guide, *Ryan Dahl* made a number of decisions in the design
    of Node:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从他们创建和维护Unix的经验中，*Ken Thompson*和*Dennis Ritchie*提出了一个关于人们如何最好构建软件的哲学。*Ryan Dahl*在Node的设计中遵循这一哲学，做出了许多决定：
- en: Node's design favors simplicity over complexity
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node的设计偏向简单而不是复杂
- en: Node uses familiar POSIX APIs, rather than attempting an improvement
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node使用熟悉的POSIX API，而不是试图改进
- en: Node does everything with events, and doesn't need threads
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node使用事件来完成所有操作，不需要线程
- en: Node leverages the existing C libraries, rather than trying to reimplement their
    functionality
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node利用现有的C库，而不是试图重新实现它们的功能
- en: Node favors text over binary formats
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node偏向文本而不是二进制格式
- en: Text streams are the language of Unix programs. JavaScript got good at manipulating
    text from its beginning as a web scripting language. It's a natural fit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 文本流是Unix程序的语言。JavaScript从一开始就擅长处理文本，作为一种Web脚本语言。这是一个自然的匹配。
- en: POSIX
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX
- en: '**POSIX,** the **Portable Operating System Interface**, defines the standard
    APIs for Unix. It''s adopted in Unix-based operating systems and beyond. The IEEE
    created and maintains the POSIX standard to enable systems from different manufacturers
    to be compatible. Write your C program using POSIX APIs on your laptop running
    macOS, and you''ll have an easier time later building it on a Raspberry Pi.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**POSIX**，**可移植操作系统接口**，定义了Unix的标准API。它被采用在基于Unix的操作系统和其他系统中。IEEE创建并维护POSIX标准，以使来自不同制造商的系统兼容。在运行macOS的笔记本电脑上使用POSIX
    API编写C程序，以后在树莓派上构建它会更容易。'
- en: 'As a common denominator, POSIX is old, simple, and most importantly, well-known
    to developers of all stripes. To make a new directory in a C program, use this
    API:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个共同的基准，POSIX古老、简单，最重要的是，所有类型的开发人员都熟悉。在C程序中创建一个新目录，使用这个API：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And here it is in Node:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Node的特点：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Node documentation for the filesystem module starts out by telling the
    developer, there''s nothing new here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统模块的Node文档一开始就告诉开发人员，这里没有什么新东西：
- en: File I/O is provided by simple wrappers around standard POSIX functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O是通过标准POSIX函数的简单包装提供的。
- en: '[https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)'
- en: For Node, *Ryan Dahl* implemented proven POSIX APIs, rather than trying to come
    up with something on his own. While such an attempt might be better in some ways,
    or some situations, it would lose the instant familiarity that POSIX gives to
    new Node developers trained in other systems.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node来说，*Ryan Dahl*实现了经过验证的POSIX API，而不是试图自己想出一些东西。虽然在某些方面或某些情况下，这样的尝试可能更好，但它会失去POSIX给其他系统训练有素的新Node开发人员带来的即时熟悉感。
- en: In choosing POSIX for the API, Node is in no way limited to the standards from
    the 1970s. It's easy for anyone to write their own module that calls down to Node's
    API, while presenting a different one upwards. These fancier alternatives can
    then compete in a Darwinian quest to prove themselves better than POSIX.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择POSIX作为API，Node并不受限于上世纪70年代的标准。任何人都可以轻松编写自己的模块，调用Node的API，同时向上呈现不同的API。这些更高级的替代方案可以在达尔文式的竞争中证明自己比POSIX更好。
- en: Events for everything
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切皆事件
- en: If a program asks the operating system to open a file on the disk, that task
    might complete right away. Or, it might take a moment for the disk to spin up,
    or for other file system activity the operating system is working on to finish
    before it can perform this new request. Tasks that go beyond manipulating the
    memory of our application's process space to more distant hardware in the computer,
    network, and internet are not fast or reliable enough to program in the same way. Software
    designers needed a way to code these tasks, which can be slow and unreliable,
    without making their applications slow and unreliable as a whole. For systems
    programmers using languages like C and Java, the standard and accepted tool to
    use to solve this problem is the **thread.**
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序要求操作系统在磁盘上打开一个文件，这个任务可能会立即完成。或者，磁盘可能需要一段时间才能启动，或者操作系统正在处理其他文件系统活动，需要等待才能执行新的请求。超越应用程序进程空间内存操作的任务，涉及到计算机、网络和互联网中更远的硬件，无法以相同的方式快速或可靠地进行编程。软件设计师需要一种方法来编写这些可能缓慢和不可靠的任务，而不会使他们的应用程序整体变得缓慢和不可靠。对于使用C和Java等语言的系统程序员来说，解决这个问题的标准和公认的工具是线程。
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If a program asks the user a question, the user might respond right away. Or,
    the user may take a moment to think before clicking Yes or No. For web developers
    using HTML and JavaScript, the way to do this is the event as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序向用户提问，用户可能会立即回答。或者，用户可能需要一段时间来思考，然后再点击“是”或“否”。对于使用HTML和JavaScript的Web开发人员，这样做的方法是事件，如下所示：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At first glance, these two scenarios may seem completely distinct:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这两种情况可能看起来完全不同：
- en: In the first, a low-level system is shuttling blocks of memory from program
    to program, with delays milliseconds can be too big to measure
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种情况下，低级系统正在将内存块从程序传输到程序，毫秒的延迟可能太大而无法测量
- en: In the second, the very top surface of a huge stack of software is asking the
    user a question
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种情况下，一个巨大的软件堆栈的顶层正在向用户提问
- en: Conceptually, however, they're the same. Node's design realizes this, and uses
    events for both. In Node, there is one thread, bound to an event loop. Deferred
    tasks are encapsulated, entering and exiting the execution context via callbacks.
    I/O operations generate evented data streams, and these are piped through a single
    stack. Concurrency is managed by the system, abstracting thread pools, and simplifying
    shared access to memory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在概念上，它们是相同的。Node的设计意识到了这一点，并且在两者都使用了事件。在Node中，有一个线程，绑定到一个事件循环。延迟任务被封装，通过回调函数进入和退出执行上下文。I/O操作生成事件数据流，并通过单个堆栈进行传输。并发由系统管理，抽象出线程池，并简化对内存的共享访问。
- en: Node showed us that JavaScript doesn't need threads to be useful as a systems
    language. Additionally, by not having threads, JavaScript and Node avoid concurrency
    issues that create performance and reliability challenges that developers expert
    in a code base can still have difficulty reasoning about. In [Chapter 2](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml),
    *Understanding Asynchronous Event-Driven Programming*, we'll go deeper into events,
    and the event loop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Node向我们展示了JavaScript作为系统语言并不需要线程。此外，通过不使用线程，JavaScript和Node避免了并发问题，这些问题会给开发人员带来性能和可靠性挑战，即使是对于熟悉代码库的开发人员也可能难以理解。在《第2章》《理解异步事件驱动编程》中，我们将深入探讨事件和事件循环。
- en: Standard libraries
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库
- en: Node is built on standard open source C libraries. For example, the *TLS* and
    *SSL* protocols are implemented by *OpenSSL*. More than just adopting an API,
    the C source code of OpenSSL is included and complied into Node. When your JavaScript
    program hashes a cryptographic key, it's not JavaScript that's actually doing
    the work. Your JavaScript, run by Node, has called down to the C code of OpenSSL.
    Essentially, you are scripting the native library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Node是建立在标准开源C库上的。例如，*TLS*和*SSL*协议是由*OpenSSL*实现的。不仅仅是采用API，OpenSSL的C源代码也包含在Node中并编译进去。当你的JavaScript程序对加密密钥进行哈希处理时，实际上并不是JavaScript在进行工作。你的JavaScript通过Node调用了OpenSSL的C代码。实质上，你在对本地库进行脚本编写。
- en: 'This design choice of using the existing and proven open source libraries helped
    Node in a number of ways:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有和经过验证的开源库的设计选择帮助了Node的多个方面：
- en: It meant that Node could arrive on the scene very rapidly, with the core set
    of functionality systems programmers needed and expected already there
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着Node可以迅速出现在舞台上，具有系统程序员需要和期望的核心功能，这些功能已经存在。
- en: It ensures performance, reliability, and security continues to match the libraries
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保性能、可靠性和安全性与库相匹配
- en: It also didn't break cross-platform use, as all of these C libraries have been
    written and maintained to compile for different architectures for years
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也没有破坏跨平台使用，因为所有这些C库都已经被编写和维护多年，可以编译到不同的架构上
- en: Previous platforms and languages have made a different choice in trying to achieve
    software portability. The *100% Pure Java™ Standard*, for instance, was a *Sun
    Microsystems* initiative to promote the development of portable applications. Rather
    than leveraging the existing code in a hybrid stack, it encouraged developers
    to rewrite everything in Java. Developers had to keep features, performance, and
    security up to the standard by writing and testing new code. Node, on the other
    hand, picked a design that gets this all for free.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的平台和语言在努力实现软件可移植性时做出了不同的选择。例如，*100% Pure Java™ Standard*是*Sun Microsystems*的一个倡议，旨在促进可移植应用程序的开发。与其利用混合堆栈中的现有代码，它鼓励开发人员在Java中重写所有内容。开发人员必须通过编写和测试新代码来保持功能、性能和安全性达到标准。另一方面，Node选择了一种设计，可以免费获得所有这些功能。
- en: Extending JavaScript
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展JavaScript
- en: When he designed Node, JavaScript was not *Ryan Dahl*'s original language choice.
    Yet, upon exploration, he found a good modern language without opinions on streams,
    the filesystem, handling binary objects, processes, networking, and other capabilities
    one would expect to exist in a systems language. JavaScript, strictly limited
    to the browser, had no use for, and had not implemented, these features.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当他设计Node时，JavaScript并不是*Ryan Dahl*的最初语言选择。然而，经过探索，他发现了一种现代语言，没有对流、文件系统、处理二进制对象、进程、网络等功能的看法。JavaScript严格限制在浏览器中，对于这些功能没有用处，也没有实现这些功能。
- en: 'Guided by the Unix philosophy, Dahl was guided by a few rigid principles:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 受Unix哲学的指导，达尔坚持了一些严格的原则：
- en: A Node program/process runs on a single thread, ordering execution through an
    event loop
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node程序/进程在单个线程上运行，通过事件循环来排序执行
- en: Web applications are I/O intensive, so the focus should be on making I/O fast
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序具有大量I/O操作，因此重点应该放在加快I/O上
- en: Program flow is always directed through asynchronous callbacks
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序流程总是通过异步回调来指导
- en: Expensive CPU operations should be split off into separate parallel processes,
    emitting events as results arrive
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 昂贵的CPU操作应该拆分成单独的并行进程，并在结果到达时发出事件
- en: Complex programs should be assembled from simpler programs
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的程序应该由简单的程序组装而成
- en: The general principle is, operations must never block. Node's desire for speed
    (high concurrency) and efficiency (minimal resource usage) demands the reduction
    of waste. A waiting process is a wasteful process, especially when waiting for
    I/O.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总的原则是，操作绝对不能阻塞。Node对速度（高并发）和效率（最小资源使用）的渴望要求减少浪费。等待过程是一种浪费，特别是在等待I/O时。
- en: 'JavaScript''s asynchronous, event-driven design fits neatly into this model.
    Applications express interest in some future event, and are notified when that
    event occurs. This common JavaScript pattern should be familiar to you:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的异步、事件驱动设计完全符合这一模式。应用程序表达对未来某个事件的兴趣，并在该事件发生时得到通知。这种常见的JavaScript模式应该对你来说很熟悉：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The time it will take for an I/O action to complete is unknown, so the pattern
    is to ask for notification when an I/O event is emitted, whenever that may be,
    allowing other operations to be completed in the meantime.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: I/O操作完成所需的时间是未知的，因此模式是在发出I/O事件时请求通知，无论何时发生，都允许其他操作在此期间完成。
- en: Node adds an enormous amount of new functionality to JavaScript. Primarily,
    the additions provide evented I/O libraries offering the developer system access
    not available to browser-based JavaScript, such as writing to the filesystem or
    opening another system process. Additionally, the environment is designed to be
    modular, allowing complex programs to be assembled out of smaller and simpler
    components.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Node为JavaScript添加了大量新功能。主要是提供了事件驱动的I/O库，为开发人员提供了系统访问权限，这是浏览器中的JavaScript无法做到的，比如写入文件系统或打开另一个系统进程。此外，该环境被设计为模块化，允许将复杂的程序组装成更小更简单的组件。
- en: Let's look at how Node imported JavaScript's event model, extended it, and used
    it in the creation of interfaces to powerful system commands.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Node如何导入JavaScript的事件模型，扩展它，并在创建强大系统命令的接口时使用它。
- en: Events
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Many functions in the Node API emit events. These events are instances of `events.EventEmitter`.
    Any object can extend `EventEmitter,` providing Node developers with a simple
    and uniform way to build tight, asynchronous interfaces to object methods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Node API中的许多函数会发出事件。这些事件是`events.EventEmitter`的实例。任何对象都可以扩展`EventEmitter`，为Node开发人员提供了一种简单而统一的方式来构建紧密的异步接口以调用对象方法。
- en: 'The following code sets Node''s `EventEmitter` object as the prototype of a
    function constructor we define. Each constructed instance has the `EventEmitter`
    object exposed to its prototype chain, providing a natural reference to the event
    API. The counter instance methods emit events, and code after that listens for
    them. After making a `Counter`, we listen for the incremented event, specifying
    a callback Node will call when the event happens. Then, we call the increment
    twice. Each time, our `Counter` increments the internal count it holds, and then
    emits the incremented event. This calls our callback, giving it the current count,
    which our callback logs:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将Node的`EventEmitter`对象设置为我们定义的函数构造函数的原型。每个构造的实例都将`EventEmitter`对象暴露给其原型链，提供对事件API的自然引用。计数器实例方法会发出事件，然后监听它们。创建一个`Counter`后，我们监听增加的事件，指定一个回调，Node在事件发生时会调用它。然后，我们调用增加两次。每次，我们的`Counter`都会增加它持有的内部计数，然后发出增加的事件。这将调用我们的回调，将当前计数传递给它，我们的回调会将其记录下来：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the output for `counter.js`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`counter.js`的输出：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To remove the event listeners bound to `counter`, use this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除绑定到`counter`的事件侦听器，请使用此代码：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For consistency with browser-based JavaScript, `counter.on` and `counter.addListener`
    are interchangeable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与基于浏览器的JavaScript保持一致，`counter.on`和`counter.addListener`是可以互换的。
- en: 'Node brought `EventEmitter` to JavaScript and made it an object your objects
    can extend. This greatly increases the possibilities available to developers.
    With `EventEmitter`, Node can handle I/O data streams in an event-oriented manner,
    performing long-running tasks while keeping true to Node''s principles of asynchronous,
    non-blocking programming:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Node将`EventEmitter`引入JavaScript，并使其成为你的对象可以扩展的对象。这大大增加了开发人员的可能性。使用`EventEmitter`，Node可以以事件导向的方式处理I/O数据流，执行长时间运行的任务，同时保持Node异步、非阻塞编程的原则：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output for `stream.js`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`stream.js`的输出：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This example creates a readable stream `r`, and pipes its output to the standard
    out. Every 500 milliseconds, code increments a counter and pushes a line of text
    with the current count downstream. Try running the program yourself, and you'll
    see the series of numbers appear on your terminal.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子创建了一个可读流`r`，并将其输出传输到标准输出。每500毫秒，代码会递增一个计数器，并将带有当前计数的文本行推送到下游。尝试自己运行程序，你会看到一系列数字出现在你的终端上。
- en: On what would be the 11^(th) count, `r` pushes null downstream, indicating that
    it has no more data to send. This closes the stream, and with nothing more to
    do, Node exits the process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11次计数时，`r`将null推送到下游，表示它没有更多的数据要发送。这关闭了流，而且没有更多的事情要做，Node退出了进程。
- en: Subsequent chapters will explain streams in more detail. Here, just note how
    pushing data onto a stream causes an event to fire, how you can assign a custom
    callback to handle this event, and how the data flows downstream.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将更详细地解释流。在这里，只需注意将数据推送到流上会触发一个事件，你可以分配一个自定义回调来处理这个事件，以及数据如何向下游流动。
- en: Node consistently implements I/O operations as asynchronous, evented data streams.
    This design choice enables Node's excellent performance. Instead of creating a
    thread (or spinning up an entire process) for a long-running task like a file
    upload that a stream may represent, Node only needs to commit the resources to
    handle callbacks. Additionally, in the long stretches of time in between the short
    moments when the stream is pushing data, Node's event loop is free to process
    other instructions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Node一贯将I/O操作实现为异步的、事件驱动的数据流。这种设计选择使得Node具有出色的性能。与为长时间运行的任务（如文件上传）创建线程（或启动整个进程）不同，Node只需要投入资源来处理回调。此外，在流推送数据的短暂时刻之间的长时间段内，Node的事件循环可以自由地处理其他指令。
- en: 'As an exercise, re-implement `stream.js` to send the data `r` produces to a
    file instead of the terminal. You''ll need to make a new writable stream `w`,
    using Node''s `fs.createWriteStream`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，重新实现`stream.js`，将`r`产生的数据发送到文件而不是终端。你需要使用Node的`fs.createWriteStream`创建一个新的可写流`w`：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Modularity
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化
- en: 'In his book, *The Art of Unix Programming, Eric Raymond* proposed the **Rule
    of Modularity**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《Unix编程艺术》中，Eric Raymond提出了**模块化原则**：
- en: '"Developers should build a program out of simple parts connected by well-defined
    interfaces, so problems are local, and parts of the program can be replaced in
    the future versions to support new features. This rule aims to save time on debugging
    complex code that is complex, long, and unreadable."'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: “开发人员应该通过明确定义的接口将程序构建成由简单部分连接而成的程序，这样问题就是局部的，程序的部分可以在未来版本中被替换以支持新功能。这个原则旨在节省调试复杂、冗长和难以阅读的代码的时间。”
- en: Large systems are hard to reason about, especially when the boundaries of internal
    components are fuzzy, and the interactions between them are complex. This principle
    of building large systems out of small, simple, and loosely-coupled pieces is
    a good idea for software and beyond. Physical manufacturing, management theory,
    education, and government, all have benefited from this design philosophy.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 大型系统很难理解，特别是当内部组件的边界模糊不清，它们之间的交互又很复杂时。将大型系统构建成由小的、简单的、松耦合的部分组成的原则对软件和其他领域都是一个好主意。物理制造、管理理论、教育和政府都受益于这种设计哲学。
- en: 'When developers began employing JavaScript for larger and more complex software
    challenges, they encountered this challenge. There was not yet a good way (and
    later, no common standard way) to assemble a JavaScript program from smaller ones. For
    example, you''ve probably seen HTML pages with tags like these at the top:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员开始将JavaScript用于更大规模和更复杂的软件挑战时，他们遇到了这个挑战。还没有一个好的方法（后来也没有一个通用的标准方法）来从更小的程序组装JavaScript程序。例如，你可能在顶部看到带有这些标签的HTML页面：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This works, but leads to a number of problems:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法虽然有效，但会导致一系列问题：
- en: The page must declare all potential dependencies before any are needed or used.
    If, while running, your program encounters a situation where it needs an additional
    dependency, dynamically loading another module is possible, but a separate hack.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面必须在需要或使用任何依赖之前声明所有潜在的依赖。如果在运行过程中，你的程序遇到需要额外依赖的情况，动态加载另一个模块是可能的，但是是一种单独的黑客行为。
- en: The scripts are not encapsulated. Code in every file writes to the same global
    object. Adding a new dependency may break an earlier one because of a name collision.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本没有封装。每个文件中的代码都写入同一个全局对象。添加新的依赖可能会因为名称冲突而破坏之前的依赖。
- en: '`fileA` cannot address `fileB` as a collection. An addressable context like
    `fileB.function1` isn''t available.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileA`无法将`fileB`作为一个集合来处理。像`fileB.function1`这样的可寻址上下文是不可用的。'
- en: The `<script>` tag would be a nice place for useful module services such as
    dependency awareness and version control, but it doesn't have these features.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script>`标签可能是一个很好的地方，用于提供诸如依赖关系意识和版本控制等有用的模块服务，但它并没有这些功能。'
- en: These difficulties and dangers made creating and using JavaScript modules feel
    more treacherous than effortless. A good module system with features like encapsulation
    and versioning can reverse this, encouraging code organization and sharing, and
    leading to a robust ecosystem of high-quality open source software components.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些困难和危险使得创建和使用JavaScript模块感觉比轻松更加危险。一个具有封装和版本控制等功能的良好模块系统可以扭转这一局面，鼓励代码组织和共享，并导致一个高质量的开源软件组件生态系统。
- en: JavaScript needed a standard way to load and share discreet program modules,
    and found one in 2009 with the CommonJS Modules specification. Node follows this
    specification, making it easy to define and share bits of reusable code called
    **modules** or **packages.**
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript需要一种标准的方式来加载和共享离散的程序模块，在2009年找到了CommonJS模块规范。Node遵循这个规范，使得定义和共享被称为**模块**或**包**的可重用代码变得容易。
- en: 'Choosing a delightfully simple design, a package is just a directory of JavaScript
    files. Metadata about the package, such as its name, version, and software license,
    lives in an additional file named `package.json`. The JSON contents of this file
    are easily both human and machine-readable. Let''s take a look:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 选择了一个简单而令人愉悦的设计，一个包就是一个JavaScript文件的目录。关于包的元数据，比如它的名称、版本和软件许可证，存储在一个名为`package.json`的额外文件中。这个文件的JSON内容既容易被人类阅读，也容易被机器读取。让我们来看一下：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This `package.json` defines a package named `mypackage1`, which depends on
    two other packages: **jQuery** and **Bluebird. **Alongside the package names is
    a version number. Version numbers follow the **Semantic Versioning (SemVer)**
    rules, with a pattern like Major.Minor.Patch. Looking at the incremented version
    numbers of a package your code has been using, here''s what that means:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`package.json`定义了一个名为`mypackage1`的包，它依赖于另外两个包：**jQuery**和**Bluebird**。在包名旁边是一个版本号。版本号遵循**语义化版本（SemVer）**规则，格式为主版本号.次版本号.修订版本号。查看你的代码正在使用的包的递增版本号，这就是它的含义：
- en: '**Major:** There''s a change in the purpose or outcome of the API. If your
    code calls an updated function, it may break or produce an unintended result.
    Figure out what''s changed, and determine if it affects your code.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要版本：**API的目的或结果发生了变化。如果你的代码调用了更新的函数，可能会出现错误或产生意外的结果。找出发生了什么变化，并确定它是否影响了你的代码。'
- en: '**Minor:** The package has added functionality, but remains compatible. Run
    all your tests, and you''re good to go. Check out the documentation if you''re
    curious, as there might be new, more advanced parts of the API alongside the functions
    and objects you''re familiar with.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要版本：**包增加了功能，但仍然兼容。运行所有的测试，然后就可以使用了。如果你感兴趣，可以查看文档，因为可能会有新的、更高级的API部分，以及你熟悉的函数和对象。'
- en: '**Patch:** The package fixed a bug, improved performance, or refactored a little.
    Run all your tests, and you''re good to go.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修订版本：**包修复了一个bug，提高了性能，或者进行了一些重构。运行所有的测试，然后就可以使用了。'
- en: Packages enable the construction of large systems from many small, interdependent
    systems. Perhaps even more importantly, packages encourage sharing. More detailed
    information about SemVer is available in [Appendix A](7e49db07-ed2c-4bf7-a1ce-e4ed513bc0c0.xhtml),
    *Organizing Your Work Into Modules*, where npm and packages are discussed in more
    depth.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 包使得可以从许多小的、相互依赖的系统构建大型系统。也许更重要的是，包鼓励分享。关于SemVer的更详细信息可以在[附录A](7e49db07-ed2c-4bf7-a1ce-e4ed513bc0c0.xhtml)中找到，*将你的工作组织成模块*，在那里更深入地讨论了npm和包。
- en: '"What I''m describing here is not a technical problem. It''s a matter of people
    getting together and making a decision to step forward and start building up something
    bigger and cooler together."'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: “我在这里描述的不是一个技术问题。这是一群人聚在一起做出决定，迈出一步，开始一起构建更大更酷的东西。”
- en: – Kevin Dangoor, creator of CommonJS
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: – Kevin Dangoor，CommonJS的创始人
- en: 'Not just about modules, CommonJS is actually a whole collection of standards
    founded with the goal of removing everything that was holding JavaScript back
    from world domination, open source developer *Kris Kowal* explained in a 2009
    post evangelizing the initiative. He names the first of these impediments as the
    absence of a good module system. The second? The absence of a standard library,
    including such systems-level fundamentals as access to the filesystem, manipulation
    of I/O streams, and types for bytes and blocks of binary data. Today, CommonJS
    is known for giving JavaScript a module system, while Node is what gave JavaScript
    systems-level access:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS不仅仅是关于模块，实际上它是一整套标准，旨在消除一切阻碍JavaScript成为世界主导语言的东西，开源开发者*Kris Kowal*在2009年的一篇文章中解释了这一点。他将这些障碍中的第一个称为缺乏一个良好的模块系统。第二个障碍是缺乏一个标准库，包括文件系统的访问、I/O流的操作，以及字节和二进制数据块的类型。如今，CommonJS以给JavaScript提供了一个模块系统而闻名，而Node则是给了JavaScript系统级的访问：
- en: '[https://arstechnica.com/information-technology/2009/12/commonjs-effort-sets-javascript-on-path-for-world-domination/](https://arstechnica.com/information-technology/2009/12/commonjs-effort-sets-javascript-on-path-for-world-domination/)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://arstechnica.com/information-technology/2009/12/commonjs-effort-sets-javascript-on-path-for-world-domination/](https://arstechnica.com/information-technology/2009/12/commonjs-effort-sets-javascript-on-path-for-world-domination/)'
- en: '**CommonJS** gave JavaScript packages. With packages, the next thing JavaScript
    needed was a package manager. Node provided one with npm.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**CommonJS**给了JavaScript包。有了包之后，JavaScript需要的下一件事就是包管理器。Node提供了npm。'
- en: A registry of packages, npm is accessible in two ways. First, at the website
    [www.npmjs.com](http://www.npmjs.com), you can link to and search for packages,
    essentially shopping for the right one. Stats that count how many times a package
    has been downloaded in the last day, week, and month show popularity and usage.
    Most packages link to a developer profile page and open source code on GitHub,
    so you can see the code, visualize recent development activity, and judge the
    reputations of the authors and contributors.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: npm作为包的注册表有两种访问方式。首先，在网站[www.npmjs.com](http://www.npmjs.com)，你可以链接和搜索包，基本上是在寻找合适的包。统计数据显示了包在过去一天、一周和一个月内被下载的次数，展示了它的受欢迎程度和使用情况。大多数包都链接到开发者的个人资料页面和GitHub上的开源代码，这样你就可以看到代码，了解最近的开发活动，并评判作者和贡献者的声誉。
- en: The second way to access npm is through the command-line tool npm, which is
    installed with Node. Using npm as a traditional package manager for your workstation,
    you can install packages globally, creating new command-line tools on your shell's
    path. npm also knows how to create, read, and edit `package.json` files, and can
    start you out with a new, empty Node package, add the dependencies it needs, download
    all the code, and keep everything up to date.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 访问npm的第二种方式是通过与Node一起安装的命令行工具npm。使用npm作为工作站的传统软件包管理器，您可以全局安装软件包，在shell的路径上创建新的命令行工具。npm还知道如何创建、读取和编辑`package.json`文件，并可以为您创建一个新的、空的Node软件包，添加它所需的依赖项，下载所有的代码，并保持一切更新。
- en: 'Along with Git and GitHub, npm is now achieving a dream of software development
    identified in the 1970s: that code could be reused more often, and software projects
    would be written entirely from scratch less frequently.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Git和GitHub，npm现在正在实现上世纪70年代确定的软件开发梦想：代码可以更频繁地被重复使用，软件项目不需要经常从头开始编写。
- en: Earlier attempts at reaching this goal through version control systems like
    CVS and Subversion, and open source code sharing websites like [SourceForge.net](http://SourceForge.net),
    focused on bigger units of both code and people, and didn't achieve as much.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 早期尝试通过CVS和Subversion等版本控制系统以及像[SourceForge.net](http://SourceForge.net)这样的开源代码共享网站来实现这一目标，侧重于更大的代码和人员单位，并没有取得太多成果。
- en: 'GitHub and npm took a different approach in two important ways:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub和npm在两个重要方面采取了不同的方法：
- en: Favoring individual developers working alone over communities meeting and discussing,
    developers could focus more on code and less on conversation
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更看重独立开发者的个人工作而不是社区会议和讨论，开发者可以更多地专注于代码而不是对话
- en: Favoring small, atomic software components over complete applications, encapsulated
    composition started happening not just at a micro-level of subroutines and objects,
    but at the more important macroscale of application design
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏爱小型、原子化的软件组件而不是完整的应用程序，封装的组合不仅发生在子例程和对象的微观层面，而且在更重要的应用程序设计的宏观层面上也发生了。
- en: 'Even documentation is better with the new approach: in a monolithic software
    application, documentation was too often the afterthought that may or may not
    have happened after the product shipped.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 即使文档也可以通过新的方法变得更好：在单片软件应用程序中，文档往往是产品发货后可能发生或可能不会发生的事后想法。
- en: With components, great documentation is necessary to sell your package to the
    world, getting it a larger public daily download count, and the social media accounts
    you keep as a developer of more followers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组件，出色的文档对于向世界推销您的软件包是必不可少的，使其每天获得更多的公共下载量，并且作为开发者保持的社交媒体账户也会有更多的关注者。
- en: In no small part, Node's success is due to the number and quality of packages
    available to you as a Node developer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Node的成功在很大程度上归功于作为Node开发者可用的软件包的数量和质量。
- en: More extensive information on creating and managing Node packages can be found
    in *[Appendix A](7e49db07-ed2c-4bf7-a1ce-e4ed513bc0c0.xhtml), Organizing Your
    Work into Modules*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建和管理Node软件包的更详细信息可以在*[附录A](7e49db07-ed2c-4bf7-a1ce-e4ed513bc0c0.xhtml)，将您的工作组织成模块*中找到。
- en: 'The key design philosophy to follow is this: build programs out of packages
    where possible, and share those packages when possible. The shape of your applications
    will be clearer and easier to maintain. Importantly, the efforts of thousands
    of other developers can be linked into applications via npm, directly by inclusion,
    and indirectly as shared packages are tested, improved, refactored, and repurposed
    by members of the Node community.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循的关键设计理念是：尽可能使用软件包构建程序，并在可能的情况下共享这些软件包。您的应用程序的形状将更清晰，更易于维护。重要的是，成千上万的其他开发人员的努力可以通过npm直接包含到应用程序中，并且间接地通过共享软件包由Node社区的成员测试、改进、重构和重新利用。
- en: 'Contrary to popular belief, npm is not an abbreviation for Node Package Manager,
    and *should never be used or explained as an acronym*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与流行观念相反，npm并不是Node Package Manager的缩写，*绝不应该被用作或解释为首字母缩写*：
- en: '[https://docs.npmjs.com/policies/trademark](https://docs.npmjs.com/policies/trademark)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.npmjs.com/policies/trademark](https://docs.npmjs.com/policies/trademark)'
- en: The network
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: I/O in the browser is mercilessly hobbled, for very good reasons - if the JavaScript
    on any given website could access your filesystem, for instance, users could only
    click links to new sites they trusted, rather than ones they simply wanted to
    try out. Keeping pages in a limited sandbox, the design of the web made navigating
    from thing1.com to thing2.com not have the consequences of double-clicking thing1.exe
    and thing2.exe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的I/O受到严格限制，这是有很好的原因的——如果任何给定网站上的JavaScript可以访问您的文件系统，例如，用户只能点击他们信任的新网站的链接，而不是他们只是想尝试的网站。通过将页面保持在有限的沙盒中，Web的设计使得从thing1.com导航到thing2.com不会像双击thing1.exe和thing2.exe那样产生后果。
- en: Node, of course, recasts JavaScript in the role of a systems language, giving
    it direct and unfettered access to operating system kernel objects such as files,
    sockets, and processes. This lets Node create scalable systems with high I/O requirements.
    It's likely the first thing you coded in Node was a HTTP server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Node将JavaScript重新塑造为系统语言，使其直接且无障碍地访问操作系统内核对象，如文件、套接字和进程。这使得Node可以创建具有高I/O需求的可扩展系统。很可能你在Node中编写的第一件事是一个HTTP服务器。
- en: Node supports standard network protocols in addition to HTTP, such as TLS/SSL,
    and UDP. With these tools we can easily build scalable network programs, moving
    far beyond the comparatively limited AJAX solutions JavaScript developers know
    from the browser.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Node支持标准的网络协议，除了HTTP，还有TLS/SSL和UDP。借助这些工具，我们可以轻松地构建可扩展的网络程序，远远超出了JavaScript开发人员从浏览器中了解的相对有限的AJAX解决方案。
- en: 'Let''s write a simple program that sends a UDP packet to another node:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序，向另一个节点发送一个UDP数据包：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Go ahead and open two terminal windows and navigate each to your code bundle
    for [Chapter 8](97a06823-2b25-44a5-9482-86f80d3d28ed.xhtml), *Scaling Your Application*, under
    the `/udp` folder. We're now going to run a UDP server in one window, and a UDP
    client in another.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 打开两个终端窗口，分别导航到您的代码包的[第8章](97a06823-2b25-44a5-9482-86f80d3d28ed.xhtml)下的“扩展应用程序”文件夹。现在我们将在一个窗口中运行UDP服务器，在另一个窗口中运行UDP客户端。
- en: 'In the right window, run `receive.js` with a command like the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧窗口中，使用以下命令运行`receive.js`：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On the left, run `send.js` with a command, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，使用以下命令运行`send.js`：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Executing that command will cause the message to appear on the right:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该命令将导致右侧出现消息：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A UDP server is an instance of `EventEmitter`, emitting a message event when
    messages are received on the bound port. With Node, you can use JavaScript to
    write your application at the I/O level, moving packets and streams of binary
    data with ease.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: UDP服务器是`EventEmitter`的一个实例，在绑定端口接收到消息时会发出消息事件。使用Node，您可以使用JavaScript在I/O级别编写应用程序，轻松移动数据包和二进制数据流。
- en: Let's continue to explore I/O, the process object, and events. First, let's
    dig into the machine powering Node's core, V8.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索I/O、进程对象和事件。首先，让我们深入了解Node核心的机器V8。
- en: V8, JavaScript, and optimizations
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: V8、JavaScript和优化
- en: V8 is Google's JavaScript engine, written in C++. It compiles and executes JavaScript
    code inside of a VM (Virtual Machine). When a webpage loaded into Google Chrome
    demonstrates some sort of dynamic effect, like automatically updating a list or
    news feed, you are seeing JavaScript, compiled by V8, at work.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: V8是谷歌的JavaScript引擎，用C++编写。它在虚拟机（Virtual Machine）内部编译和执行JavaScript代码。当加载到谷歌Chrome中的网页展示某种动态效果，比如自动更新列表或新闻源时，您看到的是由V8编译的JavaScript在工作。
- en: V8 manages Node's main process thread. When executing JavaScript, V8 does so
    in its own process, and its internal behavior is not controlled by Node. In this
    section, we will investigate the performance benefits that can be had by playing
    with these options, learning how to write *optimizable* JavaScript, and the cutting-edge
    JavaScript features available to users of the latest Node versions (such as 9.x,
    the version we use in this book).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: V8管理Node的主进程线程。在执行JavaScript时，V8会在自己的进程中执行，其内部行为不受Node控制。在本节中，我们将研究通过使用这些选项来获得的性能优势，学习如何编写可优化的JavaScript，以及最新Node版本（例如9.x，我们在本书中使用的版本）用户可用的尖端JavaScript功能。
- en: Flags
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标志
- en: 'There are a number of settings available to you for manipulating the Node runtime.
    Try this command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用于操纵Node运行时的设置。尝试这个命令：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition to standards such as `--version`, you can also flag Node to `--abort-on-uncaught-exception`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`--version`等标准选项外，您还可以将Node标记为`--abort-on-uncaught-exception`。
- en: 'You can also list the options available for v8:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以列出v8可用的选项：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Some of these settings can save the day. For example, if you are running Node
    in a restrained environment like a Raspberry Pi, you might want to limit the amount
    of memory a Node process can consume, to avoid memory spikes. In that case, you
    might want to set the `--max_old_space_size` (by default ~1.5GB) to a few hundred
    MB.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些设置可以帮助您度过难关。例如，如果您在像树莓派这样的受限环境中运行Node，您可能希望限制Node进程可以消耗的内存量，以避免内存峰值。在这种情况下，您可能希望将`--max_old_space_size`（默认约1.5GB）设置为几百MB。
- en: 'You can use the `-e` argument to execute a Node program as a string; in this
    case, logging out of the version of V8 your copy of Node contains:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-e`参数将Node程序作为字符串执行；在这种情况下，记录出您的Node副本包含的V8版本：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It's worth your time to experiment with Node/V8 settings, both for their utility
    and the path, to give you a slightly stronger understanding of what is happening
    (or might happen) *under the hood*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 值得您花时间尝试Node/V8的设置，既可以提高效用，也可以让您对发生的事情（或可能发生的事情）有更深入的了解。
- en: Optimizing your code
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化您的代码
- en: The simple optimizations of smart code design can really help you. Traditionally,
    JavaScript developers working in browsers did not need to concern themselves with
    memory usage optimizations, having quite a lot to use for what were typically
    uncomplicated programs. On a server, this is no longer the case. Programs are
    generally more complicated, and running out of memory takes down your server.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 智能代码设计的简单优化确实可以帮助您。传统上，在浏览器中工作的JavaScript开发人员不需要关注内存使用优化，因为通常对于通常不复杂的程序来说，他们有很多内存可用。在服务器上，情况就不同了。程序通常更加复杂，耗尽内存会导致服务器崩溃。
- en: The convenience of a dynamic language is in avoiding the strictness that compiled
    languages impose. For example, you need not explicitly define object property
    types, and can actually change those property types at will. This dynamism makes
    traditional compilation impossible, but opens up some interesting new opportunities
    for exploratory languages such as JavaScript. Nevertheless, dynamism introduces
    a significant penalty in terms of execution speeds when compared to statically
    compiled languages. The limited speed of JavaScript has regularly been identified
    as one of its major weaknesses.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 动态语言的便利之处在于避免了编译语言所施加的严格性。例如，您无需明确定义对象属性类型，并且实际上可以随意更改这些属性类型。这种动态性使得传统编译变得不可能，但为JavaScript等探索性语言开辟了一些有趣的新机会。然而，与静态编译语言相比，动态性在执行速度方面引入了显著的惩罚。JavaScript的有限速度经常被认为是其主要弱点之一。
- en: 'V8 attempts to achieve the sorts of speeds one observes for compiled languages
    for JavaScript. V8 compiles JavaScript into native machine code, rather than interpreting
    bytecode, or using other just-in-time techniques. Because the precise runtime
    topology of a JavaScript program cannot be known ahead of time (the language is
    dynamic), compilation consists of a two-stage, speculative approach:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: V8试图为JavaScript实现编译语言所观察到的速度。V8将JavaScript编译为本机机器代码，而不是解释字节码，或使用其他即时技术。由于JavaScript程序的精确运行时拓扑无法提前知道（语言是动态的），编译包括两阶段的推测性方法：
- en: Initially, a first-pass compiler (the *full* compiler) converts your code into
    a runnable state as quickly as possible. During this step, type analysis and other
    detailed analysis of the code is deferred, prioritizing fast compilation – your
    JavaScript can begin executing as close to instantly as possible. Further optimizations
    are accomplished during the second step.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，第一遍编译器（*完整*编译器）尽快将您的代码转换为可运行状态。在此步骤中，类型分析和代码的其他详细分析被推迟，优先考虑快速编译-您的JavaScript可以尽可能接近即时执行。进一步的优化是在第二步完成的。
- en: Once the program is up and running, an optimizing compiler then begins its job
    of watching how your program runs, and attempting to determine its current and
    future runtime characteristics, optimizing and re-optimizing as necessary. For
    example, if a certain function is being called many thousands of times with similar
    arguments of a consistent type, V8 will re-compile that function with code optimized
    on the optimistic assumption that future types will be like the past types. While
    the first compile step was conservative with as-yet unknown and un-typed functional
    signature, this `hot` function's predictable texture impels V8 to assume a certain
    optimal profile and re-compile based on that assumption.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦程序启动运行，优化编译器就开始监视程序的运行方式，并尝试确定其当前和未来的运行时特性，根据需要进行优化和重新优化。例如，如果某个函数以一致类型的相似参数被调用了成千上万次，V8将使用基于乐观假设的优化代码重新编译该函数，假设未来的类型将与过去的类型相似。虽然第一次编译步骤对尚未知和未类型化的功能签名保守，但这个`热`函数的可预测纹理促使V8假设某种最佳配置文件，并根据该假设重新编译。
- en: 'Assumptions help us make decisions more quickly, but can lead to mistakes.
    What if the `hot` function V8''s compiler just optimized against a certain type
    signature is now called with arguments violating that optimized profile? V8 has
    no choice, in that case: it must de-optimize the function. V8 must admit its mistake
    and roll back the work it has done. It will re-optimize in the future if a new
    pattern is seen. However, if V8 must again de-optimize at a later time, and if
    this optimize/de-optimize binary switching continues, V8 will simply *give up*,
    and leave your code in a de-optimized state.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设可以帮助我们更快地做出决定，但可能会导致错误。如果`热`函数V8的编译器只针对某种类型签名进行了优化，现在却使用违反该优化配置文件的参数调用了该函数怎么办？在这种情况下，V8别无选择：它必须取消优化该函数。V8必须承认自己的错误，并撤销已经完成的工作。如果看到新的模式，它将在未来重新优化。然而，如果V8在以后再次取消优化，并且如果这种优化/取消优化的二进制切换继续，V8将简单地*放弃*，并将您的代码留在取消优化状态。
- en: Let's look at some ways to approach the design and declaration of arrays, objects,
    and functions, so that you are helping, rather than hindering the compiler.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些方法来设计和声明数组、对象和函数，以便您能够帮助而不是阻碍编译器。
- en: Numbers and tracing optimization/de-optimization
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字和跟踪优化/取消优化
- en: The ECMA-262 specification defines the Number value as a "primitive value corresponding
    to a double-precision 64-bit binary format IEEE 754 value". The point is that
    there is no Integer type in JavaScript; there is a Number type defined as a double-precision
    floating-point number.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ECMA-262规范将Number值定义为“与双精度64位二进制格式IEEE 754值对应的原始值”。关键是JavaScript中没有整数类型；有一个被定义为双精度浮点数的Number类型。
- en: V8 uses 32-bit numbers for all values internally, for performance reasons that
    are too technical to discuss here. It can be said that one bit is used to point
    to another 32-bit number, should greater width be needed. Regardless, it is clear
    that there are two types of values tagged as numbers by V8, and switching between
    these types will cost you something. Try to restrict your needs to 31-bit signed
    Integers where possible.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 出于性能原因，V8在内部对所有值使用32位数字。这里讨论的技术原因太多，可以说有一位用于指向另一个32位数字，如果需要更大的宽度。无论如何，很明显V8将数字标记为两种类型的值，并在这些类型之间切换将会花费一些代价。尽量将您的需求限制在可能的情况下使用31位有符号整数。
- en: 'Because of the type ambiguity of JavaScript, switching the types of numbers
    assigned to a slot is allowed. For example, the following code does not throw
    an error:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript的类型不确定性，允许切换分配给插槽的数字的类型。例如，以下代码不会引发错误：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: However, a speculative compiler like V8 will be unable to optimize this variable
    assignment, given that its *guess* that `a` will always be an Integer turned out
    to be wrong, forcing de-optimization.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像V8这样的推测性编译器将无法优化这个变量赋值，因为它*猜测*`a`将始终是一个整数的假设是错误的，迫使取消优化。
- en: We can demonstrate the optimization/de-optimization process by setting some
    powerful V8 options, executing V8 native commands in your Node program, and tracing
    how v8 optimizes/de-optimizes your code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置一些强大的V8选项，执行Node程序中的V8本机命令，并跟踪v8如何优化/取消优化您的代码来演示优化/取消优化过程。
- en: 'Consider the following Node program:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Node程序：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you try to run this normally, you will receive an Unexpected Token error
    – the modulo (%) symbol cannot be used within an identifier name in JavaScript.
    What is this strange method with a % prefix? It is a V8 native command, and we
    can turn on execution of these types of functions by using the `--allow-natives-syntax
    flag`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试正常运行此程序，您将收到意外的令牌错误-在JavaScript中无法在标识符名称中使用模数（%）符号。带有%前缀的这个奇怪的方法是什么？这是一个V8本机命令，我们可以通过使用`--allow-natives-syntax`标志来打开执行这些类型的函数：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, consider the following code, which uses native functions to assert information
    about the optimization status of the square function, using the `%OptimizeFunctionOnNextCall`
    native method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码，它使用本机函数来断言关于平方函数的优化状态的信息，使用`％OptimizeFunctionOnNextCall`本机方法：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a file using the previous code, and execute it using the following command:
    `node --allow-natives-syntax --trace_opt --trace_deopt myfile.js`. You will see
    something like the following returned:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述代码创建一个文件，并使用以下命令执行它：`node --allow-natives-syntax --trace_opt --trace_deopt
    myfile.js`。您将看到类似以下返回的内容：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can see that V8 has no problem optimizing the square function, as operand
    is declared once and never changed. Now, append the following lines to your file
    and run it again:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到V8在优化平方函数时没有问题，因为操作数只声明一次并且从未改变。现在，将以下行追加到你的文件中，然后再次运行它：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On this execution, following the optimization report given earlier, you should
    now receive something like the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次执行中，根据之前给出的优化报告，你现在应该会收到类似以下的内容：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This very expressive optimization report tells the story very clearly: the
    once-optimized square function was de-optimized following the change we made in
    one number''s type. You are encouraged to spend some time writing code and testing
    it using these methods.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这份非常有表现力的优化报告非常清楚地讲述了故事：一度优化的平方函数在我们改变一个数字类型后被取消了优化。鼓励你花一些时间编写代码并使用这些方法进行测试。
- en: Objects and arrays
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象和数组
- en: As we learned when investigating numbers, V8 works best when your code is predictable.
    The same holds true with arrays and objects. Nearly all of the following *bad
    practices* are bad for the simple reason that they create unpredictability.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在研究数字时所学到的，当你的代码是可预测的时，V8的工作效果最好。对于数组和对象也是如此。几乎所有以下的*不良实践*之所以不好，是因为它们会造成不可预测性。
- en: Remember that in JavaScript, an object and an array are very similar *under
    the hood* (resulting in strange rules that provide no end of material for those
    poking fun at the language!). We won't be discussing those differences, only the
    important similarities, specifically in terms of how both these data constructs
    benefit from similar optimization techniques.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在JavaScript中，对象和数组在底层非常相似（导致了一些奇怪的规则，给那些取笑这门语言的人提供了无穷无尽的素材！）。我们不会讨论这些差异，只会讨论重要的相似之处，特别是在这两种数据结构如何从类似的优化技术中受益。
- en: Avoid mixing types in arrays. It is always better to have a consistent data
    type, such as *all integers* or *all strings*. As well, avoid changing types in
    arrays, or in property assignments after initialization if possible. V8 creates
    *blueprints* of objects by creating hidden classes to track types, and when those
    types change the optimization, blueprints will be destroyed and rebuilt—if you're
    lucky. Visit [https://github.com/v8/v8/wiki/Design%20Elements](https://github.com/v8/v8/wiki/Design%20Elements) for
    more information.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在数组中混合类型。最好始终保持一致的数据类型，比如*全部整数*或*全部字符串*。同样，尽量避免在数组中改变类型，或者在初始化后改变属性赋值的类型。V8通过创建隐藏类来跟踪类型来创建对象的*蓝图*，当这些类型改变时，优化蓝图将被销毁并重建——如果你幸运的话。访问[https://github.com/v8/v8/wiki/Design%20Elements](https://github.com/v8/v8/wiki/Design%20Elements)获取更多信息。
- en: 'Don''t create arrays with gaps, such as the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不要创建带有间隙的数组，比如以下的例子：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Sparse arrays are bad for this reason: V8 can either use a very efficient linear
    storage strategy to store (and access) your array data, or it can use a hash table
    (which is much slower). If your array is sparse, V8 must choose the least efficient
    of the two. For the same reason, always start your arrays at the zero index. As
    well, do not ever use *delete* to remove elements from an array. You are simply
    inserting an *undefined* value at that position, which is just another way of
    creating a sparse array. Similarly, be careful about populating an array with
    empty values—ensure that the external data you are pushing into an array is not
    incomplete.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏数组之所以不好，是因为V8可以使用非常高效的线性存储策略来存储（和访问）你的数组数据，或者它可以使用哈希表（速度要慢得多）。如果你的数组是稀疏的，V8必须选择两者中效率较低的那个。出于同样的原因，始终从零索引开始你的数组。同样，永远不要使用*delete*来从数组中删除元素。你只是在那个位置插入一个*undefined*值，这只是创建稀疏数组的另一种方式。同样，要小心用空值填充数组——确保你推入数组的外部数据不是不完整的。
- en: Try not to preallocate large arrays—grow as you go. Similarly, do not preallocate
    an array and then exceed that size. You always want to avoid spooking V8 into
    turning your array into a hash table. V8 creates a new hidden class whenever a
    new property is added to an object constructor. Try to avoid adding properties
    after an object is instantiated. Initialize all members in constructor functions
    in the same order. Same properties + same order = same object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要预先分配大数组——边用边增长。同样，不要预先分配一个数组然后超出那个大小。你总是希望避免吓到V8，使其将你的数组转换为哈希表。每当向对象构造函数添加新属性时，V8都会创建一个新的隐藏类。尽量避免在实例化后添加属性。以相同的顺序在构造函数中初始化所有成员。相同的属性+相同的顺序=相同的对象。
- en: Remember that JavaScript is a dynamic language that allows object (and object
    prototype) modifications after instantiation. Since the shape and volume of an
    object can, therefore, be altered *after the fact*, how does V8 allocate memory
    for objects? It makes some reasonable assumptions. After a set number of objects
    are instantiated from a given constructor (I believe 8 is the trigger amount),
    the largest of these is assumed to be of the maximum size, and all further instances
    are allocated that amount of memory (and the initial objects are similarly resized).
    A total of 32 fast property slots, inclusive, are then allocated to each instance
    based on this assumed maximum size. Any extra properties are slotted into a (slower)
    overflow property array, which can be resized to accommodate any further new properties.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，JavaScript是一种动态语言，允许在实例化后修改对象（和对象原型）。因此，V8为对象分配内存的方式是怎样的呢？它做出了一些合理的假设。在从给定构造函数实例化一定数量的对象之后（我相信触发数量是8），假定这些对象中最大的一个是最大尺寸，并且所有后续实例都被分配了那么多的内存（初始对象也被类似地调整大小）。每个实例基于这个假定的最大尺寸被分配了32个快速属性槽。任何额外的属性都被放入一个（更慢的）溢出属性数组中，这个数组可以调整大小以容纳任何进一步的新属性。
- en: With objects, as with arrays, try to define as much as possible the shape of
    your data structures in a *futureproof* manner, with a set number of properties,
    of types, and so on.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象和数组，尽量尽可能地定义数据结构的形状，包括一定数量的属性、类型等等，以便*未来*使用。
- en: Functions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are typically called often, and should be one of your prime optimization
    focuses. Functions containing try-catch constructs are not optimizable, nor are
    functions containing other unpredictable constructs, like `with` or `eval`. If,
    for some reason, your function is not optimizable, keep its use to a minimum.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通常经常调用函数，应该是你主要优化的焦点之一。包含try-catch结构的函数是不可优化的，包含其他不可预测结构的函数也是不可优化的，比如`with`或`eval`。如果由于某种原因，您的函数无法优化，请尽量减少使用。
- en: A very common optimization error involves the use of polymorphic functions.
    Functions that accept variable function arguments will be de-optimized. Avoid
    polymorphic functions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的优化错误涉及使用多态函数。接受可变函数参数的函数将被取消优化。避免多态函数。
- en: 'An excellent explanation of how V8 performs speculative optimization can be
    found here: [https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8](https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 关于V8如何执行推测优化的优秀解释可以在这里找到：[https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8](https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8)
- en: Optimized JavaScript
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化的JavaScript
- en: The JavaScript language is in constant flux, and some major changes and improvements
    have begun to find their way into native compilers. The V8 engine used in the
    latest Node builds supports nearly all of the latest features. Surveying all of
    these is beyond the scope of this chapter. In this section, we'll mention a few
    of the most useful updates and how they might be used to simplify your code, helping
    to make it easier to understand and reason about, to maintain, and perhaps even
    become more performant.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言不断变化，一些重大的变化和改进已经开始进入本机编译器。最新Node构建中使用的V8引擎支持几乎所有最新功能。调查所有这些超出了本章的范围。在本节中，我们将提到一些最有用的更新以及它们如何简化您的代码，帮助您更容易理解和推理，更易于维护，甚至可能更高效。
- en: We will be using the latest JavaScript features throughout this book. You can
    use Promises, Generators, and async/await constructs as of Node 8.x, and we will
    be using those throughout the book. These concurrency operators will be discussed
    at depth in [Chapter 2](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml), *Understanding
    Asynchronous Event-Driven Programming,* but a good takeaway for now is that the
    callback pattern is losing its dominance, and the Promise pattern in particular
    is coming to dominate module interfaces.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用最新的JavaScript功能。您可以使用Promise、Generator和async/await构造，从Node 8.x开始，我们将在整本书中使用这些功能。这些并发运算符将在[第2章](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml)中深入讨论，*理解异步事件驱动编程*，但现在一个很好的收获是，回调模式正在失去其主导地位，特别是Promise模式正在主导模块接口。
- en: 'In fact, a new method `util.promisify` was recently added to Node''s core,
    which converts a callback-based function to a Promise-based one:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，最近在Node的核心中添加了一个新方法`util.promisify`，它将基于回调的函数转换为基于Promise的函数：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Being able to easily *promisify *`fs.readFile` is very useful.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 能够轻松地*promisify* `fs.readFile`非常有用。
- en: Did you notice any other new JavaScript constructs possibly unfamiliar to you?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到其他可能对您不熟悉的新JavaScript结构？
- en: Help with variables
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帮助变量
- en: 'You''ll be seeing `let` and `const` throughout this book. These are new variable
    declaration types. Unlike `var`, `let` is *block scoped*; it does not apply outside
    of its containing block:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，您将看到`let`和`const`。这些是新的变量声明类型。与`var`不同，`let`是*块作用域*；它不适用于其包含的块之外：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For variables that will never change, use `const`, for *constant*. This is
    helpful for the compiler as well, as it can optimize more easily if a variable
    is guaranteed never to change. Note that `const` only works on assignment, where
    the following is illegal:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于永远不会改变的变量，请使用`const`，表示*constant*。这对编译器也很有帮助，因为如果变量保证永远不会改变，编译器可以更容易地进行优化。请注意，`const`仅适用于赋值，以下是非法的：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, if the value is an object, `const` doesn''t protect members:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果值是对象，`const`无法保护成员：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Another powerful new feature is **destructuring**, which allows us to easily
    assign the values of arrays to new variables:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个强大的新功能是**解构**，它允许我们轻松地将数组的值分配给新变量：
- en: '`let [executable, absPath, target, ...message] = process.argv;`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`let [executable, absPath, target, ...message] = process.argv;`'
- en: Destructuring allows you to rapidly map arrays to variable names. Since `process.argv`
    is an array, which always contains the path to the Node executable and the path
    to the executing file as the first two arguments, we can pass a file target to
    the previous script by executing `node script.js /some/file/path`, where the third
    argument is assigned to the `target` variable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 解构允许您快速将数组映射到变量名。由于`process.argv`是一个数组，它始终包含Node可执行文件的路径和执行文件的路径作为前两个参数，我们可以通过执行`node
    script.js /some/file/path`将文件目标传递给上一个脚本，其中第三个参数分配给`target`变量。
- en: 'Maybe we also want to pass a message with something like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们还想通过这样的方式传递消息：
- en: '`node script.js /some/file/path This is a really great file!`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`node script.js /some/file/path This is a really great file!`'
- en: 'The problem here is that `This is a really great file!` is space-separated,
    so it will be split into the array on each word, which is not what we want:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`This is a really great file!`是以空格分隔的，因此它将被分割成每个单词的数组，这不是我们想要的：
- en: '`[... , /some/file/path, This, is, a, really, great, file!]`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`[... , /some/file/path, This, is, a, really, great, file!]`'
- en: 'The **rest pattern** comes to the rescue here: the final argument  `...message`
    collapses all remaining destructured arguments into a single array, which we can
    simply `join('' '')` into a single string. This also works for objects:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**剩余模式**在这里拯救了我们：最终参数`...message`将所有剩余的解构参数合并为一个数组，我们可以简单地`join('' '')`成一个字符串。这也适用于对象：'
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This pattern is especially useful for processing function arguments. Prior
    to rest parameters, you might have been grabbing function arguments in this way:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对于处理函数参数特别有用。在使用剩余参数之前，您可能会以这种方式获取函数参数：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This was necessary previously, as the `arguments` object was not a true Array.
    In addition to being rather clumsy, this method also triggers de-optimization
    in compilers like V8.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以前是必要的，因为`arguments`对象不是真正的数组。除了相当笨拙外，这种方法还会触发像V8这样的编译器中的非优化。
- en: 'Now, you can do this instead:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以这样做：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The **spread pattern** is the rest pattern in reverse—you expand a single variable
    into many:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**展开模式**是反向的剩余模式——你可以将单个变量扩展为多个：'
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Arrow functions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: '**Arrow functions** allow you to shorten function declarations, from `function()
    {}` to `simply () => {}`. Indeed, you can replace a line like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**箭头函数**允许你缩短函数声明，从`function() {}`到`简单 () => {}`。实际上，你可以替换一行代码：'
- en: '`SomeEmitter.on(''message'', function(message) { console.log(message) });`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`SomeEmitter.on(''message'', function(message) { console.log(message) });`'
- en: 'To:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 至于：
- en: '`SomeEmitter.on(''message'', message => console.log(message));`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`SomeEmitter.on(''message'', message => console.log(message));`'
- en: Here, we lose both the brackets and curly braces, and the tighter code works
    as expected.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们失去了括号和大括号，更紧凑的代码按预期工作。
- en: 'Another important feature of arrow functions is they are not assigned their
    own `this`—arrow functions inherit `this` from the call site. For example, the
    following code does not work:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的另一个重要特性是它们不会分配自己的`this`——箭头函数从调用位置继承`this`。例如，以下代码不起作用：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The function within `setInterval` is being called in the context of `setInterval`,
    rather than the `Counter` object, so this does not have any reference to count.
    That is, at the function call site, `this` is a `Timeout` object, which you can
    check yourself by adding `console.log(this)` to the prior code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval`内的函数是在`setInterval`的上下文中调用的，而不是`Counter`对象的上下文，因此`this`没有任何与计数相关的引用。也就是说，在函数调用站点，`this`是一个`Timeout`对象，你可以通过在先前的代码中添加`console.log(this)`来检查自己。'
- en: 'With arrow functions, this is assigned at the point of definition. Fixing the
    code is easy:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数，`this`在定义的时候被分配。修复代码很容易：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: String manipulation
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'Finally, you will see a lot of backticks in the code. This is the new **template
    literal** syntax, and along with other things, it (finally!) makes working with
    strings in JavaScript much less error-prone and tedious. You saw in the example
    how it is now easy to express multiline strings (avoiding `''First line\n'' +
    ''Next line\n''` types of constructs). String interpolation is similarly improved:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会在代码中看到很多反引号。这是新的**模板文字**语法，除其他功能外，它（终于！）使得在JavaScript中处理字符串变得更不容易出错和繁琐。你在示例中看到了如何轻松表达多行字符串（避免`'First
    line\n' + 'Next line\n'`这种构造）。字符串插值也得到了类似的改进：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This sort of substitution is especially effective when concatenating many variables,
    and since the contents of each `${expression}` can be any JavaScript code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替换在连接许多变量时特别有效，因为每个`${expression}`的内容都可以是任何JavaScript代码：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can also use `repeat` to generate strings: `''ha''.repeat(3) // hahaha`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`repeat`来生成字符串：`'ha'.repeat(3) // hahaha`。
- en: 'Strings are now iterable. Using the new `for...of` construct, you can pluck
    apart a string character by character:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在字符串是可迭代的。使用新的`for...of`结构，你可以逐个字符地拆分字符串：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Alternatively, use the spread operator:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用展开操作符：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Searching is also easier. New methods allow common substring seeks without
    much ceremony:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索也更容易。新的方法允许常见的子字符串查找而不需要太多仪式：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The second argument to these methods indicates a search offset, defaulting to
    0\. `The` is found at position 0, so beginning the search at position 1 fails
    in the second case.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的第二个参数表示搜索偏移，默认为0。`The`在位置0被找到，所以在第二种情况下从位置1开始搜索会失败。
- en: Great, writing JavaScript programs just got a little easier. The next question
    is what's going on when that program is executed within a V8 process?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，编写JavaScript程序变得更容易了。下一个问题是当程序在V8进程中执行时发生了什么？
- en: The process object
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程对象
- en: 'Node''s **process object** provides information on and control over the current
    running process. It is an instance of `EventEmitter` is accessible from any scope,
    and exposes very useful low-level pointers. Consider the following program:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Node的**process对象**提供了有关当前运行进程的信息和控制。它是`EventEmitter`的一个实例，可以从任何范围访问，并公开非常有用的低级指针。考虑下面的程序：
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Have Node run `process.js` with a command like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让Node使用类似这样的命令运行`process.js`：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The program gets the command-line arguments from `process.argv`, loops to allocate
    memory, and reports memory usage back to standard out. Instead of logging back
    to the terminal, you could stream output to another process, or a file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从`process.argv`获取命令行参数，循环分配内存，并将内存使用情况报告回标准输出。你可以将输出流到另一个进程或文件，而不是记录回终端：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A Node process begins by constructing a single execution stack, with the global
    context forming the base of the stack. Functions on this stack execute within
    their own local context (sometimes referred to as **scope**), which remains enclosed
    within the global context. This way of keeping the execution of a function together
    with the environment the function runs in is called **closure. **Because Node
    is evented, any given execution context can commit the running thread to handling
    an eventual execution context. This is the purpose of callback functions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Node进程通过构建单个执行堆栈开始，全局上下文形成堆栈的基础。这个堆栈上的函数在它们自己的本地上下文中执行（有时被称为**作用域**），这个本地上下文保持在全局上下文中。将函数的执行与函数运行的环境保持在一起的方式被称为**闭包**。因为Node是事件驱动的，任何给定的执行上下文都可以将运行线程提交给处理最终执行上下文。这就是回调函数的目的。
- en: 'Consider the following schematic of a simple interface for accessing the filesystem:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的简单接口示意图，用于访问文件系统：
- en: '![](img/ed1fbee2-0820-44ff-96b6-1bacc2f11e1d.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed1fbee2-0820-44ff-96b6-1bacc2f11e1d.png)'
- en: 'If we were to instantiate `Filesystem` and call `readDir`, a nested execution
    context structure would be created:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实例化`Filesystem`并调用`readDir`，将创建一个嵌套的执行上下文结构：
- en: '[PRE56]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Inside Node, a C library named `libuv` creates and manages the event loop. It
    connects to low-level operating system kernel mode objects that can produce events,
    such as timers that go off, sockets that receive data, files that open for reading,
    and child processes that complete. It loops while there are still events to process,
    and calls callbacks associated with events. It does this at a very low level,
    and with a very performant architecture. Written for Node, `libuv` is now a building
    block of a number of software platforms and languages.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node内部，一个名为`libuv`的C库创建和管理事件循环。它连接到可以产生事件的低级操作系统内核模式对象，例如定时器触发、接收数据的套接字、打开读取的文件和完成的子进程。它在仍有事件需要处理时循环，并调用与事件相关的回调。它在非常低的级别上进行操作，并且具有非常高效的架构。为Node编写的`libuv`现在是许多软件平台和语言的构建块。
- en: The concomitant execution stack is introduced to Node's single-process thread. This
    stack remains in memory until `libuv` reports that `fs.readdir` has completed,
    at which point the registered anonymous callback fires, resolving the sole pending
    execution context. As no further events are pending, and the maintenance of closures
    no longer necessary, the entire structure can be safely torn down (in reverse,
    beginning with anonymous), and the process can exit, freeing any allocated memory.
    This method of building up and tearing down a single stack is what Node's event
    loop is ultimately doing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，执行堆栈被引入到Node的单进程线程中。这个堆栈保留在内存中，直到`libuv`报告`fs.readdir`已经完成，此时注册的匿名回调触发，解析唯一的待处理执行上下文。由于没有进一步的事件待处理，也不再需要维护闭包，整个结构可以安全地被拆除（从匿名开始逆序），进程可以退出，释放任何分配的内存。构建和拆除单个堆栈的方法就是Node的事件循环最终所做的。
- en: The REPL
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPL
- en: 'Node''s **REPL** (**Read-Eval-Print-Loop**) represents the Node shell. To enter
    the shell prompt, enter Node via your terminal without passing a filename:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Node的**REPL**（**Read-Eval-Print-Loop**）代表了Node的shell。要进入shell提示符，通过终端输入Node而不传递文件名：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You now have access to a running Node process, and may pass JavaScript commands
    to this process. Additionally, if you enter an expression, the REPL will echo
    back the value of the expression. As a simple example of this, you can use the
    REPL as a pocket calculator:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以访问正在运行的Node进程，并可以向该进程传递JavaScript命令。此外，如果输入一个表达式，REPL将回显表达式的值。作为这一点的一个简单例子，您可以使用REPL作为一个口袋计算器：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Enter the `2+2` expression, and Node will echo back the value of the expression,
    `4`. Going beyond simple number literals, you can use this behavior to query,
    set, and again, query the values of variables:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`2+2`表达式，Node将回显表达式的值`4`。除了简单的数字文字之外，您可以使用这种行为来查询、设置和再次查询变量的值：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Node's REPL is an excellent place to try out, debug, test, or otherwise play
    with JavaScript code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Node的REPL是一个很好的地方，可以尝试、调试、测试或以其他方式玩耍JavaScript代码。
- en: 'As the REPL is a native object, programs can also use instances as a context
    in which to run JavaScript interactively. For example, here we create our own
    custom function `sayHello`, add it to the context of a REPL instance, and start
    the REPL, emulating a Node shell prompt:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REPL是一个本地对象，程序也可以使用实例作为运行JavaScript的上下文。例如，在这里我们创建了自己的自定义函数`sayHello`，将其添加到REPL实例的上下文中，并启动REPL，模拟Node
    shell提示符：
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Enter `sayHello()` at the prompt, and the function will send `Hello` to standard
    out.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符处输入`sayHello()`，函数将向标准输出发送`Hello`。
- en: 'Let''s take everything we''ve learned in this chapter and create an interactive
    REPL that allows us to execute JavaScript on a remote server:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这一章学到的一切都应用到一个交互式的REPL中，允许我们在远程服务器上执行JavaScript：
- en: Create two files, `client.js` and `server.js`, and type in the following code.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个文件`client.js`和`server.js`，并输入以下代码。
- en: 'Run each in its own terminal window, keeping both windows side by side on your
    screen:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自己的终端窗口中运行每个程序，将两个窗口并排放在屏幕上：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `client.js` program creates a new socket connection to port `8080` through
    `net.connect`, and pipes any data coming from standard in (your terminal) through
    to that socket. Similarly, any data arriving from the socket is piped to standard
    out (back to your terminal). With this code, we've created a way to take terminal
    input and send it via a socket to port `8080`, listening for any data that the
    socket may send back to us.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.js`程序通过`net.connect`创建一个新的套接字连接到端口`8080`，并将来自标准输入（您的终端）的任何数据通过该套接字传输。同样，从套接字到达的任何数据都被传输到标准输出（返回到您的终端）。通过这段代码，我们创建了一种方式，将终端输入通过套接字发送到端口`8080`，并监听套接字可能发送回来的任何数据。'
- en: The other program, `server.js,` closes the loop. This program uses `net.createServer`
    and `.listen` to create and start a new TCP server. The callback the code passes
    to `net.createServer` receives a reference to the bound socket. Within the enclosure
    of that callback, we instantiate a new REPL instance, giving it a nice prompt
    (`>` here, but could be any string), indicating that it should both listen for
    input from, and broadcast output to, the passed socket reference, indicating that
    the socket data should be treated as terminal data (which has special encoding).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个程序`server.js`结束了循环。这个程序使用`net.createServer`和`.listen`来创建和启动一个新的TCP服务器。代码传递给`net.createServer`的回调接收到绑定套接字的引用。在该回调的封闭内部，我们实例化一个新的REPL实例，给它一个漂亮的提示符（这里是`>`，但可以是任何字符串），指示它应该同时监听来自传递的套接字引用的输入，并广播输出，指示套接字数据应该被视为终端数据（具有特殊编码）。
- en: We can now type something like `console.log("hello")` into the client terminal,
    and see `hello` displayed.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在客户端终端中输入`console.log("hello")`，并看到显示`hello`。
- en: To confirm that the execution of our JavaScript commands is occurring in the
    server instance, type `console.log(process.argv)` into the client, and the server
    will display an object containing the current process path, which will be `server.js.`
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认我们的JavaScript命令的执行发生在服务器实例中，可以在客户端输入`console.log(process.argv)`，服务器将显示一个包含当前进程路径的对象，即`server.js`。
- en: With just a few lines of code, we've created a way to remotely control Node
    processes. It's the first step towards multi-node analytics tools, remote memory
    management, automatic server administration, and more.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行代码，我们就创建了一种远程控制Node进程的方式。这是迈向多节点分析工具、远程内存管理、自动服务器管理等的第一步。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Experienced developers have all struggled with the problems that Node aims
    to solve:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的开发人员都曾经面对过Node旨在解决的问题：
- en: How to serve many thousands of simultaneous clients efficiently
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何有效地为成千上万的同时客户提供服务
- en: Scaling networked applications beyond a single server
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将网络应用程序扩展到单个服务器之外
- en: Preventing I/O operations from becoming bottlenecks
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止I/O操作成为瓶颈
- en: Eliminating single points of failure, thereby ensuring reliability
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除单点故障，从而确保可靠性
- en: Achieving parallelism safely and predictably
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全可预测地实现并行性
- en: As each year passes, we see collaborative applications and software responsible
    for managing levels of concurrency that would have been considered rare just a
    few years ago. Managing concurrency, both in terms of connection handling and
    application design, is the key to building scalable architectures.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每一年的过去，我们看到协作应用程序和软件负责管理并发水平，这在几年前被认为是罕见的。管理并发，无论是在连接处理还是应用程序设计方面，都是构建可扩展架构的关键。
- en: In this chapter, we've outlined the key problems Node's designers sought to
    solve, and how their solution has made the creation of easily scalable, high-concurrency
    networked systems easier for an open community of developers. We've seen how JavaScript
    has been given very useful new powers, how its evented model has been extended,
    and how V8 can be configured to further customize the JavaScript runtime. Through
    examples, we've learned how I/O is handled by Node, how to program the REPL, as
    well as how to manage inputs and outputs to the process object.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了Node的设计者试图解决的关键问题，以及他们的解决方案如何使开发人员社区更容易创建可扩展、高并发的网络系统。我们看到了JavaScript被赋予了非常有用的新功能，它的事件模型得到了扩展，V8可以配置以进一步定制JavaScript运行时。通过示例，我们学习了Node如何处理I/O，如何编程REPL，以及如何管理输入和输出到进程对象。
- en: Node turns JavaScript into a systems language, creating a useful anachronism
    of scripting sockets as well as buttons, and cutting across decades of learning
    from the evolution of computing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Node将JavaScript转化为系统语言，创造了一个有用的时代错位，既可以脚本套接字，也可以按钮，并跨越了几十年的计算机演变学习。
- en: Node's design restores the virtues of simplicity the original Unix developers
    discovered in the 1970s. Interestingly, computer science rebelled against that
    philosophy in the intervening time period. C++ and Java favored object-oriented
    design patterns, serialized binary data formats, subclassing rather than rewriting,
    and other policies that caused codebases to often grow to one million lines or
    more before finally collapsing under the weight of their own complexity.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Node的设计恢复了20世纪70年代Unix原始开发人员发现的简单性的优点。有趣的是，计算机科学在这段时间内反对了这种哲学。C++和Java倾向于面向对象的设计模式、序列化的二进制数据格式、子类化而不是重写以及其他政策，这些政策导致代码库在最终在自身复杂性的重压下崩溃之前往往增长到一百万行或更多。
- en: But then came the web. The browser's View, Source feature is a gentle on-ramp
    that brought millions of web users into the ranks of a new generation of software
    developers. Brendan Eich designed JavaScript with this novice prospective developer
    in mind. It's easy to start by editing tags and changing styles, and soon be writing
    code. Talk to the young employees of newly growing start-ups, now professional
    developers, engineers, and computer scientists, and many will recount View, Source
    as how they got their start.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后出现了网络。浏览器的“查看源代码”功能是一个温和的入口，它将数百万网络用户带入了新一代软件开发人员的行列。Brendan Eich设计JavaScript时考虑到了这些新手潜在开发人员。很容易从编辑标签和更改样式开始，然后很快就能编写代码。与新兴初创公司的年轻员工交谈，现在他们是专业开发人员、工程师和计算机科学家，许多人会回忆起“查看源代码”是他们开始的方式。
- en: Riding Node's time warp back, JavaScript found a similar design and philosophy
    in the founding principles of Unix. Perhaps connecting computers to the internet
    gave smart people new, more interesting computing problems to solve. Perhaps another
    new generation of students and junior employees arrived and rebelled against their
    mentors once again. For whatever reason, small, modular, and simple make up the
    prevailing philosophy today, as they did much earlier before.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Node的时间扭曲，JavaScript在Unix的创始原则中找到了类似的设计和哲学。也许将计算机连接到互联网给聪明人带来了新的、更有趣的计算问题要解决。也许又出现了一代新的学生和初级员工，并再次反抗他们的导师。无论出于何种原因，小型、模块化和简单构成了今天的主导哲学，就像很早以前一样。
- en: In the decades ahead, how many more times will computing technology change enough
    to prompt the designers of the day to write new software and languages quite different
    from the practices taught and accepted as correct, finished, and permanent just
    a few years earlier? As *Arthur C. Clarke* noted, trying to predict the future
    is a discouraging and hazardous occupation. Perhaps we'll see several more revolutions
    in computers and code. Alternatively, it's possible that computing technology
    will soon plateau for a stretch of years, and within that stability, computer
    scientists will find and settle on the best paradigms to teach and use. Nobody
    knows the best way to code right now, but perhaps soon, we will. If that's the
    case, then this time now, when creating and exploring to find these answers is
    anyone's game, is a wonderfully compelling time to be working and playing with
    computers.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来几十年，计算技术会发生多少次变化，足以促使当时的设计师编写与几年前教授和接受为正确、完整和永久的软件和语言截然不同的新软件？正如*阿瑟·C·克拉克*所指出的，试图预测未来是一项令人沮丧和危险的职业。也许我们会看到计算机和代码的几次革命。另一方面，计算技术很可能很快就会进入一个稳定期，在这段时间内，计算机科学家将找到并确定最佳的范例来教授和使用。现在没有人知道编码的最佳方式，但也许很快我们会知道。如果是这样的话，那么现在这个时候，当创建和探索以找到这些答案是任何人的游戏时，是一个非常引人入胜的时刻，可以与计算机一起工作和玩耍。
- en: Our goal of demonstrating how Node allows applications to be intelligently constructed
    out of well-formed pieces in a principled way has begun. In the next chapter,
    we will delve deeper into asynchronous programming, learn how to manage more complex
    event chains, and develop more powerful programs using Node's model.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示Node如何以一种有原则的方式智能地构建应用程序的目标已经开始。在下一章中，我们将更深入地探讨异步编程，学习如何管理更复杂的事件链，并使用Node的模型开发更强大的程序。
