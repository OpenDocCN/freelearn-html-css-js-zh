- en: Chapter 3. Model Bindings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。模型绑定
- en: 'Keeping models in sync with other objects such as views can be challenging,
    and if it is not done correctly, it can lead to messy code. In this chapter, we
    will explore how to deal with data synchronization to make data binding easier.
    But, what is data binding? Wikipedia defines data binding as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 保持模型与其他对象（如视图）同步可能具有挑战性，如果做得不正确，可能会导致代码混乱。在本章中，我们将探讨如何处理数据同步以简化数据绑定。但是，什么是数据绑定？维基百科将数据绑定定义为：
- en: '*Data binding is the process that establishes a connection between the application
    UI (User Interface) and business logic. If the settings and notifications are
    correctly set, the data reflects changes when made. It can also mean that when
    the UI is changed, the underlying data will reflect that change.*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*数据绑定是建立应用程序UI（用户界面）和业务逻辑之间连接的过程。如果设置和通知设置正确，数据会在更改时反映变化。它也可以意味着当UI发生变化时，底层数据将反映这一变化。*'
- en: A common issue with model binding is how to deal with complex model structures
    that include other embedded objects or lists; in this chapter, we will define
    a strategy to deal with these scenarios. A missing feature in Backbone is two-way
    binding; in the next sections, we will see how to implement this without a headache.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 模型绑定中常见的问题是如何处理包含其他嵌入对象或列表的复杂模型结构；在本章中，我们将定义一种处理这些场景的策略。Backbone 缺少的功能是双向绑定；在接下来的几节中，我们将看到如何在不头疼的情况下实现它。
- en: Let's start the chapter describing how to bind model data with views manually
    to see how Backbone works; after that, we can use Backbone.Stickit to make it
    much easier. After learning how to sync model data and views, we will explore
    how to perform validations on the models and how to display error messages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从描述如何手动将模型数据与视图绑定开始本章，以了解 Backbone 的工作原理；之后，我们可以使用 Backbone.Stickit 使其变得更加容易。在了解如何同步模型数据和视图之后，我们将探讨如何在模型上执行验证以及如何显示错误消息。
- en: Manual binding
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动绑定
- en: 'To make it simple, imagine that we have a form with a simple layout: name,
    phone, and an email address:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，想象我们有一个具有简单布局的表单：姓名、电话和电子邮件地址：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the snippet, we have two views that will be rendered at the same time. When
    the user clicks on the **Save** button in the form, the preview template will
    be updated with the model data:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们有两个将在同一时间渲染的视图。当用户点击表单中的 **保存** 按钮时，预览模板将使用模型数据更新：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code will render the contents of the `contact` model in the form and in
    the preview. When the **Save now** button is clicked, nothing happens because
    it hasn''t yet been programmed, so let''s save the changes in the model:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在表单和预览中渲染 `contact` 模型的内容。当点击 **立即保存** 按钮时，没有任何操作发生，因为它还没有被编程，所以让我们在模型中保存这些更改：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's see what's happening here. In `FormView`, we're updating the model with
    the data in the form inputs; this action syncs the form data with the model, triggering
    a `'change'` event on the Model. Because `ContactPreview` is listening for the
    change, the event will update itself with the data in the model.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。在 `FormView` 中，我们使用表单输入中的数据更新模型；这个动作同步了表单数据与模型，触发模型上的 `'change'`
    事件。因为 `ContactPreview` 正在监听变化，所以事件将使用模型中的数据更新自己。
- en: Backbone is not built with *automagic* view-model bindings, so it's the developer's
    responsibility to implement it. Fortunately, there are some Backbone plugins that
    can help us to make it less painful; one of these is `Backbone.Stickit`, developed
    by the *New York Times*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 不是通过 *自动魔法* 视图-模型绑定构建的，因此这是开发者的责任来实现它。幸运的是，有一些 Backbone 插件可以帮助我们使其不那么痛苦；其中之一是
    *纽约时报* 开发的 `Backbone.Stickit`。
- en: Two-way binding
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向绑定
- en: '`Angular.js` has been popularized as two-way data binding in the frontend;
    the idea behind two-way data binding is to keep views and models in sync. When
    you make a change in an input field the view the model should be updated immediately,
    and if you change a property in the model the view should show the current value
    immediately:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Angular.js` 在前端普及了双向数据绑定；双向数据绑定的理念是保持视图和模型同步。当你在一个输入字段中做出更改时，视图应该立即更新模型，如果你在模型中更改一个属性，视图应该立即显示当前值：'
- en: '![Two-way binding](img/B01962_03_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![双向绑定](img/B01962_03_01.jpg)'
- en: Figure 3.1 Two-way data binding with Backbone
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 使用 Backbone 的双向数据绑定
- en: Backbone does not provide a mechanism to achieve this easily; however, we can
    do it using the event system that Backbone models provide. Figure 3.1 shows how
    you can make an implementation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone不提供实现此功能的简单机制；然而，我们可以使用Backbone模型提供的事件系统来完成它。图3.1显示了如何实现。
- en: '`Backbone.View` listens for `keyup` and `change` events on input controls at
    the DOM; when a change is triggered from the DOM, `Backbone.View` can extract
    the new value from the input and set the Model:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone.View`监听DOM中的输入控件上的`keyup`和`change`事件；当从DOM触发更改时，`Backbone.View`可以从输入中提取新值并设置模型：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you call the `set()` method on `Backbone.View`, at least two events are
    triggered: `change` and `change:<fieldname>`.We can use these events to update
    the necessary views:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`Backbone.View`上调用`set()`方法时，至少会触发两个事件：`change`和`change:<fieldname>`。我们可以使用这些事件来更新必要的视图：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see the output of the preceding snippet in the following figure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图中看到前面代码片段的输出：
- en: '![Two-way binding](img/B01962_03_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![双向绑定](img/B01962_03_02.jpg)'
- en: Figure 3.2 Output of change events
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2更改事件的输出
- en: We can use these events to update the view when necessary. Indeed, the code
    we already have is enough to keep the `ContactForm` and `ContactPreview` views
    in sync.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些事件在必要时更新视图。实际上，我们已有的代码足以保持`ContactForm`和`ContactPreview`视图同步。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`ContactPreview` is listening for every change in the model and re-rendering
    the view when something changes. However, re-rendering the whole view each time
    is a heavy process; it would be better if we made the changes only when necessary.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactPreview`正在监听模型中的每一个变化，并在有变化时重新渲染视图。然而，每次都重新渲染整个视图是一个耗时的过程；如果只在必要时进行更改会更好。'
- en: 'First, you will need to identify each field with an identifier:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要使用标识符识别每个字段：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And the change event handler will update only the contents of the identified
    elements:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并且更改事件处理程序将只更新已识别元素的內容：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Despite the result of the two-way data binding it should be used with caution;
    some people don't think that two-way data binding is a good idea and consider
    it as an anti-pattern.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管双向数据绑定的结果应该谨慎使用；有些人认为双向数据绑定不是一个好主意，并将其视为反模式。
- en: References
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Refer to the following URLs for more information:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅以下链接：
- en: 'Why you should not use AngularJS: [http://bit.ly/1Mue1kC](http://bit.ly/1Mue1kC)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你不应该使用AngularJS：[http://bit.ly/1Mue1kC](http://bit.ly/1Mue1kC)
- en: 'AngularJS Antipatterns and Pitfalls: [http://bit.ly/1kTHKqS](http://bit.ly/1kTHKqS)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS的反模式和陷阱：[http://bit.ly/1kTHKqS](http://bit.ly/1kTHKqS)
- en: 'What''s wrong with Angular 1: [http://bit.ly/1N9wHok](http://bit.ly/1N9wHok)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 1的问题在哪里：[http://bit.ly/1N9wHok](http://bit.ly/1N9wHok)
- en: Data binding with plugins
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插件进行数据绑定
- en: As you can see in the previous section, Backbone does not provide an easy mechanism
    to sync your models and the views that use them. Some plugins for Backbone have
    been developed to minimize this issue; one of them is `Backbone.Stickit`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，Backbone不提供同步你的模型及其使用视图的简单机制。一些Backbone插件已被开发出来以最小化这个问题；其中之一是`Backbone.Stickit`。
- en: 'If you want an easy and yet powerful way to bind DOM nodes and Backbone models,
    `Backbone.Stickit` will do a great job:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一种简单而强大的方式来绑定DOM节点和Backbone模型，`Backbone.Stickit`将做得很好：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code example shows how it looks; please consult the project documentation
    to learn more about it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了其外观；请查阅项目文档以了解更多信息。
- en: Binding embedded data
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定嵌入数据
- en: 'One of the most common issues with Backbone is how to deal with complex model
    data:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone最常见的问题之一是如何处理复杂模型数据：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It could be easy to render a read-only view for this model data; however, the
    real challenge is how to bind form actions with embedded arrays. In Backbone,
    it is difficult to use the event system on array objects; if you push a new item
    in the list, no event will be triggered. This makes it difficult to keep model
    data in sync with the a view that edits its contents.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模型数据，渲染只读视图可能很简单；然而，真正的挑战是如何将表单操作与嵌入数组绑定。在Backbone中，很难在数组对象上使用事件系统；如果你在列表中推入一个新项目，不会触发任何事件。这使得难以保持模型数据与编辑其内容的视图同步。
- en: Binding an embedded list
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定嵌入列表
- en: 'Imagine that our Contacts App will now allow us to add more than one phone
    and email. We will need to change the edit form view to add support for adding,
    removing, and modifying items on the array of phones and emails:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们的联系人应用现在将允许我们添加多个电话和电子邮件。我们需要更改编辑表单视图以支持添加、删除和修改电话和电子邮件数组中的项目：
- en: '![Binding an embedded list](img/B01962_03_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![绑定嵌入式列表](img/B01962_03_03.jpg)'
- en: Figure 3.3\. Contact form layout with phone and email lists
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3.带有电话和电子邮件列表的联系人表单布局
- en: Figure 3.3 shows the result of adding a **New** button to allow the user to
    dynamically add the number of phones and emails he/she wants. Each item in the
    list should include a **Delete** button too to allow the user to remove them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3显示了添加**新建**按钮的结果，允许用户动态添加他们想要的电话和电子邮件数量。列表中的每个项目还应包括一个**删除**按钮，以便用户可以删除它们。
- en: 'To render the phone and email lists and sync the forms with the model, we will
    follow a different strategy; Figure 3.4 illustrates how our strategy will look:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染电话和电子邮件列表以及将表单与模型同步，我们将采用不同的策略；图3.4展示了我们的策略将如何呈现：
- en: '![Binding an embedded list](img/B01962_03_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![绑定嵌入式列表](img/B01962_03_04.jpg)'
- en: Figure 3.4 Embedded array rendering strategy
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4嵌入式数组渲染策略
- en: We will create two new Backbone collections, one for phones and another for
    emails. With the data in the `Contact` model we can initialize these collections
    and render them as regular `CollectionView`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个新的 Backbone 集合，一个用于电话，另一个用于电子邮件。有了 `Contact` 模型中的数据，我们可以初始化这些集合并将它们作为常规
    `CollectionView` 渲染。
- en: As we saw in the previous chapter, `CollectionView` objects take care of the
    changes in the collection that it renders, so that we can modify the collection
    object and the view will behave as expected.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，`CollectionView` 对象负责它所渲染的集合中的更改，因此我们可以修改集合对象，视图将按预期行为。
- en: When the user clicks on the **Save** button, we can serialize the content of
    these collections and update the model before we call the `save()` method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**保存**按钮时，我们可以在调用 `save()` 方法之前序列化这些集合的内容并更新模型。
- en: 'Each item for phones and emails will have a very similar template:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 电话和电子邮件的每个项目都将有一个非常相似的模板：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This template will be used as a `ModelView` for a `CollectionView`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板将用作 `CollectionView` 的 `ModelView`：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The contact form now should include two regions for `PhoneListView` and `EmailListView`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人表单现在应包括两个区域用于 `PhoneListView` 和 `EmailListView`：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`ContactForm` should be changed to support regions; we will extend from `Layout`
    instead of `ModelView`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactForm` 应该改为支持区域；我们将从 `Layout` 扩展而不是 `ModelView`：'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will need two new models: `Phone` and `Email`. Because both models are very
    similar, I will only show `Phone`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要两个新的模型：`Phone` 和 `Email`。由于这两个模型非常相似，我将只展示 `Phone`：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And collection that uses the `Phone` model:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Phone` 模型的集合：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have the necessary objects to render the form, let''s put them
    all together in the controller. First, we need to create the collection instances
    from the model data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了渲染表单所需的必要对象，让我们在控制器中将它们全部组合起来。首先，我们需要从模型数据中创建集合实例：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the collections in place, we can build `CollectionView`s properly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了集合之后，我们可以正确地构建 `CollectionView`s：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `phonesView` and `emailsView` can be rendered in the regions exposed in
    the `contactForm` object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`phonesView` 和 `emailsView` 可以在 `contactForm` 对象公开的区域中渲染：'
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the user clicks on the **New** button, a new item in a proper list should
    be added:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**新建**按钮时，应在适当的列表中添加一个新项目：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `ContactForm` knows nothing about the collections that we are using in
    the controller, so they can''t add an item in the collection directly; the controller
    should listen for events in the `contactForm` and update the collection:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactForm` 对我们在控制器中使用的集合一无所知，因此它们不能直接在集合中添加项目；控制器应该监听 `contactForm` 中的事件并更新集合：'
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the user clicks on the **delete** link in an item of the list, the item
    should be removed from the collection:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击列表中某个项目的**删除**链接时，该项目应从集合中移除：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we did with `add`, the controller will take care of managing the collection
    data by attaching an event listener in the list view:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对 `add` 所做的那样，控制器将通过在列表视图中附加事件监听器来管理集合数据：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see in the preceding snippets, adding items to the list (and removing
    them) is pretty simple; we just need to update the underlying collection and the
    views will be updated automatically. We did a great job with `CollectionViews`
    in the previous chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文片段所示，向列表中添加项目（以及移除它们）相当简单；我们只需更新底层集合，视图将自动更新。我们在上一章中对 `CollectionViews` 做得很好。
- en: 'To save the phone and email attributes in the model, we need to extract the
    data stored in the collections and replace the existing data in the model:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在模型中保存电话和电子邮件属性，我们需要从集合中提取存储的数据并替换模型中的现有数据：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, the collections are not in sync with the forms and you will end up
    with empty emails and phones. To fix this, we need to bind the models with the
    inputs:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，集合与表单不同步，您最终会得到空邮箱和电话号码。为了解决这个问题，我们需要将模型与输入绑定：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, if you click the **Save** button, the data about the phones and emails
    will be stored as expected.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您点击 **保存** 按钮，电话和电子邮件的数据将按预期存储。
- en: This way of binding embedded arrays in views through intermediate collections
    simplifies the way you work with lists and will make your code a lot simpler and
    more maintainable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过中间集合将嵌入式数组绑定到视图中的这种方式简化了您与列表的工作方式，并将使您的代码更加简单和易于维护。
- en: Validating model data
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证模型数据
- en: Usually, on frontend applications, the inputs are validated with UI plugins
    such as jQuery Validation, which focuses on the user interface. In other words,
    the data is validated directly on the DOM. However, on bigger applications that
    would not be the best approach.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在前端应用程序中，输入验证是通过 UI 插件如 jQuery Validation 进行的，它侧重于用户界面。换句话说，数据是在 DOM 上直接验证的。然而，对于更大的应用程序，这并不是最佳方法。
- en: Validations in Backbone can be done manually or through plugins. Of course,
    the best approach is to use a plugin because it saves time and effort, but before
    we learn how to use the `backbone.validation` plugin, I want to show you how native
    validation works.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 中的验证可以是手动进行或通过插件进行。当然，最佳方法是使用插件，因为它可以节省时间和精力，但在我们学习如何使用 `backbone.validation`
    插件之前，我想向您展示原生验证是如何工作的。
- en: Manual validation
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动验证
- en: 'Backbone models have three properties to help us validate the model data: `validate()`,
    `validationError()`, and `isValid()`. The `validate()`method should return nothing
    if the model data is correct, or a value otherwise.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 模型有三个属性帮助我们验证模型数据：`validate()`、`validationError()` 和 `isValid()`。如果模型数据正确，`validate()`
    方法应该返回空值，否则返回其他值。
- en: 'Backbone leaves open what should be returned by the `validate()` method, so
    you can return just a plain string message or a complex object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 留下了 `validate()` 方法应该返回什么内容，因此您可以返回一个纯字符串消息或一个复杂对象：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can call the `isValid()` method to ensure that your model has a valid state;
    internally, Backbone will call the `validate()` method and will return a Boolean
    value depending on the returned value: `true` if `validate()` returns nothing,
    `false` if it returns something.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调用 `isValid()` 方法来确保您的模型处于有效状态；内部，Backbone 将调用 `validate()` 方法，并根据返回值返回一个布尔值：如果
    `validate()` 返回空值，则返回 `true`，如果返回其他值，则返回 `false`。
- en: 'With `validationError`, you can get the latest validation error in the model—for
    example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `validationError`，您可以获取模型中的最新验证错误——例如：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `validate()` method is called by Backbone when you want to save the model,
    and will trigger an `''invalid''` event if the model is not valid:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要保存模型时，Backbone 会调用 `validate()` 方法，如果模型无效，将触发一个 `'invalid'` 事件：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the contacts editor, we are not validating anything. It''s time to start
    with some validations; let''s validate the name of the contact:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在联系人编辑器中，我们没有进行任何验证。是时候开始进行一些验证了；让我们验证联系人的姓名：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember, the `validate()` method can return anything. Backbone will assume
    that the model is valid only if `validate()` does not return something. In this
    case, an object is returned. Objects are more useful that plain string, because
    return more information that can be used for a better user experience.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`validate()` 方法可以返回任何内容。Backbone 只会在 `validate()` 方法不返回任何内容时认为模型是有效的。在这种情况下，会返回一个对象。对象比纯字符串更有用，因为它们可以返回更多可用于改善用户体验的信息。
- en: 'When an error occurs an `''invalid''` event will be triggered. The editor form
    should display the error, so that the form will be listening for the `''invalid''`
    event in the model, and managing the DOM to display error messages:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，将触发一个 `'invalid'` 事件。编辑表单应显示错误，因此表单将监听模型中的 `'invalid'` 事件，并管理 DOM 以显示错误消息：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `showError()` method appends a `span` message below the input box, so the
    user can see what's wrong. With the `attr` property in the error object, we can
    put the error message in the right box; that's why using an error object is better
    than plain-text messages.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`showError()` 方法在输入框下方追加一个 `span` 消息，这样用户就可以看到哪里出错了。通过错误对象的 `attr` 属性，我们可以将错误消息放入正确的框中；这就是为什么使用错误对象比使用纯文本消息更好的原因。'
- en: Note that we are creating a DOM element in the `showError()` method. I'm creating
    the element dynamically to simplify the code in the view. Of course, you can create
    a `span` element directly in the template too and show/hide it as needed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在 `showError()` 方法中创建了一个 DOM 元素。我在动态创建元素以简化视图中的代码。当然，你也可以直接在模板中创建一个 `span`
    元素，并根据需要显示/隐藏它。
- en: Validating with the Backbone.Validation plugin
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Backbone.Validation 插件进行验证
- en: '`Backbone.Validation` simplifies the validation process, allowing us to write
    validation rules in a declarative way instead of programmatically. Also, it comes
    with built-in validation rules that you can use out-of-the-box. When using `Backbone.Validation`,
    the way you validate models is simplified, as we will show next.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone.Validation` 简化了验证过程，允许我们以声明式的方式编写验证规则，而不是程序化地编写。此外，它还内置了你可以直接使用的验证规则。当使用
    `Backbone.Validation` 时，验证模型的方式会简化，我们将在下面展示。'
- en: To start with `Backbone.Validation`, install the plugin after including Backbone.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 `Backbone.Validation`，在包含 Backbone 之后安装插件。
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can use the plugin; `Backbone.Validation` uses a validation property
    in the models to specify validation rules:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个插件；`Backbone.Validation` 在模型中使用验证属性来指定验证规则：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Instead of using the `validate()` method, you can write the validation rules
    in a configuration object, where the keys of the object are the name of the fields
    in the model; in this case, we are validating the `name` field. The `required`
    and `minLength` validation rules are applied to the `name` field by `Backbone.Validation`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 `validate()` 方法，你可以在配置对象中编写验证规则，其中对象的键是模型中字段的名称；在这种情况下，我们正在验证 `name` 字段。`required`
    和 `minLength` 验证规则通过 `Backbone.Validation` 应用到 `name` 字段。
- en: 'Now that the `Contact` model has the validation configuration, we need to override
    the default `validate()` method in the Backbone model to activate the `Backbone.Validation`
    plugin. To do it, we need to call the `Backbone.Validation.bind()` method in the
    `onRender()` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Contact` 模型有了验证配置，我们需要在 Backbone 模型中重写默认的 `validate()` 方法来激活 `Backbone.Validation`
    插件。要做到这一点，我们需要在 `onRender()` 方法中调用 `Backbone.Validation.bind()` 方法：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `showError()` and `clearErrors()`are now unnecessary because we override
    the `validate()` method on the model. The `Backbone.Validation` plugin provides
    hooks to tell you when a model is valid; we will use these hooks as a shortcut.
    For now, the `save:contact` handler should change to invoke the `isValid()` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在模型上重写了 `validate()` 方法，`showError()` 和 `clearErrors()` 现在不再必要。`Backbone.Validation`
    插件提供了钩子来告诉你模型何时有效；我们将使用这些钩子作为快捷方式。目前，`save:contact` 处理程序应更改为调用 `isValid()` 方法：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note the `true` argument in the `isValid()` method; this argument should be
    used to validate all the model attributes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `isValid()` 方法中的 `true` 参数；这个参数应该用于验证所有模型属性。
- en: 'When `Backbone.Validation` detects that a field is invalid, it will try to
    show an error message in the form; however, the default behavior is based on the
    `name` attribute in the form inputs. You can change the default behavior to show
    errors properly in our layout:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Backbone.Validation` 检测到一个字段无效时，它将尝试在表单中显示一个错误消息；然而，默认行为是基于表单输入中的 `name`
    属性。你可以更改默认行为，在我们的布局中正确地显示错误：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `invalid()` method will be called when invalid data is found; the callback
    is called with an instance of the view, the field name that has the invalid data,
    and a message. With that information, we can create a `span` error message and
    add the `has-error` class to the `control-group` that contains the input.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当发现无效数据时，将调用 `invalid()` 方法；回调函数将使用视图实例、具有无效数据的字段名称和消息作为参数调用。有了这些信息，我们可以创建一个
    `span` 错误消息，并将 `has-error` 类添加到包含输入的 `control-group`。
- en: Please consult the `Backbone.Validation` documentation to learn more about its
    advantages and usage.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请查阅 `Backbone.Validation` 文档以了解更多关于其优点和使用方法。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to keep models and views in sync. In general,
    syncing model and views is easy but things can turn difficult if the model has
    embedded arrays. You can use a plugin to simplify the data binding; `Backbone.Stickit`
    is a good option because it allows you to make your bindings in a declarative
    way.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何保持模型和视图同步。一般来说，同步模型和视图是容易的，但如果模型包含嵌套数组，事情可能会变得复杂。你可以使用插件来简化数据绑定；`Backbone.Stickit`
    是一个不错的选择，因为它允许你以声明式的方式创建绑定。
- en: I showed you how you can make two-way data binding with a vanilla Backbone,
    taking advantage of the event system; it's not always a good idea to use intensive
    two-way data binding in your applications but in some cases it can be useful.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我向你展示了如何使用纯 Backbone 实现双向数据绑定，利用事件系统；在应用中过度使用双向数据绑定并不总是好主意，但在某些情况下它可能很有用。
- en: Finally, we learned how to validate models with Backbone and how to use the
    validation API to show error messages in views. The `Backbone.Validation` plugin
    can help you to validate Backbone models easily with minimal effort, once validation
    callbacks are set correctly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用 Backbone 验证模型，以及如何使用验证 API 在视图中显示错误信息。`Backbone.Validation` 插件可以帮助你轻松地通过最小努力验证
    Backbone 模型，一旦验证回调设置正确。
- en: In the next chapter, we will learn how to modularize our contacts application
    to make it more maintainable and more effectively manage dependencies. Then we
    will bundle the whole application in a single script to load it faster.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何模块化我们的联系人应用，使其更易于维护并更有效地管理依赖关系。然后我们将整个应用打包成一个脚本，以便更快地加载。
