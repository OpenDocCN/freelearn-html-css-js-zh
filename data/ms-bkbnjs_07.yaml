- en: Chapter 7. Build Like a Pro
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章.像专业人士一样构建
- en: Some years ago, you could create a website with PHP, upload your source files
    through FTP to a server, and then go online. During those days, JavaScript was
    a tight piece of the whole system, used for UI tasks such as validating forms
    or small chunks of functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，你可以用PHP创建一个网站，通过FTP上传源文件到服务器，然后上线。在那些日子里，JavaScript是整个系统的一个紧密部分，用于UI任务，如验证表单或小块功能。
- en: Today, web is more JavaScript intensive, we are building web applications instead
    websites, this means that JavaScript is no more a trivial piece of applications,
    it is now a core piece. For this reason, it is important to pack our JavaScript
    application before being deployed for production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，网络越来越依赖于JavaScript，我们正在构建网络应用程序而不是网站，这意味着JavaScript不再是应用程序的一个微不足道的部分，它现在是一个核心部分。因此，在部署到生产之前打包我们的JavaScript应用程序非常重要。
- en: 'You will learn the following in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Building a workflow to automatically process your source files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自动处理源文件的流程
- en: Minifying the application script size
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩应用程序脚本大小
- en: Minifying the number of requests to the server when the application is loaded
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序加载时减少对服务器的请求数量
- en: Minifying the images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩图片
- en: Optimizing the CSS files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化CSS文件
- en: Wiring up everything in an HTML file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML文件中连接所有内容
- en: Setting up a development environment to automatically reload the application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境以自动重新加载应用程序
- en: 'At the time of writing this book, there are many tools to build JavaScript
    applications; however, two of them are the most popular: Grunt and Gulp. Grunt
    is an older choice with a big community around and an amazing collection of plugins
    available. Gulp, on the other hand, is gaining more popularity each day and almost
    has the most popular plugins that exist for Grunt.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，有许多工具可以构建JavaScript应用程序；然而，其中两个最受欢迎的是Grunt和Gulp。Grunt是一个较老的选择，拥有庞大的社区和令人惊叹的插件集合。另一方面，Gulp每天都在获得更多的关注，几乎拥有Grunt存在的大部分最受欢迎的插件。
- en: Development workflow
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工作流程
- en: 'When you are developing an application, some tasks are very repetitive; for
    example, our contacts application uses Browserify to manage dependencies. It needs
    to rebundle the source code every time you make a change, which means that you
    need to run the `browserify` command each time:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发应用程序时，有些任务非常重复；例如，我们的联系人应用程序使用Browserify来管理依赖项。每次你进行更改时，都需要重新打包源代码，这意味着你需要每次都运行`browserify`命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run these commands every time you make a small change is a very tedious
    task, there should be a better way to do it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你进行小更改时都运行这些命令是一个非常繁琐的任务，应该有更好的方法来做这件事：
- en: '![Development workflow](img/B01962_07_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![开发工作流程](img/B01962_07_01.jpg)'
- en: Figure 7.1\. Development workflow
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1\. 开发工作流程
- en: The above figure shows the ideal development process; the first time you run
    the application, you should bundle the source files and run the BrowserSync web
    server and then open the browser. After that, for any change that you make in
    any source file, the application should be rebundled and then the browser should
    be refreshed to get the new changes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了理想的开发生成过程；第一次运行应用程序时，你应该打包源文件，并运行BrowserSync网络服务器，然后打开浏览器。之后，对于你在任何源文件中进行的任何更改，应用程序都应该重新打包，然后刷新浏览器以获取新更改。
- en: Currently, we are manually doing this process; however, in the next section,
    you will learn how to automatize this task to let the machine do all this for
    you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在手动执行此过程；然而，在下一节中，你将学习如何自动化此任务，让机器为你完成所有这些工作。
- en: What's a task runner?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是任务运行器？
- en: A task runner is computer program that runs a sequence of tasks over your source
    code, applying transformations to the files. For example, consider that you are
    writing a source code in the CoffeeScript programming language, one task would
    be compiling all your source code in JavaScript, other task can be concatenating
    all the output JavaScript files in a single file, and the third task can finally
    be minifying the concatenated file to minimize the file size.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 任务运行器是一种计算机程序，它会在你的源代码上运行一系列任务，对文件应用转换。例如，假设你正在用CoffeeScript编程语言编写源代码，一个任务可能是将所有源代码编译成JavaScript，其他任务可以是将所有输出JavaScript文件合并成一个文件，第三个任务可以将合并后的文件进行压缩以减小文件大小。
- en: These tasks will automatically be run by the task runner, you just need to write
    a script file to program what needs to be done and then forget to run any command
    line again. The task runner provides triggers to start a task whenever you change
    a file so that it is done transparently.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务将由任务运行器自动运行，你只需要编写一个脚本文件来编程需要执行的操作，然后忘记再次运行任何命令行。任务运行器提供触发器，以便在更改文件时启动任务，使其透明完成。
- en: As you can see, a task runner can improve your productivity as you can forget
    about the details of the compilation process once you have correctly configured
    a task runner. It will allow you to automate all these repetitive and boring tasks
    and then, you can focus on product development.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，任务运行器可以提高你的生产力，一旦你正确配置了任务运行器，你就可以忘记编译过程的细节。它将允许你自动化所有这些重复且无聊的任务，然后，你可以专注于产品开发。
- en: 'Grunt and Gulp are the most popular task runners for JavaScript; they take
    different approach to run the tasks. In Grunt, the tasks are run sequentially:
    once a task is running, the next task cannot start until the first is done. In
    Gulp, the tasks can run parallel to each other, as shown in the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 和 Gulp 是最流行的 JavaScript 任务运行器；它们在运行任务时采取不同的方法。在 Grunt 中，任务是顺序运行的：一旦一个任务开始运行，下一个任务不能开始，直到第一个任务完成。在
    Gulp 中，任务可以并行运行，如下所示：
- en: '![What''s a task runner?](img/B01962_07_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![什么是任务运行器？](img/B01962_07_02.jpg)'
- en: Figure 7.2 Different approach on running task by Grunt and Gulp
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 Grunt 和 Gulp 运行任务的不同方法
- en: The above figure illustrates how Grunt and Gulp will run three tasks. Task B
    depends on whether Task A and Task C are done. Note that Grunt can run the tasks
    parallel to each other using plugins. While, Gulp does this from its core design.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了 Grunt 和 Gulp 将如何运行三个任务。任务 B 取决于任务 A 和任务 C 是否已完成。请注意，Grunt 可以通过插件并行运行这些任务。而
    Gulp 则从其核心设计上就支持这样做。
- en: Another difference between Grunt and Gulp is that, in Grunt, you can configure
    the tasks on writing a big configuration object. While, in Gulp, you will write
    standard JavaScript functions. An interesting point is that Grunt and Gulp can
    work together in the same project; however, it is better to choose just one of
    them in order to reduce complexity.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 和 Gulp 之间的另一个区别是，在 Grunt 中，你可以在编写一个大的配置对象时配置任务。而在 Gulp 中，你将编写标准的 JavaScript
    函数。一个有趣的观点是，Grunt 和 Gulp 可以在同一个项目中一起工作；然而，为了减少复杂性，最好只选择其中一个。
- en: If your project uses Grunt, you should not switch to Gulp unless have a good
    reason to do it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目使用 Grunt，除非有很好的理由，否则不应切换到 Gulp。
- en: How Gulp works
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gulp 的工作原理
- en: As I mentioned at the beginning of the chapter, Gulp is the most popular JavaScript
    task runner at the time of writing this book and that's the main reason why we
    chose it. Gulp and Grunt work in a similar way, they both use third-party plugins
    to work. Keep in mind that Gulp is more like a framework, it does not make too
    much by itself.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头提到的，Gulp 是在撰写本书时最受欢迎的 JavaScript 任务运行器，这也是我们选择它的主要原因。Gulp 和 Grunt 的工作方式类似，它们都使用第三方插件来工作。请记住，Gulp
    更像是一个框架，它本身并不做太多。
- en: 'Gulp acts as the glue that coordinates the build workflow; it has some basic
    functionality and an API, which the Gulp plugins can use to do their work. The
    plugins use the compilers and utility programs that make the real file processing,
    such as the CoffeeScript transpiler. The plugins connect these programs to the
    Gulp workflow:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 作为协调构建工作流程的粘合剂；它有一些基本功能和一个 API，Gulp 插件可以使用它来完成工作。插件使用编译器和实用程序程序来执行真正的文件处理，例如
    CoffeeScript 编译器。插件将这些程序连接到 Gulp 工作流程中：
- en: '![How Gulp works](img/B01962_07_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Gulp 的工作原理](img/B01962_07_03.jpg)'
- en: Figure 7.3 Relationship between Gulp plugins and libraries
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 Gulp 插件和库之间的关系
- en: The preceding figure shows the relationship that was described earlier, you
    can get a better idea of how Gulp connects with its plugins; notice how the plugins
    delegate the file processing to the utility programs that they connect to.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了之前描述的关系，你可以更好地了解 Gulp 如何与其插件连接；注意插件如何将文件处理委托给它们连接的实用程序。
- en: Gulp is composed of several named tasks where each task can have dependencies
    on other tasks. A typical Gulp task opens a stream of files at the beginning and
    applies transformation to each file in the stream with the installed plugins.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 由几个命名任务组成，每个任务都可以依赖于其他任务。一个典型的 Gulp 任务在开始时打开一个文件流，并使用已安装的插件对流中的每个文件进行转换。
- en: 'A stream is opened with the `gulp.src()` method. It starts a stream that you
    can connect to several pipes in order to apply the necessary transformations.
    When you open a stream, you need to specify the target files that will be used
    in the stream. You will select these files using the `node-glob format`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gulp.src()` 方法打开一个流。它启动一个流，你可以将其连接到多个管道以应用必要的转换。当你打开一个流时，你需要指定将在流中使用的目标文件。你将使用
    `node-glob 格式` 选择这些文件：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is easy to specify the files for the stream, it is similar to what you do
    in the command line. The figure below shows how the stream and pipes are connected.
    The files that are selected are streamed into the Gulp plugins, they make the
    transformations and put the output back in the stream, the next plugin can then
    make its work, and put the result back in the stream:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 指定流中的文件很容易，这与你在命令行中做的类似。下面的图示显示了流和管道是如何连接的。选定的文件被流式传输到 Gulp 插件中，它们进行转换并将输出放回流中，下一个插件可以继续工作，并将结果放回流中：
- en: '![How Gulp works](img/B01962_07_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Gulp 的工作原理](img/B01962_07_04.jpg)'
- en: Figure 7.4 Using node-blob to select files
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 使用 node-blob 选择文件
- en: At the end of the pipe, you will normally write the result in a file that is
    ready to be used. You can put as many Gulp tasks as you need and each task can
    have as many dependencies as it needs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道的末尾，你通常会将结果写入一个已准备好使用的文件。你可以放置你需要的任何数量的 Gulp 任务，每个任务都可以有它需要的任何数量的依赖项。
- en: Getting started with Gulp
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Gulp
- en: 'First of all, install the Gulp package globally; this will give you access
    to the `gulp` command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，全局安装 Gulp 包；这将使你能够访问 `gulp` 命令：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you have installed Gulp globally, you will need to install it in your
    local project in order to have access to the Gulp core utilities:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦全局安装了 Gulp，你还需要在本地项目中安装它，以便能够访问 Gulp 核心工具：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To configure the Gulp tasks, you will need to create a file called `gulpfile.js`
    that Gulp will read every time you run the `gulp` command. All Gulp tasks have
    a name and a function that is executed when the task is invoked:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Gulp 任务，你需要创建一个名为 `gulpfile.js` 的文件，每次运行 `gulp` 命令时 Gulp 都会读取此文件。所有 Gulp
    任务都有一个名称和一个在任务被调用时执行的功能：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following simple Gulp task will print Hello world! on the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的 Gulp 任务将在控制台打印 Hello world!：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note how we invoke Gulp, `gulp hello`, the argument used in the command is the
    name of the task to be executed. This is the simplest Gulp task that you can write
    and it is the starting point for developing an effective build pipeline.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何调用 Gulp 的，`gulp hello`，命令中使用的参数是要执行的任务的名称。这是你可以编写的最简单的 Gulp 任务，也是开发有效构建管道的起点。
- en: Creating a development workflow
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建开发工作流程
- en: 'In this section, we will build a script to help us in the development process
    and, later, to build a production-ready script. You will need to install the basic
    dependencies first:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个脚本以帮助我们进行开发过程，并在之后构建一个可用于生产的脚本。首先，你需要安装基本依赖项：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `gulp-load-plugins` is useful to automatically load all the available plugins
    without manually requiring them in the `gulpfile.js` script; the `gulp-util` plugin
    provides utility functions such as log messages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulp-load-plugins` 非常有用，可以自动加载所有可用的插件，而无需在 `gulpfile.js` 脚本中手动引入它们；`gulp-util`
    插件提供了如日志消息等实用函数。'
- en: Bundling the JavaScript files with Browserify
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Browserify 打包 JavaScript 文件
- en: The `gulp-browserify` plugin is currently deprecated and should not be used.
    The project author recommends using one of the recipes developed by the Gulp development
    team.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulp-browserify` 插件目前已被弃用，不应使用。项目作者建议使用 Gulp 开发团队开发的食谱之一。'
- en: 'The recipes described in the repository needs to install some plugins first:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中描述的食谱需要先安装一些插件：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `gulpfile.js`, we can define the `browserify` task:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gulpfile.js` 中，我们可以定义 `browserify` 任务：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how we configure the Browserify bundle, we use the Browserify `jstify`
    transformation to compile the underscore templates. As the `browserify` task is
    not a standard Gulp plugin, we are using `vinyl-source-stream` to stream the files
    to the bundler. Finally, we will write the output in the `.tmp/js` path.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何配置 Browserify 打包的，我们使用 Browserify 的 `jstify` 转换来编译 underscore 模板。由于 `browserify`
    任务不是一个标准的 Gulp 插件，我们使用 `vinyl-source-stream` 将文件流式传输到打包器。最后，我们将输出写入 `.tmp/js`
    路径。
- en: 'Now, you can run Gulp with the Browserify argument to run the task:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 Browserify 参数运行 Gulp 来执行任务：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The`.tmp/js/app.js` file should exist and be ready to be used. You can run
    the project to verify all is working:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`.tmp/js/app.js` 文件应该存在并准备好使用。您可以运行项目以验证一切是否正常工作：'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sourcemaps
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源映射
- en: When you run the project, the browser gets a single file named `app.js`, which
    contains all the concatenated source code. That's good for the production environments
    as it reduces the number of requests made to the server in order to get the assets.
    However, in development environments, it is more useful to see the individual
    files in the browser as you have it in the source code for the debugging process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行项目时，浏览器将获得一个名为 `app.js` 的单个文件，其中包含所有连接的源代码。这对于生产环境来说很好，因为它减少了服务器请求资产的数量。然而，在开发环境中，更有用的是在浏览器中看到单个文件，就像您在源代码中进行调试过程时那样。
- en: You can make sure that the browser shows you the original source files with
    sourcemaps so that you can put debug breakpoints or simply inspect the code without
    the noise of the other dependencies such as the Backbone library.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以确保浏览器显示带有源映射的原始源文件，这样您就可以放置调试断点或简单地检查代码，而无需其他依赖项（如 Backbone 库）的噪音。
- en: 'To include sourcemaps in the `browserify` task, you will need to install some
    extra dependencies:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `browserify` 任务中包含源映射，您需要安装一些额外的依赖项：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, modify the task:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改任务：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following figure shows the source files in the Google Chrome browser. You
    can inspect the original files and put breakpoints, the browser will ensure to
    stop the execution at the right time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了 Google Chrome 浏览器中的源文件。您可以检查原始文件并放置断点，浏览器将确保在正确的时间停止执行。
- en: 'It is useful for Browserify bundles to see all the original files instead of
    a huge script; however, this technique can be used for the compiled programming
    languages such as CoffeeScript or maybe you can write your source code in ECMAScript
    6 and transpile it with babel and then, the original files with sourcemaps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Browserify 打包，看到所有原始文件而不是一个巨大的脚本非常有用；然而，这种技术也可以用于编译的编程语言，例如 CoffeeScript，或者您也可以用
    ECMAScript 6 编写源代码，然后用 babel 进行转译，然后，带有源映射的原始文件：
- en: '![Sourcemaps](img/B01962_07_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![源映射](img/B01962_07_05.jpg)'
- en: Figure 7.5 Sourcemaps in action
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 源映射的实际应用
- en: Re-bundle automatically
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动重新打包
- en: 'If you change a source file, then you will need to run the `browserify` task
    again. You can make sure that Gulp and Browserify do this job for you. First,
    you will need to install another Browserify plugin:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改了源文件，那么您将需要再次运行 `browserify` 任务。您可以通过安装另一个 Browserify 插件来确保 Gulp 和 Browserify
    为您完成这项工作。首先，您需要安装另一个 Browserify 插件：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `watchify` plugin listens for file changes in the source code and can be
    used to trigger a re-bundle task:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`watchify` 插件会监听源代码中的文件更改，并可用于触发重新打包任务：'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When a change is triggered, the `rebundle()` function will be executed automatically
    so that you only need to refresh the browser. In the next section, you will see
    how to automate this too.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发更改时，`rebundle()` 函数将自动执行，这样您就只需要刷新浏览器。在下一节中，您将看到如何自动化这个过程。
- en: BrowserSync
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BrowserSync
- en: BrowserSync is an asset server that is useful for the purpose of developing,
    you should avoid its use for production environments. BrowserSync is a node package
    that runs an HTTP server that automatically reloads the browser when a change
    on the files that serve is detected. With BrowserSync, you may forget to manually
    refresh your browser every time you make a change.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: BrowserSync 是一个用于开发的资产服务器，您应该避免在生产环境中使用它。BrowserSync 是一个运行 HTTP 服务器的 Node 包，当检测到服务文件的更改时，它会自动重新加载浏览器。使用
    BrowserSync，您可能会忘记每次更改时手动刷新浏览器。
- en: 'You need to install the package before starting to use it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用之前，您需要安装此包：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the package is installed, we can create a new Gulp task to run BrowserSync:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了包，我们就可以创建一个新的 Gulp 任务来运行 BrowserSync：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: On this Gulp task, we will run BrowserSync in the 9000 port and open an additional
    9001 port to allow us to configure the BrowserSync behavior. You can, for example,
    remotely debug your application, which is useful for mobile devices.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 Gulp 任务中，我们将运行 BrowserSync 在 9000 端口，并打开一个额外的 9001 端口以允许我们配置 BrowserSync
    的行为。例如，您可以远程调试您的应用程序，这对于移动设备非常有用。
- en: We configure BrowserSync to serve the files from the `app` and `.tmp` directories.
    If you access `http://localhost:9000/`from your browser, the `app/index.html`
    file will be served as default and will use the script files in the `.tmp` directory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置 BrowserSync 以从 `app` 和 `.tmp` 目录中提供文件。如果您从浏览器访问 `http://localhost:9000/`，则默认提供
    `app/index.html` 文件，并使用 `.tmp` 目录中的脚本文件。
- en: To automatically refresh the browser when a change in the source files is detected,
    we use the `gulp.watch()` method as it accepts a list of files to watch in the
    `node-blob` format and then, we can listen for the `change` event to fire a refresh
    signal to the browser through the `reload()` function that is included in BrowserSync.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在检测到源文件更改时自动刷新浏览器，我们使用 `gulp.watch()` 方法，因为它接受一个以 `node-blob` 格式表示的文件列表，然后我们可以监听
    `change` 事件，通过 BrowserSync 包含的 `reload()` 函数向浏览器发送刷新信号。
- en: 'As the server task depends on the availability of the bundle script file, this
    task should depend on the Browserify task that we earlier created. To indicate
    Gulp that the task has a dependency, we should add a new argument to the `gulp.task()`
    function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器任务依赖于 bundle 脚本文件的存在，这个任务应该依赖于我们之前创建的 Browserify 任务。为了向 Gulp 指示任务有依赖关系，我们应该向
    `gulp.task()` 函数添加一个新参数：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The second argument is a list of strings that the task depends on. In the previous
    snippet, Gulp will ensure that the `browserify` task runs and finishes first before
    executing the `browserify` task function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个字符串列表，表示任务依赖于哪些内容。在前面的代码片段中，Gulp 将确保 `browserify` 任务先运行并完成，然后再执行 `browserify`
    任务函数。
- en: Run server with Express
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Express 运行服务器
- en: Now that we have the assets server working, we need to run our Express server
    with `nodemon`, this package is very similar to BrowserSync; however, it does
    not include the browser features. With nodemon, you can run a node script that
    will watch for any changes on the JavaScript files. When a change is detected,
    the node script will be reloaded automatically.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让资产服务器工作，我们需要使用 `nodemon` 运行我们的 Express 服务器，这个包与 BrowserSync 非常相似；然而，它不包括浏览器功能。使用
    nodemon，你可以运行一个会监视 JavaScript 文件更改的 node 脚本。当检测到更改时，node 脚本将自动重新加载。
- en: 'You need to install the npm package first:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要首先安装 npm 包：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can create the task for nodemon:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为 nodemon 创建任务：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this task, we are informing nodemon to ignore the changes under the `app`
    directory. The reason for this is that the `app` path is already watched by BrowserSync.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们正在通知 nodemon 忽略 `app` 目录下的更改。这样做的原因是 `app` 路径已经被 BrowserSync 监视。
- en: 'Now that we have the server, and the assets are served and reloaded automatically,
    we can merge these two tasks in order to run the project in development mode:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了服务器，并且资产被自动服务和重新加载，我们可以合并这两个任务以在开发模式下运行项目：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A new dependency should be installed, **http-proxy**. This dependency allows
    us to redirect all the API requests to the Express server so that BrowserSync
    does not try to serve these requests:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 应该安装一个新的依赖项，**http-proxy**。这个依赖项允许我们将所有 API 请求重定向到 Express 服务器，这样 BrowserSync
    就不会尝试服务这些请求：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This time, we add the `express` task dependency to the `serve` task. As we are
    now running two servers on different ports, assets on 9000 and API on 8000, we
    add a middleware in BrowserSync to redirect the traffic that starts with `/api/`
    or `/avatar/` to the server located at port 8000.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将 `express` 任务依赖项添加到 `serve` 任务中。因为我们现在在不同的端口上运行两个服务器，资产在 9000 端口，API 在
    8000 端口，我们在 BrowserSync 中添加了一个中间件来将开始于 `/api/` 或 `/avatar/` 的流量重定向到位于 8000 端口的服务器。
- en: Now, when you run the `serve` task from your command line, you will get an amazing
    development environment. Every time a file in the frontend is changed, the browser
    will be reloaded automatically with a new bundle. If a change in the server files
    is detected, the Express server will also be reloaded.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您从命令行运行 `serve` 任务时，您将获得一个令人惊叹的开发环境。每次前端文件更改时，浏览器都会自动使用新的包重新加载。如果检测到服务器文件中的更改，Express
    服务器也会重新加载。
- en: That's a great improvement for your development workflow; you will be more productive
    and forget about manual reloads.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这对您的开发工作流程来说是一个巨大的改进；您将更加高效，并且可以忘记手动重新加载。
- en: Creating a production workflow
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建生产工作流程
- en: The development workflow that we built in the previous sections is an amazing
    improvement for the project; however, we are not finished yet. In this section,
    you will see how to optimize the project that is to be run in the production environments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中构建的开发工作流程对项目来说是一个巨大的改进；然而，我们还没有完成。在本节中，你将看到如何优化要在生产环境中运行的项目。
- en: In this section, you will learn how to minimize your JavaScript and CSS files
    to obfuscate your source code and reduce the time the browser takes to load the
    asset files. The images can also be minified in order to reduce its weight without
    altering its appearance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何最小化你的 JavaScript 和 CSS 文件以混淆源代码并减少浏览器加载资产文件所需的时间。图像也可以被压缩以减少其重量，同时不改变其外观。
- en: Gulp useref
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gulp useref
- en: The `gulp-useref` plugin processes your HTML files to concatenate your JavaScript
    and CSS assets into a single file. Please note that the JavaScript is already
    processed by Browserify, therefore, it is not necessary to process the JavaScript
    files with useref; on the other hand, CSS can be processed here.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulp-useref` 插件会处理你的 HTML 文件，将你的 JavaScript 和 CSS 资产合并成一个单独的文件。请注意，JavaScript
    已经由 Browserify 处理，因此不需要使用 useref 处理 JavaScript 文件；另一方面，CSS 可以在这里处理。'
- en: 'You will need to install the plugin with npm as a development dependency:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用 npm 将插件作为开发依赖项安装：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, to use it, you will need to create a new task. Let''s call it `html`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使用它，你需要创建一个新的任务。让我们称它为 `html`：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `gulp.src('app/*.html')` function grabs all the files with the`.html` extension.
    In our case, only the `index.html` file exists, therefore, it is the only file
    that will be processed. The `useref.assets()` function concatenates all the assets
    that are found in the HTML files and puts them in a stream, the `assets.restore()`
    function will restore the original stream of HTML files that are picked in the
    beginning.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`gulp.src(''app/*.html'')` 函数抓取所有具有 `.html` 扩展名的文件。在我们的例子中，只有 `index.html`
    文件存在，因此它是唯一将被处理的文件。`useref.assets()` 函数将 HTML 文件中找到的所有资产合并到一个流中，`assets.restore()`
    函数将恢复最初选择的 HTML 文件原始流。'
- en: When you call the `useref()` function, the HTML file is parsed in order to replace
    the assets files in a single HTML tag. For example, if you have five CSS files,
    it replaces these five link tags in the HTML file in a single tag that points
    to the concatenated version.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `useref()` 函数时，HTML 文件将被解析以替换单个 HTML 标签中的资产文件。例如，如果你有五个 CSS 文件，它将替换 HTML
    文件中的这五个链接标签，并在一个指向合并版本的标签中。
- en: 'You should indicate the `useref` task how to concatenate the files with special
    tags in the HTML files:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该指示 `useref` 任务如何在 HTML 文件中使用特殊标签来合并文件：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You need add two HTML comments to the code, these comments have a special meaning
    for useref. Its syntax is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在代码中添加两个 HTML 注释，这些注释对我们来说有特殊的意义。其语法如下：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we are processing CSS files, we use `css` as type, and the search path indicates
    where useref will look for the files. If we left this optional parameter blank,
    then it will use the root project path. The last `path` argument indicates where
    the concatenated CSS files will be put.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理 CSS 文件，我们使用 `css` 作为类型，搜索路径表示 useref 将查找文件的位置。如果我们留这个可选参数为空，那么它将使用根项目路径。最后一个
    `path` 参数表示合并的 CSS 文件将被放置的位置。
- en: 'If you run the Gulp `html` task, you will get a concatenated file with all
    your styles under the `dist/css/vendor.css` path. The output HTML file will point
    to this file instead of the development ones:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 Gulp `html` 任务，你将得到一个在 `dist/css/vendor.css` 路径下的所有样式合并的文件。输出 HTML 文件将指向此文件而不是开发版本：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can optimize the output CSS files by minifying them with the `gulp-minify-css`
    plugin. As you may have guessed, you should install the plugin with npm:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `gulp-minify-css` 插件来优化输出 CSS 文件。正如你可能已经猜到的，你应该使用 npm 安装此插件：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then you can use the plugin in your build process, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在构建过程中使用此插件，如下所示：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will minify the concatenated CSS file. However, as `useref` can process
    CSS and JavaScript files, the code can be buggy if a JavaScript build tag is added.
    To prevent errors, you can use the `gulp-if` plugin:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将压缩合并后的 CSS 文件。然而，由于 `useref` 可以处理 CSS 和 JavaScript 文件，如果添加了 JavaScript 构建标签，代码可能会出现错误。为了防止错误，你可以使用
    `gulp-if` 插件：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will also install `uglify` in order to also process the JavaScript files:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将安装 `uglify` 以处理 JavaScript 文件：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With `gulp-if` we test if the file in the stream is a CSS or a JavaScript file
    and then apply the right transformation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gulp-if` 我们测试流中的文件是否是 CSS 或 JavaScript 文件，然后应用正确的转换。
- en: Image Optimization
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片优化
- en: When you are developing your project in the local machine, the assets load pretty
    fast as images and code live in the same computer; however, when you go to the
    production images, they travel through the Internet to your user machine.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本地机器上开发项目时，资源加载相当快，因为图片和代码都存储在同一台计算机上；然而，当你访问生产环境中的图片时，它们将通过互联网传输到用户的机器。
- en: With image optimization, we can compress these images in order to reduce the
    amount of data that your app downloads from the server. With node, you can use
    the `imagemin` package; however, as we are using Gulp, `gulp-imagemin` will do
    the job.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图片优化，我们可以压缩这些图片以减少应用程序从服务器下载的数据量。使用 node，你可以使用 `imagemin` 包；然而，由于我们使用 Gulp，`gulp-imagemin`
    将完成这项工作。
- en: 'As we did earlier, you will need to install the plugin first:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，你需要首先安装插件：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that the plugin is installed, we can use it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件已经安装，我们可以使用它：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It grabs the images from the `app/images` path and applies the `imagemin()`
    process to each image.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它从 `app/images` 路径中获取图片，并对每个图片应用 `imagemin()` 处理。
- en: Fonts
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体
- en: 'Fonts for Bootstrap are located under the `node_modules/` directory. If you
    install other type of fonts, such as Font Awesome, or download a specific fonts;
    they should be copied to the `dist/` directory. You can create a `fonts` task
    to do this, as shown in the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 的字体位于 `node_modules/` 目录下。如果你安装了其他类型的字体，例如 Font Awesome，或者下载了特定的字体；它们应该被复制到
    `dist/` 目录。你可以创建一个 `fonts` 任务来完成这个操作，如下所示：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that you will need to install the `gulp-flatten` plugin; this plugin will
    remove any prefix directory:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要安装 `gulp-flatten` 插件；此插件将删除任何前缀目录：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Bundle JavaScript files for production
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包生产环境的 JavaScript 文件
- en: The `browserify` task that we have is useful for development, it creates sourcemaps
    and the output is not minified. If you want to go to the production, you will
    need to remove the sourcemaps and minimize the output too.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有的 `browserify` 任务对开发很有用，它创建 sourcemaps，输出未压缩。如果你想进入生产环境，你需要移除 sourcemaps
    并最小化输出。
- en: For production environment, we will transform the ECMAScript 6 code into JavaScript
    in order to add support for these browsers that does not support for ECMAScript
    6\. Babel is the best transpiler at the moment to make this transformation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，我们将 ECMAScript 6 代码转换为 JavaScript 以支持不支持 ECMAScript 6 的浏览器。Babel 是目前最好的转换器来完成这个转换。
- en: 'The babelify plugin of Browserify will apply the transformations, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify 的 babelify 插件将应用以下转换：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will need to configure Babel before using the babelify plugin. In Babel
    6, you have to install individual packages for the functions that you want to
    support. For this project, we support ES2015:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 babelify 插件之前，你需要配置 Babel。在 Babel 6 中，你必须为想要支持的函数安装单个包。对于这个项目，我们支持 ES2015：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `.babelrc` file, you should configure the preset:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.babelrc` 文件中，你应该配置预设：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once you have configured Babel properly, we can create the `browserify` task
    for production:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你正确配置了 Babel，我们就可以为生产创建 `browserify` 任务：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This task does not generate sourcemaps and optimize the output.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务不会生成 sourcemaps 并优化输出。
- en: Putting it all together
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: 'You have learned how to optimize several kind of assets: CSS, JavaScript, and
    images. Now let''s put all this together in order to build our application. The
    `serve:dist` task wires all the processes into a pipeline:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了如何优化多种类型的资源：CSS、JavaScript 和图片。现在让我们将这些整合起来，以构建我们的应用程序。`serve:dist` 任务将所有过程连接成一个管道：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To test our pipeline, we can run the `serve:dist` task in the terminal:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的管道，我们可以在终端中运行 `serve:dist` 任务：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice how the tasks are executed by Gulp. After all these processes, the browser
    will automatically open while pointing to the `http://localhost:9000` address,
    running the application in the production environment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意任务是如何由 Gulp 执行的。在所有这些过程之后，浏览器将自动打开，指向 `http://localhost:9000` 地址，在生产环境中运行应用程序。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to use tools to build our Backbone application.
    First, you learned what a task runner is and the most popular choices available
    for Node. Then, we saw how Gulp works and creates tasks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用工具来构建我们的 Backbone 应用程序。首先，你学习了什么是任务运行器以及 Node 中最流行的选择。然后，我们看到了
    Gulp 的工作原理和创建任务的方式。
- en: With Gulp, you can build a development environment and configure it in order
    to apply optimizations to your assets for the production environments. Gulp is
    stream-based, which means that you can grab a bunch of files from a `glob` specification
    and stream these files in order to apply transformations, such as compiling, concatenating,
    transpiling, and so on, as you need.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gulp，你可以构建一个开发环境并对其进行配置，以便为生产环境中的资源应用优化。Gulp 是基于流的，这意味着你可以从 `glob` 规范中抓取一串文件，并将这些文件流式传输以应用所需的转换，例如编译、连接、转译等。
- en: Task runners are amazing tools that allow you to automatize tasks. You can not
    only create development and production workflows, but also tasks for almost anything,
    which you don't want to repeat. For example, a task to make deployments.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 任务运行器是惊人的工具，它允许你自动化任务。你不仅可以创建开发和生产工作流程，还可以为几乎所有你不想重复的事情创建任务。例如，创建部署的任务。
- en: In the next chapter, we will see how to test the Backbone applications. You
    will learn how to isolate and fake dependencies for easy testing, the what and
    how to make Backbone testing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何测试 Backbone 应用程序。你将学习如何隔离和模拟依赖关系以方便测试，以及如何进行 Backbone 测试。
