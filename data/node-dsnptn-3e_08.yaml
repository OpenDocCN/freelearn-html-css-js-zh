- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Structural Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构型设计模式
- en: In this chapter, we will explore some of the most popular structural design
    patterns and discover how they apply to Node.js. Structural design patterns are
    focused on providing ways to realize relationships between entities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些最流行的结构型设计模式，并了解它们如何应用于Node.js。结构型设计模式专注于提供实现实体之间关系的方法。
- en: 'In particular, in this chapter, we will examine the following patterns:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在本章中，我们将检查以下模式：
- en: '**Proxy**: A pattern that allows us to control access to another object'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：一种允许我们控制对另一个对象访问的设计模式'
- en: '**Decorator**: A common pattern to augment the behavior of an existing object
    dynamically'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**：一种常见的动态增强现有对象行为的设计模式'
- en: '**Adapter**: A pattern that allows us to access the functionality of an object
    using a different interface'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：一种允许我们通过不同的接口访问对象功能的设计模式'
- en: Throughout the chapter, we will also explore some interesting concepts such
    as **reactive programming** (**RP**), and we will also spend some time playing
    with LevelDB, a database technology that is commonly adopted in the Node.js ecosystem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将探讨一些有趣的概念，例如**响应式编程**（**RP**），并且我们还将花一些时间与LevelDB进行互动，这是一种在Node.js生态系统中普遍采用的数据库技术。
- en: By the end of this chapter, you will be familiar with several scenarios in which
    structural design patterns can be useful and you will be able to implement them
    effectively in your Node.js applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉几个结构型设计模式可能很有用的场景，并且你将能够有效地在Node.js应用程序中实现它们。
- en: Proxy
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: A **proxy** is an object that controls access to another object, called the
    **subject**. The proxy and the subject have an identical interface, and this allows
    us to swap one for the other transparently; in fact, the alternative name for
    this pattern is **surrogate**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理**是一个控制对另一个对象（称为**主题**）访问的对象。代理和主题具有相同的接口，这使得我们可以透明地互换它们；实际上，这种模式的另一个名称是**代表**。'
- en: 'A proxy intercepts all or some of the operations that are meant to be executed
    on the subject, augmenting or complementing their behavior. *Figure 8.1* shows
    a schematic representation of this pattern:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代理拦截了要执行在主题上的所有或部分操作，增强或补充了它们的行为。*图8.1* 展示了该模式的示意图：
- en: '![](img/B15729_08_01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15729_08_01.png)'
- en: 'Figure 8.1: Proxy pattern schematic'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：代理模式示意图
- en: '*Figure 8.1* shows us how the proxy and the subject have the same interface,
    and how this is transparent to the client, who can use one or the other interchangeably.
    The proxy forwards each operation to the subject, enhancing its behavior with
    additional preprocessing or postprocessing.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.1* 展示了代理和主题具有相同的接口，以及这对于客户端来说是透明的，客户端可以使用其中一个或另一个进行互换。代理将每个操作转发给主题，通过额外的预处理或后处理增强其行为。'
- en: It's important to observe that we are not talking about proxying between classes;
    the Proxy pattern involves wrapping an actual instance of the subject, thus preserving
    its internal state.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们这里讨论的不是类之间的代理；代理模式涉及包装主题的实际实例，从而保留其内部状态。
- en: 'A proxy can be useful in several circumstances, for example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，代理可能很有用，例如：
- en: '**Data validation**: The proxy validates the input before forwarding it to
    the subject'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据验证**：代理在将数据转发给主题之前对其进行验证'
- en: '**Security**: The proxy verifies that the client is authorized to perform the
    operation, and it passes the request to the subject only if the outcome of the
    check is positive'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：代理验证客户端是否有权执行操作，并且只有在检查结果为正时才将请求传递给主题'
- en: '**Caching**: The proxy keeps an internal cache so that the proxied operations
    are executed on the subject only if the data is not yet present in the cache'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：代理保留一个内部缓存，以便只有在数据尚未存在于缓存中时，才在主题上执行代理操作'
- en: '**Lazy initialization**: If creating the subject is expensive, the proxy can
    delay it until it''s really necessary'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟初始化**：如果创建主题对象成本较高，代理可以延迟其创建，直到真正需要时'
- en: '**Logging**: The proxy intercepts the method invocations and the relative parameters,
    recoding them as they happen'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**：代理拦截方法调用及其相关参数，并按发生时的顺序记录它们'
- en: '**Remote objects**: The proxy can take a remote object and make it appear local'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程对象**：代理可以将远程对象转换为本地对象'
- en: There are more Proxy pattern applications, but these should give us an idea
    of its purpose.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多代理模式的应用，但这些应该能让我们了解其目的。
- en: Techniques for implementing proxies
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现代理的技术
- en: When *proxying* an object, we can decide to intercept all of its methods or
    only some of them, while delegating the rest directly to the subject. There are
    several ways in which this can be achieved, and in this section, we will present
    some of them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理一个对象时，我们可以决定拦截它的所有方法或只拦截其中的一些，而将其他方法直接委托给主题。这可以通过几种方式实现，在本节中，我们将介绍其中的一些。
- en: 'We will be working on a simple example, a `StackCalculator` class that looks
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的示例，一个看起来像这样的`StackCalculator`类：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class implements a simplified version of a stack calculator. The idea of
    this calculator is to keep all operands (values) in a stack. When you perform
    an operation, for example a multiplication, the multiplicand and the multiplier
    are extracted from the stack and the result of the multiplication is pushed back
    into the stack. This is not too different from how the calculator application
    on your mobile phone is actually implemented.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此类实现了一个简化版的堆栈计算器。这个计算器的想法是将所有操作数（值）都保存在堆栈中。当你执行一个操作，例如乘法，乘数和被乘数将被从堆栈中提取出来，乘法的结果将被推回堆栈。这与你的手机上实际实现的计算器应用的方式并没有太大的不同。
- en: 'Here''s an example of how we might use `StackCalculator` to perform some multiplications
    and divisions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，说明我们如何使用`StackCalculator`执行一些乘法和除法操作：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are also some utility methods such as `peekValue()`, which allows us to
    peek the value at the top of the stack (the last value inserted or the result
    of the last operation), and `clear()`, which allows us to reset the stack.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些实用方法，例如`peekValue()`，它允许我们查看堆栈顶部的值（最后插入的值或最后操作的运算结果），以及`clear()`，它允许我们重置堆栈。
- en: 'Fun fact: In JavaScript, when you perform a division by 0, you get back a mysterious
    value called `Infinity`. In many other programming languages dividing by 0 is
    an illegal operation that results in the program panicking or throwing a runtime
    exception.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实：在JavaScript中，当你执行除以零的操作时，你会得到一个神秘的值，称为`Infinity`。在许多其他编程语言中，除以零是一个非法操作，会导致程序恐慌或抛出运行时异常。
- en: 'Our task in the next few sections will be to leverage the Proxy pattern to
    enhance a `StackCalculator` instance by providing a more conservative behavior
    for division by 0: rather than returning `Infinity`, we will throw an explicit
    error.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们的任务将利用代理模式通过提供对除以零的更保守行为来增强`StackCalculator`实例：而不是返回`Infinity`，我们将抛出一个显式的错误。
- en: Object composition
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象组合
- en: Composition is a technique whereby an object is combined with another object
    for the purpose of extending or using its functionality. In the specific case
    of the Proxy pattern, a new object with the same interface as the subject is created,
    and a reference to the subject is stored internally in the proxy in the form of
    an instance variable or a closure variable. The subject can be injected from the
    client at creation time or created by the proxy itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一种技术，通过将一个对象与另一个对象组合，以扩展或使用其功能。在代理模式的具体情况下，创建了一个与主题具有相同接口的新对象，并在代理内部以实例变量或闭包变量的形式存储主题的引用。主题可以在创建时从客户端注入，或者由代理本身创建。
- en: 'The following example implements a safe calculator using object composition:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例实现了一个使用对象组合的安全计算器：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `safeCalculator` object is a proxy for the original `calculator` instance.
    By invoking `multiply()` on `safeCalculator`, we will end up calling the same
    method on `calculator`. The same goes for `divide()`, but in this case we can
    see that, if we try to divide by zero, we will get different outcomes depending
    on whether we perform the division on the subject or on the proxy.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`safeCalculator`对象是原始`calculator`实例的代理。通过在`safeCalculator`上调用`multiply()`，我们最终会在`calculator`上调用相同的方法。对于`divide()`也是如此，但在这个情况下，我们可以看到，如果我们尝试除以零，根据我们在主题或代理上执行除法，我们将会得到不同的结果。'
- en: To implement this proxy using composition, we had to intercept the methods that
    we were interested in manipulating (`divide()`), while simply delegating the rest
    of them to the subject (`putValue()`, `getValue()`, `peekValue()`, `clear()`,
    and `multiply()`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用组合实现这个代理，我们必须拦截我们感兴趣要操作的方法（`divide()`），而将其他方法简单地委托给主题（`putValue()`、`getValue()`、`peekValue()`、`clear()`和`multiply()`）。
- en: Note that the calculator state (the values in the stack) is still maintained
    by the `calculator` instance; `safeCalculator` will only invoke methods on `calculator`
    to read or mutate the state as needed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，计算器状态（栈中的值）仍然由 `calculator` 实例维护；`safeCalculator` 将只调用 `calculator` 上的方法来读取或按需突变状态。
- en: 'An alternative implementation of the proxy presented in the preceding code
    fragment might just use an object literal and a factory function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中展示的代理的另一种实现可能只是使用一个对象字面量和工厂函数：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This implementation is simpler and more concise than the class-based one, but,
    once again, it forces us to delegate all the methods to the subject explicitly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现比基于类的实现更简单、更简洁，但，再次强调，它迫使我们显式地将所有方法委托给主题。
- en: Having to delegate many methods for complex classes can be very tedious and
    might make it harder to implement these techniques. One way to create a proxy
    that delegates most of its methods is to use a library that generates all the
    methods for us, such as `delegates` ([nodejsdp.link/delegates](http://nodejsdp.link/delegates)).
    A more modern and native alternative is to use the `Proxy` object, which we will
    discuss later in this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的类，需要委托许多方法可能会非常繁琐，并可能使实现这些技术变得更难。创建一个委托大多数方法的代理的一种方法是通过使用为我们生成所有方法的库，例如
    `delegates` ([nodejsdp.link/delegates](http://nodejsdp.link/delegates))。一个更现代、更原生的方法是使用
    `Proxy` 对象，我们将在本章后面讨论。
- en: Object augmentation
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象增强
- en: '**Object augmentation** (or **monkey patching**) is probably the simplest and
    most common way of proxying just a few methods of an object. It involves modifying
    the subject directly by replacing a method with its proxied implementation.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象增强**（或**猴子补丁**）可能是代理对象仅几个方法的简单且最常见的方式。它涉及通过替换方法及其代理实现来直接修改主题。'
- en: 'In the context of our calculator example, this could be done as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计算器示例的上下文中，可以这样操作：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This technique is definitely convenient when we need to proxy only one or a
    few methods. Did you notice that we didn't have to reimplement the `multiply()`
    method and all the other delegated methods here?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只需要代理一个或几个方法时，这种技术肯定很方便。你注意到我们没有在这里重新实现 `multiply()` 方法和其他所有委托方法了吗？
- en: Unfortunately, simplicity comes at the cost of having to mutate the `subject`
    object directly, which can be dangerous.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，简单是以直接突变 `subject` 对象为代价的，这可能是危险的。
- en: Mutations should be avoided at all costs when the subject is shared with other
    parts of the codebase. In fact, "monkey patching" the subject might create undesirable
    side effects that affect other components of our application. Use this technique
    only when the subject exists in a controlled context or in a private scope. If
    you want to appreciate why "monkey patching" is a dangerous practice, you could
    try to invoke a division by zero in the original `calculator` instance. If you
    do so, you will see that the original instance will now throw an error rather
    than returning `Infinity`. The original behavior has been altered, and this might
    have unexpected effects on other parts of the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当主题与其他代码库的部分共享时，应尽量避免所有突变。实际上，“猴子补丁”主题可能会产生不希望看到的副作用，影响我们应用程序的其他组件。仅在主题存在于受控上下文或私有作用域中时使用此技术。如果你想了解为什么“猴子补丁”是一种危险的做法，你可以尝试在原始的
    `calculator` 实例中调用除以零。如果你这样做，你会看到原始实例现在会抛出一个错误，而不是返回 `Infinity`。原始行为已被改变，这可能会对应用程序的其他部分产生意外的影响。
- en: In the next section, we will explore the built-in `Proxy` object, which is a
    powerful alternative for implementing the Proxy pattern and more.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨内置的 `Proxy` 对象，它是实现代理模式及其他功能的强大替代方案。
- en: The built-in Proxy object
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置的代理对象
- en: The ES2015 specification introduced a native way to create powerful proxy objects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 规范引入了一种创建强大代理对象的原生方法。
- en: 'We are talking about the ES2015 `Proxy` object, which consists of a `Proxy`
    constructor that accepts a `target` and a `handler` as arguments:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论的是 ES2015 的 `Proxy` 对象，它由一个接受 `target` 和 `handler` 作为参数的 `Proxy` 构造函数组成：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `target` represents the object on which the proxy is applied (the **subject**
    for our canonical definition), while `handler` is a special object that defines
    the behavior of the proxy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`target` 代表代理应用到的对象（我们规范定义中的**主题**），而 `handler` 是一个特殊对象，它定义了代理的行为。
- en: The `handler` object contains a series of optional methods with predefined names
    called **trap methods** (for example, `apply`, `get`, `set`, and `has`) that are
    automatically called when the corresponding operations are performed on the proxy
    instance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler` 对象包含一系列具有预定义名称的可选方法，称为 **trap 方法**（例如，`apply`、`get`、`set` 和 `has`），当在代理实例上执行相应的操作时，这些方法会自动被调用。'
- en: 'To better understand how this API works, let''s see how we can use the `Proxy`
    object to implement our safe calculator proxy:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个 API 的工作原理，让我们看看如何使用 `Proxy` 对象来实现我们的安全计算器代理：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this implementation of the safe calculator proxy using the `Proxy` object,
    we adopted the `get` trap to intercept access to properties and methods of the
    original object, including calls to the `divide()` method. When access to `divide()`
    is intercepted, the proxy returns a modified version of the function that implements
    the additional logic to check for possible divisions by zero. Note that we can
    simply return all other methods and properties unchanged by using `target[property]`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `Proxy` 对象实现安全计算器代理的这个实现中，我们采用了 `get` trap 来拦截对原始对象属性和方法（包括对 `divide()`
    方法的调用）的访问。当拦截到对 `divide()` 的访问时，代理返回一个修改后的函数版本，该版本实现了检查可能除以零的额外逻辑。请注意，我们可以通过使用
    `target[property]` 简单地返回所有其他方法和不改变属性。
- en: Finally, it is important to mention that the `Proxy` object inherits the prototype
    of the subject, therefore running `safeCalculator instanceof StackCalculator`
    will return `true`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要提到 `Proxy` 对象继承了主题的原型，因此运行 `safeCalculator instanceof StackCalculator`
    将返回 `true`。
- en: With this example, it should be clear that the `Proxy` object allows us to avoid
    mutating the subject while giving us an easy way to proxy only the bits that we
    need to enhance, without having to explicitly delegate all the other properties
    and methods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，应该很清楚 `Proxy` 对象允许我们在不修改主题的情况下，以简单的方式代理我们需要的部分，而不必明确地委派所有其他属性和方法。
- en: Additional capabilities and limitations of the Proxy object
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Proxy` 对象的附加功能和限制'
- en: The `Proxy` object is a feature deeply integrated into the JavaScript language
    itself, which enables developers to intercept and customize many operations that
    can be performed on objects. This characteristic opens up new and interesting
    scenarios that were not easily achievable before, such as *meta-programming*,
    *operator overloading*, and *object virtualization*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Proxy` 对象是 JavaScript 语言本身深度集成的一个特性，它使开发者能够拦截和自定义可以在对象上执行的多项操作。这一特性开辟了以前难以实现的新颖有趣的场景，例如
    *元编程*、*操作符重载* 和 *对象虚拟化*。'
- en: 'Let''s see another example to clarify this concept:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子来澄清这个概念：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we are creating a virtual array that contains all even numbers.
    It can be used as a regular array, which means we can access items in the array
    with the regular array syntax (for example, `evenNumbers[7]`), or check the existence
    of an element in the array with the `in` operator (for example, `2 in evenNumbers`).
    The array is considered *virtual* because we never store data in it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个包含所有偶数的虚拟数组。它可以作为一个常规数组使用，这意味着我们可以使用常规数组语法（例如，`evenNumbers[7]`）访问数组中的项目，或者使用
    `in` 操作符（例如，`2 in evenNumbers`）检查数组中是否存在元素。这个数组被认为是 *虚拟的*，因为我们从未在其中存储数据。
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Looking at the implementation, this proxy uses an empty array as the target
    and then defines the `get` and `has` traps in the handler:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下实现，这个代理使用一个空数组作为目标，然后在处理器中定义了 `get` 和 `has` traps：
- en: The `get` trap intercepts access to the array elements, returning the even number
    for the given index
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get` trap 拦截对数组元素的访问，返回给定索引的偶数'
- en: The `has` trap instead intercepts the usage of the `in` operator and checks
    whether the given number is even or not
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，`has` trap 拦截 `in` 操作符的使用，并检查给定的数字是否为偶数
- en: The `Proxy` object supports several other interesting traps such as `set`, `delete`,
    and `construct`, and allows us to create proxies that can be revoked on demand,
    disabling all the traps and restoring the original behavior of the `target` object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Proxy` 对象支持其他几个有趣的 traps，如 `set`、`delete` 和 `construct`，并允许我们创建可以在需要时撤销的代理，禁用所有
    traps 并恢复 `target` 对象的原始行为。'
- en: Analyzing all these features goes beyond the scope of this chapter; what is
    important here is understanding that the `Proxy` object provides a powerful foundation
    for implementing the Proxy design pattern.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 分析所有这些功能超出了本章的范围；这里重要的是理解 `Proxy` 对象为实施代理设计模式提供了一个强大的基础。
- en: If you are curious to discover all the capabilities and trap methods offered
    by the Proxy object, you can read more in the related MDN article at [nodejsdp.link/mdn-proxy](http://nodejsdp.link/mdn-proxy).
    Another good source is this detailed article from Google at [nodejsdp.link/intro-proxy](http://nodejsdp.link/intro-proxy).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇想了解 `Proxy` 对象提供的所有功能和陷阱方法，你可以在相关的 MDN 文章中了解更多信息，链接为 [nodejsdp.link/mdn-proxy](http://nodejsdp.link/mdn-proxy)。另一个好的来源是
    Google 的这篇详细文章，链接为 [nodejsdp.link/intro-proxy](http://nodejsdp.link/intro-proxy)。
- en: 'While the `Proxy` object is a powerful functionality of the JavaScript language,
    it suffers from a very important limitation: the `Proxy` object cannot be fully
    *transpiled* or *polyfilled*. This is because some of the `Proxy` object traps
    can be implemented only at the runtime level and cannot be simply rewritten in
    plain JavaScript. This is something to be aware of if you are working with old
    browsers or old versions of Node.js that don''t support the `Proxy` object directly.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Proxy` 对象是 JavaScript 语言的强大功能，但它存在一个非常重要的限制：`Proxy` 对象不能完全 *transpiled*
    或 *polyfilled*。这是因为 `Proxy` 对象的一些陷阱只能在运行时级别实现，不能简单地用纯 JavaScript 重新编写。如果你在使用不支持
    `Proxy` 对象的老旧浏览器或老旧版本的 Node.js，这一点需要特别注意。
- en: '**Transpilation**: Short for *transcompilation*. It indicates the action of
    compiling source code by translating it from one source programming language to
    another. In the case of JavaScript, this technique is used to convert a program
    using new capabilities of the language into an equivalent program that can also
    run on older runtimes that do not support these new capabilities.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**Transpilation**：即 *transcompilation* 的简称。它表示通过将源代码从一种源编程语言翻译成另一种编程语言来编译源代码的行为。在
    JavaScript 的情况下，这种技术用于将使用语言新功能的程序转换为可以在不支持这些新功能的较老运行时上运行的等效程序。'
- en: '**Polyfill**: Code that provides an implementation for a standard API in plain
    JavaScript and that can be imported in environments where this API is not available
    (generally older browsers or runtimes). `core-js` ([nodejsdp.link/corejs](http://nodejsdp.link/corejs))
    is one of the most complete polyfill libraries for JavaScript.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**Polyfill**：提供标准 API 实现的代码，可以在没有该 API 的环境中（通常为老旧浏览器或运行时）导入。`core-js` ([nodejsdp.link/corejs](http://nodejsdp.link/corejs))
    是 JavaScript 最完整的 polyfill 库之一。'
- en: A comparison of the different proxying techniques
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同代理技术的比较
- en: Composition can be considered a simple and *safe* way of creating a proxy because
    it leaves the subject untouched without mutating its original behavior. Its only
    drawback is that we have to manually delegate all the methods, even if we want
    to proxy only one of them. Also, we might have to delegate access to the properties
    of the subject.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 组合可以被认为是一种简单且 *安全* 的创建代理的方式，因为它在不改变原始行为的情况下保留了主题。它的唯一缺点是我们必须手动委托所有方法，即使我们只想代理其中之一。此外，我们可能还需要委托对主题属性的访问。
- en: Object properties can be delegated using `Object.defineProperty()`. Find out
    more at [nodejsdp.link/define-prop](http://nodejsdp.link/define-prop).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `Object.defineProperty()` 来委托对象属性。更多信息请参阅 [nodejsdp.link/define-prop](http://nodejsdp.link/define-prop)。
- en: Object augmentation, on the other hand, modifies the subject, which might not
    always be ideal, but it does not suffer from the various inconveniences related
    to delegation. For this reason, between these two approaches, object augmentation
    is generally the preferred technique in all those circumstances in which modifying
    the subject is an option.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对象增强会修改主题，这不一定总是理想的，但它不遭受与委托相关的各种不便。因此，在这两种方法之间，当修改主题是可选项时，对象增强通常是在所有这些情况下首选的技术。
- en: However, there is at least one situation where composition is almost necessary;
    this is when we want to control the initialization of the subject, for example,
    to create it only when needed (*lazy initialization*).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，至少有一种情况下组合几乎是必要的；这就是当我们想要控制主题的初始化时，例如，只在需要时创建它（*延迟初始化*）。
- en: Finally, the `Proxy` object is the go-to approach if you need to intercept function
    calls or have different types of access to object attributes, even dynamic ones.
    The `Proxy` object provides an advanced level of access control that is simply
    not available with the other techniques. For example, the `Proxy` object allows
    us to intercept the deletion of a key in an object and to perform property existence
    checks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你需要拦截函数调用或对对象属性有不同类型的访问，即使是动态的，`Proxy`对象是首选方法。`Proxy`对象提供了一种高级的访问控制，这是其他技术所无法提供的。例如，`Proxy`对象允许我们拦截对象中键的删除，并执行属性存在检查。
- en: Once again, it's worth highlighting that the `Proxy` object does not mutate
    the subject, so it can be safely used in contexts where the subject is shared
    between different components of the application. We also saw that with the `Proxy`
    object, we can easily perform delegation of all the methods and attributes that
    we want to leave unchanged.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`Proxy`对象不会修改主题，因此可以在主题在应用程序的不同组件之间共享的上下文中安全使用。我们还看到，使用`Proxy`对象，我们可以轻松地执行所有我们想要保持不变的属性和方法的重定向。
- en: In the next section, we present a more realistic example leveraging the Proxy
    pattern and use it to compare the different techniques we have discussed so far
    for implementing this pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示一个更现实的示例，利用代理模式，并使用它来比较我们迄今为止讨论的不同技术，以实现此模式。
- en: Creating a logging Writable stream
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建日志可写流
- en: 'To see the Proxy pattern applied to a real example, we will now build an object
    that acts as a proxy to a Writable stream, which intercepts all the calls to the
    `write()` method and logs a message every time this happens. We will use the `Proxy`
    object to implement our proxy. Let''s write our code in a file called `logging-writable.js`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到代理模式在实际示例中的应用，我们现在将构建一个作为可写流代理的对象，它拦截所有对`write()`方法的调用，并在每次发生这种情况时记录一条消息。我们将使用`Proxy`对象来实现我们的代理。让我们将我们的代码写入一个名为`logging-writable.js`的文件中：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we created a factory that returns a proxied version
    of the `writable` object passed as an argument. Let''s see what the main points
    of the implementation are:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个工厂，它返回作为参数传递的`writable`对象的代理版本。让我们看看实现的主要要点：
- en: We create and return a proxy for the original `writable` object using the ES2015
    `Proxy` constructor.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用ES2015的`Proxy`构造函数创建并返回原始`writable`对象的代理。
- en: We use the `get` trap to intercept access to the object properties.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`get`陷阱来拦截对对象属性的访问。
- en: We check whether the property accessed is the `write` method. If that is the
    case, we return a function to proxy the original behavior.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查访问的属性是否是`write`方法。如果是这样，我们返回一个函数来代理原始行为。
- en: 'The proxy implementation logic here is simple: we extract the current `chunk`
    from the list of arguments passed to the original function, we log the content
    of the chunk, and finally, we invoke the original method with the given list of arguments.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里代理实现逻辑很简单：我们从传递给原始函数的参数列表中提取当前的`chunk`，记录块的内容，最后，我们使用给定的参数列表调用原始方法。
- en: We return unchanged any other property.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回任何其他未更改的属性。
- en: 'We can now use this newly created function and test our proxy implementation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个新创建的函数并测试我们的代理实现：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The proxy did not change the original interface of the stream or its external
    behavior, but if we run the preceding code, we will now see that every chunk that
    is written into the `writableProxy` stream is transparently logged to the console.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代理没有改变流的原生接口或其外部行为，但如果我们运行前面的代码，现在我们会看到写入`writableProxy`流中的每个数据块都会透明地记录到控制台。
- en: Change observer with Proxy
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代理的变更观察者
- en: The **Change Observer pattern** is a design pattern in which an object (the
    subject) notifies one or more observers of any state changes, so that they can
    "react" to changes as soon as they happen.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**变更观察者模式**是一种设计模式，其中对象（主题）通知一个或多个观察者任何状态变化，以便它们可以“反应”变化的发生。'
- en: Although very similar, the Change Observer pattern should not be confused with
    the Observer pattern discussed in *Chapter 3*, *Callbacks and Events*. The Change
    Observer pattern focuses on allowing the detection of property changes, while
    the Observer pattern is a more generic pattern that adopts an event emitter to
    propagate information about events happening in the system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非常相似，但变更观察者模式不应与第3章中讨论的观察者模式混淆，即*回调和事件*。变更观察者模式专注于允许检测属性变化，而观察者模式是一个更通用的模式，它采用事件发射器来传播关于系统中发生的事件的信息。
- en: 'Proxies turn out to be quite an effective tool to create observable objects.
    Let''s see a possible implementation with `create-observable.js`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代理证明是创建可观察对象的有效工具。让我们看看`create-observable.js`中可能的实现：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous code, `createObservable()` accepts a `target` object (the object
    to observe for changes) and an `observer` (a function to invoke every time a change
    is detected).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`createObservable()`接受一个`target`对象（要观察其变化的对象）和一个`observer`（每次检测到变化时调用的函数）。
- en: Here, we create the `observable` instance through an ES2015 Proxy. The proxy
    implements the `set` trap, which is triggered every time a property is set. The
    implementation compares the current value with the new one and, if they are different,
    the target object is mutated, and the observer gets notified. When the observer
    is invoked, we pass an object literal that contains information related to the change
    (the name of the property, the previous value, and the current value).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过ES2015 Proxy创建`observable`实例。代理实现了`set`陷阱，每次设置属性时都会触发。实现比较当前值与新值，如果它们不同，目标对象将被修改，并且观察者会收到通知。当观察者被调用时，我们传递一个包含与变化相关的信息的对象字面量（属性的名称、旧值和当前值）。
- en: This is a simplified implementation of the Change Observer pattern. More advanced
    implementations support multiple observers and use more traps to catch other types
    of mutation, such as field deletions or changes of prototype. Moreover, our implementation
    does not recursively create proxies for nested objects or arrays—a more advanced
    implementation takes care of these cases as well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对变更观察者模式的一个简化实现。更高级的实现支持多个观察者，并使用更多的陷阱来捕获其他类型的突变，例如字段删除或原型更改。此外，我们的实现不会递归地创建嵌套对象或数组的代理——更高级的实现也会处理这些情况。
- en: 'Let''s see now how we can take advantage of observable objects with a trivial
    invoice application where the invoice total is updated automatically based on
    observed changes in the various fields of the invoice:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何利用可观察对象，在一个简单的发票应用程序中，发票总金额会根据观察到的发票各个字段的变化自动更新：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the previous example, an invoice is composed of a `subtotal` value, a `discount`
    value, and a `tax` value. The total amount can be calculated from these three
    values. Let''s discuss the implementation in greater detail:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，发票由`subtotal`值、`discount`值和`tax`值组成。总金额可以从这三个值中计算得出。让我们更详细地讨论实现：
- en: We declare a function that calculates the total for a given invoice, then we
    create an `invoice` object and a value to hold the `total` for it.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个函数来计算给定发票的总金额，然后我们创建一个`invoice`对象和一个用于存储其`total`值的变量。
- en: Here we create an observable version of the `invoice` object. Every time there
    is a change in the original invoice object, we recalculate the total and we also
    print some logs to keep track of the changes.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`invoice`对象的观察者版本。每当原始发票对象发生变化时，我们都会重新计算总金额，并且也会打印一些日志以跟踪变化。
- en: Finally, we apply some changes to the observable invoice. Every time we mutate
    the `obsInvoice` object the observer function is triggered, the total gets updated,
    and some logs are printed on the screen.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们对可观察的发票应用一些更改。每次我们修改`obsInvoice`对象时，观察者函数都会被触发，总金额会更新，并且会在屏幕上打印一些日志。
- en: 'If we run this example, we will see the following output in the console:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个示例，我们将在控制台看到以下输出：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we could make the total calculation logic arbitrarily complicated,
    for instance, by introducing new fields in the computation (shipping costs, other
    taxes, and so on). In this case, it will be fairly trivial to introduce the new
    fields in the `invoice` object and update the `calculateTotal()` function. Once
    we do that, every change to the new properties will be observed and the `total`
    will be kept up to date with every change.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以使总计算逻辑变得任意复杂，例如，通过在计算中引入新的字段（运费、其他税费等）。在这种情况下，将新字段引入 `invoice` 对象并更新
    `calculateTotal()` 函数将相当简单。一旦我们这样做，新属性的任何变化都将被观察，并且 `total` 将随着每个变化而保持更新。
- en: Observables are the cornerstone of **reactive programming** (**RP**) and **functional
    reactive programming** (**FRP**). If you are curious to know more about these
    styles of programming check out the *Reactive Manifesto*, at [nodejsdp.link/reactive-manifesto](http://nodejsdp.link/reactive-manifesto).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察者是 **响应式编程**（**RP**）和 **函数式响应式编程**（**FRP**）的基石。如果你对这些编程风格感兴趣，可以查看 *响应式宣言*，在
    [nodejsdp.link/reactive-manifesto](http://nodejsdp.link/reactive-manifesto)。
- en: In the wild
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: 'The Proxy pattern and more specifically the Change Observer pattern are widely
    adopted patterns, which can be found on backend projects and libraries as well
    as in the frontend world. Some popular projects that take advantage of these patterns
    include the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式和更具体的变更观察者模式是广泛采用的模式，可以在后端项目和库以及前端世界中找到。一些利用这些模式的项目包括以下内容：
- en: LoopBack ([nodejsdp.link/loopback](http://nodejsdp.link/loopback)) is a popular
    Node.js web framework that uses the Proxy pattern to provide the capability to
    intercept and enhance method calls on controllers. This capability can be used
    to build custom validation or authentication mechanisms.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LoopBack ([nodejsdp.link/loopback](http://nodejsdp.link/loopback)) 是一个流行的 Node.js
    网络框架，它使用代理模式提供拦截和增强控制器上方法调用的功能。这种功能可以用来构建自定义验证或认证机制。
- en: Version 3 of Vue.js ([nodejsdp.link/vue](http://nodejsdp.link/vue)), a very
    popular JavaScript reactive UI framework, has reimplemented observable properties
    using the Proxy pattern with the `Proxy` object.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js 3 版本（[nodejsdp.link/vue](http://nodejsdp.link/vue)），一个非常流行的 JavaScript
    响应式 UI 框架，使用代理模式通过 `Proxy` 对象重新实现了可观察属性。
- en: MobX ([nodejsdp.link/mobx](http://nodejsdp.link/mobx)) is a famous reactive
    state management library commonly used in frontend applications in combination
    with React or Vue.js. Like Vue.js, MobX implements reactive observables using
    the `Proxy` object.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobX ([nodejsdp.link/mobx](http://nodejsdp.link/mobx)) 是一个著名的响应式状态管理库，通常与 React
    或 Vue.js 结合使用在前端应用程序中。与 Vue.js 类似，MobX 使用 `Proxy` 对象实现响应式可观察对象。
- en: Decorator
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorator is a structural design pattern that consists in dynamically augmenting
    the behavior of an existing object. It's different from classical inheritance,
    because the behavior is not added to all the objects of the same class, but only
    to the instances that are explicitly decorated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种结构型设计模式，它通过动态地增强现有对象的行为来实现。与经典继承不同，因为行为不是添加到同一类的所有对象上，而是仅添加到显式装饰的实例上。
- en: 'Implementation-wise, it is very similar to the Proxy pattern, but instead of
    enhancing or modifying the behavior of the existing interface of an object, it
    augments it with new functionalities, as described in *Figure 8.2*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现上，它与代理模式非常相似，但不是增强或修改对象现有接口的行为，而是通过新的功能来增强它，如 *图 8.2* 所述：
- en: '![A screenshot of a cell phone  Description automatically generated](img/B15729_08_02.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕截图  自动生成的描述](img/B15729_08_02.png)'
- en: 'Figure 8.2: Decorator pattern schematic'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：装饰器模式示意图
- en: In *Figure 8.2*, the `Decorator` object is extending the `Component` object
    by adding the `methodC()` operation. The existing methods are usually delegated
    to the decorated object without further processing but, in some cases, they might
    also be intercepted and augmented with extra behaviors.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8.2* 中，`Decorator` 对象通过添加 `methodC()` 操作来扩展 `Component` 对象。现有的方法通常被委派给装饰对象，而不进行进一步处理，但在某些情况下，它们也可能被拦截并添加额外的行为。
- en: Techniques for implementing decorators
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现装饰器的技术
- en: Although proxy and decorator are conceptually two different patterns with different
    intents, they practically share the same implementation strategies. We will review
    them shortly. This time we want to use the Decorator pattern to be able to take
    an instance of our `StackCalculator` class and "decorate it" so that it also exposes
    a new method called `add()`, which we can use to perform additions between two
    numbers. We will also use the decorator to intercept all the calls to the `divide()`
    method and implement the same division-by-zero check that we already saw in our
    `SafeCalculator` example.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代理和装饰器在概念上是两种不同的模式，具有不同的意图，但它们实际上共享相同的实现策略。我们很快就会回顾它们。这次我们想使用装饰器模式，以便能够“装饰”我们的
    `StackCalculator` 类的实例，使其也暴露一个新的方法 `add()`，我们可以使用它来执行两个数字之间的加法操作。我们还将使用装饰器来拦截对
    `divide()` 方法的所有调用，并实现我们在 `SafeCalculator` 示例中已经看到的相同的除以零检查。
- en: Composition
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合
- en: 'Using composition, the decorated component is wrapped around a new object that
    usually inherits from it. The decorator in this case simply needs to define the
    new methods, while delegating the existing ones to the original component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合，装饰的组件被包裹在一个新对象周围，这个新对象通常继承自它。在这种情况下，装饰器只需定义新方法，并将现有方法委托给原始组件：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you remember our composition implementation for the Proxy pattern, you can
    probably see that the code here looks quite similar.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们为代理模式实现的组合实现，你可能看到这里的代码看起来相当相似。
- en: We created the new `add()` method and enhanced the behavior of the original
    `divide()` method (effectively replicating the feature we saw in the previous
    `SafeCalculator` example). Finally, we delegated the `putValue()`, `getValue()`,
    `peekValue()`, `clear()`, and `multiply()` methods to the original subject.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了新的 `add()` 方法，并增强了原始的 `divide()` 方法的功能（有效地复制了我们在之前的 `SafeCalculator` 示例中看到的特性）。最后，我们将
    `putValue()`、`getValue()`、`peekValue()`、`clear()` 和 `multiply()` 方法委托给原始主题。
- en: Object augmentation
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象增强
- en: '**Object decoration** can also be achieved by simply attaching new methods
    directly to the decorated object (monkey patching), as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象装饰**也可以通过直接将新方法附加到装饰对象（猴子补丁）来实现，如下所示：'
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that in this example, `calculator` and `enhancedCalculator` reference the
    same object (`calculator == enhancedCalculator`). This is because `patchCalculator()`
    is mutating the original `calculator` object and then returning it. You can confirm
    this by invoking `calculator.add()` or `calculator.divide()`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，`calculator` 和 `enhancedCalculator` 引用同一个对象（`calculator == enhancedCalculator`）。这是因为
    `patchCalculator()` 正在修改原始的 `calculator` 对象，然后返回它。你可以通过调用 `calculator.add()` 或
    `calculator.divide()` 来确认这一点。
- en: Decorating with the Proxy object
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用代理对象进行装饰
- en: 'It''s possible to implement object decoration by using the `Proxy` object.
    A generic example might look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `Proxy` 对象来实现对象装饰。一个通用的例子可能如下所示：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we were to compare these different implementations, the same caveats discussed
    during the analysis of the Proxy pattern would also apply for the decorator. Let's
    focus instead on practicing the pattern with a real-life example!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要比较这些不同的实现，分析代理模式时讨论的相同注意事项也适用于装饰器。让我们专注于通过一个现实生活中的例子来练习这个模式！
- en: Decorating a LevelUP database
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰 LevelUP 数据库
- en: Before we start coding the next example, let's say a few words about **LevelUP**,
    the module that we are now going to work with.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写下一个示例之前，让我们简单地说几句关于 **LevelUP**，我们现在将要与之工作的模块。
- en: Introducing LevelUP and LevelDB
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍 LevelUP 和 LevelDB
- en: '**LevelUP** ([nodejsdp.link/levelup](http://nodejsdp.link/levelup)) is a Node.js
    wrapper around Google''s **LevelDB**, a key-value store originally built to implement
    IndexedDB in the Chrome browser, but it''s much more than that. LevelDB has been
    defined as the "Node.js of databases" because of its minimalism and extensibility.
    Like Node.js, LevelDB provides blazingly fast performance and only the most basic
    set of features, allowing developers to build any kind of database on top of it.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**LevelUP** ([nodejsdp.link/levelup](http://nodejsdp.link/levelup)) 是围绕 Google
    的 **LevelDB** 的 Node.js 包装器，LevelDB 是最初为在 Chrome 浏览器中实现 IndexedDB 而构建的键值存储，但它远不止于此。由于它的极简主义和可扩展性，LevelDB
    被定义为“Node.js 的数据库”。像 Node.js 一样，LevelDB 提供了极快的性能和最基本的功能集，允许开发者在其之上构建任何类型的数据库。'
- en: The Node.js community, and in this case Rod Vagg, did not miss the chance to
    bring the power of this database into the Node.js world by creating LevelUP. Born
    as a wrapper for LevelDB, it then evolved to support several kinds of backends,
    from in-memory stores, to other NoSQL databases such as Riak and Redis, to web
    storage engines such as IndexedDB and localStorage, allowing us to use the same
    API on both the server and the client, opening up some really interesting scenarios.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js社区，在这个例子中是Rod Vagg，没有错过将这个数据库的力量带入Node.js世界的机会，创建了LevelUP。它最初作为LevelDB的包装器，后来发展到支持多种后端，从内存存储到其他NoSQL数据库，如Riak和Redis，再到Web存储引擎，如IndexedDB和localStorage，允许我们在服务器和客户端上使用相同的API，开辟了一些非常有趣的场景。
- en: Today, there is a vast ecosystem around LevelUP made of plugins and modules
    that extend the tiny core to implement features such as replication, secondary
    indexes, live updates, query engines, and more. Complete databases were also built
    on top of LevelUP, including CouchDB clones such as PouchDB ([nodejsdp.link/pouchdb](http://nodejsdp.link/pouchdb)),
    and even a graph database, LevelGraph ([nodejsdp.link/levelgraph](http://nodejsdp.link/levelgraph)),
    which can work both on Node.js and the browser!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，围绕LevelUP有一个庞大的生态系统，由插件和模块组成，它们扩展了核心以实现复制、二级索引、实时更新、查询引擎等功能。在LevelUP之上还构建了完整的数据库，包括CouchDB克隆PouchDB（[nodejsdp.link/pouchdb](http://nodejsdp.link/pouchdb)），甚至一个图数据库LevelGraph（[nodejsdp.link/levelgraph](http://nodejsdp.link/levelgraph)），它可以在Node.js和浏览器上运行！
- en: Find out more about the LevelUP ecosystem at [nodejsdp.link/awesome-level](http://nodejsdp.link/awesome-level).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在[nodejsdp.link/awesome-level](http://nodejsdp.link/awesome-level)了解更多关于LevelUP生态系统的信息。
- en: Implementing a LevelUP plugin
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现LevelUP插件
- en: In the next example, we are going to show you how we can create a simple plugin
    for LevelUP using the Decorator pattern, and in particular, the object augmentation
    technique, which is the simplest but also the most pragmatic and effective way
    to decorate objects with additional capabilities.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将向您展示如何使用装饰器模式创建一个简单的LevelUP插件，特别是对象增强技术，这是最简单但也是最实用和有效的方法来为对象添加额外功能。
- en: For convenience, we are going to use the `level` package ([nodejsdp.link/level](http://nodejsdp.link/level)),
    which bundles both `levelup` and the default adapter called `leveldown`, which
    uses LevelDB as the backend.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将使用`level`包（[nodejsdp.link/level](http://nodejsdp.link/level)），它捆绑了`levelup`和默认适配器`leveldown`，后者使用LevelDB作为后端。
- en: 'What we want to build is a plugin for LevelUP that allows us to receive notifications
    every time an object with a certain pattern is saved into the database. For example,
    if we subscribe to a pattern such as `{a: 1}`, we want to receive a notification
    when objects such as `{a: 1, b: 3}` or `{a: 1, c: ''x''}` are saved into the database.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '我们想要构建的是一个LevelUP插件，允许我们在某个模式的对象被保存到数据库时接收通知。例如，如果我们订阅了一个模式如`{a: 1}`，我们希望在对象如`{a:
    1, b: 3}`或`{a: 1, c: ''x''}`被保存到数据库时收到通知。'
- en: 'Let''s start to build our small plugin by creating a new module called `level-subscribe.js`.
    We will then insert the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`level-subscribe.js`的新模块开始构建我们的小型插件。然后我们将插入以下代码：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That''s it for our plugin; it''s extremely simple. Let''s briefly analyze the
    preceding code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的插件的全部内容；它极其简单。让我们简要分析一下前面的代码：
- en: We decorate the `db` object with a new method named `subscribe()`. We simply
    attach the method directly to the provided `db` instance (object augmentation).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用一个名为`subscribe()`的新方法来装饰`db`对象。我们直接将方法附加到提供的`db`实例上（对象增强）。
- en: We listen for any `put` operation performed on the database.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们监听数据库上执行的任何`put`操作。
- en: We perform a very simple pattern-matching algorithm, which verifies that all
    the properties in the provided pattern are also available in the data being inserted.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行一个非常简单的模式匹配算法，该算法验证提供的模式中的所有属性也存在于正在插入的数据中。
- en: If we have a match, we notify the listener.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有匹配项，我们通知监听器。
- en: 'Let''s now write some code to try out our new plugin:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编写一些代码来测试我们的新插件：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is how the preceding code works:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面代码的工作原理：
- en: First, we initialize our LevelUP database, choosing the directory where the
    files are stored and the default encoding for the values.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的LevelUP数据库，选择存储文件的目录和值的默认编码。
- en: Then, we attach our plugin, which decorates the original `db` object.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们附加我们的插件，它装饰了原始的`db`对象。
- en: 'At this point, we are ready to use the new feature provided by our plugin,
    which is the `subscribe()` method, where we specify that we are interested in
    all the objects with `doctype: ''tweet''` and `language: ''en''`.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '到目前为止，我们已经准备好使用我们插件提供的新功能，即`subscribe()`方法，我们指定我们感兴趣的具有`doctype: ''tweet''`和`language:
    ''en''`的所有对象。'
- en: Finally, we save some values in the database using `put`. The first call triggers
    the callback associated with our subscription and we should see the stored object
    printed to the console. This is because, in this case, the object matches the
    subscription. The second call does not generate any output because the stored
    object does not match the subscription criteria.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`put`在数据库中保存一些值。第一次调用触发了与我们的订阅相关联的回调，我们应该看到存储的对象打印到控制台。这是因为在这种情况下，对象与订阅相匹配。第二次调用不会生成任何输出，因为存储的对象不符合订阅标准。
- en: This example shows a real application of the Decorator pattern in its simplest
    implementation, which is object augmentation. It may look like a trivial pattern,
    but it has undoubted power if used appropriately.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了装饰器模式在其最简单实现中的实际应用，即对象增强。它可能看起来像是一个微不足道的模式，但如果使用得当，它无疑具有强大的功能。
- en: For simplicity, our plugin works only in combination with `put` operations,
    but it can be easily expanded to work even with `batch` operations ([nodejsdp.link/levelup-batch](http://nodejsdp.link/levelup-batch)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们的插件仅与`put`操作结合使用，但它可以很容易地扩展到与`batch`操作一起工作 ([nodejsdp.link/levelup-batch](http://nodejsdp.link/levelup-batch))。
- en: In the wild
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: 'For more examples of how decorators are used in the real world, you can inspect
    the code of some more LevelUP plugins:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解装饰器在实际世界中的更多用法示例，您可以检查一些LevelUP插件的代码：
- en: '`level-inverted-index` ([nodejsdp.link/level-inverted-index](http://nodejsdp.link/level-inverted-index)):
    This is a plugin that adds inverted indexes to a LevelUP database, allowing us
    to perform simple text searches across the values stored in the database'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level-inverted-index` ([nodejsdp.link/level-inverted-index](http://nodejsdp.link/level-inverted-index)):
    这是一个插件，它向LevelUP数据库添加倒排索引，使我们能够在数据库存储的值中执行简单的文本搜索'
- en: '`levelplus` ([nodejsdp.link/levelplus](http://nodejsdp.link/levelplus)): This
    is a plugin that adds atomic updates to a LevelUP database'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelplus` ([nodejsdp.link/levelplus](http://nodejsdp.link/levelplus)): 这是一个向LevelUP数据库添加原子更新的插件'
- en: 'Aside from LevelUP plugins, the following projects are also good examples of
    the adoption of the Decorator pattern:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了LevelUP插件外，以下项目也是采用装饰器模式的好例子：
- en: '`json-socket` ([nodejsdp.link/json-socket](http://nodejsdp.link/json-socket)):
    This module makes it easier to send JSON data over a TCP (or a Unix) socket. It
    is designed to decorate an existing instance of `net.Socket`, which gets enriched
    with additional methods and behaviors.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json-socket` ([nodejsdp.link/json-socket](http://nodejsdp.link/json-socket)):
    这个模块使得通过TCP（或Unix）套接字发送JSON数据变得更加容易。它被设计用来装饰现有的`net.Socket`实例，该实例通过添加额外的方法和行为而得到增强。'
- en: '`fastify` ([nodejsdp.link/fastify](http://nodejsdp.link/fastify)) is a web
    application framework that exposes an API to decorate a Fastify server instance
    with additional functionality or configuration. With this approach, the additional
    functionality is made accessible to different parts of the application. This is
    a quite generalized implementation of the Decorator pattern. Check out the dedicated
    documentation page to find out more at [nodejsdp.link/fastify-decorators](http://nodejsdp.link/fastify-decorators).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fastify` ([nodejsdp.link/fastify](http://nodejsdp.link/fastify)) 是一个暴露API以装饰Fastify服务器实例并添加额外功能或配置的Web应用程序框架。使用这种方法，额外的功能可以提供给应用程序的不同部分。这是一个相当通用的装饰器模式实现。要了解更多信息，请查看专门的文档页面
    [nodejsdp.link/fastify-decorators](http://nodejsdp.link/fastify-decorators)。'
- en: The line between proxy and decorator
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理和装饰器之间的界限
- en: At this point in the book, you might have some legitimate doubts about the differences
    between the Proxy and the Decorator patterns. These two patterns are indeed very
    similar and they can sometimes be used interchangeably.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，您可能对代理模式和装饰器模式之间的区别有一些合理的疑问。这两个模式确实非常相似，有时可以互换使用。
- en: In its classic incarnation, the Decorator pattern is defined as a mechanism
    that allows us to enhance an existing object with new behavior, while the Proxy
    pattern is used to control access to a concrete or virtual object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在其经典形态中，装饰器模式被定义为一种机制，允许我们通过添加新行为来增强现有对象，而代理模式用于控制对具体或虚拟对象的访问。
- en: There is a conceptual difference between the two patterns, and it's mostly based
    on the way they are used at runtime.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模式之间有一个概念上的区别，这主要基于它们在运行时的使用方式。
- en: You can look at the Decorator pattern as a wrapper; you can take different types
    of objects and decide to wrap them with a decorator to enhance their capabilities
    with extra functionality. A proxy, instead, is used to control the access to an
    object and it does not change the original interface. For this reason, once you
    have created a proxy instance, you can pass it over to a context that expects
    the original object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将装饰器模式看作是一个包装器；你可以取不同类型的对象，并决定用装饰器来包装它们，以增加额外的功能。相反，代理用于控制对对象的访问，并且它不会改变原始接口。因此，一旦你创建了一个代理实例，你就可以将其传递给期望原始对象的环境。
- en: When it comes to implementation, these differences are generally much more obvious
    with strongly typed languages where the type of the objects you pass around is
    checked at compile time. In the Node.js ecosystem, given the dynamic nature of
    the JavaScript language, the line between the Proxy and the Decorator patterns
    is quite blurry, and often the two names are used interchangeably. We have also
    seen how the same techniques can be used to implement both patterns.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到实现时，这些差异在强类型语言中通常更为明显，在这些语言中，你传递的对象类型会在编译时进行检查。在Node.js生态系统中，由于JavaScript语言的动态性，代理模式和装饰器模式之间的界限相当模糊，并且这两个名称经常被互换使用。我们也看到了相同的技巧可以用来实现这两种模式。
- en: When dealing with JavaScript and Node.js, our advice is to avoid getting bogged
    down with the nomenclature and the canonical definition of these two patterns.
    We encourage you to look at the class of problems that proxy and decorator solve
    as a whole and treat these two patterns as complementary and sometimes interchangeable
    tools.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理JavaScript和Node.js时，我们的建议是避免陷入这两个模式的命名和规范定义的泥潭。我们鼓励你从整体上看待代理和装饰器解决的问题类别，并将这两个模式视为互补的，有时可以互换的工具。
- en: Adapter
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: The Adapter pattern allows us to access the functionality of an object using
    a different interface.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式允许我们使用不同的接口访问对象的功能。
- en: A real-life example of an adapter would be a device that allows you to plug
    a USB Type-A cable into a USB Type-C port. In a generic sense, an adapter converts
    an object with a given interface so that it can be used in a context where a different
    interface is expected.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器的真实生活例子是一个允许你将USB Type-A电缆插入USB Type-C端口的设备。在通用意义上，适配器将具有给定接口的对象转换，以便它可以在期望不同接口的环境中使用。
- en: 'In software, the Adapter pattern is used to take the interface of an object
    (the **adaptee**) and make it compatible with another interface that is expected
    by a given client. Let''s have a look at *Figure 8.3* to clarify this idea:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，适配器模式用于将对象的接口（**适配者**）与客户端期望的另一个接口兼容。让我们看看*图8.3*来澄清这个概念：
- en: '![A screenshot of a cell phone  Description automatically generated](img/B15729_08_03.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕截图  描述自动生成](img/B15729_08_03.png)'
- en: 'Figure 8.3: Adapter pattern schematic'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：适配器模式示意图
- en: In *Figure 8.3*, we can see how the adapter is essentially a wrapper for the
    adaptee, exposing a different interface. The diagram also highlights the fact
    that the operations of the adapter can also be a composition of one or more method
    invocations on the adaptee. From an implementation perspective, the most common
    technique is composition, where the methods of the adapter provide a bridge to
    the methods of the adaptee. This pattern is pretty straightforward, so let's immediately
    work on an example.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.3*中，我们可以看到适配器本质上是对适配者的包装，暴露了不同的接口。该图还突出了适配器的操作也可以是适配者一个或多个方法调用的组合。从实现的角度来看，最常见的技术是组合，其中适配器的方
    法提供了一个连接到适配者方法的桥梁。这种模式相当直接，所以让我们立即开始一个示例。
- en: Using LevelUP through the filesystem API
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过文件系统API使用LevelUP
- en: We are now going to build an adapter around the LevelUP API, transforming it
    into an interface that is compatible with the core `fs` module. In particular,
    we will make sure that every call to `readFile()` and `writeFile()` will translate
    into calls to `db.get()` and `db.put()`. This way we will be able to use a LevelUP
    database as a storage backend for simple filesystem operations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将围绕 LevelUP API 构建一个适配器，将其转换为一个与核心 `fs` 模块兼容的接口。特别是，我们将确保每个对 `readFile()`
    和 `writeFile()` 的调用都会转换为对 `db.get()` 和 `db.put()` 的调用。这样我们就能将 LevelUP 数据库用作简单文件系统操作的存储后端。
- en: 'Let''s start by creating a new module named `fs-adapter.js`. We will begin
    by loading the dependencies and exporting the `createFsAdapter()` factory that
    we are going to use to build the adapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个名为 `fs-adapter.js` 的新模块。我们将从加载依赖项并导出 `createFsAdapter()` 工厂函数开始，我们将使用这个工厂函数来构建适配器：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will implement the `readFile()` function inside the factory and ensure
    that its interface is compatible with the one of the original function from the
    `fs` module:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在工厂内部实现 `readFile()` 函数，并确保其接口与 `fs` 模块原始函数的接口兼容：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, we had to do some extra work to make sure that the behavior
    of our new function is as close as possible to the original `fs.readFile()` function.
    The steps performed by the function are described as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们必须做一些额外的工作来确保我们新函数的行为尽可能接近原始的 `fs.readFile()` 函数。该函数执行的步骤描述如下：
- en: To retrieve a file from the `db` instance, we invoke `db.get()`, using `filename`
    as a key, by making sure to always use its full path (using `resolve()`). We set
    the value of the `valueEncoding` option used by the database to be equal to any
    eventual `encoding` option received as an input.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从 `db` 实例中检索文件，我们调用 `db.get()`，使用 `filename` 作为键，确保始终使用其完整路径（使用 `resolve()`）。我们将数据库使用的
    `valueEncoding` 选项的值设置为等于任何作为输入接收到的 `encoding` 选项。
- en: If the key is not found in the database, we create an error with `ENOENT` as
    the error code, which is the code used by the original `fs` module to indicate
    a missing file. Any other type of error is forwarded to `callback` (for the scope
    of this example, we are adapting only the most common error condition).
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在数据库中找不到键，我们将创建一个错误，错误代码为 `ENOENT`，这是原始 `fs` 模块用来指示文件缺失的代码。任何其他类型的错误都会直接转发到
    `callback`（在本例的范围内，我们只适配最常见的错误条件）。
- en: If the key-value pair is retrieved successfully from the database, we will return
    the value to the caller using the `callback`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果键值对成功从数据库中检索出来，我们将使用 `callback` 将值返回给调用者。
- en: The function that we created does not want to be a perfect replacement for the
    `fs.readFile()` function, but it definitely does its job in the most common situations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的函数不想成为 `fs.readFile()` 函数的完美替代品，但它确实在大多数情况下完成了其工作。
- en: 'To complete our small adapter, let''s now see how to implement the `writeFile()`
    function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的小适配器，现在让我们看看如何实现 `writeFile()` 函数：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, we don't have a perfect wrapper in this case either. We are ignoring
    some options such as file permissions (`options.mode`), and we are forwarding
    any error that we receive from the database as is.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这种情况下我们也没有一个完美的包装器。我们忽略了某些选项，例如文件权限（`options.mode`），并且我们将从数据库接收到的任何错误原样转发。
- en: 'Our new adapter is now ready. If we now write a small test module, we can try
    to use it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新适配器现在准备好了。如果我们现在编写一个小测试模块，我们可以尝试使用它：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code uses the original `fs` API to perform a few read and write
    operations on the filesystem, and should print something like the following to
    the console:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了原始的 `fs` API 来在文件系统中执行一些读写操作，并且应该在控制台打印出类似以下内容：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can try to replace the `fs` module with our adapter, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试用我们的适配器替换 `fs` 模块，如下所示：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Running our program again should produce the same output, except for the fact
    that no parts of the file that we specified are read or written using the filesystem
    API directly. Instead, any operation performed using our adapter will be converted
    into an operation performed on a LevelUP database.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的程序应该产生相同的输出，除了我们没有使用文件系统 API 直接读取或写入我们指定的文件部分。相反，使用我们的适配器执行的任何操作都将转换为在
    LevelUP 数据库上执行的操作。
- en: The adapter that we just created might look silly; what's the purpose of using
    a database in place of the real filesystem? However, we should remember that LevelUP
    itself has adapters that enable the database to also run in the browser. One of
    these adapters is `level-js` ([nodejsdp.link/level-js](http://nodejsdp.link/level-js)).
    Now our adapter makes perfect sense. We could use something similar to allow code
    leveraging the `fs` module to run on both Node.js and a browser. We will soon
    realize that Adapter is an extremely important pattern when it comes to sharing
    code with the browser, as we will see in more detail in *Chapter 10*, *Universal
    JavaScript for Web Applications*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的适配器可能看起来很愚蠢；用数据库代替真实文件系统的目的是什么？然而，我们应该记住，LevelUP本身就有适配器，使得数据库也能够在浏览器中运行。其中之一是`level-js`
    ([nodejsdp.link/level-js](http://nodejsdp.link/level-js))。现在我们的适配器就变得非常有意义了。我们可以使用类似的方法来允许利用`fs`模块的代码在Node.js和浏览器上运行。我们很快就会意识到，当涉及到与浏览器共享代码时，适配器是一个极其重要的模式，正如我们将在第10章“通用Web应用程序的JavaScript”中更详细地看到的那样。
- en: In the wild
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在野外
- en: 'There are plenty of real-world examples of the Adapter pattern. We''ve listed
    some of the most notable examples here for you to explore and analyze:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式在现实世界中有很多实例。我们在这里列出了一些最显著的例子供您探索和分析：
- en: We already know that LevelUP is able to run with different storage backends,
    from the default LevelDB to IndexedDB in the browser. This is made possible by
    the various adapters that are created to replicate the internal (private) LevelUP
    API. Take a look at some of them to see how they are implemented at [nodejsdp.link/level-stores](http://nodejsdp.link/level-stores).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经知道LevelUP能够与不同的存储后端一起运行，从默认的LevelDB到浏览器中的IndexedDB。这是通过创建各种适配器来复制内部（私有）LevelUP
    API来实现的。查看其中的一些示例，了解它们是如何在[nodejsdp.link/level-stores](http://nodejsdp.link/level-stores)中实现的。
- en: JugglingDB is a multi-database ORM and of course, multiple adapters are used
    to make it compatible with different databases. Take a look at some of them at
    [nodejsdp.link/jugglingdb-adapters](http://nodejsdp.link/jugglingdb-adapters).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JugglingDB是一个多数据库ORM，当然，它使用了多个适配器来使其与不同的数据库兼容。查看其中的一些示例，请访问[nodejsdp.link/jugglingdb-adapters](http://nodejsdp.link/jugglingdb-adapters)。
- en: nanoSQL ([nodejsdp.link/nanosql](http://nodejsdp.link/nanosql)) is a modern
    multi-model database abstraction library that makes heavy usage of the Adapter
    pattern to support a significant variety of databases.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nanoSQL ([nodejsdp.link/nanosql](http://nodejsdp.link/nanosql))是一个现代的多模型数据库抽象库，它大量使用适配器模式来支持大量的数据库。
- en: The perfect complement to the example that we created is `level-filesystem`
    ([nodejsdp.link/level-filesystem](http://nodejsdp.link/level-filesystem)), which
    is the proper implementation of the `fs` API on top of LevelUP.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建的示例的完美补充是`level-filesystem` ([nodejsdp.link/level-filesystem](http://nodejsdp.link/level-filesystem))，这是在LevelUP之上对`fs`
    API的正确实现。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Structural design patterns are definitely some of the most widely adopted design
    patterns in software engineering and it is important to be confident with them.
    In this chapter, we explored the Proxy, the Decorator, and the Adapter patterns
    and we discussed different ways to implement these in the context of Node.js.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型设计模式无疑是软件工程中最广泛采用的设计模式之一，因此对它们有信心是非常重要的。在本章中，我们探讨了代理模式、装饰器模式和适配器模式，并讨论了在Node.js环境中实现这些模式的不同方法。
- en: We saw how the Proxy pattern can be a very valuable tool to control access to
    existing objects. In this chapter, we also mentioned how the Proxy pattern can
    enable different programming paradigms such as reactive programming using the
    Change Observer pattern.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了代理模式如何成为一个非常有价值的工具来控制对现有对象的访问。在本章中，我们还提到了代理模式如何启用不同的编程范式，例如使用变更观察者模式进行响应式编程。
- en: In the second part of the chapter, we found out that the Decorator pattern is
    an invaluable tool to be able to add additional functionality to existing objects.
    We saw that its implementation doesn't differ much from the Proxy pattern and
    we explored some examples built around the LevelDB ecosystem.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们发现装饰器模式是一个非常有价值的工具，可以用来向现有对象添加额外的功能。我们看到了它的实现与代理模式并没有太大的区别，并且我们探讨了围绕LevelDB生态系统构建的一些示例。
- en: Finally, we discussed the Adapter pattern, which allows us to wrap an existing
    object and expose its functionality through a different interface. We saw that
    this pattern can be useful to expose a piece of existing functionality to a component
    that expects a different interface. In our examples, we saw how this pattern can
    be used to implement an alternative storage layer that is compatible with the
    interface provided by the `fs` module to interact with files.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了适配器模式，它允许我们包装现有的对象，并通过不同的接口公开其功能。我们看到了这个模式可以用来向期望不同接口的组件公开现有功能。在我们的示例中，我们看到了如何使用这个模式来实现一个与
    `fs` 模块提供的接口兼容的替代存储层。
- en: 'Proxy, decorator and adapter are very similar, the difference between them
    can be appreciated from the perspective of the interface consumer: proxy provides
    the same interface as the wrapped object, decorator provides an enhanced interface,
    and adapter provides a different interface.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 代理、装饰器和适配器非常相似，它们之间的区别可以从接口消费者的角度来欣赏：代理提供与包装对象相同的接口，装饰器提供增强的接口，而适配器提供不同的接口。
- en: In the next chapter, we will complete our journey through traditional design
    patterns in Node.js by exploring the category of behavioral design patterns. This
    category includes important patterns such as the Strategy pattern, the Middleware
    pattern, and the Iterator pattern. Are you ready to discover behavioral design
    patterns?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过探索行为设计模式类别来完成我们在 Node.js 中的传统设计模式之旅。这个类别包括诸如策略模式、中间件模式和迭代器模式等重要模式。你准备好发现行为设计模式了吗？
- en: Exercises
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**8.1 HTTP client cache**: Write a proxy for your favorite HTTP client library
    that caches the response of a given HTTP request, so that if you make the same
    request again, the response is immediately returned from the local cache, rather
    than being fetched from the remote URL. If you need inspiration, you can check
    out the `superagent-cache` module ([nodejsdp.link/superagent-cache](http://nodejsdp.link/superagent-cache)).'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8.1 HTTP 客户端缓存**: 为你最喜欢的 HTTP 客户端库编写一个代理，缓存给定 HTTP 请求的响应，这样如果你再次发出相同的请求，响应将立即从本地缓存返回，而不是从远程
    URL 获取。如果你需要灵感，可以查看 `superagent-cache` 模块 ([nodejsdp.link/superagent-cache](http://nodejsdp.link/superagent-cache))。'
- en: '**8.2 Timestamped logs**: Create a proxy for the `console` object that enhances
    every logging function (`log()`, `error()`, `debug()`, and `info()`) by prepending
    the current timestamp to the message you want to print in the logs. For instance,
    executing `consoleProxy.log(''hello'')` should print something like `2020-02-18T15:59:30.699Z
    hello` in the console.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8.2 带时间戳的日志**: 为 `console` 对象创建一个代理，通过在日志中打印的消息前添加当前时间戳来增强每个日志功能（`log()`、`error()`、`debug()`
    和 `info()`）。例如，执行 `consoleProxy.log(''hello'')` 应该在控制台打印出类似 `2020-02-18T15:59:30.699Z
    hello` 的内容。'
- en: '**8.3 Colored console output**: Write a decorator for the console that adds
    the `red(message)`, `yellow(message)`, and `green(message)` methods. These methods
    will have to behave like `console.log(message)` except they will print the message
    in red, yellow, or green, respectively. In one of the exercises from the previous
    chapter, we already pointed you to some useful packages to to create colored console
    output. If you want to try something different this time, have a look at `ansi-styles`
    ([nodejsdp.link/ansi-styles](http://nodejsdp.link/ansi-styles)).'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8.3 带颜色的控制台输出**: 为控制台编写一个装饰器，添加 `red(message)`、`yellow(message)` 和 `green(message)`
    方法。这些方法的行为必须像 `console.log(message)` 一样，除了它们将分别以红色、黄色或绿色打印消息。在前一章的一个练习中，我们已经指向了一些有用的包来创建带颜色的控制台输出。如果你想尝试不同的方法，可以看看
    `ansi-styles` ([nodejsdp.link/ansi-styles](http://nodejsdp.link/ansi-styles))。'
- en: '**8.4 Virtual filesystem**: Modify our LevelDB filesystem adapter example to
    write the file data in memory rather than in LevelDB. You can use an object or
    a `Map` instance to store the key-value pairs of filenames and the associated
    data.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8.4 虚拟文件系统**: 修改我们的 LevelDB 文件系统适配器示例，将文件数据写入内存而不是 LevelDB。你可以使用一个对象或一个 `Map`
    实例来存储文件名及其相关数据的键值对。'
- en: '**8.5 The lazy buffer**: Can you implement `createLazyBuffer(size)`, a factory
    function that generates a virtual proxy for a `Buffer` of the given size? The
    proxy instance should instantiate a `Buffer` object (effectively allocating the
    given amount of memory) only when `write()` is being invoked for the first time.
    If no attempt to write into the buffer is made, no `Buffer` instance should be
    created.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8.5 懒缓冲区**: 你能否实现 `createLazyBuffer(size)`，一个生成给定大小 `Buffer` 的虚拟代理的工厂函数？代理实例应在第一次调用
    `write()` 时才实例化 `Buffer` 对象（实际上分配给定数量的内存）。如果没有尝试向缓冲区写入，则不应创建 `Buffer` 实例。'
