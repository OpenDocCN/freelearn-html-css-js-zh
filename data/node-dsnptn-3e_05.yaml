- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Asynchronous Control Flow Patterns with Promises and Async/Await
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Promise和Async/Await的异步控制流模式
- en: Callbacks are the low-level building blocks of asynchronous programming in Node.js,
    but they are far from being developer-friendly. In fact, in the last chapter,
    we learned techniques to implement different control flow constructs using callbacks,
    and we can say that they are quite complex and verbose compared to the (low) level
    of complexity of the tasks they try to accomplish. In particular, serial execution
    flow, which is the predominant control flow structure in most of the code we write,
    can easily lead an untrained developer to write code affected by the callback
    hell problem. On top of that, even if properly implemented, a serial execution
    flow seems needlessly complicated and error-prone. Let's also remember how fragile
    error management with callbacks is; if we forget to forward an error, then it
    just gets lost, and if we forget to catch any exception thrown by some synchronous
    code, then the program crashes. And all of this without considering that Zalgo
    is always breathing down our necks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是Node.js中异步编程的低级构建块，但它们远非开发者友好。实际上，在上一个章节中，我们学习了使用回调实现不同控制流结构的技术，并且可以说，与它们试图完成的任务（低）复杂度相比，它们相当复杂且冗长。特别是串行执行流程，这是我们编写的代码中占主导地位的控制流结构，很容易导致未经训练的开发者编写受回调地狱问题影响的代码。除此之外，即使正确实现，串行执行流程似乎也过于复杂且容易出错。让我们也记住回调的错误管理是多么脆弱；如果我们忘记转发错误，那么它就会丢失，如果我们忘记捕获由某些同步代码抛出的任何异常，那么程序就会崩溃。而且这一切还不考虑Zalgo总是紧随其后。
- en: Node.js and JavaScript have been criticized for many years for the lack of a
    native solution to a problem so common and ubiquitous. Luckily, over the years,
    the community has worked on new solutions to the problem and finally, after many
    iterations, discussions, and years of waiting, today we have a proper solution
    to the "callback issue."
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和JavaScript多年来一直因缺乏对如此常见且普遍存在的问题的本地解决方案而受到批评。幸运的是，多年来，社区一直在努力寻找新的解决方案，最终，经过许多迭代、讨论和多年的等待，今天我们终于有了对“回调问题”的适当解决方案。
- en: The first step toward a better asynchronous code experience is the **promise**,
    an object that "carries" the status and the eventual result of an asynchronous
    operation. A promise can be easily chained to implement serial execution flows
    and can be moved around like any other object. Promises simplify asynchronous
    code a lot; however, there was still room for improvement. So, in an attempt to
    make the ubiquitous serial execution flow as simple as possible, a new construct
    was introduced, called **async/await**, which can finally make asynchronous code
    look like synchronous code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 向更好的异步代码体验迈出的第一步是**Promise**，一个“携带”异步操作状态和最终结果的对象。Promise可以轻松地串联起来以实现串行执行流程，并且可以像任何其他对象一样移动。Promise极大地简化了异步代码；然而，仍有改进的空间。因此，为了使普遍的串行执行流程尽可能简单，引入了一个新的构造，称为**async/await**，它最终可以使异步代码看起来像同步代码。
- en: In today's modern Node.js programming, async/await is the preferred construct
    to use when dealing with asynchronous code. However, async/await is built on top
    of promises, as much as promises are built on top of callbacks. So, it's important
    that we know and master all of them in order to tackle our asynchronous programming
    problems with the right approach.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的现代化Node.js编程中，async/await是处理异步代码时首选的构造。然而，async/await建立在Promise之上，正如Promise建立在回调之上。因此，了解并掌握所有这些内容对于以正确的方法解决我们的异步编程问题至关重要。
- en: 'In this chapter, you will learn the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: How promises work and how to use them effectively to implement the main control
    flow constructs we already know about.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promise的工作原理以及如何有效地使用它们来实现我们已知的控制流结构。
- en: The async/await syntax, which will become our main tool for dealing with asynchronous
    code in Node.js.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: async/await语法，这将成为我们在Node.js中处理异步代码的主要工具。
- en: By the end of the chapter, you will have learned about the two most important
    components that we have in JavaScript for taming asynchronous code. So, let's
    get started by discovering promises.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解JavaScript中用于驯服异步代码的两个最重要的组件。那么，让我们通过发现Promise来开始吧。
- en: Promises
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise
- en: Promises are part of the ECMAScript 2015 standard (or ES6, which is why they
    are also called ES6 promises) and have been natively available in Node.js since
    version 4\. But the history of promises goes back a few years earlier, when there
    were dozens of implementations around, initially with different features and behavior.
    Eventually, the majority of those implementations settled on a standard called
    **Promises/A+**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是ECMAScript 2015标准（或ES6，这就是为什么它们也被称为ES6承诺）的一部分，并且自版本4以来在Node.js中原生可用。但承诺的历史可以追溯到几年前，当时有数十种实现，最初具有不同的功能和行为。最终，大多数这些实现都选择了一个称为**Promises/A+**的标准。
- en: Promises represent a big step ahead toward providing a robust alternative to
    continuation-passing style callbacks for propagating an asynchronous result. As
    we will see, the use of promises will make all the major asynchronous control
    flow constructs easier to read, less verbose, and more robust compared to their
    callback-based alternatives.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺代表了向提供对异步结果传播的健壮替代品迈出的重大一步。正如我们将看到的，使用承诺将使所有主要的异步控制流结构更容易阅读、更简洁、更健壮，与基于回调的替代品相比。
- en: What is a promise?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是承诺？
- en: A `Promise` is an object that embodies the eventual result (or error) of an
    asynchronous operation. In promises jargon, we say that a `Promise` is **pending** when
    the asynchronous operation is not yet complete, it's **fulfilled** when the operation
    successfully completes, and **rejected** when the operation terminates with an
    error. Once a `Promise` is either fulfilled or rejected, it's considered **settled**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`是一个对象，它体现了异步操作最终的结果（或错误）。在承诺术语中，我们说当异步操作尚未完成时，`Promise`是**挂起的**，当操作成功完成时，它是**已履行的**，当操作因错误而终止时，它是**被拒绝的**。一旦`Promise`被履行或拒绝，它就被认为是**已解决的**。'
- en: 'To receive the **fulfillment value** or the error (**reason**) associated with
    the rejection, we can use the `then()` method of a `Promise` instance. The following
    is its signature:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要接收**履行值**或与拒绝相关的错误（**原因**），我们可以使用`Promise`实例的`then()`方法。以下是其签名：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding signature, `onFulfilled` is a callback that will eventually
    receive the fulfillment value of the `Promise`, and `onRejected` is another callback
    that will receive the reason for the rejection (if any). Both are optional.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的签名中，`onFulfilled`是一个回调，它最终将接收`Promise`的履行值，而`onRejected`是另一个回调，它将接收拒绝的原因（如果有）。两者都是可选的。
- en: 'To have an idea of how promises can transform our code, let''s consider the
    following callback-based code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解承诺如何改变我们的代码，让我们考虑以下基于回调的代码：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Promises allow us to transform this typical continuation-passing style code
    into a better structured and more elegant code, such as the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺使我们能够将这种典型的传递风格代码转换为结构更好、更优雅的代码，如下所示：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the code above, `asyncOperationPromise()` is returning a `Promise`, which
    we can then use to receive the fulfillment value or the rejection reason of the
    eventual result of the function. So far, it seems that there is nothing major
    going on, but one crucial property of the `then()` method is that it *synchronously*
    returns another `Promise`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`asyncOperationPromise()`返回一个`Promise`，然后我们可以使用它来接收函数最终结果的履行值或拒绝原因。到目前为止，似乎没有什么重大事件发生，但`then()`方法的一个关键属性是它**同步地**返回另一个`Promise`。
- en: 'Moreover, if any of the `onFulfilled` or `onRejected` functions return a value *x*,
    the `Promise` returned by the `then()` method will:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果`onFulfilled`或`onRejected`函数中的任何一个返回一个值*x*，则`then()`方法返回的`Promise`将：
- en: Fulfill with *x* if *x* is a value
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*x*是一个值，则使用*x*来履行
- en: Fulfill with the fulfillment value of *x* if *x* is a `Promise`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*x*是一个`Promise`，则使用*x*的履行值来履行
- en: Reject with the eventual rejection reason of *x* if *x* is a `Promise`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*x*是一个`Promise`，则使用*x*的最终拒绝原因来拒绝
- en: 'This behavior allows us to build *chains* of promises, allowing easy aggregation
    and arrangement of asynchronous operations into several configurations. Moreover,
    if we don''t specify an `onFulfilled` or `onRejected` handler, the fulfillment
    value or rejection reason is automatically forwarded to the next promise in the
    chain. This allows us, for example, to automatically propagate errors across the
    whole chain until they are caught by an `onRejected` handler. With a `Promise`
    chain, the sequential execution of tasks suddenly becomes a trivial operation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为允许我们构建承诺的*链*，使得异步操作可以轻松地聚合和排列成几个配置。此外，如果我们没有指定`onFulfilled`或`onRejected`处理程序，满足值或拒绝原因将自动转发到链中的下一个承诺。例如，这允许我们自动将错误传播到整个链，直到被`onRejected`处理程序捕获。有了承诺链，任务的顺序执行突然变得简单：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following diagram provides another perspective on how a `Promise` chain
    works:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了对`Promise`链工作方式的另一种视角：
- en: '![](img/B15729_05_01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15729_05_01.png)'
- en: 'Figure 5.1: Promise chain execution flow'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：承诺链执行流程
- en: '*Figure 5.1* shows how our program flows when we use a chain of promises. When
    we invoke `then()` on **Promise A** we synchronously receive **Promise B** as
    a result and when we invoke `then()` on **Promise B** we synchronously receive
    **Promise C** as a result. Eventually, when **Promise A** settles, it will either
    fulfill or reject, which results in the invocation of either the `onFulfilled()`
    or the `onRejected()` callback respectively. The result of the execution of such
    a callback will then fulfill or reject **Promise B** and such a result is, in
    turn, propagated to the `onFulfilled()` or the `onRejected()` callback passed
    to the `then()` invocation on **Promise B**. The execution continues similarly
    for **Promise C** and any other promise that follows in the chain.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.1*展示了当我们使用承诺链时程序是如何流动的。当我们对**Promise A**调用`then()`时，我们同步地接收到**Promise B**作为结果，当我们对**Promise
    B**调用`then()`时，我们同步地接收到**Promise C**作为结果。最终，当**Promise A**解决时，它将满足或拒绝，这会导致分别调用`onFulfilled()`或`onRejected()`回调。这样的回调执行结果将满足或拒绝**Promise
    B**，这样的结果反过来又传播到在**Promise B**上调用`then()`时传递给`onFulfilled()`或`onRejected()`回调。对**Promise
    C**和链中后续的任何其他承诺的执行将继续以类似的方式进行。'
- en: An important property of promises is that the `onFulfilled()` and `onRejected()`
    callbacks are *guaranteed* to be invoked asynchronously and at most once, even
    if we resolve the `Promise` synchronously with a value. Not only that, the `onFulfilled()` and `onRejected()` callbacks
    will be invoked asynchronously even if the `Promise` object is already settled
    at the moment in which `then()` is called. This behavior shields our code against
    all those situations where we could unintentionally release Zalgo (see *Chapter
    3*, *Callbacks and Events*), making our asynchronous code more consistent and
    robust without any extra effort.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的一个重要特性是，无论我们是否以同步方式使用值解决`Promise`，`onFulfilled()`和`onRejected()`回调都**保证**异步调用，并且最多调用一次。不仅如此，即使`Promise`对象在调用`then()`时已经处于已解决状态，`onFulfilled()`和`onRejected()`回调也会异步调用。这种行为保护我们的代码免受那些可能无意中释放Zalgo（参见*第3章*，*回调和事件*）的情况，使我们的异步代码在无需额外努力的情况下更加一致和健壮。
- en: Now comes the best part. If an exception is thrown (using the `throw` statement)
    in the `onFulfilled()` or `onRejected()` handler, the `Promise` returned by the `then()` method
    will automatically reject, with the exception that was thrown provided as the
    rejection reason. This is a tremendous advantage over CPS, as it means that with
    promises, exceptions will propagate automatically across the chain, and the `throw` statement
    becomes finally usable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最好的一部分。如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将自动拒绝，抛出的异常作为拒绝原因提供。这比CPS有巨大的优势，因为它意味着使用承诺，异常将自动在链中传播，`throw`语句最终变得可用。
- en: Promises/A+ and thenables
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promises/A+和thenables
- en: Historically, there have been many different implementations of promises, and
    most of them were not compatible with each other, meaning that it was not possible
    to create chains between `Promise` objects coming from libraries that were using
    different `Promise` implementations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，承诺有许多不同的实现，其中大多数互不兼容，这意味着无法在来自使用不同`Promise`实现的库的`Promise`对象之间创建链。
- en: The JavaScript community worked very hard to address this limitation and those
    efforts led to the creation of the **Promises/A+** specification. This specification
    details the behavior of the `then()` method, providing an interoperable base,
    which makes `Promise` objects from different libraries able to work with each
    other out of the box. Today, the majority of `Promise` implementations use this
    standard, including the native `Promise` object of JavaScript and Node.js.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 社区非常努力地解决这个限制，这些努力导致了 `Promises/A+` 规范的创建。该规范详细说明了 `then()` 方法的行为，提供了一个可互操作的基线，使得来自不同库的
    `Promise` 对象能够无缝地相互工作。今天，大多数 `Promise` 实现都使用这个标准，包括 JavaScript 和 Node.js 的原生 `Promise`
    对象。
- en: For a detailed overview of the **Promises/A+** specification, you can refer
    to the official website at [nodejsdp.link/promises-aplus](http://nodejsdp.link/promises-aplus).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Promises/A+` 规范的详细概述，你可以参考官方网站 [nodejsdp.link/promises-aplus](http://nodejsdp.link/promises-aplus)。
- en: As a result of the adoption of the Promises/A+ standard, many `Promise` implementations,
    including the native JavaScript `Promise` API, will consider any object with a
    `then()` method a `Promise`-like object, also called **thenable**. This behavior
    allows different `Promise` implementations to interact with each other seamlessly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于采用了 Promises/A+ 标准，许多 `Promise` 实现包括原生 JavaScript `Promise` API，都将任何具有 `then()`
    方法的对象视为类似 `Promise` 的对象，也称为 **可等待的**。这种行为允许不同的 `Promise` 实现无缝地相互交互。
- en: The technique of recognizing (or typing) objects based on their external behavior,
    rather than their actual type, is called **duck typing** and is widely used in
    JavaScript.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对象的外部行为（而不是其实际类型）来识别（或类型化）对象的技术称为 **鸭子类型**，并且在 JavaScript 中被广泛使用。
- en: The promise API
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise API
- en: Let's now take a quick look at the API of the native JavaScript `Promise`. This
    is just an overview to give you an idea of what we can do with promises, so don't
    worry if things are not so clear at this point yet; we will have the chance to
    use most of these APIs throughout the book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们快速浏览一下原生 JavaScript `Promise` 的 API。这只是一个概述，让你了解我们可以用 promises 做什么，所以如果你现在觉得事情不是很清楚，不要担心；我们将在整本书中有很多机会使用这些
    API。
- en: 'The `Promise` constructor (`new Promise((resolve, reject) => {})`) creates
    a new `Promise` instance that fulfills or rejects based on the behavior of the
    function provided as an argument. The function provided to the constructor will
    receive two arguments:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 构造函数 (`new Promise((resolve, reject) => {})`) 创建一个新的 `Promise` 实例，该实例根据提供的函数的行为来满足或拒绝。构造函数提供的函数将接收两个参数：'
- en: '`resolve(obj)`: This is a function that, when invoked, will fulfill the `Promise`
    with the provided fulfillment value, which will be `obj` if `obj` is a value.
    It will be the fulfillment value of `obj` if `obj` is a `Promise` or a thenable.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolve(obj)`: 这是一个函数，当被调用时，会用提供的实现值来满足 `Promise`，如果 `obj` 是一个值，则 `obj` 将作为实现值。如果
    `obj` 是一个 `Promise` 或一个可等待的值，则它将是 `obj` 的实现值。'
- en: '`reject(err)`: This rejects the `Promise` with the reason `err`. It is a convention
    for `err` to be an instance of `Error`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reject(err)`: 这个方法用原因 `err` 拒绝 `Promise`。按照惯例，`err` 应该是一个 `Error` 实例。'
- en: 'Now, let''s take a look at the most important static methods of the `Promise`
    object:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Promise` 对象最重要的静态方法：
- en: '`Promise.resolve(obj)`: This method creates a new `Promise` from another `Promise`,
    a thenable, or a value. If a `Promise` is passed, then that `Promise` is returned
    as it is. If a thenable is provided, then it''s *converted* to the `Promise` implementation
    in use. If a value is provided, then the `Promise` will be fulfilled with that
    value.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.resolve(obj)`: 这个方法从一个 `Promise`、一个可等待的值或一个值创建一个新的 `Promise`。如果传递了一个
    `Promise`，则直接返回该 `Promise`。如果提供了一个可等待的值，则将其转换为当前使用的 `Promise` 实现。如果提供了一个值，则 `Promise`
    将使用该值来满足。'
- en: '`Promise.reject(err)`: This method creates a `Promise` that rejects with `err`
    as the reason.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.reject(err)`: 这个方法创建一个拒绝的 `Promise`，其拒绝原因为 `err`。按照惯例，`err` 应该是一个
    `Error` 实例。'
- en: '`Promise.all(iterable)`: This method creates a `Promise` that fulfills with
    an array of fulfillment values when every item in the input `iterable` (such as
    an `Array`) object fulfills. If any `Promise` in the iterable object rejects,
    then the `Promise` returned by `Promise.all()` will reject with the first rejection
    reason. Each item in the `iterable` object can be a `Promise`, a generic thenable,
    or a value.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.all(iterable)`: 这个方法创建一个`Promise`，当输入`iterable`（如`Array`）对象中的每个项目都完成时，它将完成。如果`iterable`对象中的任何`Promise`拒绝，则`Promise.all()`返回的`Promise`将拒绝，拒绝原因是第一个拒绝原因。`iterable`对象中的每个项目都可以是一个`Promise`、一个通用的`thenable`或一个值。'
- en: '`Promise.allSettled(iterable)`: This method waits for all the input promises
    to fulfill or reject and then returns an array of objects containing the fulfillment
    value or the rejection reason for each input `Promise`. Each output object has
    a `status` property, which can be equal to `''fulfilled''` or `''rejected''`,
    and a `value` property containing the fulfillment value, or a `reason` property
    containing the rejection reason. The difference with `Promise.all()` is that `Promise.allSettled()`
    will always wait for each `Promise` to either fulfill or reject, instead of immediately
    rejecting when one of the promises rejects.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.allSettled(iterable)`: 这个方法等待所有输入`Promise`完成或拒绝，然后返回一个包含每个输入`Promise`的完成值或拒绝原因的对象数组。每个输出对象都有一个`status`属性，它可以等于`''fulfilled''`或`''rejected''`，以及一个包含完成值的`value`属性，或包含拒绝原因的`reason`属性。与`Promise.all()`的区别在于，`Promise.allSettled()`将始终等待每个`Promise`完成或拒绝，而不是在其中一个`Promise`拒绝时立即拒绝。'
- en: '`Promise.race(iterable)`: This method returns a `Promise` that is equivalent
    to the first `Promise` in `iterable` that settles.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.race(iterable)`: 这个方法返回一个`Promise`，它与`iterable`中的第一个解决的`Promise`等价。'
- en: 'Finally, the following are the main methods available on a `Promise` instance:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是在`Promise`实例上可用的主要方法：
- en: '`promise.then(onFulfilled, onRejected)`: This is the essential method of a `Promise`.
    Its behavior is compatible with the Promises/A+ standard that we mentioned before.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`promise.then(onFulfilled, onRejected)`: 这是`Promise`的基本方法。它的行为与之前提到的Promises/A+标准兼容。'
- en: '`promise.catch(onRejected)`: This method is just syntactic sugar ([nodejsdp.link/syntactic-sugar](http://nodejsdp.link/syntactic-sugar))
    for `promise.then(undefined, onRejected)`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`promise.catch(onRejected)`: 这个方法只是`promise.then(undefined, onRejected)`的语法糖（[nodejsdp.link/syntactic-sugar](http://nodejsdp.link/syntactic-sugar)）。'
- en: '`promise.finally(onFinally)`: This method allows us to set up an `onFinally`
    callback, which is invoked when the `Promise` is settled (either fulfilled or
    rejected). Unlike `onFulfilled` and `onRejected`, the `onFinally` callback will
    not receive any argument as input and any value returned from it will be ignored.
    The `Promise` returned by `finally` will settle with the same fulfillment value
    or rejection reason of the current `Promise` instance. There is only once exception
    to all this, which is the case in which we `throw` inside the `onFinally` callback
    or return a rejected `Promise`. In this case, the returned `Promise` will reject
    with the error that is thrown or the rejection reason of the rejected `Promise`
    returned.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`promise.finally(onFinally)`: 这个方法允许我们设置一个`onFinally`回调，当`Promise`解决（无论是完成还是拒绝）时将被调用。与`onFulfilled`和`onRejected`不同，`onFinally`回调不会接收任何输入参数，并且从它返回的任何值都将被忽略。`finally`返回的`Promise`将以当前`Promise`实例相同的完成值或拒绝原因解决。所有这些中只有一个例外，那就是我们在`onFinally`回调内部`throw`或返回一个拒绝的`Promise`的情况。在这种情况下，返回的`Promise`将拒绝，拒绝原因是抛出的错误或返回的拒绝`Promise`的拒绝原因。'
- en: Let's now see an example of how we can create a `Promise` from scratch using
    its constructor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个例子，说明我们如何使用其构造函数从头开始创建一个`Promise`。
- en: Creating a promise
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个`Promise`
- en: Let's now see how we can create a `Promise` using its constructor. Creating
    a `Promise` from scratch is a low-level operation and it's usually required when
    we need to convert an API that uses another asynchronous style (such as a callback-based
    style). Most of the time we—as developers—are consumers of promises produced by
    other libraries and most of the promises we create will come from the `then()`
    method. Nonetheless, in some advanced scenarios, we need to manually create a
    `Promise` using its constructor.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下如何使用其构造函数创建一个`Promise`。从头开始创建`Promise`是一个低级操作，通常在我们需要将使用另一种异步风格的API（例如基于回调的风格）转换为API时需要。大多数时候，作为开发者的我们，是其他库产生的`Promise`的消费者，我们创建的大多数`Promise`将来自`then()`方法。尽管如此，在某些高级场景中，我们需要手动使用其构造函数创建一个`Promise`。
- en: 'To demonstrate how to use the `Promise` constructor, let''s create a function
    that returns a `Promise` that fulfills with the current date after a specified
    number of milliseconds. Let''s take a look at it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`Promise`构造函数，让我们创建一个函数，该函数返回一个`Promise`，在指定数量的毫秒数后解析为当前日期。让我们看看它：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you probably already guessed, we used `setTimeout()` to invoke the `resolve()`
    function of the `Promise` constructor. We can notice how the entire body of the
    function is wrapped by the `Promise` constructor; this is a frequent code pattern
    you will see when creating a `Promise` from scratch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经猜到的，我们使用了`setTimeout()`来调用`Promise`构造函数的`resolve()`函数。我们可以注意到整个函数体都被`Promise`构造函数所包裹；这是在从头创建`Promise`时经常看到的一种代码模式。
- en: 'The `delay()` function we just created can then be used with some code like
    the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才创建的`delay()`函数可以与以下代码一起使用：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `console.log()` within the `then()` handler will be executed approximately
    after 1 second from the invocation of `delay()`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`then()`处理程序中的`console.log()`将在调用`delay()`后大约1秒执行。'
- en: The Promises/A+ specification states that the `onFulfilled` and `onRejected`
    callbacks of the `then()` method have to be invoked only once and exclusively
    (only one or the other is invoked). A compliant promises implementation makes
    sure that even if we call `resolve` or `reject` multiple times, the `Promise`
    is either fulfilled or rejected only once.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Promises/A+规范指出，`then()`方法的`onFulfilled`和`onRejected`回调必须只调用一次，并且是专一的（只调用一个或另一个）。一个符合规范的Promise实现确保即使我们多次调用`resolve`或`reject`，`Promise`也只被解析或拒绝一次。
- en: Promisification
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promisification
- en: When some characteristics of a callback-based function are known in advance,
    it's possible to create a function that transforms such a callback-based function
    into an equivalent function returning a `Promise`. This transformation is called
    **promisification**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当提前知道基于回调的函数的一些特性时，可以创建一个函数，将这样的基于回调的函数转换成返回`Promise`的等效函数。这种转换称为**promisification**。
- en: 'For example, let''s consider the conventions used in Node.js-style callback-based
    functions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑Node.js风格的基于回调的函数中使用的约定：
- en: The callback is the last argument of the function
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调是函数的最后一个参数
- en: The error (if any) is always the first argument passed to the callback
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （如果有的话）错误总是作为第一个参数传递给回调
- en: Any return value is passed after the error to the callback
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何返回值都传递给回调后的错误
- en: 'Based on these rules, we can easily create a generic function that *promisifies*
    a Node.js-style callback-based function. Let''s see what this function looks like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些规则，我们可以轻松地创建一个通用函数，将Node.js风格的基于回调的函数`promisifies`。让我们看看这个函数的样子：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding function returns another function called `promisified()`, which
    represents the promisified version of the `callbackBasedApi` given as the input.
    This is how it works:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数返回另一个名为`promisified()`的函数，它代表了作为输入提供的`callbackBasedApi`的promisified版本。这是它的工作方式：
- en: The `promisified()` function creates a new `Promise` using the `Promise` constructor
    and immediately returns it to the caller.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`promisified()`函数使用`Promise`构造函数创建一个新的`Promise`，并立即将其返回给调用者。'
- en: In the function passed to the `Promise` constructor, we make sure to pass to `callbackBasedApi`
    a special callback. Since we know that the callback always comes last, we simply
    append it to the arguments list (`args`) provided to the `promisified()` function.
    In the special callback, if we receive an error, we immediately reject the `Promise`;
    otherwise, we resolve it with the given `result`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在传递给`Promise`构造函数的函数中，我们确保将一个特殊的回调函数传递给`callbackBasedApi`。因为我们知道回调函数总是最后到来，所以我们只需将它附加到传递给`promisified()`函数的参数列表（`args`）中。在特殊的回调函数中，如果我们收到一个错误，我们立即拒绝`Promise`；否则，我们使用给定的`result`来解析它。
- en: Finally, we simply invoke `callbackBasedApi` with the list of arguments we have
    built.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。
- en: 'Now, let''s promisify a Node.js function using our newly created `promisify()`
    function. We can use the `randomBytes()` function of the core `crypto` module,
    which produces a buffer containing the specified number of random bytes. The `randomBytes()`
    function accepts a callback as the last argument and it follows the conventions
    we already know very well. Let''s see what this looks like:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们新创建的`promisify()`函数来promisify一个Node.js函数。我们可以使用核心`crypto`模块的`randomBytes()`函数，该函数生成包含指定数量随机字节的缓冲区。`randomBytes()`函数接受一个回调作为最后一个参数，并且遵循我们非常熟悉的约定。让我们看看它是什么样子：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous code should print some gibberish to the console; that's because
    not all generated bytes have a corresponding printable character.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码应该在控制台打印一些乱码；这是因为并非所有生成的字节都有对应的可打印字符。
- en: The promisification function we created here is just for educational purposes
    and it's missing a few features, such as the ability to deal with callbacks returning
    more than one result. In real life, we would use the `promisify()` function of
    the `util` core module to promisify our Node.js-style callback-based functions.
    You can take a look at its documentation at [nodejsdp.link/promisify](http://nodejsdp.link/promisify).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的承诺化函数仅用于教育目的，并且缺少一些功能，例如处理返回多个结果的回调的能力。在现实生活中，我们会使用`util`核心模块的`promisify()`函数来承诺化我们的Node.js风格的回调函数。您可以在[http://nodejsdp.link/promisify](http://nodejsdp.link/promisify)查看其文档。
- en: Sequential execution and iteration
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序执行和迭代
- en: We now know enough to convert the web spider application that we created in
    the previous chapter to use promises. Let's start directly from version 2, the
    one downloading the links of a webpage in sequence.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道足够的信息，可以将我们在上一章创建的网页蜘蛛应用程序转换为使用承诺。让我们直接从版本2开始，这个版本是按顺序下载网页链接的。
- en: 'We can access an already promisified version of the core `fs` API through the
    `promises` object of the `fs` module. For example: `import { promises } from ''fs''`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`fs`模块的`promises`对象访问核心`fs` API的已承诺化版本。例如：`import { promises } from 'fs'`。
- en: 'In the `spider.js` module, the very first step required is to import our dependencies
    and promisify any callback-based function that we are going to use:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spider.js`模块中，首先需要执行的是导入我们的依赖项，并将我们打算使用的任何基于回调的函数进行承诺化：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are two main differences here compared to the `spider.js` module of the
    previous chapter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章的`spider.js`模块相比，这里有两个主要区别：
- en: We import the `promises` object of the `fs` module to get access to all the
    `fs` functions already promisified.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入`fs`模块的`promises`对象，以便访问所有已经承诺化的`fs`函数。
- en: We manually promisify the `mkdirp()` function.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们手动承诺化`mkdirp()`函数。
- en: 'Now, we can start converting the `download()` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始转换`download()`函数：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can straightaway appreciate the elegance of implementing sequential asynchronous
    operations with promises. We simply have a clean and very intuitive chain of `then()`
    invocations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接欣赏使用承诺实现顺序异步操作的优雅性。我们只需要一个干净且非常直观的`then()`调用链。
- en: Compared to the previous version of the function, this time we are leveraging
    the out-of-the-box support for promises of the `superagent` package. Instead of
    invoking `end()` on the request object returned by `superagent.get()`, we simply
    invoke `then()` to send the request (1) and receive a `Promise` that fulfills/rejects
    with the result of the request.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数的上一版本相比，这次我们利用了`superagent`包对承诺的原生支持。我们不是在`superagent.get()`返回的请求对象上调用`end()`，而是简单地调用`then()`来发送请求（1）并接收一个承诺，该承诺满足/拒绝请求的结果。
- en: The final return value of the `download()` function is the `Promise` returned
    by the last `then()` call in the chain, which fulfills with the `content` of the
    webpage (3), which we initialized in the `onFulfilled` handler of the first `then()`
    call (2). This makes sure that the caller receives a `Promise` that fulfills with
    `content` only after all operations (`get`, `mkdirp`, and `writeFile`) have completed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`download()`函数的最终返回值是链中最后一个`then()`调用的返回的`Promise`，它满足于网页的`content`（3），我们在第一个`then()`调用的`onFulfilled`处理程序中初始化了它。这确保了调用者只有在所有操作（`get`、`mkdirp`和`writeFile`）完成后才会收到满足于`content`的`Promise`。'
- en: 'In the `download()` function that we''ve just seen, we have executed a known
    set of asynchronous operations in sequence. However, in the `spiderLinks()` function,
    we will have to deal with a sequential iteration over a dynamic set of asynchronous
    tasks. Let''s see how we can achieve that:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚看到的`download()`函数中，我们已经按顺序执行了一组已知的异步操作。然而，在`spiderLinks()`函数中，我们必须处理对动态异步任务集的顺序迭代。让我们看看我们如何实现这一点：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To iterate over all the links of a webpage asynchronously, we had to dynamically
    build a chain of promises as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要异步遍历网页上的所有链接，我们不得不动态构建如下所示的承诺链：
- en: First, we defined an "empty" `Promise`, which resolves to `undefined`. This
    `Promise` is used just as the starting point for our chain.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个“空”的`Promise`，它解析为`undefined`。这个`Promise`被用作我们链的起点。
- en: Then, in a loop, we update the `promise` variable with a new `Promise` obtained
    by invoking `then()` on the previous `promise` in the chain. This is actually
    our asynchronous iteration pattern using promises.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在循环中，我们使用链中前一个 `promise` 的 `then()` 调用获取一个新的 `Promise` 来更新 `promise` 变量。这实际上是我们使用
    promises 的异步迭代模式。
- en: At the end of the `for` loop, the `promise` variable will contain the promise
    of the last `then()` invocation, so it will resolve only when all the promises
    in the chain have been resolved.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环的末尾，`promise` 变量将包含最后一个 `then()` 调用的 promise，因此它只有在链中的所有 promises
    都已解决时才会解析。
- en: '**Pattern (sequential iteration with promises)**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式（使用 promises 的顺序迭代）**'
- en: Dynamically build a chain of promises using a loop.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环动态构建一个 promises 链。
- en: 'Now, we can finally convert the `spider()` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以将 `spider()` 函数转换：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this new `spider()` function, we are using `catch()` to handle any error
    produced by `readFile()`. In particular, if the error has code `'ENOENT'`, it
    means that the file doesn't exist yet and therefore we need to download the corresponding
    URL. The `Promise` returned from `download()`, if fulfilled, will return the `content`
    at the URL. On the other hand, if the `Promise` produced by `readFile()` fulfills,
    it will *skip* the `catch()` handler and go straight to the next `then()`. In
    both cases, the `onFulfilled` handler of the last `then()` call will always receive
    the `content` of the webpage, either coming from the local file or from a fresh
    download.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的 `spider()` 函数中，我们使用 `catch()` 来处理由 `readFile()` 产生的任何错误。特别是，如果错误代码是 `'ENOENT'`，这意味着文件尚不存在，因此我们需要下载相应的
    URL。`download()` 返回的 `Promise`，如果得到满足，将返回 URL 的 `content`。另一方面，如果 `readFile()`
    生成的 `Promise` 得到满足，它将 *跳过* `catch()` 处理程序并直接进入下一个 `then()`。在这两种情况下，最后一个 `then()`
    调用的 `onFulfilled` 处理程序将始终接收到网页的 `content`，无论是来自本地文件还是来自新的下载。
- en: 'Now that we have converted our `spider()` function as well, we can finally
    modify the `spider-cli.js` module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `spider()` 函数也转换好了，我们最终可以修改 `spider-cli.js` 模块：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `catch()` handler here will intercept any error originating from the entire `spider()` process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `catch()` 处理程序将拦截来自整个 `spider()` 进程的任何错误。
- en: If we look again at all the code we have written so far, we will be pleasantly
    surprised by the fact that we haven't included any error propagation logic (as
    we would be forced to do when using callbacks). This is clearly an enormous advantage,
    as it greatly reduces the boilerplate in our code and the chances of missing any
    asynchronous errors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次审视迄今为止所编写的所有代码，我们会愉快地发现我们没有包含任何错误传播逻辑（正如在使用回调时我们被迫要做的那样）。这显然是一个巨大的优势，因为它大大减少了我们代码中的模板代码量以及遗漏任何异步错误的机会。
- en: This completes the implementation of version 2 of our web spider application
    with promises.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们使用 promises 的网络爬虫应用程序第二个版本的实现。
- en: 'An alternative of the sequential iteration pattern with promises makes use
    of the `reduce()` function, for an even more compact implementation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `reduce()` 函数的顺序迭代模式的替代方案，可以用于更紧凑的实现：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Parallel execution
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行执行
- en: Another execution flow that becomes trivial with promises is the parallel execution flow.
    In fact, all that we need to do is use the built-in `Promise.all()` method. This
    helper function creates another `Promise` that fulfills only when all the promises
    received as input are fulfilled. If there is no causal relationship between those
    promises (for example, they are not part of the same chain of promises), then
    they will be executed in parallel.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 promises 另一种变得简单的执行流程是并行执行流程。实际上，我们所需做的只是使用内置的 `Promise.all()` 方法。这个辅助函数创建了一个新的
    `Promise`，只有当所有输入的 promises 都得到满足时才会得到满足。如果这些 promises 之间没有因果关系（例如，它们不是同一个 promises
    链的一部分），那么它们将并行执行。
- en: 'To demonstrate this, let''s consider version 3 of our web spider application,
    which downloads all the links of a page in parallel. Let''s just update the `spiderLinks()`
    function again to implement a parallel execution flow using promises:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们考虑我们网络爬虫应用程序的第三个版本，它并行下载页面上的所有链接。让我们再次更新 `spiderLinks()` 函数以实现使用
    promises 的并行执行流程：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The pattern here consists in starting the `spider()` tasks all at once in the
    `links.map()` loop. At the same time, each `Promise` returned by invoking `spider()`
    is collected in the final `promises` array. The critical difference in this loop—as
    compared to the sequential iteration loop—is that we are not waiting for the previous
    `spider()` task in the list to complete before starting a new one. All the `spider()`
    tasks are started in the loop at once, in the same event loop cycle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式包括在`links.map()`循环中同时启动所有`spider()`任务。同时，调用`spider()`返回的每个`Promise`都被收集到最终的`promises`数组中。与顺序迭代循环相比，这个循环的关键区别在于我们不需要等待列表中的前一个`spider()`任务完成就开始一个新的任务。所有`spider()`任务都在循环中同时启动，在相同的事件循环周期中。
- en: Once we have all the promises, we pass them to the `Promise.all()` method, which
    returns a new `Promise` that will be fulfilled when all the promises in the array
    are fulfilled. In other words, it fulfills when all the download tasks have completed.
    In addition to that, the `Promise` returned by `Promise.all()` will reject immediately
    if any of the promises in the input array reject. This is exactly what we wanted
    for this version of our web spider.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所有的承诺，我们将它们传递给`Promise.all()`方法，它返回一个新的`Promise`，当数组中的所有承诺都满足时，它将被满足。换句话说，当所有下载任务完成时，它将被满足。此外，如果输入数组中的任何承诺拒绝，`Promise.all()`返回的`Promise`将立即拒绝。这正是我们在这个版本的蜘蛛程序中想要的。
- en: Limited parallel execution
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限并行执行
- en: So far, promises have not disappointed our expectations. We were able to greatly
    improve our code for both serial and parallel execution. Now, with limited parallel
    execution, things should not be that different, considering that this flow is
    just a combination of serial and parallel execution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，承诺并没有辜负我们的期望。我们能够极大地改进我们用于串行和并行执行的代码。现在，考虑到这个流程只是串行和并行执行的结合，有限并行执行应该不会有太大的不同。
- en: In this section, we will go straight to implementing a solution that allows
    us to *globally* limit the concurrency of our web spider tasks. In other words,
    we are going to implement our solution in a class that we can use to instantiate
    objects that we can pass around to different functions of the same application.
    If you are just interested in a simple solution to locally limit the parallel
    execution of a set of tasks, you can still apply the same principles that we will
    see in this section to implement a special asynchronous version of `Array.map()`.
    We leave this to you as an exercise; you can find more details and hints at the
    end of this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将直接实现一个解决方案，允许我们全局限制蜘蛛任务并发性。换句话说，我们将在一个类中实现我们的解决方案，我们可以使用它来实例化对象，我们可以将这些对象传递给同一应用程序的不同函数。如果你只对局部限制一组任务的并行执行有一个简单的解决方案，你仍然可以应用本节中将要看到的相同原则来实现`Array.map()`的特殊异步版本。我们将这个练习留给你；你可以在本章末尾找到更多详细信息和提示。
- en: For a ready-to-use, production-ready implementation of a `map()` function supporting
    promises and limited concurrency, you can rely on the `p-map` package. Find out
    more at [nodejsdp.link/p-map](http://nodejsdp.link/p-map).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个支持承诺和有限并发性的`map()`函数的现成、生产就绪实现，你可以信赖`p-map`包。更多信息请访问[nodejsdp.link/p-map](http://nodejsdp.link/p-map)。
- en: Implementing the TaskQueue class with promises
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用承诺实现TaskQueue类
- en: 'To globally limit the concurrency of our spider download tasks, we are going
    to reuse the `TaskQueue` class we implemented in the previous chapter. Let''s
    start with the `next()` method, where we trigger the execution of a set of tasks
    until we reach the concurrency limit:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全局限制我们蜘蛛下载任务的并发性，我们将重用我们在上一章中实现的`TaskQueue`类。让我们从`next()`方法开始，在这里我们触发一系列任务的执行，直到达到并发限制：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The core change in the `next()` method is where we invoke `task()`. In fact,
    now we expect that `task()` returns a `Promise`, so all we have to do is invoke
    `finally()` on that `Promise` so we can reset the count of running tasks if it
    either fulfills or rejects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`方法的核心变化在于我们调用`task()`的地方。实际上，现在我们期望`task()`返回一个`Promise`，所以我们只需要在那个`Promise`上调用`finally()`，这样我们就可以在它满足或拒绝时重置正在运行的任务计数。'
- en: 'Now, we implement a new method called `runTask()`. This method is responsible
    for queueing a special wrapper function and also for returning a newly built `Promise`.
    Such a `Promise` will essentially forward the result (fulfillment or rejection)
    of the `Promise` eventually returned by `task()`. Let''s see what this method
    looks like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实现一个新的方法，称为 `runTask()`。这个方法负责排队一个特殊的包装函数，并返回一个新构建的 `Promise`。这样的 `Promise`
    将本质上转发 `task()` 最终返回的 `Promise` 的结果（实现或拒绝）。让我们看看这个方法的样子：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the method we have just seen:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚看到的方法中：
- en: We create a new `Promise` using its constructor.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用其构造函数创建一个新的 `Promise`。
- en: We add a special wrapper function to the tasks queue. This function is going to
    be executed at a later `next()` run, when there are enough concurrency slots left.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向任务队列中添加了一个特殊的包装函数。这个函数将在稍后的 `next()` 运行时执行，当有足够的并发槽位时。
- en: We invoke `next()` to trigger a new set of tasks to be run. We defer this to
    a subsequent run of the event loop to guarantee that `task` is always invoked
    asynchronously with respect to when `runTask()` is invoked. This prevents the
    problems we described in *Chapter 3*, *Callbacks and Events* (for example, Zalgo).
    In fact, we can notice that in the `next()` method there is another invocation
    of `next()` itself, in the `finally()` handler, that is always asynchronous.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用 `next()` 来触发一组新的任务运行。我们将此推迟到事件循环的后续运行，以确保 `task` 总是相对于 `runTask()` 的调用异步执行。这防止了我们在
    *第 3 章*，*回调和事件* 中描述的问题（例如，Zalgo）。实际上，我们可以在 `next()` 方法中注意到，在 `finally()` 处理程序中，还有一个对
    `next()` 本身的调用，它总是异步的。
- en: When the wrapper function we queued is finally run, we execute the `task` we
    have received as the input, and we forward its results—fulfilment value or rejection
    reason—to the outer `Promise`, the one we return from the `runTask()` method.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们排队的包装函数最终运行时，我们执行作为输入接收到的 `task`，并将它的结果（实现值或拒绝原因）转发到外部的 `Promise`，即我们从 `runTask()`
    方法返回的那个 `Promise`。
- en: With this, we have completed the implementation of our new `TaskQueue` class
    using promises. Next, we'll use this new version of the `TaskQueue` class to implement
    version 4 of our web spider.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经使用承诺完成了我们新的 `TaskQueue` 类的实现。接下来，我们将使用这个新的 `TaskQueue` 类版本来实现我们网络爬虫的版本
    4。
- en: Updating the web spider
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新网络爬虫
- en: Now it's time to adapt our web spider to implement a limited parallel execution
    flow using the `TaskQueue` class we have just created.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的网络爬虫适配以使用我们刚刚创建的 `TaskQueue` 类实现一个有限的并行执行流程了。
- en: 'First, we need to split the `spider()` function into two functions, one simply
    initializing a new `TaskQueue` object and another actually executing the spidering
    task, which we will call `spiderTask()`. Then, we need to update the `spiderLinks()`
    function to invoke the newly created `spiderTask()` function and forward the task
    `queue` instance received as an input. Let''s see what all this looks like:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将 `spider()` 函数拆分为两个函数，一个简单地初始化一个新的 `TaskQueue` 对象，另一个实际执行爬取任务，我们将它称为
    `spiderTask()`。然后，我们需要更新 `spiderLinks()` 函数以调用新创建的 `spiderTask()` 函数，并将接收到的任务
    `queue` 实例作为输入转发。让我们看看这一切看起来是什么样子：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The crucial instruction in the code we have just seen is where we invoke `queue.runTask()`
    (1). Here, the task that we are queuing (and therefore limiting) comprises just
    the retrieval of the contents of the URL from either the local filesystem or the
    remote URL location. Only after this task has been run by the queue can we continue
    to spider the links of the webpage. Note that we are intentionally keeping `spiderLinks()`
    outside of the task that we want to limit. This is because `spiderLinks()` can
    trigger more `spiderTasks()` and that would create a deadlock if the depth of
    the spidering process is higher than the concurrency limit of the queue.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的代码中的关键指令是调用 `queue.runTask()` (1)。在这里，我们排队（因此限制）的任务仅包括从本地文件系统或远程 URL
    位置检索 URL 的内容。只有当队列运行了这个任务之后，我们才能继续爬取网页的链接。请注意，我们故意将 `spiderLinks()` 保持在我们想要限制的任务之外。这是因为
    `spiderLinks()` 可能会触发更多的 `spiderTasks()`，如果爬取过程的深度高于队列的并发限制，这将会造成死锁。
- en: We can also notice how in `spiderLinks()` we simply continue to use `Promise.all()`
    (2) to download all the links of a webpage in parallel. This is because it's the
    responsibility of our `queue` to limit the concurrency of the tasks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注意到，在 `spiderLinks()` 中，我们简单地继续使用 `Promise.all()` (2) 并行下载网页上的所有链接。这是因为限制任务并发是
    `queue` 的责任。
- en: In production code, you can use the package `p-limit` (available at [nodejsdp.link/p-limit](http://nodejsdp.link/p-limit))
    to limit the concurrency of a set of tasks. The package essentially implements
    the pattern we have just shown but wrapped in a slightly different API.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码中，你可以使用`p-limit`包（可在[nodejsdp.link/p-limit](http://nodejsdp.link/p-limit)找到）来限制一组任务的并发性。该包本质上实现了我们刚刚展示的模式，但封装在一个稍微不同的API中。
- en: This concludes our exploration of JavaScript promises. Next, we are going to
    learn about the async/await pair, which will completely revolutionize the way
    we deal with asynchronous code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对JavaScript Promise的探索。接下来，我们将学习关于async/await配对的内容，这将彻底改变我们处理异步代码的方式。
- en: Async/await
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async/await
- en: As we have just seen, promises are a quantum leap ahead of callbacks. They allow
    us to write clean and readable asynchronous code and provide a set of safeguards
    that can only be achieved with boilerplate code when working with callback-based
    asynchronous code. However, promises are still suboptimal when it comes to writing
    sequential asynchronous code. The `Promise` chain is indeed much better than having
    callback hell, but still, we have to invoke a `then()` and create a new function
    for each task in the chain. This is still too much for a control flow that is
    definitely the most commonly used in everyday programming. JavaScript needed a
    proper way to deal with the ubiquitous asynchronous sequential execution flow,
    and the answer arrived with the introduction in the ECMAScript standard of **async
    functions** and the `await` **expression** (**async/await** for short).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，Promise比回调前进了一大步。它们允许我们编写干净、易读的异步代码，并提供一组只有在使用基于回调的异步代码时才能通过样板代码实现的保障。然而，当涉及到编写顺序异步代码时，Promise仍然不是最优的。`Promise`链确实比回调地狱要好得多，但仍然，我们必须对链中的每个任务调用`then()`并创建一个新的函数。这对于肯定是在日常编程中最常用到的控制流来说仍然太多。JavaScript需要一个正确的方式来处理无处不在的异步顺序执行流，而随着ECMAScript标准中**异步函数**和`await`**表达式**（简称**async/await**）的引入，答案出现了。
- en: The async/await dichotomy allows us to write functions that appear to block
    at each asynchronous operation, waiting for the results before continuing with
    the following statement. As we will see, any asynchronous code using async/await
    has a readability comparable to traditional synchronous code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: async/await的二分法允许我们编写在每个异步操作上看似阻塞的函数，等待结果后再继续执行后续语句。正如我们将看到的，任何使用async/await的异步代码的可读性都可以与传统同步代码相媲美。
- en: Today, async/await is the recommended construct for dealing with asynchronous
    code in both Node.js and JavaScript. However, async/await does not replace all
    that we have learned so far about asynchronous control flow patterns; on the contrary,
    as we will see, async/await piggybacks heavily onto promises.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '今天，async/await是处理Node.js和JavaScript中异步代码的推荐结构。然而，async/await并没有取代我们迄今为止所学的所有关于异步控制流模式的内容；相反，正如我们将看到的，async/await在很大程度上依赖于Promise。 '
- en: Async functions and the await expression
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步函数和await表达式
- en: 'An async function is a special type of function in which it''s possible to
    use the `await` expression to "pause" the execution on a given `Promise` until
    it resolves. Let''s consider a simple example and use the `delay()` function we
    implemented in the *Creating a promise* subsection. The `Promise` returned by
    `delay()` resolves with the current date as the value after the given number of
    milliseconds. Let''s use this function with the async/await pair:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数是一种特殊类型的函数，在其中可以使用`await`表达式在给定的`Promise`上“暂停”执行，直到它解析。让我们考虑一个简单的例子，并使用我们在*创建一个Promise*子节中实现的`delay()`函数。`delay()`函数返回的`Promise`在给定数量的毫秒数后解析，其值为当前日期。让我们使用这个函数与async/await配对：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see from the previous function, async/await seems to work like magic.
    The code doesn't even look like it contains any asynchronous operation. However,
    don't be mistaken; this function does not run synchronously (they are called async
    functions for a reason!). At each `await` expression, the execution of the function
    is put on hold, its state saved, and the control returned to the event loop. Once
    the `Promise` that has been *awaited* resolves, the control is given back to the
    async function, returning the fulfilment value of the `Promise`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从前面的函数中可以看到，async/await似乎像魔法一样工作。代码甚至看起来不包含任何异步操作。然而，不要误解；这个函数并不是同步运行的（它们被称为异步函数是有原因的！）在每一个`await`表达式中，函数的执行被暂停，其状态被保存，控制权返回给事件循环。一旦被`await`的`Promise`解决，控制权将返回给异步函数，返回`Promise`的完成值。
- en: The `await` expression works with any value, not just promises. If a value other
    than a `Promise` is provided, then its behavior is similar to awaiting a value
    that it first passed to `Promise.resolve()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`表达式与任何值一起工作，而不仅仅是`Promise`。如果提供了除`Promise`之外的其他值，那么它的行为类似于等待它首先传递给`Promise.resolve()`的值。'
- en: 'Let''s now see how we can invoke our new async function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何调用我们的新异步函数：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From the preceding code, it''s clear that async functions can be invoked just
    like any other function. However, the most observant of you may have already spotted
    another important property of async functions: they always return a `Promise`.
    It''s like if the return value of an async function was passed to `Promise.resolve()`
    and then returned to the caller.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以清楚地看出异步函数可以像任何其他函数一样被调用。然而，最细心的你可能已经注意到了异步函数的另一个重要特性：它们总是返回一个`Promise`。这就像异步函数的返回值被传递给`Promise.resolve()`然后返回给调用者一样。
- en: Invoking an async function is instantaneous, like any other asynchronous operation.
    In other words, async functions return a `Promise` synchronously. That `Promise`
    will then eventually settle based on the result or error produced by the function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 调用异步函数是瞬时的，就像任何其他异步操作一样。换句话说，异步函数同步地返回一个`Promise`。然后这个`Promise`将根据函数产生的结果或错误最终解决。
- en: From this first encounter with async/await, we can see how dominant promises
    still are in our discussion. In fact, we can consider async/await just a syntactic
    sugar for a simpler consumption of promises. As we will see, all the asynchronous
    control flow patterns with async/await use promises and their API for most of
    the heavy-lifting operations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从对async/await的第一次接触中，我们可以看到承诺在我们的讨论中仍然占主导地位。事实上，我们可以将async/await视为承诺的语法糖，用于更简单的消费。正如我们将看到的，所有使用async/await的异步控制流模式都使用承诺及其API进行大部分重负载操作。
- en: Error handling with async/await
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用async/await的错误处理
- en: Async/await doesn't just improve the readability of asynchronous code under
    standard conditions, but it also helps when handling errors. In fact, one of the
    biggest gains of async/await is the ability to normalize the behavior of the `try...catch`
    block, to make it work seamlessly with both synchronous *throws* and asynchronous
    `Promise` rejections. Let's demonstrate that with an example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Async/await不仅提高了在标准条件下异步代码的可读性，而且在处理错误时也有帮助。事实上，async/await最大的好处之一是能够使`try...catch`块的行为规范化，使其能够无缝地与同步的*throws*和异步的`Promise`拒绝一起工作。让我们用一个例子来展示这一点。
- en: A unified try...catch experience
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统一的try...catch体验
- en: 'Let''s define a function that returns a `Promise` that rejects with an error
    after a given number of milliseconds. This is very similar to the `delay()` function
    that we already know very well:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个函数，该函数返回一个在给定毫秒数后拒绝错误的`Promise`。这与我们非常熟悉的`delay()`函数非常相似：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, let''s implement an async function that can `throw` an error synchronously
    or `await` a `Promise` that will reject. This function demonstrates how both the
    synchronous `throw` and the `Promise` rejection are caught by the same `catch`
    block:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现一个可以同步`throw`错误或`await`一个将拒绝的`Promise`的异步函数。这个函数展示了同步`throw`和`Promise`拒绝是如何被同一个`catch`块捕获的：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, invoking the function like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以这种方式调用函数：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Will print to the console the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印以下内容到控制台：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'While invoking the function with `false` as the input, like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当以`false`作为输入调用函数时，如下所示：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Will produce the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生以下输出：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we remember how we had to deal with errors in *Chapter 4*, *Asynchronous
    Control Flow Patterns with Callbacks*, we will surely appreciate the giant improvements
    introduced by both promises and async/await. Now, error handling is just as it
    should be: simple, readable, and most importantly, supporting both synchronous
    and asynchronous errors.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还记得在*第4章*，*使用回调的异步控制流模式*中我们如何处理错误，我们一定会欣赏到promises和async/await引入的巨大改进。现在，错误处理就像它应该的那样：简单、易读，最重要的是，支持同步和异步错误。
- en: The "return" versus "return await" trap
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “return”与“return await”陷阱
- en: One common antipattern when dealing with errors with async/await is returning
    a `Promise` that rejects to the caller and expecting the error to be caught by
    the local `try...catch` block of the function that is returning the `Promise`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用async/await处理错误时，一个常见的反模式是返回一个拒绝给调用者的`Promise`，并期望错误被返回`Promise`的函数的本地`try...catch`块捕获。
- en: 'For example, consider the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `Promise` returned by `delayError()` is not awaited locally, which means
    that it''s returned as it is to the caller. As a consequence, the local `catch`
    block will never be invoked. In fact, the previous code will output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`delayError()`返回的`Promise`没有在本地等待，这意味着它以原样返回给调用者。因此，本地的`catch`块永远不会被调用。事实上，前面的代码将输出：'
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If our intention is catching locally any error generated by the asynchronous
    operation that produces the value that we want to return to the caller, then we
    have to use the `await` expression on that `Promise` *before* we return the value
    to the caller. The following code demonstrates this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的目的是在返回给调用者的值之前，捕获由异步操作产生的任何错误，那么我们必须在该`Promise`上使用`await`表达式。以下代码演示了这一点：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All we did was add an `await` after the `return` keyword. This is enough to
    cause the async function to "deal" with the `Promise` locally and therefore also
    catch any rejection locally. As a confirmation, when we run the previous code,
    we should see the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是将`await`添加到`return`关键字之后。这足以让异步函数“处理”本地`Promise`，因此也可以捕获任何本地拒绝。为了确认，当我们运行前面的代码时，我们应该看到以下输出：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sequential execution and iteration
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序执行和迭代
- en: Our exploration of control flow patterns with async/await starts with sequential
    execution and iteration. We already mentioned a few times that the core strength
    of async/await lies in its ability to make asynchronous serial execution easy
    to write and straightforward to read. This was already apparent in all the code
    samples we have written so far; however, it will become even more obvious now
    that we will start converting our web spider version 2\. Async/await is so simple
    to use and understand that there are really no patterns here to study. We will
    get straight to the code, without any preamble.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对使用async/await的控制流模式的探索从顺序执行和迭代开始。我们已经多次提到，async/await的核心优势在于它使异步串行执行易于编写和直接阅读。这在我们迄今为止编写的所有代码示例中都已经很明显；然而，现在我们将开始转换我们的网络爬虫版本2。Async/await的使用和理解如此简单，以至于这里真的没有什么模式可以研究。我们将直接进入代码，没有任何前言。
- en: 'So, let''s start with the `download()` function of our web spider; this is
    how it looks with async/await:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从我们的网络爬虫的`download()`函数开始；这是使用async/await的样子：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's appreciate for a moment how simple and compact the `download()` function
    has become. Let's just consider that the same functionality was implemented with
    callbacks in two different functions using a total of 19 lines of code. Now we
    just have seven. Plus, the code is now completely flat, with no nesting at all.
    This tells us a lot about the enormous positive impact that async/await has on
    our code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时欣赏一下`download()`函数变得多么简单和紧凑。让我们仅仅考虑一下，同样的功能以前是用两个不同的函数通过回调实现的，总共用了19行代码。现在我们只需要7行。而且，代码现在完全扁平，没有任何嵌套。这让我们对async/await对我们代码的巨大积极影响有了更深的认识。
- en: 'Now, let''s see how we can iterate asynchronously over an array using async/await.
    This is exemplified in the `spiderLinks()` function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用async/await异步地遍历一个数组。这可以在`spiderLinks()`函数中看到示例：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Even here there is no pattern to learn. We just have a simple iteration over
    a list of `links` and for each item, we `await` on the `Promise` returned by `spider()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这里，也没有什么模式可以学习。我们只是简单地遍历一个`links`列表，并对每个项目，我们`await`在`spider()`返回的`Promise`上。
- en: 'The next code fragment shows the `spider()` function implemented using async/await.
    The aspect to notice here is how errors are easily dealt with using just a `try...catch`
    statement, making everything easier to read:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段展示了使用 async/await 实现的 `spider()` 函数。这里要注意的是，如何仅使用 `try...catch` 语句轻松处理错误，使代码更容易阅读：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And with the `spider()` function, we have completed the conversion of our web
    spider application to async/await. As you can see, it has been quite a smooth
    process but the results are quite impressive.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `spider()` 函数，我们已经完成了将我们的网络蜘蛛应用程序转换为 async/await 的转换。正如你所见，这是一个相当顺畅的过程，但结果却非常令人印象深刻。
- en: Antipattern – using async/await with Array.forEach for serial execution
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反模式——使用 Array.forEach 和 async/await 进行顺序执行
- en: It's worth mentioning that there is a common antipattern whereby developers
    will try to use `Array.forEach()` or `Array.map()` to implement a sequential asynchronous
    iteration with async/await, which, of course, won't work as expected.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，存在一种常见的反模式，即开发者会尝试使用 `Array.forEach()` 或 `Array.map()` 来实现带有 async/await
    的顺序异步迭代，这当然不会按预期工作。
- en: 'To see why, let''s take a look at the following alternate implementation (which
    is wrong!) of the asynchronous iteration in the `spiderLinks()` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解原因，让我们看看 `spiderLinks()` 函数中异步迭代的以下替代实现（这是错误的！）：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the previous code, the `iteration` function is invoked once for each element
    of the `links` array. Then, in the `iteration` function, we use the `await` expression
    on the `Promise` returned by `spider()`. However, the `Promise` returned by the
    `iteration` function is just ignored by `forEach()`. The result is that all the
    `spider()` functions are invoked in the same round of the event loop, which means
    they are started in parallel, and the execution continues immediately after invoking
    `forEach()`, without waiting for all the `spider()` operations to complete.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`iteration` 函数对 `links` 数组的每个元素调用一次。然后在 `iteration` 函数中，我们对 `spider()`
    返回的 `Promise` 使用 `await` 表达式。然而，`iteration` 函数返回的 `Promise` 被 `forEach()` 忽略了。结果是，所有的
    `spider()` 函数都在同一个事件循环的轮次中调用，这意味着它们是并行启动的，并且在调用 `forEach()` 后立即继续执行，而不等待所有 `spider()`
    操作完成。
- en: Parallel execution
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行执行
- en: There are mainly two ways to run a set of tasks in parallel using async/await;
    one purely uses the `await` expression and the other relies on `Promise.all()`.
    They are both very simple to implement; however, be advised that the method relying
    on `Promise.all()` is the recommended (and optimal) one to use.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 async/await 并行运行一组任务主要有两种方式；一种纯粹使用 `await` 表达式，另一种依赖于 `Promise.all()`。它们都很容易实现；然而，请注意，依赖于
    `Promise.all()` 的方法是推荐的（也是最优的）方法。
- en: 'Let''s see an example of both. Let''s consider the `spiderLinks()` function
    of our web spider. If we wanted to purely use the `await` expression to implement
    an unlimited parallel asynchronous execution flow, we would do it with some code
    like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个示例。让我们考虑我们的网络蜘蛛的 `spiderLinks()` 函数。如果我们想纯粹使用 `await` 表达式来实现无限并行的异步执行流程，我们可以用以下代码来实现：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That's it—very simple. In the previous code, we first start all the `spider()`
    tasks in parallel, collecting their promises with a `map()`. Then, we loop, and
    we `await` on each one of those promises.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——非常简单。在前面的代码中，我们首先并行启动所有的 `spider()` 任务，并用 `map()` 收集它们的 promises。然后我们循环，并对每个
    promise 使用 `await`。
- en: 'At first, it seems neat and functional; however, it has a small undesired effect.
    If a `Promise` in the array rejects, we have to wait for all the preceding promises
    in the array to resolve before the `Promise` returned by `spiderLinks()` will
    also reject. This is not optimal in most situations, as we usually want to know
    if an operation has failed as soon as possible. Luckily, we already have a built-in
    function that behaves exactly the way we want, and that''s `Promise.all()`. In
    fact, `Promise.all()` will reject as soon as any of the promises provided in the
    input array reject. Therefore, we can simply rely on this method even for all
    our async/await code. And, since `Promise.all()` returns just another `Promise`,
    we can simply invoke an `await` on it to get the results from multiple asynchronous
    operations. The following code shows an example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这似乎很整洁且功能齐全；然而，它有一个小的副作用。如果数组中的 `Promise` 被拒绝，我们必须等待数组中所有先前的 promises 都解决，`spiderLinks()`
    返回的 `Promise` 才会拒绝。在大多数情况下，这并不理想，因为我们通常希望尽快知道操作是否失败。幸运的是，我们已经有了一个内置函数，它的行为正好符合我们的需求，那就是
    `Promise.all()`。实际上，`Promise.all()` 会在输入数组中提供的任何 promises 被拒绝时立即拒绝。因此，我们可以简单地依赖这种方法，即使对于所有我们的
    async/await 代码。而且，由于 `Promise.all()` 只返回另一个 `Promise`，我们可以简单地对其调用 `await` 来获取多个异步操作的结果。以下代码展示了示例：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So, to wrap up, our recommended implementation of the `spiderLinks()` function
    with parallel execution and async/await will look almost identical to that using
    promises. The only visible difference is the fact that we are now using an async
    function, which always returns a `Promise`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，我们推荐的带有并行执行和 async/await 的 `spiderLinks()` 函数实现几乎与使用 promises 的实现相同。唯一的可见区别是我们现在使用了一个异步函数，它总是返回一个
    `Promise`：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What we just learned about parallel execution and async/await simply reiterates
    the fact that async/await is inseparable from promises. Most of the utilities
    that work with promises will also seamlessly work with async/await and we should
    never hesitate to take advantage of them in our async functions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学到的关于并行执行和 async/await 的内容只是重申了 async/await 与 promises 不可分割的事实。大多数与 promises
    一起工作的实用工具也将无缝地与 async/await 一起工作，我们不应该犹豫在异步函数中利用它们。
- en: Limited parallel execution
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限并行执行
- en: To implement a limited parallel execution pattern with async/await, we can simply
    reuse the `TaskQueue` class that we created in the *Limited parallel execution*
    subsection within the *Promises* section. We can either use it as it is or convert
    its internals to async/await. Converting the `TaskQueue` class to async/await
    is a trivial operation and we'll leave this to you as an exercise. Either way,
    the `TaskQueue` external interface shouldn't change; both implementations will
    have a `runTask()` method that returns a `Promise` that settles when the task
    has been run by the queue.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 async/await 实现有限并行执行模式，我们可以简单地重用我们在 *Promises* 部分的 *有限并行执行* 子部分中创建的 `TaskQueue`
    类。我们可以直接使用它，或者将其内部转换为 async/await。将 `TaskQueue` 类转换为 async/await 是一个简单的操作，我们将把它留给你作为练习。无论如何，`TaskQueue`
    的外部接口不应改变；两种实现都将有一个返回 `Promise` 的 `runTask()` 方法，该 `Promise` 在任务被队列运行时解决。
- en: Starting from this assumption, converting the web spider v4 from promises to
    async/await is also a trivial task and we won't show all the steps here as we
    wouldn't be learning anything new. Instead, what we'll do in this section is examine
    a third variation of the `TaskQueue` class that uses async/await and a **producer-consumer**
    approach.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个假设出发，将网络爬虫 v4 从 promises 转换为 async/await 也是一个简单的任务，我们在这里不会展示所有步骤，因为我们不会学到任何新东西。相反，在本节中，我们将检查
    `TaskQueue` 类的第三个变体，它使用 async/await 和 **生产者-消费者** 方法。
- en: 'The general idea to apply this approach to our problem goes as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种方法应用于我们问题的通用思路如下：
- en: On one side, we have an unknown set of *producers* adding tasks into a queue.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一方面，我们有一个未知的 *生产者* 集合，它们将任务添加到队列中。
- en: On the other side, we have a predefined set of *consumers*, responsible for
    extracting and executing the tasks from the queue, one at a time.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一方面，我们有一个预定义的 *消费者* 集合，负责一次提取和执行队列中的任务。
- en: 'The following diagram should help us understand the setup:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表应该有助于我们理解设置：
- en: '![](img/B15729_05_02.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2](img/B15729_05_02.png)'
- en: 'Figure 5.2: Using the Producer-Consumer pattern to implement limited parallel
    execution'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：使用生产者-消费者模式实现有限并行执行
- en: The number of consumers will determine the concurrency with which the tasks
    will be executed. The challenge here is to put the consumers to "sleep" when the
    queue is empty and "wake them up" again when there are new tasks to run. But we
    are lucky, since Node.js is single-threaded, so putting a task to "sleep" just
    means giving back control to the event loop, while "resuming" a task is equivalent
    to invoking a callback.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者的数量将决定执行任务的并发性。这里的挑战是在队列为空时将消费者“休眠”，并在有新任务要运行时再次“唤醒”他们。但我们是幸运的，因为Node.js是单线程的，所以将任务“休眠”只是将控制权交还给事件循环，而“恢复”任务相当于调用一个回调。
- en: 'With this in mind, let''s then take a look at some code. We will create a new
    class called `TaskQueuePC` with a public interface similar to one of the `TaskQueue`
    classes we implemented previously in this chapter. Taking a top-down approach,
    let''s see how we can implement the constructor:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看看一些代码。我们将创建一个新的类，称为`TaskQueuePC`，它有一个与我们在本章之前实现的一个`TaskQueue`类类似的公共接口。采用自顶向下的方法，让我们看看我们如何实现构造函数：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First of all, we can notice that we now have two queues, one to hold our tasks
    (`taskQueue`) and the other to store our sleeping consumers (`consumerQueue`).
    It will be clearer in a while how these queues will be used. In the second part
    of our constructor, we spawn as many consumers as the concurrency we want to attain.
    Let''s see what a consumer looks like:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以注意到我们现在有两个队列，一个用于存储我们的任务（`taskQueue`），另一个用于存储我们的休眠消费者（`consumerQueue`）。在不久的将来，我们将更清楚地了解这些队列的用途。在我们构造函数的第二部分，我们生成与我们要达到的并发性一样多的消费者。让我们看看消费者是什么样的：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our consumer is an infinite `while` loop (1). At each iteration, we try to retrieve
    a new task from the queue using `getNextTask()` (2). As we will see, this will
    cause the current consumer to sleep if the queue is empty. When a new `task` is
    eventually available, we just execute it (3). Any error thrown from the above
    operation should not cause the consumer to stop, so we simply log it (4) and continue
    with the next iteration.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消费者是一个无限`while`循环（1）。在每次迭代中，我们尝试使用`getNextTask()`（2）从队列中检索一个新的任务。正如我们将看到的，如果队列为空，这将导致当前消费者休眠。当最终有新的`task`可用时，我们只需执行它（3）。上述操作抛出的任何错误都不应导致消费者停止，所以我们只是记录它（4）并继续下一迭代。
- en: By the look of it, it may seem that each consumer in `TaskQueuePC` is an actual
    thread. In fact, our `consumer()` function has an infinite loop and it can "pause"
    until awakened by some other "thread." In reality, we should not forget that each
    consumer is an async function, which is nothing more than a nice syntax built
    around promises and callbacks. The `while` loop may seem to be spinning continuously
    consuming CPU cycles, but under the hood, the loop is more similar to an asynchronous
    recursion than a traditional `while` loop.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从外观上看，它可能看起来`TaskQueuePC`中的每个消费者都是一个实际的线程。实际上，我们的`consumer()`函数有一个无限循环，并且它可以“暂停”直到被某个其他“线程”唤醒。实际上，我们不应忘记每个消费者都是一个异步函数，这不过是围绕promises和callbacks构建的一个好语法。`while`循环看起来可能是在持续消耗CPU周期，但实际上，这个循环在底层更类似于异步递归，而不是传统的`while`循环。
- en: 'With the next code fragment, we should start to get an idea of what''s going
    on. Let''s take a look at the implementation of `getNextTask()`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过下一个代码片段，我们应该开始了解正在发生的事情。让我们看看`getNextTask()`的实现：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `getNextTask()` method returns a new `Promise` that resolves with the first
    task in the queue if the queue is not empty. The first task is removed from `taskQueue`
    and used as an argument to invoke `resolve` (1). If the queue is instead empty,
    we postpone the resolution of the `Promise` by queuing the `resolve` callback
    into the `consumerQueue`. This will effectively put the `Promise`—and the consumer
    that is awaiting the `Promise`—to sleep.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNextTask()`方法返回一个新`Promise`，如果队列为空，则解析为队列中的第一个任务。第一个任务从`taskQueue`中移除并用作调用`resolve`（1）的参数。如果队列是空的，我们将通过将`resolve`回调排队到`consumerQueue`中推迟`Promise`的解析。这将有效地使`Promise`——以及等待`Promise`的消费者——休眠。'
- en: 'Now comes the "gluing" part of the whole `TaskQueuePC` class, which corresponds
    to the *producer* side of the algorithm. That''s implemented in the `runTask()`
    method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是整个`TaskQueuePC`类的“粘合”部分，这对应于算法的*生产者*端。这是在`runTask()`方法中实现的：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, we create a `taskWrapper` function (1) that, when executed, has the responsibility
    for running the input `task` and forwarding the status of the `Promise` returned
    by `task()` to the outer `Promise` returned by `runTask()`. Next, if the `consumerQueue`
    is not empty (2), it means that there is at least one consumer that is asleep,
    waiting for new tasks to run. We then extract the first consumer from the queue
    (remember, that's essentially the `resolve` callback of the `Promise` returned
    by `getNextTask()`) and we invoke it immediately by passing our `taskWrapper`.
    If, instead, all the consumers are already busy (3), we push `taskWrapper` into
    the `taskQueue`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `taskWrapper` 函数（1），当执行时，它负责运行输入的 `task` 并将 `task()` 返回的 `Promise`
    的状态转发给 `runTask()` 返回的外部 `Promise`。接下来，如果 `consumerQueue` 不为空（2），这意味着至少有一个消费者正在休眠，等待运行新任务。然后我们从队列中提取第一个消费者（记住，这本质上是由
    `getNextTask()` 返回的 `Promise` 的 `resolve` 回调）并立即通过传递 `taskWrapper` 来调用它。如果所有消费者都已经忙碌（3），我们将
    `taskWrapper` 推入 `taskQueue`。
- en: This concludes the implementation of our `TaskQueuePC` class. The public interface
    of the `TaskQueuePC` class is identical to that of the `TaskQueue` class that
    we implemented in the *Promises* section, so migrating the code of our web spider
    to the new algorithm will be a trivial task.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们 `TaskQueuePC` 类的实现完成。`TaskQueuePC` 类的公共接口与我们之前在 *Promises* 部分实现的 `TaskQueue`
    类的接口相同，因此将我们的网络爬虫代码迁移到新算法将是一个简单的任务。
- en: This also concludes our exploration of the async/await construct. But, before
    we wrap up the chapter, we'll dive into a subtle problem affecting promises.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这也标志着我们对 async/await 构造的探索结束。但在我们结束本章之前，我们将深入探讨一个影响 promises 的微妙问题。
- en: The problem with infinite recursive promise resolution chains
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限递归 promise 解析链的问题
- en: At this point in the chapter, you should have a strong understanding of how
    promises work and how to use them to implement the most common control flow constructs.
    This is therefore the right time to discuss an advanced topic that every professional
    Node.js developer should know and understand. This advanced topic is about a memory
    leak caused by infinite `Promise` resolution chains. The bug seems to affect the
    actual Promises/A+ specification, so no compliant implementation is immune.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对 promises 的工作原理以及如何使用它们来实现最常见的控制流结构有了深刻的理解。因此，现在是讨论每个专业 Node.js 开发者都应该了解和理解的高级主题的正确时机。这个高级主题是关于由无限
    `Promise` 解析链引起的内存泄漏。这个错误似乎影响了实际的 Promises/A+ 规范，因此没有任何符合规范的实现可以免疫。
- en: It is quite common in programming to have tasks that don't have a predefined
    ending or take as an input a potentially infinite array of data. We can include
    in this category things like the encoding/decoding of live audio/video streams,
    the processing of live cryptocurrency market data, and the monitoring of IoT sensors.
    But we can have much more trivial situations than those, for example, when making
    heavy use of functional programming.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，有许多任务没有预定义的结束或接受一个可能无限的数据数组作为输入的情况是很常见的。我们可以将以下内容包括在内，例如实时音频/视频流的编码/解码、实时加密货币市场数据的处理以及物联网传感器的监控。但我们可以有比这些更简单的情况，例如在大量使用函数式编程时。
- en: 'To take a simple example, let''s consider the following code, which defines
    a simple infinite operation using promises:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的例子来说明，让我们考虑以下代码，它使用 promises 定义了一个简单的无限操作：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `leakingLoop()` function that we just defined uses the `delay()` function
    (which we created at the beginning of this chapter) to simulate an asynchronous
    operation. When the given number of milliseconds has elapsed, we print the current
    timestamp and we invoke `leakingLoop()` recursively to start the operation over
    again. The interesting part is that the `Promise` returned by `leakingLoop()`
    never resolves because its status depends on the next invocation of `leakingLoop()`,
    which in turn depends on the next invocation of `leakingLoop()` and so on. This
    situation creates a chain of promises that never settle, and it will cause a memory
    leak in `Promise` implementations that strictly follow the Promises/A+ specification,
    including JavaScript ES6 promises.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义的 `leakingLoop()` 函数使用我们本章开头创建的 `delay()` 函数来模拟异步操作。当指定的毫秒数已过去时，我们打印当前的时间戳，并递归地调用
    `leakingLoop()` 以重新开始操作。有趣的部分是，`leakingLoop()` 返回的 `Promise` 永远不会解析，因为它的状态取决于
    `leakingLoop()` 的下一次调用，而 `leakingLoop()` 的下一次调用又取决于 `leakingLoop()` 的下一次调用，如此循环。这种情况创建了一个永远不会解决的承诺链，它将导致严格遵循
    Promises/A+ 规范的 `Promise` 实现中发生内存泄漏，包括 JavaScript ES6 promises。
- en: 'To demonstrate the leak, we can try running the `leakingLoop()` function many
    times to accentuate the effects of the leak:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示泄漏，我们可以尝试多次运行 `leakingLoop()` 函数，以强调泄漏的效果：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Then we can take a look at the memory footprint of the process using our favorite
    process inspector and notice how it grows indefinitely until (after a few minutes)
    the process crashes entirely.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用我们喜欢的进程检查器查看进程的内存占用情况，并注意到它无限增长，直到（几分钟之后）进程完全崩溃。
- en: The solution to the problem is to break the chain of `Promise` resolution. We
    can do that by making sure that the status of the `Promise` returned by `leakingLoop()`
    does not depend on the promise returned by the next invocation of `leakingLoop()`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是打断 `Promise` 解析的链。我们可以通过确保 `leakingLoop()` 返回的 `Promise` 的状态不依赖于 `leakingLoop()`
    下一次调用的返回的 `Promise` 来实现这一点。
- en: 'We can ensure that by simply removing a `return` instruction:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地移除一个 `return` 指令来确保这一点：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, if we use this new function in our sample program, we should see that the
    memory footprint of the process will go up and down, following the schedule of
    the various runs of the garbage collector, which means that there is no memory
    leak.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在这个示例程序中使用这个新函数，我们应该看到进程的内存占用会随着垃圾收集器的各种运行计划上下波动，这意味着没有内存泄漏。
- en: 'However, the solution we have just proposed radically changes the behavior
    of the original `leakingLoop()` function. In particular, this new function won''t
    propagate eventual errors produced deeply within the recursion, since there is
    no link between the status of the various promises. This inconvenience may be
    mitigated by adding some extra logging within the function. But sometimes the
    new behavior itself may not be an option. So, a possible solution involves wrapping
    the recursive function with a `Promise` constructor, such as in the following
    code sample:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们刚刚提出的解决方案彻底改变了原始 `leakingLoop()` 函数的行为。特别是，这个新函数不会传播递归深处产生的任何错误，因为各种 `Promise`
    的状态之间没有联系。这种不便可以通过在函数中添加一些额外的日志来缓解。但有时新的行为本身可能不是一个选择。因此，一个可能的解决方案是将递归函数用 `Promise`
    构造函数包装起来，如下面的代码示例所示：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, we still don't have any link between the promises created at the
    various stages of the recursion; however, the `Promise` returned by the `nonLeakingLoopWithErrors()`
    function will still reject if any asynchronous operation fails, no matter at what
    depth in the recursion that happens.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们仍然在递归的各个阶段创建的 `Promise` 之间没有任何联系；然而，`nonLeakingLoopWithErrors()` 函数返回的
    `Promise` 仍然会在任何异步操作失败时拒绝，无论在递归的哪个深度发生。
- en: 'A third solution makes use of async/await. In fact, with async/await we can
    *simulate* a recursive `Promise` chain with a simple infinite `while` loop, such
    as the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个解决方案利用了 async/await。实际上，使用 async/await 我们可以通过一个简单的无限 `while` 循环来 *模拟* 递归的
    `Promise` 链，如下所示：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this function too, we preserve the behavior of the original recursive function,
    whereby any error thrown by the asynchronous task (in this case `delay()`) is
    propagated to the original function caller.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们也保留了原始递归函数的行为，即任何由异步任务（在这种情况下为 `delay()`）抛出的错误都会传播到原始函数调用者。
- en: 'We should note that we would still have a memory leak if instead of a `while`
    loop, we chose to implement the async/await solution with an actual asynchronous
    recursive step, such as the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，如果我们选择用实际的异步递归步骤（如下所示）而不是 `while` 循环来实现 async/await 解决方案，我们仍然会有内存泄漏：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The code above would still create an infinite chain of promises that never resolve
    and therefore it's still affected by the same memory leak issue of the equivalent
    promise-based implementation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仍然会创建一个无限循环的 `Promise` 链，这些 `Promise` 永远不会解析，因此仍然受到等效基于 Promise 的实现相同的内存泄漏问题的影响。
- en: If you are interested in knowing more about the memory leak discussed in this
    section, you can check the related Node.js issue at [nodejsdp.link/node-6673](http://nodejsdp.link/node-6673)
    or the related issue on the Promises/A+ GitHub repository at [nodejsdp.link/promisesaplus-memleak](http://nodejsdp.link/promisesaplus-memleak).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于本节中讨论的内存泄漏信息，你可以查看相关的 Node.js 问题 [nodejsdp.link/node-6673](http://nodejsdp.link/node-6673)
    或 Promises/A+ GitHub 仓库中的相关问题 [nodejsdp.link/promisesaplus-memleak](http://nodejsdp.link/promisesaplus-memleak)。
- en: So, the next time you are building an infinite promise chain, remember to double-check
    if there are the conditions for creating a memory leak, as you learned in this
    section. If that's the case, you can apply one of the proposed solutions, making
    sure to choose the one that is best suited to your context.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下次你在构建无限承诺链时，记得要仔细检查是否存在创建内存泄漏的条件，正如你在本节中学到的。如果是这样，你可以应用所提出的解决方案之一，确保选择最适合你上下文的那一个。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned how to use promises and async/await syntax to
    write asynchronous code that is more concise, cleaner, and easier to read.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用承诺和async/await语法来编写更简洁、更清晰、更易于阅读的异步代码。
- en: As we've seen, promises and async/await greatly simplify the serial execution
    flow, which is the most commonly used control flow. In fact, with async/await,
    writing a sequence of asynchronous operations is almost as easy as writing synchronous
    code. Running some asynchronous operations in parallel is also very easy thanks
    to the `Promise.all()` utility.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，承诺和async/await极大地简化了串行执行流程，这是最常用的控制流程。事实上，使用async/await，编写一系列异步操作几乎与编写同步代码一样容易。由于`Promise.all()`实用工具，并行运行一些异步操作也非常容易。
- en: But the advantages of using promises and async/await don't stop here. We've
    learned that they provide a transparent shield against tricky situations such
    as code with mixed synchronous/asynchronous behavior (a.k.a. Zalgo, which we discussed
    in *Chapter 3*, *Callbacks and Events*). On top of that, error management with
    promises and async/await is much more intuitive and leaves less room for mistakes
    (such as forgetting to forward errors, which is a serious source of bugs in code
    using callbacks).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用承诺和async/await的优势并不仅限于此。我们已经了解到，它们提供了一种透明的防护，可以防止代码中混合同步/异步行为等棘手情况（即我们在*第3章*，*回调和事件*中讨论的Zalgo）。除此之外，使用承诺和async/await的错误管理要直观得多，并且出错的机会更少（例如，忘记转发错误，这是使用回调的代码中严重的错误来源）。
- en: In terms of patterns and techniques, we should definitely keep in mind the chain
    of promises (to run tasks in series), promisification, and the Producer-Consumer
    pattern. Also, pay attention when using `Array.forEach()` with async/await (you
    are probably doing it wrong) and keep in mind the difference between a simple
    `return` and `return await` in async functions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式和技巧方面，我们绝对应该记住承诺链（用于串行运行任务）、承诺化和生产者-消费者模式。同时，注意在使用`Array.forEach()`与async/await（你可能做错了）时，并记住在异步函数中简单`return`和`return
    await`之间的区别。
- en: Callbacks are still widely used in the Node.js and JavaScript world. We find
    them in legacy APIs, in code that interacts with native libraries, or when there
    is the need to micro-optimize particular routines. That's why they are still relevant
    to us, Node.js developers; however, for most of our day-to-day programming tasks,
    promises and async/await are a huge step ahead compared to callbacks and therefore
    they are now the de facto standard for dealing with asynchronous code in Node.js.
    That's why we will be using promises and async/await throughout the rest of the
    book too to write our asynchronous code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js和JavaScript的世界中，回调仍然被广泛使用。我们在遗留API中找到它们，在与本地库交互的代码中，或者在需要微优化特定例程时。这就是为什么它们对我们这些Node.js开发者来说仍然很重要；然而，对于我们的大多数日常编程任务来说，与回调相比，承诺和async/await是一个巨大的进步，因此它们现在是Node.js中处理异步代码的事实标准。这就是为什么我们将在本书的其余部分也使用承诺和async/await来编写我们的异步代码。
- en: In the next chapter, we will explore another fascinating topic relative to asynchronous
    code execution, which is also another fundamental building block in the whole
    Node.js ecosystem, that is, streams.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨与异步代码执行相关的一个令人着迷的主题，这同样是整个Node.js生态系统中的另一个基本构建块，即流。
- en: Exercises
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**5.1 Dissecting** `Promise.all()`: Implement your own version of `Promise.all()`
    leveraging promises, async/await, or a combination of the two. The function must
    be functionally equivalent to its original counterpart.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5.1 解构** `Promise.all()`：利用承诺、async/await或两者的组合实现自己的`Promise.all()`版本。该函数必须在功能上与其原始对应版本等效。'
- en: '**5.2** `TaskQueue` **with promises**: Migrate the `TaskQueue` class internals
    from promises to async/await where possible. Hint: you won''t be able to use async/await
    everywhere.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5.2** 使用承诺的`TaskQueue`：尽可能将`TaskQueue`类的内部实现从承诺迁移到async/await。提示：你不可能在所有地方都使用async/await。'
- en: '**5.3 Producer-consumer with promises**: Update the `TaskQueuePC` class internal
    methods so that they use just promises, removing any use of the async/await syntax.
    Hint: the infinite loop must become an asynchronous recursion. Beware of the recursive
    `Promise` resolution memory leak!'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5.3 基于Promise的生产者-消费者模式**：更新`TaskQueuePC`类的内部方法，使其仅使用Promise，移除任何async/await语法的使用。提示：无限循环必须变为异步递归。注意递归`Promise`解析内存泄漏！'
- en: '**5.4 An asynchronous** `map()`: Implement a parallel asynchronous version
    of `Array.map()` that supports promises and a concurrency limit. The function
    should not directly leverage the `TaskQueue` or `TaskQueuePC` classes we presented
    in this chapter, but it can use the underlying patterns. The function, which we
    will define as `mapAsync(iterable, callback, concurrency)`, will accept the following
    as inputs:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5.4 异步的`map()`函数**：实现一个支持Promise和并发限制的并行异步版本的`Array.map()`。该函数不应直接利用本章中我们介绍的`TaskQueue`或`TaskQueuePC`类，但它可以使用底层模式。我们将定义的函数为`mapAsync(iterable,
    callback, concurrency)`，它将接受以下作为输入：'
- en: An `iterable`, such as an array.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`iterable`，例如一个数组。
- en: A `callback`, which will receive as the input each item of the iterable (exactly
    like in the original `Array.map()`) and can return either a `Promise` or a simple
    value.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`callback`，它将接收可迭代对象中的每个项目作为输入（与原始的`Array.map()`完全一样）并可以返回一个`Promise`或一个简单的值。
- en: A `concurrency`, which defines how many items in the iterable can be processed
    by `callback` in parallel at each given time.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`concurrency`，它定义了在每次给定时间点`callback`可以并行处理的可迭代对象中的项目数量。
