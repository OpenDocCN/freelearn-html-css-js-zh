- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Loops
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'We are starting to get a good basic grasp of JavaScript. This chapter will
    focus on a very important control flow concept: loops. Loops execute a code block
    a certain number of times. We can use loops to do many things, such as repeating
    operations a number of times and iterating over data sets, arrays, and objects.
    Whenever you feel the need to copy a little piece of code and place it right underneath
    where you copied it from, you should probably be using a loop instead.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始对JavaScript有一个很好的基本掌握。本章将重点介绍一个非常重要的控制流概念：循环。循环执行代码块一定次数。我们可以使用循环做很多事情，例如重复操作多次以及遍历数据集、数组和对象。每次当你觉得需要复制一小段代码并将其放置在复制的下方时，你可能应该使用循环。
- en: We will first discuss the basics of loops, then continue to discuss nesting
    loops, which is basically using loops inside loops. Also, we will explain looping
    over two complex constructs we have seen, arrays and objects. And finally, we
    will introduce two keywords related to loops, `break` and `continue`, to control
    the flow of the loop even more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论循环的基础知识，然后继续讨论嵌套循环，这基本上是在循环内部使用循环。此外，我们还将解释如何遍历我们已看到的两个复杂结构，数组和对象。最后，我们将介绍与循环相关的两个关键字，`break`和`continue`，以进一步控制循环的流程。
- en: There is one topic that is closely related to loops that is not in this chapter.
    This is the built-in `foreach` method. We can use this method to loop over arrays,
    when we can use an arrow function. Since we won't discuss these until the next
    chapter, `foreach` is not included here.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个与循环密切相关的话题，但不在本章中。这是内置的`foreach`方法。当我们可以使用箭头函数时，我们可以使用此方法遍历数组。由于我们将在下一章讨论这些内容，因此`foreach`不包括在内。
- en: 'These are the different loops we will be discussing in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下不同的循环：
- en: '`while` loop'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: '`do` `while` loop'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do` `while`循环'
- en: '`for` loop'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: '`for` `in`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` `in`'
- en: '`for of` loop'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for of`循环'
- en: 'Note: exercise, project, and self-check quiz answers can be found in the *Appendix*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：练习、项目和自我检查测验的答案可以在*附录*中找到。
- en: while loops
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `while` loop will only be executed as long as the condition is `true`, so
    if the condition is `false` to begin with, the code inside will be skipped.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环只有在条件为`true`时才会执行，所以如果一开始条件就是`false`，则代码内部将被跳过。'
- en: 'Here is a very simple example of a `while` loop printing the numbers 0 to 10
    (excluding 10) to the console:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的`while`循环示例，将数字0到10（不包括10）打印到控制台：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output will be as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These are the steps happening here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生以下步骤：
- en: Create a variable, `i`, and set its value to zero
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量`i`并将其值设置为0
- en: Start the `while` loop and check the condition that the value of `i` is smaller
    than 10
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始`while`循环并检查`i`的值是否小于10的条件
- en: Since the condition is true, the code logs `i` and increases `i` by 1
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于条件为真，代码记录了`i`并增加`i`的值1
- en: The condition gets evaluated again; 1 is still smaller than 10
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件再次被评估；1仍然小于10
- en: Since the condition is true, the code logs `i` and increases `i` by 1
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于条件为真，代码记录了`i`并增加`i`的值1
- en: The logging and increasing continues until `i` becomes 10
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录和增加会持续到`i`变为10
- en: 10 is not smaller than 10, so the loop ends
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10不小于10，所以循环结束
- en: 'We can have a `while` loop that looks for a value in an array, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个`while`循环来在数组中查找值，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It checks whether the first value of the array is a certain value, and when
    it is not, it deletes that value from the array using the `shift` method. Remember
    this method? It removes the first element of the array. So, by the next iteration,
    the first value has changed and is checked again. If it stumbles upon the value,
    it will log this to the console and change the Boolean `notFound` to `false`,
    because it has found it. That was the last iteration and the loop is done. It
    will output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查数组的第一个值是否是某个特定的值，如果不是，它将使用`shift`方法从数组中删除该值。你还记得这个方法吗？它移除数组的第一个元素。所以，在下一次迭代中，第一个值已经改变并再次进行检查。如果它偶然发现该值，它将记录到控制台并将布尔值`notFound`更改为`false`，因为它已经找到了它。那将是最后一次迭代，循环结束。它将输出：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Why do you think the `&& someArray.length > 0` is added in the `while` condition?
    If we were to leave it out, and the value we were looking for was not in the array,
    we would get stuck in an infinite loop. This is why we make sure that we also
    end things if our value is not present, so our code can continue.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么认为在`while`条件中添加了`&& someArray.length > 0`？如果我们省略它，并且我们正在寻找的值不在数组中，我们就会陷入无限循环。这就是为什么我们确保如果我们的值不存在，我们也会结束，这样我们的代码就可以继续。
- en: 'But we can also do more sophisticated things very easily with loops. Let''s
    see how easy it is to fill an array with the Fibonacci sequence using a loop:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以很容易地使用循环做更复杂的事情。让我们看看使用循环填充斐波那契数列到数组有多容易：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the Fibonacci sequence, each value is the sum of the two previous values,
    starting with the values 0 and 1\. We can do this in a `while` loop as stated
    above. We create two numbers and they change every iteration. We have limited
    our number of iterations to the length of the `fibonacciArray`, because we don't
    want an infinite loop. In this case the loop will be done as soon as the length
    of the array is no longer smaller than 25\.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在斐波那契数列中，每个值都是前两个值的和，从0和1开始。我们可以像上面所述的那样使用while循环来做这件事。我们创建两个数字，它们在每次迭代中都会改变。我们限制了迭代的次数，使其等于`fibonacciArray`的长度，因为我们不希望出现无限循环。在这种情况下，循环将在数组的长度不再小于25时结束。
- en: We need a temporary variable that stores the next value for `nr2`. And every
    iteration we push the value of the first number to the array. If we log the array,
    you can see the numbers getting rather high very quickly. Imagine having to generate
    these values one by one in your code!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个临时变量来存储`nr2`的下一个值。在每次迭代中，我们将第一个数字的值推送到数组中。如果你记录数组，你会看到数字会非常快地变得相当高。想象一下，你需要在代码中逐个生成这些值！
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Practice exercise 5.1
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.1
- en: In this exercise we will create a number guessing game that takes user input
    and replies based on how accurate the user's guess was.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个数字猜谜游戏，该游戏根据用户的猜测准确性进行回复。
- en: Create a variable to be used as the max value for the number guessing game.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量作为数字猜谜游戏的最大值。
- en: Generate a random number for the solution using `Math.random()` and `Math.floor()`.
    You will also need to add 1 so that the value is returned as 1-[whatever the set
    max value is]. You can log this value to the console for development to see the
    value as you create the game, then when the game is complete you can comment out
    this console output.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Math.random()`和`Math.floor()`生成一个随机数作为解。你还需要添加1，以便返回的值是1-[设置的任何最大值]。你可以将此值记录到控制台以供开发查看，当游戏完成时，你可以取消注释此控制台输出。
- en: Create a variable that will be used for tracking whether the answer is correct
    or not and set it to a default Boolean value of `false`. We can update it to be
    `true` if the user guess is a match.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量用于跟踪答案是否正确，并将其设置为默认的布尔值`false`。如果用户的猜测匹配，我们可以将其更新为`true`。
- en: Use a `while` loop to iterate a prompt that asks the user to enter a number
    between 1 and 5, and convert the response into a number in order to match the
    data type of the random number.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用while循环迭代一个提示，要求用户输入一个介于1和5之间的数字，并将响应转换为数字，以匹配随机数的数据类型。
- en: Inside the `while` loop, check using a condition to see if the prompt value
    is equal to the solution number. Apply logic such that if the number is correct,
    you set the status to `true` and break out of the loop. Provide the player with
    some feedback as to whether the guess was high or low, and initiate another prompt
    until the user guesses correctly. In this way we use the loop to keep asking until
    the solution is correct, and at that point we can stop the iteration of the block
    of code.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在while循环内部，使用条件检查提示值是否等于解的数字。应用逻辑，如果数字正确，将状态设置为`true`并退出循环。向玩家提供一些反馈，说明猜测是高还是低，并启动另一个提示，直到用户猜正确为止。这样我们使用循环不断提问，直到解正确，然后我们可以停止代码块的迭代。
- en: do while loops
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do while循环
- en: 'In some cases, you really need the code block to be executed at least once.
    For example, if you need valid user input, you need to ask at least once. The
    same goes for trying to connect with a database or some other external source:
    you will have to do so at least once in order for it to be successful. And you
    will probably need to do so as long as you did not get the result you needed.
    In these cases, you can use a **do while loop**.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你确实需要至少执行一次代码块。例如，如果你需要有效的用户输入，你需要至少询问一次。同样，尝试连接数据库或其他外部源也是如此：你必须至少尝试一次才能成功。而且你可能需要一直这样做，直到你得到所需的结果。在这些情况下，你可以使用**do
    while循环**。
- en: 'Here is what the syntax looks like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是语法示例：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It executes what is within the `do` block, and then after that it evaluates
    the `while`. If the condition is `true`, it will execute what is in the `do` block
    again. It will continue to do so until the condition in the `while` changes to
    `false`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它执行`do`块内的内容，然后执行`while`。如果条件为`true`，它将再次执行`do`块内的内容。它将继续这样做，直到`while`中的条件变为`false`。
- en: We can use the `prompt()` method to get user input. Let's use a `do while` loop
    to ask the user for a number between 0 and 100.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`prompt()`方法获取用户输入。让我们使用`do while`循环来要求用户输入一个介于0和100之间的数字。
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here is the output; you will have to enter the number in the console yourself
    here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出；您将需要在这里自己输入控制台中的数字。
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Everything behind the `>` is user input here. The `>` is part of the code; it
    is added by the console to make the distinction between console output (`Please
    enter a number between 0 and 100`) and the console input (`-50`, `150`, and `34`)
    clearer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`后面的所有内容都是用户输入。`>`是代码的一部分；它是控制台添加的，以使控制台输出（`请输入一个介于0和100之间的数字`）和控制台输入（`-50`、`150`和`34`）之间的区别更清晰。'
- en: It asks three times, because the first two times the number was not between
    0 and 100 and the condition in the `while` block was true. With `34`, the condition
    in the `while` block became false and the loop ended.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它询问三次，因为前两次数字不在0到100之间，`while`块中的条件为真。当输入`34`时，`while`块中的条件变为假，循环结束。
- en: Practice exercise 5.2
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.2
- en: In this exercise, we will create a basic counter that will increase a dynamic
    variable by a consistent step value, up to an upper limit.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个基本的计数器，它将通过一个一致的步长值增加动态变量，直到上限。
- en: Set the starting counter to 0
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将起始计数器设置为0
- en: Create a variable, `step`, to increase your counter by
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，`step`，用于增加计数器
- en: Add a `do while` loop, printing the counter to the console and incrementing
    it by the `step` amount each loop
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`do while`循环，将计数器打印到控制台，并在每次循环中增加`step`的值
- en: Continue to loop until the counter is equal to 100 or more than 100
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续循环，直到计数器等于100或超过100
- en: for loops
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: '**for loops** are special loops. The syntax might be a little bit confusing
    at first, but you will find yourself using them soon, because they are very useful.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**`for`循环**是特殊的循环。语法可能一开始有点令人困惑，但您很快就会发现自己会使用它们，因为它们非常有用。'
- en: 'Here is what the syntax looks like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是语法看起来像什么：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Between the parentheses following the `for` statement, there are three parts,
    separated by semi-colons. The first one initializes the variables that can be
    used in the `for` loop. The second one is a condition: as long as this condition
    is true, the loop will keep on iterating. This condition gets checked after initializing
    the variables before the first iteration (this will only take place when the condition
    evaluates to true). The last one is a statement. This statement gets executed
    after every iteration. Here is the flow of a `for` loop:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`语句后面的括号中，有三个部分，由分号分隔。第一个部分初始化可以在`for`循环中使用的变量。第二个部分是一个条件：只要这个条件为真，循环就会继续迭代。这个条件在第一次迭代之前检查变量初始化（这只会发生在条件评估为真时）。最后一个部分是一个语句。这个语句在每次迭代后执行。以下是`for`循环的流程：
- en: Initialize the variables.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化变量。
- en: Check the condition.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查条件。
- en: If the condition is true, execute the code block. If the condition is false,
    the loop will end here.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果条件为真，则执行代码块。如果条件为假，循环将在这里结束。
- en: Perform the statement (the third part, for example, `i++`).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行语句（例如，第三部分`i++`）。
- en: Go back to step 2.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到步骤2。
- en: 'This is a simple example that logs the numbers 0 to 10 (excluding 10) to the
    console:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，将数字0到10（不包括10）记录到控制台：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It starts by creating a variable, `i`, and sets this to `0`. Then it checks
    whether `i` is smaller than 10\. If it is, it will execute the log statement.
    After this, it will execute `i++` and increase `i` by one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先创建一个变量`i`，并将其设置为`0`。然后它检查`i`是否小于10。如果是，它将执行日志语句。之后，它将执行`i++`并增加`i`的值。
- en: If we don't increase `i`, we will get stuck in an infinite loop, since the value
    of `i` would not change and it would be smaller than 10 forever. This is something
    to look out for in all loops!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不增加`i`，我们将陷入无限循环，因为`i`的值将不会改变，并且将永远小于10。这是在所有循环中需要注意的事情！
- en: The condition gets checked again. And this goes on until `i` reaches a value
    of 10\. 10 is not smaller than 10, so the loop is done executing and the numbers
    0 to 9 have been logged to the console.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 条件再次被检查。然后继续，直到`i`达到10的值。10不小于10，所以循环完成执行，数字0到9已经记录到控制台。
- en: 'We can also use a `for` loop to create a sequence and add values to an array,
    like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`for`循环创建一个序列并将值添加到数组中，如下所示：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is what the array looks like after this loop:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是循环之后的数组看起来像什么：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the loop ran the block of code 100 times, starting with an initial value
    of 0 for `i`, the block of code will add the incrementing value into the array
    at the end of the array. This results in an array that has a count of 0–99 and
    a length of 100 items. Since arrays start with an index value of zero, the values
    in the array will actually match up with the index values of the items in the
    array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于循环运行了100次代码块，从`i`的初始值0开始，代码块将在数组的末尾添加递增的值。这导致一个计数为0–99且长度为100项的数组。由于数组从索引值0开始，数组中的值实际上与数组中项的索引值相匹配。
- en: 'Or we could create an array containing only even values:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以创建一个只包含偶数值的数组：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Resulting in this array:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这个数组：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Most commonly, you will see `i++` as the third part of the `for` loop, but please
    note that you can write any statement there. In this case, we are using `i = i
    + 2` to add 2 to the previous value every time, creating an array with only even
    numbers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是，你会看到`i++`作为`for`循环的第三部分，但请注意，你可以在那里写任何语句。在这种情况下，我们使用`i = i + 2`来每次将2加到前一个值上，创建一个只包含偶数的数组。
- en: Practice exercise 5.3
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.3
- en: In this exercise we will use a `for` loop to create an array that holds objects.
    Starting with creating a blank array, the block of code within the loop will create
    an object that gets inserted into the array.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`for`循环创建一个包含对象的数组。从创建一个空数组开始，循环内的代码块将创建一个被插入到数组中的对象。
- en: Setup a blank array, `myWork`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个空数组，`myWork`。
- en: 'Using a `for` loop, create a list of 10 objects, each of which is a numbered
    lesson (e.g. Lesson 1, Lesson 2, Lesson 3….) with an alternating `true`/`false`
    status for every other item to indicate whether the class will be running this
    year. For example:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环创建一个包含10个对象的列表，每个对象都是一个编号的课程（例如，课程1、课程2、课程3……），每个其他项目交替`true`/`false`状态以指示该课程是否将在今年运行。例如：
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can specify the status by using a ternary operator that checks whether the
    modulo of the given lesson value is equal to zero and by setting up a Boolean
    value to alternate the values each iteration.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过使用三元运算符来指定状态，该运算符检查给定课程值的模是否等于零，并设置一个布尔值以在每个迭代中交替值。
- en: Create a lesson using a temporary object variable, containing the name (`lesson`
    with the numeric value) and predefined status (which we set up in the previous
    step).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个临时对象变量创建一个课程，包含名称（`lesson`带有数值）和预定义的状态（我们在上一步中设置）。
- en: Push the objects to the `myWork` array.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象推送到`myWork`数组。
- en: Output the array to the console.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组输出到控制台。
- en: Nested loops
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套循环
- en: Sometimes it can be necessary to use a loop inside a loop. A loop inside a loop
    is called a nested loop. Often it is not the best solution to the problem. It
    could even be a sign of poorly written code (sometimes called "code smell" among
    programmers), but every now and then it is a perfectly fine solution to a problem.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在循环内部使用循环可能是必要的。循环内部的循环被称为嵌套循环。通常，这并不是解决问题的最佳方案。它甚至可能是代码编写不佳的迹象（在程序员中有时被称为“代码异味”），但偶尔它是一个完美的解决方案。
- en: 'Here is what it would look like for `while` loops:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`while`循环的示例：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Nesting can also be used with `for` loops, or with a combination of both `for`
    and `while`, or even with all kinds of loops; they can go several levels deep.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套也可以与`for`循环一起使用，或者与`for`和`while`的组合一起使用，甚至可以与所有类型的循环一起使用；它们可以深入几个层级。
- en: An example in which we might use nested loops would be when we want to create
    an array of arrays. With the outer loop, we create the top-level array, and with
    the inner loop we add the values to the array.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能使用嵌套循环的一个例子是当我们想要创建一个数组数组。在外部循环中，我们创建顶层数组，在内部循环中，我们向数组添加值。
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we log this array like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样记录这个数组时：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can see that the output is an array of arrays with values from `0` up to
    `6`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到输出是一个包含从`0`到`6`的值的数组。
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We used the nested loops to create an array in an array, meaning we can work
    with rows and columns after having created this loop. This means nested loops
    can be used to create tabular data. We can show this output as a table using the
    `console.table()` method instead, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了嵌套循环来创建一个数组中的数组，这意味着在创建了这个循环之后，我们可以处理行和列。这意味着嵌套循环可以用来创建表格数据。我们可以使用`console.table()`方法将此输出显示为表格，如下所示：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's put this into practice in the next exercise.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个练习中将这个应用到实践中。
- en: Practice exercise 5.4
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.4
- en: In this exercise we will be generating a table of values. We will be using loops
    to generate rows and also columns, which will be nested within the rows. Nested
    arrays can be used to represent rows in a table. This is a common structure in
    spreadsheets, where each row is a nested array within a table and the contents
    of these rows are the cells in the table. The columns will align as we are creating
    an equal number of cells in each row.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将生成一个值表格。我们将使用循环生成行和列，列将嵌套在行内。嵌套数组可以用来表示表格中的行。这是电子表格中常见的结构，其中每行都是表格内的嵌套数组，这些行的内容是表格中的单元格。列将按照我们在每行中创建相等数量的单元格来对齐。
- en: To create a table generator, first create an empty array, `myTable`, to hold
    your table data.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个表格生成器，首先创建一个空的数组`myTable`来存储你的表格数据。
- en: Set variable values for the number of rows and columns. This will allow us to
    dynamically control how many rows and columns we want within the table. Separating
    the values from the main code helps make updates to the dimensions easier.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置行和列的变量值。这将使我们能够动态地控制表格内想要的行和列的数量。将值从主代码中分离出来有助于更容易地更新维度。
- en: Set up a `counter` variable with an initial value of `0`. The counter will be
    used to set the content and count the values of the cells within the table.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个初始值为`0`的`counter`变量。计数器将用于设置单元格的内容并计算表格内单元格的值。
- en: Create a `for` loop with conditions to set the number of iterations, and to
    construct each row of the table. Within it, set up a new temporary array (`tempTable`)
    to hold each row of data. The columns will be nested within the rows, generating
    each cell needed for the column.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有条件的`for`循环来设置迭代次数，并构建表格的每一行。在其中，设置一个新的临时数组`tempTable`来存储每行数据。列将嵌套在行内，生成所需的每个列单元格。
- en: Nest a second loop within the first to count the columns. Columns are run within
    the row loop so that we have a uniform number of columns within the table.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个循环内嵌套第二个循环来计数列。列在行循环内运行，以便在表格内有均匀数量的列。
- en: Increment the main counter each iteration of the inner loop, so that we track
    a master count of each one of the cells and how many cells are created.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内循环的每次迭代中增加主计数器，以便我们跟踪每个单元格的总体计数以及创建了多少个单元格。
- en: Push the counter values to the temporary array, `tempTable`. Since the array
    is a nested array representing a table, the values of the counter can also be
    used to illustrate the cell values next to each other in the table. Although these
    are separate arrays representing new rows, the value of the counter will help
    illustrate the overall sequence of cells in the final table.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计数器值推送到临时数组`tempTable`。由于数组是一个表示表格的嵌套数组，计数器的值也可以用来在表格中相邻显示单元格值。尽管这些是表示新行的单独数组，但计数器的值将有助于说明最终表格中单元格的整体顺序。
- en: Push the temporary array to the main table. As each iteration builds a new row
    of array items, this will continue to build the main table in the array.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将临时数组推送到主表格中。随着每次迭代构建一个新行数组项，这将继续在数组中构建主表格。
- en: Output into the console with `console.table(myTable)`. This will show you a
    visual representation of the table structure.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`console.table(myTable)`将输出到控制台。这将显示表格结构的可视化表示。
- en: Loops and arrays
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环和数组
- en: If you are not convinced of how extremely useful loops are by now, have a look
    at loops and arrays. Loops make life with arrays a lot more comfortable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还没有完全确信循环的极端有用性，请看看循环和数组。循环让数组的生活变得更加舒适。
- en: 'We can combine the `length` property and the condition part of the `for` loop
    or `while` loop to loop over arrays. It would look like this in the case of a
    `for` loop:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`length`属性和`for`循环或`while`循环的条件部分结合起来，在数组上循环。在`for`循环的情况下，它看起来是这样的：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s start with a simple example that is going to log every value of the
    array:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下简单示例开始，该示例将记录数组的每个值：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use the `length` property to determine the maximum value of our index. The
    index starts counting at 0, but the length does not. The index is always one smaller
    than the length. Hence, we loop over the values of the array by increasing the
    length.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `length` 属性来确定索引的最大值。索引从 0 开始计数，但长度不是。索引总是比长度小 1。因此，我们通过增加长度来遍历数组的值。
- en: 'In this case we aren''t doing very interesting things yet; we are simply printing
    the values. But we could be changing the values of the array in a loop, for example,
    like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还没有做非常有趣的事情；我们只是在打印值。但我们可以在一个循环中改变数组的值，例如，像这样：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have concatenated `hello` with the beginnings of our names. The array is
    changed in the loop and the array will have this content after the loop has executed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `hello` 与我们名字的开头连接起来。数组在循环中被更改，循环执行后数组将包含以下内容：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The possibilities are endless here. When an array comes in somewhere in the
    application, data can be sent to the database per value. Data can be modified
    by value, or even filtered, like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性是无限的。当数组在应用程序的某个地方出现时，可以按值将数据发送到数据库。数据可以按值修改，甚至可以像这样进行过滤：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `startsWith()` method just checks whether the string starts with a certain
    character. In this case it checks whether the name starts with the string `M`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`startsWith()` 方法只是检查字符串是否以某个字符开头。在这种情况下，它检查名称是否以字符串 `M` 开头。'
- en: Don't worry, we will cover this function and many more in detail in *Chapter
    8*, *Built-in JavaScript Methods*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我们将在 *第 8 章*，*内置 JavaScript 方法* 中详细讲解这个函数以及许多其他函数。
- en: 'The output is:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You'll have to be careful here though. If we were to remove the item instead
    of deleting it and leaving an empty value, we would accidentally skip the next
    value, since that value gets the index of the recently deleted one and `i` is
    incremented and moves on to the next index.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在这里你必须小心。如果我们删除项而不是删除并留下空值，我们会意外地跳过下一个值，因为那个值会得到最近删除的那个值的索引，而 `i` 会增加并移动到下一个索引。
- en: 'What do you think this one does:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这个函数是做什么的：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Your program gets stuck in an infinite loop here. Since a value gets added every
    iteration, the length of the loop grows with every iteration and `i` will never
    be bigger than or equal to `length`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序会在这里陷入无限循环。由于每次迭代都会添加一个值，循环的长度会随着每次迭代而增长，`i` 将永远不会大于或等于 `length`。
- en: Practice exercise 5.5
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.5
- en: Explore how to create a table grid that contains nested arrays as rows within
    a table. The rows will each contain the number of cells needed for the number
    of columns set in the variables. This grid table will dynamically adjust depending
    on the values for the variables.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 探索如何创建一个包含嵌套数组作为表格行的表格网格。每一行将包含设置在变量中的列数所需的单元格数量。这个网格表格将根据变量的值动态调整。
- en: Create a grid array variable.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个网格数组变量。
- en: Set a value of `64` for the number of cells.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单元格的数量设置为 `64`。
- en: Set a counter to `0`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计数器设置为 `0`。
- en: Create a global variable to be used for the `row` array.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个全局变量用于 `row` 数组。
- en: Create a loop that will iterate up to the number of cells you want in the array,
    plus one to include the zero value. In our example, we would use 64+1.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，该循环将迭代到数组中你想要的单元格数量，再加一以包含零值。在我们的例子中，我们会使用 64+1。
- en: Add an outer `if` statement, which uses modulo to check if the main counter
    is divisible by 8 or whatever number of columns you want.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个外部的 `if` 语句，该语句使用取模运算来检查主计数器是否能被 8 或你想要的任意列数整除。
- en: Inside the preceding `if` statement, add another `if` statement to check if
    the row is undefined, indicating whether it is the first run or whether the row
    is complete. If the row has been defined, then add the row to the main grid array.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的 `if` 语句内部，添加另一个 `if` 语句来检查行是否未定义，这表示是否是第一次运行或者行是否已完成。如果行已经被定义，那么将行添加到主网格数组。
- en: To finish off the outer `if` statement, if the counter is divisible by 8, clear
    the `row` array—it has already been added to the grid by the inner `if` statement.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成外部的 `if` 语句，如果计数器能被 8 整除，则清空 `row` 数组——它已经被内部 `if` 语句添加到网格中。
- en: At the end of the for loop, increment of the main counter by 1.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `for` 循环结束时，将主计数器增加 1。
- en: Set up a temporary variable to hold the value of the counter and push it to
    the `row` array.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个临时变量来保存计数器的值并将其推送到 `row` 数组。
- en: Within the loop iteration, check if the value of the counter is equal to the
    total number of columns you want; if it is, then add the current row to the grid.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环迭代中，检查计数器的值是否等于你想要的列总数；如果是，则将当前行添加到网格中。
- en: Please note that the extra cell will not be added to the grid since there aren't
    enough cells to make a new row within the condition that adds the rows to the
    grid. An alternative solution would be to remove the +1 from the loop condition
    and add `grid.push(row)` after the loop is completed, both of which will provide
    the same solution output.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，由于没有足够的单元格在添加行的条件下创建新行，额外的单元格将不会添加到网格中。另一种解决方案是移除循环条件中的+1，并在循环完成后添加`grid.push(row)`，这两种方法都将提供相同的解决方案输出。
- en: Output the grid into the console.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将网格输出到控制台。
- en: for of loop
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for of循环
- en: 'There is another loop we can use to iterate over the elements of an array:
    the **for of loop**. It cannot be used to change the value associated with the
    index as we can do with the regular loop, but for processing values it is a very
    nice and readable loop.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用另一种循环来遍历数组的元素：**for of循环**。它不能用来改变与索引关联的值，就像我们可以在常规循环中做的那样，但对于处理值来说，它是一个非常优雅且易于阅读的循环。
- en: 'Here is what the syntax looks like:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是语法示例：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So you can read it like this: "For every value of the array, call it `variableName`
    and do the following." We can log our `names` array using this loop:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以这样读：“对于数组中的每个值，称之为`variableName`并执行以下操作。”我们可以使用这个循环记录`names`数组：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to specify a temporary variable; in this case we called it `name`.
    This is used to put the value of the current iteration in, and after the iteration,
    it gets replaced with the `next` value. This code results in the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定一个临时变量；在这个例子中我们称之为`name`。这个变量用于放置当前迭代的值，迭代完成后，它会被`next`值替换。这段代码的结果如下：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are some limitations here; we cannot modify the array, but we could write
    all the elements to a database or a file, or send it somewhere else. The advantage
    of this is that we cannot accidentally get stuck in an infinite loop or skip values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些限制；我们无法修改数组，但我们可以将所有元素写入数据库或文件，或者发送到其他地方。这种做法的优势在于我们不会意外陷入无限循环或跳过值。
- en: Practice exercise 5.6
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5.6
- en: This exercise will construct an array as it loops through the incrementing values
    of x. Once the array is done, this exercise also will demonstrate several ways
    to output array contents.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将在遍历x的递增值时构建一个数组。一旦数组完成，这个练习还将展示几种输出数组内容的方法。
- en: Create an empty array
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空数组
- en: Run a loop 10 times, adding a new incrementing value to the array
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行循环10次，向数组添加一个新的递增值
- en: Log the array into the console
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组记录到控制台
- en: Use the `for` loop to iterate through the array (adjust the number of iterations
    to however many values are in your array) and output into the console
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环遍历数组（调整迭代次数以匹配数组中的值数）并将输出到控制台
- en: Use the `for of` loop to output the value into the console from the array
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for of`循环将值输出到控制台
- en: Loops and objects
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环和对象
- en: We have just seen how to loop over the values of an array, but we can also loop
    over the properties of an object. This can be helpful when we need to go over
    all the properties but don't know the exact properties of the object we are iterating
    over.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何遍历数组中的值，但我们也可以遍历对象属性。当我们需要遍历所有属性但不知道正在迭代的对象的确切属性时，这可能会很有帮助。
- en: Looping over an object can be done in a few ways. We can use the `for in` loop
    to loop over the object directly, or we can convert the object to an array and
    loop over the array. We'll consider both in the following sections.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以几种方式遍历对象。我们可以使用`for in`循环直接遍历对象，或者将对象转换为数组并遍历数组。我们将在以下章节中考虑这两种方法。
- en: for in loop
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for in循环
- en: 'Manipulating objects with loops can also be done with another variation of
    the `for` loop, the **for in loop**. The `for in` loop is somewhat similar to
    the `for of` loop. Again here, we need to specify a temporary name, also referred
    to as a key, to store each property name in. We can see it in action here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环操作对象也可以通过`for`循环的另一种变体来实现，即**for in循环**。`for in`循环与`for of`循环有些相似。在这里，我们同样需要指定一个临时名称，也称为键，来存储每个属性名称。我们可以在以下示例中看到它的实际应用：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need to use the prop of each loop iteration to get the value out of the
    `car` object. The output then becomes:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用每次循环的`prop`来从`car`对象中获取值。输出结果如下：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we just logged the prop, like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是像这样记录了prop：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is what our output would look like:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们输出的样子：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, all the names of the properties get printed, and not the values.
    This is because the `for in` loop is getting the property names (keys) and not
    the values. The `for of` is doing the opposite; it is getting the values and not
    the keys.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有属性的名称都打印出来了，而不是值。这是因为`for in`循环获取的是属性名（键），而不是值。`for of`做的是相反的；它获取的是值，而不是键。
- en: This `for in` loop can also be used on arrays, but it is not really useful.
    It will only return the indices, since these are the "keys" of the values of the
    arrays. Also, it should be noted that the order of execution cannot be guaranteed,
    even though this is usually important for arrays. It is therefore better to use
    the approaches mentioned in the section on loops and arrays.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`for in`循环也可以用于数组，但它实际上并不实用。它只会返回索引，因为这些是数组值的“键”。还应注意的是，执行顺序不能保证，尽管这对于数组通常很重要。因此，最好使用在循环和数组部分提到的那些方法。
- en: Practice exercise 5.7
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5.7
- en: In this exercise, we will experiment with looping over objects and internal
    arrays.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实验如何遍历对象和内部数组。
- en: Create a simple object with three items in it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含三个项目的简单对象。
- en: Using the `for in` loop, get the properties' names and values from the object
    and output them into the console.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for in`循环，从对象中获取属性名和值，并将它们输出到控制台。
- en: Create an array containing the same three items. Using either the `for` loop
    or the `for in` loop, output the values from the array into the console.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含相同三个项目的数组。使用`for`循环或`for in`循环，将数组中的值输出到控制台。
- en: Looping over objects by converting to an array
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过转换为数组来遍历对象
- en: 'You can use any loop on objects, as soon as you convert the object to an array.
    This can be done in three ways:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在将对象转换为数组后使用任何循环。这可以通过三种方式完成：
- en: Convert the keys of the object to an array
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象的键转换为数组
- en: Convert the values of the object to an array
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象的值转换为数组
- en: 'Convert the key-value entries to an array (containing arrays with two elements:
    object key and object value)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将键值对转换为数组（包含包含两个元素的数组：对象键和对象值）
- en: 'Let''s use this example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个例子：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If we want to loop over the keys of the object, we can use the `for in` loop,
    as we saw in the previous section, but we can also use the `for of` loop if we
    convert it to an array first. We do so by using the `Object.keys(nameOfObject)`
    built-in function. This takes an object and grabs all the properties of this object
    and converts them to an array.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想遍历对象的键，我们可以使用`for in`循环，就像我们在上一节中看到的那样，但如果我们首先将其转换为数组，我们也可以使用`for of`循环。我们这样做是通过使用`Object.keys(nameOfObject)`内置函数。它接受一个对象，获取该对象的所有属性并将它们转换为数组。
- en: 'To demonstrate how this works:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示它是如何工作的：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can loop over the properties of this array like this using the `for of`
    loop:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`for of`循环像这样遍历数组的属性：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And this is what it will output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它输出的内容：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similarly, we can use the `for of` loop to loop over the values of the object
    by converting the values to an array. The main difference here is that we use
    `Object.values(nameOfObject)`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用`for of`循环通过将值转换为数组来遍历对象的值。这里的主要区别在于我们使用`Object.values(nameOfObject)`：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can loop over these arrays in the same way you loop over any array. You
    can use the length and index strategy like this in a regular `for` loop:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用和遍历任何数组一样的方式遍历这些数组。你可以在常规的`for`循环中使用长度和索引策略，如下所示：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And this will output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'More interesting is how to loop over both arrays at the same time using the
    `for of` loop. In order to do so, we will have to use `Object.entries()`. Let''s
    demonstrate what it does:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是如何同时使用`for of`循环遍历两个数组。为了做到这一点，我们必须使用`Object.entries()`。让我们演示它是如何工作的：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, it is returning a two-dimensional array, containing key-value
    pairs. We can loop over it like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它返回一个二维数组，包含键值对。我们可以像这样遍历它：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And this will output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Alright, you have seen many ways to loop over objects now. Most of them come
    down to converting the object to an array. We can imagine that at this point you
    could use a break. Or maybe you'd just like to continue?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你现在已经看到了许多遍历对象的方法。大多数方法都归结为将对象转换为数组。我们可以想象，到这一点，你可能想使用break。或者，也许你只是想继续？
- en: break and continue
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: break和continue
- en: '**break** and **continue** are two keywords that we can use to control the
    flow of execution of the loop. `break` will stop the loop and move on to the code
    below the loop. `continue` will stop the current iteration and move back to the
    top of the loop, checking the condition (or in the case of a `for` loop, performing
    the statement and then checking the condition).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**break**和**continue**是两个我们可以用来控制循环执行流程的关键字。`break`将停止循环并继续执行循环下面的代码。`continue`将停止当前迭代并返回到循环的顶部，检查条件（或者在`for`循环的情况下，执行语句然后检查条件）。'
- en: 'We will be using this array of `car` objects to demonstrate `break` and `continue`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个`car`对象数组来演示`break`和`continue`：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We will first have a closer look at `break`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先更详细地看看`break`。
- en: break
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: break
- en: 'We have already seen **break** in the `switch` statement. When `break` was
    executed, the `switch` statement ended. This is not very different when it comes
    to loops: when the `break` statement is executed, the loop will end, even when
    the condition is still true.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`switch`语句中看到了**break**。当执行`break`时，`switch`语句结束。在循环方面，这并没有太大的不同：当执行`break`语句时，循环将结束，即使条件仍然为真。
- en: 'Here is a silly example to demonstrate how `break` works:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个愚蠢的例子来演示`break`是如何工作的：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It looks like a loop that will log the numbers 0 to 10 (again excluding 10)
    to the console. There is a catch here though: as soon as `i` equals `4`, we execute
    the `break` command. `break` ends the loop immediately, so no more loop code gets
    executed afterward.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个将数字0到10（再次排除10）记录到控制台的循环。然而，这里有一个陷阱：一旦`i`等于4，我们就执行`break`命令。`break`会立即结束循环，因此之后不再执行更多的循环代码。
- en: We can also use `break` to stop looping through the array of cars when we have
    found a car that matches our demands.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`break`来停止遍历汽车数组，当我们找到符合我们要求的汽车时。
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As soon as we run into a car with the year 2020 or later and the car is black,
    we will stop looking for other cars and just buy that one. The last car in the
    array would also have been an option, but we did not even consider it because
    we found one already. The code snippet will output this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们遇到一辆2020年或之后的黑色汽车，我们就会停止寻找其他汽车，直接购买那辆。数组中的最后一辆车也是一个选择，但我们甚至没有考虑它，因为我们已经找到了一辆。代码片段将输出如下：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: However, often it is not a best practice to use `break`. If you can manage to
    work with the condition of the loop to break out of the loop instead, this is
    a much better practice. It prevents you getting stuck in an infinite loop, and
    the code is easier to read.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常使用`break`并不是一个好的实践。如果你能够通过管理循环的条件来跳出循环，这会是一个更好的实践。它防止你陷入无限循环，并且代码更容易阅读。
- en: If the condition of the loop is not an actual condition, but pretty much a run-forever
    kind of statement, the code gets hard to read.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环的条件不是一个真正的条件，而几乎是一个永远运行的语句，代码就很难阅读。
- en: 'Consider the following code snippet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This would be better to write without `break` and without something terrible
    like `while(true)`; you could do it like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这最好不使用`break`和不使用像`while(true)`这样可怕的东西来写；你可以这样做：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With the second example, we can see the conditions of the loop easily, namely
    the length of the array and a `notFound` flag. However, with `while(true)` we
    are kind of misusing the while concept. You want to specify the condition, and
    it should evaluate to `true` or `false`; this way your code is nice to read. If
    you say `while(true)`, you're actually saying forever, and the reader of your
    code will have to interpret it line by line to see what is going on and when the
    loop is ended by a workaround `break` statement.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们可以很容易地看到循环的条件，即数组的长度和一个`notFound`标志。然而，使用`while(true)`我们有点误用了while的概念。你想要指定条件，并且它应该评估为`true`或`false`；这样你的代码就很好阅读。如果你说`while(true)`，你实际上是在说永远，你的代码读者将不得不逐行解释以了解发生了什么以及循环是如何通过一个工作`break`语句结束的。
- en: continue
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: continue
- en: '`break` can be used to quit the loop, and **continue** can be used to move
    on to the next iteration of the loop. It quits the current iteration and moves
    back up to check the condition and start a new iteration.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`可以用来退出循环，而**continue**可以用来继续循环的下一个迭代。它将退出当前迭代并返回到检查条件并开始新迭代的位置。'
- en: 'Here you can see an example of `continue`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到一个`continue`的例子：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The approach here is to just skip every car that is not black and consider
    all the others that are not older than make year 2020 or later. The code will
    output this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的方法是不考虑所有不是黑色的车，只考虑所有不是在2020年或之后生产的其他车。代码将输出如下：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Be careful with `continue` in a `while` loop. Without running it, what do you
    think the next code snippet does?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中注意`continue`。在不运行它的情况下，你认为下一个代码片段会做什么？
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It logs `1`, and then it gets you stuck in an infinite loop, because `continue`
    gets hit before the value of `i` changes, so it will run into `continue` again,
    and again, and so on. This can be fixed by moving the `i++` up and subtracting
    1 from `i`, like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它记录`1`，然后它会让你陷入无限循环，因为`continue`在`i`的值改变之前被触发，所以它会再次遇到`continue`，然后又是，然后又是，如此等等。这可以通过将`i++`向上移动并从`i`中减去1来修复，如下所示：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'But again, there is a better way without `continue` here. The chance of error
    is a lot smaller:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次强调，这里有一种更好的方法，不需要使用`continue`。错误的机会要小得多：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: And as you can see it is even shorter and more readable. The value of `break`
    and `continue` usually comes in when you are looping over large data sets, possibly
    coming from outside your application. Here you'll have less influence to apply
    other types of control. Using `break` and `continue` is not a best practice for
    simple basic examples, but it's a great way to get familiar with the concepts.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它甚至更短、更易读。`break`和`continue`的价值通常在您遍历大型数据集时出现，这些数据集可能来自您的应用程序之外。在这里，您将更少地影响应用其他类型的控制。在简单的示例中使用`break`和`continue`不是最佳实践，但它是一个了解这些概念的好方法。
- en: Practice exercise 5.8
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.8
- en: This exercise will demonstrate how to create a string with all the digits as
    it loops through them. We can also set a value to skip by adding a condition that
    will use `continue`, skipping the matching condition. A second option is to do
    the same exercise and use the `break` keyword.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示如何创建一个字符串，其中包含循环遍历的所有数字。我们还可以通过添加一个使用`continue`跳过匹配条件的条件来设置一个要跳过的值。第二种选择是做同样的练习并使用`break`关键字。
- en: Set up a string variable to use as output.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个字符串变量作为输出。
- en: Select a number to skip, and set that number as a variable.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个要跳过的数字，并将其设置为变量。
- en: Create a `for` loop that counts to 10.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个计数到10的`for`循环。
- en: Add a condition to check if the value of the looped variable is equal to the
    number that should be skipped.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个条件来检查循环变量的值是否等于要跳过的数字。
- en: If the number is to be skipped in the condition, `continue` to the next number.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该数字在条件中要被跳过，则`continue`到下一个数字。
- en: As you iterate through the values, append the new count value to the end of
    the main output variable.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你遍历值时，将新的计数值追加到主输出变量的末尾。
- en: Output the main variable after the loop completes.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环完成后，输出主变量。
- en: Reuse the code, but change the `continue` to `break` and see the difference.
    It should now stop at the skip value.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新使用代码，但将`continue`改为`break`，看看区别。现在它应该会在跳过的值处停止。
- en: break, continue, and nested loops
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: break, continue, and nested loops
- en: '`break` and `continue` can be used in nested loops as well, but it is important
    to know that when `break` or `continue` is used in a nested loop, the outer loop
    will not break.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`也可以用在嵌套循环中，但重要的是要知道，当在嵌套循环中使用`break`或`continue`时，外层循环不会中断。'
- en: 'We will use this array of arrays to discuss `break` and `continue` in nested
    loops:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个数组的数组来讨论嵌套循环中的`break`和`continue`：
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Let's break down this example. We are looking for all the groups that have two
    names starting with an `M`. If we find such a group, we will log it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个例子。我们正在寻找所有有两个以M开头的名字的组。如果我们找到这样的组，我们将记录它。
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We first loop over the top-level arrays and set a counter, `matches`, with a
    start value of `0`, and for each of these top-level arrays, we are going to loop
    over the values. When a value starts with an M, we increase `matches` by one and
    check whether we have found two matches already. If we find two Ms, we break out
    of the inner loop and continue in our outer loop. This one will move on to the
    next top-level array, since nothing is happening after the inner loop.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先遍历顶层数组并设置一个计数器`matches`，起始值为`0`，对于这些顶层数组中的每一个，我们将遍历其值。当一个值以M开头时，我们将`matches`增加1并检查是否已经找到了两个匹配项。如果我们找到两个M，我们将跳出内层循环并继续外层循环。由于内层循环之后没有其他操作，这个循环将移动到下一个顶层数组。
- en: If the name does not start with an M, we do not need to check for `matches`
    being `2`, and we can continue to the next value in the inner array.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名字不以M开头，我们不需要检查`matches`是否为`2`，我们可以继续到内数组的下一个值。
- en: 'Take a look at this example: what do you think it will log?'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个例子：你认为它会记录什么？
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It will loop over the arrays, and for every array it will check the value to
    see if it starts with an M. If it does, the inner loop will break. So, if one
    of the arrays in the array contains multiple values starting with M, only the
    first one will be found, since the iteration over that array breaks and we continue
    to the next array.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 它将遍历数组，并且对于每个数组，它将检查值是否以 M 开头。如果是，内部循环将中断。所以，如果数组中的某个数组包含多个以 M 开头的值，只有第一个会被找到，因为遍历该数组的迭代会中断，然后我们继续到下一个数组。
- en: 'This one will output:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个会输出：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We can see that it finds Margot, the first one from the second array, but it
    skips Marina, because it is the second one in the array. And it breaks after having
    found one group, so it won't loop over the other elements in the inner array.
    It will continue with the next array, which doesn't contain names starting with
    an M.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它找到了 Margot，第二个数组中的第一个，但它跳过了 Marina，因为它在该数组中是第二个。找到一组后，它会中断循环，因此不会遍历内部数组的其他元素。它将继续到下一个数组，该数组不包含以
    M 开头的名字。
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If we want to see whether only one of all the names in the array of arrays starts
    with an M, we would have to break out of the outer loop. This is something we
    can do with labeled loops.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看数组数组中的所有名字中是否只有一个以 M 开头，我们就必须跳出外部循环。这是我们可以通过标签循环来做到的。
- en: break and continue and labeled blocks
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: break 和 continue 以及标签块
- en: 'We can break out of the outer loop from inside the inner loop, but only if
    we give a label to our loop. This can be done like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从内部循环中跳出外部循环，但前提是我们给我们的循环一个标签。这可以通过以下方式完成：
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We are giving our block a label by putting a word and a colon in front of a
    code block. These words can be pretty much anything (in our case, "outer" and
    "inner"), but not JavaScript's own reserved words, such as `for`, `if`, `break`,
    `else`, and others.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在代码块前放置一个单词和冒号来给我们的代码块一个标签。这些单词可以是几乎任何东西（在我们的例子中是“outer”和“inner”），但不能是 JavaScript
    的保留词，如 `for`、`if`、`break`、`else` 等。
- en: 'This will only log the first name starting with an `M`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会记录以 `M` 开头的第一个名字：
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It will only log one, because it is breaking out of the outer loop and all the
    loops end as soon as they find one. In a similar fashion you can continue the
    outer loop as well.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 它只会记录一个，因为它会跳出外部循环，并且所有循环都会在找到第一个匹配项时结束。以类似的方式，你也可以继续外部循环。
- en: Whenever you want to be done as soon as you find one hit, this is the option
    to use. So, for example, if you want check for errors and quit if there aren't
    any, this would be the way to go.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要在找到第一个匹配项后立即完成时，这就是你要使用的选项。例如，如果你想检查错误并在没有错误的情况下退出，这就是你要采取的方式。
- en: Chapter project
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节项目
- en: Math multiplication table
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学乘法表
- en: 'In this project, you will create a math multiplication table using loops. You
    can do this using your own creativity or by following some of the following suggested
    steps:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用循环创建一个数学乘法表。你可以通过自己的创意或遵循以下建议步骤之一来完成此操作：
- en: Set up a blank array to contain the final multiplication table.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个空数组来包含最终的乘法表。
- en: Set a `value` variable to specify how many values you want to multiply with
    one another and show the results for.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个 `value` 变量来指定你想要相乘的值的数量，并显示结果。
- en: Create an outer `for` loop to iterate through each row and a `temp` array to
    store the row values. Each row will be an array of cells that will be nested into
    the final table.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个外部 `for` 循环来遍历每一行，并创建一个 `temp` 数组来存储行值。每一行将是一个单元格数组，它将被嵌套到最终表中。
- en: Add an inner `for` loop for the column values, which will push the multiplied
    row and column values to the `temp` array.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为列值添加一个内部 `for` 循环，它将乘积的行和列值推送到 `temp` 数组中。
- en: Add the temporary row data that contains the calculated solutions to the main
    array of the final table. The final result will add a row of values for the calculations.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含计算结果的临时行数据添加到最终表的主体数组中。最终结果将为计算添加一行值。
- en: Self-check quiz
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查测验
- en: What is the expected output for the following code?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的预期输出是什么？
- en: '[PRE69]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: What is the final value for `myArray`, and what is expected in the console?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`myArray` 的最终值是什么，控制台中的预期输出是什么？'
- en: '[PRE70]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter we introduced the concept of loops. Loops enable us to repeat
    a certain block of code. We need some sort of condition when we loop, and as long
    as that condition is true, we'll keep looping. As soon as it changes to false,
    we end our loop.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了循环的概念。循环使我们能够重复执行特定的代码块。当我们循环时，我们需要某种条件，并且只要该条件为真，我们就会继续循环。一旦它变为假，我们就结束循环。
- en: We have seen the `while` loop, in which we just insert a condition, and as long
    as that condition is true we keep looping. If the condition is never true, we
    won't even execute the loop code once.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `while` 循环，其中我们只需插入一个条件，只要该条件为真，我们就继续循环。如果条件永远不为真，我们甚至不会执行循环代码一次。
- en: This is different for the `do while` loop. We always execute the code once,
    and then we start to check a condition. If this condition is true, we execute
    the code again and do so until the condition becomes false. This can be useful
    when working with input from outside, such as user input. We would need to request
    it once, and then we can keep on requesting it again until it is valid.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `do while` 循环来说，情况就不同了。我们总是先执行代码一次，然后开始检查条件。如果这个条件为真，我们会再次执行代码，并一直这样做，直到条件变为假。当处理来自外部（如用户输入）的输入时，这可能很有用。我们需要请求一次，然后我们可以继续请求，直到它有效。
- en: Then we saw the `for` loop, which has a slightly different syntax. We have to
    specify a variable, check a condition (preferably using that variable, but this
    is not mandatory), and then specify an action to be executed after every iteration.
    Again, it's preferable for the action to include the variable from the first part
    of the `for` loop. This gives us code that is to be executed as long as a condition
    is true.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到了 `for` 循环，它的语法略有不同。我们必须指定一个变量，检查一个条件（最好使用那个变量，但这不是强制性的），然后指定在每次迭代后要执行的操作。同样，最好让操作包括
    `for` 循环第一部分中的变量。这给了我们一段只要条件为真就会执行的代码。
- en: 'We also saw two ways to loop over arrays and objects, `for in` and `for of`.
    The `for in` loop loops over keys and `for of` loops over values. They go over
    every element in a collection. The advantage of these loops is that JavaScript
    controls the execution: you can''t miss an element or get stuck in an infinite
    loop.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了两种遍历数组和对象的方法，`for in` 和 `for of`。`for in` 循环遍历键，而 `for of` 循环遍历值。它们遍历集合中的每个元素。这些循环的优势在于
    JavaScript 控制执行：你不会错过任何元素，也不会陷入无限循环。
- en: Lastly, we saw `break` and `continue`. We can use the `break` keyword to end
    a loop immediately and the `continue` keyword to end the current iteration and
    go back to the top and start the next iteration, if the condition is still true,
    that is.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了 `break` 和 `continue`。我们可以使用 `break` 关键字立即结束循环，使用 `continue` 关键字结束当前迭代并回到顶部开始下一次迭代，如果条件仍然为真，那就是了。
- en: 'In the next chapter we are going to be adding a really powerful tool to our
    JavaScript toolbox: functions! They allow us to take our coding skills to the
    next level and structure our code better.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向我们的 JavaScript 工具箱添加一个真正强大的工具：函数！它们允许我们将我们的编码技能提升到下一个层次，并更好地组织我们的代码。
