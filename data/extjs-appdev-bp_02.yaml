- en: Chapter 2. MVC and MVVM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。MVC 和 MVVM
- en: 'The problem with software development is that we''re always looking for the
    right way to do things. Each software shop will have their own set of guidelines
    that indicate how their developers should operate. This is the way that software
    works: we build a set of ideas that reflect our best thoughts on how things should
    be developed and the software community learns from these ideas and builds on
    them. They are formalized into patterns of working and these patterns are shared
    throughout the development community. In this chapter, we''ll talk more about
    this concept, specifically:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的问题是我们总是在寻找做事情的正确方式。每个软件公司都会有一套自己的指南，指示他们的开发者应该如何操作。这就是软件工作的方式：我们构建一套反映我们最佳思考如何开发的想法，软件社区从这些想法中学习并在此基础上构建。它们被正式化为工作模式，这些模式在整个开发社区中共享。在本章中，我们将更多地讨论这个概念，特别是：
- en: The MVC pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC 模式
- en: The MVVM pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM 模式
- en: The way Ext JS uses both
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 使用两种方式
- en: The evolution of Ext JS from MVC to MVVM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 从 MVC 到 MVVM 的演变
- en: The benefits of design patterns in the current version of Ext JS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前版本 Ext JS 中设计模式的好处
- en: Discussions about design patterns are often very dry. In this chapter, we'll
    use some practical examples to illustrate why they're so important and how they
    can help you kick-start your architecture efforts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设计模式的讨论通常非常枯燥。在本章中，我们将使用一些实际例子来说明它们为什么如此重要以及它们如何帮助你启动架构工作。
- en: Diary of always
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总是日记
- en: In the beginning, there was a giant mess. Well, maybe not quite, but in modern
    software development, we've got lots of design and architectural patterns that
    we can draw on to help us shape an application and ensure we're not reinventing
    the wheel. Each of these is the result of decades of their work, which is constantly
    reviewed and put into practice, and we all hope that the most elegant and useful
    work will bubble to the top. Along the way, we've seen clumsy patterns being overtaken
    by more elegant ones. Hopefully, our mess has become a little bit less tangled.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，情况一团糟。好吧，也许并不完全是这样，但在现代软件开发中，我们有很多设计和架构模式可以利用，帮助我们塑造应用程序并确保我们不是在重新发明轮子。这些模式中的每一个都是数十年的工作的结果，这些工作不断被审查并付诸实践，我们都希望最优雅和最有用的工作能够浮出水面。在这个过程中，我们看到了笨拙的模式被更优雅的模式所取代。希望我们的混乱变得稍微不那么复杂了。
- en: A key development in the way we build graphical interfaces was **model-view-controller**
    (**MVC**), which was invented at the near-legendary Xerox PARC in the 1970s by
    Norwegian computer scientist Trygve Reenskaug. It was first publicly incorporated
    in Smalltalk, a programming language developed by a cast of computer scientists
    including Alan Kay. It brought together a host of ideas, which influenced nearly
    all the object-oriented languages we use today. It was a pretty big deal and created
    by some pretty big guns.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建图形界面方式的一个关键发展是**模型-视图-控制器**（**MVC**），它在20世纪70年代的近传奇的施乐帕克研究中心（Xerox PARC）由挪威计算机科学家Trygve
    Reenskaug发明。它首先在Smalltalk编程语言中被公开采用，这是一种由包括艾伦·凯（Alan Kay）在内的计算机科学家团队开发的编程语言。它汇集了许多想法，这些想法影响了我们今天使用的几乎所有面向对象的语言。这是一件大事，是由一些非常厉害的人创造的。
- en: 'Connelly Barnes, assistant professor of computer science at University of Virginia,
    gives us a great way of viewing MVC:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 弗吉尼亚大学计算机科学助理教授康奈利·巴恩斯（Connelly Barnes）给我们提供了一个很好的看待 MVC 的方法：
- en: '*"The model is the data, the view is the window on the screen, and the controller
    is the glue between the two."*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"模型是数据，视图是屏幕上的窗口，控制器是两者之间的粘合剂。"*'
- en: It was first in describing software constructs in terms of their responsibilities,
    for example, the View is responsible for presentation. In [Chapter 1](ch01.html
    "Chapter 1. Introduction"), *Introduction*, we talked about its importance in
    creating strong application architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先在描述软件结构时使用职责术语，例如，视图负责展示。在[第1章](ch01.html "第1章。简介")，*简介*中，我们讨论了它在创建强大应用架构中的重要性。
- en: 'It can be difficult for us to look back on innovations (such as Smalltalk and
    MVC) and understand why they were so important. We could spend many pages reviewing
    what went before and why the advent of MVC has been described as a seminal insight.
    What really matters though is that it was a new way of looking at organizing graphical
    user interface-based software, a new paradigm in computing science that would
    prove to stand the test of time for the next thirty years:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们回顾创新（如Smalltalk和MVC）并理解它们为何如此重要来说，可能很困难。我们可以花费许多页面来回顾之前的内容以及为什么MVC的出现被描述为一个开创性的洞察。然而，真正重要的是，它是一种新的观察基于图形用户界面的软件组织方式，这是一种在接下来的三十年里经得起时间考验的计算科学新范式：
- en: '![Diary of always](img/5308OT_02_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![始终的日记](img/5308OT_02_01.jpg)'
- en: Martin Fowler's bare-bones MVC
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler的裸骨MVC
- en: There are several differences between the MVC implementation that Ext JS uses
    (the one that Ruby on Rails brought to prominence) and the original implementation
    in Smalltalk. It has constantly been honed and tweaked since its inception, tailored
    for the various environments in which it has been used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS使用的MVC实现（Ruby on Rails带来的）与Smalltalk中的原始实现之间存在几个差异。自其诞生以来，它一直在不断优化和调整，以适应其使用的各种环境。
- en: Bringing MVC to the Web
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将MVC引入网络
- en: Smalltalk's MVC implementation was created with traditional desktop GUI systems
    in mind. The separation of responsibilities that it represents makes a lot of
    sense for web-based software; the model is the representation of the business
    and persistence layers, the controller is the server-side glue, and the view is
    the HTML rendered for the client browser.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk的MVC实现是针对传统的桌面GUI系统而创建的。它所代表的职责分离对于基于网络的软件来说非常有意义；模型是业务和持久层的表示，控制器是服务器端的粘合剂，视图是为客户端浏览器渲染的HTML。
- en: However, in traditional MVC, the view observes changes in the model in order
    to reflect its current state by responding to events that the model issues. In
    a standard HTTP request/response situation, this isn't viable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在传统的MVC中，视图通过响应模型发出的事件来观察模型的变化，以反映其当前状态。在标准的HTTP请求/响应情况下，这是不可行的。
- en: 'Model 2 is a derivative of MVC that was implemented in the Java Struts framework,
    which introduced a potential solution to this issue. Rather than the view and
    model directly communicating, the controller becomes a marshaling point for changes.
    It responds to changes in the view and passes them to the model and vice versa,
    as shown in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Model 2是MVC的一个衍生版本，它在Java Struts框架中实现，该框架为解决这个问题提供了一个潜在的解决方案。而不是视图和模型直接通信，控制器成为变化的汇集点。它响应视图的变化，并将它们传递给模型，反之亦然，如下面的图所示：
- en: '![Bringing MVC to the Web](img/5308OT_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![将MVC引入网络](img/5308OT_02_02.jpg)'
- en: MVC/Model 2 on the Web
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的MVC/Model 2
- en: This is the way in which Ruby on Rails implements MVC and in turn inspired a
    multitude of similar MVC frameworks for the Web (such as ASP.NET MVC).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Ruby on Rails实现MVC的方式，进而激发了众多类似MVC框架的诞生（如ASP.NET MVC）。
- en: This is in contrast to web technologies (such as Classic ASP, PHP, and Cold
    Fusion), where it's standard practice to create a page that combines logic, rendering,
    and database access. This can be described (although rarely is) as Model 1 with
    the MVC implementation as its logical successor. A Model 1 approach leads to the
    problems, which we described at the beginning of [Chapter 1](ch01.html "Chapter 1. Introduction"),
    *Introduction*, and so the popularization of MVC, in particular the simplified
    approach that Ruby on Rails took, begins to provide a strong basis for a well-constructed
    application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这与网络技术（如经典ASP、PHP和Cold Fusion）形成对比，在这些技术中，创建一个结合逻辑、渲染和数据库访问的页面是标准做法。这可以描述为（尽管很少这样做）是MVC实现逻辑后继者的Model
    1。Model 1方法会导致我们在[第1章](ch01.html "第1章。简介")开头描述的问题，因此MVC的普及，尤其是Ruby on Rails采用的简化方法，开始为构建良好的应用程序提供一个坚实的基础。
- en: 'MVC on the Web might follow this request flow:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的MVC可能遵循以下请求流程：
- en: The browser makes a request that is passed on to a controller.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器发起请求，并将其传递给控制器。
- en: The controller consumes the request parameters.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器消费请求参数。
- en: It retrieves a model (typically from a database) based on these parameters.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它根据这些参数检索一个模型（通常是数据库中的）。
- en: Finally, it renders a view based on the model and passes it back to the browser.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它根据模型渲染视图，并将其传递回浏览器。
- en: Of course, with the advent of Ajax, WebSockets, and fully client-side MVC frameworks,
    this is a very simplified example. It does serve to show how MVC can easily be
    adapted for the Web and, in fact, suits the Web very well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，随着 Ajax、WebSockets 和完全客户端 MVC 框架的出现，这是一个非常简化的例子。它确实有助于展示 MVC 如何轻松地适应 Web，并且实际上非常适合
    Web。
- en: Ext JS and MVC
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext JS 和 MVC
- en: We've looked at the origins of MVC and the way it was adapted for traditional
    server-side web applications. How does it work when we use it with the kind of
    JavaScript-heavy application we'd typically build using Ext JS?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 MVC 的起源以及它是如何被应用于传统的服务器端 Web 应用的。当我们使用 Ext JS 这样的 JavaScript 重量级应用时，它是如何工作的呢？
- en: The whole MVC concept moves entirely into the browser. As far as we're concerned,
    the server can use any technology it wants. It'll generally just provide and consume
    data to and from the browser. We move back to an MVC implementation that is a
    little more like the Smalltalk version (different UI elements you see on-screen
    are views) and each can have their own controller.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 MVC 概念完全移动到了浏览器中。就我们而言，服务器可以使用它想要的任何技术。它通常会只是提供和消耗浏览器之间的数据。我们回到了一种更类似于 Smalltalk
    版本的 MVC 实现（屏幕上看到的不同的 UI 元素是视图），每个都可以有自己的控制器。
- en: Again, this is about breaking down responsibility. Instead of having a single
    controller take care of an entire page, we can have a search controller, a list
    controller, and a detail controller (anything that represents the logical units
    that make up our application). This is a key detail in how the step from server-side
    MVC to client-side MVC can help our application architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是关于分解责任。我们不是让一个控制器负责整个页面，而是可以有搜索控制器、列表控制器和详细控制器（代表构成我们应用逻辑单元的任何东西）。这是从服务器端
    MVC 到客户端 MVC 的步骤如何帮助我们应用架构的关键细节。
- en: 'We already know that Ext JS Components are our views, and Ext JS models are
    well named to fit right in. We''re left with one important question: what are
    controllers actually supposed to do? It''s probably easier to remove the things
    we know they don''t do and see what''s left. We know that models deal with data,
    but they''re also responsible for the calculations and logic around this data.
    Calculations and rules, for example, belong in a model, but not in a controller.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 Ext JS 组件是我们的视图，Ext JS 模型命名得很好，可以很好地融入其中。我们剩下了一个重要的问题：控制器实际上应该做什么？可能更容易先移除我们知道它们不应该做的事情，然后看看剩下的是什么。我们知道模型处理数据，但它们也负责围绕这些数据的计算和逻辑。例如，计算和规则属于模型，但不属于控制器。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is a generalization. In many cases, you'll have other classes that do this
    logic work in order to further break down your application. The important thing
    to take away is that you do not want domain logic in your controller!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个概括。在许多情况下，你会有其他类来完成这种逻辑工作，以便进一步分解你的应用。重要的是要记住，你不想在控制器中包含领域逻辑！
- en: We also know views deal with presentation. You could build up an HTML string
    in your controller and pass it to the browser for rendering, but this would involve
    the controller in something which is the view's responsibility.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道视图处理展示。你可以在控制器中构建一个 HTML 字符串，并将其传递给浏览器进行渲染，但这将涉及控制器承担视图的责任。
- en: What are we left with? In truth, not much. All your controllers need to do is
    be in charge of your views and models. That's it. They look at the request the
    user is making, fetch a model, and use it to render the view to the browser.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还剩下什么呢？实际上，并不多。你的控制器只需要负责你的视图和模型。仅此而已。它们查看用户提出的请求，获取一个模型，并使用它来将视图渲染到浏览器中。
- en: In fact, if your controller is doing more than this, you need to take this as
    a bad sign. A controller should be the conductor of your orchestra, not the one
    making the music.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你的控制器做了更多的事情，这应该被视为一个坏信号。控制器应该是乐队的指挥，而不是创作音乐的人。
- en: Examples of Ext JS MVC
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ext JS MVC 的示例
- en: 'The following screenshot shows our Ext JS v4 MVC test application:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了我们的 Ext JS v4 MVC 测试应用：
- en: '![Examples of Ext JS MVC](img/5308OT_02_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Ext JS MVC 的示例](img/5308OT_02_03.jpg)'
- en: 'We''ve generated a stock Ext JS v4 application here, which sticks to the MVC
    structure and then we''ve amended it to suit our needs. In this small app, there''s
    a grid of music albums on the left. When you click on the button on the grid,
    it generates a summary of the artists who are mentioned in the grid, and when
    you double-click on a row, it puts the album information in the right-hand pane.
    It''s a toy application, but it''s useful to demonstrate how MVC works. Later,
    we''ll compare it with a similar application written with Ext JS v5\. Let''s take
    a look at the code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里生成了一个股票 Ext JS v4 应用程序，它遵循 MVC 结构，然后我们根据我们的需求对其进行了修改。在这个小应用程序中，左侧有一个音乐专辑的网格。当你点击网格上的按钮时，它会生成在网格中提到的艺术家的摘要，当你双击一行时，它将专辑信息放入右侧面板。这是一个玩具应用程序，但它有助于演示
    MVC 的工作原理。稍后，我们将将其与用 Ext JS v5 编写的类似应用程序进行比较。让我们看看代码：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s our `MvcEx1v4.view.List` class in `view/List.js`. It''s a fairly straightforward
    grid that uses a store called `''Albums''` and a button on the bottom toolbar
    to generate the artist summary. Notice that the event handler to generate this
    summary is included in the view:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的 `MvcEx1v4.view.List` 类在 `view/List.js` 中。它是一个相当直接的网格，使用名为 `'Albums'`
    的存储和一个位于底部工具栏上的按钮来生成艺术家摘要。请注意，生成此摘要的事件处理程序包含在视图中：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our second view is `MvcEx1v4.view.Detail` in `view/Detail.js`. This is just
    a simple container with some placeholder HTML. Finally, we have the application
    viewport that holds our views:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个视图是 `MvcEx1v4.view.Detail` 在 `view/Detail.js` 中。这只是一个带有一些占位符 HTML 的简单容器。最后，我们有包含我们的视图的应用程序视口：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Again, there are a few surprises here. Notice that we refer to our views using
    the values we defined in their individual "alias" configuration options: `app-detail`
    and `app-list`. We''ve taken care of the "V" in MVC, so let''s move on to "M"
    and see where our data comes from, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里有一些惊喜。请注意，我们使用在各自的“别名”配置选项中定义的值来引用我们的观点：`app-detail` 和 `app-list`。我们已经处理了
    MVC 中的“V”，那么让我们继续到“M”，看看我们的数据来自哪里，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For easier reading, I''ve combined the code for the model and the store that
    consumes it. The data for this application is added inline using the data configuration
    option (just to avoid messing around with server-side Ajax calls). Let''s look
    at the final facet of MVC, the controller:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，我已经将模型和消费它的存储的代码合并在一起。这个应用程序的数据是通过数据配置选项内联添加的（只是为了避免在服务器端 Ajax 调用中乱搞）。让我们看看
    MVC 的最后一个方面，即控制器：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here's where things start to deviate from the straightforward view to data implementation
    you'd typically see in an Ext JS v3 application. We're introducing a new class
    that brings in a new architectural construct. But to what end?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里开始与 Ext JS v3 应用程序中通常看到的直接视图到数据实现有所不同。我们引入了一个新类，引入了一个新的架构结构。但目的是什么？
- en: The answer is communication. The controller, as we know, is the glue that sticks
    together the "M" and the "V". In our simple example here, it's giving us a mechanism
    to let the list view talk to the detail view without either of them having to
    be aware of each other. The `control` feature is used to determine what to do
    when the list view (aliased as `app-list`) fires an `itemdblclick` event.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是通信。正如我们所知，控制器是粘合“M”和“V”的胶水。在我们的简单示例中，它为我们提供了一个机制，让列表视图（别名为 `app-list`）在没有意识到对方的情况下与详细视图进行通信。`control`
    功能用于确定当列表视图（别名为 `app-list`）触发 `itemdblclick` 事件时应该做什么。
- en: 'We supply the `onAlbumDblClick` method to respond to this event. In here, we
    want to talk to our detail view (aliased as `app-detail`). We previously used
    the `refs` configuration option to help with this. Let''s break it down:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了 `onAlbumDblClick` 方法来响应这个事件。在这里，我们想要与我们的详细视图（别名为 `app-detail`）进行通信。我们之前使用了
    `refs` 配置选项来帮助实现这一点。让我们分解一下：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Long story short, the `refs` feature gives us a shorthand way to access a view.
    In the `onAlbumDblClick` handler, we use the autogenerated `this.getDetail()`
    method that `refs` provides. This gives us a reference to the view. We can then
    set HTML of its view's element based on the event data provided by the list view.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`refs` 功能为我们提供了一个简短的方式来访问视图。在 `onAlbumDblClick` 处理程序中，我们使用了 `refs` 提供的自动生成的
    `this.getDetail()` 方法。这给了我们一个对视图的引用。然后我们可以根据列表视图提供的事件数据设置其视图元素的 HTML。
- en: How does it help your application
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它如何帮助你的应用程序
- en: Let's recap. How are we better off than in Ext JS 3 before we had any of this
    MVC stuff involved?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下。在我们涉及任何 MVC 东西之前，我们在 Ext JS 3 中比现在更好吗？
- en: We've got clear separation of presentation and data with views and models
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过视图和模型实现了展示和数据之间的清晰分离
- en: We have a way of orchestrating different parts of our application using controllers
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一种使用控制器来协调我们应用程序不同部分的方式
- en: We've got a way of splitting our app into logic units by using multiple controllers
    with associated views
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过使用多个与相关视图关联的控制器，将我们的应用程序分割成逻辑单元
- en: Not only does this lend itself to a good design by keeping different bits of
    functionality very separate from the outset, but it also gives us a good platform
    for maintainability purposes because it imposes a very specific way of working.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这有助于从一开始就保持不同功能部分非常分离，从而实现良好的设计，而且还为我们提供了一个良好的维护平台，因为它强制实施了一种非常具体的工作方式。
- en: MVC and the illusion of choice
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC 和选择幻觉
- en: Given everything we've just covered, you'd think that MVC was the holy grail
    of development. It's tried and tested, adaptable, and supported by Ext JS. In
    fact, there are some cases in which it's useful to go a little further and augment
    MVC.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们刚刚讨论的所有内容，你可能会认为 MVC 是开发的圣杯。它经过测试，适应性强，并且得到 Ext JS 的支持。事实上，在某些情况下，进一步增强
    MVC 是有用的。
- en: To use Ext JS-specific examples, let's look at what happens when you start writing
    a more complicated application. Your controllers can react to the events that
    your views fire, orchestrate interactions between different views, and even stores
    other controllers. So, does this mean that you put your event handlers in your
    controllers, your views, or a combination of both?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Ext JS 特定的示例，让我们看看当你开始编写更复杂的应用程序时会发生什么。你的控制器可以响应视图触发的事件，协调不同视图之间的交互，甚至存储其他控制器。那么，这意味着你将在控制器、视图或两者的组合中放置事件处理器吗？
- en: This is a key question, which can be answered simply by being very strict with
    your development process from the beginning. MVC provides the "illusion of choice";
    in this, it offers a large variety of ways to set up your application, but only
    a few that will result in a healthy application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键问题，可以通过从一开始就非常严格地管理你的开发过程来简单地回答。MVC 提供了“选择幻觉”；在这里，它提供了大量设置应用程序的方法，但只有少数几种方法会导致健康的应用程序。
- en: How about when you have a central source of data, but different views that consume
    it? You might want to have this data in slightly different forms for each view.
    Does the view itself take responsibility for shaping this data?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个中央数据源，但不同的视图消费它时怎么办？你可能希望为每个视图以略微不同的形式呈现这些数据。视图本身是否负责塑造这些数据？
- en: Ext JS 5 implements a pattern called **model-view-viewmodel** (**MVVM**) that
    tries to address these questions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5 实现了一个称为 **模型-视图-视图模型**（**MVVM**）的模式，试图解决这些问题。
- en: Introducing MVVM
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 MVVM
- en: MVVM can be seen as an augmentation of MVC. Introducing the view model concept,
    it recognizes that not every view concerned with a dataset will be using this
    data in the same way. It adds a layer of indirection between a view and a model,
    called a view model, to solve this issue. It also keeps separation of concerns
    to the fore; why should the model, which is dealing with our data be concerned
    about anything to do with our view, which is dealing with presentation?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 可以被视为 MVC 的一种增强。引入视图模型的概念，它认识到并非每个与数据集相关的视图都会以相同的方式使用这些数据。它通过添加一个称为视图模型的中介层来解决这一问题，这个中介层位于视图和模型之间。它还把关注点的分离放在首位；为什么处理我们数据的模型要关心与处理展示的视图有关的事情呢？
- en: '![Introducing MVVM](img/5308OT_02_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![引入 MVVM](img/5308OT_02_04.jpg)'
- en: A typical representation of MVVM
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 的典型表示
- en: How does Ext JS use MVVM?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ext JS 如何使用 MVVM？
- en: With Ext JS 5, MVVM is wholeheartedly embraced. The sample application structure
    that Sencha Cmd generates will provide a `ViewModel` class alongside the `View`
    class. This has tight integration into the `View` class via new configuration
    options, which make it a first-class citizen when trying to solve the common problems
    that arise in a large MVC application, as we discussed earlier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 5 中，MVVM 被全心全意地接纳。Sencha Cmd 生成的示例应用程序结构将提供与 `View` 类并行的 `ViewModel`
    类。这通过新的配置选项与 `View` 类紧密集成，这使得它在解决大型 MVC 应用程序中常见的常见问题时成为一等公民，正如我们之前讨论的那样。
- en: In addition, a `ViewController` class is created to encapsulate the logic you'd
    normally put in a view or in a standard controller. It removes the question of
    where to put event handlers that are concerned with things internal to the view,
    rather than event handlers that will be passing off events to other parts of your
    application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建了一个`ViewController`类来封装你通常会在视图或标准控制器中放置的逻辑。它消除了关于在哪里放置关注视图内部事件的事件处理器的问题，而不是将事件传递到应用程序其他部分的事件处理器。
- en: Getting our MVVM started
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动我们的MVVM
- en: 'We started by generating an Ext JS 5 application template using Sencha Cmd
    and used it as a basis to build an implementation of our example album list application.
    The default Ext JS 5 template uses an MVVM implementation as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用Sencha Cmd生成一个Ext JS 5应用程序模板，并将其作为构建我们示例专辑列表应用程序的基础。默认的Ext JS 5模板使用以下MVVM实现：
- en: '![Getting our MVVM started](img/5308OT_02_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![启动我们的MVVM](img/5308OT_02_05.jpg)'
- en: Our example app ported to Ext JS 5's MVVM architecture
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序移植到Ext JS 5的MVVM架构
- en: 'The most immediate difference you''ll notice is that we''ve lost our controllers
    directory and there''s a lot more going on in the views directory. Let''s break
    it down:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你最直接会注意到的是，我们已经失去了控制器目录，视图目录中发生了很多事情。让我们分解一下：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The album model is identical to the previous example, although note that we''ve
    changed the application name to `MvvmEx1v5`. The store is only very slightly different:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之前的例子，专辑模型是相同的，但请注意，我们已经将应用程序名称更改为`MvvmEx1v5`。存储器只有非常细微的不同：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ve added the `alias` configuration option so that we can refer to the store
    later using the albums shorthand. Now, let''s take a look at the views directory:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`alias`配置选项，这样我们就可以稍后使用专辑简称来引用存储器。现在，让我们看看视图目录：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've combined the previous `app-list` and `app-detail` views into a single
    `app-albums` view, and whereas before we had the logic to build the album summary
    in the view, we now define only the event handler and the logic goes elsewhere.
    This view is now 100 percent presentation and defers all the complicated stuff
    to other classes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前的`app-list`和`app-detail`视图合并为单个`app-albums`视图，而且之前我们在视图中构建专辑摘要的逻辑，我们现在只定义事件处理器和逻辑放在其他地方。这个视图现在是100%的展示，并将所有复杂的事情推迟到其他类。
- en: 'Note that we have a `controller` configuration option that defines the view
    controller to use for this view class. Our grid component has several interesting
    configuration options too:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有一个`controller`配置选项，它定义了用于此视图类的视图控制器。我们的网格组件也有几个有趣的配置选项：
- en: '`reference`: We use this later to get hold of this component from the view
    controller.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`参考`: 我们稍后会使用这个来从视图控制器获取这个组件。'
- en: '`viewModel`: This is the alias of the view model this component will use.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewModel`: 这是此组件将使用的视图模型别名。'
- en: '`bind`: This defines how the view talks to the view model. We''re using the
    simplest binding (the grid''s default `bindProperty` is store), so here we''re
    essentially just setting the store `config` to `''albums''`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind`: 这定义了视图如何与视图模型通信。我们使用最简单的绑定（网格的默认`bindProperty`是store），所以这里我们基本上只是将存储器的`config`设置为`''albums''`。'
- en: 'Now, let''s move on to our album view model:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们的专辑视图模型：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, here we have one of these places that now contain this logic. A view
    model takes data from a model (or stores) and presents it in a way suitable for
    its matching view. In this case, we take the data from the `''albums''` store
    (referenced in the `type` configuration option by the albums alias we mentioned
    earlier). It provides a `buildSummary` method that transforms the stored data
    into a string ready to be used in the UI as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里是我们现在包含这种逻辑的地方之一。一个视图模型从模型（或存储器）获取数据，并以适合其匹配视图的方式呈现。在这种情况下，我们从`'albums'`存储器（如我们之前提到的专辑别名通过`type`配置选项引用）获取数据。它提供了一个`buildSummary`方法，将存储的数据转换为可用于UI的字符串，如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, we have our view controller, which is where any logic that manages
    our view should go. Event handlers defined in the view controller will automatically
    be available to the matching view.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们的视图控制器，这是任何管理我们视图的逻辑应该去的地方。在视图控制器中定义的事件处理器将自动对匹配的视图可用。
- en: Are we better off?
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的情况更好吗？
- en: Yes, we're better off because we're more organized. We know where all of our
    application bits go, and although we've got a lot more files than a straightforward
    one-class Ext JS application, we'll always know where to look to change the configuration
    of a view, where to find our logic for the albums, or where to shape the information
    we pull from a store.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们因为更组织化而过得更好。我们知道所有应用程序的位信息在哪里，尽管我们比一个简单的单类Ext JS应用程序有更多的文件，但我们始终知道在哪里查找更改视图配置，在哪里找到我们的专辑逻辑，或者在哪里塑造我们从存储中提取的信息。
- en: One important point about this example is that we forego the overarching controller
    from the first example in favor of a view controller. Here, this makes sense;
    we want this view controller to be concerned only with albums, not with other
    parts of the application. However, a higher-level controller is still a valid
    piece of the Ext JS MVVM architecture and can be reintroduced in situations that
    require a way to coordinate an application at a higher level than a view controller.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个例子，一个重要的观点是我们放弃了第一个例子中的总体控制器，转而采用视图控制器。在这里，这很有意义；我们希望这个视图控制器只关注专辑，而不是应用程序的其他部分。然而，一个高级控制器仍然是Ext
    JS MVVM架构的有效部分，可以在需要以比视图控制器更高层次协调应用程序的情况下重新引入。
- en: A brief interlude regarding stores
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于存储的简短插曲
- en: Throughout this entire chapter, we've talked a lot about models, but never specifically
    about stores despite using them in our example applications. Why isn't it "SVC"
    or "SVVM"?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个这一章中，我们谈了很多关于模型的内容，但从未具体讨论过存储，尽管我们在示例应用程序中使用了它们。为什么不是“SVC”或“SVVM”？
- en: In Ext JS, a store is a specific class, which brings specific functionality
    and is tightly bound into your application. However, in a simple MVC or MVVM implementation,
    the "store" could just be an array of models, rather than being a separate architectural
    feature. So, a store is really just a way of collecting models together and Ext
    JS happens to be the place where we can do lots of extra things (such as sorting,
    filtering, and batching).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS中，存储是一个特定的类，它提供了特定的功能，并且紧密绑定到您的应用程序中。然而，在简单的MVC或MVVM实现中，“存储”可能只是模型数组，而不是一个单独的架构特性。因此，存储实际上只是收集模型的一种方式，而Ext
    JS恰好是我们可以进行许多额外操作的地方（例如排序、过滤和分批）。
- en: Inter-communication
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互通信
- en: We've shown how to create a simple application that uses several moving parts
    to create a logical unit. Thanks to the MVVM pattern, we have a methodology that
    allows the parts of this unit to communicate without having to be explicitly tied
    to the implementation details of other parts.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何创建一个简单的应用程序，该应用程序使用几个移动部件来创建一个逻辑单元。多亏了MVVM模式，我们有一个允许这个单元的各个部分进行通信的方法，而无需明确绑定到其他部分的实现细节。
- en: 'When we extend our application, we''ll have several of these logical units,
    perhaps, an artist section in addition to an album section. Now, these have to
    communicate with each other in turn. This represents one of the main problems
    in software architecture: how to allow albums and artists to talk to each other
    without contaminating either component with details of the other. It''s a problem
    that scales in direct proportion to the size and complexity of an application.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展我们的应用程序时，我们可能会有几个这样的逻辑单元，也许除了专辑部分外，还有一个艺术家部分。现在，这些部分必须依次相互通信。这代表了软件架构中的一个主要问题：如何允许专辑和艺术家之间进行通信，而不使任何组件受到另一个组件详细信息的污染。这是一个与应用程序的大小和复杂性成正比的问题。
- en: The main event
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要事件
- en: One approach to this problem is to allow your application parts to fire off
    custom events, each containing a payload that can be consumed by any other part
    of your application that might be interested in them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是允许应用程序部分触发自定义事件，每个事件都包含一个可以被任何可能对它们感兴趣的应用程序部分消费的有效负载。
- en: In fact, we see this in action all the time in web development. Event handlers
    are an integral part of JavaScript programming as we bind functions to the events
    thrown by user interface elements (such as buttons) or to browser events (such
    as `window.onload`). We've touched on this in our example code already; our view
    fired off a `rowdblclick` event that was handled by our view controller.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们在Web开发中经常看到这种情况。事件处理器是JavaScript编程的一个基本部分，因为我们把函数绑定到用户界面元素（如按钮）或浏览器事件（如`window.onload`）抛出的事件。我们已经在示例代码中提到了这一点；我们的视图触发了一个`rowdblclick`事件，该事件由我们的视图控制器处理。
- en: In complex applications, developers will often implement a feature called an
    event bus, a way of taking the events that application components fire off and
    transporting them to various subscribers. Since Ext JS 4.2, event domains have
    allowed developers to incorporate a similar feature into their code base.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的应用程序中，开发者通常会实现一个名为事件总线（event bus）的功能，这是一种将应用程序组件触发的事件传输到各个订阅者的方式。自从 Ext
    JS 4.2 版本以来，事件域（event domains）允许开发者将类似的功能集成到他们的代码库中。
- en: Event domains
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件域
- en: 'Event domains allow controllers to react to events from various different sources
    in your application. The default sources are:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 事件域允许控制器对应用程序中来自各种不同来源的事件做出反应。默认来源包括：
- en: '**Components**: These are events fired from components. This is essentially
    the functionality that `Ext.app.Controller.control()` provides by handling events
    from classes that extend `Ext.Component` and bind them to event listeners.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件（Components）**：这些是从组件中触发的事件。这本质上就是 `Ext.app.Controller.control()` 通过处理扩展
    `Ext.Component` 的类的事件并将它们绑定到事件监听器所提供的功能。'
- en: '**Global**: These are events fired from a single global source and used to
    bind arbitrary application-wide events.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局（Global）**：这些是从单个全局来源触发的事件，用于绑定任意应用程序范围内的事件。'
- en: '**Controller**: These are events fired from other controllers.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器（Controller）**：这些是从其他控制器中触发的事件。'
- en: '**Store**: These are events fired from a store.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储（Store）**：这些是从存储中触发的事件。'
- en: '**Direct**: These are events fired from classes that extend `Ext.direct.Provider`.
    This is only used if you require `Ext.direct.Manager` in your application.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接（Direct）**：这些是从扩展 `Ext.direct.Provider` 的类中触发的事件。这仅在您需要应用程序中的 `Ext.direct.Manager`
    时使用。'
- en: Some event domains allow you to filter the received events by a selector (usually
    the ID associated with the source), but in the Component case, you can use a full-blown
    `Ext.Component` query. This allows you to have finer-grained control on how to
    subscribe to events.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件域允许您通过选择器（通常是与源关联的 ID）过滤接收到的事件，但在组件（Component）的情况下，您可以使用完整的 `Ext.Component`
    查询。这允许您对如何订阅事件有更细粒度的控制。
- en: An event domain example
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件域示例
- en: 'Let''s go back to our MVVM album example we created earlier. Our view had handler
    and listener configurations that tied view events to event handlers that we put
    in our view controller. However, event domains allow us to remove this tie and
    give all of the control to the view component. In `view/album/Album.js` in our
    previous example, we can remove the listener config on the grid and the handler
    on the button and then add the following code to `view/album/AlbumController.js`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前创建的 MVVM 相册示例。我们的视图有处理程序和监听器配置，这些配置将视图事件绑定到我们放在视图控制器中的事件处理程序。然而，事件域允许我们解除这种绑定，并将所有控制权交给视图组件。在我们的前一个示例中，`view/album/Album.js`，我们可以移除网格上的监听器配置和按钮上的处理程序，然后向
    `view/album/AlbumController.js` 添加以下代码：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is slightly more verbose, so look at what exactly is happening here. We
    pass an object to `this.listen`, which contains a component property; this indicates
    we are configuring the Component Event Domain. Inside here, we use two selectors,
    one for the grid itself and one for the summary button, and inside these definitions
    we specify the event we are binding to and the event handlers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这稍微有点冗长，所以看看这里到底发生了什么。我们向 `this.listen` 传递一个对象，它包含一个组件属性；这表示我们正在配置组件事件域。在这里，我们使用两个选择器，一个用于网格本身，一个用于摘要按钮，在这些定义中我们指定要绑定的事件和事件处理程序。
- en: This gives us the ability to remove anything clever from the view and put it
    all in the view controller. The view deals purely with presentation and the view
    controller deals with the logic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够从视图中移除任何巧妙的功能，并将其全部放入视图控制器中。视图只处理展示，而视图控制器处理逻辑。
- en: Using custom events
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义事件
- en: 'We''ve shown how event domains can be used to separate our code concerns even
    further, but now, you''ll see how they can help orchestrate interactions at a
    higher level. For this, let''s take a look at a theoretical situation in which
    our application has grown to incorporate multiple views and view controllers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用事件域进一步分离我们的代码关注点，但现在，您将看到它们如何帮助在更高层次上编排交互。为此，让我们看看一个理论情况，即我们的应用程序已经发展到包含多个视图和视图控制器：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've created a new `SearchController`, which is the view controller for a new
    `Search` view. We use `this.listen` to listen for events on the component event
    domain and filter them using the selector `'app-search button'` (a button within
    our new `Search` view). When the button is clicked on, we trigger an event handler
    method called `onSearchSubmit`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`SearchController`，它是新`Search`视图的视图控制器。我们使用`this.listen`来监听组件事件域上的事件，并使用选择器`'app-search
    button'`（我们新`Search`视图中的一个按钮）进行过滤。当按钮被点击时，我们触发一个名为`onSearchSubmit`的事件处理方法。
- en: 'We extract the search term that the user entered and then fire a second event,
    passing the search term as the event data. The event we fire is called `''search''`
    and rather than being tied to a button or other UI component, it can be subscribed
    to by other parts of the application as a pure application event. Let''s take
    a look at how it could be consumed:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取用户输入的搜索词，然后触发第二个事件，将搜索词作为事件数据传递。我们触发的事件称为`'search'`，它不是绑定到按钮或其他UI组件，而是可以被应用程序的其他部分作为纯应用程序事件订阅。让我们看看它如何被消费：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is a snippet of the `AlbumController` we''ve seen before with some extra
    goodness. With `this.listen`, we use the `''*''` selector to allow all controllers
    on the event domain. Then, we specify that we want to handle the search event
    with the `onSearch` handler method. This should all be feeling pretty familiar
    by now! The handler method could be as simple as the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前见过的`AlbumController`片段，增加了一些额外的功能。使用`this.listen`，我们使用`'*'`选择器允许事件域上的所有控制器。然后，我们指定我们想要使用`onSearch`处理方法处理搜索事件。现在这一切都应该感觉非常熟悉了！处理方法可能像以下代码一样简单：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Assume that we created a `search` method on the view model. With just a small
    amount of code, we allowed two distinct parts of our application to communicate
    using information about our application rather than information about themselves.
    This is key to keeping the search part of this code unaware about the albums part
    and allows very clear-cut divisions between them. This provides easier testing
    through separation of concerns, better maintainability, and easier comprehension
    of how the application is structured.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在视图模型中创建了一个`search`方法。仅仅通过一小段代码，我们就允许应用程序的两个不同部分通过关于我们应用程序的信息而不是它们自己的信息进行通信。这是保持代码中的搜索部分对专辑部分一无所知的关键，并且使得它们之间的界限非常清晰。这通过关注点的分离提供了更简单的测试，更好的可维护性，以及更容易理解应用程序的结构。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: MVC and MVVM are key architectural constructs that we need to firmly understand
    before starting on a new project. Given that they're so embedded in Ext JS, it's
    even more important to have a good grasp of the ideas behind them and why implementing
    such patterns will assist in the way we construct our code base. In the next chapter,
    we'll move on to more practical examples of structuring an Ext JS application,
    incorporating MVVM concepts with a variety of other ideas that set out a strong
    platform to build on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: MVC和MVVM是我们开始新项目前必须牢固掌握的关键架构概念。鉴于它们在Ext JS中如此根深蒂固，对它们背后的理念以及为什么实现这些模式将有助于我们构建代码库的方式有一个良好的理解就更加重要了。在下一章中，我们将继续探讨更多关于如何构建Ext
    JS应用程序的实际例子，结合MVVM概念以及其他一些理念，为构建一个强大的平台奠定基础。
