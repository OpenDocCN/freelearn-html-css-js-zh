- en: Chapter 3. The Login Page
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 登录页面
- en: It is very common to have a login page for an application of which we want to
    control the access to the system by identifying and authenticating the user through
    the credentials presented by the user. Once the user is logged in, we can track
    the actions performed by the user. We can also restrain access to some features
    and screens of the system that we do not want a particular user to have access
    to or even a specific group of users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要通过用户提供的凭据来识别和验证用户以控制对系统访问的应用程序，登录页面是非常常见的。一旦用户登录，我们可以跟踪用户执行的操作。我们还可以限制对系统某些功能和屏幕的访问，这些功能和屏幕我们不希望特定用户或特定用户组访问。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating the login page
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建登录页面
- en: Handling the login page on the server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上处理登录页面
- en: Adding the Caps Lock warning message in the **Password** field
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**密码**字段中添加大写锁定警告信息
- en: Submitting the form when pressing the *Enter* key
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下*Enter*键时提交表单
- en: Encrypting the password before sending to the server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送到服务器之前加密密码
- en: The Login screen
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录界面
- en: 'The **Login** window will be the first view that we are going to implement
    in this project. We are going to build it step-by-step, as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**登录**窗口将是我们在本项目中要实现的第一视图。我们将逐步构建它，如下所示：'
- en: The user will enter the username and password to log in
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将输入用户名和密码进行登录
- en: Client-side validation (username and password required to log in)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端验证（登录所需的用户名和密码）
- en: Submit the login form by pressing *Enter*
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下*Enter*键提交登录表单
- en: Encrypt the password before sending to the server
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送到服务器之前加密密码
- en: Password Caps Lock warning (similar to Windows OS)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码大写锁定警告（类似于Windows操作系统）
- en: Multilingual capability
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言功能
- en: 'Except for the multilingual capability, which we are going to implement in
    the next chapter, we will implement all the other features throughout this topic.
    So at the end of the implementation, we will have a **Login** window that looks
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们将在下一章中实现的多语言功能外，我们将在此主题的其余部分实现所有其他功能。因此，在实现结束时，我们将拥有一个如下所示的**登录**窗口：
- en: '![The Login screen](img/0457OT_03_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![登录界面](img/0457OT_03_01.jpg)'
- en: So let's get started!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating the Login screen
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录界面
- en: Under the `app/view` directory, we will create a new folder to organize all
    the source code related to the **Login** screen named `login`. Inside the `login`
    folder, we will also create a new file named `Login.js`. In this file, we will
    implement all the code that the user is going to see on the screen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/view`目录下，我们将创建一个新的文件夹来组织所有与**登录**屏幕相关的源代码，命名为`login`。在`login`文件夹内，我们还将创建一个名为`Login.js`的新文件。在这个文件中，我们将实现用户将在屏幕上看到的全部代码。
- en: 'Inside `view/login/Login.js`, we will implement the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`view/login/Login.js`内部，我们将实现以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the first line (`#1`), we have the definition of the class. To define a
    class, we use `Ext.define`, which (`define`) is a method call of the `Ext` singleton
    class, and which takes two arguments: the class name (`#1`) and the object literal
    with the configuration of the class (`#2`–`#13`).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行（`#1`），我们有类的定义。要定义一个类，我们使用`Ext.define`，这是一个`Ext`单例类的`define`方法调用，它接受两个参数：类名（`#1`）和包含类配置的对象字面量（`#2`–`#13`）。
- en: 'We also need to pay attention to the name of the class. This is the formula
    suggested by Sencha in Ext JS MVC projects: *App Namespace + package name + name
    of the JS file*. In the previous chapter, we defined the namespace as `Packt`
    (the name of the application we passed as parameter for the `sencha generate app`
    command). If we open an existing file that was created by Sencha Cmd (the `app/view/main/Main.js`
    file) for example, we will note that the name of the class starts with `Packt`.
    So all the classes we are going to create through out this book will start with
    the namespace `Packt`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要注意类的名称。这是Sencha在Ext JS MVC项目中建议的公式：*应用程序命名空间 + 包名 + JS文件名*。在上一章中，我们将命名空间定义为`Packt`（我们传递给`sencha
    generate app`命令的应用程序名称）。例如，如果我们打开由Sencha Cmd创建的现有文件（如`app/view/main/Main.js`文件），我们会注意到类的名称以`Packt`开头。因此，我们将在此书中创建的所有类都将以命名空间`Packt`开头。
- en: 'We are creating a View for this project, so we will create the JS file under
    the `view` folder. For organization purposes, we created a subfolder named `login`.
    And then, the name of the file we created is `Login.js`; therefore, we will lose
    the `.js` and use only `Login` as the name of the View. Putting it all together,
    we have `Packt.view.login.Login`, and this will be the name of our class. It is
    very important that the class name follows the directory layout as explained;
    otherwise, we can get an error in the code saying Ext JS did not find the class.
    The following screenshot shows the dependency between the project directory layout
    and the class name:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为这个项目创建一个视图，因此我们将在`view`文件夹下创建JS文件。为了组织目的，我们创建了一个名为`login`的子文件夹。然后，我们创建的文件名为`Login.js`；因此，我们将丢弃`.js`，只使用`Login`作为视图的名称。将所有这些放在一起，我们得到`Packt.view.login.Login`，这将是我们的类名。非常重要的一点是，类名必须遵循如上所述的目录布局；否则，我们可能会在代码中得到错误，表示Ext
    JS没有找到该类。以下截图显示了项目目录布局和类名之间的依赖关系：
- en: '![Creating the Login screen](img/0457OT_03_20.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![创建登录屏幕](img/0457OT_03_20.jpg)'
- en: Then, we say that the `login` class will extend from the `Window` class (`#2`).
    Recapitulating what we have covered in [Chapter 1](ch01.html "Chapter 1. Sencha
    Ext JS Overview"), *Sencha Ext JS Overview*, we can use inheritance in Ext JS.
    The `login` class will inherit the behavior from the `Window` class (it is a subclass
    of the `Component` class). The `window` component represents a pop up that is
    rendered centralized in the browser.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们说`login`类将扩展自`Window`类（`#2`）。回顾我们在[第1章](ch01.html "第1章. Sencha Ext JS 概述")中介绍的内容，*Sencha
    Ext JS 概述*，我们可以在 Ext JS 中使用继承。`login`类将从`Window`类继承行为（它是`Component`类的子类）。`window`组件代表一个在浏览器中渲染为中心的弹出窗口。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information about the window component, please access [http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.window.Window](http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.window.Window).
    And for more details on inheritance, please read [http://goo.gl/v4bmq8](http://goo.gl/v4bmq8).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于窗口组件的信息，请访问[http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.window.Window](http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.window.Window)。有关继承的更多详细信息，请阅读[http://goo.gl/v4bmq8](http://goo.gl/v4bmq8)。
- en: 'We also assign this class: `xtype` (`#3`). The `xtype` class is a shorter name
    that can be used to instantiate the class instead of using its full name. We can
    also use the configuration `alias` instead of `xtype`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还分配了这个类：`xtype`（`#3`）。`xtype`类是一个较短的名称，可以用它来实例化类，而不是使用它的完整名称。我们还可以使用配置`alias`而不是`xtype`。
- en: 'The `alias` for a class that extends from a component always starts with `widget`,
    followed by the `alias` or `xtype` class we want to assign. If we want to use
    the `alias` configuration instead of `xtype`, we could use `alias: ''widget.login-dialog''`
    instead of `xtype: ''login-dialog''`. The result will be the same; it is just
    a matter of personal preference.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '扩展自组件的类的`alias`总是以`widget`开头，后面跟着我们想要分配的`alias`或`xtype`类。如果我们想使用`alias`配置而不是`xtype`，我们可以使用`alias:
    ''widget.login-dialog''`而不是`xtype: ''login-dialog''`。结果将相同；这只是个人偏好的问题。'
- en: 'The naming convention for `xtype` and `alias` is lowercase. It is also important
    to remember that the alias must be unique in an application. In this case, we
    want to assign the `xtype` class `login` to this class so that later we can instantiate
    this same class using its `alias` (which is the same as `xtype`). For example,
    we can instantiate the `Login` class in five different ways:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`xtype`和`alias`的命名约定是小写。还重要的是要记住，别名在应用程序中必须是唯一的。在这种情况下，我们想将`xtype`类`login`分配给这个类，以便以后我们可以使用它的`alias`（与`xtype`相同）来实例化这个相同的类。例如，我们可以以五种不同的方式实例化`Login`类：'
- en: 'Option 1: Using the complete name of the class, which is the most used method:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项1：使用类的完整名称，这是最常用的方法：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Option 2: Using `alias` in the `Ext.create` method:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项2：在`Ext.create`方法中使用`alias`：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Option 3: Using `Ext.widget`, which is shorthand for `Ext.ClassManager.instantiateByAlias`:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项3：使用`Ext.widget`，它是`Ext.ClassManager.instantiateByAlias`的简写：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Option 4: Using `xtype` as an item of another component:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项4：将`xtype`作为另一个组件的项目：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Option 5: Using the `new` keyword:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项5：使用`new`关键字：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this book, we will use the options 1, 3, and 4 the most. Options 1, 2, 3,
    and 5 return a reference to the instantiated component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将最常使用选项1、3和4。选项1、2、3和5返回实例化组件的引用。
- en: Option number 5 is not a good practice. Although options 4 and 5 were the only
    way to instantiate classes until Ext JS 3, the other options were introduced in
    Ext JS 4, and option 5 became deprecated.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选项5不是一个好的实践。尽管选项4和5是Ext JS 3之前实例化类的唯一方式，但其他选项是在Ext JS 4中引入的，并且选项5已经弃用。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although option 5 became deprecated with Ext JS 4 and later versions, we can
    still find some code in the Ext JS documentation and official Ext JS examples
    that use the `new` keyword. But do not get confused because of it. Option 5 should
    be avoided, always!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管选项5在Ext JS 4及其后续版本中已经弃用，但我们仍然可以在Ext JS文档和官方Ext JS示例中找到一些使用`new`关键字的代码。但不要因此感到困惑。选项5应该总是避免使用！
- en: 'Then we have the `autoShow` configured to `true` (`#4`). Consider the following
    line of code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`autoShow`配置为`true`（`#4`）。考虑以下代码行：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we execute the preceding code, an instance of the `Login` class will be
    created (and if we need to, we can store this reference in a variable to manipulate
    it later). As the `Login` class is a subclass of the `Window` class, it inherits
    all its behavior, and one if its behaviors is that the window is not displayed
    automatically when instantiated. If we want to display the `Window` class (or
    any of its subclasses in the application), we need to call the `show()` method
    manually, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行前面的代码时，将创建`Login`类的实例（如果我们需要的话，我们可以将这个引用存储在变量中以供以后操作）。由于`Login`类是`Window`类的子类，它继承了所有行为，其中之一就是实例化时窗口不会自动显示。如果我们想在应用程序中显示`Window`类（或其任何子类），我们需要手动调用`show()`方法，如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An alternative to the preceding code is to have the `autoShow` configuration
    set to `true`. This way the `Window` class (or the `login` class in our case)
    will be automatically displayed when we instantiate it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的一个替代方案是将`autoShow`配置设置为`true`。这样，当实例化时，`Window`类（或我们情况下的`login`类）将自动显示。
- en: We also have the `height` (`#5`) and `width` (`#6`) of the window.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有窗口的`高度`（`#5`）和`宽度`（`#6`）。
- en: We set `layout` as `fit` (`#7`). Recapitulating, the `fit` layout is used when
    the parent container (in this case, `Login`) has only one child, and this child
    will occupy all the available space of the parent container. As our **Login**
    window will have two fields inside it (username and password), these two fields
    need to be placed inside the `form` subclass . In this case, the `form` subclass
    will be the child of the `Login` class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`layout`设置为`fit`（`#7`）。总结一下，当父容器（在这种情况下，`Login`）只有一个子容器时，使用`fit`布局。由于我们的**Login**窗口将包含两个字段（用户名和密码），这两个字段需要放置在`form`子类中。在这种情况下，`form`子类将是`Login`类的子类。
- en: We are setting `iconCls` (`#8`) to the **Login** window; this way, we will have
    an icon of a key in the header of the window (we will set up the icons later in
    this chapter). We can also give a `title` to the window (`#9`), and in this case,
    we chose `Login`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`iconCls`（`#8`）设置为**Login**窗口；这样，窗口的标题栏将显示一个钥匙图标（我们将在本章后面设置图标）。我们也可以给窗口一个`标题`（`#9`），在这种情况下，我们选择了`Login`。
- en: There are also the `closeAction` (`#10`) and `closable` (`#11`) configurations.
    The `closeAction` will tell if we want to destroy the window when we close it.
    In this case, we do not want to destroy it; we only want to hide it. And the `closable`
    configuration tells us whether we want to display the *X* icon on the top-right
    corner of the window. As this is a **Login** window, we do not want to give this
    option for the user (the user can only try to submit the username and password
    to log in to the application).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样还有`closeAction`（`#10`）和`closable`（`#11`）配置。`closeAction`将告诉我们当我们关闭窗口时是否想要销毁它。在这种情况下，我们不想销毁它；我们只想隐藏它。而`closable`配置告诉我们是否想在窗口右上角显示*X*图标。由于这是一个**Login**窗口，我们不希望给用户这个选项（用户只能尝试提交用户名和密码来登录应用程序）。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What is the difference between the methods `close`, `hide`, and `destroy`? The
    `close` method closes the panel, and by default, this method removes it from the
    DOM and destroys the panel object and all its descendant components. The `hide`
    method hides the component, setting it to invisible (it can be made visible again
    by calling the `show` method). And the `destroy` method cleans up the object and
    its resources, but removes it from the DOM and frees the object so that it can
    be cleaned by the garbage collector.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`close`、`hide`和`destroy`方法之间有什么区别？`close`方法关闭面板，并且默认情况下，此方法将其从DOM中删除并销毁面板对象及其所有子组件。`hide`方法隐藏组件，将其设置为不可见（可以通过调用`show`方法再次使其可见）。而`destroy`方法清理对象及其资源，但将其从DOM中删除并释放对象，以便垃圾回收器可以清理它。'
- en: We also have the `draggable` (`#12`) and `resizable` (`#13`) configurations.
    The `draggable` configuration controls whether the component can be `draggable`
    throughout the browser space. When the `resizable` configuration is set to `true`
    (its default value), the user can scroll over the corner of the component and
    resize it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`draggable`（`#12`）和`resizable`（`#13`）配置。`draggable`配置控制组件是否可以在整个浏览器空间内进行拖动。当`resizable`配置设置为`true`（其默认值）时，用户可以滚动到组件的角落并调整其大小。
- en: 'So far, this is the output we have—a single window with a blank icon in the
    top-left corner with the title **Login** (we will set up all the icons later in
    this chapter):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是我们得到的输出——一个顶部左角带有空白图标、标题为**登录**（我们将在本章后面设置所有图标）的单个窗口：
- en: '![Creating the Login screen](img/0457OT_03_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![创建登录界面](img/0457OT_03_02.jpg)'
- en: 'The next step is to add the `form` with the `username` and `password` fields.
    We are going to add the following code to the `Login` class (after line `#13`):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加包含`username`和`password`字段的`form`。我们将在`Login`类中添加以下代码（在`#13`行之后）：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we are using the `fit` layout, we can only declare one child `item` inside
    the `Login` class. So we are going to add a `form` (`#14`) inside the `Login`
    class. Note that here we are using option 4 presented earlier. When declaring
    items in Ext JS, this is usually the way we instantiate the components (using
    option 4). We added a body `padding` to the `form` body (`#15`), which is going
    to add a space between the form and the window border, making it look prettier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用`fit`布局，我们只能在`Login`类内部声明一个子`item`。因此，我们将在`Login`类内部添加一个`form`（`#14`）。请注意，在这里我们正在使用之前提到的选项4。在Ext
    JS中声明项目时，这通常是实例化组件的方式（使用选项4）。我们向`form`的主体添加了`body padding`（`#15`），这将增加表单与窗口边框之间的空间，使其看起来更美观。
- en: As we are going to add two fields to the form, we probably want to avoid repeating
    some code. That is why we are going to declare some field configurations inside
    the `defaults` configuration of the `form` (`#16`); this way, the configuration
    we declare inside `defaults` will be applied to all items of the `form`, and we
    will need to declare only the configurations we want to customize. As we are going
    to declare two fields, both of them will be of the type `textfield` (`#17`).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在表单中添加两个字段，我们可能希望避免重复某些代码。这就是为什么我们将在`form`的`defaults`配置中声明一些字段配置（`#16`）；这样，我们在`defaults`中声明的配置将应用于`form`的所有项目，我们只需要声明我们想要定制的配置。由于我们将声明两个字段，它们都将为`textfield`类型（`#17`）。
- en: The default layout used by the `form` component is the `anchor` layout, so we
    do not need to make this declaration explicit. However, we want both fields to
    occupy all the horizontal available space of the body of the form. That is why
    we are declaring the `anchor` as `100%` (`#18`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`form`组件默认使用的布局是`anchor`布局，因此我们不需要明确声明这一点。然而，我们希望两个字段都占据表单主体的所有可用水平空间。这就是为什么我们将`anchor`声明为`100%`（`#18`）的原因。'
- en: While the `fit` layout allows you to render only one child component that will
    occupy all the available space within the parent container, the Anchor layout
    enables you to anchor child containers relative to the parent container dimensions.
    In this case, we want the text fields to occupy 100 percent of the horizontal
    space available in the form. If we wanted the text fields to occupy only 70 percent
    of the available horizontal space, we could set the `anchor` config to `70%`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`fit`布局允许你渲染一个子组件，该组件将占据父容器内的所有可用空间，但`Anchor`布局使你能够将子容器相对于父容器尺寸进行定位。在这种情况下，我们希望文本字段占据表单中可用的100%水平空间。如果我们希望文本字段只占据70%的可用的水平空间，我们可以将`anchor`配置设置为`70%`。
- en: By default, the `width` attribute of the label of the `textfield` class is 100
    pixels. This is too much space for a label `User` and `Password`, so we are going
    to decrease this value to `60 pixels` (`#19`).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`textfield`类的标签的`width`属性是100像素。这对于`User`和`Password`标签来说空间太多，所以我们将这个值减少到`60像素`（`#19`）。
- en: And finally, we have the `user` `textfield` and the `password` `textfield`.
    The configuration `name` is what we are going to use to identify each field when
    we submit the form to the server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`user` `textfield`和`password` `textfield`。配置`name`是我们提交表单到服务器时用来识别每个字段的内容。
- en: 'There is only one detail missing: when the user types the password into the
    field, the system cannot display its value—we need to mask it somehow. That is
    why `inputType` is `''password''` (`#20`) for the `password` field because we
    want to display bullets instead of the original value—and the user will not be
    able to see the password value.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 只缺少一个细节：当用户在字段中输入密码时，系统不能显示其值——我们需要以某种方式将其隐藏。这就是为什么`password`字段的`inputType`是`'password'`（`#20`），因为我们想显示点而不是原始值——用户将看不到密码值。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other input types can be used with the `textfield` as well. Input types of HTML5,
    such as `email`, `url`, and `tel` can be used as well. However, if the application
    is being executed from an older browser (or a browser that does not support the
    input type), Ext JS automatically changes it to its default value, which is `text`.
    For more information about HTML5 input types and browsers that support each type,
    please visit [http://www.w3schools.com/html/html5_form_input_types.asp](http://www.w3schools.com/html/html5_form_input_types.asp).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其他输入类型也可以与`textfield`一起使用。HTML5的输入类型，如`email`、`url`和`tel`也可以使用。然而，如果应用程序是从较旧的浏览器（或不支持输入类型的浏览器）中执行，Ext
    JS会自动将其更改为默认值，即`text`。有关HTML5输入类型和支持每种类型的浏览器更多信息，请访问[http://www.w3schools.com/html/html5_form_input_types.asp](http://www.w3schools.com/html/html5_form_input_types.asp)。
- en: 'Now we have improved our **Login** window a little more. This is the output
    so far:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对**登录**窗口进行了一些改进。这是到目前为止的输出：
- en: '![Creating the Login screen](img/0457OT_03_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建登录屏幕](img/0457OT_03_03.jpg)'
- en: Client-side validations
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端验证
- en: The field component in Ext JS provides some client-side validation capability.
    This can save time and also bandwidth (the system will only make a server request
    when it is sure the information has the basic validation and we also do not need
    to wait for the server to validate the input). It also helps to point out to the
    user where they have gone wrong in filling out the form. Of course it is also
    good to validate the information again on the server side for security reasons,
    but for now we will focus on the validations we can apply to the form of our **Login**
    window.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS中的字段组件提供了一些客户端验证功能。这可以节省时间和带宽（系统只有在确认信息具有基本验证时才会进行服务器请求，我们也不需要等待服务器验证输入）。这也有助于指出用户在填写表格时出错的地方。当然，出于安全原因，在服务器端再次验证信息也是好的，但在此我们将专注于我们可以应用于**登录**窗口的表单验证。
- en: 'Let''s brainstorm some validations we can apply to the username and password
    fields:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们头脑风暴一下可以应用于用户名和密码字段的验证：
- en: The `username` and `password` must be mandatory—how are you going to authenticate
    the user without a username and password?
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名和密码必须是必填项——没有用户名和密码，你如何验证用户？
- en: The user can only enter alphanumeric characters (A-Z, a-z, and 0-9) in both
    fields
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户只能在两个字段中输入字母数字字符（A-Z，a-z和0-9）
- en: The user can only type between 3 and 25 chars on the `username` field
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户只能在`username`字段中输入3到25个字符
- en: The user can only type between 3 and 15 chars on the `password` field
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户只能在`password`字段中输入3到15个字符
- en: 'So let''s add into the code the ones that are common to both fields:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将以下代码添加到两个字段共有的部分中：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are going to add the preceding configurations inside the `defaults` configuration
    of the `form` as they all apply to both fields we have. First, both need to be
    mandatory (`#21`), second, we can only allow the user to enter alphanumeric characters
    (`#22`), and the minimum number of characters the user needs to input is three
    (`#23`). Then, a last common configuration is that we want to display any validation
    error message under the field (`#24`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把前面的配置添加到`form`的`defaults`配置中，因为它们都适用于我们拥有的两个字段。首先，两者都需要是必填项（`#21`），其次，我们只能允许用户输入字母数字字符（`#22`），用户需要输入的最小字符数是三个（`#23`）。然后，最后一个常见的配置是我们希望在字段下方显示任何验证错误消息（`#24`）。
- en: 'And the only validation customized for each field is that we can enter a maximum
    of 25 characters in the **User** field:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 而为每个字段定制的唯一验证是，我们可以在**用户**字段中输入最多25个字符：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And a maximum of 15 characters in the **Password** field:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在**密码**字段中最多只能输入15个字符：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After we apply the client validations, we will have the following output just
    in case the user went wrong in filling out the **Login** window:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用客户端验证后，如果用户在填写**登录**窗口时出错，我们将得到以下输出：
- en: '![Client-side validations](img/0457OT_03_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![客户端验证](img/0457OT_03_04.jpg)'
- en: 'If you do not like the error message being displayed under the field, we can
    change the place where the error message appears. We just need to change the `msgTarget`
    value. The available options are: `title`, `under`, `side`, and `none`. We can
    also show the error message as a `tooltip` (`qtip`) or display them in a specific
    target (`innerHTML` of a specific component).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢在字段下方显示的错误消息，我们可以更改错误消息出现的位置。我们只需更改`msgTarget`的值。可用的选项有：`title`、`under`、`side`和`none`。我们还可以将错误消息显示为`tooltip`（`qtip`）或在特定目标中显示它们（特定组件的`innerHTML`）。
- en: For the `side` option, for example, the red exclamation mark will be displayed
    on the side of the field, and when the user does a mouseover on it, the `tooltip`
    with the error message is displayed. Once the input is valid (the user enters
    more characters in the **User** field or deletes some characters from the **Password**
    field, the error message disappears automatically).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`side`选项，例如，红色感叹号将显示在字段的旁边，当用户将其鼠标悬停在其上时，将显示包含错误消息的`tooltip`。一旦输入有效（用户在**用户**字段中输入更多字符或从**密码**字段中删除一些字符），错误消息将自动消失）。
- en: Creating custom VTypes
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义VTypes
- en: Many systems have a special format for passwords. Let's say we need the password
    to have at least one digit (0-9), one letter lowercase, one letter uppercase,
    one special character (@,#,$,%, and so on) and its length between 6 and 20 characters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统都有密码的特殊格式。比如说，我们需要密码至少包含一个数字（0-9）、一个小写字母、一个大写字母、一个特殊字符（@、#、$、%，等等）以及长度在6到20个字符之间。
- en: 'We can create a regular expression to validate that the password is being entered
    into the app. And to do this, we can create a custom `VType` to do the validation
    for us. To create a custom `VType` is simple. For our case, we can create a custom
    `VType` called `customPass`, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个正则表达式来验证密码是否被输入到应用程序中。为此，我们可以创建一个自定义的`VType`来进行验证。要创建自定义`VType`很简单。在我们的例子中，我们可以创建一个名为`customPass`的自定义`VType`，如下所示：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The name of our custom `VType` is `customPass`, and we need to declare a function
    that will validate our regular expression. And `customPassText` is the message
    that will be displayed to the user just in case the incorrect password format
    is entered.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义的`VType`名为`customPass`，我们需要声明一个函数来验证我们的正则表达式。`customPassText`是当用户输入错误的密码格式时将显示给用户的消息。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about regular expressions, please visit [http://www.regular-expressions.info/](http://www.regular-expressions.info/).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于正则表达式的信息，请访问[http://www.regular-expressions.info/](http://www.regular-expressions.info/)。
- en: The preceding code can be added anywhere in the code, inside the `init` function
    of a Controller, inside the `launch` function of `app.js`, or even in a separate
    JavaScript file (recommended) where you can put all your custom `Vtypes`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以添加到代码的任何位置，例如在Controller的`init`函数中、在`app.js`的`launch`函数中，或者甚至在一个单独的JavaScript文件中（推荐），在那里您可以放置所有自定义的`Vtypes`。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `VType` is a singleton class that contains a set of commonly used field
    validation functions and provides a mechanism to create reusable custom field
    validations. For more information about this class and the default validations
    supported by Ext JS, please visit [http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.form.field.VTypes](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.form.field.VTypes).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`VType`是一个单例类，它包含了一组常用的字段验证函数，并提供了一种创建可重用自定义字段验证的机制。有关此类和Ext JS支持的默认验证的更多信息，请访问[http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.form.field.VTypes](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.form.field.VTypes)。'
- en: Create a new file named `CustomVTypes.js` under the `app` directory. Add the
    preceding code to this file. Now, we need this file to be loaded with our application
    as well. But hold your instincts to manually include this JavaScript file in the
    `index.html` file. We are going to follow best practices!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app` 目录下创建一个名为 `CustomVTypes.js` 的新文件。将前面的代码添加到这个文件中。现在，我们需要这个文件与我们的应用程序一起加载。但请抑制手动在
    `index.html` 文件中包含这个 JavaScript 文件的冲动。我们将遵循最佳实践！
- en: 'Locate the following code around line 110 of the `app.json` file inside the
    `masteringextjs` folder:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `masteringextjs` 文件夹中的 `app.json` 文件大约第 110 行找到以下代码：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make our `CustomVTypes.js` file automatically load with our application,
    we simply need to add the following highlighted code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的 `CustomVTypes.js` 文件自动与我们的应用程序一起加载，我们只需添加以下突出显示的代码：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `includeInBundle` configuration tells Sencha Cmd that this file needs to
    be added to the final `.js` file that is generated.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`includeInBundle` 配置告诉 Sencha Cmd，这个文件需要添加到最终生成的 `.js` 文件中。'
- en: 'Only one file can have the `bundle: true` configuration. This means that it
    is the main file of the application.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '只有一个文件可以配置 `bundle: true`。这意味着它是应用程序的主文件。'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always remember to have the `sencha app watch` command running in a terminal
    window so that Sencha Cmd can make a new build every time we make changes to the
    code. In this case, `CustomVTypes.js` will be loaded without any further changes
    to the `index.html` file. Really cool!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得在终端窗口中运行 `sencha app watch` 命令，以便 Sencha Cmd 每次我们更改代码时都能进行新的构建。在这种情况下，`CustomVTypes.js`
    将在没有进一步更改 `index.html` 文件的情况下被加载。真的很酷！
- en: 'Now, let''s apply the custom `VType` to our code. Add the following code to
    the password field:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将自定义的 `VType` 应用到我们的代码中。将以下代码添加到密码字段：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also, change the message target for the password field. As the error message
    is quite long, it will not look nice with the message target `under`. This will
    be the result after we apply the custom `vType`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，更改密码字段的提示目标。由于错误信息相当长，使用 `under` 作为消息目标看起来不会很好。这将是我们应用自定义 `vType` 后的结果：
- en: '![Creating custom VTypes](img/0457OT_03_05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义 VTypes](img/0457OT_03_05.jpg)'
- en: Adding the toolbar with buttons
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加带有按钮的工具栏
- en: Until now, we created the **Login** window, which contains a form with two fields
    and it is already being validated as well. The only thing missing is to add the
    two buttons, **Cancel** and **Submit**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建了 **登录** 窗口，其中包含一个带有两个字段的表单，并且它已经被验证。唯一缺少的是添加两个按钮，**取消** 和 **提交**。
- en: 'We are going to add the buttons as items of a `toolbar`, and the `toolbar`
    will be added on the `form` as a docked item. The `dockedItems` can be docked
    to either the *top*, *right*, *left*, or *bottom* of a panel (both form and window
    components are subclasses of a panel). In this case, we will `dock` the `toolbar`
    at the bottom of the form. Add the following code right after the items configuration
    of the form:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加按钮作为 `toolbar` 的项目，并将 `toolbar` 添加到 `form` 作为停靠项。`dockedItems` 可以停靠到面板的
    *顶部*、*右侧*、*左侧* 或 *底部*（表单和窗口组件都是面板的子类）。在这种情况下，我们将 `dock` `toolbar` 到表单的底部。在表单的项目配置之后添加以下代码：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we take a look back to the screenshot of the **Login** screen that we first
    presented at the beginning of this chapter, we will notice that there is a component
    for the translation/multilingual capability. And after this component, there is
    a space and then we have the **Cancel** and **Submit** buttons. As we do not have
    the multilingual component yet, we can only implement the two buttons, but they
    need to be at the right end of the form, and we need to leave that space. That
    is why we first need to add a `tbfill` component (`#25`), which is going to instruct
    the toolbar's layout to begin using the right-justified button container.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下本章开头首次展示的 **登录** 屏幕截图，我们会注意到有一个用于翻译/多语言功能的组件。在这个组件之后，有一个空格，然后是 **取消**
    和 **提交** 按钮。由于我们还没有多语言组件，我们只能实现这两个按钮，但它们需要放在表单的右端，并且我们需要留出那个空格。这就是为什么我们首先需要添加一个
    `tbfill` 组件（`#25`），它将指导工具栏布局开始使用右对齐的按钮容器。
- en: Then we will add the **Cancel** button (`#26`) and then the **Submit** button
    (`#27`). We are going to add an icon to both buttons (`iconCls`) that we will
    add to our CSS file later in this chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加 **取消** 按钮（`#26`）和 **提交** 按钮（`#27`）。我们将为这两个按钮添加一个图标（`iconCls`），我们将在本章后面添加到
    CSS 文件中。
- en: We already have the client validations, but even with the validations, the user
    can click on the **Submit** button, and we want to avoid this behavior. That is
    why we are binding the **Submit** button to the form (`#28`); this way, the button
    will only be enabled if the form has no error from the client validation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了客户端验证，但即使有了验证，用户仍然可以点击**提交**按钮，我们希望避免这种行为。这就是为什么我们将**提交**按钮绑定到表单（`#28`）；这样，按钮只有在表单没有客户端验证错误的情况下才会启用。
- en: 'In the following screenshot, we can see the current output of the **Login**
    form (after we added the toolbar) and also verify the behavior of the **Submit**
    button:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到添加工具栏后的当前**登录**表单输出，以及验证**提交**按钮的行为：
- en: '![Adding the toolbar with buttons](img/0457OT_03_06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![添加带有按钮的工具栏](img/0457OT_03_06.jpg)'
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When we want to add a toolbar with buttons in a form, we can add it using the
    configuration `buttons` as well. For more information, please access [http://goo.gl/X38h8Q](http://goo.gl/X38h8Q).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在表单中添加带有按钮的工具栏时，我们可以使用`buttons`配置来添加。更多信息，请访问[http://goo.gl/X38h8Q](http://goo.gl/X38h8Q)。
- en: Running the code
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行代码
- en: To execute the code we have created so far, we need to make a few changes in
    the `Application.js` file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行我们到目前为止创建的代码，我们需要在`Application.js`文件中做一些更改。
- en: 'First, we need to declare the `views` we are using (only one in this case),
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要声明我们正在使用的`views`（在这种情况下只有一个），如下所示：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And the last change is inside the `launch` function. In the preceding chapter,
    we left a `console.log` message where we needed to instantiate our initial view;
    now we only need to replace the `console.log` message with the `Login` instance
    (`#1`):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个更改是在`launch`函数中。在前一章中，我们留下了一条`console.log`消息，在那里我们需要实例化我们的初始视图；现在我们只需要将`console.log`消息替换为`Login`实例（`#1`）：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that `Application.js` is OK, and we can execute what we have implemented
    so far!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Application.js`没有问题，我们可以执行到目前为止所实现的内容！
- en: A quick overview about Ext JS dynamic class loading
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于Ext JS动态类加载的简要概述
- en: Dynamic class loading was introduced in Ext JS 4\. It provides an integrated
    dependency management capability, and it is very useful, especially when working
    on the development (local) environment (it also plays an important role in the
    final production build). This capability is also one of the reasons why option
    5 for instantiating classes in Ext JS (using the keyword `new`) became deprecated
    and not a best practice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类加载是在Ext JS 4中引入的。它提供了一种集成的依赖管理能力，这在开发（本地）环境中非常有用（在最终的生产构建中也扮演着重要的角色）。这也是为什么Ext
    JS中实例化类（使用关键字`new`）的选项5被弃用，并且不是最佳实践的原因之一。
- en: What does dynamic loading mean? It means that we do not need to load all Ext
    JS SDK classes prior to load our application. For example, for the Login window,
    we are using the `Window`, `Form`, and `TextField` classes from the Ext JS SDK.
    To execute our application, we do not need the source code of the grid, tree,
    and charts. Do you agree?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 动态加载意味着什么？这意味着在我们加载应用程序之前，我们不需要加载所有Ext JS SDK类。例如，对于登录窗口，我们正在使用Ext JS SDK中的`Window`、`Form`和`TextField`类。为了执行我们的应用程序，我们不需要网格、树和图表的源代码。你同意吗？
- en: Still on the Login window example, when our application is loaded, Ext JS will
    read that the '`login.Login`' view needs to be loaded. As all the application
    source code is inside the `app` folder, and the views are inside the `app/view`
    folder, the Ext JS loader will expect to find the `app/view/login/Login.js` file,
    and inside this file it expects to find the '`Packt.view.login.Login`' class definition
    (this is why it is very important to follow the naming conventions we introduced
    earlier). The Ext JS loader will then see that this class inherits from the `Ext.window.Window`
    class, and if this class was not loaded yet, it is going to figure out all its
    dependencies (from the `extend` and `requires` declarations—we will discuss `requires`
    in a bit) and load them until we have all the source code required to execute
    the application loaded (and it will do this recursively until all code is loaded).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然以登录窗口为例，当我们的应用程序加载时，Ext JS 将读取 `'login.Login'` 视图需要被加载。由于所有应用程序源代码都在 `app`
    文件夹中，而视图在 `app/view` 文件夹中，Ext JS 加载器将期望找到 `app/view/login/Login.js` 文件，并且在这个文件中它期望找到
    `'Packt.view.login.Login'` 类定义（这就是为什么遵循我们之前介绍的命名约定非常重要）。然后 Ext JS 加载器将看到这个类继承自
    `Ext.window.Window` 类，如果这个类尚未加载，它将找出所有依赖项（从 `extend` 和 `requires` 声明中——我们将在稍后讨论
    `requires`），并将它们加载，直到我们加载了执行应用程序所需的全部源代码（并且它将递归地这样做，直到所有代码都加载完毕）。
- en: 'For example, when you try to execute the application, open the Chrome Developer
    Tools (*Ctrl + Shift + I* or *Command + Shift + I*) or Firebug for Firefox (enable
    all panels) and open the **Network** tab. We will be able to see all files that
    were loaded for our application, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你尝试执行应用程序时，打开 Chrome 开发者工具（*Ctrl + Shift + I* 或 *Command + Shift + I*）或
    Firefox 的 Firebug（启用所有面板）并打开 **网络** 选项卡。我们将能够看到为我们的应用程序加载的所有文件，如下所示：
- en: '![A quick overview about Ext JS dynamic class loading](img/0457OT_03_07.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![关于 Ext JS 动态类加载的快速概述](img/0457OT_03_07.jpg)'
- en: We know that **5MB** is scary for only a **Login** screen, but we will solve
    this issue when we do the production build later on this book. We do not need
    to worry about it for now.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 **5MB** 对于仅有的 **登录** 屏幕来说很可怕，但当我们在这本书的生产构建中解决此问题时，我们将解决这个问题。现在我们不需要担心它。
- en: What will happen later when we do the production build is that Ext JS will know
    which classes from the SDK need to be included in the final JavaScript file, will
    concatenate everything into a single file, and will also obfuscate it. If you
    try to open any of the files listed in the preceding screenshot, you will be able
    to read the source code (and it will be pretty and indented as the development
    source code should be).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行生产构建时会发生什么，Ext JS 将知道需要包含在最终 JavaScript 文件中的 SDK 中的哪些类，将所有内容合并成一个文件，并且还会对其进行混淆。如果你尝试打开前面截图中的任何文件，你将能够阅读源代码（并且它将像开发源代码一样美观和缩进）。
- en: Adding Font Awesome support (Glyph icons)
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Font Awesome 支持（符号图标）
- en: Using icons on the application improves its look and feel, it makes the application
    look prettier, and users usually enjoy it. However, unless we get (or buy) icons
    with different sizes, the icons are 16 x 16 pixels big. With the introduction
    of **CSS3**, one of the new features is called **CSS3 Web Fonts** ([http://www.w3schools.com/css/css3_fonts.asp](http://www.w3schools.com/css/css3_fonts.asp)),
    which allow us to use fonts that are not installed on the user's computer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用程序上的图标可以改善其外观和感觉，使应用程序看起来更漂亮，用户通常也会喜欢它。然而，除非我们（或购买）不同尺寸的图标，否则图标大小为 16 x
    16 像素。随着 **CSS3** 的引入，其中一项新特性被称为 **CSS3 网络字体** ([http://www.w3schools.com/css/css3_fonts.asp](http://www.w3schools.com/css/css3_fonts.asp))，它允许我们使用用户计算机上未安装的字体。
- en: This feature allowed developers to create a new type of icons, called **Glyph
    icons**, which are not actually icons, but fonts where each character looks like
    an icon (similar to the *Webding* font, [http://en.wikipedia.org/wiki/Webdings](http://en.wikipedia.org/wiki/Webdings)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能允许开发者创建一种新的图标类型，称为 **符号图标**，实际上并不是图标，而是每个字符看起来像图标的字体（类似于 *Webding* 字体，[http://en.wikipedia.org/wiki/Webdings](http://en.wikipedia.org/wiki/Webdings))。
- en: Using Glyph icons is great because we can change the size and color of the icon
    to match the application's theme. Whenever possible, we will use Glyph icons in
    our application. There is an open source and free font that is used widely by
    modern applications (HTML5 applications) called **Font Awesome**, and we are going
    to use this in our project as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图标符号很棒，因为我们可以更改图标的大小和颜色以匹配应用程序的主题。只要可能，我们将在我们的应用程序中使用图标符号。有一个开源且免费的字体，被现代应用程序（HTML5
    应用程序）广泛使用，称为 **Font Awesome**，我们也将在这个项目中使用它。
- en: 'So the first step is downloading the Font Awesome files from [http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/).
    Click on the **Download** button. The file that is going to be downloaded is a
    `.zip` file. Unzip it. Copy the `fonts` folder and paste it inside the `resources`
    folder of the `masteringextjs` application. Copy the `scss` folder and paste it
    inside the `sass/etc` folder. Rename the `scss` folder to `fontAwesome`. This
    is how the `sass/etc` and `resource` folders will look after the changes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是从 [http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/)
    下载 Font Awesome 文件。点击 **下载** 按钮。将要下载的文件是一个 `.zip` 文件。解压它。将 `fonts` 文件夹复制并粘贴到 `masteringextjs`
    应用程序的 `resources` 文件夹内。将 `scss` 文件夹复制并粘贴到 `sass/etc` 文件夹内。将 `scss` 文件夹重命名为 `fontAwesome`。这就是修改后
    `sass/etc` 和 `resource` 文件夹的样式：
- en: '![Adding Font Awesome support (Glyph icons)](img/0457OT_03_08.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![添加 Font Awesome 支持（图标符号）](img/0457OT_03_08.jpg)'
- en: 'We are almost there! Open the `sass/etc/fontAwesome/_variables.scss` file,
    and change the variable `$fa-font-path` to the following value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！打开 `sass/etc/fontAwesome/_variables.scss` 文件，并将变量 `$fa-font-path` 修改为以下值：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is to tell Sass where we placed the font files.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了告诉 Sass 我们放置字体文件的位置。
- en: 'Now all we have to do is open the `sass/etc/all.scss` file and add the following
    code in the first line of the file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所需要做的就是打开 `sass/etc/all.scss` 文件，并在文件的第一行添加以下代码：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you are running `sencha app watch` in the terminal application, you should
    note that the application was rebuilt and we are ready to see the icons in our
    application. The following is how the **Login** screen will look:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在终端应用程序中运行 `sencha app watch`，你应该注意应用程序已被重新构建，我们现在可以查看应用程序中的图标。以下是如何显示 **登录**
    屏幕的示例：
- en: '![Adding Font Awesome support (Glyph icons)](img/0457OT_03_09.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![添加 Font Awesome 支持（图标符号）](img/0457OT_03_09.jpg)'
- en: The next step is to add some action to the **Cancel** and **Submit** buttons.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为 **取消** 和 **提交** 按钮添加一些操作。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about Sass variables and import capabilities, please visit [http://sass-lang.com/guide](http://sass-lang.com/guide).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Sass 变量和导入功能的信息，请访问 [http://sass-lang.com/guide](http://sass-lang.com/guide)。
- en: Creating the Login Controller
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录控制器
- en: We have created the view for the **Login** screen so far. As we are following
    the MVC architecture, we are not implementing the user interaction on the `View`
    class. If we click on the buttons on the `Login` class, nothing will happen, because
    we have not implemented this logic yet. We are going to implement this logic now
    on the `Controller` class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为 **登录** 屏幕创建了视图。由于我们遵循 MVC 架构，我们不会在 `View` 类中实现用户交互。如果我们点击 `Login`
    类中的按钮，将不会发生任何操作，因为我们还没有实现这个逻辑。我们现在将在 `Controller` 类中实现这个逻辑。
- en: 'In Ext JS 5, we have two options to do this: use the default MVC architecture
    or use the MVVM architecture pattern (or a *hybrid* pattern).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 5 中，我们有两种选择来完成这个任务：使用默认的 MVC 架构或使用 MVVM 架构模式（或 *混合* 模式）。
- en: Introducing the MVVM architecture
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍 MVVM 架构
- en: 'In the preceding chapter, we covered an introduction of the MVC architecture
    in Ext JS. Let''s refresh our memory quickly of how MVC works:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 Ext JS 中的 MVC 架构。让我们快速回顾一下 MVC 的工作原理：
- en: '![Introducing the MVVM architecture](img/0457OT_03_10.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 MVVM 架构](img/0457OT_03_10.jpg)'
- en: The **Model** represents the information that is being used by the application.
    The **View** is what the user will see on the screen—the components. In each interaction
    of the user with the application, the components will fire events. The **Controller**
    is where we are going to handle the events and execute any logic that is needed;
    the Controller is going to manage the information (**Model**) and also manage
    the **View** (and the interaction between the **View** and **Model**).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**Model**代表应用程序正在使用的信息。**View**是用户将在屏幕上看到的内容——组件。在用户与应用程序的每次交互中，组件都会触发事件。**Controller**是我们将处理事件并执行所需逻辑的地方；控制器将管理信息（**Model**）并管理**View**（以及**View**和**Model**之间的交互）。'
- en: 'In Ext JS 5, Sencha introduced this new pattern called **Model View ViewModel**
    (**MVVM)**, which is shown in the following diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS 5中，Sencha引入了这种新的模式，称为**模型-视图-视图模型**（**MVVM**），如下面的图所示：
- en: '![Introducing the MVVM architecture](img/0457OT_03_11.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![介绍MVVM架构](img/0457OT_03_11.jpg)'
- en: What happens in the MVVM is that using this pattern, it is much easier to control
    the **View** and the **Model** if they are bound. For example, consider that we
    have a data grid where we list some contacts. When we select a contact and click
    on the **Edit** button, we want the application to open a pop up about the title
    that will be the name of the contact and the pop up will also have a form that
    will display the contact details for editing. If we use the default MVC pattern,
    we will need to control the way the **View** (data grid, pop up, and form) interacts
    with the **Model** (contact information). The MVVM (which is based on the MVC)
    introduces a new abstraction entity that is the **ViewModel**. The **ViewModel**
    mediates changes between the **View** and the associated **Model**.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM中发生的情况是，如果它们被绑定，使用这种模式控制**View**和**Model**会容易得多。例如，考虑我们有一个数据网格，其中列出了一些联系人。当我们选择一个联系人并点击**编辑**按钮时，我们希望应用程序打开一个弹出窗口，该窗口的标题将是联系人的名字，并且弹出窗口还将有一个表单，用于显示供编辑的联系人详细信息。如果我们使用默认的MVC模式，我们需要控制**View**（数据网格、弹出窗口和表单）与**Model**（联系人信息）之间的交互方式。MVVM（基于MVC）引入了一个新的抽象实体，即**ViewModel**。**ViewModel**在**View**和相关的**Model**之间进行调解。
- en: 'However, with this new pattern and new **ViewModel** abstraction, Sencha also
    introduced an abstraction for the controller, which is bound to the **View**,
    called the **ViewController**. The **ViewController** is very similar to the traditional
    controller of the MVC pattern, which is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着这种新模式和新的**ViewModel**抽象，Sencha还引入了控制器的抽象，称为**ViewController**。**ViewController**非常类似于传统的MVC模式控制器，如下所示：
- en: '![Introducing the MVVM architecture](img/0457OT_03_12.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![介绍MVVM架构](img/0457OT_03_12.jpg)'
- en: However, as we learned in [Chapter 2](ch02.html "Chapter 2. Getting Started"),
    *Getting Started*, the controllers of the MVC pattern are created in the scope
    of the application, and they are unique instances (meaning a single instance of
    each controller of the application). As long as the application is running, the
    controllers are also alive.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在[第2章](ch02.html "第2章. 入门")，*入门*中学到的，MVC模式的控制器是在应用程序的作用域中创建的，并且它们是唯一的实例（这意味着应用程序中每个控制器的单个实例）。只要应用程序在运行，控制器也就会存在。
- en: The **ViewModel** and **ViewController** are part of the component (we learned
    about component in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"),
    *Sencha Ext JS Overview*). As long as the **View** is alive, they are also alive.
    When the **View** is destroyed, they also get destroyed. This means that we can
    save some memory (if we do not have many instances of the same **View** at once).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**ViewModel**和**ViewController**是组件的一部分（我们曾在[第1章](ch01.html "第1章. Sencha Ext
    JS概述")，*Sencha Ext JS概述*中学习了组件）。只要**View**存在，它们也就会存在。当**View**被销毁时，它们也会被销毁。这意味着我们可以节省一些内存（如果我们一次没有很多相同的**View**实例）。'
- en: Do not worry if you do not understand all these concepts 100 percent right now.
    We will learn how to use them and how they work with some examples, and throughout
    this book we will use these different options of architecture so that we can learn
    how each one works, and maybe you can choose the one you like the most or the
    one that is going to fit your project best.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在不完全理解这些概念，请不要担心。我们将通过一些示例学习如何使用它们以及它们是如何工作的，并且在这本书中，我们将使用这些不同的架构选项，以便我们可以了解每个选项是如何工作的，也许你可以选择你最喜欢的一个，或者最适合你项目的一个。
- en: Creating the ViewController for Login View
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为登录视图创建ViewController
- en: 'Let''s stop to think a little bit. Logging in is performed once during the
    application''s lifetime. There are three things we can do in the application:
    log in to start using it, use its capabilities, or log out (because we clicked
    on the logout button or the session expired). Once we have logged in, we are in,
    and that is it.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微停下来思考一下。登录是在应用的生命周期中只执行一次的操作。在应用中，我们可以做三件事：登录以开始使用它，使用其功能，或者注销（因为我们点击了注销按钮或会话过期）。一旦登录，我们就进入了，这就结束了。
- en: In the previous topic we learned that the **ViewModel** and the **ViewController**
    are destroyed once the **View** is destroyed. So, instead of having a controller
    for the login alive during the application's lifetime, we can have a controller
    that will be alive only during the time that the login View is alive. For this
    reason, for the **Login** screen, we will use the **ViewController**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的主题中，我们了解到 **ViewModel** 和 **ViewController** 会在 **View** 被销毁时被销毁。因此，我们不需要在应用的生命周期中保持登录控制器活跃，我们可以有一个只在登录视图活跃期间存在的控制器。因此，对于
    **Login** 屏幕，我们将使用 **ViewController**。
- en: 'The first step is creating the JavaScript file. Inside `app/view/login`, we
    will create the `LoginController.js` file. Inside this file, we will implement
    the following code, which is only a base of the `ViewController` class we are
    going to implement:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建 JavaScript 文件。在 `app/view/login` 目录下，我们将创建 `LoginController.js` 文件。在这个文件中，我们将实现以下代码，这将是我们要实现的
    `ViewController` 类的基础：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As usual, on the first line of the class, we have its name (`#1`). Following
    the same formula we used for the `view/login/Login.js`, we will have `Packt` (*app
    namespace*) + `view` (*name of the package*) + `login` (*name of the sub package*)
    + `LoginController` (*name of the file*), resulting in `Packt.view.login.LoginController`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，在类的第一行，我们有它的名字 (`#1`)。遵循我们在 `view/login/Login.js` 中使用的相同公式，我们将有 `Packt`
    (*应用命名空间*) + `view` (*包名*) + `login` (*子包名*) + `LoginController` (*文件名*)，结果为 `Packt.view.login.LoginController`。
- en: The `ViewController` classes need to extend from `Ext.app.ViewController` (`#2`)
    so that we will always use this parent class for our `ViewController`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewController` 类需要扩展自 `Ext.app.ViewController` (`#2`)，这样我们就可以始终为我们的 `ViewController`
    使用这个父类。'
- en: We also need to give an `alias` to this `ViewController` (`#3`). Aliases for
    ViewControllers start with `'controller'`, followed by the alias we want to assign
    (remember that the alias is always in lowercase).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为这个 `ViewController` 提供一个 `alias` (`#3`)。ViewController 的别名以 `'controller'`
    开头，后跟我们要分配的别名（记住别名总是小写）。
- en: For `#4`–`#10`, we have the signature of some methods we will implement until
    the end of this chapter. We will go through each of them later.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `#4`–`#10`，我们有直到本章结束我们将要实现的一些方法的签名。我们将在稍后逐一介绍它们。
- en: Binding the ViewController to the View
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 ViewController 绑定到 View
- en: 'Now that we have the base of our ViewController ready, we need to bind the
    ViewController to its View, which is the `Login` View. Going back to the `Packt.view.login.Login`
    class, we are going to add the following configuration to the class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了 `ViewController` 的基础，我们需要将 `ViewController` 绑定到其视图，即 `Login` 视图。回到
    `Packt.view.login.Login` 类，我们将向该类添加以下配置：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding configuration will bind the `ViewController` class to the `Login`
    class life cycle. Note that we are using the alias we defined in `#3`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将 `ViewController` 类绑定到 `Login` 类的生命周期。注意我们正在使用在 `#3` 中定义的别名。
- en: 'If you try to execute the code, it will throw an error. This is because Ext
    JS does not know which `ViewController` class has the `login` alias (since this
    alias is not a native of the framework; we are creating it). To make it work,
    we need to add the following code to the `login` class as well:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试执行代码，它将抛出错误。这是因为 Ext JS 不知道哪个 `ViewController` 类有 `login` 别名（因为这个别名不是框架的本地属性；我们正在创建它）。为了使其工作，我们还需要在
    `login` 类中添加以下代码：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will tell the Ext JS loader that it also needs to be loaded when loading
    the `Login` class. Ext JS will load this class and all its dependencies. By the
    time Ext JS parses the `controller: ''login''` code, it will have registered the
    `login` alias for a controller and it is going to be OK.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '这将告诉 Ext JS 加载器在加载 `Login` 类时也需要加载它。Ext JS 将加载这个类及其所有依赖项。当 Ext JS 解析 `controller:
    ''login''` 代码时，它将注册 `login` 别名用于控制器，并且一切都会正常。'
- en: Listening to the button click event
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听按钮点击事件
- en: Our next step now is to start listening to the **Login** window events. First,
    we are going to listen to the **Submit** and **Cancel** buttons.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是开始监听**登录**窗口的事件。首先，我们将监听**提交**和**取消**按钮。
- en: 'As we are using a `ViewController` class and not a Controller (MVC), we need
    to add listeners inside the `Login` class. First, let''s do it for the **Cancel**
    button, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是`ViewController`类而不是Controller（MVC），我们需要在`Login`类中添加监听器。首先，让我们为**取消**按钮做这件事，如下所示：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code means that when a user clicks on the **Cancel** button, the `onButtonClickCancel`
    method from the `Login ViewController` class will be executed. So let''s implement
    this method! Back to the `LoginController` class, we already know that this is
    the method we are going to implement:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的意思是，当用户点击**取消**按钮时，`Login ViewController`类中的`onButtonClickCancel`方法将被执行。所以让我们来实现这个方法！回到`LoginController`类，我们已经知道这是我们即将实现的方法：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But how do we know which are the parameters the method can receive? We can
    find the answer to this question in the documentation. If we take a look at the
    click event in the documentation (`Button` class), this is what we will find:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道方法可以接收哪些参数呢？我们可以在文档中找到这个答案。如果我们查看文档中的点击事件（`Button`类），我们会发现以下内容：
- en: '![Listening to the button click event](img/0457OT_03_13.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![监听按钮点击事件](img/0457OT_03_13.jpg)'
- en: This is exactly what we declared. For all the other event listeners, we will
    go to the docs and see which are the parameters the event accepts, and then list
    them as parameters in our code. This is also a very good practice. We should always
    list out all the arguments from the docs even if we are only interested in the
    first one (or even none). This way, we always know that we have the full collection
    of the parameters, and this can come in very handy when we are doing maintenance
    on the application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们声明的。对于所有其他事件监听器，我们将查看文档，看看事件接受哪些参数，然后在我们代码中将它们作为参数列出。这也是一个非常好的实践。即使我们只对第一个（或者甚至没有）参数感兴趣，我们也应该列出文档中的所有参数。这样，我们总是知道我们拥有所有参数的完整集合，这在我们对应用程序进行维护时非常有用。
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure the documentation becomes your best friend while developing Ext JS
    applications. The Ext JS documentation is really good and user friendly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在开发 Ext JS 应用程序时，将文档变成你的最佳朋友。Ext JS 文档非常好，且用户友好。
- en: 'Note that we also want to listen to the **Submit** button click. The `onButtonClickSubmit`
    method has the same signature as the `onButtonClickCancel` method. Let''s go ahead
    and also add the listener to the **Submit** button, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还想监听**提交**按钮的点击。`onButtonClickSubmit`方法与`onButtonClickCancel`方法具有相同的签名。让我们继续添加监听器到**提交**按钮，如下所示：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s do a quick test to see if everything is working as expected so far:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速测试一下，看看到目前为止一切是否按预期工作：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For now, we are only going to output a message on the console to make sure our
    code is working. So, we are going to output `'login submit'` (`#2`) if the user
    clicks on the **Submit** button, and `'login cancel'` (`#1`) if the user clicks
    on the **Cancel** button.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只会在控制台输出一条消息，以确保我们的代码正在正常工作。所以，如果用户点击**提交**按钮，我们将输出`'login submit'`（`#2`），如果用户点击**取消**按钮，我们将输出`'login
    cancel'`（`#1`）。
- en: 'Let''s go ahead and try it. Click on the **Cancel** button and then on the
    **Submit** button. This should be the output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始尝试。点击**取消**按钮，然后点击**提交**按钮。这应该是输出结果：
- en: '![Listening to the button click event](img/0457OT_03_14.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![监听按钮点击事件](img/0457OT_03_14.jpg)'
- en: Cancel Button Listener implementation
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消按钮监听器实现
- en: Let's remove the `console.log` messages and add the code we actually want the
    methods to execute. First, let's work on the `onButtonClickCancel` method. When
    we execute this method, we want it to reset the **Login** form.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除`console.log`消息，并添加我们实际上想要方法执行的实际代码。首先，让我们专注于`onButtonClickCancel`方法。当我们执行这个方法时，我们希望它重置**登录**表单。
- en: 'So this is the logic sequence we want to program:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们想要编程的逻辑序列：
- en: Get the form reference
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取表单引用
- en: Call the `reset` method to reset the form
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`reset`方法重置表单
- en: If we take a look at the parameters we have available on the `onButtonClickCancel`
    method, we have `button`, `e`, and `options`, and none of them provides us with
    the form reference. So what can we do about it?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`onButtonClickCancel`方法中可用的参数，我们有`button`、`e`和`options`，但没有一个提供了表单引用。那么我们该怎么办呢？
- en: 'The `ViewController` class has an interesting way of getting a reference of
    the `Login` class or any of its children, which uses the method `lookupReference(reference)`
    from the `ViewController` class. To be able to use this method, all we have to
    do is add a reference for the `form` in the `Login View` class:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewController` 类有一种有趣的方式来获取 `Login` 类或其子类的引用，它使用 `ViewController` 类中的 `lookupReference(reference)`
    方法。为了能够使用这个方法，我们只需要在 `Login View` 类中为 `form` 添加一个引用：'
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With this reference, we will be able to call the `this.lookupReference(''form'')`
    method directly to retrieve the form reference. With the form reference, all we
    have to do is call the method `reset()` from the `form` class. The complete code
    for the `onButtonClickCancel` method would be:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个引用，我们将能够直接调用 `this.lookupReference('form')` 方法来检索表单引用。有了表单引用，我们只需要调用 `form`
    类中的 `reset()` 方法。`onButtonClickCancel` 方法的完整代码如下：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Submit Button Listener implementation
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提交按钮监听器实现
- en: Now we need to implement the `onButtonClickSubmit` method. Inside this method,
    we want to program the logic to send the **User** and **Password** values to the
    server so that the user can be authenticated.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现 `onButtonClickSubmit` 方法。在这个方法内部，我们想要编写逻辑来将 **用户** 和 **密码** 值发送到服务器，以便进行用户认证。
- en: 'We can implement two programming logics inside this method: the first one is
    to use the `submit` method that is provided by the `Form Basic` class, and the
    second one is to use an Ajax call to submit the values to the server. Either way,
    we will achieve what we want to do. For this example, we will use the default
    form submit call.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在该方法内部实现两种编程逻辑：第一个是使用 `Form Basic` 类提供的 `submit` 方法，第二个是使用 Ajax 调用来提交值到服务器。无论哪种方式，我们都会达到我们的目标。对于这个例子，我们将使用默认的表单提交调用。
- en: 'These are the steps we need to perform in this method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们需要执行以下步骤：
- en: Get the **Login** form reference
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 **Login** 表单引用
- en: Get the **Login** window reference (so we can close it once the user has been
    authenticated)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 **Login** 窗口引用（以便在用户认证后关闭它）
- en: Send Login information to the server
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将登录信息发送到服务器
- en: 'Handle the server response, as follows:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理服务器响应，如下所示：
- en: If the user is authenticated, display application
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户已认证，显示应用程序
- en: If not, display error message
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是，显示错误信息
- en: 'We already know how to get the form reference. This is how `onButtonClickSubmit`
    will look:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何获取表单引用。这是 `onButtonClickSubmit` 的样子：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So first, before doing anything, we will make sure the user has entered all
    the required information (user name and valid password (`#1`)). If everything
    is OK, then we call a helper method that will handle the authentication (`#2`),
    as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，在做什么之前，我们将确保用户已经输入了所有必要的信息（用户名和有效的密码 `#1`）。如果一切正常，然后我们调用一个辅助方法来处理认证（`#2`），如下所示：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, just to make sure the data we are trying to submit is valid (we will
    call this `doLogin` method from another method as well, so to be sure we are sending
    valid data to server is never too much!), we set the `clientValidation` configuration
    as `true` to validate the information one more time (`#3`). Then we have the `url`
    that is going to be called (`#4`). The `success` (`#6`) and `failure` (`#7`) callbacks
    were declared as separate functions, which belong to the `ViewController` class,
    and that is why the scope is the `ViewController` class (`#5`).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，只是为了确保我们试图提交的数据是有效的（我们也将从另一个方法中调用这个 `doLogin` 方法，所以确保我们发送给服务器的数据是有效的永远都不够！），我们将
    `clientValidation` 配置设置为 `true` 以再次验证信息（`#3`）。然后我们有将要调用的 `url`（`#4`）。`success`（`#6`）和
    `failure`（`#7`）回调被声明为单独的函数，这些函数属于 `ViewController` 类，这就是为什么作用域是 `ViewController`
    类（`#5`）。
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We could implement the success and failure methods inside the submit call as
    well (as showed by the example in the documentation [http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.form.Basic-method-submit](http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.form.Basic-method-submit)).
    But we do not know how much code we will need to handle the authentication. Working
    with scoped callbacks is better because our code stays organized, with better
    readability.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在提交调用中实现成功和失败方法（如文档中的示例所示 [http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.form.Basic-method-submit](http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.form.Basic-method-submit)）。但我们不知道我们需要多少代码来处理认证。使用作用域回调更好，因为我们的代码保持组织性，有更好的可读性。
- en: If we try to run this code, the application will send the request to the server,
    but we will get an error as response because we do not have the `login.php` page
    implemented yet. That's OK because we are interested in other details right now.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行此代码，应用程序将向服务器发送请求，但由于我们还没有实现`login.php`页面，我们将收到一个错误响应。这没关系，因为我们现在对其他细节更感兴趣。
- en: 'With Firebug or Chrome Developer Tools enabled, open the **Network** tab and
    filter by the **XHR** requests. Make sure to enter a `username` and `password`
    (any valid value so we can click on the **Submit** button). This will be the output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 启用Firebug或Chrome开发者工具，打开**网络**标签页并按**XHR**请求过滤。确保输入一个`用户名`和`密码`（任何有效值，这样我们就可以点击**提交**按钮）。这将产生以下输出：
- en: '![Submit Button Listener implementation](img/0457OT_03_15.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![提交按钮监听器实现](img/0457OT_03_15.jpg)'
- en: Note that the user and password are being sent as form data. This information
    is useful to handle the information on the server side (which in our case is the
    PHP code).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用户名和密码将以表单数据的形式发送。这些信息对于在服务器端（在我们的例子中是PHP代码）处理信息非常有用。
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whenever you have questions or you have no idea how you are going to handle
    the information sent by Ext JS to the server, open the debug tool of your browser
    and inspect the call. This helps a lot and also helps you to learn more about
    how Ext JS works when communicating with the server.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有问题或者不知道如何处理Ext JS发送到服务器的信息时，打开浏览器中的调试工具并检查调用。这非常有帮助，也能帮助你了解Ext JS与服务器通信时的工作方式。
- en: Creating the User and Groups tables
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户和组表
- en: 'Before we start coding the `login.php` page, we need to add two tables to the
    Sakila database. These two tables are going to represent the users and also the
    group that the user can belong to. In our project, a user can belong to only one
    group, as shown in the following figure:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写`login.php`页面之前，我们需要向Sakila数据库中添加两个表。这两个表将代表用户以及用户可以属于的组。在我们的项目中，一个用户只能属于一个组，如下面的图所示：
- en: '![Creating the User and Groups tables](img/0457OT_03_16.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![创建用户和组表](img/0457OT_03_16.jpg)'
- en: 'First, we are going to create the `Group` table, as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建`Group`表，如下所示：
- en: '[PRE32]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we are going to create the `User` table containing the indexes and also
    the `foreign key` to the `Group` table:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建包含索引和指向`Group`表的`外键`的`User`表：
- en: '[PRE33]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next step is to insert some data into these tables:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将一些数据插入到这些表中：
- en: '[PRE34]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As the password will be saved hashed on the database, the value `$2a$10$2a4e8803c91cc5edca222evoNPfhdRyGEG9RZcg7.qGqTjuCgXKda`
    corresponds to the value `Packt123@`. We will be hashing our password for more
    security in the user administration module.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密码将在数据库中以散列形式保存，值`$2a$10$2a4e8803c91cc5edca222evoNPfhdRyGEG9RZcg7.qGqTjuCgXKda`对应于值`Packt123@`。我们将在用户管理模块中散列我们的密码以提高安全性。
- en: Now we are ready to start developing the `login.php` page.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始开发`login.php`页面。
- en: Handling the Login page on the server
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理服务器上的登录页面
- en: Since we have part of the Ext JS code to send the login information to the server,
    we can implement the server-side code. As mentioned in the first chapter of this
    book, we are going to use PHP to implement the server-side code. But if you do
    not know PHP, do not worry because the code is not going to be complicated, and
    we are going to use pure PHP as well. The goal is to focus on the programming
    logic we need to use on the server side; this way we apply the same programming
    logic to any other server-side language that you like to use (Java, .NET, Ruby,
    Python, and so on).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一部分Ext JS代码用于将登录信息发送到服务器，我们可以实现服务器端代码。正如本书第一章中提到的，我们将使用PHP来实现服务器端代码。但是如果你不知道PHP，不要担心，因为代码不会很复杂，我们也将使用纯PHP。目标是关注我们需要在服务器端使用的编程逻辑；这样我们就可以将相同的编程逻辑应用到任何你喜欢的其他服务器端语言（Java、.NET、Ruby、Python等）。
- en: Connecting to the database
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: The first step is to create the file that is going to be responsible for connecting
    to the database. We are going to reuse this file in almost every PHP page that
    we are going to develop.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个负责连接数据库的文件。我们将在我们开发的几乎每个PHP页面中重用这个文件。
- en: 'Create a new folder named `php` under the project''s root folder, and under
    `php`, create a new folder named `db`. Then, create a new file named `db.php`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根文件夹下创建一个名为`php`的新文件夹，然后在`php`下创建一个名为`db`的新文件夹。然后，创建一个名为`db.php`的新文件：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The connection is pretty straightforward. We simply need to inform the `server`
    (which is going to be `localhost`), the databases `username` and `password`, and
    also the database `name` that we want to connect to. And at last, we can check
    whether the connection was done successfully or any error occurred.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 连接相当直接。我们只需通知 `服务器`（它将是 `localhost`），数据库的 `用户名` 和 `密码`，以及我们想要连接的数据库 `名称`。最后，我们可以检查连接是否成功完成或是否发生任何错误。
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about MySQLi, please visit [http://php.net/manual/en/book.mysqli.php](http://php.net/manual/en/book.mysqli.php).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 MySQLi 的信息，请访问 [http://php.net/manual/en/book.mysqli.php](http://php.net/manual/en/book.mysqli.php)。
- en: Login.php
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Login.php
- en: 'Finally, we can create the `login.php` file under the `php/security` folder.
    So let''s start implementing it, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在 `php/security` 文件夹下创建 `login.php` 文件。所以让我们开始实现它，如下所示：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we need to *require* the `db.php` file to connect to the database (`#1`).
    We are also going to `require` the `PassHash.php` file (`#2`). This file contains
    the `check_password` method, which will compare the password entered by the user
    with the one that is stored in the database (hashed).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要 `require` `db.php` 文件以连接到数据库（`#1`）。我们还将 `require` `PassHash.php` 文件（`#2`）。此文件包含
    `check_password` 方法，该方法将比较用户输入的密码与数据库中存储的密码（已散列）。
- en: Then, we start a session (`#3`)—we are going to store the username on the session
    later.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始一个会话（`#3`）——我们稍后将在会话中存储用户名。
- en: The next step is to retrieve the `user` and `password` values sent by the form
    submit method from Ext JS (`#4` and `#5`).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从 Ext JS (`#4` 和 `#5`) 的表单提交方法中检索 `用户` 和 `密码` 值。
- en: The `stripslashes` function removes the backslashes from the given string (`#6`
    and `#7`). For example, if the user value is `"Loiane\'s"`, the return of `stripslashes`
    will be `"Loiane's"`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`stripslashes` 函数从给定的字符串中移除反斜杠（`#6` 和 `#7`）。例如，如果用户值是 `"Loiane\''s"`，则 `stripslashes`
    的返回值将是 `"Loiane''s"`。'
- en: Tip
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: These two steps help a little bit to ensure the security of the application;
    however, they are not enough. It is very important to *sanitize* the user input
    in the server so that we do not store or try to execute SQL statements with malicious
    input. For the purpose of this book, we will not apply this technique to keep
    the server-side code simple, so even though you do not know PHP, you will be able
    to read and understand the logic behind it and implement something similar in
    the server-side language of your choice. However, be aware that in real-world
    applications, it is very important to apply this step, especially if you are releasing
    your application to the general public (not for internal use only).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤有助于确保应用程序的安全性；然而，它们并不足够。在服务器上对用户输入进行 `清理` 非常重要，这样我们就不存储或尝试使用恶意输入执行 SQL
    语句。为了本书的目的，我们将不会应用这项技术以保持服务器端代码简单，因此即使你不知道 PHP，你也能阅读并理解其背后的逻辑，并在你选择的任何服务器端语言中实现类似的功能。然而，请注意，在实际应用中，应用这一步骤非常重要，尤其是如果你将应用程序发布给公众（而不仅仅是内部使用）。
- en: There is a project called **Open Web Application Security Project** (**OWASP**),
    which is free and open source that provides a set of libraries and APIs to apply
    security techniques in your application. There are subprojects available for .NET,
    Java, and PHP, tutorials on how to avoid XSS attacks and SQL injections, and how
    to prevent other security vulnerabilities. For more information, please visit
    [https://www.owasp.org](https://www.owasp.org).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 **Open Web Application Security Project** （**OWASP**）的项目，它是免费的开源项目，提供了一套库和
    API，用于在应用程序中应用安全技术。有针对 .NET、Java 和 PHP 的子项目，有关如何避免 XSS 攻击和 SQL 注入的教程，以及如何防止其他安全漏洞。更多信息，请访问
    [https://www.owasp.org](https://www.owasp.org)。
- en: Then, we prepare the `$username` variables for the SQL statement using the function
    `real_escape_string` (`#8`), which escapes special characters in a string for
    use in a SQL statement.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `real_escape_string` 函数（`#8`）为 SQL 语句准备 `$username` 变量，该函数用于在字符串中转义特殊字符，以便在
    SQL 语句中使用。
- en: Next, we prepare the SQL query that is going to be executed (`#9`). It is a
    simple `SELECT` statement that is going to return a result matching the given
    `username`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们准备将要执行的 SQL 查询（`#9`）。这是一个简单的 `SELECT` 语句，将返回与给定 `用户名` 匹配的结果。
- en: 'Let''s continue with the next part of the code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一部分的代码：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, we need to execute the SQL query, and we are going to store the result
    set in the `resultDb` variable (`#10`). Then, we are going to store data according
    to whether the result set returned any rows within the result set (`#11`).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要执行 SQL 查询，并将结果集存储在 `resultDb` 变量中 (`#10`)。然后，我们将根据结果集中是否有行返回来存储数据 (`#11`)。
- en: Now comes the most important part of the code. We are going to verify whether
    the result set returned any rows. As we passed the `username`, the number of rows
    returned within the result set must be exactly `1`. So, if the number of rows
    is equal to `1` (`#12`), we need to see whether the hashed password stored in
    the database matches the password entered by the user, but first, we need to retrieve
    this information from the record that was fetched from the database (`#13`).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是代码中最重要的部分。我们将验证结果集是否返回了行。因为我们传递了 `username`，结果集中返回的行数必须正好是 `1`。所以，如果行数等于
    `1` (`#12`)，我们需要查看数据库中存储的哈希密码是否与用户输入的密码匹配，但首先，我们需要从数据库中检索到的记录中获取这些信息 (`#13`)。
- en: The `PassHash` class is responsible for hashing the password, making it a little
    bit more secure to save the hashed password in the database (instead of the plain
    password), for decrypting the hashed password from the database (`$record['password']`),
    and for comparing to the password the user entered in the login page (`#14`).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`PassHash` 类负责对密码进行哈希处理，使得将哈希密码保存到数据库中（而不是明文密码）更加安全，用于从数据库中解密哈希密码 (`$record[''password'']`)，以及与用户在登录页面输入的密码进行比较
    (`#14`)。'
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For now, you can get the complete code for `PassHash.php` from the source code
    downloaded from this book. In [Chapter 6](ch06.html "Chapter 6. User Management"),
    *User Management*, we will go through it line by line.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您可以从本书下载的源代码中获取 `PassHash.php` 的完整代码。在 [第 6 章](ch06.html "第 6 章。用户管理")，*用户管理*中，我们将逐行分析。
- en: If the password entered by the user and the decrypted hash password from the
    database match, it means the user can be authenticated. We are going to store
    the `username` of the authenticated user (`#16`) in the `Session` and also the
    information that the user is `authenticated` (`#15`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入的密码和从数据库中解密后的哈希密码匹配，这意味着用户可以被认证。我们将存储认证用户的 `username` (`#16`) 在 `Session`
    中，并且也存储用户已 `authenticated` (`#15`) 的信息。
- en: 'We also need to prepare the result that we are going to return to Ext JS. We
    are going to send back two pieces of information: the first one is about whether
    the user is `authenticated` (`#17`)—in this case `"true"`—and we can also send
    back a message (`#18`).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要准备将要返回给 Ext JS 的结果。我们将发送两块信息：第一块是关于用户是否 `authenticated` (`#17`)——在这种情况下
    `"true"`——我们还可以发送一条消息 (`#18`)。
- en: If the password entered by the user and the one from the database do not match,
    then we also need to return something to Ext JS. The `success` is going to be
    `false` (`#19`), and we are going to return a message so that we can display to
    the user (`#20`).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入的密码和数据库中的密码不匹配，那么我们还需要向 Ext JS 返回一些信息。`success` 将会是 `false` (`#19`)，并且我们将返回一条消息以便向用户显示
    (`#20`)。
- en: If the `username` does not exist in the database (number of rows returned within
    the result set is different from `1`), we are also going to send back a message
    to Ext JS saying the username or password informed by the user is incorrect (`#22`).
    Therefore, the `success` information will be `false` (`#21`).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `username` 在数据库中不存在（结果集中的行数与 `1` 不同），我们也将向 Ext JS 发送一条消息，说明用户提供的用户名或密码不正确
    (`#22`)。因此，`success` 信息将是 `false` (`#21`)。
- en: Then, we need to close the result set (`#23`).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要关闭结果集 (`#23`)。
- en: 'Now, the third and last part of the code of `login.php`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`login.php` 代码的第三和最后一部分：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We need to close the database connection (`#23`), and we are going to `encode`
    the `result` that we are going to send back to Ext JS in the JSON format (`#24`).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关闭数据库连接 (`#23`)，并且我们将以 JSON 格式 `encode` 我们将要发送回 Ext JS 的 `result` (`#24`)。
- en: And now, the `login.php` code is complete. We cannot forget to add `<?php` before
    the preceding code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`login.php` 代码已经完成。我们不能忘记在前面代码之前添加 `<?php`。
- en: Handling the return of the server – logged in or not?
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理服务器的返回——是否已登录？
- en: We already took care of the server-side code. Now, we need to go back to the
    Ext JS code and handle the response from the server.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了服务器端代码。现在，我们需要回到 Ext JS 代码，并处理来自服务器的响应。
- en: Success and failure in Ext JS has two different concepts. The form handles it
    in a way and the Ajax request handles it in a different one. This can be a little
    bit confusing, so we are going to implement requests to the server using the form
    submit (as this example) and also the Ajax request so that we can learn how to
    implement the proper code using both ways.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 中，成功和失败有两个不同的概念。表单以一种方式处理它，而 Ajax 请求以另一种方式处理。这可能会有些令人困惑，因此我们将通过表单提交（如本例所示）和
    Ajax 请求来实现对服务器的请求，这样我们可以学习如何使用这两种方式来实现适当的代码。
- en: 'For the form, the server needs to return the `success: true` information so
    that the callback to be executed is a successful one. For failure, the server
    needs to return `success: false`, which can be returned if any communication error
    might have occurred (page nor found, exception on server, and so on). For the
    Ajax request, it does not matter whether `success` is `true` or `false`; it is
    going to execute the success callback; only if any communication error occurs
    is it going to execute the failure callback.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '对于表单，服务器需要返回 `success: true` 信息，以便执行的回调是成功的。对于失败，服务器需要返回 `success: false`，这可以在发生任何通信错误时返回（页面未找到，服务器异常等）。对于
    Ajax 请求，`success` 是 `true` 还是 `false` 都没关系；它将执行成功回调；只有当发生任何通信错误时，它才会执行失败回调。'
- en: Note
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is good to remember that the content type that the server needs to return
    to Ext JS is `application/json` and in the JSON format.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 记住服务器需要返回给 Ext JS 的内容类型是 `application/json`，并且是 JSON 格式。
- en: 'Let''s handle the success callback first. In the event of success, the `onLoginSuccess`
    method is going to be executed. In this case, we want to close the **Login** window
    and display the main screen of the application, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理成功回调。在成功的情况下，`onLoginSuccess` 方法将被执行。在这种情况下，我们希望关闭 **登录** 窗口并显示应用程序的主屏幕，如下所示：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `Window` class has a method called `close` that we can call to close the
    window. The question is how to get the reference of the `login window` class.
    The `ViewController` class is directly bound to it, and we can reference the `Login`
    class itself by calling the method `getView` of the `ViewController` class (`#1`).
    Then, we can create the main screen by instantiating the `Main` class (`#2`) that
    was created by Sencha Cmd when we created the application. We are going to reuse
    this class to create our main screen.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window` 类有一个名为 `close` 的方法，我们可以调用它来关闭窗口。问题是如何获取 `login window` 类的引用。`ViewController`
    类直接绑定到它，我们可以通过调用 `ViewController` 类的 `getView` 方法（`#1`）来引用 `Login` 类本身。然后，我们可以通过实例化由
    Sencha Cmd 在创建应用程序时创建的 `Main` 类（`#2`）来创建主屏幕。我们将重用这个类来创建我们的主屏幕。'
- en: Tip
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: With the preceding approach, there is a flaw with the security of the code.
    A smart user who understands how Ext JS works can access the main page using a
    code similar to the preceding one even if the user is not authenticated. A more
    secure way would be to redirect to a page that holds the application (calling
    the `Main` class directly). As we are working with an example here, that is OK.
    However, keep that in mind when developing a real application!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的方法，代码的安全性存在一个缺陷。一个聪明的用户，如果理解了 Ext JS 的工作原理，即使用户未认证，也可以使用类似于前面的代码来访问主页。更安全的方法是将用户重定向到包含应用程序的页面（直接调用
    `Main` 类）。由于我们在这里使用的是示例，这是可以接受的。然而，在开发真实应用程序时，请记住这一点！
- en: 'In the event of failure, there are two cases that we need to handle: the first
    one is if the user was not authenticated because the user does not exist or because
    the password is incorrect. The second one is if there is any communication failure
    (for example, error 404). Our `onLoginFailure` method will look like the following
    code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生失败的情况下，我们需要处理两种情况：第一种情况是如果用户未认证，因为用户不存在或密码不正确。第二种情况是如果发生任何通信故障（例如，错误 404）。我们的
    `onLoginFailure` 方法将如下所示：
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Before we dive into the failure callback, note that both `onLoginFailure` and
    `onLoginSuccess` receive two parameters: `form` and `action`. Where do they come
    from?'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入失败回调之前，请注意 `onLoginFailure` 和 `onLoginSuccess` 都接收两个参数：`form` 和 `action`。它们从哪里来？
- en: If we take a look at the documentation, specifically on the `submit` method
    of the `Form` class (`Ext.form.Panel`), we will see that this `submit` method
    is calling the `submit` method from the class `Ext.form.Basic` (which is the class
    that actually contains all methods to handle form actions). If we take a look
    at the `submit` method from the `Ext.form.Basic` class ([http://docs.sencha.com/extjs/5.0/5.0.1-apidocs/#!/api/Ext.form.Basic-method-submit](http://docs.sencha.com/extjs/5.0/5.0.1-apidocs/#!/api/Ext.form.Basic-method-submit)),
    we will see a code similar to ours as an example. If we read the description,
    it says that this `submit` method is a shortcut to the `doAction` method from
    the same class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看文档，特别是`Form`类（`Ext.form.Panel`）的`submit`方法，我们将看到这个`submit`方法正在调用`Ext.form.Basic`类中的`submit`方法（这个类实际上包含处理表单操作的所有方法）。如果我们查看`Ext.form.Basic`类中的`submit`方法([http://docs.sencha.com/extjs/5.0/5.0.1-apidocs/#!/api/Ext.form.Basic-method-submit](http://docs.sencha.com/extjs/5.0/5.0.1-apidocs/#!/api/Ext.form.Basic-method-submit))，我们将看到与我们的代码类似的示例。如果我们阅读描述，它说这个`submit`方法是从同一类中`doAction`方法的快捷方式。
- en: 'If we open the documentation for this method ([http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.form.Basic-method-doAction](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.form.Basic-method-doAction)),
    we will be able to see the parameters we used for the form submit call (`url`,
    `success`, and `failure` callbacks, among others) and also the parameters that
    both success and failure callbacks receive—`form` and `action`—as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开此方法的文档([http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.form.Basic-method-doAction](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.form.Basic-method-doAction))，我们将能够看到我们用于表单提交调用的参数（`url`、`success`和`failure`回调函数等），以及成功和失败回调函数接收到的参数——`form`和`action`——如下所示：
- en: '![Handling the return of the server – logged in or not?](img/0457OT_03_22.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![处理服务器返回 – 已登录或未登录？](img/0457OT_03_22.jpg)'
- en: 'The `action` parameter contains four attributes inside it. For our failure
    callback, we are interested in two of them: `failureType` and `response`. Let''s
    analyze `response` first. Add the following code (`console.log(action);`) to the
    first line of the failure callback, and try to submit an incorrect user or password
    in the **Login** screen. Before submitting to the server, open Chrome Developer
    Tools or Firebug to see what is going to be logged, as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`action`参数内部包含四个属性。对于我们失败的回调函数，我们感兴趣的是其中的两个：`failureType`和`response`。首先让我们分析`response`。将以下代码（`console.log(action);`）添加到失败回调函数的第一行，并在**登录**屏幕中尝试提交错误的用户名或密码。在提交到服务器之前，打开Chrome开发者工具或Firebug，查看将要记录的内容，如下所示：'
- en: '![Handling the return of the server – logged in or not?](img/0457OT_03_21.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![处理服务器返回 – 已登录或未登录？](img/0457OT_03_21.jpg)'
- en: 'Inside the response, note that there is `responseText` with JSON that we returned
    from the server. So, the first thing we are going to do is decode this JSON (`#3`).
    After we decode it, we will be able to access `result.success` and `result.msg`.
    We also need to be careful about one detail: we do not know what is going to be
    returned from the server. We always hope that is our `success` and `msg` information;
    however, we cannot be sure of it. If any other error is returned, it is also going
    to be returned inside `action.response.responseText`, and it cannot have the JSON
    format we are expecting (cannot be a JSON either). If this happens, `Ext.JSON.decode`
    will fail, and it will throw an exception. We can silence the exception (passing
    `true` as the second parameter to the `Ext.JSON.decode` function, and the `result`
    will have the value `null`), but we still need to handle it. And it is what we
    do when checking whether the `result` variable is `null` (`#4`). If it is null,
    we are instantiating the `result` and assigning some values (the `msg` will receive
    the error sent by the server).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应中，请注意其中包含我们从服务器返回的JSON格式的`responseText`。因此，我们首先要做的是解码这个JSON（`#3`）。解码之后，我们将能够访问`result.success`和`result.msg`。我们还需要注意一个细节：我们不知道服务器将返回什么。我们总是希望它是我们的`success`和`msg`信息；然而，我们无法确定。如果返回任何其他错误，它也将包含在`action.response.responseText`中，并且它不能是我们期望的JSON格式（也不能是JSON）。如果发生这种情况，`Ext.JSON.decode`将失败，并抛出异常。我们可以静默异常（将`true`作为`Ext.JSON.decode`函数的第二个参数传递，`result`将具有`null`值），但我们仍然需要处理它。这正是我们在检查`result`变量是否为`null`（`#4`）时所做的。如果是null，我们将实例化`result`并分配一些值（`msg`将接收服务器发送的错误）。
- en: After that, we will use the action `failureType` to see what type of error occurred.
    As `failureType` is code, Ext JS has some constants defined that are more developer
    friendly (`Ext.form.action.Action.CLIENT_INVALID`, for example). If `failureType`
    is `'client'` (`#5`), then we will display an error message in an alert pop up
    with an error icon. If a connection error happened with the server, then (`#6`)
    will handle it by displaying an error alert pop up as well. And if any exception
    or success is returned as false, (`#7`) will handle it. As we treated the return
    of the server to display the custom error message or any other message, we can
    simply display `result.msg` on the alert pop up (`#8`).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用 `failureType` 动作来查看发生了哪种类型的错误。由于 `failureType` 是代码，Ext JS 定义了一些对开发者更友好的常量（例如
    `Ext.form.action.Action.CLIENT_INVALID`）。如果 `failureType` 是 `'client'` (`#5`)，那么我们将通过带有错误图标的弹出警告显示错误消息。如果服务器发生了连接错误，那么
    (`#6`) 将通过显示错误弹出警告来处理它。如果返回了任何异常或成功为假，(`#7`) 将处理它。由于我们处理了服务器的返回值以显示自定义错误消息或任何其他消息，我们可以在弹出警告中简单地显示
    `result.msg` (`#8`)。
- en: 'Try entering a wrong user or password again and see what happens. Change `login.php`
    `url` to `login.php` (or change to any other `url`), or inside the `db.php` file,
    enter the incorrect password to connect to the database to simulate an error,
    and here''s what you will see:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试输入错误用户名或密码并查看会发生什么。将 `login.php` `url` 更改为 `login.php`（或更改为任何其他 `url`），或在
    `db.php` 文件中输入错误的密码以连接到数据库来模拟错误，你将看到以下内容：
- en: '![Handling the return of the server – logged in or not?](img/0457OT_03_17.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![处理服务器的返回 - 是否已登录？](img/0457OT_03_17.jpg)'
- en: This way, we can handle all kind of server responses; not only the ones we are
    waiting for, but also any exceptions!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以处理所有类型的服务器响应；不仅是我们所期望的，还包括任何异常！
- en: Reusing code by creating a Util class
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过创建 Util 类重用代码
- en: Note that in (`#5`), (`#6`), and (`#7`) we are using the same error alert pop
    up, so code is repeated. Alert errors like this are used in different places of
    the application. As we are going to handle more Ajax requests and form submits
    in other screens of the application as well, the code in (`#3`) and (`#4`) will
    be repeated as well. For this reason, we can create a `Util` class that will encapsulate
    this code and provide us with the means to reuse it. Besides the reuse pro, it
    is also good to establish a pattern to be followed by the application, such as
    working out the JSON format that the server needs to return to Ext JS. This will
    make the application more organized, and it is also good when working in a team
    (usually each developer has their own pattern that they like to follow, and this
    way, we follow the same pattern for the same application, and it will not look
    as though it was implemented by different developers).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 (`#5`)、(`#6`) 和 (`#7`) 中，我们使用的是相同的错误弹出警告，因此代码是重复的。这种类型的错误弹出警告被用于应用程序的不同位置。由于我们将在应用程序的其他屏幕中处理更多的
    Ajax 请求和表单提交，因此 (`#3`) 和 (`#4`) 中的代码也将重复。因此，我们可以创建一个 `Util` 类来封装此代码并提供重用它的方法。除了重用优势之外，它还很好地建立了一个应用程序可以遵循的模式，例如确定服务器需要返回给
    Ext JS 的 JSON 格式。这将使应用程序更有组织性，当团队合作时也很好（通常每个开发者都有自己的他们喜欢遵循的模式，这样我们就可以为同一应用程序遵循相同的模式，并且看起来不像是由不同的开发者实现的）。
- en: 'So let''s go ahead and create our first `Util` class. We will name it `Packt.util.Util`.
    For this reason, we are going to create a new file named `Util.js`, and we are
    also going to create a new folder named `util` under the `app` folder, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续创建我们的第一个 `Util` 类。我们将将其命名为 `Packt.util.Util`。因此，我们将创建一个名为 `Util.js`
    的新文件，我们还将创建一个位于 `app` 文件夹下的名为 `util` 的新文件夹，如下所示：
- en: '[PRE41]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: All methods will be inside the `statics` declaration (`#1`). As we learned in
    [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"), *Sencha Ext JS Overview*,
    we can simply call `Packt.util.Util.decodeJSON` for example, without needing to
    instantiate the `Packt.util.Util` class. The `decodeJSON` method (`#2`) contains
    the code to handle the JSON decoding, and the method `showErrorMsg` (`#3`) contains
    the code to display an error pop up alert with the content passed in the text
    parameter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法都将位于 `statics` 声明中 (`#1`)。正如我们在 [第1章](ch01.html "第1章. Sencha Ext JS 概述")
    中所学到的，*Sencha Ext JS 概述*，我们可以简单地调用 `Packt.util.Util.decodeJSON`，例如，而不需要实例化 `Packt.util.Util`
    类。`decodeJSON` 方法 (`#2`) 包含处理 JSON 解码的代码，而 `showErrorMsg` 方法 (`#3`) 包含显示带有传入文本参数的错误弹出警告的代码。
- en: Tip
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Static methods do not require an instance of the class to be called. It is a
    concept of object-oriented programming.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法不需要调用类的实例。这是面向对象编程的一个概念。
- en: 'Let''s rewrite the `onLoginFailure` method by using the `Util` class, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Util`类重写`onLoginFailure`方法，如下所示：
- en: '[PRE42]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Instead of 36 lines of code, now we have only 15, and the readability is better
    as well! In case we need to maintain this code, we can make the changes in the
    `Util` class, and the changes will be applied everywhere in the code that the
    class is being used! Best practices make our code really cool!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只有15行代码，比之前的36行代码可读性更好！如果我们需要维护这段代码，我们可以在`Util`类中进行更改，这些更改将应用到使用该类的代码的每个地方！最佳实践让我们的代码变得非常酷！
- en: 'One last detail: we need to add the `Packt.util.Util` class in the `requires`
    declaration of the `ViewController` class as well:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个细节：我们需要在`ViewController`类的`requires`声明中添加`Packt.util.Util`类：
- en: '[PRE43]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is because of the dynamic loading we discussed earlier in this chapter.
    If we try to execute the preceding code without having the `Util` class loaded,
    we can get an error.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在本章前面讨论的动态加载。如果我们尝试在没有加载`Util`类的情况下执行前面的代码，我们可能会得到一个错误。
- en: Enhancing the Login screen
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强登录界面
- en: Our **Login** screen is done. However, there are some enhancements we can apply
    to it to make it even better and also offer a better experience to the user.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**登录**界面已经完成。然而，我们还可以对其应用一些增强，使其变得更好，并为用户提供更好的体验。
- en: 'The following list details the enhancements that we are going to apply in our
    **Login** screen:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表详细说明了我们将在我们的**登录**界面中应用的功能增强：
- en: Apply a loading mask while authenticating
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验证时应用加载遮罩
- en: Submit the form when the user presses *Enter*
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户按下*Enter*键时提交表单
- en: Displaying a Caps Lock warning message
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示大写锁定警告信息
- en: Applying a loading mask on the form while authenticating
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在验证表单时应用加载遮罩
- en: Sometimes, when the user clicks on the **Submit** button, there can be some
    delay while waiting for the server to send back the response. Some users will
    be patient, while some others will not. The ones that are not very patient will
    be able to click on the **Submit** button again, and this means making another
    request to the server. We can avoid this behavior by applying a loading mask to
    the **Login** window while awaiting the response.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当用户点击**提交**按钮时，在等待服务器发送响应的过程中可能会有一些延迟。一些用户可能会耐心等待，而另一些用户则不会。那些不太有耐心的用户将能够再次点击**提交**按钮，这意味着向服务器发送另一个请求。我们可以在等待响应时对**登录**窗口应用加载遮罩来避免这种行为。
- en: 'First, we need to add the following code right before the `form.submit` call
    (inside the `doLogin` method):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`form.submit`调用之前（在`doLogin`方法内部）添加以下代码：
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will apply the mask to the **Login** screen.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对**登录**屏幕应用遮罩。
- en: 'Then, on the first line inside the `onLoginSuccess` and `onLoginFailure` functions,
    we need to add the following line of code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`onLoginSuccess`和`onLoginFailure`函数的第一行中，我们需要添加以下代码行：
- en: '[PRE45]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And this will remove the mask from the **Login** window.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移除**登录**窗口的遮罩。
- en: 'If we try to execute the code, we will have the following output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行代码，我们将得到以下输出：
- en: '![Applying a loading mask on the form while authenticating](img/0457OT_03_18.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![在验证表单时应用加载遮罩](img/0457OT_03_18.jpg)'
- en: Notice that the Login screen is not reachable and the user cannot click on the
    buttons again until the server sends back a response and removes the mask.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，登录界面不可达，用户无法在服务器发送响应并移除遮罩之前再次点击按钮。
- en: Form submit on Enter
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Enter键表单提交
- en: For some forms, especially for the **Login** form, it is very natural for people
    to hit *Enter* when they are ready. This behavior is not automatic for Ext JS;
    therefore, we have to implement it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些表单，尤其是**登录**表单，当用户准备好时按下*Enter*键是非常自然的。对于Ext JS来说，这种行为不是自动的；因此，我们必须实现它。
- en: 'The `textfield` component has an event to handle special keys, such as *Enter*.
    This event is called `specialkey`, and it is the one that we are going to listen
    to in our login controller. As we want to listen to this event for both text fields
    we have (**User** and **Password**), we can add the following code inside the
    defaults of the form from the **Login** window:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`textfield`组件有一个处理特殊键的事件，例如*Enter*。这个事件被称为`specialkey`，这是我们将在登录控制器中监听的事件。因为我们想监听我们拥有的两个文本字段（**用户**和**密码**）的此事件，我们可以在**登录**窗口的表单的默认值中添加以下代码：'
- en: '[PRE46]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we need to implement the `onTextFieldSpecialKey` method inside the `ViewController`
    class as well, as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还需要在`ViewController`类内部实现`onTextFieldSpecialKey`方法，如下所示：
- en: '[PRE47]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we are going to verify that the key pressed by the user is *Enter*. If
    positive, we call the `doLogin` method we implemented earlier. Then, the form
    validation will be done and if the form is valid, it will try to log in. This
    will be the same as clicking on the **Submit** button.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将验证用户按下的键是否为*Enter*。如果是，我们将调用我们之前实现的`doLogin`方法。然后，将进行表单验证，如果表单有效，它将尝试登录。这将与点击**提交**按钮相同。
- en: Caps Lock warning message
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Caps Lock警告信息
- en: The last enhancement we will apply to the form is the **Caps Lock** message.
    Sometimes the *Caps Lock* key is active, and when we input the password, we can
    input the correct password, but the system will say it is incorrect because it
    is case sensitive; warning the user about this is a nice thing to do.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对表单进行的最后一个增强是**Caps Lock**信息。有时*Caps Lock*键处于激活状态，当我们输入密码时，我们可以输入正确的密码，但系统会说它不正确，因为它是区分大小写的；提醒用户这一点是个好主意。
- en: 'The following screenshot presents the final result of the **Caps Lock** warning
    implementation:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了**Caps Lock**警告实现的最终结果：
- en: '![Caps Lock warning message](img/0457OT_03_19.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![Caps Lock警告信息](img/0457OT_03_19.jpg)'
- en: 'As you can see in the preceding screenshot, we will display the warning as
    a tooltip. So the first thing we need to do is go back to the `Application.js`
    launch function, and on the first line, we need to add the following code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，我们将以工具提示的形式显示警告。所以我们需要做的第一件事是回到`Application.js`启动函数，并在第一行添加以下代码：
- en: '[PRE48]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'An alternative is using the configuration `enableQuickTips: true` inside `Aplication.js`
    as well. You can use either one, and the result will be the same.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个选择是在`Aplication.js`中配置`enableQuickTips: true`。你可以使用任何一个，结果都会相同。'
- en: Without the preceding code, the tooltips will not work in the application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 没有前面的代码，应用中的工具提示将无法工作。
- en: Ext JS has two concepts of tooltips. The first one is the `Tooltip` class, which
    does not have a built-in method of automatically populating the tooltip's text
    based on the target element; you must either configure a fixed HTML value for
    each tooltip instance or implement custom logic (inside an event listener). The
    second one is the `QuickTip` class, which automatically populates and configures
    a tooltip based on specific DOM attributes of each target element. Tooltips are
    enabled by default. QuickTips are managed by the `QuickTipManager`, which requires
    to be manually initiated.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS有两种工具提示的概念。第一个是`Tooltip`类，它没有内置的方法可以自动根据目标元素填充工具提示文本；你必须为每个工具提示实例配置一个固定的HTML值，或者实现自定义逻辑（在事件监听器内部）。第二个是`QuickTip`类，它可以自动填充和配置工具提示，基于每个目标元素特定的DOM属性。工具提示默认启用。QuickTips由`QuickTipManager`管理，需要手动启动。
- en: 'The event that we are going to listen to is the `keypress` event, and we are
    only going to listen to this event fired by the `password` field. By default,
    the `textfield` component does not fire this event because it is a little bit
    heavy with regard to performance. As we want to listen to this event, we need
    to add a configuration (`enableKeyEvents`) to the `password` field (inside the
    `view/login/Login.js` file):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要监听的事件是`keypress`事件，我们只监听由`password`字段触发的事件。默认情况下，`textfield`组件不会触发此事件，因为它在性能上有点沉重。因为我们想监听这个事件，所以我们需要向`password`字段添加一个配置（`enableKeyEvents`）（在`view/login/Login.js`文件中）：
- en: '[PRE49]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We also need to add an `id` value to this field. Later, we will discuss the
    importance of avoiding using `id` in the components (since it is not a good practice),
    but in this case, there is nothing we can do about it. This is because when creating
    the `Tooltip` class, we need to set a `target` (in this case, the `password` field),
    and this `target` only accepts the `id` of the component, and not `itemId`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要给这个字段添加一个`id`值。稍后，我们将讨论避免在组件中使用`id`的重要性（因为它不是一种好做法），但在这个情况下，我们无能为力。这是因为当创建`Tooltip`类时，我们需要设置一个`target`（在这种情况下，是`password`字段），而这个`target`只接受组件的`id`，而不是`itemId`。
- en: 'Before we add the code to the Controller, we need to create the `Tooltip` class.
    We are going to create a new view called `Packt.view.login.CapsLockTooltip`, so
    we need to create a file named `CapsLockTooltip.js` under the `app/view/login`
    folder:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将代码添加到Controller之前，我们需要创建`Tooltip`类。我们将创建一个新的视图，名为`Packt.view.login.CapsLockTooltip`，因此我们需要在`app/view/login`文件夹下创建一个名为`CapsLockTooltip.js`的文件：
- en: '[PRE50]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In `Packt.view.login.CapsLockTooltip`, we declare some configurations that
    are going to set the behavior of the `Tooltip` class. For example, we have the
    following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Packt.view.login.CapsLockTooltip`中，我们声明了一些配置，这些配置将设置`Tooltip`类的行为。例如，我们有以下配置：
- en: '`target`: This has the `id` value of the `password` field.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：这具有`password`字段的`id`值。'
- en: '`anchor`: This indicates that the tip should be anchored to a particular side
    of the target element (the `password` `id` field), with an arrow pointing back
    at the target.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor`：这表示提示应该锚定到目标元素（`password` `id`字段）的特定侧面，箭头指向目标。'
- en: '`anchorOffset`: This is a numeric value (in pixels) used to offset the default
    position of the anchor arrow. In this case, the arrow will be displayed 60 pixels
    after the tooltip box beginning.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchorOffset`：这是一个数值（以像素为单位），用于偏移锚点箭头的默认位置。在这种情况下，箭头将在工具提示框开始后的60像素处显示。'
- en: '`width`: This is the numeric value (in pixels) to represent the `width` of
    the tooltip box.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`：这是表示工具提示框宽度的数值（以像素为单位）。'
- en: '`dismissDelay`: This is the delay value (in milliseconds) before the tooltip
    automatically hides. As we do not want the tooltip to be automatically hidden,
    we set the value to `0` (zero) to disable it.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dismissDelay`：这是在工具提示自动隐藏之前的延迟值（以毫秒为单位）。由于我们不希望工具提示自动隐藏，我们将值设置为`0`（零）以禁用它。'
- en: '`autoHide`: Set it to `true` to automatically hide the tooltip after the mouse
    exits the target element. And as we do not want it, we set it to `false`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoHide`：将其设置为`true`以在鼠标退出目标元素后自动隐藏工具提示。由于我们不希望这样做，我们将其设置为`false`。'
- en: '`title`: This is the title text to be used as the title of the tooltip.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是用作提示标题的文本。'
- en: '`html`: This is the HTML fragment that will be displayed in the tooltip body.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html`：这是将在工具提示体中显示的HTML片段。'
- en: Note that on the title, we added a class to the `<div>` tag. This will display
    a warning icon from Font Awesome that we configured earlier.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在标题上给`<div>`标签添加了一个类。这将显示我们之前配置的Font Awesome的警告图标。
- en: Note
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To see all icons from Font Awesome that are available to be used in the application,
    please visit [http://fortawesome.github.io/Font-Awesome/cheatsheet/](http://fortawesome.github.io/Font-Awesome/cheatsheet/).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看应用程序中可用的所有Font Awesome图标，请访问[http://fortawesome.github.io/Font-Awesome/cheatsheet/](http://fortawesome.github.io/Font-Awesome/cheatsheet/)。
- en: 'And at last, we need to make some changes in the `ViewController` class. First,
    in the `requires` declaration, we will add the `CapsLockTooltip` class:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`ViewController`类中进行一些修改。首先，在`requires`声明中，我们将添加`CapsLockTooltip`类：
- en: '[PRE51]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we are going to implement the `onTextFieldKeyPress` method, as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`onTextFieldKeyPress`方法，如下所示：
- en: '[PRE52]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First, we need to get the `code` of the key that the user pressed (`#1`). Then,
    we need to verify that the *Shift* key is pressed and if the user pressed one
    of the small alphabet keys (a-z), or if the *Shift* key is not pressed and the
    user pressed one of the capital alphabet keys (A-Z) (`#2`). If the result of this
    verification is true, this means that the *Caps Lock* is active. If you want to
    check the values of each key, you can go to [http://www.asciitable.com/](http://www.asciitable.com/).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取用户按下的键的`code`（`#1`）。然后，我们需要验证是否按下了`Shift`键，并且用户按下了小写字母键（a-z），或者如果没有按下`Shift`键，用户按下了大写字母键（A-Z）（`#2`）。如果这个验证的结果为真，这意味着`Caps
    Lock`是激活的。如果您想检查每个键的值，可以访问[http://www.asciitable.com/](http://www.asciitable.com/)。
- en: If the *Caps Lock* is active, we will verify that there is a reference of the
    `CapsLockTooltip` class (`#3`). If there is not, we will create a reference using
    its `xtype` (`#4`) and store it in a variable named `capslockTooltip`. This variable
    will be created as part of the `ViewController` class, so if this method is executed
    again, we can access it. Then, we display it by executing the method shown (`#5`).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Caps Lock`是激活的，我们将验证是否存在`CapsLockTooltip`类的引用（`#3`）。如果没有，我们将使用它的`xtype`创建一个引用，并将其存储在名为`capslockTooltip`的变量中。这个变量将作为`ViewController`类的一部分创建，因此如果这个方法再次执行，我们可以访问它。然后，我们通过执行显示的方法来显示它（`#5`）。
- en: If the *Caps Lock* is not active, we need to verify that there is a reference
    to the `CapsLockTooltip` class (`#6`). If positive, we will `hide` the tooltip
    because the *Caps Lock* is not active.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *大写锁定* 未激活，我们需要验证是否存在对 `CapsLockTooltip` 类的引用 (`#6`)。如果是肯定的，我们将 `隐藏` 提示，因为
    *大写锁定* 未激活。
- en: The Caps Lock warning code is now complete. We can save the project and test
    it.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 大写锁定警告代码现在已完成。我们可以保存项目并测试它。
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the details on how to implement a login page step
    by step. We covered how to create the login View and the `Login` `ViewController`
    class. We applied client validations on the form to make sure we send acceptable
    data to the server. We covered how to do a basic login using PHP, and we covered
    important concepts of how to handle the data that the server is going to send
    back to Ext JS.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们逐步介绍了如何实现登录页面的细节。我们介绍了如何创建登录视图和 `Login` `ViewController` 类。我们在表单上应用客户端验证，以确保我们发送的数据对服务器是可接受的。我们介绍了如何使用
    PHP 进行基本登录，以及如何处理服务器将发送回 Ext JS 的数据的重要概念。
- en: We learned about some enhancements that we can apply to the **Login** screen,
    such as submitting the form when the user hit *Enter*, displaying a Caps Lock
    warning in the password field, and also how to apply a load mask on the form while
    it is sending data and waiting for information from the server.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了一些可以应用于 **登录** 屏幕的增强功能，例如当用户按下 *Enter* 键时提交表单，在密码字段中显示大写锁定警告，以及如何在表单发送数据并等待从服务器获取信息时应用加载遮罩。
- en: We also added support to Font Awesome that will be used throughout our project.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了对 Font Awesome 的支持，该支持将在我们的整个项目中使用。
- en: In the next chapter, we will continue to work on the **Login** screen. We will
    learn how to add the multilingual capability and also implement the Logout and
    Session Monitor capabilities.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续在 **登录** 屏幕上工作。我们将学习如何添加多语言功能，并实现注销和会话监控功能。
