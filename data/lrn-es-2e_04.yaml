- en: Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: Out of all chapters in this book, this is my favorite, because I've faced the
    consequences of bad asynchronous programming in the past, with callbacks on event
    listeners, HTTP requests, and basically everything that requires latency.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的所有章节中，这是我最喜欢的章节，因为我过去遇到过不良异步编程的后果，包括事件监听器上的回调、HTTP请求以及基本上所有需要延迟的操作。
- en: JavaScript has evolved from all these cluttered, unreadable, unmaintainable
    programming practices and that's what we're going to learn in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已经从所有这些杂乱无章、难以阅读、难以维护的编程实践中发展而来，这就是我们将在本章学习的内容。
- en: Anyway, let's learn what an asynchronous program is. You can think of an asynchronous
    program as a program consisting of two lines of code, say L1 and L2\. Now, we
    all know that in a given file, the code always executes from top to bottom. Also,
    it is intuitive such that the code will wait for each line to complete before
    executing the next line.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们学习异步程序是什么。你可以将异步程序想象为包含两行代码的程序，比如说L1和L2。我们都知道，在给定的文件中，代码总是从上到下执行。此外，这是直观的，代码会在执行下一行之前等待当前行完成。
- en: In the case of asynchronous programming, the code will execute L1, but it will
    not block L2 till L1 is completed. You can think of it as a kind of *non-blocking*
    programming.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步编程的情况下，代码将执行L1，但不会在L1完成之前阻塞L2。你可以将其视为一种*非阻塞*编程。
- en: 'In this chapter, we''ll cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: The JavaScript execution model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript执行模型
- en: Event loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环
- en: The difficulties faced while writing asynchronous code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写异步代码时遇到的困难
- en: What are promises?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是promises？
- en: Creating and working with promises
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用promises
- en: How async/await differs from promises
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: async/await与promises的不同之处
- en: Advanced asynchronous programming with async/await
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用async/await进行高级异步编程
- en: Let's start!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: JavaScript execution model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript执行模型
- en: JavaScript code is executed in a single thread, that is, two pieces of a script
    cannot run at the same time. Each website opened in the browser gets a single
    thread for downloading, parsing, and executing the website, called the main thread.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码是在单线程中执行的，也就是说，脚本的两部分不能同时运行。浏览器中打开的每个网站都获得一个用于下载、解析和执行网站的单独线程，称为主线程。
- en: The main thread also maintains a queue, which has asynchronous tasks queued
    to be executed one by one. These queued tasks can be event handlers, callbacks,
    or any other kind of task. New tasks are added to the queue as AJAX requests/responses
    happen, events occur, timers are registered, and more. One long-running queue
    task can stop the execution of all other queue tasks and the main script. The
    main thread executes the tasks in this queue whenever possible.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程也维护一个队列，其中包含排队等待依次执行的任务。这些排队任务可以是事件处理器、回调函数或任何其他类型的任务。当发生AJAX请求/响应、事件发生、注册计时器等情况时，新任务会被添加到队列中。一个长时间运行的队列任务可能会停止所有其他队列任务和主脚本的执行。主线程尽可能执行队列中的任务。
- en: HTML5 introduced web workers, which are actual threads running parallel to the
    main thread. When a web worker finishes executing or needs to notify the main
    thread, it simply adds a new event item to the queue. We'll discuss web workers
    separately in Chapter 9, *JavaScript on the Web*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5引入了Web Workers，这是与主线程并行运行的真正线程。当Web Worker完成执行或需要通知主线程时，它只需将一个新的事件项添加到队列中。我们将在第9章“Web上的JavaScript”中单独讨论Web
    Workers。
- en: The event loop
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: JavaScript follows an *event loop-based* model in how it works. This is very
    different from languages such as Java. Although modern JavaScript compilers implement
    a very complex and heavily optimized version of the event loop model, we can still
    basically understand how the event loop works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在运行机制上遵循基于事件循环的模型。这与Java等语言非常不同。尽管现代JavaScript编译器实现了非常复杂且高度优化的事件循环模型，我们仍然可以基本理解事件循环是如何工作的。
- en: The call stack
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用栈
- en: JavaScript is a single-threaded language. That means it can have one call stack
    at a given time (take one thread = one call stack). Furthermore, it implies that
    JavaScript cannot do more than two things at a time. Or can it?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种单线程语言。这意味着它可以在给定时间只有一个调用栈（一个线程等于一个调用栈）。此外，这也意味着JavaScript一次不能做超过两件事。或者它可以吗？
- en: When you call a function, you step inside that function. This function is added
    to the call stack. When the function returns a value, the function is popped from
    the call stack.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个函数时，你进入该函数内部。这个函数被添加到调用栈中。当函数返回一个值时，该函数从调用栈中弹出。
- en: 'Let''s take a look at this example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个例子：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the sake of simplicity, consider `$.syncHTTP` as a predefined method that
    performs **synchronous** HTTP requests, that is, it'll block the code until completed.
    Let's assume every request takes ~500 ms to complete. Thus, if all these requests
    fire on clicking, say, a button, JavaScript immediately blocks the browser from
    doing anything for two seconds! That kills the user experience by a factor of
    100!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，假设`$.syncHTTP`是一个预定义的方法，它执行**同步**HTTP请求，也就是说，它会在完成之前阻塞代码。让我们假设每个请求需要大约500毫秒来完成。因此，如果所有这些请求在点击按钮时触发，JavaScript会立即阻止浏览器在两秒钟内做任何事情！这会以100倍的比例杀死用户体验！
- en: Clearly, the call stack will consist of the first request, then after 500ms
    it'll remove that from the call stack, go to the second request, add that to the
    call stack, wait for 500ms for the response to receive, remove that from the call
    stack, and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，调用栈将包含第一个请求，然后在500毫秒后从调用栈中移除它，然后转到第二个请求，将其添加到调用栈中，等待500毫秒以接收响应，然后从调用栈中移除，依此类推。
- en: 'However, something strange happens when we make use of an asynchronous function
    such as `setTimeout()`.Take a look at this example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用像`setTimeout()`这样的异步函数时，会发生一些奇怪的事情。看看这个例子：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, as you expect, we'll first get `Start` printed because the call stack
    adds `console.log` to the stack, executes it, and removes it from the stack. Then
    the JavaScript comes to `setTimeout()`, adds it to the call stack, magically removes
    it without doing anything (more on this later), comes to the final `console.log`,
    adds it to the call stack, executes it to show `End`, and removes it from the
    stack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，正如你所期望的，我们首先会打印出`Start`，因为调用栈将`console.log`添加到栈中，执行它，然后从栈中移除。然后JavaScript来到`setTimeout()`，将其添加到调用栈中，神奇地不做任何事情（关于这一点稍后还会详细说明），来到最后的`console.log`，将其添加到调用栈中，执行它以显示`End`，然后从调用栈中移除。
- en: Finally, magically, after 1 second, another `console.log` appears on the call
    stack, gets executed to print `Middle`, and then gets removed from the call stack.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，神奇的是，1秒后，另一个`console.log`出现在调用栈中，被执行以打印`Middle`，然后从调用栈中移除。
- en: Let's understand this magic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解这个魔法。
- en: Stack, queue, and Web APIs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈、队列和Web API
- en: So what happened when we called `setTimeout()` in the previous code? Where did
    it magically disappear from the call stack, making room for the next function
    execution?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们在前面的代码中调用`setTimeout()`时发生了什么？它是如何神奇地从调用栈中消失，为下一个函数执行腾出空间的？
- en: Well, `setTimeout()` is a web API provided by each browser individually. When
    you call setTimeout, the call stack sends the `setTimeout()` function call to
    the Web API, which then keeps track of the timer (in our case) till it's complete.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`setTimeout()`是每个浏览器单独提供的Web API。当你调用`setTimeout`时，调用栈会将`setTimeout()`函数调用发送到Web
    API，然后它会跟踪计时器（在我们的例子中）直到它完成。
- en: Once the Web API realizes the timer is complete, it does not immediately push
    the contents back to the stack. It pushes a callback of the  `setTimeout()` function
    to something known as a queue**.** A Queue, as the name implies, could be a queue
    of functions to be executed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Web API意识到计时器已完成，它不会立即将内容推回栈中。它会将`setTimeout()`函数的回调推送到一个称为队列的东西**。**正如其名所示，这可以是一个等待执行的功能队列。
- en: This is when the event loop comes into play. The event loop is a simple little
    tool that looks at the stack and queue all the time and sees if the stack is empty;
    if the queue has something it takes it from the queue and pushes it to the stack.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，事件循环就派上用场了。事件循环是一个简单的工具，它始终检查栈和队列，看看栈是否为空；如果队列中有内容，它会从队列中取出并将其推入栈中。
- en: So essentially, once you're out of the call stack (async function), your function
    has to wait for the call stack to get emptied before it gets executed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以本质上，一旦你离开了调用栈（异步函数），你的函数必须等待调用栈被清空后才能执行。
- en: 'Based upon the previous line, guess the output of this code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上一行，猜测这段代码的输出：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Take a moment to think about this. When you''re ready, see the answer as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个问题。当你准备好了，看看下面的答案：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now the reason for this is, when you call `setTimeout()`, it is cleared off
    from the call stack and the next function is called. The Web API finds that the
    timer for `setTimeout()` is over and pushes it to a queue. The event loop waits
    for the final `console.log` statement to finish before pushing the callback function
    of `setTimeout()` to the stack. And thus we get the output shown earlier.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的原因是，当你调用 `setTimeout()` 时，它会被从调用栈中清除，然后调用下一个函数。Web API 发现 `setTimeout()`
    的计时器已超时，并将其推入队列。事件循环等待最后的 `console.log` 语句执行完毕，然后将 `setTimeout()` 的回调函数推入栈中。因此，我们得到了之前显示的输出。
- en: 'The following figure illustrates the previous code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了之前的代码：
- en: '![](img/35452ed8-c8c9-4066-b0c9-026711589635.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35452ed8-c8c9-4066-b0c9-026711589635.png)'
- en: Writing asynchronous code
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写异步代码
- en: Although modern JavaScript brings promises and ES8 brings in async/await (which
    we'll see soon), still, there will be times when you'll encounter old APIs using
    callback mechanism/event-based mechanisms for their asynchronous operations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现代 JavaScript 引入了 promises 和 ES8 引入了 async/await（我们很快就会看到），但仍然会有时候你遇到使用回调机制/基于事件的机制进行异步操作的老旧
    API。
- en: It is important to understand the working of older asynchronous coding practices.
    This is because you cannot convert a callback-based asynchronous code piece to
    shining promises/async-await-based code without actually understanding how it
    works!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 理解老旧的异步编程实践的工作原理非常重要。这是因为，如果不真正理解其工作原理，你无法将基于回调的异步代码片段转换为基于 promises/async-await
    的闪亮代码！
- en: JavaScript, earlier, natively supported two patterns for writing asynchronous
    code, that is, the event pattern and the callback pattern. While writing asynchronous
    code, we usually start an asynchronous operation and register the event handlers
    or pass the callbacks, which will be executed once the operation is finished.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 早期原生支持两种编写异步代码的模式，即事件模式和回调模式。在编写异步代码时，我们通常启动一个异步操作，并注册事件处理器或传递回调函数，这些函数将在操作完成后执行。
- en: Event handlers or callbacks are used, depending on how the specific asynchronous
    API is designed. An API that is designed for an event pattern can be wrapped with
    some custom code to create the callback pattern for the API, and vice-versa. For
    example, AJAX is designed for the event pattern, but jQuery AJAX exposes it as
    a callback pattern. Let's consider some examples of writing asynchronous code
    involving events and callbacks and their difficulties.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器或回调的使用取决于特定异步 API 的设计。为事件模式设计的 API 可以通过一些自定义代码包装成回调模式，反之亦然。例如，AJAX 是为事件模式设计的，但
    jQuery AJAX 以回调模式暴露它。让我们考虑一些涉及事件和回调的异步代码编写示例及其困难。
- en: Asynchronous code involving events
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涉及事件的异步代码
- en: For asynchronous JavaScript APIs involving events, you need to register the
    success and error event handlers that will be executed depending on whether the
    operation was a success or failure respectively.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及事件的异步 JavaScript API，你需要注册根据操作是否成功执行的成功和错误事件处理器。
- en: 'For example, while making an AJAX request, we register the event handlers that
    will be executed depending on whether the AJAX request was made successfully or
    not. Consider this code snippet, which makes an AJAX request and logs the retrieved
    information:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在发起 AJAX 请求时，我们会注册根据 AJAX 请求是否成功执行的事件处理器。考虑以下代码片段，它发起一个 AJAX 请求并记录检索到的信息：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we assume the `data.json` file to have this content:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们假设 `data.json` 文件包含以下内容：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `send()` method of the `XMLHttpRequest()` object is executed asynchronously,
    and retrieves the `data.json` file and calls the load or error event handler depending
    on whether the request was made successfully or not.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest()` 对象的 `send()` 方法是异步执行的，它检索 `data.json` 文件，并根据请求是否成功调用加载或错误事件处理器。'
- en: 'There is absolutely no issue with how this AJAX works, but the issue is how
    we write the code involving events. Here are the issues that we faced while writing
    the previous code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 AJAX 的工作方式完全没有问题，但问题在于我们如何编写涉及事件处理的代码。以下是我们在编写前一段代码时遇到的问题：
- en: We had to add an exception handler for every block of code that will be executed
    asynchronously. We can't just wrap the whole code using a single `try` and `catch`
    statement. This makes it difficult to catch the exceptions.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不为每个将要异步执行的代码块添加异常处理器。我们不能只用一个 `try` 和 `catch` 语句包裹整个代码。这使得捕获异常变得困难。
- en: The code is harder to read, as it's difficult to follow the code flow due to
    the nested function calls.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码难以阅读，因为嵌套函数调用使得代码流程难以追踪。
- en: 'If another part of the program wants to know if the asynchronous operation
    is finished, pending, or being executed then we have to maintain custom variables
    for that purpose. So we can say it is difficult to find the state of an asynchronous
    operation. This code can get even more complicated and harder to read if you are
    nesting multiple AJAX or any other asynchronous operations. For example, after
    displaying the data, you may want to ask the user to verify if the data is correct
    or not, and then send the Boolean value back to the server. Here is the code example
    to demonstrate this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序的另一部分想要知道异步操作是否已完成、挂起或正在执行，那么我们必须为该目的维护自定义变量。因此，我们可以说找到异步操作的状态是困难的。如果你嵌套了多个
    AJAX 或其他异步操作，这段代码可能会变得更加复杂和难以阅读。例如，在显示数据后，你可能希望让用户验证数据是否正确，然后将布尔值发送回服务器。以下是一个代码示例，演示了这一点：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Asynchronous code involving callbacks
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步代码涉及回调
- en: 'For asynchronous JavaScript APIs involving callbacks, you need to pass success
    and error callbacks, which will be called depending on whether the operation was
    a success or failure respectively. For example, while making an AJAX request using
    jQuery, we need to pass the callbacks, which will be executed depending on whether
    the AJAX request was made successfully or not. Consider this code snippet that
    makes an AJAX request using jQuery and logs the retrieved information:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及回调的异步 JavaScript API，你需要传递成功和错误回调，这些回调将根据操作是成功还是失败而分别被调用。例如，在用 jQuery 发起
    AJAX 请求时，我们需要传递回调，这些回调将根据 AJAX 请求是否成功执行。考虑以下使用 jQuery 发起 AJAX 请求并记录检索信息的代码片段：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Even here, there is absolutely no issue with how this jQuery AJAX works, but
    the issue is how we write the code involving callbacks. Here are the issues that
    we faced while writing the preceding code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这里，jQuery AJAX 的工作方式完全没有问题，但问题在于我们如何编写涉及回调的代码。以下是我们在编写前面代码时遇到的问题：
- en: It is difficult to catch the exceptions, as we have to use multiple `try` and
    `catch` statements.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获异常很困难，因为我们必须使用多个`try`和`catch`语句。
- en: The code is harder to read, as it's difficult to follow the code flow due to
    the nested function calls.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码难以阅读，因为嵌套函数调用使得代码流程难以追踪。
- en: It's difficult to maintain the state of the asynchronous operation. This code
    will get even more complicated if we nest multiple jQuery AJAX or any other asynchronous
    operations.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护异步操作的状态很困难。如果我们嵌套多个 jQuery AJAX 或其他异步操作，这段代码将变得更加复杂。
- en: Promises and async programming
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺和异步编程
- en: JavaScript now has a new native pattern for writing asynchronous code called
    the **Promise** pattern. This new pattern removes the common code issues that
    the event and callback pattern had. It also makes the code look more like synchronous
    code. A promise (or a `Promise` object) represents an asynchronous operation.
    Existing asynchronous JavaScript APIs are usually wrapped with promises, and the
    new JavaScript APIs are purely implemented using promises. Promises are new in
    JavaScript but are already present in many other programming languages. Programming
    languages, such as C# 5, C++ 11, Swift, Scala, and more are some examples that
    support promises.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 现在有一个新的原生模式来编写异步代码，称为**Promise**模式。这个新模式消除了事件和回调模式中常见的代码问题。它还使代码看起来更像同步代码。承诺（或`Promise`对象）代表一个异步操作。现有的异步
    JavaScript API 通常用承诺包装，而新的 JavaScript API 则完全使用承诺实现。承诺在 JavaScript 中是新的，但已经在许多其他编程语言中存在。支持承诺的编程语言，如
    C# 5、C++ 11、Swift、Scala 等，是一些例子。
- en: Let's see how to use promises.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用承诺。
- en: Promise states
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺状态
- en: 'A promise is always in one of these states:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺始终处于以下状态之一：
- en: '**Fulfilled:** If the resolve callback is invoked with a non-promise object
    as the argument or no argument, then we say that the promise is fulfilled'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已履行**：如果解析回调以非承诺对象作为参数或没有参数被调用，那么我们说承诺已履行'
- en: '**Rejected:** If the rejecting callback is invoked or an exception occurs in
    the executor scope, then we say that the promise is rejected'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝**：如果拒绝回调被调用或在执行器作用域中发生异常，那么我们说承诺被拒绝'
- en: '**Pending:** If the resolve or reject callback is yet to be invoked, then we
    say that the promise is pending'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：如果解析或拒绝回调尚未被调用，那么我们说承诺是挂起的'
- en: '**Settled:** A promise is said to be settled if it''s either fulfilled or rejected,
    but not pending'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已解决**：如果`Promise`被实现或拒绝，但不是挂起状态，则称其为已解决'
- en: Once a promise is fulfilled or rejected, it cannot be transitioned back. An
    attempt to transition it will have no effect.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Promise`被实现或拒绝，它就不能再转换。尝试转换将没有任何效果。
- en: Promises versus callbacks
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Promise`与回调的比较'
- en: 'Suppose you wanted to perform three AJAX requests one after another. Here''s
    a dummy implementation of that in callback-style:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要依次执行三个AJAX请求。以下是在回调风格中的示例实现：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see how quickly you can enter into something known as **callback-hell**.
    Multiple nesting makes code not only unreadable but also difficult to maintain.
    Furthermore, if you start processing data after every call, and the next call
    is based on a previous call's response data, the complexity of the code will be
    unmatchable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很快地看到如何进入所谓的**回调地狱**。多层嵌套不仅使代码难以阅读，而且难以维护。此外，如果你在每次调用后开始处理数据，并且下一个调用基于前一个调用的响应数据，代码的复杂性将无法匹敌。
- en: Callback-hell refers to multiple asynchronous functions nested inside each other's
    callback functions. This makes code harder to read and maintain.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调地狱**指的是多个异步函数嵌套在每个回调函数内部。这使得代码更难阅读和维护。'
- en: 'Promises can be used to flatten this code. Let''s take a look:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`可以简化这段代码。让我们看看：'
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see the code complexity is suddenly reduced and the code looks much
    cleaner and readable. Let's first see how `ajaxCallPromise` would've been implemented.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到代码复杂性突然降低，代码看起来更干净、更易读。让我们首先看看`ajaxCallPromise`将如何实现。
- en: Please read the following explanation for more clarity of preceding code snippet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读以下解释，以更清晰地了解前面的代码片段。
- en: Promise constructor and (resolve, reject) methods
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise 构造函数和（resolve，reject）方法
- en: 'To convert an existing *callback type* function to `Promise`, we have to use
    the `Promise` constructor. In the preceding example, `ajaxCallPromise` returns
    a `Promise`, which can be either **resolved** or **rejected** by the developer.
    Let''s see how to implement `ajaxCallPromise`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要将现有的*回调类型*函数转换为`Promise`，我们必须使用`Promise`构造函数。在前面的例子中，`ajaxCallPromise`返回一个`Promise`，开发人员可以将其实现或拒绝。让我们看看如何实现`ajaxCallPromise`：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Hang on! What just happened there?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！刚才发生了什么？
- en: First, we returned `Promise` from the `ajaxCallPromise` function. That means
    whatever we do now will be a `Promise`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从`ajaxCallPromise`函数中返回`Promise`。这意味着我们现在所做的任何操作都将是一个`Promise`。
- en: A `Promise` accepts a function argument, with the function itself accepting
    two very special arguments, that is, resolve and reject.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Promise`接受一个函数参数，该函数本身接受两个非常特殊的参数，即resolve和reject。'
- en: '`resolve` and `reject` are themselves functions.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`resolve`和`reject`本身是函数。'
- en: When, inside a `Promise` constructor function body, you call `resolve` or `reject`,
    the promise acquires a *resolved* or *rejected* value that is unchangeable later
    on.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在`Promise`构造函数函数体内调用`resolve`或`reject`时，`Promise`将获得一个*已解决*或*已拒绝*的值，该值在之后无法更改。
- en: We then make use of the native callback-based API and check if everything is
    OK. If everything is indeed OK, we resolve the `Promise` with the value being
    the message sent by the server (assuming a JSON response).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后使用原生的基于回调的API并检查一切是否正常。如果一切确实正常，我们使用由服务器发送的消息（假设是JSON响应）来`resolve` `Promise`。
- en: If there was an error in the response, we reject the promise instead.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应中存在错误，我们拒绝`Promise`。
- en: You can return a promise in a then call. When you do that, you can flatten the
    code instead of chaining promises again.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`then`调用中返回一个`Promise`。当你这样做时，你可以简化代码而不是再次链式调用`Promise`。
- en: 'For example, if `foo()` and `bar()` both return `Promise`, `then`, instead
    of:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`foo()`和`bar()`都返回`Promise`，则`then`而不是：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can write it as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样写：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This flattens the code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了代码。
- en: The then(onFulfilled, onRejected) method
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`then`（onFulfilled，onRejected）方法'
- en: The `then()` method of a `Promise` object lets us do a task after a `Promise`
    has been fulfilled or rejected. The task can also be another event-driven or callback-based
    asynchronous operation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`对象的`then`方法允许我们在`Promise`实现或拒绝后执行任务。该任务也可以是另一个事件驱动或基于回调的异步操作。'
- en: The `then()` method of a `Promise` object takes two arguments, that is, the
    `onFulfilled` and `onRejected` callbacks. The `onFulfilled` callback is executed
    if the `Promise` object was fulfilled, and the `onRejected` callback is executed
    if the `Promise` was rejected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 对象的 `then()` 方法接受两个参数，即 `onFulfilled` 和 `onRejected` 回调。如果 `Promise`
    对象得到实现，则执行 `onFulfilled` 回调；如果承诺被拒绝，则执行 `onRejected` 回调。'
- en: The `onRejected` callback is also executed if an exception is thrown in the
    scope of the executor. Therefore, it behaves like an exception handler, that is,
    it catches the exceptions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行器的作用域中抛出异常，则也会执行 `onRejected` 回调。因此，它表现得像异常处理程序，即它捕获异常。
- en: 'The `onFulfilled` callback takes a parameter, that is, the fulfilment value
    of the promise. Similarly, the `onRejected` callback takes a parameter, that is,
    the reason for rejection:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`onFulfilled` 回调接受一个参数，即承诺的实现值。同样，`onRejected` 回调接受一个参数，即拒绝的原因：'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we reject the promise inside the `ajaxCallPromise` definition, the second
    function will execute (`failData` one) instead of the first function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `ajaxCallPromise` 定义内部拒绝承诺时，第二个函数将执行（`failData` 一个），而不是第一个函数。
- en: 'Let''s take one more example by converting `setTimeout()` from a callback to
    a promise. This is how `setTimeout()` looks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将 `setTimeout()` 从回调转换为承诺来举一个例子。这是 `setTimeout()` 的样子：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A promised version will look something like the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺版本看起来可能如下所示：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we resolved the promise without a value. If you do that, it gets resolved
    with a value equal to undefined.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以无值的方式解决了这个承诺。如果你这样做，它将以等于 `undefined` 的值解决。
- en: The catch(onRejected) method
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`catch(onRejected)` 方法'
- en: The `catch()` method of a `Promise` object is used instead of the `then()` method
    when we use the `then()` method only to handle errors and exceptions. There is
    nothing special about how the `catch()` method works. It's just that it makes
    the code much easier to read, as the word *catch* makes it more meaningful.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只使用 `then()` 方法来处理错误和异常时，使用 `Promise` 对象的 `catch()` 方法代替 `then()` 方法。`catch()`
    方法的工作方式没有特别之处。只是它使代码更容易阅读，因为单词 *catch* 使其更有意义。
- en: The `catch()` method just takes one argument, that is, the `onRejected` callback.
    The `onRejected` callback of the `catch()` method is invoked in the same way as
    the `onRejected` callback of the `then()` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch()` 方法只接受一个参数，即 `onRejected` 回调。`catch()` 方法的 `onRejected` 回调以与 `then()`
    方法的 `onRejected` 回调相同的方式被调用。'
- en: 'The `catch()` method always returns a promise. Here is how a new `Promise`
    object is returned by the `catch()` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch()` 方法总是返回一个承诺。以下是 `catch()` 方法返回新 `Promise` 对象的方式：'
- en: If there is no return statement in the `onRejected` callback, then a new fulfilled
    `Promise` is created internally and returned.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `onRejected` 回调中没有返回语句，那么将内部创建一个新的实现 `Promise` 并返回。
- en: If we return a custom `Promise`, then it internally creates and returns a new
    `Promise` object. The new promise object resolves the custom promise object.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在 `onRejected` 回调中返回一个自定义的 `Promise`，那么它将内部创建并返回一个新的 `Promise` 对象。新承诺对象解决了自定义承诺对象。
- en: If we return something else other than a custom `Promise` in the `onRejected`
    callback, then a new `Promise` object is created internally and returned. The
    new `Promise` object resolves the returned value.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在 `onRejected` 回调中返回的不是自定义的 `Promise`，那么将内部创建一个新的 `Promise` 对象并返回。新 `Promise`
    对象解决了返回的值。
- en: If we pass null instead of the `onRejected` callback or omit it, then a callback
    is created internally and used instead. The internally created `onRejected` callback
    returns a rejected `Promise` object. The reason for the rejection of the new `Promise`
    object is the same as the reason for the rejection of a parent `Promise` object.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们传递 `null` 而不是 `onRejected` 回调，或者省略它，那么将内部创建一个回调并使用它。内部创建的 `onRejected` 回调返回一个被拒绝的
    `Promise` 对象。新 `Promise` 对象被拒绝的原因与父 `Promise` 对象被拒绝的原因相同。
- en: If the `Promise` object to which `catch()` is called gets fulfilled, then the
    `catch()` method simply returns a new fulfilled promise object and ignores the
    `onRejected` callback. The fulfillment value of the new `Promise` object is the
    same as the fulfillment value of the parent `Promise`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果调用 `catch()` 的 `Promise` 对象得到实现，那么 `catch()` 方法简单地返回一个新的实现承诺对象并忽略 `onRejected`
    回调。新 `Promise` 对象的实现值与父 `Promise` 的实现值相同。
- en: 'To understand the `catch()` method, consider this code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 `catch()` 方法，考虑以下代码：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code can be rewritten in this way using the `catch()` method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以使用 `catch()` 方法重写如下：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These two code snippets work more or less in the same way.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码片段的工作方式大致相同。
- en: The Promise.resolve(value) method
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Promise.resolve(value)` 方法'
- en: The `resolve()` method of the `Promise` object takes a value and returns a `Promise`
    object that resolves the passed value. The `resolve()` method is basically used
    to convert a value to a `Promise` object. It is useful when you find yourself
    with a value that may or may not be a `Promise`, but you want to use it as a `Promise`.
    For example, jQuery promises have different interfaces from ES6 promises. Therefore,
    you can use the `resolve()` method to convert jQuery promises into ES6 promises.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 对象的 `resolve()` 方法接受一个值，并返回一个 `Promise` 对象，该对象解析传递的值。`resolve()`
    方法基本上用于将值转换为 `Promise` 对象。当你发现自己有一个可能是也可能不是 `Promise` 的值，但你想将其用作 `Promise` 时，它非常有用。例如，jQuery
    承诺与 ES6 承诺有不同的接口。因此，你可以使用 `resolve()` 方法将 jQuery 承诺转换为 ES6 承诺。'
- en: 'Here is an example that demonstrates how to use the `resolve()` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示如何使用 `resolve()` 方法的示例：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Promise.reject(value) method
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Promise.reject(value)` 方法'
- en: The `reject()` method of the `Promise` object takes a value and returns a rejected
    `Promise` object with the passed value as the reason. Unlike the `Promise.resolve()`
    method, the `reject()` method is used for debugging purposes and not for converting
    values into promises.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 对象的 `reject()` 方法接受一个值，并返回一个带有传递值作为原因的拒绝的 `Promise` 对象。与 `Promise.resolve()`
    方法不同，`reject()` 方法用于调试目的，而不是将值转换为承诺。'
- en: 'Here is an example that demonstrates how to use the `reject()` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示如何使用 `reject()` 方法的示例：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Promise.all(iterable) method
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Promise.all(iterable)` 方法'
- en: The `all()` method of the `Promise` object takes an iterable object as an argument
    and returns a `Promise` that fulfills when all of the promises in the iterable
    object have been fulfilled.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 对象的 `all()` 方法接受一个可迭代对象作为参数，并在可迭代对象中的所有承诺都得到满足时返回一个承诺。'
- en: 'This can be useful when we want to execute a task after some asynchronous operations
    have finished. Here is a code example that demonstrates how to use the `Promise.all()`
    method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们在一些异步操作完成后想要执行任务时非常有用。以下是一个演示如何使用 `Promise.all()` 方法的代码示例：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the iterable object contains a value that is not a `Promise` object, then
    it's converted to the `Promise` object using the `Promise.resolve()` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可迭代对象包含一个不是 `Promise` 对象的值，则它将使用 `Promise.resolve()` 方法转换为 `Promise` 对象。
- en: 'If any of the passed promises get rejected, then the `Promise.all()` method
    immediately returns a new rejected `Promise` for the same reason as the rejected
    passed `Promise`. Here is an example to demonstrate this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的任何承诺被拒绝，那么 `Promise.all()` 方法会立即返回一个新的拒绝的 `Promise`，原因与被拒绝的传递 `Promise`
    相同。以下是一个演示此功能的示例：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Promise.race(iterable) method
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Promise.race(iterable)` 方法'
- en: The `race()` method of the `Promise` object takes an iterable object as the
    argument and returns a `Promise` that fulfills or rejects as soon as one of the
    promises in the iterable object is fulfilled or rejected, with the fulfillment
    value or reason from that `Promise`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 对象的 `race()` 方法接受一个可迭代对象作为参数，并在可迭代对象中的任何一个承诺满足或拒绝时立即满足或拒绝，使用该 `Promise`
    的满足值或原因。'
- en: 'As the name suggests, the `race()` method is used to race between promises
    and see which one finishes first. Here is a code example that shows how to use
    the `race()` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`race()` 方法用于在承诺之间进行竞争，以查看哪个先完成。以下是一个展示如何使用 `race()` 方法的代码示例：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now at this point, I assume you have a basic understanding of how promises work,
    what they are, and how to convert a callback-like API into a promised API. Let's
    take a look at **async/await**, the future of asynchronous programming.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我假设你已经对承诺的工作方式、它们是什么以及如何将回调式 API 转换为承诺式 API 有了一个基本的了解。让我们来看看 **async/await**，异步编程的未来。
- en: async/await – the future of asynchronous programming
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async/await – 异步编程的未来
- en: To be honest, async/await blows away whatever you read previously about promises.
    But hey! You obviously need to know how promises work in order to know how to
    work with async/await. async/await are built on top of promises; however, once
    you get used to them, there is no going back to promises (unless, again, you need
    to convert a callback type API to async/await (you need to use promises for that).)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，async/await完全超越了之前关于Promise的任何阅读。但是！显然，你需要了解Promise是如何工作的，才能知道如何使用async/await。async/await是基于Promise构建的；然而，一旦你习惯了它们，你就不会回到Promise（除非，再次，你需要将回调类型API转换为async/await（你需要使用Promise来完成这个转换））。
- en: 'About async/await:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于async/await：
- en: It's for asynchronous coding
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于异步编程
- en: It makes code look extremely similar to synchronous coding and thus makes it
    extremely powerful and easy on the eyes
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它让代码看起来与同步代码极其相似，因此非常强大且易于阅读
- en: It is built on top of promises
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是基于Promise构建的
- en: It makes error handling a cake walk. You can finally use `try` and `catch` with
    asynchronous coding!
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它让错误处理变得轻而易举。你终于可以使用`try`和`catch`进行异步编程了！
- en: ES8 introduced async/await and, by the time you're reading this, it will have
    been implemented in all browsers natively (at the time of writing, only IE and
    Opera don't support async/await)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES8引入了async/await，到你看这篇文档的时候，它将已经在所有浏览器中原生支持（在写作时，只有IE和Opera不支持async/await）
- en: async/await versus promises
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async/await与Promise的比较
- en: 'Although async/await are actually promises under the hood, they help a lot
    by adding a ton of readability to code. On the surface level, I believe a developer
    should be aware of minute differences in the usage of async/await versus promises.
    Here''s a glimpse of these:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然async/await实际上在底层是Promise，但它们通过极大地提高代码的可读性而非常有帮助。在表面层面上，我认为开发者应该意识到async/await与Promise使用上的细微差别。这里是一些这些差别的概述：
- en: '| **async/await** | **promises** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **async/await** | **Promise** |'
- en: '| Extremely clean code base | Uglier codebase with nested promises |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 极其干净的代码库 | 嵌套Promise的更丑陋的代码库 |'
- en: '| Error handling with native `try`-`catch` blocks | Separate `catch()` method
    for error handling |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 使用原生的`try`-`catch`块进行错误处理 | 分离的`catch()`方法进行错误处理 |'
- en: '| Syntactic sugar for promises (built on promises) | Native implementation
    in standard |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| Promise的语法糖（基于Promise构建） | 标准中的原生实现 |'
- en: '| Introduced in ES8 | Introduced in ES6 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 在ES8中引入 | 在ES6中引入 |'
- en: The async function and await keyword
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步函数和await关键字
- en: 'In order to use the `await` keyword, we need to have an `async` function. The
    difference between a function and an `async` function is that the `async` function
    is followed by an *async* keyword. Let''s take a look at an example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`await`关键字，我们需要有一个`async`函数。函数和`async`函数之间的区别在于`async`函数后面跟着一个`*async*`关键字。让我们看看一个例子：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the crux of the thing. You can only use `await` inside an `async` function.
    This is because, when you call an `async` function, it returns a `Promise`. However,
    instead of using then with it, which eventually makes it a promise chain, we use
    the `await` keyword in front of it to kind of pause the execution *(not really)*
    inside the `async` function context.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是问题的关键。你只能在`async`函数中使用`await`。这是因为当你调用一个`async`函数时，它返回一个`Promise`。然而，我们并不是使用`then`与它结合，这最终会形成一个Promise链，而是在它前面使用`await`关键字，在`async`函数的上下文中暂停执行（实际上并不是）。
- en: 'Let''s take a look at a real example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个真实的例子：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: OK! First things first. Remember that an async function returns a `Promise`?
    Why didn't we use the `async` keyword with `sendAsyncHTTP`? Why did we return
    a `Promise` from `sendAsyncHTTP`? Why won't the code below work?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！首先，记住异步函数返回一个`Promise`吗？为什么我们没有在`sendAsyncHTTP`中使用`async`关键字？为什么我们从`sendAsyncHTTP`返回一个`Promise`？下面的代码为什么不会工作？
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Carefully take a look at the hint comment line. Since we're using a function
    in `onreadystatechange`, returning inside that function does not return the parent
    function. So essentially, you return `undefined` from the `sendAsyncHTTP` function
    instead of a valid response. Had there been other async functions used with the `await`
    keyword, we could've returned a value without making use of the `new Promise()`
    declaration.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看提示注释行。由于我们在`onreadystatechange`中使用了一个函数，在该函数内部返回并不会返回父函数。所以本质上，你从`sendAsyncHTTP`函数中返回的是`undefined`而不是有效的响应。如果有其他使用`await`关键字的异步函数，我们就可以返回一个值而不需要使用`new
    Promise()`声明。
- en: 'Confused? Stay with me. If you didn''t really get what happened previously,
    continue reading. You will. Take a look at the next function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？请继续跟我。如果你之前没有真正理解发生了什么，请继续阅读。你会的。看看下一个函数：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Look carefully! We didn't return a `Promise` here by using `return new Promise`.
    Why does this work then? This is because this function actually waits for an `async`
    function using the `await` keyword. See, when the code comes to `Line 1`, it halts
    before executing the next line `(console.log('Got first document'))`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看！我们在这里没有使用 `return new Promise` 返回一个 `Promise`。那么这是为什么它能工作呢？这是因为这个函数实际上使用
    `await` 关键字等待一个 `async` 函数。看，当代码到达第1行时，它会在执行下一行 `(console.log('Got first document'))`
    之前暂停。
- en: Whenever JavaScript finds await followed by a function that returns a `Promise`,
    it will wait for that promise to either resolve or reject. In our case, `sendAsyncHTTP`
    resolves with the source code of the website, so we get that back in the `documentFile2`
    variable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript遇到 `await` 后跟一个返回 `Promise` 的函数时，它会等待那个Promise解决或拒绝。在我们的例子中，`sendAsyncHTTP`
    使用网站源代码解决，所以我们通过 `documentfile2` 变量获取它。
- en: We do a similar thing again but with a slightly different URL this time. And
    once we're done with both, we return  `documentFile2`. Hang on here. Remember
    again, the `async function` returns a `Promise`. That means, whatever value you return
    from an `async` function, it is actually the resolved value of that returned `Promise`.And
    whatever value you `throw` inside the `async` function, it goes as the rejected
    value of that returned `Promise`. This is important!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次做类似的事情，但这次使用了一个稍微不同的URL。一旦我们完成这两个步骤，我们就返回 `documentFile2`。在这里等一下。再次记住，`async
    function` 返回一个 `Promise`。这意味着，无论你从 `async` 函数中返回什么值，它实际上是那个返回的 `Promise` 的解决值。而且，无论你在
    `async` 函数内部 `throw` 的什么值，它都会作为那个返回的 `Promise` 的拒绝值。这很重要！
- en: Finally, we called `doSomeTasks()`, and as mentioned it returned a `Promise`.
    Therefore, you can use a then chain with it to just log to the console that everything
    was done. The `res` variable consists of whatever value you returned. The `catch()`
    method will catch any error you throw inside the `async` function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用了 `doSomeTasks()`，正如之前提到的，它返回了一个 `Promise`。因此，你可以使用一个 `then` 链来简单地将其输出到控制台，表明一切已完成。`res`
    变量包含你返回的任何值。`catch()` 方法将捕获 `async` 函数内部抛出的任何错误。
- en: Making asynchronous code look synchronous
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让异步代码看起来是同步的
- en: 'Try to convert the following `Promise` code to async/await:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将以下 `Promise` 代码转换为 async/await：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You see? Even with promises, you cannot avoid nesting if you need to make use
    of the first promise's value somewhere down the chain. This is because, if you
    flatten out the promise chain, you eventually lose the previous promise's returned
    values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你看？即使有Promise，如果你需要在链的某个地方使用第一个Promise的值，你也不能避免嵌套。这是因为，如果你展开Promise链，你最终会失去之前Promise返回的值。
- en: 'Ready for the answer? Here you go:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好答案了吗？看这里：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Can you see the code clarity in the latter code? It is remarkable! Try to use
    async/await wherever you can, instead of callbacks or promises.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出后者的代码清晰度吗？这是非常显著的！尽可能使用 async/await，而不是回调或Promise。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how JavaScript executes asynchronous code. We learned
    about event loops, and basically how JavaScript manages all asynchronous and multiple
    tasks without using any additional threads. We learned about different patterns
    for writing asynchronous code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了JavaScript如何执行异步代码。我们学习了事件循环，以及JavaScript如何在不使用任何额外线程的情况下管理所有异步和多个任务。我们学习了编写异步代码的不同模式。
- en: We saw how promises make it easier to read and write asynchronous code, and
    how async/await blows away promises in practice. In the next chapter, we'll take
    a look at how to organize your JavaScript code with a modular programming approach.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了Promise如何使异步代码的读写更容易，以及async/await如何在实践中取代Promise。在下一章中，我们将探讨如何使用模块化编程方法组织你的JavaScript代码。
