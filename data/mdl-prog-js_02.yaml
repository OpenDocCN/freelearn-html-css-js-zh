- en: Chapter 2. Review of Important JavaScript OOP Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. JavaScript 重要 OOP 概念回顾
- en: Before we start creating and using our modules in JavaScript, it is important
    to have a good grasp of important **Object Oriented Programming** (**OOP**) concepts
    in JavaScript. We will rely on such concepts to design and implement our application
    modules in later chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建和使用 JavaScript 中的模块之前，了解 JavaScript 中重要的 **面向对象编程**（**OOP**）概念非常重要。我们将依赖这些概念来设计和实现我们后续章节中的应用程序模块。
- en: While my intent in this chapter is not to explore such conceptes in great depth,
    I will try to provide a good overview of some of the most important related topics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我在这章中的意图不是深入探讨这些概念，但我将尝试提供一个关于一些最重要相关主题的良好概述。
- en: If you feel that you are quite familiar with these concepts in JavaScript, you
    could skip this chapter and move on to the next one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得自己对 JavaScript 中的这些概念非常熟悉，你可以跳过这一章，直接进入下一章。
- en: However, if you are not very familiar with OOP in JavaScript, even if you are
    familiar with similar concepts in classical object oriented languages, I encourage
    you to follow along as things are a little different in JavaScript. I think it
    will be worthwhile for you to have a look at these concepts in the realm of JavaScript.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你对 JavaScript 中的面向对象编程（OOP）不是很熟悉，即使你对经典面向对象语言中的类似概念很熟悉，我也鼓励你继续阅读，因为 JavaScript
    中的情况略有不同。我认为你查看这些概念在 JavaScript 领域中会很有价值。
- en: 'In this chapter, we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: JavaScript objects and their constructors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 对象及其构造函数
- en: What `this` keyword is and how it behaves in different contexts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this` 关键字是什么以及它在不同上下文中的行为'
- en: Closure and its uses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包及其用途
- en: Inheritance in JavaScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，继承
- en: Prototype chaining
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型链
- en: And other related topics.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以及其他相关主题。
- en: JavaScript objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 对象
- en: If you have programmed in JavaScript before (as I'm sure you have, since this
    book is intended for intermediate to advanced JavaScript programmers), you will
    certainly have used objects, even if you have not been aware of their inner workings.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前编程过 JavaScript（正如我确信的那样，因为这本书是为中级到高级 JavaScript 程序员准备的），你肯定使用过对象，即使你没有意识到它们的内部工作原理。
- en: If you are familiar with other more classical object oriented languages (such
    as C++, C#, or Java), you'll be surprised to know that there is no formal syntax
    for defining classes in JavaScript (at least till **ECMAScript 6**). I think you'll
    be even more surprised to find out that, without having a formal syntax, you are
    still able to create classes in JavaScript and harness the full power of object
    oriented design and architecture (and one could even argue in a more flexible
    way).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他更经典的面向对象语言（如 C++、C# 或 Java），你可能会惊讶地发现，在 JavaScript 中没有正式的语法来定义类（至少直到
    **ECMAScript 6**）。我想你会更加惊讶地发现，在没有正式语法的情况下，你仍然能够在 JavaScript 中创建类，并充分利用面向对象设计和架构的全部力量（甚至有人可能会争论这是一种更灵活的方式）。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Formal class definition in JavaScript**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 中的正式类定义**'
- en: In the newer version of JavaScript (ES6), new syntax allows you to define classes
    in a more formal and structured way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 的新版本（ES6）中，新的语法允许你以更正式和结构化的方式定义类。
- en: 'For more information visit the following link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问以下链接：
- en: '[http://es6-features.org/](http://es6-features.org/)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://es6-features.org/](http://es6-features.org/)'
- en: 'You can create objects in JavaScript in many different ways but we will focus
    on three of these approaches for creating objects in this chapter. These approaches
    are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用许多不同的方式在 JavaScript 中创建对象，但我们将在本章中关注三种创建对象的方法。这些方法包括：
- en: Using native object type constructors
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生对象类型构造函数
- en: Using object literal notation
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象字面量表示法
- en: Using constructor functions
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数
- en: Object type constructors
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象类型构造函数
- en: Probably the easiest way to create objects in JavaScript is to create an instance
    of the Object type and then augment it with properties that we need.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中创建对象可能最简单的方法是创建一个 Object 类型的实例，然后添加我们需要的属性。
- en: As you might know, the Object type is the top level object (the root object)
    in JavaScript that all other objects are created from behind the scenes. This
    object has many properties which have been defined for it by default. Every object
    created based on this type will inherit these default properties such as `toString`,
    `valueOf`, `hasOwnProperty`, and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Object 类型是 JavaScript 中的顶级对象（根对象），所有其他对象都是在幕后从这个类型创建的。这个对象具有许多默认为其定义的属性。基于此类型创建的每个对象都将继承这些默认属性，如
    `toString`、`valueOf`、`hasOwnProperty` 等。
- en: 'Have a look at the following syntax as it shows the creation of an object using
    the `Object` constructor and augmenting it with custom properties:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下语法，它展示了使用 `Object` 构造函数创建对象并添加自定义属性的过程：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This syntax for creating objects was very popular at one point. However, it
    is no longer used as much, since using other methods of creating objects allows
    for a better conceptual view of how the object properties are packaged. Also,
    using an object constructor is not as optimized, since the interpreter needs to
    do a scope resolution to determine whether there is a local constructor with the
    same name or not, in order to create the scope chain properly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种创建对象的语法一度非常流行。然而，它不再被广泛使用，因为使用其他创建对象的方法可以更好地了解对象属性是如何打包的。此外，使用对象构造函数并不那么优化，因为解释器需要执行作用域解析来确定是否存在具有相同名称的本地构造函数，以便正确创建作用域链。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Regarding scope chains**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于作用域链**'
- en: A **scope chain** is a chain of objects whose properties are looked for when
    looking for the existence and value of a property.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**作用域链** 是一个对象链，当查找属性的存在和值时，会查找这些对象的属性。'
- en: 'For more information visit the following link:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问以下链接：
- en: '[https://blogs.msdn.microsoft.com/jscript/2007/07/26/scope-chain-of-jscript-fu](https://blogs.msdn.microsoft.com/jscript/2007/07/26/scope-chain-of-jscript-fu)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/jscript/2007/07/26/scope-chain-of-jscript-fu](https://blogs.msdn.microsoft.com/jscript/2007/07/26/scope-chain-of-jscript-fu)'
- en: Object literal notation
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象字面量表示法
- en: Creating objects using **object literal notation** allows for a good conceptual
    view of the object and all of its properties.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **对象字面量表示法** 创建对象可以很好地了解对象及其所有属性的概念视图。
- en: This approach is also very popular for passing multiple parameters to functions
    instead of passing one parameter at a time. This method of passing parameters
    allows us to package all the parameters neatly into an object (usually as an anonymous
    object) and pass it as one parameter into the function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也非常流行，用于将多个参数传递给函数，而不是一次传递一个参数。这种传递参数的方法允许我们将所有参数整齐地打包到一个对象中（通常是一个匿名对象），并将其作为一个参数传递给函数。
- en: 'Using this syntax, an object in JavaScript can be created as simply as shown
    here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法，JavaScript 中的对象可以像下面这样简单地创建：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, this object does not do anything and is completely useless, but nonetheless
    it is a valid object (**Singleton**).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个对象没有任何功能，完全无用，但无论如何，它是一个有效的对象（**单例**）。
- en: 'Let''s create another object using this approach, as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这种方法创建另一个对象，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the code above, we have created a variable that has been initialized with
    an object. Our object here consists of two value properties and a simple method
    (method property) to add these value properties.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个初始化为对象的变量。我们这里的对象由两个值属性和一个简单的方法（方法属性）组成，用于添加这些值属性。
- en: 'To interact with the object in the preceding code, we can use the variable
    that holds (references) the object `MyfirstObj` and access its members using the
    dot notation, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要与前面代码中的对象交互，我们可以使用持有（引用）该对象的变量 `MyfirstObj`，并使用点符号访问其成员，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Function objects
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数对象
- en: In JavaScript, functions are considered first class objects. In fact, anytime
    you are dealing with a function, you are dealing with an object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，函数被视为一等对象。实际上，每次你处理函数时，你都是在处理一个对象。
- en: We do not always use functions as objects in JavaScript but, when are used as
    objects, we can use them as constructors to create other objects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们并不总是将函数作为对象使用，但当我们将其作为对象使用时，我们可以将它们用作构造函数来创建其他对象。
- en: Functions as object constructors (classes)
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数作为对象构造函数（类）
- en: 'Let''s mimic the object definition in the previous section, which was written
    as an object literal, and create a constructor function to achieve the same functionality.
    Consider the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模仿上一节中用对象字面量编写的对象定义，并创建一个构造函数以实现相同的功能。考虑以下内容：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that I have created a function and called it `MyObjDefinition`. I named
    the function as such to indicate that this function is going to be used as a definition
    (class) to create other objects from.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经创建了一个名为 `MyObjDefinition` 的函数，并这样命名是为了表明这个函数将被用作定义（类）来创建其他对象。
- en: Using the `new` keyword, we can create an instance of this object and assign
    it to the `myFirstObj` variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `new` 关键字，我们可以创建这个对象的实例，并将其分配给 `myFirstObj` 变量。
- en: If you are not used to using function objects as constructors, at this point
    you might wonder if `MyObjDefinition` is a function, a class, or an object?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不习惯使用函数对象作为构造函数，那么此时您可能会想知道 `MyObjDefinition` 是一个函数、一个类还是一个对象？
- en: Well, `MyObjDefinition` is all of those! I will explain this in more depth shortly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，`MyObjDefinition` 就是所有这些！我很快就会对此进行更深入的讲解。
- en: Functions as static objects
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数作为静态对象
- en: Let's modify the preceding code so we can see how `MyObjDefinition` can be better
    thought of as an object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面的代码，以便我们可以看到 `MyObjDefinition` 如何更好地被视为一个对象。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we have moved our inner `addValues` method to the outside of
    the object definition and used the dot notation to add it to `MyObjDefinition`
    object as a property.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将内部的 `addValues` 方法移动到对象定义的外部，并使用点符号将其添加到 `MyObjDefinition` 对象作为属性。
- en: The reason that we can use such syntax is because JavaScript considers `MyObjDefinition`
    function as both a function and an object. Since we can assign properties to objects
    dynamically in JavaScript, we are able to assign the `addValues` function as a
    property to this object, using the dot notation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种语法的原因是，JavaScript 将 `MyObjDefinition` 函数视为既是函数又是对象。由于我们可以在 JavaScript
    中动态地为对象分配属性，因此我们可以使用点符号将 `addValues` 函数作为属性分配给这个对象。
- en: Note that we have called our object definition as a regular function to initialize
    the default values for the `myFirstValue` and `mySecondValue` properties. Of course,
    we can do this because `MyObjDefinition` is also a function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们像调用常规函数一样调用了我们的对象定义，以初始化 `myFirstValue` 和 `mySecondValue` 属性的默认值。当然，我们可以这样做，因为
    `MyObjDefinition` 也是一个函数。
- en: We also have changed the `myFirstValue` and `mySecondValue` variables inside
    the function definition to `MyObjDefinition.myFirstValue` and `MyObjDefinition.mySecondValue`,
    respectively. This is so `MyObjDefinition.addValues` can access them from outside
    the function definition. If you are not sure what `this` keyword is, do not be
    concerned as we will talk about it shortly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还改变了函数定义内部的 `myFirstValue` 和 `mySecondValue` 变量，分别改为 `MyObjDefinition.myFirstValue`
    和 `MyObjDefinition.mySecondValue`。这样 `MyObjDefinition.addValues` 就可以从函数定义外部访问它们。如果您不确定
    `this` 关键字是什么，请不要担心，我们很快就会讨论它。
- en: 'To add the two values, we can still use the same syntax as before:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加两个值，我们仍然可以使用之前的相同语法：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that we are not able to use `MyObjDefinition` as a constructor function
    as we did before, since now it is acting as a static object. So the following
    will produce an error:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在不能像之前那样使用 `MyObjDefinition` 作为构造函数，因为它现在正在作为一个静态对象运行。所以下面的代码会产生错误：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this scenario, while we are creating an object using the `new` keyword, the
    created object does not have the properties of the `MyObjDefinition` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当我们使用 `new` 关键字创建对象时，创建的对象并没有 `MyObjDefinition` 函数的属性。
- en: This exercise in re-factoring of our code shows how functions can act as function
    as well as objects in JavaScript, depending on the usage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重构代码的练习展示了在 JavaScript 中，函数可以根据使用情况同时作为函数和对象。
- en: I like the flexibility that JavaScript offers in how objects can be defined,
    as well as how dynamic properties can be added to objects as needed. However,
    I can see why some programmers with a background in more classical object oriented
    languages might find the approach a little confusing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 JavaScript 提供的灵活性，它允许我们定义对象，以及根据需要动态地向对象添加属性。然而，我明白为什么一些有更经典面向对象语言背景的程序员可能会觉得这种方法有点令人困惑。
- en: My take on the subject is that JavaScript has its own realm and it is best to
    understand it within its realm, as opposed to trying to see it in the context
    of classical object oriented languages.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个问题的看法是，JavaScript 有自己的领域，最好在其领域内理解它，而不是试图将其放在经典面向对象语言的背景下看待。
- en: Object literal notation versus function objects
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象字面量表示法与函数对象
- en: While both object literal notation and function object syntax can be used to
    create objects, there are situations when one approach is better suited than the
    other.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对象字面量表示法和函数对象语法都可以用来创建对象，但在某些情况下，一种方法比另一种方法更适合。
- en: 'In JavaScript, after the script is parsed, all the function declarations in
    the program are hoisted to the beginning of the script. That is why you can call
    a function before its actual definition in the code, as shown in the following
    example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，在脚本解析之后，程序中的所有函数声明都会提升到脚本的开头。这就是为什么你可以在代码中调用一个在定义之前出现的函数，如下面的例子所示：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, every time `CreatePerson` function is called a new object
    is created, augmented, and then returned. This approach is also known as the **Object
    Factory** design pattern.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每次调用`CreatePerson`函数时，都会创建一个新的对象，对其进行增强，然后返回。这种方法也被称为**对象工厂**设计模式。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Design patterns in JavaScript**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript中的设计模式**'
- en: 'If you are not familiar with design patterns in general or would like to become
    more familiar with design patterns in JavaScript, I highly recommend the following
    resource:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉设计模式，或者想更熟悉JavaScript中的设计模式，我强烈推荐以下资源：
- en: '*Mastering JavaScript Design Patterns*, *Simon Timms*.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*精通JavaScript设计模式*，*西蒙·蒂姆斯*。'
- en: Notice that the call to the `CreatePerson` function is taking place before the
    actual function definition. This code will not generate an error when it is run
    because of function hoisting. Behind the scenes, the function `CreatePerson` has
    been hoisted to the top of the script so when the call is made to this function,
    the declaration has already been encountered by the interpreter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`CreatePerson`函数的调用是在实际函数定义之前发生的。由于函数提升，这段代码在运行时不会产生错误。在幕后，`CreatePerson`函数已经被提升到脚本的顶部，所以当调用这个函数时，解释器已经遇到了这个函数的声明。
- en: Because of this mechanism, you don't have to worry if the call to the function
    takes place before the function declaration or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个机制，你不必担心函数调用是在函数声明之前还是之后发生。
- en: This does not apply to object literals since there are no function declarations
    and, thus, no hoisting involved. Therefore, all the calls to such objects need
    to happen AFTER the object definition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这不适用于对象字面量，因为没有函数声明，因此没有提升。因此，所有对这些对象的调用都需要在对象定义之后发生。
- en: 'Consider the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are first defining an object, using object literal notation, and then
    adding a property to it. Everything works fine and as expected.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用对象字面量表示法定义一个对象，然后向它添加一个属性。一切正常，符合预期。
- en: 'However, if we try to add a property to this object before the object definition,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们试图在对象定义之前向这个对象添加一个属性，如下所示：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will encounter an error.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遇到一个错误。
- en: You may also have noticed that, in the case of constructor functions, the `Person`
    function in our example, we can pass arguments to the constructor and create different
    instances of `Person` with different names and different job titles. However,
    this cannot be done when using object literal notation to create objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了，在构造函数的情况下，例如我们例子中的`Person`函数，我们可以向构造函数传递参数，并使用不同的名字和不同的职位创建不同的`Person`实例。然而，当使用对象字面量表示法创建对象时，这是无法做到的。
- en: As you can tell by now, these different approaches for creating objects are
    suited for different purposes. Most of the time, we use constructor functions
    when we need to create multiple instances of an object but use object literal
    notation to package parameters (data) that need to be passed to different parts
    of the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在所知，创建对象的这些不同方法适用于不同的目的。大多数时候，当我们需要创建多个对象实例时，我们使用构造函数，而当需要将参数（数据）打包传递到应用程序的不同部分时，我们使用对象字面量表示法。
- en: Objects created using object literal notation are also best suited for creating
    modular code, which we will see a whole lot more of later in the upcoming chapters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象字面量表示法创建的对象也最适合创建模块化代码，我们将在接下来的章节中看到很多。
- en: Let's make things a little more interesting and re-factor the preceding code
    so we can use both approaches to creating objects together.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使事情变得更有趣一些，并重构前面的代码，这样我们就可以同时使用两种创建对象的方法。
- en: 'Have a look at the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下内容：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are using object literal notation to create a person data object (`personData`)
    and then pass this data object as a package to the `CreatePerson` constructor
    to create our `firstPerson` instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用对象字面量表示法创建了一个`personData`数据对象，然后将其作为包传递给`CreatePerson`构造函数以创建我们的`firstPerson`实例。
- en: In the chapters ahead, we will be using both of these object creation approaches
    to create our modules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用这两种对象创建方法来创建我们的模块。
- en: The "this" keyword
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"this"关键字'
- en: You saw an example of using the `this` keyword when we looked at our static
    object in this chapter. We will now spend some time on `this` to understand what
    it is and how it can help us write better code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章中查看静态对象时，我们看到了使用`this`关键字的一个示例。现在，我们将花一些时间来探讨`this`，了解它是什么以及它如何帮助我们编写更好的代码。
- en: The `this` keyword is simply a reference to an object. However, that reference
    can point to different objects at different times, depending on the code execution
    context.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字只是一个对对象的引用。然而，这个引用可以在不同的时间指向不同的对象，这取决于代码的执行上下文。'
- en: 'To see what that means, let''s start by creating a simple constructor function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这意味着什么，让我们首先创建一个简单的构造函数：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, the `this` keyword has a global context. So inside the
    `Person` function, `this` refers to the `window` object (if the code is run in
    a browser). In fact, if we execute the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`this`关键字具有全局上下文。因此，在`Person`函数内部，`this`指的是`window`对象（如果代码在浏览器中运行）。实际上，如果我们执行以下操作：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have now created two properties for the `window` object, called `name` and
    `job`. We can prove this by running the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为`window`对象创建了两个属性，分别命名为`name`和`job`。我们可以通过运行以下代码来证明这一点：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keep in mind that adding properties to the global context (the `window` object)
    is not a good idea and will pollute the global context as well as creating a high
    possibility of naming collisions. This could result in unexpected behavior in
    the code and strange bugs that are hard to track.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，向全局上下文（`window`对象）添加属性不是一个好主意，这会污染全局上下文，并增加命名冲突的可能性。这可能导致代码中出现意外的行为和难以追踪的奇怪错误。
- en: 'But the `this` keyword can take a whole new context and reference a totally
    different object, when used as the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但当用作以下情况时，`this`关键字可以接受一个全新的上下文，并引用一个完全不同的对象：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are creating a new person object using our `CreatePerson` constructor.
    By using the `new` keyword, an instance of person is created and the variable
    `firstPerson` now holds a reference to this instance. This person instance has
    its `name` property set to `Tom` and its `job` property to `Software Developer`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用我们的`CreatePerson`构造函数创建一个新的`Person`对象。通过使用`new`关键字，创建了一个`Person`实例，变量`firstPerson`现在持有对这个实例的引用。这个人的实例`name`属性设置为`Tom`，`job`属性设置为`Software
    Developer`。
- en: Note that the `this` keyword inside this object now refers to the instance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个对象内部，`this`关键字现在指的是这个实例。
- en: 'Let''s create another person object definition as below:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个`Person`对象定义，如下所示：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And use our constructor function to create an instance of this second person.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用我们的构造函数来创建第二个人的实例。
- en: Once the following code is executed, `this` will refer to the instance of this
    second person.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行以下代码，`this`将指向第二个人的实例。
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can examine the properties of the second person, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查第二个人的属性，如下所示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Things can get a little more interesting at times and a bit harder to figure
    out what the context of `this` can be in different circumstances.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有时事情会变得更有趣，也更难弄清楚在不同情况下`this`的上下文是什么。
- en: 'Consider the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see in this example, we have defined an object using object literal
    notation. This object is assigned to the `myOwnObject` variable and its `getName`
    method returns the value of the `name` property in the object. So, as you might
    expect, `this` in this context refers to the context of `myOwnObject`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个示例中看到的，我们使用对象字面量表示法定义了一个对象。这个对象被分配给`myOwnObject`变量，它的`getName`方法返回对象中`name`属性的值。因此，正如您可能预期的，在这个上下文中`this`指的是`myOwnObject`的上下文：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, if we make an assignment such as:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们进行如下赋值操作：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will produce the result: **The window global**. This result is rather
    confusing.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：**全局窗口**。这个结果相当令人困惑。
- en: When we make the above assignment, only the function gets assigned from the
    left side of the expression to the right side of the expression and now `this`
    refers to the global object. Note that, in this scenario, `myOwnObject.getName`
    is just a function and as explained before `this` inside a function (not an instance
    of an object) always refers to the global context, which produces the result,
    **The window global**, when executed in the browser.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行上述赋值时，只有函数从表达式的左侧被赋值到右侧，现在 `this` 指的是全局对象。请注意，在这种情况下，`myOwnObject.getName`
    只是一个函数，如前所述，函数内的 `this`（不是对象实例）始终指向全局上下文，当在浏览器中执行时，产生结果，**The window global**。
- en: Let's consider another object definition and create an inner function (a **Closure**,
    which we will talk about shortly) inside this object. The context of `this` may
    not be what you expect in this scenario.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个对象定义，并在该对象内部创建一个内部函数（一个**闭包**，我们很快就会讨论），在这个场景中，`this` 的上下文可能不是您所期望的。
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the innermost function is an anonymous function inside another anonymous
    function, the context of the innermost function is different from the object that
    is hosting it. Therefore, `this` in this context is referencing the global context.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最内层的函数是另一个匿名函数内部的匿名函数，因此最内层函数的上下文与宿主它的对象不同。因此，在这个上下文中，`this` 指的是全局上下文。
- en: 'In order to preserve the context of `myOwnObject`, we can create a context
    in the first inner function and let the innermost function access this context.
    So we can rewrite our object definition as:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留 `myOwnObject` 的上下文，我们可以在第一个内部函数中创建一个上下文，并让最内层函数访问这个上下文。因此，我们可以将我们的对象定义重写为：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using this approach, we create a context inside the first inner function which
    references our object and then the innermost function can access this context,
    which is defined in its container (the first anonymous function). This results
    in the innermost anonymous function accessing the context of `myOwnObject` object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们在第一个内部函数中创建了一个上下文，该上下文引用了我们的对象，然后最内层函数可以访问这个上下文，该上下文定义在其容器（第一个匿名函数）中。这导致最内层的匿名函数访问
    `myOwnObject` 对象的上下文。
- en: As shown, it can be a little challenging to figure out what context `this` refers
    to at times but with practice and more experience you will become better at it.
    However, till then, don't take the context of `this` for granted and make sure
    that the context which you think `this` refers to is in fact the context that
    has been set for `this` in the code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，有时确定 `this` 所指的上下文可能有点挑战性，但通过实践和更多经验，您将变得更好。然而，在此之前，不要假设 `this` 的上下文，并确保您认为
    `this` 所指的上下文确实是代码中为 `this` 设置的上下文。
- en: Closures
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: Now that we have had a brief discussion regarding execution context as it relates
    to `this`, it is time to talk about Closures. If you don't have a lot of experience
    with JavaScript, or if you are coming from more classical object oriented languages
    such as C++, you might find the concept of Closures a bit confusing in the beginning.
    In this section, I will try to take the mystery out of this concept and explain
    why Closures can be very useful in our code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经简要讨论了与 `this` 相关的执行上下文，现在是时候谈谈闭包了。如果您在 JavaScript 方面没有太多经验，或者如果您来自更传统的面向对象语言，如
    C++，您可能会觉得闭包的概念一开始有点难以理解。在本节中，我将尝试揭开这个概念的神秘面纱，并解释为什么闭包在我们的代码中非常有用。
- en: The main idea behind Closures is about preserving context and (mostly) how an
    inner function can keep the context of its containing parent.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包背后的主要思想是保留上下文，以及（主要是）内部函数如何保持其包含父级的上下文。
- en: 'Consider the following simple example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的例子：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, innermost function `setTestValue` takes a number as a parameter
    and sets it as the starting value to be used for comparison later.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，最内层的函数 `setTestValue` 接收一个数字作为参数，并将其设置为稍后用于比较的起始值。
- en: When this function is executed, it also returns an anonymous function whose
    reference will be stored in the `theNumberExaminer` variable. This anonymous function
    is then used to compare a value passed to it with the value that was set as the
    starting value (`firstNum`) in the `setTestValue` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个函数执行时，它还返回一个匿名函数，其引用将被存储在 `theNumberExaminer` 变量中。然后，这个匿名函数被用来将其传递的值与在 `setTestValue`
    函数中设置的起始值（`firstNum`）进行比较。
- en: Note that we only pass one value `(2)` to `theNumberExaminer` to be compared
    against the starting number.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只向 `theNumberExaminer` 传递了一个值 `(2)`，以与起始数字进行比较。
- en: 'The question is: how does `theNumberExaminer` have access to the previous value
    passed to the `setTestValue` function?'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：`theNumberExaminer` 是如何访问传递给 `setTestValue` 函数的先前值的？
- en: Normally, when a function is returned, its execution context is removed and
    thus all the values related to that function's execution context are destroyed.
    However, with **Closures**, things work a little differently.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个函数返回时，其执行上下文会被移除，因此与该函数执行上下文相关的所有值都会被销毁。然而，与**闭包**不同，情况略有不同。
- en: Here, the inner anonymous function is returned from the `setTestValue` function
    call (`setTestValue(6)`) and, with it, the execution context of its parent function.
    This allows the anonymous function to have access to the value of `firstNum`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内部匿名函数从 `setTestValue` 函数调用（`setTestValue(6)`）中返回，以及其父函数的执行上下文。这使得匿名函数可以访问
    `firstNum` 的值。
- en: This relationship will hold as long as the inner function (the anonymous function)
    is not destroyed. The context of the parent object remains in memory because there
    is still a reference to the inner function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 只要内部函数（匿名函数）没有被销毁，这种关系就会保持。父对象的作用域仍然保留在内存中，因为仍然有对内部函数的引用。
- en: The most important point is that Closures allow for inner functions to have
    access to the execution context of their parent functions (objects) as part of
    their scope chain. As values in the scope of the outer function change, the inner
    function can have access to the most recent values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，闭包允许内部函数作为其作用域链的一部分访问其父函数（对象）的执行上下文。当外部函数作用域中的值发生变化时，内部函数可以访问最新的值。
- en: 'One advantage of creating and using Closures can be shown in the following
    example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和使用闭包的一个优点可以在以下示例中展示：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we first create an instance of `myClosedObject` and then
    we execute the `publicFunc` of this instance. This call changes the value of `privateValue`
    from `5` to `10`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了一个 `myClosedObject` 的实例，然后执行了这个实例的 `publicFunc`。这次调用将 `privateValue`
    的值从 `5` 改变为 `10`。
- en: When we call this method one more time, the value of `privateValue` will change
    to `20`. This is because after the first call to `publicFunc` the value of `privateValue`
    has been preserved (thanks to the created Closure). The second call to `publicFunc`,
    uses the most up to date value of `privateValue` (which is 10) to do its calculation,
    thus resulting in the value `20` being returned.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次调用这个方法时，`privateValue` 的值将变为 `20`。这是因为第一次调用 `publicFunc` 后，`privateValue`
    的值已经被保留（多亏了创建的闭包）。第二次调用 `publicFunc` 使用 `privateValue` 的最新值（即 10）来进行计算，因此返回的值是
    `20`。
- en: Encapsulation and scoping
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装和作用域
- en: As you may know, in JavaScript the idea of encapsulation is handled a little
    differently from most classical object oriented languages, since we really don't
    have a formal definition for classes (ECMAScript 6 introduces formal class definition).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在 JavaScript 中，封装的概念与大多数经典面向对象语言的处理方式略有不同，因为我们实际上并没有为类提供一个正式的定义（ECMAScript
    6 引入了正式的类定义）。
- en: When we create a variable inside a function using the keyword `var`, we are
    creating a **private** variable inside of that function, thus the scope of the
    variable is contained within the function. This also means that, if we use the
    function as a constructor function, such variables are not copied to the instances
    created using this constructor function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在函数内部使用关键字 `var` 创建变量时，我们在这个函数内部创建了一个**私有**变量，因此变量的作用域被限制在函数内部。这也意味着，如果我们将函数用作构造函数，这些变量不会被复制到使用此构造函数创建的实例中。
- en: Also, JavaScript does not have the concept of block scopes; instead it has function
    scope, so all the variables declared inside a function are accessible throughout
    the function block (ECMAScript 6 introduced block scopes).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JavaScript 没有块作用域的概念；相反，它有函数作用域，因此函数内部声明的所有变量在整个函数块中都是可访问的（ECMAScript 6 引入了块作用域）。
- en: 'Let''s consider the following function declaration:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下函数声明：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the `thirdValue` variable has been defined within the `for`
    loop block, but we can access it after the end of the `for` loop, since in JavaScript
    the scope of variables is bound to the scope of the container function and not
    the container block.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`thirdValue` 变量是在 `for` 循环块内部定义的，但我们可以在这个 `for` 循环结束后访问它，因为在 JavaScript
    中，变量的作用域绑定到容器函数的作用域，而不是容器块的作用域。
- en: 'Of course, code external to this function cannot access such variables, as
    shown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，函数外部的代码无法访问这样的变量，如下所示：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As expected, the above code will produce `undefined` in the console.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，上述代码将在控制台产生`undefined`。
- en: 'We also cannot get access to `this.instanceValue` since inside a function `this`
    references the window object, as shown:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也无法访问`this.instanceValue`，因为在函数内部`this`引用的是窗口对象，如下所示：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What happens if we use the preceding function as a constructor function and
    create an instance of the `simpleFunc` object?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的函数用作构造函数并创建`simpleFunc`对象的实例会发生什么呢？
- en: 'Consider the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you know, when we define a variable with the `this` keyword, it is copied
    to the instances of the object and hence `testObj` has a copy of it and we can
    access it from the outside code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，当我们使用`this`关键字定义一个变量时，它会复制到对象的实例中，因此`testObj`有一个它的副本，并且我们可以从外部代码中访问它。
- en: However, if we take this a step further and create a private scope (**namespace**)
    inside the constructor function, then even the inner functions of the constructor
    function will not have access to it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们再进一步，在构造函数内部创建一个私有作用域（**命名空间**），那么构造函数内部的内部函数也将无法访问它。
- en: 'Consider the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code above shows an immediately invoked anonymous function (also known as
    **IIFE**) inside our `simpleFunc` function, and even though this function has
    access to the execution context of its containing function, the containing function
    (`simpleFunc`) cannot access the variables and methods inside this inner function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了在`simpleFunc`函数内部的一个立即调用的匿名函数（也称为**IIFE**），尽管这个函数可以访问其包含函数的执行上下文，但包含函数（`simpleFunc`）无法访问这个内部函数内部的变量和方法。
- en: In fact, we have created a private namespace inside our `simpleFunc` that is
    completely hidden from the outside world.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们在`simpleFunc`函数内部创建了一个私有命名空间，这个命名空间对外界是完全隐藏的。
- en: The same is also true for when we create an instance of `simpleFunc` and try
    to access `this.inastanceValue`, since this variable is only accessible from inside
    the scope of the inner anonymous function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`simpleFunc`的实例并尝试访问`this.instanceValue`时，情况也是如此，因为这个变量仅可以从内部匿名函数的作用域内访问。
- en: 'This is shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面展示：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, while JavaScript may not have the same form of encapsulation
    as classical object oriented languages, we can still create private scopes, and
    define variables and methods inside that scope that are not accessible from the
    outside code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，虽然JavaScript可能没有像经典面向对象语言那样的封装形式，但我们仍然可以创建私有作用域，并在该作用域内定义变量和方法，这些变量和方法从外部代码中不可访问。
- en: We will be re-visiting this concept and its usages a lot more when we design
    our application modules in future chapters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来章节设计我们的应用程序模块时，我们将多次重新审视这个概念及其用法。
- en: You may also be asking yourself, "What if I want to create a constructor function
    which provides public methods, so I can access private members of the constructor
    function using these public methods?"
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会问自己，“如果我想要创建一个提供公共方法的构造函数，这样我就可以通过这些公共方法访问构造函数的私有成员呢？”
- en: 'Let''s consider the following constructor function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下构造函数：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this constructor, we have created a private member `privateValue` that is
    not accessible from the outside world. However, we have created a public method
    `this.readPrivateValue`, which can be accessed by the external code and can access
    the value of this private member.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构造函数中，我们创建了一个私有成员`privateValue`，它从外部世界无法访问。然而，我们创建了一个公共方法`this.readPrivateValue`，它可以被外部代码访问，并且可以访问这个私有成员的值。
- en: So here, we have achieved two goals. First, we have kept our private member
    protected, and second, we have still provided read access to such private member
    through our public method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们实现了两个目标。首先，我们保护了我们的私有成员，其次，我们仍然通过我们的公共方法提供了对这种私有成员的读取访问。
- en: The method `this.readPrivateValue` can be considered a **privileged method**,
    which means this public member has access to private members of the object.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`this.readPrivateValue`可以被认为是一个**特权方法**，这意味着这个公共成员可以访问对象的私有成员。
- en: Inheritance
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'If you have a background in classical object oriented languages such as C++,
    C#, or Java, you will be quite familiar with the concept of inheritance. In such
    languages, there are two types of inheritance: **interface inheritance** and **implementation
    inheritance**.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像C++、C#或Java这样的经典面向对象语言，你将非常熟悉继承的概念。在这些语言中，有两种继承类型：**接口继承**和**实现继承**。
- en: JavaScript however, only supports implementation inheritance, as there is no
    concept of function signature which is required for interface inheritance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript 只支持实现继承，因为没有函数签名这个概念，它是接口继承所必需的。
- en: There are various ways of implanting inheritance in JavaScript and they all
    have their pros and cons. In this section, I will cover a few ways of implementing
    such relationship among objects and will briefly explain the advantages and disadvantages
    of each approach.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中实现继承有多种方式，每种方式都有其优缺点。在本节中，我将介绍几种实现对象之间这种关系的方法，并简要说明每种方法的优缺点。
- en: Prototype chaining
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型链
- en: Let's start by creating two different constructor functions and an inheritance
    relationship between them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建两个不同的构造函数，并在它们之间建立继承关系。
- en: 'Consider the following two function objects:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个函数对象：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we have created two extremely simple constructor functions.
    As you can see, we have defined a simple property for each one of them which are
    methods related to each object. However, we have created these simple methods
    as properties of the `prototype` object for each function as opposed to directly
    creating them on the constructor functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了两个极其简单的构造函数。正如你所见，我们为它们中的每一个定义了一个简单的属性，这些属性是与每个对象相关的方法。然而，我们把这些简单的方法作为每个函数的
    `prototype` 对象的属性来创建，而不是直接在构造函数上创建它们。
- en: If you are familiar with the `prototype` property, you know that every function
    has this property by default. The value of this property is an object that is
    shared with all the instances that are created using the constructor function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 `prototype` 属性，你知道每个函数默认都有这个属性。这个属性的值是一个对象，它与使用构造函数创建的所有实例共享。
- en: The advantage of creating methods (properties) on `prototype` object as opposed
    to on the constructor function itself is that by doing so, all the instances that
    are created using the constructor share these methods. Therefore, these instances
    do not have to have their own copy of these properties, thus optimizing our code's
    performance and memory usage.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `prototype` 对象上创建方法（属性）而不是在构造函数本身上创建的优点是，通过这样做，所有使用构造函数创建的实例都共享这些方法。因此，这些实例不需要有它们自己的这些属性的副本，从而优化了我们的代码的性能和内存使用。
- en: In the preceding code, in the case of `BaseType`, we simply augmented the `prototype`
    object of this constructor with a method called `getBaseValue`, but for `ChildType`,
    we did something a little different.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，对于 `BaseType`，我们只是简单地在构造函数的 `prototype` 对象上增加了一个名为 `getBaseValue` 的方法，但对于
    `ChildType`，我们做了点不同的事情。
- en: 'We first created an instance of `BaseType` and then we assigned it to `ChildType`
    using the following expression:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个 `BaseType` 的实例，然后使用以下表达式将其赋值给 `ChildType`：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After the above assignment, the `ChildType.prototype` value becomes an instance
    of `BaseType`. This means that this `prototype` object has access to two properties
    now, `baseValue` and `getBaseValue`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述任务之后，`ChildType.prototype` 的值变成了 `BaseType` 的一个实例。这意味着这个 `prototype` 对象现在可以访问两个属性，`baseValue`
    和 `getBaseValue`。
- en: The end result is that there are two properties that instances of `ChildType`
    have access to but didn't need to create them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，`ChildType` 的实例可以访问两个属性，但不需要创建它们。
- en: 'When we run the following line of code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行以下行代码时：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `childInstance` variable can return the value of the `baseValue` variable,
    using `getBaseValue` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`childInstance` 变量可以使用 `getBaseValue` 方法返回 `baseValue` 变量的值。'
- en: Of course, `childInstance` also has access to its own variable `childTypeValue`.
    If we run the following code, `50` will be displayed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`childInstance` 也可以访问它自己的变量 `childTypeValue`。如果我们运行以下代码，将显示 `50`。
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Property look up in prototype chaining
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原型链中的属性查找
- en: Let's examine how `ChildInstance` gets access to the properties of `BaseType`
    in a little more depth.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地考察 `ChildInstance` 如何访问 `BaseType` 的属性。
- en: When we try to access a property on `ChildInstance`, behind the scenes, a search
    is conducted on the instance itself to see if that property is available. If the
    property is not found, then the search continues to the `prototype` object of
    the `ChildInstance` object. Since an instance of `BaseType` is the value of the
    `prototype` object belonging to `ChildInstance`, the search is continued in `BaseType`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问`ChildInstance`上的属性时，幕后会在这个实例本身上进行搜索，以查看该属性是否可用。如果属性未找到，则搜索将继续到`ChildInstance`对象的`prototype`对象。由于`BaseType`的实例是`ChildInstance`所属的`prototype`对象的值，搜索将继续在`BaseType`中进行。
- en: But there is more, the instance of `BaseType` (which is the value of the `prototype`
    object belonging to `ChildType`) itself has a `prototype` object and our `ChildType`
    prototype has a link to this `prototype` object. That prototype object has a property
    called `getBaseValue`. Since this method has access to the `BaseType` properties,
    it can return the value of `baseValue`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有更多，`BaseType`的实例（它是`ChildType`所属的`prototype`对象的值）本身也有一个`prototype`对象，我们的`ChildType`原型与这个`prototype`对象有链接。这个原型对象有一个名为`getBaseValue`的属性。由于这个方法可以访问`BaseType`属性，它可以返回`baseValue`的值。
- en: 'You can think of how this lookup is conducted as shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象这个查找是如何进行的，如下所示：
- en: '![Property look up in prototype chaining](img/B04910_02_01.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![原型链中的属性查找](img/B04910_02_01.jpg)'
- en: As you can see, there is quite a bit of searching taking place in order to find
    the instance property. Also, keep in mind that if the property was not found in
    the `prototype` of `BaseType`, the search would have continued to the `prototype`
    object of the parent of all objects in JavaScript, the `Object` type. Let's talk
    about how that works.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，为了找到实例属性，进行了相当多的搜索。此外，请记住，如果属性在`BaseType`的`prototype`中未找到，搜索将继续到JavaScript中所有对象的父类的`prototype`对象，即`Object`类型。让我们谈谈它是如何工作的。
- en: Remember that every function has a `prototype` property which its value is an
    object. This `prototype` object itself has a `prototype` property which its value
    is the `prototype` object of the `Object` type.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个函数都有一个`prototype`属性，其值是一个对象。这个`prototype`对象本身也有一个`prototype`属性，其值是`Object`类型的`prototype`对象。
- en: That is why, when we call the `BaseType.toString` method, even though we have
    not defined this method on `BaseType` or its `prototype` object, the call still
    succeeds and produces the string value of the object. The `toString` method is
    defined on the `prototype` object of `Object` type, and thus is available to all
    the children of `Object` type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，当我们调用`BaseType.toString`方法时，即使我们没有在`BaseType`或其`prototype`对象上定义这个方法，调用仍然成功并产生对象的字符串值。`toString`方法是在`Object`类型的`prototype`对象上定义的，因此对所有`Object`类型的子类都是可用的。
- en: It is very important to keep in mind that the search is ceased and will not
    continue any further in the chain of `protoypes`, as soon as the property that
    the search is being conducted for is found.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要记住，一旦找到正在搜索的属性，搜索就会停止，不会在`prototype`链中继续进行。
- en: To make it a little more clear, let's modify our `ChildType` to have a property
    (method) called `getBaseValue`. Doing so will result in what is known as **shadowing**
    (or masking) of this property on `BaseType`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它更清晰，让我们将我们的`ChildType`修改为具有一个名为`getBaseValue`的属性（方法）。这样做会导致所谓的**遮蔽**（或掩盖）在`BaseType`上的这个属性。
- en: 'So, if we modify the code for `ChildType` as below:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们修改`ChildType`的代码如下：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The call to `childInstance.getBaseValue` will now return the value `50` instead
    of `2`. This is because as soon as the search for the `getBaseValue` method (property)
    finds this method on `ChildType`, it will not search any further and will execute
    this method. This of course, will return the value of the `childTypeValue` property.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`childInstance.getBaseValue`现在将返回值`50`而不是`2`。这是因为一旦搜索到`getBaseValue`方法（属性）在`ChildType`上，它将不再继续搜索并执行此方法。当然，这将返回`childTypeValue`属性的值。
- en: One other thing that we need to keep in mind, is the fact that because of the
    relationship that has been created among all these reference types, the following
    instance check will return `true` for all of them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要注意的另一件事是，由于所有这些引用类型之间建立的关系，以下实例检查将返回`true`。
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can use this test to see if one reference type is inheriting properties
    from another reference type.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个测试来查看一个引用类型是否从另一个引用类型继承属性。
- en: While prototype chaining has many advantages and allows us to create inheritance
    among our base objects and our child objects, it has the disadvantage that any
    changes to the base object's reference type properties are reflected in all the
    instances of the child classes. This at times may not be a desirable effect and
    you need to be aware of it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`prototype`链有许多优点，并允许我们在基对象和子对象之间创建继承，但它有一个缺点，即任何对基对象引用类型属性的更改都会反映在子类的所有实例中。有时这可能不是期望的效果，你需要对此有所了解。
- en: Resetting the constructor property
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重置构造函数属性
- en: 'Every `prototype` object has a `constructor` property. This property always
    refers back to the constructor function itself. When we overwrite the `prototype`
    property completely as we did in the previous code by setting it like so:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`prototype`对象都有一个`constructor`属性。这个属性始终指向构造函数本身。当我们像之前代码中那样完全覆盖`prototype`属性时，如下所示：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `constructor` property of the `prototype` object will be referencing the
    parent object. This can be examined as below:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`prototype`对象的`constructor`属性将引用父对象。这可以通过以下方式进行检查：'
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Which displays:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is always a good idea to reset the `constructor` property of the `prototype`
    object after it has been completely replaced, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`prototype`对象被完全替换后，重置其`constructor`属性总是一个好主意，如下所示：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is so the `prototype` object can correctly point back to the correct constructor
    object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这样`prototype`对象才能正确地指向正确的构造函数对象。
- en: 'The reset enables us to correctly find the constructor object of the instance
    as shown:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 重置使我们能够正确地找到实例的构造函数对象，如下所示：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Which now correctly reports the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正确地报告以下内容：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will discuss the `constructor` property some more, later in this chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面进一步讨论`constructor`属性。
- en: Constructor stealing
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数窃取
- en: Another approach to creating inheritance in JavaScript is using a technique
    known as **constructor stealing**, which is similar to classical inheritance in
    other object oriented languages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中创建继承的另一种方法是使用称为**构造函数窃取**的技术，这与其他面向对象语言中的经典继承类似。
- en: 'Consider the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the above code, we are using the `call` method to execute `BaseType` in the
    context of `ChildType`. This results in `ChildType` instances getting a copy of
    all the properties of `BaseType`. Since each instance of `ChildType` now has its
    own copy of the properties, modifying the properties of `BaseType` is not reflected
    in the child instances.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用`call`方法在`ChildType`的上下文中执行`BaseType`。这导致`ChildType`实例获得`BaseType`的所有属性副本。由于`ChildType`的每个实例现在都有自己的属性副本，因此修改`BaseType`的属性不会反映在子实例中。
- en: This approach, however, has its own issues. The main issue is that since we
    are not assigning an instance of `BaseType` to the `prototype` object of `ChildType`,
    the properties defined on the `prototype` object of `BaseType` are not shared
    among the instances of `ChildType`. This will no result in the most efficient
    approach in implementing inheritance and does not allow for code sharing of the
    parent's `prototype` object properties among child instances.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有其自身的问题。主要问题是由于我们没有将`BaseType`的实例分配给`ChildType`的`prototype`对象，因此定义在`BaseType`的`prototype`对象上的属性在`ChildType`的实例之间不会共享。这将导致在实现继承时不是最有效的方法，并且不允许在子实例之间共享父`prototype`对象的属性代码。
- en: Parasitic combination inheritance
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寄生组合继承
- en: Another way to create inheritance relationships among reference types is to
    use a combination of the techniques that we have already discussed, while eliminating
    their inefficiencies. This is also my favorite technique for creating inheritance.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 创建引用类型之间继承关系的另一种方法是使用我们已讨论的技术组合，同时消除其低效之处。这也是我创建继承的最喜欢的技术。
- en: 'Let''s modify the code that we have already seen, so we can implement this
    approach:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们之前看到的代码，以便我们可以实现这种方法：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this latest implementation, we are using the `call` method in the `ChildType`
    constructor to copy all the properties of `BaseType`. This provides the child
    object instance with the ability to modify the properties of `BaseType`, which
    only affects that particular instance of `ChildType` and does not get reflected
    in other instances of `ChildType`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最新的实现中，我们在`ChildType`构造函数中使用`call`方法来复制`BaseType`的所有属性。这为子对象实例提供了修改`BaseType`属性的能力，这只会影响特定的`ChildType`实例，并且不会反映在其他`ChildType`实例中。
- en: 'In our example, this type of inheritance is initiated in the following statement
    in the `ChildType` constructor:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这种继承类型是在`ChildType`构造函数中的以下语句中启动的：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We also have assigned the `prototype` of `BaseType` to `ChildType`, as shown:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还像下面这样将`BaseType`的`prototype`分配给了`ChildType`：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that we have assigned only the `prototype` object of `BaseType` to the
    `prototype` object of `ChildType`, thus eliminating the second call to the `BaseType`
    constructor, resulting in more efficient code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只将`BaseType`的`prototype`对象分配给了`ChildType`的`prototype`对象，从而消除了对`BaseType`构造函数的第二次调用，这导致了更高效的代码。
- en: This approach also has the advantage of allowing us to share all the properties
    that have been defined on the `prototype` object of `BaseType` among all the instances
    of the child object. Therefore, not every child object instance will have its
    own copy of such properties, which in turn leads to better code efficiency and
    memory management.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还有优点，即允许我们在所有子对象实例之间共享在`BaseType`的`prototype`对象上定义的所有属性。因此，并不是每个子对象实例都会有这样的属性副本，这反过来又导致了更好的代码效率和内存管理。
- en: Once we create an instance of `ChildType`, this instance has access to copied
    properties from `BaseType` as well as all the shared properties defined on the
    `prototype` object of `BaseType`. Of course, each instance also has access to
    all of its own properties defined on the `ChildType` constructor and on the `ChildType`
    prototype object.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`ChildType`的实例，这个实例就可以访问从`BaseType`复制的属性以及定义在`BaseType`的`prototype`对象上的所有共享属性。当然，每个实例也可以访问定义在`ChildType`构造函数和`ChildType`原型对象上的所有自己的属性。
- en: '**Parasitic combination inheritance** provides us with the best of both previously
    discussed techniques (**prototype chaining** and **constructor stealing**) and
    it is widely used by many experienced JavaScript developers.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**寄生组合继承**提供了之前讨论过的两种技术（**原型链**和**构造函数窃取**）的优点，并且被许多经验丰富的JavaScript开发者广泛使用。'
- en: Constructor property
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数属性
- en: Every object in JavaScript has a `constructor` property that references the
    constructor object that was used to create the instance of that object.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的每个对象都有一个`constructor`属性，该属性引用了用于创建该对象实例的构造函数对象。
- en: 'For instance, in all functions, the `constructor` property has a reference
    to the `Function` type constructor. We could verify this by executing the following
    statement:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在所有函数中，`constructor`属性都引用了`Function`类型构造函数。我们可以通过执行以下语句来验证这一点：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since `prototype` property''s value is an object too, it also has a `constructor`
    property. However, this `constructor` property references the object (function)
    itself. So if we examine this property **before** we assign the `BaseType.prototype`
    object to `ChildType.prototype`, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`prototype`属性的值也是一个对象，它也有一个`constructor`属性。然而，这个`constructor`属性引用的是对象（函数）本身。所以如果我们在这个属性**之前**将`BaseType.prototype`对象赋值给`ChildType.prototype`，如下所示：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can see that this property is referencing the object that `prototype` belongs
    to, which in this case is `ChildType`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个属性引用的是`prototype`所属的对象，在这种情况下是`ChildType`。
- en: 'As mentioned previously, if we completely replace the `prototype` object ,
    as in the case of the following statement, which was used in implementing our
    previous inheritance:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果我们完全替换`prototype`对象，就像在实现我们之前的继承时使用的以下语句那样，我们可以：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We overwrite the value of the `constructor` property on the `prototype` object
    of `Childtype`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们覆盖了`Childtype`的`prototype`对象上`constructor`属性的值。
- en: If we examine the `constructor` property of the `prototype` object now, it will
    be referencing `BaseType`, instead of `Childtype`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在检查`prototype`对象的`constructor`属性，它将引用`BaseType`，而不是`Childtype`。
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As seen before, we need to reset the `constructor` property of the `prototype`
    object as shown:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要重置`prototype`对象的`constructor`属性，如下所示：
- en: '[PRE53]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Keep in mind that resetting the `constructor` property needs to happen after
    the `prototype` object has been re-written and not before. Otherwise, the re-write
    will completely remove the `constructor` property.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，重置`constructor`属性需要在重写`prototype`对象之后进行，而不是之前。否则，重写将完全删除`constructor`属性。
- en: 'The following is an example of how this should be done:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何实现这一点的示例：
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: I encourage you to examine all the code discussed in this section closely to
    understand how all the pieces are tied together and how inheritance works among
    objects.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你仔细检查本节中讨论的所有代码，以了解所有部分是如何联系在一起的，以及对象之间的继承是如何工作的。
- en: Native support for inheritance
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地继承支持
- en: Now that we have had a look at different techniques for creating inheritance
    among constructor functions, it is a good idea to consider native support for
    creating such relationships in JavaScript.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了创建构造函数之间继承的不同技术，考虑JavaScript中创建此类关系的本地支持是个好主意。
- en: ECMAScript 5 provides **prototypal inheritance** by way of `Object.create()`
    method.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5通过`Object.create()`方法提供了**原型继承**。
- en: This method accepts two parameters. The first parameter is the object to be
    used as the `prototype` (base object) for the new object. The second parameter
    is optional and is used to add additional properties to the new object.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受两个参数。第一个参数是要用作新对象`prototype`（基对象）的对象。第二个参数是可选的，用于向新对象添加额外的属性。
- en: 'Consider the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There are some interesting points that you need to keep in mind regarding the
    preceding code. As you can see, we have used the `BaseType` constructor and have
    passed it to the `Object.create` method to create an instance of our `BaseType`
    object and assign it to the `ChildType1` variable.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码，有一些有趣的观点需要你记住。正如你所见，我们使用了`BaseType`构造函数并将其传递给`Object.create`方法来创建我们的`BaseType`对象实例，并将其分配给`ChildType1`变量。
- en: We then have added a new value to the property `secondValue` array of this new
    object (`ChildType1`). In the next line, we have also added a new method, `getBaseTypeFirstValue`
    to this instance.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在新对象（`ChildType1`）的`secondValue`属性数组中添加了一个新值。在下一行中，我们还向该实例添加了一个新方法`getBaseTypeFirstValue`。
- en: 'When we create a second object `ChildType2` using the method `Object.create`,
    and examine the value of the `secondValue` array, we see that the value is as
    shown below:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Object.create`方法创建第二个对象`ChildType2`并检查`secondValue`数组的值时，我们看到值如下所示：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is because the modified property `secondValue` is shared among all the
    instances that have inheritance relationships with the base object `BaseType`.
    Thus, all the changes done to the properties of the base object by one child instance
    are reflected in all the instances, as well as in the base object, `BaseType`
    itself. This is shown here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为修改后的属性`secondValue`在所有与基对象`BaseType`有继承关系的实例之间是共享的。因此，一个子实例对基对象属性所做的所有更改都会反映在所有实例中，以及基对象本身`BaseType`中。这在此处显示：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is an important point to keep in mind.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要记住的重要观点。
- en: As previously mentioned, we could also use the second optional parameter of
    the `Object.create` method to add new properties to the child instance at the
    same time that we create the inheritance relationship between the base and the
    child object.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们还可以使用`Object.create`方法的第二个可选参数，在创建基对象和子对象之间的继承关系的同时，向子实例添加新属性。
- en: 'Consider the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `ChildType` object has now inherited all the properties of the `BaseType`
    object and has a new property `optionalObject`, which is specific to this instance
    of the child object.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildType`对象现在继承了`BaseType`对象的所有属性，并有一个新的属性`optionalObject`，这是针对子对象实例特有的。'
- en: Even though this is a native way for creating inheritance among objects in ECMAScript
    5, I have found this technique to not be as popular as parasitic combination inheritance.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是在ECMAScript 5中创建对象之间继承的本地方式，但我发现这种技术并不像寄生组合继承那样受欢迎。
- en: I personally find this approach to be a little too verbose in comparison to
    the other approaches that we covered in this chapter for implementing inheritance
    but it allows us to define attributes of the new property exactly as we like.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中我们讨论的其他实现继承的方法相比，我个人觉得这种方法有点过于冗长，但它允许我们精确地定义新属性的属性。
- en: Note
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can refer to the following online resource for more information regarding
    the `Object.create` method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下在线资源以获取有关`Object.create`方法的更多信息：
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)'
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The goal of this chapter was to provide a quick overview of some OOP concepts
    in JavaScript. Having a good understanding of these concepts is important as we
    will be using them in implementing our modular architecture in the following chapters.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是快速概述JavaScript中的一些面向对象概念。对这些概念有良好的理解非常重要，因为我们将使用它们在接下来的章节中实现我们的模块化架构。
- en: In this chapter, we looked at various ways of creating objects as well as concepts
    such as closure, encapsulation, and inheritance.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了创建对象的各种方法，以及闭包、封装和继承等概念。
- en: The assumption that I made was that you likely have a fairly good experience
    with JavaScript and are probably familiar with at least some of these concepts.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的假设是，你们可能对JavaScript有相当丰富的经验，并且可能至少熟悉这些概念中的某些。
- en: My intent was to provide "just enough" of a review of JavaScript OOP concepts
    to get you ready for future chapters.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意图是提供“足够”的JavaScript面向对象概念回顾，以便你们为未来的章节做好准备。
- en: There are many good resources available that can help you extend your knowledge
    of Object Oriented JavaScript principles further.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优质的资源可以帮助你们进一步扩展对面向对象JavaScript原则的了解。
- en: 'Two of my personal favorites on this topic are:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题上，我个人的两个最爱是：
- en: '*Object-Oriented JavaScript*, *Stoyan Stefanov*, *Kumar Chetan Sharma*'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《面向对象的JavaScript》，作者：*Stoyan Stefanov*，*Kumar Chetan Sharma*
- en: '*Professional JavaScript for Web Developers*, *Nicholas C. Zakas*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《专业JavaScript Web开发者指南》，作者：*Nicholas C. Zakas*
- en: In the next chapter, we will start focusing on a popular design pattern known
    as **Module Design Pattern** to get us ready for creating simple modules in our
    application.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始关注一个流行的设计模式，即**模块设计模式**，以便我们为在应用程序中创建简单模块做好准备。
