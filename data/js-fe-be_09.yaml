- en: '*Chapter 6*: Creating and Using Node.js Modules'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：创建和使用Node.js模块'
- en: Modules are at the heart of Node.js. They correspond to JavaScript files and
    can be used in our applications. A program for the Node.js server will consist
    of a set of modules, that is, JavaScript files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是Node.js的核心。它们对应于JavaScript文件，并可以在我们的应用程序中使用。Node.js服务器的程序将包含一组模块，即JavaScript文件。
- en: 'There are three kinds of modules:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的模块：
- en: Modules that we write ourselves for our applications.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为我们的应用程序编写的模块。
- en: Modules internal to Node.js and usable directly.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js内部的模块和可以直接使用的模块。
- en: Modules that can be downloaded from the internet using a utility called `npm`
    (npm stands for Node.js package manager). This `npm` utility is installed with
    Node.js itself.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用名为`npm`（npm代表Node.js包管理器）的实用程序从互联网上下载的模块。这个`npm`实用程序与Node.js本身一起安装。
- en: In this chapter, we will learn how to create and use these different types of
    modules.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建和使用这些不同类型的模块。
- en: Regardless of the type of modules used, the `require(moduleName)` instruction
    (see below) allows the module called `moduleName` to be included in the current
    file. The functionalities of the module will then be accessible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种类型的模块，`require(moduleName)`指令（见下文）都允许将名为`moduleName`的模块包含到当前文件中。模块的功能将随后可访问。
- en: 'Here are the topics covered in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Using our own modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们自己的模块
- en: Using internal Node.js modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内部Node.js模块
- en: Using downloaded modules with npm
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用npm下载的模块
- en: Let’s first see how to create and use our own modules with Node.js.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用Node.js创建和使用我们自己的模块。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter on GitHub at: [https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip](https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件：[https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip](https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip)。
- en: Creating and using our own modules
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用我们自己的模块
- en: 'In this example, we use two modules, each corresponding to a JavaScript file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了两个模块，每个模块对应一个JavaScript文件：
- en: The first module (here named `test.js`) will be the main file of our application,
    the one we execute using the `node test.js` command in a command window.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个模块（这里命名为`test.js`）将是我们的应用程序的主文件，我们将在命令窗口中使用`node test.js`命令执行该文件。
- en: The second module (here named `module1.js`) will be the one we want to use in
    our main `test.js` module. The `module1.js` module will then be enriched to show
    how its functionalities are accessible outside the module (and will therefore
    be used in the main `test.js` module).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个模块（这里命名为`module1.js`）将是我们在主`test.js`模块中想要使用的模块。`module1.js`模块将被丰富以展示其功能如何在外部模块中访问（因此将在主`test.js`模块中使用）。
- en: Let’s go ahead and create these two modules.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建这两个模块。
- en: Creating a module
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个模块
- en: 'Here is the content of the two files, `module1.js` and `test.js`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个文件的内容，`module1.js`和`test.js`：
- en: module1.js file
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: module1.js文件
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The module currently has a simple `console.log()` statement. The module will
    then be enriched. The main module test.js is the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块目前有一个简单的`console.log()`语句。然后模块将被丰富。主模块`test.js`如下所示：
- en: test.js file
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: test.js文件
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we use the `require(moduleName)`instruction, which allows us to load in
    memory the `moduleName` module. Any use of the functionalities of the `moduleName`
    module requires the `require(moduleName)`instruction beforehand.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`require(moduleName)`指令，它允许我们将`moduleName`模块加载到内存中。任何使用`moduleName`模块功能的行为都需要事先执行`require(moduleName)`指令。
- en: The `require(moduleName)` instruction returns a reference to the module loaded
    in memory. This reference is stored in a variable (here, `mod1`), which will then
    allow access to the functionalities described in the module (here, none for the
    moment).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`require(moduleName)`指令返回对已加载到内存中的模块的引用。这个引用存储在一个变量中（这里，`mod1`），然后允许访问模块中描述的功能（目前没有）。'
- en: The `test.js` file is the main file that loads the other modules. It is therefore
    this `test.js` file that is executed using the `node test.js` instruction in a
    command window.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`test.js`文件是加载其他模块的主文件。因此，在命令窗口中使用`node test.js`指令执行的是这个`test.js`文件。'
- en: '![Figure 6.1 – Using a module with require(module)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 使用require(module)模块]'
- en: '](img/Figure_6.01_B17416.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01_B17416.jpg)'
- en: Figure 6.1 – Using a module with require(module)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 使用require(module)模块
- en: We can see here that the execution of the main `test.js` module invokes the
    call of the `require("./module1.js")`instruction, which executes the content of
    the `module1.js` file, hence the display text specified in the `console.log()`
    statement in the `module1.js` module.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到，主模块 `test.js` 的执行调用了 `require("./module1.js")` 指令的调用，这执行了 `module1.js`
    文件的内容，因此显示文本是在 `module1.js` 模块中指定的 `console.log()` 语句。
- en: After loading `module1.js`, the `mod1` variable is initialized and we will be
    able to access functionalities that the module exports later on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载 `module1.js` 之后，`mod1` 变量被初始化，我们随后将能够访问模块后来导出的功能。
- en: Before adding functionalities to the `module1.js` module, let’s see how to manage
    the location of modules using the `node_modules` directory. The `node_modules`
    directory is used by Node.js to locate modules for which it does not have a path.
    Using this directory simplifies the writing of module names when loading them
    into memory with the `require(moduleName)` instruction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在向 `module1.js` 模块添加功能之前，让我们看看如何使用 `node_modules` 目录来管理模块的位置。`node_modules`
    目录被 Node.js 用于定位它没有路径的模块。使用此目录简化了在用 `require(moduleName)` 指令将它们加载到内存中时编写模块名称。
- en: Using the node_modules directory
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 node_modules 目录
- en: Note that the previous `require(moduleName)` statement requires indicating the
    access path to the module, for example, `"./"` to indicate the current directory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前的 `require(moduleName)` 语句需要指定模块的访问路径，例如，使用 `"./"` 来指示当前目录。
- en: 'However, if the module is in the `node_modules` directory, it is not necessary
    to indicate the path because we are sure that the module is inside the `node_modules`
    directory (and moreover, it should *not* be specified). The `node_modules` directory
    can be in the main application directory (called the *local* `node_modules` directory)
    or in a dedicated directory created by Node.js (called the *global* `node_modules`
    directory: in this case, it is automatically created during the installation of
    Node.js).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果模块在 `node_modules` 目录中，则不需要指定路径，因为我们确信模块在 `node_modules` 目录内（而且更不应该指定）。`node_modules`
    目录可以位于主应用程序目录中（称为 *local* `node_modules` 目录）或由 Node.js 创建的专用目录中（称为 *global* `node_modules`
    目录：在这种情况下，它是在 Node.js 安装期间自动创建的）。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the module is not found in the `node_modules` directory (local or global)
    and if the access path to the module is not indicated, an error occurs when loading
    the module with the `require(moduleName)` instruction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `node_modules` 目录（本地或全局）中找不到模块，并且没有指定模块的访问路径，则在用 `require(moduleName)` 指令加载模块时将发生错误。
- en: 'Now, we will create a `node_modules` directory in the current directory where
    the main file, `test.js`, is located. Let’s transfer the `module1.js` file to
    this directory and use the `require("module1.js")` statement without specifying
    the path to the module. You can also write `require("module1")` without indicating
    the extension of the JavaScript file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在主文件 `test.js` 所在的当前目录中创建一个 `node_modules` 目录。让我们将 `module1.js` 文件转移到这个目录，并使用
    `require("module1.js")` 语句而不指定模块的路径。您也可以不指定 JavaScript 文件的扩展名来写 `require("module1")`：
- en: Include module1 located in node_modules directory (test.js file)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 包含位于 node_modules 目录中的模块1（test.js 文件）
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `module1.js` file must be in the locally created `node_modules` directory,
    while the `test.js` file remains in the current directory, as described here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`module1.js` 文件必须位于本地创建的 `node_modules` 目录中，而 `test.js` 文件则保持在当前目录中，如下所述：'
- en: '`root/`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`root/`'
- en: '`|— node_modules/`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`|— node_modules/`'
- en: '`│ |— module1.js`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`│ |— module1.js`'
- en: '`|— test.js`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`|— test.js`'
- en: '![Figure 6.2 – The module is loaded from the node_modules directory'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 模块从 node_modules 目录加载'
- en: '](img/Figure_6.02_B17416.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B17416.jpg)'
- en: Figure 6.2 – The module is loaded from the node_modules directory
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 模块从 node_modules 目录加载
- en: We can see that the module is indeed found by Node.js, because Node.js looks
    for it in the `node_modules` directory, which was created in the current directory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，模块确实被 Node.js 找到了，因为 Node.js 在当前目录中创建的 `node_modules` 目录中寻找它。
- en: Now let’s see how to allow a module’s files to be grouped in a directory, using
    the `package.json` file associated with the module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用与模块关联的 `package.json` 文件允许模块的文件在目录中分组。
- en: Using the package.json file
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 package.json 文件
- en: The `node_modules` directory (whether located in the application directory or
    the Node.js installation directory) can contain a lot of files and sometimes a
    module can consist of many files and directories. It would be easier to associate
    a module with a directory in the `node_modules` directory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`node_modules` 目录（无论位于应用程序目录还是 Node.js 安装目录）可以包含许多文件，有时一个模块可以由许多文件和目录组成。将模块与
    `node_modules` 目录中的目录关联起来会更容易。'
- en: Let’s create the `module1` directory inside the `node_modules` directory. The
    `module1` directory contains the `module1.js` file but may also contain other
    files and directories related to this module.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `node_modules` 目录内创建 `module1` 目录。`module1` 目录包含 `module1.js` 文件，但也可能包含与此模块相关的其他文件和目录。
- en: 'The file system is displayed here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统在此显示：
- en: '`root/`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`root/`'
- en: '`|— node_modules/`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`|— node_modules/`'
- en: '`| |— module1/`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`| |— module1/`'
- en: '`│ |— module1.js`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`│ |— module1.js`'
- en: '`|— test.js`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`|— test.js`'
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `moduleName` indicated in the `require(moduleName)` statement represents,
    in this case, the name of the *directory* that contains the module files.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `require(moduleName)` 语句中指示的 `moduleName` 在此情况下表示包含模块文件的 *目录* 名称。
- en: But as it is necessary to know which file of the directory we must use first
    when loading the module (as there can be many files in this directory), we indicate
    this correspondence in the `package.json` file in the `"main"` key.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于在加载模块时必须知道我们首先需要使用目录中的哪个文件（因为在这个目录中可能有多个文件），我们在 `"main"` 键中的 `package.json`
    文件中指示了这个对应关系。
- en: The `package.json` file is a text file in JSON format, located in the directory
    of each Node.js module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件是一个位于每个 Node.js 模块目录中的 JSON 格式的文本文件。'
- en: Now, we will create the `package.json` file in the `module1` module directory
    and indicate in this file the `"main"` key with the value `"module1.js"`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `module1` 模块目录中创建 `package.json` 文件，并在该文件中用 `"module1.js"` 的值指示 `"main"`
    键。
- en: 'The file system is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统如下：
- en: '`root/`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`root/`'
- en: '`|— node_modules/`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`|— node_modules/`'
- en: '`| |— module1/`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`| |— module1/`'
- en: '`│ |— module1.js`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`│ |— module1.js`'
- en: '`│ |— package.json`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`│ |— package.json`'
- en: '`|— test.js`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`|— test.js`'
- en: package.json file in the node_modules/module1 directory (package.json file)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 node_modules/module1 目录中的 package.json 文件（package.json 文件）
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We indicate in the `"main"` key that we must load the `module1.js` file during
    the `require("module1")` instruction:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `"main"` 键中指示，在执行 `require("module1")` 指令时必须加载 `module1.js` 文件：
- en: Including module1 located in node_modules/module1 directory (test.js file)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 包含位于 node_modules/module1 目录中的 module1（test.js 文件）
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the module name in the `require("module1")` statement in this
    case is the name of the directory that contains the module in the `node_modules`
    directory. So, we cannot write the instruction here in the form `require("module1.js")`,
    which would cause an error.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，`require("module1")` 语句中的模块名是 `node_modules` 目录中包含模块的目录名称。因此，我们在这里不能写成
    `require("module1.js")` 的形式，这会导致错误。
- en: 'We now visualize the execution of the `test.js` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可视化 `test.js` 文件的执行：
- en: '![Figure 6.3 – Module loaded with the package.json file'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 包含 package.json 文件的模块'
- en: '](img/Figure_6.02_B17416.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.02_B17416.jpg)'
- en: Figure 6.3 – Module loaded with the package.json file
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 包含 package.json 文件的模块
- en: The `"main"` key in the `package.json` file is optional if the main module file
    is named `index.js`. In all other cases, the `"main"` key must be indicated in
    `package.json`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主模块文件命名为 `index.js`，则 `package.json` 文件中的 `"main"` 键是可选的。在所有其他情况下，必须在 `package.json`
    中指示 `"main"` 键。
- en: We know how to run a module, but for now, the module contains a simple `console.log()`
    statement. Let’s see how to add features to the module and then use them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何运行一个模块，但到目前为止，模块包含一个简单的 `console.log()` 语句。让我们看看如何向模块添加功能，然后使用它们。
- en: Adding functionalities to the module
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向模块添加功能
- en: The newly created `module1.js` module is accessible but does not currently offer
    any functionality. Let’s see how to add some.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的 `module1.js` 模块是可访问的，但目前不提供任何功能。让我们看看如何添加一些功能。
- en: Exporting multiple functions in the module
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模块中导出多个函数
- en: 'For example, let’s create the function `add(a, b)`, which returns the sum of
    `a` and `b`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个名为 `add(a, b)` 的函数，它返回 `a` 和 `b` 的和：
- en: add(a, b) function defined in module1.js (module1.js file)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 module1.js 文件中定义的 add(a, b) 函数
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To export a function outside of a module (and make it accessible to users of
    the module), you can just embed it in the `module.exports` object defined by Node.js
    in each module. Each key defined in the `module.exports` object will be a function
    accessible outside the module.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要将函数导出至模块外部（并使其对模块用户可用），您只需将其嵌入到每个模块中由 Node.js 定义的 `module.exports` 对象中。`module.exports`
    对象中定义的每个键都将是一个模块外部的可访问函数。
- en: We can thus define several functions in the module that will be accessible thanks
    to the `module.exports` object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在模块中定义几个函数，这些函数将通过 `module.exports` 对象可访问。
- en: 'The usage of the `add(a, b)` function in the `test.js` file is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `test.js` 文件中使用 `add(a, b)` 函数的方式如下：
- en: Using add() function in test.js file (test.js file)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 test.js 文件中使用 add() 函数（test.js 文件）
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following display is obtained:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示结果如下：
- en: '![Figure 6.4 – The add() function added to the module'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – 添加到模块中的 add() 函数'
- en: '](img/Figure_6.04_B17416.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.04_B17416.jpg)'
- en: Figure 6.4 – The add() function added to the module
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 添加到模块中的 add() 函数
- en: Let’s add a second function in the module. For example, the function `mult(a,
    b)`, which returns `a*b`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在模块中添加第二个函数。例如，函数 `mult(a, b)`，它返回 `a*b`。
- en: 'If we add the `mult(a, b)` function in the module, it is written as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在模块中添加 `mult(a, b)` 函数，它将写成如下所示：
- en: Adding the mult(a, b) function to the module (module1.js file)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `mult(a, b)` 函数添加到模块（module1.js 文件）
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we will use the two functions `add()` and `mult()` in the `test.js` file.
    This verifies that a module can provide several functionalities to other modules
    that use it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `test.js` 文件中使用两个函数 `add()` 和 `mult()`。这验证了模块可以向使用它的其他模块提供多种功能：
- en: Using the module’s add() and mult() functions (test.js file)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块的 add() 和 mult() 函数（test.js 文件）
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following display is obtained:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示结果如下：
- en: '![Figure 6.5 – Using the two functions of the module'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5 – 使用模块的两个函数'
- en: '](img/Figure_6.05_B17416.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.05_B17416.jpg)'
- en: Figure 6.5 – Using the two functions of the module
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 使用模块的两个函数
- en: Now let’s see how to improve the module concept by using a so-called main function
    in the module.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何通过使用模块中的所谓主函数来改进模块概念。
- en: Allowing a function to be the main function of the module
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许一个函数成为模块的主函数
- en: Often, the module wishes to make a function its main function (the other functions
    defined in the module are secondary functions). This allows access to this main
    function in a simplified form.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模块希望将一个函数设为主函数（模块中定义的其他函数是次要函数）。这允许以简化的形式访问此主函数。
- en: Suppose (as before) that `module1` makes available the `add(a, b)`function and
    the `mult(a, b)`function. We want the `add()` function to be the main function
    of the module, which means that we can use it outside the module as `mod1(2, 3)`
    instead of `mod1.add(2, 3)`. The `mult(a, b)` function will remain accessible
    in the form `mod1.mult(2, 3)`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设（如前所述）`module1` 提供了 `add(a, b)` 函数和 `mult(a, b)` 函数。我们希望 `add()` 函数成为模块的主函数，这意味着我们可以将其作为
    `mod1(2, 3)` 而不是 `mod1.add(2, 3)` 在模块外部使用。`mult(a, b)` 函数将保持以 `mod1.mult(2, 3)`
    的形式可访问。
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that only one function can be defined as the main function in a module.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在模块中只能定义一个主函数。
- en: 'In this case, just specify it in the `module.exports` object like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只需在 `module.exports` 对象中指定即可：
- en: Making the add() function accessible as a main module function (module1.js file)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `add()` 函数作为主模块函数（module1.js 文件）可访问
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to assign the values in this order in the `module.exports` object
    (define the main function first, then the secondary functions). If you make the
    assignment in the other direction (`module.exports.mult` first, then `module.exports`),
    the assignment of `module.exports` last will erase the value already positioned
    in `module.exports.mult`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `module.exports` 对象中按此顺序分配值很重要（首先定义主函数，然后是次要函数）。如果您以其他方向进行分配（`module.exports.mult`
    首先分配，然后 `module.exports`），则最后分配的 `module.exports` 将会覆盖已定位在 `module.exports.mult`
    中的值。
- en: 'Also, we can no longer assign `module.exports` as an object, because that would
    remove the previously assigned value if we wrote `module.exports = { mult : mult
    }`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，我们不能再将 `module.exports` 作为对象分配，因为如果我们写成 `module.exports = { mult : mult
    }`，这将删除之前分配的值。'
- en: 'We now use the module as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用模块的方式如下：
- en: Using the module1.js module that has a main function (test.js file)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有主函数的 module1.js 模块（test.js 文件）
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following display is obtained:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示结果如下：
- en: '![Figure 6.6 – Using the module with the main function'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – 使用具有主函数的模块'
- en: '](img/Figure_6.06_B17416.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.06_B17416.jpg)'
- en: Figure 6.6 – Using the module with the main function
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 使用主函数的模块
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that instead of using the `mod1` variable as an object, we now use it
    as a function. In the call to `mod1(a, b)` causes the addition of a and b, so
    it is preferable that the variable be named `"add"` rather than `"mod1"` in the
    instruction `require(moduleName)`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再使用 `mod1` 变量作为对象，而是现在将其作为函数使用。在 `mod1(a, b)` 的调用中，a 和 b 进行相加，因此，在 `require(moduleName)`
    指令中，将变量命名为 `"add"` 而不是 `"mod1"` 更为合适。
- en: We saw how to create and use our own module. Now let’s take a look at how to
    use internal Node.js modules.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何创建和使用我们自己的模块。现在让我们看看如何使用内部 Node.js 模块。
- en: Using internal Node.js modules
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内部 Node.js 模块
- en: Node.js already has internal modules. They can also be used with the `require(moduleName)`
    instruction seen previously.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 已经有内部模块。它们也可以使用之前看到的 `require(moduleName)` 指令来使用。
- en: Let’s look at an example of an internal module. There is, for example, the `"fs"`
    module in the Node.js system. The name `"fs"` is short for file system. This module
    allows you to interact with the internal file system of Node.js.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个内部模块的例子。例如，Node.js 系统中的 `"fs"` 模块。`"fs"` 名称是文件系统的简称。此模块允许您与 Node.js 的内部文件系统进行交互。
- en: Now, we will use the `"fs"` module to read the contents of a file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `"fs"` 模块来读取文件的内容。
- en: Reading the contents of a file
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取文件内容
- en: 'Let’s use the `"fs"` module to read the file named `file1.txt` located in the
    current directory (where the `test.js` file is located). Here are the contents
    of this file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `"fs"` 模块来读取当前目录（`test.js` 文件所在的目录）中名为 `file1.txt` 的文件。以下是该文件的内容：
- en: file1.txt file (in the directory where test.js is located)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: file1.txt 文件（位于 test.js 文件所在的目录中）
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The program that uses the `"fs"` module and displays the contents of the file
    is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `"fs"` 模块并显示文件内容的程序如下：
- en: Reading and displaying the contents of the file (test.js file)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 读取并显示文件内容（test.js 文件）
- en: '[PRE64]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We use the `readFileSync()` method defined in the `"fs"` module. It returns
    the contents of the file in the corresponding variable, which is then displayed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `"fs"` 模块中定义的 `readFileSync()` 方法。它将文件内容返回到相应的变量中，然后将其显示。
- en: '![Figure 6.7 – Displaying file contents using the "fs" module'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – 使用 "fs" 模块显示文件内容'
- en: '](img/Figure_6.07_B17416.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.07_B17416.jpg)'
- en: Figure 6.7 – Displaying file contents using the “fs” module
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 使用 “fs” 模块显示文件内容
- en: The contents of the file are displayed but as hexadecimal characters. Next,
    let’s display the contents of the file as strings.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容以十六进制字符的形式显示。接下来，让我们将文件内容以字符串形式显示。
- en: Displaying file contents as strings
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将文件内容以字符串形式显示
- en: 'The contents of the file are displayed in the form of a buffer of bytes (see
    *Figure 6.7*). Node.js makes it easy to manipulate byte streams. It is also possible
    to view the contents of the file directly as strings by specifying the `{encoding:
    "utf-8"}` option in the second parameter (`options`) of the `readFileSync(name,
    options)` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '文件内容以字节缓冲区（参见 *图 6.7*）的形式显示。Node.js 使操作字节流变得容易。也可以通过在 `readFileSync(name, options)`
    方法的第二个参数（`options`）中指定 `{encoding: "utf-8"}` 选项，直接以字符串形式查看文件内容：'
- en: Displaying file contents as strings (test.js file)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件内容以字符串形式显示（test.js 文件）
- en: '[PRE68]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The result is now displayed as strings (see the following figure):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 结果现在以字符串形式显示（参见以下图）：
- en: '![Figure 6.8 – Displaying file contents as strings'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.8 – 以字符串形式显示文件内容'
- en: '](img/Figure_6.08_B17416.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.08_B17416.jpg)'
- en: Figure 6.8 – Displaying file contents as strings
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 以字符串形式显示文件内容
- en: The contents of the file are displayed. However, the program waits for the contents
    of the file to be retrieved in order to display them. By using the `readFile()`
    method instead of the `readFileSync()` method, it is possible to not block the
    program while waiting for the file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容被显示。然而，程序等待文件内容被检索以便显示。通过使用 `readFile()` 方法而不是 `readFileSync()` 方法，可以在等待文件时不会阻塞程序。
- en: Using non-blocking file reading
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非阻塞文件读取
- en: If you observe the previous `readFileSync()` method, you will see that the contents
    of the file are rendered in return for the method call. This means that the Node.js
    program is blocked while the file is being read (even if only for a few milliseconds).
    Within our small program, this is not noticeable, but in a case where the reading
    of the file is carried out by thousands of simultaneous users (for example, on
    a server), this will slow down access to the server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察之前的`readFileSync()`方法，你会看到文件内容作为方法调用的返回值被渲染。这意味着在文件读取过程中，Node.js程序会被阻塞（即使只是几毫秒）。在我们的小型程序中，这并不明显，但在文件读取由成千上万的并发用户执行的情况下（例如，在服务器上），这将减慢对服务器的访问速度。
- en: For this, Node.js has provided, for all blocking features such as this one,
    a non-blocking version of the method. Rather than returning the return result
    of the method (as before), we use a callback function indicated as a parameter
    of the method. In the case of reading the file, we will therefore use the `readFile(name,
    options, callback)` method, also defined in the `"fs"` module. The result of reading
    the file will be passed as a parameter in the callback function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此，Node.js为所有类似此的阻塞功能提供了一个非阻塞版本的方法。而不是返回方法的结果（如之前所述），我们使用一个作为方法参数的回调函数。在读取文件的情况下，因此我们将使用在`"fs"`模块中定义的`readFile(name,
    options, callback)`方法。读取文件的结果将通过回调函数作为参数传递。
- en: 'Let’s use the non-blocking form of reading the file, using the `readFile()`
    method instead of the `readFileSync()` method:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用非阻塞形式的文件读取，使用`readFile()`方法代替`readFileSync()`方法：
- en: Using readFile() method to read the file (test.js file)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readFile()`方法读取文件（test.js文件）
- en: '[PRE72]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The callback function uses the `error` and `data` parameters (in that order),
    which respectively correspond to a possible error message (`null` if none), and
    to the contents of the file if the latter has been read. The `options` parameter
    indicated as the second parameter of `readFile()` is similar to that of the `readFileSync(name,
    options)` method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数使用`error`和`data`参数（按此顺序），分别对应可能出现的错误消息（如果没有错误则为`null`），以及如果已读取，则为文件内容。`readFile()`方法的第二个参数`options`与`readFileSync(name,
    options)`方法的选项类似。
- en: 'The result is displayed here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在此显示：
- en: '![Figure 6.9 – Displaying file contents using the non-blocking readFile() method'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9 – 使用非阻塞的`readFile()`方法显示文件内容'
- en: '](img/Figure_6.09_B17416.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.09_B17416.jpg)'
- en: Figure 6.9 – Displaying file contents using the non-blocking readFile() method
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 使用非阻塞的`readFile()`方法显示文件内容
- en: We can check in the result displayed above that the `readFile()` method is really
    non-blocking. Indeed, the text indicated following the call to the `readFile()`
    method is displayed in the console even though the file has not yet been read
    and displayed, which would have been impossible using the blocking method `readFileSync()`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在上述显示的结果中检查到`readFile()`方法确实是非阻塞的。确实，在调用`readFile()`方法之后指示的文本即使在文件尚未被读取和显示的情况下也会在控制台显示，这是使用阻塞方法`readFileSync()`所不可能的。
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can therefore see that the use of modules internal to Node.js is done very
    simply by using the `require(moduleName)` instruction, and then by calling methods
    on the object returned by this instruction.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，在Node.js内部模块的使用非常简单，只需使用`require(moduleName)`指令，然后调用该指令返回的对象上的方法。
- en: We have seen how to create and use your own modules, and how to use internal
    Node.js modules.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建和使用自己的模块，以及如何使用Node.js的内部模块。
- en: Now let’s see how to use modules available on the internet using the `npm` command.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`npm`命令使用互联网上可用的模块。
- en: Using downloaded modules with npm
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用npm下载的模块
- en: In addition to the modules internal to Node.js, it is possible to import modules
    from the internet using the `npm` utility provided with Node.js.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Node.js内部的模块，还可以使用Node.js提供的`npm`实用工具从互联网导入模块。
- en: For this, the `npm` command is used (in a command interpreter) by indicating
    arguments that allow you to perform the corresponding actions on the imported
    modules.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了此，`npm`命令（在命令解释器中）通过指定允许你对导入的模块执行相应操作的参数来使用。
- en: Using the npm command
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用npm命令
- en: 'Here are some common uses of the `npm` command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`npm`命令的一些常见用法：
- en: '`npm install moduleName`: Installs the indicated module in the *local* `node_modules`
    directory. The module will only be accessible for the current application and
    not for other applications (unless it is installed again).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm install moduleName`：在本地 `node_modules` 目录中安装指定的模块。该模块将仅对当前应用程序可用，而对其他应用程序不可用（除非再次安装）。'
- en: '`npm install moduleName -g`: Installs the specified module in the *global*
    `node_modules` directory. The `-g` option allows you to indicate that this module
    can be accessed by other applications because it is installed in the `node_modules`
    directory of Node.js (globally).'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm install moduleName -g`：在全局 `node_modules` 目录中安装指定的模块。`-g` 选项允许你指定此模块可以被其他应用程序访问，因为它安装在
    Node.js 的 `node_modules` 目录中（全局）。'
- en: '`npm link moduleName`: It is possible that a module installed globally (with
    the `-g` option) is inaccessible (you get a module loading error during the `require(moduleName)`
    statement). In this case, it is necessary to run the `npm link moduleName` command.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `npm link moduleName`：可能的情况是，全局（使用 `-g` 选项）安装的模块不可访问（在 `require(moduleName)`
    语句期间出现模块加载错误）。在这种情况下，需要运行 `npm link moduleName` 命令。
- en: '`npm ll`: Lists modules already present in the *local* `node_modules` directory.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm ll`：列出已存在于本地 `node_modules` 目录中的模块。'
- en: '`npm ll -g`: Lists modules already present in the *global* `node_modules` directory.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm ll -g`：列出已存在于全局 `node_modules` 目录中的模块。'
- en: '`npm start`: Starts the Node.js application according to the command indicated
    in the `"scripts"` key, then the `"start"` key of the `package.json` file. For
    example, if you specify `"scripts": { "start": "node test.js" }` in the `package.json`
    file, you can type `npm start` instead of `node test.js` to run the `test.js`
    file. It is common to use `npm start` to start a Node.js application. This will
    be used to start an application under `uninstall` instead of `install`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm start`：根据 `"scripts"` 键中指定的命令启动 Node.js 应用程序，然后是 `package.json` 文件的 `"start"`
    键。例如，如果你在 `package.json` 文件中指定 `"scripts": { "start": "node test.js" }`，你可以输入
    `npm start` 而不是 `node test.js` 来运行 `test.js` 文件。通常使用 `npm start` 来启动 Node.js 应用程序。这将在
    `uninstall` 而不是 `install` 的情况下启动应用程序。'
- en: 'As an example, let’s create the following `package.json` file in the directory
    of the `test.js` file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子来说明，让我们在 `test.js` 文件所在的目录中创建以下 `package.json` 文件：
- en: package.json file (in the same directory as test.js)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: package.json 文件（位于与 test.js 相同的目录中）
- en: '[PRE78]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then use the `npm start` command to start the program:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `npm start` 命令来启动程序：
- en: '![Figure 6.10 – Starting the Node.js application with npm start'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10 – 使用 npm start 启动 Node.js 应用程序'
- en: '](img/Figure_6.10_B17416.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.10_B17416.jpg)'
- en: Figure 6.10 – Starting the Node.js application with npm start
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 使用 npm start 启动 Node.js 应用程序
- en: We can see that the `npm start` command thus makes it possible to execute the
    `test.js` program. The `npm start` command is often used to start a Node.js program,
    thanks to the mechanism explained above.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`npm start` 命令使得执行 `test.js` 程序成为可能。由于上述机制，`npm start` 命令通常用于启动 Node.js
    程序。这将在 `uninstall` 而不是 `install` 的情况下启动应用程序。
- en: Now let’s see how to use modules written by other developers by downloading
    them using `npm`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何通过使用 `npm` 下载来使用其他开发者编写的模块。
- en: Using a downloaded module with npm
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 npm 下载的模块
- en: Let’s look at an example of using `npm`. Here, we will use `npm` to install
    the module named `colors`. It allows you to display colored text in the console.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用 `npm` 的例子。在这里，我们将使用 `npm` 来安装名为 `colors` 的模块。它允许你在控制台中显示彩色文本。
- en: Installing the colors module in the node_modules local directory
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 node_modules 本地目录中安装 colors 模块
- en: We use the command `npm install colors`. The result of the installation of the
    `"colors"` module is displayed in the following figure.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `npm install colors` 命令。以下图显示了 `"colors"` 模块的安装结果。
- en: '![Figure 6.11 – Installing the colors module with npm'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.11 – 使用 npm 安装 colors 模块'
- en: '](img/Figure_6.11_B17416.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.11_B17416.jpg)'
- en: Figure 6.11 – Installing the colors module with npm
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 使用 npm 安装 colors 模块
- en: Once the module has been installed by `npm`, you can see that the `colors` directory
    of the module has inserted itself into the `node_modules` local directory of the
    application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块通过 `npm` 安装，你可以看到模块的 `colors` 目录已经将自己插入到应用程序的 `node_modules` 本地目录中。
- en: Using the features of the colors module
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 colors 模块的功能
- en: 'One of the ways to have an overview of the functionalities offered by a module
    is to display the content of the object returned by the `require(moduleName)`
    instruction:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 了解模块提供的功能的一种方法是通过显示 `require(moduleName)` 指令返回的对象的内容来获得概览：
- en: Displaying contents of colors object returned by require(“colors”) (test.js
    file)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 显示由 require("colors") 返回的 colors 对象的内容（test.js 文件）
- en: '[PRE83]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '![Figure 6.12 – Displaying contents of the colors module'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.12 – 显示 colors 模块的内容'
- en: '](img/Figure_6.12_B17416.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.12_B17416.jpg)'
- en: Figure 6.12 – Displaying contents of the colors module
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 显示 colors 模块的内容
- en: 'For example, let’s use the last method listed in the module, namely the `random()`
    method. It allows you to transform a character string into a string with random
    colors for each character:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用模块中列出的最后一种方法，即 `random()` 方法。它允许您将字符字符串转换为每个字符都有随机颜色的字符串：
- en: Using the random() method of the colors module (test.js file)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 colors 模块的 random() 方法（test.js 文件）
- en: '[PRE85]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `random()` method is used by prefixing its name with the name of the variable
    returned by `require("colors")`, that is, with the name of the module.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `random()` 方法，通过在变量名前加上 `require("colors")` 返回的变量名，即模块名，来使用它。
- en: 'The display of the following figure is obtained, in which each character displayed
    is a random color:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了每个显示的字符都是随机颜色的效果：
- en: '![Figure 6.13 – Using the colors module'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.13 – 使用 colors 模块'
- en: '](img/Figure_6.13_B17416.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.13_B17416.jpg)'
- en: Figure 6.13 – Using the colors module
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 使用 colors 模块
- en: 'We have seen here the three types of modules used with Node.js:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了与 Node.js 一起使用的三种模块类型：
- en: Modules written by ourselves, for our own needs
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们自己的需求编写的模块
- en: Existing internal modules in Node.js, such as the `fs` module allowing access
    to the internal file system of Node.js
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 中现有的内部模块，例如允许访问 Node.js 内部文件系统的 `fs` 模块
- en: Modules downloadable using the `npm` command, such as the colors module used
    above
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `npm` 命令下载的模块，例如上面使用的 colors 模块
- en: All that remains is to use these different types of modules in our programs.
    We will discuss that later on.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是将这些不同类型的模块用于我们的程序中。我们将在稍后讨论这一点。
- en: This brings us to the end of the chapter.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章的内容。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We have seen in this chapter how to create and use modules with Node.js, which
    are the essential components of programs created with Node.js.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Node.js 创建和使用模块，这些模块是使用 Node.js 创建的程序的基本组件。
- en: Whether the module is created by us, is an internal Node.js module, or is a
    module downloaded with `npm`, its use is the same in all cases. We use the `require(moduleName)`
    instruction and with the value returned in a variable, we access the functionality
    of the module.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 不论模块是由我们自己创建的，是 Node.js 的内部模块，还是通过 `npm` 下载的模块，其使用方式在所有情况下都是相同的。我们使用 `require(moduleName)`
    指令，并通过变量返回的值来访问模块的功能。
- en: Next, we are going to study the Express module, which is one of the main modules
    used with Node.js, allowing us to easily structure our applications according
    to the rules of the MVC model, currently widely used.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究 Express 模块，这是与 Node.js 一起使用的主要模块之一，它允许我们根据目前广泛使用的 MVC 模式规则轻松地构建我们的应用程序。
