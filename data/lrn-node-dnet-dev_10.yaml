- en: Chapter 10. Creating Real-time Web Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 创建实时Web应用
- en: The web has offered an ever more dynamic and interactive user experience. Throughout
    the 90s, most of the web consisted of static pages or server-side rendered pages.
    Frames and iframes made it possible to reload parts of the page in a limited way.
    When Ajax appeared in the mid-2000s, it allowed pages to be much more engaging.
    Client-side JavaScript could now request data from the server on demand and update
    the page dynamically.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网为用户提供了一种越来越动态和交互式的用户体验。在整个90年代，大部分互联网由静态页面或服务器端渲染的页面组成。框架和iframe使得以有限的方式重新加载页面成为可能。当Ajax在2005年中期出现时，它使得页面变得更加引人入胜。客户端JavaScript现在可以按需从服务器请求数据并动态更新页面。
- en: Real-time web applications are the next step in this evolution. These are applications
    where the server pushes data to clients without the clients needing to initiate
    a request. This allows a user to be notified of new information or for users to
    interact with each other in real time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 实时Web应用是这一演变的下一步。这些应用中，服务器无需客户端发起请求即可向客户端推送数据。这允许用户被通知新信息，或者用户可以实时相互交互。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Establishing a two-way communication channel between the client and server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端和服务器之间建立双向通信通道
- en: Adding real-time interactivity to our application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用添加实时交互性
- en: Introducing a backend to scale our real-time application across multiple servers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个服务器上扩展我们的实时应用的后端
- en: Understanding options for real-time communication
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解实时通信的选项
- en: Real-time web applications need a bidirectional communication channel between
    the client and the server. This is any persistent connection that allows the server
    to push additional data to the client when needed. The WebSockets protocol is
    the modern standard for this kind of communication and is implemented by most
    browsers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实时Web应用需要在客户端和服务器之间建立一个双向通信通道。这是任何持久连接，允许服务器在需要时向客户端推送额外的数据。WebSockets协议是这种通信的现代标准，并被大多数浏览器实现。
- en: WebSocket connections are initiated via HTTP, but otherwise do not depend on
    it. The WebSocket protocol defines a way of sending messages bi-directionally
    over a TCP connection. TCP is the low-level transport protocol that usually underlies
    HTTP. WebSockets are still a relatively new technology and not fully supported
    by all clients and servers. Most modern web browsers today do support WebSockets.
    However, intermediate servers (proxies, firewalls, and load-balancers) can prevent
    WebSocket connections from working (either through lack of support or intentionally
    blocking non-HTTP traffic). In these cases, there are alternative ways of achieving
    real-time communication.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket连接通过HTTP发起，但除此之外不依赖于它。WebSocket协议定义了一种在TCP连接上双向发送消息的方式。TCP是通常位于HTTP之下的低级传输协议。WebSockets仍然是一种相对较新的技术，并非所有客户端和服务器都完全支持。今天，大多数现代Web浏览器都支持WebSockets。然而，中间服务器（代理、防火墙和负载均衡器）可能会阻止WebSocket连接正常工作（要么是因为不支持，要么是有意阻止非HTTP流量）。在这些情况下，有其他方法可以实现实时通信。
- en: The EventSource standard defines a way for a server to send events to clients
    over HTTP and defines a JavaScript API for handling these events. It is not as
    efficient or widely-supported as WebSockets, but is better supported by some older
    servers and clients.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: EventSource标准定义了一种服务器通过HTTP向客户端发送事件的方式，并定义了一个JavaScript API来处理这些事件。它不如WebSockets高效或广泛支持，但一些较旧的服务器和客户端对其支持更好。
- en: The ultimate fallback is **long-polling**. This is when the client initiates
    an ordinary (Ajax) request to the server, which stays open until the server has
    some data to send. As soon as the client receives any data, it makes another request
    to the server for the next message. This introduces additional bandwidth overheads
    and latency compared to WebSockets, but has the widest support as it just uses
    ordinary HTTP requests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的回退方案是**长轮询**。这是当客户端向服务器发起一个普通（Ajax）请求时，该请求保持打开状态，直到服务器有数据要发送。一旦客户端收到任何数据，它就会向服务器发起另一个请求以获取下一条消息。这相比WebSockets引入了额外的带宽开销和延迟，但它具有最广泛的支持，因为它仅使用普通的HTTP请求。
- en: Ideally, a client and server can negotiate to work out the best available type
    of connection to use. This can be quite a complicated process, though. Fortunately,
    there are libraries which can handle this for us.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，客户端和服务器可以协商以确定使用最佳可用类型的连接。尽管这个过程可能相当复杂。幸运的是，有一些库可以为我们处理这些。
- en: Introducing Socket.IO
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Socket.IO
- en: Socket.IO is a mature and well-established library with excellent cross-browser
    support. It aims to quickly and reliably establish a bidirectional communication
    channel in a cross-browser compatible way. It provides a consistent abstraction,
    based on idiomatic JavaScript events, for real-time communication between the
    client and the server over this channel. If you have ever used SignalR in .NET,
    you can think of Socket.IO as the JavaScript equivalent.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO是一个成熟且稳定的库，具有出色的跨浏览器支持。它旨在以跨浏览器兼容的方式快速且可靠地建立双向通信通道。它提供了一个基于惯用JavaScript事件的抽象层，用于客户端和服务器之间通过此通道进行实时通信。如果你曾经使用过.NET中的SignalR，你可以将Socket.IO视为其JavaScript等价物。
- en: Implementing a chat room with Socket.IO
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Socket.IO实现聊天室
- en: 'Let''s implement a chat lobby for users of our application to talk to one another.
    First, we need to install Socket.IO:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的应用程序用户实现一个聊天大厅，以便他们可以互相交谈。首先，我们需要安装Socket.IO：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The server-side implementation for this is very simple. We just need to tell
    Socket.IO that, whenever a user sends a chat message, we want to broadcast this
    to all connected users as given here `src/realtime/chat.js`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的实现非常简单。我们只需要告诉Socket.IO，每当用户发送聊天消息时，我们希望将此消息广播给所有已连接的用户，如下所示`src/realtime/chat.js`：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we add a listener to Socket.IO's `connection` event. Our listener is fired
    whenever a new client connects to the application. The `socket` variable represents
    the connection to that specific client.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向Socket.IO的`connection`事件添加一个监听器。每当一个新的客户端连接到应用程序时，我们的监听器就会被触发。`socket`变量代表与该特定客户端的连接。
- en: 'The `io` parameter shown previously will be a Socket.IO instance. To create
    one of these, we need to provide a reference to the HTTP server that will host
    our application, so that Socket.IO can add its own connection handling. To keep
    things tidier, we''ll add a new `server` module in `src/server.js` to set up our
    server, start our Express application, and initialize Socket.IO:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的`io`参数将是一个Socket.IO实例。要创建一个这样的实例，我们需要提供一个引用HTTP服务器，该服务器将托管我们的应用程序，以便Socket.IO可以添加它自己的连接处理。为了使事情更整洁，我们将在`src/server.js`中添加一个新的`server`模块来设置我们的服务器，启动我们的Express应用程序，并初始化Socket.IO：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This also allows us to simplify the bootstrap script and our integration tests
    as in `bin/www`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这也允许我们简化启动脚本和我们的集成测试，如`bin/www`中的所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '... and in `gulpfile.js`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '...以及在`gulpfile.js`中：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we need to add the client-side code to communicate with this service. First,
    we''ll add a place for our chat lobby to the application home page as given here
    `src/views/index.hjs`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加客户端代码来与这个服务进行通信。首先，我们将为我们的聊天大厅添加一个位置到应用程序的主页，如下所示`src/views/index.hjs`：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we''ll create the client-side script to connect this with the server as
    given here `src/public/scripts/chat.js`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建客户端脚本以将其与服务器连接，如下所示`src/public/scripts/chat.js`：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we need to include our new script in the page and include the Socket.IO
    client-side script that defines the preceding `io` function `src/view/index.hjs`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在页面中包含我们的新脚本，并包含定义前面`io`函数的Socket.IO客户端脚本`src/view/index.hjs`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that we haven''t created the `socket.io.js` script anywhere. This is served
    as a result of attaching Socket.IO to our server in `src/server.js`. Since we
    don''t define the `io` variable in our own script, we need to let ESLint know
    that it exists as a global variable as given in `gulpfile.js`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还没有在任何地方创建`socket.io.js`脚本。这是通过在`src/server.js`中将Socket.IO附加到我们的服务器来提供的。由于我们没有在我们的脚本中定义`io`变量，我们需要让ESLint知道它作为一个全局变量存在，如`gulpfile.js`中所示：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, if we open up our application in two browser windows, they can send chat
    messages to each other!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开两个浏览器窗口中的我们的应用程序，它们可以互相发送聊天消息！
- en: Scaling real-time Node.js applications
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展实时Node.js应用程序
- en: Since our chat messages are being relayed via the server, clients can currently
    only communicate with other clients connected to the same server. This is a problem
    if we want to scale our application horizontally across many servers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的聊天消息是通过服务器中继的，因此客户端目前只能与连接到同一服务器的其他客户端通信。如果我们想将应用程序水平扩展到多个服务器，这将是一个问题。
- en: This is easy to fix, but tricky to demonstrate. To do so, we need to have two
    separate instances of our application running. This will be more realistic and
    more useful if they are also using the same shared databases for persistence.
    So we need to start up MongoDB and Redis, then start two instances of our application
    on different ports (so that they don't collide).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易修复，但很难演示。为了做到这一点，我们需要运行我们应用程序的两个独立实例。如果它们还使用相同的共享数据库进行持久化，这将更加真实和有用。因此，我们需要启动MongoDB和Redis，然后在不同的端口上启动我们应用程序的两个实例（这样它们就不会冲突）。
- en: 'This means running all of the following commands (replacing the dbpath of MongoDB
    as appropriate for your setup):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着运行以下所有命令（根据你的设置替换MongoDB的dbpath）：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The commands that start the database or application servers also occupy the
    current console. So, to be able to run all of these commands, we need to execute
    them in separate windows or tell them to execute in the background. On Windows,
    this can be achieved with the following batch script:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 启动数据库或应用程序服务器的命令也占据了当前的控制台。因此，为了能够运行所有这些命令，我们需要在单独的窗口中执行它们，或者告诉它们在后台执行。在Windows上，可以通过以下批处理脚本来实现：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now you can connect separate browsers to a separate application instance at
    `http://localhost:3000` and `http://localhost:3001`. Notice that two clients connected
    to the same application instance can receive messages from each other, but not
    from clients on the other application instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将不同的浏览器连接到不同的应用程序实例，地址为`http://localhost:3000`和`http://localhost:3001`。注意，连接到同一应用程序实例的两个客户端可以互相接收消息，但不能从其他应用程序实例的客户端接收消息。
- en: To resolve this, we need a shared backend through which all the applications
    can communicate. Redis is a perfect candidate for this.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要一个共享的后端，通过这个后端所有应用程序都可以进行通信。Redis是这一点的完美候选人。
- en: Using Redis as a backend
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Redis作为后端
- en: 'Socket.IO makes use of the **adapter** pattern to support different backends.
    An adapter is just a wrapper for converting one interface into another. Socket.IO
    has a standard backend interface and various adapters to allow different implementations
    to work with this interface. By default, it uses an in-memory adapter that is
    limited to a single process. However, the Socket.IO project also provides an adaptor
    for using Redis as a backend:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO使用**适配器**模式来支持不同的后端。适配器只是将一个接口转换为另一个接口的包装器。Socket.IO有一个标准的后端接口和多种适配器，允许不同的实现与该接口一起工作。默认情况下，它使用一个内存适配器，限制在单个进程中。然而，Socket.IO项目还提供了一个适配器，用于将Redis作为后端：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once installed, using this is simply a matter of telling Socket.IO where to
    find our Redis instance (we skip this in test environments where we only have
    one application process) as given here `src/server.js`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，使用这个中间件只需告诉Socket.IO在哪里可以找到我们的Redis实例（我们在只有一个应用程序进程的测试环境中跳过这一步）如下所示`src/server.js`：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And that's it! We don't require any other changes to our code to support scalability.
    If you restart your application instances now, you should find that clients can
    communicate between them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们不需要对我们的代码进行任何其他更改来支持可扩展性。如果你现在重新启动你的应用程序实例，你应该会发现客户端可以在它们之间进行通信。
- en: Integrating Socket.IO with Express
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Socket.IO与Express集成
- en: So far, apart from sharing the same server, the Socket.IO and Express parts
    of our application are completely independent. While it's good that they are loosely
    coupled, some cross-cutting concerns may be relevant to both.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，除了共享同一个服务器外，我们的应用程序的Socket.IO和Express部分是完全独立的。虽然它们松散耦合是好事，但一些横切关注点可能对两者都相关。
- en: For example, both parts of our application should have a mutually consistent
    way of identifying the current user. This is especially important if they are
    to come together to provide a single coherent user experience.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的应用程序的两个部分应该有一种相互一致的方式来识别当前用户。如果它们要共同提供单一连贯的用户体验，这一点尤为重要。
- en: 'First, let''s extend our user middleware to provide the current user''s name
    as well as their ID, by looking them up in the user service as given here `src/middleware/users.js`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们扩展我们的用户中间件，通过在用户服务中查找它们来提供当前用户的名称以及它们的ID，如下所示`src/middleware/users.js`：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can find updated tests for this middleware in the book's companion code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的配套代码中找到这个中间件的更新测试。
- en: 'This will mean injecting our user service as a dependency, like we do for the
    other middleware modules (that is, routes) in our application as given in `src/app.js`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着将我们的用户服务作为依赖项注入，就像我们在`src/app.js`中为其他中间件模块（即路由）所做的那样：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The interesting part is allowing Socket.IO to make use of this middleware.
    Socket.IO has its own concept of middleware very similar to that of Express. Recall
    that Express middleware functions take parameters for the current request, response,
    and a `next` callback. Socket.IO middleware functions just take a communication
    socket and a `next` callback. However, we can access the original HTTP handshake
    that initiated the socket. This allows us to adapt our Express middleware to Socket.IO
    middleware and use it as follows, in `src/server.js`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是允许 Socket.IO 使用这个中间件。Socket.IO 有自己的中间件概念，与 Express 非常相似。回想一下，Express 中间件函数接受当前请求、响应和一个
    `next` 回调的参数。Socket.IO 中间件函数只接受一个通信套接字和一个 `next` 回调。然而，我们可以访问启动套接字的原始 HTTP 握手。这允许我们将
    Express 中间件适配到 Socket.IO 中间件，并如下使用它，在 `src/server.js`：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the user middleware will run for Socket.IO as well as regular HTTP requests,
    making user data available to Socket.IO as well. Let''s use this to include usernames
    in our chat. First, we need to update our server as given in `src/realtime/chat.js`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户中间件将同时适用于 Socket.IO 和常规 HTTP 请求，使用户数据对 Socket.IO 也可用。让我们使用这个来在我们的聊天中包含用户名。首先，我们需要更新我们的服务器，如下所示
    `src/realtime/chat.js`：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that Socket.IO allows us to send objects instead of simple strings as
    the event payload. Now we just need to make use of this in the client as given
    here `src/public/scripts/chat.js`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Socket.IO 允许我们发送对象而不是简单的字符串作为事件负载。现在我们只需要在客户端使用它，如下所示 `src/public/scripts/chat.js`：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you now open the application in separate browser sessions and specify different
    usernames, you will see these in the chat output.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在单独的浏览器会话中打开应用程序并指定不同的用户名，你将看到这些用户名在聊天输出中。
- en: Directing Socket.IO messages
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指导 Socket.IO 消息
- en: 'Now that we have access to usernames, we can also announce the arrival of users
    in the lobby. We can do this by extending our Socket.IO connection event handler
    as given here `src/realtime/chat.js`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用户名访问权限，我们也可以宣布用户在大厅的到达。我们可以通过扩展我们的 Socket.IO 连接事件处理器来实现，如下所示 `src/realtime/chat.js`：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we use `socket.broadcast.emit`, rather than `io.emit`, to send the event
    to all clients except for the current socket. Note that we also add extra data
    to the message. This time we add a `type` field (set to `''action''` for the arrival
    message) to allow different visual presentation of different types of message.
    We can achieve this by updating our client-side code to set additional CSS classes
    based on the message type as given here `src/public/scripts/chat.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `socket.broadcast.emit` 而不是 `io.emit` 来将事件发送给除了当前 socket 之外的所有客户端。请注意，我们还在消息中添加了额外的数据。这次我们添加了一个
    `type` 字段（对于到达消息设置为 `'action'`），以便对不同类型的消息进行不同的视觉呈现。我们可以通过更新我们的客户端代码，根据消息类型设置额外的
    CSS 类来实现，如下所示 `src/public/scripts/chat.js`：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can find the CSS file for the example application in the companion code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在配套代码中找到示例应用的 CSS 文件。
- en: 'Let''s also enforce that users have to choose a username before they can take
    part in the chat as given here `src/realtime/chat.js`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还要强制要求用户在选择参与聊天之前必须选择一个用户名，如下所示 `src/realtime/chat.js`：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we use `socket.emit` rather than `io.emit` to send a message to the client
    associated with the current socket.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `socket.emit` 而不是 `io.emit` 来向与当前套接字关联的客户端发送消息。
- en: Testing Socket.IO applications
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Socket.IO 应用程序
- en: 'Now let''s look at how we can test our chat module. To talk to it from our
    tests we''ll need a Socket.IO client. The Socket.IO project provides another package
    for this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何测试我们的聊天模块。为了从我们的测试中与之通信，我们需要一个 Socket.IO 客户端。Socket.IO 项目为此提供了一个额外的包：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The infrastructure for our tests consists of setting up a server and multiple
    clients as given here `test/realtime/chat.js`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试基础设施包括设置一个服务器和多个客户端，如下所示 `test/realtime/chat.js`：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we create an HTTP server without specifying an address, so that the OS
    will assign us an available port. We then use this this server to host our chat
    implementation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个没有指定地址的 HTTP 服务器，这样操作系统就会为我们分配一个可用的端口。然后我们使用这个服务器来托管我们的聊天实现。
- en: 'Since we''re running the chat module in isolation, we don''t have our users
    middleware available, so will need an alternative way to provide usernames. We
    can do this with a stub middleware in our tests that reads usernames directly
    from a header:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们独立运行聊天模块，我们没有用户中间件可用，因此需要一种替代方式来提供用户名。我们可以在测试中使用一个存根中间件直接从头部读取用户名：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we are ready to implement our tests. The first two, for messages initiated
    from the server, are quite simple:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备实现我们的测试。前两个，对于从服务器发起的消息，相当简单：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Testing messages sent between clients requires a little more care to capture
    each client''s receipt of the message:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试客户端之间发送的消息需要更多注意来捕获每个客户端接收消息的情况：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Organizing Socket.IO applications
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织 Socket.IO 应用程序
- en: Now that we have a chat lobby on the index page of our application, it's a bit
    odd that users have to reload the page (and lose the chat history) to find out
    about new games. We can use Socket.IO to update these as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在应用程序的索引页上有一个聊天大厅，用户必须重新加载页面（并丢失聊天历史）才能了解新的游戏。我们可以使用 Socket.IO 来更新这些内容。
- en: Exposing real-time updates to the model
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公开模型的实时更新
- en: 'First, we''ll need our games service itself to expose events for when games
    are added or removed. Here we use the Mongoose-provided `post` method to hook
    into persistence operations on games as given here `src/services/games.js`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要我们的游戏服务本身来公开添加或删除游戏时的事件。在这里，我们使用 Mongoose 提供的 `post` 方法来挂钩游戏上的持久化操作，如这里所示
    `src/services/games.js`：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We expose an **event emitter** to allow other modules to subscribe to events
    for when games are added or removed. Event emitters are a built-in feature of
    Node.js, which provide a simple way to expose custom events. Note that the Mongoose
    `Schema` class is itself an event emitter, so we could just expose this directly.
    However, this would be leaking details about the implementation of our games service.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们公开一个 **事件发射器**，允许其他模块订阅添加或删除游戏时的事件。事件发射器是 Node.js 的内置功能，提供了一种简单的方式来公开自定义事件。请注意，Mongoose
    的 `Schema` 类本身就是一个事件发射器，所以我们可以直接公开它。然而，这将泄露有关我们游戏服务实现的细节。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Again, you can find new tests for these changes in the companion code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以在配套代码中找到这些更改的新测试。
- en: Organizing Socket.IO applications using namespaces
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名空间组织 Socket.IO 应用程序
- en: Real-time chat and real-time updates to the list of games are quite distinct
    functional areas of our application. Socket.IO provides **namespaces** to allow
    us to organise events. This allows us to still use a single connection between
    the client and the server, without having to worry about clashing event names
    between different functional areas. This is very useful as applications become
    larger and more complex.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实时聊天和实时更新游戏列表是我们应用程序中相当不同的功能区域。Socket.IO 提供了 **命名空间**，允许我们组织事件。这允许我们仍然使用客户端和服务器之间的单个连接，而无需担心不同功能区域之间的事件名称冲突。当应用程序变得更大、更复杂时，这非常有用。
- en: Putting our chat functionality under a namespace is a very simple change on
    the client and the server (and in our tests).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的聊天功能放在一个命名空间下，对客户端和服务器（以及我们的测试）来说是一个非常简单的更改。
- en: 'The following code is from `src/public/scripts/chat.js`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `src/public/scripts/chat.js`：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code is from `src/realtime/chat.js`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `src/realtime/chat.js`：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following code is from `test/realtime/chat.js`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `test/realtime/chat.js`：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we can add a new Socket.IO module for exposing changes to games. This simply
    needs to forward events from our games service to connected Socket.IO clients.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个新的 Socket.IO 模块来公开游戏的变化。这只需要将我们的游戏服务的事件转发给连接的 Socket.IO 客户端。
- en: 'We add the following code under `src/realtime/games.js`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `src/realtime/games.js` 下添加以下代码：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We also need to include this module in the initialisation of our server.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在服务器初始化时包含此模块。
- en: 'The following code is from `src/server.js`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `src/server.js`：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The corresponding client just needs to connect to the `/games` namespace and
    update the list accordingly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的客户端只需连接到 `/games` 命名空间并相应地更新列表。
- en: 'The following code is from `src/public/scripts/index.js`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `src/public/scripts/index.js`：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code is added to `src/views/index.hjs`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码添加到 `src/views/index.hjs` 中：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In practice, it would better to use a client-side MV* library such as Knockout
    or Backbone to update the page based on model changes, rather than manipulating
    the DOM like this, but that's outside the scope of this book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，最好使用客户端 MV* 库，如 Knockout 或 Backbone，根据模型更改更新页面，而不是像这样操作 DOM，但这超出了本书的范围。
- en: Now, if you open the application in two separate browser sessions and create
    a new game in one browser window, it will immediately appear in the other.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在两个不同的浏览器会话中打开应用程序并在一个浏览器窗口中创建一个新的游戏，它将立即出现在另一个窗口中。
- en: Partitioning Socket.IO clients using rooms
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用房间分区 Socket.IO 客户端
- en: The final piece of functionality we're going to add in this chapter is the ability
    for users playing the same game to talk to one another. We can re-use the chat
    functionality we've already written for this. However, we want a separate chat
    for the lobby on the homepage and for each game.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加的最后一个功能是允许玩相同游戏的用户之间进行交流。我们可以重用我们已编写的聊天功能。然而，我们希望主页上的大厅和每个游戏都有一个独立的聊天。
- en: Socket.IO provides **rooms** for directing messages to different groups of clients.
    Remember that namespaces allow us to divide our application into different functional
    areas. Rooms allow us to divide up clients within the same functional area.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 提供了**房间**功能，用于将消息定向发送到不同的客户端组。请记住，命名空间允许我们将应用程序划分为不同的功能区域。房间功能使我们能够在同一功能区域内对客户端进行划分。
- en: 'Rooms in Socket.IO are just string identifiers and we add clients to a room
    using the `socket.join` function. We''ll introduce a new `joinRoom` event to allow
    our clients to ask our server to add them to a particular room. We''ll respond
    to this event on the server as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO 中的房间只是字符串标识符，我们使用 `socket.join` 函数将客户端添加到房间中。我们将引入一个新的 `joinRoom`
    事件，允许我们的客户端请求服务器将其添加到特定的房间。服务器端将按以下方式响应此事件：
- en: 'The following code is from `src/realtime/chat.js`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `src/realtime/chat.js`：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we also announce when users leave a particular room, in the same way
    that we announce arrivals. Again, you can find the additional test for this functionality
    in the example code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也会像宣布到达一样宣布用户离开特定房间。同样，您可以在示例代码中找到此功能的附加测试。
- en: We'll add the chat functionality into the game page and specify the correct
    room using a data attribute on the chat form.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把聊天功能添加到游戏页面，并使用聊天表单上的数据属性指定正确的房间。
- en: 'The following code is from `src/views/game.hjs`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `src/views/game.hjs`：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following code is from `src/views/index.hjs`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `src/views/index.hjs`：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then we need to update the client script to join the correct room when connecting.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新客户端脚本，以便在连接时加入正确的房间。
- en: 'The following code is from `src/public/scripts/chat.js`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `src/public/scripts/chat.js`：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, we need to make sure that typing a chat message doesn't interfere with
    playing the game. We can do this by only treating keypresses as guesses for the
    game when the user isn't typing in the chat message box.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保输入聊天消息不会干扰游戏。我们可以通过仅在用户不在聊天消息框中输入时将按键视为游戏的猜测来实现这一点。
- en: 'The following code is from `src/public/javascript/game.js`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `src/public/javascript/game.js`：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can find new and updated tests for this functionality in the companion code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在配套代码中找到此功能的新的和更新的测试。
- en: 'Putting this all together, we can now have multiple clients talking to one
    another in separate rooms:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些整合起来，我们现在可以在不同的房间中让多个客户端相互交谈：
- en: '![Partitioning Socket.IO clients using rooms](img/image00221.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![使用房间分区 Socket.IO 客户端](img/image00221.jpeg)'
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have created a real-time client/server communication channel
    using Socket.IO, used Redis as a backend to scale a real-time application horizontally,
    integrated Socket.IO with Express middleware, and organized our application using
    Socket.IO namespaces and rooms.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Socket.IO 创建了一个实时客户端/服务器通信通道，使用 Redis 作为后端以横向扩展实时应用程序，将 Socket.IO
    与 Express 中间件集成，并使用 Socket.IO 命名空间和房间组织我们的应用程序。
- en: As the network connectivity of our application is becoming more complicated,
    it's more important to test the application on a web server outside of the development
    or CI environment. In the next chapter, we'll look at how to deploy our application
    to the web.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们应用程序的网络连接变得越来越复杂，在开发或 CI 环境之外在 Web 服务器上测试应用程序变得更加重要。在下一章中，我们将探讨如何将我们的应用程序部署到
    Web 上。
