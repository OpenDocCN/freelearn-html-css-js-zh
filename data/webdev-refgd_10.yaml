- en: Chapter 10. JavaScript Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。JavaScript面向对象编程
- en: JavaScript is an object-oriented programming language. In **object-oriented
    programming** (**OOP**) languages, we use the concept of objects rather than actions
    to develop applications. In the past, JavaScript had no real foundation and was
    just a basic language. JavaScript is not a fully OOP-based language like JAVA,
    C#, and other programming languages, but it still has many OOP features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种面向对象的编程语言。在**面向对象编程**（**OOP**）语言中，我们使用对象的概念而不是动作来开发应用程序。在过去，JavaScript没有真正的基础，仅仅是一种基本语言。JavaScript不是像JAVA、C#和其他编程语言那样完全基于OOP的语言，但它仍然具有许多OOP特性。
- en: There are many features in JavaScript where code is reused. So, rather than
    using procedural concepts in JavaScript, we use object-oriented programming techniques.
    There are four basic principles of object-oriented programming.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有许多代码重用的特性。因此，而不是在JavaScript中使用过程式概念，我们使用面向对象编程技术。面向对象编程有四个基本原则。
- en: Polymorphism
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: Since JavaScript is a dynamic language, it supports **polymorphism**. Polymorphism
    can be understood as the ability of an object to be different at different times.
    For example, a shape can be a square, a rectangle, or a circle.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript是一种动态语言，它支持**多态性**。多态性可以理解为对象在不同时间可以表现出不同的能力。例如，一个形状可以是正方形、长方形或圆形。
- en: Encapsulation
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: This feature is also supported in JavaScript. It means protecting parts of code
    from external use. It protects part of the code that does not concern the end
    user but is important for running an application, such as in an application that
    stores passwords. Users don't have to know how their passwords are encrypted.
    Hence, this code is encapsulated.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在JavaScript中也得到了支持。这意味着保护代码的一部分不被外部使用。它保护了与最终用户无关但运行应用程序很重要的代码部分，例如在存储密码的应用程序中。用户不需要知道他们的密码是如何加密的。因此，这段代码被封装起来。
- en: Inheritance
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: In JavaScript, inheritance can be used to derive properties of parent objects
    to their child objects and have some unique attributes for themselves as well.
    For example, a square and a triangle may inherit their stroke or fill from a `shape`
    object and, at the same time, have a number of vertices unique to themselves.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，继承可以用来从父对象推导出属性到子对象，并且它们自己也有一些独特的属性。例如，一个正方形和一个三角形可能从`shape`对象继承它们的边框或填充，同时拥有自己独特的顶点数。
- en: Abstraction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: Abstraction is not natively supported in JavaScript, but there are methods through
    which this can be achieved, using a combination of polymorphism and inheritance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象在JavaScript中不是原生支持的，但有一些方法可以通过组合多态性和继承来实现这一点。
- en: Objects
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: Objects are the basic key to understand object-oriented programming. Programming
    objects are just like real-world objects. Look around, you'll see many objects.
    Your car, mobile phone, desk, laptop, pet dog, and DVD player are all objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是理解面向对象编程的基本关键。编程对象就像现实世界中的对象一样。看看周围，你会看到很多对象。你的汽车、手机、桌子、笔记本电脑、宠物狗和DVD播放器都是对象。
- en: 'All objects have two characteristics: properties and methods.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象都有两个特性：属性和方法。
- en: A mobile has properties (color, screen size, height, and weight) and methods
    (make calls, send SMSs, receive calls, and transfer files).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一部手机有属性（颜色、屏幕尺寸、高度和重量）和方法（打电话、发送短信、接收电话和传输文件）。
- en: A car has properties (color, height, gearbox, wheels, engine, brakes, and steering)
    and methods (start engine, steer, change gear, apply brake, stop, and crash).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一辆车有属性（颜色、高度、变速箱、车轮、引擎、刹车和方向盘）和方法（启动引擎、转向、换挡、刹车、停止和碰撞）。
- en: Just like these real-world examples, the objects in OOP have the same characteristics.
    So, an object, in terms of programming, can have properties (variables in any
    programming language) and methods (functions in any programming language).Hence,
    we can define an object as "*an entity or a thing that has some properties and
    methods associated with it. An object can be individually selected and manipulated*".
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这些现实世界的例子一样，OOP中的对象具有相同的特性。因此，从编程的角度来看，一个对象可以具有属性（任何编程语言中的变量）和方法（任何编程语言中的函数）。因此，我们可以将对象定义为“*一个具有一些属性和与之关联的方法的实体或事物。对象可以被单独选择和处理*”。
- en: All generic properties and methods are combined into a template called a **class**.
    A class is then used as a template to instantiate single or multiple objects.
    In JavaScript, there are many built-in objects, such as Maths, Dates, Regular
    Expressions, Arrays, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通用属性和方法都被组合到一个称为**类**的模板中。然后，这个类被用作模板来实例化单个或多个对象。在JavaScript中，有许多内置对象，例如Maths、Dates、正则表达式、数组等等。
- en: Creating objects
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'In JavaScript, we can create objects in three different ways:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们可以以三种不同的方式创建对象：
- en: Using object literals
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象字面量
- en: Using new keywords
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`new`关键字
- en: Using the `object.create()` method (ECMAScript 5)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`object.create()`方法（ECMAScript 5）
- en: Object literals
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象字面量
- en: This is the simplest way to create an object. An object can be both created
    and defined in one statement using an object literal. An object literal is a comma-separated
    list of `name:value` (like year:1990, age:25) pairs enclosed within curly brackets.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建对象的最简单方式。可以使用对象字面量在一个语句中创建和定义一个对象。对象字面量是一个逗号分隔的`name:value`（如year:1990,
    age:25）对列表，这些对被大括号包围。
- en: 'Here is an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we have created a `car` object with four properties
    or attributes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个具有四个属性或属性的`car`对象。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On the other hand, this piece of code creates an object with no properties.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这段代码创建了一个没有任何属性的空对象。
- en: The new keyword
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`new`关键字'
- en: The `new` keyword is used to create and initialize a new object. The `new` keyword
    is always followed by a function call. This function is known as a constructor,
    which initializes the newly created object. JavaScript contains built-in constructors
    for the native types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`关键字用于创建和初始化一个新对象。`new`关键字总是跟在一个函数调用之后。这个函数被称为构造函数，它初始化新创建的对象。JavaScript包含用于原生类型的内置构造函数。'
- en: 'Here is an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding example also creates a new `car` object with four properties:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子也创建了一个具有四个属性的新的`car`对象：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The object.create() method
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`object.create()`方法'
- en: The `object.create()` method was originally defined in ECMAScript 5\. It is
    also used to create an object. The first argument passed to this method is the
    prototype of that object. The second argument is optional. It describes the object's
    properties.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`object.create()`方法最初是在ECMAScript 5中定义的。它也被用来创建对象。传递给这个方法的第一个参数是那个对象的原型。第二个参数是可选的。它描述了对象的属性。'
- en: 'Here is an example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Null` can be passed if the object does not have any prototype. However, this
    object will not inherit anything:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象没有原型，可以传递`Null`。然而，这个对象将不会继承任何内容：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Design patterns
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式
- en: To write scalable code, we need to track down the recurring sections in our
    code and to optimize them in a way that it's easy to maintain the code. Design
    patterns help us in doing this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写可扩展的代码，我们需要追踪代码中的重复部分，并以一种易于维护的方式优化它们。设计模式帮助我们做到这一点。
- en: 'In a book, *Addison-Wesley Professional* by *Erich Gamma*, *John Vlissides*,
    *Ralph Johnson*, and *Richard Helm*; First edition (November 10, 1994), Design
    Patterns are defined as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在由艾瑞克·伽玛（Erich Gamma）、约翰·弗利斯（John Vlissides）、拉尔夫·约翰逊（Ralph Johnson）和理查德·赫尔姆（Richard
    Helm）所著的《Addison-Wesley Professional》一书中；第一版（1994年11月10日），设计模式被定义为：
- en: '*A design pattern names, abstracts, and identifies the key aspects of a common
    design structure that make it useful for creating a reusable object-oriented design.
    The design pattern identifies the participating classes and their instances, their
    roles and collaborations, and the distribution of responsibilities.*'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*设计模式命名、抽象和识别一个常见设计结构的关键方面，使其对创建可重用的面向对象设计有用。设计模式识别参与类及其实例、它们的作用和协作，以及责任分配。*'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Each design pattern focuses on a particular object-oriented design problem
    or issue. It describes when it applies, whether or not it can be applied in view
    of other design constraints, and the consequences and trade-offs of its use. Since
    we must eventually implement our designs, a design pattern also provides sample
    code to illustrate an implementation.*'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*每个设计模式都专注于特定的面向对象设计问题或问题。它描述了何时适用，是否可以在其他设计约束的背景下应用，以及其使用的后果和权衡。由于我们必须最终实现我们的设计，设计模式还提供了示例代码来展示实现。*'
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Although design patterns describe object-oriented designs, they are based
    on practical solutions that have been implemented in mainstream object-oriented
    programming languages.*'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然设计模式描述的是面向对象的设计，但它们基于已经在主流面向对象编程语言中实现过的实用解决方案。
- en: Developers usually question whether there is any best design pattern to implement
    in their workflow.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常会质疑是否有一个最佳的设计模式可以实施到他们的工作流程中。
- en: Actually, no single design pattern is perfect for all scenarios. Each and every
    web application that is developed has its own needs. We have to see which pattern
    will add value to our application if implemented, because all design patterns
    serve different solutions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，没有单一的设计模式适合所有场景。每个开发出的 Web 应用程序都有其自身的需求。我们必须看看如果实施，哪种模式将给我们的应用程序增加价值，因为所有设计模式都服务于不同的解决方案。
- en: 'So, once we have a good understanding of design patterns, it will be easier
    for us to integrate a pattern into our application architecture. Design patterns
    are classified into three categories: creational, structural, and behavioral.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们对设计模式有了良好的理解，将模式集成到我们的应用程序架构中就会更容易。设计模式被分为三类：创建型、结构型和行为型。
- en: '**Creational design patterns**: Constructor, factory, prototype, and singleton
    are examples of creational design patterns'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型设计模式**：构造函数、工厂、原型和单例是创建型设计模式的例子'
- en: '**Structural design patterns**: Decorator, façade, and flyweight are example
    of structural design patterns'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型设计模式**：装饰者、外观和享元是结构型设计模式的例子'
- en: '**Behavioral** **design patterns**: Observer and mediator are examples of such
    patterns'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为型设计模式**：观察者和调解者是此类模式的例子'
- en: Constructor pattern
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数模式
- en: Constructors are special methods used to initialize objects. They may accept
    arguments, which are then used to set values to member properties and methods
    when the object is created. Native constructors, such as arrays and objects, are
    present inside JavaScript as native functions. We can also create custom constructors
    that define properties and methods for our custom object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是用于初始化对象的特殊方法。它们可以接受参数，这些参数随后用于在对象创建时设置成员属性和方法。原生构造函数，如数组和对象，在 JavaScript
    中作为原生函数存在。我们还可以创建自定义构造函数，为我们的自定义对象定义属性和方法。
- en: Description
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'In the `constructor` method, we create an object using the `new` keyword. In
    this method, we define properties and methods with the `this` keyword. Properties
    are defined after the `=` sign. When you define each property, you must place
    a semicolon at the end. When you use the `this` method in your script, you need
    to first initialize the object and then use it in your code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `constructor` 方法中，我们使用 `new` 关键字创建一个对象。在这个方法中，我们使用 `this` 关键字定义属性和方法。属性在 `=`
    符号之后定义。当你定义每个属性时，必须在末尾放置一个分号。当你需要在你的脚本中使用 `this` 方法时，你需要首先初始化对象，然后在使用代码中使用它：
- en: Simple constructors
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单构造函数
- en: A constructor is considered to be the most suitable way to implement an instance.
    The `new` keyword tells JavaScript that we would like that function to act like
    a constructor and to create an instance also called `object`. Within a constructor,
    the `this` keyword is used to reference the new object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数被认为是实现实例的最合适方式。`new` 关键字告诉 JavaScript 我们希望该函数表现得像构造函数，并创建一个实例，也称为 `object`。在构造函数内部，`this`
    关键字用于引用新对象。
- en: Prototype constructors
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原型构造函数
- en: Prototype is a property of functions in JavaScript. Whenever a `constructor`
    function is invoked to create a new object, all of the characteristics of that
    constructor's prototype are then associated to the new object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是 JavaScript 中函数的一个属性。每当一个 `constructor` 函数被调用以创建一个新对象时，该构造函数的原型中所有的特性都会与新对象关联。
- en: Module pattern
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模块模式
- en: Modules are an essential part of any well-constructed web application. They
    are independent blocks linked with each other in a neat, understandable and well-organized
    way. In other words, they give the program a structure and also provide encapsulation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是任何良好构建的 Web 应用程序的基本组成部分。它们以整洁、可理解和组织良好的方式相互独立地链接。换句话说，它们为程序提供了结构，同时也提供了封装。
- en: Description
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'Modules can be implemented in several ways in JavaScript. We will be discussing
    two of them here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，模块可以通过几种方式实现。我们在这里将讨论其中的两种：
- en: Object literal notation
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象字面量表示法
- en: The module pattern
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块模式
- en: Object literal notation
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对象字面量表示法
- en: 'As we have read earlier, object literals are a list of `name:value` pairs separated
    by commas enclosed inside curly braces `{}`. Names can be identifiers or strings
    followed by a colon. Make sure there is no comma after the last `name:value` pair;
    otherwise, it may result in some unexpected errors:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所读，对象字面量是一系列用逗号分隔的`name:value`对，这些对被括号`{}`包围。名称可以是标识符或字符串后跟冒号。确保在最后一个`name:value`对之后没有逗号；否则，可能会导致一些意外的错误：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We do not have to instantiate object literals with the `new` keyword.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必使用`new`关键字实例化对象字面量。
- en: Care should be taken to see that the keyword `new` is not used at the start
    of the statement. This is because the opening curly bracket could be interpreted
    as the start of a code block.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意确保在语句开头不使用关键字`new`。这是因为开括号可能被解释为代码块的开始。
- en: 'We can add new members from the outside object as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从外部对象添加新成员，如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using modules can help in hiding data members (encapsulation) and managing code
    in an organized way.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块可以帮助隐藏数据成员（封装）并以有组织的方式管理代码。
- en: The module pattern
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模块模式
- en: In conventional software engineering, the module pattern provides public and
    private access to classes, methods, and variables. The focus of the module pattern
    is to reduce the use of global variables, minimizing the conflicts inside the
    code throughout the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的软件工程中，模块模式提供了对类、方法和变量的公共和私有访问。模块模式的重点是减少全局变量的使用，以最小化整个应用程序内部代码中的冲突。
- en: This is the most famous and commonly used design pattern that is implemented
    in large JavaScript frameworks and extension libraries such as **jQuery**, **ExtJS**,
    **YUI**, and **DoJo**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现在大型的JavaScript框架和扩展库（如**jQuery**、**ExtJS**、**YUI**和**DoJo**）中最著名且最常用的设计模式。
- en: Here is an example of the module pattern that makes use of a shared private
    cache. This method enables us to create objects using shared storage that will,
    in return, optimize performance because the functions are only created one time
    in the start. The mixin uses the function reference to call them rather than creating
    a new instance of that function every time it needs them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用共享私有缓存的模块模式示例。这种方法使我们能够使用共享存储来创建对象，从而优化性能，因为函数只会在启动时创建一次。混入使用函数引用来调用它们，而不是每次需要时都创建该函数的新实例。
- en: 'Here are a few advantages and disadvantages of the module pattern:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是模块模式的一些优缺点：
- en: '**Advantages**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: This pattern has a cleaner approach for developers
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式为开发者提供了一种更清晰的方法
- en: It supports encapsulation
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持封装
- en: There is less global namespace cluttering
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少了全局命名空间混乱
- en: This supports localized functions and variables with closures
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这支持具有闭包的本地函数和变量
- en: '**Disadvantages**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: As the public and private members are accessed in a different manner, when there
    is a need to change visibility of a specific member we would have to change it
    everywhere the object was being used
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于公共和私有成员的访问方式不同，当需要更改特定成员的可见性时，我们不得不在对象被使用的每个地方都进行更改
- en: Private members cannot be accessed from new methods that are added to objects
    afterwards
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后添加到对象中的新方法无法访问私有成员
- en: Private members cannot be extended easily
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有成员不能轻松扩展
- en: The revealing module pattern
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 揭示模块模式
- en: This pattern is almost identical to the module pattern. The only difference
    is that, in this pattern, all members are kept private until they are explicitly
    called, usually by an object literal returned by the closure from which it is
    defined.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式几乎与模块模式相同。唯一的区别是，在这个模式中，所有成员都保持私有，直到它们被显式调用，通常是通过返回对象字面量的闭包来定义的。
- en: Description
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'Christian Heilmann engineered this pattern. He disliked the fact that we had
    to switch to object literal notation for the objects that we want to keep public.
    There was another drawback: we had to repeat the name of main object if we had
    to access public variables from one method into an other or call public methods.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 克里斯蒂安·海利曼设计了这种模式。他不喜欢我们不得不切换到对象字面量表示法来表示我们希望保持公开的对象。还有一个缺点：如果我们需要从一个方法访问另一个方法中的公共变量或调用公共方法，我们必须重复主对象的名字。
- en: In this pattern, we define all functions and variables as private and, at the
    end of module, return an anonymous object along with the pointers to the private
    functions and variables we would like to expose as public.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，我们将所有函数和变量定义为私有，并在模块末尾返回一个匿名对象，以及指向我们希望公开的私有函数和变量的指针。
- en: 'Here are a few advantages and disadvantages of the revealing module pattern:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是揭示模块模式的几个优缺点：
- en: '**Advantages**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Cleaner approach for developers
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对开发者来说是一种更干净的方法
- en: Supports encapsulation
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持封装
- en: Less global namespace cluttering
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少全局命名空间混乱
- en: Localized functions and variables with closures
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带闭包的局部函数和变量
- en: More consist script syntax
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更一致的脚本语法
- en: Explicit definition of public functions and variables
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式定义公共函数和变量
- en: Increased readability
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高可读性
- en: '**Disadvantages**:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Private members are inaccessible
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有成员不可访问
- en: It's difficult to patch public functions and variables that are referred to
    by some private members
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改被某些私有成员引用的公共函数和变量很困难
- en: The singleton pattern
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例模式
- en: This pattern ensures that only one instance of a class is created and provides
    a global access point to the object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式确保只创建一个类的实例，并提供一个全局访问点到该对象。
- en: Description
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The singleton pattern is implemented by creating a class with a method whose
    object can only be created if it doesn't exist already. If the object already
    existed, the reference will be returned to that object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式通过创建一个方法的对象来实现，该方法的对象只能在它不存在时创建。如果对象已经存在，将返回对该对象的引用。
- en: It is recommended to delay the initialization of singletons in cases where they
    require some information that might not be available at the time of initialization.
    Hence, they are different from static classes or objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要一些可能不在初始化时可用信息的情况下，建议延迟单例的初始化。因此，它们与静态类或对象不同。
- en: 'Here are a few advantages and disadvantages of the singleton pattern:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是单例模式的几个优缺点：
- en: '**Advantages**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Optimized memory usage
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化内存使用
- en: Single global point of access
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一的全局访问点
- en: Delayed initialization, which prevents instantiation until it is required
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟初始化，直到需要时才实例化
- en: '**Disadvantages**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: There is no reset option once it is instantiated.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦实例化，就没有重置选项。
- en: Unit testing is difficult because when we reference a singleton class that exists
    outside of the class under test, then we do not have a true unit test. Instead
    of what should have been a single unit test of the target class, we end up testing
    the target class and the singleton together.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试困难，因为当我们引用一个存在于测试类之外的单一类时，我们就无法进行真正的单元测试。我们最终测试的是目标类和单例一起，而不是应该是一个单一的目标类单元测试。
- en: It may introduce hidden dependencies.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会引入隐藏的依赖。
- en: The observer pattern
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The observer pattern is such that if one object changes state all others are
    notified and can update automatically. Thus this pattern defines a one-to-many
    dependency relationship between objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是这样的，如果一个对象的状态发生变化，所有其他对象都会收到通知并可以自动更新。因此，这个模式定义了对象之间的一对多依赖关系。
- en: Description
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: In the observer pattern, an object (also called a subject/publisher) is connected
    to multiple other objects that are dependent on our subject. These depending objects
    are called **observers**/**subscribers**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者模式中，一个对象（也称为主题/发布者）连接到多个其他对象，这些对象依赖于我们的主题。这些依赖对象被称为**观察者**/**订阅者**。
- en: The subject broadcasts a notification whenever a change in state occurs. All
    observers receive the notification and update them accordingly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态发生变化时，主题会广播一个通知。所有观察者都会收到通知并相应地更新。
- en: 'The book, *Design Patterns: Elements of Reusable Object-Oriented Software*,
    describes the observer pattern as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍《设计模式：可复用面向对象软件元素》将观察者模式描述如下：
- en: '*"One or more observers are interested in the state of a subject and register
    their interest with the subject by attaching themselves. When something changes
    in our subject that the observer may be interested in, a notify message is sent
    which calls the update method in each observer. When the observer is no longer
    interested in the subject''s state, they can simply detach themselves."*'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"一个或多个观察者对主题的状态感兴趣，并通过将自己附加到主题上来注册他们的兴趣。当我们的主题发生变化，观察者可能感兴趣时，会发送一个通知消息，该消息调用每个观察者的更新方法。当观察者不再对主题的状态感兴趣时，他们可以简单地断开连接。"*'
- en: 'Here are a few advantages and disadvantages of the observer pattern:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些观察者模式的优点和缺点：
- en: '**Advantages**:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: Requires a deeper understanding of various components in the system and their
    relationship with each other
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更深入地了解系统中的各种组件及其相互关系
- en: Helps in pointing out dependencies
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于指出依赖关系
- en: Helps in disintegrating objects into smaller reusable components
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于将对象分解成更小的可重用组件
- en: '**Disadvantages**:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: Application integrity check can become difficult
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序完整性检查可能变得困难
- en: Switching an observer from one subject to another can be tough
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将观察者从一个主题切换到另一个主题可能很困难
- en: The mediator pattern
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中介者模式
- en: As the name suggests, a mediator is a person who assists in negotiations between
    two or more conflicting parties.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，中介者是一个在两个或更多冲突方之间协助谈判的人。
- en: In terms of software engineering, mediator comes under the behavioral design
    pattern category. The pattern enables us to implement a single object through
    which different components of an application communicate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，中介者属于行为设计模式类别。该模式使我们能够通过一个对象实现应用程序不同组件之间的通信。
- en: Description
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The mediator pattern promotes loose coupling by ensuring that, instead of objects
    interacting with each other directly, they communicate across a central point.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式通过确保对象不是直接相互交互，而是通过一个中心点进行通信，从而通过确保松散耦合来促进。
- en: Let's take a real-world example to understand it in a better way. Consider an
    airport traffic-control system. The control tower acts as a mediator, while all
    other planes are communicating with the control tower and waiting for the notifications
    to land or to take off. They do not contact each other but just with the control
    tower. The role of the control tower is very essential and central. Hence, it
    an important key for this system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个现实世界的例子来更好地理解它。考虑一个机场交通控制系统。控制塔充当中介者，而所有其他飞机都在与控制塔通信，等待着陆或起飞的通知。它们不相互联系，只与控制塔联系。控制塔的作用非常关键和核心。因此，它是这个系统的重要关键。
- en: Similarly, the mediator is as important in this pattern.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，中介者在这个模式中同样重要。
- en: When we call mediator's subscribe method, we pass in a callback, and the mediator
    queues up these callbacks for when the given event is fired and subsequently the
    decoupled object's callback is fired. Mediator triggers the signal for the object
    to fire, allowing the object to be decoupled from any others.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用中介者的订阅方法时，我们传递一个回调，中介者将这些回调排队，以便在给定事件触发时以及随后解耦对象的回调被触发。中介者触发信号以使对象能够触发，从而允许对象与任何其他对象解耦。
- en: 'Here are a few advantages and disadvantages of the mediator pattern:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些中介者模式的优点和缺点：
- en: '**Advantages**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: Removes many-to-many relationships
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除多对多关系
- en: Establishes many-to-one relationship
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立多对一关系
- en: Help us to figure out dependencies
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助我们找出依赖关系
- en: Helps in disintegrating objects to promote smaller reusable components
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于将对象分解以促进更小的可重用组件
- en: '**Disadvantages**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: Introduces a single point of failure
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入了一个单点故障
- en: Performance issues may arise when too many modules try to communicate back and
    forth
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当太多模块试图来回通信时，可能会出现性能问题
- en: The prototype pattern
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型模式
- en: In the prototype pattern, objects are created on the template of the existing
    object through cloning.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型模式中，对象是通过克隆现有对象的模板创建的。
- en: Description
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This pattern focuses on creating an object that can be used as a template/blueprint
    for other objects through prototypal inheritance. JavaScript has native support
    for prototypal inheritance. Therefore, it's easy to work in this pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式侧重于创建一个可以通过原型继承用作其他对象模板/蓝图的对象。JavaScript 本身支持原型继承。因此，在这个模式中工作很容易。
- en: 'Here are a few advantages and disadvantages of the prototype pattern:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些原型模式的优点和缺点：
- en: '**Advantages**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: Suitable for applications where object creation is in focus
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于关注对象创建的应用程序
- en: Better performance as new objects inherit features from the prototype
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于新对象从原型继承特性，性能更好
- en: '**Disadvantages**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: Overkill for an application that has very few objects or prototypes
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有非常少对象或原型的应用程序来说，过度设计
- en: Command pattern
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令模式
- en: In this pattern, commands are encapsulated as objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，命令被封装为对象。
- en: Description
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Command objects allow loosely coupled systems to separate objects that issue
    requests from the objects that process requests. These requests are known as **events**
    and the code that processes these requests is called an event handler.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 命令对象允许松散耦合的系统将发出请求的对象与处理请求的对象分离。这些请求被称为**事件**，处理这些请求的代码称为事件处理器。
- en: In simpler words, we can say that the main purpose of the command pattern is
    separating the features of giving out commands from executing commands and delegating
    this feature to a different object. Practically, command objects bind an action
    to the object that will invoke the action. They always include a function such
    as `run()` or `execute()`. One of the biggest advantages of this pattern is that
    command objects with the same interface can be easily interchanged whenever needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以这样说，命令模式的主要目的是将发出命令的功能与执行命令的功能分离，并将此功能委托给不同的对象。实际上，命令对象将一个动作绑定到将调用该动作的对象。它们通常包括一个如
    `run()` 或 `execute()` 的函数。这种模式最大的优点之一是，具有相同接口的命令对象可以在需要时轻松互换。
- en: '**Advantages**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: The command pattern makes it easier to construct general components that have
    to execute/delegate/sequence method calls
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式使得构建必须执行/委托/排序方法调用的通用组件变得更加容易
- en: Command objects with same interface can be interchanged whenever needed
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有相同接口的命令对象可以在需要时进行互换
- en: It allows bookkeeping about command executions, without interference from the
    client
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许对命令执行进行记录，而不会受到客户端的干扰
- en: '**Disadvantages**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: It significantly increases the number of classes for each command
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它显著增加了每个命令的类数量
- en: It is useful while creating structures where generation and execution of requests
    do not depend on each other. We can say that a command instance can be instantiated
    by the client and run later by the **invoker**. The client and invoker may not
    know anything about each other.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建结构时，请求的生成和执行不依赖于彼此时很有用。我们可以这样说，命令实例可以由客户端实例化，并由**调用者**稍后运行。客户端和调用者可能对彼此一无所知。
- en: This pattern is scalable as we can add new commands without changing any existing
    code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是可扩展的，因为我们可以在不更改任何现有代码的情况下添加新命令。
- en: The facade pattern
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 门面模式
- en: A façade is a front layer that is presented to and is visible to the world.
    Behind it lies all the complexity and unpresentable objects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 门面是一个面向世界展示并可见的前端层。在其背后隐藏着所有复杂性和不可展示的对象。
- en: Description
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The façade pattern is a structural pattern that enables us to hide the backend
    complexities under an interface. This pattern increases usability of the application
    modules. Internal features and methods are not exposed directly to developers,
    but they can interact with them through this façade. This pattern makes your application
    secure.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 门面模式是一种结构模式，它使我们能够在接口下隐藏后端复杂性。这种模式提高了应用程序模块的可用性。内部特性和方法不会直接暴露给开发者，但它们可以通过这个门面与之交互。这种模式使您的应用程序更加安全。
- en: jQuery is an example of a JavaScript library that uses the façade pattern.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 是一个使用门面模式的 JavaScript 库的例子。
- en: Whenever we use jQuery's `$(this).animate()` or `$(this).css()` function, we
    are using a façade. Similarly, `$(document).ready()` implements a façade.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用 jQuery 的 `$(this).animate()` 或 `$(this).css()` 函数时，我们都在使用一个门面。同样，`$(document).ready()`
    实现了一个门面。
- en: The core jQuery attributes should be considered intermediate abstractions. The
    more immediate burden to developers is the DOM API and facades are what make the
    jQuery library so easy to use.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 核心jQuery属性应被视为中间抽象。对开发者来说，更直接的负担是DOM API，而门面使得jQuery库如此易于使用。
- en: The `ready()` function has lots of complexities at the backend. jQuery simplifies
    browser inconsistency to ensure that `ready()` is invoked at the appropriate time.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`ready()` 函数在后台有很多复杂性。jQuery 简化了浏览器的不一致性，以确保 `ready()` 在适当的时间被调用。'
- en: However, we only see a façade or a simple interface layer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只看到了一个门面或一个简单的接口层。
- en: 'Here are a few advantages and disadvantages of the facade pattern:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些门面模式的优点和缺点：
- en: '**Advantages**:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: Improves a web application's security
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了Web应用程序的安全性
- en: Compatible with other patterns
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他模式兼容
- en: Easier to patch internal modules
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易修补内部模块
- en: Easier to implement
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现起来更简单
- en: Provides a simpler public interface
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一个更简单的公共接口
- en: Being used in other JavaScript frameworks, such as jQuery
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被用于其他 JavaScript 框架，如 jQuery
- en: '**Disadvantages**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: No proven disadvantages
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有已证实的缺点
- en: The factory pattern
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Just like other creational design patterns, the factory pattern also focuses
    on object creation. However, it differs in the way that it does not require a
    constructor method to create objects.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他创建型设计模式一样，工厂模式也关注对象创建。然而，它不同之处在于它不需要构造函数来创建对象。
- en: Description
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The factory pattern provides an interface for object creation where we specify
    the type of factory object we need to create. Subclasses are allowed to decide
    which class will be instantiated so that they can specify which type of factory
    object will be created. Factory pattern is very extensible. Factory methods are
    used when collection of objects are being maintained. These collection of objects
    are different but still have many common methods and properties.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式提供了一个对象创建的接口，其中我们指定需要创建的工厂对象的类型。子类允许决定哪个类将被实例化，以便它们可以指定将创建哪种类型的工厂对象。工厂模式非常易于扩展。当维护对象集合时使用工厂方法。这些对象集合不同，但仍然有许多共同的方法和属性。
- en: In this pattern, we do not use the `new` keyword to create an object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，我们不会使用`new`关键字来创建对象。
- en: 'Let''s take a real-time example that will clarify this pattern:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个实时例子来说明这个模式：
- en: Suppose there is a garment factory. We need to create a type of garment. Instead
    of creating this object directly using the `new` keyword, we will request a factory
    object for a new garment. We tell the factory which type of object is needed (a
    shirt, jeans, coat, a scarf, and so on). It instantiates that class and returns
    the object for our further usage.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个服装工厂。我们需要创建一种服装类型。而不是直接使用`new`关键字创建这个对象，我们将请求一个用于新服装的工厂对象。我们告诉工厂需要哪种类型的对象（衬衫、牛仔裤、外套、围巾等）。它实例化那个类并返回对象供我们进一步使用。
- en: ExtJS is a JavaScript library that uses this pattern. Methods for creating objects
    can be categorized and further sub classed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ExtJS 是一个使用此模式的 JavaScript 库。创建对象的函数可以被分类并进一步子类化。
- en: 'Here are a few advantages and disadvantages of the factory pattern:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了工厂模式的一些优缺点：
- en: '**Advantages**:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Object creation is much easier through an interface class, which does the process
    for us
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个接口类创建对象要容易得多，这个接口类为我们处理这个过程
- en: Good for creating objects based on different scenarios
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于根据不同场景创建对象
- en: Practical for similar instantiating objects
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于类似实例化的对象来说非常实用
- en: Creating objects through one instance is simplified
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个实例创建对象被简化了
- en: '**Disadvantages**:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Difficult to test object-creation process as it's hidden behind factory methods
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它隐藏在工厂方法后面，因此很难测试对象创建过程
- en: The mixin pattern
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混入模式
- en: In OOP, mixins are classes that can be inherited by a subclass or a group of
    subclasses for functionality reuse.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，混入是可以被子类或一组子类继承以实现功能重用的类。
- en: Description
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Subclassing means to inherit properties for our new object from a super or base
    class object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 子类化意味着从超类或基类对象继承新对象属性。
- en: For instance, there is an `apple` class that is able to extend from another
    class, `fruit`. Here, `fruit` is a superclass, while `apple` is a subclass of
    `fruit`. All objects of `apple` inherit properties from `fruit`. However, `apple`
    is able to define its own methods and override those defined by `fruit`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个能够从另一个类`fruit`扩展的`apple`类。在这里，`fruit`是超类，而`apple`是`fruit`的子类。`apple`的所有对象都继承自`fruit`的属性。然而，`apple`能够定义自己的方法并覆盖由`fruit`定义的方法。
- en: If `apple` needs to call an overridden method in `fruit`, it's called method
    chaining.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`apple`需要调用`fruit`中的重写方法，这被称为方法链式调用。
- en: If `apple` needs to call `fruit's` constructor, it's called **constructor chaining**.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`apple`需要调用`fruit`的构造函数，这被称为**构造函数链式调用**。
- en: Mixins let other objects inherit their functionality with a very minimal level
    of complexity. This pattern allows us to share functionalities from many mixins
    through multiple inheritance.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 混入允许其他对象以非常低的复杂性级别继承其功能。这种模式允许我们通过多继承从多个混入中共享功能。
- en: 'Here are a few advantages and disadvantages of the mixin pattern:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了混入模式的一些优缺点：
- en: '**Advantages**:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: This pattern helps in decreasing function duplication and promotes reuse of
    functions. In applications where functionality is shared across the system, we
    can put the shared functions in mixins and focus on the rest of the distinct functionality
    in our system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式有助于减少函数重复，并促进函数的重用。在功能在整个系统中共享的应用中，我们可以将共享的函数放入混入（mixins）中，并专注于我们系统中其余的独特功能。
- en: '**Disadvantages**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Keeping functionality in the object prototype may result in prototype pollution
    and may confuse tracking the origin of our functions. This may cause problems
    in large-scale applications.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象原型中保持功能可能会导致原型污染，并可能混淆跟踪函数的来源。这可能在大型应用程序中引起问题。
- en: 'Example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE8]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Property getter and setter
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性获取器和设置器
- en: In programming languages, getting and setting properties are used to `get` and
    `set` the values of an object. The `g` `etter` method is used to get values of
    properties and the `setter` method is used to set values of properties.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，获取和设置属性用于`get`和`set`对象的值。`getter`方法用于获取属性的值，而`setter`方法用于设置属性的值。
- en: 'There are two property accessors in JavaScript:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有两个属性访问器：
- en: getter
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器
- en: setter
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置器
- en: Description
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: The `getter` and `setter` are methods that help us access and manipulate the
    data within an object very easily. They can help us build shortcuts to access
    concealed information. The `getter` and `setter` methods work in such a way that
    they bind objects with a function so that they look like normal object properties.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getter`和`setter`是帮助我们非常容易地访问和操作对象内部数据的函数。它们可以帮助我们建立访问隐藏信息的快捷方式。`getter`和`setter`方法以这种方式工作，即它们将对象与一个函数绑定，使其看起来像正常的对象属性。'
- en: '`getter`: This method is a special kind of property accessor. When you want
    to access a property, the value is generated dynamically. Here is an example:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getter`：此方法是一种特殊的属性访问器。当您想要访问一个属性时，值是动态生成的。以下是一个例子：'
- en: '[PRE9]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`setter`: This method is used to set properties. It passes a value as an argument
    and the returned value of the function is set to the property. Here is an example:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setter`：此方法用于设置属性。它传递一个值作为参数，并将函数的返回值设置为属性。以下是一个例子：'
- en: '[PRE10]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Deleting properties
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除属性
- en: Just like we can add properties to objects, JavaScript allows us to remove object
    properties as well.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以向对象添加属性一样，JavaScript也允许我们删除对象属性。
- en: Description
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: The `delete` operator is used to delete a property of an object. It deletes
    properties from the local version. The scope of a property can be reassigned to
    another variable on the same scope. In JavaScript, the `delete` operator always
    returns a Boolean value. Using this keyword, you cannot delete objects declared
    with the `var` keyword.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`运算符用于删除对象的属性。它从本地版本中删除属性。属性的范畴可以被重新分配到同一作用域内的另一个变量。在JavaScript中，`delete`运算符始终返回一个布尔值。使用此关键字，您不能删除用`var`关键字声明的对象。'
- en: 'Let''s assume we have an object like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个这样的对象：
- en: '[PRE11]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We wish to remove the `age` property so that we can have a final object that
    looks like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望删除`age`属性，以便我们可以有一个看起来像这样的最终对象：
- en: '[PRE12]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Enter the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also use this command to achieve the same result:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用此命令达到相同的结果：
- en: '[PRE14]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Testing properties
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试属性
- en: One of the common tests performed by developers on an object is to check whether
    an object has a specific property or not. There are different ways to check whether
    an object has a given property.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在对象上执行的一种常见测试是检查对象是否具有特定的属性。有不同方法来检查对象是否具有给定的属性。
- en: Description
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'In JavaScript, there are two methods for property testing:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，有两种属性测试方法：
- en: '`hasOwnProperty`: This method is used to check whether an object has its own
    property or not. If the property is inherited from anywhere, then it will return
    `false`:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasOwnProperty`：此方法用于检查对象是否具有自己的属性。如果属性是从任何地方继承的，则它将返回`false`：'
- en: '[PRE15]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`propertyIsEnumerable`: This method returns `true`, only if `hasOwnProperty`
    returns `true` and that property is enumerable.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyIsEnumerable`：此方法仅在`hasOwnProperty`返回`true`且该属性是可枚举的情况下返回`true`。'
- en: To check properties in JavaScript, we can use the `in` keyword. If an object
    property has its own value, it will return `true`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JavaScript中检查属性，我们可以使用`in`关键字。如果一个对象属性有它自己的值，它将返回`true`。
- en: 'Here is an example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE16]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Enumerating properties
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出属性
- en: In JavaScript, enumeration of an object's properties is done using the `for-in`
    loop.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，使用`for-in`循环来枚举对象的属性。
- en: Description
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: In JavaScript, enumerating properties are used in the `for-in` loop as this
    loop accesses all properties of an object. When we want to check the list of properties
    of an object, then we use the `for-in` loop to iterate properties. It assigns
    the name of the property to the loop variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，枚举属性在`for-in`循环中使用，因为这个循环访问了对象的所有属性。当我们想要检查对象的属性列表时，我们使用`for-in`循环来迭代属性。它将属性的名称分配给循环变量。
- en: Inherited objects are not enumerable, but properties that you add with these
    objects are enumerable.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 继承对象不可枚举，但使用这些对象添加的属性是可枚举的。
- en: 'Here is an example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Property attributes
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性属性
- en: The information associated with every JavaScript property is called an **attribute**.
    Different types of property attributes are explained here.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个JavaScript属性相关的信息称为**属性**。这里解释了不同类型的属性属性。
- en: Description
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'There are two types of JavaScript properties:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript属性有两种类型：
- en: Data property
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据属性
- en: AccessorProperty (`getter` and `setter` properties)
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问器属性（`getter`和`setter`属性）
- en: 'There are four attributes that a property has:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 属性具有四个属性：
- en: '**Enumerable**: This checks whether the property is in a loop construct'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可枚举性**：这检查属性是否在循环结构中'
- en: '**Configurable**: This checks whether we can delete or modify a property'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置性**：这检查我们是否可以删除或修改属性'
- en: '**Writable**: This checks whether we can set the value of a property or not'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可写性**：这检查我们是否可以设置属性的值'
- en: '**Value**: This is a value of property and it can be of any data type in JavaScript'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：这是属性的值，可以是JavaScript中的任何数据类型'
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The data property has all of the preceding attributes, while the accessor property
    does not have a value or writable attribute.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 数据属性具有所有前面的属性，而访问器属性没有值或可写属性。
- en: Object attributes
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象属性
- en: 'There are three types of object properties in JavaScript:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有三种类型的对象属性：
- en: '**Named data properties**: These are normal object properties in which an object
    maps string name a to a value. Here is an example:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名数据属性**：这些是正常对象属性，其中对象将字符串名称映射到值。以下是一个示例：'
- en: '[PRE18]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Named accessor properties**: Functions that are used to get and set properties
    are known as **named accessor** **properties**. Here is an example:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名访问器属性**：用于获取和设置属性的函数被称为**命名访问器** **属性**。以下是一个示例：'
- en: '[PRE19]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s another example:'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里还有一个示例：
- en: '[PRE20]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Internal properties**: Some properties that are not accessible via language
    are called **internal** **properties** in JavaScript. These properties are purely
    for specification purposes. These properties have special names and are written
    inside square brackets. All objects have an internal property known as `[[Prototype]]`.
    The value of this property is either null or an object, which is used for implementing
    inheritance.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部属性**：在语言中不可访问的一些属性在JavaScript中被称为**内部** **属性**。这些属性纯粹是为了规范目的。这些属性具有特殊名称，并写在大括号内。所有对象都有一个称为`[[Prototype]]`的内部属性。该属性的值要么是null，要么是一个对象，用于实现继承。'
- en: 'It has two parts:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它有两个部分：
- en: '**Prototype**: This tells the prototype of an object'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型**：这告诉对象的原型'
- en: '**Extensible**: This tells us whether we can or cannot add properties to an
    object'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：这告诉我们是否可以向对象添加属性'
- en: Serializing objects
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化对象
- en: Serializing an object means converting an object into bytes so that it can be
    stored in memory persistently, or it can be sent across the network. These bytes
    can then be deserialized into the original object.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化对象意味着将对象转换为字节，以便它可以持久地存储在内存中，或者可以发送到网络上。然后，这些字节可以反序列化为原始对象。
- en: Description
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'Serialization is used to store or preserve the internal state of an object.
    In serialization, an object can be transported or retrieved later. There are two
    methods of serialization in JavaScript:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化用于存储或保留对象的内部状态。在序列化过程中，一个对象可以被传输或稍后检索。JavaScript中有两种序列化方法：
- en: '`JSON.stringify`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON.stringify`'
- en: '`JSON.parse`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON.parse`'
- en: 'Here is an example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE21]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These methods can also retrieve and store objects, `arrays`, `strings`, `true`
    and `false`. Enumerable values are preserved or restored by the `JSON.stringify()`
    method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法也可以检索和存储对象、`数组`、`字符串`、`true`和`false`。可枚举值通过`JSON.stringify()`方法保留或恢复。
- en: Objects methods
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象方法
- en: Object methods are functions that are stored as object properties. These methods
    can be performed by calling them directly following a variable for which the function
    is to be called and a . (dot).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对象方法是存储为对象属性的函数。这些方法可以通过直接调用它们来执行，调用时跟在要调用函数的变量后面，后面跟着一个点（.）。
- en: Description
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: Every object has methods, which are basically actions performed on it. A method
    is a property of an object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有方法，这些方法基本上是在其上执行的操作。方法是一个对象的属性。
- en: The `toLowerCase()`, `toUpperCase()`, `substr()`, `trim()`, `charAt()`, and
    `indexOf()` methods are some of the examples of native (part of the core language)
    methods of a string object.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`toLowerCase()`、`toUpperCase()`、`substr()`、`trim()`、`charAt()`和`indexOf()`方法是字符串对象原生（核心语言的一部分）方法的示例。'
- en: 'Here is an example using the `toUpperCase()` method:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`toUpperCase()`方法的示例：
- en: '[PRE22]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The value of the result will be:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的值将是：
- en: '[PRE23]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Functions and methods
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和方法
- en: A function is a part of code that does a particular operation that is written
    by the user and called by name independently. A function may be passed some data
    and it may also return some data. On the other hand, you can think of methods
    as defined properties of objects that can be called with reference from the object
    of the class only. Objects that are associated with methods are basically window
    objects. The syntax of defining a method and a function is different in JavaScript.
    Methods are only used to define window objects. The way of defining a method is
    different than defining a function in JavaScript.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是用户编写的执行特定操作的代码部分，可以独立通过名称调用。函数可以传递一些数据，也可以返回一些数据。另一方面，你可以将方法视为对象的定义属性，只能通过类对象来调用。与方法相关联的对象基本上是窗口对象。在JavaScript中，定义方法和函数的语法不同。方法仅用于定义窗口对象。在JavaScript中定义方法的语法与定义函数的语法不同。
- en: Invoking functions
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'The four different ways of invoking a function are as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数的四种不同方式如下：
- en: Invoking a function as a function
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为函数调用
- en: Invoking a function as a method
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为方法调用
- en: Invoking a function as a constructor
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为构造函数调用
- en: Invoking a function with a function method
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数方法调用函数
- en: All these methods were discussed in detail in the previous chapter. There is
    a different way of initializing the `this` keyword. When you call a function,
    it starts a function. However, when you invoke a function, it executes it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都在上一章中详细讨论过。初始化`this`关键字有不同的方式。当你调用一个函数时，它启动一个函数。然而，当你调用一个函数时，它执行它。
- en: Defining functions
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数
- en: When you define a function, your script will not execute, but when you invoke
    a function, the script will execute. A JavaScript function performs a particular
    task. When any object calls this function, it starts working. To define a function
    in JavaScript, we use the `function` keyword. A function can have multiple parameters
    depending on the task. You can find more detail for this in [Chapter 8](ch08.html
    "Chapter 8. JavaScript Implementations, Syntax Basics, and Variable Types"), *JavaScript
    Implementations, Syntax Basics, and Variable Types*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个函数时，你的脚本不会执行，但是当你调用一个函数时，脚本会执行。JavaScript函数执行特定的任务。当任何对象调用此函数时，它开始工作。在JavaScript中定义函数，我们使用`function`关键字。一个函数可以有多个参数，这取决于任务。你可以在[第8章](ch08.html
    "第8章。JavaScript实现、语法基础和变量类型")中找到更多详细信息，*JavaScript实现、语法基础和变量类型*。
- en: Function arguments and parameters
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数和参数
- en: 'In JavaScript, a function can have number of arguments. A function may be called
    with a number of arguments. If you do not provide any argument in a function,
    then it will become undefined. Arguments are optional in a JavaScript function.
    If you do not pass any argument in a function, then it will set it to default.
    Here is an example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，一个函数可以有多个参数。一个函数可以用多个参数调用。如果你在函数中不提供任何参数，那么它将变为未定义。在JavaScript函数中，参数是可选的。如果你在函数中不传递任何参数，那么它将设置为默认值。以下是一个示例：
- en: '[PRE24]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we passed two arguments in the function: arguments `x` and
    `y`. When the first function `arg(2)` is called, then `a=2` and `b` will be undefined.
    When the second function is called, `a=2` and `b=1`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在函数中传递了两个参数：参数`x`和`y`。当第一次调用函数`arg(2)`时，`a=2`而`b`将是未定义的。当第二次调用函数时，`a=2`且`b=1`。
- en: Parameters and return values
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数和返回值
- en: 'We know we can pass arguments in a function. A function returns a value to
    perform a different operation in your script. There are two ways to pass a value
    into a function:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们可以在函数中传递参数。函数返回一个值以在脚本中执行不同的操作。有两种方法可以将值传递到函数中：
- en: '**Pass by value**: When we pass any variable (of primitive data types) as an
    argument in the function, we pass it by value. For example, first, the value is
    `2`. After passing, it is `3`:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按值传递**：当我们把任何变量（原始数据类型）作为函数的参数传递时，我们按值传递它。例如，首先，值是`2`。传递之后，它变为`3`：'
- en: '[PRE25]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Pass by reference**: When you pass a value to an object, it is passed by
    reference:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按引用传递**：当你将一个值传递给对象时，它是通过引用传递的：'
- en: '[PRE26]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Functions as namespace
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为命名空间
- en: 'Namespace is a set of logical identifiers grouped together. JavaScript does
    not provide a namespace facility by default. So, for creating namespaces in JavaScript,
    we declare a global object and make all functions and properties into that global
    object, for example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一组逻辑标识符的组合。JavaScript 默认不提供命名空间功能。因此，为了在 JavaScript 中创建命名空间，我们声明一个全局对象，并将所有函数和属性都放入该全局对象中，例如：
- en: '[PRE27]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Closure
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: To write better code, we use closures in JavaScript. Better code means code
    that is creative and expressive. In JavaScript, you encounter closures repeatedly,
    whether you are a good JavaScript programmer or not. Depending on how you use
    closures in your code, it could be complex or easy.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写更好的代码，我们在 JavaScript 中使用闭包。更好的代码意味着具有创造性和表现力的代码。在 JavaScript 中，无论你是否是一个好的
    JavaScript 程序员，你都会反复遇到闭包。根据你在代码中使用闭包的方式，它可能是复杂的或简单的。
- en: 'Basically, closures are the inner functions of JavaScript used to access the
    outer function''s scope. There are three scopes of a closure:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，闭包是 JavaScript 中的内部函数，用于访问外部函数的作用域。闭包有三个作用域：
- en: Access of outer function variables
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问外部函数变量
- en: Access to its own scope variables
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问其自己的作用域变量
- en: Access to its global variables
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问其全局变量
- en: 'Inner functions also have access to outer function variables and parameters.
    In its own scope, variables are defined in curly brackets. Here is an example:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数也可以访问外部函数的变量和参数。在其自己的作用域中，变量在花括号中定义。以下是一个示例：
- en: '[PRE28]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Function properties
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数属性
- en: 'To define a function in JavaScript, we use the `function` variable. This function
    can be called anywhere in your script. It could also be a function constructor.
    The attributes and their descriptions are as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中定义一个函数，我们使用 `function` 变量。这个函数可以在你的脚本中的任何地方调用。它也可以是一个函数构造器。属性及其描述如下：
- en: '`arguments`: This is an array passed to a function as an argument'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments`：这是一个作为参数传递给函数的数组'
- en: '`argument.length`: This tells us the number of arguments in a function'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argument.length`：这告诉我们函数中有多少个参数'
- en: '`constructor`: This is used to create an object'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor`：这用于创建对象'
- en: '`length`: This defines the number on an argument'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：这定义了参数上的数字'
- en: '`prototype`: This allows a function to add object properties'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prototype`：这允许一个函数添加对象属性'
- en: '`arguments.callee`: This tells us which function is executing currently'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments.callee`：这告诉我们当前正在执行哪个函数'
- en: Methods
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'Actions performed on objects are known as **methods** in JavaScript. They contain
    function definitions. They are stored as object properties in a script. For example,
    you can create a method like this in JavaScript:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，对对象执行的操作称为**方法**。它们包含函数定义。它们作为脚本中的对象属性存储。例如，你可以在 JavaScript 中创建一个类似的方法：
- en: '[PRE29]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here `FullName` is both a property (`Student.FullName`) and a method (`Student.FullName()`).
    When you access object properties without brackets, this will return a function
    definition. Here is an example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`FullName` 既是属性（`Student.FullName`）也是方法（`Student.FullName()`）。当你不使用括号访问对象属性时，这将返回一个函数定义。以下是一个示例：
- en: '[PRE30]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Function constructor
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数构造器
- en: 'A function constructor is used to define a function dynamically. A new operator
    is use to define a function with the constructor method. You can also pass as
    many arguments you want to use in your script to a constructor. The last argument
    will be the body of the function. It can also contain statements separated by
    commas. Here is an example:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 函数构造器用于动态定义函数。使用构造器方法定义函数时使用 new 操作符。你还可以将你想要在脚本中使用的大量参数传递给构造器。最后一个参数将是函数的主体。它也可以包含由逗号分隔的语句。以下是一个示例：
- en: '[PRE31]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We cannot pass the same function name in a constructor as an argument, as it
    will create an error in the script. It can also create an unnamed function, known
    as an anonymous function.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在构造器中将相同的函数名作为参数传递，因为这将在脚本中创建错误。它还可以创建一个无名的函数，称为匿名函数。
- en: Classes and modules
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和模块
- en: In JavaScript, we do not have any native approach to creating classes, but we
    can create a class using prototype inheritance and a constructor function.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们没有创建类的任何原生方法，但我们可以使用原型继承和构造函数创建一个类。
- en: Classes are containers for objects. We use classes to encapsulate a namespace
    and logic.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 类是对象的容器。我们使用类来封装命名空间和逻辑。
- en: 'To instantiate a class, we can use the `new` keyword. Classes are similar to
    constructor functions. Here is an example:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个类，我们可以使用`new`关键字。类类似于构造函数。以下是一个例子：
- en: '[PRE32]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modules are used to include and extend classes and properties easily. Modules
    attach properties to global objects to export module values.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 模块用于轻松包含和扩展类和属性。模块将属性附加到全局对象以导出模块值。
- en: 'Classes and their modules are extremely important and vital aspects of JavaScript.
    We will be covering the following topics in the subsequent sections:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 类及其模块是JavaScript中极其重要和关键的部分。在接下来的章节中，我们将涵盖以下主题：
- en: Classes and prototypes
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和原型
- en: Constructors
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Java-style classes in JavaScript
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中的Java风格类
- en: Augmented JavaScript
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展的JavaScript
- en: Types of classes
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的类型
- en: Subclasses
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类
- en: Classes in ECMA5 script
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMA5脚本中的类
- en: Modules
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Classes and prototypes
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和原型
- en: In JavaScript, a class is an object with special types of properties and methods.
    It is used to create instances and define the behavior of instances. Instances'
    behavior changes dynamically and we have a special syntax to write it in JavaScript.
    Instances are created when special methods are invoked on a class.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，类是一个具有特殊类型属性和方法的对象。它用于创建实例并定义实例的行为。实例的行为会动态变化，我们在JavaScript中有特殊的语法来编写它。当在类上调用特殊方法时，会创建实例。
- en: Prototypes and functions are two different things in JavaScript. A constructor
    can be any function, but a prototype is a special kind of object. To define a
    behavior of any instance, we use a prototype. There are no special properties
    or methods a prototype has. When we modify a prototype, we have instances.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，原型和函数是两回事。构造函数可以是任何函数，但原型是一种特殊的对象。为了定义任何实例的行为，我们使用原型。原型没有特殊的属性或方法。当我们修改原型时，我们就有实例了。
- en: In simpler words, we can say that in JavaScript, a constructor can be any function
    that is responsible for creating an instance. On the other hand, a prototype can
    be any object that has no special methods or properties. Prototypes are responsible
    for an instance's behavior.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，我们可以说在JavaScript中，构造函数可以是任何负责创建实例的函数。另一方面，原型可以是任何没有特殊方法或属性的对象。原型负责实例的行为。
- en: 'In JavaScript, the prototype and constructor functions act like a class, because
    a class has a constructor, and to define methods, you have a prototype:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，原型和构造函数函数像类一样工作，因为类有一个构造函数，要定义方法，你有原型：
- en: 'Here is an example:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE33]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are no special properties or objects associated with a prototype. An object
    in your script can be an empty project or a prototype. When we say that any object
    can be a prototype, then this object will have functions and data types. Prototypes
    are not special kinds of objects, but classes are special kinds of objects in
    JavaScript.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 与原型相关联的没有特殊的属性或对象。你脚本中的对象可以是空项目或原型。当我们说任何对象都可以是原型时，那么这个对象将具有函数和数据类型。原型不是特殊类型的对象，但在JavaScript中，类是特殊类型的对象。
- en: Constructors
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: A class contains a set of objects, and for initialization of the objects, we
    use constructors. In a class, we can create objects using the `new` operator.
    We can define a class as a subclass to construct objects.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 类包含一组对象，为了初始化对象，我们使用构造函数。在类中，我们可以使用`new`运算符创建对象。我们可以将类定义为子类来构造对象。
- en: 'With a single property of prototype, a constructor is created. If we overwrite
    the prototype property, the reference to the constructor might be lost. In JavaScript,
    we use the `constructor` property to create a class from an object that is passed
    as an object. Here is an example:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原型的一个属性，创建一个构造函数。如果我们覆盖原型属性，构造函数的引用可能会丢失。在JavaScript中，我们使用`constructor`属性从一个对象创建一个类。以下是一个例子：
- en: '[PRE34]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Defining a class
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个类
- en: 'There are three ways of defining a class in JavaScript:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中定义类有三种方式：
- en: Using a function
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数
- en: Using object literals
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象字面量
- en: A singleton using a function
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数创建单例
- en: Using a function
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数
- en: You can create an object using the `new` keyword in a function. To access methods
    and properties, use the `this` keyword. There would be a conflict if you define
    a function with the same name in a class.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用函数中的`new`关键字创建一个对象。要访问方法和属性，请使用`this`关键字。如果在类中定义了具有相同名称的函数，将会有冲突。
- en: Using object literals
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对象字面量
- en: 'To define an object or array in JavaScript, we use literals. Here is an example:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JavaScript中定义一个对象或数组，我们使用字面量。以下是一个例子：
- en: '[PRE35]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Classes in the ECMA5 script
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ECMA5脚本中的类
- en: 'For specific objects'' properties, the ECMA5 script added five methods. These
    methods are used to secure and restrict the extensibility of objects in the script.
    These methods are:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定对象的属性，ECMA5 脚本添加了五种方法。这些方法用于确保和限制脚本中对象的扩展性。这些方法包括：
- en: Enumerable
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可枚举
- en: Writable
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可写
- en: Getter
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器
- en: Setter
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置器
- en: Configurable
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置
- en: When we define a class in JavaScript, these methods are very useful. When you
    store an object, it sets an object ID for these methods. When we use a looping
    statement, it will return this object ID. All objects inherit the object ID, which
    is enumerable. To read a property, it will invoke the `getter` function, and there
    will be no `setter` function. So, it will be read-only. We cannot modify it, so
    it cannot be deleted.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 JavaScript 中定义一个类时，这些方法非常有用。当你存储一个对象时，它会为这些方法设置一个对象 ID。当我们使用循环语句时，它会返回这个对象
    ID。所有对象都继承了这个对象 ID，它是可枚举的。要读取一个属性，它会调用`getter`函数，而不会有`setter`函数。因此，它是只读的。我们无法修改它，所以它不能被删除。
- en: Modules
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: 'The two very important aspects of modules are:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的两个非常重要的方面是：
- en: '**They have dependencies**: This means that when you write a module in your
    system, it is fully dependent on the function. We import dependencies from functions
    while creating our application.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们有依赖**：这意味着当你在一个系统中编写模块时，它是完全依赖于函数的。我们在创建应用程序时从函数中导入依赖项。'
- en: '**They have exports**: If you leave some function and variable public in your
    system, anything can export these. For example, you have exported a function `$function`,
    module that depends on this function will also have access to this function.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们有导出**：如果你在系统中公开一些函数和变量，任何东西都可以导出这些。例如，你导出了一个函数`$function`，依赖于这个函数的模块也将能够访问这个函数。'
- en: 'A module can export a number of multiple variables and functions. To export
    these functions and variables, we use the `export` keyword. Here is an example:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块可以导出多个变量和函数。要导出这些函数和变量，我们使用`export`关键字。以下是一个示例：
- en: '[PRE36]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also store a variable after exporting it. Here is an example:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在导出后存储一个变量。以下是一个示例：
- en: '[PRE37]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Inheritance
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'JavaScript supports prototype inheritance. In other programming languages,
    objects and classes inherit from each other to use each other''s properties and
    functions. However, in JavaScript, you have an object-based inheritance, which
    is called a prototype, in which objects use the properties of other objects. For
    example, if you have a `Person` object, then you can use the `_proto_` attribute
    for that object to create another `Student` object:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 支持原型继承。在其他编程语言中，对象和类通过继承彼此来使用对方的属性和函数。然而，在 JavaScript 中，你有一个基于对象的继承，这被称为原型，其中对象使用其他对象的属性。例如，如果你有一个`Person`对象，那么你可以使用该对象上的`_proto_`属性来创建另一个`Student`对象：
- en: '![Inheritance](img/Image1544.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![继承](img/Image1544.jpg)'
- en: Prototype chaining
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型链式连接
- en: In JavaScript, you create new objects from existing objects. This process is
    called **prototype chaining**. It is similar to inheritance in object-oriented
    systems.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，你从现有对象创建新对象。这个过程被称为**原型链式连接**。它与面向对象系统中的继承类似。
- en: Description
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'Prototype is a property of the `constructor` function. When you add any object
    property to a prototype, it will add this property or method to the objects created
    by the constructor function. In prototype chaining, we create a function prototype
    using the properties of the `constructor` function. Using this, all methods or
    properties transfer to the `prototype` object from the `constructor` function.
    This method is very easy and useful for creating the `constructor` function to
    create objects. Here is an example:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是`constructor`函数的一个属性。当你向原型添加任何对象属性时，它将把这个属性或方法添加到由构造函数创建的对象中。在原型链式连接中，我们使用`constructor`函数的属性创建一个函数原型。通过这种方式，所有方法或属性都从构造函数转移到原型对象。这种方法非常简单且非常有用，可以用来创建构造函数以创建对象。以下是一个示例：
- en: '[PRE38]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In method resolution, first JavaScript checks objects for methods. When you
    use prototype chaining, it can override methods for prototypes of an object. So,
    the JavaScript construction function sets methods for objects.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法解析中，JavaScript 首先检查对象是否有方法。当你使用原型链式连接时，它可以覆盖对象原型的某些方法。因此，JavaScript 构造函数为对象设置方法。
- en: Constructor stealing
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数窃取
- en: In JavaScript, constructor stealing is also called **classical inheritance**.
    This method is use to inherit problems of prototype reference values.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，构造函数窃取也被称为**经典继承**。这种方法用于继承原型引用值的问题。
- en: Description
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'In constructor stealing, we call a super constructor in a subtype constructor.
    This idea is quite simple and easy. We use the `call()` and `apply()` methods
    for function calling. Here is an example:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数窃取中，我们在子类型构造函数中调用超构造函数。这个想法非常简单易懂。我们使用`call()`和`apply()`方法进行函数调用。以下是一个例子：
- en: '[PRE39]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, we used the `call()` method to call a super constructor for
    a newly created subclass instead of a subconstructor. This will initialize all
    objects in the `super()` function on `sub()`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`call()`方法来调用新创建的子类的一个超构造函数，而不是子构造函数。这将初始化`sub()`函数上的`super()`函数中的所有对象。
- en: Note
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we use prototype chaining, the `constructor` function will allow us to
    pass arguments from a super constructor to within the subconstructor.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用原型链式连接时，`constructor`函数将允许我们从超构造函数传递参数到子构造函数内部。
- en: Combination inheritance
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合继承
- en: Combination inheritance is also called **pseudo-classical inheritance**. This
    is a combination of constructor stealing and prototype chaining.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 组合继承也称为**伪经典继承**。这是构造函数窃取和原型链式连接的组合。
- en: Description
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'In combination inheritance, prototype chaining inherits properties and methods
    from a prototype, and constructor stealing inherits instances. In this way, we
    can reuse methods on prototypes by allowing methods to have their own properties.
    Here is an example:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合继承中，原型链继承从原型继承属性和方法，构造函数窃取继承实例。这样，我们可以通过允许方法有自己的属性来在原型上重用方法。以下是一个例子：
- en: '[PRE40]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this example, the `SuperType` constructor defines two properties: `name`
    and `colors`. The `SuperType` prototype has a single method called `sayName()`.
    The `SubType` constructor calls the `SuperType` constructor, passing in the `name`
    argument, and defines its own property called `age`. Additionally, the `SubType`
    prototype is assigned to be an instance of `SuperType`, and then, a new method
    called `sayAge()` is defined. With this code, it''s then possible to create two
    separate instances of `SubType` that have their own properties, including the
    `colors` property, but all use the same methods. Addressing the downsides of both
    prototype chaining and constructor stealing, combination inheritance is the most
    frequently used inheritance pattern in JavaScript. It also preserves the behavior
    of `instanceof` and `isPrototypeOf()` to identify the composition of objects.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`SuperType`构造函数定义了两个属性：`name`和`colors`。`SuperType`原型有一个名为`sayName()`的方法。`SubType`构造函数调用`SuperType`构造函数，传入`name`参数，并定义自己的属性`age`。此外，`SubType`原型被分配为`SuperType`的一个实例，然后定义了一个名为`sayAge()`的新方法。使用这段代码，就可以创建两个独立的`SubType`实例，它们都有自己的属性，包括`colors`属性，但都使用相同的方法。解决原型链式连接和构造函数窃取的缺点，组合继承是JavaScript中最常用的继承模式。它还保留了`instanceof`和`isPrototypeOf()`的行为，以识别对象的结构。
- en: Prototypal inheritance
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型继承
- en: In prototypal inheritance, we use an object as a base for another object.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型继承中，我们使用一个对象作为另一个对象的基础。
- en: Description
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: In prototypal inheritance, there are no classes, only objects. To create an
    object, you can either create a totally new object or you can clone an existing
    object. New objects can be then extended with new properties.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型继承中，没有类，只有对象。要创建一个对象，你可以创建一个全新的对象，或者克隆一个现有的对象。然后，新对象可以通过添加新属性进行扩展。
- en: 'Here is an example:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE41]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding object has no prototype and is a clone of `null`:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个对象没有原型，是`null`的克隆：
- en: '[PRE42]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, `rect` inherits the `area` function from `rectangle`.
    Here, rectangle is an object literal, an object literal is a way to create a clone
    of `Object.prototype`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`rect`从`rectangle`继承了`area`函数。这里，`rectangle`是一个对象字面量，对象字面量是创建`Object.prototype`克隆的一种方式。
- en: 'It can also be written as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以写成如下形式：
- en: '[PRE43]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can extend the newly created object as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式扩展新创建的对象：
- en: '[PRE44]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can create a `constructor` function that will clone `rectangle` for us and
    will extend it with the `height` and `width` properties:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`constructor`函数，它会为我们克隆`rectangle`并扩展其`height`和`width`属性：
- en: '[PRE45]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Parasitic inheritance
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄生继承
- en: Parasitic inheritance is similar to prototypal inheritance.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 寄生继承类似于原型继承。
- en: Description
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'It simply works by creating a function that performs inheritance, object augmentation,
    and finally, it returns the object after completing each task:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过创建一个执行继承、对象增强并在每个任务完成后返回对象的函数来简单地工作：
- en: '[PRE46]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, in this example, we have the `abc()` function that has one argument, which
    is an object based on a new object. This object is passed to the `object` function
    and saves the resulting object into a `clone` variable. Now, the `clone` object
    will have a new object property, and at the end, we return the object.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个 `abc()` 函数，它有一个参数，这个参数是基于新对象的。这个对象被传递给 `object` 函数，并将结果对象保存到 `clone`
    变量中。现在，`clone` 对象将有一个新的对象属性，最后，我们返回这个对象。
- en: Parasitic combination inheritance
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄生组合继承
- en: A parasite is defined as an organism that lives inside another organism and
    relies on its resources. Similarly, in this inheritance, a child object relies
    on a parent object and extends its properties from it.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 寄生生物被定义为生活在另一种生物体内并依赖其资源的生物。同样，在这个继承中，子对象依赖于父对象并从它扩展其属性。
- en: Description
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'The first constructor calls the subtype `prototype` and then it calls the subtype
    `constructor`. This is a very efficient way of creating new objects in JavaScript.
    At the end, the subtype will have all the properties of the super type. Here is
    an example:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个构造函数调用子类型的 `prototype`，然后调用子类型的 `constructor`。这是在 JavaScript 中创建新对象的一种非常有效的方法。最后，子类型将具有超类型的所有属性。以下是一个例子：
- en: '[PRE47]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The only difference between parasitic combination inheritance and combination
    inheritance is that, in the former one, the base constructor is called once, and
    in the latter one, the base constructor is called twice.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 寄生组合继承和组合继承之间的唯一区别在于，在前者中，基构造函数只调用一次，而在后者中，基构造函数调用两次。
- en: Subclasses
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类
- en: In every programming language, every subclass has a super class that inherits
    its properties and methods from. JavaScript is not a pure class-based programming
    language, but it follows some of the rules of OOP. We make classes in JavaScript
    using object notations.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种编程语言中，每个子类都有一个超类，它继承其属性和方法。JavaScript 不是一个纯面向对象编程语言，但它遵循一些面向对象的规则。我们使用对象表示法在
    JavaScript 中创建类。
- en: 'In JavaScript, you can only perform inheritance using the `constructor` function
    or prototype. This inheritance is only done at run time, which means dynamically.
    Here is an example:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，你只能使用 `constructor` 函数或原型来执行继承。这种继承仅在运行时进行，这意味着它是动态的。以下是一个例子：
- en: '[PRE48]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To run the preceding code execute following method:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行前面的代码，请执行以下方法：
- en: '[PRE49]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Built-in objects
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置对象
- en: 'To add flexibility in language, JavaScript supports a number of built-in objects.
    The most commonly used objects are:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在语言中增加灵活性，JavaScript 支持许多内置对象。最常用的对象包括：
- en: Global
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局
- en: Date
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: Math
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Math
- en: RegExp (Regular Expression)
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RegExp（正则表达式）
- en: Array
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Implementations of these built-in objects are complex and different.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置对象的实现复杂且不同。
- en: Global objects
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局对象
- en: Global objects are objects defined outside the function. Every function can
    access these variables because their scope is global for all.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象是在函数外部定义的对象。每个函数都可以访问这些变量，因为它们的范围是全局的。
- en: When you do not declare a variable and assign a value to it, then it will automatically
    become global.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有声明变量并给它赋值时，它将自动成为全局的。
- en: Description
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: When your code starts execution, functions and constants immediately become
    available. A global variable does not initialize with the `new` keyword. Basically,
    global objects are used to share same data to add properties. You can store methods
    within global objects in your script.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码开始执行时，函数和常量立即可用。全局变量不使用 `new` 关键字初始化。基本上，全局对象用于共享相同的数据以添加属性。你可以在脚本中将方法存储在全局对象中。
- en: Objects that you cannot access directly for accessing those object we use global
    objects. We pass those object directly as arguments after declaring the global
    variable. You can create a number of instances and a number of global objects
    in your script.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接访问的对象，为了访问这些对象，我们使用全局对象。在声明全局变量后，我们直接将这些对象作为参数传递。你可以在脚本中创建多个实例和多个全局对象。
- en: 'A global object has a fixed number of properties. Multiple object instances
    can access this global object. Here is an example:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象具有固定数量的属性。多个对象实例可以访问这个全局对象。以下是一个例子：
- en: '[PRE50]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Date object
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期对象
- en: Date objects in JavaScript deal with date and time objects. For example, if
    we are writing a script and we need some functionality of date and time, then
    we can use this built-in object simply.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的日期对象处理日期和时间对象。例如，如果我们正在编写脚本并且需要日期和时间的某些功能，那么我们可以简单地使用这个内置对象。
- en: getTime()
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: getTime()
- en: This function is used to get the current time with respect to the number of
    milliseconds since January 1, 1970.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取自1970年1月1日以来的毫秒数。
- en: Parameters
  id: totrans-490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters passed.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 没有传递参数。
- en: Returns
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The number of milliseconds since January 1, 1970.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 自1970年1月1日以来的毫秒数。
- en: Description
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: As the name states, this function is used to obtain the current time, in the
    form of milliseconds. We need to create a date object first.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，此函数用于获取当前时间，以毫秒为单位。我们首先需要创建一个日期对象。
- en: '[PRE51]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: getMilliseconds()
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getMilliseconds()`'
- en: This function is used to get the current time with respect to the number of
    milliseconds.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取相对于毫秒数的当前时间。
- en: Parameters
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters passed.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 没有传递参数。
- en: Returns
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: A number from 0-999.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从0到999的数字。
- en: Description
  id: totrans-503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: As the name states, this function is used to obtain the current time, in the
    form of milliseconds. We need to create a date object first.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，此函数用于获取当前时间，以毫秒为单位。我们首先需要创建一个日期对象。
- en: '[PRE52]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: getMinutes()
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getMinutes()`'
- en: This function is used to get the current time with respect to the number of
    minutes.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取相对于分钟的当前时间。我们首先需要创建一个日期对象。
- en: Parameters
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters passed.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 没有传递参数。
- en: Returns
  id: totrans-510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: A number from 0-59.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从0到59的数字。
- en: Description
  id: totrans-512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This function is used to obtain the current time, in the form of minutes. We
    need to create a date object first.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取当前时间，以分钟为单位。我们首先需要创建一个日期对象。
- en: '[PRE53]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: getHours()
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getHours()`'
- en: This function is used to get the current time with respect to the number of
    hours.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取相对于小时的当前时间。我们首先需要创建一个日期对象。
- en: Parameters
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters passed.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 没有传递参数。
- en: Returns
  id: totrans-519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: A number from 0-23 with 0 being midnight.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从0到23的数字，0代表午夜。
- en: Description
  id: totrans-521
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This function is used to obtain the current time, in the form of hours. We need
    to create a date object first.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取相对于小时的当前时间。我们首先需要创建一个日期对象。
- en: '[PRE54]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: getDate()
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getDate()`'
- en: This function is used to get the current day.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取当前天。
- en: Parameters
  id: totrans-526
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters passed.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 没有传递参数。
- en: Returns
  id: totrans-528
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: A number from 1-31.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从1到31的数字。
- en: Description
  id: totrans-530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This function is used to obtain the current day. We need to create a date object
    first.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取当前天。我们首先需要创建一个日期对象。
- en: '[PRE55]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: getDay()
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getDay()`'
- en: This function is used to get the current day in the week.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取当前周中的当前天。
- en: Parameters
  id: totrans-535
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters passed.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 没有传递参数。
- en: Returns
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: A number from 0-6 with 0 being Sunday.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从0到6的数字，0代表星期日。
- en: Description
  id: totrans-539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This function is used to obtain the current day in the week. We need to create
    a date object first.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取当前周中的当前天。我们首先需要创建一个日期对象。
- en: '[PRE56]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: getMonth()
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getMonth()`'
- en: This function is used to get the current month.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取当前月份。
- en: Parameters
  id: totrans-544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters passed.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 没有传递参数。
- en: Returns
  id: totrans-546
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: A number from 0-11.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从0到11的数字。
- en: Description
  id: totrans-548
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This function is used to obtain the current month in the year. We need to create
    a date object first.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取年份中的当前月份。我们首先需要创建一个日期对象。
- en: '[PRE57]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: getFullYear()
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getFullYear()`'
- en: This function is used to get the current year.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取当前年份。
- en: Parameters
  id: totrans-553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters passed.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 没有传递参数。
- en: Returns
  id: totrans-555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The year in the YYYY format.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 年份，格式为YYYY。
- en: Description
  id: totrans-557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This function is used to obtain the current year. We need to create a date object
    first.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于获取当前年份。我们首先需要创建一个日期对象。
- en: '[PRE58]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Set date methods
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置日期方法
- en: 'Methods are available in date objects to manipulate dates. We can also adjust
    the date dynamically. Here is an example:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 日期对象中提供了可用于操作日期的方法。我们还可以动态调整日期。以下是一个示例：
- en: '[PRE59]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can also set upcoming dates and the current date by using this function,
    for example:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过此函数设置未来的日期和当前日期，例如：
- en: '[PRE60]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The date set methods are:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 日期设置方法有：
- en: '`setTime()`'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTime()`'
- en: '`setMilliseconds()`'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMilliseconds()`'
- en: '`setMinutes()`'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMinutes()`'
- en: '`setMinutes()`'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMinutes()`'
- en: '`setHours()`'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setHours()`'
- en: '`setDate()`'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDate()`'
- en: '`setDay()`'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDay()`'
- en: '`setMonth()`'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setMonth()`'
- en: '`setFullYear()`'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFullYear()`'
- en: These methods are very similar to the date get methods described in the preceding
    term list.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与前面术语列表中描述的日期获取方法非常相似。
- en: We can also compare dates using the date object.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用日期对象来比较日期。
- en: Math object
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学对象
- en: In JavaScript, the math object is used to perform mathematical operations.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，数学对象用于执行数学运算。
- en: 'This object has several mathematical functions. Here is an example:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象有多个数学函数。以下是一个示例：
- en: '`Math.E`'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.E`'
- en: '`Math.PI`'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.PI`'
- en: '`Math.sqrt`'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.sqrt`'
- en: '`Math.Ln2`'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.Ln2`'
- en: '`Math.ln10`'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.ln10`'
- en: The `math` object has different methods. For example, we have the `pow` method
    that calculates the power of the first variable times the second.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`对象有不同的方法。例如，我们有`pow`方法，它计算第一个变量的幂乘以第二个变量。'
- en: '[PRE61]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: min()
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: min()
- en: This function is used to find out the the argument with the minimum value.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于找出具有最小值的参数。
- en: Parameters
  id: totrans-589
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The values to be evaluated are passed as parameters.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 需要评估的值作为参数传递。
- en: Returns
  id: totrans-591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: The argument with the minimum value.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 具有最小值的参数。
- en: Description
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: As the name suggests, this function is simply used to obtain the minimum value
    among all values in an argument
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，此函数简单地用于从参数中的所有值中获取最小值
- en: 'For example:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE62]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: max()
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: max()
- en: This function is used to find the argument with the maximum value.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于找出具有最大值的参数。
- en: Parameters
  id: totrans-599
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The values to be evaluated are passed as parameters.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 需要评估的值作为参数传递。
- en: Returns
  id: totrans-601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: The argument with the maximum value.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 具有最大值的参数。
- en: Description
  id: totrans-603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: As the name suggests, this function is simply used to obtain the maximum value
    among all values in an argument.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，此函数简单地用于从参数中的所有值中获取最大值。
- en: 'For example:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE63]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: random()
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: random()
- en: This function is used to generate a random number between 0 and 1.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于生成介于0和1之间的随机数。
- en: Parameters
  id: totrans-609
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: No parameters.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 无参数。
- en: Returns
  id: totrans-611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: A random number between 0 and 1.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 一个介于0和1之间的随机数。
- en: Description
  id: totrans-613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'The `random()` function is useful in generating random numbers. The value of
    the number will always lie between 0 and 1 (never exactly 1). For example:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`random()`函数在生成随机数时很有用。该数字的值始终介于0和1之间（永远不会正好是1）。例如：'
- en: '[PRE64]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: round()
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: round()
- en: This function is used to round the number to its nearest integer value.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于将数字舍入到其最近的整数值。
- en: Parameters
  id: totrans-618
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The values to be evaluated are passed as parameters.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 需要评估的值作为参数传递。
- en: Returns
  id: totrans-620
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: The rounded number.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 舍入后的数字。
- en: Description
  id: totrans-622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This method is used to create integer values after rounding them.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于在舍入后创建整数值。
- en: 'For example:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE65]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ceil()
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ceil()
- en: This function is used to round a number up to the nearest and highest possible
    integer value.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于将数字向上舍入到最近的可能的最大整数值。
- en: Parameters
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The values to be evaluated are passed as parameters.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 需要评估的值作为参数传递。
- en: Returns
  id: totrans-630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: The highest rounded number.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 舍入后的最大数字。
- en: Description
  id: totrans-632
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This method is used to create integer values after rounding them to the higher
    integer.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于在舍入到更高的整数后创建整数值。
- en: 'For example:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE66]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: floor()
  id: totrans-636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: floor()
- en: This function is used to round a number down to the nearest and lowest possible
    integer value.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于将数字向下舍入到最近的可能的最小整数值。
- en: Parameters
  id: totrans-638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The values to be evaluated are passed as parameters.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 需要评估的值作为参数传递。
- en: Returns
  id: totrans-640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: The lowest rounded number.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 舍入后的最小数字。
- en: Description
  id: totrans-642
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This method is used to create integer values after rounding them to the lower
    integer.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于在舍入到更低的整数后创建整数值。
- en: 'For example:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE67]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The RegExp object
  id: totrans-646
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RegExp对象
- en: In JavaScript, for pattern matches in string, we use a regular expression. It
    is a very powerful and useful tool for expression pattern matching.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，对于字符串中的模式匹配，我们使用正则表达式。它是一种非常强大且有用的表达式模式匹配工具。
- en: Parameters
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: 'The following are the parameters:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参数：
- en: '**Pattern**: The text/pattern of the regular expression'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式**：正则表达式的文本/模式'
- en: '**Flags**: If specified, flags can have any combination of the following:'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志**：如果指定，标志可以是以下组合之一：'
- en: '`g`: Global match'
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`: 全局匹配'
- en: '`i`: Ignore case'
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`: 忽略大小写'
- en: '`m`: Multiline; treat beginning and end characters (`^` and `$`) as working
    over multiple lines (that is, match the beginning or end of each line (delimited
    by `\n` or `\r`), not only the very beginning or end of the whole input string)'
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`: 多行；将开始和结束字符（`^`和`$`）视为跨越多行（即，匹配每行的开始或结束（由`\n`或`\r`分隔），而不仅仅是整个输入字符串的非常开始或结束）'
- en: Returns
  id: totrans-655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回
- en: The return type of different regular expressions is different.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 不同正则表达式的返回类型不同。
- en: Description
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'Using a regular expression, you can make a complex task simple by writing few
    lines of codes. There are five methods in JavaScript:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式，你可以通过编写几行代码将复杂任务简化。JavaScript中有五种方法：
- en: '`RegExp.exec(pattern)`'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegExp.exec(pattern)`'
- en: '`RegExp.replace(pattern)`'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegExp.replace(pattern)`'
- en: '`RegExp.split(pattern)`'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegExp.split(pattern)`'
- en: '`RegExp.match(pattern)`'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegExp.match(pattern)`'
- en: Defining a regular expression
  id: totrans-663
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义正则表达式
- en: 'There are two ways of writing a regular expression in JavaScript. These are:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，有两种编写正则表达式的方法。这些是：
- en: RegExp constructor method
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RegExp构造函数方法
- en: Literal syntax
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字语法
- en: Note
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are differences between the `RegExp` object and global object. They look
    the same but act differently.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegExp`对象和全局对象之间有区别。它们看起来相同，但行为不同。'
- en: RegExp constructor
  id: totrans-669
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RegExp构造函数
- en: 'This method is used to dynamically construct a string search pattern. A regular
    expression in this method should be written in quotation marks. This method has
    three parameters. Here is an example:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于动态构建字符串搜索模式。在此方法中，正则表达式应写成引号内。此方法有三个参数。以下是一个例子：
- en: '[PRE68]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this example:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中：
- en: E-mail is a required parameter to which regular expression values are assigned
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件是一个必需的参数，正则表达式值被分配给它
- en: '`\d` is a pattern parameter used to match regular expression'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d`是一个用于匹配正则表达式的模式参数'
- en: '`g` is global, which is a flag parameter. In this function, there are four
    types of parameters (`g`, `I`, `m` ,`u`).'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`是全局的，这是一个标志参数。在此函数中，有四种类型的参数（`g`、`I`、`m`、`u`）。'
- en: Literal syntax
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文字语法
- en: 'In literal notation, we write a regular expression without brackets. Here,
    `i` is a flag that shows to ignore case of the text whether it is uppercase, lowercase
    or any other. We have more flag objects such as the following ones:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在文字表示法中，我们不使用括号来编写正则表达式。在这里，`i`是一个标志，表示忽略文本的大小写，无论是大写、小写还是其他。我们还有更多的标志对象，如下所示：
- en: '`g`: Global object'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`: 全局对象'
- en: '`i`: Ignore case'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`: 忽略大小写'
- en: '`m`: Multi search'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`: 多次搜索'
- en: '`u`: Unicode search'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`: Unicode搜索'
- en: 'In regular expressions, we can have a global regular expression object, which
    will have information for each match case. A simple regular expression object
    has information about a particular regular expression:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，我们可以有一个全局正则表达式对象，它将为每个匹配情况提供信息。一个简单的正则表达式对象只包含特定正则表达式的信息：
- en: '[PRE69]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: String object
  id: totrans-684
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串对象
- en: There are four string methods for pattern matching. In these objects, a pattern
    is sent with a parameter. These methods allow you to search, match, replace, and
    split patterns.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种字符串匹配方法。在这些对象中，一个模式通过参数发送。这些方法允许您搜索、匹配、替换和分割模式。
- en: These methods are represented as follows.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法如下所示。
- en: Match(pattern)
  id: totrans-687
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Match(pattern)
- en: This method is used to find a matching pattern within a string. Using the `not`
    (`!`) operator it can also be used to find non-matches.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于在字符串中找到匹配的模式。使用`not`（`!`）运算符，它也可以用于找到非匹配项。
- en: The syntax is `string.Match(Expression)`.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是`string.Match(Expression)`。
- en: Parameters
  id: totrans-690
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The string pattern that is to be matched.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配的字符串模式。
- en: Returns
  id: totrans-692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns the result if a match is found or `0` or `null` if no match is found.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到匹配项，则返回结果，如果没有找到匹配项，则返回`0`或`null`。
- en: Description
  id: totrans-694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This runs a search for matching strings in a regular expression. If the search
    is matched or successful then it will return an array of matching results, if
    not then it will return `null` or `0`. It is also used to update properties in
    a regular expression.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在正则表达式中运行匹配字符串的搜索。如果搜索匹配或成功，则将返回匹配结果的数组，如果不匹配，则返回`null`或`0`。它还用于更新正则表达式的属性。
- en: 'Here is an example:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE70]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Replace(pattern)
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Replace(pattern)
- en: This method is used to replace a part of the string.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于替换字符串的一部分。
- en: The syntax is `string.replace(stringSearched, stringReplacement)`.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是`string.replace(stringSearched, stringReplacement)`。
- en: Parameters
  id: totrans-701
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The string pattern that is to be replaced is passed as a parameter.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换的字符串模式作为参数传递。
- en: Returns
  id: totrans-703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The string with the replaced value.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 替换后的字符串。
- en: Description
  id: totrans-705
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This executes a search and is used for replacement of regular expression match
    resulted with alternative text. This is also used for replacement of regular expressions
    with specific and different `regExp` properties.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行搜索并用于用替代文本替换正则表达式匹配的结果。这也用于用特定且不同的`regExp`属性替换正则表达式。
- en: 'Here is an example:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE71]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here the value of `parsestring1` is `Apple Cinnamon Roll`.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`parsestring1`的值是`Apple Cinnamon Roll`。
- en: Note
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember here that the search is case sensitive, so if you provide the value
    `parsestring1=str1.replace("piE", "Cinnamon Roll");` then no replacement is done.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，搜索是区分大小写的，所以如果您提供`parsestring1=str1.replace("piE", "Cinnamon Roll");`的值，则不会进行替换。
- en: 'Also, only the first occurrence of the pattern is replaced. Hence:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，只有模式的第一个出现被替换。因此：
- en: '[PRE72]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here the value of `parsestring1` is `Apple Cinnamon Roll`, `Banana Pie`, `Strawberry
    PIE`.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`parsestring1`的值是`Apple Cinnamon Roll`、`Banana Pie`、`Strawberry PIE`。
- en: 'To perform a global search and replacement so that all occurrences are replaced
    we use the following code:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行全局搜索和替换，以便替换所有出现，我们使用以下代码：
- en: '[PRE73]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here the value of `parsestring1` is `Apple Cinnamon Roll`, `Banana Cinnamon
    Roll`, `Strawberry PIE`.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `parsestring1` 的值是 `Apple Cinnamon Roll`，`Banana Cinnamon Roll`，`Strawberry
    PIE`。
- en: 'For a global insensitive search, use the following code:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全局不区分大小写的搜索，请使用以下代码：
- en: '[PRE74]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here the value of `parsestring1` is `Apple Cinnamon Roll`, `Banana Cinnamon
    Roll`, `Strawberry Cinnamon Roll`.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `parsestring1` 的值是 `Apple Cinnamon Roll`，`Banana Cinnamon Roll`，`Strawberry
    Cinnamon Roll`。
- en: Split(pattern)
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Split(pattern)
- en: This is use to split a string in a regular expression.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于使用正则表达式分割字符串。
- en: The syntax is `string.split(separator,limit)`.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是 `string.split(separator,limit)`。
- en: Parameters
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: A separator and limit are provided as optional parameters.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符和限制是可选参数。
- en: Returns
  id: totrans-726
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: The split string is returned.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 返回分割后的字符串。
- en: Description
  id: totrans-728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'With this method the string is split. Every word in the string is treated as
    a single element in an array. If a null string is passed as a parameter, the method
    causes each letter to be split into different characters. For example:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，字符串被分割。字符串中的每个单词都被视为数组中的一个单独元素。如果传递了空字符串作为参数，则该方法会将每个字母分割成不同的字符。例如：
- en: '[PRE75]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The value of `parseString` will be:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseString` 的值将是：'
- en: '[PRE76]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Providing a limit will return a comma separated array of the words containing
    only the specified number of elements. For example:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个限制将返回一个逗号分隔的数组，其中只包含指定数量的元素。例如：
- en: '[PRE77]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The value of `parseString` is `My,Car,is`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseString` 的值是 `My,Car,is`。'
- en: 'Using a letter or letters as a separator will give the following results:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字母或字母作为分隔符将给出以下结果：
- en: '[PRE78]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The value of `parseString` will be:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseString` 的值将是：'
- en: '[PRE79]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here is another example:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE80]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The value of `parseString` will be:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseString` 的值将是：'
- en: '[PRE81]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: search(pattern)
  id: totrans-744
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: search(pattern)
- en: This method is used to search for a particular string.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于搜索特定字符串。
- en: The syntax is `string.search(stringSearched)`.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是 `string.search(stringSearched)`。
- en: Parameters
  id: totrans-747
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The string pattern that is to be searched is passed as a parameter.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索的字符串模式作为参数传递。
- en: Returns
  id: totrans-749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: It returns the position of the starting letter of the string if a match is found.
    If no match is found then it returns `-1`.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到匹配项，则返回字符串起始字母的位置；如果没有找到匹配项，则返回 `-1`。
- en: Description
  id: totrans-751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: It is used to find a match in a string. If a match is found it will send an
    index of that match otherwise, if a match is not found, it will return `-1`. Global
    flags are not supported by this method.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于在字符串中查找匹配项。如果找到匹配项，它将发送该匹配项的索引；如果没有找到匹配项，则返回 `-1`。此方法不支持全局标志。
- en: 'Here is an example:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE82]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The value of `parseString` here is `18`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `parseString` 的值是 `18`。
- en: Note
  id: totrans-756
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are additional string methods available to perform other tasks on strings.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他字符串方法可用于在字符串上执行其他任务。
- en: A detailed list of these methods can be found at [https://msdn.microsoft.com/en-us/library/ecczf11c(v=vs.94).aspx](https://msdn.microsoft.com/en-us/library/ecczf11c(v=vs.94).aspx).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的详细列表可以在 [https://msdn.microsoft.com/en-us/library/ecczf11c(v=vs.94).aspx](https://msdn.microsoft.com/en-us/library/ecczf11c(v=vs.94).aspx)
    找到。
- en: Array objects
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组对象
- en: An array is a collection of objects.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一组对象的集合。
- en: 'To create an array in JavaScript, the elements of the collection are enclosed
    within square brackets and separated by commas, as seen here:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中创建数组时，集合的元素被括在方括号内，并用逗号分隔，如下所示：
- en: '[PRE83]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'An array can also be initialized using the `new` keyword or by specifying their
    length between 0 and 232-1:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以使用 `new` 关键字或指定长度（介于 0 和 232-1 之间）来初始化：
- en: '[PRE84]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To access array elements, we can use an index notation:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组元素，我们可以使用索引表示法：
- en: '[PRE85]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Always remember that array elements always start with the zero index. Hence,
    the third element in the preceding array has the index of `2`.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，数组元素始终从零索引开始。因此，前面数组中的第三个元素的索引是 `2`。
- en: Array objects can hold all sorts of data, for example, strings, numbers, literals,
    dates, and even user-defined objects.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象可以存储各种数据，例如，字符串、数字、文字、日期，甚至用户定义的对象。
- en: .Pop()
  id: totrans-769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .Pop()
- en: This method is used to *pop* an element out of an array.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于从数组中 *弹出* 一个元素。
- en: Parameters
  id: totrans-771
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters for this method.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法没有参数。
- en: Returns
  id: totrans-773
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回
- en: It returns the *popped* element of the array.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回数组的 *弹出* 元素。
- en: Description
  id: totrans-775
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Here an array is considered as a stack and the elements that are last in the
    array are popped out first. This follows the LIFO principle.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数组被视为一个栈，最后进入数组的元素首先弹出。这遵循 LIFO 原则。
- en: 'Here is an example:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE86]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The value of the element here is `Black Forest`.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 此处元素的值是 `Black Forest`。
- en: .Push()
  id: totrans-780
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .Push()
- en: This method is used to *push* an element into an array.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于 *push* 一个元素到数组中。
- en: Parameters
  id: totrans-782
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters for this method.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法没有参数。
- en: Returns
  id: totrans-784
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: It returns the new length of the array.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回数组的新的长度。
- en: Description
  id: totrans-786
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Here an array is considered as a stack and the elements that are pushed appear
    at the end of the array.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数组被视为一个栈，推入的元素出现在数组的末尾。
- en: 'Here is an example:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE87]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The value of the element here is `6`.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 此处元素的值是 `6`。
- en: .ToString()
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .ToString()
- en: This converts the elements in an array into a string. The elements appear as
    comma-separated strings.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 这将数组中的元素转换为字符串。元素以逗号分隔的字符串形式出现。
- en: Parameters
  id: totrans-793
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数。
- en: Returns
  id: totrans-795
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a string containing the elements of the array.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个包含数组元素的字符串。
- en: Description
  id: totrans-797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'The `ToString()` function is used to convert an array into a string. The elements
    of the array appear in the string and are separated by a comma:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString()` 函数用于将数组转换为字符串。数组元素在字符串中显示，并由逗号分隔：'
- en: '[PRE88]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here the value of `StrSweets` is:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `StrSweets` 的值是：
- en: '[PRE89]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: .ValueOf()
  id: totrans-802
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .ValueOf()
- en: This method is also used to convert an array into a string.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也用于将数组转换为字符串。
- en: Parameters
  id: totrans-804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: There are no parameters.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数。
- en: Returns
  id: totrans-806
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a string containing the elements of the array.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个包含数组元素的字符串。
- en: Description
  id: totrans-808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is default behaviour of the array and works same as the `ToString()` function.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数组的默认行为，与 `ToString()` 函数的工作方式相同。
- en: '[PRE90]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Here the value of `StrSweets` is:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `StrSweets` 的值是：
- en: '[PRE91]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: .Join()
  id: totrans-813
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .Join()
- en: This method is used to convert an array into a string. The elements are separated
    by the delimiter specified.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于将数组转换为字符串。元素由指定的分隔符分隔。
- en: Parameters
  id: totrans-815
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: A separator to separate the elements in the new string.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分隔符，用于分隔新字符串中的元素。
- en: Returns
  id: totrans-817
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a string containing the elements of the array separated by the
    delimiter specified.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个包含数组元素的字符串，元素由指定的分隔符分隔。
- en: Description
  id: totrans-819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'The `Join()` function is used to convert an array into a string. The elements
    of the array appear in the string and are separated by the delimter:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join()` 函数用于将数组转换为字符串。数组元素在字符串中显示，并由分隔符分隔：'
- en: '[PRE92]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here the value of `StrSweets` is:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `StrSweets` 的值是：
- en: '[PRE93]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: .Splice()
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .Splice()
- en: Splice, as the name suggests, is used to add new elements into the array. Unlike
    the `push()` method we can add elements in whichever position we want.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: Splice，如其名所示，用于向数组中添加新元素。与 `push()` 方法不同，我们可以添加到任何位置。
- en: Parameters
  id: totrans-826
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: 'The following are the parameters:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参数：
- en: Position
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置
- en: Number of elements to be removed
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除的元素数量
- en: Elements to be added
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要添加的元素
- en: Returns
  id: totrans-831
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The array as a string along with the new elements, if any.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 数组作为字符串，以及任何新元素（如果有）。
- en: Description
  id: totrans-833
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This method is used to remove and add elements in one step. We can specify where
    the new element is to be added and which elements are to be removed.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于在一步中删除和添加元素。我们可以指定新元素要添加的位置以及要删除的元素。
- en: '[PRE94]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Here the value of `StrSweets` is:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `StrSweets` 的值是：
- en: '[PRE95]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: .sort()
  id: totrans-838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .sort()
- en: This method is used to sort an array into alphabetical order.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于将数组按字母顺序排序。
- en: Parameters
  id: totrans-840
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: No parameters.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数。
- en: Returns
  id: totrans-842
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The sorted array is returned.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 返回排序后的数组。
- en: Description
  id: totrans-844
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The sort method is used to sort an array, alphabetically.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 排序方法用于按字母顺序排序数组。
- en: 'Here is an example:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE96]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here the value of `StrSweets` is:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `StrSweets` 的值是：
- en: '[PRE97]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: .reverse()
  id: totrans-850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .reverse()
- en: As the name suggests it reverses the order of the array.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，它反转数组的顺序。
- en: Parameters
  id: totrans-852
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: No parameters.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数。
- en: Returns
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The reversed array is returned.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 返回反转后的数组。
- en: Description
  id: totrans-856
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The reverse method is used to sort an array, alphabetically, in reverse order.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 反转方法用于按字母顺序反向排序数组。
- en: 'Here is an example:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE98]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Here the value of `StrSweets` is:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `StrSweets` 的值是：
- en: '[PRE99]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: .slice()
  id: totrans-862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .slice()
- en: As the name suggests, this method is used to slice up an array and create a
    new array using a part of the original array.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，此方法用于将数组切片并使用原始数组的一部分创建一个新数组。
- en: Parameters
  id: totrans-864
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The index at which we want the array sliced. The index of an array begins at
    `0`. So the first element has index `0`, the second element has index `1`, and
    so on.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要切片的数组索引。数组的索引从 `0` 开始。因此，第一个元素的索引是 `0`，第二个元素的索引是 `1`，依此类推。
- en: Returns
  id: totrans-866
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The sliced array containing the remaining elements is returned.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含剩余元素的切片数组。
- en: Description
  id: totrans-868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The slice method is used to slice up an array and get the remainder of the array
    as a string.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 切片方法用于切割数组并获取数组剩余部分作为字符串。
- en: 'Here is an example:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE100]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here the value of `StrSweets` is:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `StrSweets` 的值是：
- en: '[PRE101]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: .concat()
  id: totrans-874
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`.concat()`'
- en: This method is used to concatenate two or more arrays into a single array.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于将两个或多个数组连接成一个单一数组。
- en: Parameters
  id: totrans-876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: The array to be concated is passed as the parameter.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数传递要连接的数组。
- en: Returns
  id: totrans-878
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This method returns the concated array.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回连接后的数组。
- en: Description
  id: totrans-880
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `Concat()` method is used to create a single array by joining two or more
    arrays.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concat()` 方法用于通过连接两个或多个数组来创建一个单一数组。'
- en: 'Here is an example:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE102]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here the value of `CoolShades` is:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `CoolShades` 的值是：
- en: '[PRE103]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
