- en: Building Reusable Web Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建可重用Web组件
- en: In the previous chapter, we talked about styling our Web Components, along with
    understanding how accessibility plays a vital role in creating a good component.
    We then talked about the Gold Standard Checklist and looked into unit testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了为我们的Web组件添加样式，以及了解可访问性在创建良好组件中的重要作用。然后我们讨论了黄金标准清单并探讨了单元测试。
- en: In this chapter, we will be looking deep into reusability and how we can publish
    our Web Components on a platform for maximum reusability. We will also cover a
    few examples on responsive Web Components. We did look into styling, and while
    the concept of responsive CSS is not something new, the use of responsive styles
    could make a component look even better and more reusable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨可重用性以及我们如何将我们的Web组件发布到平台上以实现最大限度的可重用性。我们还将涵盖一些关于响应式Web组件的例子。我们已经探讨了样式，虽然响应式CSS的概念并不新颖，但响应式样式的使用可以使组件看起来更好，更具可重用性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The concept of reusability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用性的概念
- en: Responsive Web Components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式Web组件
- en: Publishing Web Components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布Web组件
- en: Extending Web Components - slots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展Web组件 - 插槽
- en: The concept of reusability
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用性的概念
- en: Before we even dive into the concept of reusability in Web Components, let's
    take a look at what reusability is with the help of an example. Let's take an
    example of an operating system, say Windows 10\. Now, we all know there are a
    lot of computers. Some with the same hardware and some with different. But what
    makes this piece of software (Windows 10) reusable is its ability to being used
    again and again and in different scenarios without any issues. The exact same
    thing can be made to work for a Web Component.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨Web组件的可重用性概念之前，让我们通过一个例子来看看什么是可重用性。让我们以一个操作系统为例，比如Windows 10。我们都知道有很多电脑。有些硬件相同，有些不同。但使这款软件（Windows
    10）可重用的原因是它能够在不同场景下反复使用而不会出现任何问题。同样的事情也可以使Web组件工作。
- en: 'Yes, Web Components can be made extremely reusable. Let''s say we have a Web
    Component `<custom-header>`. As the name indicates, it is a header. And most of
    the sites that we have ever visited have one or the other version of the same
    functional header. The functionalities are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Web组件可以被制作得极具可重用性。假设我们有一个Web组件`<custom-header>`。正如其名称所示，它是一个标题。并且我们访问过的几乎所有网站都有一个或另一个相同功能的标题版本。其功能如下：
- en: Show the logo.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示标志。
- en: Clicking on the logo should drop the user to `index.html`.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标志应将用户带到`index.html`。
- en: Show the name of the company.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示公司名称。
- en: Show user stats, that is, if the user is not logged in, show the login drop-down
    menu. If the user is logged in, show account-related links.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示用户统计数据，即如果用户未登录，显示登录下拉菜单。如果用户已登录，显示与账户相关的链接。
- en: Show Help links.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示帮助链接。
- en: Show About us and Contact us links.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示“关于我们”和“联系我们”链接。
- en: Provide a default background for the header.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为标题提供默认背景。
- en: The header can be sticky at the top.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题可以固定在顶部。
- en: 'These points all show us various ways a header can be customized and implemented.
    We can very well convert these points to an attribute list while designing the
    Web Component:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点都向我们展示了如何自定义和实现标题的各种方式。我们可以在设计Web组件时将这些点很好地转换为属性列表：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or if the user is not logged in, it can be left empty like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果用户未登录，它可以是空的，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All these attributes make the Web Component extremely reusable. The person who
    is going to use this component will simply need to import it and provide the values
    of these attributes without coding anything extra.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性使Web组件极具可重用性。使用此组件的人只需导入它并提供这些属性的值，而无需编写任何额外的代码。
- en: 'Let''s take a look at another, but complex, example. Let us say you are building
    a music player. A Web Component `<music-player>` may have a bunch of attributes
    that make it extremely reusable. The common ones are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看另一个，但更复杂的例子。假设你正在构建一个音乐播放器。一个Web组件`<music-player>`可能有一系列属性使其极具可重用性。常见的属性如下：
- en: Name of the song
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 歌曲名称
- en: URL of the song
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 歌曲的URL
- en: Player color/contrast options
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放器颜色/对比度选项
- en: Is playing, to tell whether the player is playing or not
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否正在播放，以判断播放器是否正在播放
- en: Play on load, to tell whether the player should start playing as soon as the
    player loads
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载时播放，以判断播放器是否应在加载时开始播放
- en: Show or hide playlist
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示或隐藏播放列表
- en: 'And the uncommon ones could be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不常见的例子可能如下：
- en: Player size could be set to large, medium, or small
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放器大小可以设置为大型、中型或小型
- en: Bottom sticky or top sticky, just like `Soundcloud` does
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部粘性或顶部粘性，就像 `Soundcloud` 一样
- en: Like or dislike song
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 喜欢或不喜欢歌曲
- en: Knowing these attributes and being able to implement them plays a very important
    role in creating a reusable component. A user looking for a music player with
    the ability to show liked or disliked songs will end up using the above-mentioned
    `<music-player>` component rather than something else.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些属性并能够实现它们在创建可重用组件中起着非常重要的作用。一个寻找具有显示喜欢或不喜欢歌曲功能的音乐播放器的用户最终会使用上面提到的 `<music-player>`
    组件而不是其他东西。
- en: The concept of reusability can be and should be applied to all the Web Components.
    It not only allows the Web Component to be used in more scenarios, it also makes
    it more maintainable, since we are making sure that it works in more scenarios.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用性的概念可以也应该应用到所有 Web 组件中。这不仅允许 Web 组件在更多场景中使用，还使得它更容易维护，因为我们确保它在更多场景中都能正常工作。
- en: Responsive Web Components
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式 Web 组件
- en: In the last chapter, we talked about adding styles to our Web Component to make
    it look beautiful. This time, we will take a look at it from a reusability perspective.
    What if a person who is trying to reuse our Web Component decides to use it in
    an inline tag, or what if the Web Component is used as a full-width component?
    Let us look into how our Web Component would be displayed inside different box
    models and how it would look on different screen sizes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了为我们的 Web 组件添加样式以使其看起来更美观。这次，我们将从可重用性的角度来探讨。如果试图重用我们的 Web 组件的人决定将其用于内联标签，或者如果
    Web 组件被用作全宽组件，会发生什么？让我们看看我们的 Web 组件在不同盒模型中的显示方式以及它在不同屏幕尺寸下的外观。
- en: Building <profile-info> Web Component
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 `<profile-info>` Web 组件
- en: Let us take a look at an example Web Component. Let's say we have a Web Component
    called `<profile-info>`. And the purpose of this Web Component is to show information
    about an employee. The information could be name, designation, ID number, profile
    picture, and a card background color to state whether the employee is a full-time
    employee, a part-time employee, or a contractor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例 Web 组件。假设我们有一个名为 `<profile-info>` 的 Web 组件。这个 Web 组件的目的是显示员工的信息。这些信息可能包括姓名、职位、ID
    号码、个人照片以及表示员工是全职员工、兼职员工还是承包商的卡片背景颜色。
- en: 'The HTML structure for this `<profile-info>` component would look something
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `<profile-info>` 组件的 HTML 结构看起来可能像这样：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the list of attributes, we can see that it needs a name, designation, ID
    number, picture link, and employee type. This is what it needs to do in terms
    of functionality. In terms of look and feel, it needs to look like a card with
    rounded profile picture, along with all the remaining information. And based on
    the resolution of the screen, it needs be either full-width, or if the screen
    is that of a mobile device, it should be shown in the form of a card.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从属性列表中，我们可以看到它需要一个名称、职位、ID 号码、图片链接和员工类型。这就是它在功能方面需要做的事情。在外观和感觉方面，它需要看起来像一张带有圆形个人照片的卡片，以及所有其他剩余信息。并且根据屏幕分辨率，它应该是全宽的，或者如果屏幕是移动设备，它应该以卡片的形式显示。
- en: 'Let''s do a mobile first approach on the Web Component, and start writing the
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Web 组件上采用移动优先的方法，并开始编写代码：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the most basic part that we have covered in the previous chapters. We
    are simply creating the component skeleton and making sure that the HTML for the
    shadow DOM is retrieved from the `getTemplate()` method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在前几章中介绍的最基本的部分。我们只是在创建组件骨架并确保从 `getTemplate()` 方法检索到 shadow DOM 的 HTML。
- en: 'For the mobile view, the card should look something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动视图，卡片应该看起来像这样：
- en: '![](img/5d250889-7a41-43d8-84b9-8cabcf4e6ea2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d250889-7a41-43d8-84b9-8cabcf4e6ea2.png)'
- en: 'The HTML structure would look something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 结构看起来可能像这样：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you take a look at the class names, they are all using BEM patterns.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看类名，它们都在使用 BEM 模式。
- en: If you have no idea as to what BEM is, the full form of BEM is Block Element
    Modifier. It is a methodology of using logical and reusable CSS classes for modular
    HTML blocks. If you would like to look into it, feel free to look at the following
    link: [http://getbem.com/](http://getbem.com/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道 BEM 是什么，BEM 的全称是 Block Element Modifier。它是一种使用逻辑和可重用 CSS 类的方法，用于模块化 HTML
    块。如果你想了解更多，请随时查看以下链接：[http://getbem.com/](http://getbem.com/)。
- en: 'Now, let us take a look at the CSS required to build this card. I am wrapping
    the CSS inside another method called `getStyles()` and then I am including it
    inside the `getTemplate()` method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构建这个卡片所需的 CSS。我将 CSS 包装在另一个名为 `getStyles()` 的方法中，然后将其包含在 `getTemplate()`
    方法中：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And let''s add the `getStyle()` method to the `getTemplate()` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `getTemplate()` 方法中添加 `getStyle()` 方法：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you look inside the `getStyles()` method, we have these classes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看 `getStyles()` 方法，我们有这些类：
- en: '`:host(.profile-info__emp-type-ft)`,'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:host(.profile-info__emp-type-ft)`,'
- en: '`:host(.profile-info__emp-type-pt)`, and'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:host(.profile-info__emp-type-pt)`, 和'
- en: '`:host(.profile-info__emp-type-ct)`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:host(.profile-info__emp-type-ct)`.'
- en: These change the color of the card on the basis of employee type, that is, full-time,
    part-time, or contractor, respectively.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些根据员工类型（即全职、兼职或承包商）分别更改卡片的颜色。
- en: 'But we still have no way to add these classes, so we create a new function
    called `updateCardBackground()` that will be responsible for adding the associated
    class to the Web Component. And then we will call this class inside the `render()`
    method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然没有办法添加这些类，因此我们创建了一个新的函数 `updateCardBackground()`，它将负责将相关类添加到 Web 组件中。然后我们将在
    `render()` 方法中调用这个类：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is doing nothing but getting the employee type from the attribute and then
    adding it to the class name of the host.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是在获取员工类型并将其添加到宿主类的名称中。
- en: So if the employee is full-time, then the class becomes `.profile-info__emp-type-ft`;
    if the employee is part-time, then the class becomes `.profile-info__emp-type-pt`;
    and if the employee is a contractor, the class becomes `.profile-info__emp-type-ct`.
    Notice how it is grabbing the employee type from the attribute and appending it
    to the end of the string `.profile-info__emp-type-`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果员工是全职，则类变为 `.profile-info__emp-type-ft`；如果员工是兼职，则类变为 `.profile-info__emp-type-pt`；如果员工是承包商，则类变为
    `.profile-info__emp-type-ct`。注意它如何从属性中获取员工类型并将其附加到字符串 `.profile-info__emp-type-`
    的末尾。
- en: 'Now that we are done with creating the component and styling it, let''s add
    the CSS for larger screens, say tablet and desktop. For the sake of simplicity,
    we will use the same CSS for desktop and tablet. So, let''s add the following
    CSS to our `getStyles()` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了组件的创建和样式设置，让我们添加用于更大屏幕的 CSS，比如平板电脑和桌面。为了简单起见，我们将为桌面和平板电脑使用相同的 CSS。所以，让我们将以下
    CSS 添加到我们的 `getStyles()` 方法中：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This makes sure that the Web Component looks like it''s from a contact book,
    the way we see on desktops. And it will show up only when the screen size is more
    than `650px`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了 Web 组件看起来像是从联系人簿中来的，就像我们在桌面上看到的那样。并且它只会在屏幕尺寸超过 `650px` 时显示：
- en: '![](img/6c1cdbbf-2229-4c29-b775-83d8518fc7a4.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c1cdbbf-2229-4c29-b775-83d8518fc7a4.png)'
- en: If you are building the Web Component along with this tutorial, try changing
    the width of the screen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在与这个教程一起构建 Web 组件，请尝试更改屏幕宽度。
- en: You can use a similar approach with any of the Web Components and make sure
    that it looks good when moved from one screen size to another.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似的方法处理任何 Web 组件，并确保它在从一种屏幕尺寸移动到另一种屏幕尺寸时看起来很好。
- en: Publishing Web Components
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布 Web 组件
- en: If you are developing a Web Component, whether it is for a company, a side project
    or something that is open source and publicly available, you can make it available
    for use by other people or team members very easily by publishing your Web Component
    on the web.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在为公司、副项目还是开源项目开发 Web 组件，您都可以通过在网络上发布您的 Web 组件，非常容易地使其可供其他人或团队成员使用。
- en: 'But even before you can publish, you need to make sure that the following steps
    are completed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但在您发布之前，您需要确保以下步骤已完成：
- en: Your component can be installed via `npm`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的组件可以通过 `npm` 进行安装
- en: A proper README file is present in the repository of your component with steps
    to use and attributes that can be changed
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的组件存储库中有一个适当的 README 文件，其中包含使用步骤和可以更改的属性
- en: A demo folder of a working example with `index.html` file
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 `index.html` 文件的示例工作文件夹
- en: 'Let''s prepare our file for `npm`. In order to do that, let''s do a quick `npm
    init` inside the `repo` directory with the help of a terminal. I am going to do
    it with the `<profile-info>` component that we discussed in the previous section.
    That will generate a `package.json` file that looks something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `npm` 准备我们的文件。为此，让我们在 `repo` 目录中使用终端快速执行 `npm init`。我将使用我们在上一节中讨论的 `<profile-info>`
    组件。这将生成一个类似这样的 `package.json` 文件：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will then create a `ReadMe.md` file in our component directory. And add
    the following text at the top:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在组件目录中创建一个 `ReadMe.md` 文件。并在顶部添加以下文本：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I added mine with the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了以下内容：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will create a published on webcomponents.org site badge that can be viewed
    by people visiting your GitHub or GitLab page. And it looks something like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 webcomponents.org 网站上创建一个发布徽章，供访问你的 GitHub 或 GitLab 页面的人查看。它看起来像这样：
- en: '![](img/bc661f12-04a0-4af5-929b-afff7243dc56.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc661f12-04a0-4af5-929b-afff7243dc56.png)'
- en: Once this is done, we can set up our `Readme.md` file for a demo section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以设置我们的 `Readme.md` 文件以创建一个演示部分。
- en: 'You can add to the `Readme.md` file about the attributes, and how it can be
    used as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `Readme.md` 文件中添加有关属性的信息，以及如何使用它，如下所示：
- en: '[PRE12]html'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]html'
- en: <profile-info
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <profile-info
- en: name="John Doe"
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: name="John Doe"
- en: designation="Frontend Engineer - Marketing"
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: designation="Frontend Engineer - Marketing"
- en: id-number="PRC-1455"
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: id-number="PRC-1455"
- en: picture-src="img/john-doe.png"
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: picture-src="img/john-doe.png"
- en: employee-type="ft">
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: employee-type="ft">
- en: </profile-info>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: </profile-info>
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you are ready to publish your Web Component on to the NPM JS site. Just
    type `npm publish` and it will push your code onto the site.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好在 NPM JS 网站上发布你的 Web 组件了。只需输入 `npm publish`，它就会将你的代码推送到网站。
- en: You can find the `<profile-info>` Web Component here at [https://www.npmjs.com/package/profile-info:](https://www.npmjs.com/package/profile-info)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.npmjs.com/package/profile-info:](https://www.npmjs.com/package/profile-info)找到这个
    `<profile-info>` Web 组件。
- en: '![](img/fb14233f-c25c-43e2-8d1b-2499fae8c7b9.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb14233f-c25c-43e2-8d1b-2499fae8c7b9.png)'
- en: 'Once you are done with this, you can simply go to [https://www.webcomponents.org/publish](https://www.webcomponents.org/publish) and
    scroll down to the section where it says Ready To Publish?, and simply put your
    npm package name and click on the Publish button:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你可以简单地访问[https://www.webcomponents.org/publish](https://www.webcomponents.org/publish)，滚动到“Ready
    To Publish?”部分，然后输入你的 npm 包名并点击发布按钮：
- en: '![](img/7303accc-908e-485a-ad10-0ebf72a44249.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7303accc-908e-485a-ad10-0ebf72a44249.png)'
- en: This will publish your Web Component, which can be used by anyone. Now your
    component is available to be distributed across the web.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发布你的 Web 组件，任何人都可以使用。现在你的组件可以在整个网络中分发。
- en: Extending Web Components – slots
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Web 组件 – 插槽
- en: 'Till now, we have used Web Components with no HTML content inside them. That
    is, when we import an HTML tag for a Web Component that we created, we have never
    placed any other HTML tag inside it, for example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的是没有 HTML 内容的 Web 组件。也就是说，当我们导入我们创建的 Web 组件的 HTML 标签时，我们从未在它里面放置任何其他
    HTML 标签，例如：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a huge limitation on the Web Component that we are creating. In
    the `<custom header>` component, we failed to add dynamic links. You can argue
    that we can place link data in the form of attributes and then we can run a loop
    inside our component definition and build the links. But what if we want a button
    instead of links? What if we want to show user points instead of the button? So,
    not being able to do these things is a limitation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们正在创建的 Web 组件造成了巨大的限制。在 `<custom header>` 组件中，我们未能添加动态链接。你可以争论说，我们可以将链接数据以属性的形式放置，然后我们可以在组件定义内部运行循环来构建链接。但如果我们想用按钮而不是链接呢？如果我们想显示用户积分而不是按钮呢？所以，不能做这些事情是一个限制。
- en: In this section, we will extend our current knowledge of Web Components and
    use the concept of slots to put HTML content inside our Web Components. A slot
    is a placeholder for any HTML markup that can be placed inside a Web Component.
    A slot can have a name, and this slot can have HTML or plain text that can be
    used inside our component.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将扩展我们对 Web 组件的知识，并使用插槽的概念将 HTML 内容放入我们的 Web 组件中。插槽是任何可以放置在 Web 组件内部的
    HTML 标记的占位符。插槽可以有一个名称，并且这个插槽可以包含 HTML 或纯文本，这些可以在我们的组件中使用。
- en: 'We will start with the Web Component that we have already worked on, `<company-header>`.
    The `getTemplate()` method of this component is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们已经工作的 Web 组件 `<company-header>` 开始。该组件的 `getTemplate()` 方法如下：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we can see that there are two links, `Home` and `About
    Us`. If we want to add one more link to this, we will need to modify the definition
    of the Web Component, which will in turn create problems with maintaining it and
    we will have to create a new version of it every time we want to add a new link.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到有两个链接，“Home”和“About Us”。如果我们想添加另一个链接，我们需要修改 Web 组件的定义，这反过来又会给维护带来问题，并且每次我们想要添加新链接时，我们都必须创建一个新的版本。
- en: 'In order to solve this problem, we will use slots. We will replace that whole
    `div` that contains the links with a slot of name `other-links`. Let''s take a
    look at the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将使用槽位。我们将用名为 `other-links` 的槽位替换包含链接的整个 `div`。让我们看看代码：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This way, we can create a slot that can be filled when we use the Web Component:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以创建一个槽位，当我们使用 Web 组件时可以填充它：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And here, we are filling the slot with a `<ul>` tag that has a `slot` attribute
    with a value `other-links`. You can have any HTML you want inside this slot. You
    can even replace it with plain text.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用具有 `slot` 属性且值为 `other-links` 的 `<ul>` 标签填充槽位。你可以在该槽位内放置任何 HTML。你甚至可以用纯文本替换它。
- en: In a Web Component, there can be any number of slots. It totally depends on
    your use case. But, let us take a look at another example, where we use three
    slots.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 组件中可以有任意数量的槽位。这完全取决于你的用例。但，让我们看看另一个例子，其中我们使用了三个槽位。
- en: Creating <my-article> Web Component
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 <my-article> Web 组件
- en: 'Let''s create a Web Component called `<my-article>` that has three slots: `author`,
    `article-heading`, and `article`. The definition of the Web Component is as follows
    starting with the template:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `<my-article>` 的 Web 组件，它有三个槽位：`author`、`article-heading` 和 `article`。Web
    组件的定义如下，从模板开始：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, there are three slots. One for heading, one for author name,
    and one for content. The `getStyle()` method looks something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有三个槽位。一个用于标题，一个用于作者姓名，一个用于内容。`getStyle()` 方法看起来像这样：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And when we try to use it, it looks something like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用它时，它看起来像这样：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can of course change the order of the slots while calling the `<my-article>`
    tag and it will still work as per the definition. The output will look something
    like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以在调用 `<my-article>` 标签时改变槽位的顺序，它仍然会按照定义工作。输出将看起来像这样：
- en: '![](img/cc21c5c7-20f5-4976-82cb-475a0cbc8d67.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc21c5c7-20f5-4976-82cb-475a0cbc8d67.png)'
- en: As you can see, we do not have to worry about the look and feel of the content,
    as long as the classes inside the Web Component are taking care of the styling.
    This also shows that it is up to the user to use any number of slots.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不必担心内容的样式，只要 Web 组件内部的类负责样式即可。这也表明，使用多少个槽位取决于用户。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about reusability and how we can make sure that our
    Web Component is as reusable as possible. We even looked at how responsiveness
    can be incorporated inside a Web Component for maximum reuse.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了可重用性以及如何确保我们的 Web 组件尽可能可重用。我们还探讨了如何将响应性融入 Web 组件以实现最大重用。
- en: We learned how to publish our Web Component on the internet as well as a new
    way of letting dynamic content inside a Web Component with the help of slots.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在互联网上发布我们的 Web 组件，以及使用槽位让动态内容进入 Web 组件的新方法。
- en: In the next chapter, we will look into state management, attributes, and how
    event handling works in a Web Component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨状态管理、属性以及事件处理在 Web 组件中的工作方式。
