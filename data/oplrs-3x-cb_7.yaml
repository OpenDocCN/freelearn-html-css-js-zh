- en: Chapter 7. Styling Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。样式化特征
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Styling features using symbolizers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号化器对特征进行样式化
- en: Improving style using StyleMap and the replacement of the feature's attributes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用StyleMap和替换特征属性来改进样式
- en: Playing with StyleMap and the render intents
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转StyleMap和渲染意图
- en: Working with unique value rules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用唯一值规则进行工作
- en: Defining custom rules to style features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自定义规则以样式化特征
- en: Styling clustered features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式化聚合特征
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Once we know how to work with vector layers, such as adding new features or
    modifying the existing ones, the question we can have in mind is: how to style
    them?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何处理矢量图层，例如添加新特征或修改现有特征，我们可能会想到的问题就是：如何对它们进行样式化？
- en: The visual representation of features, the **style**, is one of the most important
    concepts in GIS applications. It is not only important from the user's experience
    or designer's perspective but also as an information requirement, for example,
    to identify features that match certain rules.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 特征的视觉表示，即**样式**，是GIS应用中最重要的概念之一。它不仅从用户体验或设计师的角度来看很重要，而且作为信息需求也很重要，例如，用于识别符合某些规则的特征。
- en: The way we visualize features is not only important to make our application
    much more attractive, but also to improve the way we bring information to the
    user. For example, given a set of points that represent some temperatures, if
    we are interested on the hottest zones, we could represent them with different
    radius and color values. This way, a lesser radius and a color near to blue means
    a cold zone while a greater radius and a color near to red means a hot zone.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可视化特征的方式不仅对我们使应用程序更具吸引力很重要，而且也有助于改善我们向用户传达信息的方式。例如，给定一组代表某些温度的点，如果我们对最热的区域感兴趣，我们可以用不同的半径和颜色值来表示它们。这样，较小的半径和接近蓝色的颜色意味着冷区，而较大的半径和接近红色的颜色意味着热区。
- en: OpenLayers offers us a great degree of flexibility when styling features that
    can initially seem a bit complex. Concepts such as symbolizers, StyleMap, rules,
    or filters are all related with the process of styling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers在样式化特征方面提供了很高的灵活性，这最初可能看起来有点复杂。例如，符号化器、StyleMap、规则或过滤器等概念都与样式化过程相关。
- en: Let's see all this in the following recipes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下菜谱中的所有这些内容。
- en: Styling features using symbolizers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用符号化器对特征进行样式化
- en: 'To see the most basic form of styling a feature, we are going to create a little
    map editor that allows adding new features by specifying some few style properties:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看样式化特征的最低形式，我们将创建一个小型地图编辑器，允许通过指定一些样式属性来添加新特征：
- en: '![Styling features using symbolizers](img/7843_07_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用符号化器对特征进行样式化](img/7843_07_01.jpg)'
- en: 'Each `OpenLayers.Feature.Vector` instance can have a style associated with
    it. This style is called **symbolizer**, which is nothing more than a JavaScript
    object with some fields that specify the fill color, stroke, and so on. For example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`OpenLayers.Feature.Vector`实例都可以与其关联一个样式。这个样式被称为**符号化器**，它只是一个具有一些字段的JavaScript对象，这些字段指定了填充颜色、描边等。例如：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the code, every time a feature is going to be added to the map, the code
    will get the fill and stroke properties from the controls on the left-hand side
    and will create a new symbolizer hash to be used by the new feature.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，每次要向地图添加特征时，代码将从左侧的控件中获取填充和描边属性，并为新特征创建一个新的符号化器哈希值。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code has two main sections, one for HTML, where all the controls
    are placed, and a second one for the JavaScript code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码有两个主要部分，一个用于HTML，其中放置了所有控件，另一个用于JavaScript代码。
- en: The HTML section has plenty of codes related with the controls used to select
    the fill and stroke properties. These controls come from the Dojo Toolkit project
    ([http://dojotoolkit.org](http://dojotoolkit.org)) and because they are not the
    goal of this recipe, we have not covered it here. We encourage the reader to take
    a look at it in the code bundle of the book.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HTML部分包含大量与选择填充和描边属性相关的代码。这些控件来自Dojo Toolkit项目([http://dojotoolkit.org](http://dojotoolkit.org))，因为它们不是本菜谱的目标，所以我们没有在这里介绍。我们鼓励读者查看本书的代码包。
- en: Let's see the JavaScript code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看JavaScript代码。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'After creating the HTML file including OpenLayers dependencies (see the *Getting
    ready* section for the HTML code), create the `map` instance in the `div` element
    identified by `ch07_using_symbolizers` and add a base layer:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建包含 OpenLayers 依赖项的 HTML 文件（参见 *准备就绪* 部分中的 HTML 代码）后，在 `div` 元素中创建 `map` 实例，其标识符为
    `ch07_using_symbolizers`，并添加一个基本图层：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, add a vector layer where new features will be placed:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个矢量层，其中将放置新特征：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the `OpenLayers.Control.EditingToolbar` control that allows to add new
    features to the previous vector layer:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `OpenLayers.Control.EditingToolbar` 控件，允许向之前的矢量层添加新特征：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the code responsible, to get and apply the style to the new features:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加负责获取并应用于新特征的样式的代码：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The idea is, each time a feature is added to the layer using the EditingToolbar
    control, create a symbolizer and apply it to the new feature.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，每次使用 EditingToolbar 控件将特征添加到图层时，创建一个符号化器并将其应用于新特征。
- en: 'The first step is to register a `beforefeatureadded` event listener in the
    vector layer so that we are notified each time a new feature is going to be added:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在矢量层中注册一个 `beforefeatureadded` 事件监听器，以便我们能在每次新特征即将添加时得到通知：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function `setFeatureStyle` is called every time a new feature is added.
    An `event` parameter is passed on each call, pointing to the feature to be added
    (`event.feature`) and a reference to the vector layer (`event.object`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每次添加新特征时都会调用 `setFeatureStyle` 函数。每次调用都会传递一个 `event` 参数，指向要添加的特征（`event.feature`）和矢量层的引用（`event.object`）。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `event.object` references the object passed as the `object` parameter in
    the `event.register(event_type, object, listener)` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`event.object` 引用了在 `event.register(event_type, object, listener)` 方法中作为 `object`
    参数传递的对象。'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we obtain the property values from the Dojo widgets, we create a new symbolizer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从 Dojo 小部件中获取属性值，我们就创建一个新的符号化器。
- en: The `OpenLayers.Feature.Vector` class defines some style symbolizers in the
    `style` array property, so the quickest way is to create a copy of one of those
    styles (actually we have extended it) and then modify some of its properties.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Feature.Vector` 类在 `style` 数组属性中定义了一些样式符号化器，因此最快的方式是复制其中之一（实际上我们已经扩展了它），然后修改其一些属性。'
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The question that can arise here is: what takes precedence when styling, a
    rule applied to a vector layer or a symbolizer applied to a single feature?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可能出现的疑问是：在样式化时，是应用于矢量层的规则优先，还是应用于单个特征的符号化器优先？
- en: 'The answer is: styles goes from bottom to top, that is, if we have specified
    a symbolizer in a feature then it will be used to render it, otherwise, any rule
    or StyleMap assigned to the vector layer will be applied to its features.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：样式从下到上应用，也就是说，如果我们在一个特征中指定了符号化器，则它将被用来渲染它，否则，任何分配给矢量层的规则或 StyleMap 都将应用于其特征。
- en: See also
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Improving style using StyleMap and the replacement of feature's attributes*
    recipe
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 StyleMap 和替换特征属性改进样式* 的配方'
- en: The *Playing with StyleMap and the render intents* recipe
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*玩转 StyleMap 和渲染意图* 的配方'
- en: Improving style using StyleMap and the replacement of feature's attributes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 StyleMap 和替换特征属性改进样式
- en: We can summarize that there are two ways to style a feature. The first is applying
    a symbolizer hash directly to the feature (see the *Styling features using symbolizers*
    recipe). The second is applying the style to the layer so every feature contained
    in it becomes styled.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结说，有三种方式来样式化一个特征。第一种是直接将符号化器散列应用于特征（参见 *使用符号化器样式化特征* 配方）。第二种是将样式应用于图层，使得其中的每个特征都变得样式化。
- en: The second one is the preferred way in many situations. It is a generic way
    to style all the features in a layer by setting some styles and rules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，第二种方法是首选的。这是一种通用的方式，通过设置一些样式和规则来样式化图层中的所有特征。
- en: 'This recipe shows how we can use the `StyleMap` instances and how easily we
    can style all the points of a layer without applying a style on each feature.
    The output of this recipe should look similar to the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了我们如何使用 `StyleMap` 实例，以及我们如何轻松地样式化图层中的所有点，而无需对每个特征应用样式。此配方的输出应类似于以下截图：
- en: '![Improving style using StyleMap and the replacement of feature''s attributes](img/7843_07_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![使用 StyleMap 和替换特征属性改进样式](img/7843_07_02.jpg)'
- en: In addition, the technique we will use allows us to involve the feature's attributes
    to select a point radius and color, creating them all together more dynamically.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用的技巧允许我们涉及特征的属性来选择点半径和颜色，更动态地创建它们所有。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once we have created the HTML file with OpenLayers dependencies, start creating
    the `div` element that will hold the map instance:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了包含 OpenLayers 依赖项的 HTML 文件，就开始创建将包含地图实例的 `div` 元素：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, create the map instance and add a base layer:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建地图实例并添加一个基本图层：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s start defining the style for the whole layer. First create a color
    palette for the points:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始定义整个图层的样式。首先为点创建一个调色板：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a style instance from a previous symbolizer hash:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从之前的符号化器哈希创建一个样式实例：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a vector layer applying the desired `StyleMap:`
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用所需的 `StyleMap` 创建矢量图层：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, create some random points. Each feature will have two attributes `radius`
    and `temp` with random values:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一些随机点。每个特征将有两个属性 `radius` 和 `temp`，它们具有随机值：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's go to describe first the random point features we have added to the vector
    layer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来描述首先添加到矢量图层中的随机点特征。
- en: 'The idea is to create some random points at random places. Because of this,
    we create some random x-y values, transform to map coordinates, create geometry,
    and finally create a feature with that geometry:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是在随机位置创建一些随机点。正因为如此，我们创建了一些随机的 x-y 值，将它们转换为地图坐标，创建几何形状，最后创建一个具有该几何形状的特征：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In addition, we are setting in each feature, a couple of attributes `(radius`
    and `temp)` with random values:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在每个特征中设置了一对具有随机值的属性（`radius` 和 `temp`）：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These attributes will be used later in the feature's style definition.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性将在特征样式定义中稍后使用。
- en: Let's go to describe the creation of the style for the vector layer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来描述矢量图层样式的创建。
- en: We want each feature to be represented as a point using the attribute `radius`
    for the point's radius and the `temp` attribute for the point's color.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个特征都使用属性 `radius` 作为点的半径和 `temp` 属性作为点的颜色来表示。
- en: The first step is to create a symbolizer by hash copying (actually extending)
    that is defined at `OpenLayers.Feature.Vector.style["default"])`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个通过哈希复制（实际上扩展）的符号化器，它在 `OpenLayers.Feature.Vector.style["default"])`
    中定义。
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you look at the source code you will find that `OpenLayers.Feature.Vector.style["default"])`
    is defined as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看源代码，你会发现 `OpenLayers.Feature.Vector.style["default"])` 被定义为：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once we have a fresh copy of the symbolizer, we change the `fillColor` and `pointRadius`
    properties. What is the challenge here? Well, we do not want fixed values for
    these properties, we want these properties to take their values from the feature's
    attributes they are styling.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个新的符号化器副本，我们就更改 `fillColor` 和 `pointRadius` 属性。这里的挑战是什么？嗯，我们不想为这些属性使用固定值，我们希望这些属性从它们所修饰的特征的属性中获取它们的值。
- en: 'Fortunately, OpenLayers helps us with the **attribute replacement** syntax.
    In the same way, we can write a literal value as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，OpenLayers 帮助我们使用 **属性替换** 语法。同样，我们可以按如下方式写入一个字面值：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can specify that the radius value must come from the feature''s `featureRadius`
    attribute:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定半径值必须来自特征的 `featureRadius` 属性：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So in our sample, our features have the attribute `radius` defined as a random
    value that can be used here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的示例中，我们的特征具有属性 `radius`，定义为可以在此处使用的随机值：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the same way as we can use an attribute to be replaced as the property value,
    we can also set a function which must return the value to be used as the property
    value. This is the case for the `fillColor` property:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们可以使用一个属性作为属性值替换一样，我们也可以设置一个必须返回用作属性值的值的函数。这是 `fillColor` 属性的情况：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we will see next, the function `colorFunction` returns a value depending
    on the feature's `temp` attribute, that is, we do not want to use the `temp` attribute
    directly but a value computed from it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们接下来将要看到的，函数 `colorFunction` 返回一个值，这个值取决于特征的 `temp` 属性，也就是说，我们不想直接使用 `temp`
    属性，而想使用从它计算出的值。
- en: Unfortunately, attribute replacement cannot be used directly in a symbolizer
    hash applied to a feature or layer, it only works through an `OpenLayers.Style`
    instance. In addition, thanks to the `OpenLayers.Style` instance, we can define
    the functions, such as `colorFunction` to be used to compute a style property
    value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，属性替换不能直接在应用于特征或图层的符号化哈希中直接使用，它只能通过 `OpenLayers.Style` 实例使用。此外，多亏了 `OpenLayers.Style`
    实例，我们可以定义函数，例如 `colorFunction`，用于计算样式属性值。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Attribute replacement can only be used through an `OpenLayers.Style` instance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 属性替换只能通过 `OpenLayers.Style` 实例使用。
- en: 'In the recipe, once we define the symbolizer hash, we can create an instance
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱中，一旦我们定义了符号化哈希，我们就可以创建一个实例，如下所示：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first parameter is the symbolizer hash that has been previously defined,
    which makes use of the attribute's replacement feature. The second parameter,
    the `context`, is an object passed in the process of rendering features. Here
    we define the required functions, such as the `colorFunction` that will be available
    in the rendering process, and will define the value for the `fillColor` depending
    on the `temp` attribute of each feature.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是之前定义的符号化哈希，它使用了属性的替换功能。第二个参数，`context`，是在渲染特征的过程中传入的对象。在这里，我们定义了所需的函数，例如
    `colorFunction`，它将在渲染过程中可用，并将根据每个特征的 `temp` 属性定义 `fillColor` 的值。
- en: At this point, we are almost done. The only remaining thing is to create a vector
    layer that uses the defined `OpenLayers.Style` instance to style the features.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎完成了。唯一剩下的事情就是创建一个使用定义的 `OpenLayers.Style` 实例来样式化特征的向量层。
- en: 'The `OpenLayers.Layer.Vector` class has a `styleMap` property used to specify
    the styles to apply to the features. The `OpenLayers.StyleMap` class can be instantiated
    with passing a different argument, but here we are creating it using the previously
    defined `OpenLayers.Style` style:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Layer.Vector` 类有一个 `styleMap` 属性，用于指定应用于特征的样式。`OpenLayers.StyleMap`
    类可以通过传递不同的参数来实例化，但在这里我们使用之前定义的 `OpenLayers.Style` 样式来创建它：'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, our recipe is complete. As we can see, there is no need to create a symbolizer
    and apply it to each feature. The only thing we need to do is to define a style
    and assign it to the vector layer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的菜谱已经完成。正如我们所看到的，我们不需要为每个特征创建符号化并将其应用到每个特征上。我们唯一需要做的是定义一个样式并将其分配给向量层。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Playing with StyleMap and render intents* recipe
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*玩转 StyleMap 和渲染意图* 的菜谱'
- en: The *Styling features using symbolizers* recipe
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用符号化样式化特征* 的菜谱'
- en: The *Creating features programmatically* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章。处理向量层") 中 *Creating features programmatically* 的菜谱，*Vector
    Layers*'
- en: Playing with StyleMap and the render intents
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转 StyleMap 和渲染意图
- en: There are some controls, such as `SelectFeature, ModifyFeature`, or `EditingToolbar`,
    which change the style of the feature depending on its current state, that is,
    if it is selected or is currently being edited. How does OpenLayers manage this?
    The answer is, through the **render intents:**
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些控件，如 `SelectFeature`、`ModifyFeature` 或 `EditingToolbar`，根据特征当前的状态（即是否被选中或正在被编辑）改变特征的风格。OpenLayers
    如何管理这一点？答案是，通过 **渲染意图**：
- en: '![Playing with StyleMap and the render intents](img/7843_07_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![玩转 StyleMap 和渲染意图](img/7843_07_03.jpg)'
- en: This recipe shows how we can modify the styles used for each render intent to
    change the look of our applications.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了我们如何修改每个渲染意图所使用的样式，以改变我们应用程序的外观。
- en: This way, features will be drawn on the map using blue instead of orange. Temporary
    features, those that are going to be created, will be drawn using green. Finally,
    those features that are selected, or are in the middle of the modification process,
    will be drawn using orange.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，特征将以蓝色而不是橙色在地图上绘制。将要创建的临时特征将以绿色绘制。最后，那些被选中的特征，或者处于修改过程中的特征，将以橙色绘制。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new HTML file and add the OpenLayers dependencies. The first step
    is to add the `div` element to hold the map instance:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 HTML 文件并添加 OpenLayers 依赖项。第一步是添加 `div` 元素以容纳地图实例：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the JavaScript section, initialize the map instance, add a base layer, and
    center the viewport:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JavaScript 部分，初始化地图实例，添加基本图层，并定位视口：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we are going to create three different styles:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建三种不同的样式：
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After this, create a `StyleMap` instance that holds the three styles created
    as three different render intents:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个包含作为三个不同渲染意图创建的三个样式的 `StyleMap` 实例：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can create a vector layer using the previous `StyleMap` instance:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用之前的 `StyleMap` 实例创建一个矢量层：
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we are going to add some controls to the map to allow the addition
    of new features and modification of the existing ones:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将向地图添加一些控件，以允许添加新特征和修改现有特征：
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'Every vector layer can have an `OpenLayers.StyleMap` instance associated with
    it. On its own, a `StyleMap` instance stores one or more references to the `OpenLayers.Style`
    instances, each one of which acts as a render intent:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矢量层都可以与一个 `OpenLayers.StyleMap` 实例相关联。单独的 `StyleMap` 实例存储一个或多个对 `OpenLayers.Style`
    实例的引用，每个实例都充当一个渲染意图：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Every `Style` instance stores information about a style, and usually they are
    created from a symbolizer hash, as in this recipe:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Style` 实例存储有关样式的信息，通常它们是从符号化哈希创建的，如本食谱中所示：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here we have defined a new style for the three render intents: `default, select`,
    and `temporary`, which are well known render intents used by most of the controls.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为三种渲染意图定义了新的样式：`default`、`select` 和 `temporary`，这些是大多数控件使用的已知渲染意图。
- en: A `StyleMap` can store as many render intents as we desire, we are not limited
    to these three commonly used render intents. For example, we can define render
    intents such as `red` or `hidden`, and associate a `Style` for them that renders
    features in red or not display them at all.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`StyleMap` 可以存储我们想要的任意多的渲染意图，我们并不局限于这三种常用的渲染意图。例如，我们可以定义如 `red` 或 `hidden`
    这样的渲染意图，并为它们关联一个 `Style`，使其以红色渲染特征或完全不显示。'
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By setting the property `display` to`"none"` on the style's symbolizer hash,
    we can hide features. This is usually used in the `delete` render intent.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在样式的符号化哈希中设置属性 `display` 为 `"none"`，我们可以隐藏特征。这通常用于 `delete` 渲染意图。
- en: The render intents such as `default, select`, and `temporary`, are used extensively
    by many components within OpenLayers. This way, when a feature is rendered, the
    `default` style is used. When a feature is selected using the `OpenLayers.Control.SelectFeature`
    control, the `select` render intent is used to render the features. And when we
    are creating a new feature with `OpenLayers.Control.EditingToolbar` (which internally
    uses `OpenLayers.Control.DrawFeature)`, the control renders the feature using
    the style defined on the `temporary` render intent.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`、`select` 和 `temporary` 这样的渲染意图在 OpenLayers 的许多组件中被广泛使用。这样，当特征被渲染时，使用
    `default` 样式。当使用 `OpenLayers.Control.SelectFeature` 控件选择特征时，使用 `select` 渲染意图来渲染特征。当我们使用
    `OpenLayers.Control.EditingToolbar`（内部使用 `OpenLayers.Control.DrawFeature`）创建新特征时，控件使用在
    `temporary` 渲染意图上定义的样式来渲染特征。'
- en: So, creating new render intents is no problem. In addition, we can create our
    custom controls and let them decide which render intent the layer must use to
    render the features.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建新的渲染意图没有问题。此外，我们可以创建我们自己的自定义控件，并让它们决定图层必须使用哪种渲染意图来渲染特征。
- en: Finally, let's briefly describe the code used to create the panel with the controls.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要描述一下创建带有控制面板的代码。
- en: 'First, we have created an `OpenLayers.Control.EditingToolbar` instance:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个 `OpenLayers.Control.EditingToolbar` 实例：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is an `OpenLayers.Control.Panel` control containing buttons that activates/deactivates
    some `OpenLayers.Control.DrawFeature` controls. Next, we have created an `OpenLayers.ControlModifyFeature`
    instance, which is a single control and we have added it to the EditingToolbar
    control so that it becomes visible as a new button:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含激活/停用一些 `OpenLayers.Control.DrawFeature` 控件的按钮的 `OpenLayers.Control.Panel`
    控件。接下来，我们创建了一个 `OpenLayers.ControlModifyFeature` 实例，这是一个单独的控件，我们将其添加到 EditingToolbar
    控件中，使其作为一个新按钮可见：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![How it works...](img/7843_07_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/7843_07_04.jpg)'
- en: In the screenshot, the `ModifyFeature` control is represented by the cross icon.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图上，`ModifyFeature` 控件由交叉图标表示。
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The process to style and render a feature is complex. The following lines summarize
    the main steps involved in the feature styling process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 样式化和渲染一个特征的流程是复杂的。以下行总结了特征样式化过程中涉及的主要步骤。
- en: 'For each feature, a vector layer must render the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个特征，矢量层必须渲染以下内容：
- en: 'The method `OpenLayers.Layer.Vector.drawFeature(feature, style)` is called.
    It accepts two parameters: the `feature` to be drawn and the `style` to be used.
    It can be a symbolizer or a render intent string.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方法 `OpenLayers.Layer.Vector.drawFeature(feature, style)`。它接受两个参数：要绘制的 `feature`
    和要使用的 `style`。它可以是符号化器或渲染意图字符串。
- en: If the feature has a `style` property, it is used to render the feature.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要素有一个 `style` 属性，它将用于渲染要素。
- en: Otherwise, if the vector layer has a `style` property, it is used to render
    the feature.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果矢量层有一个 `style` 属性，它将用于渲染要素。
- en: Otherwise, if the `style` argument is provided and it is a style symbolizer,
    then it is used to render the feature.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果提供了 `style` 参数，并且它是一个样式符号化器，那么它将用于渲染要素。
- en: If the `style` is a render intent string, then a symbolizer is created from
    the `Style` property associated to the render intent using the `createSymbolizer`
    method. This is where feature attributes are merged within the symbolizer.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `style` 是一个渲染意图字符串，那么将使用 `createSymbolizer` 方法从与渲染意图关联的 `Style` 属性创建一个符号化器。这是在符号化器内合并要素属性的地方。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Styling features using symbolizers* recipe
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号化器的 *风格化要素* 菜谱
- en: The *Improving style using StyleMap and the replacement of feature's attributes*
    recipe
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 StyleMap 和替换要素属性来改进样式* 菜谱'
- en: Working with unique value rules
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用唯一值规则工作
- en: Usually, we do not only style features by what they represent, for example a
    city or a village, but we style depending on their attributes, such as the number
    of citizens, year of foundation, and number of squares.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不仅根据要素所代表的内容来风格化要素，例如城市或村庄，我们还根据它们的属性来风格化，例如公民数量、成立年份和广场数量。
- en: To help on these cases, OpenLayers offers us the possibility to define rules
    to decide how to style features. For example, we can define a rule that for all
    features of a city with a population greater than 100,000 a point with radius
    20 and color brown can be rendered, while for cities with a population less than
    100,000, a point with radius 10, color orange, and semi transparent can be rendered.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助这些情况，OpenLayers 提供了我们定义规则以决定如何风格化要素的可能性。例如，我们可以定义一个规则，对于人口超过 100,000 的所有城市要素，可以渲染一个半径为
    20、颜色为棕色的点，而对于人口少于 100,000 的城市，可以渲染一个半径为 10、颜色为橙色、半透明的点。
- en: Beginning in the world of the rules, the concept of *unique value rules* are
    the simplest case we can find. The idea is simple, apply one style or another
    depending on the value of a feature's attribute.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从规则的世界开始，唯一值规则的概念是我们能找到的最简单的情况。这个想法很简单，根据要素属性的值应用一种样式或另一种样式。
- en: 'In this recipe, we are going to load a GeoJSON file, with some cities of the
    world, and apply a rule that will set the radius of the points depending on the
    popularity rank attribute (the `POP_RANK` attribute), as shown in the following
    screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将加载一个 GeoJSON 文件，包含世界上的一些城市，并应用一个规则，该规则将根据流行度排名属性（`POP_RANK` 属性）设置点的半径，如下面的截图所示：
- en: '![Working with unique value rules](img/7843_07_05.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![使用唯一值规则工作](img/7843_07_05.jpg)'
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Start creating a new HTML file and add the OpenLayers dependencies. Add a `div`
    element to hold the map instance:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建一个新的 HTML 文件，并添加 OpenLayers 依赖项。添加一个 `div` 元素来包含地图实例：
- en: '[PRE33]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Within the `script` element, add the required code to initialize the map and
    add a base layer:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `script` 元素中，添加初始化地图和添加基本层的所需代码：
- en: '[PRE34]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now define different styles to be used on the `POP_RANK` feature''s attribute:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义要在 `POP_RANK` 特征属性上使用的不同样式：
- en: '[PRE35]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a `StyleMap` instance and define a unique value rule:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `StyleMap` 实例并定义一个唯一值规则：
- en: '[PRE36]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, add a vector layer with some cities of the world and make use of the
    previous `StyleMap` instance:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个包含世界上一些城市的矢量层，并使用之前的 `StyleMap` 实例：
- en: '[PRE37]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Almost all the magic of this recipe resides in the `OpenLayers.StyleMap.addUniqueValueRules()`
    method. So, the sentence:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的大部分魔法都集中在 `OpenLayers.StyleMap.addUniqueValueRules()` 方法上。所以，这个句子：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: means, apply to the `default` render intent the specified `style` property,
    depending on the value of the `POP_RANK` attribute.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表示，根据 `POP_RANK` 属性的值，应用指定的 `style` 属性到 `default` 渲染意图。
- en: It makes more sense once we look at the hash style. Depending on the value of
    the `POP_RANK`, the radius of the points representing cities will vary between
    `4` and `21:`
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们查看哈希样式，它就更有意义了。根据 `POP_RANK` 的值，代表城市的点的半径将在 `4` 和 `21` 之间变化：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we have added to the map a vector layer that uses the previously created
    `StyleMap` instance where the unique value rules are defined:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在地图上添加了一个矢量层，该层使用之前创建的 `StyleMap` 实例，其中定义了唯一值规则：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In addition, the vector layer uses an `OpenLayers.Protocol.HTTP` instance to
    load the GeoJSON file and an `OpenLayers.Strategy.Fixed` instance is used to just
    load the source data once.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，矢量层使用 `OpenLayers.Protocol.HTTP` 实例来加载 GeoJSON 文件，并使用 `OpenLayers.Strategy.Fixed`
    实例仅加载一次源数据。
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The use of unique value rules through the `addUniqueValueRules()` method is
    easy, but as we can understand, it works only for a discrete value range.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `addUniqueValueRules()` 方法使用唯一值规则很简单，但正如我们所理解的，它只适用于离散值范围。
- en: Also, the flexibility is poor because it is equivalent to an *is equal* rule,
    where we have no way to map a range of values to the same style.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，灵活性较差，因为它相当于一个 *等于* 规则，我们无法将值范围映射到相同的样式。
- en: See also
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Playing with StyleMap and the render intents* recipe
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*玩转 StyleMap 和渲染意图* 菜谱'
- en: The *Defining custom rules to style features* recipe
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义自定义规则以样式化特征* 菜谱'
- en: The *Using point features as markers* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用点特征作为标记* 菜谱在 [第 3 章](ch03.html "第 3 章。处理矢量层")，*矢量层*'
- en: The *Working with popups* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章。处理矢量层")中的 *使用弹出窗口工作* 菜谱，*矢量层*'
- en: Defining custom rules to style features
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自定义规则以样式化特征
- en: We will see a brief explanation before continuing with this recipe. The goal,
    as in the other recipes in the chapter, is to style the features of a vector layer
    depending on their attributes' values or their kind of feature.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本菜谱之前，我们将简要解释一下。目标，就像本章中的其他菜谱一样，是根据特征的属性值或特征类型来样式化矢量层的特征。
- en: 'So, an `OpenLayers.Layer.Vector` layer class can have an `OpenLayers.StyleMap`
    instance associated with it, which determines the default style of the layers
    if it has only one `OpenLayers.Style`, or the set of styles that can be applied
    for each render intent if it contains more than one `OpenLayers.Style`. In its
    own way, each `OpenLayers.Style` instance can be used in two forms:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`OpenLayers.Layer.Vector` 层类可以与一个 `OpenLayers.StyleMap` 实例相关联，该实例确定如果只有一个
    `OpenLayers.Style`，则层的默认样式，或者如果包含多个 `OpenLayers.Style`，则可以应用于每个渲染意图的样式集。以自己的方式，每个
    `OpenLayers.Style` 实例都可以以两种形式使用：
- en: Having a symbolizer hash acting as the default style to apply to the features
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有作为应用于特征的默认样式的符号化器散列
- en: Having some `OpenLayers.Rule` instances associated with it
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与它关联一些 `OpenLayers.Rule` 实例
- en: Here we arrive to the main concept of this recipe, the **rules.**
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们来到了本菜谱的主要概念，即**规则**。
- en: A rule is nothing more than a join between a filter (concretely an `OpenLayers.Filter)`
    and a symbolizer, if the filter matches the feature then the symbolizer is applied.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 规则不过是一个过滤器（具体来说是 `OpenLayers.Filter`）和符号化器之间的连接，如果过滤器匹配特征，则应用符号化器。
- en: 'This simple thing gives us lot of flexibilities and power to style our features.
    In addition to the possibility to use symbolizers with attribute replacement,
    we can also use the set of filters OpenLayers offers us: comparison filters, spatial
    filters, or logical filters.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这简单的事情为我们提供了很多灵活性和样式化特征的强大功能。除了可以使用具有属性替换的符号化器之外，我们还可以使用 OpenLayers 提供的过滤器集合：比较过滤器、空间过滤器或逻辑过滤器。
- en: 'The goal of this recipe is to load a GML file with European countries and style
    them depending on their `AREA` attribute, as shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的目标是加载一个包含欧洲国家的 GML 文件，并根据它们的 `AREA` 属性对其进行样式化，如下面的截图所示：
- en: '![Defining custom rules to style features](img/7843_07_06.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![定义自定义规则以样式化特征](img/7843_07_06.jpg)'
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Once created an HTML file with the OpenLayers dependencies, add the `div` element
    to hold the map:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了包含 OpenLayers 依赖项的 HTML 文件，请添加 `div` 元素以容纳地图：
- en: '[PRE41]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the JavaScript code section, initialize the map, add OpenStreetMap as the
    base layer, and center the map at the desired place:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JavaScript 代码部分，初始化地图，将 OpenStreetMap 作为底图，并将地图中心定位在所需位置：
- en: '[PRE42]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, define five different rules to style elements based on the `AREA` attribute
    of the features. The following code has the rule to check if the value is less
    than 10,000:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义五个不同的规则，根据特征的 `AREA` 属性来样式化元素。以下代码包含检查值是否小于 10,000 的规则：
- en: '[PRE43]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following code has the rule to check if the value is between 10,000 and
    25,000:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码包含检查值是否在10,000到25,000之间的规则：
- en: '[PRE44]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The rule to check if the value is between 25,000 and 50,000:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查值是否在25,000到50,000之间的规则：
- en: '[PRE45]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The rule to check if the value is between 50,000 and 100,000:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查值是否在50,000到100,000之间的规则：
- en: '[PRE46]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And finally, the rule to check for values greater than 100,000:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查值是否大于100,000的规则：
- en: '[PRE47]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the style with the customary rules defined previously:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前定义的常规规则创建样式：
- en: '[PRE48]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, create a vector layer that loads the GML file and uses the previous
    style:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个矢量层，加载GML文件并使用之前的样式：
- en: '[PRE49]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we described at the beginning of the recipe, an `OpenLayers.Style` instance
    admits a set of `OpenLayers.Rule` instances to style the features.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如配方开头所述，`OpenLayers.Style`实例接受一组`OpenLayers.Rule`实例来样式化特征。
- en: Given a rule, all the features that match the specified `OpenLayers.Filter`
    are styled with the specified symbolizer hash, and thanks to the filters, we have
    enough flexibility to create the comparison or logical filters.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个规则，所有匹配指定`OpenLayers.Filter`的特征都将使用指定的符号化哈希进行样式化，并且多亏了过滤器，我们有足够的灵活性来创建比较或逻辑过滤器。
- en: In the code, we have created five filters. Let's describe two of them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们创建了五个过滤器。让我们描述其中两个。
- en: 'The `aRule` rule is formed by a comparison filter that matches all the features
    with an `AREA` attribute having a value less than 10,000:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`aRule`规则由一个比较过滤器组成，匹配所有具有小于10,000的`AREA`属性值的特征：'
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `bRule` uses a more complex rule. In this case, it is a logical `AND` filter
    composed of two comparison filters. It matches all the features to check whether
    their `AREA` attribute is greater than 10,000 and less than or equal to 25,000:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`bRule`使用更复杂的规则。在这种情况下，它是一个由两个比较过滤器组成的逻辑`AND`过滤器。它匹配所有特征，检查它们的`AREA`属性是否大于10,000且小于或等于25,000：'
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once we have created all the desired rules, we can create an `OpenLayers.Style`
    instance:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了所有所需的规则，我们就可以创建一个`OpenLayers.Style`实例：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then apply it to the vector layer:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其应用于矢量层：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have created an `OpenLayers.StyleMap` instance passing only one style and
    not a style for each desired render intent. This means there will be no render
    intents in the layer, or expressed in other words, all the render intents will
    be rendered with the same style.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`OpenLayers.StyleMap`实例，只传递一个样式，而不是每个期望的渲染意图的样式。这意味着层中不会有渲染意图，或者换句话说，所有渲染意图都将使用相同的样式渲染。
- en: Because the vector layer must read data from a GML file in our server, we have
    made use of an `OpenLayers.Protocol.HTTP` instance that loads files from the specified
    URL and uses an instance in the `OpenLayers.Format.GML` format to read it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因为矢量层必须从我们的服务器上的GML文件中读取数据，所以我们使用了`OpenLayers.Protocol.HTTP`实例，该实例从指定的URL加载文件，并使用`OpenLayers.Format.GML`格式的实例来读取它。
- en: Finally, to center the map's viewport, we needed to transform the coordinates.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使地图视口居中，我们需要转换坐标。
- en: 'Because the base layer of the map is OpenStreetMap, this makes the map''s projection
    to become EPSG:900913, while we are specifying the center location as latitude/longitude
    using the EPSG:4326\. Because of this we need to make a transformation:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因为地图的基本层是OpenStreetMap，这使得地图的投影变为EPSG:900913，而我们在指定中心位置时使用的是EPSG:4326。因此，我们需要进行转换：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There's more...
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In our code, we have created the style with the sentences:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们使用以下句子创建了样式：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But the `OpenLayers.Style` constructor can accept two parameters: a symbolizer
    hash, to be used as the default style, and a set of options where we need to specify
    instance properties. With this in mind we can also instantiate the style as:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`OpenLayers.Style`构造函数可以接受两个参数：一个符号化哈希，用作默认样式，以及一组选项，其中我们需要指定实例属性。考虑到这一点，我们也可以这样实例化样式：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: See also
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Working with unique value rules* recipe
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用唯一值规则进行样式化配方
- en: The *Styling features using symbolizers* recipe
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号化进行特征样式化配方
- en: The *Improving style using StyleMap and the replacement of feature's attributes*
    recipe
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用StyleMap改进样式以及替换特征属性的配方
- en: Styling clustered features
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化聚类特征
- en: When working with lots of feature points, it is common to use the cluster strategy
    to avoid overlapping of points and improve the rendering performance.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量的特征点时，通常使用聚类策略来避免点重叠并提高渲染性能。
- en: 'In this recipe we are going to show how easy it is to style a vector layer
    using a cluster strategy:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示如何轻松地使用聚类策略对矢量层进行样式化：
- en: '![Styling clustered features](img/7843_07_07.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![样式化聚类要素](img/7843_07_07.jpg)'
- en: 'Our layer vector will read a GeoJSON file with some cities of the world. The
    style will have the following characteristics:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据层将读取包含世界上一些城市的GeoJSON文件。样式将具有以下特征：
- en: For each cluster we will show the number of contained features
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个聚类，我们将显示包含的要素数量
- en: The point radius and border will depend on the number of contained features,
    the more features within it, the greater the radius will be
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点半径和边框将取决于包含的要素数量，包含的要素越多，半径就越大
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Start adding the `div` element for the map:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始添加地图的`div`元素：
- en: '[PRE57]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Instantiate an `OpenLayers.Map` instance:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`OpenLayers.Map`实例：
- en: '[PRE58]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add OpenStreetMap as the base layer and center the viewport:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将OpenStreetMap作为基本图层并居中视口：
- en: '[PRE59]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Load the data from a GeoJSON file and apply the desired style:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GeoJSON文件加载数据并应用所需的样式：
- en: '[PRE60]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After creating the map instance and adding the base layer, we have centered
    the viewport. Note how we have translated the coordinates from EPSG:4326 (latitude/longitude)
    to EPSG:900913 used by the map (implicitly used by OpenStreetMap layer):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建地图实例并添加基本图层后，我们已将视口居中。注意我们如何将坐标从EPSG:4326（纬度/经度）转换为地图使用的EPSG:900913（隐式用于OpenStreetMap图层）：
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we have added the vector layer:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了矢量图层：
- en: '[PRE62]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To load the GeoJSON file from our server, we have used an `OpenLayers.Protocol.HTTP`
    instance with the `OpenLayers.Format.GeoJSON` format to read it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的服务器加载GeoJSON文件，我们使用了`OpenLayers.Protocol.HTTP`实例和`OpenLayers.Format.GeoJSON`格式来读取它。
- en: 'For layer strategies, we have specified the `OpenLayers.Strategy.Fixed` to
    load the content once and the `OpenLayers.Strategy.Cluster({distance: 25})` sentence
    to group features. The property `distance` sets the pixel distance that defines
    where two features must go into the same cluster.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '对于图层策略，我们指定了`OpenLayers.Strategy.Fixed`以加载内容一次，以及`OpenLayers.Strategy.Cluster({distance:
    25})`来分组要素。属性`distance`设置了定义两个要素必须进入同一聚类的像素距离。'
- en: At this point and, before continuing with the recipe, we need to describe how
    the clustering process works.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，在继续食谱之前，我们需要描述聚类过程是如何工作的。
- en: When the layer is going to be rendered, the clustering algorithm checks for
    each feature if they are too close to other ones. For each set of features that
    are too close, a new point (cluster) is created and rendered. This way the number
    of points to draw on the map can be reduced drastically. In addition, each cluster
    point feature will contain references to the set of features it represents and
    also a `count` attribute with the number of features it contains.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当图层即将渲染时，聚类算法会检查每个要素是否与其他要素过于接近。对于过于接近的要素集，会创建一个新的点（聚类）并渲染。这样可以在地图上大大减少需要绘制的点数。此外，每个聚类点要素将包含它所代表的要素集的引用，以及一个包含要素数量的`count`属性。
- en: Returning to our code, let's see the style applied to the layer, which is the
    most important thing in the recipe.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们的代码，让我们看看应用于图层的样式，这是食谱中最重要的事情。
- en: 'First, we have set the style for the `default` rendering intent:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为`default`渲染意图设置了样式：
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This means if we use some control that changes the render intent of the layer
    to something different from the default, the style will probably be different.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们使用一些控制来更改图层的渲染意图为不同于默认值，样式可能不同。
- en: Note
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If we create the `OpenLayers.StyleMap` instance without passing directly the
    style instance, that is, without specifying a render intent, then the style will
    be the same for any render intent: `new OpenLayers.StyleMap(our_style_here)`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不直接传递样式实例来创建`OpenLayers.StyleMap`实例，即不指定渲染意图，那么样式将适用于任何渲染意图：`new OpenLayers.StyleMap(our_style_here)`。
- en: 'Now, let''s look at the `OpenLayers.Style` instance defined for the layer:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看为图层定义的`OpenLayers.Style`实例：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The constructor receives two parameters: a symbolizer hash, which defines the
    style properties, and a set of options.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接收两个参数：一个符号化哈希，它定义了样式属性，以及一组选项。
- en: 'In the symbolizer hash, we have used the attribute replacement feature:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在符号化哈希中，我们使用了属性替换功能：
- en: '[PRE65]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `count` attribute is taken from the cluster point feature attributes, as
    we explained previously.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`属性来自聚类点要素的属性，正如我们之前解释的那样。'
- en: On the other hand, the `strokeFunction` and `radiusFunction` are not attributes,
    but functions which are defined in the `context` property of the `OpenLayers.Style`
    options. All the symbolizer properties are evaluated against the `context` object.
    So, each of the functions receives a feature reference every time the layer is
    going to be rendered.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`strokeFunction`和`radiusFunction`不是属性，而是在`OpenLayers.Style`选项的`context`属性中定义的函数。所有符号化属性都是针对`context`对象进行评估的。因此，每当图层即将渲染时，每个函数都会接收到一个特征引用。
- en: In the case of `radiusFunction`, it computes the radius for the point depending
    on the `count` attribute, returning the maximum value between the range of 60
    percent of `count` or `7:`
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在`radiusFunction`的情况下，它根据`count`属性计算点的半径，返回`count`的60%或`7`之间的最大值：
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As we can see, the use of context is powerful enough to allow us to set style
    properties dynamically and dependence on other feature attributes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，上下文的使用足够强大，允许我们根据其他特征属性动态设置样式属性。
- en: See also
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Improving style using StyleMap and the replacement of feature's attributes*
    recipe
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用StyleMap和替换特征属性来改进样式*的配方'
- en: The *Defining custom rules to style features* recipe
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义自定义规则以样式化特征*的配方'
- en: The *Using the cluster strategy* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Vector Layers*
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。处理矢量图层")的*使用聚类策略*配方中，*矢量图层*
