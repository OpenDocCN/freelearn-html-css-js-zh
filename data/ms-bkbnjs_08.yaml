- en: Chapter 8. Testing Backbone Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。测试 Backbone 应用程序
- en: It does not matter if you are an experienced programmer, it's very normal that
    you will commit mistakes in your code at some point in time. Nobody is perfect
    and errors happen all the time in software development. Your work as a developer
    is to minimize the number of defects that are in your software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是一个经验丰富的程序员，还是在某个时间点犯代码错误都是非常正常的。没有人是完美的，软件开发中错误总是时有发生。作为开发者，你的工作是将软件中的缺陷数量降到最低。
- en: Errors can occur from different sources; an unexpected input, an error that
    is not handled properly, a change in a third-party plugin, a memory issue, and
    so on. Your code should be prepared to deal with these kind of things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可能来自不同的来源；一个意外的输入，一个处理不当的错误，第三方插件的更改，内存问题等等。你的代码应该准备好处理这类事情。
- en: In the software industry, the rule of thumb is to always test your code. When
    you test your applications, the final product has a better quality as many defects
    have been detected and corrected before the users notice it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件行业，一个普遍的规则是始终测试你的代码。当你测试你的应用程序时，最终产品质量更好，因为许多缺陷在用户注意到之前就已经被检测和纠正。
- en: 'Tests are not just undertaken to prevent bugs in the software. The following
    is a list of benefits that you get when you do the testing:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不仅仅是为了防止软件中的错误。以下是在进行测试时你可以获得的一些好处：
- en: Improves end-product quality
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高最终产品的质量
- en: Makes you confident with your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你在应用中充满自信
- en: Allows you to refactor pieces of code safely
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你安全地重构代码片段
- en: Preserves functionality
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留功能
- en: Simulates errors and improves your error handling code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟错误并改进你的错误处理代码
- en: Improves your code, forcing you to make testable code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高你的代码质量，迫使你编写可测试的代码
- en: If you have never tested your software, now you have good reasons to start doing
    it. `Make` testing can slow down your development process at the start; however,
    you will see the benefits in the mid time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未测试过你的软件，现在你有很好的理由开始这样做。`Make` 测试可能会在开始时减缓你的开发过程；然而，你将在中期看到好处。
- en: 'In this chapter, you will learn the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Which tools are available to test frontend applications
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些工具可用于测试前端应用程序
- en: What and how to test Backbone applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何测试 Backbone 应用程序
- en: How to apply best practices for application testing
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何应用应用程序测试的最佳实践
- en: How to run your tests automatically
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何自动运行你的测试
- en: Testing tools
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试工具
- en: 'A testing tool can be a library or framework that helps you to write tests
    for your applications and evaluate the results. Under testing tools, you can find
    the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具可以是库或框架，帮助你编写应用程序的测试并评估结果。在测试工具下，你可以找到以下内容：
- en: '**Testing libraries**: This gives you a hook and functions to describe tests'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试库**：这为你提供了钩子和函数来描述测试'
- en: '**Assertion libraries**: This gives you functions to make expectations'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言库**：这为你提供了创建期望的功能'
- en: '**Test runners**: This discovers and runs your tests'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试运行器**：这会发现并运行你的测试'
- en: '**Test coverage**: This tells you which parts of your code are tested and which
    are not'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试覆盖率**：这告诉你哪些代码部分被测试了，哪些没有被测试'
- en: '**Test reports**: This makes reports in different formats such as HTML and
    JSON'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试报告**：这会以不同的格式生成报告，如 HTML 和 JSON'
- en: '**Mocking, stubbing, faking tools**: These give you ways to make fake objects
    with predictable behavior'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟、存根、伪造工具**：这些为你提供了创建具有可预测行为的假对象的方法'
- en: '**Module mocking**: This replaces a required module with a fake module and
    is useful to isolate modules'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块模拟**：这用假模块替换所需的模块，有助于隔离模块'
- en: '**Stress tools**: This makes many requests to the applications in order to
    see how it behaves in high demand circumstances'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力工具**：这会对应用进行多次请求，以查看它在高需求环境下的行为'
- en: '**Browser testing**: This emulates a user making inputs in the application
    as a whole'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器测试**：这模拟用户在整个应用程序中输入'
- en: Explaining and showing how all these tools work is out of scope of this book.
    In this chapter, you will work with testing libraries, asserting libraries, testing
    runners, and mocking.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解释和展示所有这些工具如何工作超出了本书的范围。在本章中，你将使用测试库、断言库、测试运行器和模拟。
- en: 'For JavaScript, there are many testing libraries available for you; however,
    two of them are more popular at the moment of writing this book: `Jasmine` and
    `Mocha`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JavaScript，有许多测试库可供你使用；然而，在撰写本书时，有两个更受欢迎：`Jasmine` 和 `Mocha`。
- en: '`Mocha` is a small library that allows you to write tests harness, it does
    not have any assertion functions by itself. What it means is that you should integrate
    `Mocha` with an assertion library of your choice; a very popular choice is to
    use a combination of Mocha and Chai.js.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mocha` 是一个小型库，允许你编写测试驱动程序，它本身不包含任何断言函数。这意味着你应该将 `Mocha` 与你选择的断言库集成；一个非常流行的选择是使用
    Mocha 和 Chai.js 的组合。'
- en: '`Jasmine` is more like a framework, it provides an API that is very similar
    to Mocha; however, it includes assertion functions. Therefore, it is simpler to
    use as you do not need to create an extra step.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jasmine` 更像是一个框架，它提供了一个与 Mocha 非常相似的 API；然而，它包括了断言函数。因此，使用起来更简单，因为你不需要创建额外的步骤。'
- en: For this book, we will use Jasmine as it is the most popular testing tool and
    is easier to start working with. In the same way as Mocha, you can use Jasmine
    as a test runner and select different types of reports.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我们将使用 Jasmine，因为它是最受欢迎的测试工具，并且更容易开始使用。与 Mocha 一样，你可以将 Jasmine 用作测试运行器并选择不同类型的报告。
- en: Getting started with Jasmine
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jasmine 入门
- en: 'To write tests, you should create two things: test suites and specs. A spec
    (short for specification) is a piece of functionality that you are testing from
    your code; for example, if your code is calculating tax of 5% for $100.00, you
    would expect it to be $5\. A test suite is a set of expectations that are grouped
    under a topic. In the preceding example, the test suite can be "Invoice totals
    calculation".'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写测试，你应该创建两样东西：测试套件和规范。规范（简称 spec）是你从代码中测试的功能的一部分；例如，如果你的代码是计算 $100.00 的 5%
    税，你预期它应该是 $5。测试套件是一组在主题下分组的预期。在上面的例子中，测试套件可以是“发票总额计算”。
- en: 'To start working with Jasmine, you should install it from npm, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Jasmine，你应该从 npm 安装它，如下所示：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you can start writing your tests. With Jasmine, you have two functions:
    `describe()` to create test suites and `it()` to make specs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以开始编写你的测试。使用 Jasmine，你有两个函数：`describe()` 用于创建测试套件，`it()` 用于创建规范：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code defines a test suite for a hypothetical set of math functions.
    Notice how in the `describe()` function, you should write a text that tells the
    people what is the context of the tests; while in the `it()` function, the text
    should tells what are you testing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个针对假设的数学函数集的测试套件。注意在 `describe()` 函数中，你应该写一段文字来告诉人们测试的上下文；而在 `it()`
    函数中，文字应该说明你要测试的内容。
- en: 'Now, let''s build the `math` functions for the test suite, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为测试套件构建 `math` 函数，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `math` object has the necessary functions to pass the test suite; however,
    to actually test the `math` object, you will need to make a set of expectations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 对象具有通过测试套件所需的功能；然而，要实际测试 `math` 对象，你需要制定一系列预期。'
- en: Expectations
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预期
- en: 'Expectations are functions that compare the output of a function with an expected
    output. In the following example, we call the `sum()` function with an input of
    `2` and `2`. We are expecting that the result should be `4`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 预期是函数，用于比较函数的输出与预期输出。在下面的例子中，我们使用 `2` 和 `2` 作为输入调用 `sum()` 函数。我们预期结果应该是 `4`：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `toEqual()`expectation function compares whether the output of the function
    and the expected value are equal; if both are the same, the test will pass, otherwise,
    it will fail. The following table shows the most common expectations in Jasmine,
    consult the documentation for a complete set of available expectation functions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`toEqual()` 预期函数比较函数的输出和预期值是否相等；如果两者相同，测试将通过，否则，测试将失败。下表显示了 Jasmine 中最常用的预期，请查阅文档以获取完整的可用预期函数集：'
- en: '| Expectation function | Description | Example |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 预期函数 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `toEqual` | The values should be exactly equal | `expect(''hello'')``.toEqual(''hello'')`
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `toEqual` | 值应该完全相等 | `expect(''hello'').toEqual(''hello'')` |'
- en: '| `toMatch` | The value will be RegEx matched | `expect(''Hello'')``.toMatch(/[Hh]ello/)`
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `toMatch` | 值将与正则表达式匹配 | `expect(''Hello'').toMatch(/[Hh]ello/)` |'
- en: '| `toBeTruthy` | The value should be a truth value | `expect(true)``.toBeTruthy();``expect(100)``.toBeTruthy();`
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `toBeTruthy` | 值应该是真值 | `expect(true).toBeTruthy();` `expect(100).toBeTruthy();`
    |'
- en: '| `toBeFalsy` | The value should be a false value | `expect(false)``.toBeFalsy();``expect(null)``.toBeFalsy();`
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `toBeFalsy` | 值应该是假值 | `expect(false).toBeFalsy();` `expect(null).toBeFalsy();`
    |'
- en: '| `toThrowError` | This verifies that the function that is called throws an
    error | `expect(function() {``math.divide(1, 0);``}).toThrowError();` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `toThrowError` | 这验证了被调用的函数会抛出错误 | `expect(function() {``math.divide(1, 0);``}).toThrowError();`
    |'
- en: 'After adding all the expectations to the example test suite that we have, the
    code should be something as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有期望添加到我们已有的示例测试套件之后，代码应该如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To run the test suite, you should first configure the Jasmine test runner.
    To do this, you should create a script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试套件，你应该首先配置 Jasmine 测试运行器。为此，你应该创建一个脚本：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Jasmine will look for tests under the `spec/`directory, it will look for all
    those files that end with `spec.js` or `Spec.js`. As our test file is named `mathSpec.js`,
    the Jasmine test runner will load and run it, as shown in the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 将在 `spec/` 目录下查找测试，它将查找所有以 `spec.js` 或 `Spec.js` 结尾的文件。由于我们的测试文件命名为
    `mathSpec.js`，Jasmine 测试运行器将加载并运行它，如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see what happens if the test fails; for example, you change the sum
    test to `5` instead of `4`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到测试失败时会发生什么；例如，你将求和测试改为 `5` 而不是 `4`：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if you make a mistake, Jasmine will tell you what''s wrong. Notice how
    Jasmine will inform you about the error:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你犯了一个错误，Jasmine 会告诉你哪里出了问题。注意 Jasmine 如何通知你错误：
- en: '*"Basic mathematic functions should result 4 the sum of 2 + 2"*'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"基本的数学函数应该得到 2 + 2 的和 4"*'
- en: Then, it tells you that it was expecting `5` and instead received `4`. Please
    note that it is very important what messages you put in the `describe()` and `it()`
    functions as they will help you to quickly diagnose what's wrong.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它告诉你它期望的是 `5`，但收到了 `4`。请注意，在 `describe()` 和 `it()` 函数中放入的消息非常重要，因为它们将帮助你快速诊断问题。
- en: Testing asynchronous code
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试异步代码
- en: When you need to test a code that is asynchronous like an Ajax call, you will
    need to make an extra step. When you write the `it()` function, you should pass
    a `done` argument and Jasmine will put a callback function there, which you should
    call when the test is done.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要测试异步代码，如 Ajax 调用，你需要额外的一步。当你编写 `it()` 函数时，你应该传递一个 `done` 参数，Jasmine 将在那里放置一个回调函数，你应该在测试完成后调用它。
- en: 'To illustrate this, let''s simulate an asynchronous task that sum two numbers,
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们模拟一个求两个数的和的异步任务，如下所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Following the JavaScript standard, the `syncSum()` function receives a third
    argument, which is the callback function that will be called when the sum is ready.
    In the following example, the callback function will be called after 1,500 milliseconds:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 JavaScript 标准，`syncSum()` 函数接收第三个参数，即当求和完成时将被调用的回调函数。在以下示例中，回调函数将在 1,500
    毫秒后调用：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To make a test with this function, we should pass a `done` callback to the
    `it()` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数编写测试，我们应该将 `done` 回调函数传递给 `it()` 函数：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Karma test runner
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Karma 测试运行器
- en: Karma is a popular test runner for JavaScript, it works with many other testing
    libraries and frameworks such as Jasmine and Mocha. The Node test runner that
    comes with Jasmine is fine; however, Karma adds superpowers to the equation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 是一个流行的 JavaScript 测试运行器，它与许多其他测试库和框架（如 Jasmine 和 Mocha）一起工作。Jasmine 附带的
    Node 测试运行器已经足够好；然而，Karma 为这个方程式增加了超级功能。
- en: With Karma, you can run your tests on real web browsers such as Google Chrome,
    Firefox, Opera, and so on. Once Karma is set and running, it will take care of
    lookup for the files to test, run it, and then give you a report.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Karma，你可以在真实的网络浏览器上运行测试，例如 Google Chrome、Firefox、Opera 等。一旦 Karma 设置并运行，它将负责查找要测试的文件，运行测试，然后给出报告。
- en: 'You will need to install Karma before starting to work with it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Karma 之前，你需要安装 Karma：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, you can configure Karma with a script named `karma.conf.js`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用名为 `karma.conf.js` 的脚本配置 Karma：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `files` field tells to Karma which files will be tested in the `glob` format.
    The `preprocessors` field tells to Karma whether the files selected from the `files`
    field should be preprocessed before running the tests. As we are using Browserify
    to manage the dependencies, we should preprocess the files with Browserify in
    order to create a test bundle.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`files` 字段告诉 Karma 哪些文件将以 `glob` 格式进行测试。`preprocessors` 字段告诉 Karma 是否应该对从 `files`
    字段选择的文件进行预处理，以便在运行测试之前。由于我们使用 Browserify 来管理依赖项，我们应该使用 Browserify 预处理文件以创建测试包。'
- en: You can choose how you want Karma to report the test status to you. The `reporters`
    field makes this possible, you can search for more reporters available; however,
    the `spec` reporter is one of the most used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择Karma如何向你报告测试状态。`reporters`字段使得这一点成为可能，你可以搜索更多可用的报告器；然而，`spec`报告器是最常用的之一。
- en: 'Once Karma is configured, you can run the tests that we have with Karma instead
    of the Jasmine test runner:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Karma配置完成，你可以运行我们用Karma配置的测试，而不是使用Jasmine测试运行器：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can automatize how you run Karma with Gulp, after all that''s its job:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Gulp来自动化Karma的运行，毕竟那是它的职责：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What and how to test Backbone applications
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要测试什么以及如何测试Backbone应用程序
- en: Backbone library has different components, each one with its own intentions
    and responsibilities, that's why you have to test them differently. Keep it in
    mind that you should only test your code and not the Backbone built-in functionalities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone库有不同的组件，每个组件都有自己的意图和职责，这就是为什么你必须以不同的方式测试它们。请记住，你应该只测试你的代码，而不是Backbone内置的功能。
- en: In the next sections, you will see what are the parts of your Backbone applications
    and how to test them; we will start from simple things and then go for more complex
    ones. Then, you will learn how to isolate modules to only test one module at time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将看到你的Backbone应用程序的各个部分以及如何测试它们；我们将从简单的事情开始，然后逐步过渡到更复杂的内容。然后，你将学习如何隔离模块，以便一次只测试一个模块。
- en: Testing models and collections
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模型和集合
- en: 'The most basic test is to ensure that models and collections have the right
    properties set in order to prevent accidental changes in its properties. In the
    case of models, you can test the default values when a new contact is created
    and verify that the `url` attribute is right:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的测试是确保模型和集合具有正确的属性设置，以防止其属性发生意外更改。在模型的情况下，你可以测试创建新联系人时的默认值，并验证`url`属性是否正确：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For collections, you can verify that the `url` is right:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集合，你可以验证`url`是否正确：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing views
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试视图
- en: 'Views manage the relationship between data (such as, models or collections)
    and the user interactions (DOM). In the case of views, you should test for the
    following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 视图管理数据（如模型或集合）与用户交互（DOM）之间的关系。在视图的情况下，你应该测试以下内容：
- en: 'Rendering: Given a model or collection, you should verify that the output HTML
    is the right one'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染：给定一个模型或集合，你应该验证输出HTML是否正确
- en: 'Events: This verifies that the DOM events are handled correctly'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件：这验证了DOM事件是否被正确处理
- en: 'Model changes: If the model changes something, the view should be in sync'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型更改：如果模型发生变化，视图应该与之同步
- en: For this example, we are going to test the `ContactForm` view; the responsibility
    of this view is to show a form to the user and then get the user input to update
    a model.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将测试`ContactForm`视图；这个视图的职责是向用户展示一个表单，然后获取用户输入以更新模型。
- en: When making test on views, it is recommended to use a fake model and not the
    original `Contact` model. The main reason for this is to isolate the `ContactView`
    object so that if a test fails, you will know that the error is isolated in the
    view and does not depend on the `Contact` model.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在对视图进行测试时，建议使用模拟模型而不是原始的`Contact`模型。这样做的主要原因是为了隔离`ContactView`对象，这样如果测试失败，你就会知道错误是孤立在视图中的，并不依赖于`Contact`模型。
- en: 'You can start testing whether the rendered HTML is right, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以开始测试渲染的HTML是否正确，如下所示：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note how in the test, we are looking in the output HTML if contains a specific
    text on it. You can use specific selectors instead:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在测试中，我们是在查看输出HTML是否包含特定的文本。你可以使用特定的选择器来代替：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, it is not recommended to do this in unstable applications as the design
    can quickly change and the tests will fail even if the name is on the screen:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不建议在不稳定的应用程序中这样做，因为设计可能会迅速改变，即使屏幕上有名称，测试也会失败：
- en: '![Testing views](img/B01962_08_01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![测试视图](img/B01962_08_01.jpg)'
- en: Figure 8.1 Jasmine testing functions
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 Jasmine测试函数
- en: Figure 8.1 illustrates the relationship between the `beforeEach()`, `afterEach()`,
    and `it()` functions. When you define one or more `beforeEach()` functions in
    `describe()`, then all the `beforeEach()` functions will always be executed before
    the `it()` functions. This feature is very useful as you can ensure the same initial
    conditions for each test.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1说明了`beforeEach()`、`afterEach()`和`it()`函数之间的关系。当你定义一个或多个`beforeEach()`函数在`describe()`中，那么所有的`beforeEach()`函数都将始终在`it()`函数之前执行。这个特性非常有用，因为它可以确保每个测试都有相同的初始条件。
- en: In the example test suite for the `ContactForm` object, we are ensuring that
    `fakeContact` always has the same attributes; if you change something in the model
    under an `it()` function, the next function will always get a clean `fakeContact`
    model to test.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ContactForm`对象的示例测试套件中，我们确保`fakeContact`始终具有相同的属性；如果你在`it()`函数下更改模型中的某些内容，下一个函数将始终获得一个干净的`fakeContact`模型进行测试。
- en: 'The `ContactForm` object has a **Save** button that triggers a `form:save`
    event when it is clicked; to test this, you can listen for the event on a Jasmine
    **spy function**. A spy function is a function that does nothing but record when
    and how it is called. Then, you can use it to make expectation in it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactForm`对象有一个**保存**按钮，当点击时会触发一个`form:save`事件；为了测试这个，你可以在Jasmine的**间谍函数**上监听这个事件。间谍函数是一个什么也不做，只是记录何时以及如何被调用的函数。然后，你可以用它来在其中设置期望：'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `createSpy()` method of Jasmine creates a spy function that will be used
    as the event handler for the `from:save` event. Then, it emulates a click event
    on the save button and tests whether the `callback` function was called.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine的`createSpy()`方法创建了一个间谍函数，该函数将被用作`form:save`事件的处理器。然后，它模拟在保存按钮上触发一个点击事件，并测试`callback`函数是否被调用。
- en: 'We can go a step forward and check whether the function is called with the
    model as argument:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，检查函数是否以模型作为参数被调用：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now is time to test when the user makes the input in the form and then click
    the **Save** button; what we are expecting from it is that the model changes with
    the input values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试用户在表单中输入并点击**保存**按钮的时候；我们期望的是模型随着输入值的改变而改变：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this test, we are changing the values in the input fields and then clicking
    the save button in the form. The `callback` spy function records how the `form:save`
    event is triggered and extracts the argument passed to it. We can use this argument
    to test whether the model was updated as expected.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们更改输入字段的值，然后在表单中点击保存按钮。`callback`间谍函数记录了`form:save`事件是如何被触发的，并提取传递给它的参数。我们可以使用这个参数来测试模型是否按预期更新。
- en: Testing controllers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试控制器
- en: Controllers are more complex than test as they have more dependencies than the
    models, collections, and views. If you explore the code on these objects, you
    will see that the only dependencies that they have are Backbone and Underscore.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器比测试更复杂，因为它们比模型、集合和视图有更多的依赖。如果你查看这些对象的代码，你会看到它们唯一的依赖是Backbone和Underscore。
- en: You can test the controllers with all its dependencies, which means that while
    testing the `ContactEditor` controller, you will be testing all the views and
    models attached to it as the module requires these objects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用所有依赖来测试控制器，这意味着在测试`ContactEditor`控制器时，你将测试所有附加到它的视图和模型，因为模块需要这些对象。
- en: That's not good for unit testing as you will end up with integration tests instead.
    If the `Contact` model has a defect, then `ContactEditor` will fail, even if it
    does not have any error in it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这对单元测试来说不是很好，因为你最终会得到集成测试。如果`Contact`模型有缺陷，那么`ContactEditor`将失败，即使它没有错误。
- en: You need to isolate the modules from the mess of other modules. Keep in mind
    that you should trust your libraries as they will already have their test suites.
    We need a mechanism to fake the dependencies of a module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将模块从其他模块的混乱中隔离出来。记住，你应该信任你的库，因为它们已经有了自己的测试套件。我们需要一个机制来伪造模块的依赖。
- en: With dependency injection, you can overwrite the `require()` function, instead
    of loading the script that points, in order to use a fake object. This will guarantee
    that the code that is being tested is isolated and its behavior is predictable
    for unit testing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入，你可以覆盖`require()`函数，而不是加载指向的脚本，以便使用一个假对象。这将保证正在测试的代码是隔离的，并且其行为对单元测试来说是可预测的。
- en: Mocking dependencies
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟依赖
- en: 'There are two main choices to mock dependencies in Node: `rewire` and `proxyquireify`;
    with these libraries, you can overwrite the original dependencies of a module
    in order to use a fake version instead.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node中模拟依赖有两个主要选择：`rewire`和`proxyquireify`；使用这些库，你可以覆盖模块的原始依赖，以便使用假版本。
- en: 'With Browserify, you should have `proxyquireify`. Install it with npm, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Browserify时，你应该有`proxyquireify`。使用npm安装它，如下所示：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the library is installed, we need to add a proper configuration in the
    Karma configuration file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦库安装完成，我们需要在Karma配置文件中添加适当的配置：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should initialize `proxyquireify` before using it. As `proxyquireify` overwrites
    the original `require()` function, it should be initialized before being used.
    The initialization function returns a function object that is similar to the original
    `require()` function; however, with the the extra functionality of fake dependencies,
    as shown in the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在使用之前初始化`proxyquireify`。因为`proxyquireify`覆盖了原始的`require()`函数，所以它应该在使用之前初始化。初始化函数返回一个与原始`require()`函数类似的功能对象；然而，它具有伪造依赖项的额外功能，如下所示：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `proxyquire` object can be used to load modules:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxyquire`对象可以用来加载模块：'
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you load a module with `proxyquireify`, you can use a second argument
    to overwrite the original dependencies. It is an object where the keys are the
    name of the dependencies and the values are the object that will substitute the
    original dependency:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`proxyquireify`加载模块时，你可以使用第二个参数来覆盖原始依赖项。它是一个对象，其中键是依赖项的名称，值是替换原始依赖项的对象：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This configuration will replace the `ContactView` object with an empty `Backbone.View`
    object so that when testing the `ContactViewer` object, the module will not load
    the original `ContactView` module.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将用空的`Backbone.View`对象替换`ContactView`对象，以便在测试`ContactViewer`对象时，模块不会加载原始的`ContactView`模块。
- en: Fake objects
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪造对象
- en: A fake object is a simple object that has the same functions as an original
    one; however, with a predictable behavior so that you can use fake objects to
    isolate the module under test. For example, all our controllers depend on the
    `App` object to work; however, it is not a good idea to use the real `App` object
    for the purpose of testing. If the `App` object has an error, then the controller
    test will fail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个伪造对象是一个具有与原始对象相同功能的简单对象；然而，它具有可预测的行为，这样你就可以使用伪造对象来隔离正在测试的模块。例如，我们所有的控制器都依赖于`App`对象来工作；然而，为了测试的目的使用真实的`App`对象并不是一个好主意。如果`App`对象出现错误，那么控制器测试将会失败。
- en: 'A fake for the `App` object is as shown in the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示是`App`对象的伪造：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This simple object can simulate to be the real `App` object, as you can see
    the object does nothing; however, it will be useful in the next section for testing
    the `ContactEditor` controller.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的对象可以模拟成真实的`App`对象，正如你所见，这个对象什么也不做；然而，它将在下一节中用于测试`ContactEditor`控制器。
- en: 'Regions can also be faked in order to remove all the overheads of the original
    region:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 区域也可以被伪造，以消除原始区域的所有开销：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is very simple, just to render the view that is passed to it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，只需渲染传递给它的视图。
- en: Testing ContactEditor
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试ContactEditor
- en: The `ContactEditor` controller's responsibility is to render the necessary views
    in order to allow the user to update or create new contacts. It is closely related
    to many views and the `Contact` model.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactEditor`控制器的职责是渲染必要的视图，以便用户可以更新或创建新的联系人。它与许多视图和`Contact`模型密切相关。'
- en: 'We are going to use `proxyquireify` to isolate the `ContactEditor` controller
    and instead of using the real objects, we will fake most of them. The first test
    is to check whether the subapplication is rendered in the right region:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`proxyquireify`来隔离`ContactEditor`控制器，并且不是使用真实对象，我们将伪造其中大部分。第一个测试是检查子应用程序是否在正确的区域渲染：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are faking almost all the views of the `ContactEditor` controller, we don''t
    need the real views as we are not testing the output HTML, that''s a job for view
    testing. The only view that is not faked is the `FormLayout` view:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎伪造了`ContactEditor`控制器的所有视图，我们不需要真实的视图，因为我们不是在测试输出HTML，这是视图测试的工作。唯一没有被伪造的视图是`FormLayout`视图：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then add the fake, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加伪造对象，如下所示：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `ContactEditor` controller, we are listening for `avatar:selected` of
    the `ContactPreview` view, we should ensure that the event is handled correctly.
    However, we have a problem, we cannot access the view instance. To make the controller
    testable, it is a common practice to put the views as attributes of the controller,
    as shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ContactEditor`控制器中，我们正在监听`ContactPreview`视图的`avatar:selected`事件，我们应该确保事件被正确处理。然而，我们有一个问题，我们无法访问视图实例。为了使控制器可测试，将视图作为控制器的属性放置是一个常见的做法，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this change, we can make the proper test, it verifies that the `avatarSelected`
    property is set when the `contactPreview` view selects an image:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，我们可以进行适当的测试，它验证了当`contactPreview`视图选择一个图像时，`avatarSelected`属性被设置：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The core functionality of the `ContactEditor` controller is to save the contact
    properly when the user clicks on the **Save** button, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactEditor` 控制器的核心功能是在用户点击 **保存** 按钮时正确保存联系信息，如下所示：'
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this test case, the controller will call the `save()` method in the model
    to save the contact and Backbone will make an Ajax call to the server. When you
    are testing, you should not make real server connections as that will make your
    tests slow and prone to failing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例中，控制器将在模型中调用 `save()` 方法以保存联系信息，Backbone 将向服务器发起 Ajax 调用。在测试时，你不应该建立真实的服务器连接，因为这会使你的测试变慢并容易失败。
- en: 'With the `jasmine-ajax` plugin, you can fake the Ajax calls so that you will
    have a total control of how the test behaves. You will need to install the package
    first:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `jasmine-ajax` 插件，你可以伪造 Ajax 调用，从而完全控制测试的行为。你需要先安装该包：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, update the configuration of Karma to include the plugin, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新 Karma 的配置以包括插件，如下所示：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The plugin overwrites the original `XMLHttpRequest` object, therefore, it's
    important to initialize the Ajax plugin before starting your test and restore
    the original object once your test is done.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 插件覆盖了原始的 `XMLHttpRequest` 对象，因此，在开始测试之前初始化 Ajax 插件并完成测试后恢复原始对象非常重要。
- en: In the `beforeEach()` function, we will initialize the plugin by calling `jasmine.Ajax.install()`
    and restore the original `XMLHttpRequest` object with `jasmine.Ajax.uninstall()`
    in `afterEach()`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `beforeEach()` 函数中，我们将通过调用 `jasmine.Ajax.install()` 初始化插件，并在 `afterEach()`
    中使用 `jasmine.Ajax.uninstall()` 恢复原始的 `XMLHttpRequest` 对象。
- en: 'When your application makes an Ajax call, the plugin will catch the request
    and you can then inspect the request or fake the response, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序发起 Ajax 调用时，插件将捕获请求，然后你可以检查请求或伪造响应，如下所示：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding test, we saved the contact and faked an HTTP `200` response.
    When this happens, the application will show a success message and redirect the
    application to the contact list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们保存了联系信息并伪造了一个 HTTP `200` 响应。当这种情况发生时，应用程序将显示成功消息并将应用程序重定向到联系列表。
- en: 'If the server responds with an error, then the application will show an error
    message and not make a redirection to the contact list:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器响应错误，那么应用程序将显示错误消息，而不会将应用程序重定向到联系列表：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another thing that the `saveContact()` method does is to set the `phones` and
    `emails` attributes in the contact model. The test will ensure that the attributes
    are sent to the server correctly, as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveContact()` 方法还做的一件事是设置联系模型中的 `phones` 和 `emails` 属性。测试将确保这些属性被正确地发送到服务器，如下面的代码所示：'
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are setting a list of `phones` and `emails` and then test whether the server
    receives the right request.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个 `phones` 和 `emails` 的列表，然后测试服务器是否接收到正确的请求。
- en: 'If the contact is not valid, then the controller will not send anything to
    the server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果联系信息无效，那么控制器将不会向服务器发送任何信息：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ContactEditor` object should upload the avatar image only if the model
    is new. If the model not is new, then the avatar is uploaded immediately when
    the user selects the image:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactEditor` 对象只有在模型是新的情况下才应上传头像图片。如果模型不是新的，那么当用户选择图片时，头像会立即上传：'
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Testing the subapplication Façade
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试子应用 Façade
- en: 'The subapplication façade''s responsibility is to create the model or collect
    objects and create the appropriate subapplication controller to render the fetched
    data. To show the contact editor, the Façade should fetch the contact by its ID
    and then run the `ContactEditor` subapplication:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 子应用 Façade 的职责是创建模型或收集对象，并创建适当的子应用控制器以渲染获取的数据。为了显示联系编辑器，Façade 应根据其 ID 获取联系信息，然后运行
    `ContactEditor` 子应用：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The setup for this test suite is very similar to the controller. We should
    fake the `Ajax` calls and create a Façade object that is to be used on the specs.
    Our first test will be to verify that it is fetching the correct data:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试套件的设置与控制器非常相似。我们应该伪造 `Ajax` 调用并创建一个 Façade 对象，该对象将在规格说明中使用。我们的第一个测试将是验证它是否获取了正确的数据：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The Façade should trigger `loading: start` when fetching the data from the
    server:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '当从服务器获取数据时，Façade 应触发 `loading: start`：'
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, it should stop when the request is fulfilled:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它应在请求完成时停止：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, it should show the editor:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它应显示编辑器：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you want to build robust applications with minimum defects, you should test
    your code. Even if you are very good at coding, sometimes you may forget a validation
    or break a dependency and won't know about it until the final user of your application
    finds the bug.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要构建具有最少缺陷的健壮应用程序，你应该测试你的代码。即使你非常擅长编码，有时你也可能忘记一个验证或破坏一个依赖关系，直到你的应用程序的最终用户发现错误时你才会知道。
- en: As a professional developer, you should make sure that your code is always ready
    for production; one way to successfully do it is to run tests in your development
    workflow. Another benefit of testing applications is that you will gain confidence
    in your code, which means that you can improve your code without the fear of breaking
    something accidentally.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名专业开发者，你应该确保你的代码始终为生产做好准备；成功做到这一点的一种方式是在你的开发工作流程中运行测试。测试应用程序的另一个好处是，你将对你的代码更有信心，这意味着你可以放心地改进你的代码，而不用担心意外破坏某些内容。
- en: In Backbone, testing depends on the responsibility of the object that you are
    testing. Models, views, controllers, and facades are tested in their own way.
    However, it doesn't matter what the object is, Jasmine does a great work in order
    to help you to make a good test battery.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Backbone 中，测试依赖于你正在测试的对象的责任。模型、视图、控制器和外观都是按照自己的方式测试的。然而，无论对象是什么，Jasmine 都能出色地帮助你制作一个良好的测试库。
- en: In the next chapter, you will learn how to deploy your Backbone application
    to a server for production and how to build a production environment for your
    applications. You will setup a Heroku instance if you don't want to mess with
    the server configuration internals or want to see how all the parts are connected
    in deep. I will show you how to configure an Ubuntu server in order to make your
    deployments.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何将你的 Backbone 应用程序部署到服务器进行生产，以及如何为你的应用程序构建一个生产环境。如果你不想处理服务器配置的内部细节，或者想看看所有部分是如何深入连接的，你可以设置一个
    Heroku 实例。我将向你展示如何配置一个 Ubuntu 服务器以便进行部署。
