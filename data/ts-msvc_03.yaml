- en: Exploring Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索响应式编程
- en: Until now, we described our application as a mixture of very famous industry
    buzz words, such as asynchronous, real-time, loosely coupled, scalable, distributed,
    message-driven, concurrent, non-blocking, fault tolerant, low latency, and high
    throughput. In this chapter, we'll go one step further and understand reactive
    programming, which brings together all of these characteristics. We will see and
    understand the Reactive Manifesto—a set of principles that when collectively applied,
    will bring all of the preceding advantages. We will understand some key aspects
    of a reactive microservice, what it should be, and what are the key advantages
    of reactive programming. We will look at what problems reactive programming solves,
    different styles of reactive programming, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们描述了我们的应用程序是非常著名的行业术语的混合体，如异步、实时、松散耦合、可扩展、分布式、消息驱动、并发、非阻塞、容错、低延迟和高吞吐量。在本章中，我们将进一步了解响应式编程，它将所有这些特征汇集在一起。我们将看到并了解响应式宣言-一组原则，当集体应用时，将带来所有前述的优势。我们将了解响应式微服务的一些关键方面，它应该是什么，响应式编程的主要优势是什么。我们将看看响应式编程解决了什么问题，响应式编程的不同风格，等等。
- en: 'In this chapter, we will focus on the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下内容：
- en: Introduction to reactive programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程介绍
- en: Reactive Manifesto
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式宣言
- en: Reactive microservice—major building blocks and concerns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式微服务-主要构建模块和关注点
- en: When to react and when not to react (orchestrate)—introduction to hybrid approaches
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时反应，何时不反应（编排）-混合方法的介绍
- en: Being reactive in Node.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js中成为响应式
- en: Introduction to reactive programming
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程介绍
- en: 'If we want a view of reactive programming from 50,000 above ground level, it
    can briefly be termed as:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从5万英尺的高空看响应式编程的视图，它可以简要地被称为：
- en: <q>When input x in any function changes, output y automatically updates in the
    corresponding response without the need to manually invoke it. In short, the sole
    purpose is to continuously respond to external inputs whenever prompted by output
    worlds.</q>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <q>当任何函数中的输入x发生变化时，相应的输出y会在对应的响应中自动更新，而无需手动调用。简而言之，唯一的目的是在输出世界提示时不断响应外部输入。</q>
- en: Reactive programming is achieved through utilities such as map, filter, reduce,
    subscribe, unsubscribe, streams. Reactive programming focuses more on events and
    message-driven patterns rather than manually fiddling with huge implementation
    details.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是通过map、filter、reduce、subscribe、unsubscribe、streams等实用程序实现的。响应式编程更注重事件和消息驱动模式，而不是手动处理庞大的实现细节。
- en: Let's take a practical day-to-day example to understand reactive programming.
    We all have used Excel since the beginning of our IT lives. Now, let's say you
    write one formula based on a cell value. Now, whenever the cell value is changed,
    all corresponding results based on that value will reflect the change automatically.
    That's called being **reactive**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个实际的日常例子来理解响应式编程。我们从IT生涯的开始就使用Excel。现在，假设你根据一个单元格的值编写一个公式。现在，每当单元格的值发生变化时，基于该值的所有相应结果都会自动反映出变化。这就是所谓的**响应式**。
- en: 'Briefly understanding reactive programming when combined to deal with various
    data flows, the reactive programming can be advanced data flows with the ability
    to handle the following things:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 简要了解响应式编程，当与处理各种数据流相结合时，响应式编程可以是具有处理以下内容的高级数据流的能力：
- en: Event streams, streams we can tap into and subscribe, and then use subscription
    output as a data source.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件流，我们可以接入和订阅的流，然后使用订阅输出作为数据源。
- en: Having streams gives us the ability to manipulate streams, create new streams
    from original ones, and apply transformations as and when needed.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有流使我们能够操作流，从原始流创建新流，并根据需要应用转换。
- en: Transformations should work independently in a distributed system. A specific
    transformation can be the merge of several streams received from various places.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换应该在分布式系统中独立工作。特定的转换可以是从各个地方接收到的多个流的合并。
- en: 'Functional reactive programming is the variant of reactive programming that
    we are going to use. Briefly stated, our functional reactive microservice should
    have the following two fundamental properties:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用函数式响应式编程。简而言之，我们的函数式响应式微服务应具有以下两个基本属性：
- en: '**Signifying or denotative**: Each function, service, or type is precise, simple,
    single, responsible, and implementation-independent.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指示性或表示性**：每个函数、服务或类型都是精确、简单、单一、负责和实现无关的。'
- en: '**Continuous time**: Programming should keep in mind time-varying values. Variables
    in functional reactive programming have a value for a very short time. It should
    provide us transformation flexibility, efficiency, modularity, single responsibility.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续时间**：编程应该考虑到时间变化的值。函数式响应式编程中的变量值持续时间很短。它应该为我们提供转换灵活性、效率、模块化、单一责任。'
- en: 'The following are the characteristics of functional reactive programming:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式响应式编程的特点如下：
- en: '**Dynamic**: Knows how to react to time or to handle various input changes'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态**：知道如何对时间做出反应或处理各种输入变化'
- en: '**Handle time variations**: When reacting values change continuously, handle
    appropriate changes'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理时间变化：当反应值不断变化时，处理适当的变化
- en: '**Efficient**: When there is a change in input value, have a minimum amount
    of processing as and when required'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效**：当输入值发生变化时，只在需要时进行最少量的处理'
- en: '**Aware of historic transitions**: Maintain state changes locally and not globally'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**了解历史转换**：在本地维护状态变化，而不是全局'
- en: Now that we briefly know about reactive programming, let's look into what advantages
    we get while adopting reactive programming. The next section talks about and gives
    us very strong reasons for why you should drop everything and start reactive programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们简要了解了响应式编程，让我们看看在采用响应式编程时我们能得到什么优势。下一节将讨论并给出非常强烈的理由，说明为什么你应该放下一切开始响应式编程。
- en: Why should I consider adopting reactive programming?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我应该考虑采用反应式编程？
- en: 'Now that we have unveiled the mystery of reactive programming, the next big
    question is why we should care about reactive programming and what advantages
    we can get while doing reactive programming. In this section, we''ll see major
    benefits of reactive programming and how easily code can be managed to introduce
    major new functionalities at any point in time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经揭开了反应式编程的神秘面纱，下一个重要问题是为什么我们应该关注反应式编程以及在进行反应式编程时可以获得什么优势。在本节中，我们将看到反应式编程的主要优势以及如何轻松地管理代码，以在任何时候引入重大新功能：
- en: Easy to interpret or tap into any functions compared to callbacks or middleware.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与回调或中间件相比，更容易解释或利用任何功能。
- en: Handle errors and memory management easily, without any centralized configurations.
    A single subscription can have an error function in which you can easily dispose
    of the resources.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松处理错误和内存管理，无需任何集中配置。单个订阅可以有一个错误函数，您可以轻松地处理资源。
- en: Efficiently handle time-related complexities. Sometimes, we are bound by rate
    limiting constraints in calling some external APIs such as the Google Cloud Vision
    API. Reactive programming has immense use cases in such situations.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效处理与时间相关的复杂性。有时，我们受到调用一些外部API的速率限制约束，例如Google Cloud Vision API。在这种情况下，反应式编程具有巨大的用例。
- en: Go to market rate is faster. When correctively implemented, reactive programming
    drastically reduces old school code to a very few lines of code.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 走向市场率更快。当正确实施时，反应式编程大大减少了老式代码到很少的代码行。
- en: Easy-to-handle throttleable input streams, that is, my input stream is dynamic.
    It can increase or decrease as per demand.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于处理可节流的输入流，即，我的输入流是动态的。它可以根据需求增加或减少。
- en: Now that we have gone through some of the major advantages of reactive programming,
    in the next section we will talk about the outcome of reactive programming, a
    reactive system. We will see a set of standards defined in the Reactive Manifesto.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了反应式编程的一些主要优势，在下一节中我们将讨论反应式编程的结果，即反应式系统。我们将看到在反应式宣言中定义的一组标准。
- en: Reactive Manifesto
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式宣言
- en: A reactive system is meant to be more loosely coupled, flexible, easy to migrate,
    and easily scalable on demand. These qualities make it easy to develop, gracefully
    handle faults, and react to errors. Errors are met with elegance rather than claustrophobic
    disasters. Reactive systems are effective and instantly respond, giving effective
    and interactive feedback to users. In order to summarize all the traits of a reactive
    system, the **Reactive Manifesto** was introduced. In this section, we'll look
    at the Reactive Manifesto and all the criteria needed. Now, let's look at what
    the Reactive Manifesto states.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式系统旨在更松散耦合，灵活，易于迁移，并且可以根据需求轻松扩展。这些特质使其易于开发，优雅地处理故障，并对错误做出反应。错误会得到优雅的处理，而不是引起恐慌性灾难。反应式系统是有效的，并立即做出反应，为用户提供有效和互动的反馈。为了总结反应式系统的所有特征，引入了**反应式宣言**。在本节中，我们将看一下反应式宣言和所有所需的标准。现在，让我们看看反应式宣言陈述了什么。
- en: Responsive systems
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式系统
- en: As part of responsive criteria, reactive systems always need to be responsive.
    They need to provide and respond to the user in a timely manner. This improves
    user experience, and we can handle errors in a better way. Any failure in the
    service should not propagate to the system, as it can cause a series of errors.
    A response is an essential thing. A failed service should provide a response even
    if it is degraded.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为响应标准的一部分，反应式系统始终需要响应。它们需要及时地向用户提供和响应。这提高了用户体验，我们可以更好地处理错误。服务的任何故障都不应传播到系统，因为这可能会导致一系列错误。响应是一个重要的事情。即使服务降级，也应该提供响应。
- en: Resilient to errors
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对错误具有弹性
- en: 'Systems should be resilient to all errors. Resiliency should be such that errors
    are handled gracefully and not crash the entire system. A resilient architecture
    can be achieved by the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应该对所有错误具有弹性。弹性应该是这样的，错误应该得到优雅处理，而不是导致整个系统崩溃。可以通过以下方式实现弹性架构：
- en: Replication in order to make sure that there's a replica in case the main node
    goes down. This avoids single points of failure. In order to make sure that components
    or services should delegate services between them in such a way that single responsibility
    is handled.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制以确保在主节点出现故障时有一个副本。这避免了单点故障。为了确保组件或服务应该以这样一种方式委托服务，以便单一责任得到处理。
- en: Ensuring containment and isolation in the system so that the component is contained
    in its boundaries. It should prevent cascading errors. The client of a component
    is not burdened with handling its own failures.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保系统中的组件被包含在其边界内，以防止级联错误。组件的客户端不需要处理自己的故障。
- en: Elastic scalable
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性可扩展
- en: This is usually used to reference a system's capability to handle varying loads
    by increasing or decreasing the number of resources utilized in time. Reactive
    systems should be able to react to a point-in-time load and take actions on the
    available resources accordingly to provide a cost-effective solution, that is,
    or scaling down when resources are not required, scaling up but only to that percentage
    of resources that is needed in order to keep the cost of infrastructure under
    a preset value. The system should be able to shard or replicate components and
    distribute inputs among them. A system should have the ability to spawn new instances
    for downstream and upstream services for client service requests as and when needed.
    There should be an efficient service discovery process to aid elastic scaling.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于指代系统处理不同负载的能力，通过增加或减少在某个时间内利用的资源数量。反应式系统应该能够对某一时刻的负载做出反应，并相应地采取行动来提供成本效益的解决方案，即在资源不需要时缩减规模，在需要时仅扩展到所需资源的百分比，以保持基础设施成本在预设值以下。系统应该能够分片或复制组件，并在它们之间分发输入。系统应该能够根据需要为客户服务请求生成下游和上游服务的新实例。应该有一个高效的服务发现过程来帮助弹性扩展。
- en: Message-driven
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动
- en: Asynchronous message passing is the base of reactive systems. This helps us
    to establish boundaries between components and parallelly ensure loose coupling,
    isolation, and location transparency. If a particular component is not available
    now, the system should delegate failures as messages. This pattern helps us to
    enable load management, elasticity, and flow control by controlling the message
    queues in the system with the option of applying back pressure as and when needed.
    Non-blocking communication leads to less system overhead. There are many tools
    available for message passing such as **Apache Kafka**, **Rabbit MQ**, **Amazon
    Simple Queue Service**, **ActiveMQ**, **Akka**, and so on. Different modules of
    the code interact with each other via message passing. Thinking deeply about the
    Reactive Manifesto, microservices just seems to be an extension of the Reactive
    Manifesto.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 异步消息传递是反应式系统的基础。这有助于我们在组件之间建立边界，并同时确保松耦合、隔离和位置透明性。如果某个特定组件现在不可用，系统应该将失败委托为消息。这种模式帮助我们通过控制系统中的消息队列来实现负载管理、弹性和流量控制，并在需要时应用反压。非阻塞通信会减少系统开销。有许多可用于消息传递的工具，如Apache
    Kafka、Rabbit MQ、Amazon Simple Queue Service、ActiveMQ、Akka等。代码的不同模块通过消息传递相互交互。深入思考反应式宣言，微服务似乎只是反应式宣言的延伸。
- en: Major building blocks and concerns
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要构建模块和关注点
- en: Continuing on our reactive journey, we will now talk about major building blocks
    of reactive programming (functional reactive programming to be precise) and what
    concerns a reactive microservice should actually handle. The following is a list
    of major building blocks of reactive programming and what they all handle. A reactive
    microservice should be designed on similar principles. These building blocks will
    allow us to make sure that a microservice is isolated, has a single responsibility,
    can pass a message asynchronously, and is mobile.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的反应式之旅，我们现在将讨论反应式编程（确切地说是函数式反应式编程）的主要构建模块以及反应式微服务实际应该处理的关注点。以下是反应式编程的主要构建模块及其处理的内容。反应式微服务应该基于类似的原则进行设计。这些构建模块将确保微服务是隔离的，具有单一职责，可以异步传递消息，并且是可移动的。
- en: Observable streams
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察流
- en: 'An oservable streams is nothing but an array that is built over time. Instead
    of being stored in memory, items arrive asynchronously over time. Observables
    can be subscribed to, and events emitted by them can be listened to and reacted
    upon. Every reactive microservice should be able to deal with native observable
    streams of events. An observable allows you to emit values to the subscriber by
    calling the `next()` function in the series:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察流实际上就是随时间构建的数组。项目不是存储在内存中，而是随时间异步到达。可观察流可以被订阅，并且可以监听并对其发出的事件做出反应。每个反应式微服务都应该能够处理本机可观察事件流。可观察对象允许您通过调用系列中的`next()`函数向订阅者发出值。
- en: '**Hot and cold observables**: Observables are further classified into hot and
    cold, based on the producer of the subscription. If it needs to be created more
    than once, it is called a **hot observable**, whereas if it needs to be created
    only once, it is called a **cold observable**. Simply stated, hot observables
    usually *multicast,* while cold observables usually *unicast*. Taking a live example,
    when you open up any video on YouTube, each subscriber will see the same sequence,
    from start to end that''s basically a cold observable. However, when you open
    a live stream, you only can view the most recent view and see further on. This
    is a hot observable, where only a reference to the producer/subscriber is there
    and the producer is not created from the beginning of each subscription.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热和冷可观察流：可观察流根据订阅者的生产者进一步分类为热和冷。如果需要创建多次，则称为热可观察流，而如果只需要创建一次，则称为冷可观察流。简单来说，热可观察流通常是多播，而冷可观察流通常是单播。举个例子，当你在YouTube上打开任何视频时，每个订阅者都会看到相同的序列，从开始到结束，这基本上是一个冷可观察流。然而，当你打开一个直播流时，你只能看到最近的视图并进一步查看。这是一个热可观察流，其中只有对生产者/订阅者的引用，生产者并不是从每次订阅的开始创建的。
- en: '**Subjects**: A subject is just an observable that can call the `next()` method
    by itself in order to emit new values on demand. Subjects allow you to broadcast
    values from a common point while limiting the subscription to only one occurrence.
    A single shared subscription is created. A subject can be termed both an observer
    and as observable. It can act as a proxy for a group of subscribers. Subjects
    are used for implementing observables for general purpose utilities such as caching,
    buffering, logs, and so on.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：主题只是一个可以自行调用`next()`方法的可观察对象，以便根据需要发出新值。主题允许您从一个公共点广播值，同时限制订阅只发生一次。创建一个共享订阅。主题可以被称为观察者和可观察对象。它可以充当一组订阅者的代理。主题用于实现通用工具的可观察对象，如缓存、缓冲、日志等。'
- en: Subscription
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅
- en: While an observable is an array that fills over time, a **subscription** is
    a `for` loop that iterates over that array, which happens over time. A subscription
    provides easy to use and easy to dispose of methods, so there are no memory loading
    issues. On disposing of a subscription, an observable will stop listening to particular
    subscriptions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可观察对象是随时间填充的数组，但**订阅**是一个随时间迭代该数组的`for`循环。订阅提供了易于使用和易于处理的方法，因此没有内存加载问题。在取消订阅时，可观察对象将停止监听特定的订阅。
- en: emit and map
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射和映射
- en: When an observable throws out a value, there is a subscriber that listens to
    the value thrown by the observable. **emit** and **map** allow you to listen to
    this value and manipulate it as per your needs. For example, it can be used to
    convert a response of an HTTP observable to JSON. To further add-on to the chain,
    the `flatMap` operator is provided, which creates a new stream from the functions
    return value it receives.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个可观察对象抛出一个值时，有一个订阅者监听可观察对象抛出的值。**发射**和**映射**允许您监听这个值并根据您的需求对其进行操作。例如，它可以用于将HTTP可观察对象的响应转换为JSON。为了进一步扩展链，提供了`flatMap`操作符，它从函数的返回值创建一个新的流。
- en: Operator
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符
- en: 'When an observable emits values, they are not always in the form that we desire.
    Operators come in handy, as they help us to alter the way in which observables
    emit values. Operators can be used in the following stages:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个可观察对象发出值时，它们并不总是以我们期望的形式。操作符很有用，因为它们帮助我们改变可观察对象发出值的方式。操作符可以在以下阶段使用：
- en: While creating an observable sequence
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建可观察序列时
- en: Converting events or some asynchronous patterns to observable sequences
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件或一些异步模式转换为可观察序列
- en: Dealing with multiple observable sequences to combine them into single observables
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个可观察序列，将它们合并为单个可观察对象
- en: Sharing side effects of an observable
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享可观察对象的副作用
- en: Doing some mathematical transformations on observable sequences
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对可观察序列进行一些数学转换
- en: Time-based operations such as throttling
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的操作，如节流
- en: Handling exceptions
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Filtering values emitted by the observable sequence
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤可观察序列发出的值
- en: Grouping and windowing values emitted
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组和窗口化发出的值
- en: Backpressure strategy
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反压策略
- en: 'Up to now, we have played with observables and observers. We imitated our problem
    using streams of data (observables), transferred it to our desired output (using
    operators), and threw out some values or some side effects (observers). Now, a
    case can also occur where an observable is throwing out data faster than what
    the observer can process. This eventually leads to loss of data, which is called
    the **backpressure problem**. To handle back pressure, either we need to accept
    a loss of data or we need to buffer the observable stream and process it in chunks
    when losing data is not an option. Different strategies are available in both
    of the options:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经玩过可观察对象和观察者。我们使用数据流（可观察对象）模拟了我们的问题，将其转换为我们期望的输出（使用操作符），并丢弃了一些值或一些副作用（观察者）。现在，也可能出现这样一种情况，即可观察对象的数据抛出速度比观察者处理速度快。这最终导致数据丢失，这就是**反压问题**。为了处理反压，我们需要接受数据丢失，或者我们需要缓冲可观察流并在不允许数据丢失时以块的方式处理它。在这两种选择中都有不同的策略：
- en: '| **When losing is an option** | **When losing isn''t an option** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **当输掉是一个选择** | **当输掉不是一个选择** |'
- en: '| **Debouncing**: Emit data only after timespan has passed. | **Buffer**: Set
    an amount of time or max number of events to buffer. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **去抖动**：只有在经过一段时间后才发出数据。 | **缓冲**：设置一定时间或最大事件数来缓冲。 |'
- en: '| **Pausing**: Pause source stream for some time. | **BufferedPause**: Buffer
    whatever is emitted by the source stream. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **暂停**：暂停源流一段时间。 | **缓冲暂停**：缓冲源流发出的任何内容。 |'
- en: '|  | **Controlled Streams**: This is a push-pull strategy with the producer
    pushing events, and the consumer pulling only as much as it can process. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  | **受控流**：这是生产者推送事件，消费者只拉取它能够处理的事件的推送-拉取策略。 |'
- en: Currying functions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化函数
- en: '**Currying** is a process of evaluating function arguments one by one, at the
    end of each evaluation producing a new function with one argument less. Currying
    is useful when arguments of a function need to be evaluated at different places.
    Using the currying process, one argument may be evaluated at some component, then
    it can be passed to any other place, and then the result can be passed to another
    component until all the arguments are evaluated. This seems very similar to our
    microservices analogy. We will use currying later on when we have service dependencies.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**柯里化**是一个逐个评估函数参数的过程，在每次评估结束时产生一个少一个参数的新函数。当函数的参数需要在不同的地方进行评估时，柯里化是有用的。使用柯里化过程，一个参数可以在某个组件中进行评估，然后可以传递到任何其他地方，然后结果可以传递到另一个组件，直到所有参数都被评估。这似乎与我们的微服务类比非常相似。当我们有服务依赖关系时，我们将在以后使用柯里化。'
- en: When to react and when not to react (orchestrate)
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时做出反应，何时不做出反应（协调）
- en: Now, we are at a stage where we are well acquainted with the core concepts of
    microservices. The next question that we often interact with is regarding the
    implementation of microservices, and how they will interact with each other. The
    most common question is when to use orchestration, when to react, and is it possible
    to use a hybrid approach. In this section, we will understand each of the approaches,
    its pros and cons, and look at practical examples for the use of each approach.
    Let's start with orchestration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经熟悉了微服务的核心概念。我们经常接触的下一个问题是关于微服务的实现，以及它们如何相互交互。最常见的问题是何时使用编排，何时使用反应，以及是否可能使用混合方法。在本节中，我们将了解每种方法，其优缺点，并查看每种方法的实际示例。让我们从编排开始。
- en: Orchestration
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编排
- en: '**Orchestration** is more of a **Service Oriented Architecture (SOA)** approach
    where we handle interaction between various services in an SOA. When we say orchestration,
    we maintain one controller that is the orchestrator or the main coordinator of
    all the service interactions. This typically follows more of a request/response-type
    pattern where a mode of communication can be anything. For example, we can have
    one orchestrator in our shopping microservices that does the following tasks synchronously—first,
    take customer orders, then check the product, prepare a bill, and after successful
    payment, update the product inventory.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**编排**更多地是一种**面向服务的架构（SOA）**方法，在SOA中我们处理各种服务之间的交互。当我们说编排时，我们维护一个控制器，即编排者或所有服务交互的主协调者。这通常遵循更多的请求/响应类型模式，其中通信模式可以是任何东西。例如，在我们的购物微服务中可以有一个编排者，它同步执行以下任务——首先接受客户订单，然后检查产品，准备账单，成功付款后更新产品库存。'
- en: Benefits
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: It provides a systematic way to handle the flow of the programming, where you
    can actually control the manner in which requests are made. For example, you can
    ensure that request B can be successfully invoked only after request A completes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一种系统化的处理编程流程的方式，您可以实际控制请求的发出方式。例如，您可以确保只有在请求A完成后才能成功调用请求B。
- en: Disadvantages
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'While the orchestration pattern may look beneficial, there are several trade-offs
    involved in this pattern, such as:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编排模式看起来有利，但这种模式涉及到一些权衡，比如：
- en: There is a tight dependency on the system. Say if one of the initial services
    is down, then the next services in the chain will never be called. The system
    can soon become a bottleneck as several single points of failure would be there.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对系统有严格的依赖。比如如果最初的某个服务宕机，那么链中的下一个服务将永远不会被调用。系统很快就会成为一个瓶颈，因为会有几个单点故障。
- en: Synchronous behavior would be introduced in the system. The total end to end
    time taken would be the sum of the time taken to process all of the individual
    services.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中将引入同步行为。总的端到端时间将是处理所有单个服务所需时间的总和。
- en: Reactive approach
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式方法
- en: Microservices are meant to coexist on their own. They are not meant to be dependent
    on each other. A **reactive approach** tends to solve some of the challenges of
    an orchestration approach. Instead of having a controlling orchestrator that takes
    care of the logic for which steps to happen at what stage, a reactive pattern
    promotes the service knowing the logic to be built in and executed ahead of time.
    The services know what to react to and how to deal with it ahead of time. The
    communication mode for services are dumb pipes and they don't have any logic inside
    them. Being asynchronous in nature, it removes the waiting part of the orchestration
    process. Services can produce events and keep on processing. Producing and consuming
    services are decoupled, so the producer doesn't need to know whether the consumer
    is up or not. There can be multiple patterns in this approach where producers
    may want to receive an acknowledgment from consumers. The centralized event stream
    takes care of all these things in a reactive approach.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是为了能够独立存在的。它们不应该相互依赖。**反应式方法**倾向于解决编排方法的一些挑战。与控制逻辑在何时发生哪些步骤的编排器不同，反应式模式促进了服务知道逻辑要提前构建和执行。服务知道要对什么做出反应以及如何提前处理。服务之间的通信模式是愚蠢的管道，它们内部没有任何逻辑。由于其异步性质，它消除了编排过程中的等待部分。服务可以产生事件并继续处理。生产和消费服务是解耦的，因此生产者不需要知道消费者是否在线。在这种方法中可以有多种模式，其中生产者可能希望从消费者那里收到确认。集中的事件流在反应式方法中处理所有这些事情。
- en: Benefits
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: 'The reactive approach has lots of advantages and it overcomes lots of traditional
    problems:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式方法有很多优势，它克服了许多传统问题：
- en: Parallel or asynchronous execution gives faster end to end processing. Asynchronous
    processing essentially won't prevent resource blocking while serving a request.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行或异步执行可以更快地完成端到端处理。异步处理基本上不会在提供请求时阻止资源。
- en: Having a centralized event stream or a dumb communication pipe as a mode of
    communication has the advantage of easily adding or removing any service at any
    point in time.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有集中的事件流或愚蠢的通信管道作为通信模式具有在任何时间点轻松添加或删除任何服务的优势。
- en: Control of the system is distributed. There is no longer a single point of failure
    in the system as the orchestrator.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的控制是分布式的。系统中不再有单一故障点作为编排者。
- en: When this approach is clubbed with several other approaches, then various benefits
    can be achieved.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当这种方法与其他几种方法结合时，就可以实现各种好处。
- en: When this approach is clubbed with event sourcing, all the events are stored
    and it enables event replay. So even if some service is down, the event store
    can still replay that event when the service is online again and the service can
    check up on updates.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当这种方法与事件溯源结合时，所有事件都被存储，并且它可以进行事件重放。因此，即使某个服务宕机，事件存储仍然可以在服务再次在线时重放该事件，并且服务可以检查更新。
- en: Another advantage is **Command Query Responsibility Segregation** (**CQRS**). As
    seen in [Chapter 1](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml), *Debunking Microservices*,
    we can apply this pattern to separate out the read and write activities. Hence,
    any of the services can be scaled out independently. This is extremely helpful
    in situations where applications are either read or write heavy.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个优点是**命令查询责任分离**（**CQRS**）。如[第1章](2eeeb09d-ecd0-403b-8a64-ac754090cebe.xhtml)所示，*揭秘微服务*，我们可以将这种模式应用于分离读取和写入活动。因此，任何服务都可以独立扩展。这在应用程序是读取或写入密集型的情况下非常有帮助。
- en: Disadvantages
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'While this approach does solve most of the complexities, it introduces a few
    trade-offs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法解决了大部分复杂性，但也引入了一些权衡：
- en: Asynchronous programming can sometimes be painful to handle. It can't be figured
    out by just looking at the code. A thorough understanding of Event Loop as shown
    in [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing up for the
    Journey*, is must to understand the actual workflow in *async coding*.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程有时可能很难处理。仅通过查看代码无法弄清楚。必须深入了解事件循环，如[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)所示，*为旅程做准备*，才能理解*异步编码*的实际工作流程。
- en: Complexity and centralized code are now shifted in individual services. The
    flow control is now broken up and distributed across all the services. This may
    introduce redundant code in the system.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂性和集中的代码现在转移到了各个服务中。流程控制现在被分解并分布到所有服务中。这可能会在系统中引入冗余代码。
- en: Like everything, a one-size-fits-all approach doesn't work here. Several hybrid
    approaches have come along, which take advantage of both processes. Let's now
    take a look at some hybrid approaches. A hybrid approach can add a lot of value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有事物一样，一刀切的方法在这里行不通。出现了几种混合方法，它们充分利用了两种过程。现在让我们来看看一些混合方法。混合方法可以增加很多价值。
- en: React outside, orchestrate inside
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部反应，内部编排
- en: 'The first hybrid patterns promote reactive patterns between different microservices
    and orchestration inside a service. Let''s consider an example to understand this.
    Consider our shopping microservices example. Whenever someone buys a product,
    we will check inventory, calculate price, process payment, check out payment,
    add recommendation products, and so on. Each of these microservices would be different.
    Here, we can have a reactive approach between product inventory service, payment
    service, and recommendation products, and an orchestration approach between checkout
    service, process payment, and dispatch product. A collective service produces
    an event based on the outcome of all these three services, which can then be produced.
    There are several advantages and value additions, such as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个混合模式促进了不同微服务之间的反应式模式和服务内的编排。让我们举个例子来理解这一点。考虑我们的购物微服务示例。每当有人购买产品时，我们将检查库存，计算价格，处理付款，结账付款，添加推荐产品等。每个微服务都是不同的。在这里，我们可以在产品库存服务、付款服务和推荐产品之间采用反应式方法，在结账服务、处理付款和发货产品之间采用编排方法。一个集体服务根据这三个服务的结果产生一个事件，然后可以产生。有几个优点和附加值，例如：
- en: Most of the services are decoupled. Orchestration only comes into the picture
    whenever it is required. The overall flow of the application is distributed.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数服务是解耦的。只有在需要时才会出现编排。应用程序的整体流程是分布式的。
- en: Having asynchronous events and an event-based approach ensures no single point
    of failure. If events are missed out by services, then events can be replayed
    whenever the service is available online.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有异步事件和基于事件的方法可确保没有单点故障。如果服务错过了事件，那么可以在服务再次上线时重放事件。
- en: 'While there are several advantages, there are some trade-offs introduced:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几个优点，但也引入了一些权衡：
- en: If services are coupled, then they can soon become a single point of failure.
    They cannot be scaled independently.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务耦合在一起，它们很快就会成为单点故障。它们无法独立扩展。
- en: Synchronous processing can cause system blocking and resources would be occupied
    until the request is fully completed.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步处理可能会导致系统阻塞，资源会被占用，直到请求完全完成。
- en: Reactive coordinator to drive the flow
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动流程的反应式协调器
- en: 'The second approach introduces something more like a reactive orchestrator
    to drive the flow between various services. It uses more of a command-based and
    event-based approach to control the overall flow of the entire ecosystem. Commands
    indicate things that need to be done and events are outcomes of the commands that
    are done. The reactive coordinator takes in requests and produces commands, then
    pushes them to the event stream. Various microservices that are already set up
    for the commands consume those commands, do some processing, and then throw out
    an event when the command is successfully done and executed. The reactive coordinator
    consumes those events and reacts to the events as programmed and as and when necessary.
    This approach has several value additions, such as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法引入了更像是反应式协调器的东西，用于驱动各种服务之间的流程。它更多地使用基于命令和基于事件的方法来控制整个生态系统的整体流程。命令指示需要完成的任务，事件是完成命令的结果。反应式协调器接收请求并生成命令，然后将其推送到事件流中。已经为命令设置的各种微服务消耗这些命令，进行一些处理，然后在成功执行命令时抛出一个事件。反应式协调器消耗这些事件，并根据需要编程和反应事件。这种方法有几个附加值，例如：
- en: Services are decoupled; even though there seems to be a coupling between the
    coordinator and services, the reactive approach and centralized event stream takes
    care of most of the previous drawbacks.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是解耦的；即使协调器和服务之间似乎存在耦合，但反应式方法和集中的事件流解决了大部分以前的缺点。
- en: An event stream or centralized event bus ensures asynchronous programming between
    microservices. Events can be replayed on demand. There are no single points of
    failure.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件流或集中的事件总线确保微服务之间的异步编程。事件可以按需重放。没有单点故障。
- en: Overall flow can be centralized in one place in the reactive coordinator. All
    such centralized logic can be kept there and there won't be any duplicated code
    anywhere.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体流程可以在反应式协调器中集中在一个地方。所有这样的集中逻辑都可以在那里保留，而且任何地方都不会有重复的代码。
- en: While there are lots of benefits, there is the following trade-off introduced
    by this approach—the coordinator needs to be taken care of. If the coordinator
    goes down, the entire system can be impacted. The coordinator needs to know what
    commands are needed in order to react or perform a preset of actions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有很多好处，但这种方法引入了以下权衡——协调器需要被照顾。如果协调器出现问题，整个系统可能会受到影响。协调器需要知道需要哪些命令以便做出反应或执行一组预设动作。
- en: Synopsis
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: After going through all the approaches, pure reactive, pure orchestration, and
    two different hybrid approaches, we will now go through various use cases in which
    we can apply the preceding four approaches. We will now learn which approach fits
    where.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了纯反应式、纯编排和两种不同的混合方法之后，我们现在将介绍可以应用前面四种方法的各种用例。我们将学习哪种方法适用于哪种情况。
- en: When a pure reactive approach is a perfect fit
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当纯反应式方法是一个完美的选择时
- en: 'In the following scenarios, a purely reactive approach is a perfect fit:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，纯粹的反应式方法是一个完美的选择：
- en: When most of the processing in your application can be done asynchronously.
    When you can have parallel processing in your application, the reactive architecture
    pattern is a great fit for processing application needs.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序中的大部分处理可以异步完成时。当应用程序可以进行并行处理时，反应式架构模式非常适合处理应用程序需求。
- en: Decentralizing the application flow in each service is manageable and it doesn't
    become a pain in the neck. For monitoring and auditing, centralized views can
    be generated using correlation IDs (**UUID**, **GUID**, **CUID**).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个服务中分散应用程序流程是可以管理的，而且不会成为一个痛点。对于监控和审计，可以使用相关ID（**UUID**，**GUID**，**CUID**）生成集中视图。
- en: When the application needs to be deployed quickly and speed to market is a top-most
    goal. When microservices are combined with a reactive approach, it helps to increase
    decoupling, minimize dependencies, handle temporary shutoff situations, and thus
    help to get products get faster to market.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序需要快速部署，市场速度是最重要的目标。当微服务与反应式方法结合时，它有助于增加解耦，最小化依赖关系，处理临时关闭的情况，从而有助于更快地将产品推向市场。
- en: When pure orchestration is a perfect fit
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当纯编排是一个完美的选择
- en: 'In the following scenarios, a pure orchestration approach is a perfect fit:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，纯编排方法是一个完美的选择：
- en: When your application's needs are not fulfilled by parallel processing. All
    the steps have to be done with sequential processing and there are zero opportunities
    for parallel processing.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序的需求无法通过并行处理满足时。所有步骤必须按顺序进行处理，没有机会进行并行处理。
- en: If the application needs demand centralized flow control. Various domains such
    as **banking** and **ERP** have needs where viewing the end to end flow in one
    place is a high priority. If there are 100 services, each with their own flow
    of control, then maintaining a centralized flow may soon become a bottleneck in
    distribution.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序需要集中的流程控制。各个领域，如**银行**和**ERP**，都有需要在一个地方查看端到端流程的需求。如果有100个服务，每个服务都有自己的控制流程，那么维护集中的流程可能很快成为分发的瓶颈。
- en: When react outside, orchestrate inside is a perfect fit
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在外部反应，内部编排是一个完美的选择
- en: 'In the following scenarios, a hybrid approach, more specifically react outside,
    orchestrate inside, is a perfect fit:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，混合方法，更具体地说是在外部反应，在内部编排，是一个完美的选择：
- en: Most of your processing can be done asynchronously. Your services can communicate
    with each other via an event stream and you can have parallel processing in the
    system, that is, you can pass data via event streams or commands based on your
    system. For example, whenever payment is successfully credited, then one microservice
    to show related products and one microservice to dispatch orders to the seller.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分处理可以异步完成。您的服务可以通过事件流相互通信，并且您可以在系统中进行并行处理，也就是说，您可以通过事件流或基于系统的命令传递数据。例如，每当付款成功入账时，一个微服务显示相关产品，另一个微服务将订单发送给卖家。
- en: Decentralizing flow in each microservice is easily manageable and there is not
    duplicated code everywhere.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个微服务中分散流程很容易管理，而且不会在各处重复代码。
- en: Speed to market is the main priority.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场速度是主要优先事项。
- en: Sequential steps don't apply within the system and they apply within the service.
    As long as sequential steps don't apply across the system.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序步骤不适用于系统，但适用于服务。只要顺序步骤不适用于整个系统。
- en: When introducing a reactive coordinator is the perfect fit
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入反应式协调器是完美的选择时
- en: 'In the following scenarios, introducing a reactive coordinator is the perfect
    solution:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，引入一个反应式协调器是完美的解决方案：
- en: Based on the data being processed, the flow of the application can change. The
    flow could have several hundred microservices and application demands temporary
    shut-ins and as soon as the application gets back online events can be replayed.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据正在处理的数据，应用程序的流程可能会发生变化。流程可能包括数百个微服务，应用程序需要临时关闭，一旦应用程序恢复在线，事件就可以被重放。
- en: There are several asynchronous processing blocks that need to be processed synchronously
    in the system.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中有几个需要同步处理的异步处理块。
- en: It allows easy service discovery. Services can easily be scaled at any time.
    Moving the entire service can be easily done.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许轻松的服务发现。服务可以随时轻松扩展。整个服务可以轻松地移动。
- en: Based on your overall needs, you can decide on any one of the strategies in
    your microservice architecture.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的整体需求，您可以在微服务架构中选择任何一种策略。
- en: Being reactive in Node.js
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Node.js中成为反应式
- en: Now that we have gone through the concepts of reactive programming and advantages
    of reactive programming in microservices, let's now look at some practical implementations
    of reactive programming in Node.js. In this section, we will understand the building
    blocks of reactive programming by seeing implementations of reactive programming
    in Node.js.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了响应式编程的概念和在微服务中的优势，让我们现在看看在Node.js中响应式编程的一些实际实现。在本节中，我们将通过在Node.js中实现响应式编程来了解响应式编程的构建模块。
- en: Rx.js
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rx.js
- en: 'This is one of the most trending libraries and it is actively maintained. This
    library is available for most programming languages in different forms such as
    **RxJava**, **RxJS**, **Rx.Net**, **RxScala**, **RxClojure**, and so on. At the
    time of writing, it had more than 40 lakh downloads in the last month. Besides
    this, a huge amount of documentation and online support is available for this.
    We will be using this library most of the time, except when the need arises. You
    can check this out at: [http://reactivex.io/](http://reactivex.io/). At the time
    of writing, the stable version of Rx.js was **5.5.6**. Rx.js has lots of operators.
    We can use the Rx.js operators for various things such as combining various things,
    applying conditions as and when needed, creating new observables from promises
    or events, error handling, filtering data, having a publisher-subscriber pattern,
    transforming data, request-response utilities, and so on. Let''s have a quick
    hands on. In order to install RxJS, we need to install the Rx package and Node-Rx
    bindings. Open up a Terminal and shoot `npm install rx node-rx --save`. We will
    need one more module as this library has to support our Node.js as a build system.
    Hit this command in the Terminal—`npm install @reactivex/rxjs --save`. Throughout
    the chapter, we will be using our `Hello World` microservices skeleton, which
    we just created in [Chapter 2](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml), *Gearing
    up for the Journey*, and continuing further with this. The following are various
    options that we are going to see in the demo:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最流行的库之一，它得到了积极的维护。该库以不同形式提供给大多数编程语言，如**RxJava**、**RxJS**、**Rx.Net**、**RxScala**、**RxClojure**等。在撰写本文时，上个月的下载量超过40万次。除此之外，该库还有大量的文档和在线支持可用。我们将大部分时间使用这个库，除非需要其他库。您可以在以下网址查看：[http://reactivex.io/](http://reactivex.io/)。在撰写本文时，Rx.js的稳定版本是**5.5.6**。Rx.js有很多操作符。我们可以使用Rx.js操作符进行各种操作，如组合各种内容，根据需要应用条件，从承诺或事件创建新的observables，错误处理，过滤数据，具有发布者-订阅者模式，转换数据，请求-响应工具等。让我们快速动手试试。为了安装RxJS，我们需要安装Rx包和Node-Rx绑定。打开终端并输入`npm
    install rx node-rx --save`。由于此库需要支持我们的Node.js作为构建系统，因此我们还需要安装一个模块。在终端中输入以下命令：`npm
    install @reactivex/rxjs --save`。在本章中，我们将使用我们在[第2章](c1987454-3c62-4e25-abf5-28a9abf833e8.xhtml)中创建的`Hello
    World`微服务骨架，并继续进行。以下是我们将在演示中看到的各种选项：
- en: '| `forkjoin` | When we have a group of observables and we want only the last
    value. This cannot be used if one of the observable never completes. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `forkjoin` | 当我们有一组observable并且只想要最后一个值时使用。如果其中一个observable永远不完成，则无法使用此操作符。
    |'
- en: '| `combineAll` | It just flattens/combines an observable of observables by
    waiting for an outer observable to complete and then automatically applying `combineLatest`.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `combineAll` | 通过等待外部observable完成，然后自动应用`combineLatest`来简化/组合observable的observable。
    |'
- en: '| `race` | The observable whose value is emitted first will be used. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `race` | 首先发出值的observable将被使用。 |'
- en: '| `retry` | Retries an observable sequence a specific number of times should
    an error occur. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `retry` | 如果发生错误，重试特定次数的observable序列。 |'
- en: '| `debounce` | Ignores emitted values that take less than a specified time.
    Example, if we set debounce to one second, then any values that are emitted before
    one second will be ignored. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `debounce` | 忽略少于指定时间的发出值。例如，如果我们将防抖设置为一秒，那么在一秒之前发出的任何值都将被忽略。 |'
- en: '| `throttle` | Emits a value only when a duration determined by the provided
    function has passed. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `throttle` | 仅在由提供的函数确定的持续时间后发出值。 |'
- en: 'The following example throttles values until two seconds:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将值节流到两秒钟：
- en: '[PRE0]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following example will trigger a race condition on observables:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将在observables上触发竞争条件：
- en: '[PRE1]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can follow along with the source at `using_rxjs` in a source folder. An
    example of all the operators in the preceding table can be found at `rx_combinations.ts`,
    `rx_error_handing.ts`, and `rx_filtering.ts`. A full list of API's can be found
    at [http://reactivex.io/rxjs/](http://reactivex.io/rxjs/).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在源文件夹中的`using_rxjs`中跟随源代码。在前面的表中，可以在`rx_combinations.ts`、`rx_error_handing.ts`和`rx_filtering.ts`中找到所有操作符的示例。可以在[http://reactivex.io/rxjs/](http://reactivex.io/rxjs/)找到完整的API列表。
- en: Bacon.js
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bacon.js
- en: '**Bacon.js** is a small, compact functional reactive programming library. When
    integrated with Node.js, you can easily turn your spaghetti code into clean, declarative
    code. It has more than 29,000 downloads a month. At the time of writing, the version
    available was **1.0.0**. Let''s have a quick hands on. In order to install Bacon.js,
    we need to install Bacon.js and its typings. Open up a Terminal and shoot `npm
    install baconjs --save` and `npm install @types/baconjs --only=dev`. Now, let''s
    see one basic example where we will see how clean the code looks. We have one
    JSON object where some products are mapped with a number `1` for `mobile`, `2` for
    `tv`, and so on. We create one service to return the product name and if the product
    is not there, it should return `Not found`. The following is the service code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bacon.js**是一个小巧的函数式响应式编程库。与Node.js集成后，您可以轻松将混乱的代码转换为清晰的声明式代码。它每月的下载量超过29,000次。在撰写本文时，可用的版本是**1.0.0**。让我们快速动手试试。为了安装Bacon.js，我们需要安装Bacon.js及其类型。打开终端并输入`npm
    install baconjs --save`和`npm install @types/baconjs --only=dev`。现在，让我们看一个基本示例，看看代码有多清晰。我们有一个JSON对象，其中一些产品与数字`1`（手机）、`2`（电视）等相对应。我们创建一个服务来返回产品名称，如果产品不存在，则应返回`Not
    found`。以下是服务代码：'
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the controller code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制器代码：
- en: '[PRE3]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can follow along with the source code at `using_baconjs` in the source folder.
    A full list of APIs can be found at [https://baconjs.github.io/api.html](https://baconjs.github.io/api.html).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在源文件夹中的`using_baconjs`中查看源代码。完整的API列表可以在[https://baconjs.github.io/api.html](https://baconjs.github.io/api.html)找到。
- en: HighLand.js
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HighLand.js
- en: This is more of a generic functional library and it is built on top of Node.js
    streams, thus allowing it to handle asynchronous and synchronous code. One of
    the best features of **HighLand.js** is the way it handles backpressure. It has
    a built-in feature for pausing and buffering, that is, when the client is not
    able to handle any more data, the stream will be paused until it's ready, and
    if the source can't be paused then it will maintain a temporary buffer until normal
    operations can be resumed. Time to get our hands dirty with a practical example.
    Let's deviate from the express theme and focus on a file-reading theme. We will
    see the power of Node.js I/O operations with parallel executions that can take
    place. Shoot up a Terminal and hit `npm install highland --save`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是一个通用的函数库，它是建立在Node.js流之上的，因此允许它处理异步和同步代码。**HighLand.js**最好的特点之一是它处理背压的方式。它具有用于暂停和缓冲的内置功能，也就是说，当客户端无法处理更多数据时，流将被暂停，直到准备好，如果源无法暂停，那么它将保持一个临时缓冲区，直到可以恢复正常操作。是时候用一个实际的例子来动手了。让我们偏离express主题，专注于文件读取主题。我们将看到Node.js
    I/O操作与并行执行的强大功能。打开终端并输入`npm install highland --save`。
- en: 'Going with our previous skeleton, create `index.ts` with the following code,
    which basically reads three files and prints their contents:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的骨架，创建`index.ts`，其中包含以下代码，基本上读取三个文件并打印它们的内容：
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Transpile the file, keep three `.txt` files parallel to `package.json`, and
    run the `node` file. The contents will be read. You can follow along with the
    project at `using_highlandjs` in the `src` folder of the source code. A full list
    of APIs is available at [http://highlandjs.org/](http://highlandjs.org/).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 转换文件，保持三个`.txt`文件与`package.json`平行，并运行`node`文件。内容将被读取。您可以在源代码的`src`文件夹中的`using_highlandjs`项目中跟踪。完整的API列表可以在[http://highlandjs.org/](http://highlandjs.org/)找到。
- en: Key takeaways
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要观点
- en: 'Now that we have seen all three libraries, we will summarize the following
    key points and salient features:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了这三个库，我们将总结以下关键点和显著特点：
- en: '|  | **Rx.js** | **Bacon.js** | **Highland.js** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  | **Rx.js** | **Bacon.js** | **Highland.js** |'
- en: '| **Documentation** | Well documented, very mature APIs along with lots of
    options, has extensions in other languages. | Fewer examples for Node.js, great
    API docs, native support for Node.js. | Very little documentation and fewer helper
    methods, evolving footprint. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **文档** | 文档完善，API非常成熟，有很多选项，在其他语言中也有扩展。 | Node.js示例较少，API文档很好，对Node.js有原生支持。
    | 文档很少，辅助方法较少，发展中的足迹。'
- en: '| **Backpressure** | Implemented. | Not supported. | Best implementation. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **背压** | 已实现。 | 不支持。 | 最佳实现。'
- en: '| **Community** | Used by big companies such as Netflix, and Microsoft. Has
    similar concepts in all other languages, more like Java, learning curve. | Smaller
    than Rx.js, reduced learning curve compared to Rx.js. | Least active community,
    have to dig right into the code base. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **社区** | 被Netflix和微软等大公司使用。在所有其他语言中都有类似的概念，更像是Java，学习曲线陡峭。 | 比Rx.js小，学习曲线降低。
    | 社区活动最少，必须直接深入代码库。'
- en: '| **Licenses** | Apache 2.0 | MIT | Apache 2.0 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **许可证** | Apache 2.0 | MIT | Apache 2.0'
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the Reactive Manifesto. We clubbed reactive
    principles and applied them in microservices. We learned how to apply reactive
    programming in Node.js. We learned about possible approaches to design the microservice
    architecture, saw its advantages and disadvantages, and saw some practical scenarios
    to find out in which situations we can apply those patterns. We saw orchestration
    processes, reaction processes, and two special cases of hybrid approaches.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了响应式宣言。我们将响应式原则应用于微服务。我们学习了如何在Node.js中应用响应式编程。我们了解了设计微服务架构的可能方法，看到了它的优点和缺点，并看到了一些实际场景，以找出在哪些情况下可以应用这些模式。我们看到了编排过程、反应过程和两种混合方法的特殊情况。
- en: In the next chapter, we will begin developing our shopping cart microservices.
    We will design our microservice architecture, write some microservices, and deploy
    them. We will see how to organize our code into the proper structure.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始开发我们的购物车微服务。我们将设计我们的微服务架构，编写一些微服务，并部署它们。我们将看到如何将我们的代码组织成适当的结构。
