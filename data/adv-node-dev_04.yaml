- en: MongoDB, Mongoose, and REST APIs – Part 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB、Mongoose和REST API - 第3部分
- en: In this chapter, you're going to resolve the Mongoose queries and ID validation
    after playing with Mongoose in the previous chapter. We will get into the details
    of different types of todo methods followed by deploying the API to Heroku. Finally,
    after learning more about Postman environments and running various test cases,
    we will create our test database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将在玩弄Mongoose之后解决Mongoose查询和ID验证的问题。我们将深入了解不同类型的todo方法，然后将API部署到Heroku。最后，在学习更多关于Postman环境和运行各种测试用例之后，我们将创建我们的测试数据库。
- en: Mongoose queries and ID validation
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoose查询和ID验证
- en: In this section, you're going to learn a few alternative ways that you can use
    Mongoose to query your data. Now, inside of the `server.test` file, we already
    looked at one way, `Todo.find`. We're going to look at two more and then we're
    also going to explore how to validate ObjectIDs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将学习一些使用Mongoose查询数据的替代方法。现在，在`server.test`文件中，我们已经看过一种方法，`Todo.find`。我们将再看两种方法，然后我们还将探讨如何验证ObjectIDs。
- en: 'In order to do all of this we are going to make a new file in the `playground`
    folder. I''m going to call this one `mongoose-queries.js`, and the first thing
    we need to do is load in the `mongoose` file in the `db` folder and the `todo`
    file in the `models` folder. I''m going to use ES6 destructuring, like we''ve
    used for all files where this happens, then we can `require` in the local file.
    Using the relative path, we need to go up a directory out of `playgroundserverdb`,
    and finally the filename we''re looking for is called `mongoose`:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一切，我们将在`playground`文件夹中创建一个新文件。我将把这个文件命名为`mongoose-queries.js`，我们需要做的第一件事是加载`db`文件夹中的`mongoose`文件和`models`文件夹中的`todo`文件。我将使用ES6解构，就像我们在发生这种情况的所有文件中使用的那样，然后我们可以在本地文件中`require`。使用相对路径，我们需要返回到`playgroundserverdb`的上一级目录，最后我们要找的文件名叫做`mongoose`：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can do the same thing for `todo`; we''re going to make that constant `Todo`
    from the `require`, return the result, and the file here is going to follow the
    same path. We need to go back a directory and into `server`, but instead of going
    into `db` we''ll go into `models`. Then we''ll get the `todo` file:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对`todo`做同样的事情；我们将从`require`中使得常量`Todo`返回结果，文件将遵循相同的路径。我们需要返回到上一级目录并进入`server`，但是不是进入`db`而是进入`models`。然后我们会得到`todo`文件：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, before we can actually do any querying, we are going to grab an ID for
    one of our existing Todos over in Robomongo. In the `TodoApp` database I''m going
    to explore all of our documents and I''ll just grab the first one:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们实际进行任何查询之前，我们将在Robomongo中获取一个现有Todos的ID。在`TodoApp`数据库中，我将浏览所有文档，然后我会获取第一个文档的ID：
- en: '![](img/3b212db1-09be-4c05-8b05-f3b72f3db2cd.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b212db1-09be-4c05-8b05-f3b72f3db2cd.png)'
- en: I'll right-click to edit it, then I can grab the ID excluding the quotes, parentheses,
    and the `ObjectId` identifier. With this ID in the clipboard back inside of Atom
    I can make a variable called `id` and set it equal to the ID I just copied inside
    of single quotes, and now we have an ID and we can use this for all of our querying.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我会右键单击进行编辑，然后我可以获取ID，不包括引号、括号和`ObjectId`标识符。有了这个ID在剪贴板中，回到Atom中我可以创建一个名为`id`的变量，并将其设置为我刚刚复制的ID，然后我们就有了一个ID，我们可以用它来进行所有的查询。
- en: Todo.find method
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Todo.find方法
- en: 'Now, I understand you''ve already used `Todo.find` before but we are going
    to talk about a few other things. So for the moment we will be starting with that.
    `Todo.find` lets you query as many Todos as you like. You can pass in no arguments
    to get all your Todos back, or you can query by anything. We''re going to query
    by `_id`. Now, Mongoose is fantastic, it doesn''t require you to pass in ObjectIDs,
    as it can actually do that for you. In this case, what we have is perfectly valid.
    We pass in a string as the value, and Mongoose is going to take that string, it''s
    going to convert it to an ObjectID, and then it''s going to run the query. This
    means we don''t need to manually convert our string into an ObjectID. Now, after
    we make the query we can attach a `then` callback, we''re going to get all of
    our Todos, we''ll name that argument and we can go ahead and print them to the
    screen, `console.log(''Todos'',)` and the second argument will be the actual `todos`
    array:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我明白你之前已经使用过`Todo.find`，但我们将讨论一些其他事情。所以我们将从那里开始。`Todo.find`允许您查询尽可能多的Todos。您可以不传递任何参数来获取所有的Todos，或者您可以按任何条件查询。我们将按`_id`查询。现在，Mongoose非常棒，它不需要您传递ObjectIDs，因为它实际上可以为您做到这一点。在这种情况下，我们所做的是完全有效的。我们传递一个字符串作为值，Mongoose将接受该字符串，将其转换为ObjectID，然后运行查询。这意味着我们不需要手动将我们的字符串转换为ObjectID。现在，在我们进行查询之后，我们可以附加一个`then`回调，我们将得到所有的Todos，我们将命名该参数，然后可以继续将它们打印到屏幕上，`console.log('Todos',)`，第二个参数将是实际的`todos`数组：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Nothing new here aside from the fact that you can indeed pass in an `id` as
    a string.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以将`id`作为字符串传递之外，这里没有什么新的东西。
- en: Todo.findOne method
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Todo.findOne方法
- en: 'The next method we''re going to look at is one called `Todo.findOne`. Now,
    `Todo.findOne` is very similar to find, the only difference is that it returns
    one document at most. That means it simply grabs the first one that matches the
    query you have. In our case we''re querying by a unique ID, so it''s only going
    to find one matching item, but if there were other results, for example, if we
    queried all Todos with completed false, the first doc would be the only one that
    returns, even though there''s two that match the query. What we can do to call
    `findOne` is identical to what we did with find, and to prove it I''m actually
    going to copy the code. All we need to do is change a few things. Instead of `todos`,
    we get `todo`, and we''re just going to get a single document not an array of
    documents. That means I can print a `Todo` string followed by the `todo` variable:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要看的方法是一个叫做`Todo.findOne`的方法。现在，`Todo.findOne`非常类似于find，唯一的区别是它最多返回一个文档。这意味着它只是简单地获取与您查询匹配的第一个文档。在我们的例子中，我们通过唯一的ID进行查询，所以它只会找到一个匹配的项目，但是如果有其他结果，例如，如果我们查询所有completed为false的Todos，第一个文档将是唯一返回的，即使有两个匹配查询的。我们调用`findOne`的方式与我们用find的方式是一样的，为了证明这一点，我实际上要复制代码。我们只需要改变一些东西。我们不再是得到`todos`，而是得到`todo`，我们只是得到一个单独的文档而不是一组文档。这意味着我可以打印一个`Todo`字符串，然后是`todo`变量：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this in place we now have enough examples where it makes sense to run the
    file and see exactly what happens.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有足够的例子来运行文件并看看到底会发生什么。
- en: 'Over inside of the Terminal I''m going to kick things off by running this file,
    and I''ll run it using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端内部，我将通过运行这个文件来开始一些事情，并且我将使用以下命令来运行它：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we run the file, we get our `Todos` array, our array of one document,
    and we get our `Todo` object:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行文件时，我们得到我们的`Todos`数组，我们得到一个文档的数组，我们得到我们的`Todo`对象：
- en: '![](img/d4e624d9-1dc2-46eb-b809-c0e8822d156e.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4e624d9-1dc2-46eb-b809-c0e8822d156e.png)'
- en: If you know you're just trying to fetch one individual item, I recommend using
    `findOne` over `find`. You get back the document as opposed to an array. This
    also makes it a lot easier when the ID of the Todo you're looking for doesn't
    exist; instead of getting an empty array as the result you'll get `null` back
    and you can work with that, doing whatever you like. Maybe that means you return
    a 404 or maybe you want to do something else if the ID is not found.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道您只是想获取一个单独的项目，我建议使用`findOne`而不是`find`。您会得到文档而不是数组。当您要查找的Todo的ID不存在时，这也会使得处理变得更加容易；与其得到一个空数组作为结果，您将得到`null`，然后您可以对此进行处理，做任何您喜欢的事情。也许这意味着您返回一个404，或者也许您希望在找不到ID时做其他事情。
- en: Todo.findById method
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Todo.findById方法
- en: 'The last method we''re going to look at is `Todo.findById`. Now, `findById`
    is fantastic if you are just looking for a document by its identifier. There is
    no way to query by anything else other than the ID and all you do is you pass
    in the id as the argument. You don''t have to make a query object and you don''t
    have to set an `_id` prompt. With this in place, we can now do the exact same
    thing we did with `findOne`. I''m going to prove that by taking the `then` call,
    pasting it inside `Todo.findById`, and just changing the print statement from
    `Todo` to `Todo By Id`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的最后一个方法是`Todo.findById`。现在，`findById`非常棒，如果您只是想通过其标识符查找一个文档。除了ID之外，没有其他查询方式，您只需将ID作为参数传入。您不需��创建一个查询对象，也不需要设置`_id`提示。有了这个，我们现在可以做与`findOne`相同的事情。我将通过将`then`调用粘贴到`Todo.findById`中来证明这一点，并且只需将打印语句从`Todo`更改为`Todo
    By Id`：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now if I save the file, `nodemon` is going to rerun and we get the exact same
    result for both:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我保存文件，`nodemon`将重新运行，我们将得到完全相同的结果：
- en: '![](img/cc9738b1-42e3-49ba-a4d5-7ddc96528f5a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc9738b1-42e3-49ba-a4d5-7ddc96528f5a.png)'
- en: 'If you want to find one document by something other than ID, I recommend using
    `findOne`. If you want to find one document by ID, I always recommend using `findById`.
    Now, all of this and more is available in the docs, so if you want to dive into
    anything I discussed here you can always go to [mongoosejs.com](http://mongoosejs.com).
    Click on the read the docs link, and over in the left-hand side they have a couple
    of links; the one that we''re looking for is the one on Queries:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想通过除ID之外的其他方式找到一个文档，我建议使用`findOne`。如果您想通过ID找到一个文档，我总是建议使用`findById`。现在，所有这些以及更多内容都可以在文档中找到，所以如果您想深入了解我在这里讨论的任何内容，您可以随时访问[mongoosejs.com](http://mongoosejs.com)。点击阅读文档链接，在左侧有一些链接；我们要找的是查询的链接：
- en: '![](img/2f8abc07-5bf2-4d7b-bd94-a602fe79de92.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f8abc07-5bf2-4d7b-bd94-a602fe79de92.png)'
- en: You can learn more about how to query your docs, but we pretty much covered
    everything this page talks about.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以了解更多关于如何查询文档的信息，但我们已经基本涵盖了这个页面所讨论的一切。
- en: Handling situations where the ID doesn't exist
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理ID不存在的情况
- en: Now, the next thing I want to talk about is what happens when the ID isn't correct,
    and this is going to be the case because, remember, our API is going to be getting
    this ID from the user, which means that if the ID isn't correct we don't want
    our code to fail, we want to elegantly handle these errors. To prove this I'm
    going to go ahead and tweak the ID a little bit. IDs do have specific protocols
    so what I want you to do, for this example, is find a number in your ID. I'm going
    to go with the first character because it happens to be a number, and just increment
    it by one. I'm going to go from `5` to `6`. Now we have a valid ID but the ID
    is not going to be in the database because I tweaked it, and obviously the other
    Todo in the database does not match this ID.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想要谈论的下一件事是当ID不正确时会发生什么，这将是一个情况，因为请记住，我们的API将从用户那里获取这个ID，这意味着如果ID不正确，我们不希望我们的代码失败，我们希望优雅地处理这些错误。为了证明这一点，我将继续调整ID。ID有特定的协议，所以我想让您在您的ID中找到一个数字。我将选择第一个字符，因为它恰好是一个数字，然后将其递增一。我将从`5`变为`6`。现在我们有一个有效的ID，但是ID不会在数据库中，因为我调整了它，显然数据库中的其他Todo与此ID不匹配。
- en: 'Now, with this in place, you can see as we restart the server we get an empty
    array for the find call, and we get null for both `findOne` and `findById`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个设置，你可以看到当我们重新启动服务器时，我们得到了一个空数组的find调用，并且对于`findOne`和`findById`都得到了null：
- en: '![](img/7c59ab25-aa86-4cb3-b4f4-0295b070e958.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c59ab25-aa86-4cb3-b4f4-0295b070e958.png)'
- en: 'When your ID does not match anything in the database, an error is not going
    to get thrown; it''s still going to fire the success case, it''s just going to
    fire it either with an empty array or with null, which means when we want to handle
    that case where the ID doesn''t exist in the database, all we have to do is add
    an `if` statement. Inside the `Todo.findById` statement, I can add an `if` statement.
    If there is no todo, we''re going to do something, and that something is going
    to be to use `return` which prevents the rest of the function from executing,
    and we''ll print a little message, `console.log(''Id not found'')`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的ID在数据库中找不到匹配项时，不会抛出错误；它仍然会触发成功情况，只是会以一个空数组或null的形式触发，这意味着当我们想处理ID在数据库中不存在的情况时，我们只需要添加一个`if`语句。在`Todo.findById`语句中，我可以添加一个`if`语句。如果没有待办事项，我们将做一些事情，那个事情就是使用`return`来阻止函数的其余部分执行，并且我们会打印一个小消息，`console.log('Id
    not found')`：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now if I save the file the last call should look a little different:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我保存文件，最后一个调用应该看起来有点不同：
- en: '![](img/9bf4952f-8946-444a-bf57-16b483e3eff5.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bf4952f-8946-444a-bf57-16b483e3eff5.png)'
- en: As shown in the preceding screenshot, instead of getting Todo with null, we
    get `Id not found`, and this is perfect. Now we know how to query using `findOne`
    and `findById`, and we also know how to handle situations where the ID you're
    querying for doesn't actually exist inside of the collection. I'm going to set
    the ID back to its original value, changing `6` to `5`, and if I save the file,
    nodemon's going to restart and we're going to get our document back.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们得到了`Id not found`而不是null的Todo，这很完美。现在我们知道如何使用`findOne`和`findById`进行查询，也知道如何处理查询的ID实际上不存在于集合中的情况。我将ID设置回原始值，将`6`改为`5`，如果我保存文件，nodemon将重新启动，我们将得到我们的文档。
- en: Validating an ObjectID
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证ObjectID
- en: 'Now, the last thing I want to talk about is how to validate an ObjectID. What
    we''ve done so far is we''ve created a valid ObjectID. It''s just of a value that
    is not in the collection, but if we were to do something like tack on two `1`s,
    we would actually have an invalid ID which is going to cause errors in the program.
    Now, you might wonder why this would ever happen, but it could happen because
    the user is the one specifying the ID. We''re going to add a `catch` call onto
    `findById`. We''re going to get that error and simply print it to the screen using
    `console.log`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想谈谈的最后一件事是如何验证ObjectID。到目前为止，我们已经创建了一个有效的ObjectID。它只是一个不在集合中的值，但如果我们做一些像加上两个`1`这样的事情，我们实际上会得到一个无效的ID，这将导致程序出错。现在，你可能会想为什么会发生这种情况，但这可能是因为用户是指定ID的人。我们将在`findById`上添加一个`catch`调用。我们将获取错误并简单地使用`console.log`将其打印到屏幕上：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, to illustrate this we don''t need all three queries. In order to clean
    up the Terminal output, I''m going to go ahead and comment out `Todo.find` and
    `Todo.findOne`. With this in place, our invalid ID, and the `catch` callback we
    can save the file, and over in the Terminal we should get a really long error
    message:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了说明这一点，我们不需要所有三个查询。为了清理终端输出，我将注释掉`Todo.find`和`Todo.findOne`。有了这个设置，我们的无效ID和`catch`回调，我们可以保存文件，在终端中我们应该会得到一个非常长的错误消息：
- en: '![](img/271e562b-ff14-43a7-9ddf-950fcfb0494b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/271e562b-ff14-43a7-9ddf-950fcfb0494b.png)'
- en: 'We have an error message, `CastError: Cast to ObjectId failed`, for the given
    value. This is warning you that your `ObjectID` doesn''t just not exist in the
    collection, it''s actually completely invalid. Now, running this with a `catch`
    method does let us handle the error. We could do something like tell the user,
    hey, the ID that you sent through is invalid, but there''s also another way to
    get it done that I prefer. What we''re going to do is load in the ObjectID off
    of the MongoDB native driver and that''s something we did before. Right here in
    `mongodb-connect` we loaded in the, `ObjectID`. Inside of `mongoose-queries` we''re
    going to do the same thing. I''m going to make a constant called `ObjectID` and
    we''re going to get it from the `mongodb` library:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '对于给定值，我们有一个错误消息，`CastError: Cast to ObjectId failed`。这是在警告你，你的`ObjectID`不仅不存在于集合中，而且完全无效。现在，使用`catch`方法运行这个可以让我们处理错误。我们可以告诉用户，嘿，你发送的ID是无效的，但也有另一种方法可以完成。我们要做的是加载MongoDB原生驱动程序中的ObjectID，这是我们以前做过的事情。在`mongodb-connect`中我们加载了`ObjectID`。在`mongoose-queries`中我们要做同样的事情。我将创建一个叫做`ObjectID`的常量，并且从`mongodb`库中获取它：'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, on `ObjectID` we have a lot of utility methods. We've looked at how we
    can create new ObjectIDs, but one thing we also have access to is a method called
    `ObjectId.isValid`. The `isValid` method takes the value, in this case it's our
    string right in `id`, and it returns true if it's valid, and false if it's not
    valid, which means we can add `if` conditions to validate the ID before we ever
    run the query.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`ObjectID`上我们有很多实用方法。我们已经看过如何创建新的ObjectIDs，但我们还可以访问一个叫做`ObjectId.isValid`的方法。`isValid`方法接受值，本例中是我们的字符串`id`，如果它是有效的则返回true，如果无效则返回false，这意味着我们可以在运行查询之前添加`if`条件来验证ID。
- en: 'We''re going to add an `if` statement, and we''re going to check if the value
    is not valid. I''m going to flip it using an exclamation mark, then we can call
    `ObjectID.isValid`. By flipping it we''ve essentially created a method that tests
    whether an ObjectID is not valid. The value I''m going to pass in is just going
    to be the string stored in the `id` variable, and now we can add some code to
    run when the ID is not valid, `console.log(''ID not valid'')`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个`if`语句，并检查值是否无效。我将使用感叹号翻转它，然后我们可以调用`ObjectID.isValid`。通过翻转它，我们实质上创建了一个测试ObjectID是否无效的方法。我要传入的值只是存储在`id`变量中的字符串，现在我们可以添加一些代码，当ID无效时运行，`console.log('ID无效')`：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, if I go ahead and save the file, we should get our `ID not valid` message,
    and then after that we should get our error message printing to the Terminal because
    we do still have our `catch` call, and this query is still going to run. Over
    here we get just that. `ID not valid` prints to the screen:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我保存文件，我们应该会收到`ID无效`的消息，然后之后我们应该会收到错误消息打印到终端，因为我们仍然有我们的`catch`调用，这个查询仍然会运行。在这里我们就得到了。`ID无效`打印到屏幕上：
- en: '![](img/7271def5-894b-4a9b-9afb-cee35c54b518.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7271def5-894b-4a9b-9afb-cee35c54b518.png)'
- en: But now we know how to validate IDs and that's going to come in handy in the
    next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们知道如何验证ID了，这将在下一节中派上用场。
- en: With this in place it's now time for a challenge. Before I set up the challenge,
    I'm going to comment out the `id` and our `isValid` call, and down below I'll
    comment out `findById`. I'm going to leave them here; you can use them as a reference
    for what to do in the challenge. Your challenge is going to be to query the users
    collection. That means that you're going to want to go ahead and move into Robomongo
    and grab an ID from your users collection. Here I have just one document; if you
    have zero documents for whatever reason, you can always right-click Insert Document,
    and all you have to do is specify the email.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候挑战一下了。在设置挑战之前，我将注释掉`id`和我们的`isValid`调用，然后在下面我将注释掉`findById`。我将把它们留在这里；您可以将它们用作挑战中要做的参考。您的挑战是查询用户集合。这意味着您将要继续前进并移入Robomongo，并从用户集合中获取一个ID。这里我只有一个文档；如果由于某种原因您没有文档，您可以随时右键单击“插入文档”，然后只需指定电子邮件。
- en: Now, in order to make that query over inside of Atom you are going to need to
    load in the user Mongoose model because currently we only have the Todo one, require.
    Down below I want you to use `User.findById` to query the ID that you picked over
    in Robomongo. Then you're going to go ahead and handle the three cases. There's
    going to be the case where the query works, but there is no user. In that case
    you're going to print something like `User not found`. You're also going to handle
    the case where the user was found. I want you to go ahead and print the user to
    the screen. Then finally you're going to handle any errors that might have occurred.
    You can simply print the error object to the screen for that. There's no need
    to use `isValid` for this one, all you have to do is fill out the `findById` call.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在Atom内部进行该查询，您需要加载用户Mongoose模型，因为目前我们只有Todo一个，需要。在下面，我希望您使用`User.findById`来查询您在Robomongo中选择的ID。然后，您将继续处理三种情况。将会有查询成功但没有用户的情况。在这种情况下，您将打印类似于`未找到用户`的内容。您还将处理找到用户的情况。我希望您继续将用户打印到屏幕上。最后，您将处理可能发生的任何错误。对于这个，您可以简单地将错误对象打印到屏幕上。这次不需要使用`isValid`，您只需填写`findById`调用即可。
- en: 'Now, the first thing I''m going to do is import the user file. I''m going to
    make a `const`, I''m going to grab the `User` variable off of the return result
    from require, and we''re going to follow the same path we have here. We have to
    go out of the `playground` directory, into the `server/models` directory, and
    finally the filename is `user`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我要做的第一件事是导入用户文件。我将创建一个`const`，我将从require的返回结果中获取`User`变量，并且我们将按照这里的相同路径进行。我们必须从`playground`目录中出来，进入`server/models`目录，最后文件名是`user`：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have the user imported, we can query it down below. Before I write
    the query I am going to fetch an ID over in Robomongo:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了用户，我们可以在下面查询它。在编写查询之前，我将在Robomongo中获取一个ID：
- en: '![](img/3f7c8938-a78a-4d42-83e7-ded3e0b6a5ba.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f7c8938-a78a-4d42-83e7-ded3e0b6a5ba.png)'
- en: 'I can edit the document, highlight it, copy it, and move back into Atom. Inside
    of Atom I''m going to set up my `User.findById` call. All I have to do is pass
    in the ID; I have that in the clipboard, and I''m going to wrap it in quotes.
    Next up, the callbacks. I''m going to attach a `then` callback, passing in two
    functions. The first one is when the promise gets resolved, and the second one
    is when the promise gets rejected. For rejections, all we''re going to do is print
    that error object to the screen, which means we can use `console.log(e)`. Now,
    if things go well, there are still a few exceptions. We want to make sure that
    the user actually does exist. The query is still going to pass if the ID doesn''t
    match anything found inside of the collection. If there is no user, we are going
    to stop function execution using `return`, then we''re going to go ahead and print
    using `console.log(''Unable to find user'')`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以编辑文档，突出显示它，复制它，并移回到Atom。在Atom内部，我将设置我的`User.findById`调用。我所要做的就是传入ID；我已经将它放在剪贴板中，并且我将用引号括起来。接下来是回调函数。我将附加一个`then`回调，传入两个函数。第一个是当承诺被解决时，第二个是当承诺被拒绝时。对于拒绝，我们要做的就是将错误对象打印到屏幕上，这意味着我们可以使用`console.log(e)`。现在，如果事情进展顺利，仍然有一些例外情况。我们要确保用户确实存在。如果ID与集合中找到的任何内容不匹配，查询仍将通过。如果没有用户，我们将使用`return`停止函数执行，然后我们将继续使用`console.log('无法找到用户')`进行打印：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, the last case we need to handle is if things actually go well, which means
    that the query was indeed valid and the ID was found inside of the users collection.
    I''m going to add `console.log` using our pretty printing technique, the `user`
    variable, `JSON.stringify`, passing in our three arguments, `user`, `undefined`,
    and the number `2`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理的最后一种情况是，如果事情确实进展顺利，这意味着查询确实有效，并且ID确实在用户集合中找到了。我将添加`console.log`，使用我们的漂亮打印技术，`user`变量，`JSON.stringify`，传入我们的三个参数，`user`，`undefined`，和数字`2`：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this in place I can now go ahead and save the file and open up the Terminal
    since it''s currently hidden, we get our user showing up in the Terminal:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我现在可以保存文件并打开终端，因为它目前是隐藏的，我们的用户出现在终端中：
- en: '![](img/b4f62900-9086-4a9b-b95e-795003c4df38.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4f62900-9086-4a9b-b95e-795003c4df38.png)'
- en: 'This is fantastic; if you''re seeing this you''ve successfully completed the
    challenge. Now I can also test that my other cases are working as expected. I''m
    going to change `6` at the end of my ID to a `7` and save the file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了；如果你看到这个，你已经成功完成了挑战。现在我也可以测试我的其他情况是否按预期工作。我将把ID末尾的`6`改为`7`并保存文件：
- en: '![](img/bb17f967-87b5-445b-82a3-16fdb0feb8f4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb17f967-87b5-445b-82a3-16fdb0feb8f4.png)'
- en: When it restarts I get `Unable to find user`, which is expected. Next up, I'm
    going to change it back to a `6`, but I am going to tack on a few `1`s, or any
    other characters. In this case, I'll use two `1`s and two `a` characters. This
    time we do get our error, we're unable to cast that value to an ObjectId. Let's
    undo the change to the ID and now we're done.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当它重新启动时，我得到`无法找到用户`，这是预期的。接下来，我将把它改回`6`，但我将添加几个`1`，或者其他任何字符。在这种情况下，我将使用两个`1`和两个`a`字符。这次我们确实得到了错误，我们无法将该值转换为ObjectId。让我们撤消对ID的更改，现在我们完成了。
- en: 'I''m going to wrap this section up by committing our changes. I''m going to
    shut down `nodemon`, run a `git status` command, and we have one new file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过提交我们的更改来结束本节。我将关闭`nodemon`，运行`git status`命令，我们有一个新文件：
- en: '![](img/1fc9a660-f5f3-46e9-90f5-f7471359a469.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fc9a660-f5f3-46e9-90f5-f7471359a469.png)'
- en: 'I can use `git add` to add it to the next commit, then I can use `git commit`
    to make the commit. A good message for this one is `Add queries playground file`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`git add`将其添加到下一个提交，然后我可以使用`git commit`进行提交。这个的一个好消息是`Add queries playground
    file`：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this in place I'm going to push it up to GitHub using the `git push` command,
    and we are done. In the next section you will be responsible for creating an entire
    API request.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我将使用`git push`命令将其推送到GitHub，我们完成了。在下一节中，您将负责创建一个完整的API请求。
- en: Getting an individual resource – GET /todos/:id
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取个人资源 - GET /todos/:id
- en: In this section, you are going to create an API route for fetching an individual
    Todo. Now, most of this section is going to be a challenge but there is one thing
    I want to show you before we get started, and that is **how to fetch a variable
    that's passed in via the URL.** Now, as I mentioned, the structure for this URL
    is going to be a `GET` request, `/todos`, then we're going to dive into the Todos,
    fetching an individual item where the ID gets passed, such as `/todos/12345`.
    This means that we need to make the ID part of the URL dynamic. I want to be able
    to fetch that value, whatever a user happens to pass in, and use it to make the
    query. The query that we set up in the `mongoose-queries` file like `User.findById`
    one to fetch the todo by Id.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建一个用于获取单个待办事项的API路由。现在，本节的大部分内容都将是一个挑战，但在我们开始之前，有一件事我想向您展示，那就是**如何获取通过URL传递的变量**。现在，正如我提到的，这个URL的结构将是一个`GET`请求，`/todos`，然后我们将深入到Todos，获取通过URL传递的单个项目的ID，比如`/todos/12345`。这意味着我们需要使URL的ID部分是动态的。我希望能够获取该值，无论用户传入什么，然后使用它进行查询。我们在`mongoose-queries`文件中设置的查询，比如`User.findById`，用于通过Id获取待办事项。
- en: Now in order to get that done, let's go ahead inside `server.js` file and call
    `app.get`, passing in the URL.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完成这个，让我们进入`server.js`文件，并调用`app.get`，传入URL。
- en: Taking on the challenge
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战接受
- en: 'The first part we already know, `/todos/`, but now what we need is a URL parameter.
    URL parameters follow this pattern: it''s a colon followed by a name. Now I could
    call this `:todoId`, or anything else, but what we''re going to call it for this
    section is `:id`. This is going to create an `id` variable; it''s going to be
    on the request object, the one we''ll set up in just a moment, and we''ll be able
    to access that variable. That means when someone makes the `GET /todos/1234324`
    request, the callback will fire, the one we''re going to specify now, and we''ll
    be able to query by the ID they pass in. Now, we are still going to get the request
    and response object, the only difference is we''re now going to be using something
    off of request. This one is `req.params`. The `req.params` object is going to
    be an object, it''s going to have key value pairs where the key is the URL parameter,
    like id, and the value is whatever value was actually put there. In order to demonstrate
    this, I am going to simply call `res.send`, sending back the `req.params` object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分我们已经知道了，`/todos/`，但现在我们需要的是一个URL参数。URL参数遵循这种模式：冒号后面跟着一个名称。现在我可以称这个为`:todoId`，或者其他任何名称，但是在本节中我们将称之为`:id`。这将创建一个`id`变量；它将在请求对象上，我们马上就会设置的那个对象上，我们将能够访问该变量。这意味着当有人发出`GET
    /todos/1234324`请求时，回调将触发，我们现在将指定的回调，我们将能够通过传入的ID进行查询。现在，我们仍然会得到请求和响应对象，唯一的区别是我们现在将使用请求的某些内容。这个是`req.params`。`req.params`对象将是一个对象，它将具有键值对，其中键是URL参数，比如id，值是实际放在那里的任何值。为了演示这一点，我将简单地调用`res.send`，发送`req.params`对象回去：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is going to let us test out this route inside of Postman and see exactly
    how it works. Inside of the Terminal I can start up our server. I''m going to
    use following command to start things up:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让我们在Postman中测试这个���由，并确切地看到它是如何工作的。在终端中，我可以启动我们的服务器。我将使用以下命令启动：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the server''s on `localhost:3000` and we can make a `GET` request to this,
    the `/todos/:id` URL. Over inside Postman I''m going to do just that; we have
    the GET method, the URL is `localhost`, and it''s still on port `3000/todos/`,
    and then we can type whatever we like, for example, `123`. Now, when I send this
    off what we get back is that `req.params` object, and right in Body you can see
    it has an `id` property set to `123`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器在`localhost:3000`上，我们可以对`/todos/:id`URL进行`GET`请求。在Postman中，我将这样做；我们有GET方法，URL是`localhost`，仍然在端口`3000/todos/`上，然后我们可以输入任何我们喜欢的东西，比如`123`。现在，当我发送这个请求时，我们得到的是`req.params`对象，在Body中你可以看到它有一个`id`属性设置为`123`：
- en: '![](img/ba53ccec-d809-40de-a675-b04e78e148c6.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba53ccec-d809-40de-a675-b04e78e148c6.png)'
- en: That means we are able to access the value in the URL using `req.params.id`,
    and that is exactly what you're going to need to do for the challenge. Over inside
    of Atom I'll start things off by creating that variable, a `var id = req.params.id`
    variable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们能够使用`req.params.id`访问URL中的值，这正是你需要为挑战做的事情。在Atom中，我将通过创建一个`var id = req.params.id`变量来开始这个过程。
- en: With this in place you now know everything you need in order to complete the
    challenge, which is going to be to finish filling out this route. First up, you're
    going to validate the ID using that ObjectID `isValid` method we explored over
    in the `mongoose-queries` file. I'll leave a little comment, `Valid id using isValid`.
    Now, if it's not valid, what you're going to do is stop the function execution
    and you're going to respond with a `404` response code, because the ID passed
    in is not valid, and there's no way it's ever going to be in the collection. We're
    going to respond with the `404` response code letting the user know that the Todo
    was not found, and you can send back an empty body, which means you can just call
    send without passing in any value. It would be similar to the `res.status(400).send(e)`
    statement with no error, and you would also change `400` to `404`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个准备，你现在知道了完成挑战所需的一切，这将是完成填写这个路由。首先，你将使用我们在`mongoose-queries`文件中探索过的ObjectID
    `isValid`方法来验证ID。我会留下一个小注释，`Valid id using isValid`。现在，如果它不是有效的，你将停止函数执行，并且你将回应一个`404`响应代码，因为传入的ID是无效的，而且永远不会在集合中。我们将回应一个`404`响应代码，让用户知道Todo没有找到，你可以发送回一个空的body，这意味着你可以只调用send而不传递任何值。这将类似于没有错误的`res.status(400).send(e)`语句，你还会将`400`改为`404`。
- en: 'Now, after that, you''re going to start querying the database and this is going
    to happen using `findById`. I want you to take the Id and query the `Todos` collection,
    looking for a matching document; there''s two ways this could go. There''s the
    success case and there is the error case. If we get an error, that one is pretty
    self-explanatory: all we''re going to do is send back a `400` response code letting
    the user know that the request was not valid, and we''re also going to go ahead
    and send back nothing. We''re not going to be sending back that error argument
    because the error that prints for the error message could contain private information.
    We''re going to be beefing out our error handling later. Currently, as you can
    see, we have the function duplicated in quite a few places. That will get moved
    into one location later but for now you can respond with a `400` response code
    and send an empty body back. This brings us to the success case. Now, if there
    is a Todo, `if todo`, you''re going to go ahead and send it back. If there is
    no Todo, `if no todo`, this means the call did succeed, but the ID was not found
    in the collection. All you''re going to do is go ahead and send back a `404` response
    code with an empty body.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将开始查询数据库，这将使用`findById`来完成。我希望你拿到ID并查询`Todos`集合，寻找匹配的文档；有两种情况。有成功的情况，也有错误的情况。如果我们得到一个错误，那就很明显：我们将发送一个`400`响应代码，让用户知道请求无效，我们也将继续发送回空值。我们不会发送回错误参数，因为错误消息中可能包含私人信息。我们稍后会加强我们的错误处理。目前，正如你所看到的，我们在很多地方都重复了这个函数。稍后这将被移到一个位置，但现在你可以用`400`响应代码回应，并发送一个空的body。这带我们来到成功的情况。现在，如果有一个Todo，`if
    todo`，你将继续发送它。如果没有Todo，`if no todo`，这意味着调用成功了，但在集合中找不到ID。你将继续发送一个`404`响应代码和一个空的body。
- en: Now, both of these statements are going to look really similar; you're sending
    back a `404` letting the user know that the ID they passed in does not match any
    ID of a document in the `Todos` collection. Now you know how to do all of this,
    you can use anything you need to get this done. That means you can use the `mongoose-queries`
    file, you can use the [mongoosejs.com](http://mongoosejs.com/) documentation,
    you can use Stack Overflow, Google, or anything else; it's not about memorizing
    exactly how to get stuff done, it's about working through those problems on your
    own. Eventually you will memorize a lot of these techniques as they come up again
    and again, but for now your goal is to just get it working. When you're done,
    go ahead and fire off this request over in the Postman application. That means
    you're going to want to grab an ID that is valid from Robomongo and paste it right
    in the URL. You can also test what happens with IDs that are valid, but don't
    exist in the database, and IDs that are invalid, such as `123`, which is not a
    valid ObjectID. With this in place you are ready to start the challenge.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这两个语句看起来非常相似；你将发送一个`404`，让用户知道他们传入的ID与`Todos`集合中的任何文档的ID都不匹配。现在你知道如何做到这一点，你可以使用任何你需要完成这个任务的东西。这意味着你可以使用`mongoose-queries`文件，你可以使用[mongoosejs.com](http://mongoosejs.com/)文档，你可以使用Stack
    Overflow，Google，或者其他任何东西；这不是关于记住如何准确地完成任务，而是关于自己解决这些问题。最终，当这些技术一次又一次地出现时，你会记住很多这些技术，但现在你的目标只是让它工作。完成后，继续在Postman应用程序中发送这个请求。这意味着你要从Robomongo中获取一个有效的ID，并将其粘贴到URL中。你还可以测试数据库中存在但无效的ID以及无效的ID，比如`123`，这不是一个有效的ObjectID。有了这个准备，你就可以开始挑战了。
- en: Challenge step 1 - filling the code
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战步骤1 - 填写代码
- en: 'The first thing I''m going to do is fill out the code. We''re going to validate
    the ID and we''re going to send back a `404` response code if it''s not valid.
    Up at the very top of the file I do not have an ObjectID imported so I''m going
    to have to go ahead and do that. Just below `bodyParser`, I can create a variable
    `ObjectID`, and set that equal to the return result from `require`; we''re requiring
    the `mongodb` library. Now that we have `ObjectID` in place, we can go ahead and
    use it. We''ll write an `if` statement, `if (ObjectID.isValid())`. Now, obviously
    we only want to run this code if it''s not valid, so I''m going to flip the return
    result using an exclamation mark, and then I''m going to pass `id` in. Now we
    have an `if` condition that''s only going to pass if the ID, the one that got
    passed in as the URL parameter, was not valid. In that case we''re going to use
    `return` to prevent function execution, then I''m going to go ahead and respond
    using `res.status`, setting it equal to `404`, and I''m going to call `send` with
    no arguments so I can send back an empty body. There we go, our first thing is
    complete. With this in place we can now go ahead and move onto creating the query:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我要做的第一件事是填写代码。我们将验证ID，如果无效，我们将发送`404`响应代码。在文件的顶部，我没有导入ObjectID，所以我需要去做。就在`bodyParser`下面，我可以创建一个变量`ObjectID`，并将其设置为`require`返回的结果；我们需要`mongodb`库。现在我们有了`ObjectID`，我们可以继续使用它。我们将编写一个`if`语句，`if
    (ObjectID.isValid())`。显然，我们只想在它无效时运行这段代码，所以我将使用感叹号翻转返回结果，然后我将传入`id`。现在我们有了一个`if`条件，只有在ID无效时才会通过。在这种情况下，我们将使用`return`来阻止函数执行，然后我将使用`res.status`进行响应，将其设置为`404`，然后我将调用`send`，不带参数，这样我就可以发送一个空的主体。我们完成了第一步。有了这个，我们现在可以继续创建查询了：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point we actually do have something we can test: we can pass in invalid
    IDs and make sure we get that 404 back. Over inside of the Terminal I ran the
    application using `nodemon` so it automatically restarted in Postman. I can rerun
    the `localhost:3000/todos/123` request and we get our 404, which is fantastic:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们实际上有一些可以测试的东西：我们可以传入无效的ID，并确保我们得到了404。在终端内部，我使用`nodemon`运行了应用程序，所以它会自动在Postman中重新启动。我可以重新运行`localhost:3000/todos/123`请求，我们得到了404，这太棒了：
- en: '![](img/a933a96a-a659-45b8-a47b-e09de0c84cd9.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a933a96a-a659-45b8-a47b-e09de0c84cd9.png)'
- en: This is not a valid ObjectID, the condition failed, and the 404 was indeed returned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个有效的ObjectID，条件失败了，404确实返回了。
- en: Challenge step 2 - Making the query
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战步骤2 - 进行查询
- en: 'Next up, we''re going to make that query `Todo.findById`. Here we''re going
    to pass in the ID, which we have in the `id` variable, and then we''re going to
    attach our success and error handlers, `.then`, passing in our success callback.
    This is going to get called potentially with the individual Todo document, and
    I am going to call `catch` as well, getting the error. We can do the error handler
    first. If there is an error, we''re going to keep things really simple, `res.status`,
    setting it equal to `400`, then we''re going to go ahead and call `send`, leaving
    out the error object intentionally:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进行查询`Todo.findById`。在这里，我们将传入ID，我们在`id`变量中拥有，然后我们将附加我们的成功和错误处理程序，`.then`，传入我们的成功回调。这可能会调用个别的Todo文档，并且我也会调用`catch`，获取错误。我们可以先处理错误处理程序。如果有错误，我们将保持非常简单，`res.status`，将其设置为`400`，然后我们将继续调用`send`，有意地省略错误对象：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this in place the only thing left to do is fill out the success handler.
    The first thing we need to do is make sure that a Todo is actually found. This
    query, if successful, might not always result in an actual document being returned.
    I''m going to use an `if` statement to check if there is no Todo. If there is
    no Todo, we want to respond with a `404` response code, just like we did before.
    We''re going to `return` to stop the function execution, `res.status`. The status
    here will be `404` and we will be using `send` to respond with no data:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，唯一剩下的事情就是填写成功处理程序。我们需要确保实际上找到了一个Todo。这个查询，如果成功，可能并不总是会返回一个实际的文档。我将使用一个`if`语句来检查是否没有Todo。如果没有Todo，我们希望用`404`响应代码进行响应，就像之前一样。我们将使用`return`来停止函数执行，`res.status`。这里的状态将是`404`，我们将使用`send`来响应没有数据：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: challenge step 3 - success path
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战步骤3 - 成功路径
- en: 'The last case is the happy path, the success case, when everything goes as
    planned. The ID is valid and we find a document in the Todos collection that has
    an ID matching the ID passed in. In that case all we''re going to do is respond
    using `res.send`, sending back the Todo. Now, you could have sent it in like `res.todo(todo)`;
    this will indeed work, but what I want to do is tweak it just a little bit. Instead
    of sending back Todo as the body, I''m going to send back an object where the
    Todo is attached as the `todo` property using the ES6 object definition, which
    is identical to this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况是快乐路径，成功的情况，当一切按计划进行时。ID是有效的，我们在Todos集合中找到了一个与传入的ID匹配的文档。在这种情况下，我们要做的就是使用`res.send`进行响应，将Todo发送回去。现在，你可以像这样发送它`res.todo(todo)`；这确实可以工作，但我想稍微调整一下。我不是将Todo作为主体发送回去，而是将Todo作为`todo`属性附加到对象中，使用ES6对象定义，这与以下内容相同：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This gives me a little flexibility down the line. I could always add other
    properties onto the response, like custom status codes or anything else. It''s
    similar to the technique we used for `GET /todos`. Right here, `res.send({todos})`,
    instead of responding with the array, we responded with an object that has a `todos`
    property and that is the array:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我一些灵活性。我可以随时添加其他属性到响应中，比如自定义状态码或其他任何东西。这类似于我们用于`GET /todos`的技术。就在这里，`res.send({todos})`，不是用数组进行响应，而是用一个具有`todos`属性的对象进行响应，这就是数组：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have this in place we are done and we can test things out. I''m
    going to save the file, remove all of our comments, add a semicolon where needed,
    and we''re going to grab an ID from Robomongo. Over inside of Robomongo I can
    grab an ID for one of my Todos. I''m going to go with the second one. I''ll edit
    the document and copy it to the clipboard. Now over in Postman we can go ahead
    and make the request, setting the ID equal to the ID value we just copied:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一切，我们可以测试一下。我将保存文件，删除所有注释，根据需要添加分号，然后我们将从Robomongo中获取一个ID。在Robomongo中，我可以获取一个我的Todos的ID。我将选择第二个。我将编辑文档并将其复制到剪贴板。现在在Postman中，我们可以继续发出请求，将ID设置为我们刚刚复制的ID值：
- en: '![](img/d1cb9eff-7242-47b7-ad97-c2601367793d.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1cb9eff-7242-47b7-ad97-c2601367793d.png)'
- en: 'I''m going to send it off. We get our object where we have a `todo` property,
    and on that `todo` property we have all of the properties for the document, `_id`,
    `text`, `completedAt`, and `completed`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我要发送它。我们在对象中有一个`todo`属性，在该`todo`属性上，我们有文档的所有属性，`_id`，`text`，`completedAt`和`completed`：
- en: '![](img/94030e07-434b-4e56-a0b9-48fc1bbc1047.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94030e07-434b-4e56-a0b9-48fc1bbc1047.png)'
- en: 'Now, the last case I want to test is what happens when we request a Todo with
    a valid ObjectID, but one that just happens to not exist. I''m going to do this
    by taking the last number in my ID and changing it from `a` to `b`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想测试的最后一种情况是，当我们请求一个具有有效ObjectID的Todo，但恰好不存在时会发生什么。我将通过将ID中的最后一个数字从`a`更改为`b`来实现这一点：
- en: '![](img/16fbd9e5-d0d9-48b6-96a2-c7a3f4d4b0cc.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16fbd9e5-d0d9-48b6-96a2-c7a3f4d4b0cc.png)'
- en: 'If I send this off we get our `404` response code back, which is fantastic;
    this is exactly what I expect to happen when I make a request for a Todo. The
    ObjectID is valid, it''s just not in the collection. Now that we''ve made this
    request we can actually save this inside of our Todo App collection, so later
    down the line it''s a lot easier to fire off this one. I''m going to save it using
    Save As:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我发送这个，我们会得到`404`响应代码，这太棒了；这正是我在请求Todo时所期望发生的。ObjectID是有效的，只是不在集合中。现在我们已经发出了这个请求，我们实际上可以将其保存在我们的Todo
    App集合中，这样以后就更容易触发这个请求。我将使用Save As保存它：
- en: '![](img/455f68bc-e917-43fc-8007-6e1b356b7532.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/455f68bc-e917-43fc-8007-6e1b356b7532.png)'
- en: We can leave the Request description empty, and we can change Request Name to
    `GET /todos/:id`. I am going to add it to our existing collection, the Todo App
    collection. Now we have three routes; the only thing left to do for this route
    is to add some test cases, and that's going to be the topic of the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将请求描述留空，并将请求名称更改为`GET /todos/:id`。我将把它添加到我们现有的集合中，Todo App集合。现在我们有三个路由；这个路由的唯一剩下的事情就是添加一些测试用例，这将是下一节的主题。
- en: To wrap this one up, let's commit our changes and push them up to GitHub. I'm
    going to shut down the server and run `git status`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一切，让我们提交我们的更改并将它们推送到GitHub。我将关闭服务器并运行`git status`。
- en: 'We can see we have our modified file; this means I can run `git commit` with
    the `-a` flag and the `-m` flag, and then I''m going to provide my commit message.
    Now, if you''re using the `-a` flag and the `-m` flag you can actually use a shortcut,
    the `-am` flag, which does the exact same thing. It''s going to add all of our
    modified files to the commit; it''s also going to give us a place to add a message.
    A good message for this one would be `Add GET /todos/:id`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有我们修改过的文件；这意味着我可以运行带有`-a`标志和`-m`标志的`git commit`，然后我将提供我的提交消息。现在，如果您使用`-a`标志和`-m`标志，您实际上可以使用一个快捷方式，即`-am`标志，它执行完全相同的操作。它将把所有修改过的文件添加到提交中；它还将为我们提供一个添加消息的地方。这个的一个好消息将是`Add
    GET /todos/:id`：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this in place, I'm going to make the commit, push it up to GitHub, and
    we are done. In the next section, we are going to go ahead and write test cases
    for this route. It's going to be mostly a challenge like this one was.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我将提交并将其推送到GitHub，我们完成了。在下一节中，我们将继续为这个路由编写测试用例。这将大致是像这个一样具有挑战性的。
- en: Testing GET /todos/:id
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试GET /todos/:id
- en: In this section, we're going to create three test cases for this route, the
    one that fetches an individual Todo item. One is going to make sure that when
    we pass in an invalid ObjectID, we get a `404` response code. Another one is going
    to verify that when we pass in a valid ObjectID, but it doesn't match a doc, we
    get a `404` response code back, and lastly we'll write a test case that makes
    sure that when we pass in an ObjectID that does match a doc, that doc actually
    comes back in the response body.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将为这个路由创建三个测试用例，用于获取单个Todo项。一个是确保当我们传入无效的ObjectID时，我们会得到`404`响应代码。另一个是验证当我们传入有效的ObjectID，但它不匹配文档时，我们会得到`404`响应代码，最后我们将编写一个测试用例，确保当我们传入与文档匹配的ObjectID时，该文档实际上会在响应体中返回。
- en: We're going to write the test case for the valid call together, then you'll
    be writing two test cases on your own. That will be the challenge for this section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一起编写有效调用的测试用例，然后您将自己编写两个测试用例。这将是本节的挑战。
- en: Writing test cases for GET/todos/:id
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写GET/todos/:id的测试用例
- en: 'Over inside of `server.test.js` we can get started down at the very bottom
    by adding a `describe` block. I''m going to call describe, and this `describe`
    block will be named `GET /todos/:id`, and we can add our arrow function (`=>`)
    as the callback function. Inside of our `describe` callback we can now set up
    the test case that we''re going to create together, `it(''should return todo doc'')`.
    This is going to be the test that makes sure that when we pass in a valid ID that
    does match a doc, the doc comes back. It''s going to be an asynchronous test,
    so we will be specifying the `done` argument:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.test.js`中，我们可以从最底部开始添加一个`describe`块。我将调用describe，这个`describe`块将被命名为`GET
    /todos/:id`，我们可以将箭头函数(`=>`)添加为回调函数。在我们的`describe`回调中，我们现在可以设置我们将一起创建的测试用例，`it('should
    return todo doc')`。这将是一个确保当我们传入与文档匹配的有效ID时，文档会返回的测试。这将是一个异步测试，所以我们将指定`done`参数：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, in order to run this test case we''re going to need the ID of a Todo that''s
    actually inside of the collection, and if you remember we do add two Todos to
    the collection, but unfortunately we don''t have the IDs. The IDs are autogenerated
    behind the scenes; in order to fix this what we''re going to do is add the ID
    property, `_id`. This means we''ll be able to access the ID in our test case and
    everything will work as expected. Now, in order to do this we do have to load
    an ObjectID off of MongoDB, which we''ve done before. I''m going to make a constant
    using ES6 Destructuring. I''m going to grab `ObjectID` off of the return result
    from requiring `mongodb`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了运行这个测试用例，我们需要一个实际在集合中的Todo的ID，如果你记得，我们确实向集合中添加了两个Todos，但不幸的是我们没有这些ID。这些ID是在幕后自动生成的；为了解决这个问题，我们要做的是添加ID属性，`_id`。这意味着我们将能够在我们的测试用例中访问ID，并且一切都将按预期工作。现在，为了做到这一点，我们必须从MongoDB中加载一个ObjectID，这是我们以前做过的。我将使用ES6解构来创建一个常量。我将从要求`mongodb`的返回结果中获取`ObjectID`：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, inside of the `todos` array we can add an `_id` property for both of our
    two `todos`, `new ObjectID()`, with a comma—this is for the first `todo`—and down
    below we can add an `_id` for the second `todo` as well, `new ObjectID()`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`todos`数组中，我们可以为我们的两个`todos`添加一个`_id`属性，`new ObjectID()`，带有一个逗号-这是为第一个`todo`-在下面，我们也可以为第二个`todo`添加一个`_id`，`new
    ObjectID()`：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have _ids and we can access those _ids by accessing them off the
    `todos` array, we're ready to write the test case.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了_ids，我们可以通过从`todos`数组中访问它们来访问这些_ids，我们准备编写测试用例。
- en: Test 1 - Super test request
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试1 - 超级测试请求
- en: 'We''re going to get started by creating our super test request. We''re going
    to `request` something from the `app` express application; it is going to be a
    `get` request, that is, the URL we''re testing, and the actual URL is going to
    be `/todos/id`, where `id` equals one of these _ids in `todos`. I''m going to
    go ahead and use the `_id` of the first `todo`. Down below we can fix this by
    changing our string to a template string, so we can inject `_id`, `/todos/` then
    we''re going to add our syntax for injecting a value into the template string.
    In this case we''re accessing something from the `todos` array. We want to grab
    the first item, this is the first `todo`, and we''re looking for its `_id` property.
    Now, this is an ObjectID; we need to convert this into a string because that is
    what we''re going to pass in as the URL. To convert an ObjectID to a string we
    can use the `toHexString` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始创建我们的超级测试请求。我们将从`app` express应用程序中`request`一些东西；这将是一个`get`请求，也就是我们要测试的URL，实际的URL将是`/todos/id`，其中`id`等于`todos`中的一个这些_ids。我将继续使用第一个`todo`的`_id`。在下面，我们可以通过将字符串更改为模板字符串来修复这个问题，这样我们就可以注入`_id`，`/todos/`然后我们将添加我们的语法来将一个值注入到模板字符串中。在这种情况下，我们从`todos`数组中访问一些东西。我们想要获取第一个项目，这是第一个`todo`，我们正在寻找它的`_id`属性。现在，这是一个ObjectID；我们需要将其转换为字符串，因为这是我们将作为URL传递的内容。要将ObjectID转换为字符串，我们可以使用`toHexString`方法：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There we go. Now we''ve generated the proper ID and we can start making some
    assertions about what should happen when this request gets fired. First up, the
    HTTP status code. That should be a `200`, so I can call `expect`, passing in `200`.
    Next step: we do want to verify that the body that comes back matches the body
    previous in the `todos` array, most notably that the `text` property equals the
    `text` property we set. I''m going to create a custom `expect` call to get that
    done. We''ll pass in our function that gets called with the response object, and
    now we can make an assertion using the `expect` library. I''m going to use `expect(res.body.todo)`,
    which we set up in `res.send({todo})` when we used the ES6 object syntax, and
    that `todo` property has a `text` property that is equal to using `toBe`, the
    `text` property of our first `todo`. That''s going to be `todos`, grabbing the
    first one, the zero-indexed todo, and we''re going to grab its `text` property.
    With this in place, all of our assertions are done; we can call `end`, passing
    in `done`, which is going to wrap up the test case:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了正确的ID，我们可以开始对这个请求触发时应该发生的事情进行一些断言。首先，HTTP状态码。那应该是`200`，所以我可以调用`expect`，传入`200`。下一步：我们确实希望验证返回的body与之前在`todos`数组中的body匹配，特别是`text`属性等于我们设置的`text`属性。我将创建一个自定义的`expect`调用来完成这个任务。我们将传入我们的函数，该函数将使用响应对象调用，现在我们可以使用`expect`库进行断言。我将使用`expect(res.body.todo)`，我们在`res.send({todo})`中设置了它，当我们使用ES6对象语法时，那个`todo`属性有一个`text`属性，它等于我们第一个`todo`的`text`属性。那将是`todos`，获取第一个，从零开始的todo，我们将获取它的`text`属性。有了这个，我们所有的断言都完成了；我们可以调用`end`，传入`done`，这将结束测试用例。
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can go ahead and run this test over inside of the Terminal by running
    `npm run test-watch`. This is going to kick off our test suite and we should have
    our new section with our test case that is passing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续在终端内运行这个测试，运行`npm run test-watch`。这将启动我们的测试套件，我们应该有我们的新部分和通过的测试用例：
- en: '![](img/970e9653-b8a6-4fcd-a4aa-a2b79168b5fe.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/970e9653-b8a6-4fcd-a4aa-a2b79168b5fe.png)'
- en: Right here, we get `should return todo doc`, and that is passing, which is fantastic.
    Now it's time for you to write two test cases on your own. I'll give you the it
    calls so we're on the same page, but you are going to be responsible for filling
    out the actual test function, `it('should return 404 if todo not found')`. This
    is going to be an async test, so we'll specify the `done` argument, and your job
    here is going to be to make a request using a real ObjectID, and you're going
    to call its `toHexString` method. It is going to be a valid ID but it won't be
    found in the collection, so we should get a 404 back. Now, the only expectation
    you need to set up is the status code; make sure you get `404` back.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了`should return todo doc`，这是通过的，太棒了。现在是你自己写两个测试用例的时候了。我会给你it调用，这样我们就在同一个页面上，但你要负责填写实际的测试函数，`it('should
    return 404 if todo not found')`。这将是一个异步测试，所以我们将指定`done`参数，你的工作是使用一个真实的ObjectID发出请求，并调用它的`toHexString`方法。这将是一个有效的ID，但它不会在集合中找到，所以我们应该得到一个404。现在，你需要设置的唯一期望是状态码；确保你得到了`404`。
- en: Test 2 - Verifying invalid ID
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试2-验证无效的ID
- en: The second test you're going to write is going to verify that when we have an
    invalid ID we get back a `404` response code, `it('should return 404 for non-object
    ids')`. This is also going to be an async test, so we'll specify `done`. For this
    one, you're going to pass in a URL, something like this: `/todos/123`. This is
    indeed a valid URL, but when we try to convert `123` to an ObjectID it's going
    to fail, and that should trigger the `return res.status(404).send()` code and
    we should get a `404` response code back. Once again, the only expectation you
    need to set up for this test is that when you make the get request to the URL
    a `404` is the status code. Take a moment to knock out both of these test cases,
    making sure they work as expected when you actually have the calls set up. If
    all of your test cases are passing over in the Terminal when you're done, then
    you are ready to move on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你要编写的第二个测试将验证当我们有一个无效的ID时，我们会得到一个`404`响应代码，`it('should return 404 for non-object
    ids')`。这也将是一个异步测试，所以我们将指定`done`。对于这个测试，你将传入一个URL，类似于这样：`/todos/123`。这确实是一个有效的URL，但当我们尝试将`123`转换为ObjectID时，它将失败，这应该触发`return
    res.status(404).send()`代码，我们应该得到一个`404`响应代码。再次，你需要为这个测试设置的唯一期望是当你向URL发出get请求时，状态码是`404`。花点时间来完成这两个测试用例，确保当你实际设置了调用时，它们能够按预期工作。如果你完成后在终端中所有的测试用例都通过了，那么你就可以继续了。
- en: 'For the first one, I''m going to go ahead and get that `HexString` by creating
    a variable. Now, you didn''t need to create a variable; you could have done it
    slightly differently. I''m going to make a variable called `hexId`, setting it
    equal to `new ObjectID`. Now on this `ObjectID` we do want to call that `toHexString`
    method which we used before. This takes our ObjectID and gives us a string, and
    we can specify that string as part of the URL. Now, it''s fine if you did this
    inside of the get call, kind of like we do here; either way works as long as the
    test case passes. We''re going to call `request`, passing in our app. Next up,
    we are going to make a `get` request, so I''ll call that `get` method and we can
    set up our URL. This one is going to be `/todos/` and we''re going to inject in
    our template string that `hexId` value. The only expectation we need to set up
    is that a `404` status code comes back. We''re expecting `404`. We can wrap this
    test case up by calling `end`, passing in our `done` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个，我将继续通过创建一个变量来获取`HexString`。现在，你不需要创建一个变量；你可以稍微不同地做。我将创建一个名为`hexId`的变量，将其设置为`new
    ObjectID`。现在在这个`ObjectID`上，我们确实想要调用之前使用过的`toHexString`方法。这将获取我们的ObjectID并给我们一个字符串，我们可以将该字符串指定为URL的一部分。现在，如果你在get调用内部执行了这个操作，就像我们在这里做的那样，那么这样做也是可以的；只要测试用例通过就可以。我们将调用`request`，传入我们的app。接下来，我们将发出一个`get`请求，所以我会调用`get`方法并设置我们的URL。这个URL将是`/todos/`，我们将在模板字符串中注入我们的`hexId`值。我们需要设置的唯一期望是返回一个`404`状态码。我们期望`404`。我们可以通过调用`end`并传入我们的`done`函数来结束这个测试用例：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we can save the file and this test case should rerun. The last test is
    still going to fail, but that''s fine, and over here you can see we get exactly
    that, `should return todo doc` passes and `should return 404 if todo not found`
    passes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存文件，这个测试用例应该重新运行。最后一个测试仍然会失败，但没关系，你可以看到这里，`should return todo doc`通过了，`should
    return 404 if todo not found`也通过了：
- en: '![](img/6f06ef81-b971-4988-85eb-4ad1b3f5d404.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f06ef81-b971-4988-85eb-4ad1b3f5d404.png)'
- en: And the last test to write is what happens when we have an invalid ObjectID.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要编写的测试是当我们有一个无效的ObjectID时会发生什么。
- en: Test 3 - Validating invalid ObjectID
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试3-验证无效的ObjectID
- en: 'I''m going to call `request`, passing in `app`, then I''m going to go ahead
    and call `get`, setting up the URL. We don''t need to use template strings here
    since we''re just going to be passing in a plain string, `/todos/123abc`. Indeed
    an invalid ObjectID. The ObjectIDs, as we talked about, have a very specific structure
    and this does not pass that criteria. To find out more about ObjectIDs you can
    always go back to the ObjectID section at the beginning of this chapter. Next,
    we''re going to start setting up our assertions by calling `expect` and expecting
    `404` to come back, and we can wrap this test up by calling the `end` method and
    passing in `done`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我将调用`request`，传入`app`，然后我将继续调用`get`，设置URL。我们不需要在这里使用模板字符串，因为我们只会传入一个普通字符串，`/todos/123abc`。确实是一个无效的ObjectID。正如我们所讨论的，ObjectIDs具有非常特定的结构，而这个不符合这个标准。要了解更多关于ObjectIDs的信息，你可以随时回到本章开头的ObjectID部分。接下来，我们将开始设置我们的断言，通过调用`expect`并期望返回`404`，然后我们可以通过调用`end`方法并传入`done`来结束这个测试：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With this in place, our test suite for `GET /todos/:id` is complete. Over in
    the Terminal it just reran and all of the test cases passed, and this is fantastic:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们对`GET /todos/:id`的测试套件就完成了。在终端中它刚刚重新运行，所有的测试用例都通过了，这太棒了：
- en: '![](img/aeccb951-303d-495e-9f59-c56fda1495f6.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aeccb951-303d-495e-9f59-c56fda1495f6.png)'
- en: We now have a complete test suite set up for the route, which means we are done,
    and if the data comes back incorrectly, for example, if the body data has an extra
    character appended like the character `1`, the test cases are going to fail. Everything
    is working really, really well.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为路由设置了一个完整的测试套件，这意味着我们已经完成了，如果数据返回不正确，例如，如果body数据附加了一个额外的字符，比如字符`1`，测试用例将失败。一切都运行得非常非常好。
- en: 'The last thing left to do is commit our changes. Over inside the Terminal I''m
    going to shut down `nodemon` and run `git status`. Here are the only changes we
    have are our changes to the `server.test` file, which is a modified file—git is
    already tracking it, which means I can use `git commit` with the `-a` or `-m`
    flag or the combined `-am` flag, providing a message, `Add test cases for GET
    /todos/:id`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要做的就是提交我们的更改。在终端中，我将关闭`nodemon`并运行`git status`。这里我们唯一的更改是对`server.test`文件的更改，这是一个修改过的文件—git已经在跟踪它，这意味着我可以使用`git
    commit`与`-a`或`-m`标志或组合的`-am`标志，提供一个消息，`Add test cases for GET /todos/:id`：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I'm going to make the commit and push it up to GitHub. In the next section,
    we're going to switch things up a little bit. Instead of continuing on, adding
    new routes, which we will do a little later, we are going to deploy our application
    to Heroku using a real-world MongoDB database. That means all the calls we're
    making in Postman we can make to a real server, and anybody can make those calls,
    not just people on our local machine, because the URL will no longer be on the
    localhost.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提交并将其推送到GitHub。在下一节中，我们将稍微改变一下。我们不会继续添加新的路由，而是稍后再做，我们将使用真实的MongoDB数据库将我们的应用程序部署到Heroku。这意味着我们在Postman中进行的所有调用都可以在真实服务器上进行，任何人都可以进行这些调用，而不仅仅是我们本地机器上的人，因为URL将不再位于本地主机上。
- en: Deploying the API to Heroku
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将API部署到Heroku
- en: In this section, you're going to deploy the Todo API to Heroku so anybody with
    the URL can access these routes, adding and fetching Todo items. Now, before we
    can push it to Heroku, there are quite a few things we need to change, small tweaks
    to get it ready for the Heroku servers. One of the bigger tweaks is going to be
    to set up a real MongoDB database because currently we use a localhost database
    and this is not going to be available once we get our app on Heroku.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将把Todo API部署到Heroku，这样任何人都可以访问这些路由，添加和获取Todo项目。现在，在我们将其推送到Heroku之前，有很多事情需要改变，需要进行一些小的调整，以便为Heroku服务器做好准备。其中一个较大的调整是设置一个真实的MongoDB数据库，因为目前我们使用的是本地主机数据库，一旦我们将应用程序部署到Heroku上，这将不再可用。
- en: 'To kick things off we''re going to move into the `server` file and set up the
    `app` variable to use the `environment` port variable that Heroku is going to
    set, which we did in the previous section when we deployed to Heroku. If you remember,
    what we did was we created a variable called `port` and we set that equal to `process.env.PORT`.
    This is the variable that may or may not be set; it''s going to be set if the
    app is running on Heroku, but it won''t be set if it''s running locally. We can
    use our `||` (OR) syntax to set up a value if a port is not defined. This is going
    to be used on the localhost and we''re going to stick with port `3000`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将进入`server`文件并设置`app`变量以使用Heroku将设置的`environment`端口变量，这是我们在上一节部署到Heroku时所做的。如果您还记得，我们创建了一个名为`port`的变量，并将其设置为`process.env.PORT`。这是一个可能设置或可能未设置的变量；如果应用程序在Heroku上运行，它将被设置，但如果在本地运行，它将不会被设置。我们可以使用我们的`||`（或）语法来设置一个值，如果端口未定义。这将在本地主机上使用，并且我们将坚持使用端口`3000`：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the `process.env.PORT` variable is there, we''re going to use it; if it''s
    not we''ll use `3000`. Now, we need to swap out `3000` in `app.listen` with the
    `port`, which means our call to `app.listen` is going to have `port` passed in
    and our string below is going to get switched to a template string, so we can
    inject the actual port. Inside `app.listen` I''ll use `Started up at port`, then
    I''m going to inject the actual port variable into the template string:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`process.env.PORT`变量存在，我们将使用它；如果没有，我们将使用`3000`。现在，我们需要在`app.listen`中用`port`替换`3000`，这意味着我们调用`app.listen`将传入`port`，我们的字符串将被切换为模板字符串，这样我们就可以注入实际的端口。在`app.listen`中，我将使用`Started
    up at port`，然后我将把实际的端口变量注入到模板字符串中：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alright, the port is set up and now we can move into the `package.json` file.
    There''s two things we need to tweak. First up, we need to tell Heroku how to
    start the project. This is done via the `start` script. The `start` script is
    the command that Heroku is going to run to start the application. In our case
    it''s going to be `node`, then we''re going to go into the `server` directory
    and we''re going to run the `server.js` file. I have a comma at the end and we
    are good to go with the `start` script:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，端口已经设置好了，现在我们可以进入`package.json`文件。有两件事我们需要调整。首先，我们需要告诉Heroku如何启动项目。这是通过`start`脚本完成的。`start`脚本是Heroku要运行以启动应用程序的命令。在我们的情况下，它将是`node`，然后我们将进入`server`目录并运行`server.js`文件。我在末尾加了一个逗号，`start`脚本就准备好了：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next thing we need to do is tell Heroku which version of Node we want to
    use. The default version currently is a v5 version of Node and that''s going to
    cause some problems because we take advantage of a lot of ES6 features in this
    project, and those are available in v6 of Node. In order to figure out exactly
    what version of Node you''re using, you can run `node -v` from the Terminal:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是告诉Heroku我们想要使用哪个版本的Node。目前默认版本是Node的v5版本，这将会导致一些问题，因为我们在这个项目中利用了很多ES6功能，而这些功能在Node的v6中是可用的。为了确切地了解您正在使用的Node版本，您可以从终端运行`node
    -v`：
- en: '![](img/5bd2f4bd-ccb0-4ef8-83e3-4d79bf3343fc.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bd2f4bd-ccb0-4ef8-83e3-4d79bf3343fc.png)'
- en: 'Here I''m using 9.3.0; if you''re using a different v6 version that is perfectly
    fine. Over inside of `package.json` we''re going to tell Heroku to use the same
    version we''re using here. This gets done by setting up an `engines` property,
    and `engines` lets us specify various versions for things that Heroku lets us
    configure. One of these is `node`. The property name will be `node` and the value
    is going to be the version of Node to use, `6.2.2`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我使用的是9.3.0；如果您使用的是不同的v6版本，那是完全可以的。在`package.json`内部，我们将告诉Heroku使用我们在这里使用的相同版本。这是通过设置一个`engines`属性来完成的，`engines`让我们指定Heroku让我们配置的各种版本。其中之一是`node`。属性名将是`node`，值将是要使用的Node版本，`6.2.2`：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now our `package.json` file is ready for Heroku. Heroku knows how to start the
    app and it knows exactly which version of Node we want to use, so we won't get
    any weird errors when we deploy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`package.json`文件已经准备好用于Heroku。Heroku知道如何启动应用程序，它也知道我们想要使用哪个Node版本，所以当我们部署时，我们不会遇到任何奇怪的错误。
- en: 'With `package.json` out of the way, the last thing we need to do is set up
    a database, and we''re going to do this with a Heroku add-on. If you go to Heroku''s
    website and click on any of your apps, we haven''t created one for this one, so
    click on an app from the previous section. I''m going to go ahead and click on
    one of mine. You''re going to see a little dashboard where you can do quite a
    few things:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`package.json`，我们需要做的最后一件事就是设置一个数据库，我们将使用Heroku的一个插件来完成这个任务。如果您转到Heroku的网站并点击任何一个您的应用程序，我们还没有为这个创建一个，所以点击上一节中的一个应用程序。我将继续点击我的一个应用程序。您将看到一个小仪表板，您可以在其中做很多事情：
- en: '![](img/2d3cf4cd-110f-4f91-8b04-491a124357f9.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d3cf4cd-110f-4f91-8b04-491a124357f9.png)'
- en: 'As shown in the preceding screenshot, you can see there''s an Installed add-ons
    section, but what we really want is to configure our add-ons. When you configure
    your add-ons you''re able to add all sorts of really cool tools that come built
    in to Heroku. Now, not all of these are free but most of them have a good free
    plan:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，您可以看到有一个已安装的插件部分，但我们真正想要的是配置我们的插件。当您配置您的插件时，您可以添加各种内置到Heroku中的非常酷的工具。现在，并不是所有这些都是免费的，但其中大多数都有一个很好的免费计划：
- en: '![](img/64dbf0fc-816e-41bc-822c-266c7a5d7921.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64dbf0fc-816e-41bc-822c-266c7a5d7921.png)'
- en: 'You can see we have various database-related items; down below we have Data
    Store Utilities, we have Monitoring tools, and a lot of really cool stuff. What
    we''re going to be using is an add-on called mLab:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们有各种与数据库相关的项目；在下面，我们有数据存储工具，我们有监控工具，还有很多非常酷的东西。我们将使用一个名为mLab的插件：
- en: '![](img/933af428-a4ba-4c37-8d70-5cb0bf05186b.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/933af428-a4ba-4c37-8d70-5cb0bf05186b.png)'
- en: This is a MongoDB database service; it has a great free plan, and it's going
    to let us integrate MongoDB with our Heroku application. Now, you don't actually
    need to do anything from the website, as we're going to do everything from the
    Terminal. I just want to make you aware of exactly where this lives. Down below,
    you can see they do have a free Sandbox plan and they have plans that go all the
    way up to $5,000 a month. We're going to be sticking with a zero-dollar plan.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个MongoDB数据库服务；它有一个很好的免费计划，它将让我们将MongoDB与我们的Heroku应用程序集成起来。现在，您实际上不需要从网站上做任何事情，因为我们将从终端上做所有的事情。我只是想让您确切地知道这个位于哪里。在下面，您可以看到他们有一个免费的Sandbox计划，他们还有一些计划，最高达每月5000美元。我们将坚持零美元计划。
- en: Creating a Heroku app
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Heroku应用程序
- en: 'In order to get set up, over inside of the Terminal we''re going to create
    a new Heroku app because currently we don''t have one. `heroku create` is the
    command to get that done:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行设置，在终端内部，我们将创建一个新的Heroku应用程序，因为目前我们还没有一个。`heroku create`是完成这个任务的命令：
- en: '![](img/228770c5-058b-4d63-9a08-6b772f713115.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/228770c5-058b-4d63-9a08-6b772f713115.png)'
- en: 'Once the application has been created we need to tell the app that we want
    to use `mLab`, which is short for Mongo Lab. In order to add this add-on, we''re
    going to run the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序创建完成后，我们需要告诉应用程序我们想要使用`mLab`，这是Mongo Lab的缩写。为了添加这个插件，我们将运行以下命令：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, the add-on is `mongolab:`, and after the `:` we''re going to specify the
    plan we want to use. We''re going to use the Sandbox plan, which is free:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个插件是`mongolab:`，在`:`之后，我们将指定我们想要使用的计划。我们将使用免费的Sandbox计划：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we run this command it''s going to configure `mLab` with our Heroku application
    and we are good to go. Now, if you run the `heroku config` command you can actually
    get a list of all the configuration variables for your Heroku application:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个命令时，它将配置`mLab`与我们的Heroku应用程序，我们就可以开始了。现在，如果您运行`heroku config`命令，您实际上可以获得您的Heroku应用程序的所有配置变量的列表：
- en: '![](img/6530f625-915e-42d0-8859-4e2222687f14.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6530f625-915e-42d0-8859-4e2222687f14.png)'
- en: 'Right now, we just have one configuration variable; it''s a MONGODB_URI. This
    is the database URL that `mLab` gave us. This is the one we need to connect to,
    it''s the only one available for our app. Now, this MONGODB_URI variable, this
    is actually on `process.env` when the app runs on Heroku, which means we can use
    a similar technique to what we did inside of our `mongoose.js` file. Inside of
    `mongoose.js`, right in our call to `connect`, we can check if `process.env.MONGODB_URI`
    exists. If it does, we''re going to use it; if it doesn''t, after our `||` statement,
    we are going to use the localhost URL:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有一个配置变量；它是一个MONGODB_URI。这是`mLab`给我们的数据库URL。这是我们需要连接的，也是我们应用程序唯一可用的。现在，这个MONGODB_URI变量，实际上是在`process.env`上，当应用程序在Heroku上运行时，这意味着我们可以使用类似的技术来处理我们在`mongoose.js`文件中所做的事情。在`mongoose.js`中，在我们的`connect`调用中，我们可以检查`process.env.MONGODB_URI`是否存在。如果存在，我们将使用它；如果不存在，在我们的`||`语句之后，我们将使用本地主机URL：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And this is going to make sure that our Heroku app connects to the actual database
    because connecting to localhost will fail, causing the app to crash. With this
    in place, we are now ready to get things going.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保我们的Heroku应用程序连接到实际的数据库，因为连接到本地主机将失败，导致应用程序崩溃。有了这个设置，我们现在准备好开始了。
- en: 'Over inside of the Terminal I''m going to run `git status` to check our changed
    files:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端内部，我将运行`git status`来检查我们的更改文件：
- en: '![](img/cda444d3-55d5-44f9-b5f2-e01c9615739d.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cda444d3-55d5-44f9-b5f2-e01c9615739d.png)'
- en: 'We have three; everything looks good. I can run `git commit` with the `-am`
    flag. This is going to let us specify our commit message, `Setup app for heroku`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个；一切看起来都很好。我可以运行`git commit`，带上`-am`标志。这将让我们指定我们的提交消息，`为heroku设置应用程序`：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I''m going to make the commit and push it up to GitHub. Now, we need to push
    our application to Heroku. I''m going to do that using the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提交并将其推送到GitHub。现在，我们需要将我们的应用程序推送到Heroku。我将使用以下命令来做到这一点：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Remember, when you create a Heroku application, it automatically adds that Heroku
    remote and here we're posting it to the master branch. The master branch is the
    only branch Heroku is actually going to do anything with. The application is getting
    pushed up; it should be ready in just a few seconds. Once it's done, we can open
    up the URL in the browser and see exactly what we get.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你创建一个Heroku应用程序时，它会自动添加Heroku远程，并且我们将其发布到主分支。主分支是唯一一个Heroku实际上会处理的分支。应用程序正在被推送上去；它应该在几秒钟内准备好。一旦完成，我们可以在浏览器中打开URL，看看我们得到了什么。
- en: Heroku logs
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Heroku日志
- en: 'Another command I want to talk about for just a moment is a command called
    `heroku logs`. The `heroku logs` command shows you the server lives for your application.
    If anything goes wrong you usually get an error message inside of the Terminal:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我想简要谈一下另一个命令，叫做`heroku logs`。`heroku logs`命令会显示应用程序的服务器日志。如果出现任何问题，通常会在终端内收到错误消息：
- en: '![](img/f50b0316-8ace-4d3a-982b-4b82dbe139da.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f50b0316-8ace-4d3a-982b-4b82dbe139da.png)'
- en: Now, as you can see, we have our Started on port 4765 message printing at the
    bottom, which is great; your port is going to be different. As long as you have
    this message everything should be good to go. I am going to run `heroku open`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所看到的，我们在底部打印了端口4765上启动的消息，这很好；你的端口会有所不同。只要你有这个消息，一切都应该正常。我将运行`heroku open`。
- en: 'This is going to open up the application in my browser. I''m going to choose
    to copy the URL. I''ll move into Chrome, and I can visit it:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我的浏览器中打开应用程序。我将选择复制URL。然后我会进入Chrome，并访问它：
- en: '![](img/666649b2-58e3-4844-87c0-fe79f551c4e8.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/666649b2-58e3-4844-87c0-fe79f551c4e8.png)'
- en: 'Now, visiting the root of the app should do nothing because we haven''t set
    up a root URL, but if we go to `/todos` we should get our `todos JSON` coming
    back:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，访问应用程序的根应该什么也不会发生，因为我们还没有设置根URL，但如果我们转到`/todos`，我们应该会得到我们的`todos JSON`返回：
- en: '![](img/10bcefb2-8817-4860-b2fa-50106753b2c0.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10bcefb2-8817-4860-b2fa-50106753b2c0.png)'
- en: Here you can see we have an empty array, which is expected because we haven't
    added any Todo items, so let's go ahead and do that.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们有一个空数组，这是预期的，因为我们还没有添加任何Todo项目，所以让我们继续做。
- en: 'What I want to do is grab the URL and head over to Postman. Inside of Postman
    we''re going to make a few calls. I''m going to create a `POST /todos` request;
    all I need to do is take the URL and swap it out with the one I just copied, then
    I can send off the request because the body data is already configured. I''m going
    to send that off. We get our Todo item and this is not coming from our local machine,
    this is coming from our Heroku application, which is talking to our Mongo Lab
    MongoDB database:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我想做的是获取URL并转到Postman。在Postman中，我们将进行一些调用。我将创建一个`POST /todos`请求；我只需要取出URL并将其替换为我刚刚复制的URL，然后我可以发送该请求，因为请求体数据已经配置好了。我将发送请求。我们得到了我们的Todo项目，这不是来自我们的本地机器，而是来自我们的Heroku应用，它正在与我们的Mongo
    Lab MongoDB数据库交互：
- en: '![](img/090d8e5a-d281-40ea-b91b-c981c6c8ec73.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/090d8e5a-d281-40ea-b91b-c981c6c8ec73.png)'
- en: 'Now, all the other commands should also work. I''m going to go to `GET /todos`,
    paste in the URL, and we should be able to get all of our Todo items:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有其他命令也应该有效。我将转到`GET /todos`，粘贴URL，然后我们应该能够获取所有的Todo项目：
- en: '![](img/7e5e7556-9672-493d-a82a-d29be9feb3c7.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e5e7556-9672-493d-a82a-d29be9feb3c7.png)'
- en: 'I''m also going to check what happens when we try to fetch an individual Todo.
    I''ll copy the `_id`, add it on to the URL, and send off that request:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我还要检查当我们尝试获取单个Todo时会发生什么。我会复制`_id`，将其添加到URL上，并发送该请求：
- en: '![](img/711071d6-9ab7-4e77-9a4f-f8c9ef5cbbb5.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/711071d6-9ab7-4e77-9a4f-f8c9ef5cbbb5.png)'
- en: I get the individual Todo item. So, no matter which call we use, everything
    is working as expected and this is fantastic. Our application is now running on
    Heroku with a real production database, and that is it for this one. Now that
    we're clued up on Heroku, in the next section I'm going to show you a few tweaks
    and tricks we can use inside of Postman to make switching between our local environment
    and our Heroku environment much, much easier.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了单个Todo项目。所以，无论我们使用哪个调用，一切都按预期工作，这太棒了。我们的应用程序现在在Heroku上运行，使用真实的生产数据库，就是这样。现在我们对Heroku有了一定了解，在下一节中，我将向你展示一些我们可以在Postman中使用的调整和技巧，以便更轻松地在我们的本地环境和Heroku环境之间切换。
- en: Postman environments
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Postman环境
- en: Before we get back to creating our express routes, we're going to take a quick
    moment to explore a feature of Postman that's going to make it a lot easier to
    switch between your local environment and the Heroku application. This is called
    Postman Environments.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回到创建express路由之前，我们将花一点时间来探索Postman的一个功能，这将使在本地环境和Heroku应用之间切换变得更容易。这就是所谓的Postman环境。
- en: Managing Postman environments
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Postman环境
- en: 'Now, in order to illustrate this I am going to start up my local server by
    running `node server/server.js` command, and over inside of Postman we''re going
    to start making a few requests. Now, if you remember, in the last section we made
    a request to our Heroku application. I click Send on the `GET /todos` URL and
    I get the `todos` array back as expected. The problem is that the actual items
    saved in the Collections tab, they all use that localhost URL and there''s no
    good way to switch between the two. To fix this issue we''re going to create environments,
    one for our local machine, and one for Heroku. This is going to let us create
    a variable as the URL and we can change that variable by flicking a switch over
    in the No environments dropdown. To illustrate exactly how this is going to work
    I am going to be copying the Heroku URL right now, then I''m going to head over
    to the No environment dropdown, and click Manage Environments:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了说明这一点，我将通过运行`node server/server.js`命令启动我的本地服务器，在Postman中我们将开始发出一些请求。现在，如果你记得，在上一节中，我们向我们的Heroku应用程序发出了请求。我点击`GET
    /todos` URL上的发送，我得到了预期的`todos`数组。问题是，实际保存在集合选项卡中的项目，它们都使用了本地主机URL，没有很好的方法在两者之间切换。为了解决这个问题，我们将创建环境，一个用于我们的本地机器，一个用于Heroku。这将让我们创建一个变量作为URL，并且我们可以通过在无环境下拉菜单中切换来更改该变量。为了准确说明这将如何工作，我现在将复制Heroku
    URL，然后我将转到无环境下拉菜单，并点击管理环境：
- en: '![](img/86476d86-6921-457e-9108-e9d0850f025e.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86476d86-6921-457e-9108-e9d0850f025e.png)'
- en: Here we currently have none, but we can go ahead and add in two.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们目前没有，但我们可以继续添加两个。
- en: Todo App Local environment
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Todo App 本地环境
- en: 'For the first environment I''m going to call `Todo App Local`. This is going
    to be the local Todo application and we can set up a set of key value pairs. Now,
    the only key we''re going to set is url. We''re going to set a localhost URL for
    the Todo App Local environment and we''ll set the Heroku URL for the Todo App
    Heroku environment, which we''ll create in just a second. We''ll enter `url` as
    `localhost:3000`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个环境，我将称之为`Todo App Local`。这将是本地Todo应用程序，我们可以设置一组键值对。现在，我们要设置的唯一键是url。我们将为Todo
    App Local环境设置本地主机URL，并为Todo App Heroku环境设置Heroku URL，我们将在接下来创建。我们将输入`url`为`localhost:3000`：
- en: '![](img/0cd6eac1-9736-46fa-bb60-cd05c0dab9b3.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cd6eac1-9736-46fa-bb60-cd05c0dab9b3.png)'
- en: We're leaving off paths because that is going to depend on the individual route.
    I'm going to go ahead and add that environment.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不包括路径，因为这将取决于个别路线。我将继续添加该环境。
- en: Todo App Heroku environment
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Todo App Heroku环境
- en: 'We can create a second one; this one will be called `Todo App Heroku` and we''re
    going to set the `url` key once again. This time though we''re setting it equal
    to the value I copied to the clipboard, the Heroku application URL:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建第二个；这个将被称为`Todo App Heroku`，我们将再次设置`url`键。不过这一次，我们将其设置为我复制到剪贴板的值，即Heroku应用程序URL：
- en: '![](img/d25b6893-7c19-4bcc-b91e-f5e984739785.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d25b6893-7c19-4bcc-b91e-f5e984739785.png)'
- en: I'm going to add that, now we have our two environments and I can close that
    window manager.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加，现在我们有了两个环境，我可以关闭那个窗口管理器。
- en: 'I''m going to close all of my tabs and I''m not going to make any changes by
    saving, then I''m going to go to `GET /todos`. Now, currently, `GET /todos` automatically
    fetches from `localhost`. What we''re going to do is replace the URL, everything
    before the slash, with the following syntax, which will look similar if you''re
    familiar with any templating engines: two curly braces followed by the variable
    name, `url`, followed by two closing braces, `{{url}}`. This is going to inject
    the URL meaning that the `GET /todos` request is now dynamic. We can change which
    endpoint it requests from, localhost or Heroku, based on the environment. I''m
    going to save this request and fire it off, and you''ll notice when you try to
    fire this request that we get an error:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我将关闭所有标签，不保存任何更改，然后我将转到`GET /todos`。现在，当前，`GET /todos`自动从`localhost`获取。我们要做的是用以下语法替换URL，斜杠之前的所有内容，这将看起来类似于任何模板引擎：两个大括号，后面跟着变量名`url`，然后是两个闭合括号，`{{url}}`。这将注入URL，这意味着`GET
    /todos`请求现在是动态的。我们可以根据环境更改它从哪个端点请求，localhost或Heroku。我将保存此请求并发送它，你会注意到当你尝试发送此请求时，我们会收到一个错误：
- en: '![](img/dfb4ed04-4556-437c-b818-084110cafd94.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfb4ed04-4556-437c-b818-084110cafd94.png)'
- en: 'It''s trying to make a request to a URL that starts with the curly braces;
    it is the encoded character, `url`, the closing curly braces, and todos. That''s
    because the `url` variable is currently not defined. We need to switch to an environment.
    Over in the environments list we now have Todo App Heroku and Todo App Local.
    If I click Todo App Local and send that request off, I get my two items in the
    local database:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图向以大括号开头的URL发出请求；这是编码字符，`url`，闭合大括号和todos。这是因为`url`变量目前未定义。我们需要切换到一个环境。在环境列表中，我们现在有Todo
    App Heroku和Todo App Local。如果我点击Todo App Local并发送该请求，我会在本地数据库中得到两个项目：
- en: '![](img/ec632d3c-ebe0-4764-8f55-92e12132b1e0.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec632d3c-ebe0-4764-8f55-92e12132b1e0.png)'
- en: 'If I switch over to Todo App Heroku, this is going to make a request to the
    Heroku application. It''s going to be updating the URL and when we fire it off
    we get a different set of data:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我切换到Todo App Heroku，这将向Heroku应用程序发出请求。它将更新URL，当我们发出请求时，我们会得到不同的数据：
- en: '![](img/ed631fd9-25a4-46e1-a145-68b9d360c2bc.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed631fd9-25a4-46e1-a145-68b9d360c2bc.png)'
- en: 'This time around all we have is our one Todo item, the one that''s available
    on the Heroku application. With this in place, `GET /todos` can now easily be
    used to fetch localhost or Heroku items, and we can do the same thing with our
    `POST /todos` request. I''m going to replace the URL with curly braces, and inside
    of those curly braces we''ll have the `url` variable. Now I can go ahead and save
    this request, fire it off, and it''s going to make a new Todo on the Heroku application:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们只有一个Todo项目，即Heroku应用程序上可用的项目。有了这个，`GET /todos`现在可以轻松地用来获取本地主机或Heroku项目，我们也可以用我们的`POST
    /todos`请求做同样的事情。我将用花括号替换URL，并在这些花括号中放入`url`变量。现在我可以保存这个请求，发送它，它将在Heroku应用程序上创建一个新的Todo：
- en: '![](img/bac62164-ff98-4f51-9de7-fae6a35c6012.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bac62164-ff98-4f51-9de7-fae6a35c6012.png)'
- en: 'If I switch to the Todo App Local, we can fire that off and now we have a new
    Todo on the Local environment:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我切换到Todo App Local，我们可以发送它，现在我们在本地环境中有一个新的Todo：
- en: '![](img/e9962c29-7867-4a3c-b2b5-35ad1ece5a3b.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9962c29-7867-4a3c-b2b5-35ad1ece5a3b.png)'
- en: 'The last request to change is going to be the `GET /todos/:id` request. We''re
    going to take that `localhost:3000` once again, then we''re going to go ahead
    and replace it with `url` just like this, `{{url}}`, and now we are done. We can
    save the request and we can go ahead and fire it off. Now, this one has a second
    variable:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要更改的请求是`GET /todos/:id`请求。我们将再次使用`localhost:3000`，然后我们将用`url`替换它，就像这样，`{{url}}`，现在我们完成了。我们可以保存这个请求，然后发送它。现在，这个有第二个变量：
- en: '![](img/f3f4c26f-c323-4fc7-b655-20f97d8f21ad.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3f4c26f-c323-4fc7-b655-20f97d8f21ad.png)'
- en: 'This is the actual Todo ID; you could add this as a variable as well. For now
    though, since it''s going to change as we add and delete Todos, I''m going to
    simply grab one from the local database, move into the `GET /todos` request, swap
    it out, and send it off, and we get our todo back:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际的Todo ID；您也可以将其添加为变量。不过，由于随着我们添加和删除Todos，它将发生变化，所以我将简单地从本地数据库中获取一个，移动到`GET
    /todos`请求中，替换它，然后发送它，我们就可以得到我们的todo：
- en: '![](img/03fbcf9f-d253-4b67-8134-cb994c78507d.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03fbcf9f-d253-4b67-8134-cb994c78507d.png)'
- en: If I make it a Todo ObjectID that doesn't exist, by changing one of the numbers
    to `6`, I get a `404` status code. Everything is still working as expected, and
    it's also going to work in the Heroku environment. I'm going to fetch all the
    todos from the Heroku environment, grab one of the `_id`s, move to the `GET /todos/:id`
    request, swap out the ID, send it off, and we get the todo item.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将它设置为一个不存在的Todo ObjectID，通过将其中一个数字改为`6`，我会得到一个`404`状态码。一切仍然按预期工作，它也将在Heroku环境中工作。我将从Heroku环境中获取所有的todos，获取一个`_id`，移动到`GET
    /todos/:id`请求，替换ID，发送它，我们就可以得到todo项目。
- en: Hopefully you're starting to see why these Postman Environments are so convenient.
    You can easily switch between two environments, changing exactly what happens
    to the request. Now, in this case, we happen to only have one variable `url`;
    you could add others, and we will a little bit later. For now though, that is
    it, we have a way to swap between the two environments inside of Postman. Now
    that we have this in place, we're going to move back into the Atom editor and
    we're going to start adding new routes. There's two more to go. In the next section,
    you're going to learn how to delete Todos by ID.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您开始看到为什么这些Postman环境是如此方便。您可以轻松地在两个环境之间切换，精确地改变请求的发生情况。现在，在这种情况下，我们碰巧只有一个变量`url`；您可以添加其他变量，稍后我们会添加。不过，现在就是这样，我们有一种在Postman中在两个环境之间切换的方法。既然我们已经做到了这一点，我们将回到Atom编辑器，开始添加新的路由。还有两个要做。在下一节中，您将学习如何通过ID删除Todos。
- en: Deleting a resource – DELETE /todos/:id
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除资源 - DELETE /todos/:id
- en: In this section, we're going to explore how to remove documents from our MongoDB
    collections using Mongoose. Then you're going to be responsible for filling out
    the `delete` route, which will let someone delete a Todo by the ID.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探讨如何使用Mongoose从我们的MongoDB集合中删除文档。然后您将负责填写`delete`路由，该路由将允许某人通过ID删除一个Todo。
- en: 'To get started we''re going to duplicate that `mongoose-queries` file, calling
    the new file `mongoose-remove`. Inside of the file we can remove everything below
    our initial imports. I''m going to highlight everything in the file, including
    the uncommented-out code, remove it, and we end up with a file that looks like
    this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将复制`mongoose-queries`文件，将新文件命名为`mongoose-remove`。在文件中，我们可以删除初始导入以下的所有内容。我将突出显示文件中的所有内容，包括未注释的代码，然后删除它，我们最终得到一个看起来像这样的文件：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Mongoose gives us three methods for deleting our records; the first one lets
    you delete multiple records.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose为我们提供了三种删除记录的方法；第一种方法允许您删除多个记录。
- en: Todo.remove method
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Todo.remove方法
- en: 'This one is `Todo.remove`, and `Todo.remove` works kind of like `Todo.find`.
    You pass in a query and that query matches multiple records, removing all of them.
    If it matches none, none will get removed. Now, the difference between `Todo.find`
    and `Todo.remove`, other than the fact that remove removes the docs, is that you
    can''t pass in an empty argument and expect all the documents to get removed.
    If you want to remove everything from your collection you need to run it like
    `Todo.remove({})`. If we run this we''re going to have everything get removed.
    I''m going to tack `then`. We''re going to get back our result and we can print
    that result to the screen using `console.log(result)`, just like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个是`Todo.remove`，`Todo.remove`的工作方式类似于`Todo.find`。您传入一个查询，该查询匹配多个记录，然后删除所有匹配的记录。如果没有匹配，就不会删除任何记录。现在，`Todo.find`和`Todo.remove`之间的区别，除了删除文档之外，还有一个区别，就是您不能传入一个空参数，然后期望所有文档都被删除。如果您想要从集合中删除所有内容，您需要像这样运行它`Todo.remove({})`。如果我们运行这个，我们将删除所有内容。我将添加`then`。我们将得到我们的结果，我们可以使用`console.log(result)`将结果打印到屏幕上，就像这样：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can run the `mongoose-remove` file, which is going to remove all of
    the Todos from our database:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行`mongoose-remove`文件，它将从我们的数据库中删除所有的Todos：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](img/8c04ea2d-7a16-4a78-b0b9-c0f6b1114821.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c04ea2d-7a16-4a78-b0b9-c0f6b1114821.png)'
- en: Now when we run the `remove` method, once again we get back a `result` object;
    a lot of this stuff is not useful to us but up at the very top there is a `result`
    property. We can see that the removal did work, we got a `1` back as opposed to
    `0`, and we have the number of records that were removed. In this case the number
    of records happens to be `3`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行`remove`方法时，我们再次得到一个`result`对象；其中很多内容对我们来说并不有用，但在顶部有一个`result`属性。我们可以看到删除确实起作用了，我们得到了`1`而不是`0`，并且我们知道删除了多少条记录。在这种情况下，记录的数量恰好是`3`。
- en: Todo.findOneAndRemove method
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Todo.findOneAndRemove方法
- en: 'There are two other ways to remove documents and these are going to be much
    more useful for us in this section. The first one is going to be `Todo.findOneAndRemove`.
    Now, `findOneAndRemove` is going to work kind of like `findOne`: it''s going to
    match that very first document, only it''s going to remove it. This will also
    return the document so you can do something with the removed data. The data will
    be removed from the database but you will get the object back so you can print
    it to the screen or send it back to the user. This is unlike the `remove` method.
    In the `remove` method we do not get the docs back that got removed, we just get
    a number saying how many were removed. With `findOneAndRemove` we do get that
    information back.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种其他删除文档的方法，这些方法对我们在本节中将会更有用。第一种将是`Todo.findOneAndRemove`。现在，`findOneAndRemove`的工作方式类似于`findOne`：它将匹配第一个文档，只是它将删除它。这也将返回文档，因此您可以对已删除的数据进行操作。数据将从数据库中删除，但您将获得对象，因此可以将其打印到屏幕上或将其发送回给用户。这与`remove`方法不同。在`remove`方法中，我们不会得到已删除的文档，我们只会得到一个数字，表示删除了多少个。使用`findOneAndRemove`我们会得到这些信息。
- en: Todo.findByIdAndRemove method
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Todo.findByIdAndRemove方法
- en: 'Another method is `Todo.findByIdAndRemove`. The `findByIdAndRemove` method
    works just like `findById`: you pass in the ID as the argument and it removes
    it. Now, both of these are going to return the doc and that is exactly what we
    want. There''s no need to run both of them, we can just run one. The `Todo.findByIdAndRemove`
    method, this is going to let us remove a `Todo ById`, some ID like `asdf`, and
    we''re going to be able to attach a `then` method providing our callback, and
    the callback is going to get the doc back. You could call it doc, or in this case
    we can call it `todo` since it is a Todo item:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是`Todo.findByIdAndRemove`。`findByIdAndRemove`方法的工作方式与`findById`类似：您将ID作为参数传递，然后将其删除。现在，这两种方法都将返回文档，这正是我们想要的。没有必要同时运行它们，我们只需要运行一个。`Todo.findByIdAndRemove`方法，这将让我们删除一个`Todo
    ById`，一些ID像`asdf`，我们将能够附加一个`then`方法提供我们的回调，回调将获得文档。您可以称其为文档，或者在这种情况下，我们可以称其为`todo`，因为它是一个Todo项目：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we have this in place, we just need to create a Todo, since we deleted
    all of them, and include the ID. Over inside of Robomongo I can right-click that
    `todos` collection and insert a document. We''re just going to set a `text` property
    and I''ll set that `text` property equal to `Something to do`, and we can save
    that record. I''m going to make sure that when I click View Documents we do get
    our one document:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个，我们只需要创建一个Todo，因为我们删除了所有的Todo，并包括ID。在Robomongo中，我可以右键单击`todos`集合并插入一个文档。我们将设置一个`text`属性，我将把`text`属性设置为`Something
    to do`，然后我们可以保存该记录。我将确保当我点击查看文档时，我们会得到我们的一个文档。
- en: '![](img/4d70010f-0594-4a0c-a4f4-edf08d09155c.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d70010f-0594-4a0c-a4f4-edf08d09155c.png)'
- en: 'Now obviously it is missing some of the properties since I created it in Robomongo,
    but that is fine for our purposes. I''m now going to edit that document and grab
    the ID, and this is the ID we can add in to our playground file to make sure the
    document gets removed. Over inside of Atom, in the `findByIdAndRemove` method,
    we''ll pass in our string. This is the string ID, and inside of our `then` callback
    we''re going to use `console.log` to print the todo to the console. I am going
    to comment out this call to remove previous because otherwise it would remove
    the document we''re trying to remove:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显然它缺少一些属性，因为我是在Robomongo中创建的，但对我们的目的来说这没关系。我现在要编辑该文档并获取ID，这是我们可以添加到我们的playground文件中以确保文档被删除。在Atom中，`findByIdAndRemove`方法中，我们将传入我们的字符串。这是字符串ID，在我们的`then`回调中，我们将使用`console.log`将todo打印到控制台。我将注释掉之前的删除调用，否则它会删除我们要删除的文档：
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this in place, I can now save the file, head into the Terminal, and rerun
    the script. I''m going to shut it down and start it up again:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我现在可以保存文件，进入终端，并重新运行脚本。我将关闭它然后再次启动：
- en: '![](img/18facfc6-160e-471b-9854-7064243c797a.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18facfc6-160e-471b-9854-7064243c797a.png)'
- en: 'We get our documents, which is fantastic, and if I head into Robomongo and
    try to fetch the documents in todos, we''re going to get an error that there are
    no documents; we had one but we deleted it. Now, inside of Atom we can also play
    around with `findOneAndRemove`. The `findOneAndRemove` method works exactly the
    same as `findByIdAndRemove`, only it takes that query object. This would be `Todo.findOneAndRemove`;
    we would pass in the query object like this, pasting in our ID, and we could attach
    our `then` callback, which would get called with the document:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们的文档，这太棒了，如果我进入Robomongo并尝试获取todos中的文档，我们将收到一个错误，即没有文档；我们曾经有一个，但我们已经删除了它。现在，在Atom中，我们还可以玩`findOneAndRemove`。`findOneAndRemove`方法与`findByIdAndRemove`完全相同，只是它接受查询对象。这将是`Todo.findOneAndRemove`；我们将传入查询对象，然后附加我们的`then`回调，该回调将使用文档调用：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Both of these work very similarly, but the big difference is whether or not
    you need to query by more than just the ID. Now that you know how to use `findByIdAndRemove`,
    we're going to go into the `server` file and start filling out the actual route.
    This is going to be the route that lets us delete a Todo. I'll do the setup for
    the route for you, but you're going to be responsible for filling out everything
    inside of the callback function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者工作方式非常相似，但最大的区别是是否需要查询除了ID之外的更多内容。现在你知道如何使用`findByIdAndRemove`，我们将进入`server`文件并开始填写实际的路由。这将是让我们删除Todo的路由。我会为你设置路由，但你需要负责填写回调函数内的所有内容。
- en: Creating a delete route
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个删除路由
- en: To create a delete route we're going to use `app.delete`. Then we're going to
    provide the URL, which will look identical to the one we have for getting an individual
    Todo by Id, `/todos/:id`. This will be the ID we can access inside of the callback
    function. The callback function will get the same request and response arguments,
    and inside I'll leave some comments to guide you in the right direction, but you're
    going to be responsible for filling every single thing out. First up, get the
    id. You're going to pull off the ID just like we do up above and we're going to
    do that because the next thing you're going to do is validate the id. If it's
    not valid, return `404`. If it's not valid you're going to send a 404 back just
    like we do above. Next up, you're going to remove todo by id and this is going
    to require you to use that function we just discussed over inside of the `mongoose-remove`
    file. You're going to remove it by ID and there's two ways that could go. We could
    have a success or we could have an error. If we do get an error you can respond
    in the usual way, sending back a `400` status code with empty body. Now, if it's
    a success we're going to need to make sure that a Todo was actually deleted by
    checking that the doc came back; if no doc, send `404`, so the person knows that
    the ID could not be found and it could not be removed, if `doc`, send `doc` back
    with `200`. Now, the reason we need to check if the doc exists is because this
    function, `findByIdAndRemove`, is still going to have its success case called
    even if no Todo gets deleted.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个删除路由，我们将使用`app.delete`。然后我们将提供URL，它看起来与我们用于通过Id获取单个Todo的URL相同，`/todos/:id`。这将是我们可以在回调函数内访问的ID。回调函数将获得相同的请求和响应参数，并且我会在内部留下一些注释来指导你朝正确的方向前进，但你需要负责填写每一件事情。首先，获取id。你将像我们在上面做的那样获取ID，并且我们这样做是因为接下来你要做的事情是验证id。如果它无效，返回`404`。如果它无效，你将像我们在上面做的那样发送404。接下来，你将通过id删除todo，这将需要你使用我们刚刚在`mongoose-remove`文件中讨论过的函数。你将通过ID删除它，有两种可能。我们可能会成功，也可能会出现错误。如果出现错误，你可以以通常的方式回应，发送一个带有空主体的`400`状态码。现在，如果成功了，我们需要确保通过检查返回的doc来确保Todo实际上已被删除；如果没有doc，则发送`404`，以便对方知道找不到ID并且无法删除，如果有`doc`，则发送带有`200`的`doc`。现在，我们需要检查doc是否存在的原因是因为即使没有删除任何Todo，`findByIdAndRemove`函数仍然会调用其成功情况。
- en: 'I can prove this by rerunning the file after having deleted the item with that
    ID. I''m going to comment out `findOneAndRemove`, head into the Terminal, and
    rerun the script:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过删除具有该ID的项目后重新运行文件来证明这一点。我将注释掉`findOneAndRemove`，进入终端，然后重新运行脚本：
- en: '![](img/2d54687a-389c-48ad-ad10-3c64281e02a9.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d54687a-389c-48ad-ad10-3c64281e02a9.png)'
- en: We get null as the value of Todo. That means you want to set up an `if` statement,
    to do something specific if no item was actually deleted. With this in place,
    you are ready to go. You know how to do all of this, most of it is done in the
    route up above and everything specific to removing an item was done over in this
    `playground` file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的Todo的值为null。这意味着如果实际上没有删除任何项目，你希望设置一个`if`语句来执行特定的操作。有了这个设置，你就准备好了。你知道如何做所有这些，大部分是在上面的路由中完成的，而删除项目的所有特定内容都是在`playground`文件中完成的。
- en: The first thing we need to do is grab the ID off of the request object. I'm
    going to make a variable called `id`, setting it equal to `req.params`; this is
    where all of our URL parameters are stored, then we get it by value. We have id
    set up so we would get the `id` property. I'm going to remove the comment and
    down below we can validate the ID, `if(ObjectID.isValid)`. Now, we're checking
    if this ID is valid, and if it is valid, well we don't really want to do anything,
    all we care about is if it's not valid. So, I'm going to flip the Boolean value
    and inside of the `if` condition we can now run some code when the ID is not valid.
    That code is going to send back a `404` status code. I'm going to use `return`
    to prevent the rest of the function from being executed, then we're going to go
    ahead and respond, setting the status, `res.status`, equal to `404`, and we'll
    call `send` to initiate the response with no body data. Now that the ObjectID
    is valid, we can move on down below actually removing it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从请求对象中获取ID。我将创建一个名为`id`的变量，将其设置为`req.params`；这是我们存储所有URL参数的地方，然后我们按值获取它。我们已经设置了id，所以我们将获取`id`属性。我将删除注释，然后在下面我们可以验证ID，`if(ObjectID.isValid)`。现在，我们正在检查这个ID是否有效，如果有效，我们实际上不想做任何事情，我们只关心它是否无效。所以，我将翻转布尔值，并且在`if`条件内，我们现在可以运行一些代码，当ID无效时。这段代码将发送回一个`404`状态码。我将使用`return`来防止函数的其余部分被执行，然后我们将继续响应，设置状态，`res.status`等于`404`，然后调用`send`来启动没有主体数据的响应。现在ObjectID有效了，我们可以继续下面实际删除它。
- en: 'We''re going to kick things off by calling `Todo.findByIdAndRemove`. Now, `findByIdAndRemove`
    as you know takes just one argument, the actual `id` to remove, we can call `then`,
    passing in our success callback, which as we know will get called with the individual
    `todo` document. Now, inside of the success case we still have to make sure a
    Todo is actually deleted. If there was no Todo, we''re going to send a 404 back;
    if there was no Todo, we are going to respond using `return` and set the status
    using `res.status` to `404`, and call `send` to initiate the response. Now, if
    this if statement doesn''t run it means a Todo was actually deleted. In that case
    we want to respond with `200`, letting the user know that everything went well,
    and we''re going to send the `todo` argument back, `res.send`, passing in `todo`.
    The only thing left to do for this Todo challenge is to call `catch`. We''re going
    to call catch so we can do something with any potential errors. All we''re going
    to do is respond using `res.status`, setting it equal to `400`, and we''ll go
    ahead and call `send` with no arguments sending back an empty response:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用`Todo.findByIdAndRemove`来开始。现在，`findByIdAndRemove`只需要一个参数，即要删除的实际`id`，我们可以调用`then`，传入我们的成功回调，正如我们所知，将使用单个`todo`文档调用。现在，在成功的情况下，我们仍然必须确保待办事项实际上已被删除。如果没有待办事项，我们将发送一个404；如果没有待办事项，我们将使用`return`并使用`res.status`设置状态为`404`，并调用`send`来启动响应。现在，如果这个if语句不运行，这意味着待办事项实际上已被删除。在这种情况下，我们希望用`200`回应，让用户知道一切都进行得很顺利，我们将把`todo`参数返回，`res.send`，传入`todo`。这个待办事项挑战的唯一剩下的事情就是调用`catch`。我们将调用catch，以便处理任何潜在的错误。我们要做的就是使用`res.status`进行响应，将其设置为`400`，然后调用`send`，不带参数发送一个空响应：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With this in place, we are now good to go. We have everything set up just like
    we wanted to, which means we can remove the comments from down below, and you'll
    notice that the method we have down below looks really similar to the one we have
    up above, and this is going to be the case for a lot of our routes that manage
    an individual Todo item. We're always going to want to get that ID, we're always
    going to want to validate that the ObjectID is indeed a real ObjectID, and inside
    of our success and error cases, similar things are also going to happen. We want
    to make sure that a doc was actually deleted. If it wasn't we'll send back that
    `404`, and with this in place we can now verify that this route works.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以开始了。我们已经按照我们想要的方式设置了一切，这意味着我们可以从下面删除注释，你会注意到我们下面的方法看起来与上面的方法非常相似，对于我们管理单个待办事项的许多路由来说，情况都是如此。我们总是想要获取那个ID，我们总是想要验证ObjectID确实是一个真正的ObjectID，在我们的成功和错误情况中，也会发生类似的事情。我们要确保文档实际上已被删除。如果没有，我们将发送`404`，有了这个，我们现在可以验证这个路由是否有效。
- en: 'Now we can save the file and start up the server in the Terminal. I''ll use
    the `clear` command to clear the Terminal output and then we can run the following
    command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存文件并在终端中启动服务器。我将使用`clear`命令清除终端输出，然后我们可以运行以下命令：
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once the server is up, we can move into Postman and start firing off a couple
    of requests. First up, I''m going to create a few Todos. I''ll send this `POST
    /todos` off, and then I''ll change the `text` property and send it off again.
    I''ll change the body text to `Some other todo item`, sending that off, and now
    we should have two todos. If I go to `GET /todos` and fetch them, we get our two
    `todos`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，我们就可以进入Postman并开始发送一些请求。首先，我要创建一些待办事项。我将发送`POST /todos`，然后我会更改`text`属性并再次发送。我将把正文文本更改为`Some
    other todo item`，发送后，现在我们应该有两个待办事项。如果我去`GET /todos`并获取它们，我们会得到我们的两个`todos`：
- en: '![](img/f5298901-ec78-45b8-acad-fd01a11d843c.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5298901-ec78-45b8-acad-fd01a11d843c.png)'
- en: 'Now, I am going to need one of these IDs; this is going to be the todo that
    we delete, so what I will do is copy this to the clipboard, then we can go ahead
    and create our new route. This new route is going to use the `delete` method so
    we''re going to switch from GET to DELETE, then we can go ahead and provide the
    URL using the environment variable URL that we created in the last section. The
    route is `/todos/id`. I''m going to paste the ID in there:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我需要其中一个ID；这将是我们要删除的待办事项，所以我要做的是将其复制到剪贴板，然后我们可以继续创建我们的新路由。这个新路由将使用`delete`方法，所以我们将从GET切换到DELETE，然后我们可以提供URL，使用我们在上一节中创建的环境变量URL。路由是`/todos/id`。我将把ID粘贴进去：
- en: '![](img/f0366096-9c4b-482c-ba9a-40ec8db5264c.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0366096-9c4b-482c-ba9a-40ec8db5264c.png)'
- en: 'Now I can go ahead and run the request. When we run it, we get a status code
    of 200 OK; everything went well, and we have the document that we deleted:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以继续运行请求。当我们运行它时，我们得到了一个状态码200 OK；一切都进行得很顺利，我们有了我们删除的文档：
- en: '![](img/f80c4479-640d-4a61-9f98-62d9c48fad2c.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f80c4479-640d-4a61-9f98-62d9c48fad2c.png)'
- en: 'If I go back to `GET /todos` and rerun it, now we only have one document; the
    item that we passed in as the ID to delete did indeed get deleted. I''m going
    to save this request to our collection so we can fire it off without having to
    manually enter all of that information. Let''s save as `DELETE`, followed by the
    route `/todos/:id`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我回到`GET /todos`并重新运行它，现在我们只有一个文档；我们传递给删除的项目确实已被删除。我将保存这个请求到我们的集合中，这样我们就可以不必手动输入所有这些信息就可以发送它。让我们保存为`DELETE`，后面跟着路由`/todos/:id`：
- en: '![](img/b99a8f13-fdf1-4a17-a2e5-375f4f3b8a3b.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b99a8f13-fdf1-4a17-a2e5-375f4f3b8a3b.png)'
- en: We are going to save this to an existing collection, the Todo App collection.
    Now we have a `DELETE /todos/:id` route sitting right in Collections, we can always
    go ahead and access it whenever we need to. Now, from here, we're going to go
    ahead and fire the request again, this is going to try and delete a Todo whose
    ID is valid but doesn't match one in the collection, and we get `404` back. Now
    if I make this ID invalid by deleting a bunch of characters and I send that off,
    we also get a `404` status code because the ID is invalid, which is fantastic.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存到一个现有的集合，Todo App集合。现在我们有一个`DELETE /todos/:id`路由坐在集合中，我们随时可以访问它。现在，从这里，我们将继续发送请求，这将尝试删除一个ID有效但与集合中的ID不匹配的Todo，我们得到`404`。现在，如果我通过删除一堆字符使此ID无效，并发送它，我们也会得到`404`状态码，因为ID无效，这太棒了。
- en: With this in place, we can now make a commit. Over inside of the Terminal, I'm
    going to shut the server down, run `git status`, and you'll see we have two files.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以进行提交。在终端内，我将关闭服务器，运行`git status`，您将看到我们有两个文件。
- en: 'We have a new file, the Mongoose playground file, and we have our modified
    `server` file. I''m going to use `git add .` to add all of those to the next commit,
    and we''ll use `git commit` with the `-m` flag to make the commit, `Add DELETE/todos/:id
    route`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个新文件，Mongoose playground文件，以及我们修改过的`server`文件。我将使用`git add .`将所有这些添加到下一个提交中，并使用`git
    commit`与`-m`标志进行提交，`Add DELETE/todos/:id route`：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'I''m going to make the commit and push it up to GitHub. We can also go ahead
    and deploy our application using the following command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提交并将其推送到GitHub。我们还可以使用以下命令部署我们的应用程序：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now we'll be able to delete our Todos inside of the Heroku application. With
    this in place, we are now done. In the next section we're going to write some
    test cases for the route we just set up.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将能够在Heroku应用程序中删除我们的Todos。有了这个，我们现在完成了。在下一节中，我们将为我们刚刚设置的路由编写一些测试用例。
- en: Testing DELETE /todos/:id
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试DELETE /todos/:id
- en: In this section, you're going to write some test cases that verify our `delete`
    route works as expected. Now, before we get into that, what we're going to do
    is make one quick change to the delete route to make it match our other routes.
    Our other routes return an object and on that object, the response body, we have
    a `todo` property, and we did the same thing for the `todos` call. On the response
    body we have the `todos` property and that stores the array. For the delete request,
    we never did that.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将编写一些测试用例，以验证我们的`delete`路由是否按预期工作。现在，在我们开始之前，我们要做的是对删除路由进行一些快速更改，以使其与我们的其他路由匹配。我们的其他路由返回一个对象，在该对象上，响应主体上有一个`todo`属性，我们对`todos`调用也是如此。在响应主体上，我们有`todos`属性，它存储数组。对于删除请求，我们从未这样做过。
- en: 'What I''m going to do is send back an object as the response body, where the
    `todo` property equals the `todo` that got deleted, although we''ll just use that
    ES6 syntax to send that back:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我要做的是将一个对象作为响应主体发送回来，其中`todo`属性等于已删除的`todo`，尽管我们将使用ES6语法将其发送回来：
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With this in place, we can now go ahead and write some test cases that verify
    the `delete` route works as expected, and this is going to happen at the very
    bottom of our `server.test` file. I'm going to create a new `describe` block for
    the `DELETE /todos/:id` route. We'll provide our arrow function and we can go
    ahead and call it three times.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以继续编写一些测试用例，以验证`delete`路由是否按预期工作，这将发生在我们的`server.test`文件的最底部。我将为`DELETE
    /todos/:id`路由创建一个新的`describe`块。我们将提供箭头函数，并可以继续调用它三次。
- en: Test case 1 - should remove a todo
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例1 - 应删除一个todo
- en: 'The first test case, `it(''should remove a todo'')`, this is going to be test
    case number one; it''s going to verify that when we pass in an ID that does exist
    inside of the Todos collection, the item gets removed:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试用例，`it('应删除一个todo')`，这将是第一个测试用例；它将验证当我们传入一个在Todos集合中存在的ID时，该项目将被删除：
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Test case 2 - should return 404 if todo not found
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例2 - 如果未找到todo，则应返回404
- en: 'Next up, `it(''should return 404 if todo not found'')`. If we try to delete
    the Todo but nothing was actually deleted, we''re going to send a `404` status
    code back so the user knows that the call probably didn''t work as expected. Yes,
    the call didn''t necessarily fail, but you never deleted the item you wanted to
    delete, so we are going to consider that a failure, and that''s what we did when
    we sent the `404` status code back:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`it('如果未找到todo，则应返回404')`。如果我们尝试删除Todo，但实际上没有删除任何东西，我们将发送`404`状态码，以便用户知道调用可能不像预期那样工作。是的，调用并没有真正失败，但您从未删除您想要删除的项目，因此我们将认为这是一个失败，这就是我们在发送`404`状态码时所做的：
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Test case 3 - should return 404 if object id is invalid
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例3 - 如果对象id无效，则应返回404
- en: 'The last test we''re going to write is `it(''should return 404 if object id
    is invalid'')`. This test is going to verify that when we have an invalid ObjectID,
    we do get a `404` status code back which is the expected response status code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要写的最后一个测试是`it('如果对象id无效，则应返回404')`。这个测试将验证当我们有一个无效的ObjectID时，我们确实会得到一个`404`状态码，这是预期的响应状态码：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, these two tests we''ll fill out a little bit later; we''re going to go
    ahead and focus on the first one because this is where we''re going to need to
    do a few complex things. Not only are we going to need to send off the request,
    but after the request comes back, we''re going to want to assert some things about
    it, and we''re going to want to query the database, making sure the Todo was actually
    removed from the `Todos` collection. The first thing I''m going to do is figure
    out which Todo I want to delete. We have two options up above. I''m going to go
    ahead and delete the second Todo item, though that choice is irrelevant; you could
    easily just do this with the first one. Down below, we''ll create a `hexId` variable,
    like we did for our previous test case. We''re going to set that equal to the
    second item from the `todos` array, then we''re going to go ahead and grab its
    `_id` property, calling the `toHexString` method:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这两个测试我们稍后会填写一些内容；我们将继续专注于第一个，因为这是我们需要做一些复杂事情的地方。我们不仅需要发送请求，而且在请求返回后，我们还希望断言一些关于它的事情，并且我们还希望查询数据库，确保待办事项实际上已从`Todos`集合中删除。我要做的第一件事是弄清楚我想要删除哪个待办事项。我们在上面有两个选项。我将继续删除第二个待办事项，尽管这个选择是无关紧要的；你也可以轻松地用第一个来做这个。在下面，我们将创建一个`hexId`变量，就像我们为前一个测试用例所做的那样。我们将把它设置为`todos`数组中的第二个项目，然后我们将继续并获取它的`_id`属性，调用`toHexString`方法：
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that we have the `hexId` for the second Todo item, we can start worrying
    about making the request. I''m going to call `request`, passing in the `app` we
    want to make the request to, then we can call `delete`, which is going to trigger
    a delete HTTP request. The following URL is going to have some variables injected
    into it, so I will use template strings: it''s `/todos/` followed by the ID. I''m
    going to inject the `hexId` variable. Now that we have our `delete` method all
    set up, we can move on and start making our expectations. We''re going to `expect`
    that we get a `200` status code back; we should get a `200` status code because
    `hexId` is going to exist in the database. Next up, we can assert that the data
    comes back as the response body. I''m going to make a custom `expect` call, passing
    in our function, where we have the response argument sent in, and all we''re going
    to do is assert that the ID is the ID right in the `hexId` variable. We''re going
    to `expect` that the `res.body` property has a `todo` prop where the `_id` property
    equals the `hexId`, `toBe(hexId)`. If this is the case then we can verify the
    call pretty much worked as expected:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了第二个待办事项的`hexId`，我们可以开始担心如何发出请求。我将调用`request`，传入我们要发出请求的`app`，然后我们可以调用`delete`，这将触发一个删除HTTP请求。以下URL将注入一些变量，所以我将使用模板字符串：它是`/todos/`后跟ID。我将注入`hexId`变量。现在我们已经设置好了我们的`delete`方法，我们可以继续并开始制定我们的期望。我们期望得到一个`200`状态码；我们应该得到一个`200`状态码，因为`hexId`将存在于数据库中。接下来，我们可以断言数据作为响应体返回。我将进行自定义的`expect`调用，传入我们的函数，在这里我们有响应参数发送进来，我们要做的就是断言ID就是`hexId`变量中的ID。我们期望`res.body`属性有一个`todo`属性，其中`_id`属性等于`hexId`，`toBe(hexId)`。如果是这种情况，那么我们可以验证调用基本上按预期工作了：
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The last thing we need to do is query the database and make sure the item was
    actually removed. I'm going to call `end`, passing in a callback, so we can do
    a few asynchronous things before we wrap up the test case, and if you remember
    it gets called with an error and the response. If there is an error we're going
    to need to handle that because otherwise there's no need to query the database,
    `if (err)`. We're going to `return` to prevent the function execution, `done`,
    passing in that error so the error gets rendered by Mocha. Now we can go ahead
    and make the query, and this is actually going to be your challenge for this section.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是查询数据库，确保该项目实际上已被删除。我将调用`end`，传入一个回调，这样我们可以在结束测试用例之前做一些异步的事情，如果你记得的话，它会被调用并传入一个错误和响应。如果有错误，我们需要处理它，否则就没有必要查询数据库，`if
    (err)`。我们将`return`以防止函数执行，`done`，传入该错误，以便Mocha渲染错误。现在我们可以继续并进行查询，这实际上将是本节的挑战。
- en: What I want you to do is query database using `findById`. You're going to try
    to find the Todo item that has the ID stored in the `hexId` variable. When you
    try to find that ID it should fail, and you should get nothing back. You're going
    to create that `Todo` variable in your `then` call and make sure it does not exist.
    You can make sure something doesn't exist using the `toNotExist` assertion. That
    would look something like this, we `expect(null).toNotExist()`. Although, instead
    of `null`, you'll pass in the `Todo` argument which is going to be in your success
    handler. Now, this usually would contain the Todo item, but since we've just deleted
    it, it should not exist; this is going to get all of that done. Now, if there
    is an error you're going to do the exact same thing we did in our test case for
    `POST /todos`. We simply add a `catch` clause, passing the error through to `done`.
    Now that you know what to do, it's your job to get it done. What I'd like you
    to do is fill this out, fill out the query, make sure to handle the errors, make
    sure to call `done`, then you can go ahead and run the test suite, verifying that
    this test case passes. The last two test cases are going to fail, so for the moment
    I'm just going to comment them out; they're going to fail because we have a `done`
    argument specified, but we never called it so the test will timeout after two
    seconds.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你使用`findById`查询数据库。你将尝试查找具有存储在`hexId`变量中的ID的Todo项目。当你尝试查找该ID时，它应该失败，并且你应该得到空值。你将在`then`调用中创建`Todo`变量，并确保它不存在。你可以使用`toNotExist`断言来确保某些内容不存在。这将看起来像这样，我们`expect(null).toNotExist()`。尽管，你将传入`Todo`参数，它将在你的成功处理程序中。现在，这通常会包含Todo项目，但由于我们刚刚删除它，它不应该存在；这将完成所有这些。现在，如果有错误，你将执行与我们为`POST
    /todos`测试用例中所做的完全相同的操作。我们只需添加一个`catch`子句，将错误传递给`done`。现在你知道该怎么做了，你的工作就是完成它。我希望你填写这个，填写查询，确保处理错误，确保调用`done`，然后你可以继续运行测试套件，验证这个测试用例是否通过。最后两个测试用例将失败，所以目前我只是将它们注释掉；它们将失败，因为我们指定了一个`done`参数，但我们从未调用它，所以测试将在两秒后超时。
- en: 'The first thing to do is call `Todo.findById`, passing in that `hexId`. This
    is the item that should have gotten deleted. Now we can call then, passing in
    our callback, it is going to get called with the doc, the `todo` variable, and
    all we''re going to do is verify that it does not exist. We just deleted it, so
    `findById` should return null for the doc. We''re going to `expect` that the `todo`
    variable does not exist using the `toNotExist` method available on that expect
    library. Now, we do need to call `done` to wrap up the test case. From here, we
    can go ahead and call `catch`. I''m going to call `catch`, grabbing that error
    argument and passing it through to `done`. There''s no need to provide curly braces
    here; we just have one statement so we can use the shortcut, which is available
    in ES6 for error functions. With our actual query in place, we can remove the
    comments that outlined what was supposed to happen and we can run the test case:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是调用`Todo.findById`，传入`hexId`。这是应该已经被删除的项目。现在我们可以调用`then`，传入我们的回调，它将使用文档、`todo`变量调用，我们要做的就是验证它不存在。我们刚刚删除了它，所以`findById`应该返回文档的空值。我们将使用`toNotExist`方法来`expect`
    `todo`变量不存在，该方法可用于`expect`库。现在，我们需要调用`done`来完成测试用例。从这里开始，我们可以继续调用`catch`。我将调用`catch`，获取错误参数并将其传递给`done`。这里不需要提供花括号；我们只有一个语句，所以我们可以使用ES6中可用的错误函数的快捷方式。有了我们实际的查询，我们可以删除概述应该发生的内容的注释，并运行测试用例：
- en: '[PRE55]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Over inside of the Terminal we can now run the test suite to verify that everything
    we set up worked as expected. Over inside of Terminal, I''m going to run the following
    command to start up our test suite with Nodemon:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端内，我们现在可以运行测试套件，以验证我们设置的一切是否按预期工作。在终端内，我将运行以下命令启动我们的测试套件与Nodemon：
- en: '[PRE56]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And when it runs we see that we have our one test under the `DELETE` describe
    block and it is passing; it should remove a todo passed without any errors:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行时，我们看到我们在`DELETE`描述块下有一个测试，并且它通过了；它应该在没有任何错误的情况下删除一个传递的todo：
- en: '![](img/864712bc-7e32-458c-a2ec-c3b6d5f2440b.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/864712bc-7e32-458c-a2ec-c3b6d5f2440b.png)'
- en: 'Now that we have our one test case in place we can fill out the two other ones.
    These test cases are going to be basically identical to the test cases we have
    for the `GET /todos/:id` route. There''s no shame in copying and pasting code
    when you:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个测试用例，我们可以填写另外两个。这些测试用例基本上与我们为`GET /todos/:id`路线编写的测试用例相同。当你：
- en: Know exactly what the code does; we know what it does because we wrote it
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确切地知道代码的作用；我们知道它的作用，因为我们编写了它
- en: Actually do need it—we can't reuse it, we need to tweak it just a little bit,
    so it does make sense to copy
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上确实需要它-我们无法重用它，我们需要稍微调整它，因此复制它是有道理的。
- en: Test case 4 - should return 404 if todo not found
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例4 - 如果未找到todo，则应返回404
- en: 'I''m going to copy the `should return 404` test case for the `should return
    404 if todo not found` test, and we''re going to paste that into the exact same
    test for the `delete` route, and all we have to do is change `.get` to `.delete`,
    and save the file. This is going to rerun the test suite, and now we have two
    tests under delete; they are both passing:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我将复制`应返回404`测试用例，用于`如果未找到todo，则应返回404`测试，然后我们将粘贴到`delete`路线的完全相同的测试中，我们只需要将`.get`更改为`.delete`，然后保存文件。这将重新运行测试套件，现在我们在删除下有两个测试；它们都通过了：
- en: '![](img/f4e108cd-f803-4800-b1de-e99de825b274.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4e108cd-f803-4800-b1de-e99de825b274.png)'
- en: 'You can see our last test still fails, so we can go ahead and do the same thing.
    I''m going to copy the code from `should return 404 for non-object ids`, which
    verifies that non-ObjectIDs cause a `404` status code. I''m going to paste it
    in the last test case, changing the `.get` method call to `.delete`. If I save
    the file it''s going to rerun the test suite and this time around all 9 test cases
    are passing:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们上一个测试仍然失败，所以我们可以继续做同样的事情。我将从`should return 404 for non-object ids`中复制代码，该代码验证非ObjectID会导致`404`状态码。我将把它粘贴到最后一个测试用例中，将`.get`方法调用更改为`.delete`。如果我保存文件，它将重新运行测试套件，这一次所有9个测试用例都通过了：
- en: '![](img/ccac1fd1-7cd8-4665-b5b6-c5a64d0195c4.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccac1fd1-7cd8-4665-b5b6-c5a64d0195c4.png)'
- en: With this in place, we now have `DELETE /todos` tested. Let's go ahead and wrap
    this one up by making a commit over inside of the Terminal.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在已经测试了`DELETE /todos`。让我们通过在终端内进行提交来结束这一切。
- en: 'I''m going to run `git status` to see what changes I have going on. We made
    one small change to the `server` file and we added our tests to the `server.test`
    file. I can use `git commit` with the `-am` flag to make it commit, and a good
    message for this one would be `Test the DELETE /todos/:id route`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我要运行`git status`来查看我所做的更改。我们对`server`文件进行了一些小改动，并将我们的测试添加到`server.test`文件中。我可以使用`git
    commit`和`-am`标志进行提交，对于这个提交，一个好的消息将是`测试DELETE /todos/:id路由`：
- en: '[PRE57]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: I'm going to take that commit and push it up to GitHub, and there's no need
    to deploy to Heroku since we haven't created anything visually different. We did
    tweak the `server` code just a little bit, but we'll worry about that a little
    bit later. For now, everything is good; we can move on to the next section where
    you are going to create the final route for managing Todos. This is going to be
    a route that lets you update a Todo.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提交并推送到GitHub，因为我们还没有创建任何视觉上的不同，所以没有必要部署到Heroku。我们只是稍微调整了`server`代码，但这是稍后的事情。现在，一切都很好；我们可以继续下一节，您将在其中创建管理Todos的最终路由。这将是一个允许您更新Todo的路由。
- en: Updating a Resource - PATCH /todos/:id
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新资源 - PATCH /todos/:id
- en: The `delete` route is now set up and tested, so it's time to start on the final
    route for managing our Todo resources. This is going to be the route that lets
    you update a Todo item whether you want to change the text to something else or
    whether you want to toggle it as completed. Now this is going to be the most complex
    route we write; everything so far has been relatively straightforward. We're going
    to need to do a few extra things to get this updating route to work as expected.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`路由现在已经设置并测试完成，所以现在是时候开始管理我们的Todo资源的最终路由了。这将是一个路由，让您更新一个Todo项目，无论您是想将文本更改为其他内容，还是想将其标记为已完成。现在，这将是我们编写的最复杂的路由；到目前为止，一切都相对简单。我们需要做一些额外的工作才能使这个更新路由按预期工作。'
- en: The first thing I want to do before we go ahead and create the route down below
    is install that Lodash library we used in one of the previous sections for this
    course.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建下面的路由之前，我想要做的第一件事就是安装我们在本课程的前几节中使用过的Lodash库。
- en: Installing Lodash library
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Lodash库
- en: 'If you remember, Lodash provides a few really great utility functions and we''ll
    be taking advantage of a couple of those inside of our update route. Right in
    the Terminal, I''m going to use `npm i` with the `--save` flag to install it;
    the module name itself is called `lodash`, and we''ll be using the most recent
    version `@4.15.0`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，Lodash提供了一些非常好的实用函数，我们将利用其中一些函数来完成我们的更新路由。在终端中，我将使用`npm i`和`--save`标志来安装它；模块名称本身叫做`lodash`，我们将使用最新版本`@4.15.0`：
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, once this is installed, we can `require` it up top and then we can go
    ahead and add our route. At the very top of the `server.js` file we can make a
    constant; we''ll use underscore as the name for the variable that stores the Lodash
    library, then we''ll go ahead and `require` it, `require(''lodash'')`. Now, I''ve
    used regular variables instead of constants for my other imports, so I can go
    ahead and switch these variables to constants as well:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦这个安装完成，我们可以在顶部`require`它，然后我们可以继续添加我们的路由。在`server.js`文件的顶部，我们可以创建一个常量；我们将使用下划线作为存储Lodash库的变量的名称，然后我们将继续`require`它，`require('lodash')`。现在，我已经使用常量而不是常规变量来进行其他导入，所以我也可以将这些变量切换为常量：
- en: '[PRE59]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that we have this in place we are ready to move to the bottom of the file
    and start adding the new route. This route is going to use the HTTP `patch` method;
    `patch` is what you use when you want to update a resource. Now remember, none
    of this is really set in stone. I could have a `delete` route that creates new
    Todos and I could have a `post` route that deletes todos, but these are just the
    general guidelines and best practices for API development. We're going to set
    up a `patch` method route by calling `app.patch`. This is what is going to allow
    us to update Todo items. Now, the URL is going to be the exact same URL as it
    has been when we're managing an individual Todo item, `/todos/:id`. Then we can
    set up our callback with our request and response arguments. Inside of the callback,
    one of the first things that we're going to need to do is grab that id just like
    we do for all our other routes. I'm going to make a variable called `id` and set
    it equal to `req.params.id`. Now, on the next line we're going to go ahead and
    create a variable called `body` and this is the reason I loaded in Lodash. The
    body, the request body, that's where the updates are going to be stored. If I
    want to set a Todos text to something else, I would make a `patch` request. I
    would set the `text` property equal to whatever I wanted the Todo text to be.
    The problem here is that someone can send any property along; they could send
    along properties that aren't on the Todo items or they could send along properties
    we don't want them to update, for example, `completedAt`. The `completedAt` property
    is going to be a property that gets updated, but it's not going to be updated
    by the user, it's going to be updated by us when the user updates the completed
    property. `completedAt` is going to be generated by the program, which means we
    do not want a user to be able to update it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪，可以转到文件底部并开始添加新的路由。这个路由将使用HTTP的`patch`方法；`patch`是在想要更新资源时使用的方法。现在记住，这一切都不是铁板钉钉的。我可以有一个`delete`路由来创建新的Todos，我也可以有一个`post`路由来删除todos，但这只是API开发的一般准则和最佳实践。我们将通过调用`app.patch`来设置一个`patch`方法路由。这将允许我们更新Todo项目。现在，URL将与我们管理单个Todo项目时的URL完全相同，`/todos/:id`。然后我们可以设置我们的回调函数，带有我们的请求和响应参数。在回调函数中，我们首先需要做的事情之一是像我们为所有其他路由做的那样获取那个id。我将创建一个名为`id`的变量，并将其设置为`req.params.id`。现在，在下一行，我们将创建一个名为`body`的变量，这就是我加载Lodash的原因。请求体，更新将存储在这里。如果我想将Todos的文本设置为其他内容，我将发出一个`patch`请求。我将把`text`属性设置为我想要的Todo文本。问题在于，有人可以发送任何属性；他们可以发送不在Todo项目上的属性，或者他们可以发送我们不希望他们更新的属性，例如`completedAt`。`completedAt`属性将被更新，但不会被用户更新，当用户更新完成的属性时，它将由我们更新。`completedAt`将由程序生成，这意味着我们不希望用户能够更新它。
- en: 'In order to pull off just the properties we want users to update, we''re going
    to be using the `pick` method, `_.pick`. The `pick` method is fantastic; it takes
    an object, we''re going to pass in `req.body`, then it takes an array of properties
    that you want to pull off, if they exist. For example, if the `text` property
    exists, we want to pull that off of `req.body`, adding it to body. This is something
    that users should be able to update, and we''ll do the same thing for completed.
    These are the only two properties a user is going to be able to update; we don''t
    need users updating IDs or adding any other properties that aren''t specified
    in the Mongoose model:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了只获取我们希望用户更新的属性，我们将使用`pick`方法，`_.pick`。`pick`方法非常棒；它接受一个对象，我们将传入`req.body`，然后它接受一个你想要提取的属性数组，如果它们存在的话。例如，如果`text`属性存在，我们希望从`req.body`中提取出来，添加到body中。这是用户应该能够更新的内容，我们将对completed做同样的处理。这是用户唯一能够更新的两个属性；我们不需要用户更新ID或添加任何在Mongoose模型中未指定的其他属性。
- en: '[PRE60]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that we have this in place, we can get started down the usual path, kicking
    things off by validating our ID. There''s no need to rewrite the code since we''ve
    written it before and we know what it does; we can simply copy it from `app.delete`
    block and paste it in `app.patch`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪，可以开始按照通常的路径进行，首先通过验证我们的ID来启动。没有必要重写代码，因为我们以前已经写过了，我们知道它的作用；我们可以简单地从`app.delete`块中复制并粘贴到`app.patch`中。
- en: '[PRE61]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: And now we can go ahead and move onto the slightly complex part of `patch`,
    which is going to be checking the `completed` value and using that value to set
    `completedAt`. If a user is setting a Todos `completed` property to `true`, we
    want to set `completedAt` to a timestamp. If they're setting it to `false`, we
    want to clear that timestamp because the Todo won't be completed. We're going
    to add an `if` statement checking if the `completed` property is a Boolean, and
    it's on `body`. We're going to use the `_.isBoolean` utility method to get that
    done. We want to check if `body.completed` is a Boolean; if it is a Boolean and
    that Boolean is true, `body.completed`, then we're going to go ahead and run some
    code. This code is going to run if it's a Boolean and it's `true`, otherwise we're
    going to run some code if it's not a Boolean or it's not `true`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行`patch`的稍微复杂的部分，这将检查`completed`值并使用该值来设置`completedAt`。如果用户将Todos的`completed`属性设置为`true`，我们希望将`completedAt`设置为时间戳。如果他们将其设置为`false`，我们希望清除该时间戳，因为Todo将不会被完成。我们将添加一个`if`语句来检查`completed`属性是否为布尔值，并且它在`body`中。我们将使用`_.isBoolean`实用方法来完成这个任务。我们要检查`body.completed`是否为布尔值；如果它是布尔值并且该布尔值为true，`body.completed`，那么我们将继续运行一些代码。如果它是布尔值并且为true，那么这段代码将运行，否则如果它不是布尔值或者不是true，我们将运行一些代码。
- en: 'If it is a Boolean and it is `true`, we''re going to set `body.completedAt`.
    Everything we set on body is eventually going to be updated in the model. Now,
    we don''t want the user to update everything, so we''ve picked off certain ones
    from the `req.body`, but we can make some modifications of our own. We''re going
    to set `body.completedAt` equal to the current timestamp. We''re going to create
    a new date, which we''ve done before, but instead of calling `toString`, which
    is the method we used in the previous section, we''ll be using a method called
    `getTime`. The `getTime` method returns a JavaScript timestamp; this is the number
    of milliseconds since midnight on January 1st of the year 1970\. It''s just a
    regular number. Values greater than zero are milliseconds from that moment forward,
    and values less than zero are in the past, so if I had a number of -1000, it would
    be 1000 milliseconds before that Unix epoch, which is the name for that date,
    that January 1st at midnight on 1970:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个布尔值并且是`true`，我们将设置`body.completedAt`。我们在body上设置的一切最终都将在模型中更新。现在，我们不希望用户更新所有内容，所以我们从`req.body`中挑选了一些内容，但我们可以进行一些修改。我们将`body.completedAt`设置为当前时间戳。我们将创建一个新的日期，这是我们以前做过的，但是不再调用`toString`，这是我们在前一节中使用的方法，而是使用一个叫做`getTime`的方法。`getTime`方法返回一个JavaScript时间戳；这是自1970年1月1日午夜以来的毫秒数。它只是一个普通的数字。大于零的值是从那一刻开始的毫秒数，小于零的值是过去的，所以如果我有一个-1000的数字，那就是在Unix纪元之前1000毫秒，这是那个日期的名称，1970年1月1日午夜：
- en: '[PRE62]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we have that in place we can go ahead and fill out the `else` clause.
    Inside of the `else` clause, if it is not a Boolean or it''s not `true`, we''re
    going to go ahead and set `body.completed = false` and we''re also going to clear
    `completedAt`. `body.completedAt` is going to get set equal to `null`. When you
    want to remove a value from the database you can simply set it to null:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了这个，我们可以继续填写`else`子句。在`else`子句中，如果它不是布尔值或者不是`true`，我们将继续设置`body.completed
    = false`，我们还将清除`completedAt`。`body.completedAt`将被设置为`null`。当你想要从数据库中删除一个值时，你可以简单地将它设置为null：
- en: '[PRE63]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we''re going to go ahead and follow a usual pattern: we''re going to be
    making a query to actually update the database. The query that we''re going to
    be making is going to be really similar to the one we made in our `mongodb-update`
    file. Inside of `mongodb-update` we used a method called `findOneAndUpdate`. It
    took a query, the update object, and a set of options. We''re going to be using
    a method called `findByIdAndUpdate` which takes a really similar set of arguments.
    Right here in `server`, we will call `Todo.findByIdAndUpdate`. The first argument
    for `findByIdAndUpdate` is going to be `id` itself; since we''re using a `findById`
    method, we can simply pass in `id` as opposed to passing in a query. Now we can
    go ahead and set the values on our object, which is the second argument. Remember,
    you can''t just set key value pairs—you have to use those MongoDB operators, things
    like increment or, in our case, `$set`. Now, `$set`, as we explored, takes a set
    of key value pairs, and these are going to get set. In this case, we''ve already
    generated the object, as shown in the following code:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将按照通常的模式进行：我们将查询以实际更新数据库。我们将要进行的查询与我们在`mongodb-update`文件中进行的查询非常相似。在`mongodb-update`中，我们使用了一个叫做`findOneAndUpdate`的方法。它接受一个查询、更新对象和一组选项。我们将使用一个叫做`findByIdAndUpdate`的方法，它接受一个非常相似的参数集。在`server`中，我们将调用`Todo.findByIdAndUpdate`。`findByIdAndUpdate`的第一个参数将是`id`本身；因为我们使用了`findById`方法，我们可以简单地传入`id`，而不是传入一个查询。现在我们可以设置我们对象的值，这是第二个参数。记住，你不能只设置键值对——你必须使用那些MongoDB操作符，比如增量或者在我们的情况下`$set`。现在，`$set`，正如我们所探讨的，接受一组键值对，这些将被设置。在这种情况下，我们已经生成了对象，如下面的代码所示：
- en: '[PRE64]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We just happen to generate it in the `app.patch` block and it happens to be
    called `body`. So I will set the `$set` operator equal to the `body` variable.
    Now we can go ahead and move onto the final options. These are just some options
    that let you tweak how the function works. If you remember, in `mongodb-update`,
    we set `returnOriginal` to `false`; this meant we got the new object back, the
    updated one. We''re going to use a similar option with a different name; it''s
    called `new`. It has similar functionality, it just has a different name because
    that''s what the Mongoose developers chose. With a query in place though, we are
    done, and we can tack on a `then` callback and a `catch` callback, and add our
    success and error code. If things go well, we''re going to get our `todo` doc
    back, and if things don''t go well we are going to get an error argument, and
    we can go ahead and send back a `400` status code, `res.status(400).send()`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚好在`app.patch`块中生成了它，它刚好被称为`body`。所以我将`$set`操作符设置为`body`变量。现在我们可以继续进行最终的选项。这些只是一些选项，让你调整函数的工作方式。如果你记得，在`mongodb-update`中，我们将`returnOriginal`设置为`false`；这意味着我们得到了新的对象，更新后的对象。我们将使用一个类似的选项，但名字不同；它叫做`new`。它有类似的功能，只是名字不同，因为这是Mongoose开发者选择的名字。有了查询，我们就完成了，我们可以添加一个`then`回调和一个`catch`回调，并添加我们的成功和错误代码。如果一切顺利，我们将得到我们的`todo`文档，如果一切不顺利，我们将得到一个错误参数，我们可以继续发送一个`400`状态码，`res.status(400).send()`：
- en: '[PRE65]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we are going to need to check if the `todo` object exists. If it doesn''t,
    if there is no `todo`, then we''re going to go ahead and respond with a `404`
    status code, `return res.status(404).send()`. If `todo` does exist, that means
    we were able to find it and it was updated, so we can simply send it back, `res.send`,
    and we''re going to send it back as the `todo` property where todo equals the
    `todo` variable using the ES6 syntax:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要检查`todo`对象是否存在。如果不存在，如果没有`todo`，那么我们将继续以`404`状态码做出响应，`return res.status(404).send()`。如果`todo`存在，那意味着我们能够找到它并对其进行更新，所以我们可以简单地将其发送回去，`res.send`，我们将其作为`todo`属性发送回去，其中todo等于`todo`变量，使用ES6语法：
- en: '[PRE66]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With this in place, we are now done. It's not too bad but it was a little more
    complex than any of the routes we've done before, so I wanted to walk you through
    it step by step. Let's take just a quick moment to recap what we did and why we
    did it. First up, the first unusual thing we did is we created the `body` variable;
    this has a subset of the things the user passed to us. We didn't want the user
    to be able to update anything they chose. Next up, we updated the `completedAt`
    property based off of the completed property, and finally we made our call to
    `findByIdAndUpdate`. With these three steps we were able to successfully update
    our Todos when we make the patch call.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了。这并不太糟糕，但比以前的任何路线都要复杂一些，所以我想一步一步地带你走过来。让我们花一点时间来回顾一下我们做了什么以及为什么这样做。首先，我们做的第一件不寻常的事情是创建了`body`变量；这包含了用户传递给我们的一部分内容。我们不希望用户能够更新他们选择的任何内容。接下来，我们根据`completed`属性更新了`completedAt`属性，最后我们调用了`findByIdAndUpdate`。通过这三个步骤，我们成功地更新了我们的Todos。
- en: Testing Todos for the patch call
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试patch调用的Todos
- en: 'Now, to test this out I''m going to save the `server` file and start up the
    server over in the Terminal. I''ll use `clear` to clear the Terminal output and
    we can run `npm start` to start up the app. The app is up and running on port
    3000, so over inside of Postman we can make some requests to see exactly how this
    works. I''m going to switch to the Todo App Local environment and make a `GET
    /todos` request so we can get a real ID for one of our Todo items, and you can
    see we have some old data from our tests right here:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试这个，我将保存`server`文件并在终端中启动服务器。我将使用`clear`清除终端输出，然后运行`npm start`启动应用程序。应用程序正在3000端口上运行，所以在Postman中，我们可以进行一些请求来看看这是如何工作的。我将切换到Todo
    App Local环境，并进行一个`GET /todos`请求，以便我们可以获得一个真正的ID用于我们的Todo项目，你可以看到我们的测试中有一些旧数据：
- en: '![](img/715574f4-2129-456e-9d21-eea992ab313b.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/715574f4-2129-456e-9d21-eea992ab313b.png)'
- en: 'I''m going to grab this second one with a `text` property equal to `Second
    test todo`, then I''m going to go ahead and create a new request, changing the
    method from GET to PATCH. We''re going to provide our URL, it''ll be `{{url}}`,
    then we''ll have `/todos/` the ID we copied:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我将拿到第二个，它的`text`属性等于`Second test todo`，然后我将继续创建一个新的请求，将方法从GET更改为PATCH。我们将提供我们的URL，它将是`{{url}}`，然后我们将有`/todos/`我们复制的ID：
- en: '![](img/999eead1-07b4-49df-83b6-12e3e30939a7.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/999eead1-07b4-49df-83b6-12e3e30939a7.png)'
- en: 'Now remember, the PATCH request is all about updating the data so we have to
    provide that data as the request body. I''m going to go to Body | raw | JSON in
    order to do just that. Let''s go ahead and make some updates to the Todo. I''m
    going to set `"completed": true` and if you look in the GET /todos tab you can
    see that second Todo has a `completed` value of `false` so it should change and
    the `completedAt` property should get added. With the request set up I''m going
    go ahead and send it off:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '现在记住，PATCH请求完全是关于更新数据，所以我们必须提供数据作为请求体。我将转到Body | raw | JSON来做到这一点。让我们继续对Todo进行一些更新。我将设置`"completed":
    true`，如果你在GET /todos选项卡中查看，你会发现第二个Todo的`completed`值为`false`，所以它应该改变，`completedAt`属性应该被添加。请求设置好后，我将发送它：'
- en: '![](img/7f5eb1b0-0f13-4616-863e-cdbb88ba73d7.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f5eb1b0-0f13-4616-863e-cdbb88ba73d7.png)'
- en: 'We get our `todo`, completed is set to `true`, and `completedAt` is set to
    the timestamp. Now I can also go ahead and tweak this, changing `"completed":
    true` to `"completed": false` to send off the request; this now sets `"completed":
    false` and clears `completedAt`. Lastly, we could go ahead and do something like
    setting the `text` property. I''m going to set it back to `true` and add a second
    property, `text`, setting that equal to `Updates from postman`. I can fire off
    this request and down below we get our Todo, looking just as we had expected it
    to look:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '我们得到了我们的`todo`，`completed`设置为`true`，`completedAt`设置为时间戳。现在我也可以继续调整这个，将`"completed":
    true`改为`"completed": false`发送请求；这会将`"completed": false`设置并清除`completedAt`。最后，我们可以继续做一些像设置`text`属性的事情。我将把它设置回`true`，并添加第二个属性，`text`，将其设置为`Updates
    from postman`。我可以发送这个请求，然后在下面我们得到了我们的Todo，看起来正如我们所期望的那样：'
- en: '![](img/972a6f06-70fb-4c95-839d-1909ef468be8.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/972a6f06-70fb-4c95-839d-1909ef468be8.png)'
- en: We have our `text` update; we also have our `completed` update and the timestamp
    showing up in the `completedAt` field. With this in place, we now have the ability
    to get, delete, update, and create Todo items—those are the four main CRUD actions.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的`text`更新；我们还有我们的`completed`更新和时间戳显示在`completedAt`字段中。有了这个，我们现在有了获取、删除、更新和创建Todo项目的能力——这些是四个主要的CRUD操作。
- en: 'The next thing we''re going to do is write some tests that verify `patch` works
    as expected, so we can automatically run them and catch any regressions in our
    code. For now, that is it, we are going to go ahead and, in the Terminal, make
    a commit and push our changes. We''ll push them up to Heroku and test that out
    as well. `git status` reveals that we have just those two changed files which
    means we can use `git commit` with the `-am` flag to make the commit. A good message
    for this one is, `Add PATCH /todos/:id`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是编写一些测试来验证`patch`是否按预期工作，这样我们就可以自动运行它们并捕捉到我们代码中的任何回归。目前就是这样，我们将继续在终端中提交并推送我们的更改。我们将把它们推送到Heroku并测试一下。`git
    status`显示我们只有这两个更改的文件，这意味着我们可以使用`git commit`和`-am`标志来进行提交。对于这个，一个好的消息是，`Add PATCH
    /todos/:id`：
- en: '[PRE67]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'I''m going to make the commit and push it up to GitHub, and once it''s on GitHub
    we can push it up to Heroku using the following command:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我要提交并将其推送到GitHub，一旦它在GitHub上，我们就可以使用以下命令将其推送到Heroku：
- en: '[PRE68]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Remember, the master branch is the only branch Heroku has access to; we're not
    going to be using branching in this book, but in case you already know branching
    and you're running into any issues, you do need to push to the Heroku master branch
    to have your app redeploy. Like I said, that is not an issue if you're using all
    the commands as I use them.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，主分支是Heroku唯一可以访问的分支；我们不会在本书中使用分支，但是如果你已经了解分支并且遇到任何问题，你需要推送到Heroku主分支以重新部署你的应用。就像我说的，如果你使用的命令和我一样，这不是一个问题。
- en: 'Now that the app is deployed, we can go ahead and open it up; we''re going
    to open it up by making requests inside of Postman. I''m going to switch to the
    Todo App Heroku environment, then I''m going to go ahead and inside of GET /todos,
    fire off the request:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用已经部署，我们可以打开它；我们将通过在Postman中发出请求来打开它。我将切换到Todo App Heroku环境，然后我将继续在GET /todos中发出请求：
- en: '![](img/06715bc4-eb01-4126-b230-eb5d6ce81706.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06715bc4-eb01-4126-b230-eb5d6ce81706.png)'
- en: 'These are all the Todos available on Heroku. I''m going to grab this first
    one. I''m going to go over to the PATCH request, swap out the ID, and keep the
    same body. I''m going to set `"completed": true` and `"text": "Updates from postman"`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '这些是在Heroku上可用的所有待办事项。我将拿到第一个。我将转到PATCH请求，替换ID，并保持相同的主体。我将设置`"completed": true`和`"text":
    "来自Postman的更新"`：'
- en: '![](img/20e9d378-b340-4006-aa2a-a540ce8bb0c1.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20e9d378-b340-4006-aa2a-a540ce8bb0c1.png)'
- en: 'When we send that off, we get back the updated Todo. `completed` looks great,
    `completedAt` looks great, and `text` looks great as well. Now I''m going to go
    ahead and add this to my collections; the patch call is going to come in handy
    down the line, so I will click Save As, giving it the name we''ve used for all
    of ours, the HTTP method followed by the URL. I am going to save it to our existing
    collection, Todo App:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送请求后，我们会收到更新后的待办事项。`completed`看起来很好，`completedAt`也很好，`text`也很好。现在我将把它添加到我的集合中；在以后，patch调用会派上用场，所以我会点击保存为，给它一个我们用于所有的名称，即HTTP方法后跟URL。我将保存到我们现有的集合Todo
    App中：
- en: '![](img/79c288af-be83-462b-b760-5893ecc28dab.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79c288af-be83-462b-b760-5893ecc28dab.png)'
- en: With this in place, we are done; we have our `patch` route working and it's
    time to move onto the next section where we will test this code.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了这一步；我们的`patch`路由已经可以工作了，现在是时候进入下一部分，我们将在那里测试这段代码。
- en: Testing PATCH /todos/:id
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试PATCH /todos/:id
- en: In this section, we, well I guess more appropriately you, are going to be writing
    two test cases that verify `patch` works as expected. We're going to take one
    Todo that's not completed and make it complete, and we'll take a second one that
    is complete and make it incomplete.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们，或者更恰当地说是你，将编写两个测试用例来验证`patch`是否按预期工作。我们将拿一个未完成的待办事项并将其标记为完成，然后拿一个已完成的待办事项并将其标记为未完成。
- en: 'Now, in order to do that, we are going to need to tweak the seed data we have
    in our `server.test` file. The seed data right in `server.test` file is two Todo
    items; neither of them have the `completed` property specified, which means it''s
    going to default to `false`. For the second item, we''re going to go ahead and
    set it. We''re going to set `completed: true` and we''re also going to set `completedAt`
    equal to whatever value we want. You can choose any number at all. I''m going
    to go ahead and use `333`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '为了做到这一点，我们需要调整`server.test`文件中的种子数据。`server.test`文件中的种子数据是两个待办事项；它们都没有指定`completed`属性，这意味着它将默认为`false`。对于第二个项目，我们将继续设置它。我们将设置`completed:
    true`，并且我们还将设置`completedAt`等于我们想要的任何值。你可以选择任何数字。我将继续使用`333`：'
- en: '[PRE69]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we have two Todos that are going to let us toggle both ways. To get started
    down below I will help you create the describe an `It` block so we''re on the
    same page, but you will be responsible for filling out the actual test cases.
    This section is basically going to be a challenge because we''ve done a lot of
    this stuff before. First up, the `describe` block. We''re going to `describe`
    this group of tests; we''ll use the method followed by the URL to do just that,
    then we can go ahead and add our function, and then we can define our two test
    cases:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个待办事项，可以让我们双向切换。在下面开始之前，我将帮助你创建一个描述和一个`It`块，以便我们在同一个页面上，但你将负责填写实际的测试用例。这一部分基本上是一个挑战，因为我们之前已经做了很多这样的事情。首先是`describe`块。我们将`describe`这组测试；我们将使用方法后跟URL来做到这一点，然后我们可以继续添加我们的函数，然后定义我们的两个测试用例：
- en: '[PRE70]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The first test is going to take our first Todo and set its `text` equal to something
    else, and we'll change `completed` from `false` to `true`, `it('should update
    the todo')`. We can provide our function with the `done` argument, and I'll leave
    some comments inside in just a moment to give you an idea as to how I'd like you
    to accomplish this. The second test is going to be for toggling that second Todo
    where the `completed` value is already equal to `true`, and then `it('should clear
    completedAt when todo is not completed')`. This test case is going to make sure
    that when we go ahead and remove the `completed` status, setting it equal to `false`,
    `completedAt` gets cleared. Now, for the first test case what you're going to
    do is grab the ID of the first item, `grab id of first item`, then you're going
    to make our patch request; you're going to provide the proper URL with the ID
    inside of it, and you're going to use send to send some data along as the request
    body. For this one I want you to update text, set it equal to whatever you like,
    and you're going to `set completed equal` to `true`. Now, once you send that off
    you'll be ready to make your assertions and you're going to make one assertion
    using the basic system, assert that you get a `200` status code back, and you're
    going to make one custom assertion. The custom assertion is going to verify that
    the response body has a `text` property equal to the text you sent in, `text is
    changed`. You're going to verify that `completed` is `true`, and you're also going
    to verify that `completedAt` is a number, and you can use the `.toBeA` method
    available inside of `expect` to get that done. Now, for the second test we're
    going to do something similar but we're just going to go in the other direction;
    we're going to `grab id of second todo item`, you're going to update the `text`
    to something different, and you're going to set `completed` to `false`. Then you
    can make your assertions. Once again, we will be expecting `200` for this one
    and we will be expecting that the response body now represents those changes,
    that the text is changed to whatever you happen to pick. I also want you to check
    that `completed` is now `false` and to check that `completedAt` is `null`, and
    you can use the `.toNotExist` method available on expect to make that assertion.
    This is what you need to do to complete the test suite. Once you're done I want
    you to run `npm test` and make sure both test cases pass.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试将获取我们的第一个待办事项，并将其`text`设置为其他内容，我们将把`completed`从`false`更改为`true`，`it('should
    update the todo')`。我们可以为我们的函数提供`done`参数，并且我将在接下来的一刻内留下一些注释，让你知道我希望你如何完成这个任务。第二个测试将用于切换第二个待办事项，其中`completed`值已经等于`true`，然后`it('should
    clear completedAt when todo is not completed')`。这个测试用例将确保当我们去除`completed`状态，将其设置为`false`时，`completedAt`被清除。现在，对于第一个测试用例，你要做的是获取第一项的ID，`获取第一项的ID`，然后你将发出我们的patch请求；你将提供带有ID的正确URL，并且你将使用send发送一些数据作为请求体。对于这个，我希望你更新文本，将其设置为你喜欢的任何内容，然后你将`设置completed为true`。现在，一旦你发送出去，你将准备好进行断言，你将使用基本系统进行一次断言，断言你得到了一个`200`状态码，并且你将进行一次自定义断言。自定义断言将验证响应体是否具有一个`text`属性等于你发送的文本，`文本已更改`。你将验证`completed`是否为`true`，并且你还将验证`completedAt`是否为一个数字，你可以使用`expect`中可用的`.toBeA`方法来完成。现在，对于第二个测试，我们将做类似的事情，但我们只是朝着另一个方向前进；我们将`获取第二个待办事项的ID`，你将将`text`更新为不同的内容，并且你将将`completed`设置为`false`。然后你可以进行断言。再次，我们将期望这个得到`200`，并且我们将期望响应体现在这些更改，文本被更改为你选择的任何内容。我还希望你检查`completed`现在是否为`false`，并且检查`completedAt`是否为`null`，你可以使用`expect`上可用的`.toNotExist`方法进行断言。这就是你需要完成测试套件的内容。完成后，我希望你运行`npm
    test`，确保两个测试用例都通过。
- en: Test 1 -  To complete the incomplete todo
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试1 - 完成未完成的待办事项
- en: 'Let''s fill out the first test case first and I''ll kick things off by grabbing
    the proper ID. Let''s make a variable called `hexId`, setting it equal to the
    first todos, `_id` property, and we''re going to call `toHexString` to get the
    string back we can pass in to the URL. Next up, I''m going to go ahead and create
    some dummy text; this will be the new updated text. Let''s make a variable called
    `text` and set it equal to whatever you like. `This should be the new text`. Now
    we can go ahead and actually make our request using `request` to our express application.
    We will be using the `patch` method; hopefully you were able to figure that out
    on your own, and if you weren''t maybe you used the documentation for super test
    since I did not explicitly tell you how to make that `patch` call. Next up, we
    are going to be using a template string as our URL, `/todos/`, then we''re going
    to inject `hexId`. Now, before we can make our assertions we do need to send some
    data along as well, so I''ll call `send`, passing in the data. This is going to
    be the things we want to change. For this test we did want to set `completed`
    equal to `true`. I''m going to set `completed: true`, and we do want to update
    the text, so I''ll set `text` equal to the `text` variable up above, and I can
    always leave off this part using ES6:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们先填写第一个测试用例，我将首先获取正确的ID。让我们创建一个名为`hexId`的变量，将其设置为第一个待办事项的`_id`属性，并调用`toHexString`以获取我们可以传递到URL的字符串。接下来，我将创建一些虚拟文本；这将是新的更新文本。让我们创建一个名为`text`的变量，并将其设置为你喜欢的任何内容。`这应该是新文本`。现在我们可以使用`request`实际发出请求到我们的express应用程序。我们将使用`patch`方法；希望你能自己找出，如果你找不到，也许你使用了super
    test的文档，因为我没有明确告诉你如何进行`patch`调用。接下来，我们将使用模板字符串作为我们的URL，`/todos/`，然后我们将注入`hexId`。现在，在我们进行断言之前，我们确实需要发送一些数据，所以我将调用`send`，传递数据。这将是我们想要更改的内容。对于这个测试，我们确实希望将`completed`设置为`true`。我将设置`completed:
    true`，我们确实希望更新文本，所以我将`text`设置为上面的`text`变量，并且我可以使用ES6略去这部分：'
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now that we have send in place, we can start making our assertions. The first
    one's easy, we're just expecting 200\. I'm going to `expect(200)` to be the return
    status code, and before we add our custom assertion, we can call `end`, passing
    in `done`. Now, the last thing we need to do is make those assertions about the
    data coming back. I'm going to call `expect`, passing in a function; this function
    as we know by now gets called with the response and we can make our custom assertions.
    We're going to make an assertion about `text`, `completed`, and `completedAt`.
    First up, `text`. We use `expect(res.body.todo.text).toBe(text)`, the variable
    we defined up above. If this is equal to the data that came back, then we're good
    to go.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了发送，我们可以开始做出断言。第一个很容易，我们只是期望 200。我将期望 `200` 作为返回状态码，并在添加自定义断言之前，我们可以调用
    `end`，传入 `done`。现在，我们需要做的最后一件事就是对返回的数据进行断言。我将调用 `expect`，传入一个函数；这个函数我们现在知道会被响应调用，我们可以进行自定义断言。我们将对
    `text`、`completed` 和 `completedAt` 进行断言。首先是 `text`。我们使用 `expect(res.body.todo.text).toBe(text)`，这是我们上面定义的变量。如果这等于返回的数据，那么我们就可以继续了。
- en: 'Next up, let''s make some assertions about that `completed` property. We''re
    going to use `expect(res.body.todo.completed)` and check that it''s true using
    `.toBe(true)`. We set `completed` to `true` so it should have changed from `false`
    to `true`. Now the last assertion we''re going to make inside of our custom expect
    call is going to be an assertion about `completedAt`, making sure it''s a number.
    We''re going to use `expect(res.body.todo.completedAt)` equals a number using
    `.toBeA`, inside of quotes the `number` type:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们对 `completed` 属性进行一些断言。我们将使用 `expect(res.body.todo.completed)` 并检查它是否为
    `true`，使用 `.toBe(true)`。我们将 `completed` 设置为 `true`，所以它应该从 `false` 变为 `true`。现在，在我们自定义的
    `expect` 调用中，我们要做的最后一个断言是关于 `completedAt`，确保它是一个数字。我们将使用 `expect(res.body.todo.completedAt)`
    等于一个数字，使用 `.toBeA`，在引号中是 `number` 类型。
- en: '[PRE72]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With this in place, our first test is now complete. We can go ahead and remove
    those comments and actually verify it''s working by running it over in the Terminal.
    Our second test is going to fail; that''s fine, as long as the first one passes,
    we''re good to continue on. I''m going to run `npm test`, and this is going to
    fire off the test suite. We can see our first `PATCH` test succeeds; this is the
    one we just filled out, and our second one fails. We''re getting a timeout after
    two seconds, which is expected because we never call `done`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的第一个测试已经完成。我们可以继续删除那些注释，并通过在终端中运行来验证它是否工作。我们的第二个测试将失败；没关系，只要第一个通过，我们就可以继续。我将运行
    `npm test`，这将触发测试套件。我们可以看到我们的第一个 `PATCH` 测试成功了；这是我们刚刚填写的，而我们的第二个测试失败了。两秒后我们得到了一个超时，这是预期的，因为我们从未调用
    `done`。
- en: '![](img/d8a67b4f-4cca-4143-8b7e-c196c25b3555.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8a67b4f-4cca-4143-8b7e-c196c25b3555.png)'
- en: Now that the first one is in place though, we can go ahead and fill out the
    second one. Now, the code for these two tests is going to be really, really similar.
    Now, since we just wrote the code and we know exactly what it does, we can copy
    and paste it. I'm not a fan of copying and pasting code I don't understand, but
    I am a fan of being efficient. Since I know what that code does, I can paste it
    right in second test case, and now we can go ahead and make some changes.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第一个已经设置好了，我们可以继续填写第二个。这两个测试的代码将非常相似。既然我们刚刚编写了代码并且知道它的作用，我们可以复制粘贴。我不喜欢复制粘贴我不理解的代码，但我喜欢高效。既然我知道那段代码的作用，我可以直接粘贴到第二个测试用例中，然后我们可以继续进行一些更改。
- en: Test 2 - to make complete todo incomplete
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试2 - 使完成的待办事项变为未完成
- en: 'Instead of grabbing the `hexId` variable or the first Todo item, we want to
    grab the `hexId` variable for the second Todo item, and then the next thing we
    need to do is update the data we''re sending. We don''t want to set `completed`
    equal to `true`; we already did that manually up above. This one we''re trying
    to set to `false`. We are also going to update the `text` so we can leave that
    in place. I''m going to go ahead and tweak the text value a little bit, adding
    a couple of exclamation marks on the end. Next up, the assertions. We''re still
    expecting a `200` to be the status code that comes back. That part''s great, and
    we are still expecting the `text` to equal `text`. For completed, though, we''re
    expecting that to be `false` and we''re not expecting `completedAt` to be a number;
    it was a number originally but after this update it should have been cleared since
    the Todo is no longer completed. We can use `toNotExist` to assert that `completedAt`
    doesn''t exist:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想获取 `hexId` 变量或第一个待办事项，而是想获取第二个待办事项的 `hexId` 变量，然后我们需要更新发送的数据。我们不想将 `completed`
    设置为 `true`；我们已经在上面手动完成了。这次我们要设置为 `false`。我们还要更新 `text`，所以我们可以保留它。我将继续调整文本值，末尾添加一些感叹号。接下来是断言。我们仍然期望返回
    `200` 作为状态码。这部分很好，我们仍然期望 `text` 等于 `text`。不过，对于 `completed`，我们期望它是 `false`，并且我们不期望
    `completedAt` 是一个数字；它原来是一个数字，但在此更新后应该已经清除，因为待办事项不再完成。我们可以使用 `toNotExist` 来断言 `completedAt`
    不存在。
- en: '[PRE73]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With this in place, our test case is done. We can now delete those comments,
    save the file, and rerun things from the Terminal. I''m going to rerun the test
    suite:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试用例已经完成。我们现在可以删除那些注释，保存文件，并从终端重新运行。我将重新运行测试套件。
- en: We get both of our `PATCH` tests passing. Now, as you've probably noticed, for
    `patch` we didn't write those test cases for invalid ObjectIDs or ObjectIDs not
    found; you could add those but we've done them so many times so far, I don't see
    that as a necessary exercise. These two test cases, though, they do validate that
    our `patch` method is working as expected, especially when it comes to the slightly
    more complex logic that `patch` requires to get everything done. With this in
    place though, we are done testing our last route.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让两个`PATCH`测试都通过了。现在，你可能已经注意到，对于`patch`，我们没有编写那些无效的ObjectIDs或者找不到ObjectIDs的测试用例；你可以添加这些，但我们迄今为止已经做了很多次，我不认为这是必要的练习。不过，这两个测试用例确实验证了我们的`patch`方法是否按预期工作，特别是当涉及到`patch`需要完成的稍微复杂的逻辑时。有了这个设置，我们已经完成了对最后一个路由的测试。
- en: 'We can go ahead and make a commit and move on to the final section of the chapter.
    Over in the Terminal I''m going to run `git status`. We''ll see we have one modified
    file, `server.test` file, which looks great. We can use `git commit` with the
    `-am` flag to make the commit, `Add tests for PATCH /todos/:id`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续进行提交，并进入本章的最后一节。在终端中，我将运行`git status`。我们会看到有一个修改过的文件，`server.test`文件，看起来很好。我们可以使用`git
    commit`和`-am`标志进行提交，`Add tests for PATCH /todos/:id`：
- en: '[PRE74]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: I'm going to go ahead and make that commit, then I'll take a moment to push
    it up to GitHub and with that in place we are done. In the next section, which
    is the last one for the chapter, you will learn how to use a separate test database
    locally, so you're not always wiping your data in the development database as
    you run your tests.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我将进行提交，然后我会花一点时间将其推送到GitHub上，有了这个设置，我们就完成了。在下一节，也是本章的最后一节，你将学习如何在本地使用一个单独的测试数据库，这样你在运行测试时就不会总是清空开发数据库中的数据。
- en: Creating a Test database
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试数据库
- en: Now that all of our Todo routes are set up and tested, in this final section
    we're going to be exploring how to create a separate Test database for our application.
    That means when we run the test suite we're not going to be deleting all of the
    data inside of our `TodoApp` database. We will have a separate database alongside
    of `Test` and `TodoApp`, used for the testing DB.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的待办事项路由都已设置并测试完成，在这最后一部分，我们将探讨如何为我们的应用程序创建一个单独的测试数据库。这意味着当我们运行测试套件时，我们不会删除`TodoApp`数据库中的所有数据。我们将在`Test`和`TodoApp`旁边有一个单独的数据库，用于测试DB。
- en: 'Now, in order to set all that up we need a way to differentiate between running
    our app locally and running our test suite locally, and that''s exactly where
    we''re going to start. This whole issue stems from the fact that in our `mongoose.js`
    file we either use the `MONGODB_URI` environment variable or we use the URL string.
    This string is used for both testing and for development, and when I say testing
    I mean when we run our `test` script, and when I say development I mean when we
    run our app locally so we can use it inside of tools like Postman. What we really
    need is a way to set environment variables locally as well, so we always use the
    `MONGODB_URI` variable and we never have a default string like the one we have
    in the `mongoose.js` file. Now, in order to get that done we''re going to look
    at an environment variable that''s actually pretty special: it''s `process.env.NODE_ENV`
    and you don''t have to write this code. I''m going to be deleting it in just a
    moment. This `NODE_ENV` environment variable was made popular by the Express library
    but it now has been adopted by pretty much any Node-hosting company. For example,
    Heroku sets this value equal to the string `production` by default. That means
    that we''re going to have three environments total. We already have a `production`
    environment. This is what we call our app on Heroku; we''re going to have a `development`
    environment when we run our app locally, and we''ll have a `test` environment
    when we run our app through Mocha. This means we''ll be able to set up a different
    value for `MONGODB_URI` for all three of those, creating a separate test database.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置好这一切，我们需要一种区分在本地运行应用程序和在本地运行测试套件的方法，这正是我们将要开始的地方。这个问题的根源在于在我们的`mongoose.js`文件中，我们要么使用`MONGODB_URI`环境变量，要么使用URL字符串。这个字符串用于测试和开发，当我说测试时，我指的是当我们运行我们的`test`脚本时，当我说开发时，我指的是当我们在本地运行我们的应用程序，这样我们就可以在Postman等工具中使用它。我们真正需要的是一种在本地设置环境变量的方法，这样我们总是使用`MONGODB_URI`变量，而不是像在`mongoose.js`文件中那样有一个默认字符串。为了做到这一点，我们将看一下一个非常特殊的环境变量：`process.env.NODE_ENV`，你不必编写这段代码。我马上就要删除它。这个`NODE_ENV`环境变量是由Express库广泛使用的，但现在几乎所有的Node托管公司都已经采用了它。例如，Heroku默认将这个值设置为字符串`production`。这意味着我们将总共有三个环境。我们已经有了一个`production`环境。这是我们在Heroku上称呼我们的应用程序的方式；当我们在本地运行应用程序时，我们将有一个`development`环境，当我们通过Mocha运行应用程序时，我们将有一个`test`环境。这意味着我们将能够为这三个环境分别设置`MONGODB_URI`的不同值，从而创建一个单独的测试数据库。
- en: 'To kick things off we''re going to add some code in the `server.js` file up
    at the very top. We''ll be moving this code out of `server.js` a little bit later,
    but for now we''re going to tack it at the top. Let''s make a variable called
    `env` and we''re going to set it equal to `process.env.NODE_ENV`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始添加一些代码到`server.js`文件的顶部。稍后我们会将这些代码移出`server.js`，但现在我们先把它放在顶部。让我们创建一个名为`env`的变量，并将其设置为`process.env.NODE_ENV`：
- en: '[PRE75]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, this variable currently is only set on Heroku; we don''t have this environment
    variable set locally. Environment variables in general are used for much more
    than just Node. Your machine has probably close to two dozen environment variables,
    telling the computer all sorts of things: where certain programs exist, what versions
    of libraries you want to use, that sort of stuff. The `NODE_ENV` variable, however,
    is something that we''re going to need to configure inside of our `package.json`
    file for our development and test environments. Then, just down below, we''ll
    be able to add some `if else` statements to configure our app depending on the
    environment. If we''re in development we''ll use one database, if we''re in test
    we''ll use a different one. Now to kick things off inside of `package.json` we
    are going to need to tweak the `test` script, setting the `NODE_ENV` environment
    variable. You can set environment variables by chaining together multiple commands.
    The code we''re about to write is going to have a fallback for Windows as well,
    so you can write the exact same line if you''re on macOS, Linux, or Windows. This
    is going to work everywhere, including Heroku. The goal here is to just set `NODE_ENV`
    equal to `test` before we run the test suite. In order to do that we''re going
    to start by using the `export` command. The `export` command is available in macOS
    and Linux. This is the way to get it done, type this even if you''re in Windows
    because when you deploy to Heroku you are going to be using Linux. We''re going
    to export `NODE_ENV`, setting it equal to `test`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个变量目前只在Heroku上设置；我们在本地没有设置这个环境变量。环境变量通常用于远不止Node。你的计算机可能有接近两打的环境变量，告诉计算机各种各样的东西：某些程序的存在位置，你想使用的库的版本，这类的东西。然而，`NODE_ENV`变量是我们需要在`package.json`文件中为开发和测试环境进行配置的东西。然后，在下面，我们将能够添加一些`if
    else`语句来根据环境配置我们的应用。如果我们在开发中，我们将使用一个数据库，如果我们在测试中，我们将使用另一个。现在，为了在`package.json`中启动这些东西，我们需要调整`test`脚本，设置`NODE_ENV`环境变量。你可以通过链接多个命令来设置环境变量。我们即将编写的代码也将为Windows提供备用方案，因此，无论你是在macOS、Linux还是Windows上，你都可以编写完全相同的代码。这将在包括Heroku在内的所有地方都能够工作。这里的目标只是在运行测试套件之前将`NODE_ENV`设置为`test`。为了做到这一点，我们将首先使用`export`命令。`export`命令在macOS和Linux中可用。这是完成的方式，即使你在Windows上也要输入这个，因为当你部署到Heroku时，你将使用Linux。我们将导出`NODE_ENV`，将其设置为`test`：
- en: '[PRE76]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, if you''re on Windows, the `export` command is going to fail; `export`
    is going to trigger an error, something along the lines of export command not
    found. For Windows users, we''re going to add this `||` block where we will call
    `SET`. `SET` is the same as export only it''s the Windows version of the command.
    Right after it, we''ll be providing the exact same argument, `NODE_ENV=test`.
    After the final test we''re going to add two ampersands to chain these commands
    together:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在Windows上，`export`命令将失败；`export`将触发一个错误，类似于export命令未找到。对于Windows用户，我们将添加这个`||`块，我们将调用`SET`。`SET`与export相同，只是它是该命令的Windows版本。在最后的测试之后，我们将添加两个和号来链接这些命令：
- en: '[PRE77]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: So, let's go ahead and break down exactly what's going to happen. If you're
    on Linux, you're going to run the `export` command; the `SET` command is never
    going to run because the first one did. Then we're going to chain on a second
    command, running `mocha`. If you're on Windows, the `export` command is going
    to fail, which means you will run the second command; either way you get the `NODE_ENV`
    variable set, then finally you'll chain on a call to `mocha`. With this in place,
    we now have a way to set our `NODE_ENV` variable right inside a `package.json`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们来详细分析一下将会发生什么。如果你在Linux上，你将运行`export`命令；`SET`命令永远不会运行，因为第一个已经运行了。然后我们将链接第二个命令，运行`mocha`。如果你在Windows上，`export`命令将失败，这意味着你将运行第二个命令；无论如何，你都会设置`NODE_ENV`变量，然后最后你将链接一个调用`mocha`的命令。有了这个设置，我们现在有了一种在`package.json`中直接设置`NODE_ENV`变量的方法。
- en: 'This is a quick cross-OS update; as you can see here, we have a modified version
    of that `test` script:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速的跨操作系统更新；正如你在这里所看到的，我们有一个修改过的`test`脚本的版本：
- en: '`"test": "export NODE_ENV=test || SET \"NODE_ENV=test\" && mocha server/**/*.test.js"`'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`"test": "export NODE_ENV=test || SET \"NODE_ENV=test\" && mocha server/**/*.test.js"`'
- en: 'The original test script had a problem on the Windows side of things: it would
    set the environment variable equal to the string test with a space at the end,
    as opposed to just the string `test`. In order to properly set the `env` variable
    to just `test`, and not `test`, we''re going to be wrapping the entire set argument
    inside of quotes, and we''re escaping those quotes since we use quotes inside
    of our JSON file. This command is going to work on Linux, macOS, and Windows.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的测试脚本在Windows端有一个问题：它会将环境变量设置为带有末尾空格的字符串test，而不是只有字符串`test`。为了正确地将`env`变量设置为`test`，而不是`test`，我们将把整个设置参数放在引号内，并且我们会转义这些引号，因为我们在JSON文件中使用引号。这个命令将在Linux、macOS和Windows上都能够工作。
- en: 'Now I''m actually not going to add a `start` script for `scripts`. The `start`
    script, which is for the development environment, will just be the default. We''ll
    have it set to production on Heroku, we''ll have it set to `test` inside of our
    `test` script, and in the case of this script we''ll just default it inside of
    `server.js` because we tend to run the file without actually going through the
    `start` script. Right in the `server.js` file, I''ll set a default to `development`.
    If we''re on production, `NODE_ENV` is going to be set, if we''re on test, `development`
    is going to be set, and if we''re on development, `NODE_ENV` won''t be set and
    `development` will be used, which means we are ready to add some `if` statements.
    `if(env)` is `development` we want to do something. The thing we want to do is
    set up the MongoDB URL. `else if (env)` is the `test` environment. In that case
    we also want to set up a custom database URL:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我实际上不会为`scripts`添加一个`start`脚本。`start`脚本，用于开发环境，将只是默认值。我们将在Heroku上将其设置为生产环境，我们将在`test`脚本中将其设置为`test`，在这种情况下，我们将在`server.js`中将其设置为默认值，因为我们倾向于在不经过`start`脚本的情况下运行文件。在`server.js`文件中，我将默认设置为`development`。如果我们处于生产环境，`NODE_ENV`将被设置，如果我们处于测试环境，`development`将被设置，如果我们处于开发环境，`NODE_ENV`将不会被设置，将使用`development`，这意味着我们准备添加一些`if`语句。如果`env`是`development`，我们要做一些事情。我们要做的事情是设置MongoDB
    URL。否则，如果`env`是`test`环境。在这种情况下，我们还要设置一个自定义数据库URL：
- en: '[PRE78]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now we can go ahead and actually set up our environment variables. We have
    two environment variables being used throughout the app, both of which are set
    on Heroku, so there''s no reason to worry about that environment, the production
    environment. We have our `PORT` environment variable, and we have our `MONGODB_URI`
    variable. Over inside of `server.js`, if we are in the development environment,
    we''re going to go ahead and set `process.env.PORT=3000`. This means that we can
    actually remove the default from the `port` variable; there''s no need to have
    a default because `PORT` is already going to be set. It''ll be set on Heroku for
    production, it''ll be set locally for `development`, and right in the `else if`
    block we''ll set it for our final environment, the test environment, setting it
    equal to `3000`. Inside `mongoose.js`, what we''re going to do is set a `MONGODB_URI`
    environment variable for `development` and `test`, which is the exact same name
    for the variable we have on production. I''m going to remove our default, taking
    the string and cutting it out so it''s in my clipboard, then I can remove all
    the excess code for setting that default, and what we''re left with is just a
    reference to the environment variable:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续设置我们的环境变量。我们在整个应用程序中使用了两个环境变量，这两个环境变量都在Heroku上设置，因此不必担心生产环境。我们有我们的`PORT`环境变量，和我们的`MONGODB_URI`变量。在`server.js`中，如果我们处于开发环境，我们将继续设置`process.env.PORT=3000`。这意味着我们实际上可以删除`port`变量的默认值；没有必要设置默认值，因为`PORT`已经被设置。它将在Heroku上设置为生产环境，它将在本地设置为`development`，然后在`else
    if`块中，我们将为我们的最终环境，测试环境，设置为`3000`。在`mongoose.js`中，我们将为`development`和`test`设置一个`MONGODB_URI`环境变量，这与我们在生产环境上使用的变量名称完全相同。我将删除我们的默认值，将字符串剪切出来，这样它就在我的剪贴板中，然后我可以删除所有设置默认值的多余代码，我们剩下的就是对环境变量的引用：
- en: '[PRE79]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Over inside of `server.js` we can now set that environment variable for both
    environments, `process.env.MONGODB_URI`, and we're going to set that equal to
    the string I just copied, `mongodb://localhost:27017/TodoApp`. We are using the
    `TodoApp` database.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`server.js`内部，我们可以为两个环境设置环境变量`process.env.MONGODB_URI`，我们将把它设置为我刚刚复制的字符串`mongodb://localhost:27017/TodoApp`。我们正在使用`TodoApp`数据库。
- en: 'Now, down below in the `else if` block, we can set `process.env.MONGODB_URI`
    equal to the string we just copied, but instead of setting it equal to the `TodoApp`
    database, we''re going to set it equal to the `TodoAppTest` database:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`else if`块下面，我们可以将`process.env.MONGODB_URI`设置为我们刚刚复制的字符串，但是不再将其设置为`TodoApp`数据库，而是将其设置为`TodoAppTest`数据库：
- en: '[PRE80]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'When we run our application in test mode, we''re going to be using a completely
    different database, so it''s not going to wipe the database that we''re using
    for development. To test that everything is working as expected, right below the
    `env` variable all I''m going to do is log out of the environment variable using
    `console.log`. I''m going to print the string `env` with a couple of asterisks
    so it''s easy to spot in the Terminal output, and then I''ll go ahead and pass
    the `env` variable in as the second argument:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以测试模式运行我们的应用程序时，我们将使用一个完全不同的数据库，因此不会清除我们用于开发的数据库。为了测试一切是否按预期工作，我将在`env`变量下方使用`console.log`记录环境变量。我将打印带有几个星号的字符串`env`，以便在终端输出中易于识别，然后我将把`env`变量作为第二个参数传递：
- en: '[PRE81]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we can go ahead and test that everything is working as expected. Over inside
    of the Terminal I''m going to start up our app using the following command:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续测试一切是否按预期工作。在终端中，我将使用以下命令启动我们的应用程序：
- en: '[PRE82]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We get an `env` equal to `development`, which is exactly what we''d expect:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个等于`development`的`env`，这正是我们所期望的：
- en: '![](img/fe710e73-932e-4ea9-aca3-636d2fc4611b.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe710e73-932e-4ea9-aca3-636d2fc4611b.png)'
- en: 'And now we can play around with it in Postman. Over inside of Postman I''m
    going to switch to my Local environment, Todo App Local, then I''m going to go
    ahead and fetch all of my Todos, and you can see we have some leftover test data:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在Postman中进行测试。在Postman中，我将切换到我的本地环境，Todo App Local，然后我将获取所有的Todos，您可以看到我们有一些剩下的测试数据：
- en: '![](img/f3e33401-f769-49cf-898a-1fb19f534bf1.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3e33401-f769-49cf-898a-1fb19f534bf1.png)'
- en: 'What I want to do is go ahead and tweak this first one so it''s different.
    Then we''ll run our tests and make sure that the tweaked Todo still shows up,
    because when we run the tests we shouldn''t be accessing the same database, so
    none of this data should get changed. I''m going to copy the id for the first
    item, moving it into my `PATCH` call. I''m updating the `text` property and the
    `completed` property, so that''s good, I don''t need to change that. I''m going
    to go ahead and swap out the ID in the URL, send off the call, and now we have
    the updated Todo with the `text` property of `Updates from postman`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要做的是继续调整第一个，使其不同。然后我们将运行我们的测试，并确保调整后的待办事项仍然显示出来，因为当我们运行测试时，我们不应该访问相同的数据库，因此这些数据都不应该被更改。我将复制第一项的ID，将其移入我的`PATCH`调用。我正在更新`text`属性和`completed`属性，所以很好，我不需要更改。我将继续更改URL中的ID，发送调用，现在我们有了`text`属性为`Updates
    from postman`的更新后的待办事项：
- en: '![](img/ab22622f-3104-4e9e-a66b-a3a230dc96a3.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab22622f-3104-4e9e-a66b-a3a230dc96a3.png)'
- en: 'Next up, I''m going to go into the Terminal, shut down node server, and run
    our tests using `npm test`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将进入终端，关闭节点服务器，并使用`npm test`运行我们的测试：
- en: '![](img/3e10b405-a47c-4baa-b08b-b5702220d4a3.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e10b405-a47c-4baa-b08b-b5702220d4a3.png)'
- en: We get our `env` variable set to `test`, then it runs through the test suite;
    all of our tests pass, which is fantastic. The true test as to whether or not
    what we set up works is if we start up the server again and we try to fetch our
    data from the `development` database.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`env`变量设置为`test`，然后运行测试套件；我们所有的测试都通过了，这太棒了。我们设置的一切是否有效的真正测试是，如果我们再次启动服务器并尝试从`development`数据库中获取数据。
- en: 'Over inside of Postman I''m going to make that `GET /todos` request one last
    time and right there our Todo data still shows up as expected. Even though the
    test suite did run, it didn''t matter because it''s not wiping this database anymore,
    it''s now wiping a brand new database you can view in Robomongo. If I click the
    connection and click Refresh, we now have two `TodoApp` databases: we have `TodoApp`
    and we have `TodoAppTest`. This is fantastic; everything is set up and we are
    ready to get rolling.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman中，我将最后一次进行`GET /todos`请求，我们的待办事项数据仍然如预期般显示出来。尽管测试套件确实运行了，但这并不重要，因为它不再清除这个数据库，而是现在清除了一个全新的数据库，您可以在Robomongo中查看。如果我点击连接并点击刷新，我们现在有两个`TodoApp`数据库：我们有`TodoApp`和`TodoAppTest`。这太棒了；一切都设置好了，我们准备好开始了。
- en: 'Now what I do want to do before we go is take all of this code out of `server.js`
    and move it somewhere else; it doesn''t really belong here and it only makes the
    server file more complex than it needs to be. In the `server` folder, I''m going
    to make a brand new folder called `config`, and in the `config` folder I''ll make
    a new file called `config.js`, and inside we can do all of that process environment
    variable configuration. I''m going to copy all of the code and replace it with
    a `require` call to that file. It''s a relative file so we''ll go to `/config/config`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们离开之前，我想把`server.js`中的所有代码移到其他地方；它并不真正属于这里，它只会使服务器文件变得比必要的更复杂。在`server`文件夹中，我将创建一个名为`config`的全新文件夹，在`config`文件夹中，我将创建一个名为`config.js`的新文件，在其中我们可以进行所有的环境变量配置。我将复制所有代码并用一个`require`调用替换它。这是一个相对文件，所以我们将转到`/config/config`：
- en: '[PRE83]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Inside of `config.js` we can now copy the code in and remove the line related
    to `console.log`. Let's wrap this section up by committing our changes and deploying
    to Heroku.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config.js`内部，我们现在可以复制代码并删除与`console.log`相关的行。让我们通过提交更改并部署到Heroku来结束这一部分。
- en: 'Over inside of the Terminal I''m going to clear the Terminal output, then we
    can go ahead and run `git status` to see what files we have changed, and we have
    quite a few:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我将清除终端输出，然后我们可以运行`git status`来查看我们更改了哪些文件，我们改变了相当多的文件。
- en: '![](img/a5e2bfee-c91b-4d80-a530-2e908b981b26.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5e2bfee-c91b-4d80-a530-2e908b981b26.png)'
- en: 'We also have some new files in the `server` directory. I''m going to use `git
    add .` to add all of that to the next commit and I''ll use `git status` again
    to confirm everything looks good. Now we''re ready for the commit and I can go
    ahead and do that, `git commit` with the `-m` flag providing our message, `Setup
    separate test and development envs`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`server`目录中有一些新文件。我将使用`git add .`将所有内容添加到下一个提交中，然后再次使用`git status`确认一切看起来都很好。现在我们准备提交，我可以继续进行，使用`git
    commit`并使用`-m`标志提供我们的消息，`设置单独的测试和开发环境`：
- en: '[PRE84]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And I''m also going to deploy it to Heroku so we can verify we haven''t broken
    anything there:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我还要将其部署到Heroku，以便我们可以验证我们在那里没有破坏任何东西：
- en: '[PRE85]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Once this is done we''ll wrap the section up by heading into Postman and making
    a `GET /todos` request to our Heroku application. Over inside of Postman I''m
    going to switch environments from Todo App Local to Todo App Heroku and we can
    fire off the request:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将通过进入Postman并向我们的Heroku应用程序发出`GET /todos`请求来结束这一部分。在Postman中，我将从Todo App
    Local切换到Todo App Heroku环境，然后我们可以发送请求：
- en: '![](img/eac61e9b-7445-4495-8747-d1ae04f00551.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eac61e9b-7445-4495-8747-d1ae04f00551.png)'
- en: Now, as shown in the preceding screenshot, we get our two `todo` items coming
    from the real database, which means nothing was broken on the Heroku application,
    and it shouldn't be—technically we haven't changed anything. In Heroku, all we're
    doing is we're running the `config` file, but we don't use the default because
    it's already set, and it's not going to pass any of those statements because the
    `env` variable is going to be equal to the string production, so as far as Heroku
    is concerned, nothing has changed, and it's showing that because the data is still
    coming back as expected.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如前面的屏幕截图所示，我们从真实数据库中获取了两个`todo`项目，这意味着Heroku应用程序上没有出现任何问题，也不应该有——从技术上讲，我们什么都没有改变。在Heroku中，我们所做的就是运行`config`文件，但我们不使用默认值，因为它已经设置好了，并且不会通过任何那些语句，因为`env`变量将等于字符串production，因此就Heroku而言，没有任何变化，并且它显示出来，因为数据仍然如预期般返回。
- en: That is it for this section, and that is it for this chapter. In this section,
    we learned about MongoDB, Mongoose APIs, Postman, testing, routes, all sorts of
    great features. In the next chapter, we're going to wrap up the Todo application
    by adding authentication.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本节的全部内容，也是本章的全部内容。在本节中，我们学习了关于MongoDB、Mongoose API、Postman、测试、路由等各种重要功能。在下一章中，我们将通过添加身份验证来完成Todo应用程序。
- en: Summary
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we worked on learning Mongoose queries and ID validation. Next,
    we looked into getting an individual resources and moved on to take a few challenges.
    After deploying the API to Heroku and exploring the Postman environments, we learnt
    about different methods of deleting a resource. Finally, we looked into creating
    a test database.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Mongoose查询和ID验证。接下来，我们研究了获取单个资源并进行了一些挑战。在将API部署到Heroku并探索Postman环境之后，我们了解了不同的删除资源的方法。最后，我们研究了创建测试数据库。
- en: In the next chapter, we will learn about Real-Time Web Apps with Socket.io
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用Socket.io创建实时Web应用程序
