- en: Chapter 10. Displaying Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。显示视图
- en: The heart and soul of most SPAs is a dynamic frontend. SPAs move a lot of the
    heavy lifting, related to display logic, onto the browser. Modern browsers have
    fast and powerful JavaScript engines that can handle a lot more computation than
    just a few years ago. In fact, Node.js is built on top of the VB engine, which
    is a standard part of the Chrome browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 SPA 的核心和灵魂是一个动态的前端。SPA 将与显示逻辑相关的许多繁重工作转移到浏览器上。现代浏览器拥有快速且强大的 JavaScript 引擎，可以处理比几年前多得多的计算。实际上，Node.js
    是建立在 VB 引擎之上的，它是 Chrome 浏览器的一个标准部分。
- en: Most importantly, however, the main idea of an SPA is to give the user an experience
    approaching that of a desktop application. Complete page loads are a thing of
    the past, replaced by snappy changes in state.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，SPA 的主要思想是给用户提供接近桌面应用程序的体验。完整的页面加载已成为过去式，被状态中的快速变化所取代。
- en: In this chapter, we will build out the heart of our own SPA. This will be a
    dashboard where users can build `giftlists` and share them with other users. We
    will have to build out a couple more routes and data structures on the backend,
    but we will focus on the frontend. We will build an Express view that will load
    AngularJS - a JavaScript toolkit designed specifically for rapid creation of SPAs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们自己的 SPA 的核心。这将是一个用户可以构建 `giftlists` 并与其他用户分享的仪表板。我们还需要在后台构建更多路由和数据结构，但我们将专注于前端。我们将构建一个
    Express 视图，该视图将加载 AngularJS - 一个专门为快速创建 SPA 而设计的 JavaScript 工具包。
- en: We will build AngularJS routes, views, services, and controllers that will implement
    the core functionality of the SPA. Using the AngularJS plugin, UI-router, we will
    manage the state of our application. We will also implement services to communicate
    to the end so that data can flow freely in our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建 AngularJS 路由、视图、服务和控制器，以实现 SPA 的核心功能。使用 AngularJS 插件 UI-router，我们将管理我们应用程序的状态。我们还将实现服务以与终端进行通信，以便数据可以在我们的应用程序中自由流动。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Developing the initial dashboard view in Express
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Express 中开发初始仪表板视图
- en: Implementing AngularJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 AngularJS
- en: AngularJS routing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS 路由
- en: Using AngularJS `$resource` to access RESTful endpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AngularJS `$resource` 访问 RESTful 端点
- en: Setting up our dashboard
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的仪表板
- en: Since this is a SPA, we need to set up a single page to contain our application.
    In our case, we are going to build a user dashboard. That dashboard will allow
    a user to create `giftlists` (such as birthday wish lists), choose who they want
    to share them with, and see lists that have been shared with them. In the next
    chapter, we're going to build authentication so that individual users will only
    be able to see their own dashboards, but for now we need to mock things up without
    authentication a bit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 SPA，我们需要设置一个单页来包含我们的应用程序。在我们的案例中，我们将构建一个用户仪表板。该仪表板将允许用户创建 `giftlists`（例如生日愿望清单），选择他们想要与之分享的人，并查看与他们分享的列表。在下一章中，我们将构建身份验证，以便单个用户只能看到他们自己的仪表板，但到目前为止，我们需要在没有身份验证的情况下进行一些模拟。
- en: We'll need a couple of routes, and a view. We're also going to use `Bootstrap`
    to style our view a little.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些路由和一个视图。我们还将使用 `Bootstrap` 为我们的视图添加一些样式。
- en: Building the view
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建视图
- en: 'We need to create a view for our dashboard. Create a new folder in your views
    directory called `dash`. Inside that folder, create a file called `dashboard.ejs`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的仪表板创建一个视图。在您的视图目录中创建一个名为 `dash` 的新文件夹。在该文件夹内，创建一个名为 `dashboard.ejs`
    的文件：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So there's nothing too exciting here yet. We have set up some placeholders,
    and we are assuming that we'll have a `user` object to display. We can't see our
    view yet - for that we need a `route` which will render the view.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里目前还没有什么特别激动人心的东西。我们已经设置了一些占位符，并假设我们将有一个 `user` 对象来显示。我们目前还看不到我们的视图 - 为了做到这一点，我们需要一个
    `route` 来渲染视图。
- en: 'Let''s set up the `route` to display our dashboard. In your `routes` directory,
    create a new file called `dashboard.js`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置显示仪表板的 `route`。在您的 `routes` 目录中，创建一个名为 `dashboard.js` 的新文件：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have done a couple of things here. First, we set up our middleware to respond
    to routes with an id parameter as we did with our users' routes. Next, we set
    up a route for displaying our dashboard.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了一些事情。首先，我们设置了我们的中间件来响应带有 id 参数的路由，就像我们为用户路由所做的那样。接下来，我们设置了一个用于显示仪表板的路由。
- en: 'Unless you have the ID for a user memorized, it''s going to be hard to test
    our new view. Let''s make it a little easier by modifying the view that lists
    our users. Open up `views/users/show.ejs`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你记住了用户的ID，否则测试我们的新视图将会很困难。让我们通过修改列出我们用户的视图来让它变得容易一些。打开`views/users/show.ejs`：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We added a new column in our users table with a link to the dashboard for each
    user. We still can''t display our dashboard yet. We have to make a change to our
    `app.js` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的用户表中添加了一个新列，其中包含指向每个用户仪表板的链接。我们仍然不能显示我们的仪表板。我们必须修改我们的`app.js`文件：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The two key changes here are that we import the dashboard router, we then map
    any requests to `/dash` to that `router`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个关键变化是，我们导入了仪表板路由器，然后我们将任何对`/dash`的请求映射到该`router`。
- en: 'Make sure your MongoDB daemon is still running, and restart it if it isn''t.
    Start or restart your server. Navigate to your list of users at `http://localhost:3000/users/show`
    and then click on one of the `view` links in the right of the table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的MongoDB守护进程仍在运行，如果不是，请重新启动它。启动或重新启动你的服务器。导航到你的用户列表`http://localhost:3000/users/show`，然后点击表格右侧的一个`view`链接：
- en: '![Building the view](img/image_10_001.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![构建视图](img/image_10_001.jpg)'
- en: 'The URL should look something like this: `http://localhost:3000/dash/566dd0cb1c09d090fd36ba83`.
    You should see a page that looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: URL应该看起来像这样：`http://localhost:3000/dash/566dd0cb1c09d090fd36ba83`。你应该看到一个看起来像这样的页面：
- en: '![Building the view](img/image_10_002.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![构建视图](img/image_10_002.jpg)'
- en: Now we have a `view` template and routing set up to display the page. The next
    thing we need to do is to build out some data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个视图模板和路由来显示页面。接下来我们需要做的是构建一些数据。
- en: Connecting to initial data
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到初始数据
- en: Our application is going to allow users to build `giftlists` and share them
    with other users. We want to think a little bit about how we want to represent
    our data. A good data model will serve us, even as we add and change features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将允许用户构建`giftlists`并与其他用户共享。我们想稍微考虑一下我们想要如何表示我们的数据。一个好的数据模型将为我们服务，即使我们添加和更改功能。
- en: As we have learned, MongoDB is very flexible, and we could just embed documents
    inside documents. This might work; we could just have each user with an array
    of lists. The issue with that is that our individual user documents would be highly
    mutable, and could grow to an enormous size easily. It also doesn't offer a lot
    of flexibility down the road if we want to do something like having shared lists.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，MongoDB非常灵活，我们可以在文档中嵌套文档。这可能可行；我们可以让每个用户都有一个列表数组。问题是，我们的单个用户文档将非常可变，并且很容易增长到巨大的大小。如果我们想在将来做一些像共享列表这样的操作，这也不提供很多灵活性。
- en: The type of relationship that we want to have for now is a one-to-many relationship.
    One user can have many lists. The way we'll accomplish this is to store a reference
    to the user who owns the list on the list itself. Later, if we want to have more
    than one user *own* a list, the change would be pretty straightforward.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要的关系类型是一对多关系。一个用户可以有多个列表。我们将通过在列表本身上存储拥有该列表的用户的引用来实现这一点。如果我们以后想要让多个用户共同拥有一个列表，这个更改将会非常直接。
- en: 'We want to use our `giftapp` database, and we are going to be creating a new
    collection of `giftlists`. Start up the MongoDB command-line tool in a new terminal
    window. Note that you''ll want to copy the exact `ID` of one of your users since
    it will differ from mine:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用我们的`giftapp`数据库，并且我们将创建一个新的`giftlists`集合。在一个新的终端窗口中启动MongoDB命令行工具。注意，你需要复制你其中一个用户的精确`ID`，因为这与我的不同：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The important part here is the format of the insert statement. Let's break it
    apart a little bit.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是插入语句的格式。让我们稍微分解一下。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We insert this object into the `giftlist` collection, which will be created
    if it doesn't already exist. The object has a name property and a `gifts` property.
    The `gifts` property is an array of objects, each containing a name property.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个对象插入到`giftlist`集合中，如果它还不存在，将会创建。该对象有一个名称属性和一个`gifts`属性。`gifts`属性是一个包含名称属性的对象数组。
- en: We also have an `owner_id` property. This property is a reference to the user
    to whom the `giftlist` belongs. It's just the string of the user's `_id`. Since
    MongoDB is a non-relational database, we will just stash this in here to do lookups
    in the `users` collection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`owner_id`属性。这个属性是对`giftlist`所属用户的引用。它只是用户`_id`的字符串。由于MongoDB是一个非关系型数据库，我们将把它放在这里，以便在`users`集合中进行查找。
- en: 'We know we''re going to be looking things up by the owner, so let''s add an
    `index`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们将通过所有者来查找信息，所以让我们添加一个`索引`：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s see what we have got by running a query on the command line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在命令行运行查询来看看我们得到了什么：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just what we would expect.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的那样。
- en: 'Now, let''s modify our `dashboard.js` route:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改我们的`dashboard.js`路由：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have modified the call to `router.param()` to search the `giftlists` collection
    based on the user `id` passed in. If we get a `giftlist` back, we then search
    the `users` collection to get the user data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修改了对`router.param()`的调用，以便根据传入的用户`id`搜索`giftlists`集合。如果我们得到了一个`giftlist`，我们接着搜索`users`集合以获取用户数据。
- en: Yes, there are two calls to the database here. This is a bit of a trade-off
    in performance for flexibility. Remember that we decided earlier not to embed
    `giftlists` in the user document. This trade-off is something you will want to
    think through in your own applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这里有两个数据库调用。这是为了灵活性而牺牲性能的一点点权衡。记住，我们之前决定不在用户文档中嵌入`giftlists`。这种权衡是你自己应用中需要仔细思考的问题。
- en: 'Let''s also modify our `dashboard.ejs` view template:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也修改我们的`dashboard.ejs`视图模板：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we have an unordered list that renders the name of each of our `giftlists`.
    When we start adding AngularJS, we''ll link each of these to a state that displays
    the lists. Navigating to the `user dashboard` page, you should see this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个无序列表，它渲染了每个`giftlists`的名称。当我们开始添加AngularJS时，我们将链接每个这些到显示列表的状态。导航到`用户仪表板`页面，你应该看到如下内容：
- en: '![Connecting to initial data](img/image_10_003.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![连接到初始数据](img/image_10_003.jpg)'
- en: We now have a list of our user's `giftlists` and a placeholder for lists that
    have been shared with them. In a little bit, when we add AngularJS, we will also
    add the code for adding, editing, and sharing lists.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个用户`giftlists`的列表以及与他们共享的列表的占位符。在不久的将来，当我们添加AngularJS时，我们也将添加添加、编辑和共享列表的代码。
- en: Right now, our dashboard is somewhat ugly. Let's fix that a little bit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的仪表板有些丑陋。让我们稍微改进一下。
- en: Implementing Bootstrap
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Bootstrap
- en: If you haven't heard of `Bootstrap` before, it is an extremely popular CSS framework.
    Plugging in `Bootstrap` helps frontend developers do things such as layout, painting
    buttons, and implementing controls without writing a lot of code by hand.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有听说过`Bootstrap`，它是一个非常流行的CSS框架。插入`Bootstrap`可以帮助前端开发者通过编写很少的手动代码来实现布局、绘制按钮和实现控件等功能。
- en: You can get `Bootstrap`, and see its documentation at [https://getbootstrap.com](https://getbootstrap.com).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以获取`Bootstrap`，并在[https://getbootstrap.com](https://getbootstrap.com)查看其文档。
- en: 'Let''s sweeten up our `dashboard.ejs` template a little:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微美化一下我们的`dashboard.ejs`模板：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the head of our document, you'll see three new lines. The first is a `meta`
    tag, which sets the viewport for mobile devices. The next two load `Bootstrap`
    and a `Bootstrap` theme from a CDN.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档的头部，你会看到三行新内容。第一行是一个`meta`标签，它为移动设备设置了视口。接下来的两行从CDN加载了`Bootstrap`和`Bootstrap`主题。
- en: We then place what we had inside an `H1` tag into a number of elements, which
    will paint a `nav` bar at the top of the page.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将之前放在`H1`标签内的内容放入多个元素中，这将绘制页面顶部的导航栏。
- en: The next section is a `div` element with a class of container. This is necessary
    for the `Bootstrap` layout to work. `Bootstrap` uses a grid system for a layout
    with rows and columns. Basically, there are 12 columns of equal width in a row.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是一个具有`container`类的`div`元素。这对于`Bootstrap`布局是必要的。`Bootstrap`使用一个网格系统进行布局，包括行和列。基本上，在每一行中，有12个宽度相等的列。
- en: Classes such as `col-xs-12` tell `Bootstrap` that, when the view port is extra
    small (like on a phone), that particular element should take up the entire width
    of the container. The  `col-md-6` class, makes the element half the width (six
    columns) when the screen is medium width or greater. By combining these classes,
    we can have a variable layout that makes sense based upon screen width. This is
    a main component of what's referred to as responsive design.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`col-xs-12`的类告诉`Bootstrap`，当视口非常小（如手机）时，该特定元素应占据容器的整个宽度。`col-md-6`类使得元素在屏幕宽度中等或更大时宽度为半宽（六个列）。通过组合这些类，我们可以有一个基于屏幕宽度的可变布局，这是所谓的响应式设计的主要组成部分。
- en: 'Looking at our dashboard in full width, we see this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 全屏查看我们的仪表板，我们看到如下内容：
- en: '![Implementing Bootstrap](img/image_10_004.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![实现Bootstrap](img/image_10_004.jpg)'
- en: 'In full size, our dashboard is divided into two equal width columns. You can
    also see our top `nav` bar is with **Mark Smith Dashboard** is rendering. Now,
    if you drag the side of your browser to make it narrow like a mobile phone screen,
    you''ll see this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在全尺寸下，我们的仪表板分为两个等宽的列。您还可以看到我们的顶部`nav`栏正在渲染**Mark Smith Dashboard**。现在，如果您将浏览器的一侧拖动以使其变窄，就像手机屏幕一样，您会看到这个：
- en: '![Implementing Bootstrap](img/image_10_005.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![实现Bootstrap](img/image_10_005.jpg)'
- en: 'Our columns are now stacked one on top of each other, which makes a lot more
    sense for a mobile form factor. Let''s add a button element to add new lists,
    which we''ll actually connect later:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将列堆叠在一起，这对于移动设备格式来说更有意义。让我们添加一个按钮元素来添加新的列表，我们稍后会将其连接起来：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added a button with a class of `btn-primary`. Inside that button we have
    a span with a couple of `glyphicon` classes. These classes actually use a font
    to paint different types of common symbols.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个具有`btn-primary`类的按钮。在该按钮内部，我们有一个带有几个`glyphicon`类的span。这些类实际上使用一种字体来绘制不同类型的常见符号。
- en: 'Viewing our page now, we''ll see a pretty blue button with a plus sign:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的页面，我们会看到一个带有加号的漂亮蓝色按钮：
- en: '![Implementing Bootstrap](img/image_10_006.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![实现Bootstrap](img/image_10_006.jpg)'
- en: We'll be developing further visual components as AngularJS views.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发更多的视觉组件作为AngularJS视图。
- en: Implementing AngularJS
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现AngularJS
- en: 'Now it''s time to implement most of our view logic by implementing a more robust
    AngularJS application. The first thing we need to do is to add AngularJS code
    to our `dashboard.ejs` view template:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过实现一个更健壮的AngularJS应用程序来实现我们的大部分视图逻辑了。我们首先需要做的是将AngularJS代码添加到我们的`dashboard.ejs`视图模板中：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We linked to AngularJS version 1.4.8 on a CDN, as well as a plugin called UI-router.
    We'll be talking about UI-router in depth. We also added the AngularJS directive
    `ng-app` to the opening `html` tag. When AngularJS loads, it looks for this directive
    to see what part of the document it should manage. Most applications will have
    Angular manage from the top level by doing this, though one could `Bootstrap`
    AngularJS into any part of the document.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在CDN上链接了AngularJS版本1.4.8，以及一个名为UI-router的插件。我们将深入讨论UI-router。我们还向打开的`html`标签添加了AngularJS指令`ng-app`。当AngularJS加载时，它会查找这个指令以确定它应该管理文档的哪个部分。大多数应用程序将通过这种方式从顶级开始由Angular管理，尽管可以将AngularJS引导到文档的任何部分。
- en: Our AngularJS module
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的AngularJS模块
- en: AngularJS packages applications, parts of applications, and dependencies using
    modules. Everything we're going to do with AngularJS is going to be done by using
    modules or using code, such as controllers, which have been added to modules.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS使用模块打包应用程序、应用程序的部分和依赖项。我们将使用AngularJS完成的每一件事都将通过使用模块或使用代码来完成，例如控制器，这些控制器已被添加到模块中。
- en: This is a core part of AngularJS architecture. Modules are containers for the
    parts of your application, and allow AngularJS to properly `Bootstrap` your application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是AngularJS架构的核心部分。模块是应用程序部分的容器，并允许AngularJS正确地`Bootstrap`您的应用程序。
- en: 'For now, our module is going to be simple, then we''ll add to it as we go on.
    Create a new file called `giftapp.js` inside `public/javascripts`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的模块将保持简单，然后我们会随着进展逐步添加功能。在`public/javascripts`目录下创建一个名为`giftapp.js`的新文件：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We create our module by invoking the `angular.module()` function. The first
    argument is the name of the module. The second argument is an array containing
    a list of dependencies we want to inject into our module. In this case, the only
    one we're injecting at the moment is UI-router.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`angular.module()`函数来创建我们的模块。第一个参数是模块的名称。第二个参数是一个数组，包含我们想要注入到模块中的依赖项列表。在这种情况下，我们目前只注入了UI-router。
- en: 'Now, we need to add our module to our `dashboard.ejs` template:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的模块添加到我们的`dashboard.ejs`模板中：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We simply load our module using a normal `script` tag. Also, we change the `ng-app`
    directive so that it will use our new module as the main application entry point
    for the page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用一个普通的`script`标签来加载我们的模块。同时，我们更改了`ng-app`指令，使其将我们的新模块作为页面的主要应用程序入口点。
- en: Controlling state with UI-router
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用UI-router控制状态
- en: State can mean a lot of things in applications, but in our SPA it refers to
    a given set of views, controllers, and data that can be invoked using a URL changer.
    By far the most popular way for developers to handle state in their AngularJS
    applications is with a plugin called UI-router.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，状态可以指很多事物，但在我们的SPA中，它指的是一组特定的视图、控制器和数据，可以通过URL更改器来调用。到目前为止，开发者处理AngularJS应用程序状态最流行的方式是使用一个名为UI-router的插件。
- en: The UI-router plugin allows us to control state rather elegantly, and is extremely
    flexible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: UI-router插件允许我们优雅地控制状态，并且非常灵活。
- en: 'Let''s implement UI-router in our application. First, we will reference UI-router
    from a CDN in our `dashboard.ejs` template:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中实现UI-router。首先，我们将在`dashboard.ejs`模板中从CDN引用UI-router：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We linked to UI-router on a CDN and loaded it using a normal `script` tag. The
    other major change in our template is the addition of a `ui-view` directive implemented
    as an attribute on a `div` element. The `ui-view` directive tells UI-router where
    to load the views that it's going to be painting.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在CDN上链接了UI-router并使用正常的`script`标签加载它。我们模板中的另一个主要变化是在`div`元素上实现了一个`ui-view`指令作为属性。`ui-view`指令告诉UI-router在哪里加载它将要绘制的视图。
- en: 'The next step is to edit our `giftapp.js` application file to add routing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编辑我们的`giftapp.js`应用程序文件以添加路由：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we make sure to inject the `ui.router` module into our module. We chain
    a `config` function onto our module declaration. Using an array notation, we inject
    `$stateProvider` and `$urlRouteprovider` into the `config` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保将`ui.router`模块注入到我们的模块中。我们将一个`config`函数链接到我们的模块声明。使用数组表示法，我们将`$stateProvider`和`$urlRouteprovider`注入到`config`函数中。
- en: Inside that function, the magic happens. First, we invoke `$urlRouterProvider.otherwise('/dash');`,
    which sets the default route. When we load our page, unless another route is triggered
    with a URL fragment, `#/dash` will be appended to the URL.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个函数内部，魔法发生了。首先，我们调用`$urlRouterProvider.otherwise('/dash');`，这设置了默认路由。当我们加载页面时，除非另一个路由通过URL片段触发，否则`#/dash`将被附加到URL上。
- en: Next, we set up two states on `$stateProvider`. For now, each is named and has
    a URL and `templateURL` property. The template URL points to a URL for a visual
    template to load.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`$stateProvider`上设置两个状态。目前，每个状态都有一个名称、URL和`templateURL`属性。模板URL指向一个用于加载的可视模板的URL。
- en: Let's mock up our two templates. Create a new directory at `public/templates`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟我们的两个模板。在`public/templates`下创建一个新的目录。
- en: 'Here''s our `dash-main.tpl.html`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`dash-main.tpl.html`：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And this is our `dash-add.tpl.html` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`dash-add.tpl.html`文件：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we've mocked up a form that could be used to add a new list. We'll flesh
    it out later, and actually connect it to the backend to store data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们模拟了一个可以用来添加新列表的表单。我们稍后会完善它，并将其实际连接到后端以存储数据。
- en: AngularJS controllers
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AngularJS控制器
- en: Right now, our templates are basically just dumb HTML, the AngularJS method
    of linking our DOM to data and functionality. Controllers contain business logic,
    but should not be used to manipulate the DOM directly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的模板基本上只是简单的HTML，使用AngularJS方法将我们的DOM与数据和功能链接起来。控制器包含业务逻辑，但不应该直接用于操作DOM。
- en: In using UI-router, we can easily attach controllers to states, making their
    `$scope` available to our views.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用UI-router时，我们可以轻松地将控制器附加到状态，使它们的`$scope`可用于我们的视图。
- en: 'Create a new controllers folder inside `public/javascripts`. Create a new JavaScript
    file called `dashMainController.js`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public/javascripts`内部创建一个新的控制器文件夹。创建一个名为`dashMainController.js`的新JavaScript文件：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We create a new module called `giftAppControllers` that takes no dependencies.
    Then, we build a controller called `DashMainController`. Using an array notation,
    we inject `$scope` and then declare a constructor function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`giftAppControllers`的新模块，它没有依赖项。然后，我们构建了一个名为`DashMainController`的控制器。使用数组表示法，我们注入`$scope`然后声明一个构造函数。
- en: Inside that function we attach a lists array to `$scope`, which will make it
    available to any view that references this controller.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个函数内部，我们将一个列表数组附加到`$scope`上，这将使它可用于任何引用此控制器的视图。
- en: 'Next, we need to load that file into the `dashboard.ejs` view template:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将那个文件加载到`dashboard.ejs`视图模板中：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You'll note that you can load the controller module after your main module.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到你可以在主模块之后加载控制器模块。
- en: 'Next, we need to edit our main `giftapp.js` module to use the new controller
    as part of a route:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编辑我们的主要`giftapp.js`模块以使用新的控制器作为路由的一部分：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing we do is to inject our new controller module into our `giftapp`
    module. This makes the `DashMainController` available in the module. We then set
    its name, as a string, to the controller property on our `dash` state.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将新的控制器模块注入到我们的`giftapp`模块中。这使得`DashMainController`在模块中可用。然后，我们将它的名称（作为一个字符串）设置为`dash`状态的控制器属性。
- en: The last thing we should do is to modify our template to take advantage of our
    new controller. Any methods or properties added to `$scope` in a controller become
    available inside the view.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后应该做的事情是修改我们的模板，以便利用我们新的控制器。控制器中添加到`$scope`的任何方法或属性都将在视图中可用。
- en: 'Here''s our new `dash-main.tpl.html`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的新`dash-main.tpl.html`：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instead of canned list items, we rely on the `ng-repeat` directive (provided
    by AngularJS itself). The `ng-repeat` directive iterates over things that are
    iterable - in this case an array called list. For each member of the array, the
    directive will paint a `li` element, assigning the instance to the variable list
    (essentially creating a new scope). Since our list objects all have name properties,
    we can access this in a markup expression with `{{list.name}}`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不依赖于预制的列表项，而是依赖于由AngularJS本身提供的`ng-repeat`指令。`ng-repeat`指令遍历可迭代的事物 - 在这种情况下是一个名为list的数组。对于数组的每个成员，指令将绘制一个`li`元素，并将实例分配给变量list（本质上创建了一个新的作用域）。由于我们的列表对象都有name属性，我们可以在标记表达式中通过`{{list.name}}`访问它。
- en: 'Making sure our database and server are running, refreshing our dashboard should
    look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的数据库和服务器正在运行，刷新我们的仪表板应该看起来像这样：
- en: '![AngularJS controllers](img/image_10_007.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![AngularJS控制器](img/image_10_007.jpg)'
- en: '**Christmas List** and **Birthday List** are coming from `$scope` in our new
    controller. Clicking on the **Add List** button takes us to our add state and
    the page suddenly looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**圣诞清单**和**生日清单**来自我们新控制器中的`$scope`。点击**添加清单**按钮将我们带到添加状态，页面突然看起来像这样：'
- en: '![AngularJS controllers](img/image_10_008.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![AngularJS控制器](img/image_10_008.jpg)'
- en: So now we have the essence of a single page web application working. We have
    a model, views, and a controller. We have a method of managing state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经拥有了一个单页Web应用程序的核心。我们有模型、视图和控制器。我们有管理状态的方法。
- en: In mocking up this functionality, we did remove the connection to the database.
    So let's add that back in the AngularJS way.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟这个功能时，我们确实移除了与数据库的连接。所以，让我们按照AngularJS的方式将其添加回来。
- en: Talking to the backend
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与后端通信
- en: So now we need to connect our frontend to our backend. Instead of rendering
    data in our page on load, we want to use AJAX to connect and do all of our CRUD.
    Fortunately for us, Angular has a pretty elegant way of handling this.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在需要将我们的前端连接到后端。我们不想在页面加载时渲染数据，而是想使用AJAX进行连接并执行所有的CRUD操作。幸运的是，Angular有一个相当优雅的方式来处理这个问题。
- en: Creating an AngularJS factory
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个AngularJS工厂
- en: Let's say that different parts of our application may need access to some of
    the same data endpoints, or some other functionality. A great way to handle this
    is with an AngularJS provider. A provider is essentially an injectable singleton,
    and there are a number of options available - see [https://docs.angularjs.org/guide/providers](https://docs.angularjs.org/guide/providers).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序的不同部分可能需要访问一些相同的数据端点，或者一些其他功能。一个处理这个问题的好方法是使用AngularJS提供者。提供者本质上是一个可注入的单例，并且有多个选项可用
    - 请参阅[https://docs.angularjs.org/guide/providers](https://docs.angularjs.org/guide/providers)。
- en: 'The provider type we are going to use is a factory. Let''s start by creating
    a `services` directory inside our `public/javascripts` directory. Create a new
    file called `giftlistFactory.js` inside that directory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的提供者类型是一个工厂。让我们首先在我们的`public/javascripts`目录内创建一个`services`目录。在那个目录内创建一个名为`giftlistFactory.js`的新文件：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We've created another module for services, and then created a factory called
    `List` on that module. That factory doesn't do much yet, but we'll get to that.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为服务创建了一个新的模块，并在该模块上创建了一个名为`List`的工厂。这个工厂目前还没有做什么，但我们会做到这一点。
- en: 'Next, we''ll load this file using a `script` tag in our `dashboard.ejs` template:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`dashboard.ejs`模板中的`script`标签来加载这个文件：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we''re loading this module, we can inject it into our controller.
    Open up `dashMainController.js` and edit the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了这个模块，我们可以将其注入到我们的控制器中。打开`dashMainController.js`并编辑以下内容：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We inject the `giftlistServices` module into our `giftappControllers` module.
    In our `DashMainController`, we inject the `List` factory. Currently, `List` only
    returns an empty object, but anything we place in there going forward becomes
    available to our controller.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`giftlistServices`模块注入到我们的`giftappControllers`模块中。在我们的`DashMainController`中，我们注入了`List`工厂。目前，`List`只返回一个空对象，但未来放入那里的任何内容都将对控制器可用。
- en: Using AngularJS $resource
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AngularJS $resource
- en: The smart people who develop AngularJS figured out that a lot of what people
    want to do in an SPA is to talk to RESTful services. They had the idea to build
    a factory on top of their `$http` service (which provides AJAX functionality),
    which would provide an easy way to interact with a RESTful interface. That's precisely
    what `$resource` does.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 开发AngularJS的聪明人意识到，在SPA中人们想要做很多事情都是与RESTful服务进行交互。他们有了在他们的`$http`服务（提供AJAX功能）之上构建工厂的想法，这将提供一个与RESTful接口交互的简单方法。这正是`$resource`所做的事情。
- en: 'We will begin by loading the `ngResource` module, which exposes `$resource`.
    In our `dashboard.ejs` template, add a `script` tag to load the module from CDN:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先加载`ngResource`模块，该模块公开了`$resource`。在我们的`dashboard.ejs`模板中，添加一个`script`标签以从CDN加载模块：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we have the module loaded, let''s edit our factory to utilize `$resource`.
    Open `giftlistFactory` and make the following edits:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了模块，让我们编辑我们的工厂以利用`$resource`。打开`giftlistFactory`并做出以下编辑：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can see that we inject the `ngResource` module in our module. This allows
    us to inject `$resource` into our `List` factory. Lastly, we return the result
    of invoking `$resouce` with the path `/giftlist/:id`. This, combined with the
    second argument, sets up a number of functions that optionally include an `id`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们在我们的模块中注入了`ngResource`模块。这使我们能够将`$resource`注入到我们的`List`工厂中。最后，我们返回调用`$resouce`并带有路径`/giftlist/:id`的结果。这与第二个参数结合，设置了一系列可选地包含`id`的函数。
- en: 'Remember the resourceful controller we built earlier? We''re going to make
    an edit with some hardcoded data, for now. `Opencontrollers/giftlist_controller.js`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前构建的资源丰富的控制器吗？现在我们将使用一些硬编码的数据进行编辑。打开`controllers/giftlist_controller.js`：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For now, only edit the `index`. You can see that I've hardcoded the `owner_id`
    for the query to match the user in the database I've been working with. You should
    match your `user id` accordingly as it will differ from mine.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需编辑`index`。你可以看到我已经硬编码了查询的`owner_id`以匹配我在数据库中工作的用户。你应该相应地匹配你的`user id`，因为它将不同于我的。
- en: 'Now, edit your `dashMainController.js` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑你的`dashMainController.js`文件：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We set the value of `$scope.lists` to the result of running a query on our
    `List` resource. In this case, the result is an array of objects. If you restart
    your server and then reload the page, you''ll see this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`$scope.lists`的值设置为对`List`资源进行查询的结果。在这种情况下，结果是对象数组。如果你重新启动你的服务器然后重新加载页面，你会看到这个：
- en: '![Using AngularJS $resource](img/image_10_009.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![使用AngularJS $resource](img/image_10_009.jpg)'
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you built out the major parts of the UI side of your SPA. You
    started by building a view in Express. You included `Bootstrap` for some easy
    styling, layout, and responsiveness. Then you refactored the page to utilize AngularJS.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你构建了SPA UI方面的主要部分。你首先在Express中构建了一个视图。你包括了`Bootstrap`以进行一些简单的样式、布局和响应式设计。然后你重构了页面以利用AngularJS。
- en: You set up modules, routes, templates, and a controller using AngularJS. You
    then built a factory and injected `$resource` into it. You started to access data
    from a RESTful endpoint and then displayed that data in your application by mapping
    it to `$scope` in your controller.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用AngularJS设置了模块、路由、模板和一个控制器。然后你构建了一个工厂并将`$resource`注入其中。你开始从RESTful端点访问数据，然后通过将数据映射到控制器中的`$scope`来在应用程序中显示这些数据。
