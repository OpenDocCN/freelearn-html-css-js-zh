- en: Callbacks in Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程中的回调
- en: This chapter is the second part of our asynchronous programming in Node.js.
    In this chapter, we'll look at callbacks, HTTP requests, and more. We're going
    to handle a lot of the errors that happen inside callbacks. There's a lot of ways
    our request in `app.js` can go wrong, and we'll want to figure out how to recover
    from errors inside of our callback functions when we're doing asynchronous programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是我们在Node.js中的异步编程的第二部分。在本章中，我们将看到回调、HTTP请求等。我们将处理回调中发生的许多错误。我们在`app.js`中的请求有很多错误的处理方式，我们将想要弄清楚如何在异步编程中从回调函数中恢复错误。
- en: Next, we'll be moving our request code block into a separate file and abstracting
    a lot of details. We'll talk about what that means and why it's important for
    us. We'll be using Google's Geolocation API, and we'll be using the Dark Sky API
    to take location information like a zip code and turn that into real-world current
    weather information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把我们的请求代码块移到一个单独的文件中，并抽象出许多细节。我们将讨论这意味着什么，以及为什么对我们很重要。我们将使用Google的地理位置API，并使用Dark
    Sky API来获取像邮政编码这样的位置信息，并将其转换为实时的天气信息。
- en: Then, we'll start wiring up that forecast API, fetching real-time weather data
    for the address that's geocoded. We'll add our request inside of the callback
    for `geocodeAddress`. This will let us take that dynamic set of latitude and longitude
    coordinates, the `lat`/`lng` for the address used in the arguments list, and fetch
    the weather for that location.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将开始连接天气预报API，获取地理编码的地址的实时天气数据。我们将在`geocodeAddress`的回调函数中添加我们的请求。这将让我们使用参数列表中地址的动态经纬度坐标`lat`/`lng`，并获取该位置的天气。
- en: 'Specifically, we''ll look into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将研究以下主题：
- en: Encoding user input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码用户输入
- en: Callback errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调错误
- en: Abstracting callbacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象回调
- en: Wiring up weather search
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接天气搜索
- en: Chaining callbacks together
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接回调
- en: Encoding user input
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码用户输入
- en: In this section, you'll learn how to set up yargs for the weather app. You'll
    also learn how to include user input, which is very important for our application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何为天气应用程序设置yargs。您还将学习如何包含用户输入，这对我们的应用程序非常重要。
- en: As shown in the previous chapter, *HTTPS request* section, the user will not
    type their encoded address into the Terminal; instead they will be typing in a
    plain text address like `1301 Lombard Street`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章节所示，*HTTPS请求*部分，用户不会在终端中输入编码后的地址；相反，他们将输入一个普通文本地址，如`1301 Lombard Street`。
- en: Now this will not work for our URL, we need to encode those special characters,
    like the space, replacing them with `%20`. Now `%20` is the special character
    for the space, other special characters have different encoding values. We'll
    learn how to encode and decode strings, so we can set up our URL to be dynamic.
    It's going to be based off of the address provided in the Terminal. That's all
    we're going to discuss in this section. By the end of the section, you'll be able
    to type in any address you like, and you'll see the formatted address, the latitude,
    and the longitude.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这对我们的URL不起作用，我们需要对这些特殊字符进行编码，比如空格，用`%20`替换它们。现在`%20`是空格的特殊字符，其他特殊字符有不同的编码值。我们将学习如何对字符串进行编码和解码，以便设置我们的URL是动态的。它将基于终端提供的地址。这就是我们将在本节讨论的全部内容。在本节结束时，您将能够输入任何您喜欢的地址，并看到格式化的地址、纬度和经度。
- en: Installing yargs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装yargs
- en: 'Before we can get started doing any encoding, we have to get the address from
    the user, and before we can set up yargs we have to install it. In the Terminal,
    we''ll run the `npm install` command, the module name is `yargs`, and we''ll look
    for version 10.1.1, which is the latest version at the time of writing. We''ll
    use the `save` flag to run this installation, as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行任何编码之前，我们必须从用户那里获取地址，而在设置yargs之前，我们必须安装它。在终端中，我们将运行`npm install`命令，模块名称是`yargs`，我们将寻找10.1.1版本，这是写作时的最新版本。我们将使用`save`标志来运行此安装，如下面的截图所示：
- en: '![](img/156cf3a2-81f0-4235-ad5d-681739b3e2bd.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/156cf3a2-81f0-4235-ad5d-681739b3e2bd.png)'
- en: Now the `save` flag is great because as you remember. It updates the `package.json`
    file and that's exactly what we want. This means that we can get rid of the node
    modules folder which takes up a ton of space, but we can always regenerate it
    using `npm install`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`save`标志很棒，因为你记得。它会更新`package.json`文件，这正是我们想要的。这意味着我们可以摆脱占用大量空间的node模块文件夹，但我们总是可以使用`npm
    install`重新生成它。
- en: If you run `npm install` without anything else, no other module names or flags.
    It will dig through that `package.json` file looking for all the modules to install,
    and it will install them, recreating your node modules folder exactly as you left
    it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只运行`npm install`，不加其他模块名称或标志。它将通过`package.json`文件查找要安装的所有模块，并安装它们，将你的node模块文件夹恢复成你离开时的样子。
- en: 'While the installation is going on, we do a bit of configuration in the `app.js`
    file. So we can get started by first loading in yargs. For this, in the `app.js`
    file, next to request constant, I''ll make a constant called `yargs`, setting
    it equal to `require(yargs)` just like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，我们在`app.js`文件中进行了一些配置。因此，我们可以首先加载yargs。为此，在`app.js`文件中，在请求常量旁边，我将创建一个名为`yargs`的常量，将其设置为`require(yargs)`，就像这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can go ahead and actually do that configuration. Next we''ll make another
    constant called `argv`. This will be the object that stores the final parsed output.
    That will take the input from the process variable, pass it through `yargs`, and
    the result will be right here in the `argv` constant. This will get set equal
    to `yargs`, and we can start adding some calls:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行配置。接下来我们将创建另一个常量叫做`argv`。这将是存储最终解析输出的对象。它将从process变量中获取输入，通过`yargs`处理，结果将直接存储在`argv`常量中。这将被设置为`yargs`，我们可以开始添加一些调用：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now when we created the notes app we had various commands, you could add a note
    and that required some arguments, list a note which required just the title, list
    all notes which didn't require any arguments, and we specified all of that inside
    of `yargs`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建笔记应用程序时，有各种命令，您可以添加一个需要一些参数的笔记，列出一个只需要标题的笔记，列出所有不需要任何参数的笔记，并且我们在 `yargs`
    中指定了所有这些。
- en: 'For the weather app the configuration will be a lot simpler. There is no command,
    the only command would be get weather, but if we only have one why even make someone
    type it. In our case, when a user wants to fetch the weather all they will do
    is type `node app.js` followed by the `address` flag just like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 天气应用程序的配置将会简单得多。没有命令，唯一的命令将是获取天气，但如果我们只有一个命令，为什么还要让用户输入呢。在我们的情况下，当用户想要获取天气时，他们只需输入
    `node app.js`，然后跟上 `address` 标志，就像这样：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then they can type their address inside of quotes. In my case it could be something
    like `1301 lombard street`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们可以在引号内输入他们的地址。在我的情况下，可能是 `1301 lombard street`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is exactly how the command will get executed. There's no need for an actual
    command like fetch weather, we go right from the file name right into our arguments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是命令将被执行的方式。不需要像获取天气这样的实际命令，我们直接从文件名进入我们的参数。
- en: Configuring yargs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 yargs
- en: 'To configure yargs, things will look a little different but still pretty similar.
    In the Atom, I''ll get started by calling `.options`, which will let us configure
    some top level options. In our case, we''ll pass in an object where we configure
    all of the options we need. Now I''ll format this like I do for all of my chained
    calls, where I move the call to the next line and I indent it like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 yargs，事情看起来会有点不同，但仍然非常相似。在 Atom 中，我将开始调用 `.options`，这将让我们配置一些顶级选项。在我们的情况下，我们将传入一个对象，其中我们配置所有我们需要的选项。现在我将像我对所有链接调用所做的那样格式化它，将调用移到下一行，并将其缩进，就像这样：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can set up our options and in this case we just have one, it will be
    that `a` option; `a` will be short for address. I could either type address in
    the options and I could put `a` in the alias, or I could put `a` in the options
    and type address in the alias. In this case I''ll put a as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置我们的选项，在这种情况下我们只有一个，那就是 `a` 选项；`a` 将是地址的缩写。我可以在选项中输入地址，然后在别名中输入 `a`，或者我可以在选项中输入
    `a`，然后在别名中输入地址。在这种情况下，我将像这样输入 a：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next up, I can go ahead and provide that empty object, and we''ll go through
    these same exact options we used inside of the notes app. We will demand it. If
    you''ll fetch the weather we need an address to fetch the weather for, so I''ll
    set `demand` equal to `true`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我可以继续提供那个空对象，然后我们将通过与笔记应用程序中使用的完全相同的选项进行。我们将要求它。如果您要获取天气，我们需要一个地址来获取天气，所以我将设置
    `demand` 等于 `true`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next up, we can set an `alias`, I''ll set `alias` equal to `address`. Then
    finally we''ll set `describe`, we can set `describe` to anything we think would
    be useful, in this case I''ll go with `Address to fetch weather for`, as shown
    here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以设置一个 `alias`，我将把 `alias` 设置为 `address`。最后我们将设置 `describe`，我们可以将 `describe`
    设置为任何我们认为有用的东西，在这种情况下，我将选择 `Address to fetch weather for`，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now these are the three options we provided for the notes app, but I''ll add
    a fourth one to make our yargs configuration for the weather app even more full
    proof. This will be an option called `string`. Now `string` takes a Boolean either
    `true` or `false`. In our case we want `true` to be the value. This tells `yargs`
    to always parse the `a` or `address` argument as a string, as opposed to something
    else like a number or a Boolean:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们为笔记应用程序提供的三个选项，但我将添加第四个选项，以使我们的天气应用程序的 yargs 配置更加完善。这将是一个名为 `string` 的选项。现在
    `string` 接受一个布尔值，要么是 `true` 要么是 `false`。在我们的情况下，我们希望值为 `true`。这告诉 `yargs` 始终将
    `a` 或 `address` 参数解析为字符串，而不是其他类型，比如数字或布尔值：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the Terminal, if I were to delete the actual string `address`, `yargs` would
    still accept this, it would just think I'm trying to add a Boolean flag, which
    could be useful in some situations. For example, do I want to fetch in Celsius
    or in Fahrenheit? But in our case, we don't need any sort of `true` or `false`
    flag, we need some data, so we'll set string to true to make sure we get that
    data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，如果我删除实际的字符串 `address`，`yargs` 仍然会接受它，它只会认为我正在尝试添加一个布尔标志，在某些情况下可能很有用。例如，我想要以摄氏度还是华氏度获取？但在我们的情况下，我们不需要任何
    `true` 或 `false` 标志，我们需要一些数据，所以我们将字符串设置为 `true`，以确保我们获得这些数据。
- en: 'Now that we have our options configuration in place, we can go ahead and add
    a couple other calls that we''ve explored. I''ll add `.help`, calling it as shown
    in the following code, which adds the `help` flag. This is really useful especially
    when someone is first using a command. Then we can access `.argv`, which takes
    all of this configuration, runs it through our arguments, and restores the result
    in the `argv` variable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了选项配置，我们可以继续添加我们已经探索过的一些其他调用。我将添加 `.help`，如下面的代码所示，调用它将添加 `help` 标志。这在某人第一次使用命令时非常有用。然后我们可以访问
    `.argv`，它接受所有这些配置，通过我们的参数运行它，并将结果存储在 `argv` 变量中：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now the `help` method adds that `help` argument, we can also add an alias for
    it right afterwards by calling `.alias`. Now `.alias` takes two arguments, the
    actual argument that you want to set an alias for and the alias. In our case,
    we already have `help` registered, it gets registered when we call `help`, and
    we''ll set an alias which will just be the letter `h`, awesome:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `help` 方法添加了 `help` 参数，我们还可以通过调用 `.alias` 来添加它的别名。现在 `.alias` 接受两个参数，您要为其设置别名的实际参数和别名。在我们的情况下，当我们调用
    `help` 时，已经注册了 `help`，我们将设置一个别名，它将只是字母 `h`，很棒：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we have all sorts of really great configurations set up for the weather
    app. For example, inside the Terminal I can now run `help`, and I can see all
    of the help information for this application:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了各种非常好的配置，例如，在终端中，我现在可以运行 `help`，并且可以看到这个应用程序的所有帮助信息：
- en: '![](img/dd9c75d0-680d-48a5-90ec-e92f63354ea7.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd9c75d0-680d-48a5-90ec-e92f63354ea7.png)'
- en: 'I could also use the shortcut `-h`, and I get the exact same data back:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以使用快捷键`-h`，然后我会得到完全相同的数据：
- en: '![](img/e32d8d46-d22c-4e84-89df-1a2653e8ad44.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e32d8d46-d22c-4e84-89df-1a2653e8ad44.png)'
- en: Printing the address to screen
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将地址打印到屏幕上
- en: 'Now the address is also getting passed through but we don''t print it to the
    screen, so let''s do that. Right after the configuration, let''s use `console.log`
    to print the entire `argv` variable to the screen. This will include everything
    that got parsed by `yargs`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在地址也被传递了，但我们没有将其打印到屏幕上，所以让我们这样做。在配置之后，让我们使用`console.log`将整个`argv`变量打印到屏幕上。这将包括`yargs`解析的所有内容：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s go ahead and rerun it in the Terminal, this time passing in an address.
    I''ll use the `a` flag, and specifying something like `1301 lombard street`, closing
    the quotes, and hitting *enter*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在终端中重新运行它，这次传入一个地址。我会使用`a`标志，并指定类似`1301 lombard street`的内容，然后关闭引号，按*enter*：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we do this we get our object, and as shown in the code output, we have
    1301 Lombard St, Philadelphia, PA 19147, USA, the plain text address:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们得到了我们的对象，并且如代码输出所示，我们有1301 Lombard St, Philadelphia, PA 19147, USA，纯文本地址：
- en: '![](img/1dde3911-17c4-4789-8bd6-b79856e7ee36.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dde3911-17c4-4789-8bd6-b79856e7ee36.png)'
- en: In the preceding screenshot, notice that we happen to fetch the latitude and
    longitude for that address, but that's just because we have it hard coded in the
    URL in `app.js`. We still need to make some changes in order to get the address,
    the one that got typed inside the argument, to be the address that shows up in
    the URL.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，请注意我们恰好获取了该地址的纬度和经度，但这只是因为我们在`app.js`中的URL中硬编码了它。为了让在URL中显示的地址是在参数中输入的地址，我们仍然需要做一些更改。
- en: Encoding and decoding the strings
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码和解码字符串
- en: 'To explore how to encode and decode strings we''ll head into the Terminal.
    Inside the Terminal, first we''ll clear the screen using the `clear` command,
    and then we boot up a node process by typing the `node` command as shown:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索如何对字符串进行编码和解码，我们将进入终端。在终端中，首先我们将使用`clear`命令清除屏幕，然后通过输入`node`命令启动一个节点进程，如下所示：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we can run any statements we like. When we're exploring a really basic
    node or JavaScript feature, we'll look into some examples first, and then we go
    ahead and add it into our actual application. We'll look at two functions, `encodeURIComponent`
    and `decodeURIComponent`. We'll get started with encoding first.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以运行任何我们喜欢的语句。当我们探索一个非常基本的节点或JavaScript功能时，我们首先会查看一些示例，然后再将其添加到我们的实际应用程序中。我们将查看两个函数，`encodeURIComponent`和`decodeURIComponent`。我们将首先开始编码。
- en: Encoding URI component
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码URI组件
- en: 'Encoding, the method is called `encodeURIComponent`, encode URI in uppercase
    component, and it takes just one argument, the string you want to encode. In our
    case, that string will be the address, something like `1301 lombard street philadelphia`.
    When we run this address through `encodeURIComponent` by hitting *enter*, we get
    the encoded version back:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编码，该方法称为`encodeURIComponent`，将URI组件编码为大写，并且只需要一个参数，即要编码的字符串。在我们的情况下，该字符串将是地址，类似于`1301
    lombard street philadelphia`。当我们通过`encodeURIComponent`运行这个地址，我们得到编码版本：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As shown in the following code output, we can see all the spaces, like the space
    between 1301 and lombard, have been replaced with their encoded character, and
    for the case of the space it is %20\. By passing our string through `encodeURIComponent`,
    we'll create something that's ready to get injected right into the URL so we can
    fire off that dynamic request.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的代码输出所示，我们可以看到所有的空格，比如1301和lombard之间的空格，都被替换为它们的编码字符，对于空格的情况，它是%20。通过`encodeURIComponent`传递我们的字符串，我们将创建一个准备好被注入到URL中的内容，以便我们可以发出动态请求。
- en: '![](img/4ac17918-e2f3-4184-a815-3a8a08346cf0.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ac17918-e2f3-4184-a815-3a8a08346cf0.png)'
- en: Decoding URI component
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码URI组件
- en: Now the alternative to `encodeURIComponent` is. This will take an encoded string
    like the one in the previous example, and take all the special characters, like
    `%20`, and convert them back into their original values, in this case space. For
    this, inside of `decodeURIComponent` once again we'll pass a string.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`encodeURIComponent`的替代方法是。这将接受一个编码的字符串，就像前面的例子中一样，并将所有特殊字符，比如`%20`，转换回它们的原始值，即空格。为此，在`decodeURIComponent`中，我们再次传递一个字符串。
- en: 'Let''s go ahead and type our first and last name. In my case it''s `Andrew`,
    and instead of a space between them I''ll add `%20`, which we know is the encoded
    character for a space. Since we''re trying to decode something, it''s important
    to have some encoded characters here. Once yours looks like the following code
    with your first and last name, you can go ahead and hit *enter*, and what we get
    back is the decoded version:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续输入我们的名字和姓氏。在我的情况下，是`Andrew`，而不是它们之间的空格，我会添加`%20`，我们知道这是空格的编码字符。由于我们正在尝试解码一些内容，这里有一些编码字符是很重要的。一旦你的代码看起来像下面的代码，带有你的名字和姓氏，你可以继续按*enter*，然后我们得到的是解码版本：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As shown in the following code output, I have Andrew Mead with the `%20` being
    replaced by the space, exactly what we expected. This is how we can encode and
    decode URI components in our app:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的代码输出所示，我有Andrew Mead，`%20`被空格替换，正是我们预期的。这就是我们如何在我们的应用程序中对URI组件进行编码和解码：
- en: '![](img/51ce6a42-36f4-41c9-b256-f15defda1d8f.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51ce6a42-36f4-41c9-b256-f15defda1d8f.png)'
- en: Pulling the address out of argv
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从argv中提取地址
- en: 'Now what we want to do is pull the address out of `argv`, we already saw that
    it''s there, we want to encode it and we want to inject it in our URL in `app.js`
    file, replacing the address:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要从`argv`中提取地址，我们已经看到它在那里，我们想要对其进行编码，并且我们想要将其注入到`app.js`文件中的URL中，替换地址：
- en: '![](img/96f8070c-683c-408c-b92c-10a215cc04a7.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96f8070c-683c-408c-b92c-10a215cc04a7.png)'
- en: This will essentially create that dynamic request we've been talking about.
    We'll be able to type in any address we want, whether it's an address or a zip
    code or a city state combination, and we'll be able to fetch the formatted address,
    the latitude, and the longitude.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将基本上创建我们一直在谈论的动态请求。我们将能够输入任何地址，无论是地址、邮政编码还是城市州组合，我们都将能够获取格式化的地址、纬度和经度。
- en: In order to get started, the first thing I'll do is get the encoded address.
    Let's make a variable called `encodedAddress` in the `app.js` next to the `argv`
    variable, where we can store that result. We'll set this equal to the return value
    from the method we just explored in the Terminal, `encodeURIComponent`. This will
    take the plain text address and return the encoded result.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我将首先获取编码后的地址。让我们在`app.js`中创建一个名为`encodedAddress`的变量，放在`argv`变量旁边，我们可以在其中存储结果。我们将把这个变量设置为我们刚刚在终端中探索的方法的返回值，`encodeURIComponent`。这将获取纯文本地址并返回编码后的结果。
- en: 'Now we do need to pass in the string, and we have that available on `argv.address`
    which is the alias:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要传入字符串，并且我们可以在`argv.address`中找到它，这是别名：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we could use `argv.a` as well as `argv.address`, both will work the same.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用`argv.a`以及`argv.address`，两者都可以正常工作。
- en: Now we have that encoded result all that's left to do is inject it inside of
    the URL string. In the `app.js`, currently we're using a regular string. We'll
    swap this out for a template string so I can inject a variable inside of it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了编码的结果，剩下的就是将其注入到URL字符串中。在`app.js`中，我们目前使用的是普通字符串。我们将其替换为模板字符串，这样我就可以在其中注入变量。
- en: 'Now that we have a template string, we can highlight the static address which
    ends at `philadelphia` and goes up to the `=` sign, and remove it, and instead
    of typing in a static address we can inject the dynamic variable. Inside of my
    curly braces, `encodedAddress`, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模板字符串，我们可以突出显示静态地址，它在`philadelphia`结束并延伸到`=`号，然后将其删除，而不是输入静态地址，我们可以注入动态变量。在我的花括号内，`encodedAddress`，如下所示：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this in place we are now done. We get the address from the Terminal, we
    encode it, and we use that inside of a `geocode` call. So the formatted address,
    latitude, and longitude should match up. Inside the Terminal, we'll shut down
    node by using *control* + *C* twice and use clear to clear the Terminal output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在完成了。我们从终端获取地址，对其进行编码，并在`geocode`调用中使用。因此，格式化的地址、纬度和经度应该匹配。在终端中，我们将使用*control*
    + *C*两次关闭node，并使用clear清除终端输出。
- en: 'Then we can go ahead and run our app using `node app.js`, passing in either
    the `a` or `address` flag. In this case, we''ll just use `a`. Then we can go ahead
    and type in an address, for example, `1614 south broad street philadelphia` as
    shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`node app.js`运行我们的应用，传入`a`或`address`标志。在这种情况下，我们将只使用`a`。然后我们可以输入一个地址，例如`1614
    south broad street philadelphia`，如下所示：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When you run it you should have that small delay while we fetch the data from
    the geocode URL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你应该会有一个小延迟，当我们从地理编码URL获取数据时。
- en: 'In this case we''ll find that it''s actually taking a little longer than we
    would expect, about three or four seconds, but we do get the address back:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们会发现它实际上比我们预期的要慢一点，大约三到四秒，但我们确实得到了地址：
- en: '![](img/5f86d2f0-ed20-4a97-a21c-1e9fae8c8d83.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f86d2f0-ed20-4a97-a21c-1e9fae8c8d83.png)'
- en: 'Here we have the formatted address with a proper zip code state and country,
    and we also have the latitude and longitude showing up. We''ll try a few other
    examples. For example for a town in Pennsylvania called Chalfont, we can type
    in `chalfont pa` which is not a complete address, but the Google Geocode API will
    convert it into the closest thing, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个格式化的地址，包括正确的邮政编码、州和国家，还有显示经纬度。我们将尝试一些其他例子。例如，对于宾夕法尼亚州的一个名叫查尔方特的小镇，我们可以输入`chalfont
    pa`，这并不是一个完整的地址，但是谷歌地理编码API会将其转换为最接近的地址，如下所示：
- en: '![](img/e0c920a5-202c-4ddd-8786-456e04217af5.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0c920a5-202c-4ddd-8786-456e04217af5.png)'
- en: We can see that it's essentially the address of the town, Chalfont, PA 18914
    is the zip, with the state USA. Next, we have the general latitude and longitude
    data for that town, and this will be fine for fetching weather data. The weather
    isn't exactly changing when you move a few blocks over.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这实际上是查尔方特镇的地址，邮编为18914，所在州为美国。接下来，我们有该镇的一般纬度和经度数据，这对获取天气数据将很有用。天气在几个街区内并不会有太大变化。
- en: Now that we have our data coming in dynamically, we are able to move on to the
    next section where we'll handle a lot of the errors that happen inside of callbacks.
    There are a lot of ways this request can go wrong, and we'll want to figure out
    how to recover from errors inside of our callback functions when we're doing asynchronous
    programming.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数据是动态获取的，我们可以继续下一节，处理回调函数中发生的错误。这个请求有很多可能出错的地方，我们需要弄清楚如何在异步编程中从回调函数中恢复错误。
- en: Callback errors
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调错误
- en: 'In this section we''ll learn how to handle errors inside of your callback functions,
    because as you might guess things don''t always go as planned. For example, the
    current version of our app has a few really big flaws, if I try to fetch weather
    using `node app.js` with the `a` flag for a zip that doesn''t exist, like `000000`,
    the program crashes, which is a really big problem. It''s going off. It''s fetching
    the data, eventually that data will come back and we get an error, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何处理回调函数中的错误，因为正如你可能猜到的那样，事情并不总是按计划进行。例如，我们的应用的当前版本存在一些很大的缺陷，如果我尝试使用`node
    app.js`来获取天气，使用`a`标志输入一个不存在的邮政编码，比如`000000`，程序会崩溃，这是一个很大的问题。它正在进行。它正在获取数据，最终数据会返回并且我们会得到一个错误，如下所示：
- en: '![](img/e68227c6-de88-4db7-9b5f-7e0af311d56a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e68227c6-de88-4db7-9b5f-7e0af311d56a.png)'
- en: It's trying to fetch properties that don't exist, such as `body.results[0].formatted_address`
    is not a real property, and this is a big problem.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图获取不存在的属性，比如`body.results[0].formatted_address`不是一个真实的属性，这是一个大问题。
- en: Our current callback expects everything went as planned. It doesn't care about
    the error object, doesn't look at response codes; it just starts printing the
    data that it wants. This is the happy path, but in real world node apps we have
    to handle errors as well otherwise the applications will become really useless,
    and a user can get super frustrated when things don't seem to be working as expected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的回调期望一切都按计划进行。它不关心错误对象，也不关注响应代码；它只开始打印它想要的数据。这是快乐的路径，但在现实世界的node应用程序中，我们也必须处理错误，否则应用程序将变得非常无用，当事情似乎不如预期工作时，用户可能会变得非常沮丧。
- en: In order to do this, we'll add a set of `if`/`else` statements inside of the
    callback. This will let us check certain properties to determine whether or not
    this call, the one to our URL in the `app.js`, should be considered a success
    or a failure. For example, if the response code is a 404, we might want to consider
    that a failure and we'll want to do something other than trying to print the address,
    latitude and longitude. If everything went well though, this is a perfectly reasonable
    thing to do.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在回调函数中添加一组`if`/`else`语句。这将让我们检查某些属性，以确定这次调用，即我们在`app.js`中的URL，是否应该被视为成功或失败。例如，如果响应代码是404，我们可能希望将其视为失败，并且我们将要做一些事情，而不是尝试打印地址、纬度和经度。不过，如果一切顺利，这是一个完全合理的做法。
- en: 'There are two types of errors that we''ll worry about in this section. That
    will be:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Google API请求中的错误
- en: The machine errors, things like being unable to connect to a network, these
    are usually will show up in the error object, and
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器错误，例如无法连接到网络，通常会显示在错误对象中，
- en: The errors coming from the other server, the Google server, this could be something
    like an invalid address
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自其他服务器，Google服务器的错误，这可能是无效的地址
- en: In order to get started, let's take a look at what can happen when we pass a
    bad data to the Google API.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们看看当我们向Google API传递错误数据时会发生什么。
- en: Checking error in Google API request
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![](img/6c6cf191-835b-435f-99bd-823a33746850.png)'
- en: 'To view what actually comes back in a call like the previous example, where
    we have an invalid address, we''ll head over to the browser and pull up the URL
    we used in the `app.js` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看像之前的示例调用返回的实际内容，其中我们有一个无效地址，我们将转到浏览器并打开我们在`app.js`文件中使用的URL：
- en: '![](img/6c6cf191-835b-435f-99bd-823a33746850.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: 在本节中，我们将担心两种类型的错误。那将是：
- en: 'We will remove the address we used earlier from the browser history, and type
    in `000000`, hit *enter*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从浏览器历史记录中删除之前使用的地址，并输入`000000`，然后按*enter*：
- en: '![](img/bc168f1e-1ff6-46aa-b1a9-b929a40c5166.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc168f1e-1ff6-46aa-b1a9-b929a40c5166.png)'
- en: 'We get our results arrive but those are no results, and we have the status,
    the status says `ZERO_RESULTS`, and this is the kind of information that''s really
    important to track down. We can use the status text value to determine whether
    or not the request was successful. If we pass in a real zip code like `19147`,
    which is `Philadelphia`, we''ll get our results back, and as shown in the following
    image, the `status` will get set equal to `OK`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了结果，但没有结果，状态显示`ZERO_RESULTS`，这是非常重要的信息。我们可以使用状态文本值来确定请求是否成功。如果我们传入一个真实的邮政编码，比如`19147`，它是`费城`，我们将得到我们的结果，如下图所示，`status`将被设置为`OK`：
- en: '![](img/48300c3e-0bab-46fe-843a-2a2fddbdd26e.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48300c3e-0bab-46fe-843a-2a2fddbdd26e.png)'
- en: We can use this status to determine that things went well. Between these status
    property and the error object, which we have inside of our app, we can determine
    what exactly to do inside of the callback.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个状态来确定事情进行得很顺利。在这些状态属性和我们应用程序中的错误对象之间，我们可以确定在回调函数中究竟要做什么。
- en: Adding the if statement for callback errors
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加回调错误的if语句
- en: 'The first thing we''ll do is add an `if` statement as shown below, checking
    if the error object exists:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是添加一个如下所示的`if`语句，检查错误对象是否存在：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will run the code inside of our code block if the error object exists,
    if it doesn't fine, we'll move on into the next `else if` statement, if there
    is any.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误对象存在，这将运行我们代码块中的代码，如果不存在，我们将继续进入下一个`else if`语句，如果有的话。
- en: 'If there is an error, all we''ll do is add a `console.log` and a message to
    the screen, something like `Unable to connect to Google servers`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，我们只会添加一个`console.log`和一个屏幕消息，类似于`无法连接到Google服务器`：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will let the user know that we were unable to connect to the user servers,
    not that something went wrong with their data, like the address was invalid. This
    is what be inside of the error object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让用户知道我们无法连接到用户服务器，而不是他们的数据出了问题，比如地址无效。这就是错误对象中的内容。
- en: 'Now the next thing that we''ll do is add an `else if` statement, and inside
    of the condition we''ll check the status property. If the status property is `ZERO_RESULTS`,
    which it was for the zip code `000000`, we want to do something other than trying
    to print the address. Inside of our conditional in Atom, we can check that using
    the following statement:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的下一件事是添加一个`else if`语句，并在条件中检查状态属性。如果状态属性是`ZERO_RESULTS`，就像邮政编码`000000`一样，我们希望做一些事情，而不是尝试打印地址。在Atom中的我们的条件中，我们可以使用以下语句进行检查：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If that''s the case, we''ll print a different message, other than `Unable to
    connect Google servers`, for this one we can use `console.log` to print `Unable
    to find that address.`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，我们将打印一个不同的消息，而不是`无法连接到Google服务器`，对于这个消息，我们可以使用`console.log`打印`无法找到该地址。`：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This lets the user know that it wasn't a problem with the connection, we were
    just unable to find the address they provided, and they should try with something
    else.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这让用户知道这不是连接的问题，我们只是无法找到他们提供的地址，他们应该尝试其他的东西。
- en: Now we have error handling for those system errors, like being unable to connect
    to the Google servers, and for errors with the input, in this case we're unable
    to find a location for that address, and this is fantastic, we have both of our
    errors handled.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了系统错误的错误处理，比如无法连接到Google服务器，以及输入错误的错误处理，在这种情况下，我们无法找到该地址的位置，这太棒了，我们已经处理了我们的两个错误。
- en: Now the `body.status` property that shows up in the `else if` statement, is
    not going to be on every API, this is specific to the Google Geocode API. When
    you explore a new API it's important to try out all sorts of data, good data like
    a real address and bad data like an invalid zip code, to see exactly what properties
    you can use to determine whether or not the request was successful, or if it failed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`body.status`属性出现在`else if`语句中，这不会出现在每个API中，这是特定于Google Geocode API的。当您探索新的API时，重要的是尝试各种数据，好的数据，比如真实地址和坏的数据，比如无效的邮政编码，以确定您可以使用哪些属性来确定请求是否成功，或者是否失败。
- en: In our case, if the status is `ZERO_RESULTS`, we know the request failed and
    we can act accordingly. Inside of our `app`, now we'll add our last `else if`
    clause, if things went well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，如果状态是`ZERO_RESULTS`，我们知道请求失败了，我们可以相应地采取行动。在我们的`app`中，现在我们将添加我们的最后一个`else
    if`子句，如果事情进展顺利。
- en: Adding if else statement to check body status property
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在检查body状态属性时添加if else语句
- en: 'Now we want to add the `else if` clause checking if the `body.status` property
    equals `OK`. If it does, we can go ahead and run these three lines inside of the
    code block:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要添加`else if`子句，检查`body.status`属性是否等于`OK`。如果是，我们可以继续运行代码块内的这三行代码：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If it doesn't, these lines shouldn't run because the code block will not execute.
    Then we'll test things out inside of the Terminal, try to fetch the address of
    `00000`, and make sure that instead of the program crashing we get our error message
    printing to the screen. Then we go ahead and mess up the URL in the app by removing
    some of the important characters, and make sure this time we get the `Unable to
    connect to the Google servers.` message. And last we'll see what happens when
    we enter a valid address, and make sure our three `console.log` statements still
    execute.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，这些行不应该运行，因为代码块不会执行。然后我们将在终端内测试一下，尝试获取`00000`的地址，并确保程序不会崩溃，而是打印我们的错误消息到屏幕上。然后我们继续搞砸应用程序中的URL，删除一些重要的字符，并确保这次我们收到`无法连接到Google服务器。`的消息。最后，我们将看看当我们输入一个有效地址时会发生什么，并确保我们的三个`console.log`语句仍然执行。
- en: 'To get started we''ll add that `else if` statement, and inside of the condition
    we''ll check if `body.status` is `OK`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加`else if`语句，并在条件内检查`body.status`是否为`OK`：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If it is `OK`, then we''ll simply take the three `console.log` lines (shown
    in the previous code block) and move them in the `else if` condition. If it is
    `OK`, we''ll run these three `console.log` statements:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是`OK`，那么我们将简单地将三个`console.log`行（在上一个代码块中显示）移到`else if`条件中。如果是`OK`，我们将运行这三个`console.log`语句：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now we have a request that handles errors really well. If anything goes wrong
    we have a special message for it, and if things go right we print exactly what
    the user expects, the address, the latitude, and the longitude. Next we'll test
    this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个非常好处理错误的请求。如果出了问题，我们有一个特殊的消息，如果事情顺利，我们打印用户期望的内容，地址，纬度和经度。接下来我们将测试这个。
- en: Testing the body status property
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试body状态属性
- en: 'To test this inside of the Terminal, we''ll start by rerunning the command
    with an address that''s invalid:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在终端中测试这一点，我们将首先重新运行具有无效地址的命令：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/88293218-c888-4e6d-91ff-6b275377596d.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88293218-c888-4e6d-91ff-6b275377596d.png)'
- en: When we run this command, we see that Unable to find address. prints to the
    screen. Instead of the program crashing, printing a bunch of errors, we simply
    have a little message printing to the screen. This is because the code we have
    in second `else if` statement, that tried to access those properties that didn't
    exist, no longer runs because our first `else if` condition gets caught and we
    simply print the message to the screen.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个命令时，我们看到`无法找到地址。`打印到屏幕上。程序不会崩溃，打印一堆错误，而是简单地在屏幕上打印一条消息。这是因为我们在第二个`else
    if`语句中的代码尝试访问那些不存在的属性，不再运行，因为我们的第一个`else if`条件被捕获，我们只是将消息打印到屏幕上。
- en: 'Now we also want to test that the first message (`Unable to connect to the
    Google servers.`) prints when it should. For this, we''ll delete some part of
    the URl in our code, let''s say, `s` and `.`, and save the file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还想测试第一个消息（`无法连接到Google服务器。`）在应该打印时是否打印。为此，我们将在我们的代码中删除一部分URl，比如`s`和`.`，然后保存文件：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we''ll rerun the previous command in the Terminal. This time around we
    can see `Unable to connect to Google servers.` prints to the screen just like
    it should:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将重新运行终端中的上一个命令。这一次，我们可以看到`无法连接到Google服务器。`像应该一样打印到屏幕上：
- en: '![](img/3677a152-c7e8-40c0-8a6b-98c6ed8e2ce1.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3677a152-c7e8-40c0-8a6b-98c6ed8e2ce1.png)'
- en: 'Now we can test it the final thing, by first readjusting the URL to make it
    correct, and then fetching a valid address from the Terminal. For example, we
    can use the `node app.js`, setting `address` equal to `08822`, which is a zip
    code in New Jersey:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试最后一件事，首先调整URL使其正确，然后从终端获取有效地址。例如，我们可以使用`node app.js`，将`address`设置为`08822`，这是新泽西州的一个邮政编码：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we run this command, we do indeed get our formatted address for Flemington,
    NJ, with a zip code and the state, and we have our latitude and longitude as shown
    here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个命令时，我们确实得到了Flemington, NJ的格式化地址，包括邮政编码和州，我们的纬度和经度如下所示：
- en: '![](img/020794e0-eb20-429a-a2f9-b256419ccd3d.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/020794e0-eb20-429a-a2f9-b256419ccd3d.png)'
- en: We now have a complete error handling model. When we make a request to Google
    providing a address that has problems, in this case there's `ZERO_RESULTS`, the
    error object will get populated, because it's not technically an error in terms
    of what request thinks an error is, it's actually in the response object, which
    is why we have to use `body.status` in order to check the error.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了完整的错误处理模型。当我们向谷歌提供有问题的地址时，比如`ZERO_RESULTS`，错误对象将被填充，因为从请求的角度来看，这不是一个错误，实际上它在响应对象中，这就是为什么我们必须使用`body.status`来检查错误。
- en: That is it for this section, we now have error handling in place, we handle
    system errors, Google server errors, and we have our success case.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本节的内容，我们现在已经有了错误处理，我们处理系统错误，谷歌服务器错误，还有我们的成功案例。
- en: Abstracting callbacks
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象回调
- en: 'In this section, we''ll be refactoring `app.js`, taking a lot of the complex
    logic related to geocoding and moving it into a separate file. Currently, all
    of the logic for making the request and determining whether or not the request
    succeeded, our `if else` statements, live inside of `app.js`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将重构`app.js`，将与地理编码相关的复杂逻辑移动到一个单独的文件中。目前，所有与发出请求和确定请求是否成功相关的逻辑，我们的`if
    else`语句，都存在于`app.js`中：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is not exactly reusable and it really doesn't belong here. What I'd like
    to do before we add even more logic related to fetching the forecast, that's the
    topic of the next section, is break this out into its own function. This function
    will live in a separate file, like we did for the notes application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是可以重复使用的，而且它真的不属于这里。在我们添加更多与获取天气预报相关的逻辑之前，我想要做的是把这部分代码拆分成自己的函数。这个函数将会存在于一个单独的文件中，就像我们为笔记应用程序所做的那样。
- en: In the `notes app` we had a separate file that had functions for adding, listing,
    and removing notes from our local adjacent file. We'll be creating a separate
    function responsible for geocoding a given address. Although the logic will stay
    the same, there really is no way around it, it will be abstracted out of the `app.js`
    file and into its own location.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`notes app`中，我们有一个单独的文件，其中有用于添加、列出和从我们的本地相邻文件中删除笔记的函数。我们将创建一个单独的函数，负责对给定地址进行地理编码。尽管逻辑将保持不变，实际上是没有办法绕过它的，它将被从`app.js`文件中抽象出来，并放到自己的位置中。
- en: Refactoring app.js and code into geocode.js file
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构app.js和代码到geocode.js文件
- en: First up, we will need to create a new directory and a new file then we'll add
    a few more advanced features to the function. But before that, we'll see what
    the require statement will look like.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的目录和一个新的文件，然后我们将为该函数添加一些更高级的功能。但在此之前，我们将看看require语句会是什么样子。
- en: Working on request statement
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求语句
- en: 'We''ll load in via a constant variable called `geocode` the module, and we''ll
    set it equal to `require`, since we''re requiring a local file we''ll add that
    relative path, `./geocode/geocode.js`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个名为`geocode`的常量变量加载模块，并将其设置为`require`，因为我们需要一个本地文件，所以我们会添加相对路径，`./geocode/geocode.js`：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That means you need to make a directory called `geocode` in the `weather-app`
    folder, and a file called `geocode.js`. Since we have a `.js` extension, we can
    actually leave it off of our require call.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要在`weather-app`文件夹中创建一个名为`geocode`的目录，以及一个名为`geocode.js`的文件。因为我们有一个`.js`扩展名，所以我们实际上可以在我们的require调用中省略它。
- en: 'Now, in the `app.js` file, next to `.argv` object, we need to call `geocode.geocodeAddress`.
    The `geocodeAddress` function, that will be the function responsible for all the
    logic we currently have in `app.js`. The `geocodeAddress` function will take the
    address, `argv.address`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`app.js`文件中，紧挨着`.argv`对象，我们需要调用`geocode.geocodeAddress`。`geocodeAddress`函数，它将负责`app.js`中当前所有逻辑。`geocodeAddress`函数将获取地址，`argv.address`：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It will be responsible for doing everything, encoding the URL, making the request,
    and handling all of the error cases. This means, in that new file we need to export
    the `geocodeAddress` function, just like we exported functions from the `notes
    application` file. Next, we have all of the logic here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它将负责做所有事情，编码URL，发出请求，并处理所有错误情况。这意味着在新文件中，我们需要导出`geocodeAddress`函数，就像我们从`notes
    application`文件中导出函数一样。接下来，我们在这里有所有的逻辑：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This logic needs to get moved inside of the `geocodeAddress` function. Now we
    can copy and paste the preceding shown code directly, there really is no way around
    some of the more complex logic, but we will need to make a few changes. We'll
    need to load requests into that new file, since we use it and it isn't going to
    be required in that file by default. Then we can go ahead and clean up the request
    require call in the code, since we won't be using it in this file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑需要被移动到`geocodeAddress`函数中。现在我们可以直接复制并粘贴上面显示的代码，有些更复杂的逻辑确实无法避免，但我们需要做一些改变。我们需要将请求加载到新文件中，因为我们使用了它，而且它不会在默认情况下被该文件所需。然后我们可以继续清理代码中的请求调用，因为我们不会在这个文件中使用它。
- en: Next up, the `argv` object is not going to exist, we'll get that passed in via
    the first argument, just like the `argv.address` in the `geocode.Address` statement.
    This means we'll need to swap this out for whatever we call that first argument
    for example, address. Once this is done, the program should work exactly as it
    works without any changes in `app.js`, there should be no change in functionality.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`argv`对象将不再存在，我们将通过第一个参数传递进来，就像`geocode.Address`语句中的`argv.address`一样。这意味着我们需要用我们称呼第一个参数的任何东西来替换它，比如address。一旦这样做了，程序应该会和在`app.js`中没有任何更改的情况下一样工作，功能上不应该有任何改变。
- en: Creating geocode file
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建地理编码文件
- en: 'To get started, let''s make a brand new directory in the `weather-app` folder,
    that''s the first thing we need to do. The directory is called `geocode`, which
    aligns with the require statement we have in the `geocode` variable. In `geocode`
    folder, we''ll make our file `geocode.js`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`weather-app`文件夹中创建一个全新的目录，这是我们需要做的第一件事。这个目录叫做`geocode`，与我们在`geocode`变量中的require语句相匹配。在`geocode`文件夹中，我们将创建我们的文件`geocode.js`：
- en: '![](img/9e0d6ccb-5aa4-4944-8978-897aac4e8cdd.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e0d6ccb-5aa4-4944-8978-897aac4e8cdd.png)'
- en: 'Now inside of `geocode.js`, we can get started by loading in request, let''s
    make a constant called `request`, and we''ll set it equal to `require(''request'')`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`geocode.js`中，我们可以开始加载请求，让我们创建一个名为`request`的常量，并将其设置为`require('request')`：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we can go ahead and define the function responsible for geocoding, this
    one will be called `geocodeAddress`. We''ll make a variable called `geocodeAddress`,
    setting it equal to an arrow function, and this arrow function will get an `address`
    argument past in:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续定义负责地理编码的函数，这个函数将被称为`geocodeAddress`。我们将创建一个名为`geocodeAddress`的变量，将其设置为一个箭头函数，并且这个箭头函数将接收一个`address`参数：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is the plain text unencoded address. Now before we copy the code from
    `app.js` into this function body, we want to export our `geocodeAddress` function
    using `module.exports`, which we know as an object. Anything we put on `module.exports`
    object will be available to any files that require this file. In our case, we
    want to make a `geocodeAddress` property available, setting it equal to the `geocodeAddress`
    function that we defined in the preceding statement:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是未编码的纯文本地址。现在在将代码从`app.js`复制到此函数体之前，我们要使用`module.exports`导出我们的`geocodeAddress`函数，我们知道它是一个对象。我们放在`module.exports`对象上的任何东西都将对任何需要此文件的文件可用。在我们的情况下，我们希望使`geocodeAddress`属性可用，将其设置为我们在前面的语句中定义的`geocodeAddress`函数：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now it''s time to actually copy all of the code from `app.js` in to `geocode.js`.
    We''ll cut the request function code, move in to `geocode.js`, and paste it inside
    of the body of our function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将`app.js`中的所有代码复制到`geocode.js`中了。我们将剪切请求函数代码，移动到`geocode.js`中，并将其粘贴到我们函数的主体中：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The only thing we need to change inside of this code, is how we get the plaintext
    address. We no longer have that `argv` object, instead we get `address` passed
    in as an argument. The final code will look like the following code block:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们唯一需要更改的是如何获取纯文本地址。我们不再有`argv`对象，而是将`address`作为参数传入。最终的代码将如下代码块所示：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With this in place, we''re now done with the `geocode` file. It contains all
    of the complex logic for making and finishing the request. Over at `app.js`, we
    can clean things up by removing some extra spaces, and removing the request module
    which is no longer used in this file. The final `app.js` file will look like the
    following code block:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在完成了`geocode`文件。它包含了所有复杂的逻辑，用于发出和完成请求。在`app.js`中，我们可以通过删除一些额外的空格和移除不再在此文件中使用的请求模块来清理代码。最终的`app.js`文件将如下代码块所示：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now at this point the functionality should be exactly the same. Inside of the
    Terminal, I''ll go ahead and run a few to confirm the changes worked. We''ll use
    the `a` flag to search for a zip code that does exist, something like `19147`,
    and as shown, we can see the address, the latitude, and the longitude:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这一点上，功能应该完全相同。在终端中，我将继续运行一些来确认更改是否有效。我们将使用`a`标志搜索一个存在的邮政编码，比如`19147`，如图所示，我们可以看到地址、纬度和经度：
- en: '![](img/48c16ab9-b3db-41f7-8b33-1a568c4614ff.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48c16ab9-b3db-41f7-8b33-1a568c4614ff.png)'
- en: 'Now we''ll swap out that zip code to one that does not exist, like `000000`,
    when we run this through the geocoder, you can see Unable to find address prints
    to screen:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这个邮政编码更改为一个不存在的邮政编码，比如`000000`，当我们通过地理编码器运行这个时，你会看到“无法找到地址”打印到屏幕上：
- en: '![](img/88013ae2-3b27-4d13-807b-197612ebf260.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88013ae2-3b27-4d13-807b-197612ebf260.png)'
- en: It means all of the logic inside of `geocode.js` is still working. Now the next
    step in the process is the process of adding a callback function to `geocodeAddress`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`geocode.js`中的所有逻辑仍然有效。现在，下一步是向`geocodeAddress`添加回调函数的过程。
- en: Adding callback function to geocodeAddress
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向geocodeAddress添加回调函数
- en: The goal of refactoring the code and `app.js` was not to get rid of the callback,
    the goal was to abstract all the complex logic related to encoding the data, making
    that request, and checking for errors. `app.js` should not care about any of that,
    it doesn't even need to know that an HTTP request was ever made. All the `app.js`
    should care about is passing an address to the function, and doing something with
    the result. The result being either an error message or the data, the formatted
    address, the latitude, and the longitude.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重构代码和`app.js`的目标不是为了摆脱回调，目标是将与编码数据、发出请求和检查错误相关的所有复杂逻辑抽象出来。`app.js`不应该关心任何这些，它甚至不需要知道是否曾经发出过HTTP请求。`app.js`唯一需要关心的是将地址传递给函数，并对结果进行处理。结果可以是错误消息或数据，格式化的地址、纬度和经度。
- en: Setting up the function in geocodeAddress function in app.js
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在app.js中的geocodeAddress函数中设置函数
- en: 'Before we go ahead and make any changes in `geocode.js`, we want to take a
    look at how we''ll structure things inside of `app.js`. We''ll pass an arrow function
    to `geocodeAddress`, and this will get called after the request comes back:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续在`geocode.js`中进行任何更改之前，我们要看一下我们将如何在`app.js`中构造事物。我们将向`geocodeAddress`传递一个箭头函数，这将在请求返回后被调用：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the parentheses, we''ll expect two arguments, `errorMessage`, which will
    be a string, and `results`, which will contain the address, the latitude, and
    the longitude:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号中，我们将期望两个参数，`errorMessage`，它将是一个字符串，和`results`，它将包含地址、纬度和经度：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Out of these two only one will be available at a time. If we have an error
    message we''ll not have results, and if we have results we''ll not have an error
    message. This will make the logic in the arrow function, of determining whether
    or not the call succeeded, much simpler. We''ll be able to use an `if` statement,
    `if (errorMessage)`, and if there is an error message, we can simply print it
    to the screen using `console.log` statement:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两者中，只有一个会一次可用。如果我们有错误消息，我们将没有结果，如果我们有结果，我们将没有错误消息。这将使箭头函数中的逻辑，确定调用是否成功，变得更简单。我们将能够使用`if`语句，`if
    (errorMessage)`，如果有错误消息，我们可以简单地使用`console.log`语句将其打印到屏幕上：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's no need to dig into any sort of object and figure out exactly what's
    going on, all of that logic is abstracted in `geocode.js`. Now if there is no
    error message inside of the `else` clause, we can go ahead and print the results.
    We'll use that pretty print method we talked about in the previous chapter, we'll
    add the `console.log(JSON.stringify)` statement, and we'll pretty print the results
    object which will be an object containing an address property, a latitude property,
    and a longitude property.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要深入任何对象并准确了解发生了什么，所有这些逻辑都在`geocode.js`中抽象出来。现在如果`else`子句中没有错误消息，我们可以继续打印结果。我们将使用我们在上一章中讨论过的漂亮打印方法，我们将添加`console.log(JSON.stringify)`语句，并且漂亮打印结果对象，这个对象将包含一个地址属性、一个纬度属性和一个经度属性。
- en: 'Then, we''ll pass the `undefined` argument as our second argument. This skips
    over the filtering function which we don''t need, and then we can specify the
    spacing, which will format this in a really nice way, we''ll use two spaces as
    shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`undefined`参数作为我们的第二个参数。这跳过了我们不需要的过滤函数，然后我们可以指定间距，这将以一种非常好的方式格式化，我们将使用两个空格，如下所示：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that we have our function set up inside of `geocodeAddress` function in
    `app.js`, and we have a good idea about how it will look, we can go ahead and
    implement it inside of `geocode.js`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`app.js`的`geocodeAddress`函数中设置好了我们的函数，并且对它的外观有了一个很好的想法，我们可以继续在`geocode.js`中实现它。
- en: Implementing the callback function in geocode.js file
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`geocode.js`文件中实现回调函数
- en: In our arguments definition, instead of just expecting an address argument we'll
    also expect a callback argument, and we can call this callback argument whenever
    we like. We'll call it in three places. We'll call it once inside of the `if (error)`
    block, instead of calling `console.log` we'll simply call the callback with the
    `Unable to connect to Google servers.` string. This string will be the error message
    we defined in `geocodeAddress` function in `app.js`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的参数定义中，我们不仅期望一个地址参数，还期望一个回调参数，我们可以在任何时候调用这个回调参数。我们将在三个地方调用它。我们将在`if (error)`块内部调用它一次，而不是调用`console.log`，我们将简单地用`Unable
    to connect to Google servers.`字符串调用回调。这个字符串将是我们在`app.js`中的`geocodeAddress`函数中定义的错误消息。
- en: 'In order to do this, all we need to do is change our `console.log` call to
    a `callback` call. We''ll pass it as the first argument our error message. We
    can take the string exactly as it appeared in `console.log`, and move it into
    the arguments for `callback`. Then I can remove the `console.log` call and save
    the file. The resultant code will look like following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们所需要做的就是将我们的`console.log`调用更改为`callback`调用。我们将作为第一个参数传递我们的错误消息。我们可以将字符串完全按照它在`console.log`中出现的方式，移动到`callback`的参数中。然后我可以删除`console.log`调用并保存文件。结果代码将如下所示：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can do the exact same thing in the next `else if` block for our other
    `console.log` statement, when there is `zero results`, we''ll replace `console.log`
    with `callback`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在下一个`else if`块中做完全相同的事情，用我们的另一个`console.log`语句替换`zero results`时的`console.log`。
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now the last `else if` block will be a little trickier. It''s a little trickier
    because we don''t exactly have our object. We also need to create an `undefined`
    variable for the first argument, since an error message will not be provided when
    things go well. All we have to do to create that undefined error message is call
    `callback`, passing an `undefined` variable as the first argument. Then we can
    go ahead and specify our object as the second argument, and this object, this
    will be exactly what''s in the `geocodeAddress` function, results:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后的`else if`块会有点棘手。这有点棘手，因为我们并没有确切的对象。我们还需要为第一个参数创建一个`undefined`变量，因为当事情顺利进行时不会提供错误消息。我们只需要调用`callback`，将一个`undefined`变量作为第一个参数传递，就可以创建未定义的错误消息。然后我们可以继续指定我们的对象作为第二个参数，这个对象将会完全符合`geocodeAddress`函数中的结果。
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now as I mentioned the results have three properties: the first one will be
    formatted address, so let''s go ahead and knock that out first. We''ll set `address`
    equal to `body.results`, just like we have in the `Address` variable of `console.log`
    statement:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，结果有三个属性：第一个将是格式化的地址，所以让我们先解决这个问题。我们将把`address`设置为`body.results`，就像我们在`console.log`语句的`Address`变量中一样。
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we're making things even easier, instead of having complex properties that
    are nested deep inside of an object inside of `app.js`, we'll be able to access
    a simple `address` property, and we'll do the same thing for `Latitude` and `Longitude`
    of `console.log` statements.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使事情变得更容易，而不是在`app.js`中深层嵌套的复杂属性，我们将能够访问一个简单的`address`属性，对于`console.log`语句的`Latitude`和`Longitude`也是同样的做法。
- en: 'Next, we''ll grab the code that let us fetch the latitude, and I''ll add my
    second property, `latitude`, setting it equal to the code we grab from the `console.log`
    statement. Then we can go ahead and add the last property, which will be `longitude`,
    setting that equal to the `latitude` code, replacing `lat` with `lng`. Now that
    we have this in place we can add a semicolon at the end, and remove the `console.log`
    statements since they''re no longer necessary, and with this we are done:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将获取让我们获取纬度的代码，并添加我的第二个属性`latitude`，将其设置为我们从`console.log`语句中获取的代码。然后我们可以继续添加最后一个属性，即`longitude`，将其设置为`latitude`代码，用`lng`替换`lat`。现在我们已经完成了这一步，我们可以在末尾添加一个分号，并删除`console.log`语句，因为它们已经不再需要了，这样我们就完成了：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can now rerun the file, and when we do we'll pass an address to `geocodeAddress`,
    this will go off and make the request, and when the request comes back, we'll
    be able to handle that response in a really simple way.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重新运行文件，当我们这样做时，我们将向`geocodeAddress`传递一个地址，这将发出请求，当请求返回时，我们将能够以一种非常简单的方式处理响应。
- en: Testing the callback function in geocode.js file
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`geocode.js`文件中测试回调函数
- en: Inside of the Terminal, we'll go back to run two `node app.js` commands; the
    command where we used the zip code of `19147`, everything works as expected and
    a bad zip code `000000`, to show the error message.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们将返回运行两个`node app.js`命令；使用邮政编码`19147`的命令，一切都按预期工作，以及一个错误的邮政编码`000000`，以显示错误消息。
- en: 'As shown in the following code output, we can see our results object with an
    address property, a latitude property, and a longitude property:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的代码输出中，我们可以看到我们的结果对象具有一个地址属性，一个纬度属性和一个经度属性：
- en: '![](img/26f6b5c3-9e0d-4608-92d3-55324d54be59.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26f6b5c3-9e0d-4608-92d3-55324d54be59.png)'
- en: 'In case of a bad zip code, we just want to make sure the error message still
    shows up, and it does, Unable to find that address. prints to the screen, as shown
    here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邮政编码错误，我们只需确保错误消息仍然显示出来，确实如此，无法找到该地址。打印到屏幕上，如下所示：
- en: '![](img/463842fb-3761-4e42-8fd3-07f4a6c4fcfc.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/463842fb-3761-4e42-8fd3-07f4a6c4fcfc.png)'
- en: This is happening because of the `if` statement in the `geocodeAddress` function
    in `app.js`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`app.js`中的`geocodeAddress`函数中的`if`语句。
- en: After abstracting all of that logic to the `geocode` file, the `app.js` file
    is now a lot simpler and a lot easier to maintain. We can also call `geocodeAddress`
    in multiple locations. If we want to reuse the code we don't have to copy and
    paste the code, which would not follow the **DRY** principle, which stands for
    **Don't Repeat Yourself**, instead we can do the DRY thing and simply call `geocodeAddress`
    like we have in the `app.js` file. With this in place we are now done fetching
    the `geocode` data.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有这些逻辑抽象到`geocode`文件之后，`app.js`文件现在变得简单得多，更容易维护。我们还可以在多个位置调用`geocodeAddress`。如果我们想要重用代码，我们不必复制和粘贴代码，这不符合**DRY**原则，即**不要重复自己**，相反，我们可以做DRY的事情，就像我们在`app.js`文件中所做的那样，简单地调用`geocodeAddress`。有了这个设置，我们现在已经完成了获取`geocode`数据。
- en: Wiring up weather search
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接天气搜索
- en: In this section, you'll make your very first request to the weather API, and
    we'll do this in a static way at first, meaning that it will not use the actual
    latitude and longitude for the address we passed in, we'll simply have a static
    URL. We'll make the request and we'll explore what data we get back in the body.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将向天气API发出您的第一个请求，并且一开始我们将以静态方式进行，这意味着它不会使用我们传入的地址的实际纬度和经度，我们将简单地有一个静态的URL。我们将发出请求，并探索我们在主体中得到的数据。
- en: Exploring working of API in the browser
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中探索API的工作原理
- en: Now before we can add anything to Atom, we want to go ahead and explore this
    API so we can see how it works in the browser. This will give us a better idea
    about what weather data we get back, when we pass a latitude and longitude to
    the API. To do this we'll head over to the browser, and we'll visit a couple of
    URLs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们可以向Atom添加任何内容之前，我们想要先探索一下这个API，这样我们就可以看到它在浏览器中的工作原理。这将让我们更好地了解当我们向API传递纬度和经度时，我们会得到什么样的天气数据。为了做到这一点，我们将前往浏览器，并访问一些URL。
- en: 'First up let''s go to [forecast.io](http://forecast.io). It is a regular weather
    website, you type in your location and you get all the weather information you''d
    expect:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们去[forecast.io](http://forecast.io)。这是一个普通的天气网站，您输入您的位置，就会得到您所期望的所有天气信息：
- en: '![](img/4025c4f9-7c8a-48a9-a0dc-021ddab3e9d3.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4025c4f9-7c8a-48a9-a0dc-021ddab3e9d3.png)'
- en: 'As shown in the preceding image, there''s warnings, there''s radar, there''s
    the current weather, and we also have the weekly forecast in the website as shown
    in the following image:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图像所示，网站上有警告、雷达、当前天气，还有周报预测，如下图所示：
- en: '![](img/a9857030-e147-4319-8064-8296d25ec765.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9857030-e147-4319-8064-8296d25ec765.png)'
- en: This is similar to [weather.com](http://weather.com), but the one cool thing
    about [forecast.io](http://forecast.io) is that the API that powers this website,
    it's actually available to you as a developer. You can make a request to our URL,
    and you can fetch the exact same weather information.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于[weather.com](http://weather.com)，但[forecast.io](http://forecast.io)的一个很酷的地方是，驱动这个网站的API实际上是可以供开发者使用的。您可以向我们的URL发出请求，获取完全相同的天气信息。
- en: 'That is exactly what we''ll do when we can explore the API by going to the
    website [developer.forecast.io](http://developer.forecast.io). Here we can sign
    up for a free developer account, in order to get started making those weather
    requests:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们将要做的，当我们可以通过访问网站[developer.forecast.io](http://developer.forecast.io)来探索API。在这里，我们可以注册一个免费的开发者账户，以便开始发出天气请求：
- en: '![](img/31b0a5f4-3092-44ab-ab18-95728da0bdfd.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31b0a5f4-3092-44ab-ab18-95728da0bdfd.png)'
- en: The Dark Sky Forecast API gives you 1,000 free requests a day, and I do not
    see us going over that limit. After the 1,000 requests, each costs a one thousandth
    of a penny, so you get a thousand requests for every penny you spend. We'll never
    go over that limit so don't even worry about it. There is no credit card required
    to get started, you'll simply get cut off after you make a thousand requests.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Dark Sky Forecast API每天为您提供1,000次免费请求，我认为我们不会超过这个限制。在1,000次请求之后，每次请求的成本是一千分之一的一分钱，因此您每花一分钱就可以获得一千次请求。我们永远不会超过这个限制，所以不用担心。开始时不需要信用卡，您只需在发出一千次请求后就会被切断。
- en: 'To get started you''ll need to register for a free account, it''s really simple,
    we just need an email and a password. Once we''ve created an account and we can
    see the dashboard as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要注册一个免费账户，这非常简单，我们只需要一个电子邮件和一个密码。一旦我们创建了一个账户，我们就可以看到如下所示的仪表板：
- en: '![](img/4539477b-cb00-44e1-8dea-4e2d44639191.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4539477b-cb00-44e1-8dea-4e2d44639191.png)'
- en: The only piece of information we need from this page is our API key. The API
    key is like a password, it will be part of the URL we request and it will help
    [forecast.io](http://forecast.io) keep track of how many requests we make a day.
    Now I'll take this API key and paste it in the `app.js`, so we have it accessible
    later when we need it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个页面需要的唯一信息是我们的API密钥。API密钥就像一个密码，它将成为我们请求的URL的一部分，并且将帮助[forecast.io](http://forecast.io)跟踪我们每天发出的请求数量。现在我将拿到这个API密钥并粘贴到`app.js`中，这样我们以后需要时就可以访问它。
- en: 'The next thing we''ll do is explore the documentation, the actual URL structure
    we need to provide in order to fetch the weather for a given latitude and longitude.
    We can get that by clicking the API Docs link button, which is present in the
    top-right side of The Dark Sky Forecast API page. This''ll lead us to following
    page:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索文档，我们需要提供的实际URL结构，以便获取给定纬度和经度的天气。我们可以通过单击API文档链接按钮来获取，该按钮位于The Dark
    Sky Forecast API页面右上方。这将引导我们到以下页面：
- en: '![](img/e9c839c4-d900-43bf-969b-a333b244ede1.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9c839c4-d900-43bf-969b-a333b244ede1.png)'
- en: In the API Docs link, we have a Forecast Request URL. As shown in the preceding
    image, this URL is exactly what we need to make a request to in order to fetch
    the data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在API文档链接中，我们有一个天气预报请求URL。如前图所示，这个URL正是我们需要发出请求以获取数据的URL。
- en: Exploring the actual URL for code
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索实际的代码URL
- en: 'Before we add this URL into our app and use the request library, we need to
    find the actual URL which we can use to make the request. For this, we''ll copy
    it and paste it into a new tab:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此URL添加到我们的应用程序并使用请求库之前，我们需要找到实际的URL，我们可以用它来发出请求。为此，我们将复制它并粘贴到一个新的标签页中：
- en: '![](img/0ac92c03-3509-4d37-8a59-d2bf52d31368.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ac92c03-3509-4d37-8a59-d2bf52d31368.png)'
- en: 'Now, we do need to swap out some of the URL information. For example, we have
    our API key that needs to get replaced, we also have latitude and longitude. Both
    of those need to get replaced with the real data. Let''s get started with that
    API key first since we already copy and pasted it inside of `app.js`. We''ll copy
    the API key, and replace the letters `[key]` with the actual value:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们确实需要替换一些URL信息。例如，我们有需要替换的API密钥，我们还有纬度和经度。这两者都需要用真实的数据替换。让我们从API密钥开始，因为我们已经将它复制并粘贴到`app.js`中。我们将复制API密钥，并用实际值替换`[key]`。
- en: '![](img/2dc75c0a-083b-439a-affb-517e7d066bca.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dc75c0a-083b-439a-affb-517e7d066bca.png)'
- en: Next up, we can grab a set of longitude and latitude coordinates. For this,
    go inside the Terminal and run our app, `node app.js`, and for the address we
    can use any zip let's say, `19146` to fetch the latitude and longitude coordinates.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以获取一组经度和纬度坐标。为此，进入终端并运行我们的应用程序，`node app.js`，对于地址，我们可以使用任何邮政编码，比如`19146`来获取纬度和经度坐标。
- en: 'Next up, we''ll copy these and place into the URL where they belong. The latitude
    goes between the forward slash and the comma, and the longitude will go after
    the comma, as shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将复制这些内容并放入URL中。纬度放在斜杠和逗号之间，经度将放在逗号之后，如下所示：
- en: '![](img/5a36c1af-c2fb-47f5-948e-957334f560ec.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a36c1af-c2fb-47f5-948e-957334f560ec.png)'
- en: 'Once we have a real URL with all of those three pieces of info swapped out
    for actual info, we can make the request, and what we''ll get back is the forecast
    information:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个真实的URL，其中所有这三个信息都被实际信息替换掉，我们就可以发出请求，我们将得到的是天气预报信息：
- en: '![](img/106731ba-7d2f-4a16-b3f6-24a99cff2dd6.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/106731ba-7d2f-4a16-b3f6-24a99cff2dd6.png)'
- en: Remember, this way the information is showing in the preceding image is due
    to JSONView, I highly recommend installing it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种方式显示在前面的图像中的信息是由JSONView生成的，我强烈建议安装它。
- en: Now the data we get back, it is overwhelming. We have a forecast by the minute,
    we have forecasts by the hour, by the week, by the day, all sorts of information,
    it's really useful but it's also super overwhelming. In this chapter, we'll be
    using the first object that is `currently`. This stores all of the current weather
    information, things like the current summary which is clear, the temperature,
    the precipitation probability, the humidity, a lot of really useful information
    is sitting in it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到的数据是令人不知所措的。我们有按分钟的预报，按小时的预报，按周的预报，按天的预报，各种各样的信息，这些信息非常有用，但也非常令人不知所措。在本章中，我们将使用`currently`中的第一个对象。这存储了所有当前的天气信息，比如当前的摘要是晴朗，温度，降水概率，湿度，很多真正有用的信息都在其中。
- en: In our case, what we really care about is the temperature. The current temperature
    in Philadelphia is shown `84.95` degrees. This is the kind of information we want
    to use inside of our application, when someone searches for the weather in a given
    location.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们真正关心的是温度。费城的当前温度显示为`84.95`度。这是我们想在应用程序中使用的信息，当有人搜索特定位置的天气时。
- en: Making a request for the weather app using the static URL
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态URL请求天气应用程序
- en: Now in order to play around with the weather API, we'll take the exact same
    URL we have defined in the previous section, and we'll make a request in `app.js`.
    First, we want to do a little setup work.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了玩转天气API，我们将采用在上一节中定义的完全相同的URL，并在`app.js`中发出请求。首先，我们需要做一些设置工作。
- en: Inside of `app.js`, we'll comment out everything we have so far, and next to
    our API key we'll make a call to request, requesting this exact URL, just like
    we did for the geocode API in the previous section/chapter, before we made it
    dynamic. Then we'll print out the `body.currently.temperature` property to the
    screen, so when we run the app we'll see the current temperature for whatever
    latitude and longitude we used. In our case it's a static latitude and longitude
    representing Philadelphia.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中，我们将注释掉到目前为止的所有内容，并在我们的API密钥旁边，我们将调用请求，请求这个确切的URL，就像我们在上一节/章节中为地理编码API所做的那样，然后我们将打印出`body.currently.temperature`属性到屏幕上，这样当我们运行应用程序时，我们将看到我们使用的纬度和经度的当前温度。在我们的情况下，它是代表费城的静态纬度和经度。
- en: 'In order to get started we''ll load in request. Now we had it in the `app.js`
    file before and then we removed it in the previous section, but we''ll add it
    back once again. We''ll add it next to the commented out code, by creating a constant
    called `request`, and loading it in, `const request` equals to `require(''request'')`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将加载请求。现在我们之前在`app.js`文件中有它，然后我们在上一节中将它移除了，但是我们将再次添加它。我们将它添加到注释掉的代码旁边，通过创建一个名为`request`的常量，并加载它，`const
    request`等于`require('request')`：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we can go ahead and make the actual request, just like we did for the geocode
    API by calling `request`, it''s a function just like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续进行实际请求，就像我们为地理编码API所做的那样，通过调用`request`，这是一个与此函数相同的函数：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We have to pass in our two arguments, the options object is the first one,
    and the second one is the arrow function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须传入我们的两个参数，选项对象是第一个，第二个是箭头函数：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is our callback function that gets fired once the HTTP request finishes.
    Before we fill out the actual function, we want to set up our options. There''re
    two options, URL and JSON. We''ll set `url` equal to the static string, the exact
    URL we have in the browser:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的回调函数，一旦HTTP请求完成就会触发。在填写实际函数之前，我们要设置我们的选项。有两个选项，URL和JSON。我们将`url`设置为静态字符串，即我们在浏览器中的确切URL：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then in the next line after comma, we can set `json` equal to `true`, telling
    the request library to go ahead and parse that body as JSON, which it is:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在逗号后的下一行，我们可以将`json`设置为`true`，告诉请求库继续解析该JSON，这就是它的作用：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'From here, we can go ahead and add our callback arguments; `error`, `response`,
    and `body`. These are the exact same three arguments we have in the `if` block
    of `geocode.js` file for the `geocoding` request:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以继续添加我们的回调参数；`error`，`response`和`body`。这些是我们在`geocode.js`文件的`geocoding`请求的`if`块中具有的完全相同的三个参数：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that we have this in place, the last thing we need to do is print the current
    temperature, which is available on the body using `console.log` statement. We''ll
    use `console.log` to print `body.currently.temperature`, as shown here:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经做到了这一点，我们需要做的最后一件事就是打印当前温度，这是在`body`中使用`console.log`语句可用的。我们将使用`console.log`来打印`body.currently.temperature`，如下所示：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that we have the temperature printing, we need to test it by running it
    from the Terminal. In the Terminal, we''ll rerun the previous command. The address
    is not actually being used here since we commented out that code, and what we
    get is 28.65, as shown in this code output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经打印了温度，我们需要通过从终端运行来测试它。在终端中，我们将重新运行之前的命令。这里实际上没有使用地址，因为我们已经注释掉了那段代码，我们得到的是28.65，如代码输出所示：
- en: '![](img/4afe0e93-2da7-4d5e-9631-f40646805e7d.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4afe0e93-2da7-4d5e-9631-f40646805e7d.png)'
- en: With this we have our weather API call working inside of the application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的天气API调用已经在应用程序中工作。
- en: Error handling in the the callback function
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数中的错误处理
- en: 'Now we do want to add a little error handling inside of our callback function.
    We''ll handle errors on the error object, and we''ll also handle errors that come
    back from the [forecast.io](http://forecast.io) servers. First up, just like we
    did for the geocoding API, we''ll check if error exists. If it does, that means
    that we were unable to connect to the servers, so we can print a message that
    relays that message to the user, `console.log` something like `Unable to connect
    to forecast.io server.`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确实想在回调函数中添加一些错误处理。我们将在错误对象上处理错误，还将处理从[forecast.io](http://forecast.io)服务器返回的错误。首先，就像我们为地理编码API所做的那样，我们将检查错误是否存在。如果存在，这意味着我们无法连接到服务器，因此我们可以打印一条向用户传达该消息的消息，`console.log`类似于`无法连接到forecast.io服务器。`：
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now that we've handled general errors, we can move on to a specific error that
    the [forecast.io](http://forecast.io) API throws. This happens when the format
    of the URL, the latitude and longitude, is not correct.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了一般错误，我们可以继续处理[forecast.io](http://forecast.io) API抛出的特定错误。当URL的格式，即纬度和经度不正确时，就会发生这种情况。
- en: 'For example, if we delete some numbers including the comma in the URL, and
    hit *enter* we''ll get a 400 Bad Request:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们删除URL中包括逗号的一些数字，然后按*enter*，我们将得到400 Bad Request：
- en: '![](img/41a55d28-22ae-4309-9e2f-cf0907b38ab0.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41a55d28-22ae-4309-9e2f-cf0907b38ab0.png)'
- en: 'This is the actual HTTP status code. If you remember from the `geolocation`
    API we had a `body.status` property that was either `OK` or `ZERO_RESULTS`. This
    is similar to that property, only this uses the HTTP mechanisms instead of some
    sort of custom solution that Google used. In our case, we''ll want to check if
    the status code is 400\. Now if we have a bad API key, I''ll add a couple e''s
    in the URL, we''ll also get a 400 Bad Request:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际的HTTP状态码。如果你还记得`geolocation` API中的`body.status`属性，它要么是`OK`，要么是`ZERO_RESULTS`。这与该属性类似，只是这里使用了HTTP机制，而不是谷歌使用的某种自定义解决方案。在我们的情况下，我们将检查状态码是否为400。现在，如果我们有一个错误的API密钥，我将在URL中添加一些e，我们也会得到400
    Bad Request：
- en: '![](img/a8f92f30-e83f-4762-a592-aca23adb78d6.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8f92f30-e83f-4762-a592-aca23adb78d6.png)'
- en: So both of these errors can be handled using the same code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这两个错误都可以使用相同的代码来处理。
- en: 'Inside of Atom, we can handle this by checking the status code property. After
    our `if` statement closing curly brace, we''ll add `else if` block, `else if (response.statusCode)`,
    this is the property we looked at when we looked at the response argument in detail.
    `response.statusCode` will be equal to `400` if something went wrong, and that''s
    exactly what we''ll check for here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，我们可以通过检查状态码属性来处理这个问题。在我们的`if`语句的闭合大括号之后，我们将添加`else if`块，`else if (response.statusCode)`，这是我们在详细查看响应参数时查看的属性。如果出现问题，`response.statusCode`将等于`400`，这正是我们要在这里检查的：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the status code is `400` we''ll print a message, `console.log(''Unable to
    fetch weather'')`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态码是`400`，我们将打印一条消息，`console.log('无法获取天气')`：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now we've handled those two errors, and we can move on to the success case.
    For this we'll add another else if block with `response.statusCode` equals `200`.
    The status code will equal `200` if everything went well, in that case we'll print
    the current temperature to the screen.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了这两个错误，我们可以继续处理成功的情况。为此，我们将添加另一个`else if`块，其中`response.statusCode`等于`200`。如果一切顺利，状态码将等于`200`，在这种情况下，我们将把当前温度打印到屏幕上。
- en: 'I''ll cut the `console.log(body.currently.temperature)` line out and paste
    it inside of the else if code block:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我将删除`console.log(body.currently.temperature)`行，并将其粘贴到else if代码块中：
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Another way of error handling
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一种错误处理方式
- en: 'There''s is another way to represent our entire if block code. The following
    is an updated code snippet, and we can actually replace everything we have in
    the current callback function with this code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法来表示我们整个if块代码。以下是一个更新的代码片段，我们实际上可以用这段代码替换当前回调函数中的所有内容：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This condition checks if there is no error and the response status code is a
    `200`, if that's the case what do we do? We simply print the temperature like
    we were doing last time, that was in the `else if` clause at the very bottom.
    Now we have an `else` case in the updated code snippet, so if there is an error
    or the status code is not a `200`, we'll go ahead and print this message to the
    screen. This will handle things like the server not having a network connection,
    or 404s from an invalid or broken URL. All right, use this code instead and everything
    should be working as expected with the latest version of the weather API.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件检查是否没有错误并且响应状态码是`200`，如果是这样，我们该怎么办？我们只需像上次一样打印温度，那是在最底部的`else if`子句中。现在我们在更新的代码片段中有一个`else`情况，所以如果有错误或状态码不是`200`，我们将继续打印这条消息到屏幕上。这将处理服务器没有网络连接，或者来自无效或损坏URL的404。好了，使用这段代码，一切应该按照最新版本的天气API预期的那样工作。
- en: Testing the error handling in callback
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试回调中的错误处理
- en: 'Now we have some error handling in place and we can go ahead and test that
    our app still works. From the Terminal we''ll rerun the previous command, and
    we still get a temperature 28.71:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了一些错误处理，我们可以继续测试我们的应用程序是否仍然有效。从终端中，我们将重新运行之前的命令，我们仍然得到一个温度28.71：
- en: '![](img/28b3db9f-71ca-4139-87ed-b70ea758317a.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28b3db9f-71ca-4139-87ed-b70ea758317a.png)'
- en: 'Back inside of Atom, we''ll trash some of the data by removing the comma, saving
    the file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在Atom中，我们将通过去掉逗号来清除一些数据，保存文件：
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When we rerun it from the Terminal, this time, we would expect Unable to fetch
    weather. to print to the screen, and when I rerun the app that is exactly what
    we get, as shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从终端重新运行它时，这次，我们期望“无法获取天气。”打印到屏幕上，当我重新运行应用程序时，这正是我们得到的，如下所示：
- en: '![](img/4a7ac319-1d5f-47bb-b8ad-8c1ef3fbc20b.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a7ac319-1d5f-47bb-b8ad-8c1ef3fbc20b.png)'
- en: 'Now, let''s add the comma back in and test our last part of the code. To test
    the if error, we can test that by removing something like the dot from `forecast.io`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把逗号加回去，测试我们代码的最后一部分。为了测试错误，我们可以通过从`forecast.io`中删除点这样的东西来测试：
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can rerun the app, and we see Unable to connect to Forecast.io server.:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新运行应用程序，我们会看到“无法连接到Forecast.io服务器。”：
- en: '![](img/c9b695a9-2e81-4df2-88d8-6b2323e6a914.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9b695a9-2e81-4df2-88d8-6b2323e6a914.png)'
- en: All of our error handling works great, and if there is no errors the proper
    temperature prints to the screen, which is fantastic.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的错误处理都很好用，如果没有错误，适当的温度将打印到屏幕上，这太棒了。
- en: Chaining callbacks together
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接回调
- en: In this section, we'll take the code that we created in the last section, and
    break it out into its own file. Similar to what we did with the Geocoding API
    request where we called `geocodeAddress` instead of actually having the request
    call in `app.js`. That means we'll make a new folder, a new file, and we'll create
    a function in there that gets exported.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将把我们在上一节中创建的代码分解成自己的文件。类似于我们在调用`geocodeAddress`时所做的地理编码API请求，而不是实际在`app.js`中进行请求调用。这意味着我们将创建一个新文件夹，一个新文件，并在其中创建一个导出的函数。
- en: After that we'll go ahead and learn how to chain callbacks together. So when
    we get that address from the Terminal we can convert that into coordinates. And
    we can take those coordinates and convert them into temperature information, or
    whatever weather data we want to pull off of the return result from the Forecast
    API.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将继续学习如何将回调链接在一起。因此，当我们从终端获取该地址时，我们可以将其转换为坐标。然后我们可以将这些坐标转换为温度信息，或者我们想要从Forecast
    API的返回结果中获取的任何天气数据。
- en: Refactoring our request call in weather.js file
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构我们在weather.js文件中的请求调用
- en: Now before we can dive into the refactoring, we'll create a brand new file,
    and we'll worry about getting the code we created in the previous section into
    that function. Then we'll go for creating that callback.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们进行重构之前，我们将创建一个全新的文件，并且我们将担心将我们在上一节中创建的代码放入该函数中。然后我们将创建回调。
- en: Defining the new function getWeather in weather file
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在weather文件中定义新函数getWeather
- en: First, let's make the directory. The directory will be called `weather`. And
    in the `weather` directory we'll make a new file called `weather.js`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建目录。目录将被称为`weather`。在`weather`目录中，我们将创建一个名为`weather.js`的新文件。
- en: 'Now in this file we can take all of our code from `app.js`, and paste it in
    `weather.js`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这个文件中，我们可以将我们从`app.js`中的所有代码复制到`weather.js`中：
- en: '[PRE62]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The only thing we need to do in order to take this code and convert it to create
    that function, which will get exported. And then we can move our call to the request
    inside of it. We''ll make a brand new function called `getWeather` next to the
    `request` variable:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这段代码转换为创建该函数所需的唯一事情，我们将调用请求移到其中。我们将创建一个名为`getWeather`的全新函数，放在`request`变量旁边：
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`getWeather` will take some arguments, but that''ll be added later. For now
    we''ll leave the arguments list empty. Next, we''ll take our call to request and
    move it inside the `getWeather` function:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWeather`将需要一些参数，但这将稍后添加。现在我们将保持参数列表为空。接下来，我们将把我们对请求的调用移到`getWeather`函数内部：'
- en: '[PRE64]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, we can go ahead and export this `getWeather` function. We''ll add `module.exports.getWeather`
    and set it equal to the `getWeather` function that we defined up:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以继续导出这个`getWeather`函数。我们将添加`module.exports.getWeather`并将其设置为我们定义的`getWeather`函数：
- en: '[PRE65]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Providing weather directory in app.js
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在app.js中提供weather目录
- en: Now that we have this in place, we can go ahead and move into `app.js` to add
    some code. The first thing we need do is remove the API key. We no longer need
    that. And we'll highlight all of the commented code and uncomment it using the
    command `/`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪，可以继续进入`app.js`添加一些代码。我们需要做的第一件事是删除API密钥。我们不再需要它。然后我们将突出显示所有注释掉的代码，并使用命令`/`取消注释。
- en: 'Now we''ll import the `weather.js` file. We''ll create a `const` variable called
    `weather`, and setting it equal to the `require`, return result:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将导入`weather.js`文件。我们将创建一个名为`weather`的`const`变量，并将其设置为`require`返回的结果：
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In this case we''re requiring our brand new file we just created. We''ll provide
    a relative path `./` because we''re loading in a file that we wrote. Then we''ll
    provide the directory named `weather` followed by the file named `weather.js`.
    And we can leave off that `js` extension, as we already know:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在引入我们刚刚创建的全新文件。我们将提供一个相对路径`./`，因为我们正在加载我们编写的文件。然后我们将提供名为`weather`的目录，后跟名为`weather.js`的文件。我们可以省略`js`扩展名，因为我们已经知道：
- en: '[PRE67]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that we have the Weather API loaded in, we can go ahead and call it. We''ll
    comment out our call to `geocodeAddress` and, we''ll run `weather.getWeather()`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了天气API，我们可以继续调用它。我们将注释掉对`geocodeAddress`的调用，并运行`weather.getWeather()`：
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now as I mentioned before, there will be arguments later in the section. For
    now we''ll leave them empty. And we can run our file from the Terminal. This means
    we should see the weather printing for the coordinates, we hard-coded in the previous
    section. So, we''ll run `node app.js`. We''ll need to provide an address since
    we haven''t commented out the yargs code. So we''ll add a dummy address. I''ll
    use a zip code in New Jersey:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，后面将有参数。现在我们将把它们留空。我们可以从终端运行我们的文件。这意味着我们应该看到我们在上一节中硬编码的坐标的天气打印出来。因此，我们将运行`node
    app.js`。因为我们没有注释掉yargs代码，所以我们需要提供一个地址。因此，我们将添加一个虚拟地址。我将使用新泽西州的邮政编码：
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![](img/c01e3671-6f77-4290-a189-3bc1d4462223.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c01e3671-6f77-4290-a189-3bc1d4462223.png)'
- en: Now, the `geolocation` code is never running, because that is commented out.
    But we are running the weather code that got moved to the new file. And we are
    indeed seeing a temperature 31.82 degrees, which means that the code is properly
    getting executed in the new file.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`geolocation`代码从未运行，因为它被注释掉了。但是我们正在运行已移至新文件的天气代码。我们确实看到了温度为31.82度，这意味着代码在新文件中得到了正确执行。
- en: Passing the arguments in the getWeather function
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`getWeather`函数中传递参数
- en: Now we'll need to pass in some arguments, including a callback function and
    inside `getWeather` variable in weather file. We'll need to use those arguments
    instead of a static `lat`/`lng` pair. And we'll also need to call the callback
    instead of using `console.log`. The first thing we'll do before we actually change
    the `weather.js` code is change the `app.js` code. There are three arguments to
    be added. These are `lat`, `lng` and `callback`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要传入一些参数，包括回调函数和天气文件中的`getWeather`变量。我们需要使用这些参数来代替静态的`lat`/`lng`对。我们还需要调用回调函数，而不是使用`console.log`。在我们实际更改`weather.js`代码之前，我们需要做的第一件事是更改`app.js`代码。需要添加三个参数。这些是`lat`，`lng`和`callback`。
- en: 'First up we''ll want to pass in the latitude. We''ll take the static data,
    like the latitude part from the URL in `weather.js`, copy it, and paste it right
    inside of the arguments list in `app.js` as first argument. The next one will
    be the longitude. We''ll grab that from the URL, copy it, and paste it inside
    of `app.js` as the second argument:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要传入纬度。我们将从`weather.js`中的URL中获取静态数据，复制它，并将其粘贴到`app.js`的参数列表中作为第一个参数。接下来是经度。我们将从URL中获取它，复制它，并将其粘贴到`app.js`中作为第二个参数：
- en: '[PRE70]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then we can go ahead and provide the third one, which will be the callback
    function. This function will get fired once the weather data comes back from the
    API. I''ll use an arrow function that will get those two arguments we discussed
    earlier in the previous section: `errorMessage` and `weatherResults`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以继续提供第三个参数，这将是回调函数。一旦天气数据从API返回，这个函数将被触发。我将使用一个箭头函数，它将得到我们在上一节中讨论过的那两个参数：`errorMessage`和`weatherResults`：
- en: '[PRE71]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `weatherResults` object containing any sort of temperature information we
    want. In this case it could be the temperature and the actual temperature. Now,
    we have used `weatherResults` in place of results, and this is because, we want
    to differentiate `weatherResults` from the results variable in `geocodeAddress`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`weatherResults`对象包含我们想要的任何温度信息。在这种情况下，它可以是温度和实际温度。现在，我们已经在`geocodeAddress`中使用`weatherResults`代替`results`，这是因为我们想要区分`weatherResults`和`geocodeAddress`中的`results`变量。'
- en: Printing errorMessage in the getWeather function
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`getWeather`函数中打印`errorMessage`
- en: 'Inside of the `getWeather` function in `app.js`, we now need to use `if`-`else`
    statements in order to print the appropriate thing to the screen, depending on
    whether or not the error message exists. If there is `errorMessage` we do want
    to go ahead and print it using `console.log`. In this case we''ll pass in the
    `errorMessage` variable:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中的`getWeather`函数内部，我们现在需要使用`if`-`else`语句来根据错误消息是否存在来打印适当的内容到屏幕上。如果有`errorMessage`，我们确实希望使用`console.log`来打印它。在这种情况下，我们将传入`errorMessage`变量：
- en: '[PRE72]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now if there is no error message we''ll use the `weatherResults` object. We''ll
    be printing a nice formatted message later. For now we can simply print the `weatherResults`
    object using the pretty printing technique we talked about in the previous chapter,
    where we call `JSON.stringify` inside of `console.log`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果没有错误消息，我们将使用`weatherResults`对象。稍后我们将打印一个漂亮格式的消息。现在我们可以简单地使用我们在上一章中讨论过的漂亮打印技术，即在`console.log`中调用`JSON.stringify`来打印`weatherResults`对象：
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Inside the `JSON.stringify` parentheses, we''ll provide those three arguments,
    the actual object; `weatherResults`, `undefined` for our filtering function, and
    a number for our indentation. In this case we''ll go with `2` once again:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在`JSON.stringify`的括号内，我们将提供这三个参数，实际对象；`weatherResults`，我们的过滤函数的`undefined`，以及缩进的数字。在这种情况下，我们将再次选择`2`：
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: And now that we have our `getWeather` call getting called with all three arguments,
    we can go ahead and actually implement this call inside of `weather.js`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用所有三个参数调用了`getWeather`，我们可以继续实际在`weather.js`中实现这个调用。
- en: Implementing getWeather callback inside weather.js file
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在weather.js文件中实现getWeather回调
- en: To get started we'll make the URL in the `weather.js` file dynamic, which means
    we need to replace the url strings with template strings. Once we have template
    strings in place, we can inject the arguments, latitude and longitude, right into
    the URL.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使`weather.js`文件中的URL动态化，这意味着我们需要用模板字符串替换URL字符串。一旦我们有了模板字符串，我们就可以将纬度和经度的参数直接注入URL中。
- en: Adding dynamic latitude and longitude
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动态纬度和经度
- en: 'Let''s go ahead and define all the arguments that are getting passed in. We
    add `lat`, `lng`, and our `callback`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续定义传入的所有参数。我们添加`lat`，`lng`和我们的`callback`：
- en: '[PRE75]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'First off let''s inject that latitude. We''ll take the static latitude, remove
    it, and between the forward slash and the comma we''ll inject it using dollar
    with our curly braces. This lets us inject a value into our template string; in
    this case `lat`. And we can do the exact same thing right after the comma with
    the longitude. We''ll remove the static longitude, use the dollar sign with our
    curly braces to inject the variable into the string:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们注入那个纬度。我们将取出静态纬度，然后在斜杠和逗号之间使用花括号和美元符号注入它。这让我们能够将一个值注入到我们的模板字符串中；在这种情况下是`lat`。然后我们可以在逗号后面做完全相同的事情，注入经度。我们将删除静态经度，使用美元符号和花括号将变量注入到字符串中：
- en: '[PRE76]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now that the URL is dynamic, the last thing we need to do inside of `getWeather`
    is change our `console.log` calls to `callback` calls.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在URL是动态的，我们在`getWeather`中需要做的最后一件事是将我们的`console.log`调用更改为`callback`调用。
- en: Changing console.log calls into callback calls
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将console.log调用更改为callback调用
- en: 'To change our `console.log` into `callback` calls, for the first two `console.log`
    calls we can replace `console.log` with `callback`. And this will line up with
    the arguments that we specified in `app.js`, where the first one is the `errorMessage`
    and the second one is the `weatherResults`. In this case we''ll pass the `errorMessage`
    back and the second argument is `undefined`, which it should be. We can do the
    same thing for `Unable to fetch weather`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的`console.log`更改为`callback`调用，对于前两个`console.log`调用，我们可以将`console.log`替换为`callback`。这将与我们在`app.js`中指定的参数对齐，第一个是`errorMessage`，第二个是`weatherResults`。在这种情况下，我们将传递`errorMessage`，第二个参数是`undefined`，这应该是的。我们可以对`Unable
    to fetch weather`做同样的事情：
- en: '[PRE77]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now the third `console.log` call will be a little more complex. We''ll have
    to actually create an object instead of just passing the temperature back. We''ll
    call the `callback` with the first argument being `undefined`, because in this
    case there is no `errorMessage`. Instead we''ll provide that `weatherResults`
    object:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第三个`console.log`调用将会更复杂一些。我们将不得不创建一个对象，而不仅仅是传递温度。我们将用第一个参数调用`callback`，因为在这种情况下没有`errorMessage`。相反，我们将提供`weatherResults`对象：
- en: '[PRE78]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Inside the parentheses, we can define all the temperature properties we like.
    In this case we''ll define `temperature`, setting it equal to `body.currently`,
    which stores all of the `currently` weather data, `.temperature`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内，我们可以定义我们喜欢的所有温度属性。在这种情况下，我们将定义`temperature`，将其设置为`body.currently`，它存储所有`currently`天气数据，`.temperature`：
- en: '[PRE79]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now that we have the `temperature` variable we can go ahead and provide that
    second property to the object, which is `actual temperature`. Actual temperature
    will account for things like humidity, wind speed, and other weather conditions.
    The actual temperature data is available under a property on currently called
    `apparentTemperature`. We''ll provide that. And as the value we''ll use the same
    thing. This gets us to the `currently` object, just like we do for temperature.
    This will be `body.currently.apparentTemperature`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`temperature`变量，我们可以继续为对象提供第二个属性，即`实际温度`。实际温度将考虑湿度、风速和其他天气条件。实际温度数据在当前称为`apparentTemperature`的属性下可用。我们将提供它。作为值，我们将使用相同的东西。这将使我们得到`currently`对象，就像我们为温度所做的那样。这将是`body.currently.apparentTemperature`：
- en: '[PRE80]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now we have our two properties, so we can go ahead and remove that `console.log`
    statement. Add a semicolon. The final code will look like:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个属性，所以我们可以继续删除那个`console.log`语句。添加一个分号。最终的代码将如下所示：
- en: '[PRE81]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we can go ahead and run the app. We have our `getWeather` function wired
    up both inside of the `weather.js` file and inside of `app.js`. Now once again
    we are still using static coordinates, but this will be the last time we run the
    file with that static data. From the Terminal we''ll rerun the application:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续运行应用程序。我们已经在`weather.js`文件和`app.js`文件中都连接了`getWeather`函数。现在我们再次使用静态坐标，但这将是我们最后一次使用静态数据运行文件。从终端中，我们将重新运行应用程序：
- en: '![](img/fec933d9-d879-4d1d-a377-c6f1c2ce06b5.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fec933d9-d879-4d1d-a377-c6f1c2ce06b5.png)'
- en: And as shown we get our temperature object printing to the screen. We have our
    temperature property 48.82 and we have the apparentTemperature, which is already
    at 47.42 degrees.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们将我们的温度对象打印到屏幕上。我们有我们的温度属性48.82，还有明显温度，已经达到了47.42度。
- en: With this in place we're now ready to learn how to chain our callbacks together.
    That means in `app.js` we'll take the results that come back from `geocodeAddress`,
    pass them in to `getWeather`, and use that to print dynamic weather for the address
    you provide over here in the Terminal. In this case we would get the address for
    the town in New Jersey. As opposed to the static address which we're using in
    the `app.js` file that latitude/longitude pair is for Philadelphia.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在准备好学习如何将我们的回调链接在一起。这意味着在`app.js`中，我们将获取从`geocodeAddress`返回的结果，将它们传递给`getWeather`，并用它来打印您在终端中提供的地址的动态天气。在这种情况下，我们将获取新泽西镇的地址。与我们在`app.js`文件中使用的静态地址相反，那个纬度/经度对是为费城的。
- en: Chaining the geocodeAddress and getWeather callbacks together
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将geocodeAddress和getWeather回调链接在一起
- en: To get started we have to take our `getWeather` call and actually move it inside
    of the `callback` function for `geocodeAddress`. Because inside this `callback`
    function is the only place we have access to the latitude and longitude pairs.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须将我们的`getWeather`调用移动到`geocodeAddress`的`callback`函数中。因为在这个`callback`函数中是我们唯一可以访问纬度和经度对的地方。
- en: Now if we open the `geocode.js` file, we can see that we get `formatted_address`
    back as the address property, we get the `latitude` back as latitude, and we get
    `longitude` back as longitude. We'll start wiring this up.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开`geocode.js`文件，我们可以看到我们得到`formatted_address`作为地址属性，我们得到`latitude`作为纬度，我们得到`longitude`作为经度。我们将开始连接这些。
- en: Moving getWeather call into geocodeAddress function
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将getWeather调用移到geocodeAddress函数中
- en: First, we do need to remove the comments of `geocodeAddress` in the `app.js`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`app.js`中删除`geocodeAddress`的注释。
- en: 'Next, we''ll go ahead and take the `console.log` statement in the success case
    and replace it with a `console.log` call that will print the formatted address:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续，将成功情况下的`console.log`语句替换为一个将打印格式化地址的`console.log`调用：
- en: '[PRE82]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This will print the address to the screen, so we know exactly what address we're
    getting weather data for.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在屏幕上打印地址，这样我们就知道我们获取天气数据的确切地址。
- en: 'Now that we have our `console.log` printing the address, we can take the `getWeather`
    call, and move it right below the `console.log` line:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让`console.log`打印出地址，我们可以把`getWeather`调用移到`console.log`行的下面：
- en: '[PRE83]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: And with this in place we're now really close to actually chaining the two callbacks
    together. All that's left to do is take these static coordinates and replace them
    with the dynamic ones, which will be available in the `results` object.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在非常接近实际将这两个回调链接在一起。唯一剩下的就是用动态坐标替换这些静态坐标，这些动态坐标将在`results`对象中可用。
- en: Replacing static coordinates with dynamic coordinates
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用动态坐标替换静态坐标
- en: 'The first argument will be `results.latitude`, which we defined in `app.js`
    on the object. And the second one will be `results.longitude`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数将是`results.latitude`，我们在`app.js`中定义的对象。第二个参数将是`results.longitude`：
- en: '[PRE84]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This is all we need to do to take the data from `geocodeAddress` and pass it
    in to `getWeather`. This will create an application that prints our dynamic weather,
    the weather for the address in the Terminal.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的一切，将数据从`geocodeAddress`传递给`getWeather`。这将创建一个在终端中打印我们动态天气的应用程序。
- en: 'Now before we go ahead and run this, we''ll replace the object call with a
    more formatted one. We''ll take both of the pieces of information-the `temperature`
    variable and the `apparentTemperature` variable from `weather.js` file, and use
    them in that string in `app.js`. This means that we can remove the `console.log`
    in the `else` block of `getWeather` call, replacing it with a different `console.log`
    statement:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们继续运行之前，我们将用更格式化的对象调用替换它。我们将从`weather.js`文件中获取`temperature`变量和`apparentTemperature`变量的信息，并在`app.js`中的字符串中使用它们。这意味着我们可以删除`getWeather`调用的`else`块中的`console.log`，并用不同的`console.log`语句替换它：
- en: '[PRE85]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We''ll use template strings, since we plan to inject a few variables in; these''re
    currently, followed by the temperature. We''ll inject that using `weatherResults.temperature`.
    And then we can go ahead and put a period, and add something along the lines of:
    `It feels like`, followed by the `apparentTemperature` property, which I''ll inject
    using `weatherResults.apparentTemperature`. I''ll put a period after that:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用模板字符串，因为我们计划注入一些变量，这些变量是当前的温度。我们将使用`weatherResults.temperature`进行注入。然后我们可以继续添加一个句号，然后添加类似于：`It
    feels like`，后面跟着`apparentTemperature`属性，我将使用`weatherResults.apparentTemperature`进行注入。之后我会加一个句号：
- en: '[PRE86]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We now have a `console.log` statement that prints the weather to the screen.
    We also have one that prints the address to the screen, and we have error handlers
    for both `geocodeAddress` and `getWeather`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个`console.log`语句，可以将天气打印到屏幕上。我们还有一个可以将地址打印到屏幕上的语句，我们还为`geocodeAddress`和`getWeather`都设置了错误处理程序。
- en: Testing the chaining of callbacks
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试回调链的链接
- en: 'Let''s go ahead and test this by rerunning the `node app.js` command in the
    Terminal. We''ll use the same zip code, `08822`:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续测试，通过在终端中重新运行`node app.js`命令。我们将使用相同的邮政编码`08822`：
- en: '[PRE87]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '![](img/f48ffac3-6759-42f6-ade3-c5385a843cce.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f48ffac3-6759-42f6-ade3-c5385a843cce.png)'
- en: 'When we run it we get Flemington, NJ as the formatted address and It''s currently
    is 31.01\. It feels like 24.9\. Now to test that this is working we''ll type in
    something else inside of quotes, something like `Key West fl`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，我们得到了Flemington, NJ作为格式化的地址，当前温度是31.01度。体感温度是24.9度。现在为了测试这个是否有效，我们将在引号内输入其他内容，比如`Key
    West fl`：
- en: '[PRE88]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '![](img/a81c7d4c-fab7-4c1e-98c9-14d9a411b022.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a81c7d4c-fab7-4c1e-98c9-14d9a411b022.png)'
- en: And when we run this command we do get Key West, FL as shown as the formatted
    address, and It's currently 64.51\. It feels like 64.52.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个命令时，我们确实得到了Key West, FL作为格式化的地址，当前温度是64.51度。体感温度是64.52度。
- en: With this in place, the weather application is now wired up. We take the address
    we get the latitude/longitude pair using the Google Geocoding API. Then we use
    our forecast API to take that latitude/longitude pair and convert it into temperature
    information.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，天气应用程序现在已经连接起来了。我们获取地址，使用Google Geocoding API获取纬度/经度对。然后我们使用我们的预报API将这个纬度/经度对转换成温度信息。
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about how to set up yargs for the `weather-app`
    file and how to include user input in it. Next, we looked into how to handle errors
    inside of our callback functions and how to recover from those errors. We simply
    added `else`/`if` statements inside of the `callback` function. Callbacks are
    just one function, so in order to figure out if things went well or if things
    didn't go well, we have to use `else`/`if` statements, this lets us do different
    things, such as print different messages, depending on whether or not we perceive
    the request to have gone well. Then, we made our first request to the weather
    API, and we looked into a way to fetch the weather based off of the latitude-longitude
    combination.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何为`weather-app`文件设置yargs，以及如何在其中包含用户输入。接下来，我们研究了如何处理回调函数中的错误以及如何从这些错误中恢复。我们只是在`callback`函数中添加了`else`/`if`语句。回调函数只是一个函数，所以为了弄清楚事情是顺利进行还是出了问题，我们必须使用`else`/`if`语句，这让我们可以根据我们是否认为请求进行顺利来执行不同的操作，比如打印不同的消息。然后，我们发出了第一个天气API请求，并研究了根据经纬度组合获取天气的方法。
- en: Last, we looked in chaining the `geocodeAddress` and `getWeather` call functions.
    We took that request call that was originally in `app.js`, and we moved it into
    `weather.js`, defining it there. We used a callback to pass the data from `weather.js`
    into `app.js` where we imported the `weather.js` file. Then, inside of the callback
    for `geocodeAddress` we call `getWeather` and inside of that `callback` we printed
    the weather specific information to the screen. This was all done using `callback`
    functions.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 上一次，我们讨论了链接`geocodeAddress`和`getWeather`调用函数。我们将最初在`app.js`中的请求调用移动到了`weather.js`中，并在那里定义了它。我们使用回调将`weather.js`中的数据传递到了我们导入`weather.js`文件的`app.js`中。然后，在`geocodeAddress`的回调中调用`getWeather`，在`getWeather`的回调中将天气特定信息打印到屏幕上。所有这些都是使用回调函数完成的。
- en: In the next chapter, we'll talk about a different way we can synchronize our
    asynchronous code using ES6 promises.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用ES6 promises来同步异步代码的另一种方法。
