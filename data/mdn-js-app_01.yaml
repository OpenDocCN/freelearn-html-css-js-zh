- en: Chapter 1. Breaking into Microservices Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 突破微服务架构
- en: The architecture of server-side application development for complex and large
    applications (applications with huge number of users and large volume of data)
    shouldn't just involve faster response and providing web services for wide variety
    of platforms. It should be easy to scale, upgrade, update, test, and deploy. It
    should also be highly available, allowing the developers write components of the
    server-side application in different programming languages and use different databases.
    Therefore, this leads the developers who build large and complex applications
    to switch from the common monolithic architecture to microservices architecture
    that allows us to do all this easily. As microservices architecture is being widely
    used in enterprises that build large and complex applications, it's really important
    to learn how to design and create server-side applications using this architecture.
    In this chapter, we will discuss how to create applications based on microservices
    architecture with Node.js using the Seneca toolkit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为复杂和大型应用程序（拥有大量用户和大量数据的程序）开发服务器端应用程序的架构不应仅仅涉及更快的响应速度和为各种平台提供网络服务。它应该易于扩展、升级、更新、测试和部署。它还应该具有高可用性，允许开发者使用不同的编程语言编写服务器端应用程序的组件，并使用不同的数据库。因此，这导致构建大型和复杂应用程序的开发者从常见的单体架构转向允许我们轻松完成所有这些任务的微服务架构。随着微服务架构在构建大型和复杂应用程序的企业中得到广泛应用，学习如何使用这种架构设计和创建服务器端应用程序变得非常重要。在本章中，我们将讨论如何使用Seneca工具包和Node.js创建基于微服务架构的应用程序。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding monolithic architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单体架构
- en: Scaling, upgrading, deploying, and writing applications based on monolithic
    architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于单体架构的扩展、升级、部署和编写应用程序
- en: Discussing microservices architecture in depth
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨微服务架构
- en: Scaling, upgrading, deploying, and writing applications based on microservices
    architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于微服务架构的扩展、升级、部署和编写应用程序
- en: Getting started with Seneca
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Seneca
- en: Creating and calling services using Seneca
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Seneca创建和调用服务
- en: What is monolithic architecture?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是单体架构？
- en: To understand microservices architecture, it's important to first understand
    monolithic architecture, which is its opposite.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解微服务架构，首先理解单体架构，这是它的对立面。
- en: In monolithic architecture, different functional components of the server-side
    application, such as payment processing, account management, push notifications,
    and other components, all blend together in a single unit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，服务器端应用程序的不同功能组件，如支付处理、账户管理、推送通知以及其他组件，都融合在一个单一单元中。
- en: For example, applications are usually divided into three parts. The parts are
    HTML pages or native UI that run on the user's machine, server-side application
    that runs on the server, and database that also runs on the server. The server-side
    application is responsible for handling HTTP requests, retrieving and storing
    data in a database, executing algorithms, and so on. If the server-side application
    is a single executable (that is, running is a single process) that does all these
    tasks, then we say that the server-side application is monolithic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，应用程序通常分为三个部分。这些部分包括在用户机器上运行的HTML页面或原生UI，运行在服务器上的服务器端应用程序，以及也在服务器上运行的数据库。服务器端应用程序负责处理HTTP请求，从数据库中检索和存储数据，执行算法等。如果服务器端应用程序是一个单一的可执行文件（即，运行时是一个单一进程）来完成所有这些任务，那么我们说服务器端应用程序是单体化的。
- en: This is a common way of building server-side applications. Almost every major
    CMS, web servers, server-side frameworks, and so on are built using monolithic
    architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的构建服务器端应用程序的方式。几乎每个主要的CMS、Web服务器、服务器端框架等都使用单体架构构建。
- en: This architecture may seem successful, but problems are likely to arise when
    your application is large and complex.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构可能看起来很成功，但当您的应用程序变得庞大且复杂时，问题很可能会出现。
- en: Demerits of monolithic architecture
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单体架构的缺点
- en: The following are some of the issues caused by server-side applications built
    using the monolithic architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用单体架构构建的服务器端应用程序引起的问题。
- en: Scaling monolithic architecture
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展单体架构
- en: As traffic to your server-side application increases, you will need to scale
    your server-side application to handle the traffic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的服务器端应用程序流量的增加，您将需要扩展您的服务器端应用程序以处理流量。
- en: 'In case of monolithic architecture, you can scale the server-side application
    by running the same executable on multiple servers and place the servers behind
    a load balancer or you can use round robin DNS to distribute the traffic among
    the servers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构的情况下，你可以通过在多个服务器上运行相同的可执行文件来扩展服务器端应用程序，并将服务器放置在负载均衡器后面，或者你可以使用轮询DNS在服务器之间分配流量：
- en: '![Scaling monolithic architecture](img/B05154_01_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![扩展单体架构](img/B05154_01_01.jpg)'
- en: In the preceding diagram, all the servers will be running the same server-side
    application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，所有服务器都将运行相同的服务器端应用程序。
- en: Although scaling is easy, scaling monolithic server-side application ends up
    with scaling all the components rather than the components that require greater
    resource. Thus, causing unbalanced utilization of resources sometimes, depending
    on the quantity and types of resources the components need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然扩展很简单，但扩展单体服务器端应用程序最终会导致扩展所有组件，而不是需要更多资源的组件。因此，有时会导致资源利用不平衡，这取决于组件需要的资源和类型。
- en: 'Let''s consider some examples to understand the issues caused while scaling
    monolithic server-side applications:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些例子，以了解在扩展单体服务器端应用程序时产生的问题：
- en: Suppose there is a component of server-side application that requires a more
    powerful or special kind of hardware, we cannot simply scale this particular component
    as all the components are packed together, therefore everything needs to be scaled
    together. So, to make sure that the component gets enough resources, you need
    to run the server-side application on some more servers with powerful or special
    hardware, leading to consumption of more resources than actually required.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设有一个需要更强大或特殊类型硬件的服务器端应用程序组件，我们不能简单地扩展这个特定的组件，因为所有组件都打包在一起，因此，所有东西都需要一起扩展。所以，为了确保该组件获得足够的资源，你需要运行具有强大或特殊硬件的更多服务器上的服务器端应用程序，从而导致消耗比实际所需的更多资源。
- en: Suppose we have a component that requires to be executed on a specific server
    operating system that is not free of charge, we cannot simply run this particular
    component in a non-free operating system as all the components are packed together
    and therefore, just to execute this specific component, we need to install the
    non-free operating system on all servers, increasing the cost greatly.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个需要在特定服务器操作系统上执行的组件，而这个操作系统并非免费，我们不能简单地在这个非免费操作系统上运行这个特定的组件，因为所有组件都打包在一起，因此，仅仅为了执行这个特定的组件，我们需要在所有服务器上安装非免费操作系统，这大大增加了成本。
- en: These are just some examples. There are many more issues that you are likely
    to come across while scaling a monolithic server-side application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是其中的一些例子。在扩展单体服务器端应用程序的过程中，你可能会遇到更多的问题。
- en: So, when we scale monolithic server-side applications, the components that don't
    need more powerful or special kind of resource starts receiving them, therefore
    deceasing resources for the component that needs them. We can say that scaling
    monolithic server-side application involves scaling all components that are forcing
    to duplicate everything in the new servers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们扩展单体服务器端应用程序时，不需要更多强大或特殊类型资源的组件开始接收它们，因此减少了需要这些资源的组件的资源。我们可以这样说，扩展单体服务器端应用程序涉及扩展所有被迫在新服务器上重复一切组件的组件。
- en: Writing monolithic server-side applications
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写单体服务器端应用程序
- en: Monolithic server-side applications are written in a particular programming
    language using a particular framework. Enterprises usually have developers who
    are experts in different programming languages and frameworks to build server-side
    applications; therefore, if they are asked to build a monolithic server-side application,
    then it will be difficult for them to work together.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单体服务器端应用程序是用特定的编程语言和框架编写的。企业通常有精通不同编程语言和框架的开发者来构建服务器端应用程序；因此，如果要求他们构建单体服务器端应用程序，那么他们合作起来将会很困难。
- en: The components of a monolithic server-side application can be reused only in
    the same framework using, which it's built. So, you cannot reuse them for some
    other kind of project that's built using different technologies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单体服务器端应用程序的组件只能在构建它的相同框架中使用，因此，你不能将它们用于使用不同技术构建的其他类型的项目。
- en: Other issues of monolithic architecture
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单体架构的其他问题
- en: 'Here are some other issues that developers might face, depending on the technology
    that is used to build the monolithic server-side application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他的问题，开发者可能会根据用于构建单体服务器端应用程序的技术遇到这些问题：
- en: It may need to be completely rebuild and redeployed for every small change made
    to it. This is a time-consuming task and makes your application inaccessible for
    a long time.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于对其所做的每一个小改动，可能都需要完全重建和重新部署。这是一个耗时的工作，并且会使你的应用程序在长时间内不可用。
- en: It may completely fail if any one of the components fails. It's difficult to
    build a monolithic application to handle failure of specific components and degrade
    application features accordingly.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何一个组件失败，它可能会完全失败。构建一个能够处理特定组件失败并相应降低应用程序功能的单体应用程序是困难的。
- en: It may be difficult to find how much resources are each components consuming.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能很难找到每个组件消耗了多少资源。
- en: It may be difficult to test and debug individual components separately.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能很难单独测试和调试各个组件。
- en: Microservices architecture to the rescue
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的拯救
- en: We saw the problems caused by monolithic architecture. These problems lead developers
    to switch from monolithic architecture to microservices architecture.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了单体架构带来的问题。这些问题导致开发者从单体架构转向微服务架构。
- en: In microservices architecture, the server-side application is divided into services.
    A service (or microservice) is a small and independent process that constitutes
    a particular functionality of the complete server-side application. For example,
    you can have a service for payment processing, another service for account management,
    and so on; the services need to communicate with each other via a network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务器端应用程序被划分为服务。一个服务（或微服务）是一个小型且独立的进程，构成了完整服务器端应用程序的特定功能。例如，你可以有一个用于支付处理的服务，另一个用于账户管理的服务，等等；服务需要通过网络相互通信。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What do you mean by "small" service?**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**“小”服务是什么意思？**'
- en: You must be wondering how small a service needs to be and how to tell whether
    a service is small or not. Well, it actually depends on many factors such as the
    type of application, team management, availability of resources, size of application,
    and how small you think is small. However, a small service doesn't have to be
    the one that is written is fewer lines of code or provides a very basic functionality.
    A small service can be the one on which a team of developers can work independently,
    which can be scaled independently to other services, scaling it doesn't cause
    unbalanced utilization of recourses, and overall they are highly decoupled (independent
    and unaware) of other services.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道一个服务需要多小，以及如何判断一个服务是否小。好吧，实际上这取决于许多因素，如应用程序的类型、团队管理、资源的可用性、应用程序的大小，以及你认为多小才算小。然而，一个小服务不一定是代码行数较少或提供非常基本功能的服务。一个小服务可以是开发者团队可以独立工作的服务，它可以独立扩展到其他服务，扩展它不会导致资源利用不平衡，并且它们在整体上与其他服务高度解耦（独立且不知情）。
- en: You don't have to run each service in a different server, that is, you can run
    multiple services in a single computer. The ratio of server to services depends
    on different factors. A common factor is the amount and type of resources and
    technologies required. For example, if a service needs a lot of RAM and CPU time,
    then it would be better to run it individually on a server. If there are some
    services that don't need much resources, then you can run them all in a single
    server together.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必在每个不同的服务器上运行每个服务，也就是说，你可以在单个计算机上运行多个服务。服务器与服务的比例取决于不同的因素。一个常见的因素是所需资源和技术的数量和类型。例如，如果一个服务需要大量的RAM和CPU时间，那么最好是在服务器上单独运行它。如果有一些服务不需要太多资源，那么你可以将它们全部在单个服务器上一起运行。
- en: 'The following diagram shows an example of the microservices architecture:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了微服务架构的一个示例：
- en: '![Microservices architecture to the rescue](img/B05154_01_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![微服务架构的拯救](img/B05154_01_02.jpg)'
- en: Here, you can think of **Service 1** as the web server with which a browser
    communicates and other services providing APIs for various functionalities. The
    web services communicate with other services to get data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以将**服务1**视为与浏览器通信的Web服务器，以及其他提供各种功能API的服务。Web服务与其他服务通信以获取数据。
- en: Merits of microservices architecture
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构的优点
- en: 'Due to the fact that services are small and independent and communicate via
    network, microservices architecture solves many problems that monolithic architecture
    had. Here are some of the benefits of microservices architecture:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务规模小且独立，并通过网络进行通信，微服务架构解决了单体架构所面临的许多问题。以下是微服务架构的一些好处：
- en: As the services communicate via a network, they can be written in different
    programming languages using different frameworks
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务通过网络进行通信，因此可以使用不同的编程语言和不同的框架来编写。
- en: Making a change to a service only requires that particular service to be redeployed
    instead of all the services, which is a faster procedure
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需要重新部署特定的服务，而不是所有服务，就可以对服务进行更改，这是一个更快的流程。
- en: It becomes easier to measure how much resources are consumed by each service
    as each service runs in a different process
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个服务都在不同的进程中运行，因此测量每个服务消耗了多少资源变得更加容易。
- en: It becomes easier to test and debug, as you can analyze each service separately
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于可以单独分析每个服务，因此测试和调试变得更加容易。
- en: Services can be reused by other applications as they interact via network calls
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以通过网络调用与其他应用程序交互，因此可以被其他应用程序重用。
- en: Scaling services
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务扩展
- en: Apart from the preceding benefits, one of the major benefits of microservices
    architecture is that you can scale individual services that require scaling instead
    of all the services, therefore preventing duplication of resources and unbalanced
    utilization of resources.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的好处之外，微服务架构的一个主要好处是你可以扩展需要扩展的个别服务，而不是所有服务，从而防止资源重复和资源利用不平衡。
- en: 'Suppose we want to scale **Service 1** in the preceding diagram. Here is a
    diagram that shows how it can be scaled:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要扩展前面图中的**服务1**。以下是展示如何扩展的图示：
- en: '![Scaling services](img/B05154_01_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![服务扩展](img/B05154_01_03.jpg)'
- en: Here, we are running two instances of **Service 1** on two different servers
    kept behind a load balancer, which distributes the traffic between them. All other
    services run the same way, as scaling them wasn't required. If you wanted to scale
    **Service 3**, then you can run multiple instances of **Service 3** on multiple
    servers and place them behind a load balancer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在两个不同的服务器上运行**服务1**的两个实例，这两个服务器位于负载均衡器后面，负载均衡器在这两个服务器之间分配流量。所有其他服务都以相同的方式运行，因为不需要扩展它们。如果你想要扩展**服务3**，那么你可以在多个服务器上运行多个**服务3**的实例，并将它们放置在负载均衡器后面。
- en: Demerits of microservices architecture
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构的缺点
- en: 'Although there are a lot of merits of using microservices architecture compared
    to monolithic architecture, there are some demerits of microservices architecture
    as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与单体架构相比，使用微服务架构有很多优点，但微服务架构也有一些缺点：
- en: As the server-side application is divided into services, deploying, and optionally,
    configuring each service separately is a cumbersome and time-consuming task.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务器端应用程序被划分为服务，因此分别部署和（可选）配置每个服务是一项繁琐且耗时的任务。
- en: Note
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that developers often use some sort automation technology (such as AWS,
    Docker, and so on) to make deployment somewhat easier; however, to use it, you
    still need a good level of experience and expertise with that technology.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，开发者通常使用一些自动化技术（如AWS、Docker等）来使部署变得更容易；然而，要使用这些技术，你仍然需要具备对该技术良好的经验和专业知识。
- en: Communication between services is likely to lag as it's done via a network.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务之间的通信是通过网络进行的，因此服务之间的通信可能会延迟。
- en: This sort of server-side applications more prone to network security vulnerabilities
    as services communicate via a network.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种服务器端应用程序更容易受到网络安全漏洞的影响，因为服务是通过网络进行通信的。
- en: Writing code for communicating with other services can be harder, that is, you
    need to make network calls and then parse the data to read it. This also requires
    more processing. Note that although there are frameworks to build server-side
    applications using microservices that make fetching and parsing data easier, it
    still doesn't deduct the processing and network wait time.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为与其他服务通信编写代码可能更困难，也就是说，你需要进行网络调用，然后解析数据以读取它。这也需要更多的处理。请注意，尽管有框架可以构建使用微服务的服务器端应用程序，使获取和解析数据变得更容易，但这仍然不能减少处理和网络等待时间。
- en: You will surely need some sort of monitoring tool to monitor services as they
    may go down due to network, hardware, or software failure. Although you may use
    the monitoring tool only when your application suddenly stops, to build the monitoring
    software or use some sort of service, monitoring software needs some level of
    extra experience and expertise.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你肯定需要某种监控工具来监控服务，因为它们可能会因为网络、硬件或软件故障而停止。尽管你可能只在应用程序突然停止时使用监控工具，但要构建监控软件或使用某种服务，监控软件需要一定程度的额外经验和专业知识。
- en: Microservices-based server-side applications are slower than monolithic-based
    server-side applications as communication via networks is slower compared to memory.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于微服务的服务器端应用程序比基于单体架构的服务器端应用程序要慢，因为通过网络进行通信比通过内存要慢。
- en: When to use microservices architecture
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用微服务架构
- en: It may seem like its difficult to choose between monolithic and microservices
    architecture, but it's actually not so hard to decide between them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选择单体和微服务架构可能看起来很困难，但实际上决定它们并不那么难。
- en: If you are building a server-side application using monolithic architecture
    and you feel that you are unlikely to face any monolithic issues that we discussed
    earlier, then you can stick to monolithic architecture. In future, if you are
    facing issues that can be solved using microservices architecture, then you should
    switch to microservices architecture.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用单体架构构建服务器端应用程序，并且你认为你不太可能遇到我们之前讨论过的任何单体问题，那么你可以坚持使用单体架构。将来，如果你遇到可以用微服务架构解决的问题，那么你应该切换到微服务架构。
- en: If you are switching from a monolithic architecture to microservices architecture,
    then you don't have to rewrite the complete application, instead you can only
    convert the components that are causing issues to services by doing some code
    refactoring. This sort of server-side applications where the main application
    logic is monolithic but some specific functionality is exposed via services is
    called microservices architecture with monolithic core. As issues increase further,
    you can start converting more components of the monolithic core to services.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在从单体架构切换到微服务架构，那么你不必重写整个应用程序，而是可以通过进行一些代码重构，将导致问题的组件转换为服务。这种主要应用程序逻辑是单体但某些特定功能通过服务公开的服务器端应用程序称为具有单体核心的微服务架构。随着问题的进一步增加，你可以开始将更多单体核心的组件转换为服务。
- en: '![When to use microservices architecture](img/B05154_01_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![何时使用微服务架构](img/B05154_01_04.jpg)'
- en: If you are building a server-side application using monolithic architecture
    and you feel that you are likely to face any of the monolithic issues that we
    discussed earlier, then you should immediately switch to microservices architecture
    or microservices architecture with monolithic core, depending on what suits you
    the best.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用单体架构构建服务器端应用程序，并且你认为你可能会遇到我们之前讨论过的任何单体问题，那么你应该立即切换到微服务架构或具有单体核心的微服务架构，具体取决于最适合你的选择。
- en: Data management
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据管理
- en: In microservices architecture, each service can have its own database to store
    data and can also use a centralized database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务都可以有自己的数据库来存储数据，也可以使用集中式数据库。
- en: Some developers don't use a centralized database at all, instead all services
    have their own database to store the data. To synchronize the data between the
    services, the services omit events when their data is changed and other services
    subscribe to the event and update the data. The problem with this mechanism is
    that if a service is down, then it may miss some events. There is also going to
    be a lot of duplicate data, and finally, it is difficult to code this kind of
    system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者根本不使用集中式数据库，而是所有服务都有自己的数据库来存储数据。为了在服务之间同步数据，当它们的数据发生变化时，服务会省略事件，而其他服务则订阅事件并更新数据。这种机制的问题在于，如果某个服务宕机，它可能会错过一些事件。还可能会有大量的重复数据，最后，编写这种系统也相当困难。
- en: Therefore, it's a good idea to have a centralized database and also let each
    service to maintain their own database if they want to store something that they
    don't want to share with others. Services should not connect to the centralized
    database directly, instead there should be another service called **database service**
    that provides APIs to work with the centralized database. This extra layer has
    many advantages, such as the underlying schema can be changed without updating
    and redeploying all the services that are dependent on the schema, we can add
    a caching layer without making changes to the services, you can change the type
    of database without making any changes to the services and there are many other
    benefits. We can also have multiple database services if there are multiple schemas,
    or if there are different types of database, or due to some other reason that
    benefits the overall architecture and decouples the services.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，拥有一个集中式数据库并允许每个服务在需要存储不希望与他人共享的数据时维护自己的数据库是一个好主意。服务不应直接连接到集中式数据库，而应该有一个名为
    **数据库服务** 的其他服务，它提供与集中式数据库交互的 API。这个额外的层有许多优点，例如，可以更改底层模式而无需更新和重新部署依赖于该模式的全部服务，我们可以在不更改服务的情况下添加缓存层，可以更改数据库类型而不对服务进行任何更改，并且还有许多其他好处。如果存在多个模式，或者有不同类型的数据库，或者由于其他有利于整体架构并解耦服务的其他原因，我们还可以拥有多个数据库服务。
- en: Implementing microservices using Seneca
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Seneca 实现微服务
- en: Seneca is a Node.js framework for creating server-side applications using microservices
    architecture with monolithic core.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca 是一个用于使用微服务架构和单体核心创建服务器端应用的 Node.js 框架。
- en: Earlier, we discussed that in microservices architecture, we create a separate
    service for every component, so you must be wondering what's the point of using
    a framework for creating services that can be done by simply writing some code
    to listen to a port and reply to requests. Well, writing code to make requests,
    send responses, and parse data requires a lot of time and work, but a framework
    like Seneca makes all this easy. Also, converting the components of a monolithic
    core to services is also a cumbersome task as it requires a lot of code refactoring,
    but Seneca makes it easy by introducing the concepts of actions and plugins. Finally,
    services written in any other programming language or framework will be able to
    communicate with Seneca services.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们讨论了在微服务架构中，我们为每个组件创建一个独立的服务，所以你可能想知道使用框架来创建服务（这些服务可以通过简单地编写一些代码来监听端口并回复请求来完成）有什么意义。好吧，编写代码来发起请求、发送响应和解析数据需要花费很多时间和精力，但像
    Seneca 这样的框架可以让这一切变得简单。此外，将单体核心的组件转换为服务也是一个繁琐的任务，因为它需要大量的代码重构，但 Seneca 通过引入动作和插件的概念使其变得容易。最后，用任何其他编程语言或框架编写的服务都将能够与
    Seneca 服务进行通信。
- en: In Seneca, an action represents a particular operation. An action is a function
    that's identified by an object literal or JSON string called the action pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Seneca 中，一个动作代表一个特定的操作。动作是一个通过称为动作模式的对象字面量或 JSON 字符串来标识的函数。
- en: In Seneca, these operations of a component of monolithic core are written using
    actions, which we may later want to move from monolithic core to a service and
    expose it to other services and monolithic cores via a network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Seneca 中，这些单体核心组件的操作是通过动作编写的，我们可能希望以后将这些操作从单体核心移动到服务，并通过网络将其暴露给其他服务和单体核心。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why actions?**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么是动作？**'
- en: You might be wondering what is the benefit of using actions instead of functions
    to write operations and how actions make it easy to convert components of monolithic
    core to services? Suppose you want to move an operation of monolithic core that
    is written using a function to a separate service and expose the function via
    a network, then you cannot simply copy and paste the function to the new service,
    instead you need to define a route (if you are using Express). To call the function
    inside the monolithic core, you will need to write code to make an HTTP request
    to the service. To call this operation inside the service, you can simply call
    a function so that there are two different code snippets depending from where
    you are executing the operation. Therefore, moving operations requires a lot of
    code refactoring. However, if you would have written the preceding operation using
    the Seneca action, then it would have been really easy to move the operation to
    a separate service.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道使用操作而不是函数来编写操作有什么好处，以及操作如何使将单体核心的组件转换为服务变得容易？假设你想要将使用函数编写的单体核心操作移动到单独的服务中并通过网络公开，那么你无法简单地复制和粘贴该函数到新服务中，相反，你需要定义一个路由（如果你使用
    Express）。要调用单体核心内的函数，你需要编写代码向服务发出 HTTP 请求。要调用服务内的此操作，你可以简单地调用一个函数，因此根据你执行操作的位置，会有两个不同的代码片段。因此，移动操作需要大量的代码重构。然而，如果你使用
    Seneca 操作编写前面的操作，那么将操作移动到单独的服务中将会非常容易。
- en: In case the operation is written using action, and you want to move the operation
    to a separate service and expose the operation via a network, then you can simply
    copy and paste the action to the new service. That's it. Obviously, we also need
    to tell the service to expose the action via the network and tell the monolithic
    core where to find the action, but all these require just couple of lines of code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作是用操作编写的，并且你想要将操作移动到单独的服务中并通过网络公开，那么你只需将操作复制和粘贴到新服务中即可。就是这样。显然，我们还需要告诉服务通过网络公开操作，并告诉单体核心在哪里可以找到操作，但所有这些只需要几行代码。
- en: A Seneca service exposes actions to other services and monolithic cores. While
    making requests to a service, we need to provide a pattern matching an action's
    pattern to be called in the service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca 服务向其他服务和单体核心公开操作。在向服务发出请求时，我们需要提供一个与操作模式匹配的模式，以便在服务中调用该操作。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why patterns?**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么使用模式？**'
- en: Patterns make it easy to map a URL to an action. Patterns can overwrite other
    patterns for specific conditions, therefore it prevents editing the existing code,
    as editing the existing code in a production site is not safe and has many other
    disadvantages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 模式使将 URL 映射到操作变得容易。模式可以根据特定条件覆盖其他模式，因此它防止了对现有代码的编辑，因为在生产网站上编辑现有代码是不安全的，并且有许多其他缺点。
- en: Seneca also has a concept of plugins. A `seneca` plugin is actually a set of
    actions that can be easily distributed and plugged in to a service or monolithic
    core.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca 还有一个插件的概念。`seneca` 插件实际上是一组可以轻松分发和插入到服务或单体核心中的操作。
- en: As our monolithic core becomes larger and complex, we can convert components
    to services. That is, move actions of certain components to services.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的单体核心变得更大和更复杂，我们可以将组件转换为服务。也就是说，将某些组件的操作移动到服务中。
- en: Creating your first Seneca application
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你的第一个 Seneca 应用程序
- en: Let's create a basic application using Seneca to demonstrate how to use it.
    We will create an application that allows users to log in and register. This will
    be a demo application just to demonstrate how actions, plugins, and services can
    be created, and not how login and registration functionality works.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Seneca 创建一个基本的应用程序来演示如何使用它。我们将创建一个允许用户登录和注册的应用程序。这将是一个演示应用程序，仅用于演示如何创建操作、插件和服务，而不是演示登录和注册功能的工作原理。
- en: 'Before you proceed further, create a directory named `seneca-example` and place
    a file named `package.json` in it. Inside the `seneca-example` directory, we will
    place our services and monolithic core. Inside the `package.json` file, place
    the following code so that npm will be able to download the dependencies for our
    application:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续之前，创建一个名为 `seneca-example` 的目录，并在其中放置一个名为 `package.json` 的文件。在 `seneca-example`
    目录中，我们将放置我们的服务和单体核心。在 `package.json` 文件中，放置以下代码，以便 npm 能够下载我们应用程序的依赖项：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we are using Seneca version 0.6.5\. Make sure that you are also using the
    same version to avoid code incompatibility.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 Seneca 版本 0.6.5。请确保您也使用相同的版本，以避免代码不兼容。
- en: Now run the `npm install` command inside the `seneca-example` directory to install
    Seneca and other packages locally.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `seneca-example` 目录中运行 `npm install` 命令以本地安装 Seneca 和其他包。
- en: Now create a file named `main.js` that will be the monolithic core of our server
    side application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为 `main.js` 的文件，它将成为我们服务器端应用程序的单一代码库核心。
- en: 'The monolithic core and services are all `seneca` instances programmatically.
    Place this code in the `main.js` file to create a `seneca` instance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单一代码库和所有服务都是 `seneca` 实例。将以下代码放置在 `main.js` 文件中以创建一个 `seneca` 实例：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now using this `seneca` object, we are going to add actions, call actions, add
    plugins, and everything.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将使用这个 `seneca` 对象添加操作、调用操作、添加插件以及做所有事情。
- en: Creating actions
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建操作
- en: Let's create actions for login and registration functionality and place them
    in the `main.js` file. To create actions, we need to use the `add` method of the
    `seneca` object. The first argument of the `add` method takes a JSON string or
    object that is the action identifier (called **pattern** to identify the action).
    The second argument is a callback that will be executed when the action is invoked.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为登录和注册功能创建操作，并将它们放置在 `main.js` 文件中。要创建操作，我们需要使用 `seneca` 对象的 `add` 方法。`add`
    方法的第一个参数接受一个 JSON 字符串或对象，它是操作标识符（称为 **pattern** 以识别操作）。第二个参数是一个回调函数，当操作被调用时将被执行。
- en: 'Place this code in the `main.js` file that creates two actions for login and
    registration, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放置在创建两个登录和注册操作的 `main.js` 文件中，如下所示：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will see the code for the body of the actions later in this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到操作体的代码。
- en: There is nothing special about `role` and `cmd` properties. You can use any
    property names you wish too.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`role` 和 `cmd` 属性没有特殊之处。你可以使用任何你想要的属性名。'
- en: The second argument is a callback, which will be invoked when the action is
    called.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个回调函数，当操作被调用时将被调用。
- en: If there are multiple actions with the same pattern, then the later overrides
    the others.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个具有相同模式的操作，则后面的操作会覆盖其他操作。
- en: We need to use the `act` method of the `seneca` object to invoke an action that's
    local to the instance or resides on some other service. The first argument of
    the `act` method is a pattern to match an action, and the second argument is a
    callback that will be executed once the action has been invoked.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用 `seneca` 对象的 `act` 方法来调用实例本地的操作或位于其他服务上的操作。`act` 方法的第一个参数是一个模式，用于匹配操作，第二个参数是一个回调函数，当操作被调用后将被执行。
- en: 'Here is an example code that shows how to call the preceding two actions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例代码，展示了如何调用前面的两个操作：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The callback passed to the `act` method is executed asynchronously once the
    result of the action arrives.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `act` 方法的回调函数会在操作的结果到达后异步执行。
- en: Here, the object we passed to the `act` method has two extra properties than
    the action's pattern it is supposed to match. However, the action is still matched
    and invoked because in case the pattern passed to the `act` method has more properties
    than the action's pattern it is supposed to match, Seneca finds all the action's
    patterns whose properties are in the pattern passed to the `act` method and invokes
    the one that has the highest number of matching properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递给 `act` 方法的对象比它应该匹配的操作模式多两个额外属性。然而，操作仍然被匹配并调用，因为如果传递给 `act` 方法的模式属性多于操作模式应该匹配的属性，Seneca
    会找到所有具有与传递给 `act` 方法的模式属性匹配的操作模式，并调用具有最多匹配属性的那个操作。
- en: If Seneca finds multiple action patterns with equal number of matching properties,
    then they are matched in ascending alphabetical order.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Seneca 找到具有相等匹配属性数量的多个操作模式，则它们将按升序字母顺序匹配。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Seneca pattern matching at [http://senecajs.org/getting-started.html#patterns-unique-override](http://senecajs.org/getting-started.html#patterns-unique-override).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://senecajs.org/getting-started.html#patterns-unique-override](http://senecajs.org/getting-started.html#patterns-unique-override)
    了解更多关于 Seneca 模式匹配的信息。
- en: Creating plugins
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建插件
- en: A Seneca plugin is just a set of related actions packed together. Programmatically,
    a `seneca` plugin can be created using a function or module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca 插件是一组相关操作的集合。从编程角度来看，可以使用函数或模块创建 `seneca` 插件。
- en: A plugin makes it easy to distribute a set of actions among applications. You
    will also find `seneca` plugins in online public package registry maintained by
    npm. For example, there is a `seneca` plugin that provides actions to work with
    the MongoDB database. This plugin can be inserted into monolithic cores or services
    with just a single line of code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 插件使得在应用程序之间分发一组动作变得容易。你也会在由npm维护的在线公共包注册库中找到`seneca`插件。例如，有一个`seneca`插件提供了与MongoDB数据库一起工作的动作。这个插件只需一行代码就可以插入单体核心或服务。
- en: By default, Seneca installs four built-in plugins when we create a `seneca`
    instance. These plugins are **basic**, **transport**, **web**, and **mem-store**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们创建一个`seneca`实例时，Seneca会安装四个内置插件。这些插件是**basic**、**transport**、**web**和**mem-store**。
- en: Let's first create a plugin using a function. The function name is the plugin
    name, and a plugin can also have an initialization action, which will be invoked
    as soon as the plugin is attached to the `seneca` instance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先使用一个函数创建一个插件。函数名称就是插件名称，插件也可以有一个初始化动作，这个动作将在插件附加到`seneca`实例时立即被调用。
- en: 'So, let''s create a plugin named `account` and place the login and register
    actions in that, as later on, we will be creating a service and moving the actions
    there. Remove the actions we defined earlier in the `main.js` file and place the
    following code instead:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个名为`account`的插件，并将登录和注册动作放在其中，因为稍后我们将创建一个服务并将动作移到那里。删除我们在`main.js`文件中之前定义的动作，并替换以下代码：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we defined a function named `account` and attached it using the `use` method
    of the `seneca` object. To attach multiple plugins, we can call the `use` method
    multiple times.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了一个名为`account`的函数，并使用`seneca`对象的`use`方法将其附加。要附加多个插件，我们可以多次调用`use`方法。
- en: The `init:account` action is the initialization action invoked by Seneca once
    the plugin is added. This can be used to do things such as establishing database
    connection or other things that the actions of the plugin depend on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`init:account`动作是Seneca在插件添加后调用的初始化动作。这可以用来做诸如建立数据库连接或其他插件动作所依赖的事情。'
- en: The `this` keyword inside the plugin refers to the `seneca` instance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 插件内部的`this`关键字指的是`seneca`实例。
- en: 'Let''s create the same plugin using a module so that it''s easily distributable
    and can be put up in the `npm` registry. Create a file named `account.js` and
    place it in the `seneca-example` directory. `account.js` is the plugin module.
    Place this code inside the `account.js` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用模块创建相同的插件，以便它易于分发，并可以放入`npm`注册库中。创建一个名为`account.js`的文件，并将其放置在`seneca-example`目录中。`account.js`是插件模块。将此代码放入`account.js`文件中：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here is the plugin name in the string returned by the anonymous function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是匿名函数返回的字符串中的插件名称。
- en: 'Remove the plugin code that we previously defined in the `main.js` file and
    place the following code instead:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 删除我们在`main.js`文件中之前定义的插件代码，并替换以下代码：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, to attach the plugin, we are providing the module path.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了附加插件，我们提供了模块路径。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about creating Seneca plugins at [http://senecajs.org/write-a-plugin.html](http://senecajs.org/write-a-plugin.html),
    and you can find all the Seneca plugins at [http://senecajs.org/plugins.html](http://senecajs.org/plugins.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://senecajs.org/write-a-plugin.html](http://senecajs.org/write-a-plugin.html)了解更多关于创建Seneca插件的信息，你可以在[http://senecajs.org/plugins.html](http://senecajs.org/plugins.html)找到所有Seneca插件。
- en: Creating services
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建服务
- en: A service is a seneca instance that exposes some actions via network. Let's
    create a service that exposes the login and register actions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是一个通过网络公开一些动作的`seneca`实例。让我们创建一个公开登录和注册动作的服务。
- en: 'Create an `account-service.js` file in the `seneca-example` directory that
    will act as the service. Then place the following code in it to create a service
    that exposes the login and register actions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`seneca-example`目录下创建一个名为`account-service.js`的文件，它将作为服务。然后将其中的以下代码放入其中，以创建一个公开登录和注册动作的服务：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we first created a `seneca` instance. Then we added actions via a plugin.
    You can also manually add actions using the `add` method of the `seneca` object.
    Finally, we exposed the actions via an HTTP protocol. Seneca also supports other
    protocols, but we will stick to HTTP, as it's the most commonly used one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们首先创建了一个`seneca`实例。然后通过插件添加了动作。你也可以使用`seneca`对象的`add`方法手动添加动作。最后，我们通过HTTP协议公开了这些动作。Seneca也支持其他协议，但我们将坚持使用HTTP，因为它是使用最广泛的协议。
- en: '`seneca.listen` creates an HTTP server to listen to requests. We also provided
    the port number and pin, which are optional. The default port is `10101`, and
    by default, there is no pin if not provided.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`seneca.listen`创建一个HTTP服务器来监听请求。我们还提供了端口号和引脚，这两者都是可选的。默认端口号是`10101`，如果没有提供，则默认没有引脚。'
- en: You must be wondering what is a pin and what is it used for? Well, you may not
    always want to expose all the actions of the service via a network. In that case,
    you can provide a pattern to the `pin` property and the server will handle these
    requests that match the `pin` pattern.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道引脚是什么，以及它用于什么？好吧，您可能并不总是想通过网络公开服务的所有动作。在这种情况下，您可以为`pin`属性提供一个模式，服务器将处理与`pin`模式匹配的请求。
- en: Now, for other services or monolithic cores to be able to call the actions of
    this service, they need to register this service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了其他服务或单体核心能够调用此服务的动作，它们需要注册此服务。
- en: 'Remove the previous plugin attachment code from the `main.js` file and add
    the following code to register the service:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从`main.js`文件中删除之前的插件附加代码，并添加以下代码来注册服务：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we are registering the service by providing the `port` number and `pin`.
    Both of them are optional. In case if we don't use any port number, then it defaults
    to `10101`. In case the service is on different server, then you should use the
    `host` property to provide the IP address.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过提供`port`号码和`pin`来注册服务。这两者都是可选的。如果我们不使用任何端口号，则默认为`10101`。如果服务在不同的服务器上，则应使用`host`属性来提供IP地址。
- en: The `pin` attached to the `client` method is used to tell the `seneca` instance
    about what actions are exposed by the service. It's completely optional. Seneca
    won't send requests to a service that doesn't match the `pin` pattern.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 附在`client`方法上的`pin`用于告诉`seneca`实例服务公开了哪些动作。这是完全可选的。Seneca不会向不匹配`pin`模式的任何服务发送请求。
- en: You can add as many services as you want by calling the client method multiple
    times.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多次调用客户端方法来添加您想要的服务。
- en: When you call the `act` method to invoke an action, the `seneca` instance first
    looks for the action locally before requesting services. If it's not found locally,
    then it checks for the services that have a pin to see if it matches any. If a
    pin matches, then it sends request to this particular service. Finally, if any
    of the pin doesn't match, it sends the requests one by one to all other services
    that don't have a pin till it gets a valid response from one of them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`act`方法来调用一个动作时，`seneca`实例首先在本地查找该动作，然后再请求服务。如果本地找不到，它将检查具有引脚的服务，看是否有匹配的。如果引脚匹配，则向该特定服务发送请求。最后，如果任何引脚不匹配，它将逐个向所有没有引脚的其他服务发送请求，直到从其中之一获得有效响应。
- en: 'You can also manually call an action of a service by sending the GET request
    to these types of URL:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过向这些类型的URL发送GET请求来手动调用服务的动作：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also call a service by using the POST request. Here is how to do it
    using CURL:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用POST请求来调用服务。以下是如何使用CURL进行操作的示例：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Storing data
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储数据
- en: Seneca provides a built-in mechanism to store data. Seneca provides some built-in
    actions that allow us to store data. The built-in actions use `mem-store` to store
    data by default. **mem-store** is an asynchronous in-memory storage system.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca提供了一个内置机制来存储数据。Seneca提供了一些内置动作，允许我们存储数据。内置动作默认使用`mem-store`来存储数据。**mem-store**是一个异步的内存存储系统。
- en: You can create your application using the default storing mechanism. In case
    you want to change the underlying store system, you just need to install plugin
    for this particular storage system that will overwrite the built-in storage actions,
    therefore you will not have to refactor any code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用默认的存储机制来创建您的应用程序。如果您想更改底层存储系统，只需安装特定存储系统的插件即可，这将覆盖内置存储动作，因此您不需要重构任何代码。
- en: 'The built-in actions to do the CRUD operations are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 执行CRUD操作的内建动作如下：
- en: '`role:entity,cmd:load,name:<entity-name>`: This is used to retrieve an entity
    using its ID. An entity can be thought of as a row in MySQL. Every entity gets
    a unique ID.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role:entity,cmd:load,name:<entity-name>`：这是用来通过其ID检索实体的。实体可以被视为MySQL中的一行。每个实体都有一个唯一的ID。'
- en: '`role:entity,cmd:save,name:<entity-name>`: This is used to update (if you provide
    entity ID) or add an entity if it does not exist. Entities are stored and retrieved
    in form of objects.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role:entity,cmd:save,name:<entity-name>`：这是用来更新（如果您提供实体ID）或添加实体（如果不存在）。实体以对象的形式存储和检索。'
- en: '`role:entity,cmd:list,name:<entity-name>`: This is used to list all the entities
    that are matching a query.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role:entity,cmd:list,name:<entity-name>`：这是用于列出所有与查询匹配的实体。'
- en: '`role:entity,cmd:remove,name:<entity-name>`: This is used to remove an entity
    using its ID.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role:entity,cmd:remove,name:<entity-name>`：这是用于使用其实体 ID 删除实体。'
- en: Seneca also provides some wrapper functions that extract these actions and make
    it easy to call these actions. These functions are `load$`, `save$`, `list$`,
    and `remove$`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca 还提供了一些包装函数，用于提取这些操作并使其调用这些操作变得容易。这些函数是 `load$`、`save$`、`list$` 和 `remove$`。
- en: Let's implement the login and register actions to allow us to log in and also
    register new accounts.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现登录和注册操作，以便我们可以登录并注册新的账户。
- en: 'Here is the implementation of the account action. Update this code in the `account.js`
    file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是账户操作的实现。在 `account.js` 文件中更新此代码：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first argument of the callback passed to the `add` method holds reference
    to the object that matched against the pattern of the action.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `add` 方法的回调的第一个参数持有与操作的模板匹配的对象的引用。
- en: Here we are first calling the `make` method of the `seneca` object. It's used
    to get reference of an entity's store. For example, in case of MySQL, the `make`
    method gets reference to a table.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先调用 `seneca` 对象的 `make` 方法。它用于获取实体存储的引用。例如，在 MySQL 的情况下，`make` 方法获取到表的引用。
- en: Then, we will find whether there are any entities with the username and password
    passed by the `act` method. As entities are added as objects, to query for entities,
    we need to pass an object. Now `list$` looks for all entities with the same username
    and password.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将查找是否有任何实体具有通过 `act` 方法传递的用户名和密码。由于实体作为对象添加，为了查询实体，我们需要传递一个对象。现在 `list$`
    查找所有具有相同用户名和密码的实体。
- en: We are passing a callback to the `$list` method that will be invoked asynchronously
    once the data is retrieved. This callback takes two parameters, that is, the first
    parameter is an `error` object if there is an error, otherwise `null`.Similarly,
    the second parameter is an array of entities found matching the given object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将一个回调传递给 `$list` 方法，该方法将在数据检索后异步调用。此回调有两个参数，即第一个参数是如果存在错误，则为 `error` 对象，否则为
    `null`。第二个参数是找到的与给定对象匹配的实体数组。
- en: For the action to respond back, it needs to call the second parameter of the
    action callback by passing it an object as the second argument. In case an error
    has occurred, we need to pass the error in the first argument.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让操作能够响应，它需要通过传递一个对象作为第二个参数调用操作回调的第二个参数。如果发生错误，我们需要在第一个参数中传递错误。
- en: 'Similarly, now let''s write the code for the register action, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，现在让我们编写注册操作的代码，如下所示：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, most of the code is understandable as it works the same way as the previous
    action. To store data, we are creating a new entity store reference using the
    `data$` method by passing the entity we want to store. Then we are calling the
    `save$` method to save the entity.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，大部分代码都是可理解的，因为它的工作方式与之前的操作相同。为了存储数据，我们通过传递要存储的实体使用 `data$` 方法创建一个新的实体存储引用。然后我们调用
    `save$` 方法来保存实体。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about storing data in Seneca, visit [http://senecajs.org/data-entities.html](http://senecajs.org/data-entities.html).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于在 Seneca 中存储数据的信息，请访问 [http://senecajs.org/data-entities.html](http://senecajs.org/data-entities.html)。
- en: Integrating Express and Seneca
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成 Express 和 Seneca
- en: We have completed creating our login and register actions. Now, as our backend
    will be used by an app or it may represent as a website, we need to provide URLs
    to the clients who will use them to talk to the server.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了登录和注册操作的创建。现在，由于我们的后端将被应用程序使用，或者它可能代表一个网站，我们需要为将使用它们与服务器通信的客户端提供 URL。
- en: Monolithic core is the part of our server-side application that the client interacts
    with for most of the functionality. Clients can also interact with services directly
    for some specific functionality if required.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 单体核心是我们服务器端应用程序的一部分，客户端在大多数功能上与之交互。如果需要，客户端也可以直接与服务交互以实现某些特定功能。
- en: So, we need to use some sort of website development framework in the monolithic
    core and services of our server-side application. We will be using Express, as
    it's the most popular one.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要在我们的服务器端应用程序的单体核心和服务的某些部分使用一种网站开发框架。我们将使用 Express，因为它是最受欢迎的。
- en: Seneca also provides a built-in way to map the URLs to actions, that is, requests
    made to an HTTP server can be automatically mapped to a particular action to invoke
    them. This is done using a definition object whose properties define a route mapping
    from URLs to action patterns. This built-in method defines route mapping independent
    of the framework being used. Once we have defined the definition objects, we need
    a plugin specific to the web server framework that will capture and resolve the
    URLs to action patterns using the definition objects. Definition object allows
    you to attach callbacks that will get the response of the action via a parameter,
    and then the callbacks can return the data to the user in whatever format they
    want. This can be useful in case you are creating a plugin for distribution that
    exposes a few actions that need to be called for specific URL requests, then you
    will have to use the built-in method, as it defines route mapping independent
    of the framework being used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca 还提供了一种内置方式将 URL 映射到动作，即发送到 HTTP 服务器的请求可以自动映射到特定的动作以调用它们。这是通过一个定义对象完成的，其属性定义了从
    URL 到动作模式的路由映射。这个内置方法定义了独立于所使用的框架的路由映射。一旦我们定义了定义对象，我们需要一个特定于 Web 服务器框架的插件来捕获并解析
    URL 到动作模式，使用定义对象。定义对象允许你附加回调函数，这些回调函数将通过参数获取动作的响应，然后回调函数可以以他们想要的任何格式将数据返回给用户。如果你正在创建一个需要公开一些特定
    URL 请求的调用动作的插件进行分发，那么你将不得不使用内置方法，因为它定义了独立于所使用的框架的路由映射。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about how to use the built-in way to integrate Seneca and
    Express at [https://github.com/rjrodger/seneca-web](https://github.com/rjrodger/seneca-web).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/rjrodger/seneca-web](https://github.com/rjrodger/seneca-web)了解更多如何使用内置方式将
    Seneca 和 Express 集成。
- en: 'Add the following code to the `main.js` file to start the Express server in
    it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `main.js` 文件中，以在其中启动 Express 服务器：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On the second line, we are exporting a middleware function provided by the `seneca-web`
    plugin. `seneca-web` is the plugin to integrate Seneca and Express directly, that
    is, to translate URLs into action patterns using the definition object for Express
    framework. This is only required if we use the definition object to define route
    mapping. We won't be using definition objects, but we should still use `seneca-web`,
    as some third-party plugins may use definition objects if we are using these plugins.
    For example, if you are using the `seneca-auth` plugin, then you will have to
    include second line.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们导出由 `seneca-web` 插件提供的中间件函数。`seneca-web` 是用于直接集成 Seneca 和 Express 的插件，即使用
    Express 框架的定义对象将 URL 转换为动作模式。如果我们使用定义对象来定义路由映射，则这是必需的。我们不会使用定义对象，但我们应该仍然使用 `seneca-web`，因为如果使用这些插件，一些第三方插件可能会使用定义对象。例如，如果你使用
    `seneca-auth` 插件，那么你将不得不包含第二行。
- en: 'We want the user to be able to log in using the `/account/login` path and register
    using the `/account/register` path. The user will provide a username and password
    via query string. Here is the code to define routes to handle HTTP requests for
    login and registration:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户能够通过 `/account/login` 路径登录，并通过 `/account/register` 路径注册。用户将通过查询字符串提供用户名和密码。以下是定义处理登录和注册
    HTTP 请求路由的代码：
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we are calling the appropriate actions depending on the path of the URL
    request.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据 URL 请求的路径调用适当的动作。
- en: Here, instead of using `seneca.act`, we are using `httpRequest.seneca.act` as
    the middleware function that we exported earlier adds a new `seneca` property
    to request the object of every HTTP requests. This property inherits the actual
    `seneca` instance. Actions in the third-party plugins add information in form
    of properties to the `seneca` property in order to share information related to
    a particular HTTP request with other route handers. The preceding code will behave
    in the same way even if we use `seneca.act`, but it's a good practice to use `httpRequest.seneca.act`
    as we may use such types of plugins. Your own route handlers can also use `httpRequest.seneca.act`
    to pass information related to `seneca` to each other.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是使用 `seneca.act`，而是使用 `httpRequest.seneca.act` 作为我们之前导出的中间件函数，它为每个 HTTP
    请求对象添加一个新的 `seneca` 属性。这个属性继承实际的 `seneca` 实例。第三方插件中的动作通过将属性添加到 `seneca` 属性中，以便与其他路由处理器共享与特定
    HTTP 请求相关的信息。即使我们使用 `seneca.act`，前面的代码也会以相同的方式运行，但使用 `httpRequest.seneca.act`
    是一个好习惯，因为我们可能会使用这种类型的插件。你自己的路由处理器也可以使用 `httpRequest.seneca.act` 来传递与 `seneca`
    相关的信息。
- en: 'Now, to run the application, first run the `account-service.js` file and then
    the `main.js` file. You can then log in and register using the following URLs:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要运行应用程序，首先运行 `account-service.js` 文件，然后运行 `main.js` 文件。您可以使用以下 URL 登录和注册：
- en: '`http://localhost:8080/account/login?username=narayan&password=mypassword`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/account/login?username=narayan&password=mypassword`'
- en: '`http://localhost:8080/account/register?username=x&password=mypassword`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/account/register?username=x&password=mypassword`'
- en: Here, we saw how to create a web interface, which can be used by an app or to
    serve HTML pages in case it's a website.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了如何创建一个网页界面，它可以被应用程序使用，或者如果是一个网站，可以用来提供 HTML 页面。
- en: We can also move the routes of Express to a service if we want a different service
    to handle certain requests.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望不同的服务来处理某些请求，我们也可以将 Express 的路由移动到该服务中。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw the difference between monolithic and microservices
    architecture. Then we discussed what microservices architecture with monolithic
    core means and its benefits. Finally, we jumped into the Seneca framework for
    implementing microservices architecture with monolithic core and discussed how
    to create a basic login and registration functionality to demonstrate various
    features of the Seneca framework and how to use it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了单体架构和微服务架构之间的区别。然后我们讨论了具有单体核心的微服务架构的含义及其优势。最后，我们探讨了使用 Seneca 框架实现具有单体核心的微服务架构，并讨论了如何创建基本的登录和注册功能来展示
    Seneca 框架的各种特性以及如何使用它。
- en: In the next chapter, we will create a fully functional e-commerce website using
    Seneca and Express frameworks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Seneca 和 Express 框架创建一个功能齐全的电子商务网站。
