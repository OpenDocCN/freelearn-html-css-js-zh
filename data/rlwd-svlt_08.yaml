- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Context versus Stores
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文与存储的比较
- en: A Svelte application can be composed of one or many Svelte components. A Svelte
    component can be seen as a standalone unit, encapsulating its own reactive data
    and logic. In the previous chapter, we learned how two Svelte components – in
    particular, components in a parent and child relationship – communicate and pass
    data between each other. In this chapter, however, we are going to explore communication
    and passing data between components beyond the parent and child relationship.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Svelte 应用可以由一个或多个 Svelte 组件组成。一个 Svelte 组件可以被看作是一个独立的单元，封装了自己的响应式数据和逻辑。在前一章中，我们学习了两个
    Svelte 组件——特别是父组件和子组件之间的关系——是如何相互通信和传递数据的。然而，在本章中，我们将探索超出父子和关系的组件间的通信和数据传递。
- en: Svelte provides two primitives to pass data across Svelte components – Svelte
    context and Svelte stores. Svelte context allows you to pass data from an ancestor
    to all children, while Svelte stores use the observer pattern to allow you to
    access reactive data across multiple unrelated Svelte components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 提供了两个原语来在 Svelte 组件间传递数据——Svelte 上下文和 Svelte 存储。Svelte 上下文允许你从祖先组件传递数据到所有子组件，而
    Svelte 存储使用观察者模式允许你在多个无关的 Svelte 组件间访问响应式数据。
- en: In the coming five chapters, we are going to explore the different use cases
    of Svelte context and Svelte stores. In this chapter, we will cover what Svelte
    context and Svelte stores are.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的五章节中，我们将探讨 Svelte 上下文和 Svelte 存储的不同用例。在本章中，我们将介绍 Svelte 上下文和 Svelte 存储是什么。
- en: We will talk about when to use Svelte context and/or Svelte stores and the considerations
    for choosing them. We will then proceed with an example of a combination of both
    Svelte context and Svelte stores – a Svelte context store.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论何时使用 Svelte 上下文和/或 Svelte 存储，以及选择它们的考虑因素。然后我们将通过一个结合了 Svelte 上下文和 Svelte
    存储的示例来继续讨论——一个 Svelte 上下文存储。
- en: By the end of this chapter, you’ll be proficient in using Svelte stores and
    Svelte context in your Svelte application. You will also understand when to use
    them effectively.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟练使用 Svelte 存储和 Svelte 上下文在你的 Svelte 应用中。你还将了解何时有效地使用它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining Svelte context and Svelte stores
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 Svelte 上下文和 Svelte 存储
- en: When to use Svelte context and Svelte stores
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用 Svelte 上下文和 Svelte 存储
- en: Creating dynamic context using Svelte stores
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Svelte 存储创建动态上下文
- en: Defining Svelte context
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 Svelte 上下文
- en: 'When you need to pass data from a parent component to a child component, the
    first thing you should think of is using props:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要从父组件传递数据到子组件时，你应该首先考虑使用 props：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What if you need to pass data from a parent component to a grandchild component?
    You could pass data as props from the parent component to the child component,
    and then from the child component to the grandchild component:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从父组件传递数据到孙组件呢？你可以从父组件通过 props 传递数据到子组件，然后从子组件传递到孙组件：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What if you need to pass data from a parent component to a great-grandchild
    component?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从父组件传递数据到曾孙组件呢？
- en: You could follow a process similar to what we did in the preceding code, passing
    the data through layers of components to reach the great-grandchild component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遵循与前面代码中类似的过程，通过组件层传递数据以到达曾孙组件。
- en: 'This approach is called *prop drilling*. It is akin to drilling a hole through
    layers of components via props. This is frowned upon in most cases due to the
    following reasons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为 *属性钻取*。它类似于通过 props 在组件层中钻孔。由于以下原因，在大多数情况下都不推荐这样做：
- en: It is hard to trace where the data comes from.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难追踪数据的来源。
- en: Whenever you want to trace where the data comes from in the child component,
    you may endlessly trace up through layers of the parent component, jumping through
    different Svelte component files.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你想在子组件中追踪数据的来源时，你可能需要无限地向上追踪通过父组件的多层，跳过不同的 Svelte 组件文件。
- en: This slows you down and makes it harder to reason with the data flow.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会减慢你的速度，并使你对数据流进行推理变得更加困难。
- en: It is hard to trace where the data leads to.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难追踪数据流向何方。
- en: The data that’s passed down through props into the child component is not to
    be used by the child component directly, but to be passed through it to its child
    component. You would have to step through the layer of components to find out
    where the data is finally being used.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过属性传递到子组件中的数据不应直接由子组件使用，而应通过它传递到其子组件。你将不得不遍历组件层来找出数据最终被使用的地方。
- en: You may lose sight of where the data goes and have less confidence in making
    changes to the data that’s passed down.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会失去数据的去向，对修改传递下来的数据进行更改的信心会降低。
- en: It is hard to restructure the component hierarchy.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新结构组件层次结构很困难。
- en: When you add a new component in between the layers, you need to make sure to
    still pass the props through the new component from its parent to its children.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在层之间添加新组件时，你需要确保仍然通过新组件从其父组件传递属性到其子组件。
- en: When you move the components around, you need to make sure the child component
    still gets the props it needs by checking the chain of parent components.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你移动组件时，你需要确保通过检查父组件的链来确保子组件仍然能够获取它需要的属性。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Keeping this in mind, when the component tree is small and simple, even with
    its drawback, passing props around may still be the simplest way to pass data
    from a parent to its child components.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，当组件树小而简单时，即使有缺点，传递属性仍然可能是从父组件传递数据到其子组件的最简单方式。
- en: So, what is the alternative to *prop drilling*? Svelte context.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，*属性钻取*的替代方案是什么？Svelte 上下文。
- en: Svelte context is a method that provides data to all child components, no matter
    how many levels down the component tree they are.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 上下文是一种为所有子组件提供数据的方法，无论它们在组件树中的层级有多深。
- en: 'A component tree is like a family tree for components. You have a parent component
    at the top, and one level down its child components, and one more level down is
    the child components of the child components:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 组件树就像组件的家谱。你有一个位于顶部的父组件，下一级是其子组件，再下一级是子组件的子组件：
- en: '![Figure 8.1: Component tree diagram](img/B18887_08_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：组件树图](img/B18887_08_01.jpg)'
- en: 'Figure 8.1: Component tree diagram'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：组件树图
- en: 'In the preceding component tree diagram, the top-left node represents where
    `setContext` is called, and all shaded nodes under the node can access the context
    value using `getContext`. To set a context value in a component, you can use `setContext()`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的组件树图中，左上角的节点表示 `setContext` 被调用的位置，该节点下的所有阴影节点都可以使用 `getContext` 访问上下文值。要在组件中设置上下文值，你可以使用
    `setContext()`：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All its child components and child components’ child components will be able
    to read the context value through `getContext()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有子组件及其子组件的子组件都将能够通过 `getContext()` 读取上下文值：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you paid attention to the preceding snippets, you may have noticed that we
    have been using strings as the context key when setting and reading context. However,
    you might wonder whether it is possible to use other data types as the context
    key. Let’s look into this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了前面的代码片段，你可能已经注意到我们一直在设置和读取上下文时使用字符串作为上下文键。然而，你可能想知道是否可以使用其他数据类型作为上下文键。让我们来看看这一点。
- en: Using an object as a context key
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象作为上下文键
- en: What is the underlying mechanism of Svelte context?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 上下文的底层机制是什么？
- en: Svelte context is implemented using a JavaScript `Map`, which means you can
    set values and read values out of Svelte context using a key, the same way you
    would with a JavaScript map.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，Svelte 上下文是使用 JavaScript `Map` 实现的，这意味着你可以使用键设置和读取 Svelte 上下文中的值，就像使用
    JavaScript 地图一样。
- en: 'This also means that you can set more than one key to Svelte context:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你可以为 Svelte 上下文设置多个键：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You just need to make sure you read them out using the same key you set the
    context with.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要确保使用你设置上下文时相同的键读取它们。
- en: 'As I mentioned earlier, Svelte context is implemented using a JavaScript `Map`,
    and the keys of a `Map` can be of any type, including functions, objects, or any
    primitives; you are not constrained to using just a `String` key value:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前提到的，Svelte 上下文是使用 JavaScript `Map` 实现的，`Map` 的键可以是任何类型，包括函数、对象或任何原始类型；你不必仅限于使用
    `String` 键值：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And just as how JavaScript `Map` works, if you set a context using an object,
    then you would need to use the same object instance to read the value out of the
    Svelte context.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 JavaScript `Map` 的工作方式一样，如果你使用对象设置上下文，那么你需要使用相同的对象实例来从 Svelte 上下文中读取值。
- en: Changing the context value
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改上下文值
- en: One thing to take note of when using `setContext` and `getContext` is that these
    functions need to be called during component initialization. Read[*Chapter 1*](B18887_01.xhtml#_idTextAnchor015)
    to recap on what component initialization is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setContext` 和 `getContext` 时需要注意的一点是，这些函数需要在组件初始化期间调用。阅读[*第一章*](B18887_01.xhtml#_idTextAnchor015)
    回顾组件初始化是什么。
- en: If we can call `setContext` after component initialization, then this leads
    us to the next question – how would we change the context value?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以在组件初始化后调用 `setContext`，那么这就会引出下一个问题——我们该如何更改上下文值？
- en: 'Look at the following snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看以下代码片段：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When calling `setContext` in line 3, we are passing the value of the `itemId`
    variable to the `setContext` function. Reassigning the `itemId` variable in line
    5 would not make the context value change.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当在第 3 行调用 `setContext` 时，我们正在将 `itemId` 变量的值传递给 `setContext` 函数。在第 5 行重新分配 `itemId`
    变量不会使上下文值发生变化。
- en: This is how JavaScript works. If you call a function with a primitive-type variable,
    then the value of the variable is being passed in, and reassigning the variable
    outside of the function would not change the value of the variable that’s read
    from inside the function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 JavaScript 的工作方式。如果你用一个原始类型的变量调用一个函数，那么变量的值就会被传递进去，而在函数外部重新分配变量不会改变函数内部读取的变量的值。
- en: 'How about passing an object as a context value? Let’s see how that works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么将对象作为上下文值传递怎么样？让我们看看它是如何工作的：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In JavaScript, objects are passed by reference. This means that the Svelte
    context and the `item` variable outside of the `setContext` function are referring
    to the same object. Mutating the object modifies the same referenced object and
    thus the changes can be seen when reading the Svelte context:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，对象是通过引用传递的。这意味着 Svelte 上下文和 `setContext` 函数之外的 `item` 变量引用的是同一个对象。修改对象会修改同一个引用对象，因此当读取
    Svelte 上下文时可以看到这些变化：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, you may have noticed that after you render `{item.id}` onto the DOM,
    the value shown in the DOM does not change when you mutate it in the parent component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能已经注意到，在你将 `{item.id}` 渲染到 DOM 上之后，当你在其父组件中修改它时，DOM 中显示的值并没有改变。
- en: 'This does not mean `item.id` has not changed. If you try to print out `item.id`
    on an interval, you will notice that `item.id` has changed, but the value in the
    DOM remains the same:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着 `item.id` 没有改变。如果你尝试以间隔打印 `item.id`，你会注意到 `item.id` 已经改变，但 DOM 中的值保持不变：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Why would this happen?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？
- en: Svelte tracks variable mutations and reassignments within a Svelte component
    and instruments operations to update the DOM to reflect the changes. However,
    what this means is that changes that happen outside of the component are not tracked,
    and therefore the DOM does not reflect such changes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 跟踪 Svelte 组件内部的变量突变和重新分配，并记录操作以更新 DOM 以反映这些变化。然而，这意味着组件外部发生的变化不会被跟踪，因此
    DOM 不会反映这些变化。
- en: So, what should we do to make Svelte aware of changes to a variable outside
    of the component?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该怎么做才能让 Svelte 意识到组件外部变量的变化？
- en: This is where the Svelte store comes in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Svelte 存储发挥作用的地方。
- en: Defining the Svelte store
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 Svelte 存储
- en: To understand why Svelte reactivity is limited within a Svelte component, we
    must first understand how Svelte’s reactivity works.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么 Svelte 的响应性在 Svelte 组件内受限，我们必须首先了解 Svelte 的响应性是如何工作的。
- en: Unlike some other frameworks, Svelte reactivity works during build time. As
    Svelte compiles a Svelte component into JavaScript, Svelte looks at each variable
    and tracks the variable to see when the variable changes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他框架不同，Svelte 的响应性在构建时就会工作。当 Svelte 将 Svelte 组件编译成 JavaScript 时，Svelte 会查看每个变量并跟踪变量，以查看变量何时发生变化。
- en: Instead of tracking all the variables throughout the application, Svelte limits
    itself to only analyzing and compiling one file at a time. This allows Svelte
    to compile multiple Svelte component files in parallel but also means that a Svelte
    component would not be aware of variable changes that happen in other files.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与其跟踪整个应用程序中的所有变量，Svelte 只限制自己一次分析并编译一个文件。这允许 Svelte 并行编译多个 Svelte 组件文件，但也意味着
    Svelte 组件不会意识到其他文件中发生的变量变化。
- en: A common situation where a variable change is not tracked is when the variable
    is defined in a separate file and imported into the current component.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 变量变化未被跟踪的常见情况是，当变量定义在单独的文件中并被导入到当前组件时。
- en: 'In the following code snippet, the `quantity` variable is imported from a separate
    file. Svelte will not track any changes to the `quantity` variable that may have
    occurred in that file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`quantity`变量是从一个单独的文件中导入的。Svelte不会跟踪该文件中可能发生的任何对`quantity`变量的更改：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you attempt to modify the variable outside of the Svelte component, then
    Svelte is not able to track that. So, Svelte has no idea when you modify the variable
    and therefore will not be able to update the DOM when that happens.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在Svelte组件外部修改变量，那么Svelte无法跟踪这一点。因此，Svelte不知道何时修改变量，因此无法在发生这种情况时更新DOM。
- en: To make Svelte aware of the changes outside of the component and update the
    DOM accordingly, we will need to design a mechanism at runtime that will notify
    Svelte whenever a variable changes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Svelte意识到组件外部的变化并相应地更新DOM，我们需要在运行时设计一个机制，以便在变量发生变化时通知Svelte。
- en: For this, we can draw inspiration from the **observer pattern**. The observer
    pattern is a design pattern that lets you define a subscription mechanism to notify
    multiple objects when an event happens.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此，我们可以从**观察者模式**中汲取灵感。观察者模式是一种设计模式，它允许你定义一个订阅机制，以便在事件发生时通知多个对象。
- en: Using the observer pattern
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用观察者模式
- en: 'Here, instead of just importing the `quantity` variable, I am also importing
    a `subscribe` function, which we will define later:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，除了导入`quantity`变量之外，我还导入了一个`subscribe`函数，我们将在稍后定义它：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The idea of the `subscribe` function is such that we can subscribe to know when
    `quantity` changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`函数的想法是这样的，我们可以订阅以了解`quantity`何时发生变化。'
- en: 'Here, we assume that `subscribe` takes in a callback function, which will be
    called whenever `quantity` changes. The callback function takes in a parameter
    that gives us the latest value of `quantity`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设`subscribe`接受一个回调函数，该函数将在`quantity`发生变化时被调用。回调函数接受一个参数，它给出了`quantity`的最新值：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, now, although Svelte still cannot track changes to the `quantity` variable
    outside of the component, we can use the `subscribe` function to tell Svelte when
    that happens.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在尽管Svelte仍然无法跟踪组件外部的`quantity`变量的变化，但我们可以使用`subscribe`函数来告诉Svelte何时发生这种情况。
- en: As an example of how to tell Svelte this, we can define another variable called
    `_quantity` that initializes to be the same value as `quantity`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何告诉Svelte这一点，我们可以定义另一个变量叫做`_quantity`，它初始化为与`quantity`相同的值。
- en: 'Whenever `quantity` changes, the callback function that’s passed into the `subscribe`
    function should be called with the new `quantity` value. We will use this as an
    opportunity to update `_quantity` to the new `quantity` value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`quantity`发生变化时，传递给`subscribe`函数的回调函数应该使用新的`quantity`值被调用。我们将利用这个机会将`_quantity`更新为新`quantity`值：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since the `_quantity` variable is defined within the component, and we update
    the value of the variable within the component (in the `_quantity = newQuantity`
    statement), Svelte can track the update of `_quantity`. And since the `_quantity`
    variable tracks the changes of the `quantity` variable itself, you can see that
    the DOM updates whenever `quantity` changes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`_quantity`变量是在组件内部定义的，并且我们在组件内部更新变量的值（在`_quantity = newQuantity`语句中），Svelte可以跟踪`_quantity`的更新。由于`_quantity`变量跟踪`quantity`变量的变化，你可以看到每当`quantity`发生变化时，DOM都会更新。
- en: However, all of this depends on the `subscribe` function, which would call the
    callback function whenever the value of `quantity` changes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些都依赖于`subscribe`函数，该函数会在`quantity`的值发生变化时调用回调函数。
- en: So, let’s see how we can define the `subscribe` function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看我们如何定义`subscribe`函数。
- en: Defining the subscribe function
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义`subscribe`函数
- en: There are multiple ways of defining the `subscribe` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`subscribe`函数有多种方式。
- en: 'Here, we are going to use an array and name it `subscribers` so that we can
    keep track of all the functions being called with `subscribe`. Then, when we attempt
    to update the value of `quantity`, we will iterate through the `subscribers` array
    to get each of the subscriber functions and call them one by one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用一个数组并将其命名为`subscribers`，以便我们可以跟踪所有使用`subscribe`调用的函数。然后，当我们尝试更新`quantity`的值时，我们将遍历`subscribers`数组以获取每个订阅函数并逐个调用它们：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As an example, here, we want to update `quantity` to `20`. To make sure that
    the subscribers are notified of the changes, we call `notifySubscribers` with
    the updated value at the same time so that each `subscribers` is notified with
    the latest value for `quantity`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里，我们想将`quantity`更新为`20`。为了确保通知订阅者变化，我们同时调用`notifySubscribers`并传递更新后的值，这样每个`subscribers`都会收到`quantity`的最新值的通知：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Take your time when connecting the implementation of the `subscribe` and `notifySubscribers`
    functions in the preceding code back to the Svelte component code in the previous
    section. You will see that whenever we call `notifySubscribers`, the callback
    function that’s passed into the `subscribe` function will be called. `_quantity`
    will be updated, and the value in the DOM will be updated.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将前面代码中`subscribe`和`notifySubscribers`函数的实现与上一节中的Svelte组件代码联系起来时，请慢慢来。你会发现每次我们调用`notifySubscribers`时，传递给`subscribe`函数的回调函数都会被调用。`_quantity`将被更新，DOM中的值也将被更新。
- en: So, it doesn’t matter if you are modifying `quantity` outside the Svelte component,
    so long as you call the `notifySubscribers` function. With the new value of `quantity`,
    Svelte will update the DOM elements to reflect the latest value of `quantity`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论你在Svelte组件外部修改`quantity`，只要调用`notifySubscribers`函数即可。Svelte会使用`quantity`的新值更新DOM元素，以反映`quantity`的最新值。
- en: With the observer pattern, we are now able to define and update variables across
    Svelte components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察者模式，我们现在能够定义和更新Svelte组件之间的变量。
- en: You will see this pattern a lot in Svelte. Svelte encapsulates the idea of `subscribe`
    and `notifySubscribers` into a concept called a Svelte store. So, let’s explore
    what it means to be a Svelte store and explore what first-class support Svelte
    is providing for Svelte stores.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在Svelte中看到很多这种模式。Svelte将`subscribe`和`notifySubscribers`的概念封装成一个叫做Svelte存储的概念。所以，让我们探索成为Svelte存储的含义，以及Svelte为Svelte存储提供的一等支持。
- en: Defining a Svelte store
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个Svelte存储
- en: A Svelte store is any object that follows the Svelte store contract.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte存储是任何遵循Svelte存储约定的对象。
- en: This means that any object that follows the Svelte store contract can be referred
    to as a Svelte store. As a Svelte store, there are a few syntactic sugars and
    built-in functions that come with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何遵循Svelte存储约定的对象都可以被称为Svelte存储。作为一个Svelte存储，它附带一些语法糖和内置函数。
- en: Before we get ahead of ourselves, let’s take a look at what a Svelte store contract
    is.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们看看Svelte存储约定是什么。
- en: 'The Svelte store contract requires an object to have a `subscribe` method and
    an optional `set` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte存储约定要求一个对象必须有一个`subscribe`方法和一个可选的`set`方法：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I have not told you about the specific requirements for the `subscribe` and
    `set` methods, but I hope you can see the similarity in the `subscribe` and `set`
    methods in the Svelte store contract to the `subscribe` and `notifySubscribers`
    functions illustrated in the previous section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有告诉你`subscribe`和`set`方法的特定要求，但我希望你能看到Svelte存储约定中的`subscribe`和`set`方法与上一节中展示的`subscribe`和`notifySubscribers`函数之间的相似性。
- en: But something is missing here. Where do we place the store value, or the corresponding
    `quantity` variable from the previous section?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里似乎缺少了什么。我们应该把价值存储放在哪里，或者从上一节中对应的`quantity`变量放在哪里？
- en: Well, the store value is not part of the Svelte store contract, and we will
    soon explain why.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，存储值不是Svelte存储约定的一部分，我们很快就会解释原因。
- en: 'Let’s continue with our requirements for the `subscribe` and `set` methods:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论`subscribe`和`set`方法的要求：
- en: The `subscribe` method has to return a function to unsubscribe from the store.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`方法必须返回一个函数来取消订阅存储。'
- en: This allows the subscriber to stop receiving updates of the latest store value.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许订阅者停止接收存储最新值的更新。
- en: 'For example, if we use an array to keep track of the subscriber functions being
    called with the `subscribe` function, then we can use the returned function from
    `subscribe` to remove the subscriber function from the array since the `subscriber`
    function is no longer needed to receive any new updates from the store:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果我们使用一个数组来跟踪使用`subscribe`函数调用的订阅者函数，那么我们可以使用`subscribe`返回的函数从数组中移除订阅者函数，因为订阅者函数不再需要从存储中接收任何新的更新：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the `subscribe` method is being called with a function, the function must
    be called immediately and synchronously with the store value.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`subscribe`方法用一个函数被调用时，该函数必须立即和同步地与存储值一起被调用。
- en: 'If the function is not called immediately, the store value is assumed to be
    `undefined`:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果函数没有立即被调用，则假设存储值为 `undefined`：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This requirement means that to read the store value out from the Svelte store,
    you will need to use the `subscribe` method:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个要求意味着要从 Svelte 存储中读取存储值，你需要使用 `subscribe` 方法：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `set` method of a Svelte store takes in a new store value and returns nothing:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Svelte 存储的 `set` 方法接收一个新的存储值并返回空值：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `set` method is supposed to update the value of the store. Naturally, we
    would implement the `set` method such that it will notify all the store subscribers
    of the latest store value:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`set` 方法是用来更新存储值的。自然地，我们会实现 `set` 方法，以便通知所有存储订阅者最新的存储值：'
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With that, we’ve gone through the requirements of a Svelte store contract. Along
    the way, we’ve also seen snippets of code on implementing each requirement of
    a Svelte store. By putting them together, we will have a Svelte store.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经了解了 Svelte 存储合约的要求。在这个过程中，我们也看到了实现 Svelte 存储每个要求的代码片段。将它们组合起来，我们就会得到一个
    Svelte 存储。
- en: Creating a Svelte store is such a common use case that Svelte has provided a
    few built-in functions to help us with creating one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Svelte 存储是一个如此常见的用例，以至于 Svelte 提供了一些内置函数来帮助我们创建一个。
- en: Creating Svelte stores with built-in functions
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置函数创建 Svelte 存储
- en: Svelte provides a sub-package that exports a few built-in functions for Svelte
    stores. You can import them from the `'``svelte/store'` package.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 提供了一个子包，导出了一些用于 Svelte 存储的内置函数。你可以从 `'svelte/store'` 包中导入它们。
- en: 'Here is the list of built-in Svelte store functions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是内置 Svelte 存储函数的列表：
- en: '`readable()` helps create a readable Svelte store. Since the `set` method in
    a Svelte contract is optional, a readable store is a store that does not implement
    the `set` method.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readable()` 帮助创建一个可读的 Svelte 存储。由于 Svelte 合约中的 `set` 方法是可选的，所以可读存储是一个没有实现
    `set` 方法的存储。'
- en: 'To update the store value, the `readable()` function takes in a callback function
    that will be called when the store is being subscribed, and the callback function
    is called with a `set` function that can be used to update the store value:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要更新存储值，`readable()` 函数接收一个回调函数，当存储被订阅时，这个回调函数会被调用，并且回调函数会带有一个 `set` 函数，可以用来更新存储值：
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `set` function in the callback function can be called numerous times. In
    the following example, we are calling the `set` function every second to update
    the store value to the latest timestamp:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回调函数中的 `set` 函数可以被多次调用。在下面的示例中，我们每秒调用一次 `set` 函数来更新存储值到最新的时间戳：
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`writable()` helps create a writable Svelte store. This is similar to the readable
    store, except it implements the `set` method:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writable()` 帮助创建一个可写的 Svelte 存储。这与可读存储类似，但它实现了 `set` 方法：'
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`derived()` creates a new Svelte store, deriving from existing stores.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`derived()` 创建一个新的 Svelte 存储，它从现有的存储中派生出来。'
- en: We will explore `derived()` in more detail in the next chapter when we talk
    about creating custom stores.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们讨论创建自定义存储时，我们将在下一章更详细地探讨 `derived()`。
- en: With `readable()`, `writable()`, and `derived()`, you can easily create a new
    Svelte store without having to implement the Svelte store contract yourself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `readable()`、`writable()` 和 `derived()`，你可以轻松地创建一个新的 Svelte 存储，而无需自己实现 Svelte
    存储合约。
- en: So, we have built-in methods to create a Svelte store, but do we have any built-in
    methods for using Svelte stores? Let’s find out.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有内置方法来创建 Svelte 存储，但我们是否有任何内置方法来使用 Svelte 存储？让我们来看看。
- en: Auto-subscribing to a Svelte store
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动订阅 Svelte 存储
- en: 'Since all Svelte stores follow the Svelte store contract, all Svelte stores
    have the `subscribe` method and, optionally, the `set` method. We can use the
    `store.subscribe()` method to subscribe to the latest store value, and `store.set()`
    to update the store value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有 Svelte 存储都遵循 Svelte 存储合约，所以所有 Svelte 存储都有 `subscribe` 方法，以及可选的 `set` 方法。我们可以使用
    `store.subscribe()` 方法来订阅最新的存储值，以及使用 `store.set()` 来更新存储值：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When using a Svelte store in a Svelte component, we only subscribe to the Svelte
    store when needed (usually as we mount the Svelte component). In the preceding
    snippet, we subscribe to the store exactly after the Svelte component is mounted
    by calling the `store.subscribe` method inside an `onMount` callback.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Svelte 组件中使用 Svelte 存储时，我们只在需要时（通常在我们挂载 Svelte 组件时）订阅 Svelte 存储。在上面的代码片段中，我们通过在
    `onMount` 回调中调用 `store.subscribe` 方法，在 Svelte 组件挂载后立即订阅存储。
- en: It is important to unsubscribe from new store value changes when it is no longer
    necessary. This is usually when we unmount and destroy the Svelte component. In
    the preceding snippet, we return a function in an `onMount` callback, which will
    be called when the component is unmounted. In the function, we call the `unsubscribe`
    function return from the `store.subscribe` method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要时，取消订阅新存储值的变化是很重要的。这通常发生在我们卸载和销毁 Svelte 组件时。在前面的代码片段中，我们在 `onMount` 回调中返回一个函数，该函数将在组件卸载时被调用。在该函数中，我们调用从
    `store.subscribe` 方法返回的 `unsubscribe` 函数。
- en: This is in accordance with the Svelte store contract, where the `store.subscribe`
    method has to return a function to unsubscribe from the store.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合 Svelte 存储契约，其中 `store.subscribe` 方法必须返回一个函数来取消订阅存储。
- en: In a Svelte component, we need to remember to call `store.subscribe` during
    `onMount`, and remember to clean up by calling `unsubscribe` during `onDestroy`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Svelte 组件中，我们需要记住在 `onMount` 期间调用 `store.subscribe`，并记住在 `onDestroy` 期间调用
    `unsubscribe` 来清理。
- en: This can become verbose, so Svelte provides a way to auto-subscribe to a Svelte
    store in a Svelte component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会变得冗长，所以 Svelte 提供了一种在 Svelte 组件中自动订阅 Svelte 存储的方法。
- en: When you have a variable that references a store in a Svelte component, you
    can auto-subscribe to the store and access the value of the store through the
    `$` prefixed variable name of the store variable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Svelte 组件中有一个引用存储的变量时，你可以自动订阅存储并通过存储变量的 `$` 前缀变量名访问存储值。
- en: 'For example, let’s say you have a Svelte store variable named `count`, as shown
    here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个名为 `count` 的 Svelte 存储变量，如下所示：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this case, you can auto-subscribe to the `count` Svelte store and access
    the store value through `$count`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以自动订阅 `count` Svelte 存储并通过 `$count` 访问存储值：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is equivalent to subscribing to the store and assigning the latest store
    value to the `$count` variable, However, when doing it this way, you no longer
    need to explicitly call the `count.subscribe` method to subscribe to the store
    and call the `unsubscribe` function to unsubscribe from it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于订阅存储并将最新的存储值赋给 `$count` 变量。然而，以这种方式做时，你不再需要显式调用 `count.subscribe` 方法来订阅存储，并调用
    `unsubscribe` 函数来取消订阅。
- en: If you paid attention to the code, you may have noticed that we did not declare
    the `$count` variable at all. However, it is magically available, automatically
    declared by Svelte as Svelte builds the Svelte component code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了代码，你可能已经注意到我们没有声明 `$count` 变量。然而，它是神奇地可用的，由 Svelte 在构建 Svelte 组件代码时自动声明。
- en: This also assumes that whenever you are using the variable that starts with
    `$`, the variable without the `$` prefix is assumed to be a Svelte store.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这也假设了每次当你使用以 `$` 开头的变量时，没有 `$` 前缀的变量被认为是 Svelte 存储。
- en: Also, because of how Svelte auto declares the `$` prefixed variable, it disallows
    any declaration of any variable with a variable name starting with the `$` sign.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于 Svelte 自动声明以 `$` 开头的变量，它禁止声明任何以 `$` 符号开头的变量名。
- en: 'What happens if I assign a new value to the `$` prefixed variable? Doing so
    is equivalent to calling the `set` method of the store:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我给 `$` 前缀变量赋一个新的值会发生什么？这样做相当于调用存储的 `set` 方法：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, now that we’ve learned about the Svelte context and Svelte store, let’s
    discuss when we should use a Svelte context and/or a Svelte store.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经了解了 Svelte 上下文和 Svelte 存储，让我们讨论我们应该何时使用 Svelte 上下文和/或 Svelte 存储。
- en: Choosing between a Svelte context and a Svelte store
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 Svelte 上下文和 Svelte 存储之间的区别
- en: The Svelte context and Svelte store are designed for very different use cases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 上下文和 Svelte 存储是为非常不同的用例设计的。
- en: 'Here’s a recap: the Svelte context helps pass data from a parent component
    to all descendent components, while a Svelte store helps make data reactive across
    multiple Svelte components.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简要回顾一下：Svelte 上下文有助于将数据从父组件传递到所有子组件，而 Svelte 存储有助于使多个 Svelte 组件之间的数据变得响应式。
- en: Although both the Svelte context and Svelte store are meant to pass data across
    Svelte components, they are designed for different use cases. So, choosing when
    to use a Svelte context and Svelte store is never an either-or situation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Svelte 上下文和 Svelte 存储都是为了在 Svelte 组件之间传递数据，但它们是为不同的用例设计的。因此，选择何时使用 Svelte
    上下文和 Svelte 存储永远不会是二选一的情况。
- en: You can use either a Svelte context, a Svelte store, or both to pass the same
    data across Svelte components.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Svelte 上下文、Svelte 存储或两者来在 Svelte 组件之间传递相同的数据。
- en: 'To decide which one to use, I’ve come up with a 2x2 decision matrix:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定使用哪一个，我想出了一个 2x2 的决策矩阵：
- en: '![Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context,
    or both](img/B18887_08_02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2：选择 Svelte 存储、Svelte 上下文或两者的决策矩阵](img/B18887_08_02.jpg)'
- en: 'Figure 8.2: A decision matrix for choosing a Svelte store, a Svelte context,
    or both'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：选择 Svelte 存储、Svelte 上下文或两者的决策矩阵
- en: 'In this 2x2 decision matrix, there are two dimensions: local-global and static-reactive.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 2x2 决策矩阵中，有两个维度：本地-全局和静态-响应式。
- en: Depending on the kind of data you are passing, the data should fall into one
    of the four quadrants. Then, we can decide on the best way of passing the data
    across components.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你传递的数据类型，数据应属于四个象限之一。然后，我们可以决定在组件之间传递数据的最佳方式。
- en: So, let’s take a closer look at what each dimension means.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们更仔细地看看每个维度代表什么。
- en: In the local-global dimension, we determine whether the data should have the
    same value globally across the entire application or have separate local versions
    among components that are close to each other.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地-全局维度中，我们确定数据是否应该在整个应用程序中具有相同的全局值，或者在不同彼此靠近的组件中具有独立的本地版本。
- en: For example, language preference data falls into being global instead of local.
    There tends to be only one piece of language preference data throughout the entire
    application so that the language preference is consistent in the application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，语言偏好数据属于全局而不是本地。在整个应用程序中通常只有一个语言偏好数据片段，以确保应用程序中的语言偏好一致。
- en: On the other hand, chart settings in a dashboard of charts could be local data.
    Multiple Svelte components, such as chart axis, chart data, and chart grid, within
    the same chart share the same data, yet different charts could have different
    chart settings. There’s no one single piece of data throughout the entire application.
    So, in this case, it is more toward local in the local-global dimension.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，图表仪表板中的图表设置可能是本地数据。在同一图表内，多个 Svelte 组件，如图表轴、图表数据和图表网格，共享相同的数据，但不同的图表可能有不同的图表设置。在整个应用程序中并没有单一的数据片段。因此，在这种情况下，它更倾向于在本地-全局维度上的本地化。
- en: 'If the data is going to be global throughout the entire application, the data
    can be declared in a JavaScript module and imported from anywhere within the application:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据将在整个应用程序中保持全局，则可以在 JavaScript 模块中声明数据，并在应用程序的任何位置导入：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On the other hand, if the data is going to be local, the data can be declared
    as a Svelte context. This allows the child component to get different values,
    depending on where the component lives in the component tree hierarchy:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果数据将是本地的，则可以将数据声明为 Svelte 上下文。这允许子组件根据组件在组件树层次结构中的位置获取不同的值：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the static-reactive dimension, we determine whether the data should be static,
    meaning it wouldn’t change through the life cycle of the application, or should
    be dynamic, where the value of the data will change as the user interacts with
    the application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态-响应式维度中，我们确定数据应该是静态的，这意味着它不会在应用程序的生命周期中改变，或者应该是动态的，其中数据的值将随着用户与应用程序的交互而改变。
- en: An example of static data would be the theme of an application. The value of
    the data could be determined based on dynamic conditions, but once the value is
    determined at the start of the application, the value does not change throughout
    the application life cycle. The application theme is a good example of such a
    scenario. Usually, the theme of an application is determined at the start as the
    application loads, and the theme stays throughout the application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据的例子可以是应用程序的主题。数据的值可以根据动态条件确定，但一旦在应用程序开始时确定值，该值在整个应用程序生命周期中不会改变。应用程序的主题是这种情况的一个好例子。通常，应用程序的主题在应用程序加载时确定，并且在整个应用程序中保持不变。
- en: On the other hand, an example of dynamic data would be chart data. Chart data
    is dynamic and can be changed throughout the application’s life cycle.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，动态数据的例子可以是图表数据。图表数据是动态的，可以在应用程序的生命周期内进行更改。
- en: 'If the data is going to be static throughout the application’s life cycle,
    then the data can be declared using a normal JavaScript variable:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据将在整个应用程序生命周期中保持静态，那么可以使用常规 JavaScript 变量声明数据：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, if the data is going to be dynamic, and needs to be reactive across
    multiple components, the data should be declared as a Svelte store:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果数据将是动态的，并且需要在多个组件之间保持响应式，则应将数据声明为 Svelte 存储：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we combine the two dimensions, we get the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这两个维度结合起来，我们得到以下结果：
- en: '**Static global**: The data is declared as a normal JavaScript variable in
    a JavaScript module and exported for Svelte components to import'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态全局**：数据在JavaScript模块中以正常JavaScript变量的形式声明，并导出供Svelte组件导入'
- en: '**Dynamic global**: The data is declared as a Svelte store in a JavaScript
    module and exported for Svelte components to import'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态全局**：数据在JavaScript模块中以Svelte存储的形式声明，并导出供Svelte组件导入'
- en: '**Static local**: The data is declared as a Svelte context with a normal JavaScript
    variable as the Svelte context value'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态局部**：数据以Svelte上下文的形式声明，其中正常JavaScript变量作为Svelte上下文值'
- en: '**Dynamic local**: The data is declared as a Svelte context with the Svelte
    store as the Svelte context value'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态局部**：数据以Svelte上下文的形式声明，其中Svelte存储作为Svelte上下文值'
- en: With that, we’ve seen how we can use a Svelte context and a Svelte store individually,
    but when we pass dynamic local data across Svelte components, we use both a Svelte
    context and Svelte store together.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经看到了如何单独使用Svelte上下文和Svelte存储，但在传递Svelte组件之间的动态局部数据时，我们同时使用Svelte上下文和Svelte存储。
- en: So, how do you combine both a Svelte context and a Svelte store? Let’s find
    out.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何结合Svelte上下文和Svelte存储呢？让我们来看看。
- en: Passing dynamic context using a Svelte store
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Svelte存储传递动态上下文
- en: To make Svelte context data dynamic and reactive across components, we need
    to pass a Svelte store as the Svelte context data instead of a normal JavaScript
    variable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Svelte上下文数据在组件之间动态且具有反应性，我们需要传递一个Svelte存储作为Svelte上下文数据，而不是一个正常的JavaScript变量。
- en: This is very similar to importing a Svelte store from a JavaScript module, except
    we are not importing the Svelte store; instead, we are sending the Svelte store
    through the Svelte context.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这与从JavaScript模块导入Svelte存储非常相似，只是我们不是导入Svelte存储；相反，我们通过Svelte上下文发送Svelte存储。
- en: 'To begin, we are creating a Svelte store, and passing the Svelte store into
    the context:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个Svelte存储，并将Svelte存储传递到上下文中：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that we are passing the store into the Svelte context directly, instead
    of passing the store value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们直接将存储传递到Svelte上下文中，而不是传递存储值。
- en: 'In the child component, we can read the value out from the context through
    `getContext()`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在子组件中，我们可以通过`getContext()`从上下文中读取值：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since `data` is a Svelte store, we can reference the Svelte store value using
    the `$` prefixed variable:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`data`是一个Svelte存储，我们可以使用带`$`前缀的变量来引用Svelte存储值：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To test whether the reactivity works, we can set a new value to the `data`
    store in the parent component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试反应性是否工作，我们可以在父组件中将新的值设置到`data`存储中：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This goes both ways. If you attempt to update the store value from the child
    component, the store value in the parent component will be updated too. Since
    you are getting the same store value through the context in all the children components,
    any component using the same store will be updated as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方向都适用。如果你尝试从子组件更新存储值，父组件中的存储值也会更新。由于你通过上下文在所有子组件中获取相同的存储值，因此使用相同存储的任何组件都会更新。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what Svelte context and Svelte store are.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Svelte上下文和Svelte存储的概念。
- en: Although both Svelte context and Svelte store are meant for sharing data across
    multiple Svelte components, they are designed and used for different reasons.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Svelte上下文和Svelte存储都旨在在多个Svelte组件之间共享数据，但它们的设计和使用目的不同。
- en: Svelte context is meant for sharing the same data across all descendant components
    in the component tree, while Svelte store is meant for sharing reactivity across
    Svelte components.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte上下文旨在在组件树中的所有后代组件之间共享相同的数据，而Svelte存储旨在在Svelte组件之间共享反应性。
- en: Then, we explored the decision matrix on when to use a Svelte context, when
    to use a Svelte store, and when to use both.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了何时使用Svelte上下文、何时使用Svelte存储以及何时同时使用两者的决策矩阵。
- en: This chapter served as an introduction to the Svelte context and the Svelte
    store. By now, you should have a good understanding of what they are and how they
    work, and feel confident in knowing when to use them. As we move forward, we will
    explore practical use cases that involve Svelte context and Svelte store, allowing
    you to apply these powerful concepts effectively in real-world scenarios.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Svelte上下文和Svelte存储。到目前为止，你应该对它们是什么以及它们的工作方式有了很好的理解，并且对何时使用它们感到自信。随着我们继续前进，我们将探讨涉及Svelte上下文和Svelte存储的实际用例，使你能够在现实世界的场景中有效地应用这些强大的概念。
- en: In the next chapter, we will dive deeper into the topic of the Svelte store
    and look at how to create a custom one.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨 Svelte store 主题，并查看如何创建一个自定义的 store。
