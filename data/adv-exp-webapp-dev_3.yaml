- en: Chapter 3. Templating
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。模板化
- en: We have our Web API in place, so let's turn our attention to the client. In
    this chapter, we will consume our Web API and present our data using a mixture
    of both server-side and client-side templating. We will serve a`./views/index.html`
    masterpage file from the server with Express and use `consolidate.js` and `handlebars.js`
    for templating. On the client side we will use `backbone.js` and precompiled handlebars
    templates served directly out of the `./public` folder.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经部署了Web API，现在让我们将注意力转向客户端。在本章中，我们将消费我们的Web API，并使用服务器端和客户端模板的混合方式来展示我们的数据。我们将使用Express从服务器上提供`./views/index.html`主页面文件，并使用`consolidate.js`和`handlebars.js`进行模板化。在客户端，我们将使用`backbone.js`和预编译的handlebars模板，这些模板直接从`./public`文件夹提供。
- en: Server-side templating
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端模板化
- en: Up until now our Express server has only served JSON; let's install a couple
    of modules that will assist us in serving HTML.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的Express服务器只提供了JSON；让我们安装一些模块，以帮助我们提供HTML。
- en: '`consolidate.js` is a template engine consolidation library that was created
    to map all of Node''s popular templating engines to the Express convention for
    templating, allowing them to work within Express:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`consolidate.js`是一个模板引擎合并库，它被创建来将所有Node的流行模板引擎映射到Express的模板约定，允许它们在Express中工作：'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`handlebars.js` is an extension to the mustache templating language. Handlebars
    is a logic-less templating language that keeps view and code separated:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlebars.js`是mustache模板语言的扩展。Handlebars是一个无逻辑的模板语言，它将视图和代码分离：'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to be able to serve our handlebar templates, we will have to make
    some changes to our Express server. Let''s change the default template engine
    to handlebars by setting the `app.engine`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够提供我们的handlebar模板，我们不得不对我们的Express服务器做一些修改。让我们通过设置`app.engine`将默认模板引擎更改为handlebars：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now register `html` as our view file extension. If we did not set this, we would
    need to name our view `index.hbs` instead of `index.html`, with `.hbs` being the
    extension for handlebars templates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注册`html`作为我们的视图文件扩展名。如果我们没有设置这个，我们就需要将我们的视图命名为`index.hbs`而不是`index.html`，其中`.hbs`是handlebars模板的扩展名。
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s create our single page application view; this will be served by our
    Express server:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的单页应用程序视图；这将由我们的Express服务器提供：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next we define the location of our `views` folder and the location of our static
    files folder; it is here that we will store `components`, for example, CSS and
    JavaScript files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的`views`文件夹的位置以及静态文件文件夹的位置；这里我们将存储`components`，例如，CSS和JavaScript文件。
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now create a folder called `public` and add the following directory structure,
    so that static resources are served with the subdirectory as prefix, for example,
    `vision/vision.css.`
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`public`的文件夹，并添加以下目录结构，以便静态资源以子目录作为前缀提供，例如，`vision/vision.css`。
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Feature: Master Page'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能：主页面
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's add a test to `./test/home.js` for our feature `Master Page`. This resource
    will `GET` our master page from route `./` and return a `200 OK` response. The
    `Content-Type` of the response should be `HTML:`
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`./test/home.js`为我们的功能`Master Page`添加一个测试。这个资源将从路由`./`获取我们的主页面并返回`200 OK`响应。响应的`Content-Type`应该是`HTML`：
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s implement our `Master Page` feature. Let''s create a new module that
    exposes a route `./lib/routes/home.js` and add a new `index` function. We start
    by defining a route called `index`. We create a view `model` with meta information
    for a page and then render the view passing the view `model`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现我们的`Master Page`功能。让我们创建一个新的模块，该模块公开一个路由`./lib/routes/home.js`并添加一个新的`index`函数。我们首先定义一个名为`index`的路由。我们创建一个带有页面元信息的视图`model`，然后通过传递视图`model`来渲染视图：
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s add a new route to our Express server `./lib/express/index.js`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Express服务器`./lib/express/index.js`中添加一个新的路由：
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Package management with Bower
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bower进行包管理
- en: We will now install the various components that make up our client, namely `Handlebars.js`,
    `Backbone.js`, and Twitter Bootstrap Version 2 using **Bower**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将安装构成我们客户端的各种组件，即`Handlebars.js`、`Backbone.js`和Twitter Bootstrap 2版本，使用**Bower**。
- en: 'Bower is a package manager for the web. A Bower package can contain assets
    of different types, such as CSS, JavaScript, and images. Let''s install Bower
    globally with the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Bower是Web的包管理器。一个Bower包可以包含不同类型的资源，如CSS、JavaScript和图像。让我们使用以下命令全局安装Bower：
- en: '[PRE11]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Bower, dependencies are listed in a `bower.json` file, similar to Node''s
    `package.json`. Let''s create a `./bower.json` file and define our client-side
    dependencies:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bower中，依赖关系列在`bower.json`文件中，类似于Node的`package.json`。让我们创建一个`./bower.json`文件并定义我们的客户端依赖项：
- en: '[PRE12]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now create the following Bower configuration file `./.bowerrc`, which allows
    us to define our target directory and the name of our `bower.json` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建以下 Bower 配置文件 `./.bowerrc`，它允许我们定义我们的目标目录和 `bower.json` 文件的名字：
- en: '[PRE13]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the following command to install all of the dependencies listed in our
    `bower.json` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来安装 `bower.json` 文件中列出的所有依赖项：
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Twitter Bootstrap''s assets are stored in the folder specified in the path
    in the following snippet, so let''s add a `static` middleware to override our
    Express server. This will keep our paths consistent on the client:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter Bootstrap 的资源存储在以下片段中指定的路径指定的文件夹中，因此让我们添加一个 `static` 中间件来覆盖我们的 Express
    服务器。这将保持客户端路径的一致性：
- en: '[PRE15]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Templates
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: Our master page contains the following sections. In order to facilitate a client-side
    templating model using `backbone.js`, we will split up our master page into templates.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主页包含以下部分。为了便于使用 `backbone.js` 进行客户端模板化模型，我们将主页拆分成模板。
- en: 'Let''s create a new folder called `./templates` and add the following files:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `./templates` 的新文件夹，并添加以下文件：
- en: '[PRE16]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to avoid compiling the templates on demand, let''s install the grunt
    task `grunt-contrib-handlebars`, which will precompile our handlebar templates:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免按需编译模板，让我们安装 `grunt-contrib-handlebars` 这个 grunt 任务，它将预编译我们的 handlebars
    模板：
- en: '[PRE17]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We outline the grunt configuration for our handlebars compilation in the following
    code; it simply takes as input a template location `templates/*.hbs` and compiles
    these templates into a single JavaScript file and stores it at `public/components/vision/templates.js`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们概述了 handlebars 编译的 grunt 配置；它简单地以模板位置 `templates/*.hbs` 作为输入，将这些模板编译成一个单一的
    JavaScript 文件，并将其存储在 `public/components/vision/templates.js`。
- en: '[PRE18]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We complete this section by taking a look at the master page template `./views/index.html`.
    The body contains the following areas: a header, which includes either a `login`
    button or a `logout` button with a `welcome` message, a `project-list` form, `repository-list`,
    `commit-list`, and `issue-list`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看主模板 `./views/index.html` 来完成这一部分。主体包含以下区域：一个头部，包括一个 `login` 按钮或一个带有 `welcome`
    消息的 `logout` 按钮，一个 `project-list` 表单，`repository-list`，`commit-list` 和 `issue-list`。
- en: '[PRE19]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Client-side development with Backbone.js
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Backbone.js 进行客户端开发
- en: '`Backbone.js` is a lightweight and very flexible **JavaScript Model View**
    (**MV***) framework that simplifies the building of complex JavaScript applications.
    It includes some very basic primitives that allow us to decouple our client''s
    model and logic from its view. Backbone supports a **RESTful JSON** interface
    that ties models/collections to a RESTful API. Further information on `Backbone.js`
    can be found at [http://backbonejs.org](http://backbonejs.org).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone.js` 是一个轻量级且非常灵活的 **JavaScript 模型视图**（**MV**）框架，它简化了复杂 JavaScript
    应用程序的构建。它包括一些非常基本的原语，允许我们将客户端的模型和逻辑与其视图解耦。Backbone 支持一个 **RESTful JSON** 接口，将模型/集合与
    RESTful API 相关联。有关 `Backbone.js` 的更多信息，请访问 [http://backbonejs.org](http://backbonejs.org)。'
- en: 'Feature: List projects'
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能：列出项目
- en: Let's build the client for our feature `List projects`. Each item in the list
    consists of a project name and an edit and delete button. Clicking on the name
    will display a list of repositories; clicking on **edit** will display an inline
    form populated with the models' data, and clicking on **delete** will delete the
    item from our database. We will return to hook up these three functions later.
    For now, we will simply display a project list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的功能 `列出项目` 的客户端。列表中的每个项目都包含一个项目名称和一个编辑和删除按钮。点击名称将显示一个仓库列表；点击 **编辑** 将显示一个填充了模型数据的内联表单，点击
    **删除** 将从我们的数据库中删除该条目。我们稍后会回来连接这三个功能。现在，我们只是简单地显示一个项目列表。
- en: 'What follows is an HTML template `./templates/projects.hbs` for a project item;
    it contains a placeholder `{{_id}}`, which will be replaced by our Backbone application:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个用于项目条目的 HTML 模板 `./templates/projects.hbs`；它包含一个占位符 `{{_id}}`，它将被我们的 Backbone
    应用程序替换：
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s define a skeleton Backbone application with all of its pieces in place:
    `./public/components/vision/vision.js`. We start by defining the `Vision` namespace;
    we add to it an outer function called `Application`, that has a single method
    called `start`. Here we instantiate a `router` and call `Backbone.history.start()`
    in order to start the Backbone application. We then call `router.navigate(''index'',
    true)` and navigate to our home page. With this function in place, we instantiate
    new `Vision.Application()` and call `start()`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个包含所有组件的骨架 Backbone 应用程序：`./public/components/vision/vision.js`。我们首先定义
    `Vision` 命名空间；我们向其中添加一个名为 `Application` 的外部函数，它有一个名为 `start` 的单一方法。在这里，我们实例化一个
    `router` 并调用 `Backbone.history.start()` 以启动 Backbone 应用程序。然后我们调用 `router.navigate('index',
    true)` 并导航到我们的主页。有了这个函数，我们实例化新的 `Vision.Application()` 并调用 `start()`。
- en: '[PRE21]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's now create the application `Router`. Generally, Backbone applications
    only have one of these; a router is the entry point for our application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为 `Router` 的应用程序。一般来说，Backbone 应用程序只有一个这样的组件；路由器是我们应用程序的入口点。
- en: First we add a function `Router`, which extends the Backbone `Router` type.
    We add a view for our list of projects called `projectListView`, and add a `routes`
    hash, which defines a single route. The entry point for our application is an
    empty route mapped to a method called `index`. The `initialize` or constructor
    method is called when the router is instantiated; from here we call a method `project`,
    which instantiates a `ProjectListView`. The `index` method, which matches the
    route as defined previously, renders our view by calling `projectApplication.render()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一个名为 `Router` 的函数，它扩展了 Backbone 的 `Router` 类型。我们添加了一个名为 `projectListView`
    的项目列表视图，并添加了一个 `routes` 哈希，它定义了一个单一的路由。我们应用程序的入口点是一个空路由，映射到名为 `index` 的方法。当路由器实例化时，会调用
    `initialize` 或构造函数方法；从这里我们调用一个名为 `project` 的方法，它实例化一个 `ProjectListView`。`index`
    方法与之前定义的路由相匹配，通过调用 `projectApplication.render()` 来渲染我们的视图。
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's implement our `Project` model to support our view. We start by adding
    a function `Project`, which extends the Backbone `Model` type and includes a hash
    of default values for the two properties in our model. We override the `idAttribute`
    parameter in order to accommodate MongoDB identifiers. We will use the MongoDB
    `_id` as our model identifier; by default Backbone will use `id`. This identifier
    will be appended to any request Backbone makes to the server, for example, when
    performing GET, POST, PUT, or DELETE. We already added the API for this model
    in [Chapter 2](ch02.html "Chapter 2. Building a Web API"), *Building a Web API*.
    The `urlRoot` parameter links this model to the web API route `/project` to return
    a project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现我们的 `Project` 模型以支持我们的视图。我们首先添加一个名为 `Project` 的函数，它扩展了 Backbone 的 `Model`
    类型，并包含我们模型中两个属性的默认值哈希。我们覆盖了 `idAttribute` 参数以适应 MongoDB 标识符。我们将使用 MongoDB 的 `_id`
    作为我们的模型标识符；默认情况下，Backbone 将使用 `id`。此标识符将被附加到 Backbone 向服务器发出的任何请求中，例如，在执行 GET、POST、PUT
    或 DELETE 操作时。我们已经在 [第 2 章](ch02.html "第 2 章。构建 Web API") 中添加了此模型的 API，*构建 Web
    API*。`urlRoot` 参数将此模型链接到 Web API 路由 `/project` 以返回一个项目。
- en: '[PRE23]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's implement a collection; `ProjectList` for our `Project` model. We add
    a function, `ProjectList`, that extends the Backbone `Collection` type and we
    specify model type as `Vision.Project`. We add a `url` method which returns our
    web API route `/project` to return a list of projects. The `initialize` method
    is called when the collection is instantiated; from here we do our initial `fetch()`
    to get our projects; thus calls the API `/project`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个集合；为我们的 `Project` 模型添加一个名为 `ProjectList` 的集合。我们添加一个名为 `ProjectList` 的函数，它扩展了
    Backbone 的 `Collection` 类型，并指定模型类型为 `Vision.Project`。我们添加一个 `url` 方法，它返回我们的 Web
    API 路由 `/project` 以返回项目列表。当集合实例化时，会调用 `initialize` 方法；从这里我们执行初始的 `fetch()` 来获取我们的项目；因此调用
    API `/project`。
- en: '[PRE24]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Before we implement `ProjectListView`, let's create `event_aggregator`; this
    will allow our views to trigger and bind named events that other views can respond
    to. We will need to do this in order for `ProjectListView` to inform `RepositoryListView`
    that it's time to display a `RepositoryList`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现 `ProjectListView` 之前，让我们创建 `event_aggregator`；这将允许我们的视图触发和绑定命名事件，其他视图可以响应这些事件。我们需要这样做，以便
    `ProjectListView` 通知 `RepositoryListView` 显示 `RepositoryList` 的时间到了。
- en: 'Let''s add an `event_aggregator` function to the Backbone view prototype using
    the `underscore.js` extend method to mix in the Backbone `event` module into our
    views:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `underscore.js` 的 `extend` 方法将 Backbone 的 `event` 模块混合到我们的视图原型中，添加一个名为
    `event_aggregator` 的函数：
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's implement a view for our `Project` collection— `ProjectListView`. We start
    by defining a function `ProjectListView` which extends the Backbone `View` type,
    and add a `Projects` array for our project list. We assign a DOM element to `el`;
    an unordered list called `projects-list`. This is the element our view will be
    inserted into. Backbone will construct an empty `div` tag if you do not assign
    it to `el`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`Project`集合实现一个视图——`ProjectListView`。我们首先定义一个函数`ProjectListView`，它扩展了Backbone的`View`类型，并为我们的项目列表添加了一个`Projects`数组。我们将一个DOM元素分配给`el`；一个名为`projects-list`的无序列表。这是我们视图将被插入的元素。如果你没有将其分配给`el`，Backbone将构造一个空的`div`标签。
- en: The `initialize` method is called when the view is instantiated; here we instantiate
    a new `ProjectList`, passing our `Projects` array. We then call `collection.on('add')`,
    which upon fetching data from the API will call the `add` method. The `add` method
    instantiates `ProjectView`, passing to it a `project` model. We then append `ProjectView`
    to our DOM element via `$el` and return the view.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图实例化时调用`initialize`方法；在这里，我们实例化一个新的`ProjectList`，传递我们的`Projects`数组。然后我们调用`collection.on('add')`，当从API获取数据时将调用`add`方法。`add`方法实例化`ProjectView`，并将其传递给一个`project`模型。然后我们通过`$el`将`ProjectView`追加到我们的DOM元素中，并返回视图。
- en: '[PRE26]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We complete this section by implementing a view for a single project—`ProjectView`.
    We start by defining a function `ProjectView`, which extends the Backbone `View`
    type, and add a `tagName` and assign `li` to it. This tag will be wrapped around
    our project view; our DOM element is a `ul` tag.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现单个项目的视图——`ProjectView`来完成本节。我们首先定义一个函数`ProjectView`，它扩展了Backbone的`View`类型，并将`tagName`分配给它，将其设置为`li`。这个标签将围绕我们的项目视图；我们的DOM元素是一个`ul`标签。
- en: 'We then include `viewTemplate` and assign our precompiled handlebars template
    to it. Although the templates are compiled to a single file —`./vision/templates.js`—
    we still refer to the template by name; `templates/projects.hbs`. The `render`
    method renders the view; we pass the `project` model to our `viewTemplate`, which
    is then added via `$el` to our DOM element and we return the view:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们包含`viewTemplate`并将预编译的handlebars模板分配给它。尽管模板被编译到一个单独的文件——`./vision/templates.js`——但我们仍然通过名称引用模板；`templates/projects.hbs`。`render`方法渲染视图；我们将`project`模型传递给我们的`viewTemplate`，然后通过`$el`添加到我们的DOM元素中，并返回视图：
- en: '[PRE27]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you go into MongoDB and add the following record to the projects collection
    in the vision database, when visiting the Vision application in a browser you
    can see this record in the project list view:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入MongoDB，并将以下记录添加到vision数据库中项目的集合，当在浏览器中访问Vision应用程序时，你可以在项目列表视图中看到此记录：
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Feature: List repositories'
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能：列出仓库
- en: Let's build the client for our feature `List repositories`. Each item in the
    list consists of a repository name, a short description, and a checkbox; which
    allows us to add or remove the repository from the project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的功能`List repositories`的客户端。列表中的每个项目都由一个仓库名称、一个简短描述和一个复选框组成；这允许我们向项目添加或删除仓库。
- en: 'What follows is an HTML template `./templates/repositories.hbs` for a repository
    item:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个用于仓库项的HTML模板`./templates/repositories.hbs`：
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's add a `Repository` model. We add a function `Repository` that extends
    the Backbone `Model` type and add a hash of default values for the four properties
    in our model. The `enabled` property signifies that a repository is included in
    the selected project.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`Repository`模型。我们添加一个函数`Repository`，它扩展了Backbone的`Model`类型，并为我们的模型中的四个属性添加了一个默认值的哈希。`enabled`属性表示仓库包含在所选项目中。
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's implement a collection for our `Repository` model. We start by defining
    a function `RepositoryList`, which extends the Backbone `Collection` type. We
    add the `projectId` of the selected project, and set the model type as `Vision.Repository`.
    We then add a `url` method and use the web API route `/project/:id/repos` to get
    a list of repositories for a project.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`Repository`模型实现一个集合。我们首先定义一个函数`RepositoryList`，它扩展了Backbone的`Collection`类型。我们添加了所选项目的`projectId`，并将模型类型设置为`Vision.Repository`。然后我们添加了一个`url`方法，并使用Web
    API路由`/project/:id/repos`来获取一个项目的仓库列表。
- en: The `initialize` method is called when the collection is instantiated; from
    here, we assign the selected `projectId`. The `parse` method is called when a
    fetch is performed and will parse the response; here we assign our MongoDB `_id`
    to the `response.id`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合实例化时调用`initialize`方法；从这里，我们分配所选的`projectId`。当执行获取操作时调用`parse`方法，并将解析的响应分配给我们的MongoDB
    `_id`。
- en: '[PRE31]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We now implement a view for a single repository. We add a function, `RepositoryView`,
    that extends the Backbone `View` type and add a `tagName` and assign `li` to it.
    This tag will be wrapped around our `RepositoryView` function; our DOM element
    is a `ul` tag. We include a `viewTemplate` function and assign our precompiled
    handlebars template `templates/repositories.hbs` to it. The `render` method renders
    the view; we pass the `repository` model to our `viewTemplate` function, which
    is then added via `$el` to our DOM element, and we return the view.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在实现一个单个仓库的视图。我们添加一个函数 `RepositoryView`，它扩展了 Backbone 的 `View` 类型，并将 `tagName`
    赋值为 `li`。这个标签将围绕我们的 `RepositoryView` 函数；我们的 DOM 元素是一个 `ul` 标签。我们包含一个 `viewTemplate`
    函数，并将预编译的 handlebars 模板 `templates/repositories.hbs` 赋值给它。`render` 方法渲染视图；我们向
    `viewTemplate` 函数传递 `repository` 模型，然后通过 `$el` 添加到我们的 DOM 元素中，并返回视图。
- en: '[PRE32]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's implement a view for our `RepositoryList` called `RepositoryListView`.
    We start by defining a function, `RepositoryListView`, that extends the Backbone
    `View` type and adds a `Repositories` array for our repository list. We add an
    `initialize` method; if `projectId` is empty we return. A valid `projectId` results
    in rendering the view; first, we clear the DOM element, and we then assign a new
    `RepositoryList` function to the views `collection`. We initialize the list with
    our `Repositories` array and our `projectId`, we then call `fetch` in our collection,
    and then we call `render` for a successful fetch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个名为 `RepositoryListView` 的 `RepositoryList` 视图。我们首先定义一个函数 `RepositoryListView`，它扩展了
    Backbone 的 `View` 类型，并为我们的仓库列表添加一个 `Repositories` 数组。我们添加一个 `initialize` 方法；如果
    `projectId` 为空，则返回。有效的 `projectId` 将导致渲染视图；首先，我们清除 DOM 元素，然后我们将一个新的 `RepositoryList`
    函数分配给视图的 `collection`。我们使用 `Repositories` 数组和 `projectId` 初始化列表，然后在我们的集合中调用 `fetch`，然后调用
    `render` 以成功获取。
- en: The `render` method uses underscore to loop through the repository collection
    called `collection.models`, calling `add(item)` for each project. We include an
    `add` method that instantiates a `RepositoryView` function, passing to it a `repository`
    model. We then append a rendered `RepositoryView` to our DOM element via `$el`
    and return the view.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 方法使用 underscore 遍历名为 `collection.models` 的仓库集合，为每个项目调用 `add(item)`。我们包含一个
    `add` 方法，它实例化一个 `RepositoryView` 函数，并将一个 `repository` 模型传递给它。然后我们通过 `$el` 将渲染后的
    `RepositoryView` 添加到我们的 DOM 元素中，并返回视图。'
- en: '[PRE33]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's make a few changes to our `ProjectView` and add a click event when selecting
    a project. We start by defining an `events` hash with a single event called click
    a, that calls the `repository` method. The `repository` method grabs `projectId`
    from our model and then calls the `trigger` method on `event_aggregator` for the
    event `repository:join`, passing `projectId`. We will listen to this event on
    `ProjectListView`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `ProjectView` 进行一些修改，并在选择项目时添加一个点击事件。我们首先定义一个 `events` 哈希，其中包含一个名为 click
    的单个事件，它调用 `repository` 方法。`repository` 方法从我们的模型中获取 `projectId`，然后调用 `event_aggregator`
    上的 `trigger` 方法，传递事件 `repository:join` 和 `projectId`。我们将在 `ProjectListView` 上监听此事件。
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's hook up the other side of the previous event and add an event binder to
    `ProjectListView`. We add an `event_aggregator.bind` statement to our `initialize`
    method, binding the event `repository:join` to the `repository` method. The `repository`
    method triggers a `join` event on the router.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将上一个事件的另一侧连接起来，并为 `ProjectListView` 添加一个事件绑定器。我们在 `initialize` 方法中添加一个 `event_aggregator.bind`
    语句，将事件 `repository:join` 绑定到 `repository` 方法。`repository` 方法在路由器上触发一个 `join` 事件。
- en: '[PRE35]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's complete the picture and change router to listen to the `join` event.
    We add a `repositoryListView` function to the router and add a `listenTo` event
    to the `initialize` method that calls the `join` method. The `join` method calls
    `repository`, which instantiates the `RepositoryListView` function, passing `projectId`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完善画面，并将路由器改为监听 `join` 事件。我们向路由器添加一个 `repositoryListView` 函数，并在 `initialize`
    方法中添加一个 `listenTo` 事件，该事件调用 `join` 方法。`join` 方法调用 `repository`，它实例化 `RepositoryListView`
    函数，并传递 `projectId`。
- en: '[PRE36]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, when you click on a project item's name in `ProjectView`, `RepositoryListView`
    is displayed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你点击 `ProjectView` 中的项目项名称时，将显示 `RepositoryListView`。
- en: 'Feature: Create a project'
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能：创建项目
- en: Let's add a project form for our feature `Create a project`. It consists of
    a large **Add project** button, a text box for our project name, and `save` and
    `cancel` buttons. Clicking on **save** will POST the project to our Express server,
    whereas, clicking on **cancel** closes the form.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的功能“创建项目”添加一个项目表单。它包括一个大的**添加项目**按钮，一个用于项目名称的文本框，以及**保存**和**取消**按钮。点击**保存**将项目
    POST 到我们的 Express 服务器，而点击**取消**将关闭表单。
- en: 'What follows is an HTML template `./templates/project-form.hbs` for a repository
    item:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于存储项的 HTML 模板 `./templates/project-form.hbs`：
- en: '[PRE37]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s make a few changes to `router` and wire up a route to our `Add Project`
    button. `routes` now includes a route called `add`, which calls a method called
    `add`. We include an `add` method that calls `projectListView.showForm()`, rendering
    our form:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `router` 进行一些修改，并将一个路由连接到我们的“添加项目”按钮。`routes` 现在包括一个名为 `add` 的路由，它调用一个名为
    `add` 的方法。我们包括一个 `add` 方法，该方法调用 `projectListView.showForm()`，渲染我们的表单：
- en: '[PRE38]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's make some changes to `projectListView` and modify the `initialize` method.
    We bind this view to the `reset`, `add`, and `remove` events of the `collection`.
    We also add a `showForm` method as called in the preceding code. The method renders
    a project form by calling `this.add()`, passing `new Vision.Project()`, and calling
    `add()` on the view returned.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `projectListView` 进行一些修改，并修改 `initialize` 方法。我们将此视图绑定到 `collection` 的 `reset`、`add`
    和 `remove` 事件。我们还添加了一个 `showForm` 方法，如前述代码所示。该方法通过调用 `this.add()`、传递 `new Vision.Project()`
    并在返回的视图中调用 `add()` 来渲染项目表单。
- en: '[PRE39]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's add some validation to our `Project` model so we can validate form input
    for our project. We add a `validate` method to our `Project` model and validate
    our `Project` model's name. If validation fails, we return an `errors` array containing
    error messages. We are actually overriding the `validate` method. `Backbone.js`
    requires that you override the validate method with your custom validation logic.
    By default, the method `validate` is also called as part of a `save` call.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Project` 模型中添加一些验证，以便我们可以验证项目表单的输入。我们在 `Project` 模型中添加了一个 `validate` 方法，并验证
    `Project` 模型的名称。如果验证失败，我们返回一个包含错误信息的 `errors` 数组。我们实际上是在重写 `validate` 方法。`Backbone.js`
    要求您使用自定义验证逻辑重写 `validate` 方法。默认情况下，`validate` 方法也是 `save` 调用的一部分。
- en: '[PRE40]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's make some changes to `projectView`. We start by adding a new template
    called `formTemplate`, which displays a form for adding a new project. We add
    two new events to the `events` hash—a button `save` event and a button `cancel`
    event.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `projectView` 进行一些修改。我们首先添加一个新的模板 `formTemplate`，该模板显示一个用于添加新项目的表单。我们在
    `events` 哈希中添加了两个新事件——一个按钮 `save` 事件和一个按钮 `cancel` 事件。
- en: The `cancel` method, which responds to the cancel event, will get the current
    `projectId` from our model and check if the `model.isNew`. If it's new we simply
    remove the `projectView` from our `projectListView`. If its not new, we render
    our view and also render `repositoryListView` by calling `repository`. We then
    navigate to the `index` page using `history.navigate`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancel` 方法响应取消事件，将从我们的模型中获取当前的 `projectId` 并检查 `model.isNew`。如果是新的，我们只需从 `projectListView`
    中移除 `projectView`。如果不是新的，我们将渲染我们的视图，并通过调用 `repository` 渲染 `repositoryListView`。然后我们使用
    `history.navigate` 导航到 `index` 页面。'
- en: The `save` method, which responds to the `save` event, grabs `projectId` from
    our model and the form data. We then call `model.isValid`, which calls the `validate`
    method in our project model. Any error returned results in calling `formError`.
    If the model is valid, we go off and get our selected repositories and assign
    this to our form. We then attempt to save the form as `Project` with a call to
    `model.save`. Any error returned results in calling `formError`. A successful
    save enables us to render the `project` in `ProjectListView`. We also render `RepositoryListView`
    by calling `repository`. We then navigate to the `index` page using `history.navigate`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`save` 方法响应 `save` 事件，从我们的模型中获取 `projectId` 和表单数据。然后我们调用 `model.isValid`，它调用我们项目模型中的
    `validate` 方法。任何返回的错误都会导致调用 `formError`。如果模型有效，我们将获取我们的选定存储库并将其分配给我们的表单。然后我们尝试通过调用
    `model.save` 将表单作为 `Project` 保存。任何返回的错误都会导致调用 `formError`。成功的保存使我们能够在 `ProjectListView`
    中渲染 `project`。我们还通过调用 `repository` 渲染 `RepositoryListView`。然后我们使用 `history.navigate`
    导航到 `index` 页面。'
- en: '[PRE41]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You will now be able to complete the form and add a new project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将能够完成表单并添加一个新的项目。
- en: 'Feature: Edit a project'
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能：编辑项目
- en: Let's add an edit project form for our feature `Edit a project`. It consists
    of a text box for the project name a save and cancel button. Clicking on **save**
    will PUT the project to our Express server; clicking on **cancel** closes the
    form. We will use the same handlebars template we used for adding a project. In
    order to make `RepositoryListView` editable, we will need to introduce the concept
    of an edit state. We have called `editMode`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的功能“编辑项目”添加一个编辑项目表单。它包括一个项目名称的文本框、一个保存按钮和一个取消按钮。点击**保存**会将项目发送到我们的 Express
    服务器；点击**取消**会关闭表单。我们将使用与添加项目相同的 handlebars 模板。为了使 `RepositoryListView` 可编辑，我们需要引入编辑状态的概念。我们将其命名为
    `editMode`。
- en: Let's make some changes to `projectView`. We start by adding a new event `edit`
    to the `events` hash, which calls an `edit` function. We change our `repository`
    method by passing a new `arg.editMode` to `event_aggregator`, which will inform
    our `RepositoryListView` that it is in edit mode.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `projectView` 进行一些修改。我们首先向 `events` 哈希中添加一个名为 `edit` 的新事件，该事件调用一个 `edit`
    函数。我们通过向 `event_aggregator` 传递新的 `arg.editMode` 参数来更改我们的 `repository` 方法，这将通知
    `RepositoryListView` 它处于编辑模式。
- en: The `edit` method, which displays our project `formTemplate`, populated with
    our `project` model data calls the `repository` method with `editMode` set to
    `false`, informing `RepositoryListView` that it is in edit mode. Finally, we update
    our `add`, `cancel`, and `save` methods; calls in these methods to the `repository`
    method should pass `{editMode:false}`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`edit` 方法，它显示我们的 `formTemplate` 并用 `project` 模型数据填充，调用 `repository` 方法并将 `editMode`
    设置为 `false`，通知 `RepositoryListView` 它处于编辑模式。最后，我们更新我们的 `add`、`cancel` 和 `save`
    方法；这些方法中对 `repository` 方法的调用应传递 `{editMode:false}`。'
- en: '[PRE42]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's make some changes to `RepositoryListView`. The `initialize` method will
    now either enable or disable the form checkboxes based on `editMode` when `collection.fetch`
    makes a successful request. The `enableForm` function removes the `disabled` tag
    from our `RepositoryListView` checkbox list. The `disableForm` function adds the
    `disabled` tag to our `RepositoryListView` checkbox list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `RepositoryListView` 进行一些修改。现在，当 `collection.fetch` 成功请求时，`initialize`
    方法将根据 `editMode` 启用或禁用表单复选框。`enableForm` 函数从我们的 `RepositoryListView` 复选框列表中移除
    `disabled` 标签。`disableForm` 函数向我们的 `RepositoryListView` 复选框列表中添加 `disabled` 标签。
- en: '[PRE43]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now you will be able to edit your existing projects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将能够编辑您现有的项目。
- en: 'Feature: Delete a project'
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能：删除项目
- en: Let's add a **delete** button to our form for the feature `Delete a project`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为功能 `Delete a project` 在我们的表单中添加一个 **删除** 按钮。
- en: Let's make a change to `ProjectView` and add a new event to the `events` hash,
    called `delete`, which calls the `delete` method. We add a `delete` method, which
    destroys the model and removes `ProjectView`. We then call `repository`, removing
    `RepositoryListView`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `ProjectView` 进行修改，并向 `events` 哈希中添加一个名为 `delete` 的新事件，该事件调用 `delete` 方法。我们添加一个
    `delete` 方法，它销毁模型并移除 `ProjectView`。然后我们调用 `repository`，移除 `RepositoryListView`。
- en: '[PRE44]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let's make a change to `ProjectListView` and add a `collection` event handler
    to `initialize`. The event handler calls the `remove` method when an item is removed.
    The `remove` method grabs the model's attributes and searches the `Projects` collection,
    removing the item when finding it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对 `ProjectListView` 进行修改，并在 `initialize` 中添加一个 `collection` 事件处理程序。事件处理程序在移除项目时调用
    `remove` 方法。`remove` 方法获取模型的属性并搜索 `Projects` 集合，找到时移除项目。
- en: '[PRE45]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You will now be able to delete a project by clicking on the delete button.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过点击删除按钮来删除项目。
- en: 'Feature: List commits'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能：列出提交
- en: 'Let''s add a list of commits for the feature `List Commits`. Each item in the
    list consists of a commit `message`, project `name`, a `date`, and the committer''s
    `username`. The following is a HTML template `./templates/commits.hbs` for a commit
    item:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为功能 `List Commits` 添加一个提交列表。列表中的每个项目由一个提交 `message`、项目 `name`、一个 `date` 和提交者的
    `username` 组成。以下是一个提交项的 HTML 模板 `./templates/commits.hbs`：
- en: '[PRE46]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let's implement our `Commit` model. We define a function, `Commit`, which extends
    the Backbone `Model` type, and we include a hash of default values for the properties
    in our model.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现我们的 `Commit` 模型。我们定义一个名为 `Commit` 的函数，它扩展了 Backbone `Model` 类型，并包括我们模型中属性的默认值哈希。
- en: '[PRE47]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Let's implement a collection, `CommitList`, for our `Commit` model. We define
    a function, `CommitList`, which extends the Backbone `Collection` type. We specify
    the model type as `Vision.Commit`. We add a `url` method that uses the web API
    route `/project/:id/commits` to return a list of commits. The `initialize` method
    is called when the collection is instantiated; from here we assign `projectId`.
    The `parse` method is called when a fetch is performed and will parse the response.
    Here we assign our MongoDB `_id` to `response.id`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的 `Commit` 模型实现一个集合，名为 `CommitList`。我们定义一个名为 `CommitList` 的函数，它扩展了 Backbone
    `Collection` 类型。我们指定模型类型为 `Vision.Commit`。我们添加一个 `url` 方法，它使用 Web API 路由 `/project/:id/commits`
    返回提交列表。当集合实例化时调用 `initialize` 方法；从这里我们分配 `projectId`。当执行获取操作时调用 `parse` 方法，它将解析响应。在这里我们将我们的
    MongoDB `_id` 分配给 `response.id`。
- en: '[PRE48]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Let's implement a view for our `Commit` collection. We define a function, `CommitListView`,
    which extends the Backbone `View` type, and adds a `Commits` array for our commits
    list. The `initialize` method is called when the view is instantiated; from here
    we call `create` and instantiate a new `CommitList`, passing our `Commits` array.
    We call `refresh` ,which loops through the `Commits` collection rendering the
    view with a call to `render`. The `render` method uses underscore to loop through
    the `Commits` collection called `collection.models` by calling `add(item)` for
    each `commit`. The method `add` instantiates `CommitView`, passing to it a `Commit`
    model, it then appends a rendered `CommitView` to the DOM element via `$el` and
    returns the view.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`Commit`集合实现一个视图。我们定义了一个函数`CommitListView`，它扩展了Backbone的`View`类型，并为我们的提交列表添加了一个`Commits`数组。当视图实例化时调用`initialize`方法；从这里我们调用`create`并实例化一个新的`CommitList`，传递我们的`Commits`数组。我们调用`refresh`，它遍历`Commits`集合，通过调用`render`方法渲染视图。`render`方法使用underscore遍历名为`collection.models`的`Commits`集合，对每个`commit`调用`add(item)`。`add`方法实例化`CommitView`，传递一个`Commit`模型给它，然后通过`$el`将渲染的`CommitView`追加到DOM元素中，并返回视图。
- en: '[PRE49]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We continue by adding a view for a single commit item. We define a function,
    `CommitView`, which extends the Backbone `View` type, and add a `tagName` and
    assign `li` to it. This tag will be wrapped around our commit view; our DOM element
    is a `ul` tag. We include `viewTemplate` and assign our precompiled handlebars
    template `./templates/commits.hbs` to it. The `render` method renders the view;
    we pass the `commit` model to our `viewTemplate`, which is then added via `$el`
    to our DOM element and we return the view.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续添加一个用于单个提交项的视图。我们定义了一个函数`CommitView`，它扩展了Backbone的`View`类型，并为它添加了一个`tagName`，将其分配为`li`。这个标签将围绕我们的提交视图；我们的DOM元素是一个`ul`标签。我们包括`viewTemplate`并将其分配给预编译的handlebars模板`./templates/commits.hbs`。`render`方法渲染视图；我们传递`commit`模型到我们的`viewTemplate`，然后通过`$el`添加到我们的DOM元素中，并返回视图。
- en: '[PRE50]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let's complete the picture and change our router; we add a `CommitListView`
    to the router and call `commits` inside the `join` method. The `commits` method
    instantiates a `CommitListView` passing the current `projectId` and a list of
    commits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完善画面并更改我们的路由；我们在路由中添加了一个`CommitListView`，并在`join`方法中调用`commits`。`commits`方法实例化一个`CommitListView`，传递当前的`projectId`和提交列表。
- en: '[PRE51]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Vision will now display a list of commits when selecting a project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择项目时，Vision将显示提交列表。
- en: 'Feature: List issues'
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能：列出问题
- en: Let's build our issues list. Each item in the list simply consists of an issue
    title, project name, a date, the issuer's username, and its status.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的问题列表。列表中的每个项仅由一个问题标题、项目名称、日期、发布者的用户名及其状态组成。
- en: 'What follows is an HTML template `./templates/issues.hbs` for a issues item:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个用于问题项的HTML模板`./templates/issues.hbs`：
- en: '[PRE52]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let's implement our `Issue` model; we define a function `Issue`, which extends
    the Backbone `Model` type, and includes a hash of `default` values for the properties
    in our model.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现我们的`Issue`模型；我们定义了一个函数`Issue`，它扩展了Backbone的`Model`类型，并包括模型属性中的默认值哈希。
- en: '[PRE53]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Let's implement a collection called `IssueList` for our `Issue` model. We define
    a function, `IssueList`, which extends the Backbone `Collection` type, and specifies
    the model type as `Vision.Issue`. We add a `url` method that uses the web API
    route `/project/:id/issues` to return a list of issues. The `initialize` method
    is called when the collection is instantiated; from here we assign the selected
    `projectId`. The `parse` method is called when a fetch is performed and will parse
    the response; here we assign our MongoDB `_id` to the `response.id`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`Issue`模型实现一个名为`IssueList`的集合。我们定义了一个函数`IssueList`，它扩展了Backbone的`Collection`类型，并将模型类型指定为`Vision.Issue`。我们添加了一个`url`方法，它使用Web
    API路由`/project/:id/issues`来返回问题列表。当集合实例化时调用`initialize`方法；从这里我们分配选定的`projectId`。当执行获取操作时调用`parse`方法，这里我们将我们的MongoDB
    `_id`分配给`response.id`。
- en: '[PRE54]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Let's implement a view for our `Issue` collection. We define a function, `IssueListView`,
    which extends the Backbone `View` type, and add an `Issues` array for our issue
    list. The `initialize` method is called when the `view` is instantiated; from
    here we call `create` and instantiate a new `IssueList`, passing our `Issues`
    array. We then call `refresh`, which loops through the `Issues` collection, rendering
    the view with a call to `render`. The `render` method uses underscore to loop
    through the `Issues` collection called `collection.models`; and calls `add(item)`for
    each issue. The method `add` instantiates `IssueView`, passing to it an `Issue`
    model. We then append a rendered `IssueView` to our DOM element via `$el` and
    return the view.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`Issue`集合实现一个视图。我们定义一个函数，`IssueListView`，它扩展了Backbone的`View`类型，并为我们的问题列表添加了一个`Issues`数组。当`view`被实例化时，会调用`initialize`方法；从这里我们调用`create`并实例化一个新的`IssueList`，传递我们的`Issues`数组。然后我们调用`refresh`，它遍历`Issues`集合，通过调用`render`来渲染视图。`render`方法使用underscore遍历名为`collection.models`的`Issues`集合；并为每个问题调用`add(item)`。`add`方法实例化`IssueView`，并传递一个`Issue`模型。然后我们通过`$el`将渲染后的`IssueView`追加到我们的DOM元素中，并返回视图。
- en: '[PRE55]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We continue by adding a view for a single issue. We define a function, `IssueView`,
    which extends the Backbone `View` type, and add a `tagName` and assign `li` to
    it; this tag will be wrapped around our `IssueView` function. Our DOM element
    is a `ul` tag. We include a `viewTemplate` and assign our precompiled handlebars
    template `templates/issues.hbs` to it. The `render` method renders the view; we
    pass the `issue` model to `viewTemplate` which is then added via `$el` to our
    DOM element and we return the view.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个用于单个问题的视图。我们定义一个函数，`IssueView`，它扩展了Backbone的`View`类型，并为它添加了一个`tagName`，将其赋值为`li`；这个标签将围绕我们的`IssueView`函数。我们的DOM元素是一个`ul`标签。我们包含了一个`viewTemplate`并将其赋值给我们的预编译的handlebars模板`templates/issues.hbs`。`render`方法渲染视图；我们将`issue`模型传递给`viewTemplate`，然后通过`$el`将其添加到我们的DOM元素中，并返回视图。
- en: '[PRE56]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Let's complete the picture and change our router; we add a `issueListView` to
    the router and call `issues` inside the `join` method. The `issues` method instantiates
    `IssueListView`, passing `projectId` and a list of issues.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完善这个画面并更改我们的路由器；我们在路由器中添加了一个`issueListView`，并在`join`方法中调用`issues`。`issues`方法实例化`IssueListView`，传递`projectId`和问题列表。
- en: '[PRE57]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Vision will now display a list of issues when selecting a project.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 选择项目时，愿景将现在显示问题列表。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We have now completed the first part of our client. We have implemented a project
    list view that allows us to add, update, and remove projects. We have also implemented
    a repository list view that displays a list of repositories for our access token;
    these repositories can be assigned to the project. We also display a list of commits
    and issues for all repositories in our project. In the next chapter, we will display
    a real-time list of commits and issues using Socket.IO.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了客户端的第一部分。我们实现了一个项目列表视图，允许我们添加、更新和删除项目。我们还实现了一个仓库列表视图，显示了我们访问令牌的仓库列表；这些仓库可以被分配到项目中。我们还显示了我们项目中所有仓库的提交和问题列表。在下一章中，我们将使用Socket.IO显示提交和问题的实时列表。
