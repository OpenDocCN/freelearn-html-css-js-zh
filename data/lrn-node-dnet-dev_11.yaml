- en: Chapter 11. Deploying Node.js Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。部署Node.js应用程序
- en: So far, we have only run our application in our local development environment.
    In this chapter, we will deploy it to the Web. There are many different options
    for hosting an application. We will work through one deployment option to quickly
    get an application up and running. We will also discuss broader principles and
    alternative options for deploying Node.js applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在本地开发环境中运行了我们的应用程序。在本章中，我们将将其部署到Web上。托管应用程序有多种不同的选项。我们将通过一个部署选项来快速启动应用程序。我们还将讨论部署Node.js应用程序的更广泛原则和替代方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Deploying our application to the Web
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的应用程序部署到Web
- en: Using application logs to diagnose issues on remote servers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序日志诊断远程服务器上的问题
- en: Setting up database servers and environmental configuration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置数据库服务器和环境配置
- en: Deploying automatically from Travis CI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Travis CI自动部署
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to follow along with this chapter, you can use the code from [https://github.com/NodeJsForDevelopers/chapter10/](https://github.com/NodeJsForDevelopers/chapter10/)
    as a starting point. This contains the example code from the end of [Chapter 10](part0058.xhtml#aid-1NA0K1
    "Chapter 10. Creating Real-time Web Apps"), *Creating Real-time Web Apps*, which
    we will build on in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟随本章，可以使用[https://github.com/NodeJsForDevelopers/chapter10/](https://github.com/NodeJsForDevelopers/chapter10/)中的代码作为起点。这包含了[第10章](part0058.xhtml#aid-1NA0K1
    "第10章。创建实时Web应用")末尾的示例代码，*创建实时Web应用*，我们将在此基础上构建。
- en: Working with Heroku
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Heroku协作
- en: '**Heroku** is a cloud-based platform for web applications. It aims to allow
    developers to focus on applications rather than infrastructure. It provides a
    low-friction workflow for deploying a new application quickly, while also supporting
    long-term scalability. It also offers a marketplace of add-on services, such as
    databases and monitoring.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Heroku**是一个基于云的Web应用程序平台。它的目标是让开发者能够专注于应用程序而不是基础设施。它提供了一个低摩擦的工作流程，可以快速部署新应用程序，同时支持长期的可扩展性。它还提供了一个附加服务市场，例如数据库和监控。'
- en: There are several similar services to Heroku, some of which we will cover later
    in this chapter. Heroku was one of the first services of its kind. In particular,
    it was one of the first to support Node.js as a first-class citizen. It also offers
    many features for free, including everything needed for the worked example in
    this section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个与Heroku类似的服务，其中一些我们将在本章后面介绍。Heroku是这类服务中的先驱之一。特别是，它是第一个将Node.js作为一等公民支持的服务之一。它还提供了许多免费功能，包括本节工作示例所需的一切。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that Heroku's free features are sufficient for deploying an application
    for development, demonstration, or experimental purposes. It would not be sufficient
    for a production deployment of an application serving end users. See [https://www.heroku.com/pricing](https://www.heroku.com/pricing)
    for details of Heroku's pricing tiers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Heroku的免费功能足以部署用于开发、演示或实验目的的应用程序。它不足以用于为最终用户提供服务的应用程序的生产部署。有关Heroku定价层的详细信息，请参阅[https://www.heroku.com/pricing](https://www.heroku.com/pricing)。
- en: Setting up a Heroku account and tooling
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Heroku账户和工具
- en: To follow the example in this section, you will first need to sign up for Heroku
    at [https://signup.heroku.com/](https://signup.heroku.com/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本节中的示例，您首先需要在[https://signup.heroku.com/](https://signup.heroku.com/)上注册Heroku。
- en: We will also be using the heroku toolbelt, a CLI for configuring Heroku. Download
    and install the version for your platform from [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用heroku工具包，这是一个用于配置Heroku的CLI。从[https://toolbelt.heroku.com/](https://toolbelt.heroku.com/)下载并安装适用于您平台版本的程序。
- en: 'Check that the heroku toolbelt is installed correctly and available on your
    path. Open a new command prompt and run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 检查heroku工具包是否正确安装并且可在您的路径上使用。打开一个新的命令提示符并运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see the help text with a list of available commands. Configure the
    toolbelt to use your Heroku account by running the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到带有可用命令列表的帮助文本。通过运行以下命令配置工具包以使用您的Heroku账户：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running an application locally with Heroku
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Heroku在本地运行应用程序
- en: 'Heroku requires a small configuration file (similar to `.travis.yml`) telling
    it how to run our application. This is a file named **Procfile**, which in our
    case contains a single line as follow:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 需要一个小的配置文件（类似于 `.travis.yml`），告诉它如何运行我们的应用程序。这个文件名为 **Procfile**，在我们的情况下，它包含以下单行：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This tells Heroku that our application consists of a single web process, which
    can be started with `npm start`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Heroku，我们的应用程序由一个单一的 Web 进程组成，可以使用 `npm start` 启动。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note, especially if you are used to the Windows filesystem, that the uppercase
    P in the filename is important. The application will be deployed to a Unix-like
    system, where filenames are case-sensitive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，特别是如果你习惯了 Windows 文件系统，文件名中的大写 P 很重要。应用程序将被部署到一个类似 Unix 的系统，其中文件名是区分大小写的。
- en: 'To verify our `Procfile`, we can run our application locally using Heroku:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的 `Procfile`，我们可以使用 Heroku 在本地运行我们的应用程序：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will launch our application using the `Procfile`. Note that it also sets
    a default port of `5000`. You should now be able to visit the application at `http://localhost:5000`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `Procfile` 启动我们的应用程序。请注意，它还设置了默认端口 `5000`。你现在应该能够访问应用程序在 `http://localhost:5000`。
- en: 'The `heroku local` command also sets up environment variables for our application.
    These are read from a local `.env` file at the root of our application:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku local` 命令还为我们的应用程序设置了环境变量。这些是从我们应用程序根目录的本地 `.env` 文件中读取的：'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can test this by starting up local instances of MongoDB and Redis. Run
    the following commands in separate prompts (setting the `--dbpath` as appropriate):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过启动 MongoDB 和 Redis 的本地实例来测试这一点。在单独的提示符中运行以下命令（根据需要设置 `--dbpath`）：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Having this `.env` file means that we can use `npm start` directly (as we have
    before) to run with mock datastores and `heroku local` when we want a more realistic
    environment, without having to keep track of our current environment variables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有这个 `.env` 文件意味着我们可以直接使用 `npm start`（就像我们之前做的那样）来运行带有模拟数据存储，当我们需要一个更真实的环境时，使用
    `heroku local`，而不必跟踪我们的当前环境变量。
- en: Deploying an application to Heroku
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Heroku
- en: 'Now that we have created a `Procfile`, deploying our application to the web
    is easy. First, we need to create a new Heroku application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个 `Procfile`，将我们的应用程序部署到网络变得容易。首先，我们需要创建一个新的 Heroku 应用程序：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By default, this provisions a minimal application on Heroku, with a randomly
    assigned name. You can optionally specify an application name as a third parameter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将在 Heroku 上创建一个最小化应用程序，并分配一个随机名称。你可以选择指定一个应用程序名称作为第三个参数。
- en: 'This command also returns the public URL for our newly-created app, which we
    can visit now. The following response is returned:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令还返回了我们新创建应用程序的公共 URL，我们现在可以访问。以下响应被返回：
- en: '![Deploying an application to Heroku](img/image00222.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![将应用程序部署到 Heroku](img/image00222.jpeg)'
- en: 'There''s not much to see because we haven''t deployed anything yet. The quickest
    way to deploy an application to Heroku is via Git. The `heroku create` command
    also created a new Git remote for us to push to. You can see this by viewing the
    list of Git remotes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有部署任何内容，所以没有太多可以看的。将应用程序部署到 Heroku 的最快方式是通过 Git。`heroku create` 命令还为我们创建了一个新的
    Git 远程，我们可以将其推送到。你可以通过查看 Git 远程列表来看到这一点：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now have a Git remote named `heroku`. Make sure the new `Procfile` has been
    committed. Now, when we push our master branch to this remote, it is automatically
    built and deployed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为 `heroku` 的 Git 远程。确保新的 `Procfile` 已经被提交。现在，当我们把我们的 master 分支推送到这个远程时，它将自动构建和部署：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we visit the application''s URL again now, we see the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次访问应用程序的 URL，我们会看到以下内容：
- en: '![Deploying an application to Heroku](img/image00223.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![将应用程序部署到 Heroku](img/image00223.jpeg)'
- en: Our application has deployed but is now returning an error. To diagnose the
    problem with our application, we'll need to look at the logs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经部署，但现在正在返回错误。为了诊断我们应用程序的问题，我们需要查看日志。
- en: Working with Heroku logs, config, and services
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Heroku 日志、配置和服务一起工作
- en: 'We can view the logs from our application by running `heroku logs`. If you
    look through the logs to the error stacktrace, you''ll see the following error
    message:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行 `heroku logs` 来查看我们应用程序的日志。如果你查看日志到错误堆栈跟踪，你会看到以下错误信息：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `mockgoose` package is unavailable because Heroku builds our application
    using the `dependencies` in `package.json` and not the `devDependencies`. Recall
    from [Chapter 9](part0052.xhtml#aid-1HIT82 "Chapter 9. Persisting Data"), *Persisting
    Data*, that this error is intentional. We wanted the application to fail in live
    environments if no MongoDB URL is configured.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockgoose`包不可用，因为Heroku使用`package.json`中的`dependencies`而不是`devDependencies`来构建我们的应用程序。回想一下[第9章](part0052.xhtml#aid-1HIT82
    "第9章。持久化数据")，*持久化数据*，这个错误是故意的。我们希望应用程序在没有配置MongoDB URL的情况下在实时环境中失败。'
- en: To fix this error, we need to set up a MongoDB instance and configure our application
    to connect to it. We'll need to do the same for our Redis DB. Both of these data
    stores are available as services from the Heroku marketplace.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个错误，我们需要设置一个MongoDB实例并配置我们的应用程序以连接到它。我们还需要为我们的Redis数据库做同样的事情。这两个数据存储都可以从Heroku市场作为服务使用。
- en: Setting up MongoDB
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置MongoDB
- en: 'We can add Heroku marketplace services via the command line. MongoLab is a
    third-party service providing MongoDB instances. We can add an instance to our
    application as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过命令行添加Heroku市场服务。MongoLab是一个第三方服务，提供MongoDB实例。我们可以按照以下方式将实例添加到我们的应用程序中：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This creates a sandbox (free tier) MongoDB instance, suitable for demo purposes.
    Note from the output of this command that it also created a `MONGOLAB_URI` config
    variable. Heroku will provide this to our application as an environment variable
    at runtime.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个沙盒（免费版）MongoDB实例，适用于演示目的。注意，从该命令的输出中可以看出，它还创建了一个`MONGOLAB_URI`配置变量。Heroku将在运行时将此变量作为环境变量提供给我们的应用程序。
- en: 'Our application is expecting an environment variable named `MONGODB_URL`. We''ll
    need to create this and set it to the same value as `MONGOLAB_URI`. You can view
    and set config variables for an application as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序期望一个名为`MONGODB_URL`的环境变量。我们需要创建这个变量并将其设置为与`MONGOLAB_URI`相同的值。您可以通过以下方式查看和设置应用程序的配置变量：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should fill in the value of `MONGODB_URL` to match the value of `MONGOLAB_URI`
    returned by the first command.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您应填写`MONGODB_URL`的值，以匹配第一个命令返回的`MONGOLAB_URI`的值。
- en: Setting up Redis
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Redis
- en: 'Heroku also provides a Redis service via its marketplace. We''ll add it to
    our application as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku还通过其市场提供Redis服务。我们将按照以下方式将其添加到我们的应用程序中：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again we use the free tier version of this service (hobby-dev) for demo purposes.
    It's easy to re-scale services to different tiers later.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用这个服务的免费版（hobby-dev）进行演示。稍后很容易将服务重新缩放到不同的级别。
- en: The Redis service also allows you to specify an alias for the created service
    instance. Aliases are specified using the `--as` parameter with `heroku addons:create`.
    This is useful for Redis as we may have several Redis instances associated with
    a single application. It's particularly useful for us, since, by aliasing our
    instance as REDIS, Heroku will create a `REDIS_URL` environment variable. This
    is exactly what our application expects to see.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Redis服务还允许您为创建的服务实例指定别名。别名使用`heroku addons:create`命令中的`--as`参数指定。这对于Redis来说很有用，因为我们可能有一个与单个应用程序关联的多个Redis实例。对我们来说尤其有用，因为通过将我们的实例别名为REDIS，Heroku将创建一个`REDIS_URL`环境变量。这正是我们的应用程序期望看到的。
- en: 'The `heroku addons:create` command restarts our application immediately. Our
    new database instances will take a minute or two to become available though. Wait
    a minute before restarting the application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku addons:create`命令会立即重启我们的应用程序。不过，我们的新数据库实例可能需要一分钟左右才能可用。在重启应用程序之前等待一分钟：'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can now visit the application URL in our browser and see it running on the
    Web!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在浏览器中访问应用程序URL，并看到它在Web上运行！
- en: '![Setting up Redis](img/image00224.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![设置Redis](img/image00224.jpeg)'
- en: Deploying from Travis CI
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Travis CI部署
- en: Deploying via Git is a quick way to get up and running and is useful for developers.
    It's not a robust way of pushing out changes though. If we are practicing Continuous
    Delivery then we may want to deploy on every commit, at least to a UAT environment.
    But we still want our CI server to act as a gatekeeper and ensure that we only
    deploy good builds.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Git部署是一种快速启动和运行的方式，对开发者很有用。但这并不是推送更改的健壮方式。如果我们正在实践持续交付，那么我们可能希望在每次提交时部署，至少部署到UAT环境。但我们仍然希望我们的CI服务器充当门卫，确保我们只部署良好的构建。
- en: 'Travis CI supports deployment to a wide range of hosting providers (as well
    as arbitrary deployment via custom scripts). We can tell Travis CI to deploy to
    Heroku by adding a `deploy` section to our `travis.yml` as follows (replacing
    `application-name-12345` with the name of our previously created Heroku application):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI 支持部署到广泛的托管提供商（以及通过自定义脚本的任意部署）。我们可以通过在 `travis.yml` 文件中添加一个 `deploy`
    部分来告诉 Travis CI 部署到 Heroku，如下所示（将 `application-name-12345` 替换为我们之前创建的 Heroku 应用程序的名称）：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Travis CI will only deploy our application if the build passes. In order for
    Travis CI to communicate with Heroku, it requires our Heroku API key. But we may
    not want to commit this to source control (especially if our Git repository is
    public). Travis CI allows you to avoid this by specifying encrypted environment
    variables for the build.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI 只有在构建通过的情况下才会部署我们的应用程序。为了使 Travis CI 能够与 Heroku 通信，它需要我们的 Heroku API
    密钥。但我们可能不想将其提交到源代码控制（尤其是如果我们的 Git 仓库是公开的）。Travis CI 允许您通过为构建指定加密的环境变量来避免这种情况。
- en: Setting encrypted Travis CI environment variables
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置加密的 Travis CI 环境变量
- en: Environment variables can be encrypted using a public key that Travis CI associates
    with our repository. Travis CI then uses the corresponding private key to decrypt
    these variables at build time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Travis CI 与我们的仓库关联的公钥来加密环境变量。Travis CI 然后使用相应的私钥在构建时解密这些变量。
- en: The easiest way to encrypt environment variables with the correct key is to
    use the Travis CLI. This is available as a Ruby package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的密钥加密环境变量的最简单方法是使用 Travis CLI。这是一个 Ruby 包。
- en: Installing Ruby
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Ruby
- en: If you do not have Ruby installed on your system already, see [https://www.ruby-lang.org/en/documentation/installation/](https://www.ruby-lang.org/en/documentation/installation/).
    The best way to install on Windows is to use `RubyInstaller`, from [http://rubyinstaller.org/](http://rubyinstaller.org/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统上尚未安装 Ruby，请参阅 [https://www.ruby-lang.org/en/documentation/installation/](https://www.ruby-lang.org/en/documentation/installation/)。在
    Windows 上安装的最佳方式是使用 `RubyInstaller`，来自 [http://rubyinstaller.org/](http://rubyinstaller.org/)。
- en: 'You can check whether Ruby is installed and configured on your path by running
    the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来检查 Ruby 是否已安装并配置在您的路径上：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should have version 2.0.0 or higher.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该拥有 2.0.0 或更高版本。
- en: Creating an encrypted environment variable
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个加密的环境变量
- en: 'Once you have Ruby installed and on your path, you can install the Travis CLI
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已将 Ruby 安装到您的路径上，您可以通过以下方式安装 Travis CLI：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Gem** is the Ruby package manager, similar to `npm`. The `--no-doc` and `--no-ri`
    arguments here skip installation of low-level API docs, which we don''t need.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gem** 是 Ruby 包管理器，类似于 `npm`。这里的 `--no-doc` 和 `--no-ri` 参数跳过了低级 API 文档的安装，这些我们不需要。'
- en: 'Now we can add our encrypted environment variable. First we need to obtain
    the Heroku API key for our application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加我们的加密环境变量。首先，我们需要获取我们应用程序的 Heroku API 密钥：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can add this to our `.travis.yml` file as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将其添加到 `.travis.yml` 文件中，如下所示：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`[AUTH_TOKEN]` is the output from the previous command.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`[AUTH_TOKEN]` 是上一条命令的输出。'
- en: 'This encrypts the API key and automatically adds the encrypted version into
    our `.travis.yml` file. Before committing, try updating something in the application,
    for example the page title from `src/routes/index.js`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加密 API 密钥并自动将加密版本添加到我们的 `.travis.yml` 文件中。在提交之前，尝试更新应用程序中的某些内容，例如 `src/routes/index.js`
    中的页面标题：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now commit and push the master branch (to `origin`, not directly to `heroku`)
    and wait for the Travis CI build to complete. The build output shows our application
    being deployed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，提交并推送主分支（到 `origin`，而不是直接到 `heroku`），并等待 Travis CI 构建完成。构建输出显示我们的应用程序正在部署：
- en: '![Creating an encrypted environment variable](img/image00225.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个加密的环境变量](img/image00225.jpeg)'
- en: If you visit the application again, you should see the new version with the
    updated title.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次访问应用程序，您应该看到带有更新标题的新版本。
- en: 'Recall that Travis CI is actually building our application for multiple versions
    of Node.js. By default, Travis CI deploys our application at the end of each build
    job. This is unnecessary and slows down our overall build. We can tell Travis
    CI to deploy only from a specific build job by altering our `.travis.yml` file
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Travis CI 实际上是在为多个 Node.js 版本构建我们的应用程序。默认情况下，Travis CI 在每个构建作业结束时部署我们的应用程序。这是不必要的，并且会减慢我们的整体构建速度。我们可以通过修改
    `.travis.yml` 文件来告诉 Travis CI 只从特定的构建作业中部署，如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we commit and check the output from Travis CI again, we can see that only
    the Node.js v6 build job performs a deployment.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次提交并检查Travis CI的输出，我们可以看到只有Node.js v6构建作业执行了部署。
- en: Further resources
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步资源
- en: For further considerations on deploying web apps, see The Twelve-Factor App
    ([http://12factor.net/](http://12factor.net/)). This is a detailed resource about
    important considerations for running enterprise-grade web applications on services
    such as Heroku.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于部署Web应用程序的进一步考虑，请参阅《十二要素应用》([http://12factor.net/](http://12factor.net/))。这是一份关于在Heroku等服务上运行企业级Web应用程序的重要考虑因素的详细资源。
- en: There are, of course, a great many options for hosting a web application. Azure's
    web app service and AWS's Elastic Beanstalk both support Node.js as a first-class
    citizen. Modulus ([https://modulus.io/](https://modulus.io/)) provides Node.js
    and Mongo DB hosting, with powerful scaling, monitoring, and load-balancing features.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，托管网络应用程序有很多选择。Azure的Web应用程序服务和AWS的Elastic Beanstalk都支持Node.js作为一等公民。Modulus
    ([https://modulus.io/](https://modulus.io/))提供Node.js和Mongo DB托管，具有强大的扩展、监控和负载均衡功能。
- en: The preceding are all examples of application hosting platforms (**Platform-as-a-Service**
    (**PaaS**), in cloud terminology). You can, of course, also deploy Node.js applications
    to bare infrastructure (either cloud infrastructure or your own machines). For
    a detailed guide, see [https://certsimple.com/blog/deploy-node-on-linux](https://certsimple.com/blog/deploy-node-on-linux).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容都是应用程序托管平台的示例（**平台即服务**（**PaaS**），在云术语中）。当然，您也可以将Node.js应用程序部署到裸机基础设施（无论是云基础设施还是您自己的机器）。有关详细指南，请参阅[https://certsimple.com/blog/deploy-node-on-linux](https://certsimple.com/blog/deploy-node-on-linux)。
- en: You may need to manage releases of your application through multiple environments.
    Your CI server might first deploy your application to an integration environment
    and run tests on it there before deploying to UAT. You may then want to be able
    to push the exact same release from UAT to Stage and Live environments at the
    click of a button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要通过多个环境管理应用程序的发布。您的CI服务器可能首先将应用程序部署到集成环境并在那里运行测试，然后再部署到UAT。然后您可能希望能够通过点击按钮将UAT环境中的确切同一发布版本推送到预发布和实时环境。
- en: Heroku Pipelines and Azure Web App deployment slots allow you to manage the
    release of your application through different environments. **Wercker** ([http://wercker.com/](http://wercker.com/))
    is a build and deployment service that can automate more complex workflows. It
    also provides isolated environments based on Docker containers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku管道和Azure Web应用程序部署槽允许您通过不同的环境管理应用程序的发布。**Wercker** ([http://wercker.com/](http://wercker.com/))是一个构建和部署服务，可以自动化更复杂的流程。它还提供基于Docker容器的隔离环境。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have deployed an application to the web using Heroku, configured
    environment settings and provisioned databases, set up Travis CI to automatically
    deploy successful builds, and learned about further options and considerations
    for deploying Node.js applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Heroku将应用程序部署到网络，配置了环境设置并提供了数据库，设置了Travis CI以自动部署成功的构建，并了解了部署Node.js应用程序的更多选项和考虑因素。
- en: Now that our application is available online, we can start thinking about how
    to integrate it with the wider Web. In the next chapter, we'll look at allowing
    users to log in using third party social media services as an identity provider.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序已上线，我们可以开始考虑如何将其与更广泛的网络集成。在下一章中，我们将探讨允许用户使用第三方社交媒体服务作为身份提供者进行登录。
