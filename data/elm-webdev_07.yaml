- en: Making a Weather App in Elm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Elm中制作天气应用
- en: Welcome to [Chapter 7](db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml), *Making
    a Weather App in Elm*. In this chapter, we will make our Elm-powered weather app.
    The purpose of this app is to learn how to fetch information from JSON and use
    it in our app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[第7章](db847a07-9e71-4a31-a477-32d85a1f34c3.xhtml)，*在Elm中制作天气应用*。在本章中，我们将制作我们的Elm天气应用。这个应用的目的在于学习如何从JSON中获取信息并将其用于我们的应用中。
- en: 'The topics we will cover include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的主题包括：
- en: Taking care of errors with `Result`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Result`处理错误
- en: Dealing with optional values and nothingness using `Maybe`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Maybe`处理可选值和空值
- en: Decoding JSON strings using decoders
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解码器解码JSON字符串
- en: Fetching remote data with the help of the HTTP package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP包帮助获取远程数据
- en: Working with a third-party API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与第三方API合作
- en: 'After completing this chapter, you will be able to:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一章后，你将能够：
- en: Fetch information from the internet in JSON format
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以JSON格式从互联网获取信息
- en: Have your Elm apps consume JSON data using decoders
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的Elm应用使用解码器消费JSON数据
- en: Understand how all the moving parts fit together to build a functioning app
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解所有部件如何组合在一起以构建一个功能性的应用
- en: To begin, we will look at obtaining weather data from a third-party API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨从第三方API获取天气数据。
- en: Obtaining the weather data from a third-party API
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从第三方API获取天气数据
- en: In order for our weather app to even be possible, we will need to obtain weather
    data from somewhere. Luckily, there are plenty of weather-related APIs online,
    which makes this task a lot easier to accomplish.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的天气应用成为可能，我们需要从某处获取天气数据。幸运的是，网上有大量的天气相关API，这使得这项任务变得容易得多。
- en: In order to have a working app, we need to connect to a third-party data provider.
    In our case, the data provider we will use is Open Weather Map.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个工作的应用，我们需要连接到第三方数据提供商。在我们的案例中，我们将使用的数据提供商是Open Weather Map。
- en: The information about the Open Weather Map's API is available at [https://openweathermap.org/api](https://openweathermap.org/api).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Open Weather Map的API信息可在[https://openweathermap.org/api](https://openweathermap.org/api)找到。
- en: To gain access to the API you need to obtain the APPID. The instructions on
    how to do that are available here, [http://openweathermap.org/appid](http://openweathermap.org/appid).
    Basically, all that is needed to obtain it is to create a new account.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问API，你需要获取APPID。如何操作的说明可在[http://openweathermap.org/appid](http://openweathermap.org/appid)找到。基本上，获取它的所有你需要做的就是创建一个新账户。
- en: 'As soon as you have created your account, you will find your API key generated
    under the API keys tab. To access the data for a city, for example, Chicago, it''s
    enough to visit the following URL: `http://api.openweathermap.org/data/2.5/weather?q=chicago&APPID=abcdef1234567890`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了账户，你将在API keys标签下找到生成的API密钥。例如，要获取芝加哥的数据，只需访问以下URL：`http://api.openweathermap.org/data/2.5/weather?q=chicago&APPID=abcdef1234567890`
- en: 'Obviously, the preceding URL is using the wrong APPID. Replace it with your
    own, and you should be good to go. Using the correct APPID in the preceding URL,
    your browser will show a JSON string like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前面的URL使用了错误的APPID。将其替换为你的自己的，你应该就可以正常使用了。使用正确的APPID在前面URL中，你的浏览器将显示一个如下的JSON字符串：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Just what we do with this string will be discussed later in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何处理这个字符串将在本章后面讨论。
- en: What are we going to build?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将要构建什么？
- en: We are going to build a very simple weather app, which will communicate with
    the outside world to fetch JSON-formatted weather data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个非常简单的天气应用，它将与外部世界通信以获取JSON格式的天气数据。
- en: Once we receive that weather data, we will then decode the JSON string into
    values that our app's model will be able to understand and work with, using decoders.
    Let's jump right in.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到天气数据，我们将使用解码器将JSON字符串解码成我们的应用模型能够理解和处理的值。让我们直接进入正题。
- en: Building our weather app
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的天气应用
- en: 'We will start by replacing the code in `Main.elm` with the bare-bones Elm code
    we have already been using in the previous chapters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先用之前章节中已经使用过的裸骨Elm代码替换`Main.elm`中的代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s immediately improve our app by replacing `beginnerProgram` with `Html.Program`,
    since `beginnerProgram,` as explained in the previous chapter, has no means of
    working with side effects:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即通过将`beginnerProgram`替换为`Html.Program`来改进我们的应用，因为，正如前一章所解释的，`beginnerProgram`没有处理副作用的方法：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's walk through the preceding code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码。
- en: We start off by describing the application model as a type alias called `Model`,
    and we set it to an empty record. Following the type alias, we introduce the `init`
    function, which holds the initial state of our app, and the initial command to
    run. With `Cmd.none`, we are basically saying to Elm runtime not to run any commands
    at this point. So, although we are not going to be requesting any commands to
    be run at this moment in our code, we cannot just omit them, we have to be explicit,
    and clearly state that we will not run any commands just yet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将应用程序模型描述为一个名为`Model`的类型别名，并将其设置为空记录。在类型别名之后，我们引入`init`函数，它包含我们应用的初始状态和要运行的初始命令。通过`Cmd.none`，我们基本上是在告诉Elm运行时不应该在这个时候运行任何命令。所以，尽管我们此刻不会请求运行任何命令，我们不能简单地省略它们，我们必须明确地声明我们目前不会运行任何命令。
- en: 'Note the change in the `init` function: the `init` function now takes the following
    two-tuple: `( Model, Cmd.none )`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`init`函数的变化：现在的`init`函数接受以下两个元素的元组：`( Model, Cmd.none )`。
- en: Next, in the `update` function, we are using a union type `Msg`, which can be
    only of `NoOp` value. Basically, whenever we want to assert that our app should
    not do anything with a message it receives, we can use `NoOp` as the value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`update`函数中，我们使用一个联合类型`Msg`，它只能是`NoOp`值。基本上，每当我们要断言我们的应用不应该对收到的消息做任何事情时，我们都可以使用`NoOp`作为值。
- en: 'The update function uses a `case of` expression. We pass two arguments to the
    `update` function: the `msg` and the `model`, and these arguments are used to
    update the `model` and return a command. Here, since we are receiving the `NoOp`
    message, the only thing that happens is: we just return the `model` as is. By
    using `Cmd.none` in the returned two-tuple, we are saying to the Elm runtime that
    it should not run any commands.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更新函数使用`case of`表达式。我们向`update`函数传递两个参数：`msg`和`model`，这些参数用于更新`model`并返回一个命令。在这里，由于我们收到的是`NoOp`消息，唯一发生的事情就是：我们只返回`model`本身。通过在返回的两个元素元组中使用`Cmd.none`，我们告诉Elm运行时不应该运行任何命令。
- en: 'In the `subscriptions` function, all that we are doing is: we are saying to
    the Elm runtime that we do not want to subscribe to any events. Hence, we assign
    it the value of `Sub.none`. Finally, the `main` function gets assigned the `Html.program`
    where all of the above comes together.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`subscriptions`函数中，我们所做的一切就是：我们告诉Elm运行时我们不想订阅任何事件。因此，我们将其赋值为`Sub.none`。最后，`main`函数被赋值为`Html.program`，所有上述内容都汇集在一起。
- en: In the next section, we'll install the HTTP package.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将安装HTTP包。
- en: Installing the HTTP package
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装HTTP包
- en: 'To install the HTTP package, we need to point our console to the location of
    our `weather app` folder. Next, run the following command in the console:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装HTTP包，我们需要将我们的控制台指向`weather app`文件夹的位置。接下来，在控制台中运行以下命令：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is what the console will return:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是控制台将返回的内容：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After confirming with `y`, the console will output the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认`y`后，控制台将输出以下内容：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Approving the plan by typing `y` will produce the following messages in the
    console:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入`y`批准计划将在控制台产生以下消息：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let''s open the `elm-package.json` and verify that it looks as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们打开`elm-package.json`并验证它看起来如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this, we have successfully added the HTTP package to our project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经成功地将HTTP包添加到我们的项目中。
- en: The official documentation for the HTTP package is available at [http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http](http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP包的官方文档可在[http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http](http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http)找到。
- en: Now that we have added all the necessary packages, we can continue building
    our app.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所有必要的包，我们可以继续构建我们的应用。
- en: Adding all the imports
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加所有导入
- en: 'Let''s begin by adding all the imports that we need at the top of `Main.elm`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`Main.elm`的顶部添加所有需要的导入开始：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The linter will throw four identical warnings after you save your code with
    the preceding update. The only difference, in each of the warnings, is the module
    that is referenced. For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用前面的更新保存代码后，代码检查器将抛出四个相同的警告。每个警告中唯一的区别是引用的模块。例如：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is wonderful that the compiler encourages us to improve our code quality
    at the first possible opportunity, but for now, it is safe to ignore those warnings.
    We will soon add the code to our app that will resolve them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器鼓励我们在第一个可能的机会改进我们的代码质量真是太好了，但就目前而言，忽略这些警告是安全的。我们很快就会添加到我们的应用中的代码来解决这些问题。
- en: Conceptualizing the model
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念化模型
- en: 'Since we will be changing up quite a lot of things in our app, at this point
    we can prevent several nagging errors by simply temporarily removing type annotations.
    To do that, simply remove type annotations from the following functions: `init`,
    `update`, `view`, `subscriptions`, and `main`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在我们的应用程序中更改很多东西，在这个时候，我们可以通过简单地临时移除类型注解来防止几个令人烦恼的错误。为此，只需从以下函数中移除类型注解：`init`、`update`、`view`、`subscriptions`和`main`。
- en: 'Let''s look at our updated model now:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的更新后的模型：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The building blocks of our model should be self-explanatory. Let''s then add
    the preceding code to `Main.elm`, and save the file. Our app compiles just fine,
    and everything works as it has. Let''s now update the `init` function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型的基本构建块应该是自解释的。然后我们将前面的代码添加到`Main.elm`中，并保存文件。我们的应用程序编译得很好，一切正常。现在让我们更新`init`函数：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What we did here is, we simply reflected the newly introduced changes to our
    model, in our `init` function. In the next section, we'll set up the `Msg` and
    the `update` functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是，简单地将模型中引入的新变化反映到我们的`init`函数中。在下一节中，我们将设置`Msg`和`update`函数。
- en: Setting up Msg union type
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Msg联合类型
- en: 'Our `Msg` union type is pretty simple:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Msg`联合类型相当简单：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are three possible messages that the `update` function can receive: `GetTemp`,
    `CityInput`, and `NewTemp`. The most peculiar of them is the third one:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`函数可以接收三种可能的消息：`GetTemp`、`CityInput`和`NewTemp`。其中最特别的是第三个：'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is some code there that we haven''t seen before.  The `NewTemp` value
    holds a `Result`.  That result can be an `Http.Error`, which means that something
    caused our HTTP request to fail. There can be a number of reasons: the URL does
    not exist, or the server did not respond, and so on. Another thing that can happen
    is: the request can succeed.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有一些我们之前没见过的代码。`NewTemp`值包含一个`Result`。这个结果可以是一个`Http.Error`，这意味着某些原因导致我们的HTTP请求失败。可能的原因有很多：URL不存在，或者服务器没有响应，等等。还有可能发生的情况是：请求可以成功。
- en: In that case, we'll get back the `String` as the result of making a successful
    HTTP request.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们将得到成功HTTP请求的结果`String`。
- en: Result and Maybe
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Result和Maybe
- en: This is a good time to make a little digression and talk about `Result` and
    `Maybe` in some more detail. To deal with errors, Elm also has `Tasks`, but we
    will not discuss them at this time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好时机，让我们更详细地讨论一下`Result`和`Maybe`。为了处理错误，Elm也有`Tasks`，但我们现在不会讨论它们。
- en: Working with Result
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Result
- en: 'The official documentation for `Result` is available at: [http://package.elm-lang.org/packages/elm-lang/core/latest/Result](http://package.elm-lang.org/packages/elm-lang/core/latest/Result).
    We use `Result` whenever there are things that our code does that can potentially
    fail. Using `Result` allows us to deal better with errors in Elm. The `Result` definition
    says that it''s a union type that has two `type` constructors: `Ok` and `Err`. 
    Take a look at the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`的官方文档可以在以下网址找到：[http://package.elm-lang.org/packages/elm-lang/core/latest/Result](http://package.elm-lang.org/packages/elm-lang/core/latest/Result)。每当我们的代码执行可能失败的操作时，我们都会使用`Result`。使用`Result`可以让我们更好地处理Elm中的错误。`Result`的定义表明它是一个联合类型，有两个类型构造函数：`Ok`和`Err`。看看下面的代码片段：'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If an operation succeeds, the `Result` is `Ok`. Otherwise, the `Result` is `Err`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个操作成功，`Result`就是`Ok`。否则，`Result`就是`Err`。
- en: 'To test drive `Result`, all that we need to do is run an operation that might
    fail. REPL is the perfect place for such a test. Thus, let''s point our browser
    to [http://elmrepl.cuberoot.in/](http://elmrepl.cuberoot.in/) and run the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试驱动`Result`，我们只需要运行一个可能失败的操作。REPL是进行此类测试的完美场所。因此，让我们将浏览器指向[http://elmrepl.cuberoot.in/](http://elmrepl.cuberoot.in/)并运行以下代码：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the preceding in the REPL, will return the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中运行前面的代码，将返回以下内容：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Wonderful, we got back an `Ok` result from an operation that could have failed.
    Let''s do it again, for good measure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们从可能失败的操作中得到了一个`Ok`结果。为了保险起见，我们再试一次：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You might think that the preceding would fail, but it is actually completely
    valid:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为前面的代码会失败，但实际上它是完全有效的：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Great, we still got back an `Ok`.  This time, let''s use a string of letters,
    to make sure that the REPL can''t handle it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们仍然得到了一个`Ok`。这次，让我们使用一串字母，以确保REPL无法处理它：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And indeed, the REPL doesn''t know how to deal with this input. However, instead
    of throwing an ugly exception, we get an elegant one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，REPL不知道如何处理这种输入。然而，而不是抛出一个丑陋的异常，我们得到了一个优雅的异常：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To drive the point home, in the preceding example, we ran an expression that
    could potentially fail, that is, we ran the  `Date.fromString` function. The `Date.fromString`
    function takes a parameter of type `String`, and returns a `Date`. In the preceding
    code snippet, we gave it the String with the value of `abc`, and it returned an
    `Err` as the `Result`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使观点更加明确，在前面例子中，我们运行了一个可能失败的表达式，即我们运行了 `Date.fromString` 函数。`Date.fromString`
    函数接受一个类型为 `String` 的参数，并返回一个 `Date`。在前面代码片段中，我们给它了一个值为 `abc` 的字符串，它返回了一个 `Err`
    作为 `Result`。
- en: '`Result` has its own module, and that is why the type definition reads `Result.Result`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 有它自己的模块，这就是为什么类型定义读作 `Result.Result`。'
- en: Next, we'll look at working with `Maybe`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用 `Maybe`。
- en: Working with Maybe
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Maybe 一起工作
- en: 'Also a union type, `Maybe` is a way to deal with nothingness in Elm, or, put
    differently, with values that are optional, that is, which might, or might not
    exist. The official documentation, available at [http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe](http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe),
    gives the definition for the `Maybe` union type as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 也是一个联合类型，`Maybe` 是 Elm 中处理空值的一种方式，或者说，处理可选值，即可能存在，也可能不存在。官方文档可在 [http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe](http://package.elm-lang.org/packages/elm-lang/core/latest/Maybe)
    找到，它给出了 `Maybe` 联合类型的定义如下：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we discussed earlier in the book, using the letter  `a` in Elm is a convention,
    and it's a way to describe that the value used at that position can be anything.
    So the `a` in the preceding definition can be a `String`, an `Int`, or any other
    value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在书中前面讨论的，在 Elm 中使用字母 `a` 是一种约定，它表示在该位置使用的值可以是任何东西。因此，前面定义中的 `a` 可以是 `String`，`Int`
    或任何其他值。
- en: 'So, in Elm, `Maybe` can be only one of two things— `Just` anything, or `Nothing`.
    More specifically, `Maybe` can be either one of these:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 Elm 中，`Maybe` 只能是两种情况之一——`Just` 任何东西，或者 `Nothing`。更具体地说，`Maybe` 可以是以下之一：
- en: '`Just` a `String`, or `Just` an `Int`, or `Just` a `Float`..., or'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Just` 一个 `String`，或者 `Just` 一个 `Int`，或者 `Just` 一个 `Float`...，'
- en: '`Nothing`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nothing`'
- en: 'Let''s now turn to Elm REPL at [http://elmrepl.cuberoot.in/](http://elmrepl.cuberoot.in/)
    and see the `Maybe` type in practice:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向 Elm REPL [http://elmrepl.cuberoot.in/](http://elmrepl.cuberoot.in/)
    并看看 `Maybe` 类型在实际中的应用：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The REPL will return the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 将返回以下内容：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we can see, `Just 1` is a `Maybe number`. Let''s do another one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Just 1` 是一个 `Maybe` 数字。让我们再做一个例子：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running the preceding line will result in this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上一行将得到以下结果：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, let''s see a `Nothing` in action:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看 `Nothing` 的实际应用：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'REPL replies with the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 回复如下：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since `Nothing` has no value, we are back to `Maybe a`. Elm guarantees require
    us to have an `a` here, even though `Nothing` is `Nothing`, and since it represents
    the absence of value it does not need a type for its value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Nothing` 没有值，我们回到了 `Maybe a`。Elm 保证要求我们在这里有一个 `a`，即使 `Nothing` 是 `Nothing`，因为它代表值的缺失，它不需要为其值指定类型。
- en: 'To destructure a `Maybe`, we can use the `case-of` expression. Let''s see an
    example of that using Ellie:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要解构 `Maybe`，我们可以使用 `case-of` 表达式。让我们用一个例子来看看 Ellie：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, we are using a slightly altered version of the person
    example available at the official documentation for `Maybe`. The difference in
    the preceding code is that instead of an `Int`, we are using a `String` for the
    `age` entry in our record. That way, we can avoid making our code any more complex
    than it needs to be, and we still return a `String` from all the branches in our
    `case-of` expression.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用的是 `Maybe` 官方文档中提供的稍作修改的人的例子。前面代码中的区别在于，我们不是使用 `Int`，而是使用 `String`
    作为记录中的 `age` 条目。这样，我们可以避免使我们的代码比必需的更复杂，并且我们仍然从 `case-of` 表达式的所有分支中返回 `String`。
- en: 'The app will print out `42` upon compilation. Now, let''s change the app so
    that we are attempting to print Sue''s age. The only difference to be made is
    listed as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在编译时将打印出 `42`。现在，让我们修改应用程序，以便尝试打印 Sue 的年龄。需要做的唯一区别如下：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This time, upon compilation, the app will pattern-match the `Nothing` branch
    of the `case-of` expression in `main`, and that will result in the `"No age for
    this person"` message printed on the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在编译时，应用程序将匹配 `main` 中的 `case-of` 表达式的 `Nothing` 分支，这将导致屏幕上打印出 `"No age for
    this person"` 消息。
- en: Result and Maybe with Defaults
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果和带有默认值的 Maybe
- en: '`Result` and `Maybe` are quite similar. If our operation succeeds, we get an
    `Ok a` with `Result`. When dealing with `Maybe`, we get `Just a` if a value is
    present.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`和`Maybe`非常相似。如果我们的操作成功，我们通过`Result`得到`Ok a`。当处理`Maybe`时，如果存在值，我们得到`Just
    a`。'
- en: 'In case there was an error, for `Result` we get `Err error`. In case of no
    value in `Maybe`, we get `Nothing`. We have already looked at using `Result.withDefault`
    earlier in the book (in [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml),
    *Preparing a Unit Conversion Website in Elm*). Let''s do a quick recap by running
    the following in Elm REPL:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，对于`Result`我们得到`Err error`。在`Maybe`中没有值的情况下，我们得到`Nothing`。我们已经在本书前面的章节中（在第4章[5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml]，*在Elm中准备一个单位转换网站*）查看过使用`Result.withDefault`。让我们通过在Elm
    REPL中运行以下代码来快速回顾：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The REPL responds with the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: REPL响应如下：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now let''s try using `Strings`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试使用`Strings`：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The REPL returns the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: REPL返回以下内容：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similar to `Result`, we can also use `withDefault` on `Maybe`. Run the following
    in the REPL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Result`类似，我们也可以在`Maybe`上使用`withDefault`。在REPL中运行以下代码：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The REPL returns the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: REPL返回以下内容：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s do a couple more. First, let''s give it a default `String`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来几个。首先，给它一个默认的`String`：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The REPL returns the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: REPL返回以下内容：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How about a default `Record`?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个默认的`Record`呢？
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running the preceding code in the REPL will produce the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中运行前面的代码将产生以下内容：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the next section, we will work on our `update` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将处理我们的`update`函数。
- en: Updating the update function
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新`update`函数
- en: 'Our `update` function will be a lot more complex. First, we need to cover all
    the preceding messages in our `update` function. We''ll do that by adding a `case-of`
    expression:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`update`函数将更加复杂。首先，我们需要在我们的`update`函数中涵盖所有前面的消息。我们将通过添加一个`case-of`表达式来完成：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code snippet, we can see four possible cases for our `update`
    function. In case our `update` function receives the `GetTemp` message, it will
    return the two-tuple that has the `model` and the `getTemperature` value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到`update`函数的四种可能情况。如果我们的`update`函数收到`GetTemp`消息，它将返回一个包含`model`和`getTemperature`值的二元组。
- en: If the `update` function receives the `NewTemp (Ok json)` message, that is,
    if we successfully receive a JSON string from a remote server, then we use a `let-in`
    expression to return the same `model`, updated with the `newTemperatureInfo`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`update`函数收到`NewTemp (Ok json)`消息，即如果我们从远程服务器成功接收JSON字符串，那么我们使用`let-in`表达式返回相同的`model`，并更新`newTemperatureInfo`。
- en: The third pattern to match is the `NewTemp (Err _)`. This pattern will be matched
    in case we receive an error from the remote server, in which case we will just
    return the existing model - that is, `(model, Cmd.none)`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个要匹配的模式是`NewTemp (Err _)`。这个模式将在我们收到远程服务器的错误时匹配，在这种情况下，我们将只返回现有的模型，即`(model,
    Cmd.none)`。
- en: The last possible message that we can pattern-match for in the `update` function,
    is the `CityInput` message. If we get a `CityInput` message, we will take the
    `city` String that gets passed to it, and return the existing model, plus the
    new `city` String.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`函数中我们可以进行模式匹配的最后一个可能的消息是`CityInput`消息。如果我们收到一个`CityInput`消息，我们将取传递给它的`city`字符串，并返回现有的模型，加上新的`city`字符串。
- en: 'However, if we ran our app now, the compiler would throw two errors:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们现在运行我们的应用程序，编译器将抛出两个错误：
- en: Cannot find variable `getTemperature`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找不到变量`getTemperature`
- en: Cannot find variable `decodeTemperatureInfo`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找不到变量`decodeTemperatureInfo`
- en: Obviously, abstracting away complexity into separate variables is great to make
    it easier to reason about our app, but now we need to get into the actual implementation
    of `getTemperature` and `decodeTemperatureInfo`, in order to make our `update`
    function work. But before we can do that, we will need to look at decoders and
    encoders in greater detail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，将复杂性抽象到单独的变量中是很好的，可以使我们更容易地推理我们的应用程序，但现在我们需要实际实现`getTemperature`和`decodeTemperatureInfo`，以便使我们的`update`函数工作。但在我们能够这样做之前，我们需要更详细地查看解码器和编码器。
- en: Decoders and encoders
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码器和编码器
- en: To parse data from JSON, Elm uses decoders. To do the opposite, Elm uses encoders.
    Using decoders and encoders, we can translate data from dynamically typed JSON,
    to statically typed Elm data structures, and vice versa.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从JSON解析数据，Elm使用解码器。为了做相反的操作，Elm使用编码器。使用解码器和编码器，我们可以将动态类型JSON数据转换为静态类型Elm数据结构，反之亦然。
- en: 'To begin, let''s look at the `Json.Decode` package, available as part of the
    Elm language core. The official documentation for `Json.Decode` is available at:
    [http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode).
    The official documentation defines a decoder as:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 Elm 语言核心部分可用的 `Json.Decode` 包。`Json.Decode` 的官方文档可在：[http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode)
    找到。官方文档定义解码器如下：
- en: A value that knows how to decode JSON values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个知道如何解码 JSON 值的值。
- en: Decoding primitive values
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码原始值
- en: 'Let''s look at a few examples of decoding primitive values, with the help of
    Elm REPL. To begin, let''s decode a simple `Int`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 Elm REPL 的帮助来查看解码原始值的一些示例。首先，让我们解码一个简单的 `Int`：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The REPL returns the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回以下内容：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, we get back a `Result`, which is a sign of an action that can potentially
    fail. Let''s see how it fails, by providing a `Bool` to the preceding expression, instead
    of an `Int`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了一个 `Result`，这是表示一个可能失败的操作的标志。让我们通过向前面的表达式提供一个 `Bool` 而不是 `Int` 来看看它如何失败：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Running the preceding code results in the REPL returning the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会导致 REPL 返回以下内容：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, let''s decode a JSON `float` into an Elm `Float`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解码一个 JSON `float` 到 Elm 的 `Float`：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The REPL returns the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回以下内容：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How about decoding a JSON `string` into an Elm `String`?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么将 JSON `string` 解码为 Elm 的 `String` 呢？
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This time, the REPL responds with the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，REPL 响应如下：
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Why is that error occuring? Because we need to provide escaped quotes as well,
    so as to make it work:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会出现这个错误？因为我们还需要提供转义引号，以便使其工作：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now the REPL is not complaining:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在REPL不再抱怨了：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, let''s look at decoding a JSON boolean into an Elm `Bool`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何将 JSON 布尔值解码为 Elm 的 `Bool`：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The REPL returns the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回以下内容：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s examine each of the decoders'' signatures:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查每个解码器的签名：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we can see in the preceding code snippet, `int` is a decoder for `Int`, `float`
    is a decoder for `Float`, `string` is a decoder for `String`, and `bool` is a
    decoder for `Bool`. Now that we understand how primitives are decoded from JSON
    into Elm, let's look at decoding a more complex JSON string, namely, the one that
    we got back from the API at the beginning of this chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码片段所示，`int` 是 `Int` 的解码器，`float` 是 `Float` 的解码器，`string` 是 `String` 的解码器，而
    `bool` 是 `Bool` 的解码器。现在我们了解了如何从 JSON 解码原始值到 Elm，让我们看看如何解码一个更复杂的 JSON 字符串，即本章开头从
    API 得到的那个。
- en: Decoding a JSON string returned from the API
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码 API 返回的 JSON 字符串
- en: 'To begin, let''s look at the JSON string that we got back from the API:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们从 API 得到的 JSON 字符串：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Obviously, we have formatted the JSON string so as to make it easier to read.
    The first thing to note is; we do not have to decode all of the preceding code.
    We can choose to decode only as much data as we need. So let's assume that the
    only piece of data that we are interested in is the second-to-last key-value pair,
    namely: `''name'':''Chicago''`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们已经格式化 JSON 字符串，使其更容易阅读。首先要注意的是；我们不必解码所有前面的代码。我们可以选择只解码我们需要的部分数据。所以，让我们假设我们唯一感兴趣的数据是倒数第二个键值对，即：`''name'':''Chicago''`。
- en: 'How do we decode it out of the preceding chunk of JSON? We''ll make a small
    Ellie app to see how this can be done:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从前面那块 JSON 中解码出来？我们将创建一个小 Ellie 应用来查看如何实现这一点：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding little app successfully decodes the JSON string provided. As
    we can see, we are decoding only the `name` key from our JSON object, whose value,
    based on the JSON object provided previously, is `Chicago`. The result of compiling
    the app in the Ellie editor is displayed on the screen:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的这个小应用成功解码了提供的 JSON 字符串。正如我们所见，我们只解码了 JSON 对象中的 `name` 键，其值根据前面提供的 JSON 对象是
    `Chicago`。在 Ellie 编辑器中编译应用的结果显示在屏幕上：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s see how we can improve on the preceding app. This time, we want to return
    not only the `name` key from our JSON object, but also the `id` key:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何改进前面的应用。这次，我们不仅想从我们的 JSON 对象中返回 `name` 键，还想返回 `id` 键：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If we compiled the app now, we''d get a slightly different result from what
    we had last time:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在编译应用，我们会得到一个与上次略有不同的结果：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'There are slight changes in the preceding app, which make it possible to extract
    two values, rather than just one, which we had in the previous version of our
    little JSON-decoding app. Let''s look at the changes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的应用程序中，有一些细微的变化，这使得我们可以提取两个值，而不是像我们之前的小型JSON解码应用程序版本中那样只提取一个值。让我们看看这些变化：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the `WeatherData` type alias, we added an `id` of type `Int` to our `Record`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WeatherData`类型别名中，我们在`Record`中添加了一个`id`类型为`Int`：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the decoders, we are using the `map2` function instead of the `map` function,
    and we are adding another JSON field, with the key of `id`, and the expected value
    of the JSON integer. Analog to what we have seen, in case we wanted to map over
    another value from our JSON object, we would need to use the `map3` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在解码器中，我们使用`map2`函数而不是`map`函数，并添加另一个带有`id`键的JSON字段，以及预期的JSON整数值。类似于我们所看到的，如果我们想要从我们的JSON对象中映射另一个值，我们需要使用`map3`函数。
- en: Decoding nested objects
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码嵌套对象
- en: 'Let''s say that we want to get the country information from the returned JSON.
    The change that we need to make to our decoder is simple: instead of `field`,
    we will use `at`. While `field` uses a string, `at` uses a list of strings, which
    allows us to go into the structure of a nested object. Let''s update our Ellie
    app''s `weatherDataDecoder` so that it looks as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从返回的JSON中获取国家信息。我们需要对我们的解码器进行简单的更改：而不是使用`field`，我们将使用`at`。虽然`field`使用一个字符串，但`at`使用一个字符串列表，这允许我们进入嵌套对象的内部结构。让我们更新我们的Ellie应用程序的`weatherDataDecoder`，使其看起来如下：
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s also update the `WeatherData` type alias:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更新`WeatherData`类型别名：
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that in the preceding code snippet, we are keeping our flat `Record` structure,
    and it does not reflect the JSON object that we get the data from. That is perfectly
    fine. Upon compilation, the app will print the following result to the screen:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的代码片段中，我们保持了我们扁平的`Record`结构，并且它并不反映我们从其中获取数据的JSON对象。这是完全可以接受的。在编译后，应用程序将以下结果打印到屏幕上：
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that we understand how decoders work, and after a bit of practice with decoders,
    it should be a lot easier to understand the code that we will see in the next
    section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了解码器的工作原理，并在解码器上练习了一段时间后，理解下一节中我们将看到的代码应该会容易得多。
- en: Adding getTemperature and decodeTemperatureInfo
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加getTemperature和decodeTemperatureInfo
- en: 'Our `getTemperature` is a simple `let-in` expression, which will send a new
    request using `Http.send` and `Http.getString`, so as to obtain the weather data
    from a custom URL. The string of the custom URL to fetch the data from, depends
    on the `city` variable, that is, the value of the user input we get from the text
    input field of our app:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`getTemperature`是一个简单的`let-in`表达式，它将使用`Http.send`和`Http.getString`发送一个新的请求，以便从自定义URL获取天气数据。从自定义URL获取数据的字符串，取决于`city`变量，即我们从应用程序文本输入字段获取的用户输入值：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `decodeTemperatureInfo` is also a `let-in` expression, which, although
    possibly a bit scary-looking at first glance, is actually just a number of repetitions
    in trying to decode JSON data:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodeTemperatureInfo`也是一个`let-in`表达式，虽然乍一看可能有点令人畏惧，但实际上它只是尝试解码JSON数据的一系列重复操作：'
- en: '[PRE65]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Basically, what''s happening in the preceding code is—we are decoding the JSON
    string we received from the remote server, step by step. At this point, saving
    and running our app, we would see exactly the same window as before: Everything
    will go here, this time using Html.program.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在先前的代码中发生的事情是——我们正在逐步解码从远程服务器接收到的JSON字符串。在这个阶段，保存并运行我们的应用程序，我们会看到与前完全相同的窗口：所有内容都将在这里，这次使用Html.program。
- en: That is a good sign. It means our app compiles successfully. It also means that
    there is more work to be done in the `view` and `main` functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好兆头。这意味着我们的应用程序编译成功。这也意味着在`view`和`main`函数中还有更多的工作要做。
- en: Updating the view
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新视图
- en: 'Our `view` function is there to give us the visual representation of our model.
    For our app to work, the `view` function needs to have an input field, the submit
    button, and several values to be populated upon contacting the remote server and
    decoding the JSON string:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`view`函数是用来给我们模型的可视表示的。为了使我们的应用程序工作，`view`函数需要一个输入字段，提交按钮，以及一些在联系远程服务器并解码JSON字符串时需要填充的值：
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Let's look at how the preceding code works. We start off with the wrapping `div`.
    Next, we have the `input` function, which will have the placeholder word `City`
    in the text input field. We also have a message that this `input` function will
    emit, and the message is of `CityInput` type.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的代码是如何工作的。我们首先使用包裹`div`。接下来，我们有`input`函数，它将在文本输入字段中显示占位符单词`City`。我们还有一个消息，即这个`input`函数将发出一个`CityInput`类型的消息。
- en: 'Next, we have the `br` function, and then the `button` function, which will
    emit the `GetTemp` message `onClick`. The next significant function is the `div`
    function, which will have the string of `''''Name: ''''` plus the value of `model.temperatureInfo.name`.
    Similarly, we follow it up with other `div` functions that concatenate strings
    together based on the values contained inside the current `model`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们有`br`函数，然后是`button`函数，它将在`onClick`时发出`GetTemp`消息。下一个重要的函数是`div`函数，它将包含字符串`''''Name:
    ''''`和`model.temperatureInfo.name`的值。同样，我们接着使用其他`div`函数，这些函数根据当前`model`中包含的值拼接字符串。'
- en: Save everything and run your app. The result will be a fully working weather
    app that fetches a JSON string from a remote server and properly displays the
    result. To make the app fetch the data, it's enough to type a major city name
    into the input field, and click the button.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有内容并运行你的应用。结果将是一个完全工作的天气应用，它从远程服务器获取JSON字符串并正确显示结果。要使应用获取数据，只需在输入字段中输入一个主要城市名称，然后点击按钮。
- en: 'Before wrapping up this section, let''s look at the complete weather app code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，让我们看看完整的天气应用代码：
- en: '[PRE67]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered a lot of new concepts, and reinforced some
    that we have learned about in the previous chapters. We have looked at using `Result`
    and `Maybe` to deal with operations that might fail and to deal with possibly
    missing data. We looked at using decoders and mapping over them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了很多新概念，并加强了一些我们在前几章中学到的概念。我们探讨了使用`Result`和`Maybe`来处理可能失败的操作以及处理可能缺失的数据。我们探讨了使用解码器和映射。
- en: We also looked at using the `Http` package to get remote JSON data. Now that
    we have set up the basics of our weather app, we will discuss ways of improving
    it in the next chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了使用`Http`包获取远程JSON数据。现在我们已经设置了天气应用的基础，我们将在下一章讨论改进它的方法。
