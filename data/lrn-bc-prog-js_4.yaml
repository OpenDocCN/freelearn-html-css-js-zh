- en: Creating a Decentralized Blockchain Network
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分散的区块链网络
- en: 'In this chapter, let''s focus on building a decentralized blockchain network.
    The way that our blockchain works right now is that we have a single blockchain,
    and the only way to access it is through the API: our single server. This server
    is very centralized, which is not beneficial because the API is in total control
    of the blockchain and the data that gets added to it.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，让我们专注于构建分散的区块链网络。我们的区块链目前的工作方式是我们有一个单一的区块链，而访问它的唯一方式是通过API：我们的单一服务器。这个服务器非常集中，这并不好，因为API完全控制着区块链和添加到其中的数据。
- en: In the real world, all blockchain technology is hosted across a decentralized
    network. In this chapter, that's what we're going to focus on building. We'll
    build a decentralized blockchain network by creating various instances of the
    API. Each of these instances of the API are going to be a network node in our
    blockchain network. All of these nodes will work together to host our blockchain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，所有区块链技术都托管在分散网络中。在本章中，这就是我们要专注于构建的内容。我们将通过创建各种API实例来构建一个分散的区块链网络。这些API实例中的每一个都将成为我们区块链网络中的一个网络节点。所有这些节点将共同工作来托管我们的区块链。
- en: In this way, it's not just a single network node that has total control over
    our blockchain. Instead, our blockchain is hosted across the entire decentralized
    network. This way, if there's one bad player in our network, or somebody who is
    trying to cheat the system, we can refer to the other network nodes to see what
    the real data should be inside of our blockchain and what our blockchain should
    actually look like.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，不仅仅是一个单一的网络节点完全控制着我们的区块链。相反，我们的区块链托管在整个分散网络中。这样，如果我们的网络中有一个坏的参与者，或者有人试图欺骗系统，我们可以参考其他网络节点来查看我们的区块链内部应该是什么样的真实数据，以及我们的区块链实际上应该是什么样的。
- en: Having our blockchain hosted across a decentralized network is very powerful
    because it vastly increases the security of our blockchain, and therefore we don't
    have to just trust one single entity with all of our data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的区块链托管在分散网络中非常强大，因为它极大地增加了我们的区块链的安全性，因此我们不必只信任一个单一实体来处理我们所有的数据。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning how to create and test multiple nodes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建和测试多个节点
- en: Adding the `currentNodeUrl` to our network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`currentNodeUrl`添加到我们的网络
- en: Adding new endpoints for the decentralized network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为分散网络添加新的端点
- en: Building the `/register-and-broadcast-node` endpoint
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`/register-and-broadcast-node`端点
- en: Building and testing the `/register-nod`e endpoint
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和测试`/register-node`端点
- en: Adding and testing the `/register-nodes-bulk` endpoint
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和测试`/register-nodes-bulk`端点
- en: Testing all of the network endpoints
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试所有网络端点
- en: Let's get started with creating our decentralized network.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的分散网络。
- en: Creating multiple nodes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多个节点
- en: 'Let''s begin by building the decentralized network:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建分散网络开始：
- en: The first thing that we'll have to do to create our decentralized blockchain
    network is make some modifications to our `api.js` file.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建我们的分散区块链网络，我们首先需要对我们的`api.js`文件进行一些修改。
- en: In our decentralized network, we're going to have multiple instances of our
    API, and each one of them will act as a network node. Since we'll be dealing with
    multiple network nodes, it will be better to rename our `api.js` file to `networkNode.js`
    for easy reference.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的分散网络中，我们将有多个API实例，每个实例都将充当网络节点。由于我们将处理多个网络节点，最好将我们的`api.js`文件重命名为`networkNode.js`以便易于引用。
- en: 'To set up the decentralized network, we''ll have to run the `networkNode.js`
    file multiple times. Each time we run the file, we want it to act as a different
    network node. Let''s do this by running the file on different ports every time
    we run it. To have a different ports value every time, we''ll have to make port a
    variable. To do this, add the following line at the start of the code in our `dev/networkNode.js`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置分散网络，我们将不得不多次运行`networkNode.js`文件。每次运行文件时，我们希望它作为不同的网络节点。我们可以通过在每次运行时在不同的端口上运行文件来实现这一点。为了每次都有不同的端口值，我们将把端口作为一个变量。为此，在我们的`dev/networkNode.js`的代码开头添加以下行：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, go to the `package.json` file and make modifications to the `start` command.
    What we''ll do here is go to the end of our command and pass a variable for the
    port number on which we want a network node to run. In our example, we want to
    run our network node to run on port number `3001`. Consequently, pass `3001` as
    a variable at the end of the start command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`package.json`文件并对`start`命令进行修改。我们要做的是转到命令的末尾，并传递我们想要网络节点运行的端口号的变量。在我们的示例中，我们希望我们的网络节点在端口号`3001`上运行。因此，在启动命令的末尾传递`3001`作为变量：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To get access to this variable, we passed the `process.argv` variable in our
    `networkNode.js` file. So, what is the `process.argv` variable? This variable
    simply refers to the `start` command that we run to start our server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问这个变量，我们在我们的`networkNode.js`文件中传递了`process.argv`变量。那么，`process.argv`变量是什么？这个变量简单地指的是我们运行启动服务器的`start`命令。
- en: You can think of the preceding `start` command as an array of elements. The
    first and the second elements of the command are comprised of `"nodemon --watch
    dev -e js dev/api.js`, and the third element of the command is the `3001` variable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将前面的“start”命令视为元素数组。命令的第一个和第二个元素由“nodemon --watch dev -e js dev/api.js”组成，命令的第三个元素是“3001”变量。
- en: If you want to add more variables to the command, you can simply make a space
    and then add more variables to it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想向命令添加更多变量，只需在其后添加更多变量。
- en: Consequently, to access the port variable in the `start` command, we passed
    the variable as `process.argv [2]` because this array starts with a `0` index and
    our port variable is the third element in the start command.  To simplify this,
    we can access the `3001` variable by stating `process.argv` at position 2\. As
    a result, we gain access to our `port` variable inside of our `dev/networkNode.js`
    file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了在`start`命令中访问端口变量，我们将变量作为`process.argv [2]`传递，因为这个数组从`0`索引开始，我们的端口变量是开始命令中的第三个元素。为了简化这个过程，我们可以通过在位置2处声明`process.argv`来访问`3001`变量。因此，我们可以在`dev/networkNode.js`文件中访问我们的`port`变量。
- en: 'Next, we want to use the `port` variable. Therefore, in the `dev/networkNode.js` 
    file, go to the bottom, where we have mentioned the following code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要使用`port`变量。因此，在`dev/networkNode.js`文件中，转到底部，我们已经提到了以下代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you have found this, make the following highlighted modifications to it:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到这个，对其进行如下突出显示的修改：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding block of code, we replaced the hardcoded `3000` port number
    with our `port` variable. We also changed `Listening on port 3000...` to `Listening
    on port ${port}...` by using string interpolation and passing the port variable. 
    Now, when we run the `networkNode.js` file, it should be listening on port `3001`
    instead of port `3000`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们用我们的`port`变量替换了硬编码的`3000`端口号。我们还通过使用字符串插值和传递端口变量，将`Listening on port
    3000...`改为`Listening on port ${port}...`。现在，当我们运行`networkNode.js`文件时，它应该在端口`3001`上监听，而不是在端口`3000`上。
- en: One tiny thing that we need to change before we run the `networkNode.js` file
    is that in the `package.json` file in the `start` command, we'll have to  change
    the name of the `api.js` file to `networkNode.js`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行`networkNode.js`文件之前，我们需要更改的一个小细节是在`package.json`文件的`start`命令中，我们需要将`api.js`文件的名称更改为`networkNode.js`。
- en: Now we're all set to run the `networkNode.js` file by passing in the variable
    of whatever port we want as a variable.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好通过传入我们想要的任何端口变量来运行`networkNode.js`文件。
- en: 'Let''s run the `networkNode.js` file. In the terminal window, type `npm start`.
    By typing this command, the server should start listening to port `3001`, as we
    can observe in the following screenshot:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行`networkNode.js`文件。在终端窗口中，输入`npm start`。通过输入这个命令，服务器应该开始监听端口`3001`，正如我们在下面的截图中所观察到的：
- en: '![](img/05dc694f-141a-40f3-97a1-13d3447bd607.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05dc694f-141a-40f3-97a1-13d3447bd607.png)'
- en: 'From the preceding screenshot, we can observe that the server is listening
    to port `3001`. We can further verify this by typing `localhost:3001/blockchain`
    in the browser. You should see an output similar to what''s shown in the following
    screenshot:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以观察到服务器正在监听端口`3001`。我们可以通过在浏览器中输入`localhost:3001/blockchain`来进一步验证这一点。您应该看到类似于下面截图所示的输出：
- en: '![](img/a719f771-fc07-439e-8331-8c20cf0f3043.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a719f771-fc07-439e-8331-8c20cf0f3043.png)'
- en: 'From the preceding screenshot, we can see that our blockchain is now hosted
    on port `3001` instead of on port `3000`. If we went to port `3000`, there would
    be nothing there, as shown in the following screenshot:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以看到我们的区块链现在托管在端口`3001`上，而不是在端口`3000`上。如果我们去端口`3000`，就会像下面的截图所示的那样，什么也没有。
- en: '![](img/501f3d91-83ef-475e-821b-ba73449070e9.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/501f3d91-83ef-475e-821b-ba73449070e9.png)'
- en: Running multiple instances of networkNode.js
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个`networkNode.js`实例
- en: 'The next thing that we will want to do is run multiple instances of `networkNode.js`.
    To do that, we are going to add a few more commands to the `package.json` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的事情是运行多个`networkNode.js`实例。为此，我们将在`package.json`文件中添加一些命令：
- en: To begin with, in the `package.json` file, we must change the `"start"` command
    to `"node_1"`. Now, when we run this command, it's going to start our first node,
    which is on port `3001`. Let's give this a try.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`package.json`文件中，我们必须将`"start"`命令更改为`"node_1"`。现在，当我们运行此命令时，它将启动我们的第一个节点，即端口`3001`上的节点。让我们试一试。
- en: 'Save the file, go to your terminal, and cancel the previous process by typing `^C%`.
    After doing this, instead of typing `npm start`,  type `npm run node_1`. With
    the help of this command, run our `node_1` on port `3001`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，转到终端，并通过输入`^C%`取消之前的进程。在这样做之后，而不是输入`npm start`，输入`npm run node_1`。通过这个命令，运行我们的`node_1`在端口`3001`上：
- en: '![](img/95ea347b-d753-4eb7-8441-cc8cd4bf1b5e.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95ea347b-d753-4eb7-8441-cc8cd4bf1b5e.png)'
- en: All we really did in this process is change the `npm start` command to `npm
    run node_1`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们真正做的是将`npm start`命令更改为`npm run node_1`。
- en: 'For our decentralized network, we want to run a couple more of these nodes
    at the same time. Let''s go back to our `package.json` file and add more commands
    that are similar to `"node_1"`. To do this, duplicate the `"node_1": "nodemon
    --watch dev -e js dev/networkNode.js 3001",` command four more times and then
    make modifications to these commands, as shown in the following screenshot:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对于我们的分散网络，我们希望同时运行几个这样的节点。让我们回到我们的`package.json`文件，并添加类似于`"node_1"`的更多命令。为此，将`"node_1":
    "nodemon --watch dev -e js dev/networkNode.js 3001",`命令复制四次，然后对这些命令进行修改，如下面的截图所示：'
- en: '![](img/bb271a9f-6803-490c-96f2-15ccdc17cbbb.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb271a9f-6803-490c-96f2-15ccdc17cbbb.png)'
- en: 'Now, save this modification and let''s head back over to our terminal and start
    up the other network nodes. From the previous run, we have the first node, `node_1`,
    running on port `3001`. For this run, we''ll want to run the second node, `node_2`,
    on port `3002`. Therefore, simply type `npm  run node_2` and then press *Enter*.
    We''ll get to observe the following output on the screen:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存这个修改，让我们回到终端并启动其他网络节点。从上一次运行中，我们有第一个节点`node_1`在端口`3001`上运行。对于这次运行，我们将希望在端口`3002`上运行第二个节点`node_2`。因此，只需输入`npm
    run node_2`然后按*Enter*。我们将在屏幕上观察到以下输出：
- en: '![](img/1401807f-a32a-4a46-9add-3e9884fd2169.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1401807f-a32a-4a46-9add-3e9884fd2169.png)'
- en: We now have one network node running on port `3001`, and the other network node
    running on port `3002`. Follow a similar process to run the remaining network
    nodes on the remaining ports.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个运行在端口`3001`上的网络节点，另一个运行在端口`3002`上的网络节点。按照类似的过程在剩下的端口上运行剩下的网络节点。
- en: For better visualization and easy understanding, it is recommended that you
    try to run each node on different tabs of the terminal window.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地可视化和易于理解，建议您尝试在终端窗口的不同标签上运行每个节点。
- en: By following this process, what we are actually doing is creating five different
    instances of our `networkNode.js` file. So, essentially, we have five different
    network nodes running.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这个过程，我们实际上正在创建我们的`networkNode.js`文件的五个不同实例。因此，基本上，我们有五个不同的网络节点在运行。
- en: In the browser, we can check each one of these network nodes by changing the
    port number in `localhost:3001/blockchain`. By doing this, we're going to get
    back a different blockchain running on the different ports.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们可以通过更改`localhost:3001/blockchain`中的端口号来检查这些网络节点中的每一个。通过这样做，我们将在不同的端口上得到不同的区块链。
- en: Testing the multiple nodes
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试多个节点
- en: 'We will continue exploring the five separate network nodes that we created
    in the previous section. By now, you might have all five of the network nodes
    running. If not, going to the previous section and understanding how to get each
    of these nodes running is recommended. What we''ve currently got, which is five
    separate network nodes running, is not really a network. All we have is five separate
    nodes or five separate instances of our API running, but they are not connected
    in any way. To verify that these network nodes are not connected, we can carry
    out a couple of tests:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续探索上一节中创建的五个独立网络节点。到目前为止，您可能已经运行了所有五个网络节点。如果没有，请回到上一节，了解如何使这些节点中的每一个运行是值得推荐的。我们目前拥有的，即五个独立运行的网络节点，实际上并不是一个网络。我们只有五个独立的节点或我们的API的五个独立实例，但它们没有以任何方式连接。为了验证这些网络节点没有连接，我们可以进行一些测试：
- en: So, let's head over to Postman and try make a couple of different transactions
    by hitting the `/transaction` endpoint on the different network nodes that we
    have running.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，让我们转到Postman，并尝试通过在我们正在运行的不同网络节点上命中`/transaction`端点来进行一些不同的交易。
- en: 'The first transaction that we want to make is going to be to our network node,
    which is hosted on port `3001`. So, let''s go into the body and type in some random
    transaction data, as shown in the following screenshot:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要进行的第一笔交易将是到我们托管在端口`3001`上的网络节点。因此，让我们进入正文，并输入一些随机交易数据，如下面的屏幕截图所示：
- en: '![](img/65cccdf0-f3aa-4357-974d-3a132f5d3b74.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/65cccdf0-f3aa-4357-974d-3a132f5d3b74.png)
- en: 'Our transaction data has an amount of 30,000 bitcoins, and we''re sending this
    to network node that''s hosted on port `3001`. Click on the Send button, and if
    the transaction is successful you''ll get the following response, as highlighted
    in the following screenshot:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的交易数据有30,000比特币，我们将其发送到端口`3001`上托管的网络节点。单击发送按钮，如果交易成功，您将获得以下响应，如下面的屏幕截图所示：
- en: '![](img/1e7ac10a-deee-434a-b4ad-ffcb10faf3bd.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/1e7ac10a-deee-434a-b4ad-ffcb10faf3bd.png)
- en: Now let's make a transaction to our network node hosted on port `3003` with
    the transaction amount as 10 bitcoins. Then click on the Send button to send the
    transaction to the network node on port `3003`. Here you will also get to observe
    the similar response.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们向托管在端口`3003`上的网络节点进行10比特币的交易。然后单击发送按钮将交易发送到端口`3003`上的网络节点。在这里，您也将看到类似的响应。
- en: 'Now that we have sent the transaction data to the network nodes, let''s verify
    it. Go to the browser and go to `localhost:3001/blockchain`, and then press *Enter*.
    You''ll get to observe a similar response, as shown in the following screenshot:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将交易数据发送到网络节点，让我们验证一下。转到浏览器，然后转到`localhost:3001/blockchain`，然后按*Enter*。您将看到一个类似的响应，如下面的屏幕截图所示：
- en: '![](img/f09a700f-459c-4b9e-ac96-6eaa7bfdc362.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f09a700f-459c-4b9e-ac96-6eaa7bfdc362.png)
- en: From the preceding screenshot, you can observe that we have one pending transaction
    for 30,000 bitcoin. That's one of the transactions that we just added.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，您可以看到我们有一个未决的30,000比特币交易。这是我们刚刚添加的交易之一。
- en: 'Now, in the other tab, if we go to `localhost:3002/blockchain`, you''ll see
    that we have no pending transactions because we did not send any transactions
    to this network node:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在另一个标签中，如果我们转到`localhost:3002/blockchain`，您将看到我们没有未决交易，因为我们没有向这个网络节点发送任何交易：
- en: '![](img/16eb2397-7d30-4ec1-aff6-6549cc2a0d9b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/16eb2397-7d30-4ec1-aff6-6549cc2a0d9b.png)
- en: 'Next, if we go to `localhost:3003/blockchain`, you''ll see that we have a pending
    transaction here for the amount of 10 Bitcoin:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果我们转到`localhost:3003/blockchain`，您将看到我们有一个未决的10比特币交易：
- en: '![](img/3eaf03d0-47f1-4a5b-a1ca-30942869c4e7.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/3eaf03d0-47f1-4a5b-a1ca-30942869c4e7.png)
- en: This was one of the other transactions that we made.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们进行的另一笔交易。
- en: 'If we were to go to `localhost: 3004/blockchain` and `localhost:3005/blockchain`,
    there should be no transactions there as we''ve not sent any of the transactions
    to these network nodes.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们去`localhost:3004/blockchain`和`localhost:3005/blockchain`，那里应该没有交易，因为我们没有向这些网络节点发送任何交易。
- en: The conclusion that we can draw from this test is that although we do have five
    different network nodes running parallel to each other, they are not connected
    in any way. As a consequence, our main motive of this chapter will be to connect
    all of the network nodes to each other in order to build up a decentralized network.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次测试中我们可以得出的结论是，尽管我们有五个不同的网络节点并行运行，但它们没有以任何方式连接。因此，本章的主要目的将是将所有网络节点连接到彼此，以建立一个去中心化的网络。
- en: Adding the currentNodeUrl
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加当前节点URL
- en: After testing our nodes, the next thing that we're going to do is alter the
    commands in our `package.json` slightly. The reason that we're going to do this
    is because we want each of our network nodes to be aware of what URL they are
    currently on. For example, they could be on `http://localhost:3001`, `localhost:3002`, `localhost:3003`,
    and so on. Therefore, we want each node to be aware of the URL that it is being
    hosted on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们的节点之后，我们要做的下一件事是稍微修改`package.json`中的命令。我们要这样做的原因是因为我们希望我们的每个网络节点都知道它们当前所在的URL。例如，它们可能在`http://localhost:3001`、`localhost:3002`、`localhost:3003`等上。因此，我们希望每个节点都知道它所托管的URL。
- en: 'In our `package.json`, as a third parameter to each of our commands, we are
    going to add the node''s URL. Therefore, our first node''s URL will simply be
    `http://localhost:3001`. It is likely that for our second node it will be `http://localhost:3002`.
    Similarly, you can add URLs for the remaining nodes, as shown in the following
    screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`package.json`中，作为我们每个命令的第三个参数，我们将添加节点的URL。因此，我们第一个节点的URL将简单地是`http://localhost:3001`。很可能对于我们的第二个节点，它将是`http://localhost:3002`。同样，您可以像下面的截图所示为其余节点添加URL：
- en: '![](img/ee845e2e-6061-4be3-87ce-65abd81fd763.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee845e2e-6061-4be3-87ce-65abd81fd763.png)'
- en: After adding the URLs, save the file. Now we have the URL of each node being
    passed in as an argument to the command we use to run each node. Therefore, we
    should have access to these URLs inside of our file, just like we have access
    to our port variables inside of our files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 添加URL后，保存文件。现在我们已经将每个节点的URL作为参数传递给我们用来运行每个节点的命令。因此，我们应该可以在我们的文件内访问这些URL，就像我们在我们的文件内访问我们的端口变量一样。
- en: 'Now let''s go to the `blockchain.js` file, and at the part where we define
    the const, we''re going to type the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到`blockchain.js`文件，并在定义常量的部分，我们将输入以下内容：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this command, we should have access to the current node's URL by using
    the `currentNodeUrl` variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们应该可以通过使用`currentNodeUrl`变量访问当前节点的URL。
- en: 'Now we should assign the `currentNodeUrl` to our `Blockchain` data structure.
    We do this by typing the following highlighted line of code inside of our `function
    Blockchain {}`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该将`currentNodeUrl`分配给我们的`Blockchain`数据结构。我们通过在我们的`function Blockchain {}`内输入以下突出显示的代码行来执行此操作：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we also want our blockchain to be aware of all of the other nodes that
    are inside of our network. Therefore, we will add the following code below the
    preceding highlighted line of code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还希望我们的区块链能意识到我们网络中的所有其他节点。因此，我们将在上述突出显示的代码行下面添加以下代码：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the further sections, we'll fill up this array with the node URLs of all
    the other nodes in our network so that every node will be aware of all the other
    nodes inside of our blockchain network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将用我们网络中所有其他节点的节点URL填充这个数组，以便每个节点都能意识到我们区块链网络中的所有其他节点。
- en: New endpoints outline
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新端点概述
- en: In our blockchain, we would now like to create a network and have a way to register
    all of the different nodes that we have with it. Therefore, let's make a couple
    more endpoints that will make it possible to register nodes with our network.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的区块链中，我们现在想要创建一个网络，并且有一种方法来注册我们的所有不同节点。因此，让我们创建一些端点，这将使得我们可以向我们的网络注册节点成为可能。
- en: Defining the /register-and-broadcast-node endpoint
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义`/register-and-broadcast-node`端点
- en: 'The first endpoint that we create will be `/register-and-broadcast-node`, and
    this is defined as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个端点将是`/register-and-broadcast-node`，定义如下：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding endpoint will register a node and broadcast that node to the
    whole network. It will do this by passing the URL of the node we want to register
    on the `req` body. Therefore, type the following inside the preceding endpoint:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述端点将注册一个节点并将该节点广播到整个网络。它将通过在`req` body中传递我们要注册的节点的URL来执行此操作。因此，在上述端点内输入以下内容：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're not going to build this endpoint now, but when we use it in later sections, we'll
    be sending in the URL of a new node that we want to add to our network. Then we're
    going to make some calculations and broadcast the node to the entire network so
    that all the other nodes can add it as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会构建这个端点，但是当我们在后面的部分中使用它时，我们将发送要添加到我们网络中的新节点的URL。然后我们将进行一些计算并将节点广播到整个网络，以便所有其他节点也可以添加它。
- en: Creating the /register-node endpoint
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建/register-node端点
- en: 'The `/register-node` will be the next endpoint that we''ll add to our network.
    This is defined as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`/register-node`将是我们将添加到我们网络中的下一个端点。定义如下：'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This endpoint will register a node with the network.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点将在网络中注册一个节点。
- en: The difference between register-and-broadcast-node and register-node endpoint
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`register-and-broadcast-node`和`register-node`端点之间的区别'
- en: Now let's try to understand how the `/register-and-broadcast-node` and `/register-node`
    endpoints are different. Basically, what's going to happen here is that whenever
    we want to register a new node with our network, we are going to hit the `/register-and-broadcast-node`
    endpoint. This endpoint is going to register the new node on its own server, and
    then it's going to broadcast this new node to all of the other network nodes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试着理解`/register-and-broadcast-node`和`/register-node`端点的不同之处。基本上，这里将发生的是，每当我们想要向我们的网络注册一个新节点时，我们将会命中`/register-and-broadcast-node`端点。这个端点将在自己的服务器上注册新节点，然后将这个新节点广播到所有其他网络节点。
- en: Those network nodes will simply accept the new network node inside of the `/register-node`
    endpoint, because all these nodes have to do is simply register the broadcast
    nodes. We just want them to register the new node; we do not want them to broadcast
    the new node because this has already occurred.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些网络节点将在`/register-node`端点内简单地接受新的网络节点，因为所有这些节点所要做的就是简单地注册广播节点。我们只希望它们注册新节点；我们不希望它们广播新节点，因为这已经发生了。
- en: If all of the other nodes in the network were to broadcast the new node as well,
    that would severely degrade the performance of our blockchain network and would
    lead to an infinite loop that would crash our blockchain. Therefore, when all
    of the other network nodes receive the new node's URL, we just want them to register
    it and not broadcast it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络中的所有其他节点也广播新节点，那将严重影响我们的区块链网络性能，并导致一个无限循环，导致我们的区块链崩溃。因此，当所有其他网络节点接收到新节点的URL时，我们只希望它们注册而不广播。
- en: Defining the /register-nodes-bulk endpoint
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义/register-nodes-bulk终端
- en: 'The final endpoint that we''re going to build in this section will be the `/register-nodes-bulk`
    endpoint:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建的最终终端将是`/register-nodes-bulk`终端：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This endpoint will register multiple nodes at once.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此终端将一次注册多个节点。
- en: Understanding how all of the endpoints work together
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解所有终端如何一起工作
- en: 'Learning about all of these endpoints might seem little bit confusing at this
    stage, so let''s try to understand this with the help of a diagram. In the following
    diagram, we have our blockchain network:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段了解所有这些终端可能会有点混乱，所以让我们尝试通过图表来理解。在下图中，我们有我们的区块链网络：
- en: '![](img/71f53dfa-9348-46fe-8838-40c861f1dc5f.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71f53dfa-9348-46fe-8838-40c861f1dc5f.png)'
- en: Now let's assume that these five network nodes are already connected to each
    other, thus forming our decentralized network. Also, let's assume that we want
    to add a node that is hosted on `localhost:3009` to our network.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设这五个网络节点已经相互连接，从而形成我们的去中心化网络。另外，假设我们想要将托管在`localhost:3009`上的节点添加到我们的网络中。
- en: 'The first thing that we''ll do to add that node to our network is hit the `register-and-broadcast-node`
    endpoint on one of our network nodes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是将该节点添加到我们的网络中，即在我们的网络节点中的一个上命中`register-and-broadcast-node`终端：
- en: '![](img/5a7ab59d-188a-4e1d-90b1-ea2e81232cee.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a7ab59d-188a-4e1d-90b1-ea2e81232cee.png)'
- en: When we hit the `register-and-broadcast-node` endpoint, we need to send the
    URL of the new node that we want to add to our network. For our example, the URL
    is `localhost:3009`. This is the first step for adding a new node to our network. We
    have to hit our `register-and-broadcast-node` endpoint with the new nodes URL
    as data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们命中`register-and-broadcast-node`终端时，我们需要发送我们想要添加到我们的网络中的新节点的URL。对于我们的示例，URL是`localhost:3009`。这是向我们的网络添加新节点的第一步。我们必须使用新节点的URL作为数据命中我们的`register-and-broadcast-node`终端。
- en: 'In the preceding diagram, the network node that we hit is going to register
    this new URL on its own node, and then it''s going to broadcast this new node''s
    URL to the rest of the network. All the other nodes in our network will receive
    this data at the `register-node` endpoint:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们命中的网络节点将在其自己的节点上注册这个新的URL，然后将这个新节点的URL广播到网络的其余部分。我们的网络中的所有其他节点将在`register-node`终端接收到这些数据：
- en: '![](img/ec42ecbb-8b21-4f13-890e-fb1269c45861.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec42ecbb-8b21-4f13-890e-fb1269c45861.png)'
- en: We're going to hit the `register-node` endpoint on all the other network nodes
    because we don't need to broadcast the data any more — we just need to register
    it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在所有其他网络节点上命中`register-node`终端，因为我们不需要再广播数据，我们只需要注册它。
- en: 'Now, after the new URL is registered with all the other network nodes, our
    original node is going to make a request to the new node, and it''s going to hit
    the `register-node-bulk` endpoint:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在所有其他网络节点上注册了新的URL后，我们的原始节点将向新节点发出请求，并命中`register-node-bulk`终端：
- en: '![](img/3664b8e3-8571-4e2f-aabf-db42c9e92719.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3664b8e3-8571-4e2f-aabf-db42c9e92719.png)'
- en: Furthermore, the original node is going to pass along the URLs of all the other
    nodes with it. So, this call will register all the other nodes that are already
    present inside of our network with the new node.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，原始节点将传递所有其他节点的URL。因此，此调用将注册网络中已经存在的所有其他节点与新节点。
- en: At this point, the node is now part of the network, and all of the nodes inside
    of the network will be aware of all the other nodes present in the network as
    well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，该节点现在是网络的一部分，网络中的所有节点也将意识到网络中存在的所有其他节点。
- en: Now let's just go over  the whole process one more time. The first thing that
    we're going to do to add a new node to our network is hit the `/register-and-broadcast-node`
    endpoint on one of the nodes inside of our network. This endpoint will register
    the new node's URL, and then it will broadcast that new URL to all the other nodes
    in the network. After the broadcast is complete, the original network node that
    we hit will send a request to the new network node and it will hit the `register-nodes-bulk`
    endpoint. In doing this, it will register all the other nodes in the network with
    our new node.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次回顾整个过程。我们要做的第一件事是在我们的网络中的一个节点上命中`/register-and-broadcast-node`终端，以添加一个新节点到我们的网络中。此终端将注册新节点的URL，然后将该新URL广播到网络中的所有其他节点。广播完成后，我们命中的原始网络节点将向新网络节点发送请求，并命中`register-nodes-bulk`终端。通过这样做，它将注册网络中的所有其他节点与我们的新节点。
- en: Consequently, when this whole process is complete, all of these nodes will be
    part of our decentralized blockchain network, and they will all be registered
    with each other.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当整个过程完成时，所有这些节点将成为我们去中心化的区块链网络的一部分，并且它们将相互注册。
- en: This is how these three endpoints are going to work together. In the following
    section, we're going to build the `register-and-broadcast-node` endpoint.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这三个终端如何一起工作的。在接下来的部分，我们将构建`register-and-broadcast-node`终端。
- en: Building  the /register-and-broadcast-node endpoint
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/register-and-broadcast-node终端
- en: 'Let''s start building our register and broadcast node endpoint. The function
    of this endpoint will be to register the new node with itself and then broadcast
    the new node to all the other nodes that are already present in the network. So,
    let''s get started with building the endpoint:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的注册和广播节点终端。这个终端的功能将是向自身注册新节点，然后将新节点广播到网络中已经存在的所有其他节点。所以，让我们开始构建这个终端：
- en: 'From the preceding sections, in the `dev/networkNode.js` file, we already have
    the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的部分，在`dev/networkNode.js`文件中，我们已经有以下代码：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we defined a variable called `newNodeUrl`, and this `newNodeUrl` data
    will be passed onto the request body, similar to how we have transaction data
    being passed into the transaction endpoint. With access to the `newNodeUrl`, the
    first thing that we want to do is register the node with the node's `register-and-broadcast-node` endpoint.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`newNodeUrl`的变量，这个`newNodeUrl`数据将被传递到请求体中，类似于我们将交易数据传递到交易端点的方式。有了`newNodeUrl`的访问权限，我们想要做的第一件事是注册节点到节点的`register-and-broadcast-node`端点。
- en: 'To register it, all we have to do is put the `newNodeUrl` inside of our `networkNodes`
    array on our `blockchain` data structure. To do that, in the preceding code block,
    add the following highlighted code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要注册它，我们所要做的就是将`newNodeUrl`放入我们的`blockchain`数据结构的`networkNodes`数组中。为此，在前面的代码块中添加以下突出显示的代码：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By adding the preceding line of code, we are pushing the `newNodeUrl` into
    the `networkNodes` array. We only want to do this if the `newNodeUrl` isn''t already
    present in the array. Check for this with the help of the `if` statement, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加上述代码行，我们将`newNodeUrl`推送到`networkNodes`数组中。只有在数组中`newNodeUrl`尚未存在时才这样做。通过以下`if`语句来检查：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What the `if` statement is doing is checking if the `newNodeUrl` is not already
    present in the `networkNodes` array. If it is not present, then it is added to
    the array. Consequently, with the help of the preceding block of code, the `newNodeUrl`
    is registered with the `register-and-broadcast-node` endpoint.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句正在检查`newNodeUrl`是否已经存在于`networkNodes`数组中。如果不存在，则将其添加到数组中。因此，借助上述代码块，`newNodeUrl`将被注册到`register-and-broadcast-node`端点。'
- en: 'Now that we''ve registered the `newNodeUrl`, what we have to do now is broadcast
    it to all the other nodes inside of the network. To do that, add the following
    line of code after the if block:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经注册了`newNodeUrl`，现在我们要做的是将其广播到网络中的所有其他节点。为此，在if块之后添加以下代码行：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding block of code, for each network node that is already present
    in the network or for every network node that is already present inside of the
    `networkNodes` array, we want to register our `newNodeUrl` with each of these
    `networkNodes` by hitting the register node endpoint. To do this, we're going
    to have to make a request to every single node at this endpoint.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码块中，对于已经存在于网络中的每个网络节点，或者对于已经存在于`networkNodes`数组中的每个网络节点，我们都希望通过命中注册节点端点来注册我们的`newNodeUrl`。为此，我们将不得不在这个端点向每个单独的节点发出请求。
- en: 'We''re going to make this request by importing a new library. Let''s head over
    to the terminal to import the library. In the terminal, we''re going to cancel
    our first network node and then type the following command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过导入一个新的库来进行此请求。让我们去终端导入这个库。在终端中，我们将取消我们的第一个网络节点，然后输入以下命令：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Installing this `request-promise` library will allow us to make requests to
    all the other nodes in our network. Once the library has been installed, restart
    the first node again by typing `npm run node_1`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装这个`request-promise`库将允许我们向网络中的所有其他节点发出请求。一旦安装了该库，再次输入`npm run node_1`来重新启动第一个节点。
- en: 'Now let''s go to the `dev/networkNode.js` file and import the library that
    we just downloaded to the code. Import the library by typing the following line
    of code at the start:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们去`dev/networkNode.js`文件，并将我们刚刚下载的库导入到代码中。在开头输入以下代码来导入库：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding line of code, `rp` stands for the request promise.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码行中，`rp`代表请求承诺。
- en: Now let's use this library in the `register-and-broadcast-node` endpoint. Over
    here, we have to broadcast our `newNodeUrl` to all the other nodes in our network.
    Do this with the help of  the `request-promise` library that we just imported.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`register-and-broadcast-node`端点中使用这个库。在这里，我们必须将我们的`newNodeUrl`广播到我们网络中的所有其他节点。使用我们刚刚导入的`request-promise`库来完成这个操作。
- en: 'The next couple of steps that we are going to add to the code might look a
    little bit confusing as we''re going through them, but don''t worry. After the
    steps are complete, we''ll walk through  the code  step by step to make sure that
    everything is clear to you. Now let''s take a look at the following steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到代码中的下一些步骤可能看起来有点混乱，但不要担心。步骤完成后，我们将逐步走过代码，确保一切对您来说都是清晰的。现在让我们看看以下步骤：
- en: 'The first thing that we want to do for our `request-promise` library is define
    some options that we''re going to use, so type in the following highlighted lines
    of code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`request-promise`库的第一件事是定义我们将使用的一些选项，因此输入以下突出显示的代码行：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Inside of this object, we want to define the options that we want to use for
    each request.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个对象中，我们想要定义我们要为每个请求使用的选项。
- en: 'The first option that we want to define is what URI/URL we want to hit. We
    know that we want to hit the `register-node` endpoints on all of our other `networkNodeUrl`.
    Consequently, we will add the following highlighted line of code to our preceding
    block:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要定义的第一个选项是我们要命中的URI/URL。我们知道我们要命中所有其他`networkNodeUrl`上的`register-node`端点。因此，我们将在前面的代码块中添加以下突出显示的代码行：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we want to define the method that we want to use. To hit the `register-node`
    endpoint, we''ll have to use the `POST` method, so add the following code to the
    preceding code block:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想定义我们要使用的方法。要命中`register-node`端点，我们将不得不使用`POST`方法，因此在前面的代码块中添加以下代码：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we want to find out what data we''re going to pass along with this request,
    so add the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们想知道我们将传递哪些数据，所以添加以下内容：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we''re going to set the `json` option to true so that we can send
    it as JSON data:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们要将`json`选项设置为true，这样我们就可以将其作为JSON数据发送：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These are the options that we want to use for each request we make. Now let''s
    see how we can use these options. After the `requestOptions` block, add the following
    line of code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是我们要用于每个请求的选项。现在让我们看看如何使用这些选项。在`requestOptions`块之后，添加以下代码行：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding request is going to return a promise to us, and we want to get
    all of these promises back in a single array. So, before and inside of the `forEach`
    loop, carry out the following highlighted changes:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述请求将返回一个promise给我们，我们希望将所有这些promise放在一个数组中。因此，在`forEach`循环之前和之内，执行以下突出显示的更改：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, outside of the `forEach` loop, we want to run all of the promises that
    we had requested. Add the following code after the loop:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`forEach`循环之外，我们希望运行我们请求的所有promise。在循环之后添加以下代码：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Continuing to work on the /register-and-broadcast-node endpoint
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续在/register-and-broadcast-node端点上工作
- en: In this section, let's continue to build our `register-and-broadcast-node` endpoint.
    So far, we have registered the new node with the current network node that we're
    on and we have broadcast the new node to all the other nodes in our network. Consequently,
    we're hitting the `register-node` endpoint on all the other nodes inside of our
    network. Also, for now, we're assuming that those other nodes are registering
    the new node, which we haven't built yet, but we're assuming that it's working.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，让我们继续构建我们的`register-and-broadcast-node`端点。到目前为止，我们已经在当前网络节点上注册了新节点，并且已经将新节点广播到我们网络中的所有其他节点。因此，我们正在访问我们网络中所有其他节点上的`register-node`端点。另外，目前我们假设那些其他节点正在注册新节点，虽然我们还没有构建它，但我们假设它正在工作。
- en: 'After the whole broadcast is completed, we must register all of the nodes that
    are currently inside of our network with the one new node that we are adding to
    the network. For that, we''re going to use our `request-promise` library. Therefore,
    we need to define some options, as highlighted in the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个广播完成后，我们必须将目前在我们网络中的所有节点注册到我们正在添加到网络中的新节点。为此，我们将使用我们的`request-promise`库。因此，我们需要定义一些选项，如下面的代码中所突出显示的：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, the options that we want to use (such as `uri`) are defined,
    along with the `POST` method. In the body option, we defined the `allNetworkNodes`
    array, and inside of this array, we want all of the URLs of all the nodes in our
    network, plus the URL of the node that we're currently on. Furthermore, you might
    have noticed that we used a spread operator `...` in the array because `bitcoin.networkNodes`
    is an array and we don't want one inside of another. Instead,  we want to spread
    out all the elements of this array and put them inside of our outer array. Finally,
    we want to define `json` as being `true`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了要使用的选项（如`uri`）以及`POST`方法。在body选项中，我们定义了`allNetworkNodes`数组，并且在这个数组内，我们希望包含我们网络中所有节点的所有URL，以及我们当前所在节点的URL。此外，您可能已经注意到我们在数组中使用了扩展运算符`...`，因为`bitcoin.networkNodes`是一个数组，我们不希望一个数组嵌套在另一个数组中。相反，我们希望展开这个数组的所有元素并将它们放入我们的外部数组中。最后，我们希望将`json`定义为`true`。
- en: 'Next, we want to make the request, so after the options block, add the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要发出请求，因此在选项块之后，添加以下内容：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After this, add the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，添加以下内容：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `data` variable present in the preceding line of code will actually be the
    data that we receive from the aforementioned promise. We're not going to do anything
    with this data, but we want to use `.then` because we want to do the next step
    inside of our endpoint. However, we can only do this after the aforementioned
    promise has completed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码行中的`data`变量实际上将是我们从上述promise中收到的数据。我们不打算对这些数据做任何处理，但我们想要使用`.then`，因为我们想在我们的端点内进行下一步操作。但是，我们只能在上述promise完成后才能这样做。
- en: 'The last step that we must complete inside of this endpoint is send a response
    back to whoever called it. Therefore, type the following highlighted lines of
    code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个端点内我们必须完成的最后一步是向调用它的人发送一个响应。因此，输入以下突出显示的代码行：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That is it for our `register-and-broadcast-node` endpoint.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`register-and-broadcast-node`端点。
- en: A quick recap of how the register-and-broadcast-node endpoint functions
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`register-and-broadcast-node`端点功能的快速回顾'
- en: Now let's run through this endpoint again for a quick summary of what we did
    in this endpoint so that we have a better understanding of this. Whenever we want
    to register a new node with our network, the `register-and-broadcast-node` endpoint
    is the first point that we want to hit. The first thing that we're doing inside
    of this endpoint is taking the `newNodeUrl` and registering it with the current
    node by pushing it into our `networkNodes` array.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次运行这个端点，以便快速总结我们在这个端点中所做的工作，以便更好地理解这一点。每当我们想要将新节点注册到我们的网络时，`register-and-broadcast-node`端点是我们想要访问的第一个点。在这个端点内我们要做的第一件事是获取`newNodeUrl`并将其通过将其推入我们的`networkNodes`数组中注册到当前节点。
- en: The next step that we have to make is to broadcast this `newNodeUrl` to the
    rest of the nodes in our network. We are doing that inside of the `forEach` loop.
    All that's happening inside of this for loop is we're making a request to each
    of the other nodes in our network. We're making this request to the `register-node`
    endpoint. We are then pushing all of these requests into our `register-node` promises
    array, and then we're simply running all of those requests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的一步是将这个`newNodeUrl`广播到我们网络中的其他节点。我们是在`forEach`循环内做这个操作。在这个循环内发生的一切就是我们向我们网络中的每个其他节点发出请求。我们正在向`register-node`端点发出这个请求。然后我们将所有这些请求推入我们的`register-node`promise数组中，然后简单地运行所有这些请求。
- en: Once all of these requests are completed without any errors, we can assume that
    the `newNodeUrl` has been registered successfully with all of our other network
    nodes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些请求都完成且没有任何错误，我们可以假设`newNodeUrl`已成功注册到我们的所有其他网络节点。
- en: After our broadcast is complete, the next thing that we want to do is register
    all of the network nodes that are already present inside of our network with our
    new node. To do this, we make a single request to our new node and we hit the
    `register-nodes-bulk` endpoint. The data that we pass along to this endpoint is
    the URLs of all the nodes that are already present inside of our network.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 广播完成后，我们要做的下一件事是将我们网络中已经存在的所有网络节点注册到我们的新节点上。为了做到这一点，我们向新节点发出单个请求，然后命中`register-nodes-bulk`端点。我们传递给这个端点的数据是我们网络中已经存在的所有节点的URL。
- en: We then run `rp(bulkRegisterOptions);`, and even though we haven't built the
    `register-nodes-bulk` endpoint yet, we're going to assume that it's working and
    that all of our network nodes have been registered with our new nodes successfully.
    Once that has happened, all of our calculations are complete, and we simply send
    back a note saying that the new node has been registered with the network successfully.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行`rp(bulkRegisterOptions);`，尽管我们还没有构建`register-nodes-bulk`端点，但我们假设它正在工作，并且我们的所有网络节点已经成功地注册到我们的新节点上。一旦发生这种情况，我们的所有计算就完成了，我们只需发送一条消息，说明新节点已成功注册到网络中。
- en: This may seem like a lot to take in at this point, but don't worry; it is recommended
    that you continue moving forward. In further sections, we're going to build our
    `register-node` endpoint, followed by our `register-nodes-bulk` endpoint. As we
    do this, everything should become clearer to you.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，这可能看起来很多，但不要担心；建议您继续前进。在接下来的部分，我们将构建我们的`register-node`端点，然后是我们的`register-nodes-bulk`端点。随着我们的操作，一切都会变得更清晰。
- en: Building the  /register-node endpoint
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/register-node端点
- en: Now that we have built the `/register-and-broadcast-node` endpoint, it's time
    we move on to some things that are a little less complex. In this section, let's
    begin building the `register-node` endpoint. This is going to be very straightforward
    compared to the endpoint that we built in the previous section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了`/register-and-broadcast-node`端点，是时候继续进行一些不那么复杂的事情了。在本节中，让我们开始构建`register-node`端点。与我们在上一节中构建的端点相比，这将非常简单。
- en: This `register-node` endpoint is where every node in the network is going to
    receive the broadcast that is sent out by our `register-and-broadcast-node` endpoint.
    The only thing that this `register-node` endpoint has to do is register the new
    node with the node that receives the request for it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`register-node`端点是网络中的每个节点都将接收到由我们的`register-and-broadcast-node`端点发送的广播。这个`register-node`端点唯一需要做的就是将新节点注册到接收到请求的节点上。
- en: 'To begin building the `register-node` endpoint,  follow these steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建`register-node`端点，请按照以下步骤进行：
- en: 'The first thing that we''ll have to do is define the `newNodeUrl`; therefore,
    add the following highlighted line of code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是定义`newNodeUrl`；因此，添加以下突出显示的代码行：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding line of code is simply stating to use the value of `newNodeUrl`
    that is sent to `req.body`. This is the data that we send to the `/register-node`
    endpoint, and we're going to save that new `nodeNodeUrl` as the `newNodeUrl` variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码只是简单地说明要使用发送到`req.body`的`newNodeUrl`的值。这是我们发送到`/register-node`端点的数据，我们将把新的`nodeNodeUrl`保存为`newNodeUrl`变量。
- en: 'Next, we want to register the `newNodeUrl` variable with the node that received
    the request. To do that, add the following highlighted line of code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要将`newNodeUrl`变量注册到接收到请求的节点上。为此，请添加以下突出显示的代码行：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding line of code will register our new node with the node that we
    are currently on. All we'll do here is simply push the `newNodeUrl` into the current
    node's `networkNodes` array.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将我们的新节点注册到我们当前所在的节点。我们要做的就是将`newNodeUrl`简单地推送到当前节点的`networkNodes`数组中。
- en: 'Now, the final thing that we have to do is send back a response, so type the
    following highlighted line of code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们要做的最后一件事就是发送一个响应，所以输入以下突出显示的代码行：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we want to do some error handling inside of this endpoint. The only thing
    that we want to do is add `newNodeUrl` to our `networkNodes` array, if it doesn''t
    already exist in that array. To do this,  we are going to add an if statement
    at the start of `bitcoin.networkNodes.push(newNodeUrl)`.  But before that, let''s
    define a variable, as follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要在这个端点内进行一些错误处理。我们唯一要做的就是，如果`newNodeUrl`在数组中不存在，就将其添加到我们的`networkNodes`数组中。为了做到这一点，我们将在`bitcoin.networkNodes.push(newNodeUrl)`的开头添加一个if语句。但在此之前，让我们定义一个变量，如下所示：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What this preceding highlighted line is stating is that if the index of the
    `newNodeUrl` is negative 1, or, in other words, if the `newNodeUrl` does not exist
    in our network nodes, then the `nodeNotAlreadyPresent` variable will be true.
    If the `newNodeUrl` already exists in our `networkNodes` array, then this variable
    will be false.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 上面突出显示的行是在说明，如果`newNodeUrl`的索引是-1，或者换句话说，如果`newNodeUrl`在我们的网络节点中不存在，那么`nodeNotAlreadyPresent`变量将为true。如果`newNodeUrl`已经存在于我们的`networkNodes`数组中，那么这个变量将为false。
- en: 'Inside of the if statement, what we''re going to state is that if the `newNodeUrl`
    is not present in our `networkNodes` array then add it by running `bitcoin.networkNodes.push(newNodeUrl)`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在if语句中，我们要说明的是，如果`newNodeUrl`不在我们的`networkNodes`数组中，则通过运行`bitcoin.networkNodes.push(newNodeUrl)`将其添加进去：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, there''s one other case that we want to handle, which is that we do not
    want to push the `newNodeUrl` into our `networkNodes` array if the `newNodeUrl`
    is actually the URL of the current node that we''re on. To mention this condition
    in the code, let''s first have to define a variable:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还要处理另一种情况，即如果`newNodeUrl`实际上是我们当前所在节点的URL，我们不希望将`newNodeUrl`推送到我们的`networkNodes`数组中。为了在代码中提到这个条件，我们首先必须定义一个变量：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding line is simply evaluating the `bitcoin.currentNodeUrl !== newNodeUrl` expression,
    which states whether or not the `currentNodeUrl` equals the `newNodeUrl`. If not,
    then the `notCurrentNode` variable will be true. If they do equal each other,
    then the variable will be false.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的一行只是评估`bitcoin.currentNodeUrl !== newNodeUrl`表达式，该表达式说明`currentNodeUrl`是否等于`newNodeUrl`。如果不是，则`notCurrentNode`变量将为true。如果它们相等，则变量将为false。
- en: 'Next, we just want to add the `notCurrentNode` variable to our if statement,
    as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需将`notCurrentNode`变量添加到我们的if语句中，如下所示：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What's happening in this if statement is that if the new node is not already
    present in our `networkNodes` array and if the new node is not the same URL as
    the current node that we're on, then we just want to add the new node to our `networkNodes`
    array.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个if语句中发生的事情是，如果新节点不在我们的`networkNodes`数组中，并且新节点的URL与我们当前所在的节点不同，那么我们只想将新节点添加到我们的`networkNodes`数组中。
- en: Everything that we have learned here is error handling inside of the endpoint.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在端点内部进行错误处理。
- en: Testing the  /register-node endpoint
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试/register-node端点
- en: In this section, let's test the `/register-node` endpoint to make sure that
    it works properly and to get a better understanding of how it works.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们测试`/register-node`端点，以确保它正常工作并更好地了解其工作原理。
- en: Installing the request library
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装请求库
- en: Before we get into testing the endpoint, there is a small update that we need
    to carry out. The update is regarding installing the request library. A few sections
    prior, we installed the `request-promise` library. Now, to test the endpoints
    that we just created, it might be necessary for us to also install the request
    library, depending on what version of the `request-promise` library we have.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试端点之前，我们需要进行一个小更新。更新涉及安装请求库。在几个部分之前，我们安装了`request-promise`库。现在，为了测试我们刚刚创建的端点，可能需要我们也安装请求库，这取决于我们安装的`request-promise`库的版本。
- en: 'To install the request library, simply go to your terminal, and inside of the
    `blockchain` directory run the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装请求库，只需转到终端，并在`blockchain`目录中运行以下命令：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Endpoint testing
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点测试
- en: 'Before we get into testing, check whether you have all five of our network
    nodes running inside of your terminal. If not, then you will have to set them
    up.  Let''s test the `register-node` endpoint by using Postman:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行测试之前，请检查您的终端中是否有我们的五个网络节点都在运行。如果没有，那么您将需要设置它们。使用Postman测试`register-node`端点：
- en: 'To start with, we''re going to type `http://localhost:3001/register-node` in
    the address bar, as shown in the following screenshot:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在地址栏中输入`http://localhost:3001/register-node`，如下截图所示：
- en: '![](img/75f40672-7bbe-403e-adcb-4d41009a6ce7.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75f40672-7bbe-403e-adcb-4d41009a6ce7.png)'
- en: When we hit this endpoint, we are expected to send in a `newNodeUrl` as data
    on our `req.body`. We'll have to set that up now. So, in the Body tab inside of
    the Postman, we want to have raw selected and JSON (application/json) selected
    as the text.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问这个端点时，我们需要在`req.body`上发送`newNodeUrl`作为数据。我们现在需要设置它。因此，在Postman的Body选项卡中，我们希望选择原始和JSON（application/json）作为文本。
- en: 'Then, inside the textbox, make an object and add the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在文本框中，创建一个对象并添加以下代码：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s say that we want to register our node that is running on port `3002`
    with our node that''s running on port `3001`. Add the following to our preceding
    code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在假设我们要使用端口`3002`上运行的节点注册我们运行在端口`3001`上的节点。将以下内容添加到我们之前的代码中：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So far, we have registered our node that's running on `localhost:3002` with
    our node that's running on `localhost:3001`. Therefore, when we hit `http://localhost:3001/register-node`,
    our `localhost:3002` should show up in the `networkNodes` array of our first node
    (that is, `localhost:3001`) because this `register-node` endpoint registers a
    node by placing it into the `networkNodes` array.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用运行在`localhost:3002`上的节点注册了我们运行在`localhost:3001`上的节点。因此，当我们访问`http://localhost:3001/register-node`时，我们的`localhost:3002`应该出现在第一个节点（即`localhost:3001`）的`networkNodes`数组中，因为这个`register-node`端点通过将节点放入`networkNodes`数组中来注册节点。
- en: 'To verify this, go to Postman and click on the Send button. You will get the
    response New node registered successfully. Now go over to your browser and  type `localhost:3001/blockchain` into
    the address bar, followed by pressing *Enter*. You will see an output similar
    to what''s shown in the following screenshot:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证这一点，打开Postman并单击发送按钮。您将收到响应“新节点成功注册”。现在转到浏览器，输入`localhost:3001/blockchain`到地址栏，然后按*Enter*。您将看到类似于以下截图所示的输出：
- en: '![](img/089da3ad-3891-4605-9b36-62bc7a6d15cd.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/089da3ad-3891-4605-9b36-62bc7a6d15cd.png)'
- en: Since we had just registered our second node with our current node on `localhost:3001`,
    we have our second node's URL inside of this array.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚使用`localhost:3001`上的当前节点注册了我们的第二个节点，因此我们的第二个节点的URL现在在这个数组中。
- en: Following the same procedure, you can try to register other nodes too. Try experimenting
    with this. This will help you in gaining a clear understanding of the nodes that
    are registered. If you come across any issues, try to read through the whole procedure
    again.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的步骤，您也可以尝试注册其他节点。尝试进行实验。这将帮助您更清楚地了解已注册的节点。如果遇到任何问题，请尝试重新阅读整个过程。
- en: One important thing that we want to notice here is that if we now go to `localhost:3002/blockchain`,
    we get to observe that there are no network nodes registered in the `networkNodes`
    array.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要注意的一件重要的事情是，如果我们现在转到`localhost:3002/blockchain`，我们会发现`networkNodes`数组中没有注册的网络节点。
- en: Ideally, what we want to happen is that when we register a new node, we want
    it to reverse register as well. So, if we register `localhost:3002` with the node
    on `3001`, then our node on `3002 `should register `localhost:3001`. That way,
    both of these nodes will be aware of each other.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望发生的是，当我们注册一个新节点时，我们希望它也进行反向注册。因此，如果我们使用`3001`上的节点注册`localhost:3002`，那么我们`3002`上的节点应该注册`localhost:3001`。这样，这两个节点都将彼此知晓。
- en: We've actually already built this functionality inside of our `register-and-broadcast-node`
    endpoint. Once we build all three of these endpoints, the functionality that we
    mentioned will work properly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们已经在`register-and-broadcast-node`端点内构建了这个功能。一旦我们构建了这三个端点，我们提到的功能将正常工作。
- en: Building the /register-nodes-bulk endpoint
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建/register-nodes-bulk端点
- en: The next endpoint that we are going to build is our `register-nodes-bulk` endpoint;
    this is the final endpoint that we need to build. These three endpoints that we
    have been working on will all work together to create our decentralized blockchain
    network.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的下一个端点是我们的`register-nodes-bulk`端点；这是我们需要构建的最终端点。我们一直在处理的这三个端点将共同工作，创建我们的去中心化区块链网络。
- en: Before we start building the endpoint, let's try to understand what the `register-nodes-bulk`
    endpoint does. Whenever a new node gets broadcast to all the other nodes inside
    of the network, we want to take all of the nodes that are already inside of the
    network and send that data back to our new node so that the new node can register
    and recognize all of the nodes that are already present inside of the network.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建端点之前，让我们试着理解一下`register-nodes-bulk`端点的作用。每当一个新节点被广播到网络中的所有其他节点时，我们希望获取已经存在于网络中的所有节点，并将这些数据发送回我们的新节点，以便新节点可以注册和识别已经存在于网络中的所有节点。
- en: The `register-nodes-bulk` endpoint will be accepting data that contains the
    URLs of every node that is already present in the network. Then, we're simply
    going to register all of these network nodes with the new node.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`register-nodes-bulk`端点将接受包含已经存在于网络中的每个节点的URL的数据。然后，我们将简单地注册所有这些网络节点到新节点。'
- en: The new node is the node on which the `register-nodes-bulk` endpoint is hit.
    This endpoint is only ever hit on a new node that's being added to our network.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点是命中`register-nodes-bulk`端点的节点。这个端点只会在我们的网络中添加新节点时才会命中。
- en: To build the `register-nodes-bulk` endpoint, we'll have to make an assumption
    that all of the node URLs that are currently in our network are being passed in
    as data, and that we can access them on the `req.body.allNetworkNodes` property.
    This is because we're sending in the `allNetworkNodes` data when we call this
    endpoint in the `Promise.all(regNodesPromise)` block. Over here, we're sending
    in `allNetworkNodes` to the `register-nodes-bulk` endpoint. This will give us
    access to the `allNetworkNodes` data inside of the endpoint.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建`register-nodes-bulk`端点，我们将假设我们当前网络中的所有节点URL都作为数据传递，并且我们可以在`req.body.allNetworkNodes`属性上访问它们。这是因为在`Promise.all(regNodesPromise)`块中调用此端点时，我们正在发送`allNetworkNodes`数据。在这里，我们正在将`allNetworkNodes`发送到`register-nodes-bulk`端点。这将使我们能够在端点内部访问`allNetworkNodes`数据。
- en: 'Let''s add the following line of code to our `register-nodes-bulk` endpoint
    that we created in the previous sections:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在之前创建的`register-nodes-bulk`端点中添加以下代码行：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, let''s loop through every node URL present in the `allNetworkNodes` array
    and register it with the new node, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们循环遍历`allNetworkNodes`数组中存在的每个节点URL，并将其注册到新节点，如下所示：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, all we''re going to do inside of the loop is register each network node
    URL with the current node that we''re on, which is the new node being added to
    the network:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在循环中我们要做的就是将每个网络节点URL注册到我们当前所在的节点，也就是正在添加到网络中的新节点：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What's happening in the preceding highlighted line of code is that as we cycle
    through all the network nodes with our `forEach` loop, we are registering each
    one by pushing that `networkNodeUrl` into our `networkNodes` array.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面突出显示的代码行中发生的情况是，当我们通过`forEach`循环遍历所有网络节点时，我们通过将`networkNodeUrl`推送到我们的`networkNodes`数组中来注册每一个节点。
- en: Whenever we hit the `/register-nodes-bulk` endpoint, we are on the new node that's
    being added to the network. All of these `networkNodeUrls` are being registered
    to the new node that we are adding.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们命中`/register-nodes-bulk`端点时，我们都在添加到网络中的新节点上。所有这些`networkNodeUrls`都将被注册到我们正在添加的新节点上。
- en: 'Now there are a couple of instances in which we do not want to add a `networkNodeUrl`
    to our `networkNodes` array. To handle these instances, we are going to use an
    if statement. But before that, we need to define a conditional statement, as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在有几种情况下，我们不希望将`networkNodeUrl`添加到我们的`networkNodes`数组中。为了处理这些情况，我们将使用一个if语句。但在此之前，我们需要定义一个条件语句，如下所示：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: One reason that we would not want to add a `networkNodeUrl` to our `networkNodes`
    array is if this `networkNodeUrl` already exists in our `networkNodes` array;
    that's what we have mentioned in the conditional statement.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`networkNodeUrl`已经存在于`networkNodes`数组中，我们就不希望将其添加到`networkNodes`数组中；这就是我们在条件语句中提到的。
- en: All this statement is doing is testing to see if the `networkNodeUrl` that we're
    on is present inside of our `networkNodes` array. From here, it will simply evaluate
    this as either true or false.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句所做的就是测试我们当前所在的`networkNodeUrl`是否存在于我们的`networkNodes`数组中。从这里，它将简单地将其评估为真或假。
- en: 'Now we can add the `nodeNotAlreadyPresent` variable and the if statement, as highlighted 
    in the following code :'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加`nodeNotAlreadyPresent`变量和if语句，如下面的代码中所突出显示的那样：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding if statement states that if the node is not already present inside
    of our `networkNodes` array, then we're going to register that node.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的if语句说明，如果节点尚未存在于我们的`networkNodes`数组中，那么我们将注册该节点。
- en: 'Now, another instance in which we would not want to register a network node
    is if that network node has the same URL as the network node that we are currently
    on. To handle this, we''ll have to make another variable:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，另一种情况是，如果要注册的网络节点具有与我们当前所在的网络节点相同的URL，我们就不希望注册该网络节点。为了处理这个情况，我们需要另一个变量：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, add this variable to our `if` statement:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将这个变量添加到我们的`if`语句中：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Basically, all we're stating in the `if` statement is that as we cycle through
    each network node that we're adding, if that node is not already present in our
    network node array and if that node is not our current node's URL, then we want
    to add the `networkNodeUrl` to our `networkNodes` array.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在`if`语句中我们所陈述的是，当我们循环遍历每个要添加的网络节点时，如果该节点尚未存在于我们的网络节点数组中，并且该节点不是我们当前节点的URL，那么我们就要将`networkNodeUrl`添加到我们的`networkNodes`数组中。
- en: 'Once we have completed the `forEach` loop, we''ll have registered all of the
    network nodes that are already present inside of our blockchain network. All we
    have to do at this point is send back a response, as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成`forEach`循环后，我们将注册所有已经存在于我们区块链网络中的网络节点。在这一点上，我们所要做的就是发送回一个响应，如下所示：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let's quickly review what we have done so far. The endpoint that we've built
    is accepting all of the network nodes as data, and then we are cycling through
    all of the network nodes that are already present in our blockchain network. For
    each node, as long as it is not already registered with the `currentNode` and
    is not the same URL as the `currentNode`, we are going to add the node to our
    `networkNodes` array.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们到目前为止所做的工作。我们构建的端点接受所有网络节点作为数据，然后我们循环遍历已经存在于我们区块链网络中的所有网络节点。对于每个节点，只要它尚未注册到`currentNode`并且不是与`currentNode`相同的URL，我们就会将该节点添加到我们的`networkNodes`数组中。
- en: Testing the /register-nodes-bulk endpoint
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试/register-nodes-bulk端点
- en: 'In this section, we''re going to test our `register-nodes-bulk` endpoint to
    make sure that it works properly. This will allow us to gain a clear understanding
    of how it works:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将测试我们的`register-nodes-bulk`端点，以确保它正常工作。这将使我们清楚地了解它的工作原理：
- en: To test the endpoint, we are going to head over to Postman. Here, we'll hit
    the `localhost:3001/register-nodes-bulk` endpoint.  When we test this endpoint,
    we expect to receive some data, which is the `allNetworkNodes` array.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这个端点，我们将前往Postman。在这里，我们将命中`localhost:3001/register-nodes-bulk`端点。当我们测试这个端点时，我们期望收到一些数据，即`allNetworkNodes`数组。
- en: 'Consequently, in the body tab inside Postman, with the raw option and JSON
    (application/json) format selected for the text, add the following lines of code
    to the body:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在Postman的body选项卡中，选择原始选项和JSON（application/json）格式，将以下代码添加到body中：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside of this array, there are going to be the URLs of all of the nodes that
    are already present in our blockchain network:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个数组中，将包含已经存在于我们区块链网络中的所有节点的URL：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When we run this request now, we should register all three of these URLs with
    our node that's running on `localhost:3001`. Let's see if that works. Click on
    the Send button and you will receive a response that states Bulk registration
    successful.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们现在运行这个请求时，我们应该在运行在`localhost:3001`上的节点上注册这三个URL。让我们看看是否有效。点击发送按钮，您将收到一个回复，说明批量注册成功。
- en: 'Now, if we head over to the browser, we can double check that it worked. In
    the address bar, type `localhost:3001/blockchain` and then press *Enter*. You
    will get to observe the three URLs that were added inside of `networkNodes` array,
    since those are bulk registered:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们转到浏览器，我们可以双重检查它是否有效。在地址栏中，键入`localhost:3001/blockchain`，然后按*Enter*。您将看到`networkNodes`数组中添加的三个URL，因为它们是批量注册的：
- en: '![](img/2e1a0bbc-6040-460b-9646-cf19e3c289e3.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e1a0bbc-6040-460b-9646-cf19e3c289e3.png)'
- en: Similarly, you can try experimenting by adding new nodes to the other nodes
    on different URLs. You'll get to observe the similar response in the `networkNodes`
    array of these nodes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以尝试通过将新节点添加到不同URL上的其他节点来进行实验。您将观察到这些节点的`networkNodes`数组中的类似响应。
- en: So, it looks like our `register-node-bulk` endpoint is working just as it should.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看起来我们的`register-node-bulk`端点正在按照预期工作。
- en: Testing all of the network endpoints
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试所有网络端点
- en: From what we have learned in the preceding section,  we know that our `register-node`
    route and that the `register-nodes-bulk` route are both working correctly. So,
    in this section, let's put it all together and test our `register-and-broadcast-node`
    route, which uses the both the `register-node` route and the `register-nodes-bulk`
    route.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在前面部分学到的知识，我们知道我们的`register-node`路由和`register-nodes-bulk`路由都正常工作。因此，在本节中，让我们把它们全部整合起来，测试我们的`register-and-broadcast-node`路由，该路由同时使用了`register-node`路由和`register-nodes-bulk`路由。
- en: The `register-and-broadcast-node` endpoint will allow us to build a decentralized
    blockchain network by allowing us to create a network and add new nodes to it.
    Let's jump right into our first example to get a better understanding of it. To
    understand how the `register-and-broadcast-node` route works, we'll make use of 
    Postman.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`register-and-broadcast-node`端点将允许我们通过创建网络并向其添加新节点来构建分散的区块链网络。让我们立即进入我们的第一个示例，以更好地理解它。为了理解`register-and-broadcast-node`路由的工作原理，我们将使用Postman。'
- en: In the Postman application, we want to make a post request to register and broadcast
    the node on `localhost:3001`. However, before we do that, just make sure that
    all four nodes are running so that we can test the routes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在Postman应用程序中，我们要发出一个post请求，以在`localhost:3001`上注册和广播节点。但在这之前，只需确保所有四个节点都在运行，以便我们可以测试路由。
- en: 'At this point, we have no network at all; we just have five individual nodes
    running, but they are not connected in any way. Therefore, the first call that
    we''re going to make is simply going to connect two nodes together to form the
    beginnings of our network. We will now register a node with our node that''s hosted
    on port `3001`. When we hit the `register-and-broadcast-node` endpoint, we must
    send in a `newNodeUrl` that we want to register. In Postman, add the following
    code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们根本没有网络；我们只有五个独立的节点在运行，但它们没有以任何方式连接。因此，我们将要做的第一个调用只是简单地将两个节点连接在一起，以形成我们网络的开端。我们现在将一个节点注册到我们在端口`3001`上托管的节点。当我们命中`register-and-broadcast-node`端点时，我们必须发送一个要注册的`newNodeUrl`。在Postman中，添加以下代码：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For this first test, we want to register our second node hosted on port `3002`
    with our first node. To do that, we will add the following highlighted code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一次测试，我们想要将我们托管在端口`3002`上的第二个节点注册到我们的第一个节点。为此，我们将添加以下突出显示的代码：
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, when we make this request, it should register our node that''s hosted
    on `localhost:3002` with our node that''s hosted on `localhost:3001`. Let''s verify
    this by clicking the Send button. You will see an output similar to what''s shown
    in the following screenshot:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们发出这个请求时，它应该将我们托管在`localhost:3002`上的节点注册到我们托管在`localhost:3001`上的节点。让我们通过单击“发送”按钮来验证这一点。您将看到类似于以下屏幕截图中显示的输出：
- en: '![](img/719bee39-e7d4-4552-9b50-cd0c070994bd.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/719bee39-e7d4-4552-9b50-cd0c070994bd.png)'
- en: From the preceding screenshot, we can see that the new node has been registered
    successfully with the network. Let's verify this by going to the browser.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，我们可以看到新节点已成功注册到网络。让我们通过转到浏览器来验证这一点。
- en: 'In the browser, you will have access to all five nodes that are running. We
    have now registered the node on port `3002` with the node  hosted on `localhost:3001`.
    So, if we refresh the page on the browser now, we''ll get to observe that `localhost:3002`
    has been registered in the `networkNodes` array of port `3001`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，您将可以访问所有正在运行的五个节点。我们现在已经将端口`3002`上的节点注册到了托管在`localhost:3001`上的节点。因此，如果我们现在在浏览器上刷新页面，我们将看到`localhost:3002`已经在端口`3001`的`networkNodes`数组中注册了：
- en: '![](img/ec380a6e-515f-4e6d-a627-9c42a1c50b87.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec380a6e-515f-4e6d-a627-9c42a1c50b87.png)'
- en: 'From the preceding screenshot, we can see that we''ve registered `localhost:3002`.
    Now, if we go to `localhost:3002`, we should have `localhost:3001` registered
    in its `networkNodes` array. Let''s refresh and see what we get here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，我们可以看到我们已经注册了`localhost:3002`。现在，如果我们转到`localhost:3002`，我们应该在它的`networkNodes`数组中有`localhost:3001`注册。让我们刷新并看看我们在这里得到了什么：
- en: '![](img/b260a295-1f23-477d-90b5-046958542553.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b260a295-1f23-477d-90b5-046958542553.png)'
- en: From the preceding screenshot, we can see that both nodes have now formed a
    network and registered each other as a network node.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，我们可以看到两个节点现在已经形成了一个网络，并将彼此注册为网络节点。
- en: 'Next, let''s add another node to this network. Let''s head back to Postman
    and change the `localhost:3002` to `localhost:3003`. We''re going to make a request
    to the node that is on `3001`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们向这个网络添加另一个节点。让我们回到Postman，并将`localhost:3002`更改为`localhost:3003`。我们将向在`3001`上的节点发出请求：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'What this should do is register our node that''s hosted on `localhost:3003`
    with all the other nodes in the network. So, `3003` should register with `3001`
    and `3002`. Let''s send this request and see if it works. If it''s successfully
    registered, you will see an output similar to what''s shown in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是将我们托管在`localhost:3003`上的节点与网络中的所有其他节点注册。因此，`3003`应该注册到`3001`和`3002`。让我们发送这个请求，看看它是否成功注册。如果成功注册，您将看到类似于以下屏幕截图中显示的输出：
- en: '![](img/835f911b-b92d-46a7-ac78-6ef5f8f25530.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/835f911b-b92d-46a7-ac78-6ef5f8f25530.png)'
- en: 'Let''s verify this in our browser. When we refresh in the `localhost:3001`, we
    should have `localhost: 3003` inside of the `networkNodes` array:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中验证这一点。当我们在`localhost:3001`中刷新时，我们应该在`networkNodes`数组中有`localhost:3003`：
- en: '![](img/cc8bbbbe-1f83-4a38-8369-62c7b9dca2cb.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc8bbbbe-1f83-4a38-8369-62c7b9dca2cb.png)'
- en: 'Now, since `localhost:3002` is also part of the network, it should have `localhost:3003`
    inside of the `networkNodes` array. When we made this request, we made it to `3001`
    not `3002`. Localhost `3002 `was already part of the network, and the broadcast
    registered `3003` with all the network nodes that are present in the network.
    To verify this, refresh the `networkNodes` array on `3002`. You will see an output
    similar to what''s shown in the following screenshot:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`localhost:3002`也是网络的一部分，它的`networkNodes`数组中应该有`localhost:3003`。当我们发出这个请求时，我们是发给`3001`而不是`3002`。`localhost:3002`已经是网络的一部分，广播注册了`3003`与网络中存在的所有网络节点。要验证这一点，请刷新`3002`上的`networkNodes`数组。您将看到类似于以下屏幕截图中显示的输出：
- en: '![](img/8980a924-52f1-41b1-9ca1-2956b5d55f59.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8980a924-52f1-41b1-9ca1-2956b5d55f59.png)'
- en: 'From the preceding screenshot, we can see that we have our third node inside
    of the `localhost:3002` `networkNodes` array as well now. Furthermore, if we go
    over to the `networkNodes` on `localhost:3003` and refresh the page,  we should
    have both `3001` and `3002` inside of the `networkNodes` array:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中，我们可以看到我们的第三个节点现在也在`localhost:3002`的`networkNodes`数组中。此外，如果我们转到`localhost:3003`上的`networkNodes`并刷新页面，我们应该在`networkNodes`数组中有`3001`和`3002`：
- en: '![](img/2d8d197b-0d69-4ab6-acd0-d967272e99b2.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d8d197b-0d69-4ab6-acd0-d967272e99b2.png)'
- en: Consequently, we now have a network comprised of our nodes on `3001`, `3002`,
    and `3003`. These are registered with each other.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个由`3001`、`3002`和`3003`节点组成的网络。这些节点已经相互注册。
- en: Now, let's head back to Postman and register the remaining `localhost:3004`
    and `localhost:3005` with the network by following the same procedures that we
    followed to register the initial nodes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到Postman，并按照注册初始节点的相同步骤，将剩下的`localhost:3004`和`localhost:3005`注册到网络中。
- en: 'After registering both `3004` and `3005` with the network, if you go to the
    browser, all of these registered nodes should have `localhost:3004` and `localhost:3005`
    inside of their `networkNodes` array. Refresh the `localhost:3001` page and you
    see an output similar to what''s shown in the following screenshot:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`3004`和`3005`注册到网络后，如果您转到浏览器，所有这些注册节点应该在它们的`networkNodes`数组中包含`localhost:3004`和`localhost:3005`。刷新`localhost:3001`页面，您将看到类似于以下屏幕截图中显示的输出：
- en: '![](img/64d347a1-5324-4e30-918f-851087536f20.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64d347a1-5324-4e30-918f-851087536f20.png)'
- en: Similarly, if you refresh the other pages, you will get to observe all the nodes,
    similar to what we observed in the preceding screenshot.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果您刷新其他页面，您将能够观察到所有节点，类似于我们在前面的屏幕截图中观察到的。
- en: So, this is how we've built up a decentralized network that is comprised of
    five different nodes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们建立了一个由五个不同节点组成的去中心化网络。
- en: 'Now, you might be wondering how all of this is working. It''s working because
    when we make a `"newNodeUrl": "http://localhost:3004"` request, we are actually
    adding a command to add `3004` to the network. But then how does `localhost:3004`
    become aware of the entire network from one request?'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，您可能想知道所有这些是如何工作的。它之所以能够工作，是因为当我们发出`"newNodeUrl": "http://localhost:3004"`的请求时，我们实际上是在添加一个命令，将`3004`添加到网络中。但是`localhost:3004`如何在一次请求中意识到整个网络呢？'
- en: If you remember from the preceding sections, when we built the `/register-and-broadcast-node`
    endpoint, there was actually a lot of calculations going on. So, if we take a
    look at the `/register-and-broadcast-node` endpoint code, we can see that the
    first thing that happens inside of our `register-and-broadcast-node` endpoint
    is that we take in the `newNodeUrl` and then broadcast it to every single node
    in the network by hitting their `register-node` endpoint. So, every node in the
    network will become aware of the new node that's being added.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得前面的部分，当我们构建`/register-and-broadcast-node`端点时，实际上进行了大量的计算。因此，如果我们看一下`/register-and-broadcast-node`端点的代码，我们可以看到我们的`register-and-broadcast-node`端点内部发生的第一件事是接收`newNodeUrl`，然后通过访问它们的`register-node`端点将其广播到网络中的每个节点。因此，网络中的每个节点都将意识到新添加的节点。
- en: 'For the complete code, please visit [https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js](https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js) and
    refer to the code block which starts with this comment: `//registering a node
    and broadcasting it the network`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的代码，请访问[https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js](https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/blob/master/dev/networkNode.js)，并参考以此注释开头的代码块：`//registering
    a node and broadcasting it the network`。
- en: Then, after the broadcast takes place, we send the request to the new node that
    was just added and register all of the network nodes that are already present
    in the network with the new node. This is where the reverse registration takes
    place. At this point, all of the original nodes in the network are aware of the
    new node, and the new node is aware of all the other nodes in the network. Thus,
    all of the nodes inside of the network become aware of each other, which is what
    needs to happen for our blockchain to work properly.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在广播发生后，我们向刚刚添加的新节点发送请求，并使用新节点注册网络中已经存在的所有网络节点。这就是反向注册发生的地方。在这一点上，网络中的所有原始节点都意识到了新节点，而新节点也意识到了网络中的所有其他节点。因此，网络中的所有节点都意识到了彼此，这是我们的区块链正常工作所必须发生的事情。
- en: So, all three of the endpoints (`register-and-broadcast-node`, `register-node`,
    and `register-nodes-bulk`) that we built are very powerful because they work together
    to create a decentralized blockchain network. This is what we have built in this
    chapter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们构建的这三个端点（`register-and-broadcast-node`、`register-node`和`register-nodes-bulk`）非常强大，因为它们共同工作以创建一个分散的区块链网络。这就是我们在本章中构建的内容。
- en: At this point in the book, it is recommended that you to take some time to play
    around with these endpoints a little bit, making different networks with different
    nodes, and testing it a little bit more to get more familiar with how it's all
    working.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，建议您花一些时间玩弄这些端点，创建不同的具有不同节点的网络，并进行一些测试，以更熟悉它的工作原理。
- en: If you are confused about any of the concepts or topics we've covered, it is
    recommend that you once again read through all of the sections in this chapter.
    You'd be surprised how much you can learn and pick up the second time around after
    you already have some context for what is going to be happening and what we're
    going to be building.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对我们所涵盖的任何概念或主题感到困惑，建议您再次阅读本章的所有部分。您会惊讶地发现，在您已经对即将发生的事情和我们将要构建的内容有一些背景之后，第二次阅读时您可以学到多少东西。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have now finished creating our decentralized network. In this chapter, we
    learned about a lot of new concepts. We began our journey by learning about how
    to create the multiple instances of our API and how to use them to set up our
    decentralized network. We then defined various endpoints such as `register-and-broadcast-node`,
    `register-node`, and `register-nodes-bulk`. After this, we built these endpoints
    and tested them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了创建我们的分散网络。在本章中，我们学习了许多新概念。我们开始学习如何创建我们API的多个实例以及如何使用它们来设置我们的分散网络。然后，我们定义了各种端点，如`register-and-broadcast-node`、`register-node`和`register-nodes-bulk`。之后，我们构建了这些端点并对其进行了测试。
- en: In the next chapter, we will learn how to synchronize the network.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何同步网络。
