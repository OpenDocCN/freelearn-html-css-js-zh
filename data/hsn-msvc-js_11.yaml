- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Microservices Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: The world of software development is constantly evolving. As applications grow
    in complexity, traditional monolithic architectures struggle to keep pace. This
    chapter dives into some key design patterns that empower developers to build scalable
    and resilient systems – an API gateway, **Command Query Responsibility Segregation**
    (**CQRS**), event sourcing, and Service Registry and discovery.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的世界正在不断演变。随着应用程序复杂性的增加，传统的单体架构难以跟上步伐。本章深入探讨了一些关键设计模式，这些模式赋予开发者构建可扩展和弹性系统的能力——API网关、**命令查询责任分离**（**CQRS**）、事件溯源以及服务注册和发现。
- en: These patterns, particularly when used together within a microservices architecture,
    offer numerous benefits. They promote loose coupling between services, making
    them easier to develop, maintain, and deploy independently. They also enhance
    scalability by allowing individual services to be scaled based on specific needs.
    Additionally, these patterns contribute to improved fault tolerance and resilience,
    ensuring that your application remains robust even if individual services encounter
    issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式，尤其是在微服务架构中联合使用时，提供了许多好处。它们促进了服务之间的松散耦合，使得它们更容易独立开发、维护和部署。它们还通过允许根据特定需求对单个服务进行扩展来增强可伸缩性。此外，这些模式有助于提高容错性和弹性，确保即使个别服务遇到问题，应用程序也能保持稳健。
- en: This chapter will provide a comprehensive introduction to each of these patterns,
    outlining their core concepts, benefits, and use cases. We will explore how to
    apply some of them to create a robust foundation for building modern, scalable
    applications. By understanding these patterns, you’ll be equipped to design and
    develop applications that can thrive in the ever-changing landscape of software
    development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将全面介绍这些模式中的每一个，概述其核心概念、优势和用例。我们将探讨如何应用其中的一些模式来构建现代、可扩展应用程序的坚实基础。通过理解这些模式，您将能够设计并开发能够在软件开发不断变化的领域中茁壮成长的应用程序。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Getting started with an API gateway
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用API网关
- en: CQRS and event sourcing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS和事件溯源
- en: Service Registry and discovery in microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务中的服务注册和发现
- en: Let’s get into the chapter!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入本章内容！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow us along the chapter, we need an IDE (we prefer Visual Studio Code),
    Postman, Docker, and a browser of your choice.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章内容，我们需要一个集成开发环境（我们更倾向于Visual Studio Code），Postman，Docker以及您选择的浏览器。
- en: It is preferable to download the repository from [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript)
    and open the `Ch11` folder to easily follow our code snippets.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 建议从[https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript)下载仓库，并打开`Ch11`文件夹，以便轻松跟随我们的代码片段。
- en: Getting started with an API gateway
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用API网关
- en: An API Gateway integrates with a microservice architecture by acting as a central
    hub, managing communication between client applications and the distributed microservices.
    When we build our microservices, we want them independently developed, deployed,
    and scaled without affecting client applications. Clients only interact with the
    API gateway, which shields them from the complexities of the underlying microservice
    network.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: API网关通过充当中央枢纽，管理客户端应用程序和分布式微服务之间的通信，与微服务架构集成。当我们构建微服务时，我们希望它们能够独立开发、部署和扩展，而不影响客户端应用程序。客户端仅与API网关交互，这可以保护他们免受底层微服务网络的复杂性。
- en: '![Figure 11.1: A simple API Gateway](img/B09148_11_001.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：一个简单的API网关](img/B09148_11_001.jpg)'
- en: 'Figure 11.1: A simple API Gateway'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：一个简单的API网关
- en: 'The API Gateway receives requests from clients and intelligently routes them
    to the appropriate microservice(s), based on the request content or URL. It can
    handle simple routing or complex scenarios, involving multiple microservices working
    together to fulfill a request. Let’s explore the importance of integrating an
    API Gateway into our microservice architecture:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: API网关接收来自客户端的请求，并根据请求内容或URL智能地将它们路由到适当的微服务（们）。它可以处理简单的路由或复杂场景，涉及多个微服务共同完成一个请求。让我们探讨将API网关集成到我们的微服务架构中的重要性：
- en: '**Simplified client interaction**: Clients have a centralized entry point/single
    point of contact (the API gateway) to interact with an application, regardless
    of how many microservices are involved. This reduces development complexity on
    the client side.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化客户端交互**：客户端有一个集中的入口点/单一联系点（即API网关）来与应用程序交互，无论涉及多少个微服务。这减少了客户端的开发复杂性。'
- en: '**Improved scalability**: An API Gateway can be independently scaled to handle
    increasing traffic volumes without impacting the individual microservices. Microservices
    can also be scaled independently based on their specific workloads, highlighting
    the importance of API gateways.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可扩展性**：API网关可以独立扩展以处理增加的流量，而不会影响单个微服务。微服务也可以根据其特定的工作负载独立扩展，突显了API网关的重要性。'
- en: '**Enhanced security**: Centralized security management of an API Gateway strengthens
    overall application security. The API Gateway can implement authentication, authorization,
    and other security policies to protect microservices from unauthorized access.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强安全性**：API网关的集中式安全管理加强了整体应用程序的安全性。API网关可以实施身份验证、授权和其他安全策略，以保护微服务免受未经授权的访问。'
- en: '**Reduced development complexity**: Developers don’t need to implement functionalities
    such as routing, security, and monitoring logic within each microservice. An API
    Gateway handles these cross-cutting concerns centrally.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少开发复杂性**：开发者不需要在每个微服务中实现诸如路由、安全和监控逻辑等功能。API网关集中处理这些跨领域关注点。'
- en: Let’s now see how an API Gateway might work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看API网关是如何工作的。
- en: How an API Gateway works
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API网关的工作原理
- en: In a microservice architecture, an API Gateway acts as the central entry point
    for all client requests. It plays a crucial role in managing and optimizing the
    flow of communication between clients and backend services. By handling authentication,
    routing, load balancing, and other vital functions, the API Gateway ensures that
    the microservices remain loosely coupled and scalable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，API网关充当所有客户端请求的中央入口点。它在管理和优化客户端与后端服务之间的通信流中发挥着关键作用。通过处理身份验证、路由、负载均衡和其他重要功能，API网关确保微服务保持松散耦合和可扩展。
- en: 'Here’s a step-by-step breakdown of how an API Gateway typically processes client
    requests:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是API网关通常处理客户端请求的步骤分解：
- en: '**Client request**: A client (e.g., a web or mobile app) sends a request to
    an API Gateway. The request includes details such as the HTTP method, URL path,
    headers, and possibly a body.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端请求**：客户端（例如，一个Web或移动应用）向API网关发送请求。请求包括诸如HTTP方法、URL路径、头部和可能的内容体等详细信息。'
- en: '**Request handling**: The API Gateway receives the request and examines its
    contents. Based on the URL path or other routing rules, the Gateway determines
    which backend service(s) should handle the request.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请求处理**：API网关接收请求并检查其内容。根据URL路径或其他路由规则，网关确定哪个后端服务应该处理该请求。'
- en: '**Authentication and authorization**: The API Gateway checks the request for
    authentication tokens (e.g., JWT or OAuth tokens). It verifies the token’s validity
    and checks whether the client has the necessary permissions to access the requested
    resource.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**身份验证和授权**：API网关会检查请求中的身份验证令牌（例如，JWT或OAuth令牌）。它验证令牌的有效性并检查客户端是否有访问请求资源的必要权限。'
- en: '**Request transformation**: The API Gateway may modify the request to fit the
    requirements of the backend service. This might include changing the protocol,
    altering headers, or modifying the request body.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**请求转换**：API网关可能会修改请求以适应后端服务的需求。这可能包括更改协议、修改头部或修改请求体。'
- en: '**Routing and aggregation**: The Gateway routes the request to the appropriate
    backend service(s). If the request involves multiple services, the Gateway will
    handle communication with each service and aggregate their responses into a single
    response for the client.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**路由和聚合**：网关将请求路由到适当的后端服务。如果请求涉及多个服务，网关将处理与每个服务的通信并将它们的响应聚合为单个响应发送给客户端。'
- en: '**Caching and load balancing**: The Gateway checks whether the response is
    cached to serve it quickly without hitting the backend service. It also distributes
    the request load among multiple instances of the backend service to balance traffic
    and improve performance.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**缓存和负载均衡**：网关检查响应是否已缓存，以便快速提供而无需击中后端服务。它还将在后端服务的多个实例之间分配请求负载，以平衡流量并提高性能。'
- en: '**Rate limiting and throttling**: The API Gateway enforces rate limits to control
    the number of requests a client can make within a specified period. It may throttle
    requests if a client exceeds the allowed request rate.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**速率限制和节流**：API网关强制执行速率限制，以控制客户端在指定时间段内可以发出的请求数量。如果客户端超过允许的请求速率，它可能会限制请求。'
- en: '**Response handling**: Once the backend service(s) respond, the Gateway may
    modify the response before sending it back to the client. This could include adding
    or removing headers, transforming data formats, or aggregating multiple responses.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**响应处理**：一旦后端服务响应，网关可能会在将其发送回客户端之前修改响应。这可能包括添加或删除头信息、转换数据格式或聚合多个响应。'
- en: '**Logging and monitoring**: The API Gateway logs details of the request and
    response for monitoring and analysis. Metrics such as request counts, response
    times, and error rates are tracked to monitor the health and performance of the
    services.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日志记录和监控**：API网关记录请求和响应的详细信息，以便进行监控和分析。跟踪的指标包括请求数量、响应时间和错误率，以监控服务的健康和性能。'
- en: Now that we know how an API Gateway works, let’s see what the better choice
    in a given situation is – single or multiple API gateways.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了API网关的工作原理，让我们看看在特定情况下更好的选择是单一还是多个API网关。
- en: Single versus multiple API gateways
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个与多个API网关
- en: You can implement multiple API gateways in a microservice architecture, but
    it’s not always the most straightforward or recommended approach. There are situations
    where it might be beneficial, but generally, a single API Gateway is preferred
    for simplicity and maintainability.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在微服务架构中实现多个API网关，但这并不总是最直接或推荐的方法。在某些情况下，这可能会带来好处，但通常，出于简单性和可维护性的考虑，单个API网关更受欢迎。
- en: A single API Gateway is ideal when you want centralized management, a consistent
    client experience, and simplified scalability – all of which streamline API operations
    and reduce complexity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望实现集中管理、一致的客户端体验和简化的可扩展性时，单个API网关是理想的——所有这些都有助于简化API操作并降低复杂性。
- en: 'While a single Gateway is often preferred, there are some situations where
    multiple gateways might be considered:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单个网关通常更受欢迎，但在某些情况下可能需要考虑使用多个网关：
- en: '**Heterogeneous client types**: If you have clients using vastly different
    protocols or communication styles (e.g., mobile apps, web applications, and legacy
    systems), separate API gateways could be used to cater to these specific needs
    with custom protocols or functionalities. This approach can be complex to maintain
    in the long run.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异构客户端类型**：如果你有使用截然不同协议或通信风格的客户端（例如，移动应用、Web应用和遗留系统），可以使用单独的API网关来满足这些特定需求，使用自定义协议或功能。然而，这种做法在长期维护中可能会变得复杂。'
- en: '**Physical separation**: If your microservices are geographically distributed
    across different data centers or cloud regions, you might consider placing an
    API Gateway in each location for performance reasons. However, this introduces
    additional management overhead to maintain consistency across gateways.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理分离**：如果你的微服务地理分布在不同的数据中心或云区域，出于性能考虑，你可能考虑在每个位置放置一个API网关。然而，这会引入额外的管理开销，以保持网关之间的一致性。'
- en: '**Security segmentation**: In very specific security-sensitive scenarios, you
    might implement separate API gateways for different security zones within your
    application. This allows for stricter control over access to certain microservices.
    However, this requires careful design and expertise to avoid creating unnecessary
    complexity.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全分区**：在非常具体的、对安全性敏感的场景中，你可以在应用程序的不同安全区域内实现单独的API网关。这允许对某些微服务的访问进行更严格的控制。然而，这需要仔细的设计和专业知识，以避免创建不必要的复杂性。'
- en: Generally, the benefits of a single API Gateway outweigh the potential advantages
    of using multiple gateways, as the former promotes simplicity, maintainability,
    and a consistent client experience.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单一API网关的好处超过了使用多个网关的潜在优势，因为前者促进了简单性、可维护性和一致的客户端体验。
- en: 'If you want to reap the benefits of multiple API gateways without the complexity,
    here are some alternatives:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要获得多个API网关的好处而又不增加复杂性，这里有一些替代方案：
- en: '**An API Gateway with routing by client type**: Consider using a single API
    Gateway with routing logic that can differentiate between different client types
    and tailor responses accordingly.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按客户端类型路由的API网关**：考虑使用一个单一的API网关，其路由逻辑能够区分不同的客户端类型并相应地定制响应。'
- en: '**Microservice facades**: Implement a **facade** pattern (more on this shortly)
    within some microservices to handle specific client interactions, potentially
    reducing the need for multiple gateways.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务外观**：在部分微服务中实现一个**外观**模式（稍后将详细介绍），以处理特定的客户端交互，可能减少对多个网关的需求。'
- en: You should carefully consider your specific needs before implementing multiple
    API gateways. In most cases, a well-designed single API Gateway will provide the
    optimal solution for your microservice architecture.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施多个 API 网关之前，你应该仔细考虑你的具体需求。在大多数情况下，一个设计良好的单一 API 网关将为你的微服务架构提供最佳解决方案。
- en: The facade pattern
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式
- en: A facade in this context refers to implementing a layer within some microservices
    that specifically handles interactions with clients. Instead of introducing multiple
    API gateways, which can add complexity, a microservice facade acts as a simplified
    interface or *front* that abstracts the internal workings of the microservice
    for the client.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，外观指的是在部分微服务中实现一个层，专门处理与客户端的交互。而不是引入多个 API 网关，这可能会增加复杂性，微服务外观充当一个简化的接口或*前端*，为客户端抽象微服务的内部工作。
- en: It is time to implement and see the power of an API Gateway in practice. The
    next section will dive into the details of the practical implementation of an
    API gateway.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候实施并看到 API 网关在实际中的力量了。下一节将深入探讨 API 网关实际实施的细节。
- en: Implementing microservices using an API gateway
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 API 网关实现微服务
- en: It is possible to implement the API Gateway pattern using different forms with
    different libraries. In this context, `Ch11`/`ApiGateway` folder in our repo.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的形式和不同的库实现 API 网关模式是可能的。在我们的仓库中，`Ch11`/`ApiGateway` 文件夹就是这种情况。
- en: 'To demonstrate the real value of the API Gateway pattern, we need to have at
    least two microservices. The reason for needing *at least two* microservices to
    show the true value of the API Gateway pattern is that the pattern is designed
    to handle multiple services and consolidate their functionality for clients. We
    will use the following two microservices in this chapter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 API 网关模式的实际价值，我们需要至少有两个微服务。需要至少两个微服务来展示 API 网关模式真实价值的原因是，该模式旨在处理多个服务并整合它们的功能以供客户端使用。在本章中，我们将使用以下两个微服务：
- en: The post-microservice
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端微服务
- en: The user microservice
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户微服务
- en: Implementing post microservice
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现后端微服务
- en: Our first microservice, the *post-microservice*, acts as a wrapper/abstraction
    over the `jsonplaceholder` service. `jsonplaceholder` is a free online service
    that provides a REST API with fake data. It’s often used by developers to easily
    access and utilize realistic-looking sample data (users, posts, comments, etc.)
    without having to set up their databases. This allows them to quickly test API
    endpoints, frontend functionality, and user interactions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个微服务，*后端微服务*，作为 `jsonplaceholder` 服务的包装/抽象。`jsonplaceholder` 是一个免费在线服务，提供带有伪造数据的
    REST API。它通常被开发者用来轻松访问和利用看起来真实的样本数据（用户、帖子、评论等），而无需设置自己的数据库。这使得他们可以快速测试 API 端点、前端功能以及用户交互。
- en: Create a new folder (a `post-microservice` folder in our case).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹（在我们的例子中是 `post-microservice` 文件夹）。
- en: Run `npm install express axios` to install the required packages.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npm install express axios` 来安装所需的包。
- en: 'Here is what your `package.json` should look like:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `package.json` 应该看起来像这样：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For all chapters, you don’t need to install the exact package versions listed.
    While our focus is on using the packages themselves rather than specific versions,
    if there are major changes or breaking differences in newer versions, refer to
    the official documentation for updates.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有章节，你不需要安装列出的确切包版本。虽然我们的重点是使用包本身而不是特定版本，但如果新版本中有重大更改或破坏性差异，请参阅官方文档以获取更新。
- en: 'Now, let’s create a new file called `server.js` in the folder we created (i.e.,
    `post-microservices`) with the following code block:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们创建的文件夹（即 `post-microservices`）中创建一个名为 `server.js` 的新文件，并使用以下代码块：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code snippet uses the Express framework to create a simple web server that
    listens on port `3001`. It imports the `axios` library to make HTTP requests.
    The server has a single route, `/posts/:id`, which responds to `GET` requests.
    When a request is made to this route, it extracts the `id` parameter from the
    URL. The server then makes an asynchronous request to `https://jsonplaceholder.typicode.com/posts/${postId}`
    to fetch a specific post. If the post is found, it sends the post data as a JSON
    response. If the post is not found, it responds with a `404` status code. If there
    are any errors during the request, it logs them and responds with a `500`-status
    code, indicating an internal server error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段使用 Express 框架创建一个简单的 Web 服务器，监听端口 `3001`。它导入 `axios` 库以发送 HTTP 请求。服务器有一个单一的路径
    `/posts/:id`，它响应 `GET` 请求。当对该路径发出请求时，它会从 URL 中提取 `id` 参数。然后服务器异步地向 `https://jsonplaceholder.typicode.com/posts/${postId}`
    发送请求以获取特定的帖子。如果找到帖子，它将帖子数据作为 JSON 响应发送。如果没有找到帖子，它将返回 `404` 状态码。如果在请求过程中出现任何错误，它将记录这些错误并以
    `500`-状态码响应，表示内部服务器错误。
- en: Let’s run our microservice using the `node server.js` command and test whether
    everything is working. Open your favorite browser and navigate to `localhost:3001/posts/1`
    (*Figure 11**.2*).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `node server.js` 命令运行我们的微服务，并测试是否一切正常。打开您喜欢的浏览器，导航到 `localhost:3001/posts/1`
    (*图 11.2*).
- en: '![Figure 11.2: A post-microservice response](img/B09148_11_002.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2：帖子微服务的响应](img/B09148_11_002.jpg)'
- en: 'Figure 11.2: A post-microservice response'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：帖子微服务的响应
- en: Implementing user microsevice
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现用户微服务
- en: 'Our second microservice is called a *user microservice*. It has approximately
    the same implementation as our post microservice, with a different port (`3002`)
    and different service abstraction (a GitHub service abstraction):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个微服务被称为 *用户微服务*。它的实现与我们的帖子微服务大致相同，但端口不同（`3002`）和服务抽象（GitHub 服务抽象）不同：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s run our microservice using the `node server.js` command and test whether
    everything is working. Open your favorite browser and navigate to `localhost:3002/users/1`
    (*Figure 11**.3*).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `node server.js` 命令运行我们的微服务，并测试是否一切正常。打开您喜欢的浏览器，导航到 `localhost:3002/users/1`
    (*图 11.3*).
- en: '![Figure 11.3: A user microservice response](img/B09148_11_003.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3：用户微服务的响应](img/B09148_11_003.jpg)'
- en: 'Figure 11.3: A user microservice response'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：用户微服务的响应
- en: Let’s build our API Gateway as a third microservice and combine the post and
    user microservices.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的 API 网关作为第三个微服务，并将帖子微服务和用户微服务结合起来。
- en: Developing an API gateway
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发 API 网关
- en: After implementing two microservices, we’re ready to show the value and power
    of an API gateway. We plan to implement rate limit, cache, and response aggregation
    functionalities for the API gateway. You can add more features such as logging,
    appropriate exception handling, monitoring, and other interesting behaviors after
    understanding the essentials.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了两个微服务后，我们准备好展示 API 网关的价值和力量。我们计划为 API 网关实现速率限制、缓存和响应聚合功能。在理解了基本知识后，您可以添加更多功能，如日志记录、适当的异常处理、监控和其他有趣的行为。
- en: 'First things first – you need to understand that an API Gateway by itself acts
    as a separate microservice. So, create a new folder for it (it is called `api-``g``ateway`
    in our GitHub repo). We have `package.json` with the following content:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要理解 API 网关本身就是一个独立的微服务。因此，为它创建一个新的文件夹（在我们的 GitHub 仓库中称为 `api-``g``ateway`）。我们有
    `package.json`，内容如下：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will use an `express-rate-limit` package to implement rate-limit functionality
    in our microservice. In a microservice architecture, where applications are broken
    down into smaller, independent services, **rate limiting** is a technique used
    to control the number of requests that a service can receive within a specific
    timeframe. It acts like a traffic controller, preventing a service from being
    overloaded by a surge of requests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `express-rate-limit` 包在我们的微服务中实现速率限制功能。在微服务架构中，应用程序被分解成更小、更独立的微服务时，**速率限制**是一种用于控制服务在特定时间段内可以接收的请求数量的技术。它就像交通控制器一样，防止服务因请求激增而超载。
- en: Conversely, `apicache` is used to implement cache behavior for an API gateway.
    **Caching** refers to a functionality that allows you to store responses from
    your backend services for a specific time. This cached data can then be served
    to subsequent requests, improving performance and reducing load on your backend.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`apicache`用于实现API网关的缓存行为。**缓存**是指允许您将后端服务的响应存储一段时间内的功能。然后，这些缓存数据可以服务于后续请求，提高性能并减少后端负载。
- en: 'Let’s create a `server.js` file to implement an API gateway. Our imported packages
    look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`server.js`文件来实现API网关。我们导入的包看起来像这样：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, let’s configure our rate limit:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们配置我们的速率限制：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use `express-rate-limit` to control how many times users can access your
    API Gateway in a minute. It acts like a gatekeeper. If a user makes fewer than
    a hundred requests within a minute, they get through. If they go over a hundred,
    they’ll be blocked with a `Too many requests, please slow down` message. This
    protects our API from overload and ensures a good user experience for everyone.
    We will use this `limiter` object later when we specify routing for our endpoint.
    Let’s move on and implement data aggregation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`express-rate-limit`来控制用户在一分钟内可以访问您的API网关的次数。它就像一个守门人。如果一个用户在一分钟内请求少于一百次，他们可以通过。如果他们超过一百次，他们将收到一个`Too
    many requests, please slow down`（请求过多，请慢点）的消息。这保护了我们的API免受过载，并确保每个人都能有一个良好的用户体验。我们将在指定端点路由时使用此`limiter`对象。让我们继续并实现数据聚合：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This function, `getAggregatedData`, retrieves data from two different microservices
    to build a combined response. It takes an ID as input:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数，`getAggregatedData`，从两个不同的微服务中检索数据以构建一个组合响应。它接受一个ID作为输入：
- en: First, it makes two separate asynchronous calls using `axios.get`. One fetches
    post data from the post microservice at port `3001`, and the other fetches user
    data from the user microservice at port `3002`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它使用`axios.get`进行两次独立的异步调用。一次从端口号为`3001`的帖子微服务中获取帖子数据，另一次从端口号为`3002`的用户微服务中获取用户数据。
- en: Then, it combines the data into a single object, named `aggregatedData`. User
    data such as location, the followers’ URLs, and the person followed by the URL
    are included. Additionally, the post data retrieved from the first call is added
    under the key post.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将数据合并成一个名为`aggregatedData`的单个对象。包括用户数据，如位置、跟随者的URL以及通过URL被跟随的人。此外，从第一次调用中检索到的帖子数据被添加到键`post`下。
- en: Finally, the function returns the `aggregatedData` object, containing all the
    relevant information about the user and their posts.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，该函数返回包含有关用户及其帖子所有相关信息的`aggregatedData`对象。
- en: By aggregating data in an API gateway, we present a simplified API to client
    applications. They only need to call a single endpoint (within the gateway) to
    receive the combined user and post data, instead of making separate calls to each
    microservice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在API网关中聚合数据，我们向客户端应用程序提供了一个简化的API。它们只需要调用网关内的单个端点（`/users/:id`），即可接收组合的用户和帖子数据，而不是分别对每个微服务进行单独调用。
- en: 'For example, when requesting `localhost:3000/users/1`, we should get user information
    from both the post and user microservices. Here is how we get aggregated data
    from more than one microservice:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当请求`localhost:3000/users/1`时，我们应该从帖子微服务和用户微服务中获取用户信息。以下是获取多个微服务聚合数据的方法：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code defines a route handler for the API Gateway using Express.js. It handles
    `GET` requests to the `/users/:id` URL path, where `:id` is a dynamic parameter
    representing the user ID. The `limiter` middleware is applied before the route
    handler function, which ensures that only allowed requests (typically, a hundred
    per minute based on the previous code) can proceed. Inside the function, the API
    extracts the ID from the request parameters. It then calls the `getAggregatedData`
    function to asynchronously retrieve and combine user and post data. If successful,
    the function sends a JSON response with the retrieved aggregated data. If there
    are errors during data fetching, it sends a response with a status code of `400`
    (bad request) and a generic error message.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用Express.js定义了一个API网关的路由处理器。它处理对`/users/:id` URL路径的`GET`请求，其中`:id`是一个动态参数，代表用户ID。在路由处理器函数之前应用了`limiter`中间件，这确保只有允许的请求（通常基于之前的代码，每分钟一百次）可以继续。在函数内部，API从请求参数中提取ID。然后调用`getAggregatedData`函数以异步检索和合并用户和帖子数据。如果成功，该函数发送包含检索到的聚合数据的JSON响应。如果在数据检索过程中出现错误，它将发送一个状态码为`400`（错误请求）和通用错误消息的响应。
- en: 'The last functionality in our API Gateway is caching. We need to add the following
    code snippet to the `server.js` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 API 网关的最后一个功能是缓存。我们需要将以下代码片段添加到 `server.js` 文件中：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using this code, we apply caching for five minutes for all types of endpoints.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们对所有类型的端点应用五分钟的缓存。
- en: We’re done with our infrastructure (the post microservice, API Gateway, and
    user microservice); it is time to test all of them together.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础设施（帖子微服务、API 网关和用户微服务）已经完成；现在是时候测试它们全部一起了。
- en: Testing an API Gateway in Docker
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Docker 中测试 API 网关
- en: To test an API Gateway, you can run every microservice separately, but as you
    know, we have different names for microservices in our `getAggregatedData` function
    – `http://post-microservice:3001` and `http://user-microservice:3002`. To make
    these microservices work properly and not run every microservice every time, we
    will containerize them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 API 网关，您可以单独运行每个微服务，但如您所知，我们在 `getAggregatedData` 函数中为微服务有不同的名称 – `http://post-microservice:3001`
    和 `http://user-microservice:3002`。为了使这些微服务正常工作并且不必每次都运行每个微服务，我们将它们容器化。
- en: 'For every microservice, we have `Dockerfile`, as shown in the following figure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个微服务，我们都有 `Dockerfile`，如下图所示：
- en: '![Figure 11.4: An API Gateway project structure](img/B09148_11_004.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4：API 网关项目结构](img/B09148_11_004.jpg)'
- en: 'Figure 11.4: An API Gateway project structure'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：API 网关项目结构
- en: A `Dockerfile` is a text file that contains instructions to build a Docker image.
    It acts like a recipe that tells Docker what steps to take to create a self-contained
    environment for your application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 是一个包含构建 Docker 镜像指令的文本文件。它就像一个食谱，告诉 Docker 如何采取步骤来创建一个为您的应用程序提供自包含环境的容器。'
- en: 'All three Docker files are completely the same, with the following content:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个 Docker 文件完全相同，内容如下：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This `Dockerfile` creates an image for a Node.js application. It starts with
    a lightweight Node.js base image, installs dependencies, copies your entire project,
    and then runs your server code upon startup.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Dockerfile` 为 Node.js 应用程序创建一个镜像。它从一个轻量级的 Node.js 基础镜像开始，安装依赖项，复制您的整个项目，然后在启动时运行您的服务器代码。
- en: 'We have a `docker-compose.yml` file in our root folder that will combine all
    these three `Dockerfile` files and compose them:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的根目录中有一个 `docker-compose.yml` 文件，它将结合这三个 `Dockerfile` 文件并将它们组合起来：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `docker-compose.yml` file defines a multi-container application. It creates
    three services – `post-microservice`, `user-microservice`, and `api-``g``ateway`.
    Each builds its own image from a separate directory (for example, `./post-microservice`)
    using a common `Dockerfile`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `docker-compose.yml` 文件定义了一个多容器应用程序。它创建了三个服务 – `post-microservice`、`user-microservice`
    和 `api-gateway`。每个服务都从单独的目录（例如，`./post-microservice`）使用共同的 `Dockerfile` 构建自己的镜像。
- en: Each service gets exposed on a specific port (`3001` for posts, `3002` for users,
    and `3000` for the Gateway).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都在特定的端口上公开（帖子为 `3001`，用户为 `3002`，网关为 `3000`）。
- en: 'The `api-Gateway` relies on both `post-microservice` and `user-microservice`
    to be active before starting itself, ensuring that the dependencies are available.
    To compose these microservices’ Docker files, navigate to the folder where we
    have the `docker-compose.yml` file and run the `docker-compose up -d` command.
    It should build and run composed services together. Here is what running all required
    services together via Docker looks like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`api-Gateway` 依赖于 `post-microservice` 和 `user-microservice` 在其启动之前处于活动状态，以确保依赖项可用。要组合这些微服务的
    Docker 文件，导航到包含 `docker-compose.yml` 文件的文件夹，并运行 `docker-compose up -d` 命令。它应该一起构建和运行组合服务。以下是使用
    Docker 一起运行所有必需服务的外观：'
- en: '![Figure 11.5: An API Gateway in Docker](img/B09148_11_005.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5：API 网关在 Docker 中的表现](img/B09148_11_005.jpg)'
- en: 'Figure 11.5: An API Gateway in Docker'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：API 网关在 Docker 中的表现
- en: 'Navigate to `localhost:3000/users/1` from your browser, and you should get
    the following aggregated data:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的浏览器导航到 `localhost:3000/users/1`，您应该得到以下聚合数据：
- en: '![Figure 11.6: An API Gateway in action](img/B09148_11_006.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6：API 网关在实际应用中的表现](img/B09148_11_006.jpg)'
- en: 'Figure 11.6: An API Gateway in action'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：API 网关在实际应用中的表现
- en: So far, we have explored the role of an API Gateway in a microservices architecture,
    emphasizing how it simplifies client interactions by acting as a central entry
    point for routing, security, and load balancing. We learned how the API Gateway
    aggregates data from multiple microservices, applies caching and rate limiting,
    and enhances scalability. By integrating it into our architecture, we improve
    both performance and security while maintaining the flexibility and independence
    of individual microservices. Finally, we containerized the microservices and API
    Gateway using Docker for efficient testing and deployment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了API网关在微服务架构中的作用，强调了它如何通过充当路由、安全和负载均衡的中心入口点来简化客户端交互。我们学习了API网关如何从多个微服务中聚合数据，应用缓存和速率限制，并增强可伸缩性。通过将其集成到我们的架构中，我们提高了性能和安全性，同时保持了单个微服务的灵活性和独立性。最后，我们使用Docker容器化了微服务和API网关，以实现高效的测试和部署。
- en: In our next section, we’re going to explore other interesting patterns such
    as CQRS and event sourcing. First, we will learn what are they and why we use
    them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨其他有趣的模式，例如CQRS和事件溯源。首先，我们将了解它们是什么，以及为什么我们会使用它们。
- en: CQRS and event sourcing
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS和事件溯源
- en: CQRS is a software design pattern used in distributed systems (often microservices)
    to separate read and write operations. This separation offers several advantages,
    particularly when dealing with applications with high read/write disparities or
    complex data models.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS是一种在分布式系统（通常是微服务）中使用的软件设计模式，用于分离读写操作。这种分离提供了几个优点，尤其是在处理具有高读写差异或复杂数据模型的应用程序时。
- en: When you apply for jobs that use distributed architecture in their applications,
    you often hear about CQRS and, most probably, will be asked about its usage. First
    things first – we need to understand that CQRS is not an architecture style; it
    is neither an architecture nor architectural principle. It is just a design pattern
    that has no wide usage. So, what is CQRS? Before answering this question, let’s
    understand the problem that CQRS seeks to resolve.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你申请使用分布式架构的应用程序的工作时，你经常会听到关于CQRS的消息，很可能会被问到其使用情况。首先，我们需要理解的是，CQRS不是一个架构风格；它既不是架构也不是架构原则。它只是一个没有广泛使用的模式。那么，CQRS是什么？在回答这个问题之前，让我们了解CQRS试图解决的问题。
- en: 'Traditional monolithic applications typically use a single database to both
    read and write data. This approach can lead to the following challenges as an
    application grows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的单体应用程序通常使用单个数据库来读取和写入数据。随着应用程序的增长，这种方法可能会导致以下挑战：
- en: '**Scaling bottlenecks**: When read traffic spikes, it can impact write performance
    (and vice versa).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展瓶颈**：当读流量激增时，可能会影响写性能（反之亦然）。'
- en: '**Data model mismatch**: Optimal read and write models may differ. Reads might
    benefit from denormalized data for faster retrieval, while writes might require
    a normalized structure for data integrity. This mismatch creates inefficiencies
    or duplication.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据模型不匹配**：最优的读写模型可能不同。读取可能从去规范化数据中受益以实现更快的检索，而写入可能需要规范化结构以保持数据完整性。这种不匹配会导致低效或重复。'
- en: '**Transaction conflicts**: Updates and reads can compete for resources, potentially
    blocking each other or causing inconsistencies (violations of **ACID** (**Atomicity,
    Consistency, Isolation,** **Durability**) principles).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务冲突**：更新和读取可能会竞争资源，可能相互阻塞或导致不一致（违反**ACID**（**原子性，一致性，隔离性，持久性**）原则）。'
- en: '**Optimization challenges**: Optimizing for reads might hinder write performance,
    and vice versa.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化挑战**：优化读取可能会妨碍写性能，反之亦然。'
- en: When we work with monolithic applications, we often use one single data store.
    This means we have multiple read and write instructions in the same database.
    We use the same data store model, and everything is simple when it comes to working
    with only one single storage in terms of development. But is that all? Well, not
    everything is okay when we have only one data store. Depending on our requirements,
    we may need to separate our database into read and write databases.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与单体应用一起工作时，我们通常使用一个单一的数据存储。这意味着我们在同一个数据库中有多个读写指令。我们使用相同的数据存储模型，当只涉及一个单一存储时，开发方面的一切都很简单。但是，这真的是全部吗？好吧，当我们只有一个数据存储时，并不是所有事情都顺利。根据我们的需求，我们可能需要将我们的数据库分成读数据库和写数据库。
- en: Understanding CQRS
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解CQRS
- en: CQRS helps us to separate data stores into read and write data stores. Why?
    One reason is that we need to optimize our read and write operations. Using CQRS,
    we can optimize our read data store to read data effectively. We can also configure
    our schema to optimize reading operations. The same is applicable for writing
    data stores.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS帮助我们将数据存储区分为读取和写入数据存储。为什么？一个原因是我们需要优化我们的读写操作。使用CQRS，我们可以优化我们的读取数据存储以有效地读取数据。我们还可以配置我们的模式以优化读取操作。同样适用于写入数据存储。
- en: When we have separate data storages, depending on loading, we can scale them
    independently. When we have separate data stores for reading and writing, we can
    scale them independently, based on the specific load requirements of each. This
    is particularly useful in applications that experience high demand for read operations.
    By decoupling the read and write operations, we can scale the read data store
    to handle the load without affecting the performance of the write data store,
    or vice versa. This approach allows more efficient resource allocation, ensuring
    that each data store is optimized for its specific role.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有独立的数据存储时，根据负载，我们可以独立扩展它们。当我们有独立的读取和写入数据存储时，我们可以根据每个的具体负载要求独立扩展它们。这在读取操作需求高的应用程序中特别有用。通过解耦读写操作，我们可以扩展读取数据存储以处理负载，而不会影响写入数据存储的性能，反之亦然。这种方法允许更有效的资源分配，确保每个数据存储都针对其特定角色进行了优化。
- en: With CQRS, read and write are separated storages, and we have two different
    data models. We can now focus on optimizing and building them to support only
    one operation – either read or write.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在CQRS中，读取和写入是分离的存储，我们有两个不同的数据模型。现在我们可以专注于优化和构建它们，以支持仅一个操作——要么是读取，要么是写入。
- en: 'In summary, here are the benefits of CQRS:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是CQRS的好处：
- en: '**Improved performance**: Optimized read and write models can significantly
    enhance performance for both read and write operations.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进性能**：优化的读写模型可以显著提高读写操作的性能。'
- en: '**Enhanced scalability**: You can scale read and write models independently
    based on their access patterns. This allows you to handle fluctuating read/write
    loads more effectively.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的可扩展性**：您可以根据其访问模式独立扩展读写模型。这允许您更有效地处理波动性的读写负载。'
- en: '**Flexibility in data modeling**: Each model can be designed for its specific
    purpose, improving overall data management and reducing complexity.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据建模的灵活性**：每个模型都可以根据其特定目的进行设计，从而提高整体数据管理并减少复杂性。'
- en: 'Is CQRS a silver bullet? Of course not. You should consider the following when
    you integrate CQRS into your projects:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS是不是银弹？当然不是。当您将CQRS集成到项目中时，应考虑以下因素：
- en: '**Added complexity**: Implementing CQRS introduces additional complexity compared
    to a single store. Careful design and trade-off analysis are necessary for successful
    implementation.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加复杂性**：与单一存储相比，实现CQRS引入了额外的复杂性。为了成功实施，需要进行仔细的设计和权衡分析。'
- en: '**Data consistency**: Maintaining consistency across read and write models
    requires careful consideration. Strategies such as eventual consistency or materialized
    views can be employed.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据一致性**：在读取和写入模型之间保持一致性需要仔细考虑。可以采用诸如最终一致性或物化视图等策略。'
- en: CQRS is a valuable pattern for applications with *high read/write disparities*
    (e.g., e-commerce with frequent product views and infrequent purchases), *complex
    data models* with different requirements for reads and writes, and scenarios that
    require *independent scaling* of read and write operations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS是一种适用于具有*高读写差异*（例如，具有频繁的产品查看和较少购买的电子商务）的应用程序的有价值模式，具有对读写操作有不同要求的*复杂数据模型*，以及需要*独立扩展*读写操作的场景。
- en: Before adopting CQRS, carefully analyze your application’s needs. While it offers
    significant benefits in specific scenarios, the added complexity might not be
    necessary for simpler applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用CQRS之前，仔细分析您应用程序的需求。虽然它在特定场景中提供了显著的好处，但增加的复杂性可能对于更简单的应用程序来说并不必要。
- en: When discussing CQRS, it is also important to discuss event sourcing. They are
    complementary patterns that work well together, but they address different aspects
    of an application’s architecture.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论CQRS时，讨论事件源也很重要。它们是互补的模式，可以很好地一起工作，但它们解决了应用程序架构的不同方面。
- en: Event sourcing
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件源
- en: '**Event sourcing** is a design pattern to persist data as a sequence of events.
    Instead of storing the current state of an entity (such as a user account), you
    record each action that modifies that entity. This creates an immutable history
    of changes, allowing you to do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件溯源**是一种将数据作为一系列事件持久化的设计模式。你不会存储实体的当前状态（例如用户账户），而是记录每个修改该实体的操作。这创建了一个不可变的历史变更记录，允许你执行以下操作：'
- en: Replay events to rebuild state at any point in time.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回放事件以在任何时间点重建状态。
- en: Gain deep insights into an application’s history for auditing and debugging
    purposes.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解应用程序的历史，以便进行审计和调试。
- en: Simplify data evolution, as new events can be added without modifying existing
    ones.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化数据演变，因为可以添加新事件而无需修改现有事件。
- en: These events represent what happened, not the current state of the data. By
    replaying an event stream, you can reconstruct the state at any point in time.
    Traditional databases in CQRS can be used to write models (i.e., store commands).
    Event sourcing shines on the read model side of CQRS. The event stream from event
    sourcing serves as the source of truth for read models. Read models are materialized
    projections built by replaying relevant events.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件代表已经发生的事情，而不是数据的当前状态。通过回放事件流，你可以在任何时间点重建状态。CQRS中的传统数据库可以用于写入模型（即存储命令）。事件溯源在CQRS的读取模型方面表现出色。事件溯源的事件流作为读取模型的真实来源。读取模型是通过回放相关事件构建的实体化投影。
- en: 'However, it is very important to note that CQRS can be implemented without
    event sourcing. Event sourcing often benefits from CQRS when managing read models,
    as the two patterns work well together in many scenarios:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非常重要的一点是要注意，CQRS可以在不使用事件溯源的情况下实现。事件溯源在管理读取模型时通常受益于CQRS，因为这两种模式在许多场景中都很好地协同工作：
- en: CQRS handles the high volume of reads efficiently by using optimized read models.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS通过使用优化的读取模型来高效地处理大量读取操作。
- en: Event sourcing provides a complete history to build these read models.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源提供了完整的记录来构建这些读取模型。
- en: Updates to an event stream automatically trigger updates in the read models,
    ensuring consistency (although eventual consistency might apply).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件流的更新会自动触发读取模型中的更新，确保一致性（尽管可能适用最终一致性）。
- en: Event sourcing versus event streaming
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源与事件流
- en: Event streaming is not the same as event sourcing, although they are closely
    related and often used together. The key difference is that event streaming is
    a mechanism for transmitting a sequence of events between different parts of a
    system, or even between different systems. Event streaming focuses on the delivery
    of events, ensuring that they are received by interested parties. It can be used
    for various purposes, such as real-time notifications, data pipelines, or triggering
    actions in other microservices.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 事件流与事件溯源不同，尽管它们密切相关且经常一起使用。关键区别在于，事件流是一种在不同系统部分之间或不同系统之间传输一系列事件的机制。事件流侧重于事件的交付，确保它们被感兴趣的各方接收。它可以用于各种目的，例如实时通知、数据管道或触发其他微服务的操作。
- en: Conversely, event sourcing is a data persistence pattern where the entire history
    of changes to an entity is stored as a sequence of events. It focuses on the storage
    and utilization of events as a system’s source of truth. These events are used
    to replay the history and rebuild the current state of data if needed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，事件溯源是一种数据持久化模式，其中实体的整个变更历史都存储为一系列事件。它侧重于事件作为系统真实来源的存储和利用。这些事件用于回放历史并在需要时重建数据的当前状态。
- en: Here’s an analogy for better understanding. Imagine event streaming as a live
    stream – it continuously delivers updates (events) to anyone subscribed. Event
    sourcing is like a detailed log – it keeps a permanent record of all past updates
    (events) for future reference.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个类比来更好地理解。想象一下事件流就像一个直播——它持续地向任何订阅者提供更新（事件）。事件溯源就像一个详细的日志——它保留所有过去更新的永久记录，供将来参考。
- en: But how are these two connected? Event sourcing often leverages event streaming
    to efficiently store and transmit the sequence of events. The event stream from
    event sourcing can be used by other systems or services subscribed to it. Some
    event stores (to be discussed further shortly), which are specialized databases
    for event sourcing, might have built-in functionalities for event streaming. In
    essence, event streaming is a broader concept for data in motion. Event sourcing
    utilizes event streaming to preserve its event history.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但这两者是如何联系起来的呢？事件溯源通常利用事件流来高效地存储和传输事件的序列。事件溯源的事件流可以被订阅了它的其他系统或服务使用。一些事件存储（稍后将进一步讨论），这些是专门为事件溯源设计的事件存储数据库，可能具有内置的事件流功能。本质上，事件流是一个更广泛的概念，用于描述数据在运动中的状态。事件溯源利用事件流来保存其事件历史。
- en: Let’s take a quick look at an event store next.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下事件存储。
- en: Event store
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件存储
- en: 'The other element we need to consider in our CQRS, and event-sourcing ecosystem
    is an **event store**. This is a specialized type of database designed specifically
    to store sequences of events. Unlike traditional relational databases that focus
    on the current state of data, event stores record every change made to an entity
    as a unique event. This creates an immutable history of all actions that have
    occurred, allowing several benefits:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CQRS和事件溯源生态系统中，我们需要考虑的另一个元素是一个**事件存储**。这是一种专门类型的数据库，专门设计用于存储事件的序列。与传统关注数据当前状态的关系型数据库不同，事件存储将每个实体所做的每个更改记录为一个独特的事件。这创建了一个不可变的历史记录，记录了所有已发生的行为，从而带来了以下好处：
- en: '**Auditability and debugging**: You can easily track changes and identify issues
    by reviewing the sequence of events. This provides a detailed log of what happened,
    when, and why.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可审计性和调试**：通过审查事件序列，您可以轻松跟踪更改并识别问题。这提供了关于发生了什么、何时以及为什么的详细日志。'
- en: '**Data evolution**: As your application evolves, new events can be added to
    a store without modifying existing logic. This makes it easier to adapt to changing
    requirements without breaking existing functionality.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据演变**：随着您的应用程序的发展，可以添加新的事件到存储中，而无需修改现有逻辑。这使得适应不断变化的需求而不会破坏现有功能变得更加容易。'
- en: '**Replayability**: By replaying an event stream in a specific order, you can
    reconstruct the state of an entity at any point in time. This is useful for various
    purposes, such as rebuilding materialized views or disaster recovery.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可回放性**：通过以特定顺序回放事件流，您可以在任何时间点重建实体的状态。这对于各种目的都很有用，例如重建物化视图或灾难恢复。'
- en: '**Scalability**: Event stores are often optimized to handle high volumes of
    writes, making them well-suited for event-driven architectures with frequent data
    changes.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：事件存储通常优化以处理大量写入操作，这使得它们非常适合具有频繁数据更改的事件驱动架构。'
- en: In essence, an event store not only captures a complete and immutable history
    of changes but also enhances flexibility and scalability. By preserving every
    event that modifies the state of an entity, the event store provides a foundation
    for reliable audit trails, effortless adaptation to new business requirements,
    and the ability to reconstruct the state as needed. These features make it a vital
    component in modern architectures, especially where high data throughput and accountability
    are important.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，事件存储不仅捕获了更改的完整且不可变的历史记录，而且还增强了灵活性和可扩展性。通过保存修改实体状态的每个事件，事件存储为可靠的审计跟踪、轻松适应新的业务需求以及按需重建状态提供了基础。这些功能使其成为现代架构中不可或缺的组件，尤其是在高数据吞吐量和问责制重要的领域。
- en: 'Here’s how event stores typically work:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事件存储通常的工作方式：
- en: '**Events**: Each action or change to an entity is represented as an event.
    These events contain relevant data about the change, such as timestamps, user
    IDs, and the specific modifications made.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：每个对实体的操作或更改都表示为一个事件。这些事件包含有关更改的相关数据，例如时间戳、用户ID和特定的修改。'
- en: '**Append-only**: Events are stored in an append-only fashion, meaning they
    cannot be modified or deleted after being added. This ensures the immutability
    of the event history.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只追加**：事件以只追加的方式存储，这意味着一旦添加后，它们不能被修改或删除。这确保了事件历史的不可变性。'
- en: '**Event stream**: Each entity typically has its event stream, which is a sequence
    of all events related to that entity.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件流**：每个实体通常都有自己的事件流，这是一系列与该实体相关的所有事件。'
- en: Event stores typically work by representing each action or change to an entity
    as an event. These events capture relevant information about the change, such
    as the time it occurred, the user responsible, and the specific details of the
    modification. Once an event is recorded, it is stored in an append-only fashion,
    meaning that it cannot be altered or deleted after being added. This ensures that
    the event history remains immutable, providing a reliable audit trail. Additionally,
    each entity is associated with its own event stream, which is a chronological
    sequence of all the events related to that specific entity. This stream allows
    you to trace the life cycle of the entity from its initial state to its current
    form, based entirely on the sequence of events recorded in a store.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 事件存储通常通过将每个实体或更改表示为事件来工作。这些事件捕获有关更改的相关信息，例如发生时间、负责的用户以及修改的特定细节。一旦事件被记录，它将以追加方式存储，这意味着一旦添加后就不能被更改或删除。这确保了事件历史保持不可变，提供了一个可靠的审计跟踪。此外，每个实体都与自己的事件流相关联，这是一个与该特定实体相关的所有事件的按时间顺序序列。这个流允许你根据存储中记录的事件序列，从实体的初始状态追踪到其当前形式。
- en: 'Event stores offer the following significant benefits that make them highly
    suitable for modern architectures, especially those driven by events:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 事件存储提供了以下显著的优点，使其非常适合现代架构，特别是那些由事件驱动的架构：
- en: One of the key advantages is the creation of an **immutable history**. Every
    change to a system is stored as an event, ensuring that past actions cannot be
    tampered with or altered. This creates a reliable, tamper-proof audit trail that
    allows you to track the complete life cycle of an entity, making it particularly
    useful for debugging, compliance, and historical analysis.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个关键优势是创建一个**不可变历史记录**。系统中的每一次更改都以事件的形式存储，确保过去的行为不会被篡改或更改。这创建了一个可靠、防篡改的审计跟踪，允许你跟踪实体的完整生命周期，这对于调试、合规性和历史分析特别有用。
- en: In terms of **scalability**, event stores are designed to handle high volumes
    of writes efficiently. Since events are appended to a store rather than modifying
    existing records, they can support applications with frequent data changes and
    ensure that performance remains consistent, even as the volume of data grows.
    This makes them an excellent choice for systems that need to process large amounts
    of data or handle real-time event streams.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**可伸缩性**方面，事件存储被设计成高效地处理大量写入操作。由于事件是追加到存储中而不是修改现有记录，因此它们可以支持频繁数据变更的应用程序，并确保性能保持一致，即使数据量增长。这使得它们成为需要处理大量数据或处理实时事件流的系统的绝佳选择。
- en: Another important benefit is **data evolution**. As applications evolve and
    new business requirements emerge, event stores allow you to adapt without disrupting
    existing functionality. New events can be added to reflect changes in a system,
    while the old event data remains intact, preserving the full history. This flexibility
    simplifies the process of evolving your application over time while maintaining
    backward compatibility with previous versions of the data.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个重要的好处是**数据演化**。随着应用程序的演变和新业务需求的产生，事件存储允许你在不影响现有功能的情况下进行适应。可以添加新事件来反映系统中的变化，同时保留旧事件数据，从而保留完整的历史记录。这种灵活性简化了随着时间的推移演化应用程序的过程，同时保持与先前数据版本的向后兼容性。
- en: '**Replayability** is another important feature of event stores. By replaying
    the event stream, you can reconstruct the state of an entity at any point in time.
    This capability is invaluable for disaster recovery, rebuilding materialized views,
    or even simulating past system states for analysis or testing. It gives you the
    power to revisit the past and see exactly how an entity reached its current state,
    something that’s not possible with traditional databases that only store the latest
    state of data.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重放性**是事件存储的另一个重要特性。通过重放事件流，你可以重建实体在任何时间点的状态。这种能力对于灾难恢复、重建物化视图，甚至模拟过去系统状态以进行分析或测试非常有价值。它赋予你回顾过去并确切了解实体如何达到当前状态的能力，这是传统数据库所无法实现的，因为传统数据库只存储数据的最新状态。'
- en: These benefits make event stores a powerful tool for building scalable, flexible,
    and resilient systems, particularly in event-driven architectures where maintaining
    a detailed history of changes is critical.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些好处使事件存储成为构建可伸缩、灵活和健壮系统的强大工具，尤其是在事件驱动架构中，维护更改的详细历史记录至关重要。
- en: 'Here are the challenges of using event stores:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用事件存储的挑战：
- en: '**Querying**: Traditional relational database querying techniques might not
    be directly applicable. Designing efficient queries on event streams can require
    different approaches.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：传统的数据库查询技术可能不直接适用。在事件流上设计高效的查询可能需要不同的方法。'
- en: '**Increased complexity**: Event stores require a different data management
    mindset compared to traditional databases.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性增加**：与传统的数据库相比，事件存储需要不同的数据管理思维。'
- en: 'Finally, let’s look at some popular event store options, including the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看一些流行的事件存储选项，包括以下内容：
- en: '**EventStoreDB**: A leading dedicated event store solution.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EventStoreDB**：领先的专用事件存储解决方案。'
- en: '**Apache Kafka**: A distributed streaming platform that can be used for event
    storage.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Kafka**：一个可以用于事件存储的分布式流平台。'
- en: '**Traditional databases (with modifications)**: Relational databases such as
    PostgreSQL can be configured for append-only functionality to act as basic event
    stores.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传统数据库（经过修改）**：例如 PostgreSQL 这样的关系型数据库可以被配置为仅追加功能，以作为基本的事件存储。'
- en: In conclusion, event stores are a valuable tool for building event-driven architectures
    and applications that require a detailed history of changes, data evolution capabilities,
    and resilience.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，事件存储库是构建事件驱动架构和需要详细变更历史、数据演变能力和弹性的应用的宝贵工具。
- en: That’s enough theory; it’s time to put CQRS and event sourcing into practice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够了；现在是时候将 CQRS 和事件溯源付诸实践了。
- en: Implementing CQRS and event sourcing
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 CQRS 和事件溯源
- en: 'Let’s create a simple application that uses CQRS and event-sourcing. Our application
    will allow us to attach multiple payment mechanisms to our account. It will be
    possible to register payment mechanisms to accounts, disable them, and enable
    them. We will use NestJS, but you can use any other framework. In `Ch11`, in the
    `CQRS_EventSourcing` folder, we have the `cqrs_app` folder in our Git repository.
    You can download it to properly follow throughout the chapter, but the other option
    is to implement everything from scratch, as we plan to do here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的应用程序，该程序使用 CQRS 和事件溯源。我们的应用程序将允许我们将多个支付机制附加到我们的账户上。我们将能够注册支付机制到账户中，禁用它们，并启用它们。我们将使用
    NestJS，但你也可以使用任何其他框架。在 `Ch11` 的 `CQRS_EventSourcing` 文件夹中，我们的 Git 仓库中有 `cqrs_app`
    文件夹。你可以下载它以正确地跟随本章，但另一种选择是从头开始实现一切，正如我们在这里计划做的那样：
- en: Create any folder and open your favorite IDE. Load the empty folder to your
    IDE, and from the command line, type `npx @nestjs/cli new cqrs_app` or `npm i
    -g @nestjs/cli` with `nest` `new cqrs_app`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建任何文件夹并打开你喜欢的 IDE。将空文件夹加载到你的 IDE 中，然后在命令行中输入 `npx @nestjs/cli new cqrs_app`
    或 `npm i -g @nestjs/cli` 并使用 `nest` `new cqrs_app`。
- en: 'This should install the NestJS template in the folder. Now, let’s install the
    required packages:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该在文件夹中安装 NestJS 模板。现在，让我们安装所需的包：
- en: '[PRE11]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'services:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'services:'
- en: 'eventstore.db:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'eventstore.db:'
- en: 'image: eventstore/eventstore:24.2.0-jammy'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'image: eventstore/eventstore:24.2.0-jammy'
- en: 'environment:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'environment:'
- en: '- EVENTSTORE_CLUSTER_SIZE=1'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- EVENTSTORE_CLUSTER_SIZE=1'
- en: '- EVENTSTORE_RUN_PROJECTIONS=All'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- EVENTSTORE_RUN_PROJECTIONS=All'
- en: '- EVENTSTORE_START_STANDARD_PROJECTIONS=true'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- EVENTSTORE_START_STANDARD_PROJECTIONS=true'
- en: '- EVENTSTORE_HTTP_PORT=2113'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- EVENTSTORE_HTTP_PORT=2113'
- en: '- EVENTSTORE_INSECURE=true'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- EVENTSTORE_INSECURE=true'
- en: '- EVENTSTORE_ENABLE_ATOM_PUB_OVER_HTTP=true'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- EVENTSTORE_ENABLE_ATOM_PUB_OVER_HTTP=true'
- en: 'ports:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'ports:'
- en: '- ''2113:2113'''
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- ''2113:2113'''
- en: 'volumes:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'volumes:'
- en: '- type: volume'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- type: volume'
- en: 'source: eventstore-volume-data'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'source: eventstore-volume-data'
- en: 'target: /var/lib/eventstore'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'target: /var/lib/eventstore'
- en: '- type: volume'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- type: volume'
- en: 'source: eventstore-volume-logs'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'source: eventstore-volume-logs'
- en: 'target: /var/log/eventstore'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'target: /var/log/eventstore'
- en: 'volumes:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'volumes:'
- en: 'eventstore-volume-data:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'eventstore-volume-data:'
- en: eventstore.db. It uses the eventstore/eventstore:24.2.0-jammy image, which is
    a specific version of EventStoreDB. You can use any other versions with a bit
    different configuration. The service runs with several environment variables to
    configure EventStore, including starting all projections and enabling insecure
    connections (which is not recommended for production). The service maps port 2113
    on the host machine to port 2113 within the container, allowing access to the
    EventStoreDB instance. Finally, it defines persistent volumes for data and logs
    to ensure that information is preserved even if the container restarts.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: eventstore.db 使用 eventstore/eventstore:24.2.0-jammy 镜像，这是 EventStoreDB 的一个特定版本。你可以使用其他版本，只需进行一些不同的配置。该服务使用几个环境变量来配置
    EventStore，包括启动所有投影和启用不安全连接（这不建议在生产环境中使用）。该服务将主机上的端口 2113 映射到容器内的端口 2113，允许访问
    EventStoreDB 实例。最后，它定义了用于数据和日志的持久卷，以确保即使在容器重启的情况下信息也能得到保留。
- en: '[PRE12]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run `docker-compose up -d` command to run it. After a successful run, you can
    navigate to `localhost:2213` for the `EventStoreDB` dashboard.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker-compose up -d`命令来运行它。运行成功后，您可以导航到`localhost:2213`以访问`EventStoreDB`仪表板。
- en: '![Figure 11.7: The event store dashboard](img/B09148_11_007.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7：事件存储仪表板](img/B09148_11_007.jpg)'
- en: 'Figure 11.7: The event store dashboard'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：事件存储仪表板
- en: 'Now, in our `src` folder, create an `eventstore.ts` file with the following
    content:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的`src`文件夹中，创建一个`eventstore.ts`文件，内容如下：
- en: '[PRE13]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The provided `connect` function attempts to read a single event (`maxCount:
    1`) from the beginning (`direction: FORWARDS, fromPosition: START`) of the event
    stream. Any errors encountered during this read operation are caught and logged
    to the console. Finally, both the client connection and the connect function are
    exported for potential use in other parts of the code.'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '提供的`connect`函数尝试从事件流的开始（`direction: FORWARDS, fromPosition: START`）读取单个事件（`maxCount:
    1`）。在读取操作过程中遇到的任何错误都会被捕获并记录到控制台。最后，客户端连接和`connect`函数都被导出，以便在其他代码部分中潜在使用。'
- en: 'We will store account-based elements such as events, commands, and aggregates
    together. Storing account-based elements such as events, commands, and aggregates
    together helps maintain consistency and clarity within the domain model. These
    elements are tightly interconnected commands that initiate actions that change
    the state of an aggregate, and these changes are captured as events. Keeping them
    together simplifies the logical flow of operations, ensuring that all related
    components are easily accessible and organized. That is why we need to create
    a folder called `account` under `src`. After creating a folder, create a new file
    called `account.commands.ts` under `src` / `account` with the following content:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将存储基于账户的元素，如事件、命令和聚合体，并将它们一起存储。将基于账户的元素（如事件、命令和聚合体）一起存储有助于在领域模型内保持一致性和清晰性。这些元素是紧密相连的命令，它们启动改变聚合体状态的动作，这些变化被捕获为事件。将它们放在一起简化了操作的逻辑流程，确保所有相关组件都易于访问和组织。这就是为什么我们需要在`src`下创建一个名为`account`的文件夹。创建文件夹后，在`src`
    / `account`下创建一个名为`account.commands.ts`的新文件，内容如下：
- en: '[PRE14]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code defines three commands for an account unit system in a NestJS application,
    using CQRS:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码定义了在NestJS应用程序的账户单元系统中使用CQRS的三个命令：
- en: '`RegisterAccountUnitCommand`: This command takes an `aggregateId` (a unique
    identifier for the account unit) and a `paymentmechanismCount` (the number of
    payment methods associated). It’s used to create a new account unit.'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegisterAccountUnitCommand`：此命令接受一个`aggregateId`（账户单元的唯一标识符）和一个`paymentmechanismCount`（关联的支付方式数量）。它用于创建一个新的账户单元。'
- en: '`DisableAccountUnitCommand`: This command simply takes `aggregateId` and presumably
    disables the account unit.'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisableAccountUnitCommand`：此命令仅接受`aggregateId`，并可能禁用账户单元。'
- en: '`EnableAccountUnitCommand`: Similar to the disabling command, this takes `aggregateId`
    and typically reenables a previously disabled account unit.'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnableAccountUnitCommand`：与禁用命令类似，它接受`aggregateId`并通常重新启用之前已禁用的账户单元。'
- en: These commands represent different actions that users might take on account
    units, and they follow the CQRS pattern by focusing on modifying the system state
    (i.e., creating, disabling, or enabling).
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些命令代表了用户可能在账户单元上执行的不同操作，并且通过专注于修改系统状态（即创建、禁用或启用）来遵循CQRS模式。
- en: Instead of calling the required functionalities directly, we will encapsulate
    them using commands. Our commands work based on a command design pattern. Using
    a command pattern, it is possible to encapsulate every action/request as an object.
    This encapsulation brings a lot of additional features, depending on the context;
    you can implement late execution, redo, undo, transactional operations, and so
    on. The `ICommand` interface helps us to achieve this.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不会直接调用所需的功能，而是使用命令来封装它们。我们的命令基于命令设计模式。使用命令模式，可以将每个动作/请求封装为一个对象。这种封装带来了许多额外的功能，具体取决于上下文；可以实现延迟执行、重做、撤销、事务操作等。`ICommand`接口帮助我们实现这一点。
- en: 'The other contracts we need to implement to cover CQRS with event sourcing
    are events. In the `src/account` folder, create a new file called `account.events.ts`
    with the following content:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要实现其他合约来覆盖使用事件源进行CQRS的事件。在`src/account`文件夹中，创建一个名为`account.events.ts`的新文件，内容如下：
- en: '[PRE15]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In CQRS, events are used to communicate changes that occur in a system. By
    inheriting from `IEvent` (provided by the `@nestjs/cqrs` package), we ensure that
    `AccountEvent` and its subclasses conform to the expected event structure within
    the CQRS framework. This allows the framework to handle these events appropriately,
    such as publishing them to an event bus or persisting them for eventual consistency:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CQRS 中，事件用于传达系统发生的变化。通过从 `@nestjs/cqrs` 包提供的 `IEvent` 继承，我们确保 `AccountEvent`
    及其子类符合 CQRS 框架中预期的事件结构。这允许框架适当地处理这些事件，例如将它们发布到事件总线或持久化以实现最终一致性：
- en: '`AccountEvent` (the base class): Acts as a base for all account events. It
    inherits from `IEvent` (from `@nestjs/cqrs`) and holds common properties such
    as `aggregateId` and `paymentmechanismCount`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccountEvent`（基类）：作为所有账户事件的基类。它继承自 `IEvent`（来自 `@nestjs/cqrs`）并持有常见的属性，如 `aggregateId`
    和 `paymentmechanismCount`。'
- en: '`AccountRegisteredEvent` inherit from `AccountEvent`, customizing it for specific
    actions (i.e., registration, disabling, and enabling) with potentially additional
    properties if needed.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccountRegisteredEvent` 继承自 `AccountEvent`，针对特定操作（例如注册、禁用和启用）进行定制，如果需要，可能包含额外的属性。'
- en: This approach promotes code reuse and keeps event data consistent across different
    account unit events.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法促进了代码的重用，并保持了不同账户单元事件的事件数据一致性。
- en: We have specified our commands and events, but we haven’t used them. The purpose
    of the `account.aggregate.ts` file under `src` | `account` is exactly for that.
    We need first to specify our command handler. If you have a command, there should
    be a handler to handle it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定了我们的命令和事件，但尚未使用它们。`src` | `account` 目录下的 `account.aggregate.ts` 文件的目的正是如此。我们首先需要指定我们的命令处理器。如果你有一个命令，就应该有一个处理器来处理它。
- en: Commands and handlers
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令和处理器
- en: Commands represent the actions that users or external systems want to perform
    on the domain model. They encapsulate the data needed to execute the action. In
    our example, `RegisterAccountUnitCommand`, `DisableAccountUnitCommand`, and `EnableAccountUnitCommand`
    are all commands that represent actions on account units.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 命令代表用户或外部系统想要在领域模型上执行的操作。它们封装了执行操作所需的数据。在我们的例子中，`RegisterAccountUnitCommand`、`DisableAccountUnitCommand`
    和 `EnableAccountUnitCommand` 都是代表对账户单元执行操作的命令。
- en: Commands are typically defined as interfaces or classes. They often include
    properties that specify an action and any necessary data (e.g., `aggregateId`
    in our commands). Conversely, **command handlers** (also referred to as handlers
    in this chapter) are responsible for receiving commands, executing the necessary
    logic to modify the system state, and potentially producing events that reflect
    the changes. They act as the bridge between commands and the domain model.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 命令通常定义为接口或类。它们通常包括指定操作和任何必要数据的属性（例如我们命令中的 `aggregateId`）。相反，**命令处理器**（在本章中也称为处理器）负责接收命令，执行必要的逻辑以修改系统状态，并可能产生反映这些变化的事件。它们在命令和领域模型之间充当桥梁。
- en: Each command typically has a corresponding command handler. The handler receives
    the command, interacts with the domain logic (i.e., aggregate root, entities and
    services), and updates the system state accordingly. It might also trigger the
    creation of events to communicate the changes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令通常都有一个相应的命令处理器。处理器接收命令，与领域逻辑（即聚合根、实体和服务）交互，并相应地更新系统状态。它还可能触发事件的创建，以传达这些变化。
- en: 'Our `account.aggregate.ts` contains `AggregateRoot`, `CommandHandler`, and
    `EventHandler` implementations. First, we will look at the command handler:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `account.aggregate.ts` 包含 `AggregateRoot`、`CommandHandler` 和 `EventHandler`
    的实现。首先，我们将查看命令处理器：
- en: '[PRE16]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This NestJS code defines a command handler to register account units using CQRS.
    The `@CommandHandler` decorator associates it with the `RegisterAccountUnitCommand`.
    It injects `EventPublisher` (for event sourcing). In the `execute` method, it
    creates an `AccountAggregate` instance, calls its `registerAccount` method with
    command data, and potentially commits the changes. This demonstrates processing
    a command by interacting with the domain model and potentially publishing events.
    We will discuss `AggregateRoot` a bit later. For now, we will just focus on the
    base idea behind the commands.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这段NestJS代码定义了一个命令处理器，用于使用CQRS注册账户单元。`@CommandHandler`装饰器将其与`RegisterAccountUnitCommand`关联。它注入`EventPublisher`（用于事件存储）。在`execute`方法中，它创建一个`AccountAggregate`实例，使用命令数据调用其`registerAccount`方法，并可能提交更改。这展示了通过与领域模型交互并可能发布事件来处理命令。我们稍后会讨论`AggregateRoot`。现在，我们只需关注命令背后的基本思想。
- en: 'We have two more commands that have approximately the same implementation,
    with different method calls:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个具有类似实现但方法调用不同的命令：
- en: '[PRE17]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`DisableAccountUnitHandler` retrieves the `AccountAggregate` instance associated
    with the `command.aggregateId`, using `AccountAggregate.loadAggregate`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisableAccountUnitHandler`使用`AccountAggregate.loadAggregate`检索与`command.aggregateId`关联的`AccountAggregate`实例。'
- en: It verifies whether the account is already disabled, using `!aggregate.disabled`.
    If not disabled, it calls `aggregate.disableAccount` to perform the disabling
    logic and then `aggregate.commit` to potentially persist the change as an event.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`!aggregate.disabled`验证账户是否已经被禁用。如果没有被禁用，它调用`aggregate.disableAccount`来执行禁用逻辑，然后调用`aggregate.commit`以将更改作为事件持久化。
- en: 'This handler ensures that an account unit is only disabled once and triggers
    event publication (if applicable) upon successful disabling. The last handler
    is `EnableAccountHandler`, which is a counterpart of `DisableAccountUnitHandler`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理器确保账户单元只被禁用一次，并在成功禁用后触发事件发布（如果适用）。最后一个处理器是`EnableAccountHandler`，它是`DisableAccountUnitHandler`的对立面：
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’re done with handlers. It is time to explore `IEventHandler<T>` interface
    from the `@nestjs/cqrs` package. These handlers respond to specific domain events
    that are emitted by the aggregate.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了处理器。现在是时候探索`@nestjs/cqrs`包中的`IEventHandler<T>`接口了。这些处理器响应由聚合体发出的特定领域事件。
- en: An event handler in the context of CQRS is responsible for handling the domain
    events that occur within a system. The events represent significant state changes
    within your aggregates, and the event handlers respond to these changes by performing
    side effects or additional logic outside the aggregate itself.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在CQRS的上下文中，事件处理器负责处理系统内部发生的领域事件。这些事件代表你的聚合体中的重大状态变化，事件处理器通过执行聚合体本身之外的效果或附加逻辑来响应这些变化。
- en: 'In the same file (`account.aggregate.ts`), we have three event handlers (`AccountRegisteredEventHandler`,
    `AccountDisabledEventHandler`, and `AccountEnabledEventHandler`):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件（`account.aggregate.ts`）中，我们有三个事件处理器（`AccountRegisteredEventHandler`、`AccountDisabledEventHandler`和`AccountEnabledEventHandler`）：
- en: '[PRE19]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All event handlers have the same contract, and that is why we use the `AccountEvent`
    interface. It then implements a function, `handleAccountEvent`, that takes an
    event type and an event object as arguments. The function prepares data in a JSON-compatible
    format and uses an event store service to persist the event information, under
    a stream specific to the involved account aggregate.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件处理器都有相同的契约，这就是我们使用`AccountEvent`接口的原因。它实现了一个函数，名为`handleAccountEvent`，该函数接受一个事件类型和一个事件对象作为参数。该函数以JSON兼容的格式准备数据，并使用事件存储服务来持久化事件信息，这些信息属于涉及到的账户聚合的特定流。
- en: 'Now, let’s take a look at concrete event handler implementations:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看具体的事件处理器实现：
- en: '[PRE20]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this code, we define event handlers for account registration, disabling,
    and enabling. When an account is registered, the `AccountRegisteredEventHandler`
    triggers logic related to account creation. Similarly, `AccountDisabledEventHandler`
    and `AccountEnabledEventHandler` handle account disabling and enabling events,
    respectively. These handlers leverage the `handleAccountEvent` function for centralized
    event processing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了用于账户注册、禁用和启用的事件处理器。当一个账户被注册时，`AccountRegisteredEventHandler`触发与账户创建相关的逻辑。同样，`AccountDisabledEventHandler`和`AccountEnabledEventHandler`分别处理账户禁用和启用事件。这些处理器利用`handleAccountEvent`函数进行集中式事件处理。
- en: That is great, but how do these commands interact with events? To demonstrate
    this, we need to discuss one more concept, called an aggregate root, a popular
    pattern in **Domain-Driven** **Design** (**DDD**).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 那是很好的，但这些命令如何与事件交互呢？为了演示这一点，我们需要讨论另一个概念，称为聚合根，这是领域驱动设计（DDD）中的一种流行模式。
- en: Implementing an aggregate root
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现聚合根
- en: In DDD, an **aggregate root** is a fundamental concept for modeling complex
    domains. It acts as the central entity within a cluster of related objects, also
    known as an **aggregate**.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DDD 中，**聚合根**是一个用于建模复杂领域的根本概念。它作为相关对象簇（也称为**聚合**）中的中心实体。
- en: An aggregate root encapsulates the core data and logic associated with a particular
    domain concept. In our example, `AccountAggregate` will hold all the essential
    information about an account (i.e., ID, payment mechanism count, and disabled
    status). This centralizes the account’s state and promotes data integrity.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个聚合根封装了与特定领域概念相关的核心数据和逻辑。在我们的例子中，`AccountAggregate` 将包含关于账户的所有必要信息（即，ID、支付机制计数和禁用状态）。这集中了账户的状态并促进了数据完整性。
- en: An aggregate root plays a crucial role in event sourcing, a technique for persisting
    domain object changes as a sequence of events. In our code, `AccountAggregate`
    methods such as `registerAccount` apply events to the aggregate, reflecting state
    changes. By reconstructing the state from the event stream, the aggregate root
    becomes the central source of truth for the account’s history.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合根在事件源技术中扮演着至关重要的角色，该技术将领域对象的变化作为一系列事件进行持久化。在我们的代码中，`AccountAggregate` 的方法，如
    `registerAccount`，将事件应用到聚合中，反映状态变化。通过从事件流中重建状态，聚合根成为账户历史的中心真相来源。
- en: An aggregate root defines the transactional boundaries within our domain. Within
    an aggregate, changes to the state of all related entities (including the root
    itself) must happen atomically. This ensures data consistency within the aggregate.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合根定义了我们领域内的交易边界。在一个聚合内，所有相关实体（包括根本身）的状态更改必须原子性地发生。这确保了聚合内的数据一致性。
- en: An aggregate root also serves as the sole entry point for external interactions
    with the aggregate. This means other parts of your application (or other aggregates)
    should interact with the domain through the aggregate root’s methods. This promotes
    loose coupling and simplifies reasoning about domain logic.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合根还作为外部与聚合交互的唯一入口点。这意味着应用程序的其他部分（或其他聚合）应通过聚合根的方法与领域交互。这促进了松散耦合并简化了对领域逻辑的推理。
- en: Aggregate roots promote data consistency and integrity by centralizing state
    management and defining transactional boundaries. They simplify domain logic by
    providing a clear entry point for interactions. They also improve code maintainability
    by encapsulating related entities and their behavior.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合根通过集中状态管理和定义事务边界来促进数据一致性和完整性。它们通过提供一个清晰的交互入口来简化领域逻辑。它们还通过封装相关实体及其行为来提高代码的可维护性。
- en: 'By effectively utilizing aggregate roots in DDD, we can build robust and maintainable
    domain models that accurately reflect your business processes. Now, let’s see
    how it is possible to rebuild the state of `AccountAggregate` by reading its event
    stream from the event store:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有效地利用 DDD 中的聚合根，我们可以构建健壮且可维护的领域模型，这些模型准确地反映了您的业务流程。现在，让我们看看如何通过从事件存储中读取其事件流来重建
    `AccountAggregate` 的状态：
- en: '[PRE21]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This NestJS code defines an asynchronous function named `loadAggregate` that
    takes an aggregate ID as input. It retrieves a `stream` of events related to that
    ID from the event store. The function then iterates through each event and applies
    the changes it describes to an `AccountAggregate` object. There are cases for
    handling different event types, such as `AccountUnitCreated`, `AccountUnitDisabled`,
    and `AccountUnitEnabled`. If an event type isn’t recognized, it’s skipped. If
    there are errors processing an event, it logs an error message but keeps iterating.
    Finally, the function returns the populated `AccountAggregate` object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 NestJS 代码定义了一个名为 `loadAggregate` 的异步函数，它接受一个聚合 ID 作为输入。它从事件存储中检索与该 ID 相关的事件
    `stream`。然后该函数遍历每个事件，并将它描述的更改应用到 `AccountAggregate` 对象上。有处理不同事件类型的情况，例如 `AccountUnitCreated`、`AccountUnitDisabled`
    和 `AccountUnitEnabled`。如果事件类型不被识别，则跳过。如果处理事件时出现错误，它记录错误消息但继续迭代。最后，该函数返回填充的 `AccountAggregate`
    对象。
- en: 'Download our Git repository for a more complete example of implementing an
    aggregate root. Here is a snippet from an aggregate root that handles the operations:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下载我们的Git仓库以获取实现聚合根的更完整示例。以下是处理操作的聚合根片段：
- en: '[PRE22]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you might guess, commands interact with events using an aggregate root, and
    the latter encapsulates the logic that triggers events.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，命令通过聚合根与事件交互，后者封装了触发事件的逻辑。
- en: Implementing projection
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现投影
- en: In CQRS and event sourcing architectures, `Account Created` or `Account Disabled`).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在CQRS和事件源架构中，`Account Created`或`Account Disabled`）。
- en: Projections are like the projection booth in a movie theater. They take the
    event stream (the film reel) and *project* it into a specific format, suitable
    for reading. This format, called a **read model**, is optimized to query data
    efficiently.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 投影就像电影院中的放映室。它们将事件流（电影胶片）*投影*到特定格式，适合读取。这种格式称为**读取模型**，它针对高效查询数据进行了优化。
- en: 'With that, let’s understand why projections are important:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们了解为什么投影很重要：
- en: '**Read efficiency**: Projections help rebuild the entire system state from
    the event stream, as doing so for every read query would be slow. Projections
    pre-process the event stream, creating a separate, optimized data structure for
    frequently accessed information.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取效率**：投影有助于从事件流中重建整个系统状态，因为为每个读取查询这样做会非常慢。投影预先处理事件流，为频繁访问的信息创建一个单独的、优化的数据结构。'
- en: '**Flexibility**: We can create multiple projections tailored to different reading
    needs with projections. One projection might focus on account details, while another
    might analyze purchase history.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：我们可以使用投影创建多个针对不同读取需求的投影。一个投影可能专注于账户详情，而另一个可能分析购买历史。'
- en: 'Next, let’s see how projections work:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看投影是如何工作的：
- en: '**Event listeners**: Projections act as event listeners, subscribing to the
    event stream.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件监听器**：投影充当事件监听器，订阅事件流。'
- en: '**Processing events**: As new events arrive, a projection processes them one
    by one, updating its internal read model accordingly.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理事件**：随着新事件的到来，投影逐个处理它们，并相应地更新其内部读取模型。'
- en: '**Read model access**: When a read query arrives, a system retrieves the relevant
    data from a projection’s read model instead of the entire event stream.'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**读取模型访问**：当读取查询到达时，系统从投影的读取模型而不是整个事件流中检索相关数据。'
- en: 'Projections are not a replacement for an event store. The event store remains
    the single source of truth for all historical events. Projections simply offer
    a way to efficiently access specific data from that history. Having said that,
    let’s look at some of the benefits of projections:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 投影不是事件存储的替代品。事件存储仍然是所有历史事件的单一真相来源。投影只是提供了一种从该历史中高效访问特定数据的方法。话虽如此，让我们看看投影的一些好处：
- en: '**Faster reads**: Queries run against read models are significantly faster
    than replaying an entire event stream.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快地读取**：针对读取模型的查询比重新播放整个事件流要快得多。'
- en: '**Scalability**: Projections can be scaled independently to handle increasing
    read traffic.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：投影可以独立扩展以处理增加的读取流量。'
- en: '**Flexibility**: Different projections cater to diverse read needs without
    impacting write performance.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：不同的投影满足不同的读取需求，而不会影响写入性能。'
- en: We plan to implement a simple projection that demonstrates the usage of projection
    in CQRS and event sourcing architectures.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划实现一个简单的投影，以展示在CQRS和事件源架构中使用投影的用法。
- en: 'Under the `src` /`paymentmechanism` folder, create a `paymentmechanism-total.projection.ts`
    file with the following functionalities:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src` /`paymentmechanism`文件夹下，创建一个`paymentmechanism-total.projection.ts`文件，具有以下功能：
- en: '[PRE23]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code defines an event handler class named `PaymentMechanismProjection`
    in a CQRS architecture with event sourcing. It listens for three specific events
    related to account management:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了一个名为`PaymentMechanismProjection`的事件处理类，在CQRS架构和事件源中。它监听与账户管理相关的三个特定事件：
- en: '`AccountRegisteredEvent`: Triggers when a new account is created.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccountRegisteredEvent`：当创建新账户时触发。'
- en: '`AccountDisabledEvent`: Triggers when an account is deactivated.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccountDisabledEvent`：当账户被停用时触发。'
- en: '`AccountEnabledEvent`: Triggers when a deactivated account is reactivated.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AccountEnabledEvent`：当停用的账户被重新激活时触发。'
- en: The class keeps track of the total number of payment mechanisms (`currentPayment`
    **MechanismTotal**), but its initial value is zero.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 该类跟踪支付机制的总数（`currentPayment` **MechanismTotal**），但其初始值为零。
- en: 'The `handle` method is the core functionality. It checks the type of the incoming
    event and calls a specific handler function, based on the event type:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle` 方法是核心功能。它检查传入事件的类型，并根据事件类型调用特定的处理函数：'
- en: '`handleAccountRegistered`: Handles `AccountRegisteredEvent` by incrementing
    `currentPaymentMechanismTotal`, based on information in the event data.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleAccountRegistered`：通过根据事件数据中的信息递增 `currentPaymentMechanismTotal` 来处理
    `AccountRegisteredEvent`。'
- en: '`handleAccountDisabled`: Handles `AccountDisabledEvent` and decrements `currentPaymentMechanismTotal`.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleAccountDisabled`：处理 `AccountDisabledEvent` 并递减 `currentPaymentMechanismTotal`。'
- en: '`handleAccountEnabled`: Handles the `AccountEnabledEvent` and applies the opposite
    operation of `handleAccountDisabled`.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleAccountEnabled`：处理 `AccountEnabledEvent` 并执行 `handleAccountDisabled`
    的相反操作。'
- en: 'This is a simplified example, but it demonstrates how an event handler projection
    can listen for specific events and update its internal state accordingly, maintaining
    a view of the data optimized for a particular purpose (e.g., tracking total payment
    mechanisms). Here are our detailed handler methods in this class:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的例子，但它展示了事件处理程序投影如何监听特定事件并根据相应的事件数据更新其内部状态，保持对数据的视图优化，以适应特定目的（例如，跟踪总支付机制）。以下是这个类中我们的详细处理方法：
- en: '[PRE24]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our handlers simply interact with `currentPaymentMechanismTotal` and build logic
    around it. The idea is simple, but you can implement more complex logic based
    on this knowledge.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理程序简单地与 `currentPaymentMechanismTotal` 交互，并围绕它构建逻辑。这个想法很简单，但你可以根据这个知识实现更复杂的逻辑。
- en: Implementing API functionalities
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现API功能
- en: We use controllers as an entry point to our request flow. In a classical flow,
    controllers accept requests and forward them to the related services. When we
    apply CQRS and event sourcing, we usually use the same controllers, but instead
    of specifying direct services, we apply a command pattern to provide commands
    and their handlers. Controllers serve as the intermediary between a client and
    the backend logic, determining how an application should respond to various requests.
    Controllers map specific routes to corresponding methods that contain business
    logic. By organizing request handling within controllers, the application maintains
    a clear separation of concerns, making it more structured, scalable, and easier
    to manage.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用控制器作为请求流程的入口点。在经典流程中，控制器接受请求并将它们转发到相关的服务。当我们应用 CQRS 和事件溯源时，我们通常使用相同的控制器，但不是指定直接的服务，而是应用命令模式来提供命令及其处理程序。控制器作为客户端和后端逻辑之间的中介，确定应用程序应该如何响应各种请求。控制器将特定的路由映射到包含业务逻辑的相应方法。通过在控制器内组织请求处理，应用程序保持了关注点的清晰分离，使其更加结构化、可扩展且易于管理。
- en: 'Create a new folder called `api` under the `src` folder. Then, create a new
    file called `account.controller.ts` under `src` / `api`, with the following content:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹下创建一个名为 `api` 的新文件夹。然后，在 `src` / `api` 下创建一个名为 `account.controller.ts`
    的新文件，内容如下：
- en: '[PRE25]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This NestJS controller handles account management. It’s named `AccountUnitController`
    and is mapped to the `/Account` route. The controller uses a command bus to send
    commands. There are three functionalities exposed through `POST` requests:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 NestJS 控制器处理账户管理。它命名为 `AccountUnitController` 并映射到 `/Account` 路由。控制器使用命令总线发送命令。通过
    `POST` 请求暴露了三个功能：
- en: '`registerAccount` allows you to create a new account with a payment mechanism
    count, by sending `RegisterAccountUnitCommand`.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerAccount` 允许你通过发送 `RegisterAccountUnitCommand` 创建一个带有支付机制计数的新的账户。'
- en: '`disableAccount` deactivates an account by ID using `DisableAccountUnitCommand`.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disableAccount` 通过 `DisableAccountUnitCommand` 使用 ID 使账户失效。'
- en: '`enableAccount` reactivates an account using an `EnableAccountUnitCommand`,
    based on its ID.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enableAccount` 使用 `EnableAccountUnitCommand` 根据其 ID 激活账户。'
- en: All successful requests return a message indicating the command was received
    and the aggregate ID (for registration).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所有成功的请求都会返回一条消息，表明已收到命令和聚合 ID（用于注册）。
- en: 'In order to enable a controller’s functionality, we need to import several
    essential elements. `Controller`, `Param`, `Post`, and `Query` from `@nestjs/common`
    are necessary to define the controller, handle route parameters, and process HTTP
    `POST` requests with query parameters. `CommandBus` from `@nestjs/cqrs` allows
    us to dispatch commands, following the CQRS pattern. We import the specific commands
    (`DisableAccountUnitCommand`, `EnableAccountUnitCommand`, and `RegisterAccountUnitCommand`)
    from the `account.commands` file to perform specific operations on the account
    unit. Finally, we import the `uuid` package to generate unique IDs for these operations:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用控制器的功能，我们需要导入几个基本元素。`Controller`、`Param`、`Post`和`Query`从`@nestjs/common`是必要的，用于定义控制器、处理路由参数和处理带有查询参数的HTTP
    `POST`请求。`CommandBus`从`@nestjs/cqrs`允许我们根据CQRS模式分发命令。我们从`account.commands`文件导入特定的命令（`DisableAccountUnitCommand`、`EnableAccountUnitCommand`和`RegisterAccountUnitCommand`）以对账户单元执行特定操作。最后，我们导入`uuid`包以生成这些操作的唯一ID：
- en: '[PRE26]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our controller doesn’t know about events. It only interacts with commands. The
    request will flow to command handlers, and they will trigger our events.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器不了解事件。它只与命令交互。请求将流向命令处理器，它们将触发我们的事件。
- en: 'Besides the controller, we have the `account.module.ts` file, which contains
    `AccountModule`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 除了控制器外，我们还有`account.module.ts`文件，其中包含`AccountModule`：
- en: '[PRE27]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For a complete example with imported functionalities, check out our repository.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看包含导入功能的完整示例，请查看我们的仓库。
- en: This code defines `AccountModule` used in a CQRS architecture with event sourcing.
    It implements the `OnModuleInit` life cycle hook, which gets called after the
    module is initialized.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了用于CQRS架构和事件源模式的`AccountModule`。它实现了`OnModuleInit`生命周期钩子，该钩子在模块初始化后调用。
- en: 'Here’s a breakdown of the functionality:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是功能分解：
- en: '`onModuleInit`: This method is called when the module is ready.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onModuleInit`: 当模块准备就绪时调用此方法。'
- en: '`startSubscription (private)`: This private method initiates a subscription
    to an event stream. It uses an **Immediately Invoked Function Expression** (**IIFE**)
    to encapsulate the asynchronous logic.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startSubscription (private)`: 这是一个私有方法，用于初始化对事件流的订阅。它使用**立即调用的函数表达式**（**IIFE**）来封装异步逻辑。'
- en: Finally, we will take a look at `subscribeToAll(private, async)`; this private
    asynchronous method does the actual subscription work. It uses `eventStore.subscribeToAll`
    to subscribe to all event streams that start with the `Account-unit-stream-` prefix.
    This method typically captures all events related to account management. It iterates
    through the subscription using `for await...` of the loop. For each event received,
    it logs the event revision number and stream ID, extracts the event data, and
    logs it as well. The `AccountModule` subscribes to a specific category of events
    in the event store (events related to accounts). Whenever a new event related
    to accounts arrives, it logs details about the event and its data for potential
    processing or monitoring.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看`subscribeToAll(private, async)`；这是一个私有的异步方法，执行实际的订阅工作。它使用`eventStore.subscribeToAll`来订阅所有以`Account-unit-stream-`前缀开始的事件流。此方法通常捕获与账户管理相关的所有事件。它使用`for
    await...`循环遍历订阅。对于收到的每个事件，它记录事件修订号和流ID，提取事件数据，并记录它。`AccountModule`订阅事件存储中的特定类别的事件（与账户相关的事件）。每当有新的与账户相关的事件到达时，它会记录有关事件及其数据的详细信息，以供潜在的处理或监控。
- en: Testing an application
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: Before running our application, you should run the provided `docker-compose`
    file via the `docker-compose up -d` command. It ensures that we already have `EventStoreDB`
    as a data store. To make sure if data store is running, just navigate to `localhost:2113`,
    and you should see the `EventStoreDB`’s dashboard.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的应用程序之前，您应该通过`docker-compose up -d`命令运行提供的`docker-compose`文件。这确保我们已经有`EventStoreDB`作为数据存储。要确保数据存储正在运行，只需导航到`localhost:2113`，你应该会看到`EventStoreDB`的仪表板。
- en: To run our application, execute the `nest start` command from the command line.
    Open your Postman application, and create a new tab. Select the `paymentmechanismcount`
    set to `67`. Then, click the **Send** button.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的应用程序，从命令行执行`nest start`命令。打开您的Postman应用程序，创建一个新标签。选择`paymentmechanismcount`设置为`67`。然后，点击**发送**按钮。
- en: '![Figure 11.8: Account registration](img/B09148_11_008.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8：账户注册](img/B09148_11_008.jpg)'
- en: 'Figure 11.8: Account registration'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：账户注册
- en: After successful operation, you should get the following message to your VS
    Code console.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 操作成功后，你应该在VS Code控制台中看到以下消息。
- en: '![Figure 11.9: Account registration logs](img/B09148_11_009.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9：账户注册日志](img/B09148_11_009.jpg)'
- en: 'Figure 11.9: Account registration logs'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：账户注册日志
- en: 'The ID will be different in your case because it is automatically generated
    by the system. After running the same command with a different payment mechanism
    count (it is twenty-three in our case), you should get the following message with
    `currentPaymentMechanismCount=90`. The ID is different again, but if you use the
    same payment mechanism count, the values should be totaled based on the `currentPaymentMechanismTotal
    = currentPaymentMechanismTotal +` `paymentMechanismCount` formula:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的情况下，ID 将不同，因为它是由系统自动生成的。在运行具有不同支付机制计数的相同命令（在我们的情况下是二十三）后，您应该会收到以下消息，其中 `currentPaymentMechanismCount=90`。ID
    再次不同，但如果您使用相同的支付机制计数，值应根据 `currentPaymentMechanismTotal = currentPaymentMechanismTotal
    + paymentMechanismCount` 公式进行总计：
- en: '![Figure 11.10: Account registration calculation](img/B09148_11_010.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10：账户注册计算](img/B09148_11_010.jpg)'
- en: 'Figure 11.10: Account registration calculation'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：账户注册计算
- en: Now, we have two different IDs (aggregate IDs), and we can use any of them to
    enable and disable requests.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个不同的 ID（聚合 ID），我们可以使用其中任何一个来启用和禁用请求。
- en: Open a new tab on Postman and send a POST request to `http://localhost:8080/account/YOUR_AGGREGATE_ID/disable`.
    The last aggregate ID stores the value of `paymentmechanismCount`, which is twenty-three.
    So, disabling the endpoint should end up making a value of `currentPaymentMechanismTotal
    = 67`. The logic is ninety minus twenty-three equals to sixty-seven.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postman 中打开一个新标签页，并向 `http://localhost:8080/account/YOUR_AGGREGATE_ID/disable`
    发送 POST 请求。最后一个聚合 ID 存储了 `paymentmechanismCount` 的值，即二十三。因此，禁用端点应该最终使 `currentPaymentMechanismTotal
    = 67` 的值。逻辑是九十减去二十三等于六十七。
- en: 'Let’s run the `http://localhost:8080/account/90f80d89-4620-4526-ae3e-02a8156df9a1/disable`
    and click **Send**:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `http://localhost:8080/account/90f80d89-4620-4526-ae3e-02a8156df9a1/disable`
    并点击 **发送**：
- en: '![Figure 11.11: The disabled account response](img/B09148_11_011.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11：禁用账户的响应](img/B09148_11_011.jpg)'
- en: 'Figure 11.11: The disabled account response'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：禁用账户的响应
- en: To enable the account, just replace `disable` with `enable` and run the command
    again. It should restore `currentPaymentMechanismTotal` to `90`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用账户，只需将 `disable` 替换为 `enable` 并再次运行命令。它应该将 `currentPaymentMechanismTotal`
    恢复到 `90`。
- en: Besides CQRS and event sourcing, we have a Service Registry and discovery for
    microservices. The next section will help us to understand them in more detail.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 CQRS 和事件溯源之外，我们还有微服务的服务注册和发现。下一节将帮助我们更详细地了解它们。
- en: Service Registry and discovery in microservices
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务中的服务注册和发现
- en: Microservices development by itself consists of huge amounts of patterns and
    best practices. It is indeed not possible to cover all of them in one book. In
    this section, we will provide popular patterns and techniques used in microservices
    development.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发本身包含大量的模式和最佳实践。确实不可能在一本书中涵盖所有这些。在本节中，我们将提供在微服务开发中使用的流行模式和技巧。
- en: In a microservice architecture, applications are built as a collection of small,
    independent services. These services need to communicate with each other to cover
    user requests. Service Registry and discovery is a mechanism that simplifies this
    communication by enabling services to find each other dynamically.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，应用程序被构建为一系列小型、独立的服务。这些服务需要相互通信以处理用户请求。服务注册和发现是一种机制，通过使服务能够动态地找到彼此来简化这种通信。
- en: Understanding Service Registry and discovery
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解服务注册和发现
- en: 'Imagine a central database. This database, called the **Service Registry**,
    acts as a directory of all the microservices in your system. Each service instance
    (i.e., an individual running a copy of a microservice) registers itself with the
    registry. During registration, the service provides details such as the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个中心数据库。这个数据库被称为 **服务注册表**，作为系统中所有微服务的目录。每个服务实例（即运行微服务副本的个体）都会向注册表注册自己。在注册过程中，服务提供如下详细信息：
- en: '**Network location**: The address (IP address and port) where the service can
    be found.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络位置**：服务可以找到的地址（IP地址和端口号）。'
- en: '**Capabilities**: What the service can do (e.g., processes payments or provides
    user data).'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**能力**：服务能做什么（例如，处理支付或提供用户数据）。'
- en: '**Health Information**: Status details such as whether the service is currently
    healthy and available to handle requests.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康信息**：服务当前是否健康以及是否可以处理请求的状态细节。'
- en: You can use tools such as Consul, ZooKeeper, and Eureka Server (as used by Netflix)
    for real-world service registries.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用诸如Consul、ZooKeeper和Eureka Server（如Netflix所使用）等工具进行实际的服务注册。
- en: Service Registry often integrates with API gateways, which are a single-entry
    point for external clients to access microservices. An API Gateway might leverage
    the Service Registry to discover the latest locations of the microservices it
    needs to route requests to.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册经常与API网关集成，API网关是外部客户端访问微服务的单一入口。API网关可能会利用服务注册来发现它需要路由请求到的微服务的最新位置。
- en: 'Conversely, **Service** **d****iscovery** is the process where microservices
    find the location of other services they need to interact with. There are two
    main approaches:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**服务** **发现**是微服务找到它们需要交互的其他服务位置的过程。有两种主要方法：
- en: '**Client-side discovery**: The service that needs another service (the client)
    directly queries the registry to find the address of the target service.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端发现**：需要另一个服务（客户端）的服务直接查询注册表以找到目标服务的地址。'
- en: '**Server-side discovery**: A separate component, such as a load balancer, sits
    in front of the services. This component retrieves service locations from the
    registry and routes requests to the appropriate service instance.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端发现**：一个单独的组件，如负载均衡器，位于服务之前。该组件从注册表中检索服务位置并将请求路由到适当的服务实例。'
- en: 'Let’s look at some benefits of Service Registry and discovery:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看服务注册和发现的一些好处：
- en: '**Dynamic service location**: Services don’t need to be hardcoded with the
    addresses of other services. They can discover them on-demand from the registry,
    making the system more adaptable to changes.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态服务位置**：服务不需要将其他服务的地址硬编码。它们可以从注册表中按需发现它们，使系统更能适应变化。'
- en: '**Scalability and elasticity**: As you add or remove service instances, the
    registry automatically reflects the changes. This ensures that clients always
    interact with available services.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和弹性**：随着你添加或删除服务实例，注册表会自动反映这些变化。这确保了客户端始终与可用的服务交互。'
- en: '**Loose coupling**: Services become loosely coupled, as they rely on the registry
    for communication. This promotes independent development and deployment of microservices.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：服务变得松耦合，因为它们依赖于注册表进行通信。这促进了微服务的独立开发和部署。'
- en: By using a central registry and enabling dynamic discovery, Service Registry
    and discovery simplify communication and promote flexibility in a microservice
    architecture.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用中央注册表并启用动态发现，服务注册和发现简化了通信并促进了微服务架构的灵活性。
- en: Approaches for implementing Service Registry and Discovery
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现服务注册和发现的方法
- en: 'There are two main approaches to implementing Service Registry and discovery
    in Node.js microservices:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js微服务中实现服务注册和发现有两种主要方法：
- en: The first option is using a dedicated Service Registry tool. This approach leverages
    a separate service specifically designed for Service Registry and discovery functionalities.
    We can use popular options such as Consul, ZooKeeper, and Eureka Server (Netflix).
    These tools offer robust features for registration, discovery, health checks,
    and so on.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种选择是使用专用的服务注册工具。这种方法利用一个专门为服务注册和发现功能设计的独立服务。我们可以使用流行的选项，如Consul、ZooKeeper和Eureka
    Server（Netflix）。这些工具提供了注册、发现、健康检查等功能。
- en: The second option is Node.js client libraries. Each registry tool typically
    provides a Node.js client library that simplifies interaction with the registry.
    The library allows your microservices to register themselves, discover other services,
    and monitor their health.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种选择是Node.js客户端库。每个注册工具通常提供一个Node.js客户端库，它简化了与注册表的交互。该库允许您的微服务自行注册、发现其他服务并监控其健康。
- en: Finally, let us look at how we can implement a Service Registry before wrapping
    up this chapter.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在结束本章之前看看如何实现服务注册。
- en: Implementing Service Registry
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现服务注册
- en: 'Now, let’s take a brief look at implementing a Service Registry:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要地看看如何实现服务注册：
- en: 'Choose a Service Registry tool, and install its Node.js client library:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个服务注册工具，并安装其Node.js客户端库：
- en: During startup, each microservice registers itself with a registry using the
    library. It provides its network location, capabilities, and health information.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动期间，每个微服务都会使用库将自己注册到注册表中。它提供其网络位置、能力和健康信息。
- en: In client-side discovery, the service needing another service uses the library
    to query the registry for the target service’s address.
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端发现中，需要另一个服务的服务使用库查询注册表以获取目标服务的地址。
- en: In server-side discovery, a separate component, such as a load balancer, retrieves
    service locations from the registry and routes requests accordingly.
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端发现中，一个单独的组件，例如负载均衡器，从注册表中检索服务位置并相应地路由请求。
- en: 'Now, let’s move on to building a simple registry with Node.js: For smaller
    deployments or learning purposes, you can implement a basic Service Registry using
    Node.js itself. Here’s a simplified example:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续构建一个简单的注册表：对于较小的部署或学习目的，您可以使用 Node.js 本身实现基本的服务注册。以下是一个简化的示例：
- en: '**For data storage**: Use a lightweight in-memory data store, such as Redis,
    or a simple Node.js object to store service information'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储**：使用轻量级的内存数据存储，例如 Redis，或者简单的 Node.js 对象来存储服务信息'
- en: '**Registration**: During startup, each microservice registers itself with the
    registry by sending a message containing its details'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册**：在启动过程中，每个微服务通过发送包含其详细信息的消息来向注册表注册自己'
- en: '**Discovery**: Services can query the registry to retrieve a list of available
    services and their addresses'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发现**：服务可以通过查询注册表来检索可用服务及其地址列表'
- en: Before we end this section, let’s look at some important considerations of Service
    Registry and discovery, the first being **security**. When implementing your own
    registry, ensure proper authentication and authorization mechanisms to control
    access to registration and discovery functionalities. Next is **scalability**.
    A homegrown registry might not scale well for large deployments. Consider a dedicated
    tool for production environments. Finally, **health checks** are very important.
    Regularly check the health of registered services to ensure that they are available.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，让我们看看服务注册和发现的一些重要考虑因素，首先是**安全性**。在实现自己的注册表时，确保适当的身份验证和授权机制来控制对注册和发现功能的访问。接下来是**可扩展性**。自制的注册表可能不适合大型部署。考虑为生产环境使用专用工具。最后，**健康检查**非常重要。定期检查已注册服务的健康状态，以确保它们可用。
- en: We’ve covered everything about microservice architecture in this chapter. It’s
    now time to wrap up.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经涵盖了关于微服务架构的所有内容。现在是时候总结一下了。
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter dived into the building blocks of a strong microservice architecture.
    It covered API gateways, explaining their purpose, use cases, and how to implement
    them for optimal performance, with caching, rate limiting, and response aggregation.
    The chapter then explored CQRS and event sourcing patterns, along with event streaming,
    a technology that makes them work. Finally, it discussed Service Registry and
    discovery, essential for microservices to communicate with each other. This chapter
    provided the knowledge and practical examples to build a well-designed and scalable
    microservice infrastructure.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了强大微服务架构的构建块。它涵盖了 API 网关，解释了其目的、用例以及如何实现它们以获得最佳性能，包括缓存、速率限制和响应聚合。然后，本章探讨了
    CQRS 和事件源模式，以及使它们工作的技术——事件流。最后，本章讨论了服务注册和发现，这对于微服务之间相互通信至关重要。本章提供了构建设计良好且可扩展的微服务基础设施的知识和实践示例。
- en: In the next chapter, we will explore testing strategies in depth and cover how
    to write effective unit and integration tests for your microservices.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨测试策略，并介绍如何为您的微服务编写有效的单元和集成测试。
