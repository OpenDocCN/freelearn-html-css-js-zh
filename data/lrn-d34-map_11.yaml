- en: Shaping Maps with Data - Hexbin Maps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据塑造地图 - 六边形地图
- en: Different pieces of data afford different visualizations. When you want to show
    a timeline, you rarely build a vertical bar chart. You would more likely use a
    horizontal line chart. You should, of course, give yourself some freedom of expression
    when encoding data to position, shape, or color. However, the data at hand, the
    meaning you want to convey, and the cognitive decoding processes at play are important
    guides when deciding how to encode your data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的数据适合不同的可视化。当你想展示时间线时，你很少构建垂直条形图。你更有可能使用水平线形图。当然，在将数据编码到位置、形状或颜色时，你应该给自己一些表达的自由。然而，手头的数据、你想要传达的意义以及认知解码过程在决定如何编码你的数据时是非常重要的指南。
- en: 'In this chapter, we will focus on a specific map-visualization technique: **hexagonal
    binning** **maps** (**hexbin maps**). We will start with a brief journey through
    various map visualization techniques before focusing on hexbin maps. You will
    learn the conceptual and cognitive benefits of hexbin maps, what hexagons are
    useful for in comparison to other shapes, and how they are calculated.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于一种特定的地图可视化技术：**六边形分箱**地图（**六边形地图**）。在专注于六边形地图之前，我们将简要回顾各种地图可视化技术。你将了解六边形地图的概念和认知优势，与其他形状相比，六边形有什么用途，以及它们是如何计算的。
- en: Most of the chapter will, however, be hands on, building a hexbin map from scratch.
    Most of the attention will go into data preparation and shaping. D3 will make
    the actual visualization a breeze with the **D3-hexbin** module. We will focus
    on a pipeline of data preparation and visualization tasks that aim to be easy
    to follow. Let’s go!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章的大部分内容将是实践性的，从头开始构建六边形地图。大部分注意力将集中在数据准备和塑形上。D3的**D3-hexbin**模块将使实际的可视化变得轻而易举。我们将关注一系列数据准备和可视化任务，这些任务旨在易于遵循。让我们开始吧！
- en: Reviewing map visualization techniques
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾地图可视化技术
- en: There are many ways to represent geographical data. Not surprisingly, maps are
    often involved. While maps are a compelling way to present data that can be deciphered
    effortlessly by most people, they can be overused. If you want to show which country
    has the highest percentage of forest cover, you might decide to show a globe and
    use color saturation to encode forest ratio. Alternatively, you could show a sorted
    vertical bar chart displaying the country with the highest forest cover on top
    and the country with the lowest at the bottom. The map version might look nicer
    and give your users a good intuition about locations of forest lack or riches.
    However, the bar chart gives a more concise overview over the distribution and
    country comparison of forest cover.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 表示地理数据的方法有很多。不出所料，地图经常被用到。虽然地图是一种吸引人的方式来展示数据，大多数人可以轻松解读，但它们可能会被过度使用。如果你想展示哪个国家森林覆盖率最高，你可能会选择展示一个地球仪并使用颜色饱和度来编码森林比率。或者，你可以展示一个排序的垂直条形图，显示森林覆盖率最高的国家在最上面，最低的国家在最下面。地图版本可能看起来更漂亮，并给你的用户一个关于森林缺乏或丰富的位置的直观感受。然而，条形图提供了对森林覆盖率分布和各国比较的更简洁的概述。
- en: So, let’s assume that you have decided to use a map as the fundamental representation
    of your visual. What options are there?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设你已经决定使用地图作为你视觉表示的基本形式。有哪些选择呢？
- en: Choropleth maps
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色图
- en: Widely known and potentially overused choropleth maps are a good choice if you
    need to compare standardized ratios across geographical units such as states,
    counties, or countries. You built a choropleth map in [chapter 4](c22382c6-84d9-411f-b795-681df2321005.xhtml),
    *Creating a Map* and in [chapter 10](328cc9b5-a87f-4492-b7ce-fa4c07cff7a1.xhtml),
    *Adding Interactivity to Your Canvas Map* comparing forest cover ratio per country
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 广为人知且可能被过度使用的着色图，如果你需要比较地理单元（如州、县或国家）之间的标准化比率时是一个不错的选择。你在[第4章](c22382c6-84d9-411f-b795-681df2321005.xhtml)“创建地图”和[第10章](328cc9b5-a87f-4492-b7ce-fa4c07cff7a1.xhtml)“为你的画布地图添加交互性”中构建了着色图，比较了每个国家的森林覆盖率比率
- en: The only visual channel you can encode your measure of choice with is color.
    The areas of the units are already given by the size of these units. This can
    draw the user’s attention away from the smaller, and toward, the larger units.
    Looking at our forest example, larger countries such as the US, Russia, or Brazil
    might get more initial attention than smaller countries, such as Luxembourg, Haiti,
    or Belize.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你唯一可以编码你选择的度量的视觉通道是颜色。这些单位的面积已经由这些单位的大小给出。这可能会将用户的注意力从较小的单位转移到较大的单位上。以我们的森林为例，像美国、俄罗斯或巴西这样的大国可能会比像卢森堡、海地或伯利兹这样的小国得到更多的初始关注。
- en: To alleviate this attention problem, you should be fair to each country in the
    measure you visualize. The key rule is to not visualize absolute numbers, but
    standardized ratios related to the country. We adhered to this rule in our forest
    example by visualizing the percentage of forested area of the total country area.
    This measure has the same range for each country, independent of the country’s
    area (0 to 100%). It’s a standardized, and hence, fair measure. The absolute number
    of trees would be an unfair measure. A large country with a few trees could still
    have more trees than a small country full of trees, rendering our comparison problematic
    to pointless.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这种注意力问题，你应该在可视化的度量中对每个国家都公平。关键规则是不要可视化绝对数字，而是与国家相关的标准化比率。我们在森林示例中遵循了这一规则，通过可视化森林覆盖面积占总国家面积的百分比。这个度量对每个国家都有相同的范围，独立于国家的面积（0到100%）。这是一个标准化且因此公平的度量。树木的绝对数量将是一个不公平的度量。一个树木较少的大国可能仍然比一个树木繁茂的小国拥有更多的树木，这使得我们的比较变得有问题的甚至毫无意义。
- en: Furthermore, the geographical unit should define the measure you visualize.
    Tax rates, for example, are made by countries and make perfect sense to compare
    across countries. Forest cover is not (entirely) informed by a country’s actions
    and policies, and makes less sense to show in a choropleth. The countries’ actions
    still influence their forest cover, so I wouldn’t disregard it (the Dominican
    Republic, for example, has a much more conservative approach to its forests than
    neighboring Haiti), but this should be a conscious part of your choice of visualization
    technique.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，地理单位应该定义你可视化的度量。例如，税率是由国家制定的，跨国家比较非常有意义。森林覆盖率并不是（完全）由一个国家的行动和政策决定的，因此在渐变图中展示它意义不大。国家的行动仍然会影响其森林覆盖率，所以我不会完全忽视它（例如，多米尼加共和国对其森林的管理方式比邻国海地更为保守），但这应该是你选择可视化技术时的一个有意识的部分。
- en: 'As choropleths are so omnipresent, let’s take a look at another example with
    different data: farmers'' markets in the US. They will accompany us for the rest
    of the chapter, so this is a good time to dive into it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于渐变图如此普遍，让我们看看另一个不同数据的例子：美国的农场市场。它们将在本章的剩余部分陪伴我们，所以这是一个深入了解的好时机。
- en: The *farmers' markets* data we will use is published by the USDA at [https://www.ams.usda.gov/local-food-directories/farmersmarkets](https://www.ams.usda.gov/local-food-directories/farmersmarkets).
    After a bit of a clean up, we have a dataset of 8,475 markets on mainland US.
    Each market has a number of interesting variables, starting with longitude and
    latitude values we can use for the mapping, as well as name, state, and city they
    are located in. It also has 29 binary variables (as in yes/no) indicating the
    products that each market is selling. We will use this later to visualize subsets
    of markets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的*农场市场*数据由美国农业部发布于[https://www.ams.usda.gov/local-food-directories/farmersmarkets](https://www.ams.usda.gov/local-food-directories/farmersmarkets)。经过一番清理后，我们得到了一个包含美国大陆8,475个市场的数据集。每个市场都有一些有趣的变量，包括我们可以用于地图的经纬度值，以及它们所在的名字、州和城市。它还包括29个二元变量（即是/否），表示每个市场正在销售的产品。我们将在以后使用这些变量来可视化市场的子集。
- en: 'Here’s a choropleth of the US states (only mainland to keep it simple). It
    shows the number of farmers'' markets per 100,000 people. Light blue means few
    markets; dark blue means many markets per 100k people:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个美国各州的渐变图（仅包括大陆部分以保持简单）。它显示了每10万人中的农场市场数量。浅蓝色表示市场少；深蓝色表示每10万人中有许多市场：
- en: '![](img/e17f4ec6-542b-4fec-a8a2-f2376a5a50a5.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e17f4ec6-542b-4fec-a8a2-f2376a5a50a5.png)'
- en: A choropleth map of farmers' markets
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 农场市场渐变图
- en: One question here has to be whether a state-wise comparison of farmers' markets
    makes much sense. Do the state-policies or cultures play a role in promoting or
    objecting to farmers' markets? Maybe. However, once we decided to go for a state-wise
    comparison of it, are we able to compare well? Texas with its size gets a lot
    of weight in the visual, suggesting southern farmers' market deprivation. We can
    see Vermont has the highest ratio (it helps that we’re pointing a red line at
    it), but what about Washington, D.C.? There are 8.5 markets per 100k people? We
    can’t even see it on the map.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题需要考虑，即按州比较农贸市场是否有很大意义。州政策或文化在促进或反对农贸市场中发挥作用吗？也许吧。然而，一旦我们决定进行州级比较，我们能否很好地进行比较？德克萨斯州由于其规模在视觉上占据了很大的权重，这暗示了南部农贸市场的匮乏。我们可以看到佛蒙特州的比例最高（我们用红线指向它也有帮助），但华盛顿特区呢？每10万人有8.5个市场？我们甚至无法在地图上看到它。
- en: Cartograms
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地形图
- en: 'Cartograms do away with the area problem, by encoding your values to area size.
    A cartogram of our farmers'' markets mapping the ratio to color and area size
    would look as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 地形图通过将你的值编码到面积大小来消除面积问题。我们的农贸市场地形图将比例映射到颜色和面积大小，看起来如下：
- en: '![](img/153f9633-e05f-4bee-9d06-35fd343e9cc9.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/153f9633-e05f-4bee-9d06-35fd343e9cc9.png)'
- en: A contiguous cartogram of farmers' markets
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 农贸市场的连续地图
- en: The area— and consequently the shape—of your map gets distorted in such a way
    that the area represents the value you want to visualize. It's great for Washington,
    D.C. which has been sized up significantly to be recognized as a farmers' markets
    heavyweight. In short, they solve the choropleth problem of attention theft, but
    create a new problem in that our geographical units are often hardly recognizable.
    Your users will be fine with this reality bend for counties, states, and countries
    they know well, but they will struggle to make sense of areas they don’t know
    the shape of. It’ll look too cryptic and reduce readability to a potential full
    loss of interest.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你的地图的面积——以及随之而来的形状——以这种方式扭曲，以至于面积代表了你想要可视化的值。这对华盛顿特区来说很棒，它被显著放大，以便被识别为农贸市场的重量级市场。简而言之，它们解决了注意力盗窃的
    choropleth 问题，但在我们的地理单位往往难以辨认的情况下，又产生了新的问题。你的用户会很好地接受他们对县、州和国家这种熟悉地区的现实扭曲，但他们会很难理解他们不熟悉形状的地区。这看起来太神秘了，可能会降低可读性，甚至可能导致对兴趣的完全丧失。
- en: The contiguous cartogram has been produced with [https://github.com/shawnbot/topogram](https://github.com/shawnbot/topogram).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 连续地图是通过[https://github.com/shawnbot/topogram](https://github.com/shawnbot/topogram)生成的。
- en: Dot density maps
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点密度图
- en: 'Dot density maps are great if you want to show **counts of things** rather
    than ratios. Each thing is a dot displayed on the map. Here’s a dot density map
    of all farmers'' markets in the US:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 点密度图非常适合你想展示**事物数量**而不是比例的情况。每个事物在地图上都是一个点。以下是美国所有农贸市场的点密度图：
- en: '![](img/51ee6872-ae5c-4e3d-a9a5-b303571679a9.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51ee6872-ae5c-4e3d-a9a5-b303571679a9.png)'
- en: A dot density map of farmers' markets
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 农贸市场的点密度图
- en: 'The benefit of this visualization technique is obvious: it shows all the data.
    You can easily see where they all are and detect clusters of farmers'' markets
    across the country. The problem is that in fact it doesn’t show all the data.
    Some of the dots are overlapping in small, busy areas. A second potential problem
    is that many absolute measures in spatial analysis correlate highly with population
    distribution. So while you want to say *Look where all the farmers'' markets are*
    you are actually saying *Look where all the people are*. This doesn''t mean you
    shouldn''t show it, but you should be aware of it. By the way, our hexbin map
    will have the same problem, so be aware. Another caveat of showing all the data
    is that it might appear confusing for users to look at that amount of data and
    elements. We might want to focus the eye in a more orderly way to the clusters.
    This is where hexbin maps come in handy.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可视化技术的优点很明显：它展示了所有数据。你可以轻松地看到它们都在哪里，并检测到全国范围内的农贸市场集群。问题是实际上它并没有展示所有数据。一些点在小而繁忙的地区重叠。第二个潜在问题是许多空间分析中的绝对度量与人口分布高度相关。所以当你想说“*看看所有农贸市场的位置*”时，你实际上是在说“*看看所有人的位置*”。这并不意味着你不应该展示它，但你应该意识到这一点。顺便说一句，我们的六边形图也会遇到同样的问题，所以要有意识。展示所有数据的另一个问题是，对于用户来说，查看如此多的数据和元素可能会显得混乱。我们可能希望以更有序的方式将注意力集中在集群上。这就是六边形图派上用场的地方。
- en: Note that this list of map visualization techniques is not complete. There are,
    of course, other map visualization techniques, such as heat maps, cluster maps,
    graduated circle, proportional symbol, or bubble maps, and non-contiguous cartograms.
    A good place to see what people visualize with and on maps is [https://flowingdata.com/category/visualization/mapping/](https://flowingdata.com/category/visualization/mapping/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这份地图可视化技术列表并不完整。当然，还有其他地图可视化技术，如热力图、聚类图、渐变圆、比例符号或气泡图，以及非连续的地图。一个很好的地方是查看人们如何在地图上可视化的内容是[https://flowingdata.com/category/visualization/mapping/](https://flowingdata.com/category/visualization/mapping/)。
- en: Value and use of the hexagon
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 六边形的价值和用途
- en: 'Hexagons can solve some of the problems we mentioned in the preceding section.
    They can help the unequal area problems of choropleth maps and can bring ordered
    focus to point clusters. Let’s look at a few first:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形可以解决我们前面提到的一些问题。它们可以帮助解决等面积问题，并为点簇带来有序的焦点。让我们先看看几个例子：
- en: '![](img/6006bc7d-d194-456a-bb3f-b7ab796a6924.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6006bc7d-d194-456a-bb3f-b7ab796a6924.png)'
- en: Hexagonal tiling
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形镶嵌
- en: 'As you can see, hexagons have equal length sides and fit nicely next to each
    other. However, they’re not just a pretty face, they also have properties we can
    leverage well in data visualization:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，六边形有等长的边，并且可以很好地相邻排列。然而，它们不仅仅是外表漂亮，它们还拥有我们可以在数据可视化中充分利用的特性：
- en: Hexagons divide a given area into equal-sized hexagons. This is called **tiling**
    and can also be done with other shapes such as circles, triangles, rectangles,
    or other polygons.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六边形将给定区域划分为大小相等的六边形。这被称为**镶嵌**，也可以用其他形状如圆形、三角形、矩形或其他多边形来完成。
- en: However, if you tile your wall with circles, you will end up with gaps between
    the circles. Covering a plane gap-free with repeating symmetric shapes is called
    a **regular** **tessellation** and is, in fact, only possible with squares, triangles,
    and hexagons.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果你用圆形铺满你的墙面，你会在圆形之间留下缝隙。用重复的对称形状无缝覆盖平面称为**规则**的**镶嵌**，实际上，这仅适用于正方形、三角形和六边形。
- en: Of these three shapes, hexagons are the highest-sided shape closest to a circle.
    Hence, they are best to represent—to **bin**—a cluster of points. Corner points
    of triangles or squares are further away from their center than corner points
    in hexagons, which make hexagons predestined for grouping dot data. Circles are
    optimal for binning, but then again, they can’t be tessellated.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这三个形状中，六边形是最接近圆形的最高边形状。因此，它们最适合表示——**分组**——一组点。三角形或正方形的角点比六边形的角点离它们的中心更远，这使得六边形天生适合对点数据进行分组。圆形在分组方面是最优的，但再次强调，它们不能进行镶嵌。
- en: Let’s consider binning for an extra moment. **Binning** means grouping data
    together into equally sized categories. When we have a dataset of 100 people with
    varying ages, we can look at the frequency of each age, or we bin the data to
    more digestible age groups, such as 20-39, 40-69, and 70-99\. We take individual
    data points and aggregate them in larger and—usually—equally sized groups.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再考虑一下分组。**分组**意味着将数据分组到大小相等的类别中。当我们有一组100人的年龄数据时，我们可以查看每个年龄的频率，或者我们将数据分组到更易于消化的年龄组，如20-39岁、40-69岁和70-99岁。我们将单个数据点汇总到更大的——通常是大小相等的——组中。
- en: In a mapping context, we can bin point location data to equally sized areas.
    Hexagons are well suited for this task as they group points well and also tessellate
    regularly across the plane. This is what a hexbin map as implemented with D3 can
    do for you. Instead of potentially piling points on top of each other as we do
    in dot density maps, we can define hexagonal areas of equal size, aggregating
    the points to a summary measure encoded with color. As such, **binning** represents
    the data for each hexagon area potentially better than individual points would
    do. The **hexagonal** **tessellation** supports the binning in that it creates
    the best possible, gap-free, and comparably fair bin shapes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图环境中，我们可以将点位置数据分组到大小相等的区域。六边形非常适合这项任务，因为它们很好地分组点，并且在平面上规则地镶嵌。这就是D3实现的六边形图能为你做的事情。我们不必像在点密度图中那样，可能将点堆叠在一起，我们可以定义大小相等的六边形区域，将点汇总到一个用颜色编码的汇总度量中。因此，**分组**比单个点更好地表示每个六边形区域的数据。**六边形**的**镶嵌**支持分组，因为它创建了最佳可能的、无缝的、相对公平的分组形状。
- en: 'In the coming sections, we will very much focus on these **hexbin maps**, where
    each hexagon represents an equal area. Before we dive into hexbins, let’s quickly
    look at another use of hexagons you might have come across: **hexagonal choropleth
    maps**. The problem the classic choropleth map, as shown above poses, is that
    smaller states such as Vermont or Washington D.C can easily be overlooked, as
    they have such low visual weight. Other area-states such as Texas or Montana attract
    the eye through sheer size. To alleviate this, we can replace the state polygons
    with hexagons:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将非常关注这些**六边形散点图**，其中每个六边形代表相等的面积。在我们深入探讨六边形散点图之前，让我们快速看一下你可能遇到过的另一种六边形应用：**六边形渐变色地图**。如上图所示的经典渐变色地图所提出的问题是，像佛蒙特州或华盛顿特区这样的小州很容易被忽视，因为它们的视觉重量很低。其他面积州，如德克萨斯州或蒙大拿州，通过
    sheer size 吸引人们的注意。为了解决这个问题，我们可以用六边形替换州多边形：
- en: '![](img/cb4c1771-d420-4f9f-8e18-7aac5ac4dca5.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb4c1771-d420-4f9f-8e18-7aac5ac4dca5.png)'
- en: Size emancipated US states in a hexagonal choropleth map
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形渐变色地图中解放美国各州的大小
- en: Let's be clear, hexagons in a *hexbin map* as described in the preceding diagram
    and in the following sections represent equal areas. Hexagons in a *hexagonal
    choropleth map* as shown in this figure represent vastly different areas. However,
    in this case, we don’t want to focus on the spatial area of our chosen unit (US
    mainland states); we want to focus on the measure that is merely categorized by
    our chosen unit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一点，正如前图和以下各节所描述的，*六边形散点图*中的六边形代表相等的面积。然而，在这个图中，我们不想关注我们选择的单位（美国大陆各州）的空间面积；我们想关注的是仅由我们选择的单位进行分类的度量。
- en: Be aware that this comes with the cost of removing the area information entirely,
    as the US states differ greatly in area and no state looks like a hexagon. However,
    unlike the preceding classic choropleth example, this hexagonal choropleth allows
    us, for example, to easily identify Washington D.C. as a farmers' market hub and
    that might be the message we want to bring across above all.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这会带来完全去除面积信息的代价，因为美国各州的面积差异很大，而且没有任何一个州看起来像六边形。然而，与先前的经典渐变色示例不同，这种六边形渐变色允许我们，例如，轻松地识别华盛顿特区作为一个农民市场中心，这可能是我们最想传达的信息。
- en: Enough theory. Let’s make a hexbin map.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够。让我们制作一个六边形散点图。
- en: Making a hexbin map
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作六边形散点图
- en: 'Having improved our US state choropleth map with hexagons, let’s now use hexagons
    to alter our dot density map. There are benefits to a dot density map as we have
    seen previously, so the changes we are about to make are more alterations than
    clear improvements. Here’s what we will build:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在改进了我们的美国州六边形渐变色地图后，现在让我们使用六边形来改变我们的点密度图。正如我们之前所看到的，点密度图有一些好处，所以我们即将进行的更改更多的是改进而不是明显的提升。以下是我们要构建的内容：
- en: '![](img/1afbac36-728f-4032-8a1e-bb517d45dd17.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1afbac36-728f-4032-8a1e-bb517d45dd17.png)'
- en: A map of many hexagons in color
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一张多边形六边形的彩色地图
- en: It’s a hexbin map showing the farmers' markets hotspots. Areas with no farmers'
    markets are shown as white hexagons, areas with many farmers' markets are shown
    in blue to dark purple. Lighter and less saturated yellow and green hexagons represent
    areas with fewer markets.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张显示农民市场热点的六边形散点图。没有农民市场的地区以白色六边形表示，拥有许多农民市场的地区以蓝色到深紫色表示。较浅且饱和度较低的黄色和绿色六边形代表市场较少的地区。
- en: Reviewing the hexbin algorithm
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查六边形散点图算法
- en: What do we want to achieve? There are two major steps we want to cover. First,
    we want to show the US as a hexagon tiling. Next, we want to highlight hexagons
    with farmers' markets, color encoding the number of markets within each hexagon.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要达到什么目标？我们想要涵盖两个主要步骤。首先，我们想要展示美国作为一个六边形镶嵌。接下来，我们想要突出显示有农民市场的六边形，并使用颜色编码每个六边形内的市场数量。
- en: Alternatively, we could be content with showing a map of the US and only display
    the hexagons where farmers' markets reside. This would be less involved; however,
    it seems worthwhile to go the extra mile for esthetics and clarity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能对只展示美国地图并仅显示有农民市场的六边形感到满意。这将涉及较少；然而，为了美观和清晰，走得更远似乎是值得的。
- en: 'The actual drawing of the hexbin is simple, thanks to the `d3.hexbin()` module
    doing the hardwork of drawing the hexagons. More attention will be required when
    producing the hexagonal grid of the US. However, don’t worry; the process is straightforward
    and right here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际绘制六边形散点图很简单，多亏了`d3.hexbin()`模块完成了绘制六边形的工作。在制作美国六边形网格时需要更多的关注。但是，不用担心；这个过程很简单，就在这里：
- en: Draw a map.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制地图。
- en: Overlay the entire map with a symmetric grid of points.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在整个地图上叠加一个对称的点网格。
- en: Only keep the grid points that are within the bounds of the map.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只保留在地图边界内的网格点。
- en: Merge the grid points data with the location data we want to visualize.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将网格点数据与我们要可视化的位置数据合并。
- en: Calculate the hexbin positions with the D3*-*hexbin module.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 D3*-*hexbin 模块计算六边形位置。
- en: For each hexagon, aggregate the summary statistic you want to visualize.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个六边形，汇总你想要可视化的统计信息。
- en: 'Visualize the summary statistic (for example, by color encoding the hexagons):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化汇总统计（例如，通过颜色编码六边形）：
- en: '![](img/544ca0f5-3a1e-436b-b15c-a34183826271.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/544ca0f5-3a1e-436b-b15c-a34183826271.png)'
- en: The hexbin map evolution
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形地图演变
- en: Setting it up
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'The setup is simple. You have a single `<div>` with the `id="vis"` in the HTML
    for the visualization. In the JavaScript, you set up a global `projection` variable
    to fill soon and create an `svg` element:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设置很简单。你有一个带有 `id="vis"` 的单个 `<div>` 用于可视化。在 JavaScript 中，你设置一个全局 `projection`
    变量以填充，并创建一个 `svg` 元素：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Drawing the map
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制地图
- en: 'As usual, the first thing we do is to get your data into the app. So far, you
    only have the US data; however, in anticipation of the farmers'' markets point
    data, we will haul in a little later—let''s use `d3.queue()` to load our data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们首先将数据放入应用程序中。到目前为止，你只有美国数据；然而，为了预见到农民市场点数据，我们稍后会将其拉入——让我们使用 `d3.queue()`
    来加载数据：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ready()` function gets called asynchronously as soon as the data is loaded:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ready()` 函数在数据加载后异步调用：'
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In there, you check for errors, prepare the US data, and draw it. The data
    preparation is a one-liner, converting the `topo` to an array of GeoJSON polygons:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，你检查错误，准备美国数据，并绘制它。数据准备是一行代码，将 `topo` 转换为 GeoJSON 多边形的数组：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The drawing function takes the GeoJSON as its only argument. Create the projection
    and the path generator and draw the US. `projection` is a global variable as we
    will use it in other places later:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图函数只接受 GeoJSON 作为其唯一参数。创建投影和路径生成器，并绘制美国。`projection` 是一个全局变量，因为我们稍后将在其他地方使用它：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we are using the `d3.geoAlbers()` projection here. The *Albers* projection
    is a so-called **equal area-conic projection**, which distorts scale and shape
    but preserves area. This is essential when producing dot density or hexbin maps
    to not distort the perceived density of the dots across distorted areas. To put
    it differently, our hexbins represent equal areas on the projected plane, hence
    we need to make sure that the projected plane honors equal areas with an appropriate
    projection. Note that equal area-conic projections require the map maker to pick
    two parallels (circles of latitude) on which the projection is based. `d3.geoAlbers`
    has been already preconfigured, picking the two parallels *[29.5,* *45.5]*. This
    produces an optimized projection for the US. When visualizing other countries
    or map areas, you can overwrite this with the `.parallels()` method or set it
    up yourself with the `d3.geoConicEqualArea()` projection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用的是 `d3.geoAlbers()` 投影。*Albers* 投影是一种所谓的**等面积圆锥投影**，它扭曲了比例和形状，但保留了面积。在制作点密度图或六边形图时，不扭曲扭曲区域中点的感知密度是至关重要的。换句话说，我们的六边形在投影平面上代表相等的面积，因此我们需要确保投影平面使用适当的投影来尊重等面积。请注意，等面积圆锥投影要求地图制作者选择两个平行线（纬度圈）作为投影的基础。`d3.geoAlbers`
    已经预先配置好了，选择了两个平行线 *[29.5,* *45.5]*。这为美国产生了一个优化的投影。当可视化其他国家或地图区域时，你可以使用 `.parallels()`
    方法覆盖它，或者使用 `d3.geoConicEqualArea()` 投影自行设置。
- en: 'The result is not too surprising:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并不令人惊讶：
- en: '![](img/6eff3b4a-b820-4834-a7ff-235be296018e.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6eff3b4a-b820-4834-a7ff-235be296018e.png)'
- en: The US mainland
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 美国大陆
- en: You can view this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-1](https://larsvers.github.io/learning-d3-mapping-11-1).
    Code example ;[11_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_01.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在浏览器中查看此步骤，网址为 [https://larsvers.github.io/learning-d3-mapping-11-1](https://larsvers.github.io/learning-d3-mapping-11-1)。代码示例
    ;[11_01.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_01.html)。
- en: At the conclusion of each step, you will find two links in an info box close
    to the relevant image. The first link brings you to a working implementation of
    this step that you can view in the browser. The second *code example* link brings
    you to the full code. If you're reading the print version, you can find all code
    examples at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)
    in their relevant chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤结束时，您将在靠近相关图像的信息框中找到两个链接。第一个链接将带您到一个可以在浏览器中查看的此步骤的工作实现。第二个*代码示例*链接将带您到完整的代码。如果您正在阅读印刷版，您可以在[https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)的相关章节中找到所有代码示例。
- en: 'Before we move on, let''s take one step back and look at how we produced the
    *TopoJSON* data on the command line. The original US map data comes in a shapefile
    from [https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html](https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html)
    and is converted from shapefile to TopoJSON in six steps as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们退一步，看看我们是如何在命令行上生成*TopoJSON*数据的。原始的美国地图数据来自[https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html](https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html)，并且通过以下六个步骤从shapefile转换为TopoJSON：
- en: 'Install `shapefile`, if you haven’t yet:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有安装，请安装`shapefile`：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install `topojson`, if you haven’t yet:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有安装，请安装`topojson`：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Convert the shapefile to GeoJSON:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将shapefile转换为GeoJSON：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Convert the Geo to TopoJSON:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Geo转换为TopoJSON：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compress number precision:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩数字精度：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Simplify the geometry:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简化几何形状：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can read more on command-line cartography at [http://bit.do/cl-carto](http://bit.do/cl-carto).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://bit.do/cl-carto](http://bit.do/cl-carto)上了解更多关于命令行制图的信息。
- en: Drawing a point grid for our hexagons
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的六边形绘制点网格
- en: 'Our aim is to draw a hexagon grid across the US map. D3-hexbin will do this
    for us later, but it can only draw a hexagon where there are points. So, we need
    to feed points to it. These points won’t have any information value for our users.
    They will only be used to produce the layout. As such, we can distinguish two
    types of points we will need:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是在美国地图上绘制一个六边形网格。D3-hexbin稍后会为我们做这件事，但它只能在有点的位置绘制六边形。因此，我们需要向它提供点。这些点对我们用户的任何信息价值都没有。它们将仅用于生成布局。因此，我们可以区分我们将需要的两种点：
- en: '**Layout points** to produce the hexbin tiling'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局点**用于生成六边形镶嵌'
- en: '**Datapoints** to render the color-scaled information'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据点**用于渲染颜色分级的信息'
- en: 'We’ll get to the datapoints soon, but at this stage, we’re only concerned with
    our layout points. Once done, you will have produced this wonderfully regular
    pattern of points stretching across our entire drawing area:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会到达数据点，但在这个阶段，我们只关心我们的布局点。一旦完成，您将产生这个美妙而规则的点模式，它横跨我们的整个绘图区域：
- en: '![](img/3b810be4-f9ec-4357-a621-5257a95a216e.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b810be4-f9ec-4357-a621-5257a95a216e.png)'
- en: A grid of many points over the US
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国上方的点网格
- en: You can view this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-2](https://larsvers.github.io/learning-d3-mapping-11-2)
    and the code example at [11_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_02.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在浏览器中查看此步骤，请访问[https://larsvers.github.io/learning-d3-mapping-11-2](https://larsvers.github.io/learning-d3-mapping-11-2)，以及代码示例在[11_02.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_02.html)。
- en: 'In the next step, we will cut this grid to shape to fit the US silhouette,
    but let’s lay it out first. Note that this will be the most involved bit of the
    calculations. No rocket science, but don’t worry if it doesn’t click immediately.
    Things often become clearer once stepping through the code in the debugger and/or
    using a few `console.log()`’s. Anyway, here we go:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个步骤中，我们将切割这个网格以适应美国的轮廓，但让我们先布局。请注意，这将是最复杂的计算部分。这不是火箭科学，但如果它一开始没有立即理解，请不要担心。一旦在调试器中逐步通过代码并/或使用几个`console.log()`，事情通常会变得清晰。无论如何，我们开始吧：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`getPointGrid()` takes only one argument: the number of columns of points we
    want. That’s enough for us to calculate the grid. First, we will get the distance
    in pixels between each dot. The distance between each dot stands in for the distance
    between the hexagon centers. `d3.hexbin()` will calculate this for us precisely
    later, but, for now, we want to get a good approximation. So, if we decide to
    have 160 columns of dots and our width is 840, the maximum distance will be *840
    / 160 = 5.25* pixels. We then calculate the number of rows. The height is 540,
    so we can fit in *540 / 5.25* rows, which equals 108 rows of dots if we round
    it down:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPointGrid()` 只接受一个参数：我们想要的点的列数。这足以让我们计算网格。首先，我们将获取每个点之间的像素距离。每个点之间的距离代表六边形中心之间的距离。`d3.hexbin()`
    将为我们精确计算这个距离，但现在我们想要一个好的近似值。所以，如果我们决定有160列的点，我们的宽度是840，最大距离将是*840 / 160 = 5.25*像素。然后我们计算行数。高度是540，因此我们可以容纳*540
    / 5.25*行，向下取整等于108行点：'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we will calculate the `hexRadius`. This might look funny. Why divide the
    distance by *1.5*? The D3-hexbin module will produce hexbins for us if we feed
    it **points** and a desired hexbin **radius**. The hexagon radius we set here
    should guarantee that the resulting hexagons are large enough to include at least
    one point of the grid we produce. We want a gap-free hexagon tiling after all.
    So, a tight grid should have a small radius, and a wide grid should have a wider
    radius. If we had a wide grid and a small radius, we wouldn’t get a hexagon for
    each point. There would be gaps.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将计算`hexRadius`。这看起来可能有点奇怪。为什么要把距离除以*1.5*？如果我们将**点**和期望的六边形**半径**输入D3-hexbin模块，它将为我们生成六边形。我们在这里设置的六边形半径应该保证生成的六边形足够大，至少包含我们生成的网格中的一个点。毕竟，我们想要一个无缝的六边形铺砖。所以，一个紧密的网格应该有一个小的半径，而一个宽的网格应该有一个更宽的半径。如果我们有一个宽的网格和小的半径，我们就不会为每个点得到一个六边形。会有缝隙。
- en: 'Luckily, hexagons are regular shapes, and their dimensions and properties are
    nicely interconnected. The vertical distance between hexagon centers is 1.5 times
    its radius, the horizontal distance is √3 (roughly 1.73):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，六边形是规则的形状，它们的尺寸和属性是相互关联的。六边形中心之间的垂直距离是其半径的1.5倍，水平距离是√3（大约1.73）：
- en: '![](img/f9b5bd24-0c14-4ba9-a787-650c1def453c.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9b5bd24-0c14-4ba9-a787-650c1def453c.png)'
- en: How hexagon distance and radius relate to each other
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形距离和半径之间的关系
- en: Our grid points work as a proxy of hexagon centers. As such they are not 'perfectly'
    laid out in the sense that their vertical distance is the exact same as their
    horizontal distance with *5.25* pixels. In a perfect hexagon grid the vertical
    distance would be a little shorter than the horizontal distance as you can see
    in above figure. In order to get a relatively tight mesh of hexagons on the base
    of our proxy grid, we should chose a safe—meaning **wide—**radius to pass to the
    D3-hexbin module which indeed will deliver a perfect hexagon grid. We can calculate
    this radius with the formulae in the preceding figure as well as our distance
    (5.25 pixel) by solving for *Radius*. When re-shuffling the equation for the vertical
    distance *Distance = 1.5 * Radius* becomes *Radius = Distance / 1.5*. In our case
    the distance is *5.25 / 1.5 =* a radius of *3.5*. Using the horizontal distance
    would have given us a less safe—meaning tighter—radius with *5.25 / √3 = 3.03*,
    which in fact would produce a few gaps in our final tiling.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络点作为六边形中心的代理。因此，它们在布局上并不“完美”，因为它们的垂直距离与水平距离相同，都是*5.25*像素。在一个完美的六边形网格中，垂直距离会比水平距离略短，如图所示。为了在我们的代理网格的基础上获得相对紧密的六边形网格，我们应该选择一个安全的——即**宽的**——半径传递给D3-hexbin模块，它确实会提供一个完美的六边形网格。我们可以通过前图中的公式以及我们的距离（5.25像素）通过求解*半径*来计算这个半径。当重新排列垂直距离的方程时，*距离
    = 1.5 * 半径*变为*半径 = 距离 / 1.5*。在我们的情况下，距离是*5.25 / 1.5 =* 半径为*3.5*。使用水平距离将给我们一个更安全的——即更紧的——半径，*5.25
    / √3 = 3.03*，这实际上会在我们的最终铺砖中产生一些缝隙。
- en: 'Next, we will create and return the grid immediately—well, the coordinates
    for the grid that is:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将立即创建并返回网格——好吧，网格的坐标：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`d3.range(rows * columns)` creates an array with one element per dot. We then
    iterate through each dot with `.map()` returning an object with three properties:
    `x`, `y`, and `datapoint`. These properties will define each of our grid points.
    The *x* coordinate will increase by the `hexDistance` every point and reset to
    *0* for each row (or put differently, after it runs through all columns). The
    *y* coordinate will increase by the `hexDistance` for each new row.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.range(rows * columns)`创建一个数组，每个点对应一个元素。然后我们使用`.map()`遍历每个点，返回一个具有三个属性的对象：`x`、`y`和`datapoint`。这些属性将定义我们的每个网格点。*x*坐标在每个点增加`hexDistance`，并在每一行重置为*0*（或者换句话说，在它运行完所有列之后）。*y*坐标在每一行增加`hexDistance`。'
- en: Equally important, each of these grid points will get a property called `datapoints`,
    which we will set to *0*. This property will distinguish all the layout points
    (*0*) from the data points (*1*) later, allowing us to focus on the latter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，每个网格点都将获得一个名为`datapoints`的属性，我们将将其设置为*0*。这个属性将区分所有布局点（*0*）和数据点（*1*），这样我们就可以专注于后者。
- en: Congratulations! This was the most difficult bit, and you’re still here proudly
    lifting a square grid of tomato-colored dots into the air.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这是最困难的部分，而你仍然自豪地举起一个方形的番茄色点阵。
- en: 'Note that not crucial but extremely helpful is visualizing the grids and points
    we make on the way. Here’s a little function that draws points if they are stored
    in an array of objects with `x` and `y` properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然不是关键，但将我们在路上标记的网格和点可视化是非常有帮助的。这里有一个小函数，如果点存储在具有`x`和`y`属性的数组对象中，它会绘制这些点：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Keeping only the points within the map
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅保留地图内的点
- en: The square grid of points is still reasonably far away from the shape of the
    US. Let’s change that. Thanks to D3’s own `d3.polygonContains()` method, this
    is rather simple. The method takes screen coordinates of a polygon and a point,
    and for each point returns `true` if the point is in the polygon and `false` if
    it isn’t. It couldn’t be more helpful.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点的正方形网格与美国地图的形状仍然相距甚远。让我们改变一下。多亏了D3的`d3.polygonContains()`方法，这相当简单。该方法接受多边形的屏幕坐标和一个点，对于每个点，如果点在多边形内则返回`true`，否则返回`false`。这非常有帮助。
- en: 'To get the polygon of our US map, we write a small function called `getPolygonPoints()`
    and use it as a next step in our `ready()` function, which so far looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取我们的美国地图的多边形，我们编写了一个名为`getPolygonPoints()`的小函数，并将其用作`ready()`函数的下一步，到目前为止，这个函数看起来是这样的：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The only argument we pass in is the array of GeoJSON objects for our map called
    `us`. For simplicity reasons, we decided to only look at the mainland US. So,
    the first thing we need to do is focus our data on the US mainland:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的唯一参数是我们地图的GeoJSON对象数组，称为`us`。出于简单起见，我们决定只查看美国大陆。因此，我们首先需要将数据集中在美国大陆上：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`data.features[0].geometry.coordinates` holds 11 arrays of polygon point pairs,
    describing mainland US as well as Alaska, Hawaii, and further offshore areas.
    We want to focus on mainland US, whose outline is represented by the first element
    in the **seventh** array. Note that this might be different if your data comes
    from a different source or is being assembled differently.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.features[0].geometry.coordinates`包含11个多边形点对数组，描述了美国大陆、阿拉斯加、夏威夷以及更远的海域。我们想专注于美国大陆，其轮廓由第七数组中的第一个元素表示。请注意，如果您的数据来自不同的来源或以不同的方式组装，这可能会不同。'
- en: Then, we will loop through all `polygonPoints`, which are in longitude and latitude,
    and convert them into *x* and *y* coordinates for further use.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将遍历所有`polygonPoints`，它们位于经纬度上，并将它们转换为*x*和*y*坐标以供进一步使用。
- en: 'Now, we have both the polygon boundaries of the US and our grid points in pixel
    coordinates. All we need to do now is to identify the grid points that lie within
    mainland US:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们既有美国地图的多边形边界，也有我们的网格点在像素坐标中。我们现在需要做的就是识别位于美国大陆内的网格点：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We pass the two arrays to a function we boldly name `keepPointsInPolygon()`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这两个数组传递给一个我们大胆命名的`keepPointsInPolygon()`函数：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In here, we create an empty array called `pointsInPolygon`, which will hold
    our US-exclusive points. We then loop through our grid points and check for each
    whether it’s within the US polygon or not. If it is, we wave it through into `pointsInPolygon.`
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`pointsInPolygon`的空数组，它将存储我们的美国专属点。然后我们遍历我们的网格点，并检查每个点是否位于美国多边形内。如果是，我们就将其传递到`pointsInPolygon.`中。
- en: 'If we were to draw these points, we would see a pointy US:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绘制这些点，我们会看到一个尖锐的美国地图：
- en: '![](img/8318924b-196e-4f81-941e-7ef0bf4f3085.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8318924b-196e-4f81-941e-7ef0bf4f3085.png)'
- en: The US in points
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 美国在点上的表示
- en: You can view this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-3](https://larsvers.github.io/learning-d3-mapping-11-3)
    the and code example at [11_03.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_03.html).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-11-3](https://larsvers.github.io/learning-d3-mapping-11-3)，以及代码示例：[11_03.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_03.html)。
- en: Making the hex tile
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作六边形瓦片
- en: Points are nice and do look pretty, but we’re here for hexagons. So, let’s finally
    draw them and introduce the D3-hexbin plugin.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 点看起来很漂亮，但我们是来画六边形的。所以，让我们最终绘制它们并介绍 D3-hexbin 插件。
- en: 'It needs the following two things from us and returns two, surely more valuable,
    things:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要我们从以下两个方面获取信息，并返回两个更有价值的东西：
- en: We need to provide a **set of points** in screen coordinates and the **radius**
    we would like to see.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要提供一组在屏幕坐标中的**点**以及我们希望看到的**半径**。
- en: It returns a grid of **hexagon center points** (one for each hexagon) and a
    **hexagon path generator**.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一个**六边形中心点**的网格（每个六边形一个）和一个**六边形路径生成器**。
- en: 'We then take the new center points and the path generator and—as is custom
    with D3—draw it ourselves with the renderer of our choice. Let’s first get the
    hexagon center points and then draw them with SVG. In our `ready()` function,
    we will add the following two lines:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用新的中心点和路径生成器，按照 D3 的惯例，使用我们选择的渲染器自己绘制它。首先，让我们获取六边形的中心点，然后用 SVG 绘制它们。在我们的
    `ready()` 函数中，我们将添加以下两行：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`getHexPoints()` retrieves the center points and `drawHexmap()` draws them.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`getHexPoints()` 获取中心点，`drawHexmap()` 绘制它们。'
- en: Retrieving the hexagon center points
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取六边形中心点
- en: As mentioned fleetingly previously, `d3.hexbin()` has two heads. Its first use
    is as a D3 **layout function** such as the force-layout, the tree-layout, or the
    circle-pack-layout functions D3 offers. Data in, augmented data out. We pass our
    data and the desired hexagon radius to it, and, for each set of data points it
    can wrap its shape around, it will return the center coordinate of that hexagon.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`d3.hexbin()` 有两个头。它的第一个用途是作为 D3 **布局函数**，例如 D3 提供的力布局、树布局或圆包布局函数。输入数据，输出增强数据。我们传递我们的数据和所需的六边形半径给它，对于它可以围绕其形状包裹的每一组数据点，它将返回该六边形的中心坐标。
- en: If we only gave it one data point, it would return one hexagon. If we gave it
    two data points close together so it fits into the hexagon’s width and height
    defined by the radius, it would also just return a single hexagon. If the second
    data point were far off the first one so that the hexagon couldn’t cover it with
    the given radius, `d3.hexbin()` would produce a second hexagon, embracing that
    second point.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只给它一个数据点，它将返回一个六边形。如果我们给出两个靠近的数据点，这样它们可以适应由半径定义的六边形的宽度和高度，它也将只返回一个六边形。如果第二个数据点离第一个数据点很远，以至于六边形无法用给定的半径覆盖它，`d3.hexbin()`
    将产生第二个六边形，包围那个第二个点。
- en: 'Here we use its layouting powers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用它的布局能力：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'First, we configure the layout. We add our radius of 3.5 (the Distance of 5.25
    / 1.5) to it and guide its attention to where it can find the `x` and `y` coordinates.
    In the next row, we use it on our grid `points` and return the resulting array
    of objects that looks as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们配置布局。我们将半径 3.5（5.25 的距离除以 1.5）添加到其中，并引导它的注意力到它可以找到 `x` 和 `y` 坐标的地方。在下一行，我们在我们的
    `points` 网格上使用它，并返回如下所示的结果数组：
- en: '![](img/ae453779-74aa-4d3c-8ffd-9edfe2f68e37.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae453779-74aa-4d3c-8ffd-9edfe2f68e37.png)'
- en: Our hexPoints as returned by d3.hexbin()
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 d3.hexbin() 返回的 hexPoints
- en: 'Our grid points are represented by 5,996 hexagonal center points, which we
    will just call **hex points** from now on. Let’s briefly go through this. The
    hexbin layout returns an array. Each element represents a single hexagon. In each
    element, each object represents a point the hexagon covers. Additionally, `d3.hexbin()`
    adds two keys to the array: `x` and `y`. Their values represent the hexagon’s
    center. So, for each hexagon, we have all point data as well as the hexagon’s
    center coordinates.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络点由 5,996 个六边形中心点表示，我们将其简称为**hex points**。让我们简要地了解一下。hexbin 布局返回一个数组。每个元素代表一个单独的六边形。在每个元素中，每个对象代表六边形覆盖的点。此外，`d3.hexbin()`
    向数组添加两个键：`x` 和 `y`。它们的值代表六边形的中心。因此，对于每个六边形，我们都有所有点数据以及六边形的中心坐标。
- en: As you can see in the preceding screenshot, the first two hexagons cover only
    one grid point, whereas the third covers two grid points. You can also see how
    the center points in the array keys are slightly different from the layout points
    in the objects. Let’s visualize it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的截图中所见，前两个六边形仅覆盖一个网格点，而第三个覆盖两个网格点。您还可以看到数组键中的中心点与对象中的布局点略有不同。让我们可视化一下。
- en: Drawing the hex tiles
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制六边形瓦片
- en: 'We have our hexagons and now just need to draw them. We do this with a new
    function we call `drawHexmap(hexPoints)` in our `ready()` function. It does what
    it says on the tin:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了六边形，现在只需要绘制它们。我们在`ready()`函数中通过一个新的函数`drawHexmap(hexPoints)`来完成这个任务。它就是它所说的那样：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We join the data (passed in as `points)` with our as yet virtual selection
    of `.hex` hexagons and use `d.x` and `d.y` to move to each hexagon’s center. At
    each center, we unwrap the second use of our hexbin instance: the **hexagon path
    generator**. `hexbin.hexagon()` will return the string the path’s `d` attribute
    requires to draw the shape. The dimensions of the hexagon will be based on the
    radius we have passed to it during configuration. The rest is basic styling.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据（以`points`的形式传入）与我们的虚拟选择`.hex`六边形连接，并使用`d.x`和`d.y`移动到每个六边形的中心。在每个中心，我们解开我们六边形实例的第二次使用：**六边形路径生成器**。`hexbin.hexagon()`将返回路径的`d`属性所需的字符串来绘制形状。六边形的尺寸将基于我们在配置期间传递给它的半径。其余的都是基本的样式。
- en: '`hexbin.hexagon()` can also take a radius as an argument. Using an accessor
    function, we can even pass through a hexagon point-specific argument, meaning
    that we can change the size of each hexagon based on a data value. Yay! However,
    we haven’t got the time or the data for this now, so let’s get back to this later.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`hexbin.hexagon()`也可以接受一个半径作为参数。使用访问器函数，我们甚至可以通过一个六边形点特定的参数传递，这意味着我们可以根据数据值改变每个六边形的大小。太棒了！然而，我们现在没有时间或数据来做这件事，所以让我们稍后再说。'
- en: 'Okay, then. Here’s your hex tiling; you deserve it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么。这是你的六边形瓦片；你应得的：
- en: '![](img/a29c8a40-31ab-48f7-92b4-1779ed48d5ee.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a29c8a40-31ab-48f7-92b4-1779ed48d5ee.png)'
- en: A hextile map
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形地图
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-4](https://larsvers.github.io/learning-d3-mapping-11-4)
    the and code example at [11_04.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_04.html).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-11-4](https://larsvers.github.io/learning-d3-mapping-11-4)，以及代码示例：[11_04.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_04.html)。
- en: Joining data points to the layout points
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据点与布局点连接
- en: 'So far, we only had eyes for the base layer setup, visualising our layout points
    as hexagons. Now, we’ll finally add some real data to it. First, we need to load
    it to our `d3.queue()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了基础层设置，将布局点可视化成六边形。现在，我们终于要添加一些真实数据了。首先，我们需要将其加载到我们的`d3.queue()`中：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `ready()` function, we just add another line to our visualization pipeline,
    triggering a function that will prepare the data for us:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ready()`函数中，我们只是向我们的可视化管道添加另一行，触发一个将为我们准备数据的函数：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`getDatapoints()` simply takes in the loaded CSV data and returns a more concise
    object boasting *x* and *y* screen coordinates as well as the `datapoint` flag,
    indicating that this is not a layout point but an actual data point. The rest
    is market-specific data, such as `name`, `state`, `city`, and `url`, we can use
    to add as info to each hexagon:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDatapoints()`简单地接受加载的CSV数据，并返回一个更简洁的对象，具有*x*和*y*屏幕坐标以及`datapoint`标志，表示这不是布局点，而是一个实际的数据点。其余的是市场特定的数据，如`name`、`state`、`city`和`url`，我们可以用来为每个六边形添加信息：'
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Back in the `ready()` function, you just concatenate these data points to the
    layout points for the complete dataset you will use for your final hexbin map:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`ready()`函数中，您只需将这些数据点连接到布局点，以获得您将用于最终六边形地图的完整数据集：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the markets data visualized as a classic dot density map in blue as
    well as together with the grid layout data in red:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是市场数据，以蓝色表示的经典点密度图可视化，以及与红色表示的网格布局数据一起：
- en: '![](img/61b608af-681b-4e39-b645-756290bc4f96.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61b608af-681b-4e39-b645-756290bc4f96.png)'
- en: The left image shows the farmers' markets points; the right image shows the
    farmers' markets points in blue and layout points in red.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 左图显示了农民市场点；右图显示了用蓝色表示的农民市场点和用红色表示的布局点。
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-5](https://larsvers.github.io/learning-d3-mapping-11-5)
    the and code example at [11_05.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_05.html).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤，请访问 [https://larsvers.github.io/learning-d3-mapping-11-5](https://larsvers.github.io/learning-d3-mapping-11-5)
    以及代码示例 [11_05.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_05.html)。
- en: 'Great! We’re one final step away from our hexmap. We need to create a value
    we can visualize: the number of markets.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们离我们的六边形图又近了一步。我们需要创建一个可以可视化的值：市场的数量。
- en: Dressing our data for the final act
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为最终表演打扮我们的数据
- en: You have some real data about farmer's markets joined with the hexagons, but
    you can’t use it yet. All your data is still tucked away in the array of objects
    per hexagon. Let’s roll this data up.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一些关于农民市场的真实数据，这些数据与六边形相关联，但你现在还不能使用它。所有你的数据仍然被存储在每个六边形对象的数组中。让我们将这些数据卷曲起来。
- en: The measure we want to visualize is the number of farmer's markets in each hexagonal
    area. Hence, all we need to do is to count the objects that have their `datapoint`
    value set to *1*. While we’re at it, let’s also remove the layout point objects,
    that is, the objects with `datapoint` value *0*; we won’t need them anymore.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要可视化的度量是每个六边形区域中农民市场的数量。因此，我们只需要计算具有 `datapoint` 值设置为 *1* 的对象数量。在此过程中，我们还将移除布局点对象，即
    `datapoint` 值为 *0* 的对象；我们不再需要它们。
- en: 'We will add our task to the `ready()` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的任务添加到 `ready()` 函数中：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Primarily, `rollupHexPoints()` will roll up the number of markets per hex point.
    It will turn the upper hexagon data into the lower hexagon data of the following
    figure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 `rollupHexPoints()` 函数将卷曲每个六边形点的市场数量。它将上图的六边形数据转换为以下图的下方六边形数据：
- en: '![](img/fc65ca7e-4756-4dbf-a7ad-30153417b962.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc65ca7e-4756-4dbf-a7ad-30153417b962.png)'
- en: The hexagon data before and after roll-up
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 卷曲前后的六边形数据
- en: '`rollupHexPoints()` will perform the following things in an order:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`rollupHexPoints()` 将按以下顺序执行以下操作：'
- en: Remove the layout grid points.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除布局网格点。
- en: Count the number of datapoints and add the count as a new property called `datapoints`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算数据点的数量，并将计数作为一个新的属性 `datapoints` 添加。
- en: Collect key markets data in single array called `markets` for easy interaction
    access.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集关键市场数据到一个名为 `markets` 的单一数组中，以便于轻松访问交互。
- en: Finally, it will produce a color scale we so dearly need for the hexagon coloring.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将产生我们迫切需要的用于六边形着色的颜色刻度。
- en: 'Here we go:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We start by initializing a `maxCount` variable that will later have the maximum
    number of farmers' markets in a single hexagon. We’ll need this for the color
    scale.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化一个 `maxCount` 变量，它将后来包含单个六边形中农民市场的最大数量。我们需要这个变量来设置颜色刻度。
- en: 'Next, we’ll loop through all the layout and data points:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将遍历所有的布局和数据点：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we will get rid of all the layout point objects with `splice()` if the
    `datapoint` property holds a `0`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将移除所有 `datapoint` 属性值为 `0` 的布局点对象。
- en: 'Next, we will create the rolled-up data. There will be two rolled-up data elements:
    an integer representing the total count of farmers'' markets within the hexagon
    and an array of market data we can use for later interaction. First, we will set
    up the variables:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建卷曲的数据。将有两个卷曲数据元素：一个表示六边形内农民市场的总数，以及一个我们可以用于后续交互的市场数据数组。首先，我们将设置变量：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We loop through each object within the hexagon array of objects, and once we’ve
    collected the data, we add it as keys to the array. This data is now on the same
    level as the *x* and *y* coordinates for the hex points.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历六边形对象数组中的每个对象，一旦收集了数据，我们就将其作为键添加到数组中。现在这些数据与六边形点的 *x* 和 *y* 坐标处于同一级别。
- en: Note that we could have taken a shortcut to summarize the count of markets.
    Our `datapoints` property just counts the number of elements in the array. This
    is exactly the same as what the in-built `Array.length` property does. However,
    this is a more conscious and descriptive way of doing it without adding much more
    complexity.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过简化市场计数来取捷径。我们的 `datapoints` 属性只是计算数组中的元素数量。这与内置的 `Array.length` 属性所做的是完全相同的。然而，这是一个更自觉且更具描述性的方法，而且不会增加太多的复杂性。
- en: 'The last thing we do in the loop is to update `maxCount` if the count value
    of this particular hexagon is higher than the `maxCount` value of all previous
    hexagons we looped through:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的最后一件事是更新 `maxCount`，如果特定六边形的计数值高于我们之前遍历的所有六边形的 `maxCount` 值：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The last thing we do in our roll-up function is to create our `colorScale`.
    We’re using the *Viridis* color scale, which has great properties for visualizing
    count data. Note that *Viridis* maps low numbers to purple and high numbers to
    yellow. However, we want high numbers to be darker (more purple) and low numbers
    to be lighter (more yellow). We will achieve this by just flipping our domain
    mapping.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`roll-up`函数中，我们最后要做的事情是创建我们的`colorScale`。我们使用的是*Viridis*颜色尺度，它具有很好的可视化计数数据的特性。请注意，*Viridis*将低数值映射到紫色，高数值映射到黄色。然而，我们希望高数值更暗（更多紫色），低数值更亮（更多黄色）。我们将通过翻转我们的域映射来实现这一点。
- en: 'The way scales work internally is that each value we feed from our domain will
    be normalized to a value between *0* and *1*. The first number we set in the array
    we pass to `.domain()` will be normalized to *0—*that''s `maxCount` or 169 in
    our case. The second number (1) will be normalized to *1*. The output range will
    also be mapped to the range from *0* to *1*, which for *Viridis* means *0 = purple*
    and *1 = yellow*. When we send a value to our scale, it will normalize the value
    and return the corresponding range value between *0* and *1*. Here is what happens
    when we feed it the number 24:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尺度内部工作的方式是，我们从域中提供的每个值都将被归一化到*0*到*1*之间的值。我们传递给`.domain()`数组的第一个数字将被归一化到*0*——在我们的例子中是`maxCount`或169。第二个数字（1）将被归一化到*1*。输出范围也将映射到*0*到*1*的范围，对于*Viridis*来说意味着*0
    = 紫色*和*1 = 黄色*。当我们向我们的尺度发送一个值时，它将归一化该值并返回*0*到*1*之间的相应范围值。以下是将数字24输入时的结果：
- en: The scale receives *24* as an input (as in `colorScale(24)`).
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尺度接收*24*作为输入（如`colorScale(24)`）。
- en: According to the `.domain()` input (`[max, min]` rather than `[min, max]`),
    the scale normalizes *24* to *0.84.*
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`.domain()`输入（`[max, min]`而不是`[min, max]`），尺度将*24*归一化到*0.84*。
- en: Next, the scale queries the *Viridis* interpolator about which color corresponds
    to the value of *0.84* on the *Viridis* color scale. The interpolator comes back
    with the color `#a2da37`, which is a light green. This makes sense, as 0.84 is
    closer to 1, which represents yellow. Light green is obviously closer to yellow
    than to dark purple, which is encoded as *0* by the interpolator.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尺度查询*Viridis*插值器，询问哪种颜色对应于*Viridis*颜色尺度上的*0.84*值。插值器返回颜色`#a2da37`，这是一种浅绿色。这很有道理，因为0.84更接近1，代表黄色。浅绿色显然比深紫色更接近黄色，而插值器将其编码为*0*。
- en: That was is it!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了！
- en: Nearly. The very last thing we have to do is to jump into our `drawHexmap()`
    function and change the hexagon coloring to our `colorScale:`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎是。我们最后要做的就是跳入我们的`drawHexmap()`函数，并将六边形的着色更改为我们的`colorScale:`。
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the hexagons don’t cover any markets, their data points property will be
    0 and we won’t color it. Otherwise, we pick the appropriate Viridis color.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果六边形不覆盖任何市场，其数据点的属性将为0，我们不会对其进行着色。否则，我们选择适当的Viridis颜色。
- en: 'Here it is:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是它：
- en: '![](img/8b646bfc-a4db-4f86-b792-babd53d1d1b6.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b646bfc-a4db-4f86-b792-babd53d1d1b6.png)'
- en: A very yellow hexbin map
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常黄色的六边形图
- en: 'Looks pretty yellow, doesn’t it? The problem is that we have a few outliers
    in our data. That single dark purple dot on the East Coast is New York, which
    has significantly more farmers'' markets than any other area (169). Washington
    and Boston are busy as well. However, that makes our visual less interesting.
    Looking at the distribution of numbers tells us that most hexagons enclose 20
    or less markets:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很黄，不是吗？问题是我们的数据中有一两个异常值。东海岸的那个单独的深紫色点就是纽约，它的农民市场数量比任何其他地区都多得多（169）。华盛顿和波士顿也很繁忙。然而，这使得我们的视觉效果不那么有趣。观察数字的分布告诉我们，大多数六边形包含20个或更少的农民市场：
- en: '![](img/ba805ff6-779c-4391-8b98-363890f4abfb.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba805ff6-779c-4391-8b98-363890f4abfb.png)'
- en: Number of farmers' markets per hexagon
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个六边形内的农民市场数量
- en: The highest number of markets per hexagon, however, is currently 169\. We can
    do two things here. We can either choose a lower value as our maximum color scale
    value, say 20\. That would only scale our values from 1 to 20 to the *Viridis*
    spectrum. All hexagons with higher values would receive the maximum colour (purple)
    by default.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个六边形内的市场数量最高目前是169。我们可以做两件事。我们可以选择一个较低的值作为我们的最大颜色尺度值，比如说20。这样，我们的值将从1缩放到20到*Viridis*光谱。所有具有更高值的六边形将默认接收最大颜色（紫色）。
- en: 'A more elegant alternative is to use an **exponential interpolator** for the
    color scale. Our domain would map not linearly but exponentially to our color
    output, effectively reaching the end of our color spectrum (purple) with much
    lower values. To achieve this, we just need a new color scale with a custom interpolator.
    Let''s take a look at the code first:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更优雅的替代方案是使用 **指数插值器** 作为颜色刻度。我们的域将不是线性映射，而是指数映射到我们的颜色输出，有效地使用更低的值达到颜色光谱的末端（紫色）。为了实现这一点，我们只需要一个新的具有自定义插值器的颜色刻度。让我们首先看看代码：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What exactly are we doing here? Let''s reconsider the scaling steps we went
    through in the preceding code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里究竟做了什么？让我们重新考虑在前面代码中经历的缩放步骤：
- en: The scale receives a number *24* (as in `colorScale(24)`).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刻度接收一个数字 *24*（如在 `colorScale(24)` 中）。
- en: According to the `.domain()` input (`[max, min]` rather than `[min, max]`),
    the scale normalizes *24* to 0.84\. No change for points *1* and *2*.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 `.domain()` 输入（`[max, min]` 而不是 `[min, max]`），刻度将 *24* 归一化为 0.84。对于点 *1*
    和 *2* 没有变化。
- en: With the old `colorScale`, we just waved through this *linearly normalized value*
    between *1* and *0* without us interfering. Now, we catch it as an argument to
    a callback. Convention lets us call this `t`. Now, we can use and transform this
    however we desire. As we saw previously, many hexagons encircle 1 to 20 markets,
    very few encircle more. So we want to traverse the majority of the Viridis color
    space in the lower range of our values so that the color scale encodes the interesting
    part of our data. How do we do this?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在旧的 `colorScale` 中，我们只是简单地通过这个在 *1* 和 *0* 之间的 *线性归一化值*，没有我们的干预。现在，我们将其作为一个回调函数的参数。惯例让我们称这个为
    `t`。现在，我们可以按需使用和转换它。正如我们之前看到的，许多六边形围绕着 1 到 20 个市场，围绕更多的很少。因此，我们希望在值域的较低范围内遍历 Viridis
    颜色空间的大部分，以便颜色刻度编码我们数据的有兴趣的部分。我们如何做到这一点？
- en: Before we pass `t` to our color interpolator, we set it to the *power of 10*.
    We can use a different exponent, but *10* works fine. In general, taking the power
    of a number between *0* and *1* returns a smaller number. The higher the power,
    the smaller the output will be. Our linear `t` was *0.84*; our exponential `tNew`
    equals *0.23*.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将 `t` 传递给我们的颜色插值器之前，我们将其设置为 *10 的幂*。我们可以使用不同的指数，但 *10* 就足够了。一般来说，取一个介于 *0*
    和 *1* 之间的数字的幂会得到一个更小的数字。幂越高，输出就越小。我们的线性 `t` 是 *0.84*；我们的指数 `tNew` 等于 *0.23*。
- en: Finally, we pass `tNew` to the *Viridis* interpolator, which spits out the respective—much
    darker—color.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将 `tNew` 传递给 *Viridis* 插值器，它输出相应的——更暗的——颜色。
- en: 'Let''s graph this transformation to clarify:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制这个转换以澄清：
- en: '![](img/2c99ded5-f9ee-434e-9985-91e0df2bce73.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c99ded5-f9ee-434e-9985-91e0df2bce73.png)'
- en: Linear versus exponential color interpolation
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 线性与指数颜色插值
- en: 'The *x axis* shows the input values, the *y axis* shows our scale-normalized
    value `t` that we send to the interpolator to retrieve a corresponding color.
    The **left graph** shows what a linear interpolation does. It linearly translates
    the increase of values to the decrease in `t`. The curve in the **right graph**
    shows us how our adjusted `tNew` behaves after setting `t` to the *power of 10*:
    we enter the lower regions of `t` (the more purple regions) with much smaller
    input values. Put differently, we traverse the color space from yellow to purple
    in a much smaller range of domain values. Piping our example value of 24 through
    a *linear interpolation* would return a yellowish green; piping it through our
    *exponential interpolation* already returns a purple value from the end of the
    color spectrum.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*x 轴* 显示输入值，*y 轴* 显示我们发送到插值器以检索相应颜色的刻度归一化值 `t`。**左图** 显示线性插值做了什么。它将值的增加线性地转换为
    `t` 的减少。**右图** 中的曲线显示我们调整后的 `tNew` 在将 `t` 设置为 *10 的幂* 后的行为：我们使用更小的输入值进入 `t` 的较低区域（更紫的区域）。换句话说，我们在一个更小的域值范围内遍历从黄色到紫色的颜色空间。将我们的示例值
    24 通过 *线性插值* 会返回一个黄绿色的值；通过我们的 *指数插值* 已经返回了颜色光谱末端的紫色值。'
- en: 'The main win this brings is that color differences can be seen where the data
    is rather than where the gap between the main data cluster and the outlier is.
    Here is our hexbin map with an exponential scale:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主要的优势是，颜色差异可以在数据所在的位置而不是在主要数据簇和异常值之间的差距处看到。以下是我们的指数刻度六边形图：
- en: '![](img/87e8893d-023b-44c8-aedb-ba89420c07ac.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87e8893d-023b-44c8-aedb-ba89420c07ac.png)'
- en: A more interestingly colored hexbin map
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有趣颜色的六边形图
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-6](https://larsvers.github.io/learning-d3-mapping-11-6)
    the and code example at [11_06.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_06.html).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤：[https://larsvers.github.io/learning-d3-mapping-11-6](https://larsvers.github.io/learning-d3-mapping-11-6)，以及代码示例：[11_06.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_06.html)。
- en: Let’s just revel in our achievement for a moment, but are we done? We’re itching
    to explore this map a little more. After all, people are used to playing with
    maps, trying to locate themselves in them or move from one area to the other with
    ease. That’s what we will allow for in our last step.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时陶醉于我们的成就，但我们已经完成了吗？我们迫不及待地想更深入地探索这个地图。毕竟，人们习惯于玩地图，试图在其中定位自己或轻松地从一处移动到另一处。这就是我们在最后一步将允许的事情。
- en: Turning our visual into an interactive app
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的视觉应用转变为一个交互式应用
- en: You have officially built a hexbin map, and that was indeed the key focus of
    this chapter. However, in this last section, let’s leisurely consider how we might
    make this more engaging and informative for ourselves and our users. We won’t
    go into as much detail as in the previous sections, but will go through general
    steps about how to improve the app.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您已正式构建了一个六边形地图，这确实是本章的关键焦点。然而，在本节的最后，让我们悠闲地考虑如何使这个应用对我们和我们的用户来说更加吸引人和信息丰富。我们不会像前几节那样详细，但会概述如何改进应用的一般步骤。
- en: 'Here’s a list of what we can do:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份我们可以做的事情列表：
- en: Show the markets in a list on hover.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在悬停时以列表形式显示市场。
- en: Let the user change the hexagon size.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户更改六边形的尺寸。
- en: Let the user change the exponent for the color scale interpolator.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户更改颜色插值器的指数。
- en: Show which markets sell specific products, e.g. cheese, wine, seafood, etc.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示哪些市场销售特定产品，例如奶酪、葡萄酒、海鲜等。
- en: Encode a second variable as hexagon size.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个变量编码为六边形大小。
- en: The first is standard. The second and third point would be very helpful for
    exploration of the data. The fourth point is indeed possible, as the data also
    covers variables specifying what products each market sells. The last point would
    be good for our own practice with the `d3.hexbin()` module.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是标准的。第二和第三点对于数据探索非常有帮助。第四点是可能的，因为数据还涵盖了指定每个市场销售什么产品的变量。最后一点将有助于我们使用`d3.hexbin()`模块进行实践。
- en: We won’t go into detail of each of these points, but do take a look at the finished
    app at [https://larsvers.github.io/learning-d3-mapping-11-8](https://larsvers.github.io/learning-d3-mapping-11-8).
    The code is commented and available as example [11_08.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html)
    in the `Chapter 11` folder at [https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细说明这些点的每个细节，但请查看完成的[https://larsvers.github.io/learning-d3-mapping-11-8](https://larsvers.github.io/learning-d3-mapping-11-8)应用。代码有注释，并在`Chapter
    11`文件夹中的示例[11_08.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html)中提供，位于[https://github.com/larsvers/Learning-D3.js-4-Mapping](https://github.com/larsvers/Learning-D3.js-4-Mapping)上。
- en: Adding additional information on hover and click
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在悬停和点击时添加额外信息
- en: 'Tooltips are a helpful exploration technique for most visualizations in order
    to give the user details on a certain data point or area. In this case, the smallest
    data units of the app are the hexagons. However, some of the hexagons contain
    more information that would fit on a tooltip—up to 169 as we’ve seen above. To
    allow the user to browse the markets per area, we will add a side panel listing
    all the markets in the hovered hexagon. This is how it could look:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 工具提示是大多数可视化中的一种有用的探索技术，以便向用户提供有关特定数据点或区域的信息。在这种情况下，应用的最小数据单元是六边形。然而，一些六边形包含更多适合工具提示的信息——多达169个，如我们上面所见。为了允许用户按区域浏览市场，我们将添加一个侧面板，列出所有悬停六边形中的市场。这将是它的样子：
- en: '![](img/1ba70117-040b-469b-81c9-515964e91d8b.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ba70117-040b-469b-81c9-515964e91d8b.png)'
- en: Interactive hexbin map with title, tooltip, and list of markets per hexagon
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 带有标题、工具提示和每个六边形市场列表的交互式六边形地图
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-8](https://larsvers.github.io/learning-d3-mapping-11-8).
    the and code example at [11_08.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html).
    Please use a recent version of the Chrome browser to view or work along these
    examples.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤的[https://larsvers.github.io/learning-d3-mapping-11-8](https://larsvers.github.io/learning-d3-mapping-11-8)。代码示例在[11_08.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html)。请使用较新的Chrome浏览器查看或工作在这些示例中。
- en: The list changes rapidly when the user moves around, so a click on a hexagon
    would lock the list view so that the user can explore and potentially use the
    links to get to the markets' websites.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户移动时，列表会迅速变化，因此点击六边形会锁定列表视图，以便用户可以探索并可能使用链接访问市场的网站。
- en: Changing the hexagon size
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变六边形的大小
- en: 'A key advantage of hexbin maps compared to dot density maps is that interaction
    is easier. If you have many dots on a map, you might have to keep them small (1-3
    pixels) to convey a good sense of the data. Such small targets are hard to catch
    with the mouse. Furthermore, some dots will inevitably overlap, so you can’t get
    to them at all. In a hexbin map, each hexagon is reachable, if it’s not too small.
    I would even argue that our choice of hexagon size might be a little small with
    **3.5** pixels. Let’s add a drop-down control, allowing the user to change the
    size of area. Here are some hexagon size variants:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与点密度地图相比，六边形地图的一个关键优势是交互更容易。如果你在地图上有许多点，你可能必须保持它们很小（1-3像素）以传达良好的数据感。这样的小目标很难用鼠标捕捉。此外，一些点不可避免地会重叠，因此你根本无法到达它们。在六边形地图中，每个六边形都是可到达的，如果它不是太小。我甚至可以说，我们选择的六边形大小可能有点小，**3.5**像素。让我们添加一个下拉控制，允许用户更改区域的大小。以下是一些六边形大小变体：
- en: '![](img/e27fd0fc-880f-403a-8b4c-61c813abb740.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e27fd0fc-880f-403a-8b4c-61c813abb740.png)'
- en: Different hex radii
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的六边形半径
- en: 'Two notes of caution here: when building a regularly tessellated hexbin map
    as we do, you might run into the **border problem**. Imagine a large hexagon just
    touching the tip of Florida. 5% of the hexagon is over land, 95% is over sea.
    However, the map readers can’t see the real coastal line. They assume the hexagon
    represents the coastal line, covering 100% land area. If that corner of Florida
    has a high point density, this hexagon should encode it. However, as it only covers
    5% of the land, and maybe around 5% of the dot density, it appears to the reader
    as though the coast of Florida is void of dots.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个注意事项：当我们构建像我们这样的规则六边形镶嵌地图时，可能会遇到**边界问题**。想象一个六边形刚好接触佛罗里达州的尖端。这个六边形的5%在陆地上，95%在海上。然而，地图读者看不到真正的海岸线。他们假设六边形代表海岸线，覆盖100%的陆地面积。如果佛罗里达州这个角落有高密度点，这个六边形应该编码它。然而，因为它只覆盖了5%的陆地，也许大约5%的点密度，它对读者来说就像佛罗里达州的海岸线没有点一样。
- en: Another problem that becomes apparent when you look at the different sized hexagons
    above is the so-called **modifiable areal unit problem** (MAUD). The summary values
    we encode are highly dependent on the shape and the scale of our aggregation units.
    This is a problem, as the results might differ when the same analysis is applied
    to the same data. You can see the *scale effect* above; changing hexagon size
    results in a different perception of farmers markets’ density. The *shape* or
    *zone effect* can be more problematic. Using a different shape at the same scale,
    for example, 10-mile squares instead of 10-mile hexagons can change the aggregate
    and hence analysis. It then becomes an analysis of different bins rather than
    of the underlying data. This effect is particularly problematic when representing
    non-arbitrary units such as counties or census tracts, which might change in shape
    over time but remain consistent in the readers’ minds.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当你观察上面不同大小的六边形时，会出现另一个明显的问题，即所谓的**可修改面积单位问题**（MAUD）。我们编码的汇总值高度依赖于我们聚合单元的形状和规模。这是一个问题，因为当相同的分析应用于相同的数据时，结果可能会有所不同。你可以在上面看到*尺度效应*；改变六边形的大小会导致对农贸市场密度的不同感知。*形状*或*区域效应*可能更加成问题。例如，使用与相同规模不同的形状，比如10英里正方形而不是10英里六边形，可以改变总体和因此分析。这样，分析就变成了对不同箱子的分析，而不是对基础数据的分析。这种效应在表示非任意单位（如县或人口普查区）时尤其成问题，这些单位可能会随时间改变形状，但在读者的心目中保持一致。
- en: You could solve the border problem by overlaying the country outline, but the
    key step to alleviate any of these problems is your awareness, explaining potential
    issues to readers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过叠加国家轮廓来解决边界问题，但缓解任何这些问题的关键步骤是您的意识，向读者解释潜在问题。
- en: Changing the color scale interpolator
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变颜色比例插值器
- en: 'In exploratory displays, it can be beneficial for users to change the scale
    in order to discover data areas of interest. By allowing our users to adjust the
    interpolator, they can focus on value ranges of their interest. The parameter
    we want to expose is the exponent our exponential interpolator uses:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索性显示中，用户改变比例以发现感兴趣的数据区域可能是有益的。通过允许我们的用户调整插值器，他们可以关注他们感兴趣的价值范围。我们想要公开的参数是我们指数插值器使用的指数：
- en: '![](img/bbacf15b-4f7b-4172-b953-df84a6d96839.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbacf15b-4f7b-4172-b953-df84a6d96839.png)'
- en: Changing the color scale interpolator
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 改变颜色比例插值器
- en: Browsing different datasets
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览不同的数据集
- en: 'The farmers'' market data we are using here also offers over 29 binary variables,
    indicating what products or facilities markets offer. Multiple datasets showing
    the geographical distribution of markets with different produce would be a good
    option. Alternatively, we can add a drop-down menu for the users to choose what
    products they are most interested in. Here are some examples:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的农民市场数据也提供了超过29个二元变量，表明市场提供的产品或设施。展示不同产品地理分布的多个数据集是一个好选择。或者，我们可以为用户添加下拉菜单，让他们选择他们最感兴趣的产品。以下是一些示例：
- en: '![](img/128c37e6-c557-41f9-aeaf-6100359ecf15.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/128c37e6-c557-41f9-aeaf-6100359ecf15.png)'
- en: Hexbin maps of different datasets (we chose 20 of the 29 binary variables available
    for the app)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不同数据集的六边形图（我们选择了29个二元变量中的20个）
- en: Encoding data as hexagon size
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据编码为六边形大小
- en: 'So far, we have encoded data only as color. `d3.hexbin()` makes it very easy
    to encode data by hexagon size. Theoretically, you just have to go to your `drawHexmap()`
    function and change a single line:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只将数据编码为颜色。`d3.hexbin()`使得通过六边形大小编码数据变得非常简单。理论上，你只需进入你的`drawHexmap()`函数并更改一行：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You just add a hexagon-specific radius to your `hexbin` path generator (as an
    optional argument to the `.hexagon()` method), which in our case above makes sure
    that each hexagon gets a radius as little or large as this hexagon’s count of
    farmers' markets. However, that would look excessive as most would get a radius
    of *0* and some would get a radius of over *100*. I’ll spare you the visual.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需将六边形特定的半径添加到您的`hexbin`路径生成器中（作为`.hexagon()`方法的可选参数），在我们的例子中，这确保每个六边形都得到一个与该六边形农民市场的数量一样小或大的半径。然而，这看起来会过于夸张，因为大多数将得到半径为*0*，而一些将得到超过*100*的半径。我将省略视觉效果。
- en: 'Instead, we will add the variable `radiusScale` to the mix (in `rollUpHexPoints()`),
    which will scale sizes from between `3.5` to `15` pixels:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将添加变量`radiusScale`到混合中（在`rollUpHexPoints()`中），这将使大小在`3.5`到`15`像素之间缩放：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can now use it when you draw the hexagons, which you should also sort ascendingly
    so that the larger ones aren’t covered by the many small hexagons around them:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您绘制六边形时，您也应该按升序排序，以便较大的六边形不会被周围的许多小六边形覆盖：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You get hexagons not only colored, but also sized by the number of markets
    within the hexagon:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您得到的六边形不仅着色，而且根据六边形内的市场数量进行大小编码：
- en: '![](img/0e892f98-f863-496a-b7aa-4a1a57c309f1.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e892f98-f863-496a-b7aa-4a1a57c309f1.png)'
- en: Number of markets encoded as color AND radius size
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 市场数量编码为颜色和半径大小
- en: View this step in the browser at [https://larsvers.github.io/learning-d3-mapping-11-7](https://larsvers.github.io/learning-d3-mapping-11-7)
    and the code example at [11_07.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_07.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看此步骤的链接为[https://larsvers.github.io/learning-d3-mapping-11-7](https://larsvers.github.io/learning-d3-mapping-11-7)，代码示例在[11_07.html](https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_07.html)。
- en: We double encode the number of markets as color and size here. That’s sometimes
    useful, but you have two encoding channels at your disposal here, which you can
    use for two variables to produce a **bi-variate hexbin map**. It's your choice.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里通过颜色和大小双重编码市场数量。这有时很有用，但您现在有两个编码通道可供使用，您可以使用两个变量来生成**双变量六边形图**。这是您的选择。
- en: We’ve covered a few options to improve and add to our hexbin map. There are
    certainly more options to have fun with. For example, we haven’t touched on zooming
    and panning, which is, of course, a standard map interaction technique and would
    be a good addition for people to dive into smaller hexagons. I’m sure that you
    can think of more ways to build on it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了几种改进和添加到我们的六边形地图的选项。当然，还有更多选项可以让我们玩得开心。例如，我们还没有涉及到缩放和平移，这当然是一种标准的地图交互技术，对于想要深入研究更小六边形的人来说，这将是一个很好的补充。我相信你还能想到更多构建它的方法。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started by comparing a few map visualization techniques. We covered the uses,
    benefits, and caveats of choropleth maps, cartograms, and dot density maps. We
    moved swiftly to the hexagon shape and explored how its geometrical properties
    can help choropleth and dot density maps.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先比较了几种地图可视化技术。我们介绍了等值线图、地图图和点密度图的使用、优点和注意事项。我们迅速转向六边形形状，并探讨了其几何属性如何帮助等值线图和点密度图。
- en: Most of the chapter was, however, spent in the mapping workshop, building a
    hexbin map from scratch. We could have built a simple hexbin map, just covering
    areas with datapoints, but our goal was to shape a map entirely of hexagons for
    the kicks and the aesthetics. That meant a little more data preparation—creating
    a map-shaped layout grid, joining the datapoints, and eventually adding and color-encoding
    the hexagons—but doesn’t it look pretty?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大部分时间都花在了制图工作坊中，从头开始构建一个六边形地图。我们本可以构建一个简单的六边形地图，只需覆盖有数据点的区域，但我们的目标是打造一个完全由六边形构成的地图，以追求乐趣和美观。这意味着需要更多的数据准备——创建地图形状的布局网格，连接数据点，最终添加并使用颜色编码六边形——但难道它看起来不漂亮吗？
- en: Finally, we turned our static map into an interactive application, handing significant
    control over shape and information gain to the user. A lot can be achieved with
    interaction, especially with maps!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将静态地图转换成了一个交互式应用程序，将形状和信息获取的控制权交给了用户。交互可以实现很多事情，尤其是对于地图来说！
- en: 'After having created a fully functional interactive visualization, you might
    want to show it to the world. There are many ways to claim some online real estate;
    in the next chapter, we''ll look at a conveniently simple one: *GitHub pages*.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了一个完全功能性的交互式可视化之后，你可能想要向世界展示它。有许多方式可以在线占据一些空间；在下一章中，我们将探讨一个方便简单的方法：*GitHub页面*。
