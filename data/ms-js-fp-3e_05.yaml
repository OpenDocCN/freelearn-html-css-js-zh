- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Programming Declaratively – A Better Style
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式编程 – 更好的风格
- en: 'Up to now, we haven’t really been able to appreciate the possibilities of **functional
    programming** (**FP**) as it pertains to working in a higher-level, declarative
    fashion. In this chapter, we will correct this and start producing shorter, more
    concise, and easier-to-understand code, by using some **higher-order functions**
    (**HOFs**) —that is, functions that take functions as parameters, such as the
    following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有真正能够欣赏到**函数式编程**（**FP**）在以高级、声明式方式工作时的可能性。在本章中，我们将纠正这一点，并通过使用一些**高阶函数**（**HOFs**）——即接受函数作为参数的函数，例如以下内容——来生成更短、更简洁、更易于理解的代码：
- en: '`reduce()` and `reduceRight()` to apply an operation to a whole array, reducing
    it to a single result'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce()` 和 `reduceRight()` 将操作应用于整个数组，将其缩减为单个结果'
- en: '`map()` to transform one array into another by applying a function to each
    of its elements'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()` 通过对每个元素应用函数将一个数组转换成另一个数组'
- en: '`flat()` to make a single array out of an array of arrays'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flat()` 将数组中的数组转换成一个单一的数组'
- en: '`flatMap()` to mix together mapping and flattening'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap()` 将映射和扁平化混合在一起'
- en: '`forEach()` to simplify writing loops by abstracting the necessary looping
    code'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach()` 通过抽象必要的循环代码来简化循环的编写'
- en: 'We’ll also be able to perform searches and selections with the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将能够使用以下方法进行搜索和选择：
- en: '`filter()` to pick some elements from an array'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()` 从数组中挑选一些元素'
- en: '`find()` and `findIndex()` to search for elements that satisfy a condition'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find()` 和 `findIndex()` 用于搜索满足条件的元素'
- en: A pair of predicates, `every()` and `some()`, to check an array for a Boolean
    test
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对断言函数，`every()` 和 `some()`，用于检查数组中的布尔测试
- en: Using these functions will let you work more declaratively, and you’ll see that
    your focus will shift to what you need to do and not so much to how it’s going
    to be done; the dirty details are hidden inside our functions. Instead of writing
    a series of possibly nested loops, we’ll focus on using functions as building
    blocks to specify our desired result.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数将使你能够以更声明式的方式工作，你会发现你的焦点将转移到你需要做什么，而不是那么关注它是如何完成的；脏细节都隐藏在我们的函数内部。我们不会编写一系列可能嵌套的循环，而是将重点放在使用函数作为构建块来指定我们期望的结果。
- en: We will use these functions to work with events in a declarative style, as we’ll
    see in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing Design
    Patterns*, when we use the **observer** pattern. We will also be able to work
    in a *fluent* fashion, in which the output of a function becomes the input of
    the next one, a style we will look at later.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些函数以声明式方式处理事件，正如我们将在[*第11章*](B19301_11.xhtml#_idTextAnchor204)中看到的，*实现设计模式*，当我们使用**观察者模式**时。我们还将能够以*流畅*的方式工作，其中函数的输出成为下一个函数的输入，这种风格我们将在稍后探讨。
- en: Transformations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: 'The first set of operations that we are going to consider works on an array
    and processes it in the base of a function to produce certain results. There are
    several possible results: a single value with the `reduce()` operation, a new
    array with `map()`, or just about any kind of result with `forEach()`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的第一组操作是在数组上进行的，它基于一个函数来处理并产生某些结果。有几种可能的结果：使用 `reduce()` 操作的单个值，使用 `map()`
    的新数组，或者使用 `forEach()` 的几乎所有类型的结果。
- en: Caring about inefficiency
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关注效率
- en: If you google around, you will find some articles declaring that these functions
    are inefficient because a loop done by hand can be faster. This, while possibly
    true, is practically irrelevant. Unless your code really suffers from speed problems
    and you can determine that the slowness derives from using these HOFs, trying
    to avoid them using longer code, with a higher probability of bugs, simply doesn’t
    make much sense.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你四处搜索，你将找到一些文章宣称这些函数效率低下，因为手动编写的循环可能更快。虽然这可能正确，但实际上并不重要。除非你的代码真的存在速度问题，并且你可以确定这种缓慢是由于使用这些
    HOFs 而导致的，否则试图通过更长的代码来避免它们，这样做更有可能引入错误，这并没有太多意义。
- en: Let’s start by considering the preceding list of functions in order, beginning
    with the most general of all, which, as we’ll see, can even be used to emulate
    the rest of the transformations in this chapter!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考虑前面列出的函数列表开始，从最一般的一个开始，正如我们将看到的，它甚至可以用来模拟本章中其余的转换！
- en: Reducing an array to a value
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数组缩减为值
- en: 'Answer this question: how many times have you had to loop through an array,
    performing an operation (say, summing) to produce a single value (maybe the sum
    of all the array values) as a result? Probably many, many, many times. This kind
    of operation can usually be implemented functionally by applying `reduce()` and
    `reduceRight()`. Let’s start with the former!'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这个问题：你有多少次需要遍历一个数组，执行一个操作（比如求和）来得到一个单一的结果（可能是所有数组值的总和）？可能很多很多次。这种操作通常可以通过应用
    `reduce()` 和 `reduceRight()` 函数以函数式的方式实现。让我们从前者开始！
- en: To fold or not to fold
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要折叠还是不折叠
- en: 'Time for some terminology! In usual FP parlance, we speak of `reduce()` is
    `reduceRight()` is correspondingly known as **foldr**. In category theory terms,
    both operations are **catamorphisms**: the reduction of all the values in a container
    down to a single result.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候引入一些术语了！在通常的函数式编程（FP）用语中，我们说 `reduce()`，相应地，`reduceRight()` 被称为 **foldr**。在范畴论术语中，这两个操作都是
    **猫形态学**：将容器中所有值缩减为一个单一结果。
- en: 'The inner workings of the `reduce()` function are illustrated in *Figure 5**.1*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()` 函数的内部工作原理在 *图 5**.1* 中展示：'
- en: '![Figure 5.1 – The workings of the reduce() operation](img/Figure_5.1_B19301.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – reduce() 操作的工作原理](img/Figure_5.1_B19301.jpg)'
- en: Figure 5.1 – The workings of the reduce() operation
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – reduce() 操作的工作原理
- en: See how `reduce()` traverses the array, applying a reducing function to each
    element and the accumulated value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 `reduce()` 如何遍历数组，将一个累加函数应用于每个元素和累积值。
- en: 'Why should you always try to use `reduce()` or `reduceRight()` instead of hand-coded
    loops? The following points might answer this question:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该总是尝试使用 `reduce()` 或 `reduceRight()` 而不是手写的循环？以下要点可能回答了这个问题：
- en: All the aspects of loop control are automatically taken care of, so you don’t
    even have the possibility of an off-by-one mistake
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环控制的各个方面都自动处理，因此你甚至没有出现一个错误的可能性
- en: The initialization and handling of the result values are also done implicitly
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化和处理结果值也是隐式完成的
- en: Unless you work really hard at being impure and modifying the original array,
    your code will be free of side-effects
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你非常努力地使代码不纯并修改原始数组，否则你的代码将没有副作用
- en: Now that we can `reduce()` an array, let’s see some of its practical use cases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够使用 `reduce()` 来处理数组，让我们看看它的实际应用案例。
- en: Summing an array
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 求和数组
- en: The most common example of the application of `reduce()`, usually seen in all
    textbooks and on all web pages, is the summing of all of the elements of an array.
    So, to keep with tradition, let’s start with precisely this example!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()` 的最常见应用示例，通常在所有教科书中和所有网页上都可以看到，就是计算数组中所有元素的总和。所以，为了保持传统，让我们从精确的这个例子开始！'
- en: 'To reduce an array, you must provide a **dyadic** function (a function with
    two parameters; **binary** would be another name for that) and an initial value.
    In our case, the function will sum up its two arguments. Initially, the function
    will be applied to the provided initial value and the first element of the array.
    For us, the initial value to provide is a zero, and the first result will be the
    first element itself. Then, the function will be applied again, this time, to
    the result of the previous operation and the second element of the array, and
    so the second result will be the sum of the first two elements of the array. Progressing
    in this fashion along the whole array, the final result will be the sum of all
    its elements:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩减一个数组，你必须提供一个 **二元** 函数（具有两个参数的函数；“二进制”是这个的另一个名称）和一个初始值。在我们的例子中，这个函数将累加其两个参数。最初，这个函数将应用于提供的初始值和数组的第一个元素。对我们来说，要提供的初始值是零，第一个结果将是数组的第一个元素本身。然后，这个函数将再次应用，这次是应用于前一个操作的结果和数组的第二个元素，因此第二个结果将是数组前两个元素的和。以这种方式沿着整个数组进行，最终结果将是所有元素的总和：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You don’t actually need the sum definition—you could have just written `myArray.reduce((x,y)
    => x+y, 0)`—however, when written in this fashion, the meaning of the code is
    clearer: you want to reduce the array to a single value by `sum`-ming all its
    elements. (Would we be forgetting data types with this? No; TypeScript can deduce
    all the implied types on its own.)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上不需要求和的定义——你只需写下 `myArray.reduce((x,y) => x+y, 0)` 即可——然而，当以这种方式编写时，代码的含义更清晰：你想要通过
    `sum`-ming 所有元素来将数组缩减为一个单一值。（我们会忘记数据类型吗？不会的；TypeScript 可以自己推断所有隐含的类型。）
- en: Instead of writing out the loop, initializing a variable to hold the result
    of the calculations, and going through the array doing the sums, you just declare
    which operation should be performed. This is what I meant when I said that programming
    with functions such as those we’ll see in this chapter allows you to work more
    declaratively, focusing on what rather than how.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必编写循环，初始化一个变量来保存计算结果，然后遍历数组进行求和，你只需声明应该执行的操作。这就是我说使用我们将在本章中看到的函数进行编程时，允许你更声明性地工作，专注于“是什么”而不是“如何”的意思。
- en: 'You can also even use `reduce()` without providing the initial value: if you
    skip it, the first value of the array will be used, and the internal loop will
    start with the second element of the array; however, be careful if the array is
    empty and you skipped providing an initial value, as you’ll get a runtime error!
    See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)
    for more details.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在不提供初始值的情况下使用 `reduce()`：如果你跳过了它，数组的第一项将被使用，内部循环将从数组的第二项开始；然而，如果你跳过了提供初始值，并且数组为空，那么你将得到一个运行时错误！有关更多详细信息，请参阅
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)。
- en: We can change the reducing function to see how it progresses through its calculations
    by just including a little bit of impurity!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过加入一点杂质来改变减少函数，以查看它是如何进行计算的。
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output would be as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see how the first sum was done by adding the initial value (`0`) and
    the first element of the array, how that result was used in the second addition,
    and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到第一个求和是通过将初始值（`0`）和数组的第一个元素相加来完成的，然后这个结果被用于第二个加法，依此类推。
- en: What’s in a name?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 名称中有什么？
- en: 'Part of the reason for the *foldl* name seen previously (at least, its ending,
    *l*) should now be clear: the reducing operation proceeds from left to right,
    from the first element to the last. You may wonder, however, how it would have
    been named if it had been defined by a right-to-left language (such as Arabic,
    Hebrew, Farsi, or Urdu) speaker!'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之前看到的 *foldl* 名称的部分原因（至少，它的结尾，*l*）现在应该很清楚了：减少操作是从左到右进行的，从第一个元素到最后一个元素。然而，你可能想知道，如果它是由从右到左的语言（如阿拉伯语、希伯来语、波斯语或乌尔都语）的说话者定义的，它会被如何命名！
- en: This example is common and well known; let’s do something more complicated.
    As we’ll find out, `reduce()` will be quite useful for many different objectives!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很常见，也很知名；让我们来做点更复杂的事情。正如我们将发现的，`reduce()` 将对许多不同的目标非常有用！
- en: Calculating an average
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算平均值
- en: Let’s do a bit more work. How do you calculate the average of a list of numbers?
    If you were explaining this to someone, your answer would surely be something
    such as *sum all the elements in the list and divide that by the number of elements*.
    In programming terms, this is not a procedural description (you don’t explain
    how to sum elements or traverse the array) but rather a declarative one since
    you say what to do, not how.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一些工作。你如何计算一列数字的平均值？如果你在向某人解释这个，你的答案肯定会是类似于 *将列表中的所有元素相加，然后除以元素的数量* 这样的话。在编程术语中，这并不是一个过程性描述（你不会解释如何累加元素或遍历数组），而是一个声明性描述，因为你只是说明了要做什么，而不是如何做。
- en: 'We can transform that description of the calculation into an almost self-explanatory
    function (In the *Averaging arrays* section of the next chapter, we’ll extend
    arrays to include an averaging method, based on this code.):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将计算描述转换为几乎无需解释的函数（在下一章的 *数组求平均值* 部分，我们将扩展数组以包括基于此代码的平均值方法）：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The definition of `average()` follows what a verbal explanation would be: sum
    the elements of the array, starting from 0, and divide by the array’s length—simpler:
    impossible!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`average()` 的定义遵循口头解释：从 0 开始累加数组的元素，然后除以数组的长度——更简单地说：不可能！'
- en: Not-so-safe reducing
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不太安全的减少
- en: As we mentioned in the previous section, you could also have written `arr.reduce(sum)`
    without specifying the initial value (`0`) for the reduction; it’s even shorter
    and closer to the verbal description of the required calculation. This, however,
    is less safe, because it would fail (producing a runtime error) should the array
    be empty. So, it’s better to always provide the starting value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，你也可以不指定累减的初始值（`0`）来编写`arr.reduce(sum)`；这甚至更短，更接近所需计算的口头描述。然而，这不太安全，因为如果数组为空，它将失败（产生运行时错误）。因此，最好始终提供起始值。
- en: 'This isn’t, however, the only way of calculating the average. The reducing
    function also gets passed the index of the current position of the array as well
    as the array itself, so you could do something different from last time:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是计算平均值的唯一方法。累减函数还传递了数组的当前位置索引以及数组本身，因此你可以做与上次不同的事情：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Given the current index (and, obviously, having access to the array’s length),
    we can do some trickery: in this case, our reducing `sumOrDivide()` function always
    sums values, but at the end of the array, it throws in a division so that the
    average value of the array will be returned. This is slick, but from the point
    of view of legibility, we can agree that the first version we saw was more declarative
    and closer to the mathematical definition than this second version.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 给定当前索引（以及显然，访问数组的长度），我们可以做一些小把戏：在这种情况下，我们的累减`sumOrDivide()`函数始终求和值，但在数组的末尾，它抛入一个除法，以便返回数组的平均值。这很酷，但从可读性的角度来看，我们可以同意我们最初看到的第一个版本更具有声明性，更接近数学定义，而不是这个第二个版本。
- en: Impurity warning!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不纯性警告！
- en: Getting the array and the index means you could also turn the function into
    an impure one. Avoid this! Anybody who sees a `reduce()` call will automatically
    assume it’s a pure function and will surely introduce bugs when using it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数组和索引意味着你也可以将函数转换为不纯的函数。避免这样做！任何看到`reduce()`调用的人都会自动假设它是一个纯函数，并且在使用它时肯定会引入错误。
- en: This example and the previous one required calculating a single result, but
    it’s possible to go beyond this and calculate several values in a single pass.
    Let’s see how.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子和上一个例子需要计算单个结果，但有可能超越这一点，在单次遍历中计算多个值。让我们看看如何。
- en: Calculating several values at once
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同时计算多个值
- en: 'What would you do if you needed to calculate two or more results instead of
    a single value? This would seem to be a case for providing a clear advantage for
    standard loops, but there’s a trick that you can use. Let’s yet again revisit
    the average calculation. We could do it the old-fashioned way by looping and simultaneously
    summing and counting all the numbers. Well, `reduce()` only lets you produce a
    single result, but there’s no reason you can’t return an object with as many fields
    as desired, as we did in the *Impure functions* section in [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069)*,*
    *Behaving Properly*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要计算两个或多个结果而不是单个值，这似乎是标准循环提供明确优势的情况，但你有一个可以使用的技巧。让我们再次回顾平均值的计算。我们可以通过循环和同时求和和计数所有数字来以传统方式完成它。嗯，`reduce()`只允许你产生一个结果，但你没有理由不能返回一个具有所需字段数量的对象，就像我们在[*第4章*](B19301_04.xhtml#_idTextAnchor069)*，*“不纯函数”*部分中做的那样：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Scrutinize the code carefully. We need two variables: one for the sum and one
    for the count of all numbers. We provide an object as the initial value for the
    accumulator, with two properties set to `0`, and our reducing function updates
    those two properties. After getting the final result with both `sum` and `count`,
    we divide to get the desired average.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细审查代码。我们需要两个变量：一个用于总和，一个用于所有数字的计数。我们提供一个对象作为累加器的初始值，其中两个属性设置为`0`，我们的累减函数更新这两个属性。在获得`sum`和`count`的最终结果后，我们进行除法以得到所需的平均值。
- en: 'By the way, there are options other than using an object. You could also produce
    any other data structure; let’s see an example with a tuple. The resemblance is
    pretty obvious:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，除了使用对象之外，还有其他选择。你也可以产生任何其他数据结构；让我们通过一个元组的例子来看看。这种相似性非常明显：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To be frank, I think it’s way more obscure than the solution with the object.
    Consider this an alternative (and not well-recommended) way of calculating many
    values simultaneously!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，我认为这比使用对象的方法更难以理解！请将此视为一种（并不特别推荐）同时计算多个值的方法！
- en: We have now seen several examples of the use of `reduce()`, so it’s high time
    to meet a variant of it, `reduceRight()`, which works similarly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了 `reduce()` 的几个使用示例，现在是时候来认识它的一个变体，`reduceRight()`，它的工作方式类似。
- en: Folding left and right
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 左右折叠
- en: The complementary `reduceRight()` method works just as `reduce()` does, only
    starting at the end and looping until the beginning of the array. (Read more about
    `reduceRight()` at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight).)
    For many operations (such as the calculation of averages that we saw previously),
    this makes no difference, but there are some cases in which it will. See *Figure
    5**.2*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相补的 `reduceRight()` 方法与 `reduce()` 方法的工作方式相同，只是从数组的末尾开始，循环到数组的开头。（更多关于 `reduceRight()`
    的信息请参阅 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight)。）对于许多操作（例如我们之前看到的平均值计算），这并没有区别，但在某些情况下会有所不同。请参阅
    *图 5**.2*。
- en: 'We shall be seeing a clear case of this in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*; let’s go with a simpler example here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 8 章*](B19301_08.xhtml#_idTextAnchor148) 的 *连接函数* 中看到一个明显的例子；这里让我们用一个更简单的例子来探讨：
- en: '![Figure 5.2 – The reduceRight() operation works the same way as reduce(),
    but in reverse order](img/Figure_5.2_B19301.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – reduceRight() 操作与 reduce() 操作相同，但顺序相反](img/Figure_5.2_B19301.jpg)'
- en: Figure 5.2 – The reduceRight() operation works the same way as reduce(), but
    in reverse order
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – reduceRight() 操作与 reduce() 操作相同，但顺序相反
- en: 'Suppose that we want to implement a function to reverse a string. (And, obviously,
    also that we don’t know that JavaScript already provides a `reverse()` method!)
    A solution could be to transform the string into an array by using `split()`,
    then reversing that array, and finally using `join()` to make it whole again:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要实现一个反转字符串的函数。（显然，我们也不知道 JavaScript 已经提供了 `reverse()` 方法！）一个解决方案可能是通过使用
    `split()` 将字符串转换为数组，然后反转这个数组，最后使用 `join()` 使其再次成为整体：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This solution works (and yes, it can be shortened, but that’s not the point
    here), but let’s do it in another way, just to experiment with `reduceRight()`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案是可行的（是的，它可以缩短，但这不是重点），但让我们用另一种方式来做，只是为了实验 `reduceRight()`：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we didn’t need to specify data types for the reducing function; just
    like earlier in this chapter, TypeScript was able to figure them out. Also, if
    you like to re-use code, look at *Question 5.2*!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为减少函数指定数据类型；就像本章前面提到的那样，TypeScript 能够自行推断它们。此外，如果你喜欢重用代码，看看 *问题 5.2*！
- en: 'From the previous examples, you can also get an idea: if you first apply `reverse()`
    to an array and then use `reduce()`, the effect will be the same as if you had
    just applied `reduceRight()` to the original array. There is only one point to
    take into account: `reverse()` alters the given array, so you would be causing
    an unintended side-effect by reversing the original array! The only way out would
    be to first generate a copy of the array and only then do the rest. Too much work,
    so it’s best to use `reduceRight()`!'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，你还可以得到一个想法：如果你首先对一个数组应用 `reverse()`，然后使用 `reduce()`，效果将等同于直接对原始数组应用
    `reduceRight()`。唯一需要注意的是：`reverse()` 会改变给定的数组，所以如果你反转原始数组，你将会造成一个意外的副作用！唯一的解决办法是首先生成数组的副本，然后再进行其他操作。这太麻烦了，所以最好使用
    `reduceRight()`！
- en: 'However, we can draw another conclusion, showing a result we had foretold:
    it is possible, albeit more cumbersome, to use `reduce()` to simulate the same
    result as `reduceRight()`—and in later sections, we’ll also use it to emulate
    the other functions in the chapter. Let’s now move on to another common and powerful
    operation: **mapping**.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还可以得出另一个结论，展示一个我们之前预测的结果：虽然比较繁琐，但使用 `reduce()` 可以模拟出与 `reduceRight()` 相同的结果——在后面的章节中，我们也会用它来模拟本章中的其他函数。现在让我们继续探讨另一个常见且强大的操作：**映射**。
- en: Applying an operation – map()
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用操作 – map()
- en: Processing lists of elements and applying some kind of operation to each of
    them is a quite common pattern in computer programming. Writing loops that systematically
    go through all the elements in an array or collection, starting at the first and
    looping until finishing with the last, and performing some kind of process on
    each of them is a basic coding exercise, usually learned in the first days of
    all programming courses. We already saw one such kind of operation in the previous
    section with `reduce()` and `reduceRight()`; let’s now turn to a new one, called
    `map()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，处理元素列表并对每个元素应用某种操作是一种相当常见的模式。编写系统性地遍历数组或集合中所有元素的循环，从第一个开始循环，直到最后一个结束，并对每个元素执行某种操作是一种基本的编码练习，通常在所有编程课程的第一天就会学到。我们已经在上一节中看到了这种类型的一种操作，即
    `reduce()` 和 `reduceRight()`；现在让我们转向一个新的操作，称为 `map()`。
- en: In mathematics, a `map()` function transforms an array of inputs into an array
    of outputs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，`map()` 函数将输入数组转换为输出数组。
- en: Names, names, names…
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 名字，名字，名字……
- en: 'Some more terminology: we would say that an array is a **functor** because
    it provides a mapping operation with some prespecified properties, which we shall
    see later. And, in category theory, which we’ll talk about a little in [*Chapter
    12*](B19301_12.xhtml#_idTextAnchor221), *Building Better Containers*, the mapping
    operation itself would be called a **morphism**.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更多的术语：我们会说数组是一个 **函子**，因为它提供了一种具有一些预定义属性的映射操作，我们将在后面看到。在范畴论中，我们将在 [*第 12 章*](B19301_12.xhtml#_idTextAnchor221)
    *构建更好的容器* 中简要讨论，映射操作本身被称为 **态射**。
- en: 'The inner workings of the `map()` operation can be seen in *Figure 5**.3*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 操作的内部工作原理可以在 *图 5**.3* 中看到：'
- en: '![Figure 5.3 – The map() operation transforms each element of the input array
    by applying a mapping function](img/Figure_5.3_B19301.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – map() 操作通过应用映射函数转换输入数组的每个元素](img/Figure_5.3_B19301.jpg)'
- en: Figure 5.3 – The map() operation transforms each element of the input array
    by applying a mapping function
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – map() 操作通过应用映射函数转换输入数组的每个元素
- en: More maps available
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可用更多地图
- en: 'The jQuery library provides a function, `$.map(array, callback)`, that is similar
    to the `map()` method. Be careful, though, because there are important differences.
    The jQuery function processes the undefined values of the array, while `map()`
    skips them. Also, if the applied function produces an array as its result, jQuery
    flattens it and adds each of its individual elements separately, while `map()`
    just includes those arrays in the result. Underscore, and Ramda also provide similar
    functions. Finally, JavaScript itself provides an alternative way of doing `map()`:
    check out the `Array.from()` method at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
    and pay special attention to its second argument!'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库提供了一个函数，`$.map(array, callback)`，它与 `map()` 方法类似。但请注意，它们之间有一些重要的区别。jQuery
    函数处理数组的未定义值，而 `map()` 则跳过它们。此外，如果应用函数的结果是一个数组，jQuery 会将其扁平化并分别添加其各个元素，而 `map()`
    只会将这些数组包含在结果中。Underscore 和 Ramda 也提供了类似的功能。最后，JavaScript 本身也提供了一种执行 `map()` 的替代方法：查看
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
    中的 `Array.from()` 方法，并特别注意其第二个参数！
- en: What are the advantages of using `map()` over using a straightforward loop?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map()` 而不是直接使用循环的优势是什么？
- en: First, you don’t have to write any loops, so that’s one less possible source
    of bugs
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一，你不需要编写任何循环，这样就少了一个可能的错误来源
- en: Second, you don’t even have to access the original array or the index position,
    even though they are there for you to use if you really need them
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，你甚至不需要访问原始数组或索引位置，尽管它们都在那里供你使用，如果你真的需要的话
- en: Lastly, a new array is produced, so your code is pure (although, of course,
    if you really want to produce side effects, you can!)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，会生成一个新的数组，所以你的代码是纯的（尽管，当然，如果你真的想产生副作用，你也可以！）
- en: 'There are only two caveats when doing this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做时只有两个注意事项：
- en: Always return something from your mapping function. If you forget this, then
    you’ll just produce an array filled with `undefined` values, because JavaScript
    always provides a default `return undefined` for all functions.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在映射函数中始终返回一些内容。如果你忘记了这一点，那么你将只会产生一个填充了 `undefined` 值的数组，因为 JavaScript 总是为所有函数提供一个默认的
    `return undefined`。
- en: If the input array elements are objects or arrays, and you include them in the
    output array, then JavaScript will still allow the original elements to be accessed.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入数组的元素是对象或数组，并且你将它们包含在输出数组中，那么 JavaScript 仍然允许访问原始元素。
- en: Also, there’s a restriction. In JavaScript, `map()` is basically available only
    for arrays (you can read more about this at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map));
    however, in the *Extending current data types* section in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221),
    *Building Better Containers*, we will learn how to make it available for other
    basic types, such as numbers, Booleans, strings, and even functions. Also, libraries
    such as Lodash, Underscore, and Ramda, provide similar functionalities.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个限制。在 JavaScript 中，`map()` 主要只适用于数组（你可以在 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
    了解更多）；然而，在 [*第 12 章*](B19301_12.xhtml#_idTextAnchor221) 的 *扩展当前数据类型* 部分，*构建更好的容器*
    中，我们将学习如何使其对其他基本类型也有效，例如数字、布尔值、字符串，甚至是函数。此外，像 Lodash、Underscore 和 Ramda 这样的库也提供了类似的功能。
- en: As we did earlier with `reduce()`, let’s now look at some examples of the use
    of `map()` for common processes so that you’ll better appreciate its power and
    convenience.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前使用 `reduce()` 一样，现在让我们看看 `map()` 在常见过程中的使用示例，以便你更好地欣赏其强大和便捷之处。
- en: Extracting data from objects
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从对象中提取数据
- en: Let’s start with a simple example. Suppose that we have some geographic data
    (as shown in the following snippet) related to some South American countries and
    the coordinates (latitude and longitude) of their capitals. Let’s say that we
    want to calculate the average position of those cities. (No, I don’t have a clue
    why we’d want to do that.) How would we go about it?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。假设我们有一些与一些南美国家和它们首都的坐标（纬度和经度）相关的地理数据（如下面的片段所示）。假设我们想计算这些城市的平均位置。（不，我不知道我们为什么要这样做。）我们该如何着手呢？
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A lot of negativity?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 很多负面情绪？
- en: In case you are wondering whether all the data is negative and if so, why, it’s
    because the countries shown here are all south of the Equator and west of the
    Greenwich Meridian. However, some South American countries, such as Colombia and
    Venezuela, have positive latitudes. We’ll return to these data a little later
    when we study the `some()` and `every()` methods.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道所有数据是否都是负数，如果是的话，原因是什么，那是因为这里显示的国家都位于赤道以南和格林威治子午线以西。然而，一些南美国家，如哥伦比亚和委内瑞拉，具有正纬度。当我们学习
    `some()` 和 `every()` 方法时，我们稍后会回到这些数据。
- en: 'We would want to use our `average()` function (which we developed earlier in
    this chapter), but there is a problem: that function can only be applied to an
    array of *numbers*, and what we have here is an array of *objects*. We can, however,
    do a trick: we can focus on calculating the average latitude (we can deal with
    the longitude later, in a similar fashion). We can map each element of the array
    to its latitude, and we would then have an appropriate input for `average()`.
    The solution would be something like the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用我们的 `average()` 函数（我们在本章早期开发了这个函数），但有一个问题：该函数只能应用于 *数字* 数组，而我们这里有一个 *对象*
    数组。然而，我们可以玩一个花招：我们可以专注于计算平均纬度（我们可以在类似的方式中稍后处理经度）。我们可以将数组的每个元素映射到其纬度，然后我们将有 `average()`
    函数的适当输入。解决方案可能如下所示：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Mapping an array to extract data is powerful, but you must be careful. Let’s
    now look at a case that seems right but produces incorrect results!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组映射以提取数据非常强大，但你必须小心。现在让我们看看一个看似正确但产生错误结果的情况！
- en: Parsing numbers tacitly
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式解析数字
- en: Working with `map()` is usually far safer and simpler than looping by hand,
    but some edge cases may trip you up. Say you received an array of strings representing
    numeric values and wanted to parse them into actual numbers. Can you explain the
    following results?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map()` 通常比手动循环更安全、更简单，但一些边缘情况可能会让你陷入困境。比如说，你收到了一个表示数值的字符串数组，并想将它们解析成实际的数字。你能解释以下结果吗？
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s analyze the results. When we used `parseFloat()` to get floating-point
    results, everything was OK; however, when we wanted to truncate the results to
    integer values with `parseInt()`, the output was really awry, and weird `NaN`
    values appeared. What happened?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下结果。当我们使用 `parseFloat()` 获取浮点数结果时，一切正常；然而，当我们想用 `parseInt()` 将结果截断为整数时，输出真的非常糟糕，出现了奇怪的
    `NaN` 值。发生了什么？
- en: 'The answer lies in a problem with tacit programming. (We have already seen
    some uses of tacit programming in the *An unnecessary mistake* section of [*Chapter
    3*](B19301_03.xhtml#_idTextAnchor054), *Starting Out with Functions*, and we’ll
    see more in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*.)
    When you don’t explicitly show the parameters to a function, it’s easy for there
    to be oversights. Look at the following code, which will lead us to the solution:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于一个隐式编程的问题。（我们已经在[*第三章*](B19301_03.xhtml#_idTextAnchor054)的[*不必要的错误*](B19301_03.xhtml#_idTextAnchor054)部分看到了一些隐式编程的用法，以及[*第八章*](B19301_08.xhtml#_idTextAnchor148)的[*连接函数*](B19301_08.xhtml#_idTextAnchor148)中我们将看到更多，但我们现在来看看以下代码，它将引导我们找到解决方案：）
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The reason for the unexpected behavior with `parseInt()` is that this function
    can also receive a second parameter—namely, the radix to use when converting the
    string into a number. For instance, a call such as `parseInt("100010100001", 2)`
    will convert a binary number of `100010100001` into a decimal.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt()`出现意外行为的原因是，此函数还可以接收第二个参数——即转换字符串为数字时要使用的基数。例如，调用`parseInt("100010100001",
    2)`将把二进制数`100010100001`转换为十进制。'
- en: 'Note:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: You can read more about `parseInt()` at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt),
    where the radix parameter is explained in detail. You should always provide it
    because some browsers might interpret strings with a leading zero to be octal,
    which would once again produce unwanted results.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt)上了解更多关于`parseInt()`的信息，其中详细解释了基数参数。你应该始终提供它，因为某些浏览器可能会将带前导零的字符串解释为八进制，这又将产生不希望的结果。
- en: 'So, what happens when we provide `parseInt()` to `map()`? Remember that `map()`
    calls your mapping function with three parameters: the array element value, its
    index, and the array itself. When `parseInt` receives these values, it ignores
    the array but assumes that the provided index is actually a radix, and `NaN` values
    are produced since the original strings are not valid numbers in the given radix.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们向`map()`提供`parseInt()`时会发生什么？记住，`map()`会使用三个参数调用你的映射函数：数组元素的值、它的索引和数组本身。当`parseInt`接收到这些值时，它会忽略数组，并假设提供的索引实际上是基数，由于原始字符串在给定的基数中不是有效的数字，因此会产生`NaN`值。
- en: OK, some functions can lead you astray when mapping, and you now know what to
    look for. Let’s keep enhancing the way we work by using ranges to write code that
    would usually require a hand-written loop.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一些函数在映射时可能会误导你，现在你知道该寻找什么了。让我们通过使用范围来编写通常需要手动循环的代码，继续提升我们的工作方式。
- en: Working with ranges
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与范围一起工作
- en: 'Let’s now turn to a helper function, which will come in handy for many uses.
    We want a `range(start,stop)` function that generates an array of numbers, with
    values ranging from `start` (inclusive) to `stop` (exclusive):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转向一个辅助函数，它将在许多用途中很有用。我们想要一个`range(start,stop)`函数，它生成一个数字数组，其值从`start`（包含）到`stop`（不包含）：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Why `fill(0)`? Undefined array elements are skipped by `map()`, so we need to
    fill them with something or our code will have no effect.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用`fill(0)`？在`map()`中，未定义的数组元素会被跳过，因此我们需要用某些东西填充它们，否则我们的代码将没有效果。
- en: Expanding your range
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展你的范围
- en: Libraries such as Underscore and Lodash provide a more powerful version of our
    `range()` function, letting us go in ascending or descending order and also specifying
    the step to use—as in `_.range(0, -8, -2)`, which produces `[0, -2, -4, -6]`—but
    for our needs, the version we wrote is enough. Refer to the *Questions* section
    at the end of this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 像Underscore和Lodash这样的库提供了我们`range()`函数的一个更强大的版本，允许我们以升序或降序进行，还可以指定要使用的步长——例如`_.range(0,
    -8, -2)`，它产生`[0, -2, -4, -6]`——但就我们的需求而言，我们编写的版本已经足够了。请参阅本章末尾的[*问题*](B19301_XX.xhtml#_idTextAnchorXXX)部分。
- en: 'How can we use it? In the following section, we’ll see some uses for controlled
    looping with `forEach()`, but we can redo our factorial function by applying `range()`
    and then `reduce()`. The idea of this is to generate all the numbers from 1 to
    `n` and then multiply them together:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用它？在接下来的部分，我们将看到使用`forEach()`进行受控循环的一些用法，但我们可以通过应用`range()`然后`reduce()`来重新实现我们的阶乘函数。这个想法是生成从1到`n`的所有数字，然后将它们相乘：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It’s important to check the border cases, but the function also works for zero;
    can you see why? The reason for this is that the produced range is empty: the
    call is `range(1,1)`, which returns an empty array. Then, `reduce()` doesn’t do
    any calculations and returns the initial value (`1`), which is correct.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 检查边界情况很重要，但该函数对零也有效；你能看出为什么吗？原因在于生成的范围是空的：调用是 `range(1,1)`，它返回一个空数组。然后，`reduce()`
    不进行任何计算，并返回初始值（`1`），这是正确的。
- en: In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*,
    we’ll have the opportunity to use `range()` to generate source code; check out
    the *Currying with eval()* and *Partial application with* *eval()* sections.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 7 章*](B19301_07.xhtml#_idTextAnchor128)，*变换函数* 中，我们将有机会使用 `range()` 生成源代码；查看
    *使用 eval() 进行柯里化* 和 *使用 eval() 进行部分应用* 部分。
- en: 'You could use these numeric ranges to produce other kinds of ranges. For example,
    should you need an array with the alphabet, you could certainly (and tediously)
    write `["A", "B", "C"`... up to ...`"X", "Y", "Z"]`. A simpler solution would
    be to generate a range with the ASCII codes for the alphabet and map those to
    letters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些数字范围来生成其他类型的范围。例如，如果你需要一个包含字母表的数组，你当然可以（但很繁琐）写出 `["A", "B", "C"`... up
    to ...`"X", "Y", "Z"]`。一个更简单的解决方案是使用字母表的 ASCII 码生成范围，并将这些映射到字母：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note the use of `charCodeAt()` to get the ASCII codes for the letters and `String.fromCharCode(x)`
    to transform the ASCII code into a character.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `charCodeAt()` 获取字母的 ASCII 码，以及使用 `String.fromCharCode(x)` 将 ASCII 码转换为字符。
- en: Mapping is very important and often used, so let’s now analyze how you could
    implement it on your own, which could help you develop code for more complex cases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 映射非常重要且经常使用，所以现在让我们分析你如何自己实现它，这可能会帮助你为更复杂的情况编写代码。
- en: Emulating map() with reduce()
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 reduce() 模拟 map()
- en: Earlier in this chapter, we saw how `reduce()` could be used to implement `reduceRight()`.
    Now, let’s see how `reduce()` can also be used to provide a polyfill for `map()`
    (not that you will need it because nowadays, browsers offer both methods, but
    it will give you more of an idea of what you can achieve with these tools).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们看到了如何使用 `reduce()` 实现 `reduceRight()`。现在，让我们看看 `reduce()` 如何也用于提供 `map()`
    的 polyfill（虽然现在浏览器提供了这两种方法，但这将给你更多关于你可以用这些工具实现什么的想法）。
- en: 'Our own `myMap()` is a one-liner but can be hard to understand. We apply the
    function to each element of the array and use `concat()` to append the result
    to a result array (which is initially empty). When the loop finishes working with
    the input array, the result array will have the desired output values. Let’s first
    see a plain JavaScript version before getting to data typing:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的 `myMap()` 是一行代码，但可能难以理解。我们将函数应用于数组的每个元素，并使用 `concat()` 将结果追加到结果数组（最初为空）。当循环完成对输入数组的处理时，结果数组将包含所需的输出值。在讨论数据类型之前，我们先看看一个普通的
    JavaScript 版本：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We apply the mapping function to each array element, one by one, and we concatenate
    the result to the accumulated output array.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将映射函数应用于每个数组元素，一个接一个，并将结果连接到累积的输出数组。
- en: 'Let’s test this with an array and a simple function. We will use both the original
    `map()` method and `myMap()`, and the results should match! Our mapping function
    will return double its input:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个数组和一个简单的函数来测试这个。我们将使用原始的 `map()` 方法以及 `myMap()`，结果应该匹配！我们的映射函数将返回其输入的两倍：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first log shows the expected result, produced by `map()`. The second output
    gives the same result, so it seems that `myMap()` works! And the final output
    is just to check that the original input array wasn’t modified in any way; mapping
    operations should always produce a new array. See *Question 5.3* for testing our
    `myMap()` function more thoroughly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条日志显示了由 `map()` 产生的预期结果。第二条输出给出了相同的结果，所以看起来 `myMap()` 是有效的！最后的输出只是检查原始输入数组没有被任何方式修改；映射操作应该始终产生一个新的数组。参见
    *问题 5.3* 以更彻底地测试我们的 `myMap()` 函数。
- en: 'Let’s review our `myMap()` function and add typing. The needed data types are
    more complex, and we’ll have a generic function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 `myMap()` 函数并添加类型注解。所需的数据类型更复杂，我们将有一个通用函数：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our `myMap()` function receives an array of elements of type `T` and an `fn()`
    mapping function that transforms its `T` argument into an `R`-type result. The
    result of this mapping is an array of `R`-type elements. Examine the accumulator
    function by yourself; is its typing understandable?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `myMap()` 函数接收一个类型为 `T` 的元素数组和一个 `fn()` 映射函数，该函数将它的 `T` 参数转换为一个 `R` 类型的结果。映射的结果是一个
    `R` 类型的元素数组。你自己检查累加函数；它的类型是否可理解？
- en: Let’s try a different mapping function to verify that our typing is correct.
    We’ll use one that returns strings instead of numbers – it just adds dashes before
    and after its input, to produce a string.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个不同的映射函数来验证我们的类型是否正确。我们将使用一个返回字符串而不是数字的函数——它只是在输入前后添加破折号，以生成一个字符串。
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: OK, it seems that our complex type definitions were correct!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，看起来我们的复杂类型定义是正确的！
- en: All the previous examples in the chapter focused on simple arrays. But what
    happens if things get more complicated, say if you had to deal with an array whose
    elements were arrays themselves? Fortunately, there’s a way out of that. Let’s
    move on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有先前列表示例都集中在简单的数组上。但如果事情变得更复杂，比如说，你必须处理一个其元素本身也是数组的数组，会怎样？幸运的是，有一个解决办法。让我们继续前进。
- en: Dealing with arrays of arrays
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理数组的数组
- en: 'So far, we have worked with an array of (single) values as an input, but what
    would happen if your input was an array of arrays? If you consider this to be
    a far-fetched case, there are many possible scenarios where this could apply:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已将一个包含（单个）值的数组作为输入进行处理，但如果你输入的是一个数组的数组会怎样？如果你认为这是一个牵强附会的案例，有许多可能的场景可以应用这种情况：
- en: 'For some applications, you could have a table of distances, which in JavaScript
    requires an array of arrays: `distance[i][j]` would be the distance between `i`
    and `j`. How could you find the maximum distance between any two points? Finding
    the maximum is simple with a common array, but how do you deal with an array of
    arrays?'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于某些应用，你可能有一个距离表，在 JavaScript 中需要数组的数组：`distance[i][j]` 将是 `i` 和 `j` 之间的距离。你如何找到任意两点之间的最大距离？使用普通数组找到最大值很简单，但如何处理数组的数组？
- en: 'A more complex example, also in a geographic vein, is that you could query
    a geographic API for cities matching a string, and the response could be an array
    of countries, each with an array of states, each itself with an array of matching
    cities: an array of arrays of arrays!'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更复杂的例子，同样在地理方面，是你可能查询一个地理 API 以获取与字符串匹配的城市，响应可能是一个包含国家的数组，每个国家都有一个包含州的数组，每个州本身都有一个包含匹配城市的数组：一个数组的数组数组！
- en: In the first case, you could want a single array with all distances, and in
    the second, an array with all cities; how would you manage this? A new operation,
    **flattening**, is required; let’s take a look.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，你可能想要一个包含所有距离的单个数组，而在第二种情况下，一个包含所有城市的数组；你将如何管理这种情况？需要一个新操作，**扁平化**；让我们看看。
- en: Flattening an array
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扁平化一个数组
- en: 'In ES2019, two operations were added to JavaScript: `flat()`, which we’ll look
    at now, and `flatMap()`, which we’ll look at later. It’s easier to show what they
    do than to explain—bear with me!'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES2019 中，JavaScript 添加了两个操作：`flat()`，我们现在将探讨它，以及 `flatMap()`，我们稍后将会探讨。展示它们的作用比解释它们更容易——请耐心等待！
- en: No flat() allowed?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许使用 flat()？
- en: 'As often happens, not all browsers have been updated to include these new methods,
    and Microsoft’s Internet Explorer and others were deficient in this regard, so
    for web programming, a polyfill will be required. As usual, for updated compatibility
    data, check out the *Can I use?* site, in this case, at [caniuse.com/#feat=array-flat](http://caniuse.com/#feat=array-flat).
    A piece of good news: since September 2018, all major browsers provide this feature
    natively!'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如常发生的那样，并非所有浏览器都已更新以包含这些新方法，微软的 Internet Explorer 和其他浏览器在这方面存在缺陷，因此对于网络编程，将需要
    polyfill。通常，为了获取更新的兼容性数据，请查看 *Can I use?* 网站，在本例中，请访问 [caniuse.com/#feat=array-flat](http://caniuse.com/#feat=array-flat)。一个好消息：自
    2018 年 9 月以来，所有主要浏览器都原生支持此功能！
- en: 'The `flat()` method creates a new array, concatenating all elements of its
    subarrays to the desired level, which is, by default, `1`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`flat()` 方法创建一个新的数组，将子数组的所有元素连接到所需的级别，默认为 `1`：'
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, how could we use this function to solve our problems? Using `flat()`, spreading,
    and `Math.max()` answers the first question (as we saw back in the *Spread* section
    of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*, Becoming Functional*; we
    could have used the `maxArray()` function we wrote back then), and we can also
    use `reduce()` for variety. Suppose we have the following table of distances:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用这个函数来解决我们的问题呢？使用 `flat()`、展开和 `Math.max()` 回答了第一个问题（正如我们在 [*第一章*](B19301_01.xhtml#_idTextAnchor015)*，成为函数式开发者*
    的 *展开* 部分中看到的，我们当时可以使用我们写的 `maxArray()` 函数），我们还可以使用 `reduce()` 来增加多样性。假设我们有一个距离表：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we can find our maximum distance in a couple of ways: we either flatten
    the array, spread it, and use `Math.max()`, or flatten the array and use reducing
    to explicitly find the maximum:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过几种方式找到我们的最大距离：我们或者扁平化数组，展开它，并使用 `Math.max()`，或者扁平化数组并使用归约来显式地找到最大值：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s go back to the second question. Suppose we queried a geographic API for
    cities that have `"LINCOLN"` (upper or lower case) in their names and got the
    following answer:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到第二个问题。假设我们查询了一个地理API，以获取名字中包含 `"LINCOLN"`（大小写不敏感）的城市，并得到了以下答案：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Extracting the list of cities can be done by applying `map()` and `flat()`
    twice:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用 `map()` 和 `flat()` 两次，我们可以提取城市列表：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have seen how to use `flat()` to flatten an array; let’s now see how to use
    `flatMap()`, an interesting mixture of `flat()` and `map()`, to further streamline
    our coding and even further shorten our preceding second solution! (And if you
    think this exercise wasn’t hard enough and its output was sort of lame, try out
    *Question 5.10* for a more challenging version!)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 `flat()` 来扁平化一个数组；现在让我们看看如何使用 `flatMap()`，这是 `flat()` 和 `map()`
    的有趣混合，来进一步简化我们的编码，甚至进一步缩短我们前面的第二个解决方案！（如果你认为这个练习还不够难，其输出有点无聊，可以尝试 *问题5.10* 以获得更具挑战性的版本！）
- en: Mapping and flattening – flatMap()
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射和扁平化 – `flatMap()`
- en: Basically, what `flatMap()` does is first apply a `map()` function and then
    apply `flat()` to the result of the mapping operation. This is an interesting
    combination because it lets you produce a new array with a different number of
    elements. (With the normal `map()` operation, the output array would be precisely
    the same length as the input array). If your mapping operation produces an array
    with two or more elements, then the output array will include many output values,
    and if you produce an empty array, the output array will include fewer values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`flatMap()` 函数所做的是首先应用一个 `map()` 函数，然后将映射操作的结果应用 `flat()` 函数。这是一个有趣的组合，因为它允许你生成一个具有不同元素数量的新数组。（使用正常的
    `map()` 操作，输出数组将与输入数组长度完全相同）。如果你的映射操作生成一个包含两个或更多元素的数组，那么输出数组将包含许多输出值；如果你生成一个空数组，输出数组将包含较少的值。
- en: 'Let’s look at a (somehow nonsensical) example. Assume that we have a list of
    names, such as `"Winston Spencer Churchill"`, `"Abraham Lincoln"`, and `"Socrates"`.
    Our rule is that if a name has several words, exclude the initial one (the first
    name, we assume) and separate the rest (last names), but if a name is a single
    word, drop it (assuming the person has no last name):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个（某种意义上说不通）的例子。假设我们有一个名字列表，例如 `"Winston Spencer Churchill"`、`"Abraham
    Lincoln"` 和 `"Socrates"`。我们的规则是，如果一个名字包含多个单词，排除第一个（我们假设是名字，即姓氏），然后将剩下的（我们假设是姓氏）分开，但如果一个名字是一个单词，则将其删除（我们假设这个人没有姓氏）：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see, the output array has a different number of elements than the
    input array: just because of this, we could consider `flatMap()` to be an upgraded
    version of `map()`, even including some aspects of `filter()`, like when we excluded
    single names.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，输出数组与输入数组的元素数量不同：仅仅因为这个原因，我们可以考虑 `flatMap()` 是 `map()` 的升级版，甚至包括一些 `filter()`
    的方面，比如当我们排除单个名字时。
- en: Let’s now move on to a simple example. Keeping with the Lincolnian theme from
    the last section, let’s count how many words are in Lincoln’s Gettysburg address,
    given as an array of sentences. By the way, this address is usually considered
    to be 272 words long, but the version I found doesn’t produce that number! This
    may be because there are five manuscript copies of the address written by Lincoln
    himself, plus another version transcribed from shorthand notes taken at the event.
    In any case, I will leave the discrepancy to historians and stick to coding!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个简单的例子。继续上节中林肯主题，让我们计算林肯的葛底斯堡演讲中包含多少个单词，这些单词以句子数组的形式给出。顺便说一句，这个演讲通常被认为有
    272 个单词长，但我找到的版本并没有产生这个数字！这可能是因为有五个林肯亲笔撰写的演讲稿副本，加上另一个从事件中的速记笔记转录的版本。无论如何，我将把这个差异留给历史学家，并专注于编码！
- en: 'We can use `flatMap()` to split each sentence into an array of words and then
    see the length of the flattened array:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `flatMap()` 将每个句子拆分成一个单词数组，然后查看展平后的数组长度：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s go back to the problem with the cities. If we notice that each `map()`
    was followed by `flat()`, an alternative solution is immediately apparent. Compare
    this solution with the one we wrote in the *Flattening an array* section; it’s
    essentially the same but conflates each `map()` with its following `flat()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到城市的问题。如果我们注意到每个 `map()` 后面都跟着 `flat()`，一个替代方案就立即显现出来。将这个解决方案与我们之前在 *Flattening
    an array* 部分中写的方案进行比较；它们基本上是相同的，但是将每个 `map()` 与其后面的 `flat()` 合并：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have now seen the new operations. (And, yes, it’s perfectly possible to solve
    the problems in this section without mapping, but that wouldn’t be a good example
    for this section! See *Question 5.11* for an alternative to the word counting
    problem.) Let’s now learn how to emulate these operations should you not have
    them readily available.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了新的操作。（是的，没有映射也可以解决本节中的问题，但这不会是本节的良好示例！有关单词计数问题的替代方案，请参阅 *问题 5.11*。）现在让我们学习如何模拟这些操作，以防你无法立即获得它们。
- en: Emulating flat() and flatMap()
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟 flat() 和 flatMap()
- en: We have already seen how `reduce()` could be used to emulate `map()`. Let’s
    now see how to work out equivalents for `flat()` and `flatMap()` to get more practice.
    We’ll also throw in a recursive version, a topic we’ll return to in [*Chapter
    9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*. As was mentioned
    earlier, we are not aiming for the fastest or smallest or any particular version
    of the code; instead, we want to focus on using the concepts we’ve been looking
    at in this book.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 `reduce()` 来模拟 `map()`。现在让我们看看如何为 `flat()` 和 `flatMap()` 找到等效的方法，以获得更多的实践。我们还将加入一个递归版本，这是一个我们将在
    [*第 9 章*](B19301_09.xhtml#_idTextAnchor172) *设计函数* 中再次讨论的主题。正如之前提到的，我们并不是在追求最快、最小或任何特定的代码版本；相反，我们想要专注于使用这本书中我们一直在探讨的概念。
- en: 'Totally flattening an array can be done with a recursive call. We use `reduce()`
    to process the array element by element, and if an element happens to be an array,
    we recursively flatten it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 完全展平一个数组可以通过递归调用来完成。我们使用 `reduce()` 逐个处理数组元素，如果一个元素恰好是一个数组，我们就递归地展平它：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Flattening an array to a given level (not infinity; let’s leave that for later)
    is easy if you can first flatten an array one level. We can do this either by
    using spreading or with `reduce()`. Let’s write a `flatOne()` function that flattens
    just a single level of an array. There are two versions of this; pick whichever
    you prefer:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能先展平一个数组的单个级别，那么将数组展平到给定级别（不是无限；让我们留到以后再说）就很容易了。我们可以通过展开或使用 `reduce()` 来做到这一点。让我们编写一个
    `flatOne()` 函数，它只展平数组的单个级别。这里有这个函数的两个版本；选择你喜欢的任何一个：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using either of these two functions, we can flatten an array of several levels,
    and we can do this in two different ways. Our two versions of a `flat()` function
    use our previous `flatOne()` and `flatAll()` functions, but the first one only
    uses standard looping, while the second one works in a fully recursive way. Which
    one do you prefer?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个函数中的任何一个，我们都可以将多层数组展平，并且我们可以以两种不同的方式做到这一点。我们两个版本的 `flat()` 函数使用了我们之前的 `flatOne()`
    和 `flatAll()` 函数，但第一个只使用标准循环，而第二个则以完全递归的方式工作。你更喜欢哪一个？
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I think the recursive one is nicer and more aligned with the theme of this book.
    Still, it’s up to you, really—although if you don’t feel comfortable with the
    ternary operator, then the recursive version is definitely not for you!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为递归版本更优雅，更符合本书的主题。尽管如此，这完全取决于你——尽管如果你不熟悉三元运算符，那么递归版本肯定不适合你！
- en: 'If you wish to polyfill these functions (despite our suggestions not to), it’s
    not complex, and is similar to what we did with the `average()` method previously.
    I took care not to create any extra methods:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望对这些函数进行 polyfill（尽管我们的建议是不这么做），这并不复杂，并且与我们之前对 `average()` 方法所做的是类似的。我注意到了不要创建任何额外的函数：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our `flatOneX()` and `flatAllX()` methods are just copies of what we developed
    before, and you’ll recognize the code of our previous `flat2()` function at the
    end of our implementation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `flatOneX()` 和 `flatAllX()` 方法只是我们之前开发的副本，你会在我们的实现末尾认出我们之前的 `flat2()` 函数的代码。
- en: Finally, emulating `flatMap()` is simple in itself, and we can skip it because
    it’s just a matter of applying `map()` first, and then `flat()`; no big deal!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模拟 `flatMap()` 本身很简单，我们可以跳过它，因为这只是一个先应用 `map()`，然后 `flat()` 的问题；没什么大不了的！
- en: We have seen how to work with arrays in several ways, but sometimes what you
    need isn’t really well served by any of the functions we have seen. Let’s move
    on to more general ways of looping, for greater power.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何以几种不同的方式处理数组，但有时你所需要的并不是我们看到的任何函数所提供的服务。让我们继续探讨更通用的循环方式，以获得更大的能力。
- en: More general looping
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更通用的循环
- en: The preceding examples that we’ve seen all loop through arrays, doing some work.
    However, sometimes, you need to loop, but the required process doesn’t really
    fit `map()` or `reduce()`. So, what can be done in such cases? There is a `forEach()`
    method that can help. (Read more about it at [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的示例都是遍历数组，做一些工作。然而，有时你需要循环，但所需的过程并不真正适合 `map()` 或 `reduce()`。在这种情况下，我们能做什么呢？有一个
    `forEach()` 方法可以帮助。（更多关于它的信息请参阅 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)。）
- en: 'You must provide a callback that will receive the value, the index, and the
    array on which you are operating. (The last two arguments are optional.) JavaScript
    will take care of the loop control, and you can do whatever you want at each step.
    For instance, we can program an object copying method by using `Object` methods
    to copy the source object attributes one at a time and generate a new object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须提供一个回调函数，该函数将接收值、索引以及你正在操作的数组。（后两个参数是可选的。）JavaScript 将负责循环控制，你可以在每个步骤做任何你想做的事情。例如，我们可以通过使用
    `Object` 方法逐个复制源对象的属性并生成一个新对象来编程一个对象复制方法：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The idea is: we create a `copy` object with the same prototype as the original
    `obj`, and then for each property in the original, we define an equivalent property
    in the copy. The function’s signature makes clear that the input and output types
    are the same. One particular detail: given the loop we are writing, we know for
    sure that `Object.getOwnPropertyDescriptor(obj, prop)` will be a string (and not
    `undefined`), but TypeScript cannot tell; adding `as string` solves this.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是：我们创建一个与原始 `obj` 具有相同原型的 `copy` 对象，然后对于原始对象中的每个属性，我们在副本中定义一个等效的属性。函数的签名清楚地表明输入和输出类型是相同的。一个特别的细节：鉴于我们正在编写的循环，我们知道
    `Object.getOwnPropertyDescriptor(obj, prop)` 将是一个字符串（而不是 `undefined`），但 TypeScript
    无法判断；添加 `as string` 解决了这个问题。
- en: Shallow or deep?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 浅拷贝或深拷贝？
- en: 'Yes, of course, we could have written `myCopy={...myObj}`, but where’s the
    fun in that? It would be better, but I needed a nice example to use `forEach()`
    with. Sorry about that! Also, there are some hidden inconveniences in that code,
    which we’ll explain in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring
    Purity*, when we try to get frozen, unmodifiable objects. Just a hint: the new
    object may share values with the old one because we have a shallow copy, not a
    deep one. We’ll learn more about this later in the book.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们本来可以写 `myCopy={...myObj}`，但那样有什么乐趣呢？这会更好，但我需要一个很好的例子来使用 `forEach()`。对此表示歉意！此外，该代码中还有一些隐藏的不便，我们将在
    [*第10章*](B19301_10.xhtml#_idTextAnchor188) *确保纯净性* 中解释，当我们尝试获取冻结的、不可修改的对象时。只是提示一下：新对象可能与旧对象共享值，因为我们有一个浅拷贝，而不是深拷贝。我们将在本书的后面部分了解更多关于这一点。
- en: 'If we use the `range()` function that we defined previously, we can also perform
    common loops of the `for(let i=0; i<10; i++)` variety. We might write yet another
    version of factorial (!) using that:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用之前定义的 `range()` 函数，我们也可以执行类似于 `for(let i=0; i<10; i++)` 的常见循环。我们可以使用它来编写另一个阶乘
    (!) 的版本：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This definition of factorial really matches the usual description: it generates
    all the numbers from 1 to *n* inclusive and multiplies them—simple!'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶乘的定义确实符合通常的描述：它生成从 1 到 *n* 的所有数字（包括 n）并将它们相乘——简单！
- en: For greater generality, consider expanding `range()` so it can generate ascending
    and descending ranges of values, possibly stepping by a number other than 1\.
    This would allow you to replace all the loops in your code with `forEach()` loops.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高通用性，考虑扩展 `range()` 以生成升序和降序的值范围，可能以除 1 以外的数字为步长。这将允许你用 `forEach()` 循环替换代码中的所有循环。
- en: At this point, we have seen many ways of processing arrays to generate results,
    but other objectives may be of interest, so let’s now move on to logical functions,
    which will also simplify our coding needs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了许多处理数组以生成结果的方法，但其他目标可能也很有趣，所以现在让我们转向逻辑函数，这将简化我们的编码需求。
- en: Logical HOFs
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑高阶函数
- en: Up to now, we have been using HOFs to produce new results. However, some other
    functions produce logical results by applying a predicate to all the elements
    of an array. (By the way, we’ll see much more about HOFs in the next chapter.)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用高阶函数（HOFs）来生成新结果。然而，有些其他函数通过将谓词应用于数组的所有元素来生成逻辑结果。（顺便说一下，我们将在下一章看到更多关于高阶函数的内容。）
- en: Many meanings
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 许多含义
- en: 'A bit of terminology: the word **predicate** can be used in several senses
    (as in predicate logic), but for us, in computer science, it has the meaning of
    *a function that returns true or false*. OK, this isn’t a very formal definition,
    but it’s enough for our needs. For example, saying that we will filter an array
    depending on a predicate means that we get to decide which elements are included
    or excluded depending on the predicate’s result.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一点术语：单词 **谓词** 可以用在几个意义上（如在谓词逻辑中），但对我们来说，在计算机科学中，它意味着 *一个返回 true 或 false 的函数*。好吧，这不是一个非常正式的定义，但对于我们的需求来说足够了。例如，说我们将根据谓词过滤数组意味着我们可以根据谓词的结果来决定哪些元素被包含或排除。
- en: 'Using these functions implies that your code will become shorter: you can get
    results corresponding to a whole set of values with a single line of code.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数意味着你的代码将变得更短：你可以用一行代码得到与整个值集相对应的结果。
- en: Filtering an array
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤数组
- en: We will encounter a common need to filter the elements of an array according
    to a specific condition. The `filter()` method lets you inspect each element of
    an array in the same fashion as `map()`. The difference is that instead of producing
    a new element, the result of your function determines whether the input value
    will be kept in the output (if the function returned `true`) or if it will be
    skipped (if the function returned `false`). Also, similar to `map()`, `filter()`
    doesn’t alter the original array but produces a new array with the chosen items.
    You can read more on the `filter()` function at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会遇到一个常见的需求，即根据特定条件过滤数组中的元素。`filter()` 方法允许你以与 `map()` 相同的方式检查数组中的每个元素。区别在于，你函数的结果决定了输入值是否会被保留在输出中（如果函数返回
    `true`），或者是否会被跳过（如果函数返回 `false`）。同样，与 `map()` 类似，`filter()` 不会改变原始数组，而是生成一个包含所选项的新数组。你可以在
    [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
    上了解更多关于 `filter()` 函数的信息。
- en: 'See *Figure 5**.4* for a diagram showing the input and output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 见 *图 5**.4* 以了解输入和输出的示意图：
- en: '![Figure 5.4 – The ﬁlter() method picks the elements of an array that satisfy
    a given predicate](img/Figure_5.4_B19301.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – filter() 方法选择满足给定谓词的数组元素](img/Figure_5.4_B19301.jpg)'
- en: Figure 5.4 – The ﬁlter() method picks the elements of an array that satisfy
    a given predicate
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – filter() 方法选择满足给定谓词的数组元素
- en: 'There are a couple of things to remember when filtering an array:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤数组时，有几件事情需要记住：
- en: '`undefined`, and since that’s a falsy value, the output will be an empty array'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`，由于这是一个假值，输出将是一个空数组'
- en: '**The copy that is made is shallow**: If the input array elements are objects
    or arrays, then the original elements will still be accessible'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制的副本是浅层的**：如果输入数组元素是对象或数组，则原始元素仍然可以访问'
- en: Let’s get into more detail by seeing a practical example of `filter()` and then
    looking at how we could implement that functionality by using `reduce()`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看 `filter()` 的实际示例来深入了解，然后看看我们如何使用 `reduce()` 实现该功能。
- en: A filter() example
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: filter() 示例
- en: 'Let’s look at a practical example. Suppose a service has returned a JSON object,
    which has an array of objects containing an account’s `id` value and `balance`.
    How can we get the list of IDs *“in the red”*, with a negative balance? The input
    data could be as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际例子。假设一个服务返回了一个 JSON 对象，其中包含一个包含账户 `id` 值和 `balance` 的对象数组。我们如何获取具有负余额的
    `“in the red”` ID 列表？输入数据可能如下所示：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We could get the delinquent accounts with something like the following. You
    can check that the value of the `delinquent` variable correctly includes the two
    IDs of accounts with a negative balance:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似以下的方式获取违约账户。你可以检查 `delinquent` 变量的值是否正确地包含了具有负余额的两个账户 ID：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By the way, given that the filtering operation produced yet another array,
    if you just wanted the accounts IDs, you could get them by mapping the output
    to only get the `id` field:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，鉴于过滤操作又产生了一个数组，如果你只想获取账户 ID，你可以通过映射输出只获取 `id` 字段：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And if you didn’t care for the intermediate result, a one-liner would have
    worked as well:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎中间结果，单行代码也可以工作得很好：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Filtering is a very useful function, so now, to get a better handle on it, let’s
    see how you can emulate it, which you could use as a basis for more sophisticated,
    powerful functions of your own.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是一个非常有用的功能，因此现在，为了更好地掌握它，让我们看看你如何模拟它，这可以作为你自己的更复杂、更强大的函数的基础。
- en: Emulating filter() with reduce()
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 reduce() 模拟 filter()
- en: 'As we did before with `map()`, we can also create our own version of `filter()`
    by using `reduce()`. The idea is similar: loop through all the elements of the
    input array, apply the predicate to it, and if the result is `true`, add the original
    element to the output array. When the loop is done, the output array will only
    have those elements for which the predicate was `true`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前使用 `map()` 一样，我们也可以通过使用 `reduce()` 创建自己的 `filter()` 版本。想法是相似的：遍历输入数组的所有元素，对其应用谓词，如果结果是
    `true`，则将原始元素添加到输出数组中。当循环完成后，输出数组将只包含谓词为 `true` 的元素：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our function is generic; it takes an array of elements of type `T` and a predicate
    that accepts a `T`-type parameter and generates a new array of elements of type
    `T`. We can quickly see that our function works as expected:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能是通用的；它接受一个类型为 `T` 的元素数组和一个接受类型为 `T` 的参数的谓词，该谓词生成一个类型为 `T` 的新元素数组。我们可以快速看到我们的函数按预期工作：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output is the same pair of accounts that we saw earlier in this section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与我们在本节前面看到的相同的一对账户。
- en: Searching an array
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索数组
- en: 'Sometimes, instead of filtering all the elements of an array, you want to find
    an element that satisfies a given predicate. There are a couple of functions that
    can be used for this, depending on your specific needs:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你不想过滤数组中的所有元素，而是想找到一个满足给定谓词的元素。有几个函数可以用来完成这个任务，具体取决于你的具体需求：
- en: '`find()` searches through the array and returns the value of the first element
    that satisfies a given condition, or `undefined` if no such element is found'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find()` 遍历数组，并返回满足给定条件的第一个元素的值，如果没有找到，则返回 `undefined`'
- en: '`findIndex()` performs a similar task, but instead of returning an element,
    it returns the index of the first element in the array that satisfies the condition,
    or `-1` if none were found'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findIndex()` 执行类似的任务，但它返回满足条件的第一个元素的索引，如果没有找到，则返回 `-1`'
- en: 'The similarity to `includes()` and `indexOf()` is clear; these functions search
    for a specific value instead of an element that satisfies a more general condition.
    We can easily write equivalent one-liners:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `includes()` 和 `indexOf()` 的相似性很明显；这些函数搜索的是特定值，而不是满足更一般条件的元素。我们可以轻松地编写等效的单行代码：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Going back to the geographic data we used earlier, we could easily find a given
    country by using the `find()` method. For instance, let’s get data for Brazil
    ( `"BR"`); it just takes a single line of code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前使用的地理数据，我们可以很容易地使用 `find()` 方法找到一个给定的国家。例如，让我们获取巴西（`"BR"`）的数据；这只需要一行代码：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can’t use the simpler `includes()` method because we have to delve into
    the object to get the field we want. If we wanted the position of the country
    in the array, we would have used `findIndex()`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用更简单的 `includes()` 方法，因为我们必须深入到对象中才能获取我们想要的字段。如果我们想获取国家在数组中的位置，我们会使用 `findIndex()`：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: OK, this was easy! What about a special case, which could even be a trick interview
    question? Read on!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这很简单！那么特殊案例呢？这甚至可能是一个面试难题？继续阅读！
- en: A special search case
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊搜索案例
- en: 'Suppose you had an array of numbers and wanted to run a sanity check, studying
    whether any of them were `NaN`. How would you do this? A tip: don’t try checking
    the types of the array elements—even though `NaN` stands for not a number, `typeof
    NaN` *is* `"number"`. You’ll get a surprising result if you try to search in an
    obvious way:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个数字数组，并想进行一个合理性检查，研究其中是否有任何是 `NaN`。你会怎么做？提示：不要尝试检查数组元素的类型——尽管 `NaN` 代表“不是一个数字”，但
    `typeof NaN` 的值是 `"number"`。如果你尝试以明显的方式搜索，你会得到一个令人惊讶的结果：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'What’s going on here? It’s a bit of interesting JavaScript trivia: `NaN` is
    the only value that isn’t equal to itself. Should you need to look for `NaN`,
    you’ll have to use the new `isNaN()` function as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？这是一个有趣的 JavaScript 知识点：`NaN` 是唯一一个不等于自身的值。如果你需要查找 `NaN`，你必须使用新的 `isNaN()`
    函数，如下所示：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'ESLint would help with the `use-isnan` rule: see eslint.org/docs/latest/rules/use-isnan
    for more on this. *Figure 5**.5* shows the result.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 会帮助 `use-isnan` 规则：有关更多信息，请参阅 eslint.org/docs/latest/rules/use-isnan。*图
    5**.5* 展示了结果。
- en: '![Figure 5.5 – ESLint prevents you from a NaN-related mistake](img/Figure_5.5_B19301.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – ESLint 防止你犯与 NaN 相关的错误](img/Figure_5.5_B19301.jpg)'
- en: Figure 5.5 – ESLint prevents you from a NaN-related mistake
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – ESLint 防止你犯与 NaN 相关的错误
- en: This was a particular case worth knowing about; I had to deal with it once!
    Now, let’s continue as we have done previously, by emulating the searching methods
    with `reduce()` so that we can see more examples of the power of that function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个值得了解的特殊情况；我必须处理过一次！现在，让我们像以前一样继续，通过使用 `reduce()` 模拟搜索方法，这样我们就可以看到更多该函数的强大功能示例。
- en: Emulating find() and findIndex() with reduce()
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `reduce()` 模拟 find() 和 findIndex()
- en: As with the other methods, let’s finish this section by studying how to implement
    the methods we showed by using the omnipotent `reduce()`. This is a good exercise
    to get accustomed to working with HOFs, even if you will never actually use these
    polyfills!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他方法一样，让我们通过研究如何使用无所不能的 `reduce()` 实现我们展示的方法来结束本节。这是一个很好的练习，让你习惯于使用 HOFs（高阶函数），即使你实际上永远不会使用这些
    polyfills（多项填充）！
- en: 'The `find()` method requires a bit of work. We start the search with an `undefined`
    value, and if we find an array element so that the predicate is `true`, we change
    the accumulated value to that of the array:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 方法需要一点工作。我们以一个 `undefined` 值开始搜索，如果我们找到一个数组元素使得谓词为 `true`，我们将累计值更改为该数组：'
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In terms of performance, there’s a slight difference with the standard `find()`
    method. The language specification (at [tc39.es/ecma262/#sec-array.prototype.find](http://tc39.es/ecma262/#sec-array.prototype.find))
    shows that the search stops as soon as an element satisfies the search. Our code,
    however, keeps processing the rest of the array (because that’s how `reduce()`
    works), although it doesn’t evaluate the predicate again; can you see why?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，它与标准的 `find()` 方法略有不同。语言规范（在 [tc39.es/ecma262/#sec-array.prototype.find](http://tc39.es/ecma262/#sec-array.prototype.find)）显示，搜索会在找到一个满足搜索条件的元素时停止。然而，我们的代码会继续处理数组的其余部分（因为这就是
    `reduce()` 的工作方式），尽管它不会再次评估谓词；你能看出为什么吗？
- en: 'For `findIndex()`, we must remember that the callback function receives the
    accumulated value, the array’s current element, and the index of the current element,
    but other than that, the equivalent expression is quite similar to the one for
    `find()`; comparing them is worth the time:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `findIndex()`，我们必须记住回调函数接收累计值、当前元素的数组以及当前元素的索引，但除此之外，等效表达式与 `find()` 的表达式非常相似；比较它们是值得花时间的：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The initial accumulated value is `-1` here, which will be the returned value
    if no element fulfills the predicate. Whenever the accumulated value is still
    `-1`, but we find an element that satisfies the predicate, we change the accumulated
    value to the array index.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的初始累计值是 `-1`，如果没有元素满足谓词，它将是返回值。每当累计值仍然是 `-1`，但我们找到一个满足谓词的元素时，我们将累计值更改为数组索引。
- en: 'OK, we are now done with searches: let’s move on to considering higher-level
    predicates that will simplify testing arrays for a condition, but always in the
    declarative style we’ve been using so far.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在完成了搜索：让我们继续考虑更高级的谓词，这将简化测试数组以检查条件，但始终使用我们迄今为止一直在使用的声明式风格。
- en: Higher-level predicates – every() and some()
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高级的谓词 – every() 和 some()
- en: 'The last functions we will consider greatly simplify going through arrays to
    test for conditions. These functions are as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的最后几个函数将极大地简化遍历数组以测试条件。这些函数如下：
- en: '`every()`, which is `true` if and only if every element in the array satisfies
    a given predicate'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`every()`，当且仅当数组中的每个元素都满足给定的谓词时为 `true`'
- en: '`some()`, which is `true` if at least one element in the array satisfies the
    predicate'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`some()`，当数组中至少有一个元素满足谓词时为 `true`'
- en: 'For example, we could quickly check our hypothesis about all the countries
    having negative coordinates:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以快速检查关于所有国家坐标为负数的假设：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we want to find equivalents to these two functions in terms of `reduce()`,
    the two alternatives show nice symmetry:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用 `reduce()` 的方式找到这两个函数的等价函数，两种替代方案显示了很好的对称性：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first folding operation evaluates `fn(y)` and ANDs the result with the previous
    tests; the only way the final result will be `true` is if every test succeeds.
    The second folding operation is similar, but ORs the result with the previous
    results and will produce `true` unless every test fails.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次折叠操作评估 `fn(y)` 并将结果与之前的测试进行 AND 操作；最终结果为 `true` 的唯一方式是每个测试都成功。第二次折叠操作类似，但它将结果与之前的测试结果进行
    OR 操作，除非每个测试都失败，否则将产生 `true`。
- en: Boolean duality
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔对偶性
- en: In terms of Boolean algebra, the alternative formulations for `every()` and
    `some()` exhibit duality. This duality is the same kind that appears in the `x
    === x && true` and `x === x || false` expressions; if `x` is a Boolean value,
    and we exchange `&&` and `||`, and also `true` and `false`, then we transform
    one expression into the other, and both are valid.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔代数中，`every()` 和 `some()` 的替代公式表现出对偶性。这种对偶性与出现在 `x === x && true` 和 `x ===
    x || false` 表达式中的对偶性相同；如果 `x` 是布尔值，并且我们交换 `&&` 和 `||`，以及 `true` 和 `false`，那么我们将一个表达式转换成另一个表达式，两者都是有效的。
- en: In this section, we saw how to check for a given Boolean condition. Let’s finish
    by seeing how to check a negative condition by inventing a method of our own.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何检查给定的布尔条件。让我们通过发明我们自己的方法来检查负条件来完成。
- en: Checking negatives – none()
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查负数 – none()
- en: 'If you wanted, you could also define `none()` as the complement of `every()`.
    This new function would be `true` only if none of the elements of the array satisfied
    the given predicate. The simplest way of coding this would be by noting that if
    no elements satisfy the condition, then all elements satisfy the negation of the
    condition:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你也可以将 `none()` 定义为 `every()` 的补集。这个新函数仅在数组的元素都不满足给定的谓词时为 `true`。实现这一点的最简单方法是通过注意，如果没有元素满足条件，那么所有元素都满足条件的否定：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can turn it into a method by modifying the array prototype, as we saw earlier.
    It’s still a bad practice, but it’s what we have until we start looking into better
    methods for composing and chaining functions, which we will do in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148),
    *Connecting Functions*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过修改数组原型将其转换为方法，就像我们之前看到的那样。这仍然是一个坏习惯，但这是我们开始寻找更好的方法来组合和链接函数之前的情况，我们将在 [*第8章*](B19301_08.xhtml#_idTextAnchor148)
    *连接函数* 中这样做：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We had to use `function()` instead of an arrow function for the same reasons
    we saw on earlier occasions: we need `this` to be correctly assigned. We also
    had to add a global definition like when we used averages so that TypeScript wouldn’t
    object to the newly added `none()` method. Other than that, it’s simple coding,
    and we now have a `none()` method available for all arrays. In [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we will see yet other ways of negating a function by writing
    an appropriate HOF of our own.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `function()` 而不是箭头函数，原因与我们在之前场合看到的原因相同：我们需要 `this` 被正确分配。我们还需要添加一个全局定义，就像我们使用平均值时那样，这样
    TypeScript 就不会反对新添加的 `none()` 方法。除此之外，这只是简单的编码，我们现在为所有数组都有一个可用的 `none()` 方法。在
    [*第6章*](B19301_06.xhtml#_idTextAnchor107) *生成函数* 中，我们将看到通过编写我们自己的适当的高阶函数（HOF）来否定函数的其他方法。
- en: In this and the preceding section, we worked with everyday problems and saw
    how to solve them declaratively. However, things change a bit when you start working
    with `async` functions. We will see in the following section that new solutions
    will be needed.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和前一节中，我们处理了日常问题，并看到了如何声明式地解决它们。然而，当你开始使用 `async` 函数时，事情会有所变化。在下一节中，我们将看到需要新的解决方案。
- en: Working with async functions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步函数
- en: 'All the examples and code we studied in the previous sections were meant to
    be used with common functions, specifically meaning *not* `async` ones. When you
    want to do mapping, filtering, reducing, and so on, but the function you are using
    is an `async` one, the results may surprise you. To simplify our work and not
    deal with actual API calls, let’s create a `fakeAPI(delay, value)` function that
    will delay a while before returning the given value:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中我们学习的所有示例和代码都是为了与常用函数一起使用，具体来说就是**不是**`async`函数。当你想要进行映射、过滤、归约等操作，但使用的函数是一个`async`函数时，结果可能会让你感到惊讶。为了简化我们的工作并避免处理实际的API调用，让我们创建一个`fakeAPI(delay,
    value)`函数，该函数会在返回给定值之前延迟一段时间：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s also have a function to display what `fakeAPI()` returns so that we can
    see that things are working as expected:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再有一个函数来显示`fakeAPI()`返回的内容，这样我们就可以看到一切是否按预期工作：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We are using the modern `async` and `await` features from ES2017 to simplify
    our code, and we are avoiding the top-level `await`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用ES2017中的现代`async`和`await`功能来简化我们的代码，并且我们避免使用顶级`await`：
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The results are previsible: we get the `START` text, then about 1 second (1,000
    milliseconds) later, the result of the fake API call (`229`), and finally the
    `END` text. What could go wrong?'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是可以预见的：我们得到`START`文本，然后大约1秒（1,000毫秒）后，得到伪造API调用的结果（`229`），最后是`END`文本。可能出什么问题？
- en: Top-level await
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级await
- en: Why are we using the immediate invocation pattern we saw in [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*? The reason is that the use of `await` at the top
    level has been available for Node.js since version 14.8 (August 2020) and browsers
    since 2021, so it’s not yet widespread. So, as you can only use `await` within
    an `async` function, I opted to go with an IIFE here for major compatibility.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要使用在[*第3章*](B19301_03.xhtml#_idTextAnchor054)“开始使用函数”中看到的立即调用模式？原因是自Node.js版本14.8（2020年8月）和浏览器自2021年以来，`await`在顶级的使用一直是可用的，所以它还没有得到广泛的应用。因此，由于你只能在`async`函数中使用`await`，我选择在这里使用IIFE以实现主要兼容性。
- en: The critical problem is that all the functions we saw earlier in this chapter
    are not `async`-*aware*, so they won’t work as you’d expect. Let’s start looking
    at this.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题是我们在本章前面看到的所有函数都不是`async`-**感知的**，所以它们不会按你预期的那样工作。让我们开始探讨这个问题。
- en: Some strange behaviors
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些奇怪的行为
- en: 'Let’s start with a simple quiz: are results what you expected? Let’s look at
    a couple of examples of code involving `async` calls, and we’ll see some unexpected
    results. First, let’s look at a typical straightforward sequence of `async` calls:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个小测验开始：结果是你预期的吗？让我们看看几个涉及`async`调用的代码示例，并会发现一些意外的结果。首先，让我们看看一个典型的直接`async`调用序列：
- en: '[PRE54]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you run this code, you’ll get the following results, which are indeed what
    you would expect—a `START SEQUENCE` text, four individual lines with the results
    of the fake API calls, and a final `END SEQUENCE` text. Nothing special here—everything
    is fine!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你会得到以下结果，这确实是你预期的——一个`START SEQUENCE`文本，四行单独的文本显示了伪造API调用的结果，以及最后的`END
    SEQUENCE`文本。这里没有什么特别的——一切正常！
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let’s go for an alternative second version, which you’d expect to be equivalent
    to the first one. The only difference here is that we are using looping to do
    the four API calls; it should be the same, shouldn’t it? (We could also have used
    a `forEach()` loop with the `range()` function that we saw earlier, but that makes
    no difference.) I kept using an IIFE, though in this particular case, it wasn’t
    needed; can you see why?
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个替代的第二版本，你可能会期望它与第一个版本等效。这里唯一的区别是我们使用循环来执行四个API调用；它应该是相同的，不是吗？（我们也可以使用我们之前看到的`range()`函数的`forEach()`循环，但这不会产生任何区别。）尽管在这个特定情况下不需要，但我仍然使用了IIFE；你能看出为什么吗？
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This code certainly looks equivalent to the first one, but it produces something
    entirely different!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来确实与第一个例子相同，但它产生的是完全不同的结果！
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `END FOREACH` text appears before the results of the API calls. What’s
    happening? The answer is what we mentioned before: methods similar to `forEach()`
    and the like are meant to be used with standard, sync function calls and behave
    strangely with `async` function calls.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`END FOREACH`文本出现在API调用结果之前。发生了什么？答案是我们在前面提到过的：类似于`forEach()`这样的方法旨在与标准、同步函数调用一起使用，并且在与`async`函数调用一起使用时会表现得非常奇怪。'
- en: The key concept is that `async` functions always return promises, so after getting
    the `START FOREACH` text, the loop actually creates four promises (which will
    eventually be resolved at some point), *but without waiting for them*, and our
    code goes on to print the `END` `FOREACH` text.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 关键概念是 `async` 函数始终返回承诺，因此在我们得到 `START FOREACH` 文本后，循环实际上创建了四个承诺（最终将在某个时刻解决），*但不需要等待它们*，我们的代码继续打印
    `END` `FOREACH` 文本。
- en: The problem is not only with `forEach()` but also affects all other similar
    methods. Let’s see how we can work around this situation and write `async`-aware
    functions to let us keep working in a declarative fashion, as we did earlier in
    the chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不仅在于 `forEach()`，还影响了所有其他类似的方法。让我们看看我们如何解决这个问题，并编写 `async` 意识函数，让我们能够以声明式的方式继续工作，就像我们在本章前面所做的那样。
- en: Async-ready looping
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`async` 准备循环'
- en: If we cannot directly use methods such as `forEach()`, `map()`, and the like,
    we’ll have to develop new versions of our own. Let’s see how to achieve this.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能直接使用 `forEach()`、`map()` 等方法，我们就必须开发我们自己的新版本。让我们看看如何实现这一点。
- en: Looping over async calls
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历 `async` 调用
- en: 'Since `async` calls return promises, we can emulate `forEach()` with `reduce()`
    by starting with a resolved promise and chaining to it the promises for each value
    in the array. The `then()` methods will be called in the proper order, so the
    results will be correct. The following piece of code manages to get the right,
    expected results:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `async` 调用返回承诺，我们可以通过从已解决的承诺开始，并将每个数组中的值的承诺链接到它，使用 `reduce()` 来模拟 `forEach()`。`then()`
    方法将按正确顺序被调用，因此结果将是正确的。以下代码片段成功地得到了正确、预期的结果：
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The result is as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As `forEachAsync()` returns a promise, we must remember to await it before showing
    the final text message. Other than not forgetting all the `await` statements,
    the code is similar to what we build using `forEach()` with the crucial difference
    being that this does work as expected!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `forEachAsync()` 返回一个承诺，我们必须记得在显示最终文本消息之前等待它。除了不要忘记所有的 `await` 语句外，代码与使用
    `forEach()` 构建的代码类似，关键的区别在于这确实按预期工作！
- en: Mapping async calls
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射 `async` 调用
- en: 'Can we use the other functions? Writing `mapAsync()`, a version of `map()`
    that can work with an `async` mapping function, is simple because you can take
    advantage of `Promise.all()` to create a promise out of an array of promises:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用其他函数吗？编写 `mapAsync()`，这是一个可以与 `async` 映射函数一起工作的 `map()` 版本，很简单，因为你可以利用
    `Promise.all()` 将承诺数组转换为承诺：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We get the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The structure of the solution is similar to the `forEachAsync()` code. As before,
    we must remember to `await` the result of `mapAsync()` before continuing the process.
    Other than that, the logic is straightforward, and the results are as expected;
    the mapping function delays for a while and returns 10 times its input argument,
    and we see the correct output is produced.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的结构与 `forEachAsync()` 代码类似。就像之前一样，我们必须记得在继续处理之前等待 `mapAsync()` 的结果。除此之外，逻辑很简单，结果也符合预期；映射函数延迟一段时间，然后返回其输入参数的
    10 倍，我们看到产生了正确的输出。
- en: Filtering with async calls
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `async` 调用进行过滤
- en: 'Filtering with an `async` function is a tad more complicated. We will have
    to use `mapAsync()` to produce an array of `true` or `false` results and then
    use the standard `filter()` method to pick values out of the original array depending
    on what the `async` filtering function returned. Let’s try out a simple example,
    calling the API and accepting only even results utilizing a `fakeFilter()` function,
    which, for our example, accepts even numbers and rejects odd ones:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async` 函数进行过滤稍微复杂一些。我们将不得不使用 `mapAsync()` 来生成一个包含 `true` 或 `false` 结果的数组，然后使用标准的
    `filter()` 方法根据 `async` 过滤函数返回的结果从原始数组中挑选值。让我们尝试一个简单的例子，使用 `fakeFilter()` 函数调用
    API 并只接受偶数结果，其中，对于我们的例子，`fakeFilter()` 接受偶数并拒绝奇数：
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The needed `async` filtering code is as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的 `async` 过滤代码如下：
- en: '[PRE63]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The result is as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE64]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that the result of the mapping of `async` calls is a Boolean array (`arr2`),
    which we then use with `filter()` to select elements from the original array of
    values (`arr`); this can be tricky to understand!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`async` 调用的映射结果是一个布尔数组（`arr2`），然后我们使用 `filter()` 从原始值数组（`arr`）中选择元素；这可能会有些难以理解！
- en: Reducing async calls
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少 `async` 调用
- en: 'Finally, finding an equivalent for `reduce()` is a bit more complex, but not
    so much after the other functions that we’ve seen. The key idea is the same as
    for `forEachAsync()`: each function call will return a promise, which must be
    awaited in order to update the accumulator in an upcoming `then()`. We set up
    this iteration with an initial promise that immediately resolves to the initial
    value for the accumulator:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，找到`reduce()`的等效函数要复杂一些，但不像我们看到的其他函数那样复杂。关键思想与`forEachAsync()`相同：每个函数调用将返回一个promise，必须等待它以在即将到来的`then()`中更新累加器。我们使用一个立即解析为累加器初始值的初始promise来设置这个迭代：
- en: '[PRE65]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To do the reducing, let’s use an `async` `fakeSum()` function that will sum
    the API-returned values:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行归约，让我们使用一个`async`的`fakeSum()`函数，该函数将累加API返回的值：
- en: '[PRE66]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Note the critical detail: in our reducing function, we must first `await` the
    value of the accumulator and only afterward `await` the result of our `async`
    function. This is an important point you must not miss: since we are reducing
    in an `async` fashion, getting the accumulator is also an `async` matter, so we
    need to `await` both the accumulator and the new API call.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意关键细节：在我们的归约函数中，我们必须首先`await`累加器的值，然后才能`await`我们`async`函数的结果。这是一个你必须注意的重要点：由于我们是以`async`方式归约的，获取累加器也是一个`async`过程，因此我们需要`await`累加器和新的API调用。
- en: 'The result shows four intermediate values and the final result:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了四个中间值和最终结果：
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: By looking at these equivalents, we have seen that `async` functions, despite
    producing problems with the usual declarative methods that we studied at the beginning
    of the chapter, may also be handled by similar new functions of our own, so we
    can keep the new style even for these cases. Even if we have to use a somewhat
    different set of functions, your code will still be declarative, tighter, and
    clearer; an all-around win!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这些等效项，我们已看到，尽管`async`函数在第一章开头我们研究的常规声明式方法中会产生问题，但它们也可以通过我们自己的类似新函数来处理，因此我们甚至可以保留这些情况的新风格。即使我们必须使用一组略有不同的函数，你的代码仍然将是声明式的、更紧凑的、更清晰的；这是一个全面的胜利！
- en: Working with parallel functions
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与并行函数一起工作
- en: JavaScript provides concurrency through `async` functions, meaning that several
    tasks can go on at the same time, even if a single CPU is doing all the jobs.
    **Web workers** (for the frontend) and **worker threads** (for the backend) allow
    processing in parallel in a different core, for better performance. This can offload
    work from the main thread and solve potential problems, in line with our FP approach.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript通过`async`函数提供并发，这意味着即使单个CPU正在完成所有工作，也可以同时进行多个任务。**Web workers**（用于前端）和**工作线程**（用于后端）允许在不同的核心上并行处理，以获得更好的性能。这可以从主线程卸载工作并解决潜在问题，符合我们的FP方法。
- en: In this section, we’ll see how to avoid bottlenecks in frontend and backend
    programming by using workers in functional ways, along the lines of the previous
    sections in this chapter.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们将看到如何通过使用与本章前几节类似的方式使用工作者来避免前端和后端编程中的瓶颈。 '
- en: Unresponsive pages
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无响应页面
- en: Let’s return to our Fibonacci slow-performing code from the *Memoization* section
    in the previous chapter. Suppose we want to create a web page that will allow
    users to enter a number and calculate the corresponding Fibonacci number, as in
    *Figure 5**.6*.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上一章*记忆化*部分中的斐波那契慢速执行代码。假设我们想要创建一个网页，允许用户输入一个数字并计算相应的斐波那契数，如图*图5.6*所示。
- en: '![Figure 5.6 – A Fibonacci calculator](img/Figure_5.6_B19301.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 斐波那契计算器](img/Figure_5.6_B19301.jpg)'
- en: Figure 5.6 – A Fibonacci calculator
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 斐波那契计算器
- en: The code for this page is very basic—and no, I’m not even trying to do any styling;
    that’s not the problem here!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面的代码非常基础——不，我甚至没有尝试进行任何样式设计；这不是问题所在！
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The script code is as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本代码如下：
- en: '[PRE69]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The corresponding Fibonacci number is calculated and shown when the user enters
    a number and clicks on the **Locally** button, but what happens if a fairly large
    number (say, around 50) is entered? *Figure 5**.7* illustrates the problem.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入一个数字并点击**本地**按钮时，相应的斐波那契数将被计算并显示，但如果输入一个相当大的数字（比如说，大约50），会发生什么？*图5.7*说明了这个问题。
- en: '![Figure 5.7 – A long-running process eventually blocks the browser](img/Figure_5.7_B19301.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 一个长时间运行的过程最终会阻塞浏览器](img/Figure_5.7_B19301.jpg)'
- en: Figure 5.7 – A long-running process eventually blocks the browser
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 一个长时间运行的过程最终会阻塞浏览器
- en: As the code runs, the page becomes totally unresponsive, and you cannot click
    anywhere or enter a new number. Furthermore, if a process requires too much processing
    time, the browser will think there’s a problem and offer the user to kill the
    page… not what we want!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码运行时，页面会完全无响应，你无法点击任何地方或输入新数字。此外，如果某个进程需要太多的处理时间，浏览器会认为存在问题，并提示用户终止页面……这并不是我们想要的！
- en: What’s the solution? We want to offload the calculation to a worker, which will
    run in parallel, freeing the browser. Let’s see how we’d set this up in not a
    particularly functional way!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是什么？我们希望将计算任务卸载到工作者（worker），使其并行运行，从而释放浏览器。让我们看看我们如何以一种不太实用的方式设置它！
- en: A frontend worker
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端工作者
- en: Workers (see developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API for web
    workers and nodejs.org/api/worker_threads.html for Node.js worker threads) work
    in similar ways. They are plain JavaScript code that can listen to messages, and
    after doing their work, they respond to their caller by sending another message.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者（有关Web工作者API，请参阅developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API；有关Node.js工作者线程，请参阅nodejs.org/api/worker_threads.html）以类似的方式工作。它们是普通的JavaScript代码，可以监听消息，并在完成工作后，通过发送另一条消息来响应调用者。
- en: 'For our Fibonacci calculation, the following would do:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的斐波那契计算，以下内容是必要的：
- en: '[PRE70]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The last line of the code provides all the interaction between the caller and
    the worker. On getting a message, `e`, its `e.data` value is passed to the `fib()`
    function, and the result is posted back to the caller.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行提供了调用者和工作者之间的所有交互。在接收到消息`e`后，其`e.data`值被传递给`fib()`函数，并将结果发送回调用者。
- en: 'How would this be used? *Figure 5**.8* shows the result we try to achieve.
    We now want to allow two ways of calculating Fibonacci numbers: locally, as before,
    subject to lengthy processing time problems, or in parallel, by offloading the
    job to a worker.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这将如何使用？*图5.8*显示了我们试图实现的结果。现在我们希望允许两种计算斐波那契数的方法：本地计算，如之前所述，但存在处理时间长的问题，或者通过将任务卸载到工作者来并行计算。
- en: '![Figure 5.8 – Calculating Fibonacci numbers by using workers as an option](img/Figure_5.8_B19301.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 使用工作者作为选项计算斐波那契数](img/Figure_5.8_B19301.jpg)'
- en: Figure 5.8 – Calculating Fibonacci numbers by using workers as an option
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 使用工作者作为选项计算斐波那契数
- en: 'The new code is as follows; we’ll highlight the additions:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码如下；我们将突出显示新增内容：
- en: '[PRE71]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The new script file is just like the previous one, with some additions at the
    end:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 新的脚本文件与之前的文件类似，只是在末尾添加了一些内容：
- en: '[PRE72]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The new `Parallelly` button calls the corresponding `parallelly()` function.
    This function gets the number that the user entered and posts it via a message
    to the worker that had been created earlier. The `onmessage` method of that worker
    receives the calculated result and shows it onscreen.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 新的“并行”按钮调用相应的`parallelly()`函数。这个函数获取用户输入的数字，并通过消息将其发送到之前创建的工作者。该工作者的`onmessage`方法接收计算结果并在屏幕上显示。
- en: Using this method, the user can ask for any Fibonacci number, and the window
    will remain responsive, and no warning will pop up for the user to close the page;
    see *Figure 5**.9*.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，用户可以请求任何斐波那契数，而窗口将保持响应，不会弹出警告让用户关闭页面；请参见*图5.9*。
- en: '![Figure 5.9 – The page remains responsive even as calculations take a long
    time](img/Figure_5.9_B19301.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 即使计算时间很长，页面也能保持响应](img/Figure_5.9_B19301.jpg)'
- en: Figure 5.9 – The page remains responsive even as calculations take a long time
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 即使计算时间很长，页面也能保持响应
- en: OK, using workers clearly helps if you have lots of calculations to perform
    at the frontend; let’s see a similar implementation for the backend.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，使用工作者（workers）在需要在前端执行大量计算时确实有帮助；让我们看看后端的一个类似实现。
- en: A backend worker
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端工作者
- en: Let’s see a quick example of a backend worker, as we could use with Node.js
    or similar. The example will be very bare-bones; in real life, we’d include route
    definitions and much more, but we want to focus on worker creation and usage here.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下后端工作者的一个例子，我们可以使用Node.js或类似的技术。这个例子将非常基础；在现实生活中，我们会包括路由定义和更多内容，但在这里我们只想关注工作者创建和使用。
- en: 'Our worker is similar to the web worker; the differences are easy to understand:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作者与Web工作者类似；差异很容易理解：
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The idea is precisely the same; when the `message` event occurs, we call `fib()`
    to calculate the corresponding Fibonacci number, and we use `postMessage()` to
    send it to the caller.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 理念完全相同；当`message`事件发生时，我们调用`fib()`来计算相应的斐波那契数，并使用`postMessage()`将其发送给调用者。
- en: 'The caller code would be simple too:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者代码也会很简单：
- en: '[PRE74]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The code is totally analogous to the frontend code. We create a worker (with
    the `new Worker()` call), we post a message to it with `postMessage()`, and we
    listen to the worker’s `message` event. When we receive the computed result, we
    display it, and `terminate()` the worker. Running this code produces the following
    simple result—the last line takes a while to appear!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与前端代码完全类似。我们创建一个工作者（使用`new Worker()`调用），通过`postMessage()`向其发送消息，并监听工作者的`message`事件。当我们收到计算结果时，我们将其显示出来，并调用`terminate()`来终止工作者。运行此代码会产生以下简单结果——最后一行需要一段时间才能出现！
- en: '[PRE75]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We have seen how to use workers in event-oriented programming, but this isn’t
    particularly suited to our desired FP way of working; let’s fix that.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在事件驱动编程中使用工作者，但这并不特别适合我们想要的函数式编程（FP）工作方式；让我们来解决这个问题。
- en: Workers, FP style
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作者，函数式编程风格
- en: 'Workers are appropriate for FP programming for the following reasons:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者适合函数式编程（FP）编程的原因如下：
- en: Workers run in separate contexts, so they cannot interact with the DOM or global
    variables.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者在单独的上下文中运行，因此它们不能与DOM或全局变量交互。
- en: All communication is done through messages; otherwise, workers are separated
    from their caller.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通信都是通过消息完成的；否则，工作者将与它们的调用者分离。
- en: Data passed to and from workers is a copy; it is serialized before it is passed
    and deserialized when received. Even if the worker were to modify the arguments
    it received, that wouldn’t cause any problem for the caller.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给工作者及其返回的数据是副本；在传递之前进行序列化，在接收时进行反序列化。即使工作者修改了它接收到的参数，也不会对调用者造成任何问题。
- en: We can work with events, but it would be better to wrap workers in promises
    so we can apply the `async` functions we developed in the previous section.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以处理事件，但最好是将工作者包装在承诺（promises）中，这样我们就可以应用上一节中开发的`async`函数。
- en: Events or promises?
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 事件或承诺？
- en: Workers can send multiple messages to their caller. If this is the case, a promise
    won’t be a good idea because it will be resolved after the first result, disregarding
    future messages. In most cases, a single result is expected, so promises are OK,
    but keep in mind there are other possibilities.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者可以向它们的调用者发送多条消息。如果这种情况发生，承诺（promise）将不是一个好主意，因为它将在第一个结果后解决，而忽略未来的消息。在大多数情况下，期望只有一个结果，所以承诺是好的，但请记住还有其他可能性。
- en: 'A direct way to wrap a worker would be the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 包装工作者的直接方法如下：
- en: '[PRE76]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `callWorker` object we create is a promise that will resolve when the worker
    sends back a result. Results are as expected: the `START` text, the `AWAITED`
    result from the worker, and the `END` text. Note that we are using a point-free
    style for processing the `message` event.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`callWorker`对象是一个承诺，当工作者发送回结果时将解决。结果正如预期：`START`文本、工作者返回的`AWAITED`结果，以及`END`文本。请注意，我们正在使用无点（point-free）风格来处理`message`事件。
- en: 'These code examples work well, but they have a performance issue: every time
    you call them, a worker is created (meaning that its JavaScript code must be read,
    parsed, and processed), so there will be delays. Let’s think about ways to avoid
    that.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码示例运行良好，但它们有一个性能问题：每次调用它们时，都会创建一个新的工作者（这意味着其JavaScript代码必须被读取、解析和处理），因此会有延迟。让我们考虑避免这种情况的方法。
- en: Long-living pooled workers
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长期存在的池化工作者
- en: Workers can stay unterminated and will be able to receive new messages and reply
    to them. Messages get queued, so if you need to use the same worker more than
    once at the same time, there will be a logical delay; calls will go out sequentially.
    If you need a worker and it’s free, you can call it directly, but if you need
    it and it’s occupied, it makes sense to create a new worker. We’ll keep a pool
    of threads, and whenever a call comes in, we’ll check whether there’s an available
    worker to deal with it or whether we need to create a new worker first.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者可以保持未终止状态，并将能够接收新消息并回复它们。消息会被排队，所以如果你需要同时多次使用同一个工作者，将会有一个逻辑上的延迟；调用将按顺序进行。如果你需要一个工作者且它空闲，你可以直接调用它，但如果需要它且它正忙，创建一个新的工作者是有意义的。我们将保持一个线程池，并且每当有调用到来时，我们将检查是否有可用的工作者来处理它，或者是否需要首先创建一个新的工作者。
- en: 'Let’s see how to do this. First, we’ll need a pool:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点。首先，我们需要一个池：
- en: '[PRE77]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `PoolEntry` objects will have the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`PoolEntry`对象将具有以下内容：'
- en: The `worker` object.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作者对象。
- en: The filename corresponding to the path with which the worker was created.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与创建工作者时使用的路径对应的文件名。
- en: The value with which it was called the last time we used this worker (just for
    logging; we can do without it).
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上次使用此工作者时调用它的值（仅用于记录；我们可以没有它）。
- en: the `inUse` flag to show whether it’s available or not. `pool` is just an array
    of `PoolEntry` objects.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`inUse`标志来显示它是否可用。`pool`只是一个`PoolEntry`对象的数组。
- en: 'We need a function that will allow us to call a worker; let’s name it `workerCall()`.
    We’ll have to specify the filename of the function to call, and the value to pass
    to it. The function will first see whether there’s an appropriate available free
    worker (with the same filename and not in use) in a very declarative fashion;
    if no worker of this kind is found, it will create a new one. Then, the worker
    will be called by using a promise, as in the previous section, and when a result
    comes, the worker will be marked as not in use, ready for a new call:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个函数来允许我们调用工作者；让我们称它为`workerCall()`。我们必须指定要调用的函数的文件名以及传递给它的值。该函数首先将以非常声明性的方式检查是否存在一个合适的可用空闲工作者（具有相同的文件名且未被使用），如果找不到这种类型的工作者，它将创建一个新的工作者。然后，工作者将通过使用承诺（promise）来调用，就像上一节中那样，当结果返回时，工作者将被标记为未使用，准备接受新的调用：
- en: '[PRE78]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can see how this works with our previous Fibonacci worker, plus a new random
    one that delays a while before returning a random number:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过我们之前使用的斐波那契工作者以及一个新随机工作者来查看这是如何工作的，该随机工作者在返回随机数之前会延迟一段时间：
- en: '[PRE79]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can verify this works:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证这一点：
- en: '[PRE80]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The results of running this code are as follows—but I disabled the `"Resolving"`
    logging line since I was also logging output in another way:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的结果如下——但我禁用了`"Resolving"`日志行，因为我还以另一种方式记录了输出：
- en: '[PRE81]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The results of Fibonacci calls come in order; this is logical since we know
    their calculation time grows. The 3 calls to the random worker take a bit longer,
    but less than the calculation of the 44th Fibonacci number.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列的调用结果按顺序返回；这是合乎逻辑的，因为我们知道它们的计算时间会增长。对随机工作者的3次调用花费的时间稍长，但少于计算第44个斐波那契数的时间。
- en: Notice that we didn’t ask for the 11th Fibonacci number until the result for
    the 10th had come in. Our pool correctly detected it had an available worker to
    use, and it didn’t create a new one.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们直到第10个斐波那契数的结果返回后才请求第11个斐波那契数。我们的池正确地检测到它有一个可用的工作者可以使用，并且没有创建一个新的工作者。
- en: You could explore several extra ideas (see the *Questions* section at the end
    of this chapter), but we achieved an efficient solution that let us run functional
    code in parallel with good performance; a nice win!
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以探索一些额外的想法（见本章末尾的*问题*部分），但我们实现了一个高效的解决方案，使我们能够在并行中运行函数式代码并获得良好的性能；这是一个不错的收获！
- en: Summary
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we started working with HOFs to show a more declarative way
    of working with shorter, more expressive code. We went over several operations:
    we used `reduce()` and `reduceRight()` to get a single result from an array, `map()`
    to apply a function to each element of an array, `forEach()` to simplify looping,
    `flat()` and `flatMap()` to work with arrays of arrays, `filter()` to pick elements
    from an array, `find()` and `findIndex()` to search in the arrays, and `every()`
    and `some()` (plus a made-up `none()`) to verify general logic conditions. We
    then considered some unexpected situations when you deal with `async` functions,
    and we wrote special functions for those cases. Finally, we showed how to do parallel
    work functionally for extra performance.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始使用高阶函数（HOFs）来展示一种更声明性的工作方式，代码更短、更易于表达。我们讨论了几个操作：我们使用了`reduce()`和`reduceRight()`从数组中获取单个结果，`map()`将函数应用于数组的每个元素，`forEach()`简化循环，`flat()`和`flatMap()`处理数组中的数组，`filter()`从数组中选择元素，`find()`和`findIndex()`在数组中进行搜索，以及`every()`和`some()`（加上我们自己编造的`none()`）来验证一般的逻辑条件。然后，我们考虑了一些处理`async`函数时可能出现的不预期情况，并为这些情况编写了特殊函数。最后，我们展示了如何以函数式的方式执行并行工作以获得额外的性能。
- en: In [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, we
    will continue working with HOFs, but we will write our own ones to gain more expressive
    power for our coding.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B19301_06.xhtml#_idTextAnchor107) *生成函数*中，我们将继续使用高阶函数（HOFs），但我们将编写自己的函数来增强我们的编码表达力。
- en: Questions
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '5.1 `filter()` → `map()` → `reduce()` sequence is quite common (even though
    sometimes you won’t use all three), and we’ll come back to this in the *Functional
    design patterns* section of [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204)*,
    Implementing Design Patterns*. The problem here is how to use those functions
    (and no others!) to produce an unordered list of elements (`<ul>...</ul>`) that
    can later be used onscreen. Your input is an array of characters such as the following
    (does the list date me?), and you must produce a list of each name that corresponds
    to chess or checkers players:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 5.1 `filter()` → `map()` → `reduce()`序列相当常见（即使有时你不会使用所有三个），我们将在[*第11章*](B19301_11.xhtml#_idTextAnchor204)*，实现设计模式*的*功能设计模式*部分再次回到这个问题。这里的问题是，如何使用这些函数（以及没有其他函数！）来生成一个无序列表元素（`<ul>...</ul>`），稍后可以在屏幕上使用。你的输入是一个字符数组，例如以下内容（这个列表让我显得很老吗？），你必须生成一个与象棋或跳棋玩家对应的每个名称的列表：
- en: '[PRE82]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output would be something like the following (although it doesn’t matter
    if you don’t generate spaces and indentation). It would be easier if you could
    use, say, `join()`, but in this case, it won’t be allowed; only the three functions
    mentioned can be used:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容（尽管如果你不生成空格和缩进也没有关系）。如果能使用`join()`会更容易，但在这个情况下，不允许这样做；只能使用提到的三个函数：
- en: '[PRE83]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '5.2 **More formal testing**: In some preceding examples, such as those in the
    *Emulating map() with reduce()* section, we didn’t write actual unit tests but
    were satisfied with doing some console logging. Can you write appropriate unit
    tests instead?'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 5.2 **更正式的测试**：在一些先前的例子中，例如在*使用reduce()模拟map()*部分，我们没有编写实际的单元测试，而是满足于进行一些控制台日志记录。你能编写适当的单元测试吗？
- en: 5.3 `reverseString2()` function, we used a summing function for the reduction,
    but we already had written a `sum()` function in the *Summing an array* section;
    couldn’t we use it here? Why not? How can we solve that?
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 5.3 `reverseString2()`函数，我们使用了求和函数进行减少，但我们已经在*求和数组*部分写了一个`sum()`函数；我们为什么不能在这里使用它呢？为什么不呢？我们该如何解决这个问题？
- en: '[PRE84]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 5.4 `reverseString2()` function (see the previous question) if we summed `x`
    and `y` the reverse way, writing this instead?
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 5.4 `reverseString2()`函数（参见上一个问题），如果我们以相反的方式求和`x`和`y`，写成这样？
- en: '[PRE85]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 5.5 `range()` function we saw here has many uses but lacks a bit of generality.
    Can you expand it to allow for descending ranges, as in, `range(10,1)`? (What
    should the last number in the range be?) Could you also include a step size to
    specify the difference between consecutive numbers in the range? With this, `range(1,10,2)`
    would produce `[1, 3, 5,` `7, 9]`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 5.5 我们在这里看到的`range()`函数有很多用途，但缺乏一点通用性。你能扩展它以允许倒序范围，比如`range(10,1)`吗？（范围中的最后一个数字应该是什么？）你也能包括一个步长来指定范围内连续数字之间的差异吗？有了这个，`range(1,10,2)`将产生`[1,
    3, 5, 7, 9]`。
- en: 5.6 `range()` function. Instead of first generating a whole array of numbers
    and then processing them, a generator-based solution generates the range numbers
    one at a time. Can you provide such an implementation?
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 5.6 `range()`函数。不是首先生成一个包含所有数字的整个数组然后再处理它们，基于生成器的解决方案一次生成一个范围数字。你能提供这样的实现吗？
- en: '5.7 `map(x => String.fromCharCode(x))`, you had written `map(String.fromCharCode)`?
    Can you explain the different behavior? Hint: we have seen a similar problem elsewhere
    in this chapter.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 5.7 `map(x => String.fromCharCode(x))`，你写了`map(String.fromCharCode)`？你能解释不同的行为吗？提示：我们在本章的另一个地方遇到过类似的问题。
- en: '5.8 `\n` stands for the newline character:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 5.8 `\n`代表换行符：
- en: '[PRE86]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 5.9 `flat1()` and `flat2()` work properly if applied to arrays with empty places,
    such as `[22, , 9, , , 60, , ]`. Why do they work?
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 5.9 `flat1()`和`flat2()`在应用于有空位的数组时工作正常，例如`[22, , 9, , , 60, , ]`。为什么它们能工作？
- en: '5.10 **Producing better output**: Modify the cities query to produce a list
    of strings that includes not only the name of the city but the state and country
    as well.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 5.10 **产生更好的输出**：修改城市查询，以产生一个包含城市名称、州和国家的字符串列表。
- en: '5.11 **Old-style code only!**: Can you rewrite the word-counting solution without
    using any mapping or reducing? This is more of a JavaScript problem than an FP
    one, but why not?'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 5.11 **仅限旧式代码**！你能不用任何映射或减少操作重写单词计数解决方案吗？这更像是一个JavaScript问题，而不是一个函数式编程问题，但为什么不试试呢？
- en: 5.12 `someArray`, and apply the following `filter()` to it, which at first sight
    doesn’t even look like valid JavaScript code. What will be in the new array, and
    why?
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 5.12 `someArray`，并应用以下`filter()`，乍一看甚至不像是有效的JavaScript代码。新数组中会有什么，为什么？
- en: '[PRE87]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 5.13 `fact4(0)` produce the correct result, i.e., 1? Why, or why not?
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 5.13 `fact4(0)`产生正确的结果，即1吗？为什么，或者为什么不呢？
- en: 5.14 `...Async()` functions are not methods; can you modify them and add them
    to `Array.prototype` so that we can write, for example, `[1,2,3,4].mapAsync(…)`?
    And by the way, will chaining work with your solution?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 5.14 `...Async()`函数不是方法；你能修改它们并将它们添加到`Array.prototype`中，以便我们可以编写，例如，`[1,2,3,4].mapAsync(…)`？顺便问一下，你的解决方案能否支持链式调用？
- en: 5.15 `forEach()`, `map()`, `filter()`, and `reduce()` equivalents for `async`,
    but we didn’t do the same for `find()`, `findIndex()`, `some()`, and `every()`;
    can you?
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 5.15 `forEach()`、`map()`、`filter()`和`reduce()`的`async`等价函数，但我们没有为`find()`、`findIndex()`、`some()`和`every()`做同样的事情；你能做到吗？
- en: '5.16 **Emptying the pool**: As coded, the pool of workers can only grow in
    size. What can you do to prevent it from growing indefinitely? Try this idea:
    whenever there are more than, say, 10 workers not in use, remove some from the
    pool.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 5.16 **排空泳池**：按照编码，工作者池的大小只能增加。你该如何防止它无限增长？尝试以下想法：每当有超过，比如说，10个未使用的工作者时，从池中移除一些。
- en: '5.17 **Queueing for the pool**: You cannot have an unlimited number of parallel
    workers running simultaneously. Implement a queueing procedure so that all calls
    will be accepted, but they will only call a worker when the number of workers
    in use is below a certain threshold.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 5.17 **排队进入池**：你不能同时运行无限数量的并行工作者。实现一个排队程序，以便所有调用都将被接受，但只有在使用中的工作者数量低于某个特定阈值时才会调用工作者。
- en: 5.18 `showResult()` function in the last section is interesting; how does it
    work? It’s a function that returns a function; an optimal example of FP!
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 5.18 上一个部分中的`showResult()`函数很有趣；它是如何工作的？这是一个返回函数的函数；FP（函数式编程）的一个最佳示例！
- en: 5.19 `workerCall()` in the *Long-living pooled workers* section, we wrote the
    following—is this the best way to find the available workers?
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 5.19 在*长生命周期的池工作者*部分，我们编写了以下内容——这是找到可用工作者的最佳方式吗？
- en: '[PRE88]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 5.20 `workerCall()` more suited to real-world problems?
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 5.20 `workerCall()`更适合现实世界的问题吗？
