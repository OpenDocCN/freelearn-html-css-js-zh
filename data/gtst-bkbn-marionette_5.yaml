- en: Chapter 5. Divide and Conquer – Modularizing Everything
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。分而治之——模块化一切
- en: After explaining in detail in [Chapter 4](ch04.html "Chapter 4. Managing Views"),
    *Managing Views*, how to implement regions in `Marionette.js` to manage your views,
    it is time to understand how to deal with complex JavaScript projects and learn
    how to create a framework that would be extensible in subapplications and should
    require minimal effort to scale.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。管理视图")中详细解释了如何实现`Marionette.js`中的区域来管理视图后，现在是时候了解如何处理复杂的JavaScript项目，并学习如何创建一个在子应用中可扩展且应需要最小努力来扩展的框架。
- en: 'The following list contains the main topics that we will cover in this chapter
    and that we should consider while building modular and scalable single-page apps
    using `Marionette.js`:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含我们将在本章中涵盖的主要主题，以及我们在使用`Marionette.js`构建模块化和可扩展的单页应用时应考虑的主题：
- en: Divide and conquer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分而治之
- en: Modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Subapplications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子应用
- en: Memory management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理
- en: Applying the divide and conquer principle
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用分而治之原则
- en: Complexity is the enemy of software, and building complex JavaScript applications
    can easily get out of hand. There are multiple ways to deal with complexity, but
    the most effective method is by using the principle of divide and conquer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性是软件的敌人，构建复杂的JavaScript应用很容易失控。有多种处理复杂性的方法，但最有效的方法是使用分而治之的原则。
- en: 'Directly through its module definition, `Marionette.js` allows us to split
    our code into smaller and more single responsibility blocks. If we do not break
    our code into smaller pieces, we will slow down development and make our application
    difficult to maintain. The easiest starting point to structure the code is the
    `Marionette.Application`. The application''s primary responsibility is to start
    and stop subapplications and, if necessary, mediate cross subapplication communication.
    The following image shows how we can start from the application object to modularize
    our solution in subapplications and modules:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其模块定义，`Marionette.js`允许我们将代码拆分成更小、责任更单一的块。如果我们不将代码拆分成更小的部分，我们将减慢开发速度，并使我们的应用难以维护。结构化代码的最简单起点是`Marionette.Application`。应用的主要职责是启动和停止子应用，并在必要时调解跨子应用通信。以下图像显示了我们可以从应用对象开始，如何将我们的解决方案模块化到子应用和模块中：
- en: '![Applying the divide and conquer principle](img/4252OS_05_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![应用分而治之原则](img/4252OS_05_01.jpg)'
- en: For the **Single-page application** (**SPA**) example that we are building,
    we probably will not need a lot of subapplications right from the beginning. But
    it is really important to know how to use this powerful feature that helps to
    break up an app into smaller and single responsibility units. The subapplication
    modules are independent parts of our app and they can consist of routers, controllers,
    models, layouts, and views.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们正在构建的**单页应用**（SPA）示例，我们可能从一开始就不需要很多子应用。但真正重要的是要知道如何使用这个强大的功能，它有助于将应用拆分成更小、责任单一的单元。子应用模块是我们应用中的独立部分，它们可以包括路由器、控制器、模型、布局和视图。
- en: All modules can be loaded on demand, so they do not need to be created from
    the beginning. For example, we can start them when the subapplication route matches
    specific patterns.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模块都可以按需加载，因此它们不需要从一开始就创建。例如，我们可以在子应用路由匹配特定模式时启动它们。
- en: Modularizing single-page applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化单页应用
- en: Designing a base architecture for single-page apps is not trivial. SPAs are
    opposite to traditional web apps that often have full-page reloads. They are dynamic
    page applications running in one page and usually, require spending some time
    on designing foundations. They are designed more like desktop apps since we store
    the application state in the client, but managing it quickly becomes a problem.
    As we have learned from the divide and conquer principle, a problem can be divided
    in several parts, so that each part can be handled independently. Having said
    that, let's explore how we can implement an application that will load single
    responsibility subapplications on demand, each of them has the ability to stop
    and start modules.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设计单页应用程序的基础架构并非易事。SPAs与经常有完整页面重新加载的传统Web应用程序相反。它们是运行在一个页面上的动态页面应用程序，通常需要花费一些时间来设计基础。由于我们在客户端存储应用程序状态，因此它们更像桌面应用程序，但管理它很快就会成为一个问题。正如我们从分而治之原则中学到的，一个问题可以被分成几个部分，这样每个部分就可以独立处理。话虽如此，让我们探索如何实现一个应用程序，该应用程序将根据需要加载具有单个职责的子应用程序，每个子应用程序都有停止和启动模块的能力。
- en: Getting started with modules
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从模块开始
- en: '|   | "Beauty of style and harmony and grace and good rhythm depends on simplicity."
    |   |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|   | "风格、和谐、优雅和良好节奏之美取决于简单。" |   |'
- en: '|   | -- Plato |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|   | -- 柏拉图 |'
- en: By understanding the concept of divide and conquer, we should agree that the
    modularization of code is tremendously important. Modules are small, simple, and
    well-encapsulated packages that have a singular focus with well-defined functions;
    they can be used in conjunction with other modules to create an entire system.
    In `Marionette.js`, a module provides a high-level piece of functionality and
    manages objects that really provide implementation details.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解分而治之的概念，我们应该同意代码模块化非常重要。模块是小型、简单且封装良好的包，具有单一的关注点以及定义良好的函数；它们可以与其他模块结合使用，以创建整个系统。在`Marionette.js`中，一个模块提供高级功能，并管理提供实现细节的对象。
- en: 'Let''s define a module with no functionality to continue with the examples
    from the book store, where we will create the module that will contain the cart
    and order history subapplications:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个没有功能的模块，以便继续从书店的例子中进行示例，我们将创建包含购物车和订单历史子应用程序的模块：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The modules of `Marionette.js` are loaded and defined after the `app.start()`
    call and they are fully instantiated objects. As you can see, Marionette''s modules
    hang from our application. Let''s now define a real-world module definition:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Marionette.js`的模块在`app.start()`调用之后加载和定义，并且它们是完全实例化的对象。正如你所看到的，Marionette的模块悬挂在我们的应用程序上。现在让我们定义一个真实的模块定义：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is an explanation of the previous code snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码片段的解释：
- en: '`Books`: This is the main application object.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Books`: 这是主要的应用程序对象。'
- en: '`HistoryApp`: This is the name module.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HistoryApp`: 这是命名模块。'
- en: '`startWithParent`: This should be false if we wish to manually start a module
    instead of having the application start it. We have to tell the module definition
    not to start with the parent, and that is exactly our scenario since we do not
    want to start all the subapplications from the beginning. This concept will be
    explained in detail when we get into the *Working with* *subapplications* section
    of this chapter.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startWithParent`: 如果我们希望手动启动模块而不是让应用程序启动它，则此值应为`false`。我们必须告诉模块定义不要与父对象一起启动，这正是我们的场景，因为我们不希望从开始就启动所有子应用程序。这个概念将在本章的*与子应用程序一起工作*部分详细解释。'
- en: 'An explanation of the function arguments is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数的解释如下：
- en: '`App`: This is the application central object that manage the module life cycle'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App`: 这是管理模块生命周期的应用程序中心对象'
- en: '`Backbone`: This is the reference to the `Backbone` library'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone`: 这是`Backbone`库的引用'
- en: '`Marionette`: This is the reference to the `Backbone.Marionette` library'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette`: 这是`Backbone.Marionette`库的引用'
- en: '`$`: This is the reference to the DOM library, jQuery in this case'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`: 这是DOM库的引用，在这种情况下是jQuery。'
- en: '`_`: This is a reference to underscore'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_`: 这是下划线的引用'
- en: In addition to the arguments explained, you can pass custom arguments to this
    function definition. Now we have a very simple module ready to encapsulate some
    of the functionality required.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解释过的参数外，你还可以向这个函数定义传递自定义参数。现在我们有一个非常简单的模块，准备封装一些所需的功能。
- en: Splitting modules into multiple files
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模块拆分为多个文件
- en: Sometimes a module is so long for a single file that we want to split the definition
    across multiple files. But it is pretty common for the subapplication modules
    to contain controllers, routers, and views, among others, so we do not want to
    put them all together in a file. This is made really simple by `Marionette.js`
    modules, so let's take a look.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个模块太长，不适合放在单个文件中，我们希望将定义分散到多个文件中。但是，子应用模块通常包含控制器、路由器和视图等，所以我们不想将它们全部放在一个文件中。`Marionette.js`模块使这一点变得非常简单，所以让我们看看。
- en: 'The following is an example code from a controller file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个控制器文件的示例代码：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An example code from a router file is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个路由器文件的示例代码：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have created two files, one for the controller and other for the router,
    both of them are contained in the same module HistoryApp but located in separated
    files.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个文件，一个用于控制器，另一个用于路由器，这两个文件都包含在同一个模块HistoryApp中，但位于不同的文件中。
- en: Implementing initializers and finalizers
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现初始化器和终结器
- en: Modules have initializers and finalizers similar to application objects. Initializers
    are run when the module is started and finalizers are run when a module is stopped.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模块具有类似于应用对象的初始化器和终结器。初始化器在模块启动时运行，终结器在模块停止时运行。
- en: 'Let''s add an initializer and a finalizer to our existing module:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在现有的模块中添加一个初始化器和终结器：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example shows how we can create definitions inside a module. We added a
    controller in this case, without actually creating any objects—just the definition—and
    then we let the initializer start creating the objects and set them up when the
    module is loaded.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了我们如何在模块内部创建定义。在这种情况下，我们添加了一个控制器，实际上并没有创建任何对象——只是定义——然后我们让初始化器在模块加载时创建对象并设置它们。
- en: Working with subapplications
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与子应用一起工作
- en: Our book's sample app is a single application that can contains several smaller
    applications, for example, shopping cart and order history. Each of them are independent
    but managed by the same application and are able to interact with other modules
    if necessary. The next diagram describes the concept of two subapplications being
    managed by a central application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这本书的示例应用是一个可以包含几个较小应用的单个应用，例如购物车和订单历史。每个应用都是独立的，但由同一个应用管理，并在必要时能够与其他模块交互。下图中描述了由中央应用管理的两个子应用的概念。
- en: '![Working with subapplications](img/4252OS_05_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![与子应用一起工作](img/4252OS_05_02.jpg)'
- en: Each subapplication is usually related with a screen from the SPA. They are
    responsible for doing what is required for screen changes using a controller that
    starts and stops modules and deals with their communication. They also manage
    the layout manipulating regions to display or hide views. Take a look at the code
    related to the diagram.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子应用通常与SPA中的一个屏幕相关联。它们负责使用控制器来执行屏幕更改所需的工作，控制器负责启动和停止模块以及处理它们的通信。它们还管理布局，操纵区域以显示或隐藏视图。查看与图表相关的代码。
- en: Let's now explore how to define two subapplications, each of them is also located
    in different file as we just learned in the previous section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索如何定义两个子应用，每个子应用都位于不同的文件中，正如我们在上一节中学到的。
- en: 'The following is our first application:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们第一个应用：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our second application is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个应用如下：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These applications are managed by the central application (`App`) that is passed
    as a parameter. Both the modules contain a controller definition as an example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用由中央应用（`App`）管理，该应用作为参数传递。这两个模块都包含一个控制器定义作为示例。
- en: 'The next code snippet demonstrates how the main application is capable of starting
    and stopping subapplications:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段演示了主应用能够启动和停止子应用：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, the main application is defined in a self-invoking function.
    It runs automatically/immediately when we create it, and note that calling the
    function returns the main `App` object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，主应用定义在一个自调用函数中。当我们创建它时，它会自动/立即运行，请注意，调用该函数会返回主要的`App`对象。
- en: The function `startSubApp` is what provides the ability to start and stop a
    module. This function will be called probably when the user clicks on the button
    to open the history or when a user navigates directly to this specific route.
    The next step is to understand how to call this function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`startSubApp`提供了启动和停止模块的能力。这个函数可能在用户点击按钮打开历史记录或用户直接导航到这个特定路由时被调用。下一步是了解如何调用这个函数。
- en: Using the route filter
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由过滤器
- en: We have understood how to divide the application into subapplications; however,
    we still need to decide when and how we will tell the main application that we
    need to start a specific subapplication. To accomplish that, each module should
    be associated with a specific router that needs to be active from the beginning.
    This is different from modules that can be lazy loaded when a route matches. The
    creator of `Marionette.js` solves this scenario perfectly with his `BBCloneMail`
    example app that we mentioned before. For that purpose, he included a library
    called `routefilter.js`. As with any other library, this library is installed
    by adding the path reference in our project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何将应用划分为子应用；然而，我们仍需要决定何时以及如何通知主应用我们需要启动特定的子应用。为了实现这一点，每个模块都应该与一个特定的路由器关联，该路由器需要从一开始就处于活动状态。这与当路由匹配时可以懒加载的模块不同。`Marionette.js`的创建者通过我们之前提到的`BBCloneMail`示例应用完美地解决了这个场景。为此，他包含了一个名为`routefilter.js`的库。与任何其他库一样，这个库通过在我们的项目中添加路径引用来安装。
- en: Route filter can be found at [https://github.com/boazsender/backbone.routefilter](https://github.com/boazsender/backbone.routefilter).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 路由过滤器可以在[https://github.com/boazsender/backbone.routefilter](https://github.com/boazsender/backbone.routefilter)找到。
- en: Usually, when we use SPA composed by subapplications, just one subapp is active
    at the same time, and our example application is not the exception. It is important
    to mention this in order to understand the next code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们使用由子应用组成的SPA时，同一时间只有一个子应用处于活动状态，我们的示例应用也不例外。这一点很重要，以便理解接下来的代码。
- en: 'The following code is for the `cart` router:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是针对`cart`路由器的：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we mentioned before, each subapplication generally has a router associated
    with it. This router will be the point of entrance for that application and will
    be responsible to lazy load it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，每个子应用通常都关联着一个路由器。这个路由器将成为该应用的入口点，并负责懒加载它。
- en: Let's explain what the pieces of the code means. Here, `before` is a function
    that is defined with the magic of `routefilter.js`. This function is executed
    before any function that maps the particular route. What it means is that the
    router will know when we are trying to access the specific subapplication and
    will start it by calling the function that we visited before, which is located
    at the main application (`App.startSubApp('CartApp')`). Other pieces that we are
    already familiar with are the module initializer and the route definition.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释一下代码的各个部分。在这里，`before`是一个使用`routefilter.js`的魔法定义的函数。这个函数在映射特定路由的任何函数之前执行。这意味着路由器将知道我们正在尝试访问特定的子应用，并通过调用我们之前访问的函数来启动它，该函数位于主应用中（`App.startSubApp('CartApp')`）。我们已熟悉的其它部分包括模块初始化器和路由定义。
- en: So, what if we want to start the history application now? Easy, just create
    a router associated with that subapplication, define that router, and we are done.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们现在想启动历史应用会怎样？很简单，只需创建一个与该子应用关联的路由器，定义该路由器，我们就完成了。
- en: 'The following code puts this concept into practice:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将这个概念付诸实践：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Memory considerations
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存考虑事项
- en: One of the major challenges in single-page applications is to eliminate the
    memory leaks. The main problem is that we never do full-page reloads to flush
    the memory. So, applications need to handle closing subapplications when a new
    one is put in place to simulate a page load, thus unbinding all the events and
    objects associated with it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用中的一个主要挑战是消除内存泄漏。主要问题是我们从未进行过完整的页面重新加载以刷新内存。因此，当放置新的子应用以模拟页面加载时，应用需要处理关闭子应用，从而解除所有与其相关的事件和对象。
- en: But, we can still mess up the memory with zombies if we do not clean up references
    correctly. So like the main application, all subapplications should close old
    views and this is where Marionette's Region comes in to play. This especially
    ensures the unbinding of all the events when an object is disposed or when we
    switch viewsin a region.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们没有正确清理引用，我们仍然可以通过僵尸进程搞乱内存。因此，就像主应用一样，所有子应用都应该关闭旧视图，这就是Marionette的Region发挥作用的地方。这特别确保了在对象被销毁或我们在区域中切换视图时解除所有事件。
- en: In the case of subapplications, there are multiple ways to clean up the memory.
    To illustrate this, let's revisit some lines of code from the *Working with subapplications*
    section. This function is designed to stop and start subapplications as needed.
    We are using this technique to have just one subapplication running at the same
    time; once a subapplication is stopped, all its objects and events are disposed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在子应用程序的情况下，有多种清理内存的方法。为了说明这一点，让我们回顾一下“与子应用程序一起工作”部分的一些代码。此函数旨在根据需要停止和启动子应用程序。我们使用这项技术以确保同时只有一个子应用程序运行；一旦子应用程序停止，所有其对象和事件都将被销毁。
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our example, if the application was stopped, the router provides the functionality
    to call this function to start the subapplication again, if required. The next
    code is from the *Using the route filter* section of this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果应用程序停止了，路由器提供了调用此函数以在需要时再次启动子应用程序的功能。下面的代码来自本章的“使用路由过滤器”部分。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As an important note, we need to develop discipline to remember that every time
    we create objects, we should be writing the proper code to remove them, always
    taking advantage of the `Marionette.js` capabilities.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个重要的注意事项，我们需要培养纪律性，记住每次我们创建对象时，都应该编写适当的代码来删除它们，始终利用`Marionette.js`的能力。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By far, the main problem that we have in creating a software is complexity.
    An easy starting point for a model view structure is provided by `Backbone.js`,
    but it offers mainly low-level patterns. In the case of a more complex application,
    we can take advantage of some other frameworks to provide the missing parts on
    top of `Backbone.js`. For each part of your system, find a way to solve it and
    combine the solutions of the parts to obtain the solution of the original problem.
    Always strive for readability and maintainability when you implement your modules,
    and try to encapsulate behavior and not just state code with no reason.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在创建软件时遇到的主要问题是复杂性。`Backbone.js`提供了一个易于开始的模型视图结构起点，但它主要提供低级模式。在更复杂的应用程序的情况下，我们可以利用一些其他框架在`Backbone.js`之上提供缺失的部分。对于你系统中的每个部分，找到解决问题的方法，并将各部分的解决方案组合起来以获得原始问题的解决方案。在实现你的模块时，始终追求可读性和可维护性，并尝试封装行为，而不仅仅是无理由的状态代码。
- en: Modules address the larger scale needs for encapsulation, while controllers,
    views, routers, and regions address the more detailed aspects of the matter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 模块解决了封装的大规模需求，而控制器、视图、路由器和区域则处理问题的更详细方面。
- en: Divide and conquer is a principle that has been used for years and is one of
    the most useful concepts when dealing with large and complex system structures.
    Keep up with all the best practices that we have learned and try to make them
    an integral part of your applications. The next step is to learn about messaging
    with `Marionette.js`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 分而治之是一个多年来一直被使用的原则，当处理大型和复杂系统结构时，这是最有用的概念之一。继续掌握我们所学到的所有最佳实践，并尝试将它们作为你应用程序的有机组成部分。下一步是学习使用`Marionette.js`进行消息传递。
