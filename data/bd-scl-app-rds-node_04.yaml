- en: '[CHAPTER 5](toc.xhtml#c05)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第五章](toc.xhtml#c05)'
- en: '[REST API for User Module](toc.xhtml#c05)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[用户模块的 REST API](toc.xhtml#c05)'
- en: '[Introduction](toc.xhtml#s142a)'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[简介](toc.xhtml#s142a)'
- en: At the heart of any application lies the User module, a foundational component
    that orchestrates the management of user-centric features. This module allows
    users to administer the user accounts, enables authentication and authorization,
    and various user-specific operations, such as adding or registering users, updating
    user profiles, deleting users, password management, role-based permission, logging,
    and many more. The User module enhances the user experience and promotes the seamless
    operation of the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的核心都是用户模块，这是一个基础组件，负责管理以用户为中心的功能。此模块允许用户管理用户账户，启用身份验证和授权，以及各种用户特定操作，如添加或注册用户、更新用户资料、删除用户、密码管理、基于角色的权限、日志记录等。用户模块提升了用户体验并促进了应用程序的无缝运行。
- en: '[Structure](toc.xhtml#s143a)'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结构](toc.xhtml#s143a)'
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Base Controller and Base Service for REST API development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础控制器和基础服务用于 REST API 开发
- en: Role Management with Input Validation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带输入验证的角色管理
- en: User Management with Input Validation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带输入验证的用户管理
- en: User Onboarding
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户入职
- en: User Sign-In
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户登录
- en: Authentication and Authorization Mechanism
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权机制
- en: Update User Data
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新用户数据
- en: Delete User Account
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除用户账户
- en: Password Management and Recovery with Email Notification
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带电子邮件通知的密码管理和恢复
- en: '[Base Controller](toc.xhtml#s144a)'
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[基础控制器](toc.xhtml#s144a)'
- en: We have seen in the previous chapter how we constructed individual controllers
    for each module. For each controller, there were some common methods, such as
    handlers for add, get all, get one, update, and so on. Since there is one controller
    for each entity, this set of common functions must be implemented by each controller.
    We could write an abstract class for the controllers to extend and force them
    to provide an implementation. Therefore, adhering to established norms, we are
    now introducing a foundational concept known as **Base Controller**. It is an
    abstract class that serves as a blueprint for other classes to inherit its predefined
    methods that facilitate operations like creating, updating, retrieving all, retrieving
    one, and deleting data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何为每个模块构建单独的控制器。对于每个控制器，都有一些常见的方法，例如添加、获取所有、获取单个、更新等处理程序。由于每个实体都有一个控制器，因此这些通用函数必须由每个控制器实现。我们可以编写一个抽象类供控制器扩展，并强制它们提供实现。因此，遵循既定规范，我们现在介绍一个基础概念，称为
    **基础控制器**。它是一个抽象类，作为其他类继承其预定义方法的蓝图，这些方法有助于创建、更新、检索所有、检索单个和删除数据。
- en: 'Let''s create the `**base_controller.ts**` in the utils directory using the
    following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 utils 目录中使用以下代码创建 `**base_controller.ts**`：
- en: '`// base_controller.ts`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`// base_controller.ts`'
- en: '`import { Request, Response } from ''express'';`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { Request, Response } from ''express'';`'
- en: '`export abstract class BaseController {`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`export abstract class BaseController {`'
- en: '`public abstract addHandler(req: Request, res: Response): void;`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`public abstract addHandler(req: Request, res: Response): void;`'
- en: '`public abstract getAllHandler(req: Request, res: Response): void;`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`public abstract getAllHandler(req: Request, res: Response): void;`'
- en: '`public abstract getOneHandler(req: Request, res: Response): void;`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`public abstract getOneHandler(req: Request, res: Response): void;`'
- en: '`public abstract updateHandler(req: Request, res: Response): void;`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`public abstract updateHandler(req: Request, res: Response): void;`'
- en: '`public abstract deleteHandler(req: Request, res: Response): void;`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`public abstract deleteHandler(req: Request, res: Response): void;`'
- en: '`}`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: The purpose of this abstract class is to furnish a uniform framework that other
    classes (controllers) can adhere to while implementing these methods. When a class
    extends the `**BaseController**`, it becomes obligatory to furnish implementations
    for these abstract methods. This practice guarantees that controllers across various
    routes maintain consistent method names and parameters, even though the specific
    execution details might vary.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象类的目的是提供一个统一的框架，其他类（控制器）在实现这些方法时可以遵循。当一个类扩展了 `**BaseController**` 时，它必须提供这些抽象方法的实现。这种做法保证了跨各种路由的控制器保持一致的方法名称和参数，尽管具体的执行细节可能有所不同。
- en: Please note that an individual controller can still write their own additional
    methods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，单个控制器仍然可以编写自己的额外方法。
- en: The code for this chapter can be downloaded from [https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/tree/main/ch-05-code-files](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/tree/main/ch-05-code-files)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以从[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/tree/main/ch-05-code-files](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/tree/main/ch-05-code-files)下载。
- en: '[Base Service](toc.xhtml#s145a)'
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[基础服务](toc.xhtml#s145a)'
- en: Base Service is a foundational structure that provides common functionalities
    for managing data operations in an application. It serves as a blueprint that
    other services can inherit to avoid repetitive code and ensure consistent patterns
    for data manipulation. The primary purpose of a base service is to encapsulate
    commonly used data operations, such as create, read, update, and delete, and make
    them available to other services. This reduces code duplication and enforces consistent
    practices across different modules of an application. Other services requiring
    data operations can inherit from the base service. By extending the base service,
    these child services gain access to the common methods defined in the base service.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基础服务是一个基础结构，为应用程序中管理数据操作提供常用功能。它作为蓝图，其他服务可以继承以避免重复代码并确保数据操作的一致模式。基础服务的主要目的是封装常用的数据操作，如创建、读取、更新和删除，并将它们提供给其他服务。这减少了代码重复并强制执行应用程序不同模块中的一致实践。需要数据操作的其他服务可以继承基础服务。通过扩展基础服务，这些子服务可以访问基础服务中定义的常用方法。
- en: 'Let''s create the `**base_service.ts**` using the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码创建`**base_service.ts**`：
- en: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/base_service.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/base_service.ts)`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/base_service.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/base_service.ts)`'
- en: If you had downloaded the source code for this chapter, then you can find the
    `**base_service.ts**` inside. We have added comments for each method to explain
    what it does and how it works. This base service class provides common CRUD operations,
    `**findbyIds**`, and a custom query runner along with handling API responses and
    error cases. This service class can be inherited by other services.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经下载了本章的源代码，那么您可以在其中找到`**base_service.ts**`。我们为每个方法添加了注释，以解释其功能和工作原理。这个基础服务类提供了常见的CRUD操作、`**findbyIds**`以及自定义查询执行器，同时处理API响应和错误情况。这个服务类可以被其他服务继承。
- en: It is important to manage database connections efficiently. If we make separate
    database connections for each operation, the application would likely crash during
    high loads. Using a database pool is the best practice to limit and reuse the
    connections from a pool.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 管理数据库连接效率非常重要。如果我们为每个操作创建单独的数据库连接，那么在高负载期间应用程序可能会崩溃。使用数据库池是最佳实践，以限制和重用连接池中的连接。
- en: 'Let''s change the `**db.ts**` file using the following code for adding a database
    pool and to use a single connection in the whole app:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码更改`**db.ts**`文件，以添加数据库池并在整个应用程序中使用单个连接：
- en: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/db.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/db.ts)`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/db.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/db.ts)`'
- en: The `**connectDatabase**` function is responsible for establishing a database
    connection or returning an existing connection if available. It first checks if
    a valid connection already exists, and if not, it initializes a new connection
    and stores it for future use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`**connectDatabase**`函数负责建立数据库连接，如果可用则返回现有连接。它首先检查是否已经存在有效的连接，如果没有，则初始化一个新的连接并将其存储以供将来使用。'
- en: The `**getInstance**` function retrieves a database instance, ensuring it is
    connected before providing access. Unlike the `**connectDatabase**` function,
    `**getInstance**` waits until the connection is established before returning,
    ensuring that it can only be used once the connection is ready.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`**getInstance**` 函数检索数据库实例，确保在提供访问之前连接已经建立。与 `**connectDatabase**` 函数不同，`**getInstance**`
    在返回之前会等待连接建立，确保它只能在连接就绪后使用一次。'
- en: The `**getRepository**` function is designed to retrieve a repository instance
    for a given entity. It checks if a valid database connection exists and creates
    the repository instance if it doesn't already exist. If there's no valid connection,
    it returns null.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`**getRepository**` 函数旨在为给定实体检索存储库实例。它会检查是否存在有效的数据库连接，并在存储库实例不存在时创建它。如果没有有效的连接，它返回
    null。'
- en: '[Role Management](toc.xhtml#s146a)'
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[角色管理](toc.xhtml#s146a)'
- en: Role management is a critical aspect of application security that involves controlling
    and defining the access and permissions of users within a system. It ensures that
    users have the appropriate rights to perform specific actions based on their roles
    or responsibilities. Role management is essential in preventing unauthorized access
    and data breaches and maintaining the overall integrity of an application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 角色管理是应用程序安全的一个关键方面，它涉及控制和定义系统内用户的访问和权限。它确保用户根据其角色或职责执行特定操作时拥有适当的权利。角色管理对于防止未授权访问和数据泄露以及维护应用程序的整体完整性至关重要。
- en: Different users have different levels of access and privileges. For example,
    an application might have different user roles such as `**Super Admin**`, `**Project
    Manager**`, and `**Guest**`, each with distinct sets of permissions. Admins typically
    have access to all features and functionalities, project managers have limited
    access, and guests might have very restricted access.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不同用户有不同的访问级别和权限。例如，一个应用程序可能有不同的用户角色，如 `**超级管理员**`、`**项目经理**` 和 `**访客**`，每个角色都有不同的权限集。管理员通常可以访问所有功能和功能，项目经理有有限的访问权限，而访客可能有非常受限的访问权限。
- en: '[Role Service](toc.xhtml#s147a)'
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[角色服务](toc.xhtml#s147a)'
- en: 'Role Service will be used to perform role-based operations in a database that
    extends from the base service. So, let''s create the `**roles_service.ts**` file
    in the roles component using the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 角色服务将用于在继承自基础服务的数据库中执行基于角色的操作。因此，让我们在角色组件中使用以下代码创建 `**roles_service.ts**` 文件：
- en: '`// role_service.ts`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`// role_service.ts`'
- en: '`import { Repository } from ''typeorm'';`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { Repository } from ''typeorm'';`'
- en: '`import { BaseService } from ''../../utils/base_service'';`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { BaseService } from ''../../utils/base_service'';`'
- en: '`import { DatabaseUtil } from ''../../utils/db'';`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { DatabaseUtil } from ''../../utils/db'';`'
- en: '`import { Roles } from ''./roles_entity'';`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { Roles } from ''./roles_entity'';`'
- en: '`export class RolesService extends BaseService<Roles> {`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`export class RolesService extends BaseService<Roles> {`'
- en: '`constructor() {`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor() {`'
- en: '`// Create an instance of DatabaseUtil`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 创建 DatabaseUtil 的实例`'
- en: '`const databaseUtil = new DatabaseUtil();`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`const databaseUtil = new DatabaseUtil();`'
- en: '`// Get the repository for the Roles entity`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 获取 Roles 实体的存储库`'
- en: '`const roleRepository: Repository<Roles> = databaseUtil.getRepository(Roles);`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`const roleRepository: Repository<Roles> = databaseUtil.getRepository(Roles);`'
- en: '`// Call the constructor of the BaseService class with the`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 调用 BaseService 类的构造函数，并将`'
- en: '`repository as a parameter`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`repository` 作为参数'
- en: '`super(roleRepository);`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`super(roleRepository);`'
- en: '`}`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: The `**RolesService**` class is designed to extend the functionality provided
    by the `**BaseService**` class. It uses the `**DatabaseUtil**` class to get the
    repository for the `**Roles**` entity and then passes that repository to the constructor
    of the `**BaseService**` class. This allows the `**RolesService**` class to inherit
    and use the CRUD methods defined in the `**BaseService**` class for working with
    the `**Roles**` entity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`**RolesService**` 类旨在扩展 `**BaseService**` 类提供的功能。它使用 `**DatabaseUtil**` 类获取
    `**Roles**` 实体的存储库，然后将该存储库传递给 `**BaseService**` 类的构造函数。这使得 `**RolesService**`
    类能够继承并使用在 `**BaseService**` 类中定义的 CRUD 方法来处理 `**Roles**` 实体。'
- en: 'We will develop the REST API for roles as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式开发角色的 REST API：
- en: Add Roles
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加角色
- en: Get All Roles
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有角色
- en: GetOne Role
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取单个角色
- en: Update Role
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新角色
- en: Delete Role
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除角色
- en: Before developing the actual **Add Role** API, we need to define input validation
    for roles while adding them to the database. So, let's use an Express Validator
    to validate input requests.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发实际的 **添加角色** API 之前，我们需要在将角色添加到数据库时定义输入验证。因此，让我们使用 Express Validator 来验证输入请求。
- en: '[Input Validation](toc.xhtml#s148a)'
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[输入验证](toc.xhtml#s148a)'
- en: 'First, install the Express Validator module so paste the following command
    in `**cmd**`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装 Express Validator 模块，请在 `**cmd**` 中粘贴以下命令：
- en: '`npm i express-validator --save`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm i express-validator --save`'
- en: 'Now create the `**validator.ts**` file in the utils directory using the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 utils 目录中创建名为 `**validator.ts**` 的文件，使用以下代码：
- en: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/validator.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/validator.ts)`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/validator.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/validator.ts)`'
- en: The provided code exports a function named `**validate**` that generates `**middleware**`
    for validating request data using the express-validator package. This middleware
    function runs the provided validation functions, checks for validation errors
    using `**validationResult**`, and sends a response with a 400 status and error
    messages if validation fails. The structure of the error messages aligns with
    the `**IValidationError**` interface. This approach is commonly used to handle
    request validation in Express applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码导出一个名为 `**validate**` 的函数，该函数使用 express-validator 包生成用于验证请求数据的 `**middleware**`。此中间件函数运行提供的验证函数，使用
    `**validationResult**` 检查验证错误，如果验证失败，则发送带有 400 状态和错误消息的响应。错误消息的结构与 `**IValidationError**`
    接口相匹配。这种方法通常用于处理 Express 应用程序中的请求验证。
- en: 'Next, create the `**validRoleInput**` in the `**roles_routers.ts**` file using
    the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `**roles_routers.ts**` 文件中创建 `**validRoleInput**`，使用以下代码：
- en: '`// roles_routers.ts`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`// roles_routers.ts`'
- en: '`import { Express } from ''express'';`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { Express } from ''express'';`'
- en: '`import { RoleController, RolesUtil } from ''./roles_controller'';`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { RoleController, RolesUtil } from ''./roles_controller'';`'
- en: '`import { validate } from ''../../utils/validator'';`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { validate } from ''../../utils/validator'';`'
- en: '`import { body } from ''express-validator'';`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { body } from ''express-validator'';`'
- en: '`const validRoleInput = [`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`const validRoleInput = [`'
- en: '`body(''name'').trim().notEmpty().withMessage(''It should be required''),`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`body(''name'').trim().notEmpty().withMessage(''It should be required''),`'
- en: '`body(''description'').isLength({ max: 200 }).withMessage(''It has`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`body(''description'').isLength({ max: 200 }).withMessage(''It has`'
- en: '`maximum limit of 200 characters''),`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`maximum limit of 200 characters''),`'
- en: '`];`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`];`'
- en: '`export class RoleRoutes {`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`export class RoleRoutes {`'
- en: '`private baseEndPoint = ''/api/roles'';`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`private baseEndPoint = ''/api/roles'';`'
- en: '`constructor(app: Express) {`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor(app: Express) {`'
- en: '`const controller = new RoleController();`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`const controller = new RoleController();`'
- en: '`app.route(this.baseEndPoint)`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.route(this.baseEndPoint)`'
- en: '`.get(controller.getAllHandler)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`.get(controller.getAllHandler)`'
- en: '`.post(validate(validRoleInput), controller.addHandler);`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`.post(validate(validRoleInput), controller.addHandler);`'
- en: '`app.route(this.baseEndPoint + ''/:id'')`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.route(this.baseEndPoint + ''/:id'')`'
- en: '`.get(controller.getOneHandler)`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`.get(controller.getOneHandler)`'
- en: '`.put(validate(validRoleInput), controller.updateHandler)`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`.put(validate(validRoleInput), controller.updateHandler)`'
- en: '`.delete(controller.deleteHandler);`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`.delete(controller.deleteHandler);`'
- en: '`}`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: In the preceding class, the `**baseEndPoint**` variable is used. This is part
    of the API endpoints, which is going to be the same for all of the role APIs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中使用了 `**baseEndPoint**` 变量。这是 API 端点的一部分，对于所有角色 API 都将是相同的。
- en: Notice the `**validRoleInput**` variable, which is an array. This array contains
    a series of validation checks for each input field expected in a role. Each element
    of this array is a validator function that checks a specific aspect of the data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `**validRoleInput**` 变量，它是一个数组。这个数组包含了对角色中预期每个输入字段的一系列验证检查。这个数组的每个元素都是一个验证函数，用于检查数据的特定方面。
- en: 'The validator for the `**name**` field in request body would be processed as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体中 `**name**` 字段的验证器将按以下方式处理：
- en: '`body(''name'').trim().notEmpty().withMessage(''It should be required'')`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`body(''name'').trim().notEmpty().withMessage(''It should be required'')`'
- en: 'This validator is applied to the `**name**` field in the request body and performs
    the following functions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此验证器应用于请求体中的 `**name**` 字段，并执行以下功能：
- en: '`**trim()**`: Removes any leading and trailing whitespace from the input.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**trim()**`: 从输入中删除任何前导和尾随空白字符。'
- en: '`**notEmpty()**`: Checks that the input is not empty.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**notEmpty()**`: 检查输入是否为空。'
- en: '`**withMessage(''It should be required'')**`: If the validation fails, this
    message will be included in the error response.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**withMessage(''It should be required'')**`: 如果验证失败，此消息将包含在错误响应中。'
- en: 'Similarly, the validator for the `**description**` field would be as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`**description**`字段的验证器如下所示：
- en: '`body(''description'').isLength({ max: 200 }).withMessage(''It has a maximum
    limit of 200 characters'')`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`body(''description'').isLength({ max: 200 }).withMessage(''It has a maximum
    limit of 200 characters'')`'
- en: This validator is applied to the `**description**` field in the request body.
    It checks that the length of the input does not exceed `**200**` characters.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此验证器应用于请求体中的`**description**`字段。它检查输入的长度不超过`**200**`个字符。
- en: 'Overall, this code defines a set of validation rules for different fields of
    role data, including checking for the presence, length, and validity of access
    rights. If any of the validations fail, the corresponding error message will be
    included in the error response with status code `**400: bad**` request.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '总体而言，此代码定义了一组针对角色数据不同字段的验证规则，包括检查访问权限的存在、长度和有效性。如果任何验证失败，相应的错误消息将包含在状态码为`**400:
    bad**`的错误响应中。'
- en: Each role consists of a set of rights. These rights are nothing but string keys,
    which can help us to understand whether a logged-in user has a particular right
    assigned to let them do a corresponding task. A right for adding a task could
    be as simple as `**add_task**`, which could be added to the role assigned to the
    user.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色都包含一组权限。这些权限不过是字符串键，这有助于我们了解登录用户是否被分配了特定的权限，以便让他们执行相应的任务。添加任务的权限可能非常简单，如`**add_task**`，这可以添加到分配给用户的角色中。
- en: 'Let''s define all of the necessary application rights in `**common.ts**` file
    as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`**common.ts**`文件中定义所有必要的应用权限，如下所示：
- en: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/common.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/common.ts)`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/common.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/common.ts)`'
- en: These rights are application rights, which are used to check permission during
    user login based on the assigned Role. When a role is created, it has a rights
    value that is saved as comma-separated from these application rights.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权限是应用权限，用于根据分配的角色在用户登录时检查权限。当创建角色时，它有一个权限值，这些应用权限以逗号分隔的形式保存。
- en: 'Let''s create a `**RolesUtil**` class with `**getAllPermissionsFromRights**`
    function in the `**role_controller.ts**` file using the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`**role_controller.ts**`文件中使用以下代码创建一个包含`**getAllPermissionsFromRights**`函数的`**RolesUtil**`类：
- en: '`// role_controller.ts`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`// role_controller.ts`'
- en: '`export class RolesUtil {`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`export class RolesUtil {`'
- en: '`/**`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`/**`'
- en: '`* Retrieves all possible permissions from the defined rights in the Rights
    object.`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 从定义的权限对象中的权限中检索所有可能的权限。`'
- en: '`* @returns {string[]} An array of permissions`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`* @returns {string[]} An array of permissions`'
- en: '`*/`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`*/`'
- en: '`public static getAllPermissionsFromRights(): string[] {`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static getAllPermissionsFromRights(): string[] {`'
- en: '`// Initialize an empty array to collect values;`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 初始化一个空数组以收集值；`'
- en: '`let permissions = [];`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`let permissions = [];`'
- en: '`// Iterate through each section of the Rights object`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 遍历Rights对象的每个部分`'
- en: '`for (const module in Rights) {`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`for (const module in Rights) {`'
- en: '`// Check if rights for ALL are defined for the current module`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 检查当前模块是否定义了ALL的权限`'
- en: '`if (Rights[module][''ALL'']) {`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (Rights[module][''ALL'']) {`'
- en: '`let sectionValues = Rights[module][''ALL''];`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`let sectionValues = Rights[module][''ALL''];`'
- en: '`sectionValues = sectionValues.split('','');`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`sectionValues = sectionValues.split('','');`'
- en: '`permissions = […permissions, …sectionValues];`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`permissions = […permissions, …sectionValues];`'
- en: '`}`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`// Return the collected permissions`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 返回收集到的权限`'
- en: '`return permissions;`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`return permissions;`'
- en: '`}`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: This function effectively compiles all the available permissions from the defined
    Rights object, which can then be used for validation and other purposes in the
    application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有效地编译了从定义的权限对象中可用的所有权限，然后可以在应用程序中用于验证和其他目的。
- en: 'Now add validation for the `**rights**` field in `**validRoleInput**` using
    the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请使用以下代码在`**validRoleInput**`中的`**rights**`字段添加验证：
- en: '`const validRoleInput = [`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`const validRoleInput = [`'
- en: '`body(''name'').trim().notEmpty().withMessage(''It should be required''),`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`body(''name'').trim().notEmpty().withMessage(''It should be required''),`'
- en: '`body(''description'').isLength({ max: 200 }).withMessage(''It has maximum
    limit of 200 characters''),`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`body(''description'').isLength({ max: 200 }).withMessage(''It has maximum
    limit of 200 characters''),`'
- en: '`body(''rights'').custom((value: string) => {`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`body(''rights'').custom((value: string) => {`'
- en: '`const accessRights = value?.split('','');`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`const accessRights = value?.split('','');`'
- en: '`if (accessRights?.length > 0) {`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (accessRights?.length > 0) {`'
- en: '`const validRights = RolesUtil.getAllPermissionsFromRights();`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`const validRights = RolesUtil.getAllPermissionsFromRights();`'
- en: '`const areAllRightsValid = accessRights.every(right =>`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`const areAllRightsValid = accessRights.every(right =>`'
- en: '`validRights.includes(right));`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`validRights.includes(right));`'
- en: '`if (!areAllRightsValid) {`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (!areAllRightsValid) {`'
- en: '`throw new Error(''Invalid permission'');`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw new Error(''无效权限'');`'
- en: '`}`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`return true; // Validation passed`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`return true; // 验证通过`'
- en: '`})`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`})`'
- en: '`];`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`];`'
- en: Based on the provided code, the custom validation function ensures the validity
    of rights during the process of adding or updating a role. It evaluates the rights
    received in the request and verifies whether they are valid or not. If any of
    the rights are found to be invalid, an error is generated.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的代码，自定义验证函数确保在添加或更新角色过程中权限的有效性。它评估请求中接收到的权限，并验证它们是否有效。如果发现任何权限无效，将生成错误。
- en: '[Add Role](toc.xhtml#s149a)'
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[添加角色](toc.xhtml#s149a)'
- en: When using the REST API to add a role, you typically provide the necessary data
    in the request body, such as the role's name, description, and the rights it should
    have. The API endpoint responsible for this action is designed to receive this
    data, validate it according to predefined rules, and create a new role based on
    the provided information.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用REST API添加角色时，你通常会在请求体中提供必要的数据，例如角色的名称、描述以及它应该拥有的权限。负责此操作的API端点旨在接收这些数据，根据预定义的规则进行验证，并根据提供的信息创建新的角色。
- en: 'We have already created `**roles_controller.ts**` as a skeleton class. Now,
    let''s change it with an extended Base Controller and use the base service to
    perform database operations using the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`**roles_controller.ts**`作为骨架类。现在，让我们使用扩展的Base Controller来修改它，并使用基础服务通过以下代码执行数据库操作：
- en: '`// roles_controller.ts`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`// roles_controller.ts`'
- en: '`import { Response, Request } from ''express'';`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { Response, Request } from ''express'';`'
- en: '`import { RolesService } from ''./roles_service'';`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { RolesService } from ''./roles_service'';`'
- en: '`import { BaseController } from ''../../utils/base_controller'';`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { BaseController } from ''../../utils/base_controller'';`'
- en: '`import { Rights } from ''../../utils/common'';`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`import { Rights } from ''../../utils/common'';`'
- en: '`export class RoleController extends BaseController {`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`export class RoleController extends BaseController {`'
- en: '`public async addHandler(req: Request, res: Response): Promise<void> {`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`public async addHandler(req: Request, res: Response): Promise<void> {`'
- en: '`const role = req.body;`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`const role = req.body;`'
- en: '`const service = new RolesService();`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`const service = new RolesService();`'
- en: '`const result = await service.create(role);`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`const result = await service.create(role);`'
- en: '`res.status(result.statusCode).json(result);`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.status(result.statusCode).json(result);`'
- en: '`return;`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`return;`'
- en: '`}`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '[PRE0][PRE1]``js[PRE2]`` `{`    `"statusCode": 200,`    `"status": "success",`    `"data":
    [`    `{`    `"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",`    `"name":
    "visitor",`    `"description": null,`    `"rights": null,`    `"created_at": "2023-08-15T13:04:50.314Z",`    `"updated_at":
    "2023-08-15T13:04:50.314Z"`    `}`    `]`    `}`    **Note**: In base service,
    query params will now be applicable for only exact matches. We will explore search
    functionality later on.    # [GetOne Role](toc.xhtml#s151a)    GetOne role endpoint
    is a fundamental part of role management systems, allowing users to view specific
    role information without having to retrieve the entire list of roles. It''s essential
    for providing targeted insights into each role''s attributes and permissions.    To
    implement the GetOne Role API, make the following changes in the `**getOneHandler**`
    code in the role controller:    `// roles_controller.ts`    `public async getOneHandler(req:
    Request, res: Response): Promise<void> {`    `const service = new RolesService();`    `const
    result = await service.findOne(req.params.id);`    `res.status(result.statusCode).json(result);`    `}`    The
    `**getOneHandler**` function serves as the bridge between the incoming client
    request, the service layer that interacts with the database, and the outgoing
    HTTP response. It retrieves a single role''s details from the database based on
    the provided role ID and sends the role information back to the client.    This
    method called from the routes file with making a new route for it as follows:    `//
    roles_routes.ts`    `app.route(this.baseEndPoint + ''/:id'')`    `.get(controller.getOneHandler);`    Here**,**
    `**/:id**` will be a request parameter meant to capture the ID of the role that
    the user wants to retrieve.    **REST API** `**GetOne**` **Role**    **Request**    `URL:
    http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238`    `Method:
    GET`    **Response**    `{`    `"statusCode": 200,`    `"status": "success",`    `"data":
    {`    `"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",`    `"name": "visitor",`    `"description":
    null,`    `"rights": null,`    `"created_at": "2023-08-15T13:04:50.314Z",`    `"updated_at":
    "2023-08-15T13:04:50.314Z"`    `}`    `}`    Providing a valid role ID will yield
    a successful response, while inputting an ID that doesn''t correspond to an existing
    database entry will result in a `**404 error**`, signifying that the requested
    entity was not found.    `{`    `"statusCode": 404,`    `"status": "error",`    `"message":
    "Not Found"`    `}`    # [Update Role](toc.xhtml#s152a)    Updating a role involves
    modifying the existing data of a specific role stored in the database. This process
    allows you to adjust the attributes of a role, such as its name, description,
    and associated rights. By performing an update, you can ensure that the role''s
    information remains accurate and up-to-date. This operation is particularly useful
    when there are changes in a role''s permissions, and you need to reflect those
    changes in the database.    To implement the Update Role API, make the following
    changes in the `**updateHandler**` code in the role controller:    `// roles_controller.ts`    `public
    async updateHandler(req: Request, res: Response) : Promise<void> {`    `const
    role = req.body;`    `const service = new RolesService();`    `const result =
    await service.update(req.params.id, role);`    `res.status(result.statusCode).json(result);`    `}`    The
    `**updateHandler**` function is intended to handle the updating of a role in the
    database.    It operates by retrieving data from the incoming HTTP request body,
    which is then utilized to update the corresponding role data in the database based
    on the role''s unique identifier (`**role_id**`) as request parameter ID. The
    function subsequently generates a response indicating whether the update operation
    was successful or unsuccessful, providing details about the updated data or an
    appropriate error message if needed.    This method called from the routes file
    with making a new route for it as follows:    `// roles_routes.ts`    `app.route(this.baseEndPoint
    + ''/:id'')`    `.get(controller.getOneHandler)`    `.put(validate(validRoleInput),
    controller.updateHandler);`    Here, `**/:id**` will be a request parameter meant
    to capture the ID of the role that the user wants to retrieve, and it also validates
    data before updating in the database.    **REST API Update Role**    **Request**    `URL:
    http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238`    `Method:
    PUT`    `body :`    `{`    `"name":"visitor",`    `"Description":"Allow read projects",`    `"rights":
    "get_all_projects,get_details_project"`    `}`    **Response**    `{`    `"statusCode":
    200,`    `"status": "success",`    `"data": {`    `"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",`    `"name":
    "visitor",`    `"description": null,`    `"created_at": "2023-08-15T13:04:50.314Z",`    `"updated_at":
    "2023-08-18T07:35:06.238Z",`    `"rights": "get_all_projects,get_details_project"`    `}`    `}`    Providing
    a valid role ID will yield a successful response, while inputting an ID that doesn''t
    correspond to an existing database entry will result in a `**404 error**`, signifying
    that the requested entity was not found.    `{`    `"statusCode": 404,`    `"status":
    "error",`    `"message": "Not Found"`    `}`    # [Delete Role](toc.xhtml#s153a)    The
    `**delete**` functionality for roles in a REST API involves the removal of a specific
    role from the database. This process is managed through an endpoint dedicated
    to role deletion. When a request is made to this endpoint, it triggers a function
    that handles the deletion process. The incoming request typically contains the
    unique identifier (`**role_id**`) of the role that needs to be deleted.    To
    implement `**Delete**` Role API, make the following changes in the `**deleteHandler**`
    code in the role controller:    `// roles_controller.ts`    `public async deleteHandler(req:
    Request, res: Response) : Promise<void> {`    `const service = new RolesService();`    `const
    result = await service.delete(req.params.id);`    `res.status(result.statusCode).json(result);`    `}`    The
    `**deleteHandler**` processes the request by utilizing a service that interacts
    with the database. This service is responsible for executing the deletion operation.
    If the requested role exists in the database and the deletion is successful, the
    function responds with a success message and an appropriate status code, such
    as `**200 OK**`. If the role does not exist, the function returns an error response
    with a status code of 404 Not Found, indicating that the role was not located
    in the database.    This method called from the routes file with making a new
    route for it as follows:    `// roles_routes.ts`    `app.route(this.baseEndPoint
    + ''/:id'')`    `.get(controller.getOneHandler)`    `.put(validate(validRoleInput),
    controller.updateHandler)`    `.delete(controller.deleteHandler);`    Here, `**/:id**`
    will be a request parameter meant to capture the ID of the role that the user
    wants to delete.    **REST API Delete Role**    **Request**    `URL: http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238`    `Method:
    DELETE`    **Response**    `{`    `"statusCode": 200,`    `"status": "success"`    `}`    In
    case of already deleted or not exist in database:    `{`    `"statusCode": 404,`    `"status":
    "error",`    `"message": "Not Found"`    `}`    # [Add Default Role from System](toc.xhtml#s154a)    After
    implementing APIs related to roles, let''s add a feature to create a default role
    for `**SuperAdmin**` who has all rights in the system during project initialization.
    This additional functionality can be utilized later for authorization purposes.    Create
    one file in utils directory with name `**ddl_util.ts**` with the following code:    `[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/ddl_util.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/ddl_util.ts)`    This
    DDLUtil class contains a static method addDefaultRole() responsible for adding
    a default role to the system.    Now do following changes in main.ts file:    `[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/main.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/main.ts)`    As
    per code, it checks if command-line arguments are provided and if the first argument
    is `**--init**`. If these conditions are met, an asynchronous function is immediately
    invoked using an async function. It awaits the execution of `**DDLUtil.addDefaultRole()**`,
    which presumably initializes a default role in the system. Once `**addDefaultRole()**`
    completes, `**process.exit()**` is called to terminate the Node.js process. In
    summary, this code block is responsible for initializing a default role in the
    system when the program is run with the `**--init**` flag, and then exiting the
    process afterward.  ![](img/5.2.jpg)  **Figure 5.2:** Invoke Add Default Role
    Script    **Output:**  ![](img/5.3.jpg)  **Figure 5.3:** Postgres Added Role Output    In
    summary, role management plays a critical role in ensuring the security and controlled
    access of users within a system. It allows organizations to define and assign
    specific permissions and rights to different user roles, ensuring that each user
    can only perform actions that are relevant to their role and responsibilities.    #
    [User Management](toc.xhtml#s155a)    User management refers to the process of
    handling user-related functionalities in an application. This includes creating,
    updating, retrieving, and deleting user accounts, as well as managing user roles,
    permissions, and authentication. User management is a crucial aspect of many applications,
    especially those that require user registration, authentication, and authorization.    #
    [User Service](toc.xhtml#s156a)    Let''s create the first user service to perform
    user table operations. Create `**users_service.ts**` using the following code:    `//
    users_service.ts`    `import { Repository } from ''typeorm'';`    `import { BaseService
    } from ''../../utils/base_service'';`    `import { DatabaseUtil } from ''../../utils/db'';`    `import
    { Users } from ''./users_entity'';`    `export class UsersService extends BaseService<Users>
    {`   [PRE3]`` `constructor() {`    `let userRepository: Repository<Users> | null
    = null;`    `userRepository = new DatabaseUtil().getRepository(Users);`    `super(userRepository);`    `}`    `}`    The
    `**UsersService**` class is designed to extend the functionality provided by the
    `**BaseService**` class. It uses the `**DatabaseUtil**` class to get the repository
    for the User entity and then passes that repository to the constructor of the
    `**BaseService**` class. This allows the `**UsersService**` class to inherit and
    use the CRUD methods defined in the `**BaseService**` class for working with the
    Users entity.    # [Input Validation](toc.xhtml#s157a)    User input validation
    is a crucial aspect of developing web applications to ensure data integrity, security,
    and a smooth user experience. It involves checking and sanitizing the data submitted
    by users through various input fields, such as `**email**`, `**username**`, `**password**`,
    `**role**`, and so on.    Now add `**validUserInput**` in the `**users_routes.ts**`
    file using the following code:    `// user_routes.ts`    `import { body } from
    ''express-validator'';`    `import { validate } from ''../../utils/validator'';`    `const
    validUserInput = [`    `body(''username'').trim().notEmpty().withMessage(''It
    should be required''),`    `body(''email'').isEmail().withMessage(''It should
    be valid emailId''),`    `body(''password'')`    `.isLength({ min: 6, max: 12
    }).withMessage(''It must be between 6 and 12 characters in length'')`    `.isStrongPassword({
    minLowercase: 1, minUppercase: 1,`    `minSymbols: 1, minNumbers: 1 })`    `.withMessage(''It
    should include at least one uppercase letter, one lowercase letter, one special
    symbol, and one numerical digit.''),`    `body(''role_ids'').isArray().withMessage(''It
    must be an array of uuids of roles'')`    `.custom((value: string[]) => {`    `if
    (value?.length > 0 && value instanceof Array) {`    `const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;`    `const
    isValid = value?.every(uuid => uuidPattern.test(uuid.trim()));`    `if (!isValid)
    {`    `throw new Error(''It has invalid uuids for role'');`    `}`    `}`    `return
    true; // Validation passed`    `})`    `];`    *   `**validUserInput**` array:
    This array contains a series of validation checks for each input field expected
    in a user. Each element of this array is a validator function that checks a specific
    aspect of the data. *   `**body(''username'').trim().notEmpty().withMessage(''It
    should be required'')**`: This validator is applied to the username field in the
    request body. It removes any leading and trailing whitespace from the input and
    checks that the input is not empty. If the validation fails, this message will
    be included in the error response. *   `**body(''email'').isEmail().withMessage(''It
    should be valid emailId'')**`: This validator is applied to the email field in
    the request body. It checks if a valid email ID is provided or not. If the validation
    fails, it displays a message as given in `**withMessage**`. *   `**body(''password'').isLength({
    min: 6, max: 12 }).withMessage(''It must be between 6 and 12 characters in length'').isStrongPassword({
    minLowercase: 1, minUppercase: 1, minSymbols: 1, minNumbers: 1 }).withMessage(''It
    should include at least one uppercase letter, one lowercase letter, one special
    symbol, and one numerical digit.'')**`: This validator is applied to the password
    field. It checks that the password should be between 6 and 12 characters long
    and have strong passwords as specified in the given option. If the validation
    fails, it gives a defined error message. *   `**body(''role_ids'')…**` : It validates
    the given `**role_ids**` array of UUIDs or not. If any of them are not matched
    in the db, it gives an error.    # [User Onboarding](toc.xhtml#s158a)    In PMS,
    a user onboarding facility is provided by a super admin or someone who has permission
    to add users to the system. First, we create one master or super admin user who
    has all rights, meaning we assign a role that has each and every right. We have
    already created a super admin role, so we will assign that `**role_id**` to the
    user and create a super admin user.    We will store the user''s password in the
    database in an encrypted form instead of plain text for security reasons. So,
    we will install an npm package and encryption function, and then compare encrypted
    password validation during login.    To begin, open the terminal with the root
    directory of the project and paste the following command:    `npm install bcrypt
    --save`    Next, open the `**common.ts**` file and add the following functions:    `//
    common.ts`    `/**`    `* Encrypts a string using bcrypt hashing.`    `*`    `*
    @param {string} s - The string to be encrypted.`    `* @returns {Promise<string>}
    - The encrypted string.`    `*/`    `export const encryptString = async (s: string)
    => {`    `const encryptedString = await bcrypt.hash(s, 8);`    `return encryptedString;`    `};`    `/**`    `*
    Compares a plain string with a bcrypt hash to determine if they match.`    `*`    `*
    @param {string} s - The plain string to be compared.`    `* @param {string} hash
    - The bcrypt hash to compare against.`    `* @returns {Promise<boolean>} - A promise
    that resolves to true if the comparison is successful, otherwise false.`    `*/`    `export
    const bcryptCompare = async (s, hash) => {`    `return await bcrypt.compare(s,
    hash);`    `};`    The `**encryptString**` function takes a string as input and
    uses the `**bcrypt.hash**` function to perform a one-way hashing with a cost factor
    of 8\. The result is an encrypted string that can be stored securely, The async
    keyword indicates that the function is asynchronous, meaning it returns a promise
    that resolves to the encrypted string once the hashing is complete.    The `**bcryptCompare**`
    function takes a plain string and a `**bcrypt**` hash as input. It uses the `**bcrypt.compare**`
    function to compare the plain string with the provided hash. The function returns
    a promise that resolves to true if the comparison is successful (that is, the
    plain string matches the hash), and false otherwise. This comparison is used for
    verifying passwords during authentication processes. The async keyword indicates
    that the function is asynchronous, meaning it returns a promise that holds the
    comparison result.    In `**validUserInput**`, we have seen that we just check
    if the `**role_ids**` field has a value in array form. However, it is necessary
    to check whether these role IDs exist in the db or not before user insertion in
    the db. So, we will create the `**checkValidRoleIds**` function in `**RolesUtil**`
    class.    `public static async checkValidRoleIds(role_ids: string[]) {`    `const
    roleService = new RolesService();`    `// Query the database to check if all role_ids
    are valid`    `const roles = await roleService.findByIds(role_ids);`    `// Check
    if all role_ids are found in the database`    `return roles.data.length === role_ids.length;`    `}`    It
    queries the database using the `**findByIds**` method from the `**roleService**`
    instance to retrieve roles based on the provided role IDs, and then it checks
    whether the number of roles retrieved from the database matches the number of
    input role IDs. If they match, it indicates that all the provided role IDs are
    valid; otherwise, it implies that it is not valid `**role_ids**`.    Let''s update
    the `**users_controller.ts**` file using the following code:    `[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/components/users/users_controller.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/components/users/users_controller.ts)`    This
    function appears to handle the addition of a new user by processing the user data,
    encrypting the password, and checking the validity of role IDs before creating
    the user using a service class. It also handles errors gracefully by providing
    appropriate error responses.    Now call `**addHandler**` in user routes with
    change in the `**users_router.ts**` file as follows:    `// users_routes.ts`    `export
    class UserRoutes {`    `private baseEndPoint = ''/api/users'';`    `constructor(app:
    Express) {`    `const controller = new UserController();`    `app.route(this.baseEndPoint)`    `.post(validate(validUserInput),
    controller.addHandler);`    `}`    This way we created an add user router with
    input validation for user onboarding through middleware of validation. If validation
    happens successfully, then the user is inserted in the database.    **REST API
    Add User**    **Request**    `URL: http://127.0.0.1:`    `Method: POST`    `body
    :`    `{`    `"fullname":"Super Admin",`    `"username":"pms-admin",`    `"email":"admin@pms.com",`    `"password":"Admin@pms1",`    `"role_ids":["b88cc70d-ab0a-4464-9562-f6320df519f6"]`    `}`    **Response**    `{`    `"statusCode":
    201,`    `"status": "success",`    `"data": {`    `"user_id": "f249e681-57d8-4f91-addd-a8c615b43a37",`    `"fullname":
    "Super Admin",`    `"username": "pms-admin",`    `"email": "admin@pms.com",`    `"password":
    "$2b$08$pSsEBELbLrXjDfqBJY/7EuyygVuqDzLyBA0JO8pPnWDYJYp5.O15G",`    `"role_ids":
    [`    `"b88cc70d-ab0a-4464-9562-f6320df519f6"`    `],`    `"created_at": "2023-08-19T18:12:55.315Z",`    `"updated_at":
    "2023-08-19T18:12:55.315Z"`    `}`    `}`    In case, if the `**role_id**` has
    the wrong UUID or does not exist in the role table, then it gives an error with
    status `**400**` as follows:    `{`    `"statusCode": 400,`    `"status": "error",`    `"message":
    "Invalid role_ids"`    `}`    Here, we onboarded super admin. This admin similarly
    adds other users and shares their credentials manually with them. Afterward, users
    can change their own password, which we will cover later on.    # [Add Default
    User from System](toc.xhtml#s159a)    After establishing the default role, let''s
    proceed to create a default user with super admin privileges, granting access
    to all APIs associated with the default role.    Create one `**addDefaultUser**`
    method in `**ddl_util.ts**` file with the following code:    `public static async
    addDefaultUser(): Promise<boolean> {`    `try {`    `await DatabaseUtil.getInstance();`    `const
    service = new UsersService();`    `const user: Users = {`    `user_id: v4(),`    `fullname:
    ''Super Admin'',`    `username: ''superadmin'',`    `email: config.default_user.email,`    `password:
    await encryptString(config.default_user.password),`    `role_id: this.superAdminRoleId,`    `created_at:
    new Date(),`    `updated_at: new Date()`    `};`    `const result = await service.create(user);`    `console.log(''Add
    Default User Result'', result);`    `if (result.statusCode === 201) {`    `return
    true;`    `}`    `return false;`    `} catch (error) {`    ``console.error(`Error
    while addDefaultRole() =>``    ``${error.message}`);``    `return false;`    `}`    `}`    Here,
    we added the default user''s email and password in `**server_config.json**` file
    and used it from there, so you can add it in a similar manner as per your convenience.    This
    function is invoked from the `**main.ts**` file, after creating the default role,
    as follows:    `if (args.length > 0 && args[0] === ''--init'') {`    `(async ()
    => {`    `await DatabaseUtil.getInstance();`    `await DDLUtil.addDefaultRole();`    `await
    DDLUtil.addDefaultUser();`    `process.exit();`    `})();`    `}`    Now run the
    script and see the following output:  ![](img/5.4.jpg)  **Figure 5.4:** Add Default
    User from Script    Output:  ![](img/5.5.jpg)  **Figure 5.5:** Postgres Database
    Added User Output    # [User Sign-In](toc.xhtml#s160a)    Once the user registration
    process is completed, users should have the capability to log into the application.
    As a component of the user sign-in procedure, an API will be established to enable
    users to request the server using their email and password. The server''s role
    is to verify whether the user exists and if the provided password is valid. If
    the validation fails, an error response is generated. However, if the validation
    is successful, the server responds with both an access token and a refresh token.
    This entire process is known as **authentication**.    Upon successful login,
    each subsequent API request must incorporate the access token in the request header.
    The server''s task at this point is to verify the validity of the token. If the
    token is invalid, an error response is generated, preventing further actions.
    Conversely, if the token is valid, the server grants permission for the requested
    actions to be executed. This aspect of validating the access token and permitting
    or denying actions is referred to as **authorization**.    To create `**AccessToken**`,
    we will use the `**jsonwebtoken**`, also known as JWT token. First, you will need
    to install the npm package. For more information, please visit [https://www.npmjs.com/package/jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken)    Open
    the terminal with the root directory and paste the following command:    `npm
    install jsonwebtoken -- save`    `npm install @types/jsonwebtoken -D`    Here
    is a general overview of how JWT works:    *   **Token Structure**: A JWT consists
    of three parts: header, payload, and signature. These parts are base64-encoded
    and combined with periods.     *   **Header**: Contains info about the signing
    algorithm and token type.     *   **Payload**: Contains claims (user info, expiration
    time, and so on).     *   **Signature**: Used for verification and to ensure data
    integrity. *   **Token Creation**: When a user logs in, the server constructs
    the header and payload, including user details and other info. The server signs
    the JWT using a secret key or private key. *   **Token Issuance**: The server
    sends the JWT to the client after successful login. The client stores it, often
    in cookies or local storage. *   **Token Usage**: In subsequent requests, the
    client sends the JWT in the Authorization header or as a parameter. This helps
    the server verify the request''s authenticity and identify the user by decoding
    the payload. *   **Token Verification:** The server verifies the JWT by recalculating
    the signature using the same key. If the recalculated signature matches the JWT''s
    signature, the token is valid. *   **Token Expiration**: JWTs usually have an
    expiration time (exp claim) to prevent indefinite validity. Servers can reject
    expired tokens by checking the expiration time in the payload. *   **Token Revocation
    (Optional)**: JWTs are stateless, meaning the server doesn''t keep track of them
    after issuing. If you need to revoke a JWT before it expires, extra measures like
    maintaining a list of revoked tokens are required.    Remember, the security of
    JWTs relies on protecting the secret key (or private key) and ensuring proper
    token verification on the server side.    Let''s define constants for JWT secret
    and expiration times in the `**common.ts**` file as follows:    `// common.ts`    `export
    const SERVER_CONST = {`    `JWTSECRET: ''SecretKeyOfPMS-SECRET'',`    `ACCESS_TOKEN_EXPIRY_TIME_SECONDS:
    1 * 8 * 60 * 60, // 8 hours`    `REFRESH_TOKEN_EXPIRY_TIME_SECONDS: 5 * 7 * 24
    * 60 * 60, // one week`    `};`    The mentioned parameters are flexible and adaptable
    according to your needs.    # [Authentication](toc.xhtml#s161a)    In the standard
    login process, two tokens are usually created: an access token and a refresh token,
    each having distinct expiration times. The access token has a shorter lifespan,
    while the refresh token has a longer one. If the access token expires, the refresh
    token can be used to generate a new access token, facilitating seamless reauthentication
    without requiring manual login. This approach ensures continuous access without
    interruption.    This process is called **Authentication** in terms of generation
    of tokens.    Let''s create login function in the `**users_controller.ts**` file
    as follows:    `// user_controller.ts`    `import * as jwt from ''jsonwebtoken'';`   [PRE4]`
    `/**`    `* Handles user login by checking credentials, generating tokens, and
    responding with tokens.`    `*`    `* @param {Request} req - The request object.`    `*
    @param {Response} res - The response object.`    `*/`    `public async login(req:
    Request, res: Response): Promise<void> {`    `const { email, password } = req.body;`    `const
    service = new UsersService();`    `// Find user by email`    `const result = await
    service.findAll({ email: email });`    `if (result.data.length < 1) {`    `res.status(404).json({
    statusCode: 404, status: ''error'', message: ''Email`    `not found'' });`    `return;`    `}
    else {`    `const user = result.data[0];`    `// Compare provided password with
    stored hashed password`    `const comparePasswords = await bcryptCompare(password,
    user.password);`    `if (!comparePasswords) {`    `res.status(400).json({ statusCode:
    400, status: ''error'', message: ''Password is not valid'' });`    `return;`    `}`    `//
    Generate access and refresh tokens`    `const accessToken: string = jwt.sign({`    `email:
    user.email,`    `username: user.username`    `}, SERVER_CONST.JWTSECRET, { expiresIn:`    `SERVER_CONST.ACCESS_TOKEN_EXPIRY_TIME_SECONDS
    });`    `const refreshToken: string = jwt.sign({`    `email: user.email,`    `username:
    user.username`    `}, SERVER_CONST.JWTSECRET, { expiresIn:`    `SERVER_CONST.REFRESH_TOKEN_EXPIRY_TIME_SECONDS
    });`    `// Respond with tokens`    `res.status(200).json({ statusCode: 200, status:
    ''success'', data: {`    `accessToken, refreshToken } });`    `return;`    `}`    `}`    In
    this code, the login function handles user login functionality using the following
    steps:    *   It receives the email and password from the request body. *   It
    creates an instance of the `**UsersService**` class to interact with user data.
    *   It queries the database to find a user based on the provided email. *   If
    no user is found with the provided email, it sends a 404 error response. *   If
    a user is found, it compares the provided password with the hashed password stored
    in the user''s data. If the passwords don''t match, it sends a 400 error response.
    *   If the passwords match, it generates an access token and a refresh token using
    the `**jwt.sign**` function. The access token contains user information and has
    a short expiration time, while the refresh token has a longer expiration time.
    *   It sends a success response (status `**200**`) containing the generated access
    and refresh tokens.    Now add another function `**getAccessTokenFromRefreshToken**`
    in the same file using the following code:    `/**`    `* Generates a new access
    token using a valid refresh token.`    `*`    `* @param {Request} req - The request
    object.`    `* @param {Response} res - The response object.`    `*/`    `public
    async getAccessTokenFromRefreshToken(req: Request, res:`    `Response): Promise<void>
    {`    `// Get the refresh token from the request body`    `const refreshToken
    = req.body.refreshToken;`    `// Verify the refresh token`    `jwt.verify(refreshToken,
    SERVER_CONST.JWTSECRET, (err, user) => {`    `if (err) {`    `// If refresh token
    is invalid, send a 403 error response`    `res.status(403).json({ statusCode:
    403, status:`    `''error'', message: ''Invalid Refresh Token'' });`    `return;`    `}`    `//
    Generate a new access token using user information from the refresh token`    `const
    accessToken = jwt.sign(user, SERVER_CONST.JWTSECRET, { expiresIn: SERVER_CONST.ACCESS_TOKEN_EXPIRY_TIME_SECONDS
    });`    `// Respond with the new access token`    `res.status(200).json({ statusCode:
    200, status: ''success'', data: { accessToken } });`    `return;`    `});`    `}`    The
    `**getAccessTokenFromRefreshToken**` function handles the generation of a new
    access token using a valid refresh token. It retrieves the refresh token from
    the request body. It uses the `**jwt.verify**` function to verify the refresh
    token. If the refresh token is invalid or has expired, an error will be caught
    in the `**err**` parameter. If the refresh token is invalid, it sends a 403 error
    response indicating an invalid refresh token. If the refresh token is valid, it
    uses the user information decoded from the refresh token to generate a new access
    token using the same `**jwt.sign**` function. The new access token is signed with
    the same secret key and has a shorter expiration time. It sends a success response
    (status `**200**`) containing the newly generated access token.    These two functions
    are called from routes for HTTP requests, so let''s add two routes in the `**users_router.ts**`
    file as follows:    `// users_router.ts`    `app.route(''/api/login'')`    `.post(controller.login);`    `app.route(''/api/refresh_token'')`    `.post(controller.getAccessTokenFromRefreshToken);`    **Sign
    In API**    **REST API Login**    **Request**    `URL: http://127.0.0.1:`    `Method:
    POST`    `body :`    `{`    `"email":"admin@pms.com",`    `"password":"Admin@pms1"`    `}`    **Response**    `{`    `"statusCode":
    200,`    `"status": "success",`    `"data": {`    `"accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJ1c2VybmFtZSI6InlhbWluaSIsInR5cCI6IkJlYXJlciIsImlhdCI6MTY5MjY0MjgwNywiZXhwIjoxNjkyNjcxNjA3fQ.LzYu6ZZT501MvRbuiZGNCv-kMD9UdWMG_iNYCuI3ta4",`    `"refreshToken":
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJ1c2VybmFtZSI6InlhbWluaSIsInR5cCI6IlJlZnJlc2giLCJpYXQiOjE2OTI2NDI4MDcsImV4cCI6MTY5NTY2NjgwN30.bbbVs_7AUTpwqDxOhyx66A59uV-CIrkPvEdJsDWD-OM"`    `}`    `}`    In
    case of a wrong email ID passed in a request, the server will respond with the
    following error message:    `{`    `"statusCode": 404,`    `"status": "error",`    `"message":
    "Email not found"`    `}`    Similarly, if a wrong password is sent in the request,
    then it will result in a `**400 error**` code, as follows:    `{`    `"statusCode":
    400,`    `"status": "error",`    `"message": "Password is not valid"`    `}`    In
    this manner, users can effortlessly and securely log into the application.    #
    [Authorization](toc.xhtml#s162a)    Authorization is the process of determining
    whether a user or entity has the right permissions to access certain resources
    or perform specific actions within an application. It is a critical component
    of security that ensures that users can only access the data and functionality
    they are allowed to while protecting sensitive information and preventing unauthorized
    actions.    We are going to create a middleware function responsible for authorizing
    whether the JWT token is valid or not. If it is valid, then only pass it to the
    next function or the actual API; otherwise, we will restrict and give an error
    as 401 unauthorized.    Create `**custom.d.ts**` file in the `**src**` directory
    with the following code:    `// custom.d.ts`    `declare namespace Express {`    `interface
    Request {`    `user?: {`    `username?: string;`    `email?: string;`    `rights?:
    string[];`    `user_id?: string;`    `};`    `// Add any other custom properties
    you need`    `}`    `}`    In this part of the code, a `**TypeScript**` namespace
    declaration is used to extend the Request interface provided by the `**Express.js**`
    framework. It adds a custom property called user to the Request object. This user
    property is an optional object that can contain properties such as username, email,
    and rights. The comment suggests that you can add any other custom properties
    you might need here.    Now, let''s make `**UsersUtils**` in the `**users_controller.ts**`
    file with the following code:    `// users_controller.ts`    `export class UsersUtil
    {`    `public static async getUserFromUsername(username: string) {`    `try {`    `if
    (username) {`    `const service = new UsersService();`    ``const users = await
    service.customQuery(`username = ''${username}''`);``    `if (users && users.length
    > 0) {`    `return users[0];`    `}`    `}`    `} catch (error) {`    ``console.error(`Error
    while getUserFromToken() => ${error.message}`);``    `}`    `return null;`    `}`    `}`    The
    `**getUserFromUsername**` function accepts a username as its input parameter and
    retrieves the corresponding user from the database. If the provided username does
    not have a match in the database, the function returns a null response.    After
    that, add one method in `**RolesUtil**` to get rights from roles:    `public static
    async getAllRightsFromRoles(role_ids: string[]):`    `Promise<string[]> {`    `//
    Create an instance of RolesService to interact with the roles`    `const roleService
    = new RolesService();`    `// Initialize an array to store the collected rights`    `let
    rights: string[] = [];`    `// Query the database to validate the provided role_ids`    `const
    queryData = await roleService.findByIds(role_ids);`    `const roles: Roles[] =
    queryData.data ? queryData.data : [];`    `// Extract rights from each role and
    add them to the rights array`    `roles.forEach((role) => {`    `const rightFromRole:
    string[] = role.rights.split('','');`    `rights = […new Set(rights.concat(rightFromRole))];`    `});`    `//
    Return the accumulated rights`    `return rights;`    `}`    The `**getAllRightsFromRoles**`
    is designed to retrieve and consolidate rights associated with a collection of
    role IDs. The function queries the database using the provided role IDs to fetch
    corresponding role data. For each retrieved role, the associated rights are extracted
    by splitting the rights string. These rights are then added to the rights array
    while avoiding duplicates using a set-based approach. Finally, the function returns
    an array containing the accumulated and unique rights gathered from all the roles.    Let''s
    create `**auth_util.ts**` in the utils directory using the following code:    `[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/auth_util.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/auth_util.ts)`    The
    `**authorize**` middleware function is responsible for verifying the authorization
    token, decoding it, and attaching user-related information to the `**req.user**`
    object. It first checks if the authorization token exists in the request headers.
    If not, it returns a 401 Unauthorized response indicating a missing token. The
    token is split to extract the actual token value after the “Bearer” prefix. The
    token is then verified using the provided JWT secret. If the token is successfully
    decoded, it extracts the username and email from the decoded token and assigns
    them to `**req.user.username**` and `**req.user.email**`, respectively. If a valid
    username exists, it fetches the user''s information and assigned it to `**req.user**`.
    Finally, if everything is successful, the middleware proceeds to the next middleware
    using the `**next()**` function.    The `**hasPermission**` function takes an
    array of user rights and a desired right as parameters. It checks if the array
    of user rights includes the desired right. If the desired right is found in the
    user rights, the function returns true; otherwise, it returns false.    We created
    raw functions of authorization, and now change call the `**authorize**` function
    in the routes file for each API, as follows:    `// users_routes.ts`    `export
    class UserRoutes {`    `private baseEndPoint = ''/api/users'';`    `constructor(app:
    Express) {`    `const controller = new UserController();`    `app.route(this.baseEndPoint)`    `.all(authorize)
    // Apply authorization middleware to all routes under this endpoint`    `.get(controller.getAllHandler)`    `.post(validate(validUserInput),
    controller.addHandler);`    `app.route(this.baseEndPoint + ''/:id'')`    `.all(authorize)
    // Apply authorization middleware to all routes under this endpoint`    `.get(controller.getOneHandler)`    `.put(controller.updateHandler)`    `.delete(controller.deleteHandler);`    `app.route(''/api/login'')`    `.post(controller.login);`    `app.route(''/api/refresh_token'')`    `.post(controller.getAccessTokenFromRefreshToken);`    `}`    `}`    Authorization
    is not required for the login and refresh token API since it falls under the category
    of authentication APIs:    `// roles_routes.ts`    `export class RoleRoutes {`    `private
    baseEndPoint = ''/api/roles'';`    `constructor(app: Express) {`    `const controller
    = new RoleController();`    `app.route(this.baseEndPoint)`    `.all(authorize)`    `.post(validate(validRoleInput),
    controller.addHandler)`    `.get(controller.getAllHandler);`    `app.route(this.baseEndPoint
    + ''/:id'')`    `.all(authorize)`    `.get(controller.getOneHandler)`    `.put(validate(validRoleInput),
    controller.updateHandler)`    `.delete(controller.deleteHandler);`   [PRE5] `}`    `}`    From
    now onwards, make sure, except for the login and refresh token APIs, you have
    to pass the access token with bearer type in the header as Authorization in the
    request; otherwise, it gives an error:    `{`    `"statusCode": 401,`    `"status":
    "error",`    `"message": "Missing Authorization Token"`    `}`    Checking for
    valid rights of permission is also a part of Authorization. We have already created
    a `**hasPermission**` method that will be the first call in each API controller
    with respective rights.    In the User Controller, add the following checks with
    their respective methods:    `// addHandler`    `public async addHandler(req:
    Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''add_user'')) {`    `res.status(403).json({ statusCode: 403, status: ''error'',`    `message:
    ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `// getAllHandler`    `public
    async getAllHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_all_users'')) {`    `res.status(403).json({ statusCode: 403, status: ''error'',`    `message:
    ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `// getOneHandler`    `public
    async getOneHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_details_user'')) {`    `res.status(403).json({ statusCode: 403, status:
    ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `//
    updateHandler`    `public async updateHandler(req: Request, res: Response): Promise<void>
    {`    `if (!hasPermission(req.user.rights, ''edit_user'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `//
    deleteHandler`    `public async deleteHandler(req: Request, res: Response): Promise<void>
    {`    `if (!hasPermission(req.user.rights, ''delete_user'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    Similarly,
    add in the Role controller to check permission for roles API:    `// addHandler`    `public
    async addHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''add_role'')) {`    `res.status(403).json({ statusCode: 403, status: ''error'',`    `message:
    ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `// getAllHandler`    `public
    async getAllHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_all_roles'')) {`    `res.status(403).json({ statusCode: 403, status: ''error'',`    `message:
    ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `// getOneHandler`    `public
    async getOneHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_details_role'')) {`    `res.status(403).json({ statusCode: 403, status:
    ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `//
    updateHandler`    `public async updateHandler(req: Request, res: Response): Promise<void>
    {`    `if (!hasPermission(req.user.rights, ''edit_role'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    `//
    deleteHandler`    `public async deleteHandler(req: Request, res: Response): Promise<void>
    {`    `if (!hasPermission(req.user.rights, ''delete_role'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'',`    `message: ''Unauthorised'' });`    `return;`    `}`    `…`    `}`    This
    is how middleware functions for authorization and permissions work in an `**Express.js**`
    application. It extends the Request interface to include a user object with properties
    such as username, email, and rights. The `**authorize**` middleware verifies JSON
    Web Tokens (JWTs) from the request header, extracts user information, and checks
    permissions. The `**hasPermission**` function checks if a user''s rights include
    the desired permission. Moving forward, except for the login and refresh token
    APIs, the access token should be passed in the header as a bearer type using the
    **Authorization** field.    # [GetAll Users](toc.xhtml#s163a)    After successfully
    onboarding users, we can proceed to retrieve the newly inserted users from the
    database. So, update the `**getAllHandler**` method in the `**users_controller.ts**`
    file using the following code:    `public async getAllHandler(req: Request, res:
    Response): Promise<void> {`    `if (!hasPermission(req.user.rights, ''get_all_users''))
    {`    `res.status(403).json({ statusCode: 403, status: ''error'', message: ''Unauthorised''
    });`    `return;`    `}`    `const service = new UsersService();`    `const result
    = await service.findAll(req.query);`    `if (result.statusCode === 200) {`    `//
    Remove password field to send in response`    `result.data.forEach(i => delete
    i.password);`    `}`    `res.status(result.statusCode).json(result);`    `return;`    `}`    The
    `**getAllHandler**` method uses the `**UsersService**` class to retrieve all users
    from the database based on the query parameters in the request. The resulting
    data is then sent back to the client with an appropriate HTTP status code and
    formatted as JSON.    This controller method call in routes with a change in `**roles_routes.ts**`
    as follows:    `app.route(this.baseEndPoint)`    `.all(authorize) // Apply authorization
    middleware to all routes under this endpoint`    `.get(controller.getAllHandler)`    `.post(validate(validUserInput),
    controller.addHandler);`    By employing this approach, we establish a GET route
    that fetches all roles stored in the database, effectively functioning as a REST
    API endpoint for retrieving role data.    **REST API GetAll Roles**    **Request**    `URL:
    http://127.0.0.1:3000/api/users`    `Method: GET`    `Query Params: {}`    **Response**    `{`    `"statusCode":
    200,`    `"status": "success",`    `"data": [`    `{`    `"user_id": "b930d02c-43af-4875-b7e9-546c9f4c23dd",`    `"fullname":
    "Super Admin",`    `"username": "pms-admin",`    `"email": "admin@pms.com",`    `"role_ids":
    [`    `"dbda47e4-f843-4263-a4d6-69ef80156f81"`    `],`    `"created_at": "2023-08-22T17:08:24.722Z",`    `"updated_at":
    "2023-08-22T17:08:24.722Z"`    `}, {`    `"user_id": "d166945a-f85d-485c-bdac-0c8056b3188a",`    `"fullname":
    "Yami Panchal",`    `"username": "yamini",`    `"email": "yami@gmail.com",`    `"role_ids":
    [`    `"b88cc70d-ab0a-4464-9562-f6320df519f6"`    `],`    `"created_at": "2023-08-18T17:57:38.744Z",`    `"updated_at":
    "2023-08-24T16:57:19.110Z"`    `}`    `]`    `}`    If you want to filter or search
    by exact name, you can change query params as follows:    `URL: http://127.0.0.1:3000/api/users?username=pms-admin`    It
    gives only matched data as a response, as follows    `{`    `"statusCode": 200,`    `"status":
    "success",`    `"data": [`    `{`    `"user_id": "b930d02c-43af-4875-b7e9-546c9f4c23dd",`    `"fullname":
    "Super Admin",`    `"username": "pms-admin",`    `"email": "admin@pms.com",`    `"role_ids":
    [`    `"dbda47e4-f843-4263-a4d6-69ef80156f81"`    `],`    `"created_at": "2023-08-22T17:08:24.722Z",`    `"updated_at":
    "2023-08-22T17:08:24.722Z"`    `}`    `]`    `}`    # [GetOne User](toc.xhtml#s164a)    This
    endpoint offers a valuable function by providing specific user information. It
    serves as a crucial tool for users to access their own details and also enables
    administrators to retrieve specific user information whenever necessary.    To
    implement the `**GetOne**` User API, make the following changes in the `**getOneHandler**`
    code in the user controller:    `// users_controller.ts`    `public async getOneHandler(req:
    Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights,
    ''get_details_user'')) {`    `res.status(403).json({ statusCode: 403, status:
    ''error'', message: ''Unauthorised'' });`    `return;`    `}`    `const service
    = new UsersService();`    `const result = await service.findOne(req.params.id);`    `if
    (result.statusCode === 200) {`    `delete result.data.password;`    `}`    `res.status(result.statusCode).json(result);`    `return;`    `}`    The
    `**getOneHandler**` function serves as the bridge between the incoming client
    request, the service layer that interacts with the database, and the outgoing
    HTTP response. It retrieves a single user''s details from the database based on
    the provided user ID and sends the user information back to the client, except
    password data for security reasons.    This method is called from the routes file
    by creating a new route for it as follows:    `app.route(this.baseEndPoint + ''/:id'')`    `.all(authorize)
    // Apply authorization middleware to all routes under this endpoint`    `.get(controller.getOneHandler)`    Here**,**
    `**/:id**` will be a request parameter meant to capture the ID of the user that
    wants to retrieve.    **REST API GetOne Role**    **Request**    `URL: http://127.0.0.1:5000/api/users/b930d02c-43af-4875-b7e9-546c9f4c23dd`    `Method:
    GET`    **Response**    `{`    `"statusCode": 200,`    `"status": "success",`    `"data":
    {`    `"user_id": "b930d02c-43af-4875-b7e9-546c9f4c23dd",`    `"fullname": "Super
    Admin",`    `"username": "pms-admin",`    `"email": "admin@pms.com",`    `"role_ids":
    [`    `"dbda47e4-f843-4263-a4d6-69ef80156f81"`    `],`    `"created_at": "2023-08-22T17:08:24.722Z",`    `"updated_at":
    "2023-08-22T17:08:24.722Z"`    `}`    `}`    Providing a valid role ID will yield
    a successful response, while inputting an ID that doesn''t correspond to an existing
    database entry will result in a `**404**` `**error**`, signifying that the requested
    entity was `**Not found**`.    `{`    `"statusCode": 404,`    `"status": "error",`    `"message":
    "Not Found"`    `}`    # [Update User](toc.xhtml#s165a)    In updating user information,
    it''s important to note that the username and email fields won''t be modified.
    These fields are unique identifiers and will retain their initial values as set
    during creation. Additionally, to change the password, a separate API will be
    implemented specifically for that purpose, known as the `**change password**`
    API.    Let''s develop `**updateHandler**` in the `**users_controller.ts**` using
    the following code:    `public async updateHandler(req: Request, res: Response):
    Promise<void> {`    `if (!hasPermission(req.user.rights, ''edit_user'')) {`    `res.status(403).json({
    statusCode: 403, status: ''error'', message: ''Unauthorised'' });`    `return;`    `}`    `const
    service = new UsersService();`    `const user = req.body;`    `// we will not
    update email and username once inserted so remove it from body`    `delete user?.email;`    `delete
    user?.username;`    `// we will also not update password from here it will be
    from changePassword function separate`    `delete user?.password;`   [PRE6]`js
    [PRE7]js`` [PRE8]js[PRE9]````'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0][PRE1]``js[PRE2]`` `{`    `"statusCode": 200,`    `"status": "success",`    `"data":
    [`    `{`    `"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",`    `"name":
    "visitor",`    `"description": null,`    `"rights": null,`    `"created_at": "2023-08-15T13:04:50.314Z",`    `"updated_at":
    "2023-08-15T13:04:50.314Z"`    `}`    `]`    `}`    **注意**：在基础服务中，查询参数现在将仅适用于精确匹配。我们将在稍后探索搜索功能。    #
    [获取单个角色](toc.xhtml#s151a)    获取单个角色端点是角色管理系统的一个基本部分，允许用户查看特定角色的信息，而无需检索所有角色的完整列表。这对于提供针对每个角色属性和权限的针对性见解至关重要。要实现获取单个角色API，请在角色控制器中的`**getOneHandler**`代码中进行以下更改：    `//
    roles_controller.ts`    `public async getOneHandler(req: Request, res: Response):
    Promise<void> {`    `const service = new RolesService();`    `const result = await
    service.findOne(req.params.id);`    `res.status(result.statusCode).json(result);`    `}`    `**getOneHandler**`函数作为传入客户端请求、与数据库交互的服务层和传出HTTP响应之间的桥梁。它根据提供的角色ID从数据库中检索单个角色的详细信息，并将角色信息发送回客户端。    该方法通过在路由文件中创建一个新的路由来从路由文件中调用：    `//
    roles_routes.ts`    `app.route(this.baseEndPoint + ''/:id'')`    `.get(controller.getOneHandler);`    这里****，`**/:id**`将是一个请求参数，用于捕获用户想要检索的角色ID。    **REST
    API 获取单个角色**    **请求**    `URL: http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238`    `方法：GET`    **响应**    `{`    `"statusCode":
    200,`    `"status": "success",`    `"data": {`    `"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",`    `"name":
    "visitor",`    `"description": null,`    `"rights": null,`    `"created_at": "2023-08-15T13:04:50.314Z",`    `"updated_at":
    "2023-08-15T13:04:50.314Z"`    `}`    `}`    提供有效的角色ID将产生成功响应，而输入一个与现有数据库条目不对应的ID将导致`**404错误**`，表示请求的实体未找到。    `{`    `"statusCode":
    404,`    `"status": "error",`    `"message": "Not Found"`    `}`    # [更新角色](toc.xhtml#s152a)    更新角色涉及修改存储在数据库中的特定角色的现有数据。此过程允许您调整角色的属性，例如其名称、描述和关联的权限。通过执行更新，您可以确保角色的信息保持准确和最新。当角色的权限发生变化时，此操作特别有用，您需要将这些更改反映在数据库中。    要实现更新角色API，请在角色控制器中的`**updateHandler**`代码中进行以下更改：    `//
    roles_controller.ts`    `public async updateHandler(req: Request, res: Response)
    : Promise<void> {`    `const role = req.body;`    `const service = new RolesService();`    `const
    result = await service.update(req.params.id, role);`    `res.status(result.statusCode).json(result);`    `}`    `**updateHandler**`函数旨在处理数据库中角色的更新。    它通过从传入的HTTP请求体中检索数据来操作，然后利用这些数据根据请求参数ID（即角色的唯一标识符`**role_id**`）更新数据库中的相应角色数据。该函数随后生成一个响应，指示更新操作是成功还是失败，如果需要，提供有关更新数据或适当的错误消息。    该方法通过在路由文件中创建一个新的路由来从路由文件中调用：    `//
    roles_routes.ts`    `app.route(this.baseEndPoint + ''/:id'')`    `.'
