- en: Chapter 9. Deploying to Production
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。部署到生产环境
- en: 'You have built a great project: it is modularized, has tests, has been automatized
    to do common tasks, and finally you have built a production version with Gulp;
    however, now how do you deploy to a production server?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经构建了一个伟大的项目：它模块化，有测试，已经自动化以执行常见任务，最后你使用 Gulp 构建了一个生产版本；然而，现在你如何将项目部署到生产服务器？
- en: This chapter examines what to do with the production version of your project.
    Here, you will see how to run your node server and frontend assets in a production
    environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨如何处理你项目的生产版本。在这里，你将看到如何在生产环境中运行你的节点服务器和前端资源。
- en: There are many choices to run your project in production mode; you can deploy
    on a bare metal server, use a virtual machine, on a shared host such as DigitalOcean
    or RackSpace, or maybe just deploy it to a **PaaS** (**Platform as a service**)
    service such as Heroku.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产模式下运行你的项目有许多选择；你可以在裸金属服务器上部署，使用虚拟机，在 DigitalOcean 或 RackSpace 等共享主机上，或者也许只是将其部署到
    **PaaS**（**平台即服务**）服务，如 Heroku。
- en: In the following section, we will see how to deploy to an Heroku instance, this
    is the easiest way to make a deployment as you don't have to worry about the server
    details and you can manage all the configurations in a single configuration file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何部署到 Heroku 实例，这是部署的最简单方法，因为你不必担心服务器细节，你可以在单个配置文件中管理所有配置。
- en: If you already have your own infrastructure or simply prefer to work with server
    instances such as DigitalOcean or RackSpace virtual server, we will show you how
    to configure a production environment on a server, where you have access to a
    shell.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了自己的基础设施，或者只是喜欢与 DigitalOcean 或 RackSpace 虚拟服务器等服务器实例一起工作，我们将向你展示如何在服务器上配置生产环境，在那里你可以访问
    shell。
- en: Heroku
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Heroku
- en: Heroku is a PaaS, which means that you don't have to worry about the details
    of the server configuration where you are deploying your code, you only focus
    on your code; Heroku will do the difficult job with the infrastructure configuration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 是一个 PaaS，这意味着你不必担心你部署代码的服务器配置细节，你只需关注你的代码；Heroku 将完成基础设施配置的困难工作。
- en: Instead of using a shell to install, configure, and tune up your packages in
    order to run in production mode, you only have to edit a configuration file and
    publish your changes with the standard `git push` command.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 shell 安装、配置和调整你的包以在生产模式下运行相比，你只需要编辑一个配置文件，然后使用标准的 `git push` 命令发布你的更改。
- en: Dynos
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dynos
- en: Heroku uses lightweight Linux containers that run a single command in order
    to run your projects in the Heroku platform. Heroku calls these containers Dynos.
    A Dyno can host your code and run it as a single process in an isolated Linux
    environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 使用轻量级的 Linux 容器来运行你的项目在 Heroku 平台上。Heroku 将这些容器称为 Dynos。一个 Dyno 可以托管你的代码，并在隔离的
    Linux 环境中以单个进程运行它。
- en: 'If you don''t have an experience in Linux containers such as Docker, you can
    imagine a container to be like a small virtual machine without hardware emulation;
    a Linux container uses the same kernel as the host machine, it means that you
    don''t need to emulate hardware:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 Linux 容器（如 Docker）的经验，你可以想象一个容器就像一个没有硬件仿真的小虚拟机；Linux 容器使用与主机机器相同的内核，这意味着你不需要仿真硬件：
- en: '![Dynos](img/B01962_09_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Dynos](img/B01962_09_01.jpg)'
- en: Figure 9.1 Difference between virtualization and containers
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 虚拟化和容器之间的区别
- en: 'By default, Heroku will use Celadon Cedar stack to build Dynos; and Celadon
    Cedar stack is based on the Ubuntu distribution. With this is mind, you will get
    an Ubuntu-like distribution, where you can run your code written on:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Heroku 将使用 Celadon Cedar 栈来构建 Dynos；Celadon Cedar 栈基于 Ubuntu 发行版。考虑到这一点，你将获得一个类似
    Ubuntu 的发行版，你可以在其中运行你用以下语言编写的代码：
- en: Ruby on Rails
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby on Rails
- en: Node.js
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js
- en: Java or Spring
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 或 Spring
- en: Python or Django
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 或 Django
- en: Clojure
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure
- en: Scala or Play
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala 或 Play
- en: PHP
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Go
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: 'Dyno comes in three different types, as shown in the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Dyno 有三种不同的类型，如下所示：
- en: '**Web Dynos**: They are used to run the server code and respond to HTTP requests.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web Dynos**：它们用于运行服务器代码并响应 HTTP 请求。'
- en: '**Worker Dynos**: They are useful for background jobs such as image processor.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作 Dynos**：它们对于后台作业，如图像处理器非常有用。'
- en: '**One-off Dynos**: Their purpose is to provide maintenance to the other two
    Dyno types.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性 Dynos**：它们的作用是为其他两种 Dyno 类型提供维护。'
- en: As you may have guessed that in this book, we will only use the Web Dynos with
    Node.js to run our `Contacts app`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，在这本书中，我们只会使用 Node.js 的 Web Dynos 来运行我们的 `Contacts app`。
- en: Getting started with Heroku
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Heroku
- en: 'The first thing to do in order to start working with Heroku is to register
    with the service, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用 Heroku，首先要做的事情是注册该服务，具体步骤如下：
- en: '![Getting started with Heroku](img/B01962_09_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Heroku](img/B01962_09_02.jpg)'
- en: Figure 9.2 Heroku registration form
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 Heroku 注册表单
- en: 'Once you are registered in the platform, you will need to install the Heroku
    Toolbelt in your host; there are versions available for Linux, Mac OS X, and Windows.
    After the installation process, you can use the `heroku` command to authenticate
    the service:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在平台上注册，您需要在您的宿主机上安装 Heroku Toolbelt；有适用于 Linux、Mac OS X 和 Windows 的版本。安装过程完成后，您可以使用
    `heroku` 命令对服务进行身份验证：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you have authenticated with the Heroku service, you can start creating
    Dynos using the create command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在您通过 Heroku 服务进行身份验证后，您可以使用 create 命令开始创建 Dynos：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you create a new Dyno on Heroku, it generates a random name for your Dyno.
    In the preceding example, the name is `enigmatic-anchorage-3587` and you can access
    to your Dyno at [https://enigmatic-anchorage-3587.herokuapp.com](https://enigmatic-anchorage-3587.herokuapp.com):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Heroku 上创建一个新的 Dyno 时，它会为您的 Dyno 生成一个随机名称。在前面的示例中，名称是 `enigmatic-anchorage-3587`，您可以通过
    [https://enigmatic-anchorage-3587.herokuapp.com](https://enigmatic-anchorage-3587.herokuapp.com)
    访问您的 Dyno：
- en: '![Getting started with Heroku](img/B01962_09_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Heroku](img/B01962_09_03.jpg)'
- en: Figure 9.3 Dyno default output
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 Dyno 默认输出
- en: 'You can deploy your application by pushing your changes to the Git server located
    at [https://git.heroku.com/enigmatic-anchorage-3587.git](https://git.heroku.com/enigmatic-anchorage-3587.git).
    You will need to add this address as a remote server in your repo:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将更改推送到位于 [https://git.heroku.com/enigmatic-anchorage-3587.git](https://git.heroku.com/enigmatic-anchorage-3587.git)
    的 Git 服务器来部署您的应用程序。您需要将此地址添加为您的仓库中的远程服务器：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you make a push right now, the deployment will not work and that''s because
    you need to tell Heroku how to run your project; this is done with a configuration
    file named `Procfile` that you should put in the application root:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在进行推送，部署将不会工作，这是因为您需要告诉 Heroku 如何运行您的项目；这是通过一个名为 `Procfile` 的配置文件完成的，您应该将其放在应用程序根目录中：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code is very simple, run the `server/index.js` script. You can test whether
    the configuration is working with the `local` command; this command is very useful
    in order to find bugs or issues before making a real deployment:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单，运行 `server/index.js` 脚本。您可以使用 `local` 命令测试配置是否正常工作；此命令在真正部署之前查找错误或问题非常有用：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the output logs, you can see what Heroku is doing:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出日志中，您可以看到 Heroku 正在做什么：
- en: Heroku detects what kind of project it is in order to know how to build the
    right environment. It could detect that it is a `Node` project due the presence
    of the `package.json` file.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku 会检测项目的类型，以便知道如何构建正确的环境。它可能会检测到这是一个 `Node` 项目，因为存在 `package.json` 文件。
- en: Knowing that it is a Node project, it could set some useful environment variables
    in order to run the project in production mode. You can use the `NODE_ENV` environment
    variable in your code in order to use some special configuration for production
    environments.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道这是一个 Node 项目后，它可以为运行生产模式下的项目设置一些有用的环境变量。您可以在代码中使用 `NODE_ENV` 环境变量来使用针对生产环境的特殊配置。
- en: 'Then, read the `package.json` file to see what version of node to install.
    You can specify a node version to install with the engines configuration, as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，阅读 `package.json` 文件以查看要安装的节点版本。您可以使用 engines 配置指定要安装的节点版本，如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the right node version is installed in the Dyno, Heroku will install the
    project dependencies that are specified in the `package.json` file.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Dyno 中安装正确的节点版本后，Heroku 将安装 `package.json` 文件中指定的项目依赖项。
- en: Then, it will look up for the configuration for the kind of Dyno that is launched
    and see how to run the project at `Procfile`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它将查找启动的 Dyno 类型的配置，并查看如何在 `Procfile` 中运行项目。
- en: Finally, it will compress the build and launche the project.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它将压缩构建并启动项目。
- en: 'Once the project is running in the Heroku infrastructure, you can see the result
    at [https://enigmatic-anchorage-3587.herokuapp.com/](https://enigmatic-anchorage-3587.herokuapp.com/):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目在 Heroku 基础设施中运行，您可以在 [https://enigmatic-anchorage-3587.herokuapp.com/](https://enigmatic-anchorage-3587.herokuapp.com/)
    上看到结果：
- en: '![Getting started with Heroku](img/B01962_09_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Heroku](img/B01962_09_04.jpg)'
- en: Figure 9.4 Application deployed on Heroku
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 在 Heroku 上部署的应用程序
- en: As you can see, deploying to Heroku infrastructure is very straightforward,
    you don't have to worry about the server details such as the HTTP server or the
    process management so that you can focus on your application development and forget
    about the infrastructure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，部署到Heroku基础设施非常简单，你不必担心服务器细节，如HTTP服务器或进程管理，这样你可以专注于应用程序开发，而无需担心基础设施。
- en: 'If you have any issues with your application in production, you can see what''s
    happening with the `logs` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在生产中的应用程序遇到任何问题，你可以使用`logs`命令查看发生了什么：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will show the last log messages in the Heroku server. Please consult the
    online documentation of the service for more details; here you can find information
    about how to scale your application, connect Dyno instances to databases, and
    so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示Heroku服务器上的最后一条日志消息。请查阅服务的在线文档以获取更多详细信息；在这里你可以找到有关如何扩展你的应用程序、将Dyno实例连接到数据库等信息。
- en: Production environment
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境
- en: If you have a bare metal server or want to work with virtual servers, such as
    DigitalOcean or Rackspace, you can create your own production environment. In
    this section, you will see how to make it possible.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一台裸金属服务器或者想要使用虚拟服务器，例如DigitalOcean或Rackspace，你可以创建自己的生产环境。在本节中，你将了解如何实现这一点。
- en: It doesn't matter what the case is as the way you configure a production environment
    on these kind of servers are the same. However, keep in mind that the production
    environment that you will see here is for simple web applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 无论情况如何，因为你在这类服务器上配置生产环境的方式都是相同的。然而，请记住，这里展示的生产环境是为简单的Web应用程序设计的。
- en: If you have an application with high traffic, you can start from here; however,
    the server architecture should have a sophisticated organization. The details
    on how to scale your deployments are out of the scope of this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个高流量的应用程序，你可以从这里开始；然而，服务器架构应该有复杂的组织。关于如何扩展你的部署的详细信息超出了本书的范围。
- en: For the server, I will use the Ubuntu server as it is the easiest and the most
    popular choice to deploy application. If you are familiar with other distributions
    such as CentOS, you can use it; however, the instructions are not the same.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器，我将使用Ubuntu服务器，因为它是最简单且最受欢迎的应用程序部署选择。如果你熟悉其他发行版，如CentOS，你也可以使用它；然而，说明并不相同。
- en: 'The following diagram shows you a typical configuration for a **Node** server
    in the production environment:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了生产环境中**Node**服务器的典型配置：
- en: '![Production environment](img/B01962_09_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![生产环境](img/B01962_09_05.jpg)'
- en: Figure 9.5 Deployment diagram
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 部署图
- en: As Node was not built to be a full-featured and robust web server, you should
    put an HTTP server in front to answer the client requests instead of using Node
    directly. The HTTP server will forward the request to the Node process and return
    the response from the Node server to the user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node不是构建为功能齐全且健壮的Web服务器，你应该在Node之前放置一个HTTP服务器来响应用户请求，而不是直接使用Node。HTTP服务器将请求转发到Node进程，并将Node服务器的响应返回给用户。
- en: In the preceding diagram, you can see that we are using a **Process Manager**,
    its work is to keep the Node process up and alive; if the Node process crashes
    for some reason, **PM2** will take care of it and restart the process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到我们正在使用一个**进程管理器**，其工作是将Node进程保持运行状态；如果Node进程由于某种原因崩溃，**PM2**将负责处理并重启进程。
- en: Also, you can monitor the memory and processor that your application is consuming
    in real time, manually restart and stop processes, check logs, and so on. Finally,
    the access to the database is made from the **Node** server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以实时监控应用程序消耗的内存和处理器，手动重启和停止进程，检查日志等。最后，数据库的访问是从**Node**服务器进行的。
- en: 'When a user makes a request from its browser, the server will process the request
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从其浏览器发起请求时，服务器将按以下方式处理请求：
- en: The client sends a request to the server host
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端向服务器主机发送请求
- en: An HTTP server takes the request
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器接收请求
- en: The HTTP server forwards the request to the Node server
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器将请求转发到Node服务器
- en: The Node process makes its internal process of the request
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node进程处理其内部请求过程
- en: The Node process returns an answer to the HTTP server
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node进程向HTTP服务器返回答案
- en: The HTTP server forwards the answer to the client
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器将答案转发给客户端
- en: The client receives the request
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端接收请求
- en: In the following sections, we will explore how to install and configure all
    the components in order to have a Node application running. We will use an **Ubuntu-14.04**
    box to perform the installation process. If you have a different environment,
    the configuration content should still work; however, the instructions to install
    and the location of the configuration files may be different.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何安装和配置所有组件，以便运行Node应用程序。我们将使用**Ubuntu-14.04**虚拟机来执行安装过程。如果您有不同的环境，配置内容应该仍然有效；然而，安装说明和配置文件的存放位置可能会有所不同。
- en: The HTTP Server
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP服务器
- en: 'The HTTP server handles the connections with the client and forwards all the
    requests to the Node server. In some way, it is a kind of proxy. Currently, there
    are two main HTTP servers on the market that were used widely in production: Apache
    and Nginx, both can be used to server Node applications. However, in this book,
    we will cover Nginx. The main reason for this decision is its simplicity and performance
    and it is smaller than Apache.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器处理与客户端的连接，并将所有请求转发到Node服务器。在某种程度上，它是一种代理。目前，市场上主要有两个广泛用于生产的HTTP服务器：Apache和Nginx，两者都可以用于托管Node应用程序。然而，在这本书中，我们将介绍Nginx。做出这个决定的主要原因是它的简单性和性能，并且它比Apache小。
- en: 'To install Nginx, use `apt-get`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Nginx，请使用`apt-get`：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After the Nginx server is installed, Ubuntu will start the server automatically;
    however, you can manage the server daemon with the service command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nginx服务器安装后，Ubuntu将自动启动服务器；然而，您可以使用服务命令管理服务器守护进程：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can check whether the server is running by pointing your browser to the
    server IP, as shown in the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将浏览器指向服务器IP来检查服务器是否正在运行，如下面的截图所示：
- en: '![The HTTP Server](img/B01962_09_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![The HTTP Server](img/B01962_09_06.jpg)'
- en: Figure 9.6 Nginx fresh installation
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 Nginx全新安装
- en: 'The Nginx configuration files are located at `/etc/nginx`, in this path are
    two more paths, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx配置文件位于`/etc/nginx`，在这个路径中还有两个子路径，如下所示：
- en: '**sites-available**: Each file is a configuration of a single host (subdomain).
    Note that these files are not active until they are not in sites-enabled.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sites-available**：每个文件都是一个单一主机的配置（子域名）。请注意，这些文件在未放入sites-enabled之前不是活动的。'
- en: '**sites-enabled**: While the sites-available has a set of configuration files,
    the sites-enabled are a set of sites that are actually active.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sites-enabled**：虽然sites-available包含一组配置文件，但sites-enabled是一组实际激活的网站。'
- en: 'To create a new site, you need to create a new configuration file in the sites-available
    path:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的网站，您需要在sites-available路径中创建一个新的配置文件：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The configuration content is shown in the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 配置内容如下所示：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The upstream module of Nginx defines a server or a group of servers that can
    be referenced as `proxy_pass`, what it means is that the target to hit when a
    request is incoming at Nginx. Server configuration creates a new virtual host
    listening for requests to the `server_name` address. In this case, it is listening
    for `www.example.com`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx的上游模块定义了一个或一组服务器，这些服务器可以通过`proxy_pass`进行引用，这意味着当请求到达Nginx时需要击中的目标。服务器配置创建了一个新的虚拟主机，监听对`server_name`地址的请求。在这种情况下，它正在监听`www.example.com`。
- en: 'In the `location` block, it describes how to handle the requests; in the previous
    example, it will forward the request to the `webapp` upstream, which points to
    `127.0.0.1:8000`. To activate the site, you need to link the contents of this
    file to the `sites-enabled` path:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`location`块中，它描述了如何处理请求；在先前的示例中，它将请求转发到指向`127.0.0.1:8000`的`webapp`上游。要激活网站，您需要将此文件的
    内容链接到`sites-enabled`路径：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Maybe you will need to delete the previous default-enabled site:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可能您需要删除之前启用的默认网站：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then restart the Nginx server in order to load the new configuration:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新启动Nginx服务器以加载新的配置：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If everything is OK, the server will be up:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，服务器将启动：
- en: '![The HTTP Server](img/B01962_09_07.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![The HTTP Server](img/B01962_09_07.jpg)'
- en: Figure 9.7 Nginx running without node.js working
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 Nginx在没有node.js工作的情况下运行
- en: 'The preceding image shows a `502` error, that''s because the Nginx server is
    pointing to the `proxy_pass` setting that has the `127.0.0.1:8000` address; however,
    nothing is running on that socket. You need to have something listening for requests
    on the `127.0.0.1:8000` socket, therefore, you should run the project in the same
    host and the `502` error will go away:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片显示了一个`502`错误，这是因为Nginx服务器指向了具有`127.0.0.1:8000`地址的`proxy_pass`设置；然而，在那个套接字上没有任何东西在运行。你需要有一个东西在`127.0.0.1:8000`套接字上监听请求，因此，你应该在同一主机上运行项目，这样`502`错误就会消失：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This should be enough to make the server work. However, we don't want to run
    the `app.js` script manually each time, there is a better way to launch the node
    process automatically.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以让服务器工作。然而，我们不想每次都手动运行`app.js`脚本，有一个更好的方法可以自动启动Node进程。
- en: Do not run as root
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要以root身份运行
- en: 'Running the server process as root can be dangerous. If someone discovers a
    vulnerability in node or in your application code, then they can cause serious
    damage to the system. It''s always a good idea to create a user to run the application
    server only:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以root身份运行服务器进程可能很危险。如果有人发现node或你的应用程序代码中的漏洞，那么他们可能会对系统造成严重损害。创建一个仅用于运行应用程序服务器的用户总是一个好主意：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `m` option will create a home path located at `/home/production`, where
    you can clone the project repo:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`m`选项将在`/home/production`位置创建一个家目录，你可以在这里克隆项目仓库：'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Do not run as root](img/B01962_09_07.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![不要以root身份运行](img/B01962_09_07.jpg)'
- en: Figure 9.7 After running node.js process
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 运行node.js进程后
- en: Process Management
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程管理
- en: 'Anytime you run a program in your computer, it can fail for many reasons: maybe
    a server that it depends on is turned off or, even worst, an unhandled exception
    can tear down the running process. That''s terrible for production applications
    as you leave your users without the server until you notice that it is not working.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候你在电脑上运行一个程序，它都可能因为许多原因而失败：可能它所依赖的服务器已经关闭，或者更糟糕的是，一个未处理的异常可能会终止正在运行的进程。这对生产应用来说是非常糟糕的，因为你直到注意到服务器不工作之前，你的用户都没有服务器可用。
- en: This is where the process manager comes in, you can run your code behind a process
    manager and it will ensure that the process is always running. If something fails
    and crashes the program, the process manager will reset the entire application
    automatically.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是进程管理器发挥作用的地方，你可以在进程管理器后面运行你的代码，并且它会确保进程始终在运行。如果出现问题并导致程序崩溃，进程管理器将自动重置整个应用程序。
- en: 'There are two popular process managers for Node: `forever` and `pm2`, both
    work in a similar way; however, `pm2` seems to be more popular and provides more
    utility tools than ever. For this reason, we will use `pm2` for the stack.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node有两个流行的进程管理器：`forever`和`pm2`，它们的工作方式类似；然而，`pm2`似乎更受欢迎，并且提供了比以往更多的实用工具。因此，我们将使用`pm2`作为栈。
- en: Ubuntu comes with an integrated process manager known as Upstart. You can use
    the operative system process manager; however, `pm2` is focused on node applications,
    it allows you to run more than an instance of your process instead of running
    a single process.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu自带一个名为Upstart的集成进程管理器。你可以使用操作系统的进程管理器；然而，`pm2`专注于Node应用，它允许你运行多个进程实例，而不是只运行一个进程。
- en: 'You can install `pm2` with the `npm` tool, do not forget to install it as global
    package:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`npm`工具安装`pm2`，别忘了将其安装为全局包：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the installation is complete, you can run your process behind `pm2` with
    the `start` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以使用`start`命令在`pm2`后面运行你的进程：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After you do this, the script is running and you can see the output of the
    process with the logs command and the application ID:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成这个步骤后，脚本开始运行，你可以通过日志命令和应用ID查看进程的输出：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead of using the raw ID of the process, you can name your running processes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用名称而不是进程的原始ID来命名你的运行进程：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can also run more than one instance so that you can have two running instances
    of the same application and `pm2` will load and balance requests between them:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以运行多个实例，这样你就可以有两个相同应用正在运行的实例，`pm2`将在它们之间加载和平衡请求：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's a good idea to run more than one instance of a Node server as the Node
    blocks is making I/O operations. If you run more than one instance, then the other
    processes can continue serving the incoming requests while the other is blocked.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行多个Node服务器实例是一个好主意，因为Node阻塞正在进行的I/O操作。如果你运行多个实例，那么其他进程可以在另一个被阻塞时继续服务传入的请求。
- en: 'You can save the application parameters in a JSON file and use it instead of
    putting all the options in the command line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将应用程序参数保存到JSON文件中，并使用它而不是在命令行中放置所有选项：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the JSON file, you have the advantage that you don't have to remember how
    to run the application as the file contains all the required configurations and
    the same environment is easily reproducible on different hosts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON文件，你有这样的优势，你不必记住如何运行应用程序，因为文件包含所有必需的配置，并且相同的环境可以轻松地在不同的主机上重现。
- en: If you are fine with your settings and everything is working as you expected,
    the next step is to persist the `pm2` process to run it as daemon each time that
    the server is restarted; this is always a good idea as if the server restarts
    for some reason such as maintenance, your processes will spawn automatically.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对设置满意，并且一切按预期工作，下一步就是将`pm2`进程持久化，以便每次服务器重启时都作为守护进程运行；这总是一个好主意，因为如果服务器因某种原因（如维护）重启，你的进程将自动启动。
- en: 'Fortunately, `pm2` provides an easy way to daemonize your configuration with
    the `startup` command for many operative systems, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`pm2`提供了一个简单的方法，使用`startup`命令为许多操作系统守护化你的配置，如下所示：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first command shows the available operative systems. As the `startup` command
    writes on the `/etc/` path, we need to run this command as the root user and that's
    the reason why we are using sudo command.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令显示了可用的操作系统。由于`startup`命令写入`/etc/`路径，我们需要以root用户运行此命令，这就是为什么我们使用sudo命令的原因。
- en: 'To run the daemon, you need to run the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行守护进程，你需要运行以下命令：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, before running this command, you will need to dump your current configuration
    in the daemon configuration and if you skip this step, the service will not start
    any process:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在运行此命令之前，你需要在守护进程配置中导出你的当前配置，如果你跳过此步骤，服务将不会启动任何进程：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this command, the current configuration of `pm2` will be used every time
    the server restarts or you manually restart the service.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，每次服务器重启或你手动重启服务时，都将使用`pm2`的当前配置。
- en: That's how you can run your node application in a production environment; run
    a real HTTP server and run your node processes behind it with the help of a process
    manager such as `pm2`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你在生产环境中运行你的Node应用程序的方法；运行一个真实的HTTP服务器，并在其后面运行你的Node进程，借助像`pm2`这样的进程管理器。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to run a Node application in the Heroku platform
    and in a bare metal or virtual machine server with Linux. These two methods to
    deploy Node applications are simple; however, they are the base for more complex
    deployments. You can make deployments on Docker containers, for instance. With
    Docker, you will need to know how to install your application in a fresh Linux
    installation as we did, and then, manage containers as a process like Heroku does.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在Heroku平台以及裸机或虚拟机服务器上运行Node应用程序，这两种部署Node应用程序的方法很简单；然而，它们是更复杂部署的基础。例如，你可以在Docker容器上进行部署。使用Docker，你需要知道如何像我们一样在你的新鲜Linux安装中安装你的应用程序，然后，像Heroku一样管理容器作为进程。
- en: In this chapter, we don't see many things related to Backbone; however, if you
    have a Backbone application and it is backed by Node, you probably want to put
    your code in production. In this chapter, we have seen how to put the output of
    the distribution files in a production server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们没有看到很多与Backbone相关的内容；然而，如果你有一个由Node支持的Backbone应用程序，你可能希望将你的代码部署到生产环境中。在本章中，我们看到了如何将分发文件的输出部署到生产服务器。
