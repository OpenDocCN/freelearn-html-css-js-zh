- en: 12\. Guide to Promises in TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. TypeScript 中 Promise 的指南
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter explores asynchronous programming in TypeScript using promises
    and discusses uses for asynchronous programming and how it is implemented in single-threaded
    JavaScript with the event loop. By the end of the chapter, you should have a solid
    understanding of how promises work and how TypeScript can enhance them. You will
    also be able to build a promise-based app using the concepts taught in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨使用 Promise 在 TypeScript 中的异步编程，并讨论异步编程的用途以及如何在单线程 JavaScript 和事件循环中实现。到本章结束时，你应该对
    Promise 的工作原理以及 TypeScript 如何增强它们有一个牢固的理解。你还将能够使用本章教授的概念构建一个基于 Promise 的应用程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned about asynchronous programming using callbacks.
    With this knowledge, we can manage concurrent requests and write non-blocking
    code that allows our applications to render web pages faster or serve concurrent
    requests on a Node.js server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了使用回调函数进行异步编程。有了这些知识，我们可以管理并发请求，并编写非阻塞代码，使我们的应用程序能够更快地渲染网页或在一个 Node.js
    服务器上处理并发请求。
- en: In this chapter, we will learn how promises allow us to write more readable,
    concise code to better manage asynchronous processes and forever escape deep callback
    nesting, sometimes known as "callback hell." We will explore the evolution of
    the `Promise` object and how it eventually became part of the JavaScript language.
    We'll look at different transpilation targets for TypeScript and how TypeScript
    can enhance promises and allow developers to leverage generics to infer return
    types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Promise 如何使我们能够编写更易于阅读和简洁的代码，以更好地管理异步过程，并永远摆脱深层次的回调嵌套，有时也称为“回调地狱”。我们将探讨
    `Promise` 对象的演变以及它最终成为 JavaScript 语言的一部分。我们将查看 TypeScript 的不同转译目标以及 TypeScript
    如何增强 Promise 并允许开发者利用泛型来推断返回类型。
- en: We will work on some practical exercises, such as managing multiple API requests
    from a website and managing concurrency in Node.js. We will use the Node.js FileSystem
    API to perform asynchronous operations on files and see how powerful asynchronous
    programming can be.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一些实际练习，例如管理来自网站的多个 API 请求以及管理 Node.js 中的并发。我们将使用 Node.js 文件系统 API 对文件执行异步操作，并看到异步编程有多么强大。
- en: The Evolution of and Motivation for Promises
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise 的演变及其动机
- en: 'As we''ve learned, a callback is a function that is given as an argument to
    another function, in effect saying, "do this when you are done." This capability
    has been in JavaScript since its inception in 1995 and can work very well, but
    as the complexity of JavaScript applications grew through the 2000s, developers
    found callback patterns and nesting in particular to be too messy and unreadable,
    giving rise to complaints about "callback hell" as shown in the following example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，回调是一个作为另一个函数参数给出的函数，实际上是在说：“当你完成时做这个。”这种能力自 1995 年 JavaScript 诞生以来就存在，并且可以工作得很好，但随着
    JavaScript 应用程序在 2000 年代的复杂性增长，开发者发现回调模式和嵌套尤其混乱且难以阅读，正如以下示例所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition to making code more readable and concise, promises have advantages
    beyond callbacks in that promises are objects that contain the state of the resolving
    asynchronous function. This means that a promise can be stored and either queried
    for the current state or called via its `then()` or `catch()` methods at any time
    to obtain the resolved state of the promise. We'll discuss those methods later
    in this chapter, but it's worth calling out at the beginning here that promises
    are more than syntactic sugar. They open up entirely new programming paradigms
    in which event handling logic can be decoupled from the event itself, just by
    storing the event in a promise.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使代码更易于阅读和简洁外，Promise 在回调之外还有优势，因为 Promise 是包含解决异步函数状态的对象。这意味着 Promise 可以被存储，并且可以在任何时间查询其当前状态，或者通过其
    `then()` 或 `catch()` 方法调用以获取 Promise 的解决状态。我们将在本章后面讨论这些方法，但在这里值得指出的是，Promise 不仅仅是语法糖。它们开辟了全新的编程范式，其中事件处理逻辑可以通过将事件存储在
    Promise 中来与事件本身解耦。
- en: Promises are not unique to JavaScript but were first proposed as a computer
    programming concept in the 1970s.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 并非 JavaScript 独有，但最初在 20 世纪 70 年代作为一个计算机编程概念被提出。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, refer to Friedman, Daniel; David Wise (1976). *The Impact
    of Applicative Programming on Multiprocessing*. International Conference on Parallel
    Processing. pp. 263–272.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅弗里德曼，丹尼尔；大卫·怀斯（1976）。*应用编程对并行处理的影响*。国际并行处理会议。第263-272页。
- en: As web frameworks gained popularity, proposals for promises started to appear
    in 2009 and libraries such as jQuery started implementing promise-like objects
    in 2011\.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web框架的流行，Promise的提案始于2009年，jQuery等库在2011年开始实现类似Promise的对象。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information, refer to the following: [https://groups.google.com/g/commonjs/c/6T9z75fohDk](https://groups.google.com/g/commonjs/c/6T9z75fohDk)
    and [https://api.jquery.com/category/version/1.5/](https://api.jquery.com/category/version/1.5/)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参阅以下链接：[https://groups.google.com/g/commonjs/c/6T9z75fohDk](https://groups.google.com/g/commonjs/c/6T9z75fohDk)
    和 [https://api.jquery.com/category/version/1.5/](https://api.jquery.com/category/version/1.5/)。
- en: It wasn't long before Node.js started to have some promise libraries as well.
    Google's AngularJS bundled the Q library. All of these libraries wrapped callbacks
    in a higher-level API that appealed to developers and helped them to write cleaner
    and more readable code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不久之后，Node.js也开始拥有了一些Promise库。Google的AngularJS捆绑了Q库。所有这些库都将回调封装在高级API中，这些API对开发者有吸引力，并帮助他们编写更干净、更易读的代码。
- en: In 2012, promises were proposed as an official specification in order to standardize
    the API. The specification was accepted in 2015 and has since been implemented
    in all major browsers as well as Node.js.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，Promise被正式提出作为一项规范，以标准化API。该规范于2015年获得批准，并自那时起在所有主要浏览器以及Node.js中得到了实现。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details, refer to [http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor](http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请参阅[http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor](http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor)。
- en: '"Promisification," the ability to wrap an existing asynchronous function in
    a promise, was added to many libraries and became part of the `util` package in
    the standard Node.js library as of version 8.0 (released in 2017).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “Promise化”，即能够将现有的异步函数包裹在Promise中，这一功能被添加到许多库中，并成为了Node.js标准库中`util`包的一部分，自8.0版本（2017年发布）起。
- en: TypeScript, as a superset of JavaScript, will always support native language
    features such as promises; however, TypeScript does not provide polyfills, so
    if the target environment doesn't support native promises, a library is required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JavaScript的超集，TypeScript将始终支持原生语言特性，如Promise；然而，TypeScript不提供polyfills，因此如果目标环境不支持原生的Promise，则需要一个库。
- en: Most JavaScript runtimes (such as a web browser or Node.js server) are single-threaded
    execution environments. That means the main JavaScript process will only do one
    thing at a time. Thanks to the event loop, the runtime will seem like it's capable
    of doing many things at once as long as we write non-blocking code. The event
    loop recognizes asynchronous events and can turn to other tasks while it waits
    for those events to resolve.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript运行时（如网页浏览器或Node.js服务器）都是单线程执行环境。这意味着主JavaScript进程一次只能做一件事。多亏了事件循环，只要我们编写非阻塞代码，运行时就会看起来能够同时做很多事情。事件循环能够识别异步事件，并在等待这些事件解决的同时转向其他任务。
- en: 'Consider the example of a web page that needs to call an API to load data into
    a table. If that API call were blocking, then that would mean the page render
    couldn''t complete until the data loaded. Our user would have to stare at a blank
    page until all the data loaded and page elements rendered. But because of the
    event loop, we can register a listener that allows rendering of the website to
    continue and then load the table when our data is finally returned. This is visualized
    in the following figure:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个需要调用API将数据加载到表格中的网页为例。如果该API调用是阻塞的，那么这意味着页面渲染无法完成，直到数据加载完毕。我们的用户将不得不盯着一个空白的页面，直到所有数据加载完毕，页面元素渲染完成。但是，由于事件循环，我们可以注册一个监听器，允许网站渲染继续进行，然后在我们的数据最终返回时加载表格。这将在以下图中展示：
- en: '![Figure 12.1: A typical event loop'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1：典型的事件循环]'
- en: '](img/B14508_12_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_12_01.jpg)'
- en: 'Figure 12.1: A typical event loop'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：典型的事件循环
- en: 'This can be implemented using callbacks or promises. The event loop is what
    makes this possible. Node.js works similarly, but now we may be responding to
    requests from a multitude of clients. In this simple example, three different
    requests are being made:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过回调或承诺来实现。事件循环使得这一点成为可能。Node.js的工作方式类似，但现在我们可能需要响应来自众多客户端的请求。在这个简单的例子中，正在发出三个不同的请求：
- en: '![Figure 12.2: Multiple requests'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2：多个请求'
- en: '](img/B14508_12_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2：多个请求](img/B14508_12_02.jpg)'
- en: 'Figure 12.2: Multiple requests'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：多个请求
- en: The API is not blocking so additional requests can come in even when the initial
    one has not been served. The requests are served in the order the work is completed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: API不是阻塞的，因此即使初始请求尚未被处理，也可以进来额外的请求。请求按照工作完成的顺序被处理。
- en: Anatomy of a Promise
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺的构成
- en: 'A promise is a JavaScript object that can exist in three states: *pending*,
    *fulfilled*, or *rejected*. Although promises can be instantly fulfilled or rejected,
    it is most typical for a promise to be created in a pending state and then resolved
    to be fulfilled or rejected as an operation succeeds or fails. Promises are chainable
    and implement several convenience methods that we''ll go into.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个承诺（promise）是JavaScript对象，它可以存在于三种状态：*待定（pending）*、*已解决（fulfilled）*或*已拒绝（rejected）*。尽管承诺可以立即解决或拒绝，但最典型的情况是承诺在待定状态下创建，然后根据操作的成功或失败被解决为已解决或已拒绝。承诺是可链式的，并实现了几个方便的方法，我们将在后面介绍。
- en: To understand the states of a promise better, it's important to know that the
    states of a promise cannot be queried. As a programmer, we do not check the state
    of the promise and take action based on that state. Rather we provide a function
    callback that will be invoked when the promise reaches that state. For example,
    we make an HTTP request to our backend server and get a promise in response. Now
    we have set up our event and we merely need to tell the promise what to do next
    and how to handle any errors. Examples of this will follow.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解承诺的状态，重要的是要知道承诺的状态不能被查询。作为程序员，我们不会检查承诺的状态并根据该状态采取行动。相反，我们提供一个函数回调，当承诺达到该状态时将被调用。例如，我们向我们的后端服务器发出HTTP请求并得到一个承诺作为响应。现在我们已经设置了事件，我们只需要告诉承诺接下来要做什么以及如何处理任何错误。以下是一些示例。
- en: The Promise Callback
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺回调
- en: 'A promise can be instantiated using the `new` keyword and `Promise` constructor.
    When instantiated in this way, `Promise` expects a callback argument that contains
    the actual work to be done. The callback has two arguments of its own, `resolve`
    and `reject`. These arguments can be called explicitly to either resolve or reject
    the promise. For example, we can create a promise that resolves after 100 ms like
    this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`new`关键字和`Promise`构造函数来实例化一个承诺。以这种方式实例化时，`Promise`期望一个包含实际要执行的工作的回调参数。该回调有两个自己的参数，`resolve`和`reject`。这些参数可以被显式调用以解决或拒绝承诺。例如，我们可以创建一个在100毫秒后解决的承诺，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We could also create a promise that rejects after 100 ms:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个在100毫秒后拒绝的承诺：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: then and catch
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: then和catch
- en: 'Promises can be chained into callback functions of their own using `then` and
    `catch`. The callback function given to `then` will fire only once the promise
    is fulfilled and the callback function given to `catch` will only fire if the
    promise is rejected. Most libraries that return promises will automatically call
    `resolve` and `reject`, so we only need to provide `then` and `catch`. Here''s
    an example using the Fetch API:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`then`和`catch`将承诺链入它们自己的回调函数。`then`提供的回调函数只有在承诺被解决后才会触发，而`catch`提供的回调函数只有在承诺被拒绝时才会触发。大多数返回承诺的库会自动调用`resolve`和`reject`，所以我们只需要提供`then`和`catch`。以下是一个使用Fetch
    API的示例：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code will make a call to our backend server and log out the result. If
    the call fails, it'll log that too.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将调用我们的后端服务器并记录结果。如果调用失败，它也会记录下来。
- en: 'If this were a real application, we might have a couple of functions, `showData`
    and `handleError`, that could manage what our application does with the response
    from the server. In that case, the use of `fetch` would likely be something like
    this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个真实的应用程序，我们可能有一些函数，如`showData`和`handleError`，可以管理应用程序如何处理来自服务器的响应。在这种情况下，使用`fetch`可能如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using promises like this shows how we can decouple our asynchronous processes
    from business logic and display elements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺（promises）这种方式展示了我们如何将异步过程与业务逻辑和显示元素解耦。
- en: Pending State
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 待定状态
- en: 'A pending promise is one that has yet to complete its work. It''s simple to
    create a promise that is forever stuck in a pending state:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起承诺是指尚未完成其工作的承诺。创建一个永远处于挂起状态的承诺很简单：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This promise will never do anything as neither `resolve` nor `reject` are ever
    called. The promise will remain in a pending state. If we execute this code, it'll
    print out `Promise { <pending> }`. As noted above, we do not query the state of
    a promise but rather provide a callback for the eventual resolution of a promise.
    The sample code above contains a promise that can never be resolved and as such
    could be seen as invalid code. There is no use case for promises that cannot resolve.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个承诺永远不会做任何事情，因为`resolve`和`reject`从未被调用。承诺将保持挂起状态。如果我们执行此代码，它将输出`Promise { <pending>
    }`。如上所述，我们并不查询承诺的状态，而是提供一个回调以供承诺最终解决。上面的示例代码包含一个永远无法解决的承诺，因此可以被视为无效代码。无法解决的承诺没有用例。
- en: Fulfilled State
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成状态
- en: 'We can create a promise that is fulfilled immediately:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个立即解决的承诺：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will log out `Promise { 'fulfilled!' }`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出`Promise { 'fulfilled!' }`。
- en: Unlike the pending state, creating a promise that resolves immediately has a
    few more practical use cases. The primary use of an immediately resolved promise
    would be when working with an API that expects a promise.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与挂起状态不同，创建一个立即解决的承诺有更多实际用途。立即解决承诺的主要用途是在与期望承诺的API一起工作时。
- en: Rejected State
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拒绝状态
- en: 'We can create a promise that is fulfilled immediately:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个立即解决的承诺：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will log out `Promise { <rejected> 'rejected!' }` and then throw an unhandled
    promise rejection warning. Rejected promises always need to be caught. Failure
    to catch a promise rejection may cause our program to crash!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出`Promise { <rejected> 'rejected!' }`，然后抛出一个未处理的承诺拒绝警告。拒绝的承诺总是需要被捕获。未能捕获承诺拒绝可能会导致我们的程序崩溃！
- en: As with the fulfilled state, the primary use case for immediately rejecting
    a promise would be for writing a good unit test, but there may be secondary use
    cases in which some process throws an error during an asynchronous workflow and
    it may make sense to return a rejected promise. This circumstance would be most
    likely when working with a third-party library where the API isn't quite to our
    liking and we need to wrap it with something more in line with the rest of our
    application architecture.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与完成状态一样，立即拒绝承诺的主要用例是当与期望承诺的API一起工作时。但可能有次要用例，在异步工作流程中，某些过程在执行过程中抛出错误，返回一个拒绝的承诺可能是有意义的。这种情况最有可能发生在与第三方库一起工作时，其中API并不完全符合我们的喜好，我们需要用更符合我们应用程序架构的东西来包装它。
- en: Chaining
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链式
- en: 'One of the main advantages of promises over callbacks is the ability to chain
    promises together. Consider a function that waits 1 second, generates a random
    number between 0 and 99, and adds it to the previous result. There are better
    ways to write recursive functions, but this is meant to simulate a website making
    several calls to a backend:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与回调相比，承诺的主要优势之一是能够将承诺链式连接起来。考虑一个等待1秒、生成0到99之间的随机数并将其添加到前一个结果的函数。虽然写递归函数有更好的方法，但这里是为了模拟一个网站对后端进行多次调用的过程：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A sample output of this program is the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的以下是一个示例输出：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each time we call `getTheValue`, we wait 1 second, then generate a random number
    and add it to the value we passed in. In a real-world scenario, we can think of
    this as a program that completes several asynchronous tasks, using the output
    from the last one as input to the next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用`getTheValue`时，我们等待1秒，然后生成一个随机数并将其添加到我们传入的值中。在现实世界的场景中，我们可以将其视为一个完成多个异步任务的程序，其中一个任务的输出作为下一个任务的输入。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As the starting point of the program is a random number, your output would be
    different from the one presented above.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序的起点是一个随机数，你的输出将与上面展示的不同。
- en: Everything in the previous program works correctly; however, the callback nesting
    isn't very nice to look at and could be challenging to maintain or debug. The
    next exercise will teach you how you can write more readable and maintainable
    code using promises.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 之前程序中的所有内容都工作正常；然而，回调嵌套看起来并不美观，可能难以维护或调试。接下来的练习将教你如何使用承诺编写更易读和可维护的代码。
- en: 'Exercise 12.01: Chaining Promises'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：链式连接承诺
- en: 'In this exercise, we will refactor the preceding example and chain promises
    to eliminate nesting and make the code more readable:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将重构前面的示例，并链式连接承诺以消除嵌套，使代码更易读：
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can be found here: [https://packt.link/IO8Pz](https://packt.link/IO8Pz).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在此处找到：[https://packt.link/IO8Pz](https://packt.link/IO8Pz)。
- en: 'Write the following program, which refactors the previous example using promises:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下程序，该程序使用承诺重构了前面的示例：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The nesting is gone and the code is a lot more readable. Our `getTheValue` function
    now returns a promise instead of using a callback. Because it returns a promise,
    we can call `.then()` on the promise, which can be chained into another promise
    call.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嵌套消失了，代码的可读性也大大提高。我们的`getTheValue`函数现在返回一个承诺而不是使用回调。因为它返回一个承诺，所以我们可以对承诺调用`.then()`，这可以链入另一个承诺调用。
- en: 'Run the program. The chain of promises will resolve each in turn and we''ll
    get similar output to the previous program:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。承诺链将依次解决每个承诺，我们将得到与上一个程序类似的输出：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that you will get an output that is different from the one shown above
    because the program uses a random number as the starting point.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你将得到一个与上面显示的不同输出，因为程序使用一个随机数作为起始点。
- en: 'Chaining can also be a big help when it comes to error conditions. If my `getTheValue`
    function rejects the promise, I''m able to catch the error by chaining a single
    `catch` to the end of the chain:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理错误条件时，链式调用也可以大有帮助。如果我的`getTheValue`函数拒绝承诺，我可以通过在链的末尾链式调用一个`catch`来捕获错误：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are introducing a 10% chance (the chance our number when divided by 10 will
    have a remainder of 0) of throwing an error on each iteration. On average, our
    program will fail more often than it executes successfully now:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个迭代中引入了10%的概率（即我们的数字除以10后余数为0的概率）来抛出错误。平均而言，我们的程序现在失败的概率将比成功执行的概率更高：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: finally
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: finally
- en: In addition to `then` and `catch` methods, the `Promise` object also exposes
    a `finally` method. This is a callback function that will be called regardless
    of whether an error is thrown or caught. It's great for logging, closing a database
    connection, or simply cleaning up resources, regardless of how the promise is
    eventually resolved.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`then`和`catch`方法外，`Promise`对象还公开了一个`finally`方法。这是一个无论是否抛出或捕获错误都会被调用的回调函数。这对于记录日志、关闭数据库连接或简单地清理资源来说非常棒，无论最终承诺是如何解决的。
- en: 'We can add a `finally` callback to the above promise:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在上面的承诺中添加一个`finally`回调：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now `"We are done!"` will be logged regardless of whether or not we trip the
    `"Bad modulus!"` error condition:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“`We are done!`”将无论是否触发“`Bad modulus!`”错误条件都会被记录：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Promise.all
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise.all
- en: '`Promise.all` is one of the most useful utility methods that `Promise` has
    to offer. Even code written with async/await syntax (see *Chapter 13, Async/Await*)
    can make good use of `Promise.all`. This method takes an iterable (likely an array)
    of promises as an argument and resolves all of them. Let''s see how we can change
    our example promise using `Promise.all`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all`是`Promise`提供最有用的实用方法之一。即使使用async/await语法编写的代码（见*第13章，Async/Await*）也可以很好地使用`Promise.all`。此方法接受一个承诺的可迭代参数（可能是数组），并解决所有承诺。让我们看看我们如何使用`Promise.all`改变我们的示例承诺：'
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The output should be similar to the ones obtained for the preceding examples.
    In this example, we call the same function 10 times, but imagine these are 10
    different API calls we need to reach and then sum the total. Each call takes approximately
    1 second. If we chain a series of promises, this operation will take just over
    10 seconds. By using `Promise.all`, we are able to run those operations in parallel
    and now it takes only 1 second to complete the function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该与前面示例中获得的输出类似。在这个例子中，我们调用了同一个函数10次，但想象一下，这些是10个不同的API调用，我们需要达到并求和。每个调用大约需要1秒钟。如果我们链式调用一系列承诺，这个操作将需要超过10秒钟。通过使用`Promise.all`，我们能够并行运行这些操作，现在完成函数只需要1秒钟。
- en: '`Promise.all` is useful any time you can run two or more asynchronous processes
    in parallel. It can be useful for persisting data to multiple database tables,
    letting multiple independent components render in a web browser independently,
    or making multiple HTTP requests. A good example of making multiple HTTP requests
    in parallel would be a service that monitors the uptime and ping duration of other
    services. There''s no reason such an operation would need to be synchronous and
    `Promise.all` lets us wait on several web requests within the same process.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all`在任何你可以并行运行两个或更多异步过程时都很有用。它可以用于将数据持久化到多个数据库表，让多个独立组件在网页浏览器中独立渲染，或者进行多个
    HTTP 请求。一个并行进行多个 HTTP 请求的好例子是监控其他服务正常运行时间和 ping 持续时间的服务。这种操作没有必要是同步的，`Promise.all`让我们在同一个过程中等待多个网络请求。'
- en: 'Exercise 12.02: Recursive Promise.all'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.02：递归 Promise.all
- en: 'In this exercise, instead of repeating the same function call 10 times, let''s
    optimize the programs from the previous examples to be more DRY (don''t repeat
    yourself). We can load up an array of promises and then use `Promise.all` to resolve
    all the promises in parallel and use `catch` and `finally` to resolve errors and
    ensure we return some output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们不是重复相同的函数调用 10 次，而是将前一个示例中的程序优化，使其更加DRY（不要重复自己）。我们可以加载一个承诺数组，然后使用`Promise.all`并行解决所有承诺，并使用`catch`和`finally`解决错误并确保我们返回一些输出：
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can also be found here: [https://packt.link/KNpqx](https://packt.link/KNpqx).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件也可以在这里找到：[https://packt.link/KNpqx](https://packt.link/KNpqx)。
- en: 'The following code will be our starting place for this refactor:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将是这次重构的起点：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In order to catch errors and make the program recursive, we'll need to wrap
    `Promise.all` in a function. Recursion is a pattern in which the same function
    can be called multiple times within the same execution.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了捕获错误并使程序递归，我们需要将`Promise.all`包裹在一个函数中。递归是一种模式，其中同一个函数可以在同一执行中多次调用。
- en: 'To add the recursion, create a new function and make the `Promise.all` statement
    the body of that function. Then call the function:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加递归，创建一个新的函数并将`Promise.all`语句作为该函数的主体。然后调用该函数：
- en: '[PRE18]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can use some functional programming techniques to, rather than having an
    array in which `getTheValue()` is repeated 10 times, programmatically construct
    an array of 10 elements, all of which are that function call. Doing this won't
    change how our program operates, but it will make it a bit nicer to work with.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用一些函数式编程技术，而不是在数组中重复`getTheValue()` 10 次，程序化地构建一个包含 10 个元素的数组，其中所有元素都是该函数调用。这样做不会改变我们的程序操作方式，但会使它更容易处理。
- en: 'Update the code given in the preceding step with the following:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一步骤中给出的代码更新如下：
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The logic here is that `Array(10)` creates a new array of 10 elements, `fill(null)`
    will initialize the array, then `map` will remap the array elements to be the
    `getTheValue()` function call.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的逻辑是`Array(10)`创建一个新的包含 10 个元素的数组，`fill(null)`将初始化数组，然后`map`将重新映射数组元素为`getTheValue()`函数调用。
- en: Th above code actually calls the function and returns the pending promise to
    the array that is already wrapped in `Promise.all`.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码实际上调用了函数，并将挂起的承诺返回到已经包裹在`Promise.all`中的数组。
- en: Now we want to use recursion in the case of an error. We will change our `catch()`
    callback from simply logging the error to starting the process over again. In
    this case, our business rule is we want the entire set of calculations to complete
    and we will restart if there is an error. The code to do this is very easy as
    `catch()` expects a function as its callback so we can just pass our `doIt` function
    back to it again.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们希望在出现错误的情况下使用递归。我们将改变我们的`catch()`回调，从简单地记录错误到重新开始整个过程。在这种情况下，我们的业务规则是希望整个计算集完成，如果有错误我们将重新启动。执行此操作的代码非常简单，因为`catch()`期望一个函数作为其回调，所以我们可以再次将我们的`doIt`函数传递给它。
- en: 'Pass the `doIt` function back to `catch()`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`doIt`函数传递回`catch()`：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that we do not invoke the callback function here. We want to pass a function
    and it will be invoked in the case of an error.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在这里没有调用回调函数。我们想要传递一个函数，它将在出现错误时被调用。
- en: 'We will now want to clean up our error messages a little so we can have a clean run:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在想要稍微清理一下错误消息，以便我们可以有一个干净的运行：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we run the program, we''ll see a few iterations of the program looping.
    The output may be something like this:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们运行程序时，我们会看到程序循环的几个迭代。输出可能如下所示：
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that depending on the number of iterations, you might get an output different
    from the one shown above.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，根据迭代次数的不同，你可能会得到与上面显示不同的输出。
- en: Promise.allSettled
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise.allSettled
- en: 'This method is a variation on `Promise.all`, which is ideal for when it''s
    acceptable for some of our promises to resolve successfully and some of them to
    be rejected. Let''s see how it''s different from `Promise.all`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是对 `Promise.all` 的一个变体，当一些承诺可以成功解析而另一些被拒绝时，它是非常理想的。让我们看看它与 `Promise.all`
    有什么不同：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The program will generate output like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将生成如下输出：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ve made a couple of enhancements here. For one thing, we are now passing
    the array size into `generateTheNumber`, which can give a bit more flavor or variation
    to our program. The main improvement now is the use of `Promise.allSettled`. Now,
    `Promise.allSettled` allows us to have a mix of successes and failures, unlike
    `Promise.all`, which will call the `then()` method if all the promises resolve
    successfully or call the `catch()` method if any of them fail. The output of `Promise.allSettled`
    could look something like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了一些增强。一方面，我们现在将数组大小传递给 `generateTheNumber`，这可以为我们的程序增添一些风味或变化。现在的主要改进是使用
    `Promise.allSettled`。现在，`Promise.allSettled` 允许我们有一个成功和失败混合的结果，而 `Promise.all`
    则不同，如果所有的承诺都成功解析，它将调用 `then()` 方法；如果任何一个失败，它将调用 `catch()` 方法。`Promise.allSettled`
    的输出可能看起来像这样：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each of the resolved promises will have a status containing the string `'fulfilled'`
    if the promise resolved successfully or `'rejected'` if there was an error. Fulfilled
    promises will have a `value` property containing the value the promise resolved
    to and rejected promises will have a `reason` property containing the error.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个已解析的承诺都将包含一个状态字符串，如果承诺成功解析，则为 `'fulfilled'`；如果发生错误，则为 `'rejected'`。满足的承诺将有一个包含承诺解析到的值的
    `value` 属性，而被拒绝的承诺将有一个包含错误的 `reason` 属性。
- en: In the example given, we are totaling the rejected promises and summing the
    values of the fulfilled promises, then returning that as a new object. To perform
    this operation, we use the built-in array function `reduce()`. Now, `reduce()`
    will iterate over each element of an array and collect transformed results in
    an accumulator, which is returned by the function. `MapReduce` functions are common
    in functional programming paradigms.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在给出的示例中，我们将拒绝的承诺进行总计，并将满足的承诺的值相加，然后返回一个新的对象。为了执行这个操作，我们使用内置的数组函数 `reduce()`。现在，`reduce()`
    将遍历数组的每个元素，并在累加器中收集转换后的结果，该累加器由函数返回。`MapReduce` 函数在函数式编程范式中被广泛使用。
- en: Note that `Promise.allSettled` is a fairly recent addition to ECMAScript, having
    landed in Node.js 12.9\. In order to use it, you'll need to set your `compilerOptions`
    target to `es2020` or `esnext` in your `tsconfig.json` file. Most modern browsers
    support this method, but it's a good idea to verify support before using this
    recent feature.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Promise.allSettled` 是 ECMAScript 中相对较新的一个功能，它在 Node.js 12.9 版本中首次出现。为了使用它，你需要在你的
    `tsconfig.json` 文件中将 `compilerOptions` 的目标设置为 `es2020` 或 `esnext`。大多数现代浏览器都支持这个方法，但在使用这个新功能之前验证其支持性是个好主意。
- en: 'Exercise 12.03: Promise.allSettled'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.03：Promise.allSettled
- en: 'We''ve seen an example of using `Promise.allSettled` to produce a mixed result
    of fulfilled and rejected promises. Now let''s combine `Promise.allSettled` and
    `Promise.all` to aggregate multiple results of our runs of `getTheValue()`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用 `Promise.allSettled` 来产生已满足和被拒绝的承诺的混合结果的例子。现在让我们将 `Promise.allSettled`
    和 `Promise.all` 结合起来，以聚合 `getTheValue()` 运行的多个结果：
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can also be found here: [https://packt.link/D8jIQ](https://packt.link/D8jIQ).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件也可以在这里找到：[https://packt.link/D8jIQ](https://packt.link/D8jIQ)。
- en: 'Start with the code from the example above. We are going to want to call `generateTheNumber()`
    three times. Once we have all the results, we can sort them to print out the highest
    and lowest results. We can use the same `Array().fill().map()` technique described
    above to create a new array of `generateTheNumber()` calls:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上面的示例代码开始。我们打算调用 `generateTheNumber()` 三次。一旦我们得到所有结果，我们可以对它们进行排序，以打印出最高和最低的结果。我们可以使用上面描述的相同的
    `Array().fill().map()` 技巧来创建一个新的 `generateTheNumber()` 调用数组：
- en: '[PRE26]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we can resolve three separate calls, we need to manage the output.
    First, we can log out the results to see what we need to do next:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们能够解析三个独立的调用，我们需要管理输出。首先，我们可以输出结果以查看下一步需要做什么：
- en: '[PRE27]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We log out `[undefined, undefined, undefined]`. That's not what we wanted. The
    reason for this is `generateTheNumber` doesn't actually return its promise – it
    didn't need to in the prior example.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们记录了 `[undefined, undefined, undefined]`。这不是我们想要的。原因在于 `generateTheNumber`
    实际上没有返回其承诺——在先前的例子中它不需要这样做。
- en: 'We can fix that by adding a `return` statement and removing the `void` return
    type. We also need our callback function to return the results instead of simply
    logging them out. All these changes would help a program like this integrate into
    a larger application:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个 `return` 语句并移除 `void` 返回类型来解决这个问题。我们还需要我们的回调函数返回结果而不是简单地将其记录出来。所有这些更改都将帮助此类程序集成到更大的应用程序中：
- en: '[PRE28]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last step to complete this exercise is we only want to output the highest
    and lowest totals. To accomplish this, we can use the `Array.map()` function to
    extract only the totals from the output and the `Array.sort()` function to order
    the above output from lowest to highest, then print the totals from the first
    and last entries:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个练习的最后一步是我们只想输出最高和最低的总数。为了实现这一点，我们可以使用 `Array.map()` 函数从输出中提取仅包含总数的部分，并使用
    `Array.sort()` 函数将上述输出从低到高排序，然后打印第一和最后条目的总数：
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You might get an output similar to the following:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会得到以下类似的输出：
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that only a section of the actual output is displayed for ease of presentation.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，为了便于展示，这里只显示了实际输出的部分内容。
- en: This exercise showed us how we can filter and sort the results of many promises
    and create data structures that accurately reflect the state of our application.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个练习向我们展示了我们如何过滤和排序许多承诺的结果，并创建准确反映应用程序状态的数据库结构。
- en: Promise.any
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise.any
- en: At the other end of the spectrum from `Promise.allSettled` lies `Promise.any`.
    This method takes an iterable (or array) of promises, but instead of settling
    all of them, it will resolve to the value of the first promise that resolves successfully.
    `Promise.any` is so new it has yet to be implemented in every browser and at the
    time of writing is not available in the LTS version of Node.js. You should check
    compatibility and availability before using it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Promise.allSettled` 相比，另一端是 `Promise.any`。此方法接受一个承诺的可迭代对象（或数组），但它不会解决所有承诺，而是将解析为第一个成功解决的承诺的值。`Promise.any`
    非常新，尚未在所有浏览器中实现，在撰写本文时，它尚未在 Node.js 的 LTS 版本中可用。在使用之前，你应该检查兼容性和可用性。
- en: Promise.race
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise.race
- en: '`Promise.race` has been around for some time and is similar to `Promise.any`.
    Now, `Promise.race` again takes an iterable of promises and executes them all.
    The first promise that resolves or rejects will resolve or reject the race. This
    is in contrast to `Promise.any` in that if the first promise in `Promise.any`
    rejects, the other promises still have an opportunity to resolve successfully:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.race` 已经存在一段时间了，并且与 `Promise.any` 类似。现在，`Promise.race` 再次接受一个承诺的可迭代对象并执行它们。第一个解决或拒绝的承诺将解决或拒绝比赛。这与
    `Promise.any` 相反，因为如果 `Promise.any` 中的第一个承诺拒绝，其他承诺仍然有机会成功解决：'
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, one promise always rejects in 1 second while the other resolves
    at a random interval between 0 and 2 seconds. If the `oneSecond` promise wins
    the race, the entire promise is rejected. If `upToTwoSeconds` takes less than
    a second, then the promise resolves successfully with the message `"Made It!"`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个承诺在 1 秒后总是拒绝，而另一个承诺在 0 到 2 秒之间的随机间隔内解决。如果 `oneSecond` 承诺赢得比赛，整个承诺将被拒绝。如果
    `upToTwoSeconds` 小于 1 秒，那么承诺将成功解决，并带有消息 `"Made It!"`。
- en: A practical example of using `Promise.race` might be a timeout and fallback
    feature where if the primary web service can't respond within an expected amount
    of time, the application either switches to a secondary source for data or exhibits
    some other behavior. Or perhaps we want to deal with a slow render issue in a
    web browser where if a screen paint hasn't finished in the expected amount of
    time, we switch to a simpler view. There are lots of cases where `Promise.race`
    can ease the complexity of handling asynchronous operations in TypeScript.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Promise.race` 的一个实际例子可能是超时和回退功能，如果主网络服务在预期时间内无法响应，应用程序将切换到次要数据源或表现出其他行为。或者，我们可能想要处理浏览器中的慢速渲染问题，如果在预期时间内屏幕绘制未完成，我们将切换到更简单的视图。在
    TypeScript 中处理异步操作时，`Promise.race` 可以简化许多情况。
- en: Enhancing Promises with Types
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过类型增强承诺
- en: The example we're working with so far specifies the type of input to the promise,
    but we have to provide a type for the result in each step of the chain. That's
    because TypeScript doesn't know what the promise may resolve to so we have to
    tell it what kind of type we're getting as the result.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理的示例指定了承诺的输入类型，但我们必须在链的每个步骤中为结果提供类型。这是因为 TypeScript 不了解承诺可能解析为什么类型，因此我们必须告诉它我们得到的结果的类型。
- en: 'In other words, we''re missing out on one of TypeScript''s most powerful features:
    *type inference*. Type inference is the ability for TypeScript to know what the
    type of something should be without having to be told. A very simple example of
    type inference would be the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们错过了一个 TypeScript 最强大的功能：*类型推断*。类型推断是 TypeScript 能够知道某物的类型应该是什么，而无需被告知的能力。类型推断的一个非常简单的例子如下：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: No type is specified. This is because TypeScript understands that the variable
    `hello` is being assigned a string and cannot be reassigned. If we try to pass
    this variable as an argument to a function that expects another type, we will
    get a compilation error, even though we never specified the type. Let's apply
    type inference to promises.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 没有指定类型。这是因为 TypeScript 理解变量 `hello` 被分配了一个字符串，并且不能重新分配。如果我们尝试将这个变量作为参数传递给期望另一种类型的函数，我们将得到编译错误，即使我们从未指定过类型。让我们将类型推断应用于承诺。
- en: 'First, let''s look at the type definition for the `Promise` object:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 `Promise` 对象的类型定义：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`T` is what''s known as a generic. It means any type can be specified to take
    the place of `T`. Let''s say we define a promise like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 是所谓的泛型。这意味着可以指定任何类型来代替 `T`。假设我们定义了一个像这样的承诺：'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What we''re doing here is stating the `resolve` argument will resolve to an
    unknown type. The receiving code will need to provide a type for it. This can
    be improved by adding a type value for `T`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是声明 `resolve` 参数将解析为未知类型。接收代码需要为它提供一个类型。这可以通过为 `T` 添加一个类型值来改进：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now the promise constructor resolves to a type of `Promise<string>`. When the
    promise becomes fulfilled, it is expected to return a type of `string`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的承诺构造函数解析为 `Promise<string>` 类型。当承诺被实现时，它预期返回一个 `string` 类型的值。
- en: 'Let''s examine an example where casting the return type of a promise becomes important:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个示例，其中将承诺的返回类型转换为重要：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you put this example into an IDE such as VS Code, you''ll see that you have
    a type error on the `result` parameter given to `printResult`. The type that the
    promise returned by `getPromise` is unknown but `printResult` expects `number`.
    We can fix this problem by providing a type to the promise when we declare it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把这个例子放入一个 IDE，比如 VS Code，你会看到在传递给 `printResult` 的 `result` 参数上有类型错误。`getPromise`
    返回的承诺的类型是未知的，但 `printResult` 期望 `number` 类型。我们可以通过在声明承诺时提供类型来解决这个问题：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We have added `<number>` immediately after our promise declaration and TypeScript
    knows this promise is expected to resolve to a number. This type-checking will
    also be applied to the resolution of our promise. For example, if we tried to
    resolve to a value of `"Hello!"`, we'd get another type error now that our promise
    is expected to return a number.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的承诺声明后立即添加了 `<number>`，TypeScript 知道这个承诺预期解析为数字。这种类型检查也将应用于承诺的解析。例如，如果我们尝试解析为
    `"Hello!"` 的值，由于我们的承诺现在预期返回数字，我们将得到另一个类型错误。
- en: 'Exercise 12.04: Asynchronous Rendering'
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.04：异步渲染
- en: 'In this exercise, we''ll create a simple website with synchronous rendering
    and refactor it so the rendering is asynchronous:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个具有同步渲染的简单网站，并将其重构为异步渲染：
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can also be found here: [https://packt.link/q8rka](https://packt.link/q8rka).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件也可以在这里找到：[https://packt.link/q8rka](https://packt.link/q8rka)。
- en: 'Clone the project from GitHub ([https://packt.link/q8rka](https://packt.link/q8rka))
    to begin. Then, install dependencies:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GitHub ([https://packt.link/q8rka](https://packt.link/q8rka)) 克隆项目以开始。然后，安装依赖项：
- en: '[PRE38]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We just installed TypeScript into our project as well as `http-server`, which
    is a simple Node.js HTTP server that will allow us to run our website on localhost.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚在我们的项目中安装了 TypeScript 以及 `http-server`，这是一个简单的 Node.js HTTP 服务器，它将允许我们在本地主机上运行我们的网站。
- en: Now we'll add a few files to get the project started.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们将添加一些文件以启动项目。
- en: 'In the root of your project, create a file called `index.html` and add the
    following lines to it:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中创建一个名为 `index.html` 的文件，并向其中添加以下行：
- en: '[PRE39]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, optionally add a stylesheet as the default styles are quite an eyesore.
    Bring your own or use something simple like this:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，可选地添加一个样式表作为默认样式相当难看。带来你自己的样式或者使用像这样简单的样式：
- en: '[PRE40]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a file called `data.json` to represent the data we are fetching from a
    remote server:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个名为 `data.json` 的文件添加进来，以表示我们从远程服务器获取的数据：
- en: '[PRE41]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'One more to go. Let''s add a TypeScript file called `data-loader.ts`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个要完成。让我们添加一个名为 `data-loader.ts` 的 TypeScript 文件：
- en: '[PRE42]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That's all you need to run a local service with a TypeScript web application!
    Later in the book, we'll see some more robust solutions, but for now, this will
    let us focus on the TypeScript without too many bells or whistles around.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是你运行 TypeScript 网络应用程序所需的所有内容！在本书的后面部分，我们将看到一些更健壮的解决方案，但到目前为止，这将让我们专注于 TypeScript，而无需太多花哨的功能。
- en: 'To see our application, we''ll need to transpile the TypeScript and start the
    local server. For the best experience, we''ll need two separate Command Prompt
    windows. In one of them, we''ll type a command to transpile the TypeScript and
    watch for changes:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看我们的应用程序，我们需要将 TypeScript 编译并启动本地服务器。为了获得最佳体验，我们需要两个独立的命令提示符窗口。在一个窗口中，我们将输入一个命令来编译
    TypeScript 并监视更改：
- en: '[PRE43]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And in the other window, we''ll start our server with a flag to avoid caching
    so we can see our changes right away:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个窗口中，我们将使用一个标志启动服务器以避免缓存，这样我们就可以立即看到我们的更改：
- en: '[PRE44]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we navigate to `http://localhost:8080`, we''ll see our application load
    and receive this message:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们导航到 `http://localhost:8080`，我们会看到我们的应用程序加载并收到这条消息：
- en: '[PRE45]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Something hasn''t worked correctly. What we want to see is `"Here is your data:
    Hello Promise!"`. If we go and look at the TypeScript code, we''ll see this line:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '似乎某些地方没有正确工作。我们想要看到的是 `"Here is your data: Hello Promise!"`。如果我们查看 TypeScript
    代码，我们会看到这一行：'
- en: '[PRE46]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This isn't working correctly. `fetch` is an asynchronous request. We are just
    seeing the unresolved promise and printing it to the screen.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有正确工作。`fetch` 是一个异步请求。我们只是看到了未解决的承诺并将其打印到屏幕上。
- en: Another warning sign is the use of `any` in the `updateUI` function. Why is
    the `any` type being used there when it should be a string? That's because TypeScript
    won't allow us to use a string. TypeScript knows we're calling `updateUI` with
    an unresolved promise and so we'll get a type error if we try to treat that as
    a string type. New developers sometimes think they are fixing a problem by using
    `any`, but more often than not they will be ignoring valid errors.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个警告信号是 `updateUI` 函数中使用 `any` 类型。为什么那里使用的是 `any` 类型，而应该是字符串？这是因为 TypeScript
    不允许我们使用字符串。TypeScript 知道我们正在使用未解决的承诺调用 `updateUI`，因此如果我们尝试将其视为字符串类型，将会得到类型错误。新开发者有时认为通过使用
    `any` 来修复问题，但更多的时候，他们将会忽略有效的错误。
- en: In order to get this code to work correctly, you will need to refactor it so
    that the promise `fetch` returns is resolved. When it works correctly, `fetch`
    returns a response object that exposes a `data` method that also returns a promise,
    so you will need to resolve two promises in order to display the data on your
    page.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码正确运行，你需要重构它，以便 `fetch` 返回的承诺得到解决。当它正确运行时，`fetch` 返回一个响应对象，该对象公开一个 `data`
    方法，该方法也返回一个承诺，因此你需要解决两个承诺才能在你的页面上显示数据。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The fetch library is a web API for browsers that is a great improvement on the
    original `XMLHttpRequest` specification. It retains all the power of `XMLHttpRequest`
    but the API is much more ergonomic and as such is used by many web applications,
    rather than installing a third-party client library. `fetch` is not implemented
    in Node.js natively but there are some libraries that provide the same functionality.
    We'll take a look at those later in the chapter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch` 库是浏览器的一个 Web API，它在原始 `XMLHttpRequest` 规范上有了很大的改进。它保留了 `XMLHttpRequest`
    的所有功能，但 API 要更加人性化，因此被许多网络应用程序使用，而不是安装第三方客户端库。`fetch` 在 Node.js 中不是原生实现的，但有一些库提供了相同的功能。我们将在本章后面部分查看这些库。'
- en: Libraries and Native Promises — Third-Party Libraries, Q, and Bluebird
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库和原生承诺 — 第三方库、Q 和 Bluebird
- en: As stated previously, promises became part of the ECMAScript standard in 2015\.
    Up until that point, developers used libraries such as Q or Bluebird to fill the
    gap in the language. While many developers choose to use native promises, these
    libraries remain quite popular with weekly downloads still growing. That said,
    we should carefully consider whether it's a good idea to depend on a third-party
    library over a native language feature. Unless one of these libraries provides
    some critical functionality that we can't do without, we should prefer native
    features over third-party libraries. Third-party libraries can introduce bugs,
    complexity, and security vulnerabilities and require extra effort to maintain.
    This isn't an indictment against open source.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，承诺在2015年成为了ECMAScript标准的一部分。在此之前，开发者使用Q或Bluebird等库来填补语言中的空白。虽然许多开发者选择使用原生的承诺，但这些库仍然非常受欢迎，每周的下载量仍在增长。话虽如此，我们应该仔细考虑是否依赖第三方库而不是原生语言特性是个好主意。除非这些库提供了我们无法没有的关键功能，否则我们应该优先考虑原生特性而不是第三方库。第三方库可能会引入错误、复杂性和安全漏洞，并需要额外的努力来维护。这并不是对开源的指控。
- en: Open source projects (such as TypeScript) are an essential part of today's developer
    ecosystem. That said, it's still a good idea to carefully choose our dependencies
    and make sure they are well-maintained libraries that are not redundant with native features.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 开源项目（如TypeScript）是当今开发者生态系统的重要组成部分。尽管如此，仔细选择我们的依赖项并确保它们是维护良好的库，且不与原生特性重复，仍然是一个好主意。
- en: 'It''s also worth noting that the APIs of third-party libraries may differ from
    the native language feature. For example, the Q library borrows a deferred object
    from the jQuery implementation:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，第三方库的API可能与原生语言特性不同。例如，Q库从jQuery实现中借用了一个延迟对象：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This written in a native promise is more like the examples we''ve seen so far:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 用原生承诺编写的代码更像是我们迄今为止看到的例子：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There's nothing inherently wrong with the Q implementation here, but it's non-standard
    and this may make our code less readable to other developers or prevent us from
    learning standard best practices.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Q实现本身并没有什么固有的错误，但它是不标准的，这可能会使我们的代码对其他开发者来说不那么易读，或者阻止我们学习标准最佳实践。
- en: Bluebird is more similar to the native promise. In fact, it could be used as
    a polyfill.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Bluebird与原生承诺更相似。事实上，它可以作为polyfill使用。
- en: Polyfilling Promises
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Polyfilling Promises
- en: TypeScript will transpile code, but it will *not* polyfill native language features
    that are not present in your target environment. This is critical to understand
    to avoid frustration and mysterious bugs. What TypeScript will do for us is allow
    us to specify the target environment. Let's look at a simple example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript会转译代码，但它**不会**为你的目标环境中不存在的原生语言特性进行polyfill。这一点至关重要，以避免挫败感和神秘的错误。TypeScript将为我们做的是允许我们指定目标环境。让我们看看一个简单的例子。
- en: 'Consider the following `tsconfig.json` file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`tsconfig.json`文件：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now consider this module in `promise.ts`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑这个位于`promise.ts`的模块：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our code will transpile fine. We enter `npx` `tsc` and the transpiled JavaScript
    output looks very much like our TypeScript code. The only difference is the type
    has been removed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码可以正常转译。我们输入`npx` `tsc`，转译后的JavaScript输出看起来非常像我们的TypeScript代码。唯一的区别是类型已被移除：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, consider if we change the target to `es5`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑如果我们将目标更改为“`es5`”：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now the project will no longer build:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个项目将无法构建：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: TypeScript even warns me that I might want to fix my target. Note that `"es2015"`
    and `"es6"` are the same thing (as are `"es2016"` and `"es7"`, and so on). This
    is a somewhat confusing convention that we simply need to get used to.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript甚至提醒我可能需要修复我的目标。请注意，“`es2015`”和“`es6`”是同一件事（同样，“`es2016`”和“`es7`”等等也是如此）。这是一个有些令人困惑的约定，我们只需要习惯它。
- en: This will be fine if I can build my project for an `es6+` environment (such
    as a current version of Node.js or any modern browser), but if I need to support
    a legacy browser or a very old version of Node.js, then "fixing" this by setting
    the compilation target higher will only result in a broken application. We'll
    need to use a polyfill.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我能为`es6+`环境（如当前版本的Node.js或任何现代浏览器）构建我的项目，那么这将是可行的，但如果我们需要支持旧版浏览器或非常旧的Node.js版本，那么通过设置编译目标更高来“修复”这个问题只会导致应用程序损坏。我们需要使用polyfill。
- en: 'In this case, Bluebird can be a really good choice as it has an API very similar
    to native promises. In fact, all I will need to do is `npm` `install` `bluebird`
    and then import the library into my module. The Bluebird library does not include
    typings so to have full IDE support, you''d need to also `install` `@types/bluebird`
    as a `devDependency`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Bluebird 可以是一个非常好的选择，因为它有一个与原生承诺非常相似的 API。实际上，我需要做的只是 `npm` `install`
    `bluebird`，然后把我模块中的库导入进来。Bluebird 库不包含类型定义，所以为了获得完整的 IDE 支持，你还需要将 `@types/bluebird`
    作为 `devDependency` 来安装：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: My transpiled code will now run in a very early version of Node.js, such as
    version 0.10 (released in 2013).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我转译的代码现在可以在一个非常早期的 Node.js 版本上运行，比如版本 0.10（2013 年发布）。
- en: 'Note that Bluebird is designed to be a full-featured `Promise` library. If
    I''m just looking for a polyfill, I might prefer to use something like `es6-promise`.
    Its use is exactly the same. I `npm` `install` `es6-promise` and then import the
    `Promise` class into my module:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Bluebird 是设计成一个功能齐全的 `Promise` 库。如果我只是寻找一个 polyfill，我可能更喜欢使用像 `es6-promise`
    这样的东西。它的使用方法完全相同。我 `npm` `install` `es6-promise`，然后把我模块中的 `Promise` 类导入进来：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you want to try this yourself, be aware that modern versions of TypeScript
    won't even run on Node.js 0.10! You'll have to transpile your code in a recent
    version (such as Node.js 12) and then switch to Node.js 0.10 to execute the code.
    To do this, it's a good idea to use a version manager such as `nvm` or `n`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要亲自尝试，请注意，TypeScript 的现代版本甚至无法在 Node.js 0.10 上运行！你将不得不在一个较新的版本（如 Node.js
    12）上转译你的代码，然后切换到 Node.js 0.10 来执行代码。为此，使用版本管理器（如 `nvm` 或 `n`）是个好主意。
- en: This is actually a great example of the power of TypeScript. We can write and
    build our code on a modern version but target a legacy runtime. Setting the compilation
    target will make sure we build code that is suitable for that runtime.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个 TypeScript 强大功能的绝佳例子。我们可以在现代版本上编写和构建我们的代码，但目标是遗留运行时。设置编译目标将确保我们构建的代码适合那个运行时。
- en: Promisify
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺化
- en: Promisification is the practice of taking an asynchronous function that expects
    a callback and turning it into a promise. This is essentially a convenience utility
    that allows you to always write in promises instead of having to use the callbacks
    of a legacy API. It can be really helpful to promisify legacy APIs so that all
    our code can use promises uniformly and be easy to read. But it's more than just
    a convenience to convert callbacks into promises. Some modern APIs will only accept
    promises as parameters. If we could only work on some code with callbacks, we
    would have to wrap the callback asynchronous code with promises manually. Promisification
    saves us the trouble and potentially many lines of code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺化是将期望回调的异步函数转换为承诺的实践。这本质上是一个便利工具，它允许你始终使用承诺而不是必须使用遗留 API 的回调。承诺化遗留 API 可以非常有助于使所有代码都使用承诺，并且易于阅读。但承诺化不仅仅是将回调转换为承诺的便利。一些现代
    API 只接受承诺作为参数。如果我们只能用回调编写一些代码，我们就必须手动将回调异步代码包装在承诺中。承诺化节省了我们麻烦，并可能节省许多代码行。
- en: 'Let''s work through an example of *promisifying* a function that expects a
    callback. We have a few options to choose from. Bluebird again provides this functionality
    with `Promise.promisify`. This time, we''ll try a polyfill, `es6-promisify`. Let''s
    start with a function that expects a callback:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解如何将一个期望回调的函数进行承诺化。我们有几个选项可供选择。Bluebird 再次通过 `Promise.promisify`
    提供这个功能。这次，我们将尝试一个 polyfill，`es6-promisify`。让我们从一个期望回调的函数开始：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Functions that can be promisified follow a convention where the first argument
    into the callback is an error object. If the error is null or undefined, then
    the function is considered to have been invoked successfully. Here, I am calling
    `asyncAdder`, giving it two numbers and a callback function. My callback understands
    that `asyncAdder` will have an error in the first argument position if an error
    was thrown or the sum of the two numbers in the second argument position if it
    was successful. By adhering to this pattern, the function can be promisified.
    First, we `npm install` `es6-promisify` and then we import the module:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被承诺化的函数遵循一个约定，即回调函数的第一个参数是一个错误对象。如果错误是 null 或 undefined，则认为函数已成功调用。在这里，我正在调用
    `asyncAdder`，给它两个数字和一个回调函数。我的回调理解到，如果抛出错误，`asyncAdder` 将在第一个参数位置有一个错误；如果成功，第二个参数位置将是两个数字的和。通过遵循这个模式，函数可以被承诺化。首先，我们
    `npm install` `es6-promisify`，然后导入模块：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We use the `promisify` import to wrap our function and now we can work exclusively
    with promises.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`promisify`导入来包装我们的函数，现在我们可以完全使用承诺（promises）来工作。
- en: 'Bluebird gives us exactly the same functionality:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Bluebird为我们提供了完全相同的功能：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Node.js util.promisify
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js util.promisify
- en: 'Node.js introduced its own version of `promisify` as a native feature in version
    8 (2017). Instead of using `es6-promise` or Bluebird, if we are targeting a Node.js
    8+ environment, we can leverage the `util` package. Note that since we are writing
    TypeScript, we will need to add the `@types/node` dependency to take advantage
    of this package. Otherwise, TypeScript will not understand our import. We''ll
    run `npm` `install` `-D @types/node`. The `-D` flag will install the type as a
    `devDependency`, which means it can be excluded from production builds:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js在版本8（2017年）中引入了自己的`promisify`版本作为原生功能。如果我们针对的是Node.js 8+环境，我们可以利用`util`包。请注意，由于我们正在编写TypeScript，我们需要添加`@types/node`依赖项来利用这个包。否则，TypeScript将无法理解我们的导入。我们将运行`npm
    install -D @types/node`。`-D`标志将安装类型作为`devDependency`，这意味着它可以排除在生产构建之外：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Obviously, if we want our code to run in a browser, this won't work and we should
    use one of the other libraries, such as Bluebird, to enable this functionality.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们想让我们的代码在浏览器中运行，这不会起作用，我们应该使用其他库之一，例如Bluebird，来启用这个功能。
- en: Asynchronous FileSystem
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步文件系统
- en: As of Node.js 10 (released 2018), the FileSystem API (`fs`) comes with promisified
    async versions of all the functions as well as blocking synchronous versions of
    them. Let's look at the same operation with all three alternatives.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2018年发布的Node.js 10，文件系统API（`fs`）提供了所有函数的承诺化异步版本以及它们的阻塞同步版本。让我们看看使用这三种替代方案执行相同操作的情况。
- en: fs.readFile
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fs.readFile
- en: 'Many Node.js developers have worked with this API. This method will read a
    file, taking the file path as the first argument and a callback as the second
    argument. The callback will receive one or two arguments, an error (should one
    occur) as the first argument and a data buffer object as the second argument,
    should the read be successful:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Node.js开发者都使用过这个API。这个方法将读取一个文件，第一个参数是文件路径，第二个参数是回调函数。回调函数将接收一个或两个参数，第一个参数是错误（如果发生错误），第二个参数是数据缓冲区对象，如果读取成功：
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We read the file and log out the contents asynchronously. Anyone who has worked
    with the Node.js `fs` library in the past has probably seen code that looks like
    this. The code is non-blocking, which means even if the file is very large and
    the read is very slow, it won't prevent the application from performing other
    operations in the meantime. There's nothing wrong with this code other than it's
    not as concise and modern as we might like.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们异步读取文件并将内容记录出来。任何过去使用过Node.js `fs`库的人可能都见过类似这样的代码。这段代码是非阻塞的，这意味着即使文件非常大且读取速度很慢，它也不会阻止应用程序在此期间执行其他操作。这段代码没有问题，只是它不如我们希望的那样简洁和现代。
- en: In the example above, we're reading the file and logging to the console – not
    very useful, but in a real-world scenario, we might be reading a config file on
    startup, handling the documents of clients, or managing the lifecycle of web assets.
    There are many reasons you might need to access the local filesystem in a Node.js
    application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们正在读取文件并将日志记录到控制台——这不是很有用，但在现实世界的场景中，我们可能在启动时读取配置文件，处理客户的文档，或者管理Web资源的生命周期。在Node.js应用程序中，你可能有很多需要访问本地文件系统的原因。
- en: fs.readFileSync
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fs.readFileSync
- en: 'The `fs` library also exposes a fully synchronous API, meaning its operations
    are blocking and the event loop won''t progress until these operations are complete.
    Such blocking operations are more often used with command-line utilities where
    taking full advantage of the event loop isn''t a priority and instead, simple,
    clean code is the priority. With this API, we can write some nice, concise code
    like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs`库还公开了一个完全同步的API，这意味着它的操作是阻塞的，事件循环不会在这些操作完成之前前进。这种阻塞操作通常与命令行工具一起使用，在这些工具中，充分利用事件循环不是优先事项，而是简单、干净的代码是优先事项。使用这个API，我们可以编写一些简洁的代码，如下所示：'
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It could be tempting to write code like this and call it a day, but `readFileSync`
    is a blocking operation so we must beware. The main execution thread will actually
    be paused until this work is complete. This may still be appropriate for a command-line
    utility, but it could be a real disaster to put code like this in a web API.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能有人会写这样的代码并就此结束，但 `readFileSync` 是一个阻塞操作，因此我们必须小心。主执行线程实际上会暂停，直到这项工作完成。这仍然可能适用于命令行工具，但将此类代码放入
    Web API 可能会是一场灾难。
- en: The fs Promises API
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The fs Promises API
- en: 'The `fs` library exposes the promises API, which can give us the best of both
    worlds, asynchronous execution and concise code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `fs` library exposes the promises API, which can give us the best of both
    worlds, asynchronous execution and concise code:'
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Using the promises API lets us write nearly as concise code as the synchronous
    version, but now we are fully asynchronous, making the code suitable for a high-throughput
    web application or any other process where a blocking operation would be unacceptable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 promises API 让我们能够写出与同步版本几乎一样简洁的代码，但现在我们是完全异步的，这使得代码适合高吞吐量的 Web 应用程序或任何其他不允许阻塞操作的过程。
- en: 'Exercise 12.05: The fs Promises API'
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.05：The fs Promises API
- en: 'In this exercise, you will use the `fs` promises API to concatenate two files
    into one. Whenever possible, make your code DRY (don''t repeat yourself) by using
    functions. You''ll need to use `readFile` and `writeFile`. The only dependencies
    needed for this program are `ts-node` (for execution), `typescript`, and `@types/node`
    so we have the types for the built-in `fs` and `path` libraries in Node.js:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用 `fs` 的 promises API 将两个文件合并成一个。尽可能通过使用函数使您的代码遵循DRY（不要重复自己）原则。您将需要使用
    `readFile` 和 `writeFile`。此程序所需的唯一依赖项是 `ts-node`（用于执行）、`typescript` 和 `@types/node`，这样我们就有
    Node.js 内置的 `fs` 和 `path` 库的类型：
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can also be found here: [https://packt.link/M3MH3](https://packt.link/M3MH3).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件也可以在这里找到：[https://packt.link/M3MH3](https://packt.link/M3MH3)。
- en: Using the file in the GitHub repo as a basis for this exercise, navigate to
    the exercise directory and type `npm` `i` to install these dependencies.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 GitHub 仓库中的文件为基础，导航到练习目录，并输入 `npm i` 来安装这些依赖项。
- en: We are going to want to read two separate files using `readFile` and then use
    `writeFile` to write our output text file. The sample project already has two
    text files with some simple text. Feel free to add your own files and text.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要使用 `readFile` 读取两个独立的文件，然后使用 `writeFile` 来写入我们的输出文本文件。示例项目已经包含了两个包含一些简单文本的文本文件。请随意添加您自己的文件和文本。
- en: 'This project could be completed using `readFileSync` and `writeFileSync`. That
    code would look something like this:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此项目可以使用 `readFileSync` 和 `writeFileSync` 完成。该代码可能看起来像这样：
- en: '[PRE63]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `resolve` function from the path library resolves paths on your filesystem
    and is often used alongside the `fs` library, as depicted above. Both these libraries
    are part of the Node.js standard library so we need only install typings, not
    the libraries themselves.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`resolve` 函数来自路径库，它会在您的文件系统上解析路径，通常与 `fs` 库一起使用，如上图所示。这两个库都是 Node.js 的标准库的一部分，所以我们只需要安装类型定义，而不是库本身。'
- en: 'We can execute this program with `npx` `ts-node` `file-concat.ts`. This will
    produce a file called `output.txt`, which contains this text:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `npx ts-node file-concat.ts` 来执行此程序。这将生成一个名为 `output.txt` 的文件，其中包含以下文本：
- en: '[PRE64]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So this works without promises. And this is probably fine for a command-line
    utility executed by a single user on a single workstation. However, if this kind
    of code were put into a web server, we might start to see some blocking issues.
    Synchronous filesystem calls are *blocking* and block the event loop. Doing this
    in a production application can cause latency or failure.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，这可以在没有 promises 的情况下工作。这可能对于由单个用户在单个工作站上执行的命令行工具来说是不错的。然而，如果将此类代码放入 Web 服务器，我们可能会开始看到一些阻塞问题。同步文件系统调用是
    *阻塞的*，并阻塞事件循环。在生产应用程序中这样做可能会导致延迟或失败。
- en: 'We could solve this problem using `readFile` and `writeFile`, which are both
    asynchronous functions that take callbacks, but then we''d need to nest the second
    `readFile` inside the first. The code would look like this:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `readFile` 和 `writeFile` 来解决这个问题，这两个都是接受回调的异步函数，但那时我们需要将第二个 `readFile`
    嵌套在第一个中。代码看起来像这样：
- en: '[PRE65]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We are now clear of blocking issues, but the code is looking quite ugly. It's
    not hard to imagine another developer failing to understand the intent of this
    code and introducing a bug. Additionally, by putting the second `readFile` as
    a callback in the first, we are making the function slower than it needs to be.
    In a perfect world, those calls can be made in parallel. To do that, we can leverage
    the promises API.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已经摆脱了阻塞问题，但代码看起来相当丑陋。不难想象另一位开发者可能无法理解这段代码的意图，并引入了错误。此外，通过将第二个 `readFile`
    作为回调放在第一个中，我们使函数的运行速度比实际需要的慢。在一个完美的世界中，这些调用可以并行进行。为此，我们可以利用承诺 API。
- en: 'The best way to do things in parallel with promises is `Promise.all`. We can
    wrap our two `readFile` calls in a single `Promise.all`. To do that, we need to
    promisify `readFile`. Lucky for us, the `fs` library comes with a helper that
    will do that for us. Instead of importing `readFile`, we import promises from
    `fs` and call the `readFile` method on that object:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用承诺并行处理事情的最佳方式是 `Promise.all`。我们可以将我们的两个 `readFile` 调用包裹在一个 `Promise.all` 中。为此，我们需要将
    `readFile` 函数进行承诺化。幸运的是，`fs` 库提供了一个帮助我们完成这一点的辅助函数。我们不是导入 `readFile`，而是从 `fs` 中导入承诺，并在该对象上调用
    `readFile` 方法：
- en: '[PRE66]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'These two reads will now run asynchronously in parallel. Now we can handle
    the output and use the same `array.join` function from the earlier example along
    with `promises.writeFile`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个读取操作现在将异步并行运行。现在我们可以处理输出并使用之前示例中的相同 `array.join` 函数以及 `promises.writeFile`：
- en: '[PRE67]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code is looking quite a lot cleaner than the nested code above. When we
    execute it with `npx` `ts-node` `file-concat.ts`, we get the expected output of
    `output.txt` containing the concatenated text:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码看起来比上面的嵌套代码干净得多。当我们使用 `npx ts-node file-concat.ts` 执行它时，我们得到预期的输出 `output.txt`，其中包含连接后的文本：
- en: '[PRE68]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that we have this working, we can certainly imagine much more complicated
    programs manipulating other types of files, such as a PDF merge function as a
    web service. Though some of the internals would be a lot more challenging to implement,
    the principles would be the same.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经使它工作，我们当然可以想象出更复杂的程序，这些程序可以操作其他类型的文件，例如作为网络服务的 PDF 合并功能。尽管其中的一些内部实现可能会更具挑战性，但原则是相同的。
- en: Working with Databases
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库一起工作
- en: It is very common for Node.js applications to work with a backend database such
    as `mysql` or `postgres`. It is critical that queries against a database be made
    asynchronously. Production-grade Node.js web services may serve thousands of requests
    per second. If it were necessary to pause the main execution thread for queries
    made synchronously against a database, these services just wouldn't scale at all.
    Asynchronous execution is critical to making this work.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 应用程序中，与后端数据库（如 `mysql` 或 `postgres`）一起工作是非常常见的。对数据库进行查询时异步执行是至关重要的。生产级别的
    Node.js 网络服务可能每秒处理数千个请求。如果需要对数据库进行同步查询而暂停主执行线程，这些服务根本无法扩展。异步执行对于使这一切工作至关重要。
- en: The process of negotiating a database connection, sending a SQL string, and
    parsing the response is complicated and not a native feature of Node.js and so
    we will almost always use a third-party library to manage this. These libraries
    are guaranteed to implement some kind of callback or promise pattern and we'll
    see it throughout their documentation and examples. Depending on the library you
    choose, you may have to implement a callback pattern, you may get to work with
    promises, or you may be presented with `async`/`await` (see *Chapter 13 Async/Await*).
    You may even get a choice of any of these as it's definitely possible to provide
    all of the above as options.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 协商数据库连接、发送 SQL 字符串和解析响应的过程很复杂，并且不是 Node.js 的原生功能，所以我们几乎总是使用第三方库来管理这一点。这些库保证实现某种回调或承诺模式，我们将在它们的文档和示例中看到这一点。根据你选择的库，你可能需要实现回调模式，你可能可以使用承诺进行工作，或者你可能被提供
    `async`/`await`（见 *第 13 章 Async/Await*）。你甚至可以选择其中任何一个，因为确实可以提供所有这些选项作为选项。
- en: For these examples, we'll use `sqlite`. Now, `sqlite` is a nice library that
    implements a fairly standard SQL syntax and can operate against a static file
    as a database or even run in memory. We will use the in-memory option. This means
    that there is nothing that needs to be done to set up our database. But we will
    have to run a few scripts to create a table or two and populate it on startup.
    It would be fairly simple to adapt these exercises to work with `mysql`, `postgres`,
    or even `mongodb`. All of these databases can be installed on your workstation
    or run in a Docker container for local development.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些示例，我们将使用`sqlite`。现在，`sqlite`是一个很好的库，它实现了相当标准的SQL语法，可以作为数据库操作静态文件，甚至可以在内存中运行。我们将使用内存选项。这意味着我们不需要做任何事情来设置我们的数据库。但我们将运行一些脚本在启动时创建一个或两个表并填充它们。将这些练习调整为与`mysql`、`postgres`或甚至`mongodb`一起工作相当简单。所有这些数据库都可以安装在工作站上或在Docker容器中本地运行开发。
- en: 'For the first example, let''s look at `sqlite3`. This library has an asynchronous
    API. Unlike more permanent and robust databases such as `mysql` or `postgres`,
    some `sqlite` client libraries are actually synchronous, but we won''t be looking
    at those as they aren''t very useful for demonstrating how promises work. So `sqlite3`
    implements an asynchronous API, but it works entirely with callbacks. Here is
    an example of creating an in-memory database, adding a table, adding a row to
    that table, and then querying back the row we added:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个例子，让我们看看`sqlite3`。这个库有一个异步API。与`mysql`或`postgres`等更永久和健壮的数据库不同，一些`sqlite`客户端库实际上是同步的，但我们将不会查看这些，因为它们对于演示Promise的工作方式并不很有用。所以`sqlite3`实现了一个异步API，但它完全使用回调。以下是一个创建内存数据库、添加一个表、向该表中添加一行，然后查询我们添加的行的示例：
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This is exactly what developers mean when they complain about "callback hell."
    Again, this code executes perfectly well, but it is needlessly verbose, becomes
    deeply nested, and repeats itself, especially in the error-handling department.
    Of course, the code could be improved by adding abstractions and chaining together
    methods, but that doesn't change the fact that callbacks aren't a very modern
    way to think about writing Node.js code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是开发者们在抱怨“回调地狱”时所表达的意思。再次强调，这段代码执行得非常完美，但它毫无必要地冗长，变得非常嵌套，并且重复，尤其是在错误处理方面。当然，可以通过添加抽象和链式调用方法来改进代码，但这并不改变回调不是编写Node.js代码的现代方式的事实。
- en: Since all of these callbacks follow the pattern of expecting the first argument
    to be an error object, we could promisify `sqlite3`, but as is often the case,
    somebody has already done this work for us and provided a library called simply
    `sqlite` that mimics the exact API of `sqlite3`, but implements a promise API.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些回调都遵循期望第一个参数是一个错误对象的模式，我们可以将`sqlite3`进行Promise化，但正如通常情况那样，有人已经为我们做了这项工作，并提供了一个名为`sqlite`的库，该库模仿了`sqlite3`的确切API，但实现了Promise
    API。
- en: 'I can rewrite the same code using this library and the result is a good deal
    more pleasing:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用这个库重写相同的代码，结果是好得多：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We've dropped nearly half of the lines of code and it's not nested as deeply.
    This still could be improved, but it's much cleaner now. Best of all, we have
    a single `catch` block followed by `finally`, to make sure the database connection
    is closed at the end.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经减少了近一半的代码行数，它也没有那么深地嵌套。这仍然可以改进，但现在它更干净了。最好的是，我们有一个单一的`catch`块后面跟着`finally`，以确保数据库连接在最后关闭。
- en: Developing with REST
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST进行开发
- en: In the next exercise, we'll build a RESTful API. REST is a very common standard
    for web traffic. Most websites and web APIs operate using REST. It stands for
    Representational State Transfer and defines concepts such as operations (sometimes
    called "methods" or even "verbs") such as `GET`, `DELETE`, `POST`, `PUT`, and
    `PATCH` and resources (the "path" or "noun"). The full scope of REST is beyond
    this book.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将构建一个RESTful API。REST是一个非常常见的网络流量标准。大多数网站和Web API都使用REST进行操作。它代表“表示状态传输”，定义了诸如操作（有时称为“方法”甚至“动词”）如`GET`、`DELETE`、`POST`、`PUT`和`PATCH`以及资源（“路径”或“名词”）等概念。REST的完整范围超出了本书的范围。
- en: Developers working on RESTful APIs frequently find it useful to work with some
    sort of REST client. The REST client can be configured to make different kinds
    of requests and display the responses. Requests can be saved and run again in
    the future. Some REST clients allow the creation of scenarios or test suites.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful API 上工作的开发者通常会发现在使用某种类型的 REST 客户端时很有用。REST 客户端可以被配置来执行不同类型的请求并显示响应。请求可以被保存并在将来再次运行。一些
    REST 客户端允许创建场景或测试套件。
- en: Postman is a popular and free REST client. If you don't already have a REST
    client you're comfortable working with, try downloading Postman at [https://www.postman.com/downloads/](https://www.postman.com/downloads/)
    before the next exercise. Once you've installed Postman, check its documentation
    ([https://learning.postman.com/docs/getting-started/sending-the-first-request/](https://learning.postman.com/docs/getting-started/sending-the-first-request/))
    and get ready for the next exercise.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是一个流行的免费 REST 客户端。如果你还没有一个你舒服工作的 REST 客户端，在下一个练习之前，尝试在 [https://www.postman.com/downloads/](https://www.postman.com/downloads/)
    下载 Postman。一旦你安装了 Postman，检查其文档 ([https://learning.postman.com/docs/getting-started/sending-the-first-request/](https://learning.postman.com/docs/getting-started/sending-the-first-request/))
    并为下一个练习做好准备。
- en: 'Exercise 12.06: Implementing a RESTful API backed by sqlite'
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.06：实现由 sqlite 支持的 RESTful API
- en: 'In this exercise, you will create a REST API backed by `sqlite`. In this project,
    you will implement all CRUD (create, read, update, and delete) operations in the
    `sqlite` database and we will expose the corresponding REST verbs (`POST`, `GET`,
    `PUT`, and `DELETE`) from our web server:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个由 `sqlite` 支持的 REST API。在这个项目中，你将在 `sqlite` 数据库中实现所有 CRUD（创建、读取、更新和删除）操作，并且我们将从我们的
    web 服务器公开相应的 REST 动词（`POST`、`GET`、`PUT` 和 `DELETE`）：
- en: Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this exercise can also be found here: [https://packt.link/rlX7G](https://packt.link/rlX7G).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件也可以在这里找到：[https://packt.link/rlX7G](https://packt.link/rlX7G)。
- en: To get started, clone the project from GitHub and change to the directory for
    this exercise.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，从 GitHub 克隆项目并切换到这个练习的目录。
- en: 'Install the dependencies:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装依赖项：
- en: '[PRE71]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This will install typings for Node.js, as well as `ts-node` and `typescript`
    as development dependencies while `sqlite` and `sqlite3` are regular dependencies.
    All of these dependencies are already specified in the project's `package.json`
    file. Some of the dependencies, such as `@types/node`, `ts-node`, and `typescript`,
    are specified as `devDependencies` and others are regular dependencies. For the
    purpose of this exercise, the distinction is not going to matter but it's a common
    practice to run application builds so that only the necessary dependencies are
    part of the production build, thus the separation. The way to run this kind of
    build is `npm install --production` if you only wish to install the production
    dependencies or `npm prune --production` if you've already installed your `devDependencies`
    and wish to remove them.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装 Node.js 的类型定义，以及 `ts-node` 和 `typescript` 作为开发依赖项，而 `sqlite` 和 `sqlite3`
    是常规依赖项。所有这些依赖项都已经指定在项目的 `package.json` 文件中。一些依赖项，如 `@types/node`、`ts-node` 和 `typescript`，被指定为
    `devDependencies`，而其他则是常规依赖项。对于这个练习的目的，这种区别不会很重要，但这是一个常见的做法，以便在运行应用程序构建时，只有必要的依赖项是生产构建的一部分，因此进行了分离。运行这种类型构建的方式是
    `npm install --production`，如果你只想安装生产依赖项，或者 `npm prune --production`，如果你已经安装了你的
    `devDependencies` 并希望移除它们。
- en: 'Now let''s create a file to hold our `sqlite` database. Add a file in the root
    of your project called `db.ts`. We''ll go with an object-oriented approach for
    the database and create a singleton object to represent our database and access
    patterns. One reason for doing this is we are going to want to maintain the state
    of whether or not the database has been initialized. Calling open on an in-memory
    `sqlite` database will destroy the database and create another one immediately,
    thus we only want to open the database connection if it isn''t already open:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个文件来保存我们的 `sqlite` 数据库。在你的项目根目录下添加一个名为 `db.ts` 的文件。我们将采用面向对象的方法来处理数据库，并创建一个单例对象来表示我们的数据库和访问模式。这样做的一个原因是我们将想要维护数据库是否已经初始化的状态。在内存中的
    `sqlite` 数据库上调用 open 将会销毁数据库并立即创建另一个，因此我们只希望在数据库连接尚未打开时打开数据库连接：
- en: '[PRE72]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: It's always a good idea to create a class or interface to describe our entity,
    so here we have created `PromiseModel`. It will be useful to other parts of our
    application to be able to understand the properties our entity has as well as
    their types, since the database will only return untyped query results. We export
    the interface so that it can be used by other modules.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总是创建一个类或接口来描述我们的实体是个好主意，因此我们创建了`PromiseModel`。这将有助于应用程序的其他部分理解我们的实体具有哪些属性以及它们的类型，因为数据库只会返回无类型的查询结果。我们导出这个接口，以便它可以被其他模块使用。
- en: 'Our database is an object with a constructor that will have a private member
    representing the actual database connection and a Boolean value to track whether
    the database has been initialized. Let''s add a method for initialization:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的数据库是一个对象，它有一个构造函数，该构造函数将有一个私有成员来表示实际的数据库连接，以及一个布尔值来跟踪数据库是否已初始化。让我们添加一个初始化方法：
- en: '[PRE73]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: First, we check to see if we've already initialized the database. If so, we're
    done and we resolve the promise. If not, we call `open`, then once that promise
    has resolved, run our table creation SQL, and then finally update the state of
    the database so that we don't accidentally re-initialize it.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们检查数据库是否已经初始化。如果是这样，我们就完成了，并解析这个承诺。如果不是，我们调用`open`，一旦这个承诺解析完成，就运行我们的表创建SQL语句，然后最后更新数据库的状态，这样我们就不会意外地重新初始化它。
- en: We could try to initialize the database in the constructor. The problem with
    that approach is that constructors do not resolve promises before returning. Constructor
    functions may call methods that return promises, but they will not resolve the
    promise. It's usually cleaner to create the singleton object and then invoke the
    initialization promise separately. For more information about singleton classes,
    see *Chapter 8, Dependency Injection in TypeScript*.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在构造函数中尝试初始化数据库。这种方法的问题在于构造函数在返回之前不会解析承诺。构造函数可以调用返回承诺的方法，但它们不会解析承诺。通常，创建单例对象并在单独调用初始化承诺会更干净。有关单例类的更多信息，请参阅*第8章，TypeScript中的依赖注入*。
- en: 'Now let''s add some methods. This will be pretty simple since our table only
    has two columns:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些方法。由于我们的表只有两列，所以这将会很简单：
- en: '[PRE74]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This method takes an object of type `PromiseModel` as an argument, sends a prepared
    statement (a parameterized SQL statement that is safe from SQL injection attacks),
    and then returns `RunResult`, which contains some metadata about the operation
    that took place. Since the `sqlite` library ships with typings, we're able to
    infer the return type without needing to specify it. The return type in this case
    is `Promise<ISqlite.RunResult<sqlite.Statement>>`. We could paste all of that
    into our code, but it's much cleaner the way it is. Remember, if a good type can
    be inferred, it's best to just let TypeScript do the heavy lifting.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个方法接受一个类型为`PromiseModel`的对象作为参数，发送一个预处理语句（一个参数化的SQL语句，可以防止SQL注入攻击），然后返回`RunResult`，它包含有关所执行操作的一些元数据。由于`sqlite`库附带类型定义，我们能够推断返回类型，而无需指定它。在这种情况下，返回类型是`Promise<ISqlite.RunResult<sqlite.Statement>>`。我们可以将所有这些粘贴到我们的代码中，但这样更干净。记住，如果可以推断出良好的类型，最好让TypeScript来做繁重的工作。
- en: 'In addition to the `create` method, we will want `delete`, `getAll`, `getOne`,
    and `update` methods. The `delete` method is very straightforward:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了`create`方法之外，我们还想添加`delete`、`getAll`、`getOne`和`update`方法。`delete`方法非常直接：
- en: '[PRE75]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Since we''re calling `db.run` again, we''re again returning that `RunResult`
    type. Let''s see what it looks like to return some of your own data:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们再次调用`db.run`，我们再次返回`RunResult`类型。让我们看看返回一些你自己的数据是什么样子：
- en: '[PRE76]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: These methods use type parameters to specify the expected return types. If the
    type parameters were omitted, these methods would return `any` types, which wouldn't
    be very helpful to the other parts of our application.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法使用类型参数来指定预期的返回类型。如果省略了类型参数，这些方法将返回`any`类型，这对我们应用程序的其他部分帮助不大。
- en: 'Last of all is the `update` method. This one will use our `PromiseModel` again
    to type check the input:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个是`update`方法。这个方法将再次使用我们的`PromiseModel`来进行输入类型检查：
- en: '[PRE77]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The final code for the class looks like this:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的最终代码看起来像这样：
- en: '[PRE78]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The next step is to build an HTTP server implementing a RESTful interface. Many
    Node.js developers use frameworks such as Express.js, Fastify, or NestJS, but
    for this exercise, we're just going to build a basic HTTP server. It won't have
    all the niceties of those frameworks, but it'll help us focus on asynchronous programming.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一步是构建一个实现 RESTful 接口的 HTTP 服务器。许多 Node.js 开发者使用 Express.js、Fastify 或 NestJS
    等框架，但在这个练习中，我们只是构建一个基本的 HTTP 服务器。它不会有那些框架的所有便利功能，但它将帮助我们专注于异步编程。
- en: 'To create our server, we''ll create a class called `App` and expose an instance
    of it. Create a file called `app.ts` and declare the class:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建我们的服务器，我们将创建一个名为 `App` 的类并公开其一个实例。创建一个名为 `app.ts` 的文件并声明这个类：
- en: '[PRE79]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Our `App` class takes an argument of the port number we''ll run our server
    on. The class will maintain the state of the running server as well as the database
    connection. Like our `PromiseDB` class, the constructor needs to be supplemented
    by an `initialize` method to handle the asynchronous setup:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `App` 类接受一个参数，即我们将在其上运行服务器的端口号。该类将维护运行中的服务器状态以及数据库连接。类似于我们的 `PromiseDB`
    类，构造函数需要补充一个 `initialize` 方法来处理异步设置：
- en: '[PRE80]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This method uses `Promise.all` so that we can initialize our database and server
    in parallel. When both are ready, it'll log a message letting us know the application
    is ready to handle requests. We are calling the `initialize` method on the `PromiseDB`
    instance that we've exposed to our `App` class. Unfortunately, `server.listen`
    doesn't return a promise but instead implements a fairly primitive API that requires
    a callback so we are wrapping it in our own promise. It's tempting to want to
    wrap `server.listen` in `util.promisify`, but even that won't work because `util.promisify`
    expects the callback function to expect the first argument to be an error object
    and the `server.listen` callback doesn't take any arguments. Sometimes, despite
    our best efforts, we just have to use a callback, but we can usually wrap them
    with promises.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法使用 `Promise.all` 以便我们可以并行初始化数据库和服务器。当两者都准备好时，它将记录一条消息，让我们知道应用程序已准备好处理请求。我们在
    `PromiseDB` 实例上调用 `initialize` 方法，该实例我们已经公开给 `App` 类。不幸的是，`server.listen` 不返回一个
    promise，而是实现了一个相当原始的 API，该 API 需要一个回调函数，因此我们将其包装在我们的自己的 promise 中。虽然我们很想用 `util.promisify`
    包装 `server.listen`，但即使那样也不会工作，因为 `util.promisify` 预期回调函数的第一个参数是一个错误对象，而 `server.listen`
    的回调函数不接受任何参数。有时，尽管我们尽了最大努力，但我们仍然不得不使用回调函数，但我们可以通常用 promises 包装它们。
- en: 'We''re also going to need to add a `requestHandler` method. `createServer`
    is a method exposed by the `http` module in Node.js. It takes an argument that
    should be a function to handle requests and supply a response. Again, the API
    for the `http` module is fairly low-level:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加一个 `requestHandler` 方法。`createServer` 是 Node.js 中 `http` 模块公开的一个方法。它接受一个参数，该参数应该是一个处理请求并返回响应的函数。再次强调，`http`
    模块的 API 相对较低级：
- en: '[PRE81]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We want our application to direct all traffic on the `/promise` resource to
    our promises API. This will allow us to add more resources (maybe `/admin` or
    `/users`) later on. The request handler's job is to see if we have requested the
    `/promise` route and then direct traffic to that specific router. Since we haven't
    defined any other resources, we'll return a 404 if we request any other route.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望我们的应用程序将 `/promise` 资源上的所有流量都导向我们的承诺 API。这将允许我们稍后添加更多资源（比如 `/admin` 或 `/users`）。请求处理器的任务是检查我们是否请求了
    `/promise` 路由，然后将流量导向那个特定的路由器。由于我们还没有定义任何其他资源，如果我们请求任何其他路由，我们将返回一个 404 状态码。
- en: Note that we are handling the `OPTIONS` HTTP verb differently than any other.
    If we get a request with that verb, we set the `"Access-Control-Allow-Origin"`
    header and return a successful response. This is for development convenience.
    The topic of CORS is beyond the scope of this book, and readers are encouraged
    to learn more about it before implementing it in a production environment.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们处理 `OPTIONS` HTTP 动词的方式与其他任何动词不同。如果我们收到一个带有该动词的请求，我们将设置 `"Access-Control-Allow-Origin"`
    头并返回一个成功的响应。这是为了开发方便。CORS 的话题超出了本书的范围，建议读者在将其应用于生产环境之前先了解更多相关信息。
- en: 'That error handler needs a definition, so let''s add one:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个错误处理器需要一个定义，让我们添加一个：
- en: '[PRE82]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This is a nice one-liner that by default will throw a 500 status code `Internal
    Server Error`, but can take optional parameters to return any error code or message.
    Our default handler sets the status code to 404 and provides the message `"Not
    Found"`.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个很好的单行代码，默认情况下会抛出一个 500 状态码 `Internal Server Error`，但可以接受可选参数以返回任何错误代码或消息。我们的默认处理器将状态码设置为
    404 并提供消息 `"Not Found"`。
- en: 'We add a call to `initialize` at the end and we''re good to go. Let''s take
    another look at the `App` class:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在最后添加了一个对`initialize`的调用，然后我们就可以开始了。让我们再次看看`App`类：
- en: '[PRE83]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If you've implemented all this in code, you're probably still getting an error
    on `promiseRouter`. That's because we haven't written that yet.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你已经在代码中实现了所有这些，你可能在`promiseRouter`上仍然会遇到错误。那是因为我们还没有写那个。
- en: Add a `router.ts` file to your project. This will be the last part we need to
    build this simple API. A more complicated application would hopefully include
    a more sophisticated directory structure and most likely be based on a leading
    framework such as Express.js or NestJS.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`router.ts`文件添加到你的项目中。这将是我们构建这个简单API所需构建的最后一部分。一个更复杂的应用程序可能希望包括一个更复杂的目录结构，并且很可能会基于一个领先的框架，如Express.js或NestJS。
- en: Unlike our database and server modules, the router is stateless. It does not
    need to be initialized and does not track any variables. We could still create
    a class for our router, but let's instead use a functional programming style.
    There's really no right or wrong way to do this. Instead of using classes for
    our database and server, we could likewise use a functional style.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与我们的数据库和服务器模块不同，路由器是无状态的。它不需要初始化，也不跟踪任何变量。我们仍然可以为我们路由器创建一个类，但让我们改用函数式编程风格。实际上，没有绝对的对错之分。我们同样可以用函数式风格代替为数据库和服务器使用的类。
- en: We're going to work on creating several handlers, tie them together with a router
    based on HTTP verbs, and also create a body parser. Let's start with the body parser.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将致力于创建几个处理器，基于HTTP动词将它们与一个路由器结合起来，并创建一个body解析器。让我们从body解析器开始。
- en: 'Readers who have some experience with the Express.js framework may have used
    its powerful `bodyParser` module. It''s normally a good idea to use an off-the-shelf
    solution for something like that, but in this exercise, you will write your own
    in order to get a closer look at how we can take the request or `IncomingMessage`
    object as a stream and convert it into a typed object:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于有Express.js框架经验的读者来说，可能已经使用过其强大的`bodyParser`模块。对于这类事情，通常使用现成的解决方案是个好主意，但在这个练习中，你将编写自己的代码，以便更深入地了解我们如何将请求或`IncomingMessage`对象作为流，并将其转换为类型化对象：
- en: '[PRE84]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The data stream is again a fairly low-level API that we must wrap in a promise.
    The stream is event-based, as are a lot of the Node.js APIs. In this case, we
    are listening for two separate events, `data` and `end`. Each time we get a `data`
    event, we add data to the `body` string. When we receive the `end` event, we can
    finally resolve our promise. Since the data is a string at this point and we want
    an object, we will use `JSON.parse` to parse the object. `JSON.parse` must be
    wrapped with `try/catch` to catch any parsing errors.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据流再次是一个相对底层的API，我们必须将其封装在Promise中。流是事件驱动的，Node.js的许多API也是如此。在这种情况下，我们正在监听两个独立的事件，`data`和`end`。每次我们收到`data`事件时，我们都会将数据添加到`body`字符串中。当我们收到`end`事件时，我们最终可以解析我们的Promise。由于此时数据是一个字符串，而我们想要一个对象，我们将使用`JSON.parse`来解析对象。`JSON.parse`必须用`try/catch`封装来捕获任何解析错误。
- en: By default, `JSON.parse` returns an `any` type. This type is too broad to be
    of any use in checking our application for type correctness. Fortunately, we can
    add proper type checking by setting the return type of `parseBody` to `Promise<PromiseModel>`.
    This will narrow the type of the object returned by `JSON.parse` to `PromiseModel`
    and the rest of our application can expect that type to have been parsed. Note
    that this is a compile-time check and does not guarantee the correct data has
    come from a third-party source such as an end user. It is advisable to combine
    type checks with validators or type guards to ensure consistency. When in doubt,
    employ good error handling.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，`JSON.parse`返回一个`any`类型。这个类型太宽泛了，在检查我们的应用程序的类型正确性时没有任何帮助。幸运的是，我们可以通过将`parseBody`的返回类型设置为`Promise<PromiseModel>`来添加适当的类型检查。这将使`JSON.parse`返回的对象类型缩小到`PromiseModel`，并且我们应用程序的其余部分可以期望该类型已被解析。请注意，这是一个编译时检查，并不能保证从第三方源（如最终用户）正确地收到了数据。建议将类型检查与验证器或类型守卫结合使用，以确保一致性。如有疑问，请使用良好的错误处理。
- en: 'Now that you have a good method for parsing the request body, let''s add one
    to handle the create action:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经有一个很好的解析请求体的方法了，让我们添加一个来处理创建操作：
- en: '[PRE85]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This function parses the body of the request, attempts to insert it into our
    database, and then responds with a default 200 response if the operation was successful.
    Note that the chained catch at the end will catch any errors that occur in the
    promise. If our body parsing fails, the error will be caught here, even though
    it's placed after `db.create` in the chain.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数解析请求的正文，尝试将其插入我们的数据库，如果操作成功，则返回默认的200响应。请注意，最后的链式 `catch` 会捕获任何在promise中发生的错误。即使它放在链中的
    `db.create` 之后，如果我们的正文解析失败，错误也会在这里被捕获。
- en: 'Now let''s handle the delete action:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们处理删除操作：
- en: '[PRE86]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The HTTP `DELETE` verb does not use a body. Instead, we will take the ID of
    the row we want to delete from the URL. We'll see how that routing works in a moment.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HTTP的 `DELETE` 动词不使用正文。相反，我们将从URL中获取我们想要删除的行的ID。我们将在稍后看到这个路由是如何工作的。
- en: 'The `GET` operations need to return some data and will use `JSON.stringify`
    to serialize their response objects to send them to a client:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET` 操作需要返回一些数据，并将使用 `JSON.stringify` 将其响应对象序列化以发送给客户端：'
- en: '[PRE87]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The update action looks similar to delete:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新操作看起来与删除类似：
- en: '[PRE88]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we just need a router. Your router will need to make a decision based
    on the HTTP verb used as well as any request parameter that may refer to the ID
    of the row we want to interact with. We will also set the `Content-Type` header
    to `application/json` for all responses. Then we simply need to delegate to the
    correct handler:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要一个路由器。你的路由器将需要根据使用的HTTP动词以及可能引用我们想要交互的行的ID的任何请求参数做出决定。我们还将为所有响应设置 `Content-Type`
    报头为 `application/json`。然后我们只需委托给正确的处理程序：
- en: '[PRE89]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now it''s time to try our application. We installed `ts-node` earlier. This
    library allows us to transpile and run our TypeScript program in a single step.
    It is not necessarily recommended to use `ts-node` in production, but it makes
    for a very handy development tool. Let''s try it now:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候尝试我们的应用程序了。我们之前安装了 `ts-node`。这个库允许我们一步完成转换和运行我们的TypeScript程序。在生产环境中不一定推荐使用
    `ts-node`，但它是一个非常方便的开发工具。让我们现在试试：
- en: '[PRE90]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You should see the following on your console:'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在控制台看到以下内容：
- en: '[PRE91]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This implies that your application is ready to start receiving requests. If
    not, you may have a typo somewhere. Let's try it out. You can either use a REST
    client or curl. This exercise uses Postman
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着你的应用程序已经准备好开始接收请求。如果不是，你可能某个地方有拼写错误。让我们试试。你可以使用REST客户端或curl。这个练习使用Postman
- en: 'If you make a `GET` request to `http://localhost:3000/promise`, you will get
    an empty array ([]) back:![Figure 12.3: Initial GET request'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你向 `http://localhost:3000/promise` 发起 `GET` 请求，你将返回一个空数组([])：![图12.3：初始GET请求
- en: '](img/B14508_12_03.jpg)'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_12_03.jpg)'
- en: 'Figure 12.3: Initial GET request'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.3：初始GET请求
- en: This is because we haven't created any records yet.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为我们还没有创建任何记录。
- en: 'Try a `POST` with the payload `{"desc":"Always lint your code"}`:![Figure 12.4:
    POST data'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用有效载荷 `{"desc":"Always lint your code"}` 的 `POST` 请求：![图12.4：POST数据
- en: '](img/B14508_12_04.jpg)'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_12_04.jpg)'
- en: 'Figure 12.4: POST data'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.4：POST数据
- en: 'Now the `GET` request returns `[{"id":1,"desc":"Always lint your code"}]`:![Figure
    12.5: Use GET to retrieve data'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 `GET` 请求返回 `[{"id":1,"desc":"Always lint your code"}]`：![图12.5：使用GET检索数据
- en: '](img/B14508_12_05.jpg)'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_12_05.jpg)'
- en: 'Figure 12.5: Use GET to retrieve data'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.5：使用GET检索数据
- en: 'If you do a request to `http://localhost:3000/promise/1`, you will get a single
    object back:![Figure 12.6: Single object'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你向 `http://localhost:3000/promise/1` 发起请求，你将返回一个单一的对象：![图12.6：单个对象
- en: '](img/B14508_12_06.jpg)'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_12_06.jpg)'
- en: 'Figure 12.6: Single object'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.6：单个对象
- en: 'If you request `http://localhost:3000/promise/2`, you will get nothing:![Figure
    12.7: No items found'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你请求 `http://localhost:3000/promise/2`，你将一无所获：![图12.7：没有找到项目
- en: '](img/B14508_12_07.jpg)'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_12_07.jpg)'
- en: 'Figure 12.7: No items found'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.7：没有找到项目
- en: 'If you request `http://localhost:3000/something-else`, you will get a 404 response:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你请求 `http://localhost:3000/something-else`，你将得到一个404响应：
- en: '![Figure 12.8: 404 response'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：404响应'
- en: '](img/B14508_12_08.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_12_08.jpg)'
- en: 'Figure 12.8: 404 response'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：404响应
- en: Looks like things are working. Experiment with the different HTTP verbs. Try
    giving invalid input and see how the error handling works. We'll use this API
    in the next section.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都在正常工作。尝试不同的HTTP动词。尝试输入无效数据，看看错误处理是如何工作的。我们将在下一节中使用这个API。
- en: Putting It All Together – Building a Promise App
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容 - 构建Promise应用
- en: We've learned techniques for using promises in web projects as well as Node.js
    APIs. Let's combine our earlier exercises to build a web application that renders
    progressively as data is ready and makes use of asynchronous programming on the
    server to avoid blocking the event loop.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了在 Web 项目和 Node.js API 中使用承诺的技术。让我们结合我们之前的练习来构建一个 Web 应用程序，该应用程序在数据准备就绪时逐步渲染，并利用服务器上的异步编程来避免阻塞事件循环。
- en: 'Activity 12.01: Building a Promise App'
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.01：构建承诺应用程序
- en: In this activity, we're going to build a web application that talks to the API
    we just built. Although frameworks such as Angular, React, and Vue are very popular,
    those are covered in later chapters so we will build a very basic TypeScript application
    with no bells or whistles.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，我们将构建一个与刚刚构建的 API 通信的 Web 应用程序。尽管 Angular、React 和 Vue 等框架非常流行，但这些将在后面的章节中介绍，所以我们将构建一个没有铃声或哨声的基本
    TypeScript 应用程序。
- en: Note
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This activity provides a UI application that communicates with the backend API
    we built in *Exercise 12.06*, *Implementing a RESTful API backed by sqlite*. In
    order to get the output shown, you will need to have your API running. Return
    to that exercise for help if you need it.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动提供了一个与我们在 *练习 12.06* 中构建的后端 API 通信的 UI 应用程序，该 API 是在 *实现基于 sqlite 的 RESTful
    API* 中构建的。为了获得显示的输出，您需要让您的 API 运行。如果需要帮助，请返回该练习。
- en: This UI application will connect to our API and allow us to modify the data
    we store in our database. We will be able to list out the data we've saved (the
    promises we make), create new items to save, and delete items. Our UI application
    will need to make `GET`, `POST`, and `DELETE` calls to our backend API. It will
    need to use an HTTP client to do that. We could install a library such as `axios`
    to handle that or we could use the native Fetch API available in all modern web
    browsers.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此 UI 应用程序将连接到我们的 API，并允许我们修改存储在数据库中的数据。我们将能够列出我们已保存的数据（我们做出的承诺），创建新的条目进行保存，以及删除条目。我们的
    UI 应用程序需要对后端 API 进行 `GET`、`POST` 和 `DELETE` 调用。它需要使用 HTTP 客户端来完成。我们可以安装一个库，如 `axios`
    来处理它，或者我们可以使用所有现代 Web 浏览器中可用的原生 Fetch API。
- en: Our web application will also need to be able to dynamically update the UI.
    Modern view libraries such as `react` or `vue` do that for us, but in this case
    we are framework-free so we'll need to use more DOM (document object model) APIs
    such as `getElementById`, `createElement`, and `appendChild`. These are natively
    available in all web browsers with no libraries needed.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Web 应用程序还需要能够动态更新 UI。现代视图库，如 `react` 或 `vue`，为我们做了这件事，但在这个案例中，我们是框架自由的，所以我们需要使用更多的
    DOM（文档对象模型）API，如 `getElementById`、`createElement` 和 `appendChild`。这些在所有浏览器中都是原生可用的，无需任何库。
- en: Implementing this application using promises will be critical because all of
    the API calls will be asynchronous. We will perform an action, such as a click,
    our application will call the API, then it will respond with data and then and
    only then will the promise resolve and cause a change in the DOM state.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺实现此应用程序至关重要，因为所有的 API 调用都将异步进行。我们将执行一个动作，例如点击，我们的应用程序将调用 API，然后它将响应数据，然后并且只有在那时承诺才会解决并导致
    DOM 状态的变化。
- en: 'Here are some high-level steps that will enable you to create the app:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些高级步骤，可以帮助您创建应用程序：
- en: Note
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code file for this activity can be found here: [https://packt.link/RlYli](https://packt.link/RlYli).'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在此处找到：[https://packt.link/RlYli](https://packt.link/RlYli)。
- en: Create a static `html` page with `css` to be served via `http-server` for local development.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个静态 `html` 页面，带有 `css`，通过 `http-server` 在本地开发中提供。
- en: Add an `app.ts` file to make a web request to the backend using `fetch` and
    do the required DOM manipulation based on the response.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `app.ts` 文件，使用 `fetch` 向后端发起 Web 请求，并根据响应进行必要的 DOM 操作。
- en: Transpile the `app.ts` file into `app.js` and test against the local server
    using a web browser.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `app.ts` 文件转换为 `app.js` 并使用 Web 浏览器在本地服务器上进行测试。
- en: Make adjustments to `app.ts` and continue testing until all the scenarios are working.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 `app.ts` 并继续测试，直到所有场景都工作。
- en: 'Once you have completed the activity, you should be able to view the form on
    `localhost:8080`. An example is shown here:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成活动后，您应该能够在 `localhost:8080` 上查看表格。这里有一个示例：
- en: '![Figure 12.9: Completed form'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.9：完成后的表格'
- en: '](img/B14508_12_09.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_12_09.jpg](img/B14508_12_09.jpg)'
- en: 'Figure 12.9: Completed form'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9：完成后的表格
- en: Note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor441).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过 [此链接](B14508_Solution_ePub.xhtml#_idTextAnchor441) 获取。
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned how promises came to be a part of the ECMAScript standard, taken
    a tour of the native implementation, and worked through sample projects using
    promises to solve real-world problems. We also explored how TypeScript can enhance
    the promise spec and how we can polyfill promises when targeting environments
    that don't include native promise support. We contrasted the Bluebird promise
    library with native promises. We learned about different ways of interacting with
    the filesystem using Node.js and we also covered managing asynchronous database
    connections and queries. In the end, we put all of this together into a working
    application.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了承诺如何成为 ECMAScript 标准的一部分，参观了原生的实现方式，并通过使用承诺解决实际问题的示例项目进行了实践。我们还探讨了 TypeScript
    如何增强承诺规范，以及如何在目标环境不支持原生承诺支持时进行 polyfill。我们对比了 Bluebird 承诺库与原生承诺。我们了解了使用 Node.js
    与文件系统交互的不同方式，还涵盖了管理异步数据库连接和查询的内容。最后，我们将所有这些内容整合到一个工作应用中。
- en: In the next chapter, we will build upon the asynchronous programming paradigm
    by covering `async` and `await`. We'll discuss when to use these over promises
    and the place promises still have in the TypeScript ecosystem.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过介绍 `async` 和 `await` 来构建异步编程范式。我们将讨论何时使用这些功能而不是承诺，以及承诺在 TypeScript
    生态系统中的位置。
