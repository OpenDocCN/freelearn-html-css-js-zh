- en: Chapter 4. Working with Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 使用事件
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Creating a side-by-side map comparator
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并排地图比较器
- en: Implementing a work in progress indicator for map layers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现地图图层的工作进度指示器
- en: Listening for vector layer features' events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听矢量图层特征的事件
- en: Listening for non-OpenLayers events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听非OpenLayers事件
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is focused on events, which is an important concept in any JavaScript
    program. Although this chapter is brief, the concepts explained here are very
    important to understand when working with OpenLayers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于事件，这是任何JavaScript程序中的重要概念。尽管本章内容简短，但这里解释的概念对于使用OpenLayers来说非常重要。
- en: Events are the heart of JavaScript. They are the impulses that allow us to produce
    a reaction. As programmers of a mapping application, we are interested in reacting
    when the map zoom changes, when a layer is loaded, or when a feature is added
    to a layer. Every class susceptible to emit events is responsible for managing
    its listeners (those interested in being notified when an event is fired) and
    also to emit events under certain circumstances.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是JavaScript的核心。它们是产生反应的冲动。作为地图应用程序的程序员，我们感兴趣的是在地图缩放改变、图层加载或特征被添加到图层时做出反应。任何可能发出事件的类都负责管理其监听器（那些在事件被触发时感兴趣的人）并在某些情况下发出事件。
- en: For example, we can register a function listening for the `zoomend` event on
    the `OpenLayers.Map` instance. Every time the map instance changes its zoom, it
    is responsible to trigger the `zoomend` event, so all its listeners will be notified
    by the new event.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以注册一个函数，监听`OpenLayers.Map`实例上的`zoomend`事件。每当地图实例改变其缩放时，它负责触发`zoomend`事件，因此所有监听器都将通过新事件得到通知。
- en: 'To help in all this process, OpenLayers has the `OpenLayers.Events` class,
    that takes care of registering listeners and simplifying the action of firing
    an event to all of them. In concrete, it allows to:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助完成所有这些过程，OpenLayers有一个`OpenLayers.Events`类，负责注册监听器并简化向所有监听器触发事件的操作。具体来说，它允许：
- en: Define event
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义事件
- en: Register listeners
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册监听器
- en: Trigger events to notify all listeners
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发事件以通知所有监听器
- en: Many classes, such as `OpenLayers.Map` and `OpenLayers.Layer`, have an `events`
    property, which is an instance of `OpenLayers.Events` that takes care of registering
    the listeners interested to be notified on their event.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类，如`OpenLayers.Map`和`OpenLayers.Layer`，都有一个`events`属性，它是一个`OpenLayers.Events`的实例，负责注册对通知感兴趣的事件监听器。
- en: 'In addition, these classes commonly define an `EVENT_TYPES` array property
    (which is constant) and list the available events you can register for that class.
    For example, for the `OpenLayers.Map` class the `EVENT_TYPES` is set as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些类通常定义一个`EVENT_TYPES`数组属性（它是常量）并列出你可以为该类注册的可用事件。例如，对于`OpenLayers.Map`类，`EVENT_TYPES`被设置为以下内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As a programmer you need to look at the OpenLayers API documentation ([http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Map-js.html](http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Map-js.html))
    or you can also refer to the source code to know the available events that you
    can register on each class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你需要查看OpenLayers API文档([http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Map-js.html](http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Map-js.html))，或者你也可以参考源代码以了解可以在每个类上注册的可用事件。
- en: Creating a side-by-side map comparator
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并排地图比较器
- en: We are going to create a map comparator. The goal is to have two maps side-
    by-side from different providers and using some of the events that `OpenLayers.Map`
    instance provides to keep the maps synchronized at the same position and zoom
    level.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个地图比较器。目标是使两个来自不同提供商的地图并排显示，并使用`OpenLayers.Map`实例提供的某些事件来保持地图在相同的位置和缩放级别上同步。
- en: '![Creating a side-by-side map comparator](img/7843_ch04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![创建并排地图比较器](img/7843_ch04_01.jpg)'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To have two maps side-by-side, perform the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使两个地图并排显示，请执行以下步骤：
- en: Start creating an HTML with OpenLayers library dependency.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建一个带有OpenLayers库依赖的HTML。
- en: 'Now, add the HTML code required to have two maps side-by-side. Here we are
    using a table with a row and two columns:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加所需的HTML代码以使两个地图并排显示。这里我们使用一个带有行和两列的表格：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's write the JavaScript code. Create the two maps and initialize with
    the desired image provider. Here we have used `OpenStreetMap` and `Bing:`
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写JavaScript代码。创建两个地图并使用期望的图像提供者进行初始化。这里我们使用了`OpenStreetMap`和`Bing:`
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, register the `move` and `zoomend` events on both layers:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在两个图层上注册`move`和`zoomend`事件：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, implement the `listener` functions that are called every time an event
    occurs:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现每次事件发生时被调用的`listener`函数：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To keep the two maps always in synchronization at the same position and zoom
    level, we need to know when the map has moved and when the zoom level has changed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使两个地图始终在相同的位置和缩放级别上保持同步，我们需要知道地图何时移动以及缩放级别何时改变。
- en: The `move` event is triggered every time the map is moved. Additionally, there
    are the `movestart` and `moveend` events, which are fired only when the `move`
    action starts or ends, but they are not useful here because we need to catch every
    movement.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`move`事件在每次地图移动时都会触发。此外，还有`movestart`和`moveend`事件，它们只在`move`动作开始或结束时触发，但在这里它们并不有用，因为我们需要捕捉到每一次移动。'
- en: The `zoomend` event is triggered when the map's zoom level changes. So, how
    can we listen for events in the map? This is achieved through the `events` property,
    which is an instance of `OpenLayers.Events`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当地图的缩放级别改变时，会触发`zoomend`事件。那么，我们如何监听地图中的事件呢？这是通过`events`属性实现的，它是一个`OpenLayers.Events`的实例。
- en: There are two ways (really there is also a third one that we will see in the
    *There's more* section) to register event listeners for the map events—using the
    `on` or the `register` methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式（实际上还有第三种，我们将在*还有更多*部分看到）来注册地图事件的监听器——使用`on`或`register`方法。
- en: 'On the first map, we have used the `on` method to register multiple events
    at once:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一张地图上，我们使用了`on`方法一次性注册多个事件：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `on` method requires an object in which its properties' names are the event
    names and the values are the listener functions to be called when events are triggered.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`on`方法需要一个对象，其中其属性的名称是事件名称，值是在事件触发时被调用的监听函数。'
- en: The `on` method accepts a special property called `scope`. This allows us to
    register all the specified events to be executed within the same context. That
    is, when the `listener` function is executed, the `this` keyword will point to
    the object specified in the `scope` property.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`on`方法接受一个特殊属性，称为`scope`。这允许我们将所有指定的事件注册为在相同的上下文中执行。也就是说，当`listener`函数执行时，`this`关键字将指向`scope`属性中指定的对象。'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Contexts can be an advanced topic for someone who has just initiated in JavaScript.
    An interesting conversation can be found at [http://stackoverflow.com/questions/1798881/javascript-context](http://stackoverflow.com/questions/1798881/javascript-context).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始学习JavaScript的人来说，上下文可能是一个高级话题。一个有趣的讨论可以在[http://stackoverflow.com/questions/1798881/javascript-context](http://stackoverflow.com/questions/1798881/javascript-context)找到。
- en: 'In the second map, we have used the `register` method, which allows us to register
    an event listener one at a time:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二张地图上，我们使用了`register`方法，它允许我们一次注册一个事件监听器：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `events.register()` function accepts four parameters:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`events.register()`函数接受四个参数：'
- en: '`type:` This is the event we want to listen for.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type:` 这是我们要监听的事件。'
- en: '`object:` This is the context where the function is executed (similar to the
    `scope` property in the `on` method).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:` 这是函数执行的环境（类似于`on`方法中的`scope`属性）。'
- en: '`function:` This is the function to be executed when the event is triggered.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function:` 这是事件触发时要执行的功能。'
- en: '`priority:` This is a Boolean value. If it is `true`, the listener is queued
    at the front of the event''s queue instead of at the end.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority:` 这是一个布尔值。如果它是`true`，则监听器将在事件队列的前端排队，而不是在末尾。'
- en: Now, we will be notified for any `move` or `zoomend` event that any of the two
    maps will produce.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将被通知任何两个地图产生的`move`或`zoomend`事件。
- en: 'It is important to note that OpenLayers event''s mechanism always calls the
    `listener` function by passing an `event` parameter. This `event` object contains
    any information that is written by the `source` object that triggers the event,
    plus the following three properties that are always added automatically:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，OpenLayers事件机制总是通过传递一个`event`参数来调用`listener`函数。这个`event`对象包含由触发事件的`source`对象编写的任何信息，以及以下三个总是自动添加的属性：
- en: '`type:` Contains the event name (move, `zoomend`, and so on)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type:` 包含事件名称（移动、`zoomend`等）'
- en: '`object:` Points to the object that fires the event'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object:` 指向触发事件的对象'
- en: '`element:` The `DOM` element related to the event'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element:` 与事件相关的`DOM`元素'
- en: 'Let''s take a look at our listener functions. The `moveListener` function checks
    which map has fired the event, then gets the map''s `center`, and assigns the
    same `center` to the other map:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的监听器函数。`moveListener`函数检查哪个地图触发了事件，然后获取地图的`center`，并将相同的`center`分配给另一个地图：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we can get a reference to the map that triggers the event with
    `event.object.`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以通过`event.object.`获取触发事件的地图的引用。
- en: Similarly, the `zoomListener` function gets the zoom level on the source event
    map and applies it on the other map.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`zoomListener`函数获取源事件地图上的缩放级别，并将其应用于另一个地图。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Bing maps have different resolution levels on their imagery than `OpenStreetMap`.
    We can say it differs by one zoom level with respect to other imagery providers
    because we are adding or subtracting this to/from the zoom level.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Bing地图在其影像上具有与`OpenStreetMap`不同的分辨率级别。我们可以这样说，与其他影像提供商相比，它相差一个缩放级别，因为我们是在添加或从缩放级别中减去这个值。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: As we can be interested in listening events, in the same way, we can also be
    interested in stopping the notifications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以对监听事件感兴趣一样，我们也可以对停止通知感兴趣。
- en: The `OpenLayers.Events` class has the `un` and `unregister` methods, which allow
    us to unregister our listener functions from notifying when certain events are
    triggered.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Events`类有`un`和`unregister`方法，允许我们在某些事件被触发时注销我们的监听器函数。'
- en: 'Similar to the `on` method, the `un` method allows to unregister multiple listeners,
    while the `unregister` method allows to unregister only one listener at a time.
    Taking this recipe as a sample, we could unregister events on maps as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与`on`方法类似，`un`方法允许注销多个监听器，而`unregister`方法允许一次注销一个监听器。以这个配方为例，我们可以在地图上注销事件如下：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another way to register an event listener
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注册事件监听器的另一种方法
- en: In addition to the `on` and `register` methods, there is a third way to register
    event listeners.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`on`和`register`方法之外，还有第三种注册事件监听器的方法。
- en: 'When creating `OpenLayers.Map, OpenLayers.Layer`, and `OpenLayers.Control`
    instances, we can use the `eventListeners` property, in the same way as we use
    the `on` method to register a set of listeners. For example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`OpenLayers.Map`、`OpenLayers.Layer`和`OpenLayers.Control`实例时，我们可以使用`eventListeners`属性，就像我们使用`on`方法来注册一组监听器一样。例如：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What really happens is the object passed to the `eventListener` property is
    directly used to initialize the listeners by using the `on` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的情况是传递给`eventListener`属性的对象直接通过`on`方法用来初始化监听器。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using Bing imagery* recipe in [Chapter 2](ch02.html "Chapter 2. Adding
    Raster Layers"), *Adding Raster Layers*
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。添加栅格图层")的*使用Bing影像*配方中，*添加栅格图层*
- en: The *Implementing a work in progress indicator for map layers* recipe
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现地图图层的工作进度指示器*的配方'
- en: The *Listening for vector layer features' events* recipe
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监听矢量图层事件*的配方'
- en: Implementing a work in progress indicator for map layers
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现地图图层的工作进度指示器
- en: In the art of creating great applications, the most important thing to take
    into account is the user experience. A good application does what it must do,
    but by making the user feel comfortable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建优秀应用程序的艺术中，最重要的考虑因素是用户体验。一个好的应用程序完成它必须做的事情，但通过让用户感到舒适。
- en: When working with remote server, most of the time the user is waiting for data
    retrieval. For example, when working with a WMS layer, every time we change the
    zoom level, the user has to wait for some seconds till data is obtained from the
    server and the tiles start rendering.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当与远程服务器一起工作时，大多数时间用户都在等待数据检索。例如，当与WMS图层一起工作时，每次我们更改缩放级别，用户都必须等待几秒钟，直到从服务器获取数据并且瓦片开始渲染。
- en: It would be great to show some feedback to the users by using an icon, a progress
    bar, and so on, to inform that the application is working but needs some time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用图标、进度条等来向用户显示一些反馈，告知应用程序正在工作但需要一些时间，这将非常棒。
- en: This recipe shows how we can give some feedback to the user by informing when
    the application is loading content from different servers, making use of some
    layer events.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了我们如何通过通知应用程序正在从不同的服务器加载数据，利用一些图层事件，来给用户一些反馈。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like in many other recipes in this book, we have used the Dojo toolkit framework
    ([http://dojotoolkit.org](http://dojotoolkit.org)) for a better user experience.
    The main difference we can see is that a basic HTML page is the set of rich widgets
    (buttons, toolbar, progress bar, and so on) it offers. Do not worry if something
    on the HTML page is not clear, the goal of the book is not teaching Dojo, and
    that does not alter the explanations about OpenLayers concepts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在这本书的许多其他配方中一样，我们使用了Dojo工具包框架([http://dojotoolkit.org](http://dojotoolkit.org))来提供更好的用户体验。我们可以看到的主要区别是，一个基本的HTML页面是它提供的丰富小部件（按钮、工具栏、进度条等）的集合。如果HTML页面上的某些内容不清楚，请不要担心，这本书的目标不是教授Dojo，这不会改变对OpenLayers概念的说明。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create an HTML file with OpenLayers dependency.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含OpenLayers依赖项的HTML文件。
- en: First we are going to add the HTML code required to show a progress bar. Note
    how simply it can be created by using the Dojo framework. Tag a normal `span`
    element with the `data-dojo-type` and `data-dojo-props` attributes.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加显示进度条的HTML代码。注意它如何通过使用Dojo框架简单创建。使用`data-dojo-type`和`data-dojo-props`属性标记一个普通的`span`元素。
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As always, place the `div` element to hold the map:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，放置`div`元素以容纳地图：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For starting the JavaScript section code, we need to take into account that
    we are requesting features from a remote WFS server, because this is the first
    thing we need to do for setting the proxy URL to be used:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于开始JavaScript部分代码，我们需要考虑到我们正在从远程WFS服务器请求功能，因为这是我们需要做的第一件事来设置要使用的代理URL：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, create the map and two layers—a WMS layer, which is the base layer, and
    a WFS layer:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建地图和两个图层——一个WMS图层，它是基础图层，和一个WFS图层：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a layer switcher control and centralize the map:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加图层切换控件并集中地图：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Register event listeners on WMS and WFS layers:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在WMS和WFS图层上注册事件监听器：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, implement the listener function to show the progress bar when any
    of the two layers is loading its content:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现监听函数，以便在两个图层中的任何一个加载其内容时显示进度条：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After creating the map and the two layers, register our listener functions
    for the events `loadstart, loadend`, and `loadcancel` on both layers:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建地图和两个图层之后，在两个图层上注册我们的监听函数，用于事件`loadstart, loadend`和`loadcancel`：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These are common events to all layers, because they are inherited from the `OpenLayers.Layer`
    class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是所有图层都有的常见事件，因为它们是从`OpenLayers.Layer`类继承而来的。
- en: The `loadstart` event is triggered when the layer starts the process of loading
    data, while `loadend` or `loadcancel` are triggered because the process ends or
    is canceled.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当图层开始加载数据时，会触发`loadstart`事件，而`loadend`或`loadcancel`则会在过程结束或被取消时触发。
- en: With this in mind, the cumbersome `updateLoader` listener function is responsible
    for showing an indeterminate progress bar with a text message when any of the
    two layers is loading data. The text message can be WMS, WFS, or WMS WFS, depending
    on the layers that are loading the content.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，繁琐的`updateLoader`监听函数负责在两个图层中的任何一个加载数据时显示一个不确定的进度条和文本消息。文本消息可以是WMS、WFS或WMS
    WFS，具体取决于正在加载内容的图层。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: As we mentioned earlier, the events used in this recipe are common for all layers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个配方中使用的这些事件对所有图层都是通用的。
- en: Concrete subclasses of the `OpenLayers.Layer` class can have their own events,
    as in the case of `OpenLayers.Layer.Vector` that has events to notify when features
    are added, removed, and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Layer`类的具体子类可以有自己的事件，例如`OpenLayers.Layer.Vector`，它有事件来通知特征被添加、删除等情况。'
- en: See also
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding WMS layer* recipe in [Chapter 2](ch02.html "Chapter 2. Adding Raster
    Layers"), *Adding Raster Layers*
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。添加栅格图层")中的*添加WMS图层*配方，*添加栅格图层*'
- en: The *Adding features from a WFS server* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Working with Vector Layers*
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从WFS服务器添加功能](ch03.html "第3章。处理矢量图层")中的*从WFS服务器添加功能*配方，*处理矢量图层*'
- en: The *Creating a side-by-side map comparator* recipe
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建并排地图比较器*的配方'
- en: The *Listening for vector layer features' events* recipe
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监听矢量图层特征事件*的配方'
- en: Listening for vector layer features' events
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听矢量图层特征事件
- en: When working with vector layers, it is common to find a situation where you
    need to know what is happening, that is, when a new feature is going to be added
    to the layers or when a feature has been modified, deleted, and so on. Fortunately,
    vector layer has the capability to trigger a great fan of events.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当与矢量层一起工作时，通常会遇到需要了解正在发生什么的情况，即当新特征即将被添加到层中或特征已被修改、删除等情况。幸运的是，矢量层具有触发大量事件的能力。
- en: The goal of this recipe is to show how easy it is to listen for events in a
    vector layer and know what is happening on it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的目标是展示在矢量层中监听事件是多么容易，以及了解其上正在发生什么。
- en: We are going to load a GML file with some cities around the world, and we will
    style its fill color depending on some feature attribute.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载一个包含世界各地一些城市的 GML 文件，并根据某些特征属性设置其填充颜色。
- en: '![Listening for vector layer features'' events](img/7843_ch04_04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![监听矢量层特征事件](img/7843_ch04_04.jpg)'
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create an HTML file and add the OpenLayers library dependency files. Then,
    add a `div` element to define where to hold the map instance:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 HTML 文件并添加 OpenLayers 库的依赖文件。然后，添加一个 `div` 元素来定义放置地图实例的位置：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Initialize the map instance, add a base layer, and centralize the viewport:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化地图实例，添加基本层，并中央化视口：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a vector layer to read a GML file. Also, initialize it by registering
    an event listener for the `beforefeatureadded` event:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个矢量层来读取 GML 文件。同时，通过注册一个监听 `beforefeatureadded` 事件的监听器来初始化它：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Write the code for the listener function. Define a color palette that assigns
    a fill color to every feature depending on the `POP_RANK` attribute:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写监听函数的代码。定义一个颜色方案，根据 `POP_RANK` 属性为每个特征分配填充颜色：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'After initializing the map and the base layer, we have to create a vector layer:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化地图和基本层之后，我们必须创建一个矢量层：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As a protocol, we are using the `OpenLayers.Protocol.HTTP` instance that will
    get data from the specified URL, via HTTP protocol and will read it by using the
    `OpenLayers.Format.GeoJSON` format reader.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种协议，我们使用 `OpenLayers.Protocol.HTTP` 实例，它将通过 HTTP 协议从指定的 URL 获取数据，并使用 `OpenLayers.Format.GeoJSON`
    格式读取器读取它。
- en: The vector layer uses `OpenLayers.Strategy.Fixed`, which means the content is
    loaded only once, no matter whether we move the map's viewport or not.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量层使用 `OpenLayers.Strategy.Fixed`，这意味着无论我们是否移动地图的视口，内容都只加载一次。
- en: There are some ways to register the event listeners. One of those ways is using
    the `on` or `register` methods, but we have chosen to register the event listener
    at the same time when we initialize the layer by using the `eventListener` property.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以注册事件监听器。其中一种方法是通过 `on` 或 `register` 方法，但我们选择在初始化层时使用 `eventListener`
    属性同时注册事件监听器。
- en: 'This way, every time when a feature is going to be added to the layer (before
    it was added), the listener function will be called by receiving an `event` object
    as a parameter, with some information related to the layer''s event:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每次当特征即将被添加到层中（在它被添加之前），监听函数都会被调用，并接收一个作为参数的 `event` 对象，其中包含与层事件相关的某些信息：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From the event, we can get a reference to the feature and its attributes. Here
    we are using the `POP_RANK` attribute to select the fill color of the feature.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件中，我们可以获取到特征及其属性的引用。在这里，我们使用 `POP_RANK` 属性来选择特征的填充颜色。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about the feature style properties, which we can change, is
    available at [http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Feature/Vector-js.html#OpenLayers.Feature.Vector.OpenLayers.Feature.Vector.style](http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Feature/Vector-js.html#OpenLayers.Feature.Vector.OpenLayers.Feature.Vector.style).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们可以更改的特征样式属性，更多信息请参阅 [http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Feature/Vector-js.html#OpenLayers.Feature.Vector.OpenLayers.Feature.Vector.style](http://dev.openlayers.org/releases/OpenLayers-2.11/doc/apidocs/files/OpenLayers/Feature/Vector-js.html#OpenLayers.Feature.Vector.OpenLayers.Feature.Vector.style)。
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In this recipe, we can use the `OpenLayers.Util.extend` method to set the initial
    style of the feature and then set the desired fill color:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们可以使用 `OpenLayers.Util.extend` 方法设置特征的初始样式，然后设置所需的填充颜色：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `OpenLayers.Util.extend` method requires two parameters—the destination
    and the source objects. Its function is to copy all the properties found in the
    source object to the destination.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Util.extend` 方法需要两个参数——目标和源对象。其功能是将源对象中找到的所有属性复制到目标对象。'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `OpenLayers.Util.extend` method is very important to create hierarchy and
    inheritance in OpenLayers. However, its namespace is `OpenLayers.Util` and it
    is located in the `OpenLayers/BaseTypes/Class.js` file, which talks about its
    importance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Util.extend` 方法对于在 OpenLayers 中创建层次结构和继承非常重要。然而，它的命名空间是 `OpenLayers.Util`，它位于
    `OpenLayers/BaseTypes/Class.js` 文件中，该文件讨论了其重要性。'
- en: On the other hand, `OpenLayers.Feature.Vector.style` is an object with some
    predefined styles for features such as `default, selected, delete`, and so on.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`OpenLayers.Feature.Vector.style` 是一个对象，其中包含一些预定义的样式，如 `default, selected,
    delete` 等。
- en: So, the preceding line means that a new object extending an empty object with
    all the properties in the `OpenLayers.Feature.Vector.style['default']` object
    can be created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的行意味着可以创建一个新的对象，它扩展了一个空对象，并包含 `OpenLayers.Feature.Vector.style['default']`
    对象中的所有属性。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Styling features using symbolizers* recipe in [Chapter 7](ch07.html "Chapter 7. Styling
    Features"), *Styling Features*
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用符号化器设置要素样式* 策略在 [第 7 章](ch07.html "第 7 章。设置要素样式")，*设置要素样式*'
- en: The *Adding a GML layer* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Working with Vector Layers.*
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。处理矢量层") 的 *添加 GML 层* 策略中，*处理矢量层*
- en: The *Creating a side-by-side map comparator* recipe
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建并排地图比较器* 策略'
- en: The *Listening for non-OpenLayers events* recipe
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监听非 OpenLayers 事件* 策略'
- en: Listening for non-OpenLayers events
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听非 OpenLayers 事件
- en: When developing a web mapping application, the use of OpenLayers is only a piece
    among the set of tools that we need to use. Adding other components, such as buttons,
    images, lists, and so on, and interacting with them are other tasks that we must
    work on.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发网络地图应用时，OpenLayers 的使用只是我们需要使用的工具集中的一个部分。添加其他组件，如按钮、图片、列表等，并与它们交互是其他我们必须完成的任务。
- en: Interacting with a `OpenLayers.Map` instance or `OpenLayers.Layer` subclass
    is easy because they trigger specific events, but what if we want to listen for
    events on a button or any `DOM` element?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `OpenLayers.Map` 实例或 `OpenLayers.Layer` 子类交互很简单，因为它们会触发特定的事件，但如果我们想在按钮或任何
    `DOM` 元素上监听事件怎么办呢？
- en: For this purpose, OpenLayers offers us the `OpenLayers.Event` class (do not
    get confused with the plural `OpenLayers.Events` class). This is a helper class,
    which, among other things, allows us to listen for events in non-OpenLayers elements
    in a browser-independent way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，OpenLayers 为我们提供了 `OpenLayers.Event` 类（不要与复数 `OpenLayers.Events` 类混淆）。这是一个辅助类，它允许我们在浏览器无关的方式下监听非
    OpenLayers 元素中的事件。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately the way to register event listeners in JavaScript is not the same
    in all browsers. Also, Microsoft differs from W3C (the WWW Consortium) in the
    way to register listeners. You can find more information at [http://www.quirksmode.org/js/events_advanced.html](http://www.quirksmode.org/js/events_advanced.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在 JavaScript 中注册事件监听器的方法在所有浏览器中并不相同。此外，Microsoft 与 W3C（万维网联盟）在注册监听器的方式上有所不同。你可以在
    [http://www.quirksmode.org/js/events_advanced.html](http://www.quirksmode.org/js/events_advanced.html)
    找到更多信息。
- en: If your project uses a library or framework such as jQuery, Dojo, or ExtJS,
    you will probably use their features to access DOM elements, register for events,
    and so on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目使用 jQuery、Dojo 或 ExtJS 等库或框架，你可能会使用它们的功能来访问 DOM 元素、注册事件等。
- en: If you are working on a simpler project without the aforementioned libraries,
    it is a good idea to register events through the `OpenLayers.Event` class, because
    it is browser-independent, which means your application will be compatible with
    more browsers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理一个没有上述库的更简单的项目，通过 `OpenLayers.Event` 类注册事件是一个好主意，因为它与浏览器无关，这意味着你的应用程序将与更多浏览器兼容。
- en: In addition, there is one more reason to read this recipe and the reason is
    that OpenLayers uses the `OpenLayers.Event` class internally to implement many
    handlers and controls, which we will see in the future chapters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个原因要阅读这个策略，那就是 OpenLayers 使用 `OpenLayers.Event` 类来内部实现许多处理程序和控制，我们将在未来的章节中看到。
- en: Let's have a look at how we can listen for events on HTML elements through the
    `OpenLayers.Event` class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过 `OpenLayers.Event` 类在 HTML 元素上监听事件。
- en: '![Listening for non-OpenLayers events](img/7843_ch04_02.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![监听非 OpenLayers 事件](img/7843_ch04_02.jpg)'
- en: The idea is to create six buttons and add six point features to a vector layer.
    Then highlight the feature when mouse enters a button or unselect if mouse leaves
    it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是创建六个按钮，并将六个点要素添加到矢量层中。然后当鼠标进入按钮时突出显示要素，当鼠标离开时取消选择。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To listen for non-OpenLayers events, follow the next steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要监听非 OpenLayers 事件，请按照以下步骤操作：
- en: 'Create an HTML with OpenLayers library dependency. Start adding some CSS styles
    for the buttons. The following code defines a style when the buttons are not selected
    (the mouse is out) and also a style with different background color when mouse
    is hovered over the buttons:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有 OpenLayers 库依赖的 HTML。开始为按钮添加一些 CSS 样式。以下代码定义了当按钮未被选中（鼠标不在上面）时的样式，以及当鼠标悬停在按钮上时具有不同背景色的样式：
- en: '[PRE26]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a table to hold the six buttons. A button will be represented by a `span`
    element with an identifier:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表格来存放六个按钮。一个按钮将由一个带有标识符的 `span` 元素表示：
- en: '[PRE27]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add a `div` element to hold the map:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `div` 元素来存放地图：
- en: '[PRE28]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, add the JavaScript code required to instantiate the map object, set a
    base layer, and add a vector layer:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加所需的 JavaScript 代码以实例化地图对象，设置基本图层，并添加矢量图层：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Populate the vector layer with six features. Each one will contain the identifier
    of the button that represents it:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用六个特征填充矢量图层。每个特征都将包含代表它的按钮的标识符：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, add the code that implements the event listeners:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加实现事件监听器的代码：
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have created six buttons, identified from `f0` to `f5`, and we want to create
    six features that represent them. To do this, in the `for` loop, first we create
    a string with an identifier:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了六个按钮，从 `f0` 到 `f5` 进行标识，我们想要创建六个代表它们的特征。为此，在 `for` 循环中，首先创建一个带有标识符的字符串：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, register an event listener function for the `mouseover` and `mouseout`
    events:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为 `mouseover` 和 `mouseout` 事件注册一个事件监听器函数：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is done by using the `OpenLayers.Event.observe` method, which requires
    three parameters. These parameters are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用 `OpenLayers.Event.observe` 方法实现的，它需要三个参数。这些参数如下：
- en: '`elementParam:` The `DOM` element reference, or its identifier, which we want
    to listen to for `tis` events'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementParam:` 我们想要监听 `tis` 事件的 `DOM` 元素引用或其标识符'
- en: '`name:` The event you want to listen to'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name:` 你想要监听的事件'
- en: '`observer:` The function that will act as a listener'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observer:` 将作为监听器的函数'
- en: Because we need to pass the `DOM` element reference, we need to get it first.
    To get an element reference when its identifier is available, we can use the helper
    method `OpenLayers.Util.getElement`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要传递 `DOM` 元素引用，所以我们需要先获取它。当其标识符可用时，我们可以使用辅助方法 `OpenLayers.Util.getElement`
    来获取元素引用。
- en: 'From the `elementParam` definition, you can see that the use of `OpenLayers.Util.getElement`
    is not strictly necessary. If we pass an ID, the `OpenLayers.Event.observe` method
    will internally use the `OpenLayers.Util.getElement` function to get the element
    reference, so the next two lines will have the same result:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `elementParam` 定义中，你可以看到使用 `OpenLayers.Util.getElement` 并不是严格必要的。如果我们传递一个
    ID，`OpenLayers.Event.observe` 方法将内部使用 `OpenLayers.Util.getElement` 函数来获取元素引用，所以接下来的两行将产生相同的结果：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `OpenLayers.Util` class has plenty of methods to help in working with the
    `DOM` elements, arrays, and many more functions. We encourage you to take a look.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenLayers.Util` 类有许多方法可以帮助处理 `DOM` 元素、数组以及许多其他功能。我们鼓励您查看。'
- en: 'Once the listeners are registered, we create a random point feature and add
    it to the vector layer:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注册了监听器，我们创建一个随机点功能并将其添加到矢量图层：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Remember to transform the point coordinates to the projection used by the map.
    In this case, because the base layer is OSM and the map has no specified projection
    property, the OSM projection will be used:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要将点坐标转换为地图使用的投影。在这种情况下，因为基本图层是 OSM，并且地图没有指定投影属性，所以将使用 OSM 投影：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have created the feature by passing a custom attribute `elem_id`, which will
    store the identifier of the button that represents the feature. This way we have
    a reference to connect the feature and the button.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递一个自定义属性 `elem_id` 创建了这个功能，该属性将存储代表该功能的按钮的标识符。这样我们就有了一个连接功能和按钮的引用。
- en: 'The following screenshot shows how custom attributes are stored within the
    feature `attributes` property:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了自定义属性是如何存储在功能的 `attributes` 属性中的：
- en: '![How it works...](img/7843_ch04_03.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7843_ch04_03.jpg)'
- en: At this point we have six buttons and six features, which store the corresponding
    button identifiers as the custom attributes. Now, the task is to implement the
    listener function. Let's have a look at the `mouseOverListener` function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了六个按钮和六个功能，它们将相应的按钮标识符作为自定义属性存储。现在，任务是实现监听器函数。让我们看看 `mouseOverListener`
    函数。
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'From the event, which is a browser `MouseEvent`, we get the identifier of the
    target element that has triggered the event:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件，它是一个浏览器 `MouseEvent`，我们获取触发事件的元素标识符：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, using the `OpenLayers.Layers.Vector.getFeatureByAttribute` method, we
    get an array of features within the vector layer that has the `elem_id` with the
    value `id`. Of course, here it will always return an array with only one element:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `OpenLayers.Layers.Vector.getFeatureByAttribute` 方法，我们获取具有 `elem_id`
    值 `id` 的矢量层内的特征数组。当然，这里它将始终返回只包含一个元素的数组：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we have the feature. Simply redraw it with a different render intent.
    Select to highlight the feature as selected and put its style back to default:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了特征。只需用不同的渲染意图重新绘制它。选择突出显示选定的特征并将其样式恢复到默认值：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will see more about styling features in [Chapter 7](ch07.html "Chapter 7. Styling
    Features"), *Styling Features*. Meanwhile, consider render intents as predefined
    styles to render features.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 7 章](ch07.html "第 7 章。样式化特征") 的 *样式化特征* 中了解更多关于样式化特征的内容。同时，考虑将渲染意图作为预定义样式来渲染特征。
- en: There's more...
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: OpenLayers defines a global variable `$`, which points to the `OpenLayers.Util.getElement`
    function, if it does not exist. This way we can get a reference to an element
    in a short way.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLayers 定义了一个全局变量 `$`，它指向 `OpenLayers.Util.getElement` 函数，如果它不存在。这样我们就可以以简短的方式获取一个元素的引用。
- en: 'For example, the next two lines have the same result:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面两行有相同的结果：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Be careful with the use of the `$` function. Many JavaScript libraries, one
    of the most known is jQuery library ([http://jquery.com](http://jquery.com)),
    also define the global `$` object as a common way to operate with it. So, check
    twice the order in which you have imported libraries on your application and where
    the `$` function really points.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `$` 函数时要小心。许多 JavaScript 库，其中最著名的是 jQuery 库 ([http://jquery.com](http://jquery.com))，也将全局
    `$` 对象定义为操作它的常用方式。因此，请检查你应用程序中导入库的顺序以及 `$` 函数真正指向的位置。
- en: 'As a curiosity, while getting an element reference by its identifier with `OpenLayers.Util.getElement`
    written:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种好奇，当通过 `OpenLayers.Util.getElement` 函数根据其标识符获取元素引用时：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'jQuery library requires you to use the `#` character:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库要求你使用 `#` 字符：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Stop observing
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 停止观察
- en: We can be interested in observing some event, in the same way, we can also have
    a desire to stop observing it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能对观察某些事件感兴趣，同样，我们可能也希望停止观察它。
- en: Similar to the `OpenLayers.Event.observe` method, given an element reference
    or a string identifier, the `OpenLayers.Event.stopObservingElement` method allows
    us to stop observing some `DOM` element.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `OpenLayers.Event.observe` 方法类似，给定一个元素引用或一个字符串标识符，`OpenLayers.Event.stopObservingElement`
    方法允许我们停止观察某些 `DOM` 元素。
- en: See also
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating features programmatically* recipe in [Chapter 3](ch03.html "Chapter 3. Working
    with Vector Layers"), *Working with Vector Layers*
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。处理矢量层") 的 *程序化创建特征* 菜单，*处理矢量层*
- en: The *Styling features using symbolizers* recipe in [Chapter 7](ch07.html "Chapter 7. Styling
    Features"), *Styling Features*
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 7 章](ch07.html "第 7 章。使用符号化样式化特征") 的 *使用符号化样式化特征* 菜单，*样式化特征*
- en: The *Creating a side-by-side map comparator* recipe
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建并排地图比较器* 菜单'
- en: The *Listening for vector layer features' events* recipe
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监听矢量层特征事件* 菜单'
