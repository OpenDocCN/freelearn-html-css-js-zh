- en: Chapter 3. Module Design Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 模块设计模式
- en: Now that we have reviewed some important JavaScript OOP concepts in the previous
    chapter, we are going to leverage some of the techniques discussed to create modules
    and start using them in our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了上一章中的一些重要的JavaScript OOP概念，我们将利用其中讨论的一些技术来创建模块，并开始在应用程序中使用它们。
- en: You are probably familiar with the term **design pattern**, which is essentially
    a way of structuring code as a reusable solution for common programming problems.
    In this chapter, we are going to focus on a particular design pattern in JavaScript
    called **module pattern**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉**设计模式**这个术语，它本质上是一种将代码结构化为可重用解决方案的方法，用于解决常见的编程问题。在本章中，我们将专注于JavaScript中称为**模块模式**的特定设计模式。
- en: We will explore how we can create simple modules using this pattern and then
    we will build upon these modules to create our application's modules in the following
    chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用此模式创建简单的模块，然后在接下来的章节中，我们将基于这些模块创建我们应用程序的模块。
- en: Module pattern is one of the most frequently used patterns in JavaScript for
    creating modular applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式是JavaScript中用于创建模块化应用程序最常用的模式之一。
- en: 'Some of the topics that we will discuss in this chapter are:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Structure of module pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块模式的结构
- en: Internal private scope in module pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块模式中的内部私有作用域
- en: How to create simple modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建简单的模块
- en: How to create a module factory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建模块工厂
- en: Module pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块模式
- en: In the previous chapter, we had a look at how we can create private variables
    and namespaces inside functions. We also explored how private scopes can be implemented.
    Some concepts related to private scopes can also be applied to **singleton** objects
    residing inside functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了如何在函数内部创建私有变量和命名空间。我们还探讨了如何实现私有作用域。与私有作用域相关的一些概念也可以应用于函数内部的**单例**对象。
- en: A singleton object is an object there will only ever be one instance of it in
    the application. Singleton objects can be created using object literal notation,
    which we saw examples of in the previous chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单例对象是一个在应用程序中只会存在一个实例的对象。单例对象可以使用对象字面量表示法创建，我们已经在上一章中看到了一些例子。
- en: 'Consider the following object definition:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下对象定义：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While the preceding object does not do anything, it is in fact a valid object
    and there can only be one instance of this object as we cannot create other objects
    based on `mySingletonObj`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的对象没有做任何事情，但实际上它是一个有效的对象，并且由于我们不能基于`mySingletonObj`创建其他对象，因此这个对象只能有一个实例。
- en: 'Let''s add some value properties and methods (method properties) to this object
    and see how we can access such properties outside of the object definition:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给这个对象添加一些值属性和方法（方法属性），看看我们如何从对象定义外部访问这些属性：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the above object definition, we have created a singleton object with four
    properties. Two of them are value properties and two are method properties.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述对象定义中，我们创建了一个具有四个属性的单例对象。其中两个是值属性，两个是方法属性。
- en: Our method properties have access to our value properties and return their values.
    However, we can also directly access the object's properties and even override
    their values from outside of the object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法属性可以访问我们的值属性，并返回它们的值。然而，我们也可以直接访问对象的属性，甚至可以从对象外部覆盖它们的值。
- en: 'Have a look at the following code snippet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码片段：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This shows that, while we have encapsulation (I am using the term loosely here)
    in our code, we do not have access control and the external code can change the
    values of the properties in our object. This at times, is undesirable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，尽管我们的代码中存在封装（我在这里使用这个术语比较宽松），但我们没有访问控制权，外部代码可以更改我们对象中属性的值。有时，这是不希望的。
- en: Let's re-factor our code and create a simple module, using the module pattern.
    This will help us implement encapsulations as well as access control in our singleton
    object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的代码，使用模块模式创建一个简单的模块。这将帮助我们实现封装以及在我们的单例对象中实现访问控制。
- en: 'Consider the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have created an **Immediately Invoked Function Expression**
    (**IIFE**) and have assigned its return value (which is a singleton object) to
    the variable `mySingletonObj`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个**立即执行函数表达式**（**IIFE**），并将其返回值（即单例对象）赋值给变量`mySingletonObj`。
- en: The returned singleton object has two methods that have access to the private
    variables of the container function and return their related values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的单例对象有两个方法可以访问容器函数的私有变量并返回相关的值。
- en: 'If we try to access the function variables directory from the returned object
    such as:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从返回的对象中访问函数变量目录，例如：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are unable to do so. This is because the `name` property is a private property
    of the container function and it does not exist on the returned anonymous object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法这样做。这是因为`name`属性是容器函数的私有属性，它不存在于返回的匿名对象上。
- en: However, we can access this property through the privileged method `getName`,
    which is defined on the singleton object returned by our IIFE.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过特权的`getName`方法访问这个属性，该方法定义在我们IIFE返回的单例对象上。
- en: 'As the `mySingletonObj` variable has a reference to this singleton object,
    if we execute the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`mySingletonObj`变量引用了这个单例对象，如果我们执行以下代码：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are able to access the value assigned to the `name` property of the function.
    Note that the singleton object returned from the IIFE still has access to the
    context of the anonymous function that contains it. This is possible because we
    have created a closure here. Of course, the same applies to the `title` property
    of the function as seen here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够访问分配给函数`name`属性的值。请注意，从IIFE返回的单例对象仍然可以访问包含它的匿名函数的上下文。这是可能的，因为我们在这里创建了一个闭包。当然，这里看到的函数的`title`属性也是如此：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This approach of structuring our code in such a way that a returned singleton
    object from inside a function provides access to the private members (internal
    private scope) of the container function object) is what forms the basis of module
    pattern in JavaScript.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将我们的代码结构化为从函数内部返回的单例对象提供对容器函数对象私有成员（内部私有作用域）访问的方法，是JavaScript中模块模式的基础。
- en: Internal private scope in module pattern
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块模式中的内部私有作用域
- en: Module pattern enables us to create a private scope for our code inside a function
    while providing controlled access to such a private scope through an interface.
    This interface can be in the form of a returned singleton object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式使我们能够在函数内部为我们的代码创建一个私有作用域，同时通过接口提供对这样一个私有作用域的受控访问。这个接口可以是返回的单例对象的形式。
- en: In the code example in the previous section, `mySingletonObj` is the interface
    to the private scope of our IIFE.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中的代码示例中，`mySingletonObj`是访问我们IIFE私有作用域的接口。
- en: What happens if we add another property to `mySingletonObj` that has the same
    identifier as one of the properties of the containing function?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`mySingletonObj`上添加另一个具有与包含函数属性相同标识符的属性会发生什么？
- en: Well, `mySingletonObj` is like any other object in the sense that we can add
    properties to it regardless of it containing the object's properties. However,
    the important thing to remember here is that assigning or modifying such properties
    on the returned interface has no effect on the private variables encapsulated
    in the function that contains the returned object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`mySingletonObj`就像任何其他对象一样，我们可以向它添加属性，而不管它是否包含对象的属性。然而，在这里要记住的重要事情是，在返回的接口上分配或修改这样的属性对包含返回对象的函数中封装的私有变量没有任何影响。
- en: 'Let''s modify our previous module and dig a little deeper:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们之前的模块并深入探讨一下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we have added a `name` property to our returned singleton object
    from the IIFE, which has the same identifier as the `name` property on the function
    object. We have also replaced one of the previous methods with two new methods
    in our interface (the singleton object returned from the IIFE). The first method,
    `getOuterName`, simply returns the value of the `name` property.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在IIFE返回的单例对象上添加了一个`name`属性，其标识符与函数对象上的`name`属性相同。我们还在我们的接口（IIFE返回的单例对象）中用两个新方法替换了之前的一个方法。第一个方法`getOuterName`简单地返回`name`属性的值。
- en: The question is, which `name` property, the one from the private scope of the
    function or the `name` property from the singleton object itself?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，哪个`name`属性，函数的私有作用域中的那个，还是单例对象本身的`name`属性？
- en: 'If we run the following line of code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行以下代码行：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that the value returned is the value in the scope of the singleton
    object itself; thus, `Tom` is displayed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到返回的值是单例对象本身的范围中的值；因此，显示的是`Tom`。
- en: 'However, if we try to access the same property, using the method property on
    the interface, a different value will be returned. Have a look at the following
    code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试使用接口上的方法属性访问相同的属性，将返回不同的值。请看以下代码片段：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the value returned from this method is the value for the `name`
    property from the outer scope of the interface, which is the scope of the container
    function. This can be rather confusing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，从这个方法返回的值是接口外部作用域中`name`属性的值，即容器函数的作用域。这可能会相当令人困惑。
- en: If the intent is to return the value for the name property which is defined
    inside the singleton object itself (the interface), we need to qualify the property
    using the `this` keyword.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果意图是返回单例对象内部（接口）定义的`name`属性值，我们需要使用`this`关键字指定属性。
- en: 'Have a look at the second new method that we added to our module:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们添加到模块中的第二个新方法：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this method, we specifically qualify the context for `name` using the `this`
    keyword, which references the context of the singleton object itself as opposed
    to the containing function. Thus, if we run the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用`this`关键字特别指定了`name`的上下文，它引用的是单例对象本身的上下文，而不是包含函数的上下文。因此，如果我们运行以下代码：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The value assigned to `name` in the context of the singleton object is returned.
    This is an important distinction to keep in mind.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的是单例对象上下文中`name`的值。这是一个需要记住的重要区别。
- en: Adding properties to an interface in module pattern
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模块模式中向接口添加属性
- en: Now that we have seen how internal private scope is at in play when we use the
    module pattern, let's see what happens if we add new dynamic properties to the
    singleton object returned in our previous example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了当我们使用模块模式时内部私有作用域是如何起作用的，让我们看看如果我们向之前示例中返回的单例对象添加新的动态属性会发生什么。
- en: 'Consider the following line of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码行：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are simply adding a new property dynamically to our object `mySingletonObj`.
    This property happens to have the same identifier as an already existing property
    on the object. What happens to the original value of the `name` property?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将一个新的属性动态地添加到我们的对象`mySingletonObj`中。这个属性恰好与对象上已经存在的属性具有相同的标识符。原始的`name`属性值会发生什么变化？
- en: 'We can find out by running the following tests:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下测试来找出答案：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the new value of the singleton object's property is displayed
    regardless of whether we directly access the property or use our singleton's method
    to return the value of the property.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，无论我们直接访问属性还是使用单例的方法返回属性的值，都会显示单例对象属性的新值。
- en: On the other hand, as expected, no changes have taken place in the value of
    the property contained in the container function's context, even though our singleton
    object does have access to this context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，正如预期的那样，容器函数上下文中属性的值没有发生变化，尽管我们的单例对象确实可以访问这个上下文。
- en: Remember, when we use the module pattern in JavaScript and return a singleton
    object from it (as an interface to the containing object/function), there are
    two contexts that are at play.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们使用JavaScript中的模块模式并从中返回单例对象（作为包含对象/函数的接口）时，有两个上下文在起作用。
- en: First, the internal private scope of the container function, which our singleton
    object has access to through closure.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，容器函数的内部私有作用域，我们的单例对象可以通过闭包访问。
- en: The second is the context of the singleton object itself as with any other object
    in JavaScript. It is important to understand the distinction between the two contexts
    when you design your modules using the module pattern in JavaScript.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是单例对象本身的上下文，就像JavaScript中的任何其他对象一样。当您使用JavaScript中的模块模式设计模块时，理解这两个上下文之间的区别很重要。
- en: Another important point to keep in mind is that the code structure (pattern)
    shown previously allows us to have both object encapsulation and access control
    on the properties defined in a private namespace. In this case, the anonymous
    function creates a namespace that returns an anonymous object or, more accurately,
    a reference to the anonymous object (the singleton object) as an interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的重要点是，之前展示的代码结构（模式）允许我们在私有命名空间中定义属性时同时拥有对象封装和访问控制。在这种情况下，匿名函数创建了一个命名空间，该命名空间返回一个匿名对象，或者更准确地说，返回对匿名对象（单例对象）的引用作为接口。
- en: This approach becomes very valuable since now we can be sure that no external
    code is able to either intentionally or accidentally change the values of the
    properties in our namespace. This structure provides control over what properties
    are accessible by the outside code and what properties are hidden away and protected
    in the private scope.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法变得非常有价值，因为我们现在可以确信没有任何外部代码能够有意或无意地更改我们命名空间中属性的值。这种结构提供了控制哪些属性可以被外部代码访问，哪些属性被隐藏在私有作用域中并受到保护。
- en: Object factory module
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象工厂模块
- en: We can design our modules to be very specialized chunks of code that do very
    specific tasks, while protecting their internals from external code interferences.
    So far, we have looked at a very simple pattern for creating modules. We can take
    this pattern a step further and design a module that creates instances of an object,
    adds properties to these instances, and then returns them to the code external
    to the module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计我们的模块成为非常专业的代码块，执行非常具体的任务，同时保护它们的内部不受外部代码干扰。到目前为止，我们已经查看了一个用于创建模块的非常简单的模式。我们可以进一步发展这个模式，并设计一个创建对象实例、向这些实例添加属性，然后将它们返回给模块外部代码的模块。
- en: 'Consider the following module:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下模块：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see in this code, we have combined two patterns together: the **object
    factory** pattern and the module pattern.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们结合了两种模式：**对象工厂**模式和模块模式。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Design patterns in JavaScript**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript中的设计模式**'
- en: 'If you are not familiar with design patterns in general or would like to become
    more familiar with design patterns in JavaScript, I highly recommend the following
    resource:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉设计模式，或者想要更熟悉JavaScript中的设计模式，我强烈推荐以下资源：
- en: '*Mastering JavaScript Design Patterns* by *Simon Timms*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*《精通JavaScript设计模式》* 由 *Simon Timms* 著。'
- en: When our function `myCarFactoryModule` is called, based on the parameters passed
    in, we create an instance of a car and then we assign it to an array which is
    the repository for all instances of the cars created. We have designed this module
    in such a way that the external code to the module has no access to the method
    that creates the cars, nor has access to the car repository.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的函数`myCarFactoryModule`被调用时，根据传入的参数，我们创建一个汽车实例，然后将其分配给一个数组，这个数组是所有创建的汽车实例的存储库。我们设计这个模块的方式是，模块外部的代码无法访问创建汽车的函数，也无法访问汽车存储库。
- en: 'Let''s test this using the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码进行测试：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the outside code can call our module's interface to create cars
    and also get a count on the number of the cars created. It can also remove a car,
    if it is desired to do so.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，外部代码可以调用我们的模块接口来创建汽车，也可以获取创建的汽车数量。如果需要，它还可以删除汽车。
- en: 'There are three privileged methods in this module: `createCar`, `getCarCount`,
    and `removeCar`. You can think of these methods as bridges between the internals
    of the module, which are hidden away from the outside world, and the external
    code, which relies on the internals of the module to do some specific tasks.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中有三个特权方法：`createCar`、`getCarCount`和`removeCar`。你可以将这些方法视为模块内部（对外界隐藏）和外部代码之间的桥梁，外部代码依赖于模块的内部来实现一些特定的任务。
- en: The privileged methods (which are members of the singleton interface object)
    are exposed to the external code to provide the module's functionality to whoever
    needs its services.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 特权方法（单例接口对象的成员）被暴露给外部代码，以便为需要其服务的任何人提供模块的功能。
- en: There is a notable advantage to this design. As you might have noticed, we can
    modify the code inside our module and add additional functionality to the module
    without affecting how other parts of our application can interact with our module.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计有一个明显的优势。正如你可能已经注意到的，我们可以修改模块内部的代码，并添加额外的功能到模块中，而不会影响应用程序的其他部分如何与我们的模块交互。
- en: This is true, as long as we don't change the name or the functionality of the
    privileged methods that provide access for the external code to utilize the module's
    functionality.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们不更改提供外部代码访问模块功能的特权方法的名字或功能，这就是真的。
- en: At the same time, we can add new privileged methods to the interface of the
    module or modify the internals of our current privileged methods in the singleton
    object without affecting the internal code of the module itself.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们可以在模块的接口中添加新的特权方法，或者修改单例对象中当前特权方法的内部结构，而不会影响模块本身的内部代码。
- en: This allows us to have a good separation of concerns and responsibilities between
    the exposed part of our module (the module's interface) and the private internals
    of the module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们可以在模块的公开部分（模块的接口）和模块的私有内部之间有一个很好的关注点和责任分离。
- en: Creating loose coupling among modules
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模块之间创建松耦合
- en: In a modular design, an application is often created using many modules. In
    order for these modules to work together, we need to create coupling among them,
    without the modules being tightly dependent on each other.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块化设计中，应用程序通常由许多模块创建。为了使这些模块能够协同工作，我们需要在它们之间创建耦合，而无需模块之间紧密依赖。
- en: Let's create an application based on a few simple modules and have the modules
    interact with each other in a loosely coupled manner. Of course, we will keep
    this application very simple for now. In later chapters, we will take the concepts
    utilized in this application and build upon them to create our fully modularized
    application ecosystem.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于几个简单的模块创建一个应用程序，并让这些模块以松耦合的方式相互交互。当然，我们现在将保持这个应用程序非常简单。在后面的章节中，我们将利用这个应用程序中的概念，在此基础上构建我们的完全模块化应用程序生态系统。
- en: I'm making the safe assumption here that our future application will consist
    of many separate modules, with each one of them being responsible for doing a
    very specific task.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里做出一个安全的假设，即我们的未来应用程序将包含许多独立的模块，每个模块都负责执行一个非常具体的任务。
- en: We will start by creating our core application module and calling it `ApplicationInitModule`.
    Usually, the very first step in running an application is to take care of the
    application's initialization tasks. Our `ApplicationInitModule` will be designed
    to do just that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建我们的核心应用程序模块，并将其命名为`ApplicationInitModule`。通常，运行应用程序的第一步是处理应用程序的初始化任务。我们的`ApplicationInitModule`将被设计来执行这项任务。
- en: In the following code snippet, when `ApplicationInitModule` is started, it will
    in turn start all the registered modules and their initialization routines. This
    process will take care of the application's initialization routine as a whole.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，当`ApplicationInitModule`启动时，它将依次启动所有注册的模块及其初始化例程。这个过程将负责整个应用程序的初始化例程。
- en: 'Have a look at the following code and see how our application is designed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码，看看我们的应用程序是如何设计的：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, a few interesting things are taking place in this application,
    but all the techniques used, we have already discussed in this book. Nonetheless,
    I'll go through each piece and explain the inner workings of each module.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在这个应用程序中发生了一些有趣的事情，但我们已经在本书中讨论了所有使用的技术。尽管如此，我仍将逐一解释每个模块的内部工作原理。
- en: Application core module
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序核心模块
- en: The code starts by defining `ApplicationInitModule` as an application initializer
    module. The purpose of this module is to register all the available modules in
    the application (store them in an array) and then initialize them all (one at
    a time), when the application runs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先定义`ApplicationInitModule`作为一个应用程序初始化模块。这个模块的目的是注册应用程序中所有可用的模块（将它们存储在数组中），然后在应用程序运行时初始化它们（一次一个）。
- en: This module also provides an interface with some hooks for the external code
    to interact with it. As you can see, there are methods to register a module, get
    the count of all the modules registered in the app for initialization, and remove
    a module from the list of registered modules; of course, there is also a method
    to initialize all modules that have been registered with the app.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块还提供了一个接口，其中包含一些钩子，以便外部代码与之交互。正如你所见，有方法可以注册模块、获取应用程序中注册的所有模块的计数以进行初始化，以及从注册模块列表中删除模块；当然，还有一个方法可以初始化已注册到应用程序中的所有模块。
- en: In this module, we are using an IIFE to return a reference to an anonymous singleton
    object, which is essentially the interface of the module.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我们使用IIFE（立即执行函数表达式）返回一个对匿名单例对象的引用，这实际上是模块的接口。
- en: One of the points that I'd like to draw your attention to is the fact that the
    functionality of this module is really defined in its interface. However, the
    module didn't have to be designed in this manner. You can also see that, in the
    other modules shown in the previous code, I have not used this approach. This
    is so you can see how we can implement the module pattern in various ways.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要引起你注意的一个点是，这个模块的功能实际上是在其接口中定义的。然而，模块并不一定要以这种方式设计。你还可以看到，在前面的代码中展示的其他模块中，我没有使用这种方法。这样做是为了让你看到我们可以以各种方式实现模块模式。
- en: Application Mediator module
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序中介模块
- en: Our `GlobalApp` module also uses an IIFE to return a singleton object as the
    interface to the module. The whole purpose of this module is to act as a mediator
    (abstraction layer) between `testModule1`, `testModule2`, and our core module,
    `ApplicationInitModule`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `GlobalApp` 模块也使用IIFE返回一个单例对象作为模块的接口。这个模块的整个目的就是作为 `testModule1`、`testModule2`
    和我们的核心模块 `ApplicationInitModule` 之间的中介（抽象层）。
- en: We have designed the application this way so we can create a loose coupling
    between our core module and the other registered modules. As you can see, `GlobalApp`
    has been designed as a very thin layer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样设计应用程序是为了能够在我们的核心模块和其他已注册模块之间创建松散耦合。正如你所见，`GlobalApp` 被设计成一个非常薄的层。
- en: This thin layer allows us to change our core module (`ApplicationInitModule`)
    as we please and even change its interface to the outside world, without affecting
    the other modules that rely on this module's functionality.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这薄薄的一层允许我们随心所欲地更改我们的核心模块（`ApplicationInitModule`），甚至可以更改其与外部世界的接口，而不会影响依赖于该模块功能的其他模块。
- en: In our design, the only module which relies directly on the `ApplicationInitModule`
    interface is our `GlobalApp` module. This means that, if there are any changes
    to the interface of `ApplicationInitModule`, we only need to make modifications
    to our thin mediator layer `GlobalApp`. All the other modules in the application
    will be unaffected, as they still use the same thin layer interface provided by
    `GlobalApp`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计中，唯一直接依赖于 `ApplicationInitModule` 接口的模块是我们的 `GlobalApp` 模块。这意味着，如果 `ApplicationInitModule`
    的接口有任何更改，我们只需要修改我们的薄中介层 `GlobalApp`。应用程序中的所有其他模块将不受影响，因为它们仍然使用 `GlobalApp` 提供的相同薄层接口。
- en: You will see in the future chapters of this book that this thin layer is called
    the **sandbox** and we will be using this concept of sandboxing to isolate our
    application modules/components from our application's core module(s). We will
    also use the same technique to isolate the modules/components from each other.
    For now, just try to become familiar with the general idea of module isolation
    (sandboxing) as shown in the previous application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书的未来章节中看到，这个薄层被称为 **沙盒**，我们将使用沙盒化的概念来隔离我们的应用程序模块/组件与我们的应用程序核心模块。我们还将使用相同的技巧来隔离模块/组件彼此之间。现在，只需尝试熟悉一下前面应用程序中展示的模块隔离（沙盒化）的一般概念。
- en: Application non-core modules
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序非核心模块
- en: In our application implementation, we have created two simple modules that register
    themselves with the core module and really do nothing other than announcing to
    the world that they have been initialized.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序实现中，我们创建了两个简单的模块，它们将自己注册到核心模块中，实际上除了向世界宣布它们已经被初始化之外，什么也不做。
- en: Let's have a closer look at how these modules have been implemented.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些模块是如何实现的。
- en: testModule1 implementation
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`testModule1` 实现细节'
- en: In `testModule1`, we have created an empty object called `self`, which gets
    augmented with a method called `initialize`. This is the method that will be called
    when our core module tries to initialize this module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `testModule1` 中，我们创建了一个名为 `self` 的空对象，该对象通过一个名为 `initialize` 的方法进行扩展。当我们的核心模块尝试初始化此模块时，将调用此方法。
- en: 'The registration of this module with the core module happens using an internal
    IIFE, which in turn calls our mediator module `GlobalApp` with a reference to
    the object `self`. This is implemented as shown below:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块与核心模块的注册是通过一个内部IIFE实现的，该IIFE反过来调用我们的中介模块 `GlobalApp` 并传递对对象 `self` 的引用。这如下所示实现：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Of course, the `GlobalApp.registerModule` method is in fact a reference to the
    core module's method, `ApplicationInitModule.registerModule`. However, `testModule1`
    does not know that and is only aware of `GlobalApp` provided interface, `GlobalApp.registerModule`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`GlobalApp.registerModule` 方法实际上是核心模块的方法 `ApplicationInitModule.registerModule`
    的引用。然而，`testModule1` 并不知道这一点，它只知道 `GlobalApp` 提供的接口，即 `GlobalApp.registerModule`。
- en: We have also used an IIFE to return an interface to this module, which is available
    through the `testModule1` variable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用IIFE返回一个接口给这个模块，该接口可以通过 `testModule1` 变量访问。
- en: Note that the interface provides two properties. One is a reference to the `self.initialize`
    method of the module and the other, `getName`, simply returns the value of the
    encapsulated and hidden `moduleName` variable. Also note that `moduleName` is
    not a property on the `self` object. Instead, it is implemented as a containing
    function's property.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，接口提供了两个属性。一个是模块的 `self.initialize` 方法的引用，另一个是 `getName`，它简单地返回封装和隐藏的 `moduleName`
    变量的值。还要注意，`moduleName` 不是 `self` 对象上的属性。相反，它被实现为一个包含函数的属性。
- en: testModule2 implementation
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: testModule2 实现
- en: Our `testModule2` is implemented a little differently in comparison to `testModule1`.
    As shown in the code, we have simply defined a function inside our module called
    `initialize` that is exposed to the external code indirectly through the interface
    returned from our IIFE for this module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `testModule1` 相比，我们的 `testModule2` 实现略有不同。如代码所示，我们在模块内部简单地定义了一个名为 `initialize`
    的函数，该函数通过模块返回的接口间接暴露给外部代码。
- en: In our `testModule2`, the `moduleName` variable is completely sealed from the
    outside world as there are no methods defined on the interface to provide access
    to this variable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `testModule2` 中，`moduleName` 变量完全被封装起来，因为接口上没有定义任何方法来提供对这个变量的访问。
- en: 'There is also no internal IIFE that registers the module with our core module,
    `ApplicationInitModule`, thus we need to make a call outside of our module definition
    to achieve this task, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有内部 IIFE 将模块注册到我们的核心模块 `ApplicationInitModule` 中，因此我们需要在模块定义之外进行调用以完成此任务，如下所示：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that we have used our mediator module `GlobalApp` for this registration
    again and we are not directly calling the related method on the core module. This
    allows us to still preserve our loose coupling among the modules.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们再次使用了我们的中介模块 `GlobalApp` 进行注册，并且我们没有直接在核心模块上调用相关方法。这允许我们仍然保持模块之间的松散耦合。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Design Pattern used in testModule2**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**testModule2 中使用的模式**'
- en: The way we have implemented `testModule2` is based on a design pattern known
    as **revealing module pattern**, in its simplest form. This is a very popular
    pattern for designing modules but of course there are various ways of implementing
    modules, as we have already seen. We will see even more patterns for implementing
    modules in the upcoming chapters. To get a better understanding of this pattern,
    please refer to previously mentioned resource for JavaScript design patterns.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现 `testModule2` 的方式基于一种称为 **揭示模块模式** 的设计模式，其最简单的形式。这是一种非常流行的模块设计模式，但当然，实现模块的方式有很多种，正如我们之前所看到的。在接下来的章节中，我们还将看到更多实现模块的模式。为了更好地理解这种模式，请参考之前提到的JavaScript设计模式资源。
- en: Auto-initialization of application modules
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用模块的自动初始化
- en: So far we have seen how our application modules use a mediator module to register
    themselves with our application's core module, without being aware of the existence
    of the core module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们的应用程序模块如何使用中介模块将自己注册到应用程序的核心模块中，而无需意识到核心模块的存在。
- en: We also noted that communication among modules was done through the interfaces
    that were provided by the modules to the outside world. Only such interfaces had
    access to the internals of the modules and their internal private scope.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到，模块之间的通信是通过模块提供给外界的接口完成的。只有这样的接口才能访问模块的内部和它们的内部私有作用域。
- en: 'The following diagram depicts the relationships that exist among our application
    modules and provides an overall view of our application:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了我们的应用程序模块之间的关系，并提供了我们应用程序的整体视图：
- en: '![Auto-initialization of application modules](img/B04910_03_01.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![应用模块的自动初始化](img/B04910_03_01.jpg)'
- en: Let's have a look at the method in the core module that is responsible for calling
    initialization methods on all of our registered modules.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看核心模块中负责调用所有注册模块初始化方法的方法。
- en: 'Remember that a reference to each application module registered with the core
    module has been added to the array `registeredModules`. This is shown in the following
    code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个注册到核心模块的应用模块的引用都已添加到数组 `registeredModules` 中。这在上面的代码片段中显示：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we call the `initializeAllModules` method in our application (on the core
    module), a `for` loop is used to call the `initialize` method on all the registered
    modules. This is done as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中调用 `initializeAllModules` 方法（在核心模块上）时，使用一个 `for` 循环来调用所有注册模块的 `initialize`
    方法。具体做法如下：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, `initializeAllModules` has no idea what each registered module's
    `initialize` method does when it is called. All it knows is to call the `initialize`
    method on the registered module and let the module take care of its own initialization
    tasks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`initializeAllModules`在调用时并不知道每个已注册模块的`initialize`方法做了什么。它只知道在注册的模块上调用`initialize`方法，并让模块自己处理其初始化任务。
- en: This is a very important point when we modularize our code. Each module only
    deals with tasks that are specific to that module's design and none of the other
    modules have any knowledge of how such tasks are done in that module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们模块化我们的代码时，这是一个非常重要的观点。每个模块只处理特定于该模块设计的任务，其他模块对如何在模块中执行此类任务没有任何了解。
- en: This means, while our core module calls the `initialize` method on one or many
    modules, it does not directly get involved with the initialization tasks of each
    module.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，当我们的核心模块在一个或多个模块上调用`initialize`方法时，它并不直接参与每个模块的初始化任务。
- en: 'It is time to run a test and see how application initialization takes place.
    Consider the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行测试，看看应用程序初始化是如何进行的了。考虑以下内容：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we run the preceding code, we can see that both of our modules report that
    they have been successfully initialized.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的代码时，我们可以看到我们的两个模块都报告它们已经成功初始化。
- en: Of course, we have designed our application in such a way that all the registered
    modules do have an accessible method called `initialize`. This allows us to use
    an array and a `for` loop to initialize them all in sequence.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们已经以这种方式设计我们的应用程序，所有已注册的模块都确实有一个可访问的方法称为`initialize`。这允许我们使用一个数组和`for`循环来按顺序初始化它们。
- en: Module initialization and design considerations
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块初始化和设计考虑
- en: At the application design time, you decide on how the modules should be initialized
    and how the initialization method in each module should be called. The important
    point is that calling the initialization routine of each module should not cause
    a tight coupling.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序设计时，您决定模块应该如何初始化以及每个模块的初始化方法应该如何调用。重要的是，调用每个模块的初始化例程不应导致紧密耦合。
- en: 'For consistency reasons, as well as ease of maintainability, I usually name
    the methods which are responsible for initialization tasks in all of my application
    modules: `initialize` or `init`. This allows me to use a `for` loop to call all
    the registered modules in sequence and ask the modules to initialize themselves
    accordingly.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性以及便于维护，我通常将负责所有应用程序模块中初始化任务的函数命名为`initialize`或`init`。这允许我使用`for`循环按顺序调用所有已注册的模块，并要求模块相应地初始化自己。
- en: Keep in mind that creating loose coupling among modules is only possible as
    long as the interfaces (public method hooks) in our modules do not change their
    names and their accessibility for the external code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只有在模块的接口（公共方法钩子）不更改其名称及其对外部代码的可访问性时，才能在模块之间创建松散耦合。
- en: This means that, for example, if `testModule1` calls the `GlobalApp.registerModule`
    method to register itself, it should always be able to call that method for registration.
    This should hold true even if the mechanism of how this registration takes place
    changes internally in the `GlobalApp` object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如，如果`testModule1`调用`GlobalApp.registerModule`方法来注册自身，它应该始终能够调用该方法进行注册。即使在`GlobalApp`对象内部如何进行注册的机制发生变化，这也应该是正确的。
- en: The architecture and design that you saw in our simple application here creates
    a foundation for creating loose coupling among our application modules. This in
    turn leads to a more extensible and maintainable implementation for both small
    and large applications.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里简单应用程序中看到的架构和设计为在应用程序模块之间创建松散耦合奠定了基础。这反过来又导致了对小型和大型应用程序都更加可扩展和可维护的实现。
- en: You can look at module interfaces as contracts among modules, which enables
    them to interact with each other regardless of how the internals of such contracts
    are implemented. Note that, while there are contracts among modules in the application,
    there is no direct dependency among them. Each module is free to decide on how
    to implement its specific functionality to accomplish the tasks that it was designed
    to do.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将模块接口视为模块之间的合同，这使得它们能够相互交互，而不管这些合同的内部实现细节如何。请注意，尽管应用程序中存在模块之间的合同，但它们之间没有直接的依赖关系。每个模块都可以自由决定如何实现其特定的功能来完成其设计要完成的任务。
- en: This is so, as long as the module provides the functionality and the service
    which is expected from it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 只要模块提供了预期的功能和服务，情况就是如此。
- en: This approach will provide a great deal of flexibility and extensibility for
    our application. It allows us to add, remove, and modify various parts of our
    application in a very targeted and manageable manner without such changes having
    an impact on other pieces of the application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将为我们的应用程序提供极大的灵活性和可扩展性。它允许我们以非常针对性和可管理的方式添加、删除和修改应用程序的各个部分，而不会影响应用程序的其他部分。
- en: The fundamental architectural concepts that we discussed here are the concepts
    that will form the building blocks of the final application that we will build
    in this book.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的基本架构概念是构成我们将在本书中构建的最终应用程序的构建块的概念。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at one of the most popular design patterns in JavaScript:
    module pattern.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了JavaScript中最受欢迎的设计模式之一：模块模式。
- en: By creating simple modules, we explored various aspects of internal private
    scope in module pattern and saw how modules can interact with each other, without
    having access to the protected properties of each other's private scope.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建简单的模块，我们探讨了模块模式中内部私有作用域的各个方面，并看到了模块如何在不访问彼此私有作用域的受保护属性的情况下相互交互。
- en: This pattern allows us to create encapsulation and access control in our objects
    and modules, while providing an interface for the external code to leverage the
    implemented functionality intended for external use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式允许我们在对象和模块中创建封装和访问控制，同时为外部代码提供一个接口，以便利用为外部使用而实现的功能。
- en: One of the most important aspect of module pattern is how it can be used to
    create a modular design for our application as a whole. This enables us to create
    loose coupling among our modules, which are essentially the building blocks of
    our application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式最重要的一个方面是它如何被用来为我们的整个应用程序创建模块化设计。这使我们能够在模块之间创建松散耦合，这些模块实际上是我们的应用程序的构建块。
- en: In later chapters, we will utilize this approach and slowly build more complex
    modules to create a robust and easily maintainable code base for our application.
    These modules can also be easily reused as needed, in all of our future applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将利用这种方法，逐步构建更复杂的模块，以创建一个健壮且易于维护的代码库，用于我们的应用程序。这些模块也可以根据需要轻松地在所有未来的应用程序中重用。
