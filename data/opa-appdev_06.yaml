- en: Chapter 6. Binding with Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。与其他语言的绑定
- en: As mentioned in the *Register handler* section of [Chapter 3](ch03.html "Chapter 3. Developing
    Web Applications"), *Developing Web Applications*, we can register external JavaScript
    code by utilizing the `Resource.register_external_js` function. But, this is not
    how we call external JavaScript functions from Opa. This is only true when we
    wish to invoke Node.js functions. In such cases, we instead bind external functions
    with Opa's binding ability. In this chapter, we will explain how to bind external
    JavaScript or Node.js functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[第3章](ch03.html "第3章。开发 Web 应用程序")的*注册处理程序*部分所述，*开发 Web 应用程序*，我们可以通过使用`Resource.register_external_js`函数来注册外部
    JavaScript 代码。但是，这不是我们从 Opa 调用外部 JavaScript 函数的方式。这仅在我们希望调用 Node.js 函数时才成立。在这种情况下，我们使用
    Opa 的绑定能力绑定外部函数。在本章中，我们将解释如何绑定外部 JavaScript 或 Node.js 函数。
- en: Binding JavaScript
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定 JavaScript
- en: 'Opa allows binding of the external functions through its **Binding System Library**
    (**BSL**). If we surf the source code of Opa, we will find in many places that
    Opa binds JavaScript in its source code. Actually, Opa provides three forms of
    binding syntax: `classic` , `jsdoc`, and `new`. The jsdoc syntax is now (Opa 1.1.0)
    the default.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Opa 允许通过其**绑定系统库**（**BSL**）绑定外部函数。如果我们浏览 Opa 的源代码，我们会发现它在许多地方绑定了 JavaScript。实际上，Opa
    提供了三种绑定语法：`classic`、`jsdoc`和`new`。`jsdoc`语法现在是（Opa 1.1.0）的默认语法。
- en: The first example
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个示例
- en: Let's get started with a binding example of JavaScript. Suppose we have finished
    a `test` function in the `test.js` JavaScript file, and then we want to use it
    in the `601.opa` Opa file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 JavaScript 的绑定示例开始。假设我们在`test.js` JavaScript 文件中完成了一个`test`函数，然后我们想在`601.opa`
    Opa 文件中使用它。
- en: '![The first example](img/3749OS_06_01.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![第一个示例](img/3749OS_06_01.png.jpg)'
- en: 'The content of the `test.js` file is as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`test.js`文件的内容如下：'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We registered the `test` function using the annotation `@register {string ->
    void}`. This indicates that the function being registered has the `string -> void`
    type. To invoke the `test` function in Opa code, we designate the function as
    an external JavaScript function by surrounding the name of the function with the
    special designator `%%`. In the following example, we call the JavaScript `test`
    function located in `test.js` from within the `601.opa` file:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用注解`@register {string -> void}`注册了`test`函数。这表示正在注册的函数具有`string -> void`类型。要在
    Opa 代码中调用`test`函数，我们将函数指定为外部 JavaScript 函数，通过将函数名用特殊标识符`%%`包围来实现。在以下示例中，我们从`601.opa`文件中调用位于`test.js`中的
    JavaScript `test`函数：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We call the function using `%%test.test%%("Hello Opa!")`. The word "test" appears
    in this example twice, once preceding the dot and once after the dot. The first
    "test" is the name of the plugin module; in this case it is the filename of `test.js`.
    The second "test" is the name of the function that we define in this file. We
    can compile the JavaScript code and Opa code together by using the following command
    line:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`%%test.test%%("Hello Opa!")`调用函数。在这个例子中，“test”出现了两次，一次在点号之前，一次在点号之后。第一个“test”是插件模块的名称；在这种情况下，它是`test.js`的文件名。第二个“test”是我们在这个文件中定义的函数的名称。我们可以通过以下命令行一起编译
    JavaScript 代码和 Opa 代码：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By default, the registered function name is identical to the original function
    name that we defined in the JavaScript file. However, we can modify the name as
    follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，注册的函数名与我们在 JavaScript 文件中定义的原始函数名相同。然而，我们可以按以下方式修改名称：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we added `test2` to the end of the line that we used to register the
    function. Now, we can invoke it using `%%test.test2%%("Hello Opa!")`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在注册函数的行末添加了`test2`。现在，我们可以使用`%%test.test2%%("Hello Opa!")`来调用它。
- en: Using external types
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用外部类型
- en: Sometimes, we may want to handle the Opa types such as list (`a), option ('a),
    or Opa external types that we defined in Opa in JavaScript. In the following example,
    we define a type `Student` and its variable `stu`; variable `lst` is the Opa type
    `list(string)`, which we may not use in JavaScript directly; and the variable
    `arr` is an external type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能想在 JavaScript 中处理 Opa 类型，例如列表（`a`）、选项（`'a'`）或我们在 Opa 中定义的外部 Opa 类型。在下面的示例中，我们定义了一个类型`Student`及其变量`stu`；变量`lst`是
    Opa 类型`list(string)`，我们可能无法直接在 JavaScript 中使用它；变量`arr`是一个外部类型。
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our JavaScript file, we define three functions: `func1`, `func2`, and `func3`.
    `func1` accepts type `Student`, `func2` accepts type `list(string)`, and `func3`
    accepts type `llarray(int)`. All these three functions do nothing but print the
    content of their respective arguments to the console. The first thing we should
    do is declare Opa types and external types with the directives `@opaType` and
    `@externType` respectively.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 JavaScript 文件中，我们定义了三个函数：`func1`、`func2` 和 `func3`。`func1` 接受类型 `Student`，`func2`
    接受类型 `list(string)`，`func3` 接受类型 `llarray(int)`。所有这三个函数只是将它们各自参数的内容打印到控制台。我们应该做的第一件事是使用指令
    `@opaType` 和 `@externType` 分别声明 Opa 类型和外部的类型。
- en: 'The content of the file `test2.js` is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `test2.js` 的内容如下：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Compile and run `opa test2.js 602.opa --`
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行 `opa test2.js 602.opa --`
- en: Press *F12* in your Chrome browser to open the developer tool and you will see
    the output we printed in the console.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Chrome 浏览器中按 *F12* 打开开发者工具，您将看到我们在控制台打印的输出。
- en: '![Using external types](img/3749OS_06_02.png.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![使用外部类型](img/3749OS_06_02.png.jpg)'
- en: Binding Node.js
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定 Node.js
- en: 'Binding Node.js code is just as easy as binding JavaScript. Let''s see an example:
    suppose we have written a function called `calcMD5` in a Node.js file called `test.nodejs`.
    The function accepts a string and returns its MD5 hash value. The `test.nodejs`
    file contains the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定 Node.js 代码与绑定 JavaScript 一样简单。让我们看一个例子：假设我们在名为 `test.nodejs` 的 Node.js 文件中编写了一个名为
    `calcMD5` 的函数。该函数接受一个字符串并返回其 MD5 哈希值。`test.nodejs` 文件包含以下代码：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see from the preceding code, we bind Node.js in the same manner that
    we previously used to bind the client-side JavaScript code. We also invoke it
    in the same way:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看到，我们以与之前绑定客户端 JavaScript 代码相同的方式绑定了 Node.js。我们也是以相同的方式调用的：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And finally, we compile and run the application:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编译并运行应用程序：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result is as shown in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Binding Node.js](img/3749OS_06_03.png.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![绑定 Node.js](img/3749OS_06_03.png.jpg)'
- en: Binding external functions using the classic syntax
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用经典语法绑定外部函数
- en: 'We can also bind external functions with the `classic` syntax. The `classic`
    syntax is a little different from the `jsdoc` syntax. It uses `##` to register
    functions. A typical registration body is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `classic` 语法绑定外部函数。`classic` 语法与 `jsdoc` 语法略有不同。它使用 `##` 来注册函数。一个典型的注册体如下：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `classic` syntax, `test2.js` will contain the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `classic` 语法中，`test2.js` 将包含以下代码：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now compile the rewritten file using the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令编译重写的文件：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we talked about how to bind client-side JavaScript and server-side
    Node.js into our Opa code. We described two syntax variations: `classic` syntax
    and `jsdoc` syntax. The examples used in this chapter demonstrated that binding
    JavaScript and Node.js is quite trivial in Opa.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何将客户端 JavaScript 和服务器端 Node.js 绑入我们的 Opa 代码。我们描述了两种语法变体：`classic`
    语法和 `jsdoc` 语法。本章中使用的示例演示了在 Opa 中绑定 JavaScript 和 Node.js 非常简单。
