- en: Completing the Unit Conversion Website in Elm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成 Elm 中的单位转换网站
- en: 'Welcome to [Chapter 5](d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml), *Completing
    the Unit Conversion Website in Elm*. The goal of this chapter is to complete the
    unit conversion website while discussing the following concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 [第 5 章](d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml)，*完成 Elm 中的单位转换网站*。本章的目标是在讨论以下概念的同时完成单位转换网站：
- en: Using `Html.map`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Html.map`
- en: Working with complex relationships between different views
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不同视图之间的复杂关系
- en: Working with multiple models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个模型
- en: Combining everything we learned in a relatively complex app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个相对复杂的应用中结合我们所学的所有内容
- en: 'After completing this chapter, you will be able to:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一章后，你将能够：
- en: Build Elm applications that have multiple models separated into modules, while
    following best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建具有多个模型且模块化的 Elm 应用程序，同时遵循最佳实践
- en: We'll begin this chapter by looking at the completed functionality for our unit
    converter app. The reason for this is to be able to see the bigger picture and
    understand what is going on in the two modules of our updated app before continuing
    to improve the app itself.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，查看我们单位转换器应用的完成功能。这样做的原因是能够看到更大的图景，并在继续改进应用本身之前，理解我们更新应用的两个模块中正在发生什么。
- en: Improving the Unit Converter app
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进单位转换器应用
- en: In this iteration of our app, we have two separate files that work together
    to produce our unit conversion app. At this point, there are no styles in our
    app at all, since the focus is on functionality. Now, let's rebuild our unit converter
    app from scratch.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用的这个迭代中，我们有两个单独的文件协同工作以生成我们的单位转换器应用。到目前为止，我们的应用中没有任何样式，因为重点是功能。现在，让我们从头开始重建我们的单位转换器应用。
- en: 'We''ll start with the barebones Elm app:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从裸骨 Elm 应用程序开始：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we will improve it so that it can take multiple input fields. The first
    improvement has to do with separating the current unit converter into a different
    module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对其进行改进，使其能够接受多个输入字段。第一次改进是将当前的单位转换器模块分离成不同的模块。
- en: Separating UnitConverter into a different module
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 UnitConverter 分离到不同的模块
- en: Create a new file, call it `UnitConverter.elm`, and save it inside the `src`
    folder. Next, copy and paste the barebones app there as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，命名为 `UnitConverter.elm`，并将其保存在 `src` 文件夹中。接下来，也将裸骨应用复制粘贴到那里。
- en: 'Back in `Main.elm`, change its imports section so that it looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Main.elm` 中，更改其导入部分，使其看起来如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside `UnitConverter.elm`, change the imports section so that it looks like
    this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UnitConverter.elm` 内部，更改导入部分，使其看起来如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Still in `UnitConverter.elm`, add the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 `UnitConverter.elm` 中，添加以下代码：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the preceding code looks almost identical to what we had at the
    end of [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml), *Preparing a Unit
    Conversion Website in Elm*, except that there is no call to `main` anymore, and
    the `init` function has changed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码几乎与我们在 [第 4 章](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml) 的结尾所看到的内容相同，即
    *在 Elm 中准备单位转换网站*，除了不再调用 `main`，`init` 函数也发生了变化。
- en: Now, we can update the `Main.elm` file so that it works with multiple input
    fields.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新 `Main.elm` 文件，使其能够处理多个输入字段。
- en: Adding type alias Model, initModel, and Main
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加类型别名 Model、initModel 和 Main
- en: 'We''ll start updating `Main.elm` by adding a new type alias `Model`. Place
    the type alias `Model` just above the `initModel`. The code should be as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始更新 `Main.elm`，通过添加一个新的类型别名 `Model`。将类型别名 `Model` 放在 `initModel` 之上。代码应如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let''s update the `initModel` itself:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新 `initModel` 本身：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's discuss the preceding code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论前面的代码。
- en: 'Our type alias `Model` consists of a `lengthConverter` and a `weightConverter`,
    both of which take the value of `UnitConverter.Model`. Looking at type alias `UnitConverter.Model`,
    we see the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类型别名 `Model` 由一个 `lengthConverter` 和一个 `weightConverter` 组成，它们都接受 `UnitConverter.Model`
    的值。查看类型别名 `UnitConverter.Model`，我们看到以下内容：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `initModel` function, we have the `lengthConverter` take the value from
    `UnitConverter.init`, with three arguments passed to it: "Miles", "Kilometers",
    and 1.608, which is in accordance with the type annotation of the `init` function
    in the `UnitConverter` module:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initModel` 函数中，我们将 `lengthConverter` 的值从 `UnitConverter.init` 中获取，传递给它三个参数：“英里”、“千米”和
    1.608，这与 `UnitConverter` 模块中 `init` 函数的类型注解一致：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, we set up the values of `initialModel` for the `weightConverter`,
    populating it with the following expression:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们为 `weightConverter` 设置了 `initialModel` 的值，并用以下表达式填充它：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Continuing with code in `Main.elm`, we can add it to the `main` function, which
    has not changed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在`Main.elm`中的代码，我们可以将其添加到没有变化的`main`函数中：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we run our app now, we'll get the `Everything will go here` text in the browser.
    This means that everything is working and ready for us to improve it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用，我们将在浏览器中得到`Everything will go here`的文本。这意味着一切都在正常工作，并且已经准备好供我们改进。
- en: In the next section, we'll update the `view` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更新`view`函数。
- en: Updating the Main.view function
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新`Main.view`函数
- en: 'To update the `view` function, we''ll use the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新`view`函数，我们将使用以下代码：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s look at a compiler-suggested type annotation for the `Main.view` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编译器为`Main.view`函数建议的类型注解：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `view` function takes a record. The values of the record will be that of
    the current model, plus the update made to `lengthConverter` or `weightConverter`.
    The `lengthConverter` function will return *either* its current value, signified
    by type variable `b`, *or* the updated value which sets the `convertedValue`,
    `unit1`, and `unit2` to their respective values. The same goes for `weightConverter`—it
    will return *either* as is, *or* its updated values for `convertedValue`, `unit1`,
    and `unit2`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`view`函数接受一个记录。记录的值将是当前模型的值，加上对`lengthConverter`或`weightConverter`所做的更新。`lengthConverter`函数将返回*要么*它的当前值，由类型变量`b`表示，*要么*更新后的值，将`convertedValue`、`unit1`和`unit2`设置为它们的相应值。对于`weightConverter`也是一样——它将返回*要么*原样，*要么*更新后的`convertedValue`、`unit1`和`unit2`的值。'
- en: So, the `view` function takes a record and returns an `Html.Html Msg`. Why is
    the `Html` module listed here? Because we have not exposed it explicitly when
    importing the `Html` module. This way of referencing it is known as the fully
    qualified style. Had we exposed the `Html` function explicitly in the `Html` import
    expression at the top of our `Main.elm`, we could have just used `-> Html Msg`,
    which is referred to as an unqualified style.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`view`函数接受一个记录并返回一个`Html.Html Msg`。为什么这里列出了`Html`模块？因为我们没有在导入`Html`模块时显式地暴露它。这种引用方式被称为完全限定风格。如果我们已经在`Main.elm`的顶部导入表达式中显式地暴露了`Html`函数，我们就可以直接使用`->
    Html Msg`，这被称为非限定风格。
- en: 'If we run our app now, the compiler will throw these two errors:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用，编译器将抛出这两个错误：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Of course it cannot. We have not set it anywhere.  Let''s start doing that.
    We''ll begin by adding the union `type Msg`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当然不行。我们还没有设置它。让我们开始做这件事。我们将首先添加`type Msg`的联合类型：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `type Msg` in `Main.elm` can be either a `LengthConverterMsg` type constructor
    function, taking the `UnitConverter.Msg` as its argument, or it can be a `WeightConverterMsg`
    type constructor function, also taking the `UnitConverter.Msg`. Both of these
    type constructor functions take in the same value as its single argument. Why
    is that?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main.elm`中的`type Msg`可以是`LengthConverterMsg`类型构造函数，它接受`UnitConverter.Msg`作为其参数，或者它可以是`WeightConverterMsg`类型构造函数，也接受`UnitConverter.Msg`。这两个类型构造函数都接受相同的值作为其单个参数。为什么是这样？'
- en: 'The answer is easy: if you look at the `UnitConverter.update` function, you''ll
    see that if its Swap pattern gets matched, the expression that evaluates will
    do exactly that, swap the values, just as it did in [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml),
    *Preparing a Unit Conversion Website in Elm*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：如果你查看`UnitConverter.update`函数，你会看到如果它的Swap模式匹配成功，评估的表达式将执行确切的操作，交换值，就像它在[第4章](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml)中，*在Elm中准备一个单位转换网站*所做的那样。
- en: If the `UnitConverter.update` function's `Convert` pattern gets matched, it
    will return the `model` as it received it, *plus* the updated `convertedValue`.
    Again, this is the same as what we had in [Chapter 4](http://prepat), *Preparing
    a Unit Conversion Website in Elm*, which means that the logic is the same.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`UnitConverter.update`函数的`Convert`模式匹配成功，它将返回它接收到的`model`，*加上*更新的`convertedValue`。这和我们在[第4章](http://prepat)中提到的相同，*在Elm中准备一个单位转换网站*，这意味着逻辑是相同的。
- en: What changed then? What changed is the `view` function in `Main.elm`. Let's
    pick it apart.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么发生了什么变化？变化的是`Main.elm`中的`view`函数。让我们来分解它。
- en: 'Our `Main.view` is just a `div` function. The first `List` we pass to it is
    empty. The second `List` has two parameters. The first one looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Main.view`只是一个`div`函数。我们传递给它的第一个`List`是空的。第二个`List`有两个参数。第一个参数看起来像这样：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is the piping syntax that we already discussed. Another way to write it
    is to use parentheses, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们已经讨论过的管道语法。另一种写法是使用括号，如下所示：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s start with the expression inside parentheses:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从括号内的表达式开始：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Remember that on line 22 of `UnitConverter.elm`, we can see that its `view`
    function takes a single parameter:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 `UnitConverter.elm` 的第 22 行，我们可以看到其 `view` 函数只接受一个参数：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Thus, the parameter `model.lengthConverter` we pass to `UnitConverter.view`
    inside `Main.elm` is, in fact, the model, more specifically, the `lengthConverter`
    flavor of the model.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 `Main.elm` 中传递给 `UnitConverter.view` 的参数 `model.lengthConverter` 实际上是模型本身，更具体地说，是模型的
    `lengthConverter` 类型。
- en: Where does `lengthConverter` come from? We can find the answer if we look at
    the flow of data in `Main.elm`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `lengthConverter` 从哪里来呢？如果我们查看 `Main.elm` 中的数据流，我们就可以找到答案。
- en: 'First, the `Main.elm` entry point, the `main` function, receives the value
    that''s computed by evaluating the following expression:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Main.elm` 的入口点，`main` 函数，接收评估以下表达式计算出的值：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to focus on the first line of the preceding Record: `model = initModel`.
    It means that `model` will get populated with the `initModel` value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注上述记录的第一行：`model = initModel`。这意味着 `model` 将被填充为 `initModel` 的值：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This record will get stored in our `Main.model`. Next, the `Main.view` function
    takes the values from the model and gives them to the `div` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个记录将被存储在我们的 `Main.model` 中。接下来，`Main.view` 函数从模型中获取值，并将它们传递给 `div` 函数：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We ended up where we began, but now we know that on the first run, our app
    will give our `UnitConverter.view` the `model.lengthConverter` parameter that
    has the following initial values: "Miles", "Kilometers", and 1.608.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到了起点，但现在我们知道，在第一次运行时，我们的应用程序将给 `UnitConverter.view` 函数传递 `model.lengthConverter`
    参数，该参数具有以下初始值："Miles"，"Kilometers"，以及 1.608。
- en: 'Similarly, our app will give our `UnitConverter.view` the `model.weightConverter`
    parameter that has the following initial values: "Kilograms", "Pounds", and 2.2046.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们的应用程序将给 `UnitConverter.view` 函数传递 `model.weightConverter` 参数，该参数具有以下初始值："Kilograms"，"Pounds"，以及
    2.2046。
- en: 'But that''s only the first part of the rendering process. What happens next
    is this bit of code: `Html.map LenghtConverterMsg`, and `Html.map WeightConverterMsg`,
    respectively.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但那只是渲染过程的第一部分。接下来发生的事情是这段代码：`Html.map LenghtConverterMsg` 和 `Html.map WeightConverterMsg`。
- en: Let's look at the `Html.map` function now.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 `Html.map` 函数。
- en: Understanding Html.map
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Html.map
- en: 'Understanding `Html.map` is simple. Let''s start with the official documentation,
    available at [http://package.elm-lang.org/packages/elm-lang/html/latest/Html#map](http://package.elm-lang.org/packages/elm-lang/html/latest/Html#map).
    The documentation says that `Html.map` is used to:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `Html.map` 非常简单。让我们从官方文档开始，文档可在 [http://package.elm-lang.org/packages/elm-lang/html/latest/Html#map](http://package.elm-lang.org/packages/elm-lang/html/latest/Html#map)
    找到。文档说明 `Html.map` 用于：
- en: '"Transform the messages produced by some Html."'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '"将某些 Html 产生的消息进行转换。"'
- en: That's all it does!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是它所做的一切！
- en: Now, why do we need to transform messages produced by `UnitConverter.view model.lengthConverter`
    in our `Main.elm` file? Because in order to use the Html Msg that gets returned
    from the `UnitConverter.view model.lengthConverter` expression, we need to match
    it to the `LengthConverterMsg` type that the `Main.update` function will be using.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为什么我们需要在 `Main.elm` 文件中转换 `UnitConverter.view model.lengthConverter` 产生的消息呢？因为为了使用从
    `UnitConverter.view model.lengthConverter` 表达式返回的 Html Msg，我们需要将其匹配到 `Main.update`
    函数将使用的 `LengthConverterMsg` 类型。
- en: In the next section, we'll add the `update` function to our app and then remove
    the `Html.map` from the `Main.view` function to see what kind of error will be
    thrown by the compiler.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向我们的应用程序添加 `update` 函数，然后从 `Main.view` 函数中移除 `Html.map`，以查看编译器将抛出什么样的错误。
- en: Updating the Main.update function
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 Main.update 函数
- en: 'To start off, let''s add the following code to our `Main.update` function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们将以下代码添加到我们的 `Main.update` 函数中：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Contrary to what you might think the first time you look at the preceding code,
    there is not a lot going on there. As usual, our update function takes a message
    and a model. The message comes from the `Model.view` function, and it can either
    be `LengthConverterMsg` or `WeightConverterMsg`, as determined in the `Msg` union
    type above the update function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与你第一次查看上述代码时可能想到的相反，那里并没有发生太多。像往常一样，我们的更新函数接受一个消息和一个模型。消息来自 `Model.view` 函数，可以是
    `LengthConverterMsg` 或 `WeightConverterMsg`，这由更新函数上方的 `Msg` 联合类型决定。
- en: As mentioned in [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml), *Preparing
    a Unit Conversion Website in Elm*, for the `case` expression to compile successfully,
    it needs to cover all possible options, and `LengthConverterMsg` and `WeightConverterMsg`
    patterns do just that.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 [第 4 章](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml) 中提到的，*在 Elm 中准备一个单位转换网站*，为了使
    `case` 表达式成功编译，它需要覆盖所有可能的选项，而 `LengthConverterMsg` 和 `WeightConverterMsg` 模式正是这样做的。
- en: Going into a `LenghtConverterMsg` pattern, we can see that it takes a parameter
    we called `msg_`. This name was given in order to distinguish between the first
    argument passed to the `update` function, which is just called `msg` (without
    the underscore).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `LenghtConverterMsg` 模式，我们可以看到它接受一个我们称之为 `msg_` 的参数。这个名称是为了区分传递给 `update`
    函数的第一个参数，它只是简单地称为 `msg`（没有下划线）。
- en: 'Inside the `LenghtConverterMsg` pattern, we have a `let` expression, and inside
    of its `let` part, we specify a locally-scoped `newLengthConverter`, which gets
    the value evaluated from the following expression:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LenghtConverterMsg` 模式中，我们有一个 `let` 表达式，在其 `let` 部分中，我们指定了一个局部作用域的 `newLengthConverter`，它从以下表达式中获取评估后的值：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, in the let-expression''s `in` part, we return this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 let 表达式的 `in` 部分中，我们返回这个：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code is straightforward: the `lenghtConverter` gets updated with
    the value returned from the computation of the expression saved in `newLengthConverter`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码很简单：`lenghtConverter` 通过存储在 `newLengthConverter` 中的表达式的计算结果进行更新。
- en: In case our `Main.update` function's case statement pattern matches the `WeightConverterMsg` pattern,
    the operations performed are almost identical—the only difference is that `model.weightConverter` is
    being passed as the second argument to the `UnitConverter.update` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 `Main.update` 函数的 case 语句模式匹配 `WeightConverterMsg` 模式，执行的操作几乎相同——唯一的区别是
    `model.weightConverter` 被作为第二个参数传递给 `UnitConverter.update` 函数。
- en: 'To conclude this section, let''s look at the `Main.update` function''s type
    annotation, as suggested by the compiler:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节，让我们看看编译器建议的 `Main.update` 函数的类型注解：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The update function takes a `Msg` and a `Record` and returns a `Record`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更新函数接受一个 `Msg` 和一个 `Record` 并返回一个 `Record`。
- en: If we save all the files and run the app at this point, we'd get a fully functional
    unit converter. However, we still need to remove the `Html.map` from the `Main.view`
    function, as announced a few pages back, since we want to see what kind of error
    the compiler will throw.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在保存所有文件并运行应用程序，我们会得到一个完全功能的单位转换器。然而，我们仍然需要从 `Main.view` 函数中删除 `Html.map`，正如几页前宣布的那样，因为我们想看到编译器会抛出什么样的错误。
- en: Playing with error messages in Elm is a great way to learn more advanced concepts,
    or reinforce concepts that are somewhat familiar.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Elm 中玩弄错误信息是学习更高级概念或加强某些熟悉概念的好方法。
- en: Learning from compiler error messages
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从编译器错误信息中学习
- en: 'Let''s start by removing a single `Html.map` function from `Main.view`, so
    that its updated code looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从 `Main.view` 中移除一个 `Html.map` 函数，这样它的更新后的代码看起来就像这样：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Make sure to remove the type annotation as well, to avoid additional error
    messages. Saving and running the app after these changes will produce the following
    error message:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 确保也删除类型注解，以避免额外的错误信息。在这些更改后保存并运行应用程序将产生以下错误信息：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we discussed previously, the first entry, since it's not being converted
    to `lengthConverterMsg` via `Html.map`, has the type of `Html UnitConverter.Msg`.
    Looking at the `Msg` union type of the `UnitConverter` type, we can see that it
    can be either `Swap` or `Convert String`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，第一个条目，因为它没有通过 `Html.map` 转换为 `lengthConverterMsg`，其类型为 `Html UnitConverter.Msg`。查看
    `UnitConverter` 类型的 `Msg` 联合类型，我们可以看到它可以是 `Swap` 或 `Convert String`。
- en: However, looking at Main's `Msg` union type, we can see that it can be either
    `LengthConverterMsg UnitConverter.Msg`, or `WeightConverterMsg UnitConverter.Msg`.
    In other words, it can be either of these two function constructors, taking `UnitConverter.Msg`
    as its parameter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，查看 `Main` 的 `Msg` 联合类型，我们可以看到它可以是 `LengthConverterMsg UnitConverter.Msg`
    或 `WeightConverterMsg UnitConverter.Msg`。换句话说，它可以是这两个函数构造器之一，以 `UnitConverter.Msg`
    作为其参数。
- en: 'To drive the point home, let''s erase the other piped function from `Main.view`
    as well. Doing that will produce the following error message:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调这一点，让我们也从 `Main.view` 中删除另一个管道函数。这样做会产生以下错误信息：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This concludes the changes made to our code's logic. However, there is still
    quite a lot of work to be done. We will make our app look a lot nicer by using
    a free Bootstrap 4 template as our starting point and then adjusting it to our
    needs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对代码逻辑所做的更改。然而，还有很多工作要做。我们将通过使用免费的 Bootstrap 4 模板作为起点，然后调整以满足我们的需求，使我们的应用程序看起来更加美观。
- en: A Bootstrap-based HTML layout for our app
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Bootstrap的HTML布局
- en: Let's look at the completed layout for our app. The layout is based on the Cover
    template provided by the official Bootstrap docs, and has several sections. We'll
    cover them in the order in which they appear in the code, top to bottom.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们应用程序完成的布局。布局基于官方 Bootstrap 文档提供的 Cover 模板，并包含几个部分。我们将按照它们在代码中出现的顺序，从上到下介绍它们。
- en: 'To begin with, we have the `DOCTYPE` and the `head` tag. This code sets the
    Bootstrap 4 template as an HTML5 page, provides some meta information, gives our
    page a title, and calls the Bootstrap 4 CSS from a CDN (content delivery network):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `DOCTYPE` 和 `head` 标签。这段代码将 Bootstrap 4 模板设置为 HTML5 页面，提供一些元信息，给我们的页面一个标题，并从
    CDN（内容分发网络）调用 Bootstrap 4 CSS。
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Just above the closing `head` tag, we have a relatively lengthy `style` tag.
    This tag provides custom CSS styles on top of the regular Bootstrap 4 styles we
    imported from a CDN, as explained in the preceding code. The custom styles have
    the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `head` 标签的上方，我们有一个相对较长的 `style` 标签。这个标签在从 CDN 导入的常规 Bootstrap 4 样式之上提供了自定义
    CSS 样式，如前述代码所述。自定义样式具有以下代码：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we have the `body` tag, which holds the page title and the input fields
    for our app:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `body` 标签，它包含页面的标题和我们的应用程序的输入字段：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we put all of the preceding sections together and save them as an HTML
    file, then run that file in a browser, the browser will render a page that looks
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将所有前面的部分组合在一起，并将它们保存为 HTML 文件，然后在浏览器中运行该文件时，浏览器将渲染一个看起来像这样的页面：
- en: '![](img/83a220b7-9874-48b2-9dbd-4c02374a0f66.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83a220b7-9874-48b2-9dbd-4c02374a0f66.png)'
- en: Now that we have a nice layout to work with, let's convert it into an Elm `view`
    function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个很好的布局可以工作，让我们将其转换为 Elm 的 `view` 函数。
- en: Converting an HTML layout into an Elm view
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HTML布局转换为Elm视图
- en: 'Now that we''ve completed the previous section of this chapter, it''s time
    to take a break from Unit Converter App''s functionality, and look at our app
    from an entirely different angle: design.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了本章的前一部分，是时候从 Unit Converter 应用程序的功能中休息一下，并从完全不同的角度来审视我们的应用程序：设计。
- en: 'In order to fully understand the process of creating a design for our app,
    we''ll take a drastic approach: we''ll build a new app from scratch, this time
    focusing on design only. After we''ve finished our design, we''ll add the changes
    to our Unit Converter''s functionality.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解为我们的应用程序创建设计的过程，我们将采取一种极端的方法：我们将从头开始构建一个新的应用程序，这次只关注设计。完成设计后，我们将添加更改到我们的
    Unit Converter 的功能中。
- en: 'To be able to follow along, you should create a completely new app. Let''s
    call it design-focused. Point your console to a folder in which you want to save
    your design-focused app, and run the following commands:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟上，你应该创建一个全新的应用程序。让我们称它为以设计为重点。将你的控制台指向你想要保存以设计为重点应用程序的文件夹，并运行以下命令：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we have seen so many times before, this will run a brand new Elm app, displaying
    only a navy blue-colored Elm logo at the upper-center section of our browser window.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前多次看到的，这将运行一个新的 Elm 应用程序，只在浏览器窗口的上中部显示一个海军蓝色的 Elm 标志。
- en: 'Now, we can start building our app''s design. To begin, we''ll remind ourselves
    of the bare-bones template we used in the previous chapter:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始构建我们应用程序的设计。首先，我们将回顾一下我们在上一章中使用的裸骨模板：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have our bare-bones app, it''s time to add custom styles to it.
    In our HTML template, we served them from the head of the HTML document. This
    time, we''ll do something different. Just under the imports in the bare-bones
    app, add the following function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的裸骨应用程序，是时候给它添加自定义样式了。在我们的 HTML 模板中，我们从 HTML 文档的头部提供了它们。这次，我们将做一些不同的事情。在裸骨应用程序的导入下面，添加以下函数：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What this does is create a style tag that calls the minified Bootstrap CSS file
    from a CDN.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的就是创建一个样式标签，该标签从 CDN 调用压缩后的 Bootstrap CSS 文件。
- en: 'Next, we''ll update our app''s `view` function so that its code is the same
    as the one we have in our HTML layout. Once converted from HTML to Elm (using
    the online converter at [https://mbylstra.github.io/html-to-elm/](https://mbylstra.github.io/html-to-elm/)),
    we''ll just add the `stylesheet` function, as follows. The layout''s HTML, in
    the form of an Elm `view` function, will look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新我们应用的`view`函数，使其代码与我们的HTML布局中的代码相同。一旦从HTML转换为Elm（使用[https://mbylstra.github.io/html-to-elm/](https://mbylstra.github.io/html-to-elm/)上的在线转换器），我们只需添加`stylesheet`函数，如下所示。布局的HTML，以Elm
    `view`函数的形式，将看起来像这样：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, we have given our app a static view that gets rendered to our web page.
    However, we are serving no custom styles from the Cover template we got from the
    official Bootstrap site.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为我们的应用添加了一个静态视图，该视图会被渲染到我们的网页上。然而，我们没有从官方Bootstrap网站获取的Cover模板中提供任何自定义样式。
- en: There is a great CDN that can help us with that, called RawGit, available at [https://rawgit.com/](https://rawgit.com/).
    What RawGit does is let you use any raw file from GitHub, paste in its address,
    and get back a CDN link that you can use in your apps.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个叫做RawGit的CDN可以帮我们解决这个问题，它可在[https://rawgit.com/](https://rawgit.com/)找到。RawGit的作用是让您使用GitHub上的任何原始文件，粘贴其地址，然后获取一个您可以在应用中使用CDN链接。
- en: So, for our custom Cover template's CSS to be included in our app, we can just
    locate its raw address on GitHub, which is as follows: [https://raw.githubusercontent.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css](https://raw.githubusercontent.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css). Now
    that we have the raw link, we can just paste it into RawGit, and use the following
    link that it gives us: [https://rawgit.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css](https://rawgit.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了将我们的自定义Cover模板的CSS包含到我们的应用中，我们只需在GitHub上找到它的原始地址，如下所示：[https://raw.githubusercontent.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css](https://raw.githubusercontent.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css)。现在我们有了原始链接，我们只需将其粘贴到RawGit中，并使用它提供的以下链接：[https://rawgit.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css](https://rawgit.com/twbs/bootstrap/v4-dev/docs/4.0/examples/cover/cover.css)。
- en: 'Now, we can add the Cover template styles too, just under the `bootstrapCss`
    function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`bootstrapCss`函数下方添加Cover模板样式。
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need to call these styles in our `view` function. The update will occur
    at the beginning of the `view` function so that its first few lines look like
    this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的`view`函数中调用这些样式。更新将在`view`函数的开始处发生，使其前几行看起来像这样：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that we have saved everything and run our app, we'll see the static view
    with all the styles served. There is just a slight improvement that needs to be
    made, and that is that the `div` with the class of `site-wrapper-inner needs`
    to be set to the width of 100vh. Let's do that now in our view function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经保存了一切并运行了我们的应用，我们将看到带有所有样式的静态视图。只需要进行一点小的改进，那就是将具有`site-wrapper-inner`类的`div`设置为100vh的宽度。现在让我们在我们的视图函数中实现这一点。
- en: 'Locate the following line of code in the `view` function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`view`函数中找到以下代码行：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, replace that line of code with the improved code that adds the inline
    style using the `style` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此代码行替换为使用`style`函数添加内联样式的改进代码：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, let's change the buttons on our app by giving them a different class.
    In Main.elm's `view` function, find all the instances of `btn-secondary` and replace
    them with `btn-warning`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过给它们赋予不同的类来更改我们应用中的按钮。在Main.elm的`view`函数中，找到所有`btn-secondary`的实例，并将它们替换为`btn-warning`。
- en: You also might want to change that dark background color to something more pleasing.
    Unfortunately, we cannot just replace one class with another, since the background
    color is specified in the custom cover.css file that we are serving from the CDN.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可能希望将那个深色背景颜色改为更令人愉悦的颜色。不幸的是，我们无法简单地用一个类替换另一个类，因为背景颜色是在我们从CDN提供的自定义cover.css文件中指定的。
- en: 'To make things more interesting, we''ll use an online CSS gradient generator,
    available at [https://uigradients.com/#VeryBlue](https://uigradients.com/#VeryBlue).
    This link points to their #VeryBlue gradient, but feel free to use another that
    suits you.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更有趣，我们将使用一个在线CSS渐变生成器，可在[https://uigradients.com/#VeryBlue](https://uigradients.com/#VeryBlue)找到。此链接指向他们的#VeryBlue渐变，但请随意使用适合您的另一个渐变。
- en: 'The CSS we generated from the gradient website is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从渐变网站生成的CSS如下所示：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can convert it to inline Elm styles and update the outermost `div`
    of our `view` function so that the first dozen lines of our `view` function look
    like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将其转换为内联 Elm 样式，并更新我们 `view` 函数的最外层 `div`，使得我们的 `view` 函数的前十几行看起来像这样：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s update the input fields now:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新输入字段：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s introduce the append `div`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍附加的 `div`：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding code produces a nice-looking site. However, we still need to add
    the preceding `view` information to our functioning app. We'll do that next.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生了一个看起来很不错的网站。然而，我们仍然需要将上述 `view` 信息添加到我们的功能应用中。我们将在下一部分完成这项工作。
- en: Adding the improved view to our functioning app
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将改进的视图添加到我们的功能应用中
- en: At the beginning of this chapter, we built our app's functionality. After that,
    we built a design from scratch, based on a free Bootstrap 4 template. Now, it's
    time to get the best of both worlds.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们构建了应用的功能。之后，我们从头开始构建了一个设计，基于一个免费的 Bootstrap 4 模板。现在，是时候将两者的优点结合起来。
- en: 'To begin, switch back to the app we called **unit-converter-complex**. Next,
    simply copy and paste the slightly-improved code into the updated `UnitConverter.elm`
    file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，切换回我们称为 **unit-converter-complex** 的应用。接下来，只需简单地将略微改进的代码复制粘贴到更新的 `UnitConverter.elm`
    文件中：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we''ll focus on changing the following section:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注更改以下部分：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first improvement we will make will be a simple replacement of other function
    calls with button functions where needed:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行的第一次改进将是将所需的其他函数调用简单地替换为按钮函数：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we''ll slowly start building our more Bootstrap-like look:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐步开始构建更类似 Bootstrap 的外观：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we''ll pull in everything inside the wrapping `div`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将将包装 `div` 内部的所有内容拉入：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s pull in the append buttons:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们拉入附加的按钮：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After building up the site slowly from the inside out, the final code will
    be as follows. The `Main.elm` file will look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从内部到外部逐步构建网站后，最终的代码将如下所示。`Main.elm` 文件将看起来像这样：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `UnitConverter.elm` file will look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnitConverter.elm` 文件将看起来像这样：'
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There is a lot of code, but we have discussed all of it already. Even though
    there are some changes from what we had in the original design-focused file, the
    important thing is that we have finally built a fully functional, beautiful Unit
    Conversion website in Elm.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码量很大，但我们已经讨论了所有这些内容。尽管与原始以设计为重点的文件相比有一些变化，但重要的是我们最终在 Elm 中构建了一个功能齐全、美观的单位转换网站。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In [Chapter 5](d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml), *Completing the
    Unit Conversion Website in Elm*, we improved our Unit Converter app so that it
    works with multiple inputs, that is, it can convert more than a single unit of
    measurement. Along the way, we learned a number of important concepts:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml)，《在 Elm 中完成单位转换网站》，我们改进了我们的单位转换器应用，使其能够处理多个输入，也就是说，它可以转换多个测量单位。在这个过程中，我们学习了许多重要的概念：
- en: Using `Html.map`
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Html.map`
- en: Working with complex relationships between different views
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与不同视图之间复杂关系的处理
- en: Working with multiple messages in views
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中处理多个消息
- en: Working with multiple models
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个模型
- en: Combining everything we learned in a relatively complex app
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合我们在一个相对复杂的应用中学到的所有知识
- en: In the first five chapters of this book, we have followed a hands-on approach
    which has involved a lot of coding and app building. For the most part, we have
    briefly touched on theory only where it was absolutely necessary. In the next
    chapter, we'll fill in the gaps in our knowledge by exploring the Elm language
    in more detail.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前五章中，我们采取了一种动手实践的方法，这涉及大量的编码和应用构建。大部分情况下，我们只在绝对必要时简要地提到了理论。在下一章中，我们将通过更详细地探索
    Elm 语言来填补我们知识上的空白。
