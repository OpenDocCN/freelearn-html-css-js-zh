- en: Chapter 10. Building a Game – Pacman
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 构建游戏 - Pacman
- en: 'In this chapter, we will build the game called **Pacman**. We will learn how
    to program with the help of HTML5 Canvas in Opa, including drawing shapes, texts,
    and images on the canvas. We will also discuss how to use an external JavaScript
    library. The complete source code can be found at [https://github.com/winbomb/opapackt/tree/master/opacman](https://github.com/winbomb/opapackt/tree/master/opacman).
    Following is a screenshot of our Pacman game:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建名为**Pacman**的游戏。我们将学习如何在Opa的帮助下使用HTML5 Canvas进行编程，包括在画布上绘制形状、文本和图像。我们还将讨论如何使用外部JavaScript库。完整的源代码可以在[https://github.com/winbomb/opapackt/tree/master/opacman](https://github.com/winbomb/opapackt/tree/master/opacman)找到。以下是我们的Pacman游戏的截图：
- en: '![Building a Game – Pacman](img/3749OS_10_01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![构建游戏 - Pacman](img/3749OS_10_01.jpg)'
- en: The project structure
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'Create an empty Opa project with the `opa create opacman` command. We need
    to modify the project structure. Let''s first have a look at the modified project
    structure of our Pacman game:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`opa create opacman`命令创建一个空的Opa项目。我们需要修改项目结构。让我们首先看看我们的Pacman游戏的修改后的项目结构：
- en: '![The project structure](img/3749OS_10_02.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构](img/3749OS_10_02.jpg)'
- en: 'The following is a brief description of the project files:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对项目文件的简要描述：
- en: '`src`: The source code, `ghost.opa` and `pacman.opa` define the type of ghost
    and Pacman, `render.opa` takes charge of drawing on the canvas, and `game.opa`
    contains the game logic'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：源代码，`ghost.opa`和`pacman.opa`定义了幽灵和Pacman的类型，`render.opa`负责在画布上绘制，而`game.opa`包含游戏逻辑'
- en: '`resources`: This folder contains the required resources, including images,
    sounds, and styles'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`：此文件夹包含所需资源，包括图像、声音和样式'
- en: '`resources/js`: `Preloadjs.min.js` and `soundjs.min.js` are two open source
    JavaScript libraries and are used to preload game resources and to play sounds'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources/js`：`Preloadjs.min.js`和`soundjs.min.js`是两个开源JavaScript库，用于预加载游戏资源和播放声音'
- en: '`plugins`: `Preloader.js` is a plugin that we write to load game resources.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plugins`：`Preloader.js`是我们编写的用于加载游戏资源的插件。'
- en: 'We need to rewrite the `opa.conf` file to include the source code in the `src`
    directory:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要重写`opa.conf`文件以在`src`目录中包含源代码：
- en: '`opacman.game` has the following files:'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`opacman.game`包含以下文件：'
- en: '`src/game.opa`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/game.opa`'
- en: '`src/ghost.opa`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/ghost.opa`'
- en: '`src/pacman.opa`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/pacman.opa`'
- en: '`src/render.opa`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/render.opa`'
- en: 'We need to modify `Makefile` to remove database support as we do not need the
    database in this application. We also need to tell the compiler to compile the
    plugins with source code. These two jobs can be done by changing `FLAG` with the
    following line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`Makefile`以移除数据库支持，因为我们在这个应用程序中不需要数据库。我们还需要告诉编译器编译插件时使用源代码。这两项工作可以通过将`FLAG`更改为以下行来完成：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The HTML5 Canvas
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5 Canvas
- en: 'First of all, we need a canvas element on which to draw our graphics. The HTML5
    Canvas element is an HTML tag similar to the `<div>`, `<a>`, and `<table>` tags,
    with the exception that its contents are rendered with JavaScript. In Opa, we
    create a canvas element the exact same way in which we create other HTML elements:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个画布元素来绘制我们的图形。HTML5 Canvas元素与`<div>`、`<a>`和`<table>`标签类似，不同之处在于其内容是用JavaScript渲染的。在Opa中，我们创建画布元素的方式与创建其他HTML元素的方式完全相同：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code creates a canvas with the `gamecanvas` ID. When the canvas element
    is ready, the `Game.gamestart` function will be invoked to start the game.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个具有`gamecanvas` ID的画布。当画布元素准备好时，`Game.gamestart`函数将被调用以开始游戏。
- en: 'Next we must get the canvas context. It is important for us to understand the
    difference between the canvas element and the canvas context. The canvas element
    is a DOM node embedded in the HTML page, whereas the canvas context is an object
    with properties and methods that you can use to render graphics inside the canvas
    element. The context can be 2D or 3D (WebGL). In our Pacman game, we are using
    the 2D context. To get the canvas 2D context, we use the `Canvas.get_context_2d`
    function. The following code fragment demonstrates how to get the canvas context
    for a given ID:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须获取画布上下文。对于我们来说，理解画布元素和画布上下文之间的区别很重要。画布元素是嵌入在HTML页面中的DOM节点，而画布上下文是一个具有属性和方法的对象，您可以使用这些属性和方法在画布元素内渲染图形。上下文可以是2D或3D（WebGL）。在我们的Pacman游戏中，我们使用的是2D上下文。要获取画布2D上下文，我们使用`Canvas.get_context_2d`函数。以下代码片段演示了如何为给定ID获取画布上下文：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that each canvas element can only have one context. If we use the `Canvas.get_context_2d`
    method multiple times for the same element, it will return the same context.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个画布元素只能有一个上下文。如果我们对同一个元素多次使用 `Canvas.get_context_2d` 方法，它将返回相同的上下文。
- en: Drawing a shape
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个形状
- en: Now that we have the context of our canvas element, we can draw graphics on
    it. Opa and JavaScript use similar code to draw the graphics. The primary difference
    between them is that the drawing functions in Opa are static. All drawing methods
    can be found in the `Canvas` module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了画布元素的上下文，我们可以在它上面绘制图形。Opa和JavaScript使用类似的代码来绘制图形。它们之间的主要区别是Opa中的绘图函数是静态的。所有绘图方法都可以在
    `Canvas` 模块中找到。
- en: Using the fill and stroke properties
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用填充和描边属性
- en: 'Whenever we wish to draw shapes on a canvas, there are two properties that
    we need to set: `Stroke` and `Fill`. `Stroke` and `fill` determine how the shape
    is drawn. The `stroke` property is used for the outline of a shape; the `fill`
    property is used for the inside of a shape. In the following example, the first
    two lines fill a rectangle, whereas the last three lines stroke a rectangle:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想在画布上绘制形状时，我们需要设置两个属性：`Stroke` 和 `Fill`。`Stroke` 和 `fill` 决定了形状的绘制方式。`stroke`
    属性用于形状的轮廓；`fill` 属性用于形状的内部。在以下示例中，前两行填充了一个矩形，而后三行则描边了一个矩形：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Following is the result of the preceding code fragment:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了前面的结果：
- en: '![Using the fill and stroke properties](img/3749OS_10_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![使用填充和描边属性](img/3749OS_10_03.jpg)'
- en: Note that we used `Canvas.save` and `Canvas.restore` in the preceding code.
    Each canvas context maintains a stack of drawing states such as `fillStyle` and
    `strokeStyel`. Since a canvas can only have one 2D context, `Canvas.save` and
    `Canvas.restore` are used to save and restore canvas states in short.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在前面的代码中使用了 `Canvas.save` 和 `Canvas.restore`。每个画布上下文都维护着一个包含诸如 `fillStyle`
    和 `strokeStyle` 等绘图状态的栈。由于画布只能有一个2D上下文，因此使用 `Canvas.save` 和 `Canvas.restore` 来在短时间内保存和恢复画布状态。
- en: Drawing a curve
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制一个曲线
- en: In our game, we create our Pacman by drawing an arc on the canvas. When the
    Pacman's mouth is open, we draw a pie, and when it's closed, we draw a circle.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们通过在画布上绘制一个弧线来创建我们的Pacman。当Pacman的嘴巴张开时，我们绘制一个饼形，当它闭合时，我们绘制一个圆形。
- en: 'We can draw the pie and the circle both with the `Canvas.arc` function. Arcs
    are defined by a center point, a radius, a starting angle, an ending angle, and
    the drawing direction (either clockwise or counterclockwise). The following diagram
    shows how we should draw the Pacman when he is facing left:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Canvas.arc` 函数绘制饼形和圆形。弧线由一个中心点、一个半径、一个起始角度、一个结束角度和绘制方向（顺时针或逆时针）定义。以下图表显示了当Pacman面向左时我们应该如何绘制它：
- en: '![Drawing a curve](img/3749OS_10_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![绘制一个曲线](img/3749OS_10_04.jpg)'
- en: 'First, we move to the center point and begin drawing from the starting angle
    `5*PI/4`. We then draw an arc to the ending angle `3*PI/4` moving clockwise. Finally,
    we fill and stroke the shape. Here is the code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将移动到中心点，并从起始角度 `5*PI/4` 开始绘制。然后我们按顺时针方向绘制一个到结束角度 `3*PI/4` 的弧线。最后，我们填充和描边这个形状。以下是代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Drawing an image
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个图像
- en: 'To display an image on HTML5 Canvas in Opa, we can use the `Canvas.draw_image`
    function that requires an image object and a destination point. Since the `draw_image`
    method requires an image object, we must first create an image and wait for it
    to load before we can draw it on the canvas. In our game, we will preload all
    images and sounds at the beginning of the game as you will see later. The `Canvas.draw_image`
    function is declared as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Opa中，要在HTML5 Canvas上显示图像，我们可以使用 `Canvas.draw_image` 函数，该函数需要一个图像对象和一个目标点。由于
    `draw_image` 方法需要一个图像对象，我们必须首先创建一个图像，并在它加载完成后才能在画布上绘制它。在我们的游戏中，我们将在游戏开始时预加载所有图像和声音，正如你稍后将会看到的。`Canvas.draw_image`
    函数声明如下：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first argument that we pass to `draw_image` is the canvas context that
    we retrieved. The second argument is the image object of type `Canvas.image`.
    The `Canvas.image` type is declared as:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `draw_image` 的第一个参数是我们检索到的画布上下文。第二个参数是类型为 `Canvas.image` 的图像对象。`Canvas.image`
    类型声明如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Image.image` is an external type. It is identical to the image type that we
    created in JavaScript with the `new Image()` code.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image.image` 是一个外部类型。它与我们在JavaScript中使用 `new Image()` 代码创建的图像类型相同。'
- en: 'We preload the images when the game starts. When needed, we will obtain an
    image object by calling the plugin function as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，我们预加载图像。当需要时，我们将通过调用以下插件函数来获取图像对象：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In addition to the draw_image function, there are two more functions that we
    can use to draw images on canvas:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `draw_image` 函数外，还有两个我们可以用来在画布上绘制图像的函数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To set the size of an image, we can use `draw_image_with_dimensions`. This will
    scale the image to the target size. The `draw_image_full` function is even more
    powerful, as we can use it to crop the image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置图像的大小，我们可以使用 `draw_image_with_dimensions`。这将按目标大小缩放图像。`draw_image_full` 函数功能更强大，因为我们可以使用它来裁剪图像。
- en: Drawing the text
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制文本
- en: To display texts on a canvas in Opa, we can use the `Canvas.fill_text` or `Canvas.stroke_text`
    method. We can change the fill style or stroke style by invoking `Canvas.set_fill_style`
    or `Canvas.set_stroke_style` respectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Opa 画布上显示文本，我们可以使用 `Canvas.fill_text` 或 `Canvas.stroke_text` 方法。我们可以通过调用
    `Canvas.set_fill_style` 或 `Canvas.set_stroke_style` 分别更改填充样式或描边样式。
- en: 'To set the font of the text, use the `Canvas.set_font` function. We should
    pass the font information to the method; the font information is a string matching
    the following pattern:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置文本的字体，请使用 `Canvas.set_font` 函数。我们应该将字体信息传递给该方法；字体信息是一个与以下模式匹配的字符串：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code draws the word "start" twice, one is filled and the other
    is stroked, both with font information `italic bold 40px verdana`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码绘制了单词 "start" 两次，一个是填充的，另一个是描边的，两者都带有字体信息 `italic bold 40px verdana`：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result of the preceding code fragment is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段的结果如下：
- en: '![Drawing the text](img/3749OS_10_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![绘制文本](img/3749OS_10_05.jpg)'
- en: Binding the external JavaScript library
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定外部 JavaScript 库
- en: In our Pacman game, we need to preload game resources such as images and sounds.
    We need to play sounds and music as well. Of course, we could write our own code
    to accomplish these tasks. However, why reinvent the wheel? There are numerous
    JavaScript libraries that make our job easier. The following section shows how
    to bind an existing JavaScript library into our game.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Pacman 游戏中，我们需要预加载游戏资源，如图像和声音。我们还需要播放声音和音乐。当然，我们可以编写自己的代码来完成这些任务。然而，为什么要重新发明轮子呢？有无数的
    JavaScript 库可以使我们的工作变得更简单。下一节将展示如何将现有的 JavaScript 库绑定到我们的游戏中。
- en: Preloading the resources
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预加载资源
- en: When a program requires multiple images and sounds, as is the case with our
    Pacman game, it's usually a good idea to load all of the resources before displaying
    or playing them. There are many excellent JavaScript libraries available. For
    our purposes, the Preload JS 0.3.0 (for resource) and SoundJS 0.4.0 (for sounds)
    libraries are a good fit. You can download Preload JS 0.3.0 from [https://github.com/CreateJS/PreloadJS](https://github.com/CreateJS/PreloadJS)
    and the SoundJS 0.4.0 library is available at [https://github.com/CreateJS/SoundJS](https://github.com/CreateJS/SoundJS).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序需要多个图像和声音时，就像我们的 Pacman 游戏一样，通常在显示或播放它们之前加载所有资源是个好主意。有许多优秀的 JavaScript
    库可供选择。就我们的目的而言，Preload JS 0.3.0（用于资源）和 SoundJS 0.4.0（用于声音）库是一个不错的选择。您可以从 [https://github.com/CreateJS/PreloadJS](https://github.com/CreateJS/PreloadJS)
    下载 Preload JS 0.3.0，SoundJS 0.4.0 库可在 [https://github.com/CreateJS/SoundJS](https://github.com/CreateJS/SoundJS)
    获取。
- en: 'To bind the JavaScript library, we must register those functions that we plan
    to call from within our Opa code. We have discussed how to bind JavaScript in
    [Chapter 6](ch06.html "Chapter 6. Binding with Other Languages"), *Binding with
    Other Languages*. In our Pacman game, we register a `preload` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定 JavaScript 库，我们必须注册我们计划从我们的 Opa 代码中调用的那些函数。我们已经在 [第 6 章](ch06.html "第 6
    章。与其他语言绑定") *与其他语言绑定* 中讨论了如何绑定 JavaScript。在我们的 Pacman 游戏中，我们注册了一个 `preload` 函数：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `preload` function uses `PreloadJS` to preload resources, and will invoke
    a callback when it is finished. We can call the `preload` function in Opa in the
    following way:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`preload` 函数使用 `PreloadJS` 预加载资源，并在完成后调用回调函数。我们可以在 Opa 中以下方式调用 `preload` 函数：'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete code can be found in `plugins/preloader.js` and `/src/game.opa`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在 `plugins/preloader.js` 和 `/src/game.opa` 中找到。
- en: Playing sounds
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放声音
- en: We bind the `SoundJS` library and play sounds by registering a function in the
    `preloader.js` plugin file. The function invokes methods from SoundJS to build
    a sound instance and then play it. The `SoundJS` library is entirely out of the
    scope of this book. For more details regarding the use of this library visit the
    SoundJS homepage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绑定 `SoundJS` 库并通过在 `preloader.js` 插件文件中注册一个函数来播放声音。该函数调用 SoundJS 中的方法来构建声音实例然后播放它。`SoundJS`
    库完全超出了本书的范围。有关该库的更多详细信息，请访问 SoundJS 主页。
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a game called **Pacman**. First, we discussed how
    to declare an HTML5 Canvas element and how to get canvas context. Then, we reviewed
    how to draw shapes, images, and texts on a canvas. Finally, we showed how to write
    a plugin and embed external JavaScript libraries in the application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个名为**Pacman**的游戏。首先，我们讨论了如何声明一个HTML5画布元素以及如何获取画布上下文。然后，我们回顾了如何在画布上绘制形状、图像和文本。最后，我们展示了如何编写插件并将外部JavaScript库嵌入到应用程序中。
