- en: Improving the User Experience for Your Bots
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升您的聊天机器人的用户体验
- en: After having learned how to create Alexa Skills and Lex chatbots, we will now
    learn how we can improve the user experience. This is important, as adding images
    to your Lex chatbot or having a better voice model for Alexa can make a huge difference
    to whether the user enjoys interacting with your chatbot. Adding these features
    will also make your chatbots stand out from the basic, text-only chatbots.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何创建Alexa技能和Lex聊天机器人之后，我们现在将学习如何提升用户体验。这非常重要，因为为Lex聊天机器人添加图片或为Alexa提供更好的语音模型，都会对用户是否享受与聊天机器人的互动产生巨大影响。添加这些功能也将使您的聊天机器人从基本的纯文本聊天机器人中脱颖而出。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Adding response cards to Lex chatbots
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将响应卡片添加到Lex聊天机器人中
- en: Using phrase slots to create a more refined voice model for Alexa Skills
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用短语槽位为Alexa技能创建更精细的语音模型
- en: Using utterance monitoring with Amazon Lex to refine interaction models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon Lex的语音监测来细化交互模型
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be modifying our existing Lambda functions, so we'll
    be deploying them using the local development setup that we created [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml),
    *Getting Started with AWS and Amazon CLI*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将修改现有的Lambda函数，因此我们将使用我们创建的本地开发环境来部署它们[第2章](ac448944-0559-408e-a9c4-972933a03611.xhtml)，*AWS和Amazon
    CLI入门*。
- en: All of the code and data required for this chapter can be found at [http://bit.ly/chatbot-ch8](http://bit.ly/chatbot-ch8).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的所有代码和数据都可以在[http://bit.ly/chatbot-ch8](http://bit.ly/chatbot-ch8)找到。
- en: Response cards in Amazon Lex
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon Lex中的响应卡片
- en: 'Cards give you a way to offer a richer in-conversation experience than just
    text messages by integrating buttons, images, and more. Cards can be used for
    many purposes, such as displaying product information, asking the message recipient
    to choose from a predetermined set of options, and showing search results. If
    you are integrating your cards into Slack or Facebook, then they will be shown
    on those platforms:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片通过集成按钮、图片等，为您提供了比纯文本消息更丰富的对话体验。卡片可用于多种用途，例如显示产品信息、让消息接收者从预定的选项集中选择，以及显示搜索结果。如果您将卡片集成到Slack或Facebook中，它们将显示在这些平台上：
- en: '![](img/01ef9d44-c468-47f8-9e93-a2f5a66064fe.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01ef9d44-c468-47f8-9e93-a2f5a66064fe.png)'
- en: Example cards in Facebook
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook中的示例卡片
- en: Creating a card
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建卡片
- en: 'To create a card, we need to change the format of the response that we are
    sending back to Lex. This means we need to change the functions in `LexResponses`
    by passing in a `responseCard` attribute. We can then add this `responseCard`
    to the `dialogAction` object. If we don''t pass in a response card parameter,
    we still want the function to work so we default it to `null`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建卡片，我们需要更改发送回Lex的响应格式。这意味着我们需要通过传递`responseCard`属性来更改`LexResponses`中的函数。然后我们可以将这个`responseCard`添加到`dialogAction`对象中。如果我们没有传递响应卡片参数，我们仍然希望函数能够工作，因此我们将其默认设置为`null`：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This needs to be done for `elicitSlot`, `close`, `elicitIntent`, and `confirmIntent`,
    but not for `delegate` as that function doesn't send messages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要对`elicitSlot`、`close`、`elicitIntent`和`confirmIntent`进行操作，但不包括`delegate`，因为该功能不会发送消息。
- en: 'To add a response card, we need to make sure that the response is also in the
    correct format. To make this easier for ourselves, we can make a new function
    inside `LexResponses` called `createCardFormat`. This will take a single attribute
    of cards, which is an array of objects containing a `title`, `subtitle`, `imageUrl`,
    `linkUrl`, and `buttons`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加响应卡片，我们需要确保响应也处于正确的格式。为了使这个过程更简单，我们可以在`LexResponses`内部创建一个新的函数，称为`createCardFormat`。这将接受卡片的一个属性，即包含`title`、`subtitle`、`imageUrl`、`linkUrl`和`buttons`的对象数组：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using cards in chats
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在聊天中使用卡片
- en: With our modified `LexResponses` class, we can now start adding cards to our
    existing Lex Lambdas. One obvious place to use cards is in the shopping app to
    display the items we found based on the user's search. This means we are going
    to alter our `productFind` Lambda.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们修改后的`LexResponses`类，我们现在可以开始向现有的Lex Lambda中添加卡片。一个明显的使用卡片的地方是在购物应用中显示基于用户搜索找到的商品。这意味着我们将修改我们的`productFind`
    Lambda。
- en: After we create the message telling the user how many of the items we have in
    stock (line 77 of `productFind`/`index.js`), we can create our first card.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的消息中告诉用户我们有多少库存的商品（`productFind`/`index.js`的第77行）之后，我们可以创建我们的第一个卡片。
- en: 'This is going to be a single card with a title of the item, a subtitle of the
    stock, an image, and `Add to Cart` and `Not Now` buttons:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个带有项目标题的单个卡片，库存的副标题，图像，以及“添加到购物车”和“现在不”按钮：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we are giving the buttons a different value to their text. This
    allows the response we receive to be different from the button that the user clicks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在给按钮赋予与文本不同的值。这使得我们收到的响应可以与用户点击的按钮不同。
- en: You may have noticed that we have also added an image using `item.imageURL`
    but this never existed in our original data. We need to go through and add this
    to each of the items in the stock data. Luckily, we can use the same image for
    the different sizes of clothes. The stock data with images is available to download
    at [bit.ly/chatbot-ch8](http://bit.ly/chatbot-ch8).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们使用 `item.imageURL` 添加了一个图像，但这个图像在我们的原始数据中并不存在。我们需要遍历并添加到库存数据中的每个项目。幸运的是，我们可以使用相同的图像来处理不同尺寸的衣物。带有图像的库存数据可在
    [bit.ly/chatbot-ch8](http://bit.ly/chatbot-ch8) 下载。
- en: 'When we deploy these changes, we can test it out in the Lex chat window. We
    can go through the normal `productFind` flow up to the point where we are shown
    the product selected. When we are told how many are in stock, we are also shown
    a card displaying the information:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们部署这些更改时，我们可以在 Lex 聊天窗口中测试它们。我们可以通过正常的 `productFind` 流程，直到我们看到选定的产品。当我们被告知库存数量时，我们还会看到一个显示信息的卡片：
- en: '![](img/4393720f-7b1f-46aa-9e1a-1190ccbf44a8.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4393720f-7b1f-46aa-9e1a-1190ccbf44a8.png)'
- en: Chat card
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天卡片
- en: 'If we have the Facebook or Slack integrations hooked up from the previous chapters,
    then our new cards should work on there too. Lex does a lot of clever logic to
    translate the card into the correct format needed for each platform and then uses
    them in the replies. It should be noted that Facebook crops the images to a 1:1.9
    ratio, so selecting your images with that in mind is a good idea:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从前几章中设置了 Facebook 或 Slack 集成，那么我们的新卡片也应该在那里工作。Lex 会进行很多聪明的逻辑转换，将卡片转换为每个平台所需的正确格式，然后在回复中使用它们。需要注意的是，Facebook
    会将图像裁剪为 1:1.9 的比例，所以考虑到这一点选择你的图像是个好主意：
- en: '![](img/ef8c6998-4329-493d-bf3f-f5428ee288be.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef8c6998-4329-493d-bf3f-f5428ee288be.png)'
- en: Facebook card
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 卡片
- en: Alexa search queries
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Alexa 搜索查询
- en: Alexa is great when you know the sort of responses that your users are going
    to be saying, but what if they ask for something you aren't expecting? Even using
    custom slot types can be limiting, which could result in a user's request being
    incorrectly handled. Luckily, Amazon has introduced the Search Query slot type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道用户将要说的响应类型时，Alexa 是很棒的，但如果他们询问你意料之外的东西呢？即使使用自定义槽位类型也可能有限制，这可能导致用户的请求被错误处理。幸运的是，亚马逊引入了搜索查询槽位类型。
- en: This slot type for Alexa is designed to be able to take a much wider range of
    values so that you can handle more requests.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用于 Alexa 的槽位类型旨在能够接受更广泛的值范围，以便您能够处理更多请求。
- en: We're going to add a new intent onto our existing Weather Gods skill that uses
    a Search Query slot type to allow users to search for places in a city. We'll
    be using Google Maps API to power the backend.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在现有的天气之神技能中添加一个新的意图，该意图使用搜索查询槽位类型，允许用户在某个城市中搜索地点。我们将使用 Google Maps API 来提供后端支持。
- en: 'Go to your Alexa developer''s console and open the `WeatherGods` skill. Add
    a new intent called `searchIntent` and we can start by creating the different
    slots that we''ll be using. Create two slots, one called `query` and the other
    called `city`. Our query slot can be given a slot type of AMAZON.SearchQuery and
    our city slot will be AMAZON.US_CITY:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前往你的 Alexa 开发者控制台并打开 `WeatherGods` 技能。添加一个名为 `searchIntent` 的新意图，我们可以从创建我们将要使用的不同槽位开始。创建两个槽位，一个名为
    `query`，另一个名为 `city`。我们的查询槽位可以指定为 AMAZON.SearchQuery，我们的城市槽位将是 AMAZON.US_CITY：
- en: '![](img/701adf1a-5e6a-467c-ac4c-de7438360c94.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/701adf1a-5e6a-467c-ac4c-de7438360c94.png)'
- en: Search slots
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索槽位
- en: 'With the slots completed, we can start populating the utterances. Unfortunately,
    we can''t have a search query slot in an utterance with another slot so we''ll
    have to fill one slot at a time. We should allow a user to ask about a city or
    ask a query to start the intent:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 完成槽位后，我们可以开始填充话语。不幸的是，我们不能在包含另一个槽位的话语中有一个搜索查询槽位，所以我们将不得不一次填充一个槽位。我们应该允许用户询问一个城市或提出一个查询以启动意图：
- en: '![](img/aba3813d-d8f6-45fc-97c8-1383604cd57a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aba3813d-d8f6-45fc-97c8-1383604cd57a.png)'
- en: Utterances for search query
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索查询的话语
- en: Now that we have our slots and utterances completed, we can modify our existing
    `weatherGods` Lambda to handle the new intent. Find the Lambda in your editor,
    open the `index.js` file, and go into the `handlers` object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了槽位和语句的设置，我们可以修改现有的 `weatherGods` Lambda 来处理新的意图。在您的编辑器中找到 Lambda，打开
    `index.js` 文件，进入 `handlers` 对象。
- en: 'Inside the `handlers` object, we need to add a new handler called `searchIntent`.
    This handler will start by getting the city and query slot values and checking
    whether they exist. If they don''t, we''ll ask the user to tell us the missing
    information. We check `cityValue` first, so we can specify the city when we ask
    for the query:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handlers` 对象内部，我们需要添加一个新的处理器，称为 `searchIntent`。这个处理器将首先获取城市和查询槽位值，并检查它们是否存在。如果它们不存在，我们将要求用户告诉我们缺失的信息。我们首先检查
    `cityValue`，这样当我们请求查询时可以指定城市：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we have both the city and query values, then we can use these to make a request
    to Google's Maps API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们既有城市值又有查询值，那么我们可以使用这些值来向 Google 地图 API 发送请求。
- en: Google Cloud Platform
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Platform
- en: To use Google Maps API, we need to set up a Google Cloud Platform developers
    account. We can get one by going to [cloud.google.com/](https://cloud.google.com/)
    and clicking Try free. You need to sign in to a Google account, confirm terms
    and conditions, and then enter payment information. Don't worry; you get $300
    of free credit when you start, so you shouldn't get billed any time soon.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Google Maps API，我们需要设置一个 Google Cloud Platform 开发者账户。我们可以通过访问 [cloud.google.com](https://cloud.google.com/)
    并点击“免费试用”来获取一个账户。您需要登录到一个 Google 账户，确认条款和条件，然后输入支付信息。不用担心；您在开始时将获得 300 美元的免费信用额度，所以您不会很快收到账单。
- en: To start, we need to create a project by clicking Select a project in the upper-left
    corner and then choosing NEW PROJECT. Now we can name our new project `WeatherGodsAPI`
    and click CREATE.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过点击左上角的“选择项目”并选择“新建项目”来创建一个项目。现在我们可以将我们的新项目命名为 `WeatherGodsAPI` 并点击“创建”。
- en: 'With our project created, we need to check that it is selected in the upper-left
    corner of the page and then we can start to set up this project. In the search
    box, we can search for `Places API` and enable it for this project:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目创建后，我们需要检查它是否已选中页面左上角，然后我们就可以开始设置这个项目了。在搜索框中，我们可以搜索“Places API”并为此项目启用它：
- en: '![](img/f61fe323-d4bc-4822-83c7-d33f324e06ea.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f61fe323-d4bc-4822-83c7-d33f324e06ea.png)'
- en: Places API
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Places API
- en: 'Once the Places API has been enabled on this project, we need to generate an
    API key so we can access it from our Lambda. Click on Credentials and, from the
    Create Credentials drop-down menu, select API Key:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在这个项目中启用了 Places API，我们需要生成一个 API 密钥，以便我们能够从我们的 Lambda 中访问它。点击“凭证”，然后从“创建凭证”下拉菜单中选择“API
    密钥”：
- en: '![](img/374b1877-cdf4-402d-b6d9-f53da14d5abd.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/374b1877-cdf4-402d-b6d9-f53da14d5abd.png)'
- en: Creating an API key
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 API 密钥
- en: You need to copy this API key, as we'll be using it in our Lambda.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要复制这个 API 密钥，因为我们将在我们的 Lambda 中使用它。
- en: Continuing Lambda building
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续构建 Lambda
- en: 'We now have an API key that we can use to hit the Google Places API. Copy it
    and open your Lambda in the Lambda console. Scroll down to Environment variables,
    and create a new variable with a key of GOOGLE_API_KEY, and paste the API key
    as the value. Make sure not to remove the other API key, which is for `openWeatherMaps`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以用来调用 Google Places API 的 API 密钥。复制它并打开您的 Lambda 在 Lambda 控制台中。向下滚动到环境变量，创建一个键为
    GOOGLE_API_KEY 的新变量，并将 API 密钥粘贴为值。确保不要删除其他 API 密钥，它是为 `openWeatherMaps` 使用的：
- en: '![](img/7374ea69-a4d1-45fe-a4a3-95b836298239.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7374ea69-a4d1-45fe-a4a3-95b836298239.png)'
- en: Storing environment variables
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 存储环境变量
- en: 'With our Google API key stored as an environment variable, we can create our
    request that we''ll be sending to Google. The format of the API request URL is
    this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的 Google API 密钥存储为环境变量后，我们可以创建我们将要发送给 Google 的请求。API 请求 URL 的格式如下：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To make it easier for ourselves, we can store most sections of this as constants,
    even the Google API key. In our `index.js` file, we can add these constants to
    the top of the file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们自己更容易操作，我们可以将这个文档的大部分内容存储为常量，甚至包括 Google API 密钥。在我们的 `index.js` 文件中，我们可以在文件顶部添加这些常量：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With these constants accessible, the only part that we need to generate is
    our search. To do this, we can take our `queryValue` and our `cityValue` and turn
    it into a search phrase. This can be done by joining `{queryValue}` and `{cityValue}`
    into a basic sentence. Because we are inserting this into a URL, we need to use
    `%20` instead of spaces and then we can build our request:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些常量可访问的情况下，我们唯一需要生成的是我们的搜索。为此，我们可以将 `queryValue` 和 `cityValue` 转换为一个搜索短语。这可以通过将
    `{queryValue}` 和 `{cityValue}` 组合成一个基本句子来完成。因为我们将其插入到 URL 中，所以需要使用 `%20` 而不是空格，然后我们可以构建我们的请求：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With our request URL built, we can make our request to Google. To catch any
    errors, we can use our `to` method and then check that there are no errors and
    that there is a `response.data` field. If we didn''t get what we expect, we can
    tell the user that we couldn''t find that information:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 构建了请求 URL 后，我们可以向 Google 发送请求。为了捕捉任何错误，我们可以使用我们的 `to` 方法，然后检查是否存在错误以及是否存在 `response.data`
    字段。如果我们没有得到预期的结果，我们可以告诉用户我们找不到该信息：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If our request did successfully return some data, then we can build a response
    for the user. First, we can tell them how many of their query there are in that
    city, and then we can list the names of each of those places:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的请求成功返回了一些数据，那么我们可以为用户构建一个响应。首先，我们可以告诉他们在该城市中有多少个查询，然后我们可以列出这些地点的名称：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've now completed our updated Lambda and can deploy it to AWS using our build
    script from [Chapter 2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting
    Started with AWS and Amazon CLI*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了更新的 Lambda，可以使用[第2章](ac448944-0559-408e-a9c4-972933a03611.xhtml)，《AWS
    和 Amazon CLI 入门》中的构建脚本将其部署到 AWS。
- en: Rebuilding the skill and testing
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新构建技能并测试
- en: Back in our skill in the Alexa Console, we can check our modified skill and
    make sure to save it and rebuild it. When it has finished building, we can click
    Test to try it out. You can test the old intents that we built in [Chapter 4](7567de44-8fd8-4f0a-b304-adfe6006e0a3.xhtml),
    *Connecting your Alexa Skill to External APIs*, and they should all work as before,
    but we really want to test our new intent.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Alexa 控制台中，我们可以检查修改后的技能，并确保保存它并重新构建。构建完成后，我们可以点击“测试”来尝试它。您可以测试我们在[第4章](7567de44-8fd8-4f0a-b304-adfe6006e0a3.xhtml)，《将您的
    Alexa 技能连接到外部 API》中构建的旧意图，并且它们应该像以前一样工作，但我们真正想测试的是我们的新意图。
- en: You can now ask the weather gods what there is in Manchester and say that you're
    looking for a Catholic cathedral, and your skill will ask Google for Catholic
    cathedral in Manchester. It should tell you there is one called Salford Cathedral.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以向天气之神询问曼彻斯特有什么，并说明您正在寻找一个天主教堂，您的技能将向 Google 查询曼彻斯特的天主教教堂。它应该告诉您有一个叫做索尔福德大教堂的教堂。
- en: 'While this is good, we could have used a custom slot type and listed lots of
    things that a user might ask for. This is where search queries are really useful:
    they can handle far less common requests. We can ask for Saint Paul''s primary
    school in Manchester, and we''ll get a result. There is no way we could have created
    a custom slot that would be large enough to include every school name:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很好，但我们本可以使用自定义槽类型并列出用户可能询问的大量内容。这正是搜索查询真正有用之处：它们可以处理远不那么常见的请求。我们可以询问曼彻斯特的圣保罗小学，我们会得到一个结果。我们不可能创建一个足够大的自定义槽来包含每个学校的名称：
- en: '![](img/bf5dc87b-fb31-43eb-89fe-968144e108be.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf5dc87b-fb31-43eb-89fe-968144e108be.png)'
- en: Testing search query
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 测试搜索查询
- en: Lex utterance monitoring
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lex 语句监控
- en: When you create your intents and generate the list of utterances, you try your
    best to cover everything that a user might say. Unfortunately, people often come
    up with unique ways of saying something that you've not thought of. In this case,
    the user will get an "*I don't understand*" message from Lex. This obviously isn't
    great for providing a good user experience.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建意图并生成语句列表时，您尽力涵盖用户可能说的所有内容。不幸的是，人们经常想出一些独特的方式来表达您未曾想到的内容。在这种情况下，用户将从 Lex
    获得一个“我不理解”的消息。这显然不利于提供良好的用户体验。
- en: Luckily, Lex has built-in monitoring to allow you to see the utterances that
    the users have been saying. To get to these, we need to click on the Monitoring
    tab in Lex. Lex utterances are stored for a specific chatbot version, so we need
    to select a value from the dropdown next to our chatbot name.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Lex 内置了监控功能，允许您查看用户所说的语句。要访问这些语句，我们需要点击 Lex 中的“监控”标签。Lex 语句存储在特定的聊天机器人版本中，因此我们需要从聊天机器人名称旁边的下拉菜单中选择一个值。
- en: 'You should now have a screen of graphs showing the Lex usage. This can be useful,
    but we''re looking for the tables of utterances, found in the menu on the left:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一个显示Lex使用情况的图表屏幕。这可能很有用，但我们正在寻找左侧菜单中的话语表：
- en: '![](img/f910f7dd-78ba-4d85-bfe7-d3ae09682177.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f910f7dd-78ba-4d85-bfe7-d3ae09682177.png)'
- en: Utterance monitoring
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 话语监控
- en: You should now see a table with a toggle in the center for Detected/Missed.
    The Detected utterances can be useful for seeing how most of your users are interacting
    with the chatbot. This can help you work out which areas you can develop to improve
    your chatbot for the largest portion of your audience.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该看到一个带有中心切换按钮的表格，用于检测/未检测。检测到的话语可以用来查看大多数用户是如何与聊天机器人互动的。这可以帮助你确定哪些领域可以开发以改善你的聊天机器人，以适应你最大部分的受众。
- en: If you don't see any utterances, then there are a few things to check. You need
    to make sure that in the general settings of the chatbot, COPPA is set to No.
    Next, you should try changing the version of the chatbot (next to the chatbot
    name) as utterances are saved to a specific version. Utterances show up in these
    tables if they are between 24 hours and 15 days old. If you still don't see any
    utterances, then you may just need to wait until you have utterances within this
    range.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到任何话语，那么你需要检查几件事情。你需要确保在聊天机器人的常规设置中，COPPA设置为否。接下来，你应该尝试更改聊天机器人的版本（位于聊天机器人名称旁边），因为话语保存到特定的版本。如果话语在24小时到15天之间，它们会出现在这些表格中。如果你仍然没有看到任何话语，那么你可能只需要等待直到你有这个范围内的话语。
- en: 'Utterance monitoring is very useful when users have said something that Lex
    couldn''t match to one of your example utterances. The Missed utterances give
    you a list of all of the utterances where this has happened. Although some of
    them will be gibberish or typos, some of them will be valid utterances that you
    might not have thought about:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户说了Lex无法匹配到你的示例话语时，话语监控非常有用。未识别话语给你一个列表，其中包含所有发生这种情况的话语。尽管其中一些可能是胡言乱语或打字错误，但其中一些可能是有效的、你可能没有考虑过的话语：
- en: '![](img/313bf545-433f-4bac-bb04-bbcf38ef9a05.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/313bf545-433f-4bac-bb04-bbcf38ef9a05.png)'
- en: Missed utterances
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 未识别话语
- en: Looking through the missed intents, you may realize that the user has typed
    an utterance that you hadn't thought of. You can easily add this to your intent
    by selecting the missed utterance and then selecting the intent from the dropdown
    that is just above the table. This saves manually copying and pasting the utterances
    into the intents.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看未识别意图时，你可能会意识到用户输入了一个你没有想到的话语。你可以通过选择未识别话语，然后从位于表格上方下拉菜单中选择意图，轻松地将这个话语添加到意图中。这样可以节省手动复制和粘贴话语到意图中的时间。
- en: Once you've moved all of the valid missed utterances into the correct intents,
    you need to make sure you build and deploy your updated chatbot.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将所有有效的未识别话语移动到正确意图中，你需要确保构建和部署你的更新版聊天机器人。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've looked into three ways to improve the user experience
    of both Alexa Skills and Lex chatbots.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了三种改善Alexa技能和Lex聊天机器人用户体验的方法。
- en: We started by creating cards in Lex chats to increase the visual information
    provided to a user. These cards are a great way to make your Lex chatbots stand
    out from just text-based chatbots.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在Lex聊天中创建卡片，以增加提供给用户的视觉信息。这些卡片是使你的Lex聊天机器人区别于仅基于文本的聊天机器人的好方法。
- en: We then moved over to Alexa, where we learned about Search Query slots. This
    slot type allows users to enter a wider range of values to fill a slot than we
    could allow using custom slot types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向Alexa，在那里我们学习了搜索查询槽位。这种槽位类型允许用户输入比使用自定义槽位类型更多的值来填充槽位。
- en: The final tool we learned to use to improve the user experience was *utterance
    monitoring*. Seeing what your users are really saying to your chatbot helps you
    increase the example utterances for each intent. This results in a chatbot that
    can successfully handle a wider range of user utterances.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后学会使用的工具来改善用户体验是*话语监控*。看到你的用户真正对聊天机器人说了什么，可以帮助你增加每个意图的示例话语。这导致了一个能够成功处理更广泛用户话语的聊天机器人。
- en: All of these things will provide more information or reduce the chance that
    the chatbots can't handle a user's requests.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都会提供更多信息或减少聊天机器人无法处理用户请求的可能性。
- en: In the final chapter we'll discuss a few of the best ways to continue your learning.
    We'll also talk about the future of chatbots and how they will become part of
    our everyday lives.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将讨论一些继续学习最佳方法。我们还将讨论聊天机器人的未来以及它们将如何成为我们日常生活的一部分。
- en: Questions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the benefits of using cards in Lex conversations?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Lex 对话中使用卡片的好处是什么？
- en: Do you need to use an image in a Lex card?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在 Lex 卡片中使用图片吗？
- en: Why would you choose to use search query slot type over a default or custom
    slot type?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你会选择使用搜索查询槽位类型而不是默认或自定义槽位类型？
- en: Can you populate a search query slot from the user utterance?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否从用户语句中填充搜索查询槽位？
- en: How can you find out which Lex utterances weren't matched to an intent?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何找出哪些 Lex 语句没有匹配到意图？
