- en: 4\. Classes and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 类和对象
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to define classes and instantiate them to
    create objects. You will also learn how to define the data types that can be passed
    to a class using interfaces. By the end of this chapter, you will be able to build
    a basic class that includes data attributes, a constructor, methods, and an interface.
    You will be able to create classes that take in multiple objects as arguments
    to build dynamic behavior and confidently use TypeScript to generate HTML code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何定义类并实例化它们以创建对象。你还将学习如何使用接口定义可以传递给类的数据类型。到本章结束时，你将能够构建一个包含数据属性、构造函数、方法和接口的基本类。你将能够创建接受多个对象作为参数的类，以构建动态行为，并自信地使用TypeScript生成HTML代码。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Object-Oriented Programming** (**OOP**) has been around since the 1960s and
    many popular programming languages utilize it, including **Java**, **Ruby**, and
    **Python**. Prior to OOP, developers typically followed the procedural programming
    style. Languages that utilize procedural programming processes run from the top
    of the code file to the bottom. Eventually, developers started wanting to wrap
    entire processes and data so that they could be called from different parts of
    a program at different times. And that''s how OOP was born.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）自20世纪60年代以来一直存在，许多流行的编程语言都采用了它，包括 **Java**、**Ruby** 和 **Python**。在OOP出现之前，开发者通常遵循过程式编程风格。采用过程式编程的语言，其执行过程是从代码文件顶部到底部的。最终，开发者开始希望将整个过程和数据封装起来，以便它们可以在程序的不同部分和不同时间被调用。这就是面向对象编程诞生的原因。'
- en: From a high-level perspective, OOP allows programs to wrap data and behavior
    together to create complete systems. So, instead of programs running code from
    top to bottom, as with procedural programs, OOP programs allow you to create code
    blueprints and establish rules for how a program will run, and then you can call
    those blueprints from other parts of an application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个高层次的角度来看，面向对象编程允许程序将数据和行为一起封装，以创建完整的系统。因此，与过程式程序从上到下运行代码不同，面向对象程序允许你创建代码蓝图并建立程序运行的规则，然后你可以从应用程序的其他部分调用这些蓝图。
- en: Don't worry if that doesn't make sense quite yet – we're going to walk through
    exactly how to work with OOP in TypeScript in this chapter. And we're going to
    start by learning about the fundamental building blocks of OOP – **classes** and
    **objects**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在还不明白，请不要担心——我们将在本章中详细讲解如何在TypeScript中处理面向对象编程。我们将从学习面向对象编程的基本构建块——**类**和**对象**开始。
- en: In the previous chapters, we've covered a wide assortment of topics, including
    various ways to declare variables, how to work with advanced types, aliases, union
    types, and assertions, and how to check for types. You've already added quite
    a bit of knowledge to your TypeScript skill set.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们涵盖了广泛的主题，包括声明变量的各种方法、如何处理高级类型、别名、联合类型和断言，以及如何检查类型。你已经为你的TypeScript技能集增添了相当多的知识。
- en: In this chapter, we're going to build a scoreboard application in TypeScript
    and will be learning about classes and objects along the way. Do not worry if
    you have no previous knowledge or familiarity with OOP, or how it applies to TypeScript.
    If you have some experience with classes and objects, then you can skip ahead
    to some of the more advanced material later in the chapter – though you may still
    benefit from a refresher on these key concepts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用TypeScript构建一个计分板应用程序，并在过程中学习类和对象。如果你对面向对象编程或它如何应用于TypeScript没有任何先前的知识或熟悉度，请不要担心。如果你对类和对象有一些经验，那么你可以跳过本章后面的一些更高级的内容——尽管你仍然可能从这些关键概念的复习中受益。
- en: What Are Classes and Objects?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类和对象？
- en: Before we build out our class, let's take a step back and understand how classes
    work. You can think of a class as a blueprint. It establishes a structure for
    what we want to build and has some behavior inside it. Now, the class by itself
    does nothing. It is simply a blueprint. In order to work with it, we have to perform
    a process called **instantiation**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建类之前，让我们退一步，了解类是如何工作的。你可以把类想象成一个蓝图。它为我们想要构建的东西建立了一个结构，并在其中包含了一些行为。现在，类本身并不做任何事情。它仅仅是一个蓝图。为了与之交互，我们必须执行一个称为**实例化**的过程。
- en: Instantiation is the process of taking a class and creating an actual object
    of the class that we can use. Let's walk through an example to understand instantiation
    further. Imagine that you're building a house and, like a good builder, you have
    a blueprint of what you want to build. That blueprint is like our class. The blueprint
    for a home is simply a set of rules, attributes, and behavior for a home. A blueprint
    for a house defines elements such as square footage, the number of rooms, the
    number of bathrooms, and where the plumbing goes. Technically, a blueprint is
    simply a set of rules that are printed out or stored on a computer; it's not the
    house itself, or the program itself, in this case. In order to create the house,
    someone needs to take the blueprint and then actually build the house, and it's
    the same in programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化是将一个类转换成我们可以使用的实际类的对象的过程。让我们通过一个例子来进一步了解实例化。想象一下你正在建造一栋房子，就像一个好的建筑商一样，你有一张你想要建造的蓝图。这个蓝图就像我们的类。房子的蓝图只是一套规则、属性和行为。房子的蓝图定义了诸如面积、房间数量、浴室数量以及管道走向等元素。技术上，蓝图只是一套打印出来或存储在计算机上的规则；它不是房子本身，或者在这个例子中，不是程序本身。为了创建房子，有人需要拿走蓝图并实际建造房子，编程也是如此。
- en: A class by itself does nothing besides establishing the rules for the program.
    In order to work with the class, we need to create an instance or object of that
    class. So, returning to the building analogy, you can think of instantiation as
    taking the blueprint for the house and building it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类本身除了为程序建立规则外，什么都不做。为了使用类，我们需要创建该类的实例或对象。所以，回到建筑比喻，你可以将实例化想象为拿走房子的蓝图并建造它。
- en: 'Let''s look at the following code snippet to understand how classes and objects
    appear in TypeScript:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的代码片段，以了解如何在 TypeScript 中出现类和对象：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s walk through each of the elements in the preceding code so that you
    can have a mental model of the key terminology associated with classes and objects
    in TypeScript, and then we''ll go through an in-depth exercise where you will
    see how to work with each element:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析前面代码中的每个元素，以便你可以在脑海中形成与 TypeScript 中类和对象相关的关键术语的模型，然后我们将进行一个深入练习，你将看到如何处理每个元素：
- en: '`class Person {}` creates or defines a class.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class Person {}` 创建或定义一个类。'
- en: '`name: string;` creates the class attributes.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name: string;` 创建类属性。'
- en: '`constructor()` allows you to perform setup work for when an object is created.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor()` 允许你在创建对象时执行设置工作。'
- en: '`read()` is a method that allows you to implement custom behavior in a class.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read()` 是一个允许你在类中实现自定义行为的方法。'
- en: '`const obj = new Person("Mike");` creates an object from a class and stores
    it in a variable so that it can be used.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const obj = new Person("Mike");` 从一个类创建一个对象并将其存储在变量中，以便可以使用它。'
- en: '`obj.read();` calls a method on an object. In this example, it would console
    log out the value `Mike likes to read`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj.read();` 在一个对象上调用一个方法。在这个例子中，它会在控制台输出值 `Mike 喜欢阅读`。'
- en: In the next section, we will solve an exercise wherein we'll be building our
    first TypeScript class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解决一个练习，其中我们将构建我们的第一个 TypeScript 类。
- en: 'Exercise 4.01: Building Your First Class'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.01：构建你的第一个类
- en: 'In this exercise, we''ll build a class named `Team` and add a behavior or method
    named `generateLineup` inside it. We''ll also create an object of this class and
    access its method. Perform the following steps to implement this exercise:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建一个名为 `Team` 的类，并在其中添加一个名为 `generateLineup` 的行为或方法。我们还将创建这个类的对象并访问其方法。执行以下步骤以实现此练习：
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/UJXSY](https://packt.link/UJXSY).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在此处找到：[https://packt.link/UJXSY](https://packt.link/UJXSY)。
- en: Open the Visual Studio Code editor.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code 编辑器。
- en: 'Create a new directory and then a new file called `scoreboard.ts`. You will
    be running the TypeScript compiler on it to have it generate a JavaScript file
    as well. Add the following command in the TypeScript compiler to generate a JavaScript file:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的目录，然后创建一个名为 `scoreboard.ts` 的新文件。你将在它上面运行 TypeScript 编译器以生成一个 JavaScript
    文件。在 TypeScript 编译器中添加以下命令以生成 JavaScript 文件：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once this command is executed, a `scoreboard.js` file is generated, as you
    can see in the following screenshot:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此命令后，将生成一个 `scoreboard.js` 文件，如下面的截图所示：
- en: '![Figure 4.1: TypeScript scoreboard and generated JavaScript files'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.1：TypeScript 评分板和生成的 JavaScript 文件'
- en: '](img/B14508_04_01.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 B14508_04_01.jpg](img/B14508_04_01.jpg)'
- en: 'Figure 4.1: TypeScript scoreboard and generated JavaScript files'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.1：TypeScript 记分板和生成的 JavaScript 文件
- en: 'Now, create a class called `Team`, and then utilize the instantiation process
    to create an object of that class. Write the following code inside the `scoreboard.ts`
    file to create a class:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `Team` 的类，然后利用实例化过程创建该类的对象。在 `scoreboard.ts` 文件中编写以下代码以创建一个类：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Right now, this is simply an empty class that doesn't do anything. Let's fix
    that by adding some behavior to the class. We can add behavior by defining functions.
    For our `Team` class, we're going to generate a lineup, so we define a function
    called `generateLineup`, and it doesn't take in any arguments.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，这只是一个空的类，没有任何功能。让我们通过向类中添加一些行为来修复它。我们可以通过定义函数来添加行为。对于我们的 `Team` 类，我们将生成一个阵容，因此我们定义了一个名为
    `generateLineup` 的函数，它不接受任何参数。
- en: Note
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: From a syntax perspective, notice that we're using the `class` keyword. The
    term `class` is a reserved word in TypeScript and JavaScript, and it tells the
    compiler that we're about to define a class. In this case, we're calling the `Team`
    class.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从语法角度来看，请注意我们正在使用 `class` 关键字。`class` 是 TypeScript 和 JavaScript 中的一个保留字，它告诉编译器我们即将定义一个类。在这种情况下，我们正在调用
    `Team` 类。
- en: 'Write the following code to define a `generateLineup()` function inside the class:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码在类内部定义一个 `generateLineup()` 函数：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, functions in classes, which are also referred to as methods,
    look similar in syntax to standard functions in JavaScript. Now, our `generateLineup`
    method simply returns a string. Later in the chapter, we'll see how we can implement
    dynamic behavior in this method.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，类中的函数，也称为方法，在语法上与 JavaScript 中的标准函数相似。现在，我们的 `generateLineup` 方法仅返回一个字符串。在本章的后面部分，我们将看到如何在此方法中实现动态行为。
- en: Once we've created a class and defined its behavior, we can create an object.
    In order to create an object of the `Team` class, we call the `new` keyword in
    front of the `Team` class name and assign that to a variable. In this case, we'll
    store the instantiated object in a variable called `astros`.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个类并定义了其行为，我们就可以创建一个对象。为了创建 `Team` 类的对象，我们在 `Team` 类名称前调用 `new` 关键字，并将其分配给一个变量。在这种情况下，我们将实例化的对象存储在一个名为
    `astros` 的变量中。
- en: 'Add the following code to create an object of the `Team` class:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以创建 `Team` 类的对象：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that in the preceding code, we're also adding parentheses after the `Team`
    class name, mimicking how we call functions in TypeScript.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们在 `Team` 类名称后面也添加了括号，模仿我们在 TypeScript 中调用函数的方式。
- en: With all of this in place, we can now use the `astros` variable to call the
    `generateLineup` method on it.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪后，我们现在可以使用 `astros` 变量来调用其上的 `generateLineup` 方法。
- en: 'Add the following code to call the `generateLineup` method:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以调用 `generateLineup` 方法：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the terminal, type the following commands to generate the JavaScript code
    and run it:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，输入以下命令以生成 JavaScript 代码并运行：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we run the preceding commands, the following output is displayed in the
    terminal: `Lineup will go here…`'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行前面的命令，终端将显示以下输出：`阵容将在这里…`
- en: Hence, we've created our first class, and then from there, we've taken that
    class, that blueprint, and then used instantiation to create an object. From that
    point, we're able to call the method inside the class. Now that we've created
    a class and used its object to access its methods, in the next section, we'll
    explore the concept of the **constructor**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经创建了我们第一个类，然后从那里，我们使用了这个类，这个蓝图，然后通过实例化来创建一个对象。从那个点开始，我们能够调用类内部的函数。现在我们已经创建了一个类并使用其对象来访问其方法，在下一节中，我们将探讨
    **构造函数** 的概念。
- en: Extending Class Behavior with a Constructor
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数扩展类行为
- en: In the previous section, we established the syntax for classes in TypeScript.
    Before we get started with the next phase of the previous program, let's take
    a step back and discuss an element that we're going to use, called the constructor.
    The concept of constructors can be confusing if you've never used them before.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们为 TypeScript 中的类建立了语法。在我们开始之前程序的下一阶段之前，让我们退一步，讨论我们将要使用的一个元素，称为构造函数。如果您以前从未使用过构造函数，这个概念可能会令人困惑。
- en: 'Returning to our blueprint/house analogy, if a class is like a home''s blueprint
    and an object is the home that is created, the constructor is the process of going
    to the hardware shop and purchasing the materials needed to build the home. A
    constructor is run automatically anytime that you create an object. Typically,
    constructors are used to do the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的蓝图/房屋类比，如果一个类就像房屋的蓝图，而对象是创建的房屋，那么构造函数就是去建材店购买建造房屋所需材料的过程。构造函数在创建对象时自动运行。通常，构造函数用于执行以下操作：
- en: Set data for attributes, which we're about to explore.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置属性数据，这是我们即将探讨的内容。
- en: Run any setup processes. Examples of this include calling outside APIs to get
    data and communicating with a database.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行任何设置过程。这包括调用外部API获取数据和与数据库通信。
- en: Note
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: More on constructors will be covered in *Chapter 8*, *Dependency Injection in TypeScript*.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于构造函数的内容将在*第8章*，*TypeScript中的依赖注入*中介绍。
- en: The this Keyword
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`this`关键字'
- en: 'The concept of `this` keyword refers to the instance of the class that is currently
    being executed. It has access to the data and behavior of the created object.
    Let''s say we have the following code within a class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字的含义是指当前正在执行的类的实例。它能够访问创建的对象的数据和行为。假设我们在一个类中有以下代码：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, if `this.name` is referring to the instance of the class
    and the attribute of `name`, what does the `name` parameter in the constructor
    represent? In order to use data in our class, we need to have a mechanism for
    passing data into the object, and that's what the constructor parameters are doing.
    So, why do we need to assign `this.name` to `name`? It does seem redundant; however,
    it is helpful for understanding how variable scope works in TypeScript classes.
    We need to assign the values passed into the object to `this.attributeName` so
    that the other methods in the class can have access to the values. If we simply
    passed the value into the constructor and didn't perform the `this.name` assignment,
    the other methods in the class wouldn't have access to the `name` value. Now,
    let's extend the behavior of the program in the next exercise, where we will explore
    the attributes of the class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果`this.name`是指向类的实例和`name`属性，那么构造函数中的`name`参数代表什么？为了在我们的类中使用数据，我们需要一个机制将数据传递到对象中，这就是构造函数参数的作用。那么，为什么我们需要将`this.name`赋值为`name`？这似乎是多余的；然而，这对于理解TypeScript类中的变量作用域工作方式是有帮助的。我们需要将传递给对象的值赋给`this.attributeName`，这样类中的其他方法就可以访问这些值。如果我们只是将值传递给构造函数而没有执行`this.name`的赋值，类中的其他方法就无法访问`name`值。现在，让我们在下一个练习中扩展程序的行为，我们将探索类的属性。
- en: 'Exercise 4.02: Defining and Accessing the Attributes of a Class'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02：定义和访问类的属性
- en: In this exercise, we'll add attributes to the `Team` class, which we created
    in the previous exercise. We'll be using constructors to define and access the
    attributes of the objects. Perform the following steps to implement this exercise.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向我们在上一个练习中创建的`Team`类添加属性。我们将使用构造函数来定义和访问对象的属性。按照以下步骤实现这个练习。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this exercise, we''ll continue the work we performed earlier in the chapter
    with our `Team` class, so make sure to reference it as a starting point. The code
    files for this exercise can be found here: [https://packt.link/Diuyl](https://packt.link/Diuyl).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将继续本章前面用`Team`类所做的操作，所以请确保将其作为起点。这个练习的代码文件可以在以下位置找到：[https://packt.link/Diuyl](https://packt.link/Diuyl)。
- en: 'We begin by listing the names of the attributes at the top of the `Team` class
    and then we set the value with a `constructor` function by passing in a `name`
    parameter. From there, we set the value of `this.name` to the value that gets
    passed into the `constructor` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`Team`类的顶部列出属性名称，然后通过传递`name`参数使用`constructor`函数设置值。从那里，我们将`this.name`的值设置为传递给构造函数的值：
- en: 'Write the following code to create a `constructor` function:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码以创建一个`constructor`函数：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we create the `astros` object, the `this` keyword represents the object
    that was created.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们创建`astros`对象时，`this`关键字代表被创建的对象。
- en: 'Create another object to see how the `this` keyword works with multiple objects.
    Add the following code to the `scoreboard.ts` file to create objects of the `Team`
    class:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个对象来查看`this`关键字在多个对象中的工作方式。将以下代码添加到`scoreboard.ts`文件中，以创建`Team`类的对象：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we've created another `Team` class object called `blueJays`.
    From there, we called the `generateLineup` method on the object. When we say `this.name`,
    what we're referring to is the instance of the class. This means that when we
    say `this.name` for the first object, we're referring to the `astros` object.
    And then, for the new object we've created, `this.name` is referencing the `blueJays`
    object.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `blueJays` 的另一个 `Team` 类对象。从那里，我们在该对象上调用 `generateLineup`
    方法。当我们说 `this.name` 时，我们指的是类的实例。这意味着当我们对第一个对象说 `this.name` 时，我们指的是 `astros` 对象。然后，对于我们创建的新对象，`this.name`
    指的是 `blueJays` 对象。
- en: Our `generateLineup` method has access to the value of `name` because we assigned
    it in the constructor.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `generateLineup` 方法可以访问 `name` 的值，因为我们已经在构造函数中对其进行了赋值。
- en: 'Pass values to the constructors of both the objects by writing the following
    code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写以下代码将值传递给对象的构造函数：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If you ever get asked the difference between parameters and arguments in TypeScript,
    parameters are what you place inside the function's declarations in your class.
    Arguments are what you pass to an object or a function.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你被问到 TypeScript 中参数和参数的区别，参数是你放在类中函数声明内的内容。参数是你传递给对象或函数的内容。
- en: In order to pass arguments to a class, you can pass them in the same way that
    you do with functions, as you can see above. Additionally, when we perform an
    assignment such as `this.name = name`, this means that when an object is created,
    it can call the data value as well.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了将参数传递给一个类，你可以像上面那样传递它们，此外，当我们执行 `this.name = name` 这样的赋值操作时，这意味着当创建一个对象时，它也可以调用数据值。
- en: 'Write the following code to call the relevant data values:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码以调用相关数据值：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the terminal, type the following commands to generate the JavaScript code
    and run it:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，键入以下命令以生成 JavaScript 代码并运行：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we run the preceding commands, the following output is displayed in the terminal:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行前面的命令，终端将显示以下输出：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see in the code in the previous step, when we call `astros.name`,
    this outputs the name value that was passed into the instantiated object. When
    we pass the name value `Blue Jays` into the new object, the new value is printed
    in the terminal.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在上一步的代码中所见，当我们调用 `astros.name` 时，它输出传递给实例化对象的名字值。当我们把名字值 `Blue Jays` 传递给新对象时，新值将在终端中打印出来。
- en: We are now able to understand the basic workings of classes and objects. We've
    also learned how to pass data into an object via a constructor. Now it's time
    to extend that knowledge and see how we can integrate types directly into our
    classes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够理解类和对象的基本工作原理。我们还学习了如何通过构造函数将数据传递给对象。现在是时候扩展这些知识，看看我们如何将类型直接集成到我们的类中。
- en: Even though the current implementation works, we're not taking advantage of
    the key benefits that TypeScript offers. In fact, the current implementation is
    very close to how you would build a class in vanilla JavaScript. By using types
    in classes, we can define exactly how to work with the code, which will help to
    make our code more manageable and scalable.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管当前实现有效，但我们没有充分利用 TypeScript 提供的关键优势。事实上，当前实现非常接近你用纯 JavaScript 构建类的方式。通过在类中使用类型，我们可以精确地定义如何处理代码，这将有助于使我们的代码更易于管理和扩展。
- en: A real-world example of this would be a React application that utilizes TypeScript
    versus vanilla JavaScript. One of the most common errors that developers run into
    is passing the wrong type of data to a class or method, resulting in an error
    for the user. Imagine accidentally passing a string to a class that requires an
    array. When the user tries to access the page that is associated with that class,
    they won't see any data, as the wrong data was passed to the method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实世界的例子是使用 TypeScript 的 React 应用程序与纯 JavaScript 相比。开发者遇到的最常见的错误之一是将错误类型的数据传递给类或方法，导致用户出现错误。想象一下，不小心将一个字符串传递给需要一个数组的类。当用户尝试访问与该类关联的页面时，他们不会看到任何数据，因为传递给方法的数据是错误的。
- en: When you utilize TypeScript and types in a React class, the text editor won't
    allow the program to even compile as it will explain to you exactly what type
    of data is required by each class and process. In the next section, we'll solve
    an exercise wherein we'll integrate different types into our class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 React 类中使用 TypeScript 和类型时，文本编辑器不会允许程序编译，因为它会向你解释每个类和过程需要的数据类型。在下一节中，我们将解决一个练习，我们将把不同的类型集成到我们的类中。
- en: 'Exercise 4.03: Integrating Types into Classes'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03：将类型集成到类中
- en: 'In this exercise, we''ll add another attribute named `players` inside our `Team`
    class. This parameter takes arrays of strings. Perform the following steps to
    implement this exercise:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在我们的`Team`类中添加另一个名为`players`的属性。这个参数接受字符串数组。按照以下步骤来实施这个练习：
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We''ll continue the work we performed in the previous exercise with our `Team`
    class, so make sure to reference it as a starting point. The code files for this
    exercise can be found here: [https://packt.link/tbav7](https://packt.link/tbav7).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在之前的练习中用我们的`Team`类完成的工作，所以请确保将其作为起点引用。本练习的代码文件可以在以下位置找到：[https://packt.link/tbav7](https://packt.link/tbav7)。
- en: Open the `scoreboard.ts` file.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`scoreboard.ts`文件。
- en: 'Inside the `Team` class, declare another attribute named `players`, which takes
    arrays of strings. Write the following code to declare the `string` array:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Team`类内部，声明另一个名为`players`的属性，它接受字符串数组。编写以下代码来声明`string`数组：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the `constructor` function by adding the `name` and `players` parameters.
    Set the values of the `name` and `players` parameters to `this.name` and `this.players`,
    respectively. Write the following code to update our `constructor` function:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`name`和`players`参数来更新`constructor`函数。将`name`和`players`参数的值分别设置为`this.name`和`this.players`。编写以下代码来更新我们的`constructor`函数：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Update the `generateLineup()` method so that it joins the player names that
    will get passed into the object. This method will return a plain string. Here
    is the updated code of the `generateLineup()` method:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`generateLineup()`方法，使其连接将传递给对象的玩家名称。此方法将返回一个普通字符串。以下是更新后的`generateLineup()`方法的代码：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create two arrays of players, namely, `astrosPlayers` and `blueJaysPlayers`.
    Assign four player names to each array and pass those arrays as second arguments
    to the `Team` class objects. Write the following code to accomplish this:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个玩家数组，即`astrosPlayers`和`blueJaysPlayers`。将四个玩家名称分配给每个数组，并将这些数组作为`Team`类对象的第二个参数传递。编写以下代码来完成此操作：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, in the terminal, type the following commands to generate the JavaScript
    code and run it:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中，键入以下命令以生成JavaScript代码并运行它：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once we run the preceding commands, the following output is displayed in the terminal:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行前面的命令，终端将显示以下输出：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've now integrated types into our `Team` class. If you're able to view the
    names that you passed to the class in the console, this means that you're working
    with the class and their types properly. In the next section, we'll learn why
    **interfaces** are needed and how they are useful.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将类型集成到我们的`Team`类中。如果你能在控制台中查看传递给类的名称，这意味着你正在正确地使用类及其类型。在下一节中，我们将学习为什么需要**接口**以及它们是如何有用的。
- en: TypeScript Interfaces
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript接口
- en: 'We''ll go through a deep dive into TypeScript interfaces in the next chapter.
    But for now, just know that an interface allows you to describe the data passed
    to a class when you''re creating an object. In the previous exercise code, if
    we hover over the `Team` class on Visual Studio Code, we get the following message:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章深入探讨TypeScript接口。但到目前为止，只需知道接口允许你在创建对象时描述传递给类的数据。在前面的练习代码中，如果我们将鼠标悬停在Visual
    Studio Code中的`Team`类上，我们会得到以下消息：
- en: '![Figure 4.2: Vague IntelliSense guidance'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：模糊的IntelliSense指导'
- en: '](img/B14508_04_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_04_02.jpg](img/B14508_04_02.jpg)'
- en: 'Figure 4.2: Vague IntelliSense guidance'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：模糊的IntelliSense指导
- en: As you can see in the preceding screenshot, the Visual Studio Code editor's
    IntelliSense is saying that the `players` parameter uses the `any` data type.
    It's not giving us any usage hints here, and this starts to speak to the reason
    why we need interfaces, because right now, the `players` array could be anything.
    It could be a string, it could be an object, and so on. This is essentially breaking
    one of the main benefits of using TypeScript in the first place. Ideally, our
    programs should be declarative to the point that we know exactly what type of
    data should be passed to our functions and classes. We're going to leverage interfaces
    in order to do that. The way you define an interface is by starting with the `interface`
    keyword followed by the name of the interface. The common convention in the TypeScript
    community is to start with a capital `I`, followed by whatever class you're building
    the interface for.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的截图中所见，Visual Studio Code 编辑器的 IntelliSense 表示 `players` 参数使用的是 `any` 数据类型。它在这里没有提供任何使用提示，这也开始说明了为什么我们需要接口，因为现在
    `players` 数组可以是任何东西。它可以是字符串，也可以是对象，等等。这实际上破坏了使用 TypeScript 的主要好处之一。理想情况下，我们的程序应该是声明式的，以至于我们知道应该将什么类型的数据传递给我们的函数和类。我们将利用接口来实现这一点。定义接口的方式是先使用
    `interface` 关键字，然后是接口的名称。在 TypeScript 社区中，常见的约定是以大写字母 `I` 开头，后面跟着为该接口构建的类的名称。
- en: Once we have created the interface and update the constructor, we'll establish
    a way of defining our arguments and our types. This will break any of the previously
    created objects with the old argument syntax since the previous arguments no longer
    match up with our new interface. In the next section, we'll complete an exercise
    wherein we'll build an interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了接口并更新了构造函数，我们将建立一个定义我们的参数和类型的方法。这将破坏使用旧参数语法创建的任何先前创建的对象，因为之前的参数不再与我们的新接口匹配。在下一节中，我们将完成一个练习，其中我们将构建一个接口。
- en: 'Exercise 4.04: Building an Interface'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.04：构建接口
- en: 'In this exercise, we''ll build an interface and set the types of data that
    need to be passed to our functions and classes. Perform the following steps to
    implement this exercise:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建一个接口并设置需要传递给我们的函数和类的数据类型。执行以下步骤以实现此练习：
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We''ll continue the work we performed in the previous exercise with our `Team`
    class, so make sure to reference it as a starting point. The code files for this
    exercise can be found here: [https://packt.link/FWUA6](https://packt.link/FWUA6).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在 `Team` 类中执行我们在上一个练习中完成的工作，所以请确保将其作为起点。此练习的代码文件可以在以下位置找到：[https://packt.link/FWUA6](https://packt.link/FWUA6)。
- en: Open the `scoreboard.ts` file.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `scoreboard.ts` 文件。
- en: 'Create an interface named `ITeam` and list out the attributes and data types
    with the same key/value syntax that you would use with an object. Write the following
    code to create an interface:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ITeam` 的接口，并使用与对象相同的键/值语法列出属性和数据类型。编写以下代码以创建接口：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside our `Team` class, alter the parameter list in the `constructor` function
    so that the data is passed in as a single object that is of the `ITeam` type.
    Write the following code to accomplish this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `Team` 类内部，修改 `constructor` 函数中的参数列表，以便将数据作为一个 `ITeam` 类型的单个对象传递。编写以下代码以完成此操作：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice in the preceding code that, instead of listing out each of the parameters
    separately, we're declaring the exact structure that is needed for a `Team` object
    to be created. From that point, we're calling the `name` and `players` values
    from the `args` parameter since our parameter list has now been refactored to
    use a single argument.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意在前面的代码中，我们不是单独列出每个参数，而是声明了创建 `Team` 对象所需的精确结构。从那时起，我们从 `args` 参数中调用 `name`
    和 `players` 值，因为我们的参数列表现在已经被重构为使用单个参数。
- en: 'Create an object of the `Team` class by writing the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写以下代码创建 `Team` 类的对象：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now notice what happens when we hover over the parentheses. It says that it
    expected one argument but got zero. Look at the following screenshot to view the
    message:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在请注意，当我们悬停在括号上时，它表示期望一个参数但得到了零个。查看以下截图以查看消息：
- en: '![Figure 4.3: IntelliSense listing out the arguments needed by the class'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.3：IntelliSense 列出类所需的参数'
- en: '](img/B14508_04_03.jpg)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_04_03.jpg)'
- en: 'Figure 4.3: IntelliSense listing out the arguments needed by the class'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.3：IntelliSense 列出类所需的参数
- en: 'Let''s update how we create the objects. Start typing in the `name` attribute.
    Write the following code to create the object:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新创建对象的方式。在`name`属性中开始输入。编写以下代码来创建对象：
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After adding in the `name` argument, we''ll see the following error:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加`name`参数后，我们将看到以下错误：
- en: '![Figure 4.4: IntelliSense describing the data types needed to create the object'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.4：IntelliSense描述创建对象所需的数据类型'
- en: '](img/B14508_04_04.jpg)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_04_04.jpg)'
- en: 'Figure 4.4: IntelliSense describing the data types needed to create the object'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.4：IntelliSense描述创建对象所需的数据类型
- en: If you hover over the `name` attribute, you can see that TypeScript is helping
    us understand the other arguments we need to pass in, because the `players` property
    is missing. So, this is already giving us so much more information on how our
    class needs to work.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在`name`属性上，你可以看到TypeScript正在帮助我们理解我们需要传递的其他参数，因为`players`属性缺失。所以，这已经为我们提供了关于我们的类应该如何工作的更多信息。
- en: 'Now, pass the values for both the attributes, `name` and `players`, and update
    the values for both the objects, `astros` and `blueJays`. Write the following
    code to accomplish this:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，传递两个属性`name`和`players`的值，并更新两个对象`astros`和`blueJays`的值。编写以下代码来完成此操作：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, in the terminal, type the following commands to generate the JavaScript
    code and run it:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中，键入以下命令以生成JavaScript代码并运行它：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once we run the preceding commands, the following output is displayed in the terminal:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的命令后，以下输出显示在终端中：
- en: '[PRE26]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've now built an interface and set the types of data that need to be passed
    to our functions and classes. Although we got the same output as we got in the
    previous exercise, we are now aware of what type of data needs to be passed to
    our functions and classes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经建立了一个接口，并设置了需要传递给我们的函数和类的数据类型。尽管我们得到了与之前练习相同的结果，但我们现在清楚需要传递给我们的函数和类的是哪种类型的数据。
- en: Another great benefit of using interfaces and object-based arguments with classes
    is that the arguments do not have to be in a specific order. You can pass in the
    keys in any order that you want, and the class can still parse them properly.
    If you use standard parameter names, you'll always need to know the order to pass
    arguments to the class and function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口和基于对象的参数与类一起使用的另一个巨大好处是，参数不需要按特定顺序排列。你可以按你想要的任何顺序传递键，类仍然可以正确解析它们。如果你使用标准的参数名称，你总是需要知道传递参数到类和函数的顺序。
- en: Generating HTML Code in Methods
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在方法中生成HTML代码
- en: Now that we have learned how to build an interface and have the ability to pass
    data, along with having some help from IntelliSense in knowing the types of data
    that we're passing in, we can actually generate some HTML. It's fun to see the
    code we write generate its own code. Part of the reason why we chose to include
    this example is that this is very close to the same type of process that you will
    be using when building React JS or Angular applications. At their very core, the
    goal of a standard React app is to leverage JavaScript/TypeScript code to render
    HTML code that can be rendered to the user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何构建接口，并且有能力传递数据，再加上IntelliSense的帮助，我们知道传递的数据类型，我们实际上可以生成一些HTML。看到我们编写的代码生成自己的代码很有趣。我们选择包含这个示例的部分原因是因为这非常接近你在构建React
    JS或Angular应用程序时将使用的过程。在它们的内核中，标准React应用程序的目标是利用JavaScript/TypeScript代码来渲染可以呈现给用户的HTML代码。
- en: In the next section, we'll complete an exercise wherein we generate HTML code
    and view it in the browser.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将完成一个练习，在这个练习中我们将生成HTML代码并在浏览器中查看。
- en: 'Exercise 4.05: Generating and Viewing HTML Code'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.05：生成和查看HTML代码
- en: 'In this exercise, we will generate some HTML by cleaning up some of the code.
    We''ll get rid of the `name` attribute and the interface. Perform the following
    steps to implement this exercise:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过清理一些代码来生成一些HTML。我们将移除`name`属性和接口。按照以下步骤实现这个练习：
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We''ll continue the work we performed in the previous exercise with our `Team`
    class, so make sure to reference it as a starting point. The code files for this
    exercise can be found here: [https://packt.link/Bz5LV](https://packt.link/Bz5LV).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用`Team`类完成之前练习中执行的工作，所以请确保将其作为起点进行参考。本练习的代码文件可以在以下链接找到：[https://packt.link/Bz5LV](https://packt.link/Bz5LV)。
- en: Open the `scoreboard.ts` file.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`scoreboard.ts`文件。
- en: 'Inside the `Team` class, declare the `players` array and create a `constructor`
    function. Write the following code to implement this:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Team`类中，声明`players`数组并创建一个`constructor`函数。编写以下代码以实现此功能：
- en: '[PRE27]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Update the `generateLineup()` function by writing the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写以下代码来更新`generateLineup()`函数：
- en: '[PRE28]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `map` function is a helpful iterator tool that loops over the player array.
    You can pass it as a function that performs some type of operation. In the preceding
    code, the line `` `<div>${idx + 1} – ${player}</div>` `` states that in every
    iteration, each player's data is wrapped inside the HTML code. Also, each element
    that is returned is stored in a new array, `playersWithOrderNumber`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`map`函数是一个有用的迭代工具，它遍历球员数组。您可以将其作为执行某种操作的函数传递。在前面的代码中，行` `<div>${idx + 1} –
    ${player}</div>`表明在每次迭代中，每个球员的数据都被HTML代码包裹。此外，每个返回的元素都存储在一个新的数组`playersWithOrderNumber`中。'
- en: Note
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the return type that we've declared for the `generateLineup` method.
    This means that we're telling the TypeScript compiler that the method will always
    return a string value. The reason why this is so important is that if any other
    part of the application calls this method and tries to perform a task that does
    not work with the string data type, they'll get a clear error and recommendation
    on how to fix it.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们为`generateLineup`方法声明的返回类型。这意味着我们正在告诉TypeScript编译器该方法将始终返回一个字符串值。之所以如此重要，是因为如果应用程序的任何其他部分调用此方法并尝试执行不适用于字符串数据类型的任务，它们将得到一个清晰的错误和建议如何修复它。
- en: 'Now, in the terminal, type the following commands to generate the JavaScript
    code and run it:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中，输入以下命令以生成JavaScript代码并运行它：
- en: '[PRE29]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we have run the preceding commands, the following output is displayed
    in the terminal:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的命令后，终端中显示以下输出：
- en: '![Figure 4.5: Output showing the lineup of players for both teams'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.5：显示两支球队球员阵容的输出'
- en: '](img/B14508_04_05.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_04_05.jpg)'
- en: 'Figure 4.5: Output showing the lineup of players for both teams'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.5：显示两支球队球员阵容的输出
- en: In the preceding output, you'll see that we're getting HTML returned that prints
    out the lineup of players for both teams.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的输出中，您将看到我们得到的是打印出两支球队球员阵容的HTML。
- en: But let's not stop here. Let's see what this looks like in the browser.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但我们不要就此止步。让我们看看在浏览器中这看起来是什么样子。
- en: 'Save the generated code in an HTML file named `index.html` and view it in the
    browser. The following output will be displayed in the browser:![Figure 4.6: Viewing
    the generated HTML code in the browser'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的代码保存到名为`index.html`的HTML文件中，并在浏览器中查看。浏览器中将显示以下输出：![图4.6：在浏览器中查看生成的HTML代码
- en: '](img/B14508_04_06.jpg)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_04_06.jpg)'
- en: 'Figure 4.6: Viewing the generated HTML code in the browser'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：在浏览器中查看生成的HTML代码
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may get a different image depending on your default browser; however, the
    text displayed will be the same as listed in the preceding screenshot.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能根据默认浏览器得到不同的图像；然而，显示的文本将与前面的截图中所列的相同。
- en: You can see that we have a full lineup of players for both teams. However, we
    have not yet formatted the text on the page, and so it is difficult to ascertain
    the teams to which the players belong unless you have access to the code. We will
    be enhancing this page with more information and formatting as we progress in
    this chapter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们为两支球队都有一套完整的球员阵容。然而，我们还没有格式化页面上的文本，因此除非您能访问代码，否则很难确定球员所属的球队。随着我们在本章的进展，我们将增强这个页面，添加更多信息并进行格式化。
- en: Note that we can pass the objects themselves to another class that will put
    them together for us and generate a full scoreboard. In the next section, we'll
    learn how to work with multiple classes and objects.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以将对象本身传递给另一个类，该类将为我们将它们组合在一起并生成完整的得分板。在下一节中，我们将学习如何与多个类和对象一起工作。
- en: Working with Multiple Classes and Objects
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个类和对象的工作
- en: In this section, we're going to learn how to create a class that combines other
    classes to give us more advanced behavior. The reason why this is an important
    concept to understand is that you will need to implement this type of behavior
    in many different types of applications. For example, if you are building a contact
    form in a React application, you might need to have classes for an API, form elements,
    form validations, and other form features all working together. In the next section,
    we will look at an exercise where we'll combine classes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何创建一个结合其他类以提供更高级行为的类。这个概念之所以重要，是因为你将在许多不同类型的应用程序中需要实现这种类型的行为。例如，如果你正在构建一个
    React 应用程序中的联系表单，你可能需要为 API、表单元素、表单验证和其他表单功能创建类，使它们协同工作。在下一节中，我们将查看一个将类结合起来的练习。
- en: 'Exercise 4.06: Combining Classes'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.06：组合类
- en: 'In this exercise, we will be creating a `scoreboard` class that will allow
    us to pass in objects and work with their data and behavior. This will allow us
    to take instantiated objects that were created from other classes such as our
    `Team` class. Then, we''re going to add in some other behavior that will generate
    a full scoreboard that shows off both the lineups along with the data. Perform
    the following steps to implement this exercise:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将创建一个 `scoreboard` 类，它将允许我们传入对象并处理它们的数据和行为。这将使我们能够使用从其他类（如我们的 `Team`
    类）创建的实例化对象。然后，我们将添加一些其他行为，以生成一个完整的分数板，展示阵容和数据。执行以下步骤以实现本练习：
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We''ll continue the work we performed in the previous exercise with our `Team`
    class, so make sure to reference it as a starting point. The code files for this
    exercise can be found here: [https://packt.link/UY5NP](https://packt.link/UY5NP).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前练习中完成的 `Team` 类继续我们的工作，所以请确保将其作为起点进行引用。本练习的代码文件可以在以下位置找到：[https://packt.link/UY5NP](https://packt.link/UY5NP)。
- en: Open the `scoreboard.ts` file.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `scoreboard.ts` 文件。
- en: 'Create a `Scoreboard` class and list three attributes, namely, `homeTeam`,
    `awayTeam`, and `date`. Here, `homeTeam` and `awayTeam` will be of the `Team`
    type, and `date` will be of the `string` type. Write the following code to accomplish
    this:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Scoreboard` 类，列出三个属性，即 `homeTeam`、`awayTeam` 和 `date`。在这里，`homeTeam` 和
    `awayTeam` 将是 `Team` 类型，而 `date` 将是 `string` 类型。编写以下代码以完成此操作：
- en: '[PRE30]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, notice how we were able to call the `Team` class. This
    is because when we create a class, we're able to treat that class like a type
    in TypeScript. So, TypeScript now knows that our `homeTeam` and `awayTeam` data
    attributes must be a `Team` object. The `date` attribute will represent the date
    of the scoreboard. If we tried to pass in `string`, `array`, or anything else
    for a `Team` object, the program would not compile.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意我们如何能够调用 `Team` 类。这是因为当我们创建一个类时，我们能够将这个类当作 TypeScript 中的类型来处理。因此，TypeScript
    现在知道我们的 `homeTeam` 和 `awayTeam` 数据属性必须是 `Team` 对象。`date` 属性将代表分数板的日期。如果我们尝试传递
    `string`、`array` 或任何其他 `Team` 对象，程序将无法编译。
- en: 'Now that we know the type of data that our scoreboard needs to have, let''s
    create an interface for it. Write the following code to create an interface:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的分数板需要的数据类型，让我们为它创建一个接口。编写以下代码以创建接口：
- en: '[PRE31]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is similar to what we implemented with the `ITeam` interface, but with
    a nice twist. Because our `homeTeam` and `awayTeam` attributes are not associated
    with a basic data type such as `string` or `number`, we're letting the interface
    know that these values are required to be objects of the `Team` class.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与我们在 `ITeam` 接口中实现的方式类似，但有一个很好的转折。因为我们的 `homeTeam` 和 `awayTeam` 属性与基本数据类型（如
    `string` 或 `number`）不相关联，所以我们让接口知道这些值必须是 `Team` 类的对象。
- en: 'Now, in the terminal, type the following commands to generate the JavaScript
    code and run it:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中，输入以下命令以生成 JavaScript 代码并运行：
- en: '[PRE32]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When the preceding command is executed, the `scoreboard.js` file is created.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当执行前面的命令时，将创建 `scoreboard.js` 文件。
- en: 'Open the `scoreboard.js` file and you''ll see the following code at the beginning:![Figure
    4.7: Generated JavaScript that shows interfaces are only used by the text editor'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `scoreboard.js` 文件，你将在开头看到以下代码：![图 4.7：生成的 JavaScript 代码显示接口仅由文本编辑器使用
- en: '](img/B14508_04_07.jpg)'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_04_07.jpg)'
- en: 'Figure 4.7: Generated JavaScript that shows interfaces are only used by the
    text editor'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.7：生成的 JavaScript 代码显示接口仅由文本编辑器使用
- en: In the preceding screenshot, what we're essentially doing here is almost like
    a mini declaration file for this class. We're defining the shape of the class.
    If you remember, those interfaces and those declaration files do not get compiled
    down into JavaScript. You can confirm this by looking at the generated JavaScript
    code in the preceding screenshot.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们实际上在这里做的事情几乎就像是为这个类的一个小型声明文件。我们正在定义类的形状。如果你记得，那些接口和那些声明文件不会编译成JavaScript。你可以通过查看前面屏幕截图中的生成的JavaScript代码来确认这一点。
- en: Now that we've defined the interface, we have essentially defined the shape
    of our `Scoreboard` class.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经定义了接口，我们实际上已经定义了`Scoreboard`类的形状。
- en: 'Now we implement a `constructor` function, allowing the `Scoreboard` class
    to know what parameters to expect when creating a new object. Write the following
    code to accomplish this:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们实现一个`constructor`函数，允许`Scoreboard`类在创建新对象时知道期望的参数。编写以下代码以完成此操作：
- en: '[PRE33]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this in place, any functions inside our `Scoreboard` class can work with
    these values.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此基础上，我们`Scoreboard`类中的任何函数都可以使用这些值。
- en: 'Now let''s create a function called `scoreboardHtml()` inside the `Scoreboard`
    class. Write the following code to accomplish this:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`Scoreboard`类中创建一个名为`scoreboardHtml()`的函数。编写以下代码以完成此操作：
- en: '[PRE34]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, we have an `<h1>` heading tag for `date` and an `<h2>`
    heading tag wrapping the team names. This is great, as even though the `Scoreboard`
    class has no knowledge of the `Team` class, the IDE can let us know that we have
    access to the name value. Lastly, we're able to call the `Team` functions. So,
    inside the `<div>` tags wrapper, we're calling the `generateLineup()` function
    of `Team`, which we know from earlier returns a list of HTML elements. Also, notice
    that this function will always return a string and that we're using backticks
    so that we can use string literals, which can be dynamic.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个`<h1>`标题标签用于`date`，以及一个包含团队名称的`<h2>`标题标签。这很好，因为尽管`Scoreboard`类对`Team`类一无所知，但IDE可以让我们知道我们可以访问名称值。最后，我们能够调用`Team`函数。因此，在`<div>`标签包装器内部，我们调用`Team`的`generateLineup()`函数，我们知道从之前返回的是HTML元素列表。注意，此函数始终返回一个字符串，并且我们使用反引号以便可以使用字符串字面量，这些可以是动态的。
- en: Note
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In TypeScript and JavaScript, string literals can be written on multiple lines,
    which is not allowed with quotation marks.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在TypeScript和JavaScript中，字符串字面量可以写在多行，而引号不允许这样做。
- en: 'Update the `Team` class with the `name` attribute and `constructor` function.
    Write the following code to accomplish this:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`name`属性和`constructor`函数更新`Team`类。编写以下代码以完成此操作：
- en: '[PRE35]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To view the final scoreboard, first create two team objects followed by the
    `Scoreboard` class object, and then pass in dates and both of our team objects
    to it. Write the following code to accomplish this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看最终的记分板，首先创建两个团队对象，然后创建`Scoreboard`类对象，然后将日期和我们的两个团队对象传递给它。编写以下代码以完成此操作：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, in the terminal, type the following commands to generate the JavaScript
    code and run it:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中，键入以下命令以生成JavaScript代码并运行：
- en: '[PRE37]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once we run the preceding commands, the following output is displayed in the terminal:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦运行前面的命令，终端将显示以下输出：
- en: '![Figure 4.8: Generated HTML code'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.8：生成的HTML代码'
- en: '](img/B14508_04_08.jpg)'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_04_08.jpg)'
- en: 'Figure 4.8: Generated HTML code'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.8：生成的HTML代码
- en: 'Add this code to an HTML file and view it in the browser. You will see that
    we have a full scoreboard like the one shown in the following screenshot:![Figure
    4.9: Generated code in the browser'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码添加到HTML文件中，并在浏览器中查看。您将看到我们有一个完整的记分板，如下面的截图所示：![图4.9：浏览器中生成的代码
- en: '](img/B14508_04_09.jpg)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14508_04_09.jpg)'
- en: 'Figure 4.9: Generated code in the browser'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：浏览器中生成的代码
- en: Finally, we combined two classes, namely, `Scoreboard` and `Team`. In the `Scoreboard`
    class, we created attributes of the `Team` type and added a few behaviors that
    will help to generate a full scoreboard consisting of the lineups of both teams.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们结合了两个类，即`Scoreboard`和`Team`。在`Scoreboard`类中，我们创建了`Team`类型的属性并添加了一些有助于生成包含两队阵容的完整记分板的操作。
- en: So far, we've introduced classes and objects in TypeScript, and with this knowledge,
    we're ready to move on to the code activity in the next section, where we will
    create a user model.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了TypeScript中的类和对象，并且有了这些知识，我们准备进入下一节的代码活动，我们将创建一个用户模型。
- en: 'Activity 4.01: Creating a User Model Using Classes, Objects, and Interfaces'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：使用类、对象和接口创建用户模型
- en: 'In this activity, you will build a user authentication system that mimics how
    a TypeScript application would pass login data to a backend API to register and
    sign users into our baseball scorecard application. This will entail building
    multiple TypeScript classes and combining classes and objects together to mimic
    an authentication feature. Perform the following steps to implement this activity:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将构建一个用户身份验证系统，模拟 TypeScript 应用程序如何将登录数据传递给后端 API 以注册和登录我们的棒球比分卡应用程序。这包括构建多个
    TypeScript 类并将类和对象组合在一起来模拟身份验证功能。按照以下步骤实现此活动：
- en: 'Visit the GitHub repository and download the activity project containing the
    specs and configuration elements: [https://packt.link/vJxBm](https://packt.link/vJxBm).'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 GitHub 仓库并下载包含规范和配置元素的 activity 项目：[https://packt.link/vJxBm](https://packt.link/vJxBm)。
- en: Open the Visual Studio Code editor.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio Code 编辑器。
- en: Create a file called `auth.ts`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `auth.ts` 的文件。
- en: Run the TypeScript compiler on the file and watch for changes.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件上运行 TypeScript 编译器并观察更改。
- en: Create a `Login` class that takes in an object containing the string attributes
    of `email` and `password`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Login` 类，它接受一个包含字符串属性 `email` 和 `password` 的对象。
- en: Build an interface called `ILogin` that defines the `email` and `password` attributes.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ILogin` 的接口，它定义了 `email` 和 `password` 属性。
- en: Pass it as a parameter to the `constructor` function.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它作为参数传递给构造函数。
- en: Create an `Auth` class that takes in an object containing the attributes of
    `user` and `source`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Auth` 类，它接受一个包含 `user` 和 `source` 属性的对象。
- en: Build an interface called `IAuth` that defines the `user` and `source` attributes
    and pass it as the `constructor` function parameter. Have the `user` attribute
    be of the `Login` type and the `source` attribute of the `string` type.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `IAuth` 的接口，它定义了 `user` 和 `source` 属性，并将其作为构造函数参数传递。让 `user` 属性为 `Login`
    类型，`source` 属性为 `string` 类型。
- en: Add a `validUser()` method to the `Auth` class that returns `true` if `email`
    is equal to `admin@example.com` and if `password` is equal to `secret123`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Auth` 类添加一个 `validUser()` 方法，如果 `email` 等于 `admin@example.com` 并且 `password`
    等于 `secret123`，则返回 `true`。
- en: Ensure that you can access the `source` attribute from the instantiated `Auth`
    object and that it's a string.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你可以从实例化的 `Auth` 对象中访问 `source` 属性，并且它是一个字符串。
- en: Test the user model by first checking a valid user and then an invalid user.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过首先检查有效用户然后检查无效用户来测试用户模型。
- en: 'The expected output should look something like this:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出应该看起来像这样：
- en: '[PRE38]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor399).
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor399)找到。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Learning OOP development patterns for the first time can be a challenging task.
    In this chapter, you learned about OOP development, how to define classes in TypeScript,
    how to instantiate classes and create objects, how to combine data and methods
    in a class to encapsulate a full set of behavior, how to utilize interfaces in
    order to define the data that can be passed to a TypeScript class, and finally,
    how to pass the objects to classes of various types.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首次学习面向对象开发模式可能是一项具有挑战性的任务。在本章中，你学习了面向对象开发，如何在 TypeScript 中定义类，如何实例化类并创建对象，如何在一个类中将数据和函数结合起来以封装完整的行为集，如何利用接口来定义可以传递给
    TypeScript 类的数据，以及最后如何将对象传递给各种类型的类。
- en: You also now have a basic understanding of how an authentication system works
    and how to utilize TypeScript to generate HTML code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在也基本了解了身份验证系统的工作原理以及如何使用 TypeScript 生成 HTML 代码。
- en: Now that you have a basic understanding of how classes and objects work in TypeScript,
    in the next chapter, you'll learn how to work with the concept of class inheritance
    and take a deeper dive into interfaces.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经基本了解了 TypeScript 中类和对象的工作原理，在下一章中，你将学习如何处理类继承的概念，并更深入地了解接口。
