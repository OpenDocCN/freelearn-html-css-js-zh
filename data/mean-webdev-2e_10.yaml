- en: Chapter 10. Testing MEAN Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。测试MEAN应用程序
- en: 'In previous chapters, you learned to build your real-time MEAN application.
    You went through Express and Angular basics and learned to connect all the parts
    together. However, when your application becomes bigger and more complex, you''ll
    soon find out that it''s very difficult to manually verify your code. You will
    then need to start testing your application automatically. Fortunately, testing
    a web application, which was once a complicated task, has become much easier with
    the help of new tools and suitable testing frameworks. In this chapter, you''ll
    learn to cover your MEAN application code using modern test frameworks and popular
    tools. We''ll cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，你学会了如何构建实时的MEAN应用程序。你学习了Express和Angular的基础知识，并学会了将所有部分连接在一起。然而，当你的应用程序变得更大更复杂时，你很快就会发现手动验证你的代码非常困难。然后，你需要开始自动测试你的应用程序。幸运的是，借助新工具和适当的测试框架，测试Web应用程序，这曾经是一项复杂的任务，现在变得更加容易。在本章中，你将学习如何使用现代测试框架和流行工具来覆盖你的MEAN应用程序代码。我们将涵盖以下主题：
- en: Introducing JavaScript TDD and BDD
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍JavaScript TDD和BDD
- en: Setting up your testing environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的测试环境
- en: Installing and configuring the Mocha test framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Mocha测试框架
- en: Writing Express model and controller tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Express模型和控制器测试
- en: Installing and configuring the Karma test runner
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Karma测试运行器
- en: Using Jasmine to unit test your Angular entities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine来对你的Angular实体进行单元测试
- en: Writing and running end-to-end Angular tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和运行端到端的Angular测试
- en: Introducing JavaScript testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍JavaScript测试
- en: As you already know, in the past couple of years, JavaScript has evolved dramatically.
    It was once a simple scripting language made for small web applications, but now
    it's the backbone for complex architectures, both in the server and the browser.
    However, this evolution has put developers in a situation where they need to manually
    manage a large code base that remained uncovered in terms of automated testing.
    While our fellow Java, .NET, or Ruby developers have been safely writing and running
    their tests, JavaScript developers remained in an uncharted territory, with the
    burden of figuring out how to properly test their applications. Lately, this void
    has been filled with the formation of new tools and testing frameworks written
    by the talented JavaScript community members. In this chapter, we'll cover some
    of these popular tools, but keep in mind that this field is fairly new and is
    constantly changing, so you'll also have to keep an eye out for newly emerging
    solutions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经知道的，在过去的几年里，JavaScript发展迅速。它曾经是一个简单的脚本语言，用于小型Web应用程序，但现在它是复杂架构的骨干，无论是在服务器还是浏览器中。然而，这种发展让开发人员陷入了一个境地，他们需要手动管理一个大型的代码库，而这些代码在自动化测试方面仍然没有覆盖到。虽然我们的Java、.NET或Ruby开发人员一直安全地编写和运行他们的测试，但JavaScript开发人员仍然处于未知的领域，需要弄清楚如何正确地测试他们的应用程序。最近，这个空白已经被由才华横溢的JavaScript社区成员编写的新工具和测试框架填补。在本章中，我们将介绍一些流行的工具，但请记住，这个领域是相当新的，不断变化，所以你也需要密切关注新出现的解决方案。
- en: 'In this chapter, we''ll discuss two major types of tests: unit tests and **end-to-end**(**E2E**)
    tests. Unit tests are written to validate the functionality of isolated units
    of code. This means a developer should aspire to write each unit test to cover
    the smallest testable part of the application. For example, a developer might
    write unit tests to validate that an ORM method works properly and gives the right
    validation errors as output. However, quite often a developer will choose to write
    unit tests that verify bigger code units, mostly because these units perform an
    isolated operation together. If a developer wants to test a process that includes
    many of the software components combined, he will write an E2E test. E2E tests
    are written to validate cross-application functionality. These tests often force
    the developer to use more than one tool and cover different parts of the application
    in the same test, including UI, server, and database components. An example would
    be an E2E test that validates the signup process. Identifying the right tests
    is one of the crucial steps to writing a proper test suite for your application.
    However, setting appropriate conventions for the development team can make this
    process much easier.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论两种主要类型的测试：单元测试和**端到端**（**E2E**）测试。单元测试是为了验证孤立的代码单元的功能。这意味着开发人员应该努力编写每个单元测试来覆盖应用程序中最小的可测试部分。例如，开发人员可能会编写单元测试来验证ORM方法是否正常工作，并且输出正确的验证错误。然而，开发人员通常会选择编写验证更大代码单元的单元测试，主要是因为这些单元一起执行孤立的操作。如果开发人员想要测试包括许多软件组件的过程，他将编写一个E2E测试。E2E测试是为了验证跨应用程序功能。这些测试通常会迫使开发人员使用多个工具，并在同一个测试中覆盖应用程序的不同部分，包括UI、服务器和数据库组件。一个例子是验证注册过程的E2E测试。确定正确的测试是编写应用程序的适当测试套件的关键步骤之一。然而，为开发团队设置适当的约定可以使这个过程变得更加容易。
- en: Before we begin discussing JavaScript-specific tools, let's first look at a
    quick overview of the TDD paradigm and how it affects our daily development cycles.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论特定于JavaScript的工具之前，让我们首先快速了解一下TDD范式的概述以及它如何影响我们日常的开发周期。
- en: TDD, BDD, and unit testing
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD、BDD和单元测试
- en: '**Test-driven development** (**TDD**) is a software-development paradigm developed
    by software engineer and agile methodology advocate Kent Beck. In TDD, the developer
    starts by writing a (initially failing) test, which defines what is expected from
    an isolated unit of code. The developer is then required to implement the minimum
    amount of code that passes the test.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是由软件工程师和敏捷方法倡导者Kent Beck开发的一种软件开发范式。在TDD中，开发人员首先编写一个（最初失败的）测试，定义了对代码的孤立单元的期望。然后，开发人员需要实现最少量的代码来通过测试。'
- en: 'When the test is successfully passed, the developer cleans up the code and
    verifies that all the tests are passing. The following diagram illustrates TDD
    cycles:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试成功通过时，开发人员清理代码并验证所有测试是否通过。下图说明了TDD循环：
- en: '![TDD, BDD, and unit testing](img/B05071_10_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![TDD，BDD和单元测试](img/B05071_10_01.jpg)'
- en: It is important to remember that although TDD has become a popular approach
    in modern software development, it is very difficult to implement in its purest
    form. To ease this process and improve team communication, a new approach was
    developed on top of TDD, called **Behavior-Driven Development** (**BDD**). The
    BDD paradigm is a subset of TDD, created by Dan North, that helps developers identify
    the scope of their unit tests and express their test process in behavioral terminology.
    Basically, TDD provides the wireframe for writing tests, and BDD provides the
    vocabulary to shape the way tests are written. Usually, a BDD test framework provides
    the developer with a set of self-explanatory methods to describe the test process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，尽管TDD已经成为现代软件开发中流行的方法，但在其纯粹形式下实施是非常困难的。为了简化这个过程并改善团队沟通，TDD的基础上开发了一种新的方法，称为**行为驱动开发**（**BDD**）。BDD范式是TDD的一个子集，由Dan
    North创建，帮助开发人员确定其单元测试的范围，并用行为术语表达其测试过程。基本上，TDD为编写测试提供了框架，而BDD提供了塑造测试编写方式的词汇。通常，BDD测试框架为开发人员提供了一组自解释的方法来描述测试过程。
- en: Although BDD provides us with a mechanism for writing tests, running these tests
    in a JavaScript environment is still a complicated task. Your application will
    probably run on different browsers and even different versions of the same browser.
    So, running the tests you wrote on a single browser will not provide you with
    proper coverage. To solve this issue, the JavaScript community has developed a
    diverse set of tools for writing, evaluating, and properly running tests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管BDD为我们提供了编写测试的机制，但在JavaScript环境中运行这些测试仍然是一个复杂的任务。您的应用程序可能会在不同的浏览器甚至同一浏览器的不同版本上运行。因此，在单个浏览器上运行您编写的测试将无法提供适当的覆盖范围。为解决这个问题，JavaScript社区开发了一系列多样化的工具，用于编写、评估和正确运行测试。
- en: Test frameworks
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试框架
- en: Although you can start writing your tests using your own library, you'll soon
    find out that it is not very scalable and requires you to build a complex infrastructure.
    Fortunately, considerable effort has been put into solving this issue, which has
    resulted in several popular test frameworks that allow you to write your tests
    in a structured and common way. These test frameworks usually provide a set of
    methods to encapsulate tests. It is also very common for a test framework to provide
    some sort of API that enables you to run tests and integrate the results with
    other tools in your development cycle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以开始使用自己的库编写测试，但很快就会发现这种方法不够可扩展，并且需要您构建一个复杂的基础设施。幸运的是，已经付出了相当大的努力来解决这个问题，这导致了几个流行的测试框架，允许您以结构化和通用的方式编写测试。这些测试框架通常提供一组方法来封装测试。测试框架通常还提供一些API，使您能够运行测试并将结果与开发周期中的其他工具集成。
- en: Assertion libraries
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言库
- en: Though test frameworks provide the developer with a way to create and organize
    tests, they often lack the ability to actually test a Boolean expression that
    represents the test result. For instance, the Mocha test framework, which we'll
    introduce in the next section, doesn't provide the developer with an assertion
    tool. For this purpose, the community has developed several assertion libraries,
    which allow you to examine a certain predicate. The developer uses assertion expressions
    to indicate a predicate that should be true in the test context. When running
    the test, the assertion is evaluated, and if it turns out to be false, the test
    fails.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试框架为开发人员提供了一种创建和组织测试的方式，但它们通常缺乏实际测试表示测试结果的布尔表达式的能力。例如，Mocha测试框架（我们将在下一节介绍）不提供开发人员断言工具。为此，社区开发了几个断言库，允许您检查特定的谓词。开发人员使用断言表达式来指示在测试上下文中应为真的谓词。运行测试时，将评估断言，如果结果为假，则测试失败。
- en: Test runners
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试运行器
- en: Test runners are utilities that enable the developer to easily run and evaluate
    tests. A test runner usually uses a defined testing framework along with a set
    of preconfigured properties to evaluate test results in different contexts. For
    instance, a test runner can be configured to run tests with different environment
    variables or run the same test on different testing platforms (usually browsers).
    We will look at two different test runners in the *Testing your Angular application*
    section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器是一种实用工具，可以让开发人员轻松地运行和评估测试。测试运行器通常使用一个定义好的测试框架以及一组预配置的属性来在不同的上下文中评估测试结果。例如，测试运行器可以配置为在不同的环境变量下运行测试，或者在不同的测试平台（通常是浏览器）上运行相同的测试。我们将在*测试您的Angular应用程序*部分看到两种不同的测试运行器。
- en: 'Now that you have an overview of a set of terms associated with testing, you
    can finally learn how to test the different parts of your MEAN application. Although
    your code is written entirely in JavaScript, it does run on different platforms
    with different scenarios. In order to mitigate the testing process, I''ve divided
    it into two different sections: testing Express components and testing Angular
    components. Let''s begin with testing your Express application components.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了与测试相关的一组术语，最终可以学习如何测试您的MEAN应用程序的不同部分。尽管您的代码完全是用JavaScript编写的，但它在不同的平台上以不同的场景运行。为了简化测试过程，我将其分为两个不同的部分：测试Express组件和测试Angular组件。让我们从测试您的Express应用程序组件开始。
- en: Testing your Express application
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的Express应用程序
- en: In the Express part of your MEAN application, your business logic is mostly
    encapsulated inside controllers; however, you also have Mongoose models that obfuscate
    many tasks, including data manipulation and validations. So, to properly cover
    your Express application code, you will need to write tests that cover both models
    and controllers. In order to do so, you will use Mocha as your test framework,
    the `Should.js` assertion library for your models, and the `SuperTest HTTP` assertion
    library for your controllers. You will also need to create a new test environment
    configuration file that will provide you with special configuration options for
    testing purposes, for example, a dedicated MongoDB connection string. By the end
    of this section, you will learn to use the Mocha command-line tool to run and
    evaluate your test results. We'll begin with presenting the Mocha test framework.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的MEAN应用程序的Express部分中，您的业务逻辑主要封装在控制器中；但是，您还有Mongoose模型，它们模糊了许多任务，包括数据操作和验证。因此，为了正确覆盖Express应用程序代码，您需要编写覆盖模型和控制器的测试。为此，您将使用Mocha作为测试框架，`Should.js`作为模型的断言库，`SuperTest
    HTTP`作为控制器的断言库。您还需要创建一个新的测试环境配置文件，该文件将为您提供用于测试目的的特殊配置选项，例如专用的MongoDB连接字符串。在本节结束时，您将学会使用Mocha命令行工具来运行和评估测试结果。我们将从介绍Mocha测试框架开始。
- en: Introducing Mocha
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Mocha
- en: Mocha is a versatile test framework developed by Express creator TJ Holowaychuk.
    It supports both BDD and TDD unit tests, uses Node.js to run the tests, and allows
    the developer to run both synchronous and asynchronous tests. Since Mocha is minimal
    by structure, it doesn't include a built-in assertion library; instead, it supports
    the integration of popular assertion frameworks. It comes packed with a set of
    different reporters to present the test results and includes many features, such
    as pending tests, excluding tests, and skipping tests. The main interaction with
    Mocha is done using the command-line tool provided, which lets you configure the
    way tests are executed and reported.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha是由Express的创始人TJ Holowaychuk开发的多功能测试框架。它支持BDD和TDD单元测试，使用Node.js运行测试，并允许开发人员运行同步和异步测试。由于Mocha的结构很简洁，它不包括内置的断言库；相反，它支持流行的断言框架的集成。它配备了一系列不同的报告器来呈现测试结果，并包括许多功能，如挂起测试、排除测试和跳过测试。与Mocha的主要交互是通过提供的命令行工具完成的，该工具允许您配置测试的执行和报告方式。
- en: 'The BDD interface for Mocha tests includes several descriptive methods, which
    enable the developer to easily describe the test scenario. These methods are as
    follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha测试的BDD接口包括几种描述性方法，使开发人员能够轻松描述测试场景。这些方法如下：
- en: '`describe(description, callback)`: This is the basic method that wraps each
    test suite with a description. The callback function is used to define test specifications
    or sub-suites.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe(description, callback)`: 这是一个基本方法，用于为每个测试套件添加描述。回调函数用于定义测试规范或子套件。'
- en: '`it(description, callback)`: This is the basic method that wraps each test
    specification with a description. The callback function is used to define the
    actual test logic.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it(description, callback)`: 这是一个基本方法，用于为每个测试规范添加描述。回调函数用于定义实际的测试逻辑。'
- en: '`before(callback)`: This is a hook function that is executed once before all
    the tests in a test suite.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before(callback)`: 这是一个钩子函数，在测试套件中的所有测试之前执行一次。'
- en: '`beforeEach(callback)`: This is a hook function that is executed before each
    test specification in a test suite.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach(callback)`: 这是一个钩子函数，在测试套件中的每个测试规范执行前执行一次。'
- en: '`after(callback)`: This is a hook function that is executed once after all
    the tests in a test suite are executed.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after(callback)`: 这是一个钩子函数，在测试套件中的所有测试执行后执行一次。'
- en: '`afterEach(callback)`: This is a hook function that is executed after each
    test specification in a test suite is executed.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach(callback)`: 这是一个钩子函数，在测试套件中的每个测试规范执行后执行一次。'
- en: Using these basic methods will allow you to define unit tests by utilizing the
    BDD paradigm. However, no test can be concluded without including an assertion
    expression that determines the developer's expectations from the covered code.
    To support assertions, you will need to use an assertion library.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些基本方法将允许您利用BDD范式定义单元测试。然而，没有包含确定开发人员对覆盖的代码的期望的断言表达式，没有测试可以得出结论。为了支持断言，您需要使用一个断言库。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Mocha's features by visiting the official documentation
    at [https://github.com/mochajs/mocha](https://github.com/mochajs/mocha).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问官方文档了解更多关于Mocha的特性[https://github.com/mochajs/mocha](https://github.com/mochajs/mocha)。
- en: Introducing Should.js
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Should.js
- en: 'The `Should.js` library, also developed by TJ Holowaychuk, aims to help developers
    write readable and expressive assertion expressions. Using `Should.js`, you''ll
    be able to keep your test code better organized and produce useful error messages.
    The `Should.js` library extends `Object.prototype` with a non-enumerable getter
    that allows you to express how that object should behave. One of `Should.js''`
    powerful features is that every assertion returns a wrapped object, so assertions
    can be chained. This means that you can write readable expressions that pretty
    much describe the assertions associated with the tested object. For example, a
    chained assertion expression would be as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Should.js`库也是由TJ Holowaychuk开发的，旨在帮助开发人员编写可读性强且表达力强的断言表达式。使用`Should.js`，您将能够更好地组织测试代码并生成有用的错误消息。`Should.js`库通过一个不可枚举的getter扩展了`Object.prototype`，允许您表达对象应该如何行为。`Should.js`的一个强大功能是每个断言都返回一个包装对象，因此可以链接断言。这意味着您可以编写可读的表达式，几乎描述了与被测试对象相关的断言。例如，链接的断言表达式如下所示：'
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how each helper property returns a Should.js object, which can be chained
    using another helper property (`be`, `an`, `have`, and so on) or tested using
    assertion properties and methods (`Object`, `property()`). You can learn more
    about Should.js' features by reading the official documentation at [https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意每个辅助属性如何返回一个Should.js对象，可以使用另一个辅助属性（`be`，`an`，`have`等）链接，或者使用断言属性和方法（`Object`，`property()`）进行测试。您可以通过阅读官方文档了解更多关于Should.js的功能：[https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js)。
- en: While Should.js does an excellent job testing objects, it will not help you
    with testing your HTTP endpoints. To do this, you will need to use a different
    kind of assertion library. This is where the minimal modularity of Mocha comes
    in handy.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Should.js在测试对象方面做得很好，但它无法帮助您测试HTTP端点。为此，您需要使用不同类型的断言库。这就是Mocha的最小模块化的地方派上用场。
- en: Introducing SuperTest
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍SuperTest
- en: 'SuperTest is another assertion library developed by TJ Holowaychuk, which differs
    from other assertion libraries by providing developers with an abstraction layer
    that makes HTTP assertions. This means that instead of testing objects, it will
    help you create assertion expressions that test HTTP endpoints. In your case,
    it will help you test your controller endpoints, thus covering the code that''s
    exposed to the browser. To do so, it will make use of the Express application
    object and test the responses returned from your Express endpoints. An example
    SuperTest assertion expression is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SuperTest是由TJ Holowaychuk开发的另一个断言库，与其他断言库不同之处在于它提供了一个抽象层，用于进行HTTP断言。这意味着它将帮助您创建断言表达式来测试HTTP端点，而不是测试对象。在您的情况下，它将帮助您测试控制器端点，从而覆盖暴露给浏览器的代码。为此，它将利用Express应用程序对象并测试从Express端点返回的响应。一个SuperTest断言表达式示例如下：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how each method can be chained to another assertion expression. This
    will allow you to make several assertions on the same response using the `expect()`
    method. You can learn more about SuperTest's features by visiting the official
    documentation at [https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意每个方法如何可以链接到另一个断言表达式。这将允许您使用`expect()`方法对同一响应进行多个断言。您可以通过访问官方文档了解更多关于SuperTest的功能：[https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest)。
- en: In the next section, you will learn how to leverage Mocha, Should.js, and SuperTest
    to test both your models and your controllers. Let's begin by installing these
    dependencies and properly configuring the test environment. The examples in this
    chapter will continue directly from those in previous chapters, so copy the final
    example from [Chapter 9](ch09.html "Chapter 9. Adding Real-time Functionality
    Using Socket.io"), *Adding Real-time Functionality Using Socket.io*, and let's
    take it from there.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，您将学习如何利用Mocha、Should.js和SuperTest来测试您的模型和控制器。让我们开始安装这些依赖项并正确配置测试环境。本章中的示例将直接从前几章中的示例继续，因此请复制[第9章](ch09.html
    "第9章。使用Socket.io添加实时功能")中的最终示例，*使用Socket.io添加实时功能*，然后从那里开始。
- en: Installing Mocha
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Mocha
- en: 'Mocha is basically a Node.js module that provides command-line capabilities
    to run tests. The easiest way to use Mocha is to first install it as a global
    node module using `npm`. To do so, just issue the following command in your command-line
    tool:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha基本上是一个Node.js模块，提供了运行测试的命令行功能。使用Mocha的最简单方法是首先将其作为全局node模块使用`npm`进行安装。为此，只需在命令行工具中输入以下命令：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As usual, this will install the latest version of Mocha in your global `node_modules`
    folder. When the installation process is successfully finished, you'll be able
    to use the Mocha utility from your command line. Next, you'll need to install
    the Should.js and SuperTest assertion libraries in your project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这将在全局`node_modules`文件夹中安装Mocha的最新版本。安装过程成功完成后，您将能够从命令行中使用Mocha实用程序。接下来，您需要在项目中安装Should.js和SuperTest断言库。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may experience some trouble installing global modules. This is usually a
    permission issue, so use `sudo` or `super user` when running the global install
    command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在安装全局模块时遇到一些问题。这通常是一个权限问题，所以在运行全局安装命令时，请使用`sudo`或`super user`。
- en: Installing the Should.js and SuperTest modules
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Should.js和SuperTest模块
- en: 'Before you can start writing your tests, you will need to install both `Should.js`
    and `SuperTest` using `npm`. To do so, change your project''s `package.json` file
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写测试之前，您需要使用`npm`安装`Should.js`和`SuperTest`。为此，请按照以下步骤更改项目的`package.json`文件：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To install your new dependencies, go to your application''s root folder and
    issue the following command in your command-line tool:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装新的依赖项，请转到应用程序的根文件夹，并在命令行工具中输入以下命令：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will install the specified versions of `Should.js` and `SuperTest` in your
    project's `node modules` folder. When the installation process is successfully
    finished, you will be able to use these modules in your tests. Next, you'll need
    to prepare your project for testing by creating a new environment configuration
    file and setting up your test environment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您项目的`node modules`文件夹中安装指定版本的`Should.js`和`SuperTest`。安装过程成功完成后，您将能够在测试中使用这些模块。接下来，您需要通过创建新的环境配置文件并设置测试环境来为测试准备项目。
- en: Configuring your test environment
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置您的测试环境
- en: 'Since you''re going to run tests that include database manipulation, it would
    be safer to use a different configuration file to run tests. Fortunately, your
    project is already configured to use different configuration files according to
    the `NODE_ENV` variable. While the application automatically uses the `config/env/development.js`
    file, when running in a test environment, we will make sure to set the `NODE_ENV`
    variable to test. All you need to do is create a new configuration file named
    `test.js` in the `config/env` folder. In this new file, paste the following code
    snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您将运行包括数据库操作的测试，因此最好使用不同的配置文件来运行测试。幸运的是，您的项目已经配置为根据`NODE_ENV`变量使用不同的配置文件。虽然应用程序在运行测试环境时会自动使用`config/env/development.js`文件，但我们将确保将`NODE_ENV`变量设置为测试。您需要做的就是在`config/env`文件夹中创建一个名为`test.js`的新配置文件。在这个新文件中，粘贴以下代码片段：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can notice, we changed the `db` property to use a different MongoDB database.
    Other properties remain the same, but you can change them later to test different
    configurations of your application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，我们已经更改了`db`属性，以使用不同的MongoDB数据库。其他属性保持不变，但您可以稍后更改它们以测试应用程序的不同配置。
- en: You'll now need to create a new folder for your test files. To do so, go to
    your app folder and create a new folder named `tests`. Once you're done setting
    up your environment, you can continue to the next section and write your first
    tests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要为测试文件创建一个新文件夹。要这样做，请转到您的应用程序文件夹并创建一个名为`tests`的新文件夹。设置环境完成后，您可以继续下一节并编写您的第一个测试。
- en: Writing your first Mocha test
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写您的第一个Mocha测试
- en: Before you begin writing your tests, you will first need to identify and break
    your Express application's components into testable units. Since most of your
    application logic is already divided into models and controllers, the obvious
    way to go about this would be to test each model and controller individually.
    The next step would be to break this component into logical units of code and
    test each unit separately. For instance, take each method in your controller and
    write a set of tests for each method. You can also decide to test a couple of
    your controller's methods together when each method doesn't perform any significant
    operation by itself. Another example would be to take your Mongoose model and
    test each model method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写测试之前，您首先需要识别和分解Express应用程序的组件为可测试单元。由于大多数应用程序逻辑已经分为模型和控制器，显而易见的方法是分别测试每个模型和控制器。下一步将是将此组件分解为逻辑代码单元，并分别测试每个单元。例如，对控制器中的每个方法进行测试。当每个方法本身不执行任何重要操作时，您还可以决定一起测试控制器的一些方法。另一个例子是对Mongoose模型进行测试并测试每个模型方法。
- en: In BDD, every test begins by describing the test's purpose in natural language.
    This is done using the `describe()` method, which lets you define the test scenario's
    description and functionality. Describe blocks can be nested, which enables you
    to further elaborate on each test. Once you have your test's descriptive structure
    ready, you will be able to define a test specification using the `it()` method.
    Each `it()` block will be regarded as a single unit test by the test framework.
    Each test will also include a single assertion expression or multiple assertion
    expressions. The assertion expressions will basically function as Boolean test
    indicators for your test assumptions. When an assertion expression fails, it will
    usually provide the test framework with a traceable error object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在BDD中，每个测试都以自然语言描述测试目的开始。这是使用`describe()`方法完成的，它允许您定义测试场景的描述和功能。描述块可以嵌套，这使您能够进一步阐述每个测试。一旦您准备好测试的描述结构，您将能够使用`it()`方法定义测试规范。每个`it()`块将被测试框架视为单个单元测试。每个测试还将包括一个或多个断言表达式。断言表达式基本上将作为布尔测试指示器，用于测试您的测试假设。当断言表达式失败时，它通常会为测试框架提供可追踪的错误对象。
- en: While this pretty much explains most of the tests you'll encounter, you'll also
    be able to use supportive methods that execute certain functionality in context
    with your tests. These supportive methods can be configured to run before or after
    a set of tests and even before or after each test is executed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这基本上解释了您将遇到的大多数测试，但您还可以使用支持方法，在测试上下文中执行某些功能。这些支持方法可以配置为在一组测试之前或之后运行，甚至可以在每个测试执行之前或之后运行。
- en: In the following examples, you'll learn to easily use each method to test the
    articles module that you created in [Chapter 8](ch08.html "Chapter 8. Creating
    a MEAN CRUD Module"), *Creating a MEAN CRUD Module*. For the sake of simplicity,
    we will only implement a basic test suite for each component. This test suite
    could and should be largely expanded to ultimately provide decent code coverage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，您将学习如何轻松使用每个方法来测试您在[第8章](ch08.html "第8章。创建一个MEAN CRUD模块")中创建的文章模块，*创建一个MEAN
    CRUD模块*。为简单起见，我们将仅为每个组件实现一个基本的测试套件。这个测试套件可以和应该大大扩展，以最终提供体面的代码覆盖率。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although TDD clearly states that tests should be written before you start coding
    features, the structure of this book forces us to write tests that examine existing
    code. If you wish to implement real TDD in your development process, you should
    be aware that development cycles should begin by first writing the appropriate
    tests.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TDD明确规定在开始编写功能代码之前应编写测试，但本书的结构迫使我们编写检查现有代码的测试。如果您希望在开发过程中实施真正的TDD，您应该意识到开发周期应该从首先编写适当的测试开始。
- en: Testing the Express model
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试Express模型
- en: 'In the model''s test example, we''ll write two tests that verify the model
    `save` method. To begin testing your `Article` Mongoose model, you will need to
    create a new file named `article.server.model.tests.js` in your `app/tests` folder.
    In your new file, paste the following lines of code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型的测试示例中，我们将编写两个测试，以验证模型的`save`方法。要开始测试您的`Article` Mongoose模型，您需要在`app/tests`文件夹中创建一个名为`article.server.model.tests.js`的新文件。在新文件中，粘贴以下代码行：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's start breaking down the test code. First, you required your module dependencies
    and defined your global variables. Then, you began your test using a `describe()`
    method, which informs the test tool that this test is going to examine the `Article`
    model. Inside the `describe` block, we began by creating new `user` and `article`
    objects using the `beforeEach()` method. The `beforeEach()` method is used to
    define a block of code that runs before each test is executed. You can also replace
    it with the `before()` method, which will only get executed once, before all the
    tests are executed. Notice how the `beforeEach()` method informs the test framework
    that it can continue with the test's execution by calling the `done()` callback.
    This will allow the database operations to be completed before actually executing
    the tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始分解测试代码。首先，您需要引入模块依赖项并定义全局变量。然后，您使用`describe()`方法开始测试，该方法通知测试工具将要检查`Article`模型。在`describe`块内，我们首先使用`beforeEach()`方法创建新的`user`和`article`对象。`beforeEach()`方法用于定义在执行每个测试之前运行的代码块。您还可以用`before()`方法替换它，它只会在执行所有测试之前执行一次。注意`beforeEach()`方法如何通过调用`done()`回调通知测试框架可以继续执行测试。这将允许数据库操作在实际执行测试之前完成。
- en: Next, you created a new `describe` block, indicating that you were about to
    test the model save method. In this block, you created two tests using the `it()`
    method. The first test used the `article` object to save a new article. Then,
    you used the `Should.js` assertion library to validate that no error occurred.
    The second test checked the `Article` model validation by assigning an invalid
    value to the `title` property. This time, the `Should.js` assertion library was
    used to validate that an error actually occurred when trying to save an invalid
    `article` object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您创建了一个新的`describe`块，表明您将要测试模型保存方法。在这个块中，您使用`it()`方法创建了两个测试。第一个测试使用`article`对象保存了一篇新文章。然后，您使用`Should.js`断言库来验证没有发生错误。第二个测试通过将无效值赋给`title`属性来检查`Article`模型的验证。这次，使用`Should.js`断言库来验证在尝试保存无效的`article`对象时确实发生了错误。
- en: You finished your tests by cleaning up the `Article` and `User` collections
    using the `afterEach()` method. Like with the `beforeEach()` method, this code
    will run after each test is executed, and can also be replaced with an `after()`
    method. The `done()` method is also used here in the same manner.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过使用`afterEach()`方法清理`Article`和`User`集合来完成测试。与`beforeEach()`方法类似，这段代码将在每个测试执行后运行，并且也可以用`after()`方法替换。`done()`方法在这里也以相同的方式使用。
- en: Congratulations, you created your first unit test! As we stated earlier, you
    can continue expanding this test suite to cover more of the model code, which
    you probably will when dealing with more complicated objects. Next, we'll see
    how you can write more advanced unit tests when covering your controller's code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您创建了您的第一个单元测试！正如我们之前所述，您可以继续扩展此测试套件，以覆盖更多模型代码，当处理更复杂的对象时，您可能会这样做。接下来，我们将看到在覆盖控制器代码时如何编写更高级的单元测试。
- en: Testing the Express controller
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试Express控制器
- en: 'In the controller test example, we''ll write two tests to check the controller''s
    methods that retrieve articles. When setting out to write these tests, we have
    two options: either test the controller''s methods directly or use the defined
    controller''s Express routes in the tests. Although it is preferable to test each
    unit separately, we would choose to go with the second option since our routes''
    definitions are quite simple, so we can benefit from writing more inclusive tests.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器测试示例中，我们将编写两个测试来检查控制器检索文章的方法。在开始编写这些测试时，我们有两个选择：直接测试控制器的方法，或者在测试中使用定义的控制器Express路由。虽然最好是分别测试每个单元，但由于我们的路由定义非常简单，所以我们选择第二个选项，这样我们可以从编写更全面的测试中受益。
- en: 'To begin testing your articles controller, you will need to create a new file
    named `articles.server.controller.tests.js` in your `app/tests` folder. In your
    new file, paste the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始测试文章控制器，您需要在`app/tests`文件夹中创建一个名为`articles.server.controller.tests.js`的新文件。在新文件中，粘贴以下代码片段：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just as with your model test, first you required your module dependencies and
    defined your global variables. Then, you started your test using a `describe()`
    method, which informs the test tool that this test is going to examine the `Articles`
    controller. Inside the `describe` block, we began by creating new `user` and `article`
    objects using the `beforeEach()` method. This time, we saved the article before
    initiating the tests, and then continued with test execution by calling the `done()`
    callback.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您的模型测试一样，首先需要引入模块依赖项并定义全局变量。然后，您使用`describe()`方法开始测试，该方法通知测试工具将要检查`Articles`控制器。在`describe`块内，我们首先使用`beforeEach()`方法创建新的`user`和`article`对象。这次，在初始化测试之前保存了文章，然后通过调用`done()`回调继续测试执行。
- en: Next, you created a new `describe` block indicating that you were about to test
    the controllers' `GET` methods. In this block, you created two tests using the
    `it()` method. The first test uses the `SuperTest` assertion library to issue
    an HTTP `GET` request at the endpoint that returns the list of articles. It then
    examines the HTTP response variables, including the `content-type` header and
    the HTTP response code. When it verifies the response is returned properly, it
    uses three `Should.js` assertion expressions to test the response body. The response
    body should be an array of articles that includes a single article which should
    be similar to the article you created in the `beforeEach()` method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您创建了一个新的`describe`块，表明您将要测试控制器的`GET`方法。在这个块中，您使用`it()`方法创建了两个测试。第一个测试使用`SuperTest`断言库在返回文章列表的端点发出HTTP
    `GET`请求。然后检查HTTP响应变量，包括`content-type`头和HTTP响应代码。当它验证响应正确返回时，它使用三个`Should.js`断言表达式来测试响应主体。响应主体应该是包含一篇文章的文章数组，这篇文章应该类似于您在`beforeEach()`方法中创建的文章。
- en: The second test uses the `SuperTest` assertion library to issue an HTTP `GET`
    request at the endpoint that returns a single article. It then examines the HTTP
    response variables, including the `content-type` header and the HTTP response
    code. Once it verifies that the response is returned properly, it uses three `Should.js`
    assertion expressions to test the response body. The response body should be a
    single `article` object and should be similar to the article you created in the
    `beforeEach()` method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试使用`SuperTest`断言库在返回单个文章的端点发出HTTP `GET`请求。然后，它检查HTTP响应变量，包括`content-type`头和HTTP响应代码。一旦验证响应正确返回，它使用三个`Should.js`断言表达式来测试响应主体。响应主体应该是一个单独的`article`对象，并且应该类似于您在`beforeEach()`方法中创建的文章。
- en: Just as before, you finished your tests by cleaning up the `Article` and `User`
    collections using the `afterEach()` method. Once you're done setting up the testing
    environment and creating your tests, all you have left to do is run them using
    Mocha's command-line tool.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，您可以通过使用`afterEach()`方法清理`Article`和`User`集合来完成测试。完成测试环境的设置和创建测试后，您所剩的就是使用Mocha的命令行工具运行它们。
- en: Running your Mocha test
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行您的Mocha测试
- en: 'To run your Mocha test, you need to use Mocha''s command-line utility, which
    you previously installed. To do so, use your command-line tool and navigate to
    your project''s base folder. Then, issue the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行您的Mocha测试，您需要使用先前安装的Mocha命令行实用程序。为此，请使用命令行工具并导航到项目的基本文件夹。然后，发出以下命令：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Windows users should first execute the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户应首先执行以下命令：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then run Mocha using the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令运行Mocha：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding command will do a few things. First, it will set the `NODE_ENV`
    variable to `test`, forcing your MEAN application to use the test environment''s
    configuration file. Then, it will execute the Mocha command-line utility with
    the `--reporter` flag, telling Mocha to use the `spec` reporter and the path to
    your tests folder. The test results should be reported in your command-line tool
    and will be similar to the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将执行一些操作。首先，它将将`NODE_ENV`变量设置为`test`，强制您的MEAN应用程序使用测试环境的配置文件。然后，它将使用`--reporter`标志执行Mocha命令行实用程序，告诉Mocha使用`spec`报告和您的测试文件夹的路径。测试结果应该在您的命令行工具中报告，并且类似于以下截图：
- en: '![Running your Mocha test](img/B05071_10_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![运行您的Mocha测试](img/B05071_10_02.jpg)'
- en: Mocha's test results
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha的测试结果
- en: This concludes the test coverage of your Express application. You can use these
    methods to expand your test suite and dramatically improve application development.
    It is recommended that you set your test conventions from the beginning of your
    development process; otherwise, writing tests can become an overwhelming experience.
    Next, you'll learn to test your Angular components and write E2E tests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了对Express应用程序的测试覆盖。您可以使用这些方法来扩展您的测试套件，并显着改进应用程序开发。建议您从开发过程的开始设置测试约定；否则，编写测试可能会成为一种令人不知所措的体验。接下来，您将学习如何测试您的Angular组件并编写E2E测试。
- en: Testing your Angular application
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的Angular应用程序
- en: For years, testing frontend code was a complex task. Running tests across different
    browsers and platforms was complicated, and since most of the application code
    was unstructured, test tools mainly focused on UI E2E tests. However, the shift
    towards MVC frameworks allowed the community to create better test utilities,
    improving the way developers write both unit and E2E tests. In fact, the Angular
    team is so focused on testing that every feature developed by the team is designed
    with testability in mind.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，测试前端代码是一项复杂的任务。在不同浏览器和平台上运行测试是复杂的，由于大多数应用程序代码是无结构的，测试工具主要集中在UI E2E测试上。然而，向MVC框架的转变使社区能够创建更好的测试工具，改进了开发人员编写单元测试和E2E测试的方式。事实上，Angular团队非常注重测试，团队开发的每个功能都是以可测试性为目标设计的。
- en: 'Furthermore, platform fragmentation also created a new layer of tools called
    test runners, which allow developers to easily run their tests in different contexts
    and platforms. In this section, we''ll focus on tools and frameworks associated
    with Angular applications, explaining how to best use them to write and run both
    unit and E2E tests. We''ll start with the test framework that will serve us in
    both cases: the Jasmine test framework.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，平台碎片化还创建了一个称为测试运行器的新工具层，允许开发人员轻松地在不同的上下文和平台上运行他们的测试。在本节中，我们将重点关注与Angular应用程序相关的工具和框架，解释如何最好地使用它们来编写和运行单元测试和E2E测试。我们将从将在两种情况下为我们提供服务的测试框架开始：Jasmine测试框架。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although we can use Mocha or any other test framework, using Jasmine is currently
    the easiest and most common approach when testing Angular applications.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用Mocha或任何其他测试框架，但在测试Angular应用程序时，使用Jasmine目前是最简单和最常见的方法。
- en: Introducing the Jasmine framework
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Jasmine框架
- en: 'Jasmine is an opinionated BDD framework developed by the Pivotal organization.
    Conveniently, Jasmine uses the same terminology as Mocha''s BDD interface, including
    the `describe()`, `it()`, `beforeEach()`, and `afterEach()` methods. However,
    unlike Mocha, Jasmine comes prebundled with assertion capabilities, using the
    `expect()` method chained with assertion methods called **Matchers**. Matchers
    are basically functions that implement a Boolean comparison between an actual
    object and an expected value. For instance, a simple test using the `toBe()` matcher
    is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是由Pivotal组织开发的一种有见地的BDD框架。方便的是，Jasmine使用与Mocha的BDD接口相同的术语，包括`describe()`、`it()`、`beforeEach()`和`afterEach()`方法。然而，与Mocha不同，Jasmine预先捆绑了断言功能，使用与**Matchers**相关的`expect()`方法链接的断言方法。Matchers基本上是实现实际对象和预期值之间的布尔比较的函数。例如，使用`toBe()`匹配器的简单测试如下：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `toBe()` matcher uses the `===` operator to compare objects. Jasmine includes
    plenty of other matchers and even enables developers to add custom matchers. Jasmine
    also includes other robust features to allow more advanced test suites. In the
    next section, we'll focus on how to use Jasmine to easily test your Angular components.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBe()`匹配器使用`===`运算符来比较对象。Jasmine还包括许多其他匹配器，甚至使开发人员能够添加自定义匹配器。Jasmine还包括其他强大的功能，以允许更高级的测试套件。在下一节中，我们将重点介绍如何使用Jasmine轻松测试您的Angular组件。'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Jasmine's features by visiting the official documentation
    at [http://jasmine.github.io/2.5/introduction.html](http://jasmine.github.io/2.5/introduction.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问官方文档了解更多有关Jasmine功能的信息[http://jasmine.github.io/2.5/introduction.html](http://jasmine.github.io/2.5/introduction.html)。
- en: Angular unit tests
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular单元测试
- en: In the past, web developers who wanted to write unit tests to cover their frontend
    code had to struggle with determining their test scope and properly organizing
    their test suite. However, the inherent separation of concerns in Angular forces
    the developer to write isolated units of code, making the testing process much
    simpler. Developers can now quickly identify the units they need to test, so components,
    services, directives, and any other Angular entities can be tested as standalone
    units. Furthermore, the extensive use of dependency injection in Angular enables
    developers to switch contexts and easily cover their code with an extensive test
    suite. However, before you begin writing tests for your Angular application, you
    will first need to prepare your test environment, beginning with the Karma test
    runner.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，想要编写单元测试以覆盖其前端代码的Web开发人员必须努力确定其测试范围并正确组织其测试套件。然而，Angular中的关注点内在分离迫使开发人员编写独立的代码单元，使测试过程变得更加简单。开发人员现在可以快速识别他们需要测试的单元，因此组件、服务、指令和任何其他Angular实体都可以作为独立单元进行测试。此外，Angular中广泛使用的依赖注入使开发人员能够切换上下文并轻松地使用广泛的测试套件覆盖其代码。但是，在开始为您的Angular应用程序编写测试之前，您首先需要准备好测试环境，从Karma测试运行器开始。
- en: Introducing Karma test runner
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍Karma测试运行器
- en: The Karma test runner is a utility developed by the Angular team that helps
    developers execute tests in different browsers. It does so by starting a web server
    that runs source code with test code on selected browsers, reporting the tests
    result back to the command-line utility. Karma offers real test results for real
    devices and browsers, flow control for IDEs and the command line, and framework-agnostic
    testability. It also provides developers with a set of plugins that enables them
    to run tests with the most popular test frameworks. The team also provides special
    plugins called browser launchers that enable Karma to run tests on selected browsers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Karma测试运行器是由Angular团队开发的实用工具，可帮助开发人员在不同的浏览器中执行测试。它通过启动一个运行源代码和测试代码的Web服务器在选定的浏览器上运行，将测试结果报告给命令行实用程序。Karma为真实设备和浏览器提供真实的测试结果，为IDE和命令行提供流程控制，并提供与框架无关的可测试性。它还为开发人员提供了一组插件，使他们能够使用最流行的测试框架运行测试。团队还提供了称为浏览器启动器的特殊插件，使Karma能够在选定的浏览器上运行测试。
- en: In our case, we will use the Jasmine test framework along with a PhantomJS browser
    launcher. However, testing real applications will require you to expand Karma's
    configuration to include more launchers and execute tests on the browsers you
    intend to support.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将使用Jasmine测试框架以及PhantomJS浏览器启动器。但是，测试真实应用程序将需要您扩展Karma的配置以包括更多的启动器，并在您打算支持的浏览器上执行测试。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PhantomJS is a headless WebKit browser often used in programmable scenarios
    where you don't need a visual output; that's why it works perfectly for testing
    purposes. You can learn more about PhantomJS by visiting the official documentation
    at [http://phantomjs.org/documentation/](http://phantomjs.org/documentation/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS是一个无头的WebKit浏览器，通常用于不需要视觉输出的可编程场景；这就是为什么它非常适用于测试目的。您可以通过访问官方文档了解更多关于PhantomJS的信息[http://phantomjs.org/documentation/](http://phantomjs.org/documentation/)。
- en: Installing the Karma command-line tool
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Karma命令行工具
- en: 'The easiest way to start using Karma is to globally install the command-line
    tool provided using `npm`. To do so, just issue the following command in your
    command-line tool:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Karma的最简单方法是使用`npm`提供的命令行工具进行全局安装。要这样做，只需在命令行工具中输入以下命令：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will install the latest version of Karma's command-line utility in your
    global `node_modules` folder. When the installation process is successfully finished,
    you'll be able to use the Karma utility from your command line. Next, you'll need
    to install Karma's project dependencies.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在全局`node_modules`文件夹中安装Karma命令行实用程序的最新版本。安装过程成功完成后，您将能够从命令行使用Karma实用程序。接下来，您需要安装Karma的项目依赖项。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may experience some trouble installing global modules. This is usually a
    permission issue, so use `sudo` or super user when running the global install
    command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在安装全局模块时遇到一些问题。这通常是权限问题，因此在运行全局安装命令时，请使用`sudo`或超级用户。
- en: Installing Karma's dependencies
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Karma的依赖项
- en: 'Before you can start writing your tests, you will need to install Karma''s
    dependencies using `npm`. To do so, change your `package.json` file as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始编写测试之前，您需要使用`npm`安装Karma的依赖项。要这样做，请按照以下步骤更改您的`package.json`文件：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, you added Karma and Jasmine core packages, Karma''s Jasmine
    plugin, and Karma''s PhantomJS launcher to your `devDependencies` property. To
    install your new dependencies, go to your application''s `root` folder and issue
    the following command in your command-line tool:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您已将Karma和Jasmine核心包、Karma的Jasmine插件以及Karma的PhantomJS启动器添加到了`devDependencies`属性中。要安装新的依赖项，请转到应用程序的`root`文件夹，并在命令行工具中输入以下命令：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will install the specified version of Karma's core package, Karma's Jasmine
    plugin, and Karma's PhantomJS launcher in your project's `node_modules` folder.
    When the installation process is successfully finished, you will be able to use
    these modules to run your tests. Next, you'll need to configure Karma's execution
    by adding a Karma configuration file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的项目的`node_modules`文件夹中安装指定版本的Karma核心包、Karma的Jasmine插件和Karma的PhantomJS启动器。当安装过程成功完成时，你将能够使用这些模块来运行你的测试。接下来，你需要通过添加一个Karma配置文件来配置Karma的执行。
- en: Configuring the Karma test runner
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Karma测试运行器
- en: 'In order to control Karma''s test execution, you will need to configure Karma
    using a special configuration file placed at the `root` folder of your application.
    When executed, Karma will automatically look for the default configuration file,
    named `karma.conf.js`, in the application''s `root` folder. You can also indicate
    your configuration file''s name using a command-line flag, but for simplicity
    reasons, we''ll use the default filename. To start configuring Karma, create a
    new file in your application folder, and name it `karma.conf.js`. In your new
    file, paste the following code snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制Karma的测试执行，你需要使用一个特殊的配置文件来配置Karma，该文件放置在应用程序的`root`文件夹中。当执行时，Karma将自动查找默认配置文件，命名为`karma.conf.js`，位于应用程序的`root`文件夹中。你也可以使用命令行标志指示你的配置文件的名称，但出于简单起见，我们将使用默认文件名。要开始配置Karma，在你的应用程序文件夹中创建一个新文件，并将其命名为`karma.conf.js`。在你的新文件中，粘贴以下代码片段：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, Karma''s configuration file is used to set the way Karma executes
    tests. In this case, we used the following settings:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Karma的配置文件用于设置Karma执行测试的方式。在这种情况下，我们使用了以下设置：
- en: '`basePath`: This tells Karma to use an empty base path.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basePath`：这告诉Karma使用空的基本路径。'
- en: '`frameworks`: This tells Karma to use the Jasmine framework.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frameworks`：这告诉Karma使用Jasmine框架。'
- en: '`files`: This sets the list of files that Karma will include in its tests.
    Notice that you can use glob patterns to indicate file patterns. In this case,
    we included all of our library files and module files, excluding our test files.
    Moreover, we configured our application and library files to be served by the
    Karma server even though they''re not being included directly in the page.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`：这设置了Karma将包含在其测试中的文件列表。请注意，你可以使用glob模式来指示文件模式。在这种情况下，我们包括了所有的库文件和模块文件，但不包括我们的测试文件。此外，我们配置了我们的应用程序和库文件，以便它们由Karma服务器提供，即使它们并没有直接包含在页面中。'
- en: '`reporters`: This sets the way Karma reports its test results.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reporters`：这设置了Karma报告其测试结果的方式。'
- en: '`browsers`: This is a list of browsers Karma will test on. Note that we can
    only use the PhantomJS browser since we haven''t installed any other launcher
    plugin.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browsers`：这是Karma将在其上测试的浏览器列表。请注意，由于我们没有安装其他启动器插件，所以我们只能使用PhantomJS浏览器。'
- en: '`captureTimeout`: This sets the timeout for Karma test execution.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`captureTimeout`：这设置了Karma测试执行的超时时间。'
- en: '`singleRun`: This forces Karma to quit after it finishes the test execution.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singleRun`：这强制Karma在完成测试执行后退出。'
- en: These properties are project oriented, which means they will change according
    to your requirements. For instance, you'll probably include more browser launchers
    in real-world applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性是项目导向的，这意味着它们将根据你的需求而改变。例如，在实际应用中，你可能会包含更多的浏览器启动器。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Karma's configuration by visiting the official documentation
    at [https://karma-runner.github.io/1.0/config/configuration-file.html](https://karma-runner.github.io/1.0/config/configuration-file.html).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问官方文档了解更多关于Karma配置的信息[https://karma-runner.github.io/1.0/config/configuration-file.html](https://karma-runner.github.io/1.0/config/configuration-file.html)。
- en: 'We have two more things to do in order to finish with our Karma configuration.
    We''ll begin by modifying the `System.js` configuration. To do so, go to your
    `public`/s`ystemjs.config.js` file and change it as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两件事要做，以完成我们的Karma配置。我们将首先修改`System.js`配置。为此，转到你的`public`/s`ystemjs.config.js`文件，并按以下方式更改它：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, we only told `System.js` to map our Angular testing modules
    to the right `UMD` module file. Next, we''ll need to create our karma "shim" file
    that actually loads our tests. To do so, create a new file named `karma.shim.js`
    in the `root` folder of your application. Inside your new file, paste the following
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们只告诉`System.js`将我们的Angular测试模块映射到正确的`UMD`模块文件。接下来，我们需要创建我们的karma“shim”文件，实际上加载我们的测试。为此，在应用程序的`root`文件夹中创建一个名为`karma.shim.js`的新文件。在你的新文件中，粘贴以下代码：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, our file basically stops Karma from running the tests automatically
    on startup by overriding the loaded hook. Then, it loads the `System.js` configuration
    file and imports our test files. Once it loads all the files, it tells Karma to
    run the tests by calling its start hook. That's it! All we have left to do is
    to start writing our tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的文件基本上通过覆盖加载钩子来阻止Karma在启动时自动运行测试。然后，它加载`System.js`配置文件并导入我们的测试文件。一旦加载了所有文件，它告诉Karma通过调用其start
    hook来运行测试。就是这样！我们唯一剩下的事情就是开始编写我们的测试。
- en: Writing Angular unit tests
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Angular单元测试
- en: Once you're done configuring your test environment, writing unit tests becomes
    an easy task. While the general structure is the same, each entity test is a bit
    different and involves subtle changes. In this section, you'll learn how to test
    the major Angular entities. Let's begin with testing a component.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了测试环境，编写单元测试就变得很容易。虽然一般结构是相同的，但每个实体测试都有些不同，并涉及微妙的变化。在本节中，你将学习如何测试主要的Angular实体。让我们从测试一个组件开始。
- en: Testing components
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试组件
- en: 'Testing a component can vary in complexity. A simple component is quite easy
    to test, while more complicated components can be a bit tricky. A good intermediate
    example would be to test our articles list component, since it uses a service
    and it renders a simple DOM for our articles. To test your component, go to your
    `public/app/articles/list` folder and create a file named `list.component.spec.ts`.
    In your new file, paste the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个组件的复杂程度可能会有所不同。简单的组件测试起来相当容易，而更复杂的组件可能会有些棘手。一个很好的中间例子是测试我们的文章列表组件，因为它使用了一个服务，并为我们的文章呈现了一个简单的DOM。要测试您的组件，请转到`public/app/articles/list`文件夹，并创建一个名为`list.component.spec.ts`的文件。在新文件中，粘贴以下代码：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's go over this example. We begin with importing all the necessary modules
    for our test. Next, we create the `MockArticlesService`, which will replace our
    `ArticlesService` in order to provide the `ListComponent` with a list of articles.
    This is an important step, because as we write our unit tests, it's very important
    to isolate each unit as much as possible. In this case, we want to avoid any connection
    to the real `ArticlesService`, so we'll provide our component with a static data
    source. Then, we create a mock `routerLink` so that our component test can render
    our links.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个例子。我们首先导入所有测试所需的模块。接下来，我们创建`MockArticlesService`，它将替换我们的`ArticlesService`，以便为`ListComponent`提供一组文章。这是一个重要的步骤，因为在编写单元测试时，尽可能地隔离每个单元非常重要。在这种情况下，我们希望避免与真实的`ArticlesService`建立任何连接，因此我们将为我们的组件提供一个静态数据源。然后，我们创建一个模拟的`routerLink`，以便我们的组件测试可以呈现我们的链接。
- en: Next, we create our test suite using the `describe` keyword, and we use Angular's
    `TestBed` object to configure our testing module. We provide the `configureTestingModule`
    method with the declarations and providers we need in our module and then use
    the `TestBed` object again to create a component fixture of our `ListComponent`.
    We then create our test using the `it` keyword and use the component fixture to
    get our `ListComponent` native element, so we'll be able to compare it with the
    data from the `MockArticlesService` using Jasmine's matchers. This is it! Next,
    we'll see how we test services, but before we can do so, we'll need to learn how
    to mock a backend data service.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`describe`关键字创建我们的测试套件，并使用Angular的`TestBed`对象来配置我们的测试模块。我们使用`configureTestingModule`方法提供我们模块中需要的声明和提供者，然后再次使用`TestBed`对象来创建我们的`ListComponent`的组件装置。然后我们使用`it`关键字创建我们的测试，并使用组件装置来获取我们的`ListComponent`的原生元素，这样我们就能够使用Jasmine的匹配器与`MockArticlesService`的数据进行比较。就是这样！接下来，我们将看到如何测试服务，但在我们这样做之前，我们需要学习如何模拟后端数据服务。
- en: Mocking backend data
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟后端数据
- en: While testing an Angular application, it is recommended that unit tests execute
    quickly and separately from the backend server. This is because we want the unit
    tests to be as isolated as possible and work in a synchronous manner. This means
    we need to control the dependency-injection process and provide mock components
    that emulate real components' operation. For instance, most of the components
    that communicate with the backend server usually use the `http` service or some
    sort of abstraction layer. Furthermore, the `Http` service sends requests to the
    server using the `XHRBackend` service. This means that by injecting a different
    backend service, we can send fake HTTP requests that won't hit a real server.
    As we previously stated, the Angular team is very committed to testing, so they've
    already created these tools for us in the form of the `MockBackend` class. The
    `MockBackend` class allows developers to define mock responses to HTTP requests.
    This class can be injected into any service that uses the `Http` service and be
    configured to supply HTTP requests with predefined data. Let's see how it can
    be used to test our `ArticlesService`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试Angular应用程序时，建议单元测试快速执行，并与后端服务器分开。这是因为我们希望单元测试尽可能地独立并以同步方式工作。这意味着我们需要控制依赖注入过程，并提供模拟组件来模拟真实组件的操作。例如，大多数与后端服务器通信的组件通常使用`http`服务或某种抽象层。此外，`Http`服务使用`XHRBackend`服务向服务器发送请求。这意味着通过注入不同的后端服务，我们可以发送不会命中真实服务器的假HTTP请求。正如我们之前所述，Angular团队非常致力于测试，因此他们已经为我们创建了这些工具，以`MockBackend`类的形式提供。`MockBackend`类允许开发人员定义对HTTP请求的模拟响应。这个类可以被注入到任何使用`Http`服务的服务中，并配置为提供预定义数据的HTTP请求。让我们看看如何使用它来测试我们的`ArticlesService`。
- en: Testing services
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试服务
- en: 'Testing services is a bit different from testing components. As we previously
    discussed, we''ll need to use the `MockBackend` class in order to mock our service
    HTTP requests. Let''s see how this can be applied with our `ArticlesService`.
    To create a sample test suite of our service, go to your `public/app/articles`
    folder and create a file named `articles.service.spec.ts`. In your new file, paste
    the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 测试服务与测试组件有些不同。正如我们之前讨论的，我们需要使用`MockBackend`类来模拟我们的服务HTTP请求。让我们看看如何在`ArticlesService`中应用这个方法。要创建一个服务的示例测试套件，请转到`public/app/articles`文件夹，并创建一个名为`articles.service.spec.ts`的文件。在新文件中，粘贴以下代码：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's go over this example. We begin with importing all the necessary modules
    for our test. Next, we create our test suite using the `describe` keyword and
    utilize Angular's `TestBed` object to configure our testing module. We provide
    the `configureTestingModule` method with the `ArticlesService` provider and the
    `MockBackend` as our `XHRBackend` provider. We then inject it along with the HTTP
    service and create an instance of our `ArticlesService`. In our actual test, we
    create a mock response and tell our `MockBackend` instance to respond with our
    mock response by subscribing to its connections. We finish our test by calling
    the `create` method of our `ArticlesService` and expect it to respond with our
    mock article instance properties. That's it! We've just tested one of the methods
    of our `ArticlesService`; to complete the test suite, you'll need to test the
    others as well. Next, we'll learn how to test our Angular routes definitions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个例子。我们首先导入所有必要的模块进行测试。接下来，我们使用`describe`关键字创建我们的测试套件，并利用Angular的`TestBed`对象来配置我们的测试模块。我们使用`configureTestingModule`方法提供`ArticlesService`提供程序和`MockBackend`作为我们的`XHRBackend`提供程序。然后我们将其与HTTP服务一起注入并创建我们的`ArticlesService`的实例。在我们的实际测试中，我们创建一个模拟响应，并告诉我们的`MockBackend`实例通过订阅其连接来响应我们的模拟响应。我们通过调用`ArticlesService`的`create`方法并期望它响应我们的模拟文章实例属性来完成我们的测试。就是这样！我们刚刚测试了`ArticlesService`的一个方法；要完成测试套件，您还需要测试其他方法。接下来，我们将学习如何测试我们的Angular路由定义。
- en: Testing routes
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试路由
- en: 'To test our routes, we will need to make sure our router can navigate to our
    application''s URLs. In our case, we can test the routes created in our `AppComponent`.
    To do so, go to your `public/app` folder and create a file named `app.routes.spec.ts`.
    In your new file, paste the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的路由，我们需要确保我们的路由器能够导航到我们应用程序的URL。在我们的情况下，我们可以测试在我们的`AppComponent`中创建的路由。要这样做，转到您的`public/app`文件夹并创建一个名为`app.routes.spec.ts`的文件。在新文件中，粘贴以下代码：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can notice, testing routes is quite simple. We're just using Angular's
    `TestBed` object to create our testing module and import the `RouterTestingModule`.
    Next, we use our component injector to get the `location` instance. In our tests,
    we just use the `location.go` method and check whether the location path changed
    accordingly. Next, we'll learn how we can write unit tests for directives.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，测试路由非常简单。我们只是使用Angular的`TestBed`对象来创建我们的测试模块并导入`RouterTestingModule`。接下来，我们使用我们的组件注入器来获取`location`实例。在我们的测试中，我们只是使用`location.go`方法并检查位置路径是否相应地更改。接下来，我们将学习如何为指令编写单元测试。
- en: Testing directives
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试指令
- en: 'Testing directives in Angular 2 is basically testing the way structural and
    attribute directives affect the DOM. For instance, to test the `ngIf` directive,
    you can go to your `public/app` folder and create a file named `directive.spec.ts`.
    In your new file, paste the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 2中测试指令基本上是测试结构和属性指令影响DOM的方式。例如，要测试`ngIf`指令，您可以转到您的`public/app`文件夹并创建一个名为`directive.spec.ts`的文件。在新文件中，粘贴以下代码：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how we created a `TestComponent` for our directive and then used the
    `TestBed` utility to generate our component instance and test the way the `ngIf`
    directive changes the rendering of the DOM.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们为指令创建了一个`TestComponent`，然后使用`TestBed`实用程序生成我们的组件实例，并测试`ngIf`指令改变DOM渲染的方式。
- en: Testing pipes
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试管道
- en: 'As with directives, we haven''t touched the subject of pipes enough. However,
    pipes are a very simple yet powerful component of Angular that help us easily
    transform data into readable format. The Angular pipes vary in functionality from
    simple case changing to date and internationalization, but most importantly, you
    can write your own pipes. Testing a pipe is very easy, since all you have to do
    is instantiate the `Pipe` class and provide it with input and expected output.
    For instance, to test Angular''s `LowerCasePipe` class, you will need to go to
    your `public/app` folder and create a file named `pipe.spec.ts`. In your new file,
    paste the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与指令一样，我们还没有涉及管道的主题。然而，管道是Angular的一个非常简单但功能强大的组件，它可以帮助我们轻松地将数据转换为可读格式。Angular的管道功能各不相同，从简单的大小写转换到日期和国际化，但最重要的是，您可以编写自己的管道。测试管道非常容易，因为您只需实例化`Pipe`类并为其提供输入和预期输出。例如，要测试Angular的`LowerCasePipe`类，您需要转到`public/app`文件夹并创建一个名为`pipe.spec.ts`的文件。在新文件中，粘贴以下代码：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can notice, we just imported the `LowerCasePipe` class and used its transform
    method to check its functionality.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，我们只是导入了`LowerCasePipe`类，并使用其transform方法来检查其功能。
- en: Now that you have a few unit tests, let's see how you can execute it using Karma's
    command-line utility.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了一些单元测试，让我们看看如何使用Karma的命令行实用程序来执行它。
- en: Running your Angular unit tests
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行您的Angular单元测试
- en: 'To run your Angular tests, you will need to use the Karma''s command-line utility
    you previously installed. Before you can do that, we''ll need to finish our test
    setup. To do so, go to your `public/app` folder and create a file named `bootstrap.spec.ts`.
    In your new file, paste the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行您的Angular测试，您需要使用之前安装的Karma的命令行实用程序。在您完成测试设置之前，我们需要完成我们的测试设置。要这样做，转到您的`public/app`文件夹并创建一个名为`bootstrap.spec.ts`的文件。在新文件中，粘贴以下代码：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will set the test environment for us with the proper platform modules.
    Now all you have left to do is to go to your project''s base folder and then issue
    the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们设置适当的平台模块的测试环境。现在您只需要转到项目的基本文件夹，然后发出以下命令：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will compile your TypeScript files, so you will now be able to run Karma
    using the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译您的TypeScript文件，因此您现在可以使用以下命令运行Karma：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Windows users should first execute the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户应首先执行以下命令：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, run your tests using the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令运行您的测试：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding command will do a few things. First, it will set the `NODE_ENV`
    variable to `test`, forcing your MEAN application to use the test environment
    configuration file. Then, it will execute the Karma command-line utility. The
    test results should be reported in your command-line tool, similar to the following
    screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将执行一些操作。首先，它将将`NODE_ENV`变量设置为`test`，强制您的MEAN应用程序使用测试环境配置文件。然后，它将执行Karma命令行实用程序。测试结果应该报告在您的命令行工具中，类似于以下屏幕截图：
- en: '![Running your Angular unit tests](img/B05071_10_03.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![运行您的Angular单元测试](img/B05071_10_03.jpg)'
- en: Karma's test results
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Karma的测试结果
- en: This concludes the unit-test coverage of your Angular application. It is recommended
    that you use these methods to expand your test suite and include more tests. In
    the next subsection, you'll learn about Angular E2E testing and how to write and
    run a cross-application E2E test.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了您的Angular应用程序的单元测试覆盖范围。建议您使用这些方法来扩展您的测试套件并包含更多测试。在下一小节中，您将了解有关Angular端到端测试以及如何编写和运行跨应用程序端到端测试。
- en: Angular E2E tests
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular端到端测试
- en: While unit tests serve as the first layer to keep our applications covered,
    it is sometimes necessary to write tests that involve several components together
    that react with a certain interface. The Angular team often refers to these tests
    as E2E tests.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试作为保持应用程序覆盖的第一层，但有时需要编写涉及多个组件一起与某个接口交互的测试。Angular团队经常将这些测试称为端到端测试。
- en: To understand this better, let's say Bob is an excellent frontend developer
    who keeps his Angular code well tested. Alice is also an excellent developer,
    but she works on the backend code, making sure her Express controllers and models
    are all covered. In theory, this team of two does a superb job, but when they
    finish writing the login feature of their MEAN application, they suddenly discover
    it's failing. When they dig deeper, they find out that Bob's code is sending a
    certain `JSON` object, while Alice's backend controller is expecting a slightly
    different `JSON` object. The fact is that both of them did their job, but the
    code is still failing. You might say this is the team leader's fault, but we've
    all been there at some point or another, and while this is just a small example,
    modern applications tend to become very complex. This means that you cannot just
    trust manual testing or even unit tests. You will need to find a way to test features
    across the entire application, and this is why E2E tests are so important.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们假设Bob是一位优秀的前端开发人员，他保持他的Angular代码经过了充分的测试。Alice也是一位优秀的开发人员，但她负责后端代码，确保她的Express控制器和模型都得到了覆盖。理论上，这两个人的团队做得很好，但当他们完成他们的MEAN应用程序的登录功能的编写时，他们突然发现它失败了。当他们深入挖掘时，他们发现Bob的代码发送了一个特定的`JSON`对象，而Alice的后端控制器期望一个略有不同的`JSON`对象。事实是，他们两个都做了自己的工作，但代码仍然失败了。你可能会说这是团队领导的错，但我们都曾经历过这种情况，虽然这只是一个小例子，但现代应用程序往往变得非常复杂。这意味着你不能只信任手动测试甚至单元测试。您需要找到一种方法来测试整个应用程序的功能，这就是端到端测试如此重要的原因。
- en: Introducing the Protractor test runner
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍Protractor测试运行器
- en: 'To execute E2E tests, you will need some sort of tool that emulates user behavior.
    In the past, the Angular team advocated a tool called the **Angular scenario test
    runner**. However, they decided to abandon this tool and create a new test runner
    called **Protractor**. Protractor is a dedicated E2E test runner that simulates
    human interactions and runs tests using the Jasmine test framework. It is basically
    a Node.js tool that uses a neat library called **WebDriver**. WebDriver is an
    open source utility that allows programmable control over a web browser''s behavior.
    As I stated, Protractor uses Jasmine by default, so tests will look very similar
    to the unit tests you wrote before, but Protractor also provides you with several
    global objects, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行端到端测试，您将需要一些模拟用户行为的工具。过去，Angular团队推荐了一个称为**Angular场景测试运行器**的工具。然而，他们决定放弃这个工具，并创建一个名为**Protractor**的新测试运行器。Protractor是一个专门的端到端测试运行器，模拟人类交互并使用Jasmine测试框架运行测试。它基本上是一个使用名为**WebDriver**的不错的库的Node.js工具。WebDriver是一个开源实用程序，允许对Web浏览器的行为进行可编程控制。正如我所说，Protractor默认使用Jasmine，因此测试看起来会非常类似于您之前编写的单元测试，但Protractor还为您提供了几个全局对象，如下所示：
- en: '`browser`: This is a `WebDriver` instance wrapper that allows you to communicate
    with the browser.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browser`：这是一个`WebDriver`实例包装器，允许您与浏览器通信。'
- en: '`element`: This is a helper function to manipulate HTML elements.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element`：这是一个辅助函数，用于操作HTML元素。'
- en: '`by`: This is a collection of element locator functions. You can use it to
    find an element by a CSS selector, its ID, or even by the model property it''s
    bound to.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`by`：这是一组元素定位器函数。您可以使用它通过CSS选择器、其ID甚至通过其绑定到的模型属性来查找元素。'
- en: '`protractor`: This is a `WebDriver` namespace wrapper containing a set of static
    classes and variables.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protractor`：这是一个`WebDriver`命名空间包装器，包含一组静态类和变量。'
- en: Using these utilities, you'll be able to perform browser operations inside your
    tests' specifications. For instance, the `browser.get()` method will load a page
    for you to perform tests on. It is important to remember that Protractor is a
    dedicated tool for Angular applications, so the `browser.get()` method will throw
    an error if the page it tries to load doesn't include the Angular library. You'll
    write your first E2E test in a moment, but first, let's install Protractor.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些实用程序，您将能够在测试规范中执行浏览器操作。例如，`browser.get()`方法将为您加载一个页面以进行测试。重要的是要记住，Protractor是Angular应用程序的专用工具，因此如果它尝试加载的页面不包括Angular库，`browser.get()`方法将抛出错误。您将很快编写您的第一个端到端测试，但首先让我们安装Protractor。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Protractor is kind of a young tool, so things are bound to change rapidly. It
    is recommended that you learn more about Protractor by visiting the official repository
    page at [https://github.com/angular/protractor](https://github.com/angular/protractor).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor是一种比较年轻的工具，因此事情很可能会迅速发生变化。建议您通过访问官方存储库页面[https://github.com/angular/protractor](https://github.com/angular/protractor)来了解更多关于Protractor的信息。
- en: Installing the Protractor test runner
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Protractor测试运行器
- en: 'Protractor is a command-line tool, so you''ll need to globally install it using
    `npm`. To do so, just issue the following command in your command-line tool:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor是一个命令行工具，因此您需要使用`npm`全局安装它。只需在命令行工具中发出以下命令即可：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will install the latest version of the Protractor command-line utilities
    in your global `node_modules` folder. When the installation process is successfully
    finished, you'll be able to use Protractor from your command line.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在全局`node_modules`文件夹中安装最新版本的Protractor命令行实用程序。安装过程成功完成后，您将能够从命令行中使用Protractor。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may experience some trouble when installing global modules. This is usually
    a permission issue, so use `sudo` or `super user` when running the global install
    command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装全局模块时可能会遇到一些问题。这通常是一个权限问题，所以在运行全局安装命令时使用`sudo`或`super user`。
- en: 'Since Protractor will need a working WebDriver server, you will either need
    to use a Selenium server or install a standalone WebDriver server. You can download
    and install a standalone server by issuing the following command in your command-line
    tool:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Protractor将需要一个可用的WebDriver服务器，您将需要使用Selenium服务器或安装一个独立的WebDriver服务器。您可以通过在命令行工具中发出以下命令来下载并安装一个独立的服务器：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will install the Selenium standalone server, which you'll later use to
    handle Protractor's tests. The next step would be to configure Protractor's execution
    options.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Selenium独立服务器，您稍后将用它来处理Protractor的测试。下一步是配置Protractor的执行选项。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about WebDriver by visiting the official project page at
    [http://www.seleniumhq.org/](http://www.seleniumhq.org/).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问官方项目页面[http://www.seleniumhq.org/](http://www.seleniumhq.org/)了解更多关于WebDriver的信息。
- en: Configuring the Protractor test runner
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Protractor测试运行器
- en: 'In order to control Protractor''s test execution, you will need to create a
    Protractor configuration file in the `root` folder of your application. When executed,
    Protractor will automatically look for a configuration file named `protractor.conf.js`
    in your application''s `root` folder. You can also indicate your configuration
    filename using a command-line flag, but for simplicity reasons, we''ll use the
    default filename. So begin by creating a new file named `protractor.conf.js` in
    your application''s `root` folder. In your new file, paste the following lines
    of code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制Protractor的测试执行，您需要在应用程序的`root`文件夹中创建一个Protractor配置文件。执行时，Protractor将自动在应用程序的`root`文件夹中查找名为`protractor.conf.js`的配置文件。您也可以使用命令行标志指定配置文件名，但出于简单起见，我们将使用默认文件名。因此，请在应用程序的`root`文件夹中创建一个名为`protractor.conf.js`的新文件。在您的新文件中，粘贴以下代码行：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our Protractor configuration file is very basic. The `specs` property basically
    tells Protractor where to find the test files, and the `useAllAngular2AppRoots`
    property tells Protractor to go over all Angular apps available in the page. This
    configuration is project oriented, which means that it will change according to
    your requirements.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Protractor配置文件非常基本。`specs`属性基本上告诉Protractor在哪里找到测试文件，`useAllAngular2AppRoots`属性告诉Protractor遍历页面中所有可用的Angular应用程序。这个配置是面向项目的，这意味着它会根据您的需求而改变。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Protractor's configuration by going over the example
    configuration file at [https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看示例配置文件[https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts)了解更多关于Protractor配置的信息。
- en: Writing your first E2E test
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写您的第一个端到端测试
- en: 'Since E2E tests are quite complicated to write and read, we''ll begin with
    a simple example. In our example, we''ll test the **Create Article** page and
    try to create a new article. Since we didn''t log in first, an error should occur
    and be presented to the user. To implement this test, go to your `public/tests`
    folder and create a new folder named `e2e`, inside this folder, create a new folder
    named `articles`. Inside the `articles` folder, create a new file named `articles.client.e2e.tests.js`.
    Finally, in your new file, paste the following code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于端到端测试编写和阅读起来相当复杂，我们将从一个简单的例子开始。在我们的例子中，我们将测试**创建文章**页面，并尝试创建一篇新文章。由于我们没有先登录，应该会出现错误并呈现给用户。要实现这个测试，转到您的`public/tests`文件夹，并创建一个名为`e2e`的新文件夹，在这个文件夹内，创建一个名为`articles`的新文件夹。在`articles`文件夹内，创建一个名为`articles.client.e2e.tests.js`的新文件。最后，在您的新文件中，粘贴以下代码片段：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The general test structure should already be familiar to you; however, the test
    itself is quite different. We began by requesting the **Create Article** page
    using the `browser.get()` method. Then, we used the `element()` and `by.css()`
    methods to submit the form. Finally, we found the error message element using
    `by.id()` and validated the error text. While this is a simple example, it nicely
    illustrates the way E2E tests work. Next we'll use Protractor to run this test.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的测试结构应该已经很熟悉了；然而，测试本身是非常不同的。我们首先使用`browser.get()`方法请求**创建文章**页面。然后，我们使用`element()`和`by.css()`方法提交表单。最后，我们使用`by.id()`找到错误消息元素并验证错误文本。虽然这是一个简单的例子，但它很好地说明了端到端测试的工作方式。接下来我们将使用Protractor来运行这个测试。
- en: Running your Angular E2E tests
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行您的Angular端到端测试
- en: 'Running Protractor is a bit different from using Karma and Mocha. Protractor
    needs your application to run so that it can access it just like a real user does.
    So let''s begin by running the application; navigate to your application''s `root`
    folder and use your command-line tool to start the MEAN application, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Protractor与使用Karma和Mocha有些不同。Protractor需要您的应用程序运行，以便它可以像真实用户一样访问它。因此，让我们从运行应用程序开始；转到应用程序的`root`文件夹，并使用命令行工具启动MEAN应用程序，如下所示：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Windows users should first execute the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户应首先执行以下命令：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, run your application using the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令运行您的应用程序：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will start your MEAN application using the test environment''s configuration
    file. Now, open a new command-line window and navigate to your application''s
    `root` folder. Then, start the Protractor test runner by issuing the following
    command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用测试环境的配置文件启动您的MEAN应用程序。现在，打开一个新的命令行窗口，并导航到您的应用程序的`root`文件夹。然后，通过发出以下命令启动Protractor测试运行器：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Protractor should run your tests and report the results in your command-line
    window, as shown in the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor应该在命令行窗口中运行您的测试并报告结果，如下面的屏幕截图所示：
- en: '![Running your Angular E2E tests](img/B05071_10_04.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![运行您的Angular E2E测试](img/B05071_10_04.jpg)'
- en: Protractor's test results
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor的测试结果
- en: Congratulations! You now know how to cover your application code with E2E tests.
    It is recommended that you use these methods to expand your test suite and include
    extensive E2E tests.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在知道如何用E2E测试覆盖您的应用程序代码。建议您使用这些方法来扩展您的测试套件并包括广泛的E2E测试。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to test your MEAN application. You learned
    about testing in general and the common TDD/BDD testing paradigms. You then used
    the Mocha test framework and created controller and model unit tests, where you
    utilized different assertion libraries. Then, we discussed the methods of testing
    Angular, where you learned the difference between unit and E2E testing. We then
    proceeded to unit test your Angular application using the Jasmine test framework
    and the Karma test runner. Then, you learned how to create and run E2E tests using
    Protractor. Once you've built and tested your real-time MEAN application, in the
    next chapter, you'll learn how to improve your development-cycle time using some
    popular automation tools.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何测试您的MEAN应用程序。您了解了一般的测试和常见的TDD/BDD测试范式。然后，您使用了Mocha测试框架，并创建了控制器和模型单元测试，其中您使用了不同的断言库。然后，我们讨论了测试Angular的方法，您了解了单元测试和E2E测试之间的区别。然后，我们使用Jasmine测试框架和Karma测试运行器对您的Angular应用程序进行了单元测试。然后，您学习了如何使用Protractor创建和运行E2E测试。一旦您构建并测试了您的实时MEAN应用程序，在下一章中，您将学习如何使用一些流行的自动化工具来提高您的开发周期时间。
