- en: Chapter 2. Using Arrays, Nesting, and Grids
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 使用数组、嵌套和网格
- en: 'Now we''ve had a taste of KnockoutJS, we are now ready to learn new coding
    skills. In this chapter, we will see how to extend our MVVM skills to make a lot
    more sweet data interaction experiences. This chapter will focus on:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝到了KnockoutJS的滋味，我们现在准备好学习新的编程技能。在本章中，我们将看到如何扩展我们的MVVM技能，以创造更多甜蜜的数据交互体验。本章将重点关注：
- en: Conditional binding
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件绑定
- en: Simpler nested binding
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单嵌套绑定
- en: Observable arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察数组
- en: Paged grids
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页网格
- en: Sorting data collections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集合排序
- en: Conditional binding
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件绑定
- en: Data binding is the essence of many new libraries that interact with the HTML
    markup as it gets converted to the DOM. We saw binding in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with KnockoutJS"), *Getting Started with KnockoutJS*,
    using the `data-bind ="..."` bindings. Here we will be looking at conditional
    binding.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是许多与HTML标记交互的新库的核心。我们在[第一章](ch01.html "第一章 使用KnockoutJS入门")中看到了绑定，使用`data-bind="..."`绑定。在这里，我们将探讨条件绑定。
- en: The first thing we will do is understand the concept of conditional binding.
    Our example is meant to be conceptual. We will show a more practical example shortly
    in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是理解条件绑定的概念。我们的例子旨在说明这个概念。在本章中，我们将很快展示一个更实际的例子。
- en: The `if` binding plays a very similar role to the visible property in the DOM.
    The difference is that the `if` binding actually adds and removes the content
    from the DOM whereas visible swaps the CSS display style between visible and none.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`绑定在DOM中的角色与visible属性非常相似。不同之处在于，`if`绑定实际上会在DOM中添加和移除内容，而visible则是交换CSS显示样式在可见和不可见之间。'
- en: 'Create a new file by copying the `_base.htm` file, located in the `ko_2/do`
    folder, and naming it `condition.htm` within the `do` folder. If you get stuck,
    there is a completed copy inside the `done` folder. To make things look better,
    we will now be using the larger Bootstrap template base as it will give us better
    presentation. You will see the following area in the markup code, which is where
    you will place the code for the rest of the book:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制位于`ko_2/do`文件夹中的`_base.htm`文件，并在`do`文件夹中将其命名为`condition.htm`来创建一个新文件。如果你遇到困难，`done`文件夹中有一个完成的副本。为了使事物看起来更好，我们现在将使用更大的Bootstrap模板基础，因为它将给我们更好的展示。你将在标记代码中看到以下区域，这是你将放置本书其余部分代码的地方：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will place the rest of the code in the same place as explained in [Chapter
    1](ch01.html "Chapter 1. Getting Started with KnockoutJS"), *Getting Started with
    KnockoutJS*. Again, this is just to make our work look better as we go through
    the rest of the book. Now, enter the following code in the markup section of the
    `htm` file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把其余的代码放在[第一章](ch01.html "第一章 使用KnockoutJS入门")中解释的相同位置。再次强调，这只是为了让我们的工作在阅读本书的其余部分时看起来更好。现在，在`htm`文件的标记部分输入以下代码：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will give us a checkbox to toggle our content. We will create a variable
    called `showDetails` to bind our content toggle in the `script` section of the
    page. When the checkbox is checked, the content will be added, and when the checkbox
    is unchecked, the content will be removed. Here is the content for the `script`
    section of the `.htm` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个复选框来切换我们的内容。我们将在页面的`script`部分创建一个名为`showDetails`的变量来绑定内容切换。当复选框被勾选时，内容将被添加，当复选框未被勾选时，内容将被移除。以下是`.htm`文件`script`部分的代码：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is nothing complex here. We just have a variable that will hold our true
    or false state. When the variable is true, the content will be added, and when
    the variable is false, it will be removed from the page. Here is what it will
    look like when the value is true:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么复杂的。我们只有一个变量，它将保存我们的真假状态。当变量为真时，内容将被添加，当变量为假时，它将从页面中移除。以下是当值为真时的样子：
- en: '![Conditional binding](img/1028OS_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![条件绑定](img/1028OS_02_01.jpg)'
- en: Go ahead and run the code in the browser and toggle the content by setting the
    checkbox as checked and not checked a few times to make sure your code is working.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行代码，并通过将复选框设置为勾选和不勾选来切换内容几次，以确保你的代码正在工作。
- en: Introduction to arrays in Knockout
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout中数组简介
- en: 'We will start by working with an unbound array. You will see that Knockout
    is smart enough to still work with the array and display the contents correctly.
    In fact, the array we will start out with will be an array with nested data. Add
    the highlighted data to the `script` section of our page:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个未绑定的数组开始工作。你会看到Knockout足够智能，仍然可以与数组一起工作并正确显示内容。实际上，我们将开始的数组将是一个包含嵌套数据的数组。将高亮的数据添加到我们页面的`script`部分：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The employee array data will automatically bind to the MVVM system when we
    run our `applyBindings` function on the page. We will need some markup to tell
    us that it has actually worked. I suggest separating the section of content on
    the page using the `<hr/>` tag just for clarity. Now add the following code to
    the markup section:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在页面上运行`applyBindings`函数时，员工数组数据将自动绑定到MVVM系统。我们需要一些标记来告诉我们它实际上已经工作。我建议使用`<hr/>`标签来分隔页面上的内容部分，以便更清晰。现在将以下代码添加到标记部分：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We learn a few new commands now with Knockout. The first is the `foreach` command.
    If we have an array, which I refer to as a collection, this will look through
    each item. We tell the `foreach` loop to loop through the employee array collection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用Knockout学习一些新的命令。第一个是`foreach`命令。如果我们有一个数组，我称之为集合，这个命令将会遍历每个项目。我们告诉`foreach`循环遍历员工数组集合。
- en: The next thing you will notice is that the elements of the collection are addressed
    at the item level. In other words, we do not need to use `myVM.employee.name`;
    instead, we simply use `name`. This makes for much cleaner code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来会注意到，集合的元素是在项目级别被引用的。换句话说，我们不需要使用`myVM.employee.name`；我们只需简单地使用`name`。这使得代码更加简洁。
- en: 'You will also see we are using the `if` command again. We have also thrown
    in the opposite logic command, `ifnot`. If a null result is returned, then it
    is understood to be the same thing functionally as a false value. This means if
    a person does not have a spouse, they will be marked as available. Hint: this
    would likely cause social waves if you ran a page in your company declaring who
    was available, so this is definitely not suggested as the best practice for a
    company web page.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到我们再次使用了`if`命令。我们还加入了相反的逻辑命令`ifnot`。如果返回空结果，那么在功能上它被视为与false值相同。这意味着如果一个人没有配偶，他们将被标记为可用。提示：如果你在你的公司页面上运行一个声明谁可用的页面，这可能会引起社会波动，所以这绝对不是公司网页的最佳实践。
- en: '![Introduction to arrays in Knockout](img/1028OS_02_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Knockout中数组介绍](img/1028OS_02_02.jpg)'
- en: 'When we run the code, we get the result as shown in the preceding screenshot.
    We see that Bill is not married as expected. Since we know it would not be a good
    idea to post that someone is available there is a simpler way to display this
    same information while skipping the risky classification. We will copy the code
    section and repeat it using the `with` command in place of the `if` command as
    follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们得到的结果如前一个截图所示。我们看到比尔没有结婚，这与预期不符。由于我们知道发布某人可用的信息不是一个好主意，因此有一个更简单的方法来显示相同的信息，同时跳过有风险的分类。我们将复制代码部分，并使用`with`命令代替`if`命令，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is what the page looks like when we run the `with` command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`with`命令时，页面看起来是这样的：
- en: '![Introduction to arrays in Knockout](img/1028OS_02_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Knockout中数组介绍](img/1028OS_02_03.jpg)'
- en: Now I am not saying that `with` is safer than `if` from a technical perspective.
    You will need to think through your business logic smartly just like you would
    think about the social issues in this example. Take a few moments and think about
    the business requirements as the issues that are there are not always technical
    issues. We need to make sure the technical code is taking care of any business
    issues that we should know about as we do our work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我并不是说从技术角度来看`with`比`if`更安全。你需要像思考这个例子中的社会问题一样，聪明地思考你的业务逻辑。花几分钟时间思考业务需求，因为那里的问题并不总是技术问题。我们需要确保技术代码处理我们在工作中应该知道的所有业务问题。
- en: Working with array collections
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与数组集合一起工作
- en: 'Let''s copy our `_base.htm` file to `arrays.htm` in the `do` folder to continue
    our study of array collections in Knockout. First, add our core markup to the
    new page as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`_base.htm`文件复制到`do`文件夹中的`arrays.htm`，以继续我们在Knockout中学习数组集合。首先，将我们的核心标记添加到新页面，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will again need to create a data model in the `script` section for this
    to work. The following is the code for the data section. Here is where we will
    start using an observable array. Knockout uses additional logic to handle arrays
    than it does for simple variable types. These arrays can be a collection of simple
    variables or nested rows of complex structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `script` 部分创建一个数据模型才能使其工作。以下是为数据部分编写的代码。这里我们将开始使用可观察数组。Knockout 使用比简单变量类型更多的逻辑来处理数组。这些数组可以是简单变量的集合或复杂结构的嵌套行：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the page and make sure you get the following result. Of course, if you modified
    the data, you get bonus points for exploring and enjoying the work. In that case,
    your results will look slightly different.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行页面并确保你得到以下结果。当然，如果你修改了数据，你将因探索和享受工作而获得加分。在这种情况下，你的结果将略有不同。
- en: '![Working with array collections](img/1028OS_02_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![处理数组集合](img/1028OS_02_04.jpg)'
- en: 'We will be adding four different buttons to experience working with array collections
    using observable arrays in Knockout. Before we do that, here are the functions
    we can perform on array methods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加四个不同的按钮来体验使用可观察数组在 Knockout 中与数组集合一起工作。在我们这样做之前，这里有我们可以对数组方法执行的操作：
- en: '| Function | Description |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `push()` | Adds item to the end of the collection |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `push()` | 将项添加到集合的末尾 |'
- en: '| `pop()` | Removes the last item from the collection |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 从集合中移除最后一个项 |'
- en: '| `unshift()` | Inserts a new item at the start of the collection |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `unshift()` | 在集合的开始处插入一个新项 |'
- en: '| `shift()` | Removes the first item from the collection and returns it |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `shift()` | 从集合中移除第一个项并返回它 |'
- en: '| `reverse()` | Swaps the order of items in the collection |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `reverse()` | 交换集合中项的顺序 |'
- en: '| `sort()` | Sorts the order of the collection (requires a sorting function)
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `sort()` | 对集合的顺序进行排序（需要排序函数）|'
- en: '| `splice()` | Removes a given number of elements from the collection beginning
    at a declared starting point |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `splice()` | 从集合中从指定的起始点开始移除给定数量的元素 |'
- en: '| `remove()` | Removes all values that equal something and returns them as
    an array; this can also be run as a function for identifying items |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `remove()` | 移除所有等于某个值的值并将它们作为数组返回；这也可以作为函数运行以识别项 |'
- en: '| `removeAll()` | Removes all items from an array list or removes everything
    and returns removed items as an array |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `removeAll()` | 从数组列表中移除所有项或移除所有内容并返回移除的项作为数组 |'
- en: '| `destroy()` | This the **Ruby on Rails** (**RoR**) version of `remove()`
    to make things more familiar to RoR developers |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `destroy()` | 这是 **Ruby on Rails** (**RoR**) 的 `remove()` 版本，以便让 RoR 开发者更熟悉
    |'
- en: '| `destroyAll()` | This is the RoR version of `removeAll()` to make things
    more familiar to RoR developers |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `destroyAll()` | 这是 `removeAll()` 的 RoR 版本，以便让 RoR 开发者更熟悉 |'
- en: 'We will start by adding a button to the page to work with reversing the array
    collection order. On this page, we will be practicing interacting with the data
    model by using functions outside the MVVM binding of Knockout. We will still be
    interacting with the binding results. This will help build inside and outside
    coding skills to use Knockout in different scenarios. Use the following code to
    make a button:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向页面添加一个按钮来处理反转数组集合顺序。在这个页面上，我们将通过使用 Knockout 的 MVVM 绑定之外的功能来与数据模型进行交互。我们仍然将与绑定结果进行交互。这将有助于构建内部和外部编码技能，以便在不同场景中使用
    Knockout。使用以下代码创建一个按钮：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You see here that we are running the JavaScript directly from the button using
    the `reverse` method of the array collection. Add this button and run the page
    again. After clicking on the button, you will see that all of the items in the
    array collection are now in reverse order. Click on it again and again and you
    will see it will reverse the items each time you click. If you compare the previous
    screenshot with the following screenshot, you can see the items in the array collection
    are reversed:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里可以看到，我们正在直接从按钮使用数组集合的 `reverse` 方法运行 JavaScript。添加此按钮并再次运行页面。点击按钮后，你会看到数组集合中的所有项现在都已反转。再次点击它，每次点击都会反转项。如果你将前面的截图与下面的截图进行比较，你可以看到数组集合中的项已反转：
- en: '![Working with array collections](img/1028OS_02_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![处理数组集合](img/1028OS_02_05.jpg)'
- en: 'While this is all nice, dynamic websites are sites that need to have data added
    and removed. We will get started learning about this right now in this chapter.
    The first thing we will do is create a button to add staff. Add the highlighted
    code here to the markup section of the page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一切都很不错，但动态网站是需要添加和删除数据的网站。我们将在本章中立即开始学习这方面的知识。我们首先要做的是创建一个添加员工的按钮。将以下高亮代码添加到页面的标记部分：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Working with array collections](img/1028OS_02_06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![处理数组集合](img/1028OS_02_06.jpg)'
- en: 'You see the `addStaff` function that we need to add staff to our page attached
    to the `onClick` event handler of the button. We will need to use the `push` method
    of our bound array collection to add this in. Add the following function to the
    `script` section of the code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们需要将添加员工到我们页面上的`addStaff`函数附加到按钮的`onClick`事件处理器。我们需要使用我们绑定的数组集合的`push`方法来添加这个函数。将以下函数添加到代码的`script`部分：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when we run the code, it should add the new employee as expected. The
    `push` method will always add the item to the end of the collection, as seen in
    the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行代码时，它应该会按照预期添加新员工。`push`方法始终会将项目添加到集合的末尾，如下面的截图所示：
- en: '![Working with array collections](img/1028OS_02_07.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![处理数组集合](img/1028OS_02_07.jpg)'
- en: 'Let''s refresh the page and follow these steps in order to verify that assumption:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们刷新页面，并按照以下步骤验证这个假设：
- en: Refresh the page.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面。
- en: Click on the **Reverse Sort Staff** button.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**反转排序员工**按钮。
- en: Click on the **Add Staff** button.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加员工**按钮。
- en: Click on the **Reverse Sort Staff** button one more time.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**反转排序员工**按钮。
- en: 'And here is the output image you get:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是你会得到的输出图像：
- en: '![Working with array collections](img/1028OS_02_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![处理数组集合](img/1028OS_02_08.jpg)'
- en: If all we wanted to do was put the item at the top of the list, it would have
    been too much work. This will become especially true as we begin to work with
    larger and larger sets of data. To insert an item at the start of the array collection,
    we will use the `unshift` method in place of the `push` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想将项目放在列表顶部，那就太麻烦了。当我们开始处理更大和更大的数据集时，这一点将变得更加明显。为了在数组集合的开始处插入一个项目，我们将使用`unshift`方法代替`push`方法。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Now is there anyone besides me who thinks the term `unshift()` is just strange?
    Perhaps that will help us remember it easier!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在除了我之外，还有谁认为`unshift()`这个术语很奇怪吗？也许这能帮助我们更容易地记住它！
- en: Removing the last item
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除最后一个项目
- en: 'We saw how `push` added the item to the end of the data; now we can take a
    look at pulling the last item off the array collection. If you use the `pop` method,
    it will not be the last item added to the end of the data, but the last item on
    the collection. This will be the last item showing on the page at the bottom of
    the list of employees; in our case, we will use the following lines code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`push`是如何将项目添加到数据末尾的；现在我们可以看看如何从数组集合中取出最后一个项目。如果你使用`pop`方法，它不会是添加到数据末尾的最后一个项目，而是集合中的最后一个项目。这将是页面上员工列表底部显示的最后一个项目；在我们的例子中，我们将使用以下代码行：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now add a staff member using the **Add Staff** button and you will get the
    following result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过**添加员工**按钮添加一个员工，你会得到以下结果：
- en: '![Removing the last item](img/1028OS_02_09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![移除最后一个项目](img/1028OS_02_09.jpg)'
- en: We see things working just like before. Now there are four staff members. We
    are now going to remove the last item using the inline JavaScript code within
    our button's `onClick` method. This has the opposite effect of the `push` function
    that adds an item to the end of the array collection. It removes the very last
    item of the array collection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一切就像之前一样工作。现在有四名员工。我们现在将使用按钮内的内联JavaScript代码移除最后一个项目。这与向数组集合末尾添加项目的`push`函数相反。它会移除数组集合中的最后一个项目。
- en: 'Here is the view you should have after clicking on the **Remove Staff** button:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**移除员工**按钮后，你应该看到的视图是：
- en: '![Removing the last item](img/1028OS_02_10.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![移除最后一个项目](img/1028OS_02_10.jpg)'
- en: 'Try clicking on the **Reverse Sort Staff** button followed by the **Remove
    Staff** button. This time, you should see **John Jones** gone from the bottom
    of the list, and the list should look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试先点击**反转排序员工**按钮，然后点击**移除员工**按钮。这次，你应该看到**John Jones**从列表底部消失，列表应该看起来像这样：
- en: '![Removing the last item](img/1028OS_02_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![移除最后一个项目](img/1028OS_02_11.jpg)'
- en: Sorting time
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序时间
- en: 'Displaying data is a very common use case for web pages. Perhaps the most common
    function people perform on data besides searching is sorting. We are going to
    look at how to sort data based on particular data fields. This time, we will create
    the logic first. Enter the following code into the `script` tag:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显示数据是网页的一个非常常见的用例。也许除了搜索之外，人们最常对数据进行的功能就是排序。我们将探讨如何根据特定的数据字段对数据进行排序。这次，我们将首先创建逻辑。将以下代码输入到
    `script` 标签中：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will break down the logic for those unfamiliar with this level of JavaScript:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分解那些不熟悉这种JavaScript级别的逻辑的人的逻辑：
- en: The `sort` function passes in two structures. Each structure matches the items
    being sorted. The variable name could be anything; we choose `left` and `right`
    because it helps the programmer remember which variable is which. You can use,
    of course, any variable naming you choose. Each variable contains the whole structure
    of the item being passed in.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sort` 函数传入两个结构。每个结构匹配正在排序的项。变量名可以是任何名称；我们选择 `left` 和 `right` 是因为它们有助于程序员记住哪个变量是哪个。当然，你可以使用你选择的任何变量命名。每个变量包含传入项的整个结构。'
- en: 'The basic return value for `sort` needs to be true or false. This tells the
    program whether the two items should be swapped. This is why they return a value
    using the ternary symbols. It is likely that these are not symbols you used in
    high school math, so they will be foreign to most of us. Here is an explanation:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sort` 的基本返回值需要是 true 或 false。这告诉程序是否应该交换这两个项。这就是为什么它们使用三元符号返回值的原因。这些符号可能不是你在高中数学中使用的符号，所以对我们大多数人来说可能是陌生的。以下是一个解释：'
- en: First, there is a logical comparison followed by the `?` symbol; symbolizing
    the value before `?` tells us whether the results should be based on true or on
    false.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，有一个逻辑比较，后面跟着 `?` 符号；`?` 前面的值告诉我们结果应该基于真还是假。
- en: The first value is what should be returned if the results are true.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个值是如果结果为真应该返回的值。
- en: Then there is a colon to represent the results that should be returned if the
    logic evaluation is false.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后有一个冒号来表示如果逻辑评估为假应该返回的结果。
- en: Note
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should see here that the logic can be stacked to perform a second logical
    evaluation if desired. This could be in either the true or false position.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在这里看到，如果需要的话，逻辑可以堆叠以执行第二次逻辑评估。这可以在真或假的位置进行。
- en: The second value will be what is returned if the value is false. Again, in this
    example, we observe a nested logic that is run when the results are false.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个值将是如果值为假时返回的值。同样，在这个例子中，我们观察到当结果为假时运行的嵌套逻辑。
- en: 'Here is the same logic in an `if` statement for the sake of comparison:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是相同逻辑的 `if` 语句，以便进行比较：
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One of the things you should notice is that there is definitely less code using
    the ternary operator approach. This doesn't mean using the `if` approach is wrong;
    it's just more code to get right, and the more code we type, of course, the more
    time we are likely to spend debugging. If you don't have a standard where you
    work and prefer to use the `if` logic, feel free to go that way. My main goal
    was to show you what many experienced developers do so you could understand the
    code.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该注意到的一件事是，使用三元运算符方法确实有更少的代码。这并不意味着使用 `if` 方法是错误的；只是需要更多的正确代码，而当然，我们输入的代码越多，我们可能花费在调试上的时间就越多。如果你在工作中没有标准并且更喜欢使用
    `if` 逻辑，请随意这样做。我的主要目标是向你展示许多经验丰富的开发者所做的事情，这样你就可以理解代码。
- en: 'Now, let''s add the button to call the code in the markup:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在标记中添加调用代码的按钮：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is what you should see before the sort button is clicked on:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在点击排序按钮之前，你应该看到以下内容：
- en: '![Sorting time](img/1028OS_02_12.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![排序时间](img/1028OS_02_12.jpg)'
- en: 'Notice that it sorts alphabetically based on the first name because the whole
    name is stored as a single field. This is what we expected, and it is working
    correctly if it looks the same as in the following image:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，它根据姓氏按字母顺序排序，因为整个姓名存储为单个字段。这正是我们预期的，如果它看起来与以下图像相同，则表示它工作正确：
- en: '![Sorting time](img/1028OS_02_13.jpg)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![排序时间](img/1028OS_02_13.jpg)'
- en: Now, let's add a staff member to see whether it will sort properly with the
    added item:![Sorting time](img/1028OS_02_14.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个员工成员以查看它是否与添加的项正确排序：![排序时间](img/1028OS_02_14.jpg)
- en: Press the **Sort Staff** button to see whether our added item appears properly
    in the employee list:![Sorting time](img/1028OS_02_15.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **排序员工** 按钮以查看我们添加的项是否正确出现在员工列表中：![排序时间](img/1028OS_02_15.jpg)
- en: The simpleGrid plugin
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单网格插件
- en: Just like jQuery allows for custom plugins, it is possible to use plugins with
    Knockout as well. Here, we are going to use a simple plugin to add grid functionality
    to our page. This plugin also smartly adds paging to the page. We will also do
    some simple CSS to set our grid so it loosens up the space between the cells in
    the table.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像jQuery允许自定义插件一样，使用Knockout也可以使用插件。在这里，我们将使用一个简单的插件来向我们的页面添加网格功能。此插件还智能地添加了分页。我们还将做一些简单的CSS来设置网格，以便在表格单元格之间放松空间。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The reason we code with jQuery, KnockoutJS, Bootstrap, and other **Don't Repeat
    Yourself** (**DRY)** libraries is that they package our work. We don't have to
    rethink, recode, or repeat our work when this is done. Using solutions such as
    jQuery and KnockoutJS, we can DRY out our code by adding our own library extensions.
    The simple grid plugin is an example of this.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用jQuery、KnockoutJS、Bootstrap和其他**DRY（不要重复自己）**库进行编码的原因是它们打包了我们的工作。当这样做时，我们不必重新思考、重新编码或重复我们的工作。使用jQuery和KnockoutJS等解决方案，我们可以通过添加自己的库扩展来DRY我们的代码。简单网格插件就是这样一个例子。
- en: Note that we will cover enough detail in this book that by the end you should
    be able to modify this plugin or build your own. However, you will have to understand
    JavaScript, CSS, HTML, and other topics enough to get the job you are seeking
    to DRY out. Regarding KnockoutJS, you will get the knowledge you need from this
    book. (The `simpleGrid` code was acquired from the KnockoutJS main site. It is
    not part of the core but great learning code just the same.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这本书将涵盖足够的细节，到结束时你应该能够修改此插件或构建自己的。然而，你必须足够理解JavaScript、CSS、HTML和其他主题，以便获得你寻求的工作以DRY（不要重复自己）的方式。关于KnockoutJS，你将从这本书中获得所需的知识。（`simpleGrid`代码是从KnockoutJS主站获得的。它不是核心部分，但同样是一段很好的学习代码。）
- en: 'Use the `_base.htm` copy and create a new page in the `do` folder of `ko_2`,
    named `paged.htm` for this exercise. The first modification we will make is adding
    the highlighted line after the `include` tag for Knockout.js near the bottom of
    the code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`_base.htm`副本，在`ko_2`的`do`文件夹中创建一个名为`paged.htm`的新页面，用于此练习。我们将进行的第一次修改是在代码底部附近的`include`标签之后添加高亮显示的行，用于Knockout.js：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This adds in the logic we need for the simple grid plugin for Knockout. Now
    we can create the markup for our exercise. In the markup section, add the following
    markup:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了我们为简单网格插件所需的逻辑。现在我们可以创建我们练习的标记。在标记部分，添加以下标记：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Look closely at the `data-bind` attribute of the `div` tag. You should notice
    a new command attribute called `simpleGrid`. This is not part of Knockout by default.
    It has been added by our plugin. The `orderVM` attribute that follows is a root
    structure in our ViewModel. This elegant code teaches you how to package your
    code. It is so much simpler and easier to reuse your work or even take advantage
    of the work of others.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察`div`标签的`data-bind`属性。你应该注意到一个新的命令属性，称为`simpleGrid`。这不是Knockout的默认部分。它是由我们的插件添加的。随后的`orderVM`属性是我们ViewModel中的根结构。这段优雅的代码教你如何打包你的代码。它要简单得多，更容易重用你的工作，甚至利用他人的工作。
- en: 'Let''s go through this code. First, we will add in some data for the grid within
    the `script` tag section. This code will be a standard array collection. Take
    a look at the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这段代码。首先，我们将在`script`标签部分添加一些用于网格的数据。这段代码将是一个标准的数组集合。请看以下代码：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we will add our ViewModel to bind using Knockout. Add the following code
    to the page in the `script` section:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加我们的ViewModel以使用Knockout进行绑定。在页面的`script`部分添加以下代码：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the code
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'This is a common manner in which you will see code for Knockout. Let''s run
    the code and make some observations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将看到的Knockout代码的常见方式。让我们运行代码并做一些观察：
- en: '![Running the code](img/1028OS_02_16.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![运行代码](img/1028OS_02_16.jpg)'
- en: 'We see that our data displays as expected with the names of the collection
    item fields listed as the column names. It also added a paging item to the bottom
    automatically. This is the default configuration when running the code for the
    `simpleGrid` plugin. The default page size is 5 records per page. Notice that
    the columns are all squished together. Let''s begin by adding the following line
    of code to the CSS styles on our page:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的数据显示与预期一致，集合项字段的名称被列在列名中。它还自动在底部添加了一个分页项。这是运行`simpleGrid`插件代码时的默认配置。默认每页5条记录。请注意，所有列都挤在一起。让我们首先将以下代码行添加到我们页面上的CSS样式：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Running the code](img/1028OS_02_17.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![运行代码](img/1028OS_02_17.jpg)'
- en: This looks much better with this simple modification. If you are using this
    grid and actually need more control over the style, you can use the cascading
    logic in CSS and nest the table inside a second `div` tag to create an ID or class
    to manage tables contained within that class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这个简单的修改后，看起来要好得多。如果你使用这个网格并且实际上需要更多对样式的控制，你可以使用CSS中的级联逻辑，并将表格嵌套在第二个`div`标签内以创建一个ID或类来管理该类中包含的表格。
- en: 'Next, we want to modify the columns and the default number of columns that
    show by setting the configuration. Add this highlighted code to our `script` section
    on the page:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要通过设置配置来修改列和默认显示的列数。将以下高亮代码添加到页面的`script`部分：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the columns detail declared and the page size set, we see the greater
    value of using DRY code. This has enabled us to manage the ViewModel from our
    scripted code. This is our result with our code at this point:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了列的详细信息并设置了页面大小之后，我们看到使用DRY（Don't Repeat Yourself）代码的更大价值。这使我们能够从我们的脚本代码中管理ViewModel。这是我们在这个阶段的代码结果：
- en: '![Running the code](img/1028OS_02_18.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![运行代码](img/1028OS_02_18.jpg)'
- en: Now you can click through to page 2 to see how this grid is working. We also
    see that our columns look much better with custom column names.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以点击到第2页，看看这个网格是如何工作的。我们还看到，我们的列使用自定义列名后看起来要好得多。
- en: 'It is time to consider the best practice approach to coding with Knockout.
    Open your browser developer tools and go to **Console**. From the console, we
    want to interact with the ViewModel. Try typing the following in the command prompt:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候考虑使用Knockout进行编码的最佳实践方法了。打开你的浏览器开发者工具并转到**控制台**。从控制台，我们想要与ViewModel交互。尝试在命令提示符中键入以下内容：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will get a response similar to the undefined response given by Chrome. The
    model is there and working but suddenly you cannot access the model. This one
    stumped me the first time my code had this issue. The biggest stump was that my
    code came from an online example, but there was a key point I was missing. The
    online example was not interacting with the code from the command prompt and it
    was not interacting with the code from JavaScript outside the ViewModel.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个类似于Chrome给出的未定义响应。模型在那里并且正在工作，但你突然无法访问模型。这让我第一次遇到这个问题时感到困惑。最大的困惑是我从在线示例中获取的代码，但我遗漏了一个关键点。在线示例没有与命令提示符中的代码交互，也没有与ViewModel外部的JavaScript代码交互。
- en: 'The problem is when we declare a `new` object within a JavaScript function,
    the object will not be available outside the call to the code. We can solve this
    by creating a variable to hold the object outside the method call and then passing
    in the object that was created outside the method argument. Let''s change the
    `applyBindings` method by making the following changes. First add the line declaring
    the variable and then update the `applyBindings` method, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于当我们在一个JavaScript函数中声明一个`new`对象时，该对象将不会在代码调用之外可用。我们可以通过在方法调用之外创建一个变量来保存对象，然后传递在方法参数中创建的对象来解决此问题。让我们通过以下更改来更改`applyBindings`方法。首先添加声明变量的行，然后更新`applyBindings`方法，如下所示：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can return to the browser developer tools and run the page again. Then
    type the new command in and notice that the first P is now in lowercase. JavaScript
    is case sensitive, so make sure you get your upper and lowercase right:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到浏览器开发者工具并再次运行页面。然后输入新的命令，注意第一个P现在是小写的。JavaScript区分大小写，所以请确保你的大小写正确：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now you should see an array of collection items. I expanded the first one so
    we could see the results from Chrome here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能看到一个集合项的数组。我展开第一个，这样我们就能在这里看到Chrome的结果：
- en: '![Running the code](img/1028OS_02_19.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![运行代码](img/1028OS_02_19.jpg)'
- en: If you are using JavaScript and it is not connecting to your ViewModel, then
    you might want to make sure you have not made the previously explained error in
    coding. This is only an issue if you need to connect to the ViewModel from outside
    the ViewModel.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用JavaScript并且它没有连接到你的ViewModel，那么你可能想要确保你没有犯之前解释过的编码错误。这仅在你需要从ViewModel外部连接到ViewModel时才是一个问题。
- en: 'Now it is time to add some buttons below our grid for even more custom control.
    We will be adding two buttons: **Add Order** and **First Page**. Let''s add the
    **Add Order** button first. It is code we should be familiar with as we have used
    it earlier in this chapter. We are going to use it again to show that even while
    working with a completely different **user interface** (**UI**) presentation,
    when we update the data in the ViewModel, the View is automatically updated. Add
    the following code to our `script` section on the page:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们的网格下方添加一些按钮，以便进行更多自定义控制了。我们将添加两个按钮：**添加订单**和**第一页**。让我们首先添加**添加订单**按钮。这是我们应该熟悉的代码，因为我们已经在本章的早期使用过它。我们将再次使用它来展示，即使在完全不同的**用户界面**（**UI**）展示中，当我们更新ViewModel中的数据时，视图会自动更新。将以下代码添加到页面的`script`部分：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also, of course, need the markup for the button:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要按钮的标记：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After adding the button, refresh the browser. Add the order and click through
    to the second page of data, and this is what it should look like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 添加按钮后，刷新浏览器。添加订单并点击到数据的第二页，它应该看起来像这样：
- en: '![Running the code](img/1028OS_02_20.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![运行代码](img/1028OS_02_20.jpg)'
- en: We see that the record for **Gerry Markus** has been added. We could use any
    of the code we used in earlier examples to do things like reversing or removing
    records using the array methods listed in this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到**Gerry Markus**的记录已经被添加。我们可以使用本章中列出的数组方法中的任何代码来做像反转或删除记录这样的事情。
- en: 'Now, we have one more button to add that will allow us to control the grid
    page from our ViewModel. First, add the following markup:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要添加一个按钮，这将允许我们从ViewModel控制网格页面。首先，添加以下标记：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We see the click event is wired to the ViewModel method to move to page one.
    We also see a command to enable the page index. This will make sure our index
    is updated.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到点击事件连接到了ViewModel方法以跳转到第一页。我们还看到了一个命令来启用页面索引。这将确保我们的索引得到更新。
- en: 'There are some other methods that can be called on `simpleGrid` that have been
    listed here. You will notice that some of the items are variables while others
    are method calls:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里列出了可以调用`simpleGrid`的一些其他方法。你会注意到其中一些是变量，而其他的是方法调用：
- en: '`pagedOrderModel.orderVM.columns`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pagedOrderModel.orderVM.columns`'
- en: '`pagedOrderModel.orderVM.data()`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pagedOrderModel.orderVM.data()`'
- en: '`pagedOrderModel.orderVM.currentPageIndex()`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pagedOrderModel.orderVM.currentPageIndex()`'
- en: '`pagedOrderModel.orderVM.itemsOnCurrentPage()`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pagedOrderModel.orderVM.itemsOnCurrentPage()`'
- en: '`pagedOrderModel.orderVM.maxPageIndex()`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pagedOrderModel.orderVM.maxPageIndex()`'
- en: '`pagedOrderModel.orderVM.pageSize`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pagedOrderModel.orderVM.pageSize`'
- en: Remember, if you use these items bound to the Knockout `data-bind` attributes,
    you don't always need the parenthesis. This topic was covered in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with KnockoutJS"), *Getting Started with KnockoutJS*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你使用这些绑定到Knockout `data-bind`属性的项，你并不总是需要括号。这个主题在[第1章](ch01.html "第1章。KnockoutJS入门")中有所涉及，*KnockoutJS入门*。
- en: 'The final `script` section should look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`script`部分应该看起来像这样：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Final sort
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终排序
- en: Congratulations on creating a fairly functional piece of code using Knockout!
    Yet, what would data interaction be without the ability to sort? We are going
    to see how to take the sorting we did earlier and modify it to make it more dynamic
    than our previous example with a few simple modifications. You can just continue
    to modify the current page or you could copy the page as `sorting.htm` as that
    is how we approached it. Note that this is completely a matter of choice as it
    will only serve to make your `do` folder match our `done` folder.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你使用Knockout创建了一个相当功能性的代码片段！然而，如果没有排序能力，数据交互将是什么样子呢？我们将看到如何将我们之前所做的排序修改得比之前的示例更动态，只需进行一些简单的修改。你可以继续修改当前页面，或者你可以将页面复制为`sorting.htm`，这就是我们处理它的方式。请注意，这完全是一个选择问题，因为它只会让你的`do`文件夹与我们的`done`文件夹相匹配。
- en: 'Add the following two buttons to your page:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下两个按钮添加到你的页面：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In our previous example for sorting, we did not pass in any values during the
    method call. Here, we are passing the name of a field in our data that tells us
    what we will be sorting with. This follows our theme of DRY coding as we are able
    to use the same command for either of these buttons or in any future code that
    matches. Here is the `script` code we need to add to actually do the sorting:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的排序示例中，我们在方法调用期间没有传递任何值。在这里，我们传递了数据中的一个字段名称，它告诉我们我们将使用什么进行排序。这遵循了DRY编码的主题，因为我们能够为这两个按钮或任何未来的匹配代码使用相同的命令。以下是我们需要添加到实际进行排序的`script`代码：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As simple as it seems, this is all the code it takes to create a reusable piece
    of code allowing us to sort when desired. Here is a screenshot showing name-based
    sorting:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来很简单，但这正是创建一个可重用代码片段所需的所有代码，使我们能够在需要时进行排序。以下是基于名称排序的截图：
- en: '![Final sort](img/1028OS_02_21.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![最终排序](img/1028OS_02_21.jpg)'
- en: 'Here is another screenshot based on item sorting:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是基于项目排序的另一个截图：
- en: '![Final sort](img/1028OS_02_22.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![最终排序](img/1028OS_02_22.jpg)'
- en: 'Why don''t you create one more button to sort based on quantity as an exercise
    to see whether you have it figured out. The following screenshot is what the table
    should look like if you get it right. We will do one more thing though. We need
    to make sure our sort is out of order, so click on the **Sort By Name** button
    first. Then, clicking on the **Sort By Quantity** button should give us this result:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不创建一个按钮来根据数量进行排序作为练习，看看你是否已经搞明白了。以下截图显示了如果你做对了，表格应该看起来像什么。不过，我们还会做一件事。我们需要确保我们的排序是逆序的，所以先点击**按名称排序**按钮。然后，点击**按数量排序**按钮应该给出以下结果：
- en: '![Final sort](img/1028OS_02_23.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![最终排序](img/1028OS_02_23.jpg)'
- en: 'Now, we should modify the table so that we can do reverse sorting. Basically,
    all that is needed is for us to flip our greater than sign in our code where we
    compare the left and right items passed from the sorting logic. We will, of course,
    also need another argument in our method because we want to reuse our code. Since
    the sort direction is not always passed in, we will also include a line to set
    ascending sort as the default choice if one is not declared. The `script` code
    should look like this with the changes highlighted:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该修改表格，以便我们可以进行逆序排序。基本上，我们只需要在我们的代码中将比较排序逻辑传递的左右项的“大于”符号翻转。当然，我们还需要在我们的方法中添加另一个参数，因为我们想重用我们的代码。由于排序方向并不总是传递，我们还将包括一行来设置升序排序作为默认选择，如果没有声明。修改后的`script`代码应该如下所示，变化部分已突出显示：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will, of course, need a new set of buttons for the reverse sort as well:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要为逆序排序设置一组新的按钮：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the view with the reverse sort on the quantity column labeled **Count**:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有逆序排序的**计数**列的视图：
- en: '![Final sort](img/1028OS_02_24.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![最终排序](img/1028OS_02_24.jpg)'
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you have ever built any JavaScript pages with this much interaction with
    your data using JavaScript or even with jQuery, then you will know why the library
    deserves the title of Knockout. The amount of power we have gained using this
    library in just two chapters is compelling. Through this chapter you should have
    gained the ability to do conditional binding, nested binding, observable array
    collections, adding and deleting records in array style management, and sorting
    observable arrays. You even got a quick look at a Knockout plugin.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用JavaScript或jQuery构建过如此多的JavaScript页面与数据交互，那么你就会知道为什么这个库值得“Knockout”这个称号。我们仅用两章就获得了使用这个库所获得的强大功能，这是令人信服的。通过本章，你应该已经获得了进行条件绑定、嵌套绑定、可观察数组集合、以数组风格管理添加和删除记录以及排序可观察数组的能力。你甚至快速浏览了Knockout插件。
- en: In the next chapter, we will learn to drive web forms with the power of Knockout.
    They think differently; and for a few, that is the first reaction. It is an interesting
    double take as the second reaction that nearly instantly follows is that it is
    better. Event binding is also a topic we will dig into in the next chapter with
    special focus on the over-the-top punch Knockout gives us when dealing with grid
    forms.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Knockout的强大功能来驱动Web表单。它们的工作方式不同；对于一些人来说，这是第一个反应。这是一个有趣的第二次反应，紧接着几乎瞬间出现的反应是它更好。事件绑定也是我们将在下一章深入探讨的主题，特别关注Knockout在处理网格表单时给予我们的超凡表现。
