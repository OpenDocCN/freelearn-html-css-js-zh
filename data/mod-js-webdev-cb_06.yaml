- en: Developing with React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React进行开发
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Starting out with React
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用React
- en: Reinstalling your tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新安装您的工具
- en: Defining components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件
- en: Handling state
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理状态
- en: Composing components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合组件
- en: Handling life cycle events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理生命周期事件
- en: Simplifying component development with Storybook
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Storybook简化组件开发
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In the last three chapters, we were developing a backend with `Node`, and now
    we''ll turn to the frontend and build a web application: in particular, a **Single
    Page Application** (**SPA**) in the modern style users have gotten used to.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后三章中，我们正在使用`Node`开发后端，现在我们将转向前端，构建一个Web应用程序：特别是一种现代风格的**单页应用程序**（**SPA**），用户已经习惯了。
- en: Starting out with React
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用React
- en: Suppose you want to build a web application. How would you go about it? Unless
    you have been hiding away somewhere, you are probably aware that there are many
    frameworks out there that can help you construct and organize your web page. However,
    you might be wondering, if you already know HTML, CSS, and JS, why use a framework
    at all, instead of just keeping with vanilla JS, and possibly some library like
    `jQuery` or `Lodash`? After all, a framework imposes some rules and ways of working
    that you could consider to be offputting or bothersome.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想构建一个Web应用程序。您会如何做？除非您一直躲在某个地方，否则您可能已经意识到，有许多框架可以帮助您构建和组织您的网页。但是，您可能会想知道，如果您已经了解HTML、CSS和JS，为什么要使用框架，而不是继续使用纯JS，可能还有一些库，如`jQuery`或`Lodash`？毕竟，框架会施加一些规则和工作方式，您可能会认为这些规则令人讨厌或麻烦。
- en: 'You also have to *learn* how to use the framework, of course, and you probably
    won''t benefit from it until you become proficient. So, there are several possible
    answers for the *why?* question – even including *Sure, don''t use any framework! – *which
    could be just fine for a very small, simple project:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您还必须*学习*如何使用框架，而且直到您熟练掌握它之前，您可能不会从中受益。因此，对于*为什么？*这个问题有几种可能的答案，甚至包括*当然，不使用任何框架！*，这对于一个非常小的、简单的项目可能也是可以的：
- en: Frameworks provide you with a well-tested, solid way, to organize your project
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架为您提供了一个经过充分测试的、稳固的方式来组织您的项目
- en: Frameworks usually scale better for large size applications
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架通常更适合大型应用程序
- en: Frameworks let you work at a higher level of abstractions (for example, creating
    and using your own components) and deal with the nitty-gritty aspects of getting
    everything to work
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架让您在更高级的抽象层次上工作（例如，创建和使用自己的组件），并处理让一切正常运行的琐碎方面
- en: 'Ramping up new developers is usually simpler: if they know the framework, they
    already know where things are supposed to go and how they interact with each other'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 培养新开发人员通常更简单：如果他们了解框架，他们已经知道应该放置在哪里以及它们如何相互作用
- en: Of course, as I mentioned previously, all of these advantages do not apply for
    small projects, with a few developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如我之前提到的，所有这些优势并不适用于小型项目，只有少数开发人员。
- en: There's one extra reason, however, that can be considered even more important.
    Frameworks help you with the difficult task of keeping state (data) and view in
    sync. With large applications, a change or event that happens in one *corner*
    of your application may have implications elsewhere, in other places of the same
    application. Trying to wire things up so that all of the changes are correctly
    propagated throughout your code isn't a simple endeavor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个更重要的原因。框架帮助您解决保持状态（数据）和视图同步的困难任务。对于大型应用程序，应用程序中一个*角落*发生的更改或事件可能会对应用程序的其他地方产生影响。试图将所有更改正确传播到代码中并不是一件简单的事情。
- en: Most frameworks automatically generate the view from the data, and whenever
    anything changes in the state, they do whatever's needed to update the screen
    in an optimal fashion. For example, say you had a list of doodads somewhere. Then,
    you call a webservice and you get an updated list—most doodads match, but some
    are added and some are missing. You could, of course, just recreate the list from
    zero, but that wouldn't look very good, and if you decide to regenerate the whole
    screen every time something changes, performance will suffer. Usually, what will
    happen is that the framework will compute the differences between the current
    list and the new one, and will correspondingly update the HTML code, adding or
    removing DOM elements, so that the list is once again correct. Doing all of this
    by hand, extending this to your whole application, would be a tad too much to
    do!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数框架会自动生成视图，从数据中获取，每当状态发生变化时，它们会以最佳方式更新屏幕。例如，假设您在某处有一个doodads列表。然后，您调用一个网络服务，获取更新后的列表——大多数doodads匹配，但有一些被添加了，有一些缺失了。当然，您可以从零开始重新创建列表，但那看起来不太好，如果您决定每次发生变化时重新生成整个屏幕，性能会受到影响。通常情况下，框架会计算当前列表和新列表之间的差异，并相应地更新HTML代码，添加或删除DOM元素，以使列表再次正确。手动完成所有这些工作，并将其扩展到整个应用程序，将是一件有点太多的事情！
- en: There are several well-known frameworks such as `Angular` (by Google), `Vue`,
    `Ember`, `Backbone`, `Knockout`, and so on. (Sometimes you feel that a new framework
    is born every day!) We'll be using `React` (by Facebook) in this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个知名的框架，如`Angular`（由Google）、`Vue`、`Ember`、`Backbone`、`Knockout`等等。（有时候你会觉得每天都有一个新的框架诞生！）我们将在本书中使用`React`（由Facebook）。
- en: 'An admission: `React` is more correctly called a *library* than a framework,
    because it doesn''t include everything you need to develop your application out
    of the box. However, all of the necessary packages are out there, so that won''t
    impede us. By the way, this sort of criticism also applies to `Vue`, `Knockout`,
    and `Backbone`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 承认一点：`React`更正确地称为*库*而不是框架，因为它不包含您开箱即用开发应用程序所需的一切。然而，所有必要的包都在那里，所以这不会妨碍我们。顺便说一句，这种批评也适用于`Vue`、`Knockout`和`Backbone`。
- en: '`React` also extends to doing mobile applications with `React-Native`, which
    we''ll see later in this book in [Chapter 11](c6b4a41a-3937-419b-8b75-2d6e96452702.xhtml),
    *Creating Mobile Apps with React Native*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`React`还可以用于使用`React-Native`创建移动应用程序，我们将在本书的[第11章](c6b4a41a-3937-419b-8b75-2d6e96452702.xhtml)中看到，*使用React
    Native创建移动应用程序*。'
- en: An interesting article, *The Ultimate Guide to JavaScript Frameworks*, at [https://javascriptreport.com/the-ultimate-guide-to-javascript-frameworks/](https://javascriptreport.com/the-ultimate-guide-to-javascript-frameworks/),
    lists over fifty frameworks! Take a look, and see what pros and cons each framework
    has.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇有趣的文章，*JavaScript框架的终极指南*，在[https://javascriptreport.com/the-ultimate-guide-to-javascript-frameworks/](https://javascriptreport.com/the-ultimate-guide-to-javascript-frameworks/)列出了50多个框架！看一看，看看每个框架有什么优缺点。
- en: In this recipe, we'll install the necessary packages and build a very basic
    first web application of our own.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将安装必要的包并构建我们自己的非常基本的第一个Web应用程序。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's go ahead and create our basic application. If you had to set up a project
    purely by hand, you'd find yourself having to deal with many different tools,
    such as `Babel` for transpiling, `ESLint` for code checks, `Jest` for testing,
    or `Webpack` in order to pack all of your application together, instead of having
    to send dozens or hundreds of individual files over the web. However, nowadays,
    there is a much simpler tool, `create-react-app`, that can deal with this chore
    and get you set up for `React` development in a jiffy. The key selling point is
    *zero configuration*, meaning that some reasonable good choices for both development
    and production builds have been selected, and you can directly move on to writing
    code, not really caring about myriad configuration details.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们的基本应用程序。如果你不得不纯手工设置一个项目，你会发现自己不得不处理许多不同的工具，比如`Babel`用于转译，`ESLint`用于代码检查，`Jest`用于测试，或者`Webpack`用于将你的整个应用程序打包在一起，而不是不得不将数十个或数百个单独的文件发送到网络上。然而，如今，有一个更简单的工具，`create-react-app`，可以处理这个繁琐的工作，并让你迅速开始`React`开发。其关键卖点是*零配置*，这意味着已经选择了一些合理的好选择，用于开发和生产构建，并且你可以直接开始编写代码，而不必关心无数的配置细节。
- en: For people in the know, `create-react-app` is known as CRA, and that's the name
    we'll be using. By the way, CRA is not the only possible way to create a project;
    for example, `react-boilerplate` (at [https://github.com/react-boilerplate/react-boilerplate](https://github.com/react-boilerplate/react-boilerplate))
    provides an alternate solution, but the chosen set of packages and tools are more
    suited to experienced `React` developers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内行的人来说，`create-react-app`被称为CRA，这就是我们将要使用的名称。顺便说一句，CRA并不是创建项目的唯一可能方式；例如，`react-boilerplate`（在[https://github.com/react-boilerplate/react-boilerplate](https://github.com/react-boilerplate/react-boilerplate)）提供了一个替代方案，但所选择的一套包和工具更适合有经验的`React`开发人员。
- en: To create the basic structure (which we'll explain later on) we'll use `npx`
    to run the application creator tool, as shown in the following code. Since we
    are at Chapter 6, let's (imaginatively!) name our project `chapter06`!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建基本结构（我们稍后会解释），我们将使用`npx`来运行应用程序创建工具，如下面的代码所示。由于我们在第6章，让我们（想象！）将我们的项目命名为`chapter06`！
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are curious, `npx` is similar to `npm`, but it executes a *binary* command,
    which is either found in your `node_modules` directory, or at a central cache,
    even installing any packages it might need to run. For more information, go to
    its GitHub page at [https://github.com/zkat/npx](https://github.com/zkat/npx),
    or better yet, read an article by npx''s creator, *Introducing npx: an npm package
    runner* at [https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b](https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你好奇，`npx`类似于`npm`，但它执行一个*二进制*命令，该命令要么在你的`node_modules`目录中找到，要么在一个中央缓存中找到，甚至安装它可能需要运行的任何包。有关更多信息，请访问其GitHub页面[https://github.com/zkat/npx](https://github.com/zkat/npx)，或者更好的是，阅读npx的创建者的一篇文章，*Introducing
    npx: an npm package runner* [https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b](https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b)。'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Running the script will create a basic project structure, including the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本将创建一个基本的项目结构，包括以下内容：
- en: A `package.json` file, and a corresponding `node_modules` directory.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`package.json`文件，以及一个相应的`node_modules`目录。
- en: A `README.md` file, essentially a copy of what you can find at [https://github.com/wmonk/create-react-app-typescript/blob/master/packages/react-scripts/template/README.md](https://github.com/wmonk/create-react-app-typescript/blob/master/packages/react-scripts/template/README.md).
    Pay particular attention to it, because it's full of tips, suggestions, and solutions
    to usual problems you may encounter.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`README.md`文件，基本上是你可以在[https://github.com/wmonk/create-react-app-typescript/blob/master/packages/react-scripts/template/README.md](https://github.com/wmonk/create-react-app-typescript/blob/master/packages/react-scripts/template/README.md)找到的内容的副本。特别注意它，因为它充满了提示、建议和解决你可能遇到的常见问题。
- en: A `public/` directory, with the `index.html` basic HTML code for your application,
    plus a `favicon.ico` icon file and a `manifest.json` file describing your app.
    (If you want to read more about the latter, check out [https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json](https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json).)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`public/`目录，其中包含应用程序的`index.html`基本HTML代码，以及一个`favicon.ico`图标文件和一个描述你的应用程序的`manifest.json`文件。（如果你想了解更多关于后者的信息，请查看[https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json](https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json)。）
- en: A `src/` directory with the `index.js` JS basic code for your application, `index.css`
    with CSS styles, and an `App` component that shows some welcome text, plus some
    basic instructions. All of your JS and CSS files should be placed in `src/` or
    in subdirectories within it, otherwise they won't be included in the build.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`src/`目录，其中包含你的应用程序的`index.js`基本代码，带有CSS样式的`index.css`，以及显示一些欢迎文本和一些基本说明的`App`组件。你所有的JS和CSS文件都应该放在`src/`或其子目录中，否则它们将不会被包含在构建中。
- en: 'Basically, you will want to edit the `index.*` and `App.*` files, and grow
    the project by expanding its structure to provide more components, styles, and
    so on. (Be careful: don''t change the names of the `index.*` files, or your project
    won''t run!) Before getting into writing code, and as shown in the preceding run,
    in the created project directory, you should try `npm start`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你会想要编辑`index.*`和`App.*`文件，并通过扩展其结构来提供更多的组件、样式等来扩展项目。（注意：不要更改`index.*`文件的名称，否则你的项目将无法运行！）在开始编写代码之前，就像前面的运行所示，在创建的项目目录中，你应该尝试`npm
    start`。
- en: 'By doing this, you''ll be able to see the new application, as shown in the
    following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你将能够看到新的应用程序，就像下面的截图所示：
- en: '![](img/edd6e9b1-b0cd-491b-b374-c8f1e4444b86.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edd6e9b1-b0cd-491b-b374-c8f1e4444b86.png)'
- en: The created application, ready for you to start coding
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的应用程序，准备开始编码
- en: If you wish, you can make any kind of minor change in `App.js`, save it, and
    notice the immediate change in the browser page. As to what features of JS you
    can use in your coding, the project is set to accept most modern options, from
    ES6 (full), ES7 (like the exponentiation operator, which you may probably never
    use!), and even newer (most interestingly, `async` and `await`), plus some *Stage
    3* proposals; check [https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#supported-language-features-and-polyfills](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#supported-language-features-and-polyfills) for
    an updated list. It's noteworthy that Flow is recognized, and also JSX, which
    we'll be using in later sections.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以在`App.js`中进行任何小的更改，保存它，然后注意浏览器页面的立即变化。关于你可以在编码中使用的JS功能，项目已经设置为接受大多数现代选项，从ES6（完整）、ES7（如指数运算符，你可能永远不会使用！），甚至更新的（最有趣的是`async`和`await`），再加上一些*Stage
    3*提案；查看[https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#supported-language-features-and-polyfills](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#supported-language-features-and-polyfills)获取更新的列表。值得注意的是，Flow是被认可的，还有JSX，我们将在后面的部分中使用。
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It may happen, at some time, that you need to do some extra configuration that
    CRA hasn't considered, or that you are unable to add it otherwise. In this case,
    you can use the `npm run eject` command to move all of the configuration, scripts,
    and dependencies directly into your project so that you can start tweaking things
    in any way you want. Of course, this will be harder than using the *zero configuration*
    setup, but at least you won't be locked in, with no way out.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生这样的情况，有时你需要做一些额外的配置，CRA没有考虑到，或者你无法以其他方式添加它。在这种情况下，你可以使用`npm run eject`命令将所有配置、脚本和依赖项直接移动到你的项目中，这样你就可以按照自己的方式开始调整事情。当然，这将比使用*零配置*设置更困难，但至少你不会被锁定，没有出路。
- en: If you are curious to learn where all of those things are hidden away, possibly
    to study how everything is set up, the answer is "in the `node_modules/create_react_app`"
    directory; ejecting the project copies things from that directory to your project's.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇想知道所有这些东西都藏在哪里，可能想研究一下所有设置是如何进行的，答案是“在`node_modules/create_react_app`”目录中；弹出项目会将这个目录中的东西复制到你的项目中。
- en: Reinstalling your tools
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新安装你的工具
- en: We have been using `ESLint` for code quality checks, `Prettier` for formatting,
    and `Flow` for data types. In this recipe, we'll get these packages back to work,
    and we'll leave testing (`Jest`, plus more) for [Chapter 10](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml),
    *Testing your Application*. Doing this for two of our tools will be quite straightforward,
    but a tad more complex for the third.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用`ESLint`进行代码质量检查，`Prettier`进行格式化，`Flow`进行数据类型检查。在这个教程中，我们将重新使用这些包，并且将测试（`Jest`等）留到[第10章](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml)，*测试你的应用程序*。对于我们的两个工具来说，这将是非常简单的，但对于第三个工具来说会稍微复杂一些。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: With a fully manual installation, getting everything to work together will be
    quite difficult, but CRA already includes practically everything we need, so all
    you have to do is add some configuration details.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完全手动安装，让所有东西一起工作将会非常困难，但CRA已经包含了我们需要的几乎所有东西，所以你只需要添加一些配置细节。
- en: Reinstalling Flow and Prettier
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新安装Flow和Prettier
- en: 'Let''s start with `Flow`. It''s quite simple to do this: I just did the same
    as for `Node`, adding the same packages, scripts, `.flowconfig` file, and so on.
    (If you need to, check out the *Adding Flow for Data Types checks* section of
    [Chapter 1](d13c6d45-6e6b-4119-9dcd-a65ee7af9f6f.xhtml), *Working with JavaScript
    Development Tools* for more information.)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Flow`开始。这很简单：我只是像对`Node`做的一样，添加了相同的包、脚本、`.flowconfig`文件等。（如果需要，查看[第1章](d13c6d45-6e6b-4119-9dcd-a65ee7af9f6f.xhtml)，*使用JavaScript开发工具*中的*添加Flow进行数据类型检查*部分获取更多信息。）
- en: 'Next, let''s deal with `Prettier`. It also is a simple matter: I had to remove
    the following lines from `package.json` and put them in a separate `.prettierrc`
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理`Prettier`。这也很简单：我不得不从`package.json`中删除以下行，并将它们放在一个单独的`.prettierrc`文件中：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Flow` already *knows* about `React` and CRA, so you won''t need anything with
    regard to that. However, to use `PropTypes` (we''ll get to that very soon), you''ll
    need the appropriate flow-typed package, which is easy to install:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow`已经*知道*关于`React`和CRA的一切，所以在这方面你不需要任何东西。然而，要使用`PropTypes`（我们很快就会讲到），你需要适当的flow-typed包，这很容易安装：'
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Reinstalling ESLint
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新安装ESLint
- en: 'Finally, our third tool will require a bit more work. For `ESLint`, we cannot
    use `package.json` either, and we need a `.eslintrc` file. But, even if you extract
    that part, you''ll find that the configuration doesn''t pay attention to your
    settings, and that''s because CRA has its own set of `ESLint` rules, which you
    cannot change! Unless, of course, you decide to eject the project and start doing
    configuration by yourself, which you''ll want to avoid for as long as possible. There''s
    a package, `react-app-rewired`, that lets you change the internal configurations
    without ejection. Start by installing a couple of required packages:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的第三个工具需要更多的工作。对于`ESLint`，我们也不能使用`package.json`，我们需要一个`.eslintrc`文件。但是，即使你提取了那部分，你会发现配置并没有关注你的设置，这是因为CRA有自己一套`ESLint`规则，你无法更改！除非当然，你决定弹出项目并开始自己进行配置，但你会尽量避免这样做。有一个包，`react-app-rewired`，它允许你在不弹出的情况下更改内部配置。首先安装一些必需的包：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As for rules themselves, you''ll want to have the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 至于规则本身，你会想要有以下内容：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now you''ll have to change a few scripts in `package.json`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要在`package.json`中更改一些脚本：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, create a `config-overrides.js` files, at the root of your project,
    at the same level of the `package.json` file. The  `/* global module */` comment
    is there to avoid an error that will pop up after `ESLint` gets to work, reporting
    that `module` isn''t defined:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在项目的根目录下创建一个`config-overrides.js`文件，与`package.json`文件处于同一级别。`/* global module
    */`的注释是为了避免在`ESLint`开始工作后出现一个错误，报告`module`未定义：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You''re all set! Your `.eslintrc` file should look as follows, with some additions
    and changes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好了！你的`.eslintrc`文件应该如下所示，其中包括一些添加和更改：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you are wondering why I left the line for `Node`, it's because `Storybook`
    (which we'll see near the end of this chapter) uses a `module` variable, which
    would otherwise be marked as undefined.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我留下了`Node`这一行，那是因为`Storybook`（我们将在本章末看到）使用了一个`module`变量，否则它将被标记为未定义。
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this case, there's not too much to explain. The normal configuration of the
    project already includes all of the tools we need, so we are just configuring
    a bit instead of just going with the standard.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有太多需要解释的。项目的正常配置已经包括了我们需要的所有工具，所以我们只是在进行一些配置，而不是按照标准进行操作。
- en: As for `ESLint`, when you now use `npm start`, the `ESLint` configuration will
    get *rewired* to work with your configuration instead of CRA's one. This means
    that all of your standard settings and checks will continue to run, and you'll
    apply the same quality checks for React than for other JS code—except, obviously,
    for the React-specific ones.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`ESLint`，当你现在使用`npm start`时，`ESLint`配置将被*重新配置*以适应你的配置，而不是CRA的配置。这意味着你所有的标准设置和检查将继续运行，你将为React应用相同的质量检查运行，除了显然的React特定的检查。
- en: You can read more about `react-app-rewired` at [https://github.com/timarney/react-app-rewired](https://github.com/timarney/react-app-rewired.).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/timarney/react-app-rewired](https://github.com/timarney/react-app-rewired)了解更多关于`react-app-rewired`的信息。
- en: Defining components
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义组件
- en: The key idea behind working with `React` is that everything – and I mean, *everything* – is
    a component. Your whole web application will be a component, itself made of other
    components, which will themselves have smaller components, and so on. Components
    generate HTML, which is shown onscreen. The data for the HTML comes from externally
    assigned *props* (*properties*) and internally maintained *state*. Whenever there
    is a change in props or state, React takes care of refreshing the HTML so that
    the view (what the user sees) is always up to date.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`React`的关键思想是，一切 - 我的意思是，*一切* - 都是一个组件。你整个的网络应用将是一个组件，它本身由其他组件组成，这些组件本身又有更小的组件，依此类推。组件生成HTML，显示在屏幕上。HTML的数据来自外部分配的*props*（属性）和内部维护的*state*。每当props或state发生变化时，React会负责刷新HTML，以便视图（用户所见的内容）始终保持最新。
- en: 'Let''s look at an example. Imagine that you want to create a screen that will
    let the user query data about regions of the world. How could you go about designing
    it? Check out the following screenshot for details:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。想象一下，你想创建一个屏幕，让用户查询世界各地区域的数据。你该如何设计？查看以下屏幕截图以获取详细信息：
- en: '![](img/bc5eb0a4-0eb1-462b-8b9f-ac1b15faee08.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc5eb0a4-0eb1-462b-8b9f-ac1b15faee08.png)'
- en: Whenever the user selects a country, we'll show several cards with information
    about its regions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户选择一个国家，我们将显示几张关于其地区的信息卡片。
- en: 'Note: I created this sketch at http://www.wireframes.com—but don''t blame the
    tool for my poor sketching ability!'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我在http://www.wireframes.com上创建了这个草图，但不要因为我糟糕的素描能力而责怪这个工具！
- en: 'Your whole view would be a component, but it''s fairly obvious that wouldn''t
    help with coding or testing. A good design principle is that *each component should
    be responsible for a single duty*, and if it needs to do more, decompose it into
    smaller components. In our case, we''d have the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你的整个视图将是一个组件，但显然这对编码或测试并不会有所帮助。一个很好的设计原则是*每个组件应负责单一职责*，如果它需要做更多的事情，就将其分解为更小的组件。在我们的例子中，我们将有以下内容：
- en: The whole table is a `RegionsInformationTable`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个表格是一个`RegionsInformationTable`。
- en: The part at the top can be the `CountryFilterBar`, with a dropdown for countries
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部的部分可以是`CountryFilterBar`，带有一个国家的下拉菜单
- en: At the bottom we have a `ResultsDataTable`, which shows a collection of `ExpandableCard` components,
    each with a title, a toggle, and space for more components. We could have designed
    a specific card for this situation, but having a generic card, whose components
    may be whatever we want, is more powerful.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底部我们有一个`ResultsDataTable`，显示了一系列`ExpandableCard`组件，每个组件都有一个标题，一个切换开关，以及更多组件的空间。我们本可以为这种情况设计一个特定的卡片，但是拥有一个通用的卡片，其组件可以是我们想要的任何东西，更加强大。
- en: 'A first rule involves events, such as clicks on elements, data being entered,
    and so on. They should be passed up until a component is able to fully process
    them: *events flow up*. For example, when the user clicks on the button, that
    component shouldn''t (and couldn''t) fully process it, at the very least because
    it couldn''t access the table. So, the event will be passed up (by means of callbacks)
    until some component is able to deal with it. You may have options: for example,
    the `CountryFilterBar` component could handle calling a service and getting the
    data, but then it would pass the results up to the `RegionsInformationTable`,
    so that it can pass it to the `ResultsDataTable` component, which will itself
    produce the necessary `ExpandableCard` elements. Alternatives would be passing
    the `CountryFilterBar` value up to the `RegionsInformationTable`, which would
    do the search on its own, or passing it even higher, to some component to do the
    search and push the data down as props to our big table.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则涉及事件，例如单击元素，输入数据等。它们应该一直传递到某个组件能够完全处理它们为止：*事件向上流动*。例如，当用户单击按钮时，该组件不应该（也不能）完全处理它，至少因为它无法访问表格。因此，事件将通过回调传递（通过回调）直到某个组件能够处理它。您可能有选择：例如，`CountryFilterBar`组件可以处理调用服务并获取数据，然后将结果传递给`RegionsInformationTable`，以便它可以将其传递给`ResultsDataTable`组件，后者将生成必要的`ExpandableCard`元素。另一种选择是将`CountryFilterBar`的值传递给`RegionsInformationTable`，后者将自行进行搜索，或者将其传递得更高，以便某个组件进行搜索并将数据作为props推送到我们的大表格。
- en: 'The preceding explanation helps us with a second decision. You should analyze
    your components hierarchy and decide where data (props or state) should be kept.
    A key rule is: if two (or more) components share data (or if one component produces
    data that other component needs). It should belong to a component higher up, which
    will pass it down as needed: *data flows down*. In our case, we already applied
    that rule when we decided that the regions data would be owned by the `CountryFilterBar`,
    which was then to be passed to the `RegionResults` table; each `ExpandableCard` would
    only work with the props it receives.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的解释帮助我们做出第二个决定。您应该分析组件层次结构，并决定数据（props或state）应该放在哪里。一个关键规则是：如果两个（或更多）组件共享数据（或者一个组件产生其他组件需要的数据），它应该属于更高级的组件，它将根据需要向下传递：*数据向下流动*。在我们的情况下，当我们决定区域数据将由`CountryFilterBar`拥有，然后传递给`RegionResults`表时，我们已经应用了该规则；每个`ExpandableCard`只能使用它接收到的props。
- en: Even if we don't know how to handle web service requests to get the necessary
    data just yet (or, for example, to initialize the countries dropdown), we can
    build a static version of our components and see how it works.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们还不知道如何处理Web服务请求以获取必要的数据（或者例如初始化国家下拉菜单），我们可以构建组件的静态版本并查看其工作原理。
- en: It's better to start with these static aspects of web design, and only afterwards
    deal with the dynamic aspects, such as reacting to events or getting data. Let's
    get to that code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最好从Web设计的这些静态方面开始，然后再处理动态方面，例如对事件的反应或获取数据。让我们开始编写代码。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We need to create several components, and that will allow us to find out how
    we can include components in other components, how to pass properties, how to
    define them, and more. Let's go component by component.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建几个组件，这将使我们能够找出如何在其他组件中包含组件，如何传递属性，如何定义它们等。让我们逐个组件地进行。
- en: Creating the application
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'To start a `React` application, all we need is a basic HTML page, and CRA already
    provides one in `public/index.html`. Stripped down to the basics (check the book
    source code for the full version), it''s something like the following, and the
    key part is the `<div>`, in which all of the `React` generated HTML code will
    be placed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个`React`应用程序，我们只需要一个基本的HTML页面，CRA已经在`public/index.html`中提供了一个。简化到基础部分（查看完整版本的书源代码），它大致如下，关键部分是`<div>`，其中将放置所有`React`生成的HTML代码：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The entry point to our application will be `index.js`, which (we''re dropping
    out some lines of code that are irrelevant here) boils down to the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的入口将是`index.js`，它（我们在这里省略了一些无关紧要的代码行）归结为以下代码：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Why do we need to define a `root` variable and `if`? The key is a `Flow` check:
    a `document.getElementById(...)` call may produce a web node, or may be null,
    and `Flow` reminds us to check for null before committing to work.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要定义一个`root`变量和`if`？关键是`Flow`检查：`document.getElementById(...)`调用可能会产生一个Web节点，也可能为空，并且`Flow`提醒我们在承诺工作之前检查空值。
- en: Now that we have our basic scaffolding, let's get to writing some actual `React`
    components!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本的脚手架，让我们开始编写一些实际的`React`组件！
- en: Creating the basic App component
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的App组件
- en: 'Let''s start with the `App.js` file; we''ll render a simple `RegionsInformationTable`.
    We are extending a `React` class called `PureComponent`; we''ll explain what this
    implies later. Your own components should have names starting with upper case
    to distinguish them from HTML names, which should go in lower case. Every component
    should have a `.render()` method that produces whatever HTML is needed; there
    are more methods you can use for this, as we''ll see:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`App.js`文件开始；我们将呈现一个简单的`RegionsInformationTable`。我们正在扩展一个名为`PureComponent`的`React`类；我们稍后会解释这意味着什么。您自己的组件名称应以大写字母开头，以区别于应该以小写字母开头的HTML名称。每个组件都应该有一个`.render()`方法，用于生成所需的HTML；还有更多方法可以用于此，我们将会看到：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only method that must be specified when defining a component is `.render()`.
    Components also have many other methods, including several *life cycle* ones,
    that we'll see later in the *Handling life cycle events* section, but all of them
    are optional.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义组件时必须指定的唯一方法是`.render()`。组件还有许多其他方法，包括几种*生命周期*方法，我们将在*处理生命周期事件*部分中看到，但它们都是可选的。
- en: 'You may be asking yourself: why go to the bother of creating an `<App>` component
    that doesn''t do anything but produce a `<RegionsInformationTable>` component?
    Why not use the latter directly? We''ll get to the reason why in the upcoming
    sections; we''ll want the `<App>` component to do more, such as defining routing,
    managing a store, and so on. So, even in this particular small example, it''s
    overkill – it''s a pattern we want to keep.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问自己：为什么要费事创建一个什么都不做，只是生成一个`<RegionsInformationTable>`组件的`<App>`组件？为什么不直接使用后者？我们将在接下来的部分中解释原因；我们希望`<App>`组件能做更多的事情，比如定义路由、管理存储等。因此，即使在这个特定的小例子中，这是多余的-这是我们想要保留的一种模式。
- en: You'll also want to notice that we wrote `React.PureComponent<{}>`, and this
    was to let `Flow` know that our component doesn't need either properties or state.
    In later sections we'll look at more examples that require better type definitions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要注意我们写了`React.PureComponent<{}>`，这是为了让`Flow`知道我们的组件既不需要属性也不需要状态。在后面的部分中，我们将看到更多需要更好类型定义的示例。
- en: Creating the RegionsInformationTable component
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`RegionsInformationTable`组件
- en: 'We can immediately see how the `RegionsInformationTable` component is rendered:
    it just depends on two more of the components we decided that we would create.
    Note that we are returning HTML code as if it were a valid JS value: this is JSX,
    and it provides a very simple way to intermingle JS code and HTML code. We''ll
    have a list of countries (much reduced!) that supposedly comes from a web service,
    and a list of regions (also reduced, with fake data) that would come from a different
    service, after the user has selected a country. This data is the *state* of the
    component; whenever any of those lists changes, React will re-render the component
    and everything it includes. We''ll look at that further in the *Handling State*
    section:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到`RegionsInformationTable`组件是如何渲染的：它只依赖于我们决定创建的另外两个组件。请注意，我们返回HTML代码，就好像它是一个有效的JS值：这就是JSX，它提供了一种非常简单的方式来交织JS代码和HTML代码。我们将有一个国家列表（大大减少！）据说来自于一个Web服务，以及一个地区列表（也减少了，带有虚假数据），它将在用户选择国家后来自不同的服务。这些数据是组件的*状态*；每当这些列表中的任何一个发生变化时，React都会重新渲染组件及其包含的所有内容。我们将在*处理状态*部分进一步讨论这一点：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This component receives no props, but works with state, so for Flow's sake,
    we had to write `React.PureComponent<{},{countries:..., regions:...}>`, providing
    data types for the state elements. You could also define these data types in a
    separate file (see [https://flow.org/en/docs/types/modules/](https://flow.org/en/docs/types/modules/)
    for more on this), but we'll let it be.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件不接收任何属性，但使用状态，因此为了`Flow`的缘故，我们不得不写`React.PureComponent<{},{countries:...,
    regions:...}>`，为状态元素提供数据类型。您还可以在单独的文件中定义这些数据类型（有关此内容的更多信息，请参见[https://flow.org/en/docs/types/modules/](https://flow.org/en/docs/types/modules/)），但我们就此打住。
- en: What about the list of countries? The `CountryFilterBar` should show some countries,
    so the parent will provide the list as a prop; let's see how it will receive and
    use that list. We'll also provide a callback, `onSelect`, that the child component
    will use to inform you whenever the user selects a country. Finally, we'll pass
    the list of (fake, hardcoded) regions to the `ResultsDataTable`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于国家列表呢？`CountryFilterBar`应该显示一些国家，所以父组件将作为属性提供列表；让我们看看它将如何接收和使用该列表。我们还将提供一个回调函数`onSelect`，子组件将使用它来在用户选择国家时通知您。最后，我们将把（虚假的，硬编码的）地区列表传递给`ResultsDataTable`。
- en: 'A noteworthy comment: props are passed using a `name=...` syntax, as standard
    with HTML elements; your `React` elements are used in the same fashion as common,
    standard HTML ones. The only difference here is that you use braces, in template
    fashion, to include any expression.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是：属性是使用`name=...`语法传递的，与HTML元素的标准用法相同；您的`React`元素与常见的标准HTML元素的用法相同。这里唯一的区别是您使用大括号，以模板方式包含任何表达式。
- en: By the way, note that our list of regions starts out empty; the results table
    will have to deal with that. When the user selects a country, the `.update()`
    method will run and load some regions by using the `.setState()` method, which
    we'll see in the following section. Later in this book, we'll also see how to
    use a web service to get that data, but for the time being, a fixed result will
    have to do.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，注意我们的地区列表起初是空的；结果表将不得不处理这一点。当用户选择一个国家时，`.update()`方法将运行，并使用`.setState()`方法加载一些地区，我们将在下一节中看到。在本书的后面，我们还将看到如何使用Web服务获取这些数据，但目前，固定的结果将不得不使用。
- en: Creating the CountryFilterBar component
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`CountryFilterBar`组件
- en: 'The next component we need is more complex: it receives a pair of props, and
    that starts by providing `PropTypes` definitions for them:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个组件更复杂：它接收一对属性，并且首先提供了这些属性的`PropTypes`定义：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is our first component that receives props. We''ll have to provide a definition
    for `Flow`, which is easy: the component will receive `list`, an array of objects,
    and `onSelect`, a function with a single string parameter, that doesn''t return
    anything.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个接收属性的组件。我们将为`Flow`提供一个定义，很简单：组件将接收`list`，一个对象数组，和`onSelect`，一个带有单个字符串参数的函数，不返回任何内容。
- en: '`React` also lets you define a runtime check for parameters. We define a `propTypes`
    class property, with an element for each actual prop that our component will receive,
    and another `defaultProps` property, for default values should actual ones not
    be provided. Defining the data types is also needed (for example, `onSelect` is
    a function) if they are required or optional (both are required, in this case).
    In development (not in production), whenever you pass props to an object, they
    will be checked against their definitions and a warning will be produced if there
    is some mismatch; this is a good debugging technique.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`React`还允许您为参数定义运行时检查。我们定义了一个`propTypes`类属性，其中包含我们的组件将接收的每个实际属性的元素，以及另一个`defaultProps`属性，用于在未提供实际值时提供默认值。如果需要定义数据类型（例如，`onSelect`是一个函数），以及它们是必需的还是可选的（在这种情况下都是必需的）。在开发中（而不是在生产中），每当您将属性传递给对象时，它们将根据其定义进行检查，如果存在某种不匹配，将产生警告；这是一种很好的调试技术。'
- en: Why use both `Flow` and `PropTypes` if it seems that both do the same job? Basically,
    `Flow` is a static checker, while `PropTypes` is a dynamic, runtime checker. If
    you use `Flow` everywhere throughout your application, theoretically, you could
    get by without using `PropTypes`—but since this package, in testing, will catch
    anything you missed, it's an extra "safety net" for your code. I do agree that
    writing two sets of data types is a bother, though.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要同时使用`Flow`和`PropTypes`，如果它们似乎都是做同样的工作？基本上，`Flow`是一个静态检查器，而`PropTypes`是一个动态的运行时检查器。如果您在整个应用程序中都使用`Flow`，理论上，您可以不使用`PropTypes`
    - 但由于这个包在测试中会捕捉到您忽略的任何内容，它是代码的额外“安全网”。我同意写两套数据类型确实很麻烦。
- en: 'The valid types for this are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有效的类型如下：
- en: '`any`, if any type is acceptable – this is not a good practice'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`，如果任何类型都可以接受 - 这不是一个好的做法'
- en: '`array`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`'
- en: '`arrayOf(someType)`, to specify the values of the array elements'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrayOf(someType)`，指定数组元素的值'
- en: '`bool`, for Booleans'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`，用于布尔值'
- en: '`element`, for a React element'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element`，用于React元素'
- en: '`func`, for functions'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`，用于函数'
- en: '`instanceOf(SomeClass)`, for an object that must be an instance of a given
    class'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instanceOf(SomeClass)`，用于必须是给定类的实例的对象'
- en: '`node`, for anything that can be rendered as HTML, such as numbers or strings'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`，对于任何可以呈现为HTML的东西，比如数字或字符串'
- en: '`number`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`'
- en: '`object`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object`'
- en: '`objectOf(SomeType)`, to specify an object with property values of a given
    type'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectOf(SomeType)`，指定具有给定类型的属性值的对象'
- en: '`oneOf([...an array of values...])`, to verify that a prop is limited to some
    values'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oneOf([...值数组...])`，验证属性是否限制在某些值上'
- en: '`oneOfType([...an array of types...])`, to specify that a prop will be one
    of a list of types'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oneOfType([...类型数组...])`，指定一个属性将是类型列表中的一个'
- en: '`shape({...an object with types...})`, to completely define an object, including
    keys and value types'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape({...具有类型的对象...})`，完全定义一个对象，包括键和值类型'
- en: '`string`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`symbol`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol`'
- en: You can go even further and define, for example, specific functions for type
    validation. For a complete explanation of all of the possibilities of `PropTypes`,
    read [https://reactjs.org/docs/typechecking-with-proptypes.html](https://reactjs.org/docs/typechecking-with-proptypes.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以进一步定义，例如，用于类型验证的特定函数。有关`PropTypes`的所有可能性的完整解释，请阅读[https://reactjs.org/docs/typechecking-with-proptypes.html](https://reactjs.org/docs/typechecking-with-proptypes.html)。
- en: 'Now, how would we generate the HTML for the filter? We need several `<option>`
    elements, and we can apply `.map()` to `this.props.list` (properties are accessed
    through `this.props`) as follows. Also note how we use the `onChange` callback
    to inform the parent component whenever a different country is selected:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何为过滤器生成HTML呢？我们需要几个`<option>`元素，并且我们可以将`.map()`应用于`this.props.list`（通过`this.props`访问属性），如下所示。还要注意我们如何使用`onChange`回调来在选择不同的国家时通知父组件：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The input properties (`this.props`) should be considered read-only, and never
    modified. On the other hand, the component's state (`this.state`) is read-write
    and can be modified, though not directly but rather through `this.setState()`,
    as we'll see.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输入属性（`this.props`）应被视为只读，永远不要修改。另一方面，组件的状态（`this.state`）是可读写的，可以被修改，尽管不是直接修改，而是通过`this.setState()`，我们将看到。
- en: A special explanation is needed for the `key=` attribute. Whenever you define
    a list (with `<option>` or `<li>`, for example) and React needs to re-render it,
    the key attribute is used to recognize already available elements and avoid regenerating
    them, but rather reuse them. Keep in mind that the `CountryFilterBar` component
    will be called, over time, with different lists of countries to render, so React
    will optimize its performance by avoiding the creation of already existing list
    elements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`key=`属性需要特别解释。每当您定义一个列表（例如`<option>`或`<li>`）并且React需要重新呈现它时，`key`属性用于识别已经可用的元素并避免重新生成它们，而是重复使用它们。请记住，`CountryFilterBar`组件将随着时间的推移以不同的国家列表呈现，因此React将通过避免创建已经存在的列表元素来优化其性能。'
- en: Creating the ResultsDataTable component
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ResultsDataTable组件
- en: 'Building the results table is easy, and requires similar work to what we did
    with the countries selector. We only have to check the special case when we haven''t
    got any regions to show:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 构建结果表格很容易，需要的工作与我们在国家选择器中所做的类似。我们只需要检查特殊情况，即当我们没有任何地区要显示时：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A side comment: `React` allows us to define props as optional (meaning that
    no `isRequired` is included when defining `PropTypes`) and to provide default
    values instead. In this case, if results could be *not* provided, you would have
    written the following code, using `defaultProps` to provide the necessary default
    values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个附带的评论：`React`允许我们将props定义为可选的（意味着在定义`PropTypes`时没有包含`isRequired`），并提供默认值。在这种情况下，如果结果可能*不*被提供，您将编写以下代码，使用`defaultProps`来提供必要的默认值：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In terms of `Flow` and `PropTypes`, the definition is very much similar to the
    previous ones. The interesting part is using `.map()` to process all of the received
    objects, creating an `ExpandableCard` for each; this is a very common pattern
    with React. So, all we need now to finish our application is to provide an expandable
    card, so let's get to that.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Flow`和`PropTypes`方面，定义与之前的非常相似。有趣的部分是使用`.map()`来处理所有接收到的对象，为每个创建一个`ExpandableCard`；这是React中非常常见的模式。因此，我们现在需要完成我们的应用程序的是提供一个可展开的卡片，所以让我们开始吧。
- en: Creating the ExpandableCard component
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可展开卡组件
- en: 'For starters, let''s forget about expanding a card—even though that makes the
    name of the component a misnomer! Here, we''ll just make a component that shows
    a few strings. In the *Composing Components* section, we''ll see some interesting
    ways of achieving our original goal:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们忘记扩展卡片 - 即使这使得组件的名称不准确！在这里，我们只是制作一个显示几个字符串的组件。在*组合组件*部分，我们将看到一些实现我们最初目标的有趣方法：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Everything is ready; let's see how and why it functions!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪；让我们看看它是如何以及为什么运作的！
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you start the application with `npm start`, you get our basic screen,
    showing the dropbox with the countries, and no cards, as shown in the following
    screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用`npm start`启动应用程序时，你会得到我们的基本屏幕，显示带有国家的下拉框，以及没有卡片，如下面的截图所示：
- en: '![](img/9d19b73b-35af-41bf-8382-373c442edc67.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/9d19b73b-35af-41bf-8382-373c442edc67.png)
- en: Our basic application, showing fixed, non-varying cards
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本应用程序，显示固定的、不变的卡片
- en: 'Then, suppose you select a country; what will happen? Let''s follow that, step
    by step:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，假设你选择了一个国家；会发生什么？让我们一步一步地跟踪一下：
- en: In the `CountryFilterBar`, the `onChange` event will fire and will execute a
    callback (`this.props.onSelect()`), providing it with the selected country code.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CountryFilterBar`中，`onChange`事件将触发并执行一个回调(`this.props.onSelect()`)，并提供所选国家的代码。
- en: In the `RegionsInformationTable`, the callback that was provided to the `CountryFilterBar`
    is `this.update()`, so that method will execute.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RegionsInformationTable`中，提供给`CountryFilterBar`的回调是`this.update()`，因此该方法将被执行。
- en: The update method will log the country (just for reference) and use `this.setState`
    (see the next section) to load some regions in the `RegionsInformationTable` state.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新方法将记录国家(仅供参考)并使用`this.setState` (见下一节)在`RegionsInformationTable`状态中加载一些区域。
- en: The change in state will cause `React` to re-render the component.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态的改变将导致`React`重新渲染组件。
- en: The `CountryFilterBar` won't need re-rendering because neither its props nor
    its state changed.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CountryFilterBar`不需要重新渲染，因为它的props和状态都没有改变。'
- en: The `ResultsDataTable`, on the other hand, will be re-rendered because its props
    will change, receiving a new list of regions.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，`ResultsDataTable`将重新渲染，因为它的props将改变，接收一个新的区域列表。
- en: 'So, after all this is said and done, the new view will be as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，说了这么多之后，新的视图将如下所示：
- en: '![](img/f5f0f845-1642-40cd-8994-40f552af1691.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f5f0f845-1642-40cd-8994-40f552af1691.png)
- en: The updated view, after React handles all the necessary re-rendering
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: React 处理所有必要的重新渲染后，更新的视图
- en: 'This is basically how your application will work: events are captured and handled,
    state is changed, props are passed, and `React` takes care of re-rendering whatever
    needs to be re-rendered.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是你的应用程序将如何工作的：事件被捕获和处理，状态被改变，props被传递，`React`负责重新渲染需要重新渲染的部分。
- en: There's more...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s go back to the `CountryFilterBar` component. We used the most recent
    JS ways to define it, but in many articles and books, you may find an older style
    that you should be aware of, if only to better understand the variant:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`CountryFilterBar`组件。我们使用了最近的JS方式来定义它，但在许多文章和书籍中，你可能会发现一个你应该了解的旧风格，这样你就可以更好地理解这个变体：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can sum up the differences as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结如下的差异：
- en: The `propTypes` and `defaultProps` values are defined separately, by directly
    modifying the class
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propTypes`和`defaultProps`的值是通过直接修改类来分别定义的'
- en: We bind `this.onSelect` in the constructor, so when this method is called, the
    value of `this` will be the `window` object, not what we need.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在构造函数中绑定了`this.onSelect`，所以当调用这个方法时，`this`的值将是`window`对象，而不是我们需要的。
- en: With modern JS features, this is not needed, but be aware that in older JS code,
    you are likely to find these patterns.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代JS功能，这是不需要的，但要注意，在旧的JS代码中，你可能会发现这些模式。
- en: Handling state
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理状态
- en: 'In the previous section, we saw the usage of *state* for the regions; let''s
    delve a bit deeper into that. The concept of state is very similar to props, but
    with crucial differences: props are assigned from the outside and are read-only,
    and state is handled privately, and read-write. If a component needs to keep some
    information, which it can use to render itself, then using state is the solution.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了*state*用于区域的用法；让我们深入了解一下。状态的概念与props非常相似，但有关键的区别：props是从外部分配的，是只读的，而状态是私下处理的，是可读写的。如果一个组件需要保留一些信息，它可以用来渲染自己，那么使用状态就是解决方案。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Defining state is done by using class fields, a fairly new feature of JS, that's
    enabled via `Babel` since it isn't fully official yet. (See [https://github.com/tc39/proposal-class-fields](https://github.com/tc39/proposal-class-fields)
    for the proposal, which is at Stage 3, meaning that it's one step away from being
    officially adopted.) With older JS versions, you would have had to create `this.state`
    in the class constructor, but this syntax is clearer. Let's remember what the
    code looked like, and let's drop the Flow definition.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类字段来定义状态，这是JS的一个相当新的功能，通过`Babel`启用，因为它还没有完全正式化。(请参阅[https://github.com/tc39/proposal-class-fields](https://github.com/tc39/proposal-class-fields)查看提案，该提案处于第3阶段，意味着它离正式采纳只有一步之遥。)在旧的JS版本中，你必须在类构造函数中创建`this.state`，但这种语法更清晰。让我们记住代码是什么样子的，然后放弃Flow定义。
- en: 'First, let''s modify the `RegionsInformationTable` component:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改`RegionsInformationTable`组件：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Second, let''s see what happens when a country changes. Rendering for an object
    can depend on both its props (which it cannot change, as we said) and its state
    (which it can change), but there is an important restriction on updating state.
    You cannot simply assign a new value to the component''s state because it won''t
    be detected by `React`, and then no rendering will be done. Instead, you must
    use the `.setState()` method. This method can be called in different ways, but
    *functional* `.setState()` is the safest way to do this. With this, you must pass
    a function that will receive both state and props and return whatever parts of
    the state need to be updated. In our earlier code, we would have written the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们看看当国家改变时会发生什么。对象的渲染可以取决于它的props(如我们所说，它不能改变)和它的状态(它可以改变)，但在更新状态时有一个重要的限制。你不能简单地给组件的状态赋一个新值，因为`React`不会检测到它，然后不会进行任何渲染。相反，你必须使用`.setState()`方法。这个方法可以以不同的方式调用，但*functional*`.setState()`是最安全的方法。通过这种方式，你必须传递一个函数，该函数将接收状态和props，并返回需要更新的状态的任何部分。在我们之前的代码中，我们将写下以下内容：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you check, you'll see that we didn't include the `state` and `props` parameters
    in the actual code, but that was in order to satisfy ESLint's rule about no unused
    arguments in functions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查一下，你会发现我们在实际代码中没有包括`state`和`props`参数，但这是为了满足ESLint关于函数中没有未使用的参数的规则。
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Why did we need to pass a function? There''s a key point to understanding this:
    *state updates are asynchronous*. Whenever you call `.setState()`, `React` will
    update the component''s state and start its reconciliation process to update the
    UI view. But what happens if there is more than one `.setState()` call? There
    lies the problem.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要传递一个函数？理解这一点有一个关键：*状态更新是异步的*。每当你调用`.setState()`时，`React`将更新组件的状态并启动协调过程以更新UI视图。但是如果有多个`.setState()`调用会发生什么呢？问题就在这里。
- en: '`React` is allowed to *queue* many such calls together into a single update
    to achieve better performance, and that has an important effect: state may have
    changed before `.setState()` is executed! (Even so, if batching is done, updates
    will be done in the order they are called.) So, you provide a function and `React`
    will call it with the appropriately updated `state` parameter. Don''t do anything
    depending on `this.state` because it may be wrong; always work with the `state`
    parameter.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`React`允许*排队*许多这样的调用一起进行单个更新，以实现更好的性能，这具有重要的影响：在执行`.setState()`之前，状态可能已经发生了变化！（即使这样，如果进行批处理，更新将按照调用它们的顺序进行。）因此，你提供一个函数，`React`将使用适当更新的`state`参数调用它。不要做任何依赖于`this.state`的事情，因为它可能是错误的；始终使用`state`参数进行操作。'
- en: 'There is a shortcut that you should know, in any case. If (and only if) your
    update does not depend in any way on the state or props values, you can use an
    alternative call without requiring a function. For example, our update could have
    been simply written as follows, and `this.state.regions` would be changed, leaving
    the rest of the state unchanged; the key is that the new values for the `regions`
    attribute are not dependent in any way on state or props:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你应该知道有一个快捷方式。如果（仅当）你的更新不以任何方式依赖于状态或props值，你可以使用另一种调用而不需要一个函数。例如，我们的更新可以简单地写成如下形式，`this.state.regions`将被改变，而其余状态将保持不变；关键是`regions`属性的新值不以任何方式依赖于状态或props：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Why would this work? Because in this case, even if the state had changed before,
    your update would still be the same. Be careful, though, and use this syntax only
    when your update is totally independent of state and props; otherwise, use the
    functional approach we showed first.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样会起作用？因为在这种情况下，即使状态在之前已经改变，你的更新仍然是相同的。但要小心，只有当你的更新完全独立于状态和props时，才使用这种语法；否则，使用我们首先展示的函数式方法。
- en: Once you realize that the state updates are functions, you can move that logic
    out of components, for separate, independent coding and testing, this will be
    quite similar to things we'll be doing with `Redux` in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding your Application*. You would write `this.setState(someFunction)` and `someFunction()` would
    be defined separately; your code will have become more declarative in style.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你意识到状态更新是函数，你就可以将逻辑从组件中移出，进行独立的编码和测试，这将与我们在[第8章](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml)中使用`Redux`进行的操作非常相似，*扩展你的应用程序*。你会写`this.setState(someFunction)`，然后`someFunction()`会被单独定义；你的代码将变得更加声明式。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'With what we have done here, you may realize that you have all you could need
    to handle state, for any application size – and you would be right! You could
    set up the general state for your whole application in the `App` component (remember
    we mentioned that `App` would have more responsibilities?) and you would be able
    to do the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们在这里所做的一切，你可能会意识到你拥有处理任何应用程序规模的状态所需的一切-你是对的！你可以在`App`组件中设置整个应用程序的一般状态（记得我们提到过`App`将有更多的责任？），并且你将能够进行以下操作：
- en: Pass it down to components by using props
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用props将其传递给组件
- en: Update it in answer to events that the components send
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据组件发送的事件进行更新
- en: 'This is a perfectly valid solution, and `App.state` could have all sorts of
    data for the whole page. `App` could handle, for example, calling a web service
    to get the regions for a given country, storing the results in its state, and
    passing it to our components so that they can be rendered. In our hardcoded version, `RegionsInformationTable`
    had the list of countries (where did it get it from?) and handled the requests
    for regions (by returning hardcoded data). In reality, as we''ll see later in
    this book, getting this sort of information from a server would be handled differently,
    and at a higher level: `RegionsInformationTable` would handle rendering the table
    and leave data gathering to another part of your solution.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全有效的解决方案，`App.state`可以包含整个页面的各种数据。例如，`App`可以处理调用Web服务以获取给定国家的地区，将结果存储在其状态中，并将其传递给我们的组件以便它们进行渲染。在我们的硬编码版本中，`RegionsInformationTable`拥有国家列表（它是从哪里获取的？）并处理地区的请求（通过返回硬编码数据）。实际上，正如我们将在本书后面看到的那样，从服务器获取这种信息将以不同的方式处理，并且在更高的级别：`RegionsInformationTable`将处理渲染表格，并将数据收集留给解决方案的另一部分。
- en: Even if you passed web services handling to `App`, as your application grows
    in size, this sort of solution may become unwieldy because of the number of data
    fields you may have to keep track of. We'll find a better scalable solution for
    this in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml), *Expanding your
    Application*, by adding a specific package to handle state updates in a more orderly,
    structured fashion.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你将Web服务处理传递给`App`，随着应用程序规模的增长，由于你可能需要跟踪的数据字段数量，这种解决方案可能变得难以控制。在[第8章](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml)中，我们将为此找到更好的可扩展解决方案，通过添加一个特定的包来更有序、结构化地处理状态更新。
- en: Composing components
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合组件
- en: Let's go back to the `ExpandableCard`, which we didn't quite finish before.
    We could certainly do a regions-specific card, but it seems that the general concept
    of a card that can be expanded or condensed is useful enough that we could prefer
    a more general solution. `React` allows us to do that via *composition*, as we'll
    see in this section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`ExpandableCard`，之前我们没有完全完成。我们当然可以做一个特定于地区的卡片，但似乎可扩展或压缩的卡片的一般概念足够有用，以至于我们可能更喜欢一个更一般的解决方案。`React`允许我们通过*组合*来做到这一点，我们将在本节中看到。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The component we want to create could have any kind of content. (The same idea
    would apply to generic dialog boxes, header sections, or sidebars, by the way.)
    Instead of creating a base class and using inheritance to create multiple derived
    classes, React allows you to pass a special children prop (`this.props.children`)
    so that you can pass children elements to the original component.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建的组件可以包含任何类型的内容。（顺便说一句，相同的想法也适用于通用对话框、标题部分或侧边栏。）React允许您传递一个特殊的children属性（`this.props.children`），以便您可以将子元素传递给原始组件。
- en: 'First, let''s see how our `ResultsDataTable` code would change. First, the
    `render()` method would have to change:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的`ResultsDataTable`代码会如何改变。首先，`render()`方法将需要更改：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Second, let''s define the component we are using. We are inserting an `ExpandableCard`
    component with a key and a title, and within it we are including a couple of `<div>` elements
    with data for cities and population. This content will be available as `this.prop.children`,
    as we''ll see later. We also added a `title` prop and an internal state, `open`,
    which will be toggled when you expand or condense a card via the `.toggle()` method.
    First, let''s look at the props, state, and types:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们定义我们正在使用的组件。我们正在插入一个带有键和标题的`ExpandableCard`组件，并在其中包含一对`<div>`元素，其中包含城市和人口的数据。这些内容将作为`this.prop.children`可用，我们稍后会看到。我们还添加了一个`title`prop和一个内部状态`open`，当您通过`.toggle()`方法展开或压缩卡片时，它将被切换。首先，让我们看看props、state和类型：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For `React`, `Flow` predefines a lot of data types. (You can read more about
    this at [https://github.com/facebook/flow/blob/master/website/en/docs/react/types.md](https://github.com/facebook/flow/blob/master/website/en/docs/react/types.md).)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`React`，`Flow`预定义了许多数据类型。（您可以在[https://github.com/facebook/flow/blob/master/website/en/docs/react/types.md](https://github.com/facebook/flow/blob/master/website/en/docs/react/types.md)上了解更多信息。）
- en: 'The few more usual ones you are likely to require are as follows, but read
    the aforementioned web page for a full list:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要的一些更常见的类型如下，但是请阅读上述网页以获取完整的列表：
- en: '| **Data Types ** | ** Explanations ** |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **解释** |'
- en: '| `React.ChildrenArray<T>` | An array of children, of type `<T>`, just as shown
    in the previous code. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `React.ChildrenArray<T>` | 一个子元素数组，类型为`<T>`，就像前面的代码中所示的那样。|'
- en: '| `React.Element<typeof Component>` | A node of a specific type: for example,
    `React.Element<"div">` is an element that renders a `<div>`. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `React.Element<typeof Component>` | 特定类型的节点：例如，`React.Element<"div">`是一个渲染`<div>`的元素。|'
- en: '| `React.Key` | The type of a prop that is used as key: essentially, either
    a number or a string. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `React.Key` | 用作键的prop的类型：基本上是数字或字符串。|'
- en: '| `React.Node` | Any node that can be rendered, including React elements, numbers,
    strings, Booleans, undefined, null, or arrays of those types. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `React.Node` | 可以呈现的任何节点，包括React元素、数字、字符串、布尔值、未定义、null或这些类型的数组。|'
- en: 'Finally, let''s get to the functioning part of the component. Let''s see how
    we show the children of the component when the state of the component shows that
    it should be expanded. Also of interest is looking at how clicking on the card
    calls the `.toggle()` method to change the component''s `state.open` value:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来到组件的功能部分。让我们看看当组件的状态显示应该展开时，如何显示组件的子元素。还有一个有趣的地方是看看点击卡片如何调用`.toggle()`方法来改变组件的`state.open`值：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're done! Let's see how this all comes together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！让我们看看这一切是如何结合在一起的。
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When this object is rendered for the first time, `this.state.open` is false,
    so the `.render()` method will just produce the title of the card, plus a triangle
    pointing down, to suggest that the card may be expanded by clicking on it. When
    the user clicks on the triangle, `this.setState()` is called with a function that
    will take the current value of `this.state.open`, and toggle it. `React` will
    decide whether the object needs to be re-rendered (because of the change in state)
    and this time, since `this.state.open` will be true, the expanded, complete version
    of the card will be rendered. In particular, the triangle will be shown pointing
    up, so the user will understand that the card will be condensed if they click
    there. Check out the following screenshot for a trial run, showing some expanded
    and condensed cards:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当此对象首次呈现时，`this.state.open`为false，因此`.render()`方法将只产生卡片的标题，以及一个指向下方的三角形，表明可以通过点击展开卡片。当用户点击三角形时，将调用`this.setState()`，并传递一个函数，该函数将获取`this.state.open`的当前值，并切换它。`React`将决定对象是否需要重新呈现（因为状态的改变），这一次，由于`this.state.open`将为true，将呈现卡片的扩展完整版本。特别是，三角形将指向上方，因此用户将了解如果他们在那里点击，卡片将被压缩。查看以下截图，进行试运行，显示一些展开和压缩的卡片：
- en: '![](img/6ebbbdd8-b518-4165-bb85-4c37b287df5a.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ebbbdd8-b518-4165-bb85-4c37b287df5a.png)'
- en: A run of our application; some cards are expanded and show their children
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的运行；一些卡片已展开并显示其子元素
- en: What's going to be the content of the expanded card? This is where `this.props.children`
    comes in. Whatever elements were provided as props will be rendered here. In this
    way, you can reuse your `ExpandableCard` with any type of content. The main characteristics
    (the title, the triangle to expand/condense the card) will always be there, but
    thanks to the use of composition, you'll be able to have as many versions of expandable
    cards as you may need.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展卡的内容将是什么？这就是`this.props.children`发挥作用的地方。任何作为props提供的元素都将在这里呈现。通过这种方式，你可以重用你的`ExpandableCard`来呈现任何类型的内容。主要特征（标题，展开/收缩卡的三角形）将始终存在，但由于使用了组合，你可以拥有任何你需要的可展开卡的版本。
- en: Handling life cycle events
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理生命周期事件
- en: Components don't only have a `.render()` method – they can also implement many
    more *life cycle* events that can help you in specific situations. In this section,
    let's go over all of the available methods and provide ideas about when you will
    use them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 组件不仅有一个`.render()`方法 - 它们还可以实现许多更多的*生命周期*事件，可以帮助你在特定情况下。在这一节中，让我们介绍所有可用的方法，并提供关于何时使用它们的想法。
- en: For a full description of all the available methods, go to [https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)
    – but pay careful attention to some deprecated, legacy methods that should be
    avoided, and also read about the conditions and parameters for each method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有可用方法的完整描述，请访问[https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)
    - 但要特别注意一些已弃用的、遗留的方法，应该避免使用，并且阅读每个方法的条件和参数。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the life of a component, in order from the time a component
    is created and placed into the DOM, during its life when it may be updated, up
    to the moment the component is removed from the DOM. We are going to hit only
    the main methods, and even so it''s likely that you won''t get to use all of them:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序来看一下组件的生命周期，从组件被创建并放入DOM中开始，到它的生命周期中可能被更新的时候，直到组件从DOM中被移除的时刻。我们只会介绍主要的方法，即使这样，你可能也不会用到所有的方法：
- en: '`constructor()`: This method is called before the component is mounted for
    basic setup and initialization. This method is used for all kinds of initialization.
    The only key rule is that you should always start by calling `super(props)` before
    doing anything else, so `this.props` will be created and accessible.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor()`: 这个方法在组件被挂载之前被调用，用于基本设置和初始化。这个方法用于各种初始化。唯一的关键规则是在做任何其他事情之前，你应该始终先调用`super(props)`，这样`this.props`就会被创建并且可以访问。'
- en: '`componentDidMount()`: This method is called after the component is mounted.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount()`: 这个方法在组件被挂载后被调用。'
- en: '`shouldComponentUpdate(nextProps, nextState)`: This method is used by React
    to decide whether a component needs to be re-rendered or not.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate(nextProps, nextState)`: 这个方法被React用来决定一个组件是否需要重新渲染。'
- en: '`render()`: This (mandatory) method produces HTML elements, ideally based only
    on `this.props` and `this.state`. If the function returns a `boolean` or `null` value,
    nothing will be rendered. The method should be pure, not attempting to modify
    the component''s state (which can lead to nasty loops) or to use anything but
    state and props.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render()`: 这个（强制性的）方法产生HTML元素，理想情况下只基于`this.props`和`this.state`。如果函数返回一个`boolean`或`null`值，将不会呈现任何内容。这个方法应该是纯的，不尝试修改组件的状态（这可能导致恶性循环）或使用除了状态和props之外的任何东西。'
- en: '`forceUpdate()`: This method is not really a life cycle one, and you can call
    it whenever you want to force a re-rendering to be done.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forceUpdate()`: 这个方法不是真正的生命周期方法，你可以在任何时候调用它来强制重新渲染。'
- en: '`componentDidUpdate(previousProps, previousState)`: This method is called after
    a component has been updated.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate(previousProps, previousState)`: 这个方法在组件更新后被调用。'
- en: '`componentWillUnmount()`: This method is called just before a component is
    going to be unmounted.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount()`: 这个方法在组件将要被卸载之前被调用。'
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We went over the methods in the previous section. Now let''s go over some ideas
    about getting the less obvious of them to work:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了上一节中的方法。现在让我们来看一些关于让不太明显的方法工作的想法：
- en: '| **Methods ** | **Explanations** |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| **方法 ** | **解释** |'
- en: '| `componentDidMount()` | This is the usual place to start some action to get
    data from a web service. A usual trick for that is to have a state property like
    `this.state.loading` that you initialize to true when you ask for the data and
    reset to false after the data comes in. You can then make the `.render()` method
    produce different outputs, possibly a loading icon, until the data comes, and
    real data afterwards. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `componentDidMount()` | 这是开始从网络服务获取数据的常规位置。一个常见的技巧是有一个状态属性，比如`this.state.loading`，当你请求数据时将其初始化为true，并在数据到来后重置为false。然后可以让`.render()`方法产生不同的输出，可能是加载图标，直到数据到来，然后是真实的数据。
    |'
- en: '| `shouldComponentUpdate(...)` | This method works as a performance optimization,
    allowing React to skip unnecessary updates. With `React.PureComponent`, this is
    implemented by a comparison between the current state and the next state, and
    the current props and the next props. For normal `React.Components` this method
    always returns `true`, forcing re-rendering. If your component is rendered based
    on anything extra (such as other than state and props), you should use a `Component`
    instead of a `PureComponent`. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `shouldComponentUpdate(...)` | 这个方法作为性能优化，允许React跳过不必要的更新。对于`React.PureComponent`，这是通过比较当前状态和下一个状态，以及当前props和下一个props来实现的。对于普通的`React.Components`，这个方法总是返回`true`，强制重新渲染。如果你的组件是基于任何额外的东西（比如除了状态和props之外的其他东西）进行渲染，你应该使用`Component`而不是`PureComponent`。
    |'
- en: '| `componentDidUpdate(...)` | You could use this method to do some animation,
    or to get data from a web service—but in the latter case, you might want to compare
    the current state and props with the previous values, because if there were no
    changes, the request may not be needed, or it might have already been done. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `componentDidUpdate(...)` | 您可以使用此方法执行一些动画，或从Web服务获取数据，但在后一种情况下，您可能希望将当前状态和props与先前的值进行比较，因为如果没有更改，则可能不需要请求，或者可能已经完成了。
    |'
- en: '| `componentWillUnmount()` | This is the usual place to do some cleanup tasks,
    like disabling timers or removing listeners, for example. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `componentWillUnmount()` | 这是通常执行一些清理任务的地方，比如禁用定时器或删除侦听器。 |'
- en: Simplifying component development with Storybook
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Storybook简化组件开发
- en: 'When you are developing components, there is a basic, important question: how
    can you try them out? Of course, you could include them somewhere, in any page,
    but then whenever you want to see how they work, you must follow the full path
    through your application so that you can get to actually see the component.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发组件时，有一个基本而重要的问题：如何尝试它们？当然，您可以在任何页面的任何地方包含它们，但是每当您想要查看它们的工作方式时，您必须按照应用程序的完整路径，以便您可以实际看到组件。
- en: '`Storybook` is a UI development environment that lets you visualize your components
    in isolation, outside of your application, even making changes to them in an interactive
    way until you get them exactly right!'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Storybook`是一个UI开发环境，可以让您在应用程序之外独立地可视化您的组件，甚至以交互方式对它们进行更改，直到您完全正确为止！'
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, start by installing `Storybook` itself; we are going to use this version
    for `React`, but the tool can also be used with `Angular` and `Vue`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装`Storybook`本身；我们将使用这个版本的`React`，但这个工具也可以与`Angular`和`Vue`一起使用：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then add a couple of scripts to `package.json`: one will launch `Storybook`
    (as we''ll see later) and the other will build a standalone application that you
    can use to showcase your components in an independent fashion:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`package.json`中添加一些脚本：一个将启动`Storybook`（稍后我们将看到），另一个将构建一个独立的应用程序，您可以使用它来展示您的组件：
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let''s write a simple story for `ExpandableCard`. In the same directory
    where that component is (the final version, which actually allowed expanding and
    compressing, not the first version without that behavior), create a `ExpandableCard.story.js`
    file. What would you want to show about your component? You could display the
    following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为`ExpandableCard`编写一个简单的故事。在该组件所在的同一目录中（最终版本，实际上允许展开和压缩，而不是没有该行为的第一个版本），创建一个`ExpandableCard.story.js`文件。您想展示关于您的组件的内容是什么？您可以显示以下内容：
- en: An expandable card with a couple of lines within, as we used previously
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可展开的卡片，里面有几行，就像我们之前使用的那样
- en: Another card with many lines, to show how the card stretches
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一张卡片，有很多行，展示卡片如何拉伸
- en: A card containing other cards, each of them with some minimal content
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含其他卡片的卡片，每个卡片都有一些最小的内容
- en: 'The code will look quite similar in style to the tests we wrote for `Node` back
    in [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and Debugging
    your Server*. I''m assuming that you can figure out what each test does:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码风格与我们在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)中为`Node`编写的测试非常相似，*测试和调试您的服务器*。我假设您可以弄清楚每个测试的作用：
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So as not to have a single story, let's write a short one for the `CountryFilterBar`
    component; it will be in the same directory, named `countryFilterBar.story.js`.
    And, yes, I know this is a very simple component, but this is just for our example!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不只有一个故事，让我们为`CountryFilterBar`组件写一个简短的故事；它将在相同的目录中，命名为`countryFilterBar.story.js`。是的，我知道这是一个非常简单的组件，但这只是为了我们的例子！
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we need a launcher. Create a `.storybook` directory at the root of
    the project, and a `config.js` file within, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个启动器。在项目的根目录下创建一个`.storybook`目录，并在其中创建一个`config.js`文件，如下所示：
- en: '[PRE28]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Yes, it's sort of mysterious—but it basically says to scan the `/src` directory,
    and pick up all of the files whose names end with `.story.js`. Now we are set
    to see how this all comes together.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这有点神秘，但基本上是要扫描`/src`目录，并选择所有文件名以`.story.js`结尾的文件。现在我们准备好看看这一切是如何结合在一起的。
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have written stories for just a couple of our components, but that will
    do for our purposes. To start the `Storybook` server, you''ll have to run one
    of the scripts we created earlier in this section:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只为一些组件编写了故事，但这对我们的目的足够了。要启动`Storybook`服务器，您必须运行我们在本节早些时候创建的脚本之一：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After some work, you''ll get the following screen:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些工作，你会得到以下屏幕：
- en: '![](img/414d3646-e57c-4fb0-8adc-7b84cecad785.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/414d3646-e57c-4fb0-8adc-7b84cecad785.png)'
- en: The Storybook, showing all of the available stories. You can interact with components,
    click on them, and even test out changes in source code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook，显示所有可用的故事。您可以与组件交互，单击它们，甚至测试源代码中的更改。
- en: You can select any component in the left sidebar (or even use the Filter text
    box), and you'll get the individual stories for it. Clicking on a story will show
    the corresponding component on the right. You can work with the component and
    see how it looks and performs... and if you are not satisfied, you can dynamically
    change its source code, and immediately see the results!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在左侧边栏中选择任何组件（甚至使用过滤文本框），并获取它的各个故事。单击一个故事将在右侧显示相应的组件。您可以使用组件并查看其外观和性能...如果您不满意，您可以动态更改其源代码，并立即查看结果！
- en: 'To finish, let''s build a separate showcase application:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们构建一个独立的展示应用程序：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After this, in the `/out_sb` directory, we will have a full standalone version
    of our showcase. To see how it works, we can use the Web Server for Chrome application
    (search for it in the Chrome extensions) and choose the output directory:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/out_sb`目录中，我们将拥有一个完整的独立版本的展示。要查看它的工作原理，我们可以使用Chrome浏览器的Web服务器应用程序（在Chrome扩展中搜索），并选择输出目录：
- en: '![](img/d567adc8-893b-462b-9cd1-e1e3c29a06a2.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d567adc8-893b-462b-9cd1-e1e3c29a06a2.png)'
- en: The Web Server for Chrome application is sufficient to let us see what the standalone
    Storybook would look like
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome的Web服务器应用程序足以让我们看到独立的Storybook会是什么样子
- en: If you open the web server URL that is shown onscreen, you'll get exactly the
    same output as earlier – but now you could copy the `out_sb` directory elsewhere,
    and use it as a showcase tool, with independence from the developers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开屏幕上显示的Web服务器URL，您将得到与之前完全相同的输出-但现在您可以将`out_sb`目录复制到其他位置，并将其用作展示工具，独立于开发人员。
- en: There's more...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can expand `Storybook` with *add-ons*, which allow you to enhance your
    showcase. Out of the many available ones, we will install three of them and have
    a quick look at their usage:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过*插件*扩展`Storybook`，从而增强您的展示。在众多可用的插件中，我们将安装其中三个，并快速查看它们的用法：
- en: '`addon-actions` lets you see the data received by event handlers to see what
    would happen, for example, when the user clicks on a component'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addon-actions`允许您查看事件处理程序接收的数据，以查看例如当用户单击组件时会发生什么'
- en: '`addon-notes` allows you to add notes to a component, to explain how it works
    or to give insights on its usage'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addon-notes`允许您向组件添加注释，以解释其工作原理或提供有关其用法的见解'
- en: '`addon-knobs` lets you dynamically tweak a component''s props to see how they
    change'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addon-knobs`允许您动态调整组件的属性以查看其变化'
- en: You can read more about add-ons at [https://storybook.js.org/addons/introduction/](https://storybook.js.org/addons/introduction/)
    and take a look at the gallery of available add-ons at [https://storybook.js.org/addons/addon-gallery/](https://storybook.js.org/addons/addon-gallery/).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://storybook.js.org/addons/introduction/](https://storybook.js.org/addons/introduction/)上阅读有关插件的更多信息，并查看可用插件的画廊[https://storybook.js.org/addons/addon-gallery/](https://storybook.js.org/addons/addon-gallery/)。
- en: 'Since add-ons are quite simple, let''s look at an example where all of the
    aforementioned ones are used. First, we''ll have to create an `addons.js` file
    in the `.storybook` directory, with a line for each add-on that we want to use:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于插件非常简单，让我们看一个使用了所有前述插件的示例。首先，我们需要在`.storybook`目录中创建一个`addons.js`文件，每个要使用的插件都需要一行：
- en: '[PRE31]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now let''s modify our stories so that `CountryFilterBar` will show what value
    it sends back with the onSelect event, and will also show some notes describing
    the component, so that `ExpandableCard` will let you tweak the props it receives:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改我们的故事，使`CountryFilterBar`将显示其在选择事件上发送的值，并且还将显示一些描述该组件的注释，以便`ExpandableCard`可以让您调整其接收到的属性：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the action, I provided an `action(...)` function, which will display its
    results in another tab, ACTION LOGGER, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动作，我提供了一个`action(...)`函数，它将在另一个选项卡“ACTION LOGGER”中显示其结果，如下所示：
- en: '![](img/87d8f759-c6a5-4ddf-8f57-cbb7d292837f.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87d8f759-c6a5-4ddf-8f57-cbb7d292837f.png)'
- en: Whenever you select a country, the executed callback and its parameters are
    shown in the ACTIONS tab.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您选择一个国家时，执行的回调及其参数将显示在ACTIONS选项卡中。
- en: I clicked on my country, Uruguay, and I can see that "UY" is being sent.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我点击了我的国家乌拉圭，我可以看到正在发送“UY”。
- en: 'I also added a `withNotes(...)` call, providing the text from a markdown file
    I created. The content of this will be shown in the NOTES tab, as shown in the
    following screenshot:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了一个`withNotes(...)`调用，提供了我创建的一个 markdown 文件中的文本。此内容将显示在NOTES选项卡中，如下截图所示：
- en: '![](img/4864a6f4-ebd6-45a8-a334-2032c28e1cf6.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4864a6f4-ebd6-45a8-a334-2032c28e1cf6.png)'
- en: You can provide good documentation (not like mine!) for every component
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为每个组件提供良好的文档（不像我的！）
- en: 'Finally, we can add a few "knobs" that lets the user change parameters dynamically.
    Let''s allow them to modify the card''s title and the numbers shown inside it:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一些“旋钮”，让用户动态修改参数。让他们修改卡片的标题和其中显示的数字：
- en: '[PRE33]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When the user sees this story, the KNOBS panel lets them type in some values
    that are immediately updated on screen, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户看到这个故事时，KNOBS面板会让他们在屏幕上立即更新一些值。
- en: '![](img/43d12d96-4aa9-4cd5-8bae-6509eb01aec1.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43d12d96-4aa9-4cd5-8bae-6509eb01aec1.png)'
- en: Adding knobs to a story lets users experiment with different settings. The values
    you enter in the Knobs panel are automatically reflected in the component.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 向故事添加旋钮可以让用户尝试不同的设置。您在旋钮面板中输入的值会自动反映在组件中。
- en: We used only texts and numbers, but you can also provide knobs for Booleans,
    colors, dates, numbers within a given range, objects, string arrays, and options
    from a list.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅使用文本和数字，但您还可以为布尔值、颜色、日期、给定范围内的数字、对象、字符串数组和列表中的选项提供旋钮。
