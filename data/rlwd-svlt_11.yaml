- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Renderless Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无渲染组件
- en: A renderless component is an advanced concept in Svelte that allows developers
    to create reusable components without rendering any HTML elements within the component
    itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无渲染组件是Svelte中的一个高级概念，它允许开发者创建不包含任何HTML元素的可重用组件。
- en: This technique is particularly useful when leveraging Svelte to render on a
    canvas or in a 3D context, where the rendering of an HTML template by Svelte is
    not required. Instead, the canvas and **Web Graphics Library** (**WebGL**) offer
    an imperative API to produce graphics on the canvas. With the renderless component
    technique, it becomes possible to design components that enable users to describe
    the canvas declaratively, allowing the component to translate it into imperative
    instructions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在利用Svelte在画布或3D上下文中渲染时特别有用，其中Svelte不需要渲染HTML模板。相反，画布和**Web图形库**（**WebGL**）提供了一个命令式API来在画布上生成图形。使用无渲染组件技术，可以设计出允许用户声明性地描述画布的组件，从而使组件能够将其转换为命令式指令。
- en: Another use case for a renderless component is to create components that only
    manage states and behaviors, leaving the parent component control over what should
    actually be rendered. This will come in handy when developing a component library
    and you want to make it easy for users to customize how your component looks and
    lets you have control over the state and behaviors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 无渲染组件的另一个用例是创建仅管理状态和行为，而将实际渲染的控制权留给父组件的组件。这在开发组件库时非常有用，你希望用户能够轻松地自定义组件的外观，同时让你控制状态和行为。
- en: In this chapter, we will utilize Svelte context to create our renderless component.
    If you are new to Svelte context, please refer to [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121),
    where we explain its meaning.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用Svelte上下文来创建我们的无渲染组件。如果你对Svelte上下文不熟悉，请参阅[*第8章*](B18887_08.xhtml#_idTextAnchor121)，其中我们解释了它的含义。
- en: Initially, we will explore the concept of renderless components and subsequently
    build techniques to create them. As we develop our renderless component, we will
    share a few examples of renderless components.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将探讨无渲染组件的概念，然后构建创建它们的技巧。随着我们开发无渲染组件，我们将分享一些无渲染组件的示例。
- en: At the end of the chapter, you should possess the ability to employ the renderless
    component technique to convert imperative APIs into declarative components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该能够使用无渲染组件技术将命令式API转换为声明式组件。
- en: 'The topics discussed in this chapter are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题如下：
- en: What are renderless components?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是无渲染组件？
- en: Building renderless components with Svelte context
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Svelte上下文构建无渲染组件
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code used in this chapter on GitHub: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章使用的代码：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11)。
- en: What are renderless components?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是无渲染组件？
- en: A renderless component, as its name implies, is a type of component that does
    not render any HTML elements of its own.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，无渲染组件是一种不渲染任何自身HTML元素的组件类型。
- en: You might wonder, what’s the purpose of a component that doesn’t render anything?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，一个不渲染任何内容的组件有什么用？
- en: 'Well, despite not rendering HTML, there are still several useful things that
    a component can do, including the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，尽管它不支持渲染HTML，但组件仍然可以做几件有用的事情，包括以下内容：
- en: '**Accepting props, processing their values, and triggering side effects as
    their values change**: Even though the prop values are not used directly in the
    template, they are still reactive. You can write reactive statements with props
    in the component and have them run whenever the prop values change. You can see
    this in the following example code snippet:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接受属性、处理它们的值，并在它们的值变化时触发副作用**：即使属性值没有直接在模板中使用，它们仍然是响应式的。你可以在组件中使用属性编写响应式语句，并在属性值变化时运行它们。你可以在下面的示例代码片段中看到这一点：'
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Even though the `title` and `description` props are not used in the template,
    both `title` and `description` are used in a reactive statement. Whenever the
    `title` or `description` props change, the reactive statement in line 4 will rerun
    and update the title of the document.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使`title`和`description`属性在模板中没有使用，`title`和`description`都会在响应式语句中使用。每当`title`或`description`属性发生变化时，第4行的响应式语句将重新运行并更新文档的标题。
- en: Setting the document title, updating the cookie value, and modifying context
    are good examples of side effects.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设置文档标题、更新cookie值和修改上下文是副作用的好例子。
- en: '`onMount` and `onDestroy`, still run even if no elements are mounted and destroyed
    in the component.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在组件中没有元素挂载和销毁，`onMount`和`onDestroy`也会运行。
- en: '`<slot>``<slot>` element that allows the user of the component to pass in child
    elements or components.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<slot>` `<slot>`元素允许组件的使用者传递子元素或组件。'
- en: 'For example, in the following `Parent` component, we render a `default` slot:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在下面的`Parent`组件中，我们渲染了一个`default`槽：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, the user of the `Parent` component can pass in child elements or components
    under the `Parent` component:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，`Parent`组件的使用者可以在`Parent`组件下传递子元素或组件：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Parent` component can pass data to the child components or elements through
    two avenues – setting context data and setting slot props.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Parent`组件可以通过两种途径向子组件或元素传递数据——设置上下文数据和设置槽属性。'
- en: You can read more about setting slot props in [*Chapter 4*](B18887_04.xhtml#_idTextAnchor064).
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[*第4章*](B18887_04.xhtml#_idTextAnchor064)中了解更多关于设置槽属性的信息。
- en: '`getContext()` to retrieve the context value set by its parent component. Depending
    on the type of context value provided by the parent, we can use the context value
    to communicate with the parent or inform it about the existence of the child component.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getContext()`来检索由其父组件设置的上下文值。根据父组件提供的上下文值类型，我们可以使用上下文值与父组件通信或通知它子组件的存在。
- en: In the *Writing declarative canvas components* section later in the chapter,
    you will see an example of such a technique.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章后面的*编写声明式画布组件*部分，你将看到一个此类技术的示例。
- en: Throughout the upcoming sections, we will challenge ourselves by creating components
    that perform only the operations listed in the preceding list, without rendering
    any HTML elements.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过创建仅执行前面列表中列出的操作，而不渲染任何HTML元素的组件来挑战自己。
- en: In this chapter, we will explore two use cases for renderless components, which
    are turning reusable renderless components and declarative descriptions into imperative
    instructions. Let’s take an in-depth look at them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨无状态组件的两个用例，即把可重复使用的无状态组件和声明性描述转换为命令性指令。让我们深入了解一下。
- en: Exploring reusable renderless components
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索可重复使用的无状态组件
- en: The first use case for renderless components involves creating components that
    solely focus on the logic of the component. These components are not your typical
    ones, such as buttons or text inputs. Instead, think of components with slightly
    complex logic, such as carousels, tabs, or drop-down menus. Although the logic
    of a carousel component is relatively standard, its appearance can vary significantly
    based on where and how it is used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态组件的第一个用例是创建仅关注组件逻辑的组件。这些组件不是你典型的按钮或文本输入等组件。相反，考虑一下具有稍微复杂逻辑的组件，例如轮播、标签页或下拉菜单。尽管轮播组件的逻辑相对标准，但其外观可以根据其使用位置和方式而有很大差异。
- en: So, how can we create a reusable carousel component that can look different
    based on where it is used?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何创建一个可重复使用的轮播组件，使其根据使用位置的不同而具有不同的外观？
- en: One solution is to create a carousel component that only contains the carousel
    logic, without any specific styling or HTML structure. Then, the consumer of the
    component can decide how the carousel should look by passing in their own styling
    and HTML structure. This allows for greater flexibility and customization, making
    the component more versatile and reusable in different contexts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是创建一个仅包含轮播逻辑的轮播组件，不包含任何特定的样式或HTML结构。然后，组件的消费者可以通过传递自己的样式和HTML结构来决定轮播组件的外观。这提供了更大的灵活性和定制性，使组件在不同环境中更具通用性和可重复使用性。
- en: For example, the carousel component could accept props such as `items`, which
    would determine the list of items in the carousel. The carousel component could
    render a `slot` element that takes in slot props such as `currentIndex` and `setIndex`,
    which would be the index of the currently active item and the function to set
    the index. This allows the carousel component to manage the carousel item cycling
    logic, while leaving the consumer of the carousel component to determine the actual
    carousel styling and structure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，轮播组件可以接受如`items`这样的属性，这将确定轮播中的项目列表。轮播组件可以渲染一个`slot`元素，该元素接受如`currentIndex`和`setIndex`这样的slot属性，这将代表当前活动项目的索引和设置索引的函数。这允许轮播组件管理轮播项目循环逻辑，同时让轮播组件的消费者决定实际的轮播样式和结构。
- en: By separating the carousel logic from the specific styling and structure, we
    can create a more modular and reusable component that can be used in various contexts,
    without having to rewrite the same logic over and over again. This is the power
    of renderless components – they allow us to create components that focus solely
    on their core functionality, without being tied to any specific rendering or styling
    requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将轮播逻辑与特定的样式和结构分离，我们可以创建一个更模块化和可重用的组件，可以在各种环境中使用，而无需反复重写相同的逻辑。这就是无渲染组件的力量——它们允许我们创建专注于核心功能的组件，而不受任何特定渲染或样式要求的限制。
- en: Of course, before we proceed, it’s essential to clarify when not to use a renderless
    component to create a carousel. If you require a fully functional carousel component,
    including the design and style, a renderless component may not be suitable for
    your needs, as its main purpose is to handle the logic and behavior of the carousel
    without dictating its appearance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们继续之前，明确何时不使用无渲染组件来创建轮播是很重要的。如果您需要一个包含设计和样式的完整功能的轮播组件，那么无渲染组件可能不适合您的需求，因为其主要目的是处理轮播的逻辑和行为，而不规定其外观。
- en: Ultimately, the decision to create a renderless component for a carousel depends
    on your specific needs and goals. Consider your project requirements and design
    preferences before deciding on the best approach.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，是否为轮播创建无渲染组件取决于您的具体需求和目标。在决定最佳方法之前，请考虑您的项目需求和设计偏好。
- en: In the next section, I will show you step by step how we can build a renderless
    carousel component.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将逐步向您展示如何构建一个无渲染的轮播组件。
- en: Example – building a renderless carousel component
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 构建一个无渲染的轮播组件
- en: A carousel component is a UI component that displays a set of items in a loop.
    It allows users to view a collection of items in a slideshow-like format. A carousel
    component is usually found on websites such as e-commerce platforms, news portals,
    and social media platforms.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 轮播组件是一个UI组件，以循环的方式显示一组项目。它允许用户以幻灯片式的格式查看一系列项目。轮播组件通常在电子商务平台、新闻门户和社交媒体平台上找到。
- en: '![Figure 11.1: An example of a carousel component](img/B18887_11_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：轮播组件的示例](img/B18887_11_01.jpg)'
- en: 'Figure 11.1: An example of a carousel component'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：轮播组件的示例
- en: We will create a renderless carousel component that accepts a list of items
    through props named `items`. The carousel component will render a `slot` element
    to allow customization of its appearance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个无渲染的轮播组件，该组件通过名为`items`的属性接受一个项目列表。轮播组件将渲染一个`slot`元素，以允许自定义其外观。
- en: 'The `slot` element will take in a few slot props:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`slot`元素将接受一些slot属性：'
- en: '`currentIndex`: This represents the index of the currently displayed item in
    the carousel.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentIndex`：这代表轮播中当前显示项目的索引。'
- en: '`currentItem`: This represents the currently displayed item in the carousel.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentItem`：这代表轮播中当前显示的项目。'
- en: '`setCurrentIndex`: This is a function that can be used to update the current
    index of the carousel. It can be used to implement custom navigation controls.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setCurrentIndex`：这是一个可以用来更新轮播当前索引的函数。它可以用来实现自定义导航控制。'
- en: '`next` and `prev`: These `slot` props are functions that can be used to navigate
    to the next or previous item in the carousel. They can be used to implement custom
    navigation controls or respond to user input, such as clicks or swipes.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`和`prev`：这些`slot`属性是函数，可以用来导航到轮播中的下一个或上一个项目。它们可以用来实现自定义导航控制或响应用户输入，如点击或滑动。'
- en: These `slot` props allow the consumer to decide how to use them to build their
    own carousel UI.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`slot`属性允许消费者决定如何使用它们来构建自己的轮播UI。
- en: To determine the appropriate `slot` props for the carousel component, we consider
    the essential states and functions required for users to build their own carousel
    UI. In this case, the key states are `currentIndex` and `currentItem`, while the
    necessary functions to interact with the carousel UI include `setCurrentIndex`,
    `next`, and `prev`, which are helpful to implement custom navigation controls.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定轮播组件适当的`slot`属性，我们考虑了用户构建自己的轮播UI所需的基本状态和功能。在这种情况下，关键状态是`currentIndex`和`currentItem`，而与轮播UI交互所需的必要函数包括`setCurrentIndex`、`next`和`prev`，这些对于实现自定义导航控制非常有帮助。
- en: 'An example of a carousel UI is one that displays the current item and has buttons
    to navigate forward and backward through the carousel:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 轮播UI的一个例子是显示当前项目并具有导航前后按钮的轮播：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, we use the `currentItem`, `next`, and `prev`
    slot props to build a simple carousel UI. We decide how to use the `slot` props
    and control the structure and styling of the HTML elements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`currentItem`、`next`和`prev` slot属性构建了一个简单的轮播UI。我们决定如何使用`slot`属性，并控制HTML元素的布局和样式。
- en: 'Another example of a carousel UI is displaying a list of item numbers at the
    bottom of it, enabling the user to quickly jump to a selected item by clicking
    on its number:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 轮播UI的另一个例子是在其底部显示项目编号列表，使用户能够通过点击其编号快速跳转到所选项目：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, I used Svelte’s `{#each}` block to create a list of buttons,
    labeled with a different index number. Each of the buttons has a click event listener
    that sets the current index of the carousel to the index number of the button.
    When you click on the button, the carousel will jump to the item at the index
    that is specified by the button.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我使用了Svelte的`{#each}`块来创建一个按钮列表，每个按钮都有一个不同的索引编号。每个按钮都有一个点击事件监听器，将轮播的当前索引设置为按钮的索引编号。当你点击按钮时，轮播将跳转到按钮指定的索引位置的项目。
- en: The second carousel UI is different from the first carousel UI, and you can
    create and style a totally different carousel UI. You can see that the appearance
    of the carousel UI is entirely up to the user. The renderless carousel component
    focuses on the carousel logic and allows the user to decide on the UI structure
    and styling.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个轮播UI与第一个轮播UI不同，你可以创建并设计一个完全不同的轮播UI。你可以看到轮播UI的外观完全取决于用户。无渲染轮播组件专注于轮播逻辑，并允许用户决定UI结构和样式。
- en: Without further ado, let’s explore how to write the carousel component.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们探索如何编写轮播组件。
- en: Writing a renderless carousel component
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写无渲染轮播组件
- en: In the previous section, we decided on the props of our `Carousel` component,
    `items`, and decided that it should have a default `<slot>`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们决定了我们的`Carousel`组件的属性`items`，并决定它应该有一个默认的`<slot>`。
- en: 'Based on this information, let’s create the structure of our `Carousel` component:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，让我们创建我们的`Carousel`组件的结构：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code snippet, the `<slot>` element will be the only element
    we will have in our `Carousel` component. This `<slot>` element is needed; otherwise,
    the child elements inside the `<Carousel>` component, indicated in the following
    code snippet, will be ignored and discarded if there’s no `<slot>` element in
    the `Carousel` component:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`<slot>`元素将是我们在`Carousel`组件中拥有的唯一元素。这个`<slot>`元素是必需的；否则，如果没有`<slot>`元素，在`Carousel`组件内部指示的以下代码片段中的子元素将被忽略并丢弃：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `<slot>` element, we define the following `slot` props – `currentIndex`,
    `currentItem`, `setCurrentIndex`, `prev`, and `next`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<slot>`元素中，我们定义以下`slot`属性 - `currentIndex`、`currentItem`、`setCurrentIndex`、`prev`和`next`：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, these `slot` props are not defined in our `Carousel` component yet,
    so let’s define them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些`slot`属性在我们的`Carousel`组件中尚未定义，所以让我们来定义它们。
- en: 'We initialize `currentIndex` to `0` at the start of the component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在组件开始时将`currentIndex`初始化为`0`：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`setCurrentIndex` is used to update `currentIndex` to the value being passed
    in:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`setCurrentIndex`用于将`currentIndex`更新为传入的值：'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`currentItem` will be the item in the `items` array at the index position of
    `currentIndex`. Here, I’ll use the reactive statements so that we will have a
    new `currentItem` slot prop whenever the `items` array or `currentIndex` changes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentItem`将是`items`数组中`currentIndex`索引位置的项目。在这里，我将使用响应式语句，这样每当`items`数组或`currentIndex`发生变化时，我们都会有新的`currentItem`
    slot属性：'
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, the `prev` and `next` functions will be used to set `currentIndex`,
    based on its current value:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`prev`和`next`函数将根据其当前值设置`currentIndex`：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding snippet, I used `% items.length` so that the index is always
    within the bounds of the length of the `items` array. This way, we ensure that
    the carousel can loop back to the beginning of the `items` array after reaching
    the end, creating a seamless looping effect for the user.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我使用了`% items.length`，这样索引总是位于`items`数组长度的范围内。这样，我们确保在到达数组末尾后，轮播图可以回到`items`数组的开头，为用户创建一个无缝循环效果。
- en: And that’s it. If you add all the preceding code snippets to the `Carousel`
    component, you’ll have a working renderless component. The full code is available
    on GitHub at[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel)
    as well.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。如果你将所有前面的代码片段添加到`Carousel`组件中，你将拥有一个可工作的无状态组件。完整的代码可在GitHub上找到：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/01-carousel)。
- en: Creating a renderless component is not hard; it doesn’t take us much time to
    create a renderless `Carousel` component. The key here is to figure out the props
    for our renderless component, then figure out the `slot` props needed, and finally,
    create a default `<slot>` element with the `slot` props.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个无状态组件并不难；创建一个无状态`Carousel`组件并不需要我们花费太多时间。关键是要弄清楚我们无状态组件的属性，然后确定所需的`slot`属性，最后创建一个带有`slot`属性的默认`<slot>`元素。
- en: Before we move on, let’s have an exercise to create a reusable renderless component
    yourself.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们进行一个练习，自己创建一个可重用的无状态组件。
- en: Exercise 1 – a renderless autocomplete component
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1 - 创建一个无状态自动完成组件
- en: An autocomplete component is an input with an auto-suggest dropdown that shows
    a list of matching options as a user types in the input. It helps users quickly
    and easily find and select an option from a large set of choices. autocomplete
    components are commonly used in search bars, forms, and other areas where users
    need to enter data quickly and accurately.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成组件是一个带有自动建议下拉菜单的输入框，当用户在输入框中输入时，会显示匹配选项的列表。它帮助用户快速、轻松地从大量选择中找到并选择一个选项。自动完成组件通常用于搜索栏、表单和其他需要用户快速、准确输入数据的区域。
- en: In this exercise, we’ll create a renderless autocomplete component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个无状态自动完成组件。
- en: The autocomplete component will take in only one prop, a `search` function,
    which takes in a search value and returns `Promise`, which resolves to an array
    of string results.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成组件仅接受一个属性，即一个`search`函数，该函数接受一个搜索值并返回`Promise`，该`Promise`解析为一个字符串结果数组。
- en: What about the slot props that our renderless `Autocomplete` component would
    provide?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的无状态`Autocomplete`组件会提供哪些插槽属性呢？
- en: 'We need three states for our autocomplete component:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的自动完成组件设置三个状态：
- en: '`value`: To represent the current value in the input box'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：表示输入框中的当前值'
- en: '`searching`: A Boolean value to represent whether the autocomplete currently
    searches for results'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searching`：一个布尔值，表示自动完成当前是否正在搜索结果'
- en: '`suggestions`: An array of autocomplete results returned from the `search`
    function'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suggestions`：从`search`函数返回的自动完成结果数组'
- en: 'For a user to interact with the `Autocomplete` component, we need two functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户与`Autocomplete`组件交互，我们需要两个函数：
- en: '`setValue`: To update the value of the input box'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setValue`：用于更新输入框的值'
- en: '`selectSuggestion`: To select the suggestion and apply it to the input box'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectSuggestion`：用于选择建议并将其应用到输入框'
- en: So, the preceding three states and two functions will be the `slot` props for
    our `Autocomplete` component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的三个状态和两个函数将成为我们的`Autocomplete`组件的插槽属性。
- en: 'Here is an example of how the `Autocomplete` component could be used:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Autocomplete`组件的一个使用示例：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code snippet, we use the `Autocomplete` component to render
    an autocomplete textbox, with an `<input>` element and an `<ul>` element in the
    default slot.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`Autocomplete`组件来渲染一个自动完成文本框，其中包含一个`<input>`元素和一个`<ul>`元素在默认插槽中。
- en: The `<input>` element uses the `value` and `setValue` slot props to access and
    modify `value`, held by the `Autocomplete` component.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input>`元素使用`value`和`setValue`插槽属性来访问和修改由`Autocomplete`组件持有的`value`。'
- en: The `<ul>` element uses the `suggestions` slot prop to showcase the list of
    suggestions provided by the `Autocomplete` component and the `selectSuggestion`
    slot props are used in the `click` event handler of the `<li>` element to select
    the chosen suggestion and apply it to the textbox.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ul>` 元素使用 `suggestions` 插槽属性来展示 `Autocomplete` 组件提供的建议列表，而 `selectSuggestion`
    插槽属性用于 `<li>` 元素的 `click` 事件处理器中，以选择选定的建议并将其应用到文本框中。'
- en: A sample solution can be found at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例解决方案可以在[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/02-autocomplete)找到。
- en: Now, let us look at the second use case for a renderless component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看无渲染组件的第二个用例。
- en: Turning a declarative description into imperative instructions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将声明性描述转换为命令式指令
- en: The second use case for a renderless component involves allowing users to describe
    their needs declaratively and then translating them into imperative instructions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无渲染组件的第二个用例涉及允许用户以声明式方式描述他们的需求，然后将它们转换为命令式指令。
- en: A good example of this use case is when working with a canvas or WebGL.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理画布或 WebGL 时，这是一个很好的用例示例。
- en: 'For example, in a canvas, to create a red rectangle with a green border, you
    would need to use imperative APIs to create and style the rectangle:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在画布中，要创建一个带有绿色边框的红色矩形，你需要使用命令式 API 来创建和样式化矩形：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Step by step, we instruct the canvas context to set `fillStyle` and `strokeStyle`
    and then draw a rectangle, based on the fill color and stroke color set.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步指导画布上下文设置 `fillStyle` 和 `strokeStyle`，然后根据设置的填充颜色和描边颜色绘制矩形。
- en: When interacting with the canvas in an imperative manner, the code focuses on
    how to do things rather than what to do. This can result in code that is difficult
    to read and maintain, with a lot of low-level details that can make it hard to
    see the bigger picture.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当以命令式方式与画布交互时，代码关注的是如何做事情，而不是要做什么。这可能导致难以阅读和维护的代码，其中包含大量低级细节，可能会使其难以看到整体情况。
- en: Conversely, if you write code declaratively, you describe what you want to happen,
    rather than how it should happen. This makes the code more expressive and easier
    to read, as well as more flexible and reusable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你以声明式编写代码，你描述的是你想要发生的事情，而不是它应该如何发生。这使得代码更具表现力，更容易阅读，同时也更灵活和可重用。
- en: Continuing with the example of the red rectangle, we can create a Svelte component
    that handles drawing the rectangle on the canvas. Instead of manually coding the
    instructions to draw the rectangle, we can simply describe how we want it to appear
    on the canvas through the component. The component then takes care of rendering
    the rectangle on the canvas for us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以红色矩形的例子，我们可以创建一个 Svelte 组件来处理在画布上绘制矩形。我们不需要手动编写绘制矩形的指令，而可以通过组件简单地描述我们希望在画布上看到的样子。然后，组件会为我们处理在画布上渲染矩形。
- en: 'Here’s an example of code that describes the same rectangle through a Svelte
    component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个通过 Svelte 组件描述相同矩形的代码示例：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code snippet, we see a `Rectangle` component nested within
    a `Canvas` component. The `Rectangle` component has its fill, stroke, *x* position,
    *y* position, width, and height specified.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们看到一个嵌套在 `Canvas` 组件中的 `Rectangle` 组件。`Rectangle` 组件指定了其填充、描边、*x*
    位置、*y* 位置、宽度和高度。
- en: The following diagram illustrates how the `Rectangle` component from the preceding
    code renders a red square with a green border.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了前面代码中的 `Rectangle` 组件如何渲染一个带有绿色边框的红色正方形。
- en: '![Figure 11.2: A red square with a green border](img/B18887_11_02.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2：一个带有绿色边框的红色正方形](img/B18887_11_02.jpg)'
- en: 'Figure 11.2: A red square with a green border'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：一个带有绿色边框的红色正方形
- en: Even though explicit instructions to draw on the canvas are nowhere to be seen
    in the code, we can visualize a rectangle being drawn on the canvas based on the
    `Rectangle` component. This rectangle, with a width and height of 100 px each,
    is positioned 10 px from the left and 10 px from the top, filled with a red color
    and a green border.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码中看不到绘制在画布上的显式指令，但我们可以根据 `Rectangle` 组件可视化一个矩形在画布上被绘制。这个矩形，宽度和高度各为 100 像素，距离左边和上边各
    10 像素，填充红色，边框为绿色。
- en: By creating a renderless component that handles the low-level canvas instructions,
    we can separate the logic of drawing the rectangle from the specifics of how it
    should be rendered. This allows for more flexibility in how the rectangle is displayed
    on the canvas, as well as easier maintenance of the code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个处理低级画布指令的无渲染组件，我们可以将绘制矩形的逻辑与它应该如何渲染的具体细节分开。这允许我们在画布上以更多样化的方式显示矩形，同时也使得代码的维护更加容易。
- en: Furthermore, by allowing a user to describe their needs declaratively, we create
    a more intuitive and user-friendly interface to work with the canvas and other
    low-level technologies. This can lead to faster development times and a more enjoyable
    development experience.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过允许用户以声明式的方式描述他们的需求，我们创建了一个更直观、用户友好的界面来与画布和其他低级技术一起工作。这可能导致开发时间更快，开发体验更加愉快。
- en: 'Let me show you an example of how declaratively describing a canvas is much
    faster than instructing it imperatively. If I want to animate the size of the
    rectangle, rather than coding the animation manually using imperative APIs, I
    can simply animate the `height` and `width` variables'' value, just like the following
    code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你举一个例子，说明以声明式描述画布比强制性地指令它要快得多。如果我想动画化矩形的尺寸，而不是手动使用命令式API编码动画，我只需简单地动画化 `height`
    和 `width` 变量的值，就像以下代码片段所示：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Although the use of `setInterval` may not be the best to create an animation,
    the preceding code snippet attempts to demonstrate how easy it is to change the
    height and width of the rectangle in the canvas.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `setInterval` 可能不是创建动画的最佳方式，但前面的代码片段试图展示改变画布上矩形的高度和宽度是多么容易。
- en: In the preceding code snippet, we update `height` and `width` on every interval.
    We pass `height` and `width` into the `Rectangle` component. As you can see, the
    height and width of the rectangle on the canvas increases by 10 px every 100 ms.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们每隔一段时间更新 `height` 和 `width`。我们将 `height` 和 `width` 传递给 `Rectangle`
    组件。正如你所见，画布上矩形的宽度和高度每100毫秒增加10 px。
- en: Conversely, if we were to animate it imperatively, we would have to clear the
    canvas and redraw a rectangle with a new height and width on each interval. These
    implementation details are now abstracted away in the declarative component, making
    it easier to reason about the animation and modify it in the future.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们强制性地进行动画处理，我们必须在每个间隔清除画布并重新绘制一个具有新高度和宽度的矩形。这些实现细节现在在声明式组件中被抽象出来，使得推理动画和未来修改它变得更加容易。
- en: Overall, using renderless components to handle low-level imperative tasks can
    greatly improve the readability, maintainability, and flexibility of our code,
    while also making it more accessible and user-friendly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，使用无渲染组件来处理低级命令式任务可以极大地提高我们代码的可读性、可维护性和灵活性，同时使其更加易于访问和用户友好。
- en: So, how do we implement the `Canvas` and the `Rectangle` component shown in
    the preceding code snippet? Let’s find out.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现前面代码片段中显示的 `Canvas` 和 `Rectangle` 组件呢？让我们来看看。
- en: Writing declarative Canvas components
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写声明式 Canvas 组件
- en: We’ll start with the `Canvas` component.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `Canvas` 组件开始。
- en: Similar to the component structure of the `Carousel` component in the previous
    section, the `Canvas` component will render a `<slot>` element to insert all the
    child components.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一小节中 `Carousel` 组件的组件结构类似，`Canvas` 组件将渲染一个 `<slot>` 元素来插入所有子组件。
- en: 'However, what’s different is that it will also render a `<canvas>` element,
    which is what we will interact with and draw on:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不同之处在于它还会渲染一个 `<canvas>` 元素，这是我们将会与之交互并在其上绘制的元素：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code snippet, we bind the reference of the `<canvas>` element
    to the variable named `canvas`. After the `<canvas>` element is mounted onto the
    DOM, we get the drawing context of the `<canvas>` element and assign it to the
    variable named `ctx`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `<canvas>` 元素的引用绑定到名为 `canvas` 的变量。在 `<canvas>` 元素挂载到DOM之后，我们获取
    `<canvas>` 元素的绘图上下文并将其分配给名为 `ctx` 的变量。
- en: If you recall the previous code example, we placed the `<Rectangle>` component
    inside the `<Canvas>` component to draw a rectangle onto the canvas. The `<Rectangle>`
    component does not receive any data or slot props from the `<Canvas>` component.
    So, how does the `<Rectangle>` component inform the `<Canvas>` component that
    it is a child of the `<Canvas>` component? How does the `<Canvas>` component communicate
    with the `<Rectangle>` component to know what to draw and how to draw on its `<``canvas>`
    element?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前的代码示例，我们将 `<Rectangle>` 组件放置在 `<Canvas>` 组件内部，以便在画布上绘制矩形。`<Rectangle>`
    组件不会从 `<Canvas>` 组件接收任何数据或插槽属性。那么，`<Rectangle>` 组件是如何通知 `<Canvas>` 组件它是 `<Canvas>`
    组件的子组件的呢？`<Canvas>` 组件是如何与 `<Rectangle>` 组件通信，以知道要绘制什么以及如何在它的 `<canvas>` 元素上绘制呢？
- en: If you recall [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121), we introduced
    Svelte context as a mechanism to set data and make it available to child components.
    Svelte context allows parent components to share data and functions with the child
    components without explicitly passing them as props.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得 [*第 8 章*](B18887_08.xhtml#_idTextAnchor121)，我们介绍了 Svelte 上下文作为一种设置数据并将其提供给子组件的机制。Svelte
    上下文允许父组件在无需显式作为属性传递的情况下，与子组件共享数据和函数。
- en: We can use Svelte context for communication between the `<Canvas>` and `<``Rectangle>`
    components.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Svelte 上下文在 `<Canvas>` 和 `<Rectangle>` 组件之间进行通信。
- en: 'The `<Canvas>` component can set the context with the drawing context, `ctx`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Canvas>` 组件可以使用绘图上下文 `ctx` 设置上下文：'
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the `<Rectangle>` component is rendered as a child of the `<Canvas>` component,
    it can access the context set by the `<Canvas>` component and retrieve the `ctx`
    variable. In `onMount`, `<Rectangle>` retrieves the drawing context of the `<canvas>`
    element and draws a rectangle on the canvas:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `<Rectangle>` 组件作为 `<Canvas>` 组件的子组件渲染时，它可以访问 `<Canvas>` 组件设置的上下文并检索 `ctx`
    变量。在 `onMount` 中，`<Rectangle>` 获取 `<canvas>` 元素的绘图上下文并在画布上绘制矩形：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reason we pass a function that returns `ctx` instead of directly passing
    `ctx` in the context is that the `ctx` value is only available in `onMount` after
    the `<canvas>` element is mounted onto the DOM, yet `setContext` has to be called
    during component initialization, which is before `onMount`. In the `<Rectangle>`
    component, you should only call `getCtx()`within `onMount` to retrieve the latest
    value of `ctx`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个返回 `ctx` 的函数而不是直接在上下文中传递 `ctx` 的原因是因为 `ctx` 值仅在 `<canvas>` 元素挂载到 DOM 之后在
    `onMount` 中可用，而 `setContext` 必须在组件初始化期间调用，即在 `onMount` 之前。在 `<Rectangle>` 组件中，你应该只在
    `onMount` 中调用 `getCtx()` 来检索 `ctx` 的最新值。
- en: By leveraging Svelte context, the `<Canvas>` and `<Rectangle>` components can
    maintain a clear and efficient communication channel. The `<Canvas>` component
    creates the canvas and provides the drawing context, while the `<Rectangle>` component
    accesses the canvas and performs the drawing tasks.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 Svelte 上下文，`<Canvas>` 和 `<Rectangle>` 组件可以保持清晰且高效的通信通道。`<Canvas>` 组件创建画布并提供绘图上下文，而
    `<Rectangle>` 组件访问画布并执行绘图任务。
- en: 'To complete the `<Rectangle>` component, we need to redraw the rectangle whenever
    the *x* or *y* positions or the width and height dimensions change. To do that,
    we will use a reactive statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成 `<Rectangle>` 组件，我们需要在 `x` 或 `y` 位置或宽度和高度尺寸发生变化时重新绘制矩形。为此，我们将使用响应式语句：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding reactive statement, the `draw` function is rerun whenever the
    `x`, `y`, `width`, or `height` values change. By using this approach, the `<Rectangle>`
    component can efficiently update its appearance in response to changes in position
    or dimensions, ensuring that the rendered rectangle always reflects the latest
    state.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的响应式语句中，每当 `x`、`y`、`width` 或 `height` 值发生变化时，`draw` 函数会重新执行。通过使用这种方法，`<Rectangle>`
    组件可以高效地根据位置或尺寸的变化更新其外观，确保渲染的矩形始终反映最新的状态。
- en: However, you might notice that it doesn’t work as expected. You’ll see that
    the new rectangle is drawn on top of the old rectangle. This is because we need
    to clear the canvas before drawing another rectangle. We cannot do that with our
    `draw` function, as it would lead to undesirable results if we have more than
    one `<Rectangle>` component. Each component would clear the canvas before drawing
    its own rectangle, resulting in only the last `<Rectangle>` component being visible.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能注意到它没有按预期工作。你会看到新矩形被绘制在旧矩形之上。这是因为我们需要在绘制另一个矩形之前清除画布。我们不能用我们的 `draw` 函数来做这件事，因为如果有多个
    `<Rectangle>` 组件，这会导致不希望的结果。每个组件都会在绘制自己的矩形之前清除画布，结果只有最后一个 `<Rectangle>` 组件是可见的。
- en: To fix this issue, we need the `<Canvas>` component to clear the canvas before
    redrawing all the child rectangles. This function can be called whenever any of
    the child rectangle components request an update.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要 `<Canvas>` 组件在重新绘制所有子矩形之前清除画布。这个函数可以在任何子矩形组件请求更新时调用。
- en: 'Let us define a `redrawCanvas` function in the `<Canvas>` component to redraw
    the canvas. In the `redrawCanvas` function, we first clear the canvas through
    `ctx.clearRect()`. Here is the update code for the `<``Canvas>` component:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `<Canvas>` 组件中定义一个 `redrawCanvas` 函数来重新绘制画布。在 `redrawCanvas` 函数中，我们首先通过
    `ctx.clearRect()` 清除画布。以下是 `<Canvas>` 组件的更新代码：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `redrawCanvas` function, we want to redraw all the rectangles after we
    clear the canvas. But how do we do that? One idea is that instead of providing
    the drawing context, `ctx`, to all the child components and letting the components
    decide when and how to draw on the canvas, we could provide a function for the
    components to register their `draw` functions. This way, the `<Canvas>` component
    can call the `draw` functions when it needs to redraw the canvas.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `redrawCanvas` 函数中，我们希望在清除画布后重新绘制所有矩形。但我们如何做到这一点？一个想法是，而不是为所有子组件提供绘图上下文 `ctx`
    并让组件决定何时以及如何绘制到画布上，我们可以提供一个函数让组件注册它们的 `draw` 函数。这样，`<Canvas>` 组件可以在需要重新绘制画布时调用这些
    `draw` 函数。
- en: 'In the `<Canvas>` component, we change the `getCtx` function into `registerDrawFunction`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<Canvas>` 组件中，我们将 `getCtx` 函数改为 `registerDrawFunction`：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding `redrawCanvas` function, we loop through the `drawFunctions`
    registered from child components and call them with the drawing context, `ctx`.
    This way, we don’t need to provide `ctx` through Svelte context, yet the child
    components can get the latest `ctx` in their `draw` functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `redrawCanvas` 函数中，我们遍历从子组件注册的 `drawFunctions` 并使用绘图上下文 `ctx` 调用它们。这样，我们不需要通过
    Svelte 上下文提供 `ctx`，但子组件可以在它们的 `draw` 函数中获取最新的 `ctx`。
- en: 'Finally, let us register our `draw` function in the `<``Rectangle>` component:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在 `<Rectangle>` 组件中注册我们的 `draw` 函数：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `onMount` callback, we register the `draw` function of the `<Rectangle>`
    component through Svelte context. When the component is destroyed and removed
    from the DOM, the `<Rectangle>` component unregisters itself and calls the `redrawCanvas`
    function. This ensures that the `<Canvas>` component is updated, and the canvas
    is cleared of the removed rectangle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onMount` 回调中，我们通过 Svelte 上下文注册 `<Rectangle>` 组件的 `draw` 函数。当组件被销毁并从 DOM 中移除时，`<Rectangle>`
    组件会取消注册自己并调用 `redrawCanvas` 函数。这确保了 `<Canvas>` 组件被更新，并且画布上的移除矩形被清除。
- en: Moreover, by calling the `redrawCanvas` function in a reactive statement whenever
    `x`, `y`, `height`, or `width` changes, the `<Rectangle>` component ensures that
    its position and dimensions are accurately reflected on the canvas. This way,
    the `<Canvas>` component always maintains an up-to-date visual representation
    of its child components.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过在 `x`、`y`、`height` 或 `width` 发生变化时调用 `redrawCanvas` 函数，`<Rectangle>` 组件确保其位置和尺寸在画布上得到准确反映。这样，`<Canvas>`
    组件始终保持其子组件的最新视觉表示。
- en: Now, the `<Canvas>` component has full control over redrawing the entire canvas,
    and the `<Rectangle>` components can register their `draw` functions with the
    `<Canvas>` component. This approach ensures that the canvas is always cleared
    before redrawing and allows multiple `<Rectangle>` components to coexist without
    interfering with each other’s drawings.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`<Canvas>` 组件完全控制整个画布的重新绘制，`<Rectangle>` 组件可以将其 `draw` 函数注册到 `<Canvas>` 组件上。这种方法确保在重新绘制之前总是清除画布，并允许多个
    `<Rectangle>` 组件共存而不会相互干扰。
- en: We now have functional `<Canvas>` and `<Rectangle>` components. Throughout the
    process of creating these components, we have transformed imperative canvas operations
    into more manageable, declarative components.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了功能性的 `<Canvas>` 和 `<Rectangle>` 组件。在整个创建这些组件的过程中，我们将命令式画布操作转换为更易于管理的声明式组件。
- en: To facilitate communication between parent and child components, we utilized
    Svelte context as the communication channel. As demonstrated in the preceding
    code snippets, the parent `<Canvas>` component maintains a list of `draw` functions
    from its child components, enabling it to invoke them as needed. This general
    pattern can be applied to parent components that need to track and call methods
    from their child components.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进父组件和子组件之间的通信，我们使用了 Svelte 上下文作为通信渠道。正如前述代码片段所示，父 `<Canvas>` 组件维护一个从其子组件继承的
    `draw` 函数列表，使其能够按需调用它们。这种通用模式可以应用于需要跟踪和调用其子组件方法的父组件。
- en: 'While the code we’ve written is functional, it may still require some refinements.
    To access the full working code, including any additional features or optimizations
    necessary for a polished and comprehensive implementation, please visit the GitHub
    repository: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas%0D).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们编写的代码是可行的，但它可能还需要一些改进。要访问完整的可工作代码，包括任何额外的功能或优化，以便实现一个完善和全面的实现，请访问 GitHub
    仓库：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas%0D)。
- en: Exercise 2 – expanding shape components
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2 – 扩展形状组件
- en: In this exercise, we challenge you to create additional shape components to
    expand the capabilities of your existing `<``Canvas>` component.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们挑战您创建额外的形状组件，以扩展您现有的 `<Canvas>` 组件的功能。
- en: 'Examples of shapes you can create include the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建的形状示例包括以下内容：
- en: A `<Circle>` component that takes in `x`, `y`, `radius`, and `color` as props.
    The component should draw a circle on the canvas at the given coordinates and
    with the specified radius and color.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `<Circle>` 组件，它接受 `x`、`y`、`radius` 和 `color` 作为属性。该组件应在指定的坐标和指定的半径和颜色上绘制画布上的圆。
- en: A `<Line>` component that takes in `x1`, `y1`, `x2`, `y2`, and `color` as props.
    The component should draw a line on the canvas between the two sets of coordinates
    with the specified color.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `<Line>` 组件，它接受 `x1`、`y1`、`x2`、`y2` 和 `color` 作为属性。该组件应在指定的颜色下在两个坐标集之间绘制画布上的线。
- en: Other shape components, such as `<Ellipse>` and `<Triangle>`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他形状组件，如 `<Ellipse>` 和 `<Triangle>`。
- en: You may need to refer to the Canvas API documentation to learn how to draw different
    shapes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要参考 Canvas API 文档来学习如何绘制不同的形状。
- en: You can find the code for the `<Circle>` and `<Line>` components at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter11/03-canvas)
    找到 `<Circle>` 和 `<Line>` 组件的代码。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have delved into the concept of renderless components
    in Svelte and explored their various use cases. Understanding renderless components
    equips you with a new toolset to create reusable components. A renderless component
    emphasizes reusability by focusing on the core logic, state, and behavior, leaving
    the visual presentation flexible for customization.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Svelte 中无渲染组件的概念，并探讨了它们的各种用例。理解无渲染组件为您提供了创建可重用组件的新工具集。无渲染组件通过关注核心逻辑、状态和行为来强调可重用性，同时将视觉呈现留作灵活定制。
- en: By using slot props, we demonstrated how to build a renderless component that
    is reusable and gives users control over its appearance, while maintaining the
    component logic and transforming imperative operations into declarative Svelte
    components.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用插槽属性，我们演示了如何构建一个可重用且允许用户控制其外观的无渲染组件，同时保持组件逻辑并将命令式操作转换为声明式 Svelte 组件。
- en: We also presented practical examples of transforming imperative operations into
    declarative Svelte components. We demonstrated how to create `<Canvas>` and `<Rectangle>`
    components that draw a rectangle on a canvas, which can change in size dynamically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了将命令式操作转换为声明式 Svelte 组件的实际示例。我们演示了如何创建 `<Canvas>` 和 `<Rectangle>` 组件，这些组件可以在画布上绘制矩形，其大小可以动态变化。
- en: In the next chapter, we will explore how Svelte stores and animations can be
    combined to create fluid, animated applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将 Svelte 存储和动画结合，以创建流畅、动态的应用程序。
- en: Renderless Components
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态组件
