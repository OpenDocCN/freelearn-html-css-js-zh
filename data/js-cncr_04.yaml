- en: Chapter 4. Lazy Evaluation with Generators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 使用生成器进行延迟评估
- en: Lazy evaluation is a programming technique, which is used when we don't want
    to compute values until the very last second. This way, we're sure we actually
    need it. The opposite approach, eager evaluation, has the potential to compute
    several values that aren't needed. This generally isn't a problem, until the size
    and complexity of our applications grow beyond a level where these wasted computations
    are imperceptible to the user.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟评估是一种编程技术，当我们不想在最后一刻计算值时使用。这样，我们就可以确定我们确实需要它。相反的方法，即急切评估，可能会计算几个不需要的值。这通常不是问题，直到我们的应用程序的大小和复杂性增长到用户无法察觉这些浪费计算的程度。
- en: The `Generator` is a new primitive type introduced to JavaScript as a part of
    the ES6 specification of the language. Generators help us implement lazy evaluation
    techniques in our code, and as a corollary, help us implement the conserve concurrency
    principle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`生成器`是JavaScript语言ES6规范中引入的一种新原始类型。生成器帮助我们实现代码中的延迟评估技术，并且作为推论，帮助我们实现节省并发原则。'
- en: We'll start the chapter off with some simple introductions to generators, so
    we can get a feel for how they behave. From there, we'll move onto more advanced
    lazy evaluation scenarios, wrapping up the chapter with a look at coroutines.
    Let's get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些简单的生成器介绍开始本章，这样我们就可以了解它们的行为。然后，我们将转向更高级的延迟评估场景，并以协程的概述结束本章。让我们开始吧。
- en: Call stacks and memory allocation
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用栈和内存分配
- en: Memory allocation is a necessity of any programming language. Without this,
    we have no data structures to work with, not even primitive types. Memory is cheap,
    and it seems that there's plenty of it to go around; this isn't cause for celebration
    just yet. While it's more feasible today to allocate larger data structures in
    memory then it was 10 years ago, we still have to deallocate that memory when
    we're done with it. JavaScript is a garbage-collected language, which means our
    code doesn't have to explicitly destroy objects in memory. However, the garbage
    collector incurs a CPU penalty.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配是任何编程语言的必要条件。没有它，我们就没有数据结构可以工作，甚至没有原始类型。内存很便宜，看起来似乎有足够的内存可用；这还不是庆祝的理由。虽然今天在内存中分配较大的数据结构比10年前更容易，但我们仍然需要在完成时释放内存。JavaScript是一种垃圾回收语言，这意味着我们的代码不需要显式地在内存中销毁对象。然而，垃圾回收器会带来CPU的惩罚。
- en: So there are two factors in play here. We want to conserve two resources here,
    and we'll try to do so using generators to implement lazy evaluation. We don't
    want to allocate memory unnecessarily, and if we can avoid this, then we can avoid
    invoking the garbage collector frequently. In this section, I'll introduce some
    generator concepts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有两个因素在起作用。我们想要节省两种资源，我们将尝试使用生成器来实现延迟评估。我们不希望无谓地分配内存，如果我们能避免这一点，那么我们就可以避免频繁地调用垃圾回收器。在本节中，我将介绍一些生成器概念。
- en: Bookmarking function contexts
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记函数上下文
- en: 'In a normal function call stack, a function returns a value. The `return` statement
    activates a new execution context and discards the old context because we returned,
    so we''re done with it. Generator functions are a special kind of JavaScript function
    denoted with their own syntax, and their call stacks aren''t so cut-and-dried
    compared to `return` statements. Here''s a visualization of what happens when
    a generator function is invoked, and it starts generating values:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的函数调用栈中，一个函数返回一个值。`return`语句激活一个新的执行上下文，并丢弃旧的上下文，因为我们已经返回了，所以我们已经完成了。生成器函数是一种特殊的JavaScript函数，用它们自己的语法表示，它们的调用栈与`return`语句相比并不那么简单明了。以下是调用生成器函数时发生的情况的视觉表示，它开始产生值：
- en: '![Bookmarking function contexts](img/B05133_04_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![标记函数上下文](img/B05133_04_01.jpg)'
- en: Just as the `return` statement passes a value to the calling context, the `yield`
    statement passes a value back. However, unlike a regular function, generator function
    contexts aren't discarded. In fact, they're bookmarked so that when control is
    given back to the generator context, it can pick up where it left off to continue
    yielding values until it's done. This bookmarking data is very insignificant,
    as it just points to a location in our code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`return`语句将值传递给调用上下文一样，`yield`语句将值返回。然而，与普通函数不同，生成器函数上下文不会被丢弃。实际上，它们被标记，以便当控制权返回给生成器上下文时，它可以从中断的地方继续产生值，直到完成。这个标记数据非常微不足道，因为它仅仅指向我们代码中的一个位置。
- en: Sequences instead of arrays
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列而不是数组
- en: In JavaScript, when we need to iterate over a list of things, numbers, strings,
    objects, and so on, we use an array. Arrays are general purpose and powerful.
    The challenge with arrays in the context of lazy evaluation is that arrays themselves
    are data that need to be allocated. So we have the elements within the array that
    need to be allocated somewhere in memory, and we also have metadata about the
    elements in the array.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，当我们需要遍历一系列事物，如数字、字符串、对象等时，我们使用数组。数组是通用且强大的。在延迟评估的上下文中，数组的挑战在于数组本身是需要分配的数据。因此，数组内的元素需要在内存中分配某个位置，我们还需要有关数组中元素元数据。
- en: 'If we''re working with a large number of objects, the memory overhead associated
    with the array is significant. Additionally, we need to somehow put these objects
    in the array. This is an additional step that adds CPU time. An alternative concept
    is a sequence. Sequences aren''t a tangible JavaScript language construct. They''re
    an abstract concept—arrays without actually allocating arrays. Sequences help
    with lazy evaluation. For this exact reason, there''s nothing to allocate, and
    there''s no initial population step. Here''s a visualization of the steps involved
    with iterating over an array:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理大量对象，与数组相关的内存开销是显著的。此外，我们还需要以某种方式将这些对象放入数组中。这是一个额外的步骤，会增加CPU时间。另一种概念是序列。序列并不是一个实际的JavaScript语言结构。它是一个抽象概念——实际上不分配数组的数组。序列有助于延迟评估。正因为如此，没有需要分配的内容，也没有初始填充步骤。以下是迭代数组所涉及的步骤的示意图：
- en: '![Sequences instead of arrays](img/B05133_04_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![用序列代替数组](img/B05133_04_02.jpg)'
- en: 'As we can see, before we can iterate over these three objects, we first have
    to allocate an array, then populate it with these objects. Let''s contrast this
    approach with the conceptual idea of a sequence with the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在我们能够遍历这三个对象之前，我们首先必须分配一个数组，然后填充这些对象。让我们通过以下图表来对比这种方法和序列的概念：
- en: '![Sequences instead of arrays](img/B05133_04_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![用序列代替数组](img/B05133_04_03.jpg)'
- en: With sequences, we don't have an explicit container structure for the objects
    that we're interested in iterating over. The only overhead associated with a sequence
    is the pointer to the current item. We can use generator functions as a mechanism
    for generating sequences in JavaScript. As we saw in the preceding section, generators
    bookmark their execution context when they yield values back to the caller. This
    is the kind of minimal overhead that we're looking for. It enables us to lazily
    evaluate objects and iterate over them as a sequence.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列中，我们没有为我们要迭代的对象提供一个显式的容器结构。与序列相关的唯一开销是当前项的指针。我们可以使用生成器函数作为在JavaScript中生成序列的机制。正如我们在前一节中看到的，生成器在向调用者返回值时，会标记其执行上下文。这正是我们所寻找的最小开销。它使我们能够延迟评估对象，并以序列的形式迭代它们。
- en: Creating generators and yielding values
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建生成器和产生值
- en: In this section, I'll introduce the generator function syntax, and we'll walk
    through yielding values from a generator. We'll also look at the two approaches
    that we can use to iterate over values yielded from generators.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍生成器函数的语法，并带大家了解如何从生成器中产生值。我们还将探讨两种可以用来遍历生成器产生的值的途径。
- en: Generator function syntax
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器函数语法
- en: 'The syntax for generator functions is nearly identical to normal functions.
    The difference in the declaration is that the `function` keyword is followed by
    an asterisk. The more profound difference is the return value, which is always
    a generator instance. Moreover, there''s no need for the `new` keyword, despite
    a new object being created. Let''s take a look at what a generator function looks
    like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数的语法几乎与普通函数相同。声明中的区别在于`function`关键字后面跟着一个星号。更深刻的不同之处在于返回值，它始终是一个生成器实例。此外，尽管创建了一个新对象，但不需要`new`关键字。让我们看看生成器函数的样子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's highly unlikely that we'd ever use generators in this fashion, but it's
    a good way to illustrate the nuances of generator functions. For example, `return`
    statements are perfectly valid within generator functions, and yet, they produce
    a completely different result for the caller, as we can see. In practice, we're
    far more likely to encounter `yield` statements in generators, so let's look at
    them next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎不可能以这种方式使用生成器，但这是一个很好的方式来展示生成器函数的细微差别。例如，`return`语句在生成器函数中是完全有效的，然而，它们对调用者产生了完全不同的结果，正如我们所看到的。在实践中，我们更有可能遇到生成器中的`yield`语句，所以让我们看看它们。
- en: Yielding values
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产生值
- en: 'The common case with generator functions is to yield values and control back
    to the caller. Yielding control back to the caller is a defining characteristic
    of generators. When we yield, the generator bookmarks our position in the code.
    It does this because the caller is likely going to request another value from
    the generator, and when it does, the generator simply picks up where it left off.
    Let''s take a look at a generator function that yields several times:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数的常见情况是产生值并将控制权交还给调用者。将控制权交还给调用者是生成器的定义特征。当我们产生值时，生成器会标记我们的代码位置。它这样做是因为调用者很可能会从生成器请求另一个值，当它这样做时，生成器只需从上次离开的地方继续即可。让我们看看一个多次产生值的生成器函数：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code is what a sequence looks like. We have three values, and they're
    sequentially yielded from our function. They're not put in any kind of container
    structure either. The first call to `yield` passes `first` to `next()`, which
    is where it's used. The same goes for the other two values. In fact, this is lazy
    evaluation in action. We have three calls to `console.log()`. The eager implementation
    of `gen()` would return a collection of values for us to log. Instead, when we
    need to log a value, we go and get it from the generator. This is the laziness
    factor; we conserve our efforts until they're actually required, avoiding allocations
    and computations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了序列的样子。我们有三个值，它们按顺序从我们的函数中产生。它们也没有被放入任何容器结构中。第一次调用`yield`将`first`传递给`next()`，这就是它被使用的地方。对于其他两个值也是同样的情况。实际上，这就是惰性求值的作用。我们有三个`console.log()`调用。`gen()`的急切实现会返回一个值集合供我们记录。相反，当我们需要记录一个值时，我们会去生成器中获取它。这就是惰性因素；我们直到实际需要时才保存我们的努力，避免分配和计算。
- en: The not-so-ideal aspect of our previous example is that we're actually repeating
    calls to `console.log()`, when really, we want to iterate over the sequence, calling
    `console.log()` for each item in it. Let's iterate over some generator sequences
    now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前示例的不太理想之处在于，我们实际上在重复调用`console.log()`，而实际上我们想要迭代序列，为序列中的每个项目调用`console.log()`。现在让我们迭代一些生成器序列。
- en: Iterating over generators
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代生成器
- en: 'The `next()` method gets us, not surprisingly, the next value in the generator
    sequence. The actual value returned by `next()` is an object with two properties:
    the yielded `value` and whether or not the generator is `done`. However, we generally
    don''t want to hard-code our calls to `next()`. Instead, we want to call it iteratively
    as values are yielded from the generator. Here''s an example that uses a `while`
    loop to iterate over a generator:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`方法，不出所料，给我们生成器序列中的下一个值。`next()`实际返回的对象有两个属性：产生的`value`和生成器是否`done`。然而，我们通常不想硬编码我们的`next()`调用。相反，我们希望随着生成器产生值而迭代地调用它。以下是一个使用`while`循环迭代生成器的示例：'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This loop will continue until the `done` property of the yielded item is `true`;
    at this point, we know there aren''t any items, and thus, we can stop. This allows
    us to iterate over a sequence of yielded values without the need to create an
    array for the sole purpose of iterating over it. However, there''s a lot of boilerplate
    code in this loop that has more to do with managing the generator iteration than
    actually iterating over it. Let''s take a look at another approach:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将继续，直到产生的项目的`done`属性为`true`；在这个时候，我们知道没有更多项目了，因此我们可以停止。这允许我们迭代一个产生的值序列，而无需创建一个仅用于迭代的数组。然而，这个循环中有许多样板代码，与生成器迭代的管理比实际迭代更多。让我们看看另一种方法：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is much better. We've condensed our code down into something that's much
    more focused on the task at hand. This code essentially does the exact same thing
    as our `while` loop, except the `for..of` statement, which understands what to
    do when the iterable is a generator. Iterating over generators is a common pattern
    in concurrent JavaScript applications, so optimizing for compact and readable
    code here would be a wise decision.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多。我们已经将代码压缩成更专注于当前任务的东西。这段代码本质上与我们的`while`循环做的是完全相同的事情，除了`for..of`语句，它理解当可迭代对象是生成器时应该做什么。在并发JavaScript应用程序中迭代生成器是一种常见模式，因此在这里优化为紧凑和可读的代码是一个明智的决定。
- en: Infinite sequences
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无穷序列
- en: Some sequences are infinite, prime numbers, Fibonacci numbers, odd numbers,
    and so on. Infinite sequences aren't limited to sets of numbers; more abstract
    notions can be considered infinite. For example, a set of stings that repeats
    itself infinitely, a Boolean value that toggles infinitely, and so on. In this
    section, we'll explore how generators make it possible for us to work with infinite
    sequences.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些序列是无限的，如素数、斐波那契数、奇数等。无穷序列不仅限于数字集合；还可以考虑更抽象的概念为无限。例如，一个无限重复的字符串集合，一个无限切换的布尔值，等等。在本节中，我们将探讨生成器如何使我们能够处理无穷序列。
- en: No end in sight
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无尽头
- en: 'Allocating items from an infinite sequence isn''t practical from a memory consumption
    point of view. In fact, it''s not even possible to allocate the whole sequence—it''s
    infinite. Memory is finite. So, it''s better to simply sidestep the whole allocation
    problem entirely and use a generator to yield the values from the sequence as
    we need them. At any given point in time, our application is only going to use
    a tiny slice of the infinite sequence. Here''s a visualization of what''s used
    from an infinite sequence versus the potential size of these sequences:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从无穷序列中分配项目从内存消耗的角度来看并不实用。事实上，甚至无法分配整个序列——它是无限的。内存是有限的。因此，最好是完全避开整个分配问题，并使用生成器按需生成序列中的值。在任何给定的时间点，我们的应用程序只会使用无穷序列的一小部分。以下是无穷序列的使用与这些序列潜在大小的可视化：
- en: '![No end in sight](img/B05133_04_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![无尽头](img/B05133_04_04.jpg)'
- en: 'As we can see, there are a vast number of items available that we''ll never
    use with this sequence. Let''s take a look at some generator code that lazily
    produces items from an infinite Fibonacci sequence:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有大量的项目可用，但我们永远不会在这个序列中使用。让我们看看一些生成器代码，它可以从无穷大的斐波那契序列中懒加载项目：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Alternating sequences
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交替序列
- en: 'A variation on infinite sequences is either a circular sequence or an alternating
    sequence. These types of sequences are circular when the end is reached; they
    start from the beginning. Here''s what a sequence that alternates between two
    values looks like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无穷序列的变体可以是循环序列或交替序列。当达到序列的末尾时，这些类型的序列是循环的；它们从开始处重新开始。以下是一个在两个值之间交替的序列的示例：
- en: '![Alternating sequences](img/B05133_04_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![交替序列](img/B05133_04_05.jpg)'
- en: 'These types of sequences will continue to generate values infinitely. This
    becomes useful when we have a set of rules that determine how the sequence is
    defined and the set of items that''s generated; then, we start this set all over
    again. Now, let''s look at some code to see the implementation of these sequences
    using generators. Here''s a generic generator function that we can use to alternate
    between values:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的序列将无限期地生成值。当我们有一组规则来定义序列以及生成的项目集合时，这很有用；然后，我们再次从头开始这个集合。现在，让我们看看一些代码，看看如何使用生成器实现这些序列。以下是一个通用的生成器函数，我们可以用它来在值之间交替：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the first time we''ve declared a generator function that accepts arguments.
    In fact, we''re using the spread operator to iterate over arguments passed to
    the function. Unlike arguments, the `seq` argument that we''ve created using the
    spread operator is a real array. As we iterate over this array, we yield each
    item from the generator. This may not seem all that useful at first glance, but
    it''s the `while` loop that adds the real power here. Since the `while` loop will
    never exit, the `for` loop will simply repeat itself. That is, it''ll alternate.
    This negates the need for explicit bookkeeping code (Have we reached the end of
    the sequence? How do we reset the counter and move back to the beginning? And
    so on) Let''s see how this generator function works:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次声明一个接受参数的生成器函数。实际上，我们正在使用扩展运算符来遍历传递给函数的参数。与参数不同，我们使用扩展运算符创建的`seq`参数是一个真正的数组。当我们遍历这个数组时，我们从生成器中产生每个项目。乍一看，这可能并不那么有用，但正是`while`循环在这里增加了真正的力量。由于`while`循环永远不会退出，`for`循环将简单地重复自己。也就是说，它会交替。这消除了显式记账代码的需要（我们是否到达了序列的末尾？我们如何重置计数器并回到开始？等等）让我们看看这个生成器函数是如何工作的：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Cool. So the `alternator` will continue to generate `true`/`false` values as
    long as we continue to ask for them. The main benefit here is that we don''t need
    to know about the next value, `alternator` takes care of this for us. Let''s look
    at this generator function with a different sequence to iterate over:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷。所以`alternator`将一直生成`true`/`false`值，只要我们继续请求它们。这里的主要好处是我们不需要知道下一个值，`alternator`会为我们处理这个问题。让我们看看这个生成器函数，它使用不同的序列进行迭代：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, the `alternate()` function comes in handy for alternating between
    any arguments passed to it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`alternate()`函数在交替传递给它的任何参数时非常有用。
- en: Deferring to other generators
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托给其他生成器
- en: We've seen how the `yield` statement is able to pause the execution context
    of a `generator` function, and yield a value back to the calling context. There's
    a variation on the `yield` statement that allows us to defer to other `generator`
    functions. Another technique involves creating a mesh of generators by interweaving
    several generator sources together. In this section, we'll explore both of these
    ideas.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`yield`语句能够暂停`生成器`函数的执行上下文，并将值返回到调用上下文。`yield`语句有一个变体，允许我们委托给其他`生成器`函数。另一种技术是通过交织几个生成器源来创建一个生成器网格。在本节中，我们将探讨这两个想法。
- en: Selecting a strategy
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择策略
- en: 'Deferring to other generators gives our functions the ability to decide at
    run-time, to hand off control from one generator to another. In other words, it
    allows the selection of a more appropriate generator function based on a strategy.
    Here''s a visualization of a generator function that makes a decision and defers
    to one of several other generator functions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 委托给其他生成器使我们的函数能够在运行时决定，将控制权从一个生成器传递给另一个生成器。换句话说，它允许根据策略选择更合适的生成器函数。以下是一个生成器函数的视觉表示，该函数做出决定并委托给几个其他生成器函数之一：
- en: '![Selecting a strategy](img/B05133_04_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![选择策略](img/B05133_04_06.jpg)'
- en: What we have here are three specialized generators that we would like to use
    throughout our application. That is, they each work in their own unique way. Perhaps,
    they're tailored for specific types of inputs. However, these generators simply
    make assumptions about the input that they're given. It may not be the best tool
    for the job, and so, we have to figure out which of these generators to use. What
    we want to avoid is having to implement this strategy selection code all over
    the place. It would be nice if we were able to encapsulate all of this into a
    general purpose generator that captures common cases throughout our code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有三个专门的生成器，我们希望在应用程序的各个地方使用它们。也就是说，它们各自以独特的方式工作。也许，它们是为特定类型的输入量身定制的。然而，这些生成器只是对它们所提供的输入做出假设。这可能不是最佳工具，因此，我们必须弄清楚使用哪个生成器。我们想要避免的是在各个地方实现这个策略选择代码。如果能够将所有这些封装到一个通用目的的生成器中，该生成器可以捕捉到代码中的常见情况，那就太好了。
- en: 'Let''s say that we have the following generator functions, and they''re equally
    used throughout our application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下生成器函数，并且它们在我们的整个应用程序中都被同等使用：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These are small and concise functions, and they are easy to use wherever we
    need them. The trouble is that each of these functions make assumptions about
    the collection that''s passed in. Is it an array of objects, each with a specific
    property? Is it an array of strings? Is it an object instead of an array? Since
    these generator functions are commonly used throughout our code for a similar
    purpose, we can implement a more generic iterator, who''s job is to determine
    the best generator function to use, and then to defer to it. Let''s see what this
    function looks like:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数都是小而简洁的，并且它们在需要的地方很容易使用。问题是每个这些函数都对传入的集合做出了假设。它是对象的数组，每个对象都有特定的属性吗？它是字符串数组吗？它是一个对象而不是数组吗？由于这些生成器函数在我们的代码中用于类似的目的，并且经常被使用，我们可以实现一个更通用的迭代器，其任务是确定使用哪个最佳生成器函数，然后将其委托给它。让我们看看这个函数是什么样子：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Think of the `iterateNames()` function as a simple proxy for any one of the
    other three generators. It examines the input and makes a selection based on the
    collection. We could have implemented one large generator function, but that would
    preclude us from use cases where we want to use the smaller generators directly.
    What if we want to use them to compose new functionality, or if another composite
    generator wants to use it? It's always a good idea to keep generator functions
    small and focused. The `yield*` syntax allows us to handoff control to a more
    suitable generator.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将`iterateNames()`函数视为其他三个生成器中的任何一个的简单代理。它检查输入并根据集合做出选择。我们本可以实施一个大的生成器函数，但那样会阻止我们在需要直接使用较小生成器的情况下使用。如果我们想将它们用于组合新功能，或者如果另一个组合生成器想使用它怎么办？始终保持生成器函数小而专注是一个好主意。`yield*`语法允许我们将控制权传递给更合适的生成器。
- en: 'Now, let''s see how this general purpose generator function is put to use by
    deferring to generators that are best equipped to handle the data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个通用生成器函数是如何通过委托给最适合处理数据的生成器来使用的：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Interweaving generators
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交织生成器
- en: When a generator defers to another generator, control isn't handed back to the
    first generator until the second generator is completely finished. In the preceding
    example, our generator simply looked for a better generator to carry out the work.
    However, there will be other times when we'll have two or more data sources that
    we want to use together. So, instead of handing off control to one generator,
    then to another and so on, we would alternate between the various sources, taking
    turns consuming data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个生成器委托给另一个生成器时，控制权不会在第二个生成器完全完成后交还给第一个生成器。在前面的例子中，我们的生成器只是寻找一个更好的生成器来完成工作。然而，在其他时候，我们可能想要使用两个或更多数据源。因此，而不是将控制权传递给一个生成器，然后传递给另一个，如此类推，我们将交替使用各种来源，轮流消耗数据。
- en: 'Here''s a diagram that illustrates the idea of a generator that interweaves
    multiple data sources to create a single data source:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个图解，说明了将多个数据源交织在一起以创建单个数据源的生成器概念：
- en: '![Interweaving generators](img/B05133_04_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![交织生成器](img/B05133_04_07.jpg)'
- en: 'The idea is to round-robin the data sources, rather than to empty one source,
    then another, and so on. A generator like this is handy when there isn''t a single
    large collection for us to work with, but instead, two or more collections. Using
    this generator technique, we can actually treat multiple data sources as though
    they were one big source, but without having to allocate the memory for a large
    structure. Let''s look at the following code example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是轮询数据源，而不是清空一个源，然后另一个，如此类推。当没有单个大型集合供我们工作时，这种生成器非常有用，而是有两个或更多集合。使用这种生成器技术，我们实际上可以将多个数据源视为一个大型源，而无需为大型结构分配内存。让我们看看以下代码示例：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Passing data to generators
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据传递给生成器
- en: The `yield` statement doesn't just yield control back to the caller, it also
    returns a value. This value is passed to the generator function through the `next()`
    method. This is how we pass data into generators after they've been created. In
    this section, we'll address the bidirectional aspect of generators, and how creating
    feedback loops can produce some lean code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`语句不仅将控制权交还给调用者，还返回一个值。这个值通过`next()`方法传递给生成器函数。这就是我们在生成器创建后如何将数据传递给生成器的方式。在本节中，我们将讨论生成器的双向特性，以及创建反馈循环可以产生一些简洁的代码。'
- en: Reusing generators
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复使用生成器
- en: Some generators are general purpose and used frequently throughout our code.
    This being the case, does it make sense to constantly create and destroy these
    generator instances? Or can we reuse them? For instance, consider a sequence that's
    mainly dependent on initial conditions. Let's say we want to generate a sequence
    of even numbers. We would start at two, and as we iterate over this generator,
    the value would be incremented. The next time we want to iterate over even numbers,
    we would have to create a new generator.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成器是通用型的，并在我们的代码中频繁使用。在这种情况下，我们是否需要不断地创建和销毁这些生成器实例？或者我们可以重用它们？例如，考虑一个主要依赖于初始条件的序列。假设我们想要生成一个偶数序列。我们会从2开始，当我们遍历这个生成器时，值会增加。下次我们想要遍历偶数时，我们必须创建一个新的生成器。
- en: This is kind of wasteful, since all we're doing is resetting a counter. What
    if we took a different approach, one that would allow us to keep on using the
    same generator instance for these types of sequences? The `next()` method of generators
    is a possible implementation path for this capability. We could pass it a value,
    which would then reset our counter. So instead of having to create a new generator
    instance every time we need to iterate over even numbers, we can simply call `next()`
    with a value that resets the initial conditions of our generator.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点浪费，因为我们所做的只是重置一个计数器。如果我们采取不同的方法，一种可以让我们继续使用相同的生成器实例来处理这些类型的序列的方法会怎样？生成器的`next()`方法是实现这种功能的可能途径之一。我们可以传递一个值，然后重置我们的计数器。因此，每次我们需要遍历偶数时，我们不必创建一个新的生成器实例，只需用重置生成器初始条件的值调用`next()`即可。
- en: The `yield` keyword actually returns a value—the argument that's passed to `next()`.
    Most of the time, this is undefined, such as when the generator is iterated over
    in a `for..of` loop. However, this is how we're able to pass arguments to the
    generator after it starts running. This is not the same thing as passing arguments
    to the generator function, which comes in handy for doing the initial configuration
    of the generator. Values passed to `next()` are how we talk to the generator when
    we need to change something for the next value that's to be generated.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`yield`关键字返回一个值——传递给`next()`的参数。大多数情况下，这是未定义的，例如当生成器在`for..of`循环中迭代时。然而，这就是我们能够在生成器开始运行后传递参数给生成器的方式。这与传递参数给生成器函数不同，这对于生成器的初始配置很有用。传递给`next()`的值是我们需要更改下一个要生成的值时与生成器交流的方式。
- en: 'Let''s take a look at how we can use the `next()` method to create a reusable
    even number sequence generator:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何可以使用`next()`方法创建一个可重用的偶数序列生成器：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In case you're wondering why we're not using a `for..of` loop in the favor of
    a `while` loop, it's because you use a `for..of` loop to iterate over a generator.
    When you do so, the generator gets marked as *done* as soon as the loop exits.
    Hence, it would no longer be usable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我们不使用`for..of`循环而使用`while`循环，那是因为你使用`for..of`循环来遍历生成器。当你这样做时，一旦循环退出，生成器就会被标记为*完成*。因此，它将不再可用。
- en: Lightweight map/reduce
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轻量级map/reduce
- en: Something else we can do with the `next()` method is map one value to another.
    For example, let's say we had a collection containing seven items. To map these
    items, we would iterate over the collection, passing each item to `next()`. As
    we saw in the preceding section, this method can reset the state of a generator,
    but it can also be used to supply a stream of input data, just as it supplies
    a stream of output data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`next()`方法将一个值映射到另一个值。例如，假设我们有一个包含七个项目的集合。为了映射这些项目，我们会遍历这个集合，将每个项目传递给`next()`。正如我们在前面的部分中看到的，这种方法可以重置生成器的状态，但它也可以用来提供输入数据流，就像它提供输出数据流一样。
- en: 'Let''s see if we can write some code that does this—map collection items by
    feeding them into a generator through `next()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是否可以编写一些代码来实现这一点——通过将集合项目通过`next()`馈入生成器来映射集合项目：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, this is indeed possible. We're able to perform a lightweight
    map/reduce job using this approach. The mapper generator has the `iteratee` function
    that's applied to every item in the collection. As we iterate over the array,
    we're able to feed items into the generator by passing them to the `next()`method
    as an argument.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这确实可行。我们可以使用这种方法执行轻量级的map/reduce作业。映射生成器具有应用于集合中每个项目的`iteratee`函数。当我们遍历数组时，我们可以通过将它们作为参数传递给`next()`方法来将这些项目馈入生成器。
- en: But, there's something about the previous method that just doesn't feel optimal—having
    to bootstrap the generator like this, and explicitly calling `next()`for every
    iteration feels clunky. In fact, could we not apply the `iteratee` function directly,
    instead of calling `next()`? It's these things that we need to be on the lookout
    while using generators; in particular, when passing data to generators. Just because
    we're able to, doesn't mean that it's a good idea.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，关于之前的方法，总感觉它并不那么优化——需要这样启动生成器，并且每次迭代都要显式调用`next()`，感觉有点笨拙。实际上，我们能否直接应用`iteratee`函数，而不是调用`next()`呢？在使用生成器时，我们需要留意这些事情；特别是在向生成器传递数据时。仅仅因为我们能够这样做，并不意味着这是一个好主意。
- en: 'Mapping and reducing would probably feel more natural, if we were to simply
    iterate over the generator just as we do with all other generators. We still want
    the lightweight mapping that generators give us, to, avoid the memory allocations.
    Let''s try a different approach here—one that doesn''t require the `next()` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像对待其他所有生成器一样简单地迭代生成器，映射和归约可能会感觉更自然。我们仍然想要生成器提供的轻量级映射，以避免内存分配。让我们尝试一种不同的方法——一种不需要`next()`方法的方法：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This looks like an improvement. There's less code, and the flow of the generator
    is easy to grok. The difference is that we pass our array and `iteratee` function
    to the generator up front. Then, as we iterate over the generator, each item gets
    mapped lazily. The code that reduces this array into an object is simpler to read
    too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个改进。代码更少，生成器的流程也更容易理解。区别在于我们提前将数组和我们自己的`iteratee`函数传递给生成器。然后，当我们迭代生成器时，每个项目都会被惰性地映射。将这个数组归约成一个对象的代码也更容易阅读。
- en: The `genMap()` function that we've just implemented is generic, which is advantageous
    to us. In real applications, mappings are going to be more complex than an uppercase
    transformation. More likely, there will be multiple levels of mappings. That is,
    we map the collection, then map it N more times before reducing it. If we've done
    a good job designing our code, then we'll want to compose generators out of smaller
    iterated functions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现的`genMap()`函数是通用的，这对我们来说是有利的。在实际应用中，映射将比大写转换更复杂。更有可能的是，会有多个映射级别。也就是说，我们映射集合，然后映射它N次，然后再进行归约。如果我们已经很好地设计了我们的代码，那么我们将想要将较小的迭代函数组合成生成器。
- en: 'But how can we keep this generic and lazy? The idea is to have several generators,
    each serving as the input to the next. This means that as our reducer code iterates
    over these generators, only one item makes it''s way through the various layers
    of mappings, to the reduction code. Let''s take a stab at implementing this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何保持这种通用性和惰性呢？想法是拥有几个生成器，每个生成器都作为下一个生成器的输入。这意味着当我们的归约代码迭代这些生成器时，只有一个项目会通过映射的各个层次，到达归约代码。让我们尝试实现这一点：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Coroutines
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: Coroutines are a concurrency technique that allow for cooperative multitasking.
    What this means is that if one part of our application needs to perform part of
    a task, it can do so, and then hand control off to another part of the application.
    Think about a subroutine, or in more recent times, a function. These subroutines
    often rely on other subroutines. However, they don't just run in succession, they
    cooperate with one another.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种并发技术，允许协作式多任务处理。这意味着如果我们的应用程序的某个部分需要执行任务的一部分，它可以这样做，然后将控制权交给应用程序的另一个部分。想想子程序，或者更近期的函数。这些子程序通常依赖于其他子程序。然而，它们并不是依次运行，而是相互协作。
- en: In JavaScript, there's no intrinsic coroutine mechanism. Generators aren't coroutines,
    but they have similar properties. For example, generators can pause the execution
    of a function, yielding control to another context, then regain control and resume.
    This gets us partway there, but generators are for generating values, which isn't
    necessarily what we're after with coroutines. In this section, we'll look at some
    techniques for implementing coroutines in JavaScript using generators.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，没有内建的协程机制。生成器不是协程，但它们有相似的性质。例如，生成器可以暂停函数的执行，将控制权交给另一个上下文，然后重新获得控制权并继续执行。这让我们前进了一步，但生成器是用来生成值的，这并不一定是协程的目标。在本节中，我们将探讨一些使用生成器在JavaScript中实现协程的技术。
- en: Creating coroutine functions
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建协程函数
- en: 'Generators give us most of what we need to implement `coroutine` functions
    in JavaScript; they can pause and resume executing. We just need to implement
    some minor abstractions around generators so that the functions that we''re working
    with actually feel like calling `coroutine` functions, instead of iterating over
    generators. Here''s a rough illustration of how we want our coroutines to behave
    when called:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器为我们提供了在JavaScript中实现`coroutine`函数所需的大部分功能；它们可以暂停和恢复执行。我们只需要在生成器周围实现一些小的抽象，这样我们正在处理的函数就会感觉像是调用`coroutine`函数，而不是迭代生成器。以下是我们希望我们的协程在调用时表现的大致示例：
- en: '![Creating coroutine functions](img/B05133_04_08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![创建协程函数](img/B05133_04_08.jpg)'
- en: 'The idea is that invoking the `coroutine` function moves from one `yield` statement
    to the next. And we can supply input to the coroutine by passing an argument,
    which is then returned by the `yield` statement. This is a lot to remember, so
    let''s generalize these coroutine concepts in a function wrapper:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是调用`coroutine`函数会从一个`yield`语句移动到下一个。我们可以通过传递一个参数来向协程提供输入，然后该参数由`yield`语句返回。这有很多东西需要记住，所以让我们在函数包装器中概括这些协程概念：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Pretty simple—five lines of code, but it''s also powerful. The function returned
    by Harold''s wrapper simply advances the generator to the next `yield` statement,
    supplying the argument to `next()`, if one was provided. It''s one thing to make
    claims of utility, but let''s actually use this thing to make a `coroutine` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单——只有五行代码，但功能强大。Harold的包装函数返回的函数只是将生成器推进到下一个`yield`语句，如果提供了参数，则将其提供给`next()`。声称有用是一回事，但让我们实际使用这个工具来创建一个`coroutine`函数：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When there are a series of steps involved with fulfilling some task, we typically
    require bookkeeping code, temporary values, and so on. These aren't necessary
    with coroutines because the function simply pauses, leaving any local state intact.
    In other words, there's no need to intertwine concurrency logic with our application
    logic when coroutines do a decent job of hiding these details for us.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到一系列步骤来完成某个任务时，我们通常需要记账代码、临时值等等。但在协程中这些都不是必需的，因为函数只是暂停，保留任何局部状态不变。换句话说，当协程能够很好地为我们隐藏这些细节时，我们不需要将并发逻辑与我们的应用逻辑交织在一起。
- en: Handling DOM events
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理DOM事件
- en: Somewhere else where we can use coroutines is with the DOM as event handlers.
    This works by adding the same `coroutine()` function as an event listener to several
    elements. Let's recall that each call to these coroutine functions talks to a
    single generator. This means that our coroutines that are setup to handle DOM
    events get passed in as a stream. It's almost like we're iterating over these
    events.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在DOM事件处理程序中使用协程。这是通过将相同的`coroutine()`函数作为事件监听器添加到多个元素上实现的。让我们回顾一下，对这些协程函数的每次调用都对应一个单独的生成器。这意味着我们设置来处理DOM事件的协程被作为流传递。这几乎就像我们正在迭代这些事件。
- en: 'Since these `coroutine` functions use the same generator, it''s easy for elements
    to talk to one another using this technique. The typical approach to DOM events
    involves callback functions that talk to some sort of central source that''s shared
    among elements and maintains state. With coroutines, the state of element communications
    is implicit inside our function code. Let''s use our coroutine wrapper in the
    context of DOM event handlers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些`coroutine`函数使用相同的生成器，元素之间使用这种技术进行通信变得很容易。处理DOM事件的典型方法涉及回调函数，这些函数与某种中央源进行通信，该源在元素之间共享并维护状态。使用协程，元素通信的状态隐含在我们的函数代码中。让我们在DOM事件处理程序的上下文中使用我们的协程包装器：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Handling promised values
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理承诺值
- en: In the preceding section, we saw how the `coroutine()` function can be used
    to process DOM events. Instead of haphazardly adding callback functions that respond
    to DOM events, we use the same `coroutine()` function, which treats events as
    a stream of data. It's easier for DOM event handlers to cooperate with one another
    since they share the same generator context.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用`coroutine()`函数来处理DOM事件。我们不是随意添加响应DOM事件的回调函数，而是使用相同的`coroutine()`函数，它将事件视为数据流。由于它们共享相同的生成器上下文，DOM事件处理程序之间的协作变得更加容易。
- en: 'We can apply this same principle to `then()` callbacks of promises, which works
    in a similar way to the DOM coroutine approach. Instead of passing a regular function,
    we pass a coroutine to `then()`. When the promise resolves, the `coroutine` advances
    to the next `yield` statement along with a resolved value. Let''s take a look
    at the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将同样的原则应用到promise的`then()`回调中，这与DOM协程方法类似。我们不是传递一个常规函数，而是将协程传递给`then()`。当promise解决时，`coroutine`会随着解决值一起前进到下一个`yield`语句。让我们看一下以下代码：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is very useful because it provides something that static promise methods
    do not. The `Promise.all()` method forces us to wait for all the promises to resolve
    before resolving the returned promise. However, in the case where the resolved
    promise values aren't dependent on one another, we can simply iterate over them,
    responding as they resolve in any order.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，因为它提供了一些静态promise方法所不具备的东西。`Promise.all()`方法强制我们等待所有promise解决后，才解决返回的promise。然而，在解决promise值之间没有相互依赖的情况下，我们可以简单地遍历它们，以它们解决的任何顺序做出响应。
- en: We can achieve something similar by attaching plain functions to `then()` as
    callbacks, but then, we wouldn't have a shared context for promise values as they
    resolve. Another tactic we can adopt by combining promises with coroutines is
    to declare a handful of coroutines that respond differently, depending on the
    type of data they're responding to. These coroutines would then live on throughout
    the entire duration of the application, being passed to promises as they get created.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将普通函数附加到`then()`作为回调来实现类似的效果，但那样的话，我们就没有一个共享的上下文来处理解决时的promise值。另一种我们可以采用的方法是将promise与协程结合使用，声明一些响应不同，取决于它们响应的数据类型的协程。然后，这些协程将在整个应用期间存在，当它们被创建时，会传递给promise。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the concept of generators, a new construct as
    of ES6, which allow us to implement lazy evaluation. Generators help us realize
    the conserve concurrency principle because we can avoid computations and intermediary
    memory allocations. There are a few new syntax forms associated with generators.
    First, there's the generator function, which always returns a generator instance.
    These are declared differently than regular functions. These functions are responsible
    for generating values, which rely on the `yield` keyword.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了生成器的概念，这是ES6中的一种新结构，它允许我们实现惰性求值。生成器帮助我们实现节省并发原则，因为我们能够避免计算和中间内存分配。与生成器相关联有一些新的语法形式。首先，是生成器函数，它总是返回一个生成器实例。这些函数的声明方式与常规函数不同。这些函数负责生成值，这依赖于`yield`关键字。
- en: We then explored more advanced generator and lazy evaluation topics, including
    deferring to other generators, implementing map/reduce functionality, and passing
    data into generators. We closed the chapter with a look at how to use generators
    to make coroutine functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后探讨了更高级的生成器和惰性求值主题，包括委派给其他生成器、实现map/reduce功能以及将数据传递到生成器中。我们以如何使用生成器创建协程函数来结束本章。
- en: In the following chapter, we'll look at web workers—our first glimpse at utilizing
    parallelism in the browser environment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Web Workers——这是我们在浏览器环境中首次接触利用并行性的方法。
