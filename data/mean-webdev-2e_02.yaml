- en: Chapter 2. Getting Started with Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。开始使用Node.js
- en: 'In the previous chapter, you set up your environment and discovered the basic
    development principles of Node.js. This chapter will cover the proper way of building
    your first Node.js web application. You''ll go through the basics of JavaScript
    event-driven nature and how to utilize it to build Node.js applications. You''ll
    also learn about the Node.js module system and how to build your first Node.js
    web application. You''ll then proceed to the Connect module and learn about its
    powerful middleware approach. By the end of this chapter, you''ll know how to
    use Connect and Node.js to build simple yet powerful web applications. In this
    chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您设置了您的环境并发现了Node.js的基本开发原则。本章将介绍构建您的第一个Node.js Web应用程序的正确方法。您将学习JavaScript事件驱动的基础知识以及如何利用它来构建Node.js应用程序。您还将了解Node.js模块系统以及如何构建您的第一个Node.js
    Web应用程序。然后，您将继续学习Connect模块，并了解其强大的中间件方法。在本章结束时，您将知道如何使用Connect和Node.js构建简单而强大的Web应用程序。在本章中，我们将涵盖以下主题：
- en: Introduction to Node.js
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js介绍
- en: JavaScript closures and event-driven programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript闭包和事件驱动编程
- en: Node.js event-driven web development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js事件驱动的Web开发
- en: CommonJS modules and the Node.js module system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS模块和Node.js模块系统
- en: Introduction to the Connect web framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Connect Web框架介绍
- en: Connect's middleware pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Connect的中间件模式
- en: Introduction to Node.js
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js介绍
- en: At JSConf EU 2009, a developer named Ryan Dahl went onstage to present his project
    named Node.js. Starting in 2008, Dahl looked at the current web trends and discovered
    something odd in the way web applications worked. The introduction of the **Asynchronous
    JavaScript and XML** (**AJAX**) technology a few years earlier transformed static
    websites into dynamic web applications, but the fundamental building block of
    web development didn't follow this trend.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在2009年的JSConf EU上，一位名叫Ryan Dahl的开发人员上台介绍了他的项目Node.js。从2008年开始，Dahl研究了当前的Web趋势，并发现了Web应用程序工作方式的一些奇怪之处。几年前引入的**异步JavaScript和XML**（**AJAX**）技术将静态网站转变为动态Web应用程序，但Web开发的基本构建块并没有遵循这一趋势。
- en: The problem was that web technologies didn't support two-way communication between
    the browser and the server. The test case he used was the Flickr upload file feature,
    where the browser was unable to know when to update the progress bar as the server
    could not inform it of how much of the file was uploaded.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于Web技术不支持浏览器和服务器之间的双向通信。他使用的测试案例是Flickr上传文件功能，浏览器无法知道何时更新进度条，因为服务器无法告知它已上传文件的多少。
- en: Dahl's idea was to build a web platform that would gracefully support the push
    of data from the server to the browser, but it wasn't that simple. When scaling
    to common web usage, the platform had to support hundreds (and sometimes thousands)
    of ongoing connections between the server and the browser. Most web platforms
    used expensive threads to handle requests, which meant keeping a fair amount of
    idle threads in order to keep the connection alive. So, Dahl used a different
    approach. He understood that using non-blocking sockets could save a lot in terms
    of system resources and went as far as proving that this could be done using C.
    Given that this technique could be implemented in any programming language and
    the fact that Dahl thought working with non-blocking C code was a tedious task,
    he decided to look for a better programming language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Dahl的想法是构建一个Web平台，能够从服务器优雅地支持向浏览器推送数据，但这并不简单。当扩展到常见的Web使用时，该平台必须支持服务器和浏览器之间数百（有时甚至数千）个正在进行的连接。大多数Web平台使用昂贵的线程来处理请求，这意味着要保持相当数量的空闲线程以保持连接活动。因此，Dahl采用了不同的方法。他意识到使用非阻塞套接字可以在系统资源方面节省很多，并且证明了这可以通过C来实现。鉴于这种技术可以在任何编程语言中实现，以及Dahl认为使用非阻塞C代码是一项繁琐的任务，他决定寻找一种更好的编程语言。
- en: 'When Google announced Chrome and its new V8 JavaScript engine in late 2008,
    it was obvious that JavaScript could run faster than before—a lot faster. V8''s
    greatest advantage over other JavaScript engines was the compiling of JavaScript
    code to native machine code before executing it. This and other optimizations
    made JavaScript a viable programming language capable of executing complex tasks.
    Dahl noticed this and decided to try a new idea: non-blocking sockets in JavaScript.
    He took the V8 engine, wrapped it with the already solid C code, and created the
    first version of Node.js.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当谷歌在2008年底宣布推出Chrome及其新的V8 JavaScript引擎时，很明显JavaScript可以比以前运行得更快 - 快得多。 V8引擎相对于其他JavaScript引擎的最大优势是在执行之前将JavaScript代码编译为本机机器代码。这和其他优化使JavaScript成为一种能够执行复杂任务的可行编程语言。
    Dahl注意到了这一点，并决定尝试一个新的想法：在JavaScript中使用非阻塞套接字。他拿了V8引擎，用已经稳固的C代码包装起来，创建了Node.js的第一个版本。
- en: After a very warm response from the community, he went on to expand the Node
    core. The V8 engine wasn't built to run in a server environment, so Node.js had
    to extend it in a way that made more sense in a server context. For example, browsers
    don't usually need access to the filesystem, but when running server code, this
    becomes essential. The result was that Node.js wasn't just a JavaScript execution
    engine, but a platform capable of running complex JavaScript applications that
    were simple to code, highly efficient, and easily scalable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在社区的热烈反响之后，他继续扩展了Node核心。 V8引擎并不是为了在服务器环境中运行而构建的，因此Node.js必须以一种在服务器上更有意义的方式来扩展它。例如，浏览器通常不需要访问文件系统，但在运行服务器代码时，这变得至关重要。结果是Node.js不仅仅是一个JavaScript执行引擎，而是一个能够运行简单编码、高效且易于扩展的复杂JavaScript应用程序的平台。
- en: io.js and the Node.js foundation
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: io.js和Node.js基金会
- en: By the end of 2014, a conflict rose between Joyent, the company that owns the
    Node.js assets, and a group of core contributors to the project. This group of
    developers felt that the governance of the project was lacking, so they requested
    Joyent create a non-profit foundation that will govern the project. In January
    2015, the group decided to fork the Node.js project and call it io.js. The new
    project aimed for faster and more predictable release cycles and was starting
    to gain some traction.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到2014年底，Joyent公司，拥有Node.js资产的公司，与项目的一些核心贡献者之间产生了冲突。这些开发人员认为项目的治理不足，因此他们要求Joyent创建一个非营利基金会来管理该项目。2015年1月，该团队决定分叉Node.js项目，并将其称为io.js。新项目旨在实现更快和更可预测的发布周期，并开始获得一些关注。
- en: A few months later, the io.js team, backed by companies and community developers,
    was invited to Joyent's offices to discuss the future of the project. Together,
    they agreed on creating a Node foundation led by a Technical Steering Committee,
    merged the projects under the Node.js brand, and based it on the io.js repository.
    This led to a big upgrade in Node's release cycles and a more transparent governance
    of the project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月后，io.js团队得到公司和社区开发者的支持，受邀到Joyent的办公室讨论项目的未来。他们一起决定创建一个由技术指导委员会领导的Node基金会，将项目合并为Node.js品牌，并基于io.js存储库。这导致了Node发布周期的大幅升级和项目治理的更加透明。
- en: Node.js ES6 support
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js ES6支持
- en: 'Although Node.js already implemented partial ES6 support in older versions,
    latest versions have been showing better progress in implementing ES6 features.
    For stability reasons, the Node V8 engine implements ES6 features in three classifications:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Node.js在旧版本中已经实现了部分ES6支持，但最新版本在实现ES6功能方面取得了更好的进展。出于稳定性原因，Node V8引擎将ES6功能分为三个分类：
- en: '**Shipping**: All features that are considered stable and are turned on by
    default. This means that they will *not* require any type of runtime flag to be
    activated.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shipping**：所有被认为是稳定的功能并且默认开启。这意味着它们*不*需要任何运行时标志来激活。'
- en: '**Staged**: All features that are almost stable and are not recommended for
    production usage. These features can be activated using the `--es_staging` runtime
    flag or its better-known synonym, the `--harmony` flag.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Staged**：几乎稳定但不建议在生产中使用的所有功能。这些功能可以使用`--es_staging`运行时标志或其更为常见的同义词`--harmony`标志来激活。'
- en: '**In progress**: All features that are still under work and are not stable.
    These features can be activated using their respective `--harmony` flags.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**In progress**：所有仍在进行中且不稳定的功能。这些功能可以使用它们各自的`--harmony`标志来激活。'
- en: While it is outside of this book's scope, it is recommend that you visit the
    official documentation at [https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/)
    to learn more about ES6 implementation in Node.js.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这超出了本书的范围，但建议您访问官方文档[https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/)，了解更多关于Node.js中ES6实现的信息。
- en: Node.js LTS support
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js LTS支持
- en: As the Node.js community grew bigger, companies and larger organizations joined
    in, leading to a rising demand for stability and predictable version releases.
    In response to these new needs, the Node.js Foundation decided on a new release
    cycle. Basically, the team releases a new stable version every year in October.
    This version will always have an even version number such as v4 or v6\. These
    stable versions are supported by the LTS plan. It includes security and stability
    updates and can be used in production once they enter the LTS plan in October.
    Every April, a stable version release is cut from the LTS plan. It means that
    there are always two active stable versions that overlap for a maximum period
    of 6 months and that every stable version is covered for 18 months. Odd number
    versions are considered not stable and are mainly used to present the community
    with an implementation of the road map. These versions are cut in October so that
    they can be merged to the new stable version in time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Node.js社区的不断壮大，越来越多的公司和大型组织加入进来，导致对稳定性和可预测版本发布的需求不断增加。为了满足这些新需求，Node.js基金会决定了一个新的发布周期。基本上，团队每年10月发布一个新的稳定版本。这个版本总是有一个偶数版本号，比如v4或v6。这些稳定版本受LTS计划支持。它包括安全和稳定更新，并且一旦它们在10月进入LTS计划，就可以在生产中使用。每年4月，一个稳定版本从LTS计划中发布。这意味着总是有两个重叠的稳定版本，最长为6个月，每个稳定版本都有18个月的支持。奇数版本被认为不稳定，主要用于向社区展示路线图的实现。这些版本在10月份被切割，以便及时合并到新的稳定版本中。
- en: 'A simple roadmap for the following few years'' release cycle is shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是未来几年发布周期的简单路线图：
- en: '![Node.js LTS support](img/B05071_02_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js LTS support](img/B05071_02_01.jpg)'
- en: JavaScript event-driven programming
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript事件驱动编程
- en: Node.js uses the event-driven nature of JavaScript to support non-blocking operations
    in the platform, a feature that enables its excellent efficiency. JavaScript is
    an event-driven language, which means that you register code to specific events,
    and this code will be executed once the event is emitted. This concept allows
    you to seamlessly execute asynchronous code without blocking the rest of the program
    from running.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js利用JavaScript的事件驱动特性来支持平台中的非阻塞操作，这一特性使其具有出色的效率。JavaScript是一种事件驱动的语言，这意味着您可以将代码注册到特定的事件上，一旦事件被触发，这些代码就会被执行。这个概念允许您无缝地执行异步代码，而不会阻止程序的其余部分运行。
- en: 'To understand this better, take a look at the following Java code example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，看一下以下的Java代码示例：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the program executes the first and second lines, but any code
    after the second line will not be executed until the user inputs their name. This
    is synchronous programming, where I/O operations block the rest of the program
    from running. However, this is not how JavaScript works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序执行第一行和第二行，但在第二行之后的任何代码都不会被执行，直到用户输入他们的名字。这是同步编程，其中I/O操作阻止程序的其余部分运行。然而，这不是JavaScript的工作方式。
- en: 'As it was originally written to support browser operations, JavaScript was
    designed around browser events. Even though it has vastly evolved since its early
    days, the idea was to allow the browser to take the HTML user events and delegate
    them to JavaScript code. Let''s have a look at the following HTML example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最初设计用于支持浏览器操作，JavaScript围绕浏览器事件进行了设计。尽管它自早期以来已经大大发展，但其设计理念是允许浏览器接收HTML用户事件并将其委托给JavaScript代码。让我们看下面的HTML示例：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, we have a textbox and a button. When the button is
    pressed, it will alert the value inside the textbox. The main function to watch
    here is the `addEventListener()` method. As you can see, it takes two arguments:
    the name of the event and an anonymous function that will run once the event is
    emitted. We usually refer to arguments of the latter kind as a *callback* function.
    Notice that any code after the `addEventListener()` method will execute accordingly,
    regardless of what we write in the callback function.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们有一个文本框和一个按钮。当按下按钮时，它将警报文本框内的值。这里要关注的主要函数是`addEventListener()`方法。如您所见，它接受两个参数：事件的名称和一个匿名函数，该函数在事件发生时运行一次。我们通常将后一种参数称为*回调*函数。请注意，`addEventListener()`方法之后的任何代码都将相应地执行，而不管我们在回调函数中写了什么。
- en: As simple as this example is, it illustrates well how JavaScript uses events
    to execute a set of commands. Since the browser is single-threaded, using synchronous
    programming in this example would freeze everything else on the page, which would
    make every web page extremely unresponsive and impair the web experience in general.
    Thankfully, this is not how it works. The browser manages a single thread to run
    the entire JavaScript code using an inner loop, commonly referred to as the event
    loop. The event loop is a single-threaded loop that the browser runs infinitely.
    Every time an event is emitted, the browser adds it to an event queue. The loop
    will then grab the next event from the queue in order to execute the event handlers
    registered to that event.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子很简单，但很好地说明了JavaScript如何使用事件来执行一组命令。由于浏览器是单线程的，在这个例子中使用同步编程会冻结页面上的所有其他内容，这将使每个网页都变得极其不响应，并且会影响整体的网页体验。幸运的是，事实并非如此。浏览器使用内部循环（通常称为事件循环）来管理单个线程来运行整个JavaScript代码。事件循环是浏览器无限运行的单线程循环。每次发出事件时，浏览器都会将其添加到事件队列中。然后循环将从队列中获取下一个事件，以执行注册到该事件的事件处理程序。
- en: 'After all the event handlers are executed, the loop grabs the next event, executes
    its handlers, grabs another event, and so on. The event loop cycle is shown in
    the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件处理程序执行完毕后，循环会获取下一个事件，执行其处理程序，再获取另一个事件，依此类推。事件循环周期如下图所示：
- en: '![JavaScript event-driven programming](img/B05071_02_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![JavaScript事件驱动编程](img/B05071_02_02.jpg)'
- en: The event loop cycle
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环周期
- en: While the browser usually deals with user-generated events (such as button clicks),
    Node.js has to deal with various types of event that are generated from different
    sources.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然浏览器通常处理用户生成的事件（例如按钮点击），但Node.js必须处理从不同来源生成的各种类型的事件。
- en: Node.js event-driven programming
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js事件驱动编程
- en: 'When developing web server logic, you will probably notice that a lot of your
    system resources are wasted on blocking code. For instance, let''s observe the
    following PHP database interactions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Web服务器逻辑时，您可能会注意到大量系统资源被阻塞代码浪费。例如，让我们观察以下PHP数据库交互：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our server will try querying the database. The database will then perform the
    `SELECT` statement and return the result to the PHP code, which will eventually
    output the data as a response. The preceding code blocks any other operation until
    it gets the result from the database. This means the process, or more commonly
    the thread, will stay idle, consuming system resources while it waits for other
    processes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器将尝试查询数据库。数据库将执行`SELECT`语句，并将结果返回给PHP代码，最终将数据输出为响应。上述代码会阻塞其他操作，直到从数据库获取结果。这意味着该进程，或更常见的是线程，将保持空闲状态，消耗系统资源，同时等待其他进程。
- en: 'To solve this issue, many web platforms have implemented a thread pool system
    that usually issues a single thread per connection. This kind of multithreading
    may seem intuitive at first, but has some significant disadvantages. They are
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，许多Web平台已经实现了一个线程池系统，通常为每个连接发出一个单个线程。这种多线程可能一开始看起来很直观，但有一些显著的缺点。它们如下：
- en: Managing threads becomes a complex task
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理线程变得复杂
- en: System resources are wasted on idle threads
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统资源被空闲线程浪费
- en: Scaling these kinds of applications cannot be done easily
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些应用程序的扩展性不容易实现
- en: 'This is tolerable while developing one-sided web applications, where the browser
    makes a quick request that ends with a server response. However, what happens
    when you want to build real-time applications that keep a long-living connection
    between the browser and the server? To understand the real-life consequences of
    these design choices, take a look at the following graphs. They present a famous
    performance comparison between Apache, which is a blocking web server, and NGINX,
    which uses a non-blocking event loop. The following screenshot shows concurrent
    request handling in Apache versus NGINX ([http://blog.webfaction.com/2008/12/a-little-holiday-present-10000-reqssec-with-nginx-2/](http://blog.webfaction.com/2008/12/a-little-holiday-present-10000-reqssec-with-nginx-2/)):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这在开发单向Web应用程序时是可以容忍的，其中浏览器发出快速请求，以服务器响应结束。但是，当您想要构建保持浏览器和服务器之间长期连接的实时应用程序时会发生什么？要了解这些设计选择的现实后果，请看以下图表。它们展示了Apache（一个阻塞式Web服务器）和使用非阻塞事件循环的NGINX之间的著名性能比较。以下截图显示了Apache与NGINX中的并发请求处理（[http://blog.webfaction.com/2008/12/a-little-holiday-present-10000-reqssec-with-nginx-2/](http://blog.webfaction.com/2008/12/a-little-holiday-present-10000-reqssec-with-nginx-2/)）：
- en: '![Node.js event-driven programming](img/B05071_02_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js事件驱动编程](img/B05071_02_03.jpg)'
- en: Concurrent connections impact on request handling in Apache vs. NGINX.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Apache与NGINX中并发连接对请求处理的影响。
- en: 'In the preceding diagram, you can see how Apache''s request-handling ability
    is degrading much faster than NGINX''s ability. An even clearer impact can be
    seen in the following diagram, where you can see how NGINX''s event loop architecture
    affects memory consumption:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以看到Apache的请求处理能力下降得比NGINX快得多。在下图中可以更清楚地看到NGINX的事件循环架构如何影响内存消耗：
- en: '![Node.js event-driven programming](img/B05071_02_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Node.js事件驱动编程](img/B05071_02_04.jpg)'
- en: Concurrent connections impact on memory allocation in Apache vs. NGINX.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Apache与NGINX中并发连接对内存分配的影响。
- en: As you can see from the results, using event-driven architecture will help you
    dramatically reduce the load on your server while leveraging JavaScript's asynchronous
    behavior in building your web application. An approach that is easier to implement
    thanks to a simple design pattern called **Closures**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中可以看出，使用事件驱动架构将帮助您大大减少服务器的负载，同时利用JavaScript的异步行为来构建您的Web应用程序。这种方法更容易实现，这要归功于一个称为**闭包**的简单设计模式。
- en: JavaScript Closures
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript闭包
- en: 'Closures are functions that refer to variables from their parent environment.
    To understand them better, let''s take a look at the following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是指从其父环境引用变量的函数。为了更好地理解它们，让我们看一个例子：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, you can see how the `child()` function has access
    to a constant defined in the `parent()` function. However, this is a simple example,
    so let''s look at a more interesting one:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，您可以看到`child()`函数可以访问在`parent()`函数中定义的常量。然而，这只是一个简单的例子，让我们看一个更有趣的例子：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, the `parent()` function returned the `child()` function, and the
    `child()` function is called after the `parent()` function has already been executed.
    This is counterintuitive to some developers because usually the `parent()` function's
    local members should only exist while the function is being executed. This is
    what closures are all about! A closure is not only the function, but also the
    environment in which the function was created. In this case, `childFN()` is a
    closure object that consists of the `child()` function and the environment members
    that existed when the closure was created, including the `message` constant.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，`parent()`函数返回了`child()`函数，并且`child()`函数是在`parent()`函数已经执行之后被调用的。这对一些开发人员来说是违反直觉的，因为通常`parent()`函数的局部成员应该只在函数执行时存在。这就是闭包的全部内容！闭包不仅仅是函数，还包括函数创建时存在的环境。在这种情况下，`childFN()`是一个闭包对象，包括`child()`函数和在创建闭包时存在的环境成员，包括`message`常量。
- en: Closures are very important in asynchronous programming because JavaScript functions
    are first-class objects that can be passed as arguments to other functions. This
    means that you can create a callback function and pass it as an argument to an
    event handler. When the event will be emitted, the function will be invoked, and
    it will be able to manipulate any member that existed when the callback function
    was created, even if its parent function was already executed. This means that
    using the closure pattern will help you utilize event-driven programming without
    the need to pass the scope state to the event handler.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包在异步编程中非常重要，因为JavaScript函数是一级对象，可以作为参数传递给其他函数。这意味着您可以创建一个回调函数，并将其作为参数传递给事件处理程序。当事件被触发时，函数将被调用，并且它将能够操作在创建回调函数时存在的任何成员，即使其父函数已经执行。这意味着使用闭包模式将帮助您利用事件驱动编程，而无需将作用域状态传递给事件处理程序。
- en: Node modules
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node模块
- en: JavaScript has turned out to be a powerful language with some unique features
    that enable efficient yet maintainable programming. Its closure pattern and event-driven
    behavior have proven to be very helpful in real-life scenarios, but like all programming
    languages, it isn't perfect. One of its major design flaws is the sharing of a
    single global namespace.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已经成为一种功能强大的语言，具有一些独特的特性，可以实现高效而可维护的编程。它的闭包模式和事件驱动行为在现实场景中被证明非常有帮助，但像所有编程语言一样，它并不完美。其主要设计缺陷之一是共享单个全局命名空间。
- en: To understand this problem, we need to go back to JavaScript's browser origins.
    In the browser, when you load a script into your web page, the engine will inject
    its code into an address space that is shared by all the other scripts. This means
    that when you assign a variable in one script, you can accidently overwrite another
    variable already defined in a previous script. While this could work with a small
    code base, it can easily cause conflicts in larger applications, as errors will
    be difficult to trace. It could have been a major threat for Node.js evolution
    as a platform, but luckily, a solution was found in the CommonJS module standard.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个问题，我们需要回到JavaScript的浏览器起源。在浏览器中，当您将脚本加载到网页中时，引擎将其代码注入到所有其他脚本共享的地址空间中。这意味着当您在一个脚本中分配一个变量时，您可能会意外地覆盖先前脚本中已定义的另一个变量。虽然这可能适用于小型代码库，但在更大的应用程序中很容易引起冲突，因为错误将很难追踪。这可能是Node.js作为一个平台的主要威胁，但幸运的是，在CommonJS模块标准中找到了一个解决方案。
- en: CommonJS modules
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CommonJS模块
- en: CommonJS is a project started in 2009 to standardize the way of working with
    JavaScript outside the browser. The project has evolved since then to support
    a variety of JavaScript issues, including the global namespace issue, which was
    solved through a simple specification of how to write and include isolated JavaScript
    modules.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS是一个于2009年开始的项目，旨在规范浏览器外部的JavaScript工作方式。从那时起，该项目已经发展，以支持各种JavaScript问题，包括全局命名空间问题，通过简单的规范来编写和包含隔离的JavaScript模块来解决。
- en: 'The CommonJS standards specify the following key components when working with
    modules:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS标准在处理模块时指定了以下关键组件：
- en: '`require()`: A method that is used to load the module into your code.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require()`: 用于将模块加载到您的代码中的方法。'
- en: '`exports`: An object that''s contained in each module and allows you to expose
    pieces of your code when the module is loaded.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`: 每个模块中包含的对象，允许在加载模块时公开代码片段。'
- en: '`module`: An object that was originally used to provide metadata information
    about the module. It also contains the pointer of an `exports` object as a property.
    However, the popular implementation of the `exports` object as a standalone object
    literally changed the use case of the `module` object.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`：最初用于提供有关模块的元数据信息的对象。它还包含`exports`对象的指针作为属性。然而，将`exports`对象作为独立对象的流行实现实际上改变了`module`对象的用例。'
- en: 'In Node''s CommonJS module implementation, each module is written in a single
    JavaScript file and has an isolated scope that holds its own members. The author
    of the module can expose any functionality through the `exports` object. To understand
    this better, let''s say we created a module file named `hello.js` that contains
    the following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node的CommonJS模块实现中，每个模块都是在单个JavaScript文件中编写的，并具有一个持有自己成员的隔离作用域。模块的作者可以通过`exports`对象公开任何功能。为了更好地理解这一点，假设我们创建了一个名为`hello.js`的模块文件，其中包含以下代码段：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also created an application file named `server.js`, which contains this
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为`server.js`的应用程序文件，其中包含以下代码：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, you have the `hello` module, which contains a constant
    named `message`. The message constant is self-contained within the `hello` module,
    which only exposes the `sayHello()` method by defining it as a property of the
    `exports` object. Then, the application file loads the `hello` module using the
    `require()` method, which allows it to call the `sayHello()` method of the `hello`
    module.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你有一个名为`hello`的模块，其中包含一个名为`message`的常量。消息常量是在`hello`模块内部自包含的，它只通过将其定义为`exports`对象的属性来公开`sayHello()`方法。然后，应用程序文件使用`require()`方法加载`hello`模块，这允许它调用`hello`模块的`sayHello()`方法。
- en: 'A different approach to creating modules is exposing a single function using
    the `module.exports` pointer. To understand this better, let''s revise the preceding
    example. A modified `hello.js` file should look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模块的另一种方法是使用`module.exports`指针公开单个函数。为了更好地理解这一点，让我们修改前面的例子。修改后的`hello.js`文件应该如下所示：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the module is loaded in the `server.js` file as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，模块在`server.js`文件中加载如下：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, the application file uses the `hello` module directly
    as a function, instead of using the `sayHello()` method as a property of the `hello`
    module.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，应用程序文件直接将`hello`模块作为函数使用，而不是将`sayHello()`方法作为`hello`模块的属性使用。
- en: The CommonJS module standard allows the endless extension of the Node.js platform,
    while preventing the pollution of Node's core. Without it, the Node.js platform
    would become a mess of conflicts. However, not all modules are the same, and while
    developing a Node application, you will encounter several types of module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: CommonJS模块标准允许对Node.js平台进行无限扩展，同时防止污染Node的核心。没有它，Node.js平台将变成一团混乱。然而，并非所有模块都是相同的，在开发Node应用程序时，你将遇到多种类型的模块。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can omit the `.js` extension when you need modules. Node will automatically
    look for a folder with that name, and if it doesn't find one, it will look for
    an applicable `.js` file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要模块时，可以省略`.js`扩展名。Node会自动查找同名的文件夹，如果找不到，它会查找一个适用的`.js`文件。
- en: Node.js core modules
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js核心模块
- en: Core modules are modules that were compiled into the Node binary. They come
    pre-bundled with Node and are explained in great detail in its documentation.
    The core modules provide most of the basic functionalities of Node, including
    filesystem access, HTTP and HTTPS interfaces, and much more. To load a core module,
    you just need to use the `require` method in your JavaScript file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 核心模块是编译到Node二进制文件中的模块。它们与Node一起预先捆绑，并在其文档中有详细解释。核心模块提供了Node的大部分基本功能，包括文件系统访问、HTTP和HTTPS接口等。要加载核心模块，你只需要在你的JavaScript文件中使用`require`方法。
- en: 'An example code, using the `fs` core module to read the content of the environment
    hosts file, would look like the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fs`核心模块读取环境主机文件内容的示例代码如下所示：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you require the `fs` module, Node will find it in the `core modules` folder.
    You'll then be able to use the `fs.readFile()` method to read the file's content
    and print it in the command-line output.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要`fs`模块时，Node会在`core modules`文件夹中找到它。然后你就可以使用`fs.readFile()`方法来读取文件内容并将其打印在命令行输出中。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about Node's core modules, it is recommended you visit the official
    documentation at [http://nodejs.org/api/](http://nodejs.org/api/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Node的核心模块的信息，建议你访问官方文档[http://nodejs.org/api/](http://nodejs.org/api/)。
- en: Node.js third-party modules
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js第三方模块
- en: 'In the previous chapter, you learned how to use npm to install third-party
    modules. As you probably remember, npm installs these modules in a folder named
    `node_modules` under the root folder of your application. To use third-party modules,
    you can just require them as you would normally require a core module. Node will
    first look for the module in the `core modules` folder and then try to load the
    module from the `module` folder inside the `node_modules` folder. For instance,
    to use the `express` module, your code should look like the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学会了如何使用npm安装第三方模块。你可能还记得，npm会将这些模块安装在应用程序根文件夹下名为`node_modules`的文件夹中。要使用第三方模块，你可以像通常加载核心模块一样加载它们。Node首先会在`core
    modules`文件夹中查找模块，然后尝试从`node_modules`文件夹中的`module`文件夹加载模块。例如，要使用`express`模块，你的代码应该如下所示：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Node will then look for the `express` module in the `node_modules` folder and
    load it into your application file, where you'll be able to use it as a method
    to generate the `express` application object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后Node会在`node_modules`文件夹中查找`express`模块，并将其加载到你的应用程序文件中，你将能够将其用作生成`express`应用程序对象的方法。
- en: Node.js file modules
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js文件模块
- en: 'In the previous examples, you saw how Node loads modules directly from files.
    These examples describe a scenario where the files reside in the same folder.
    However, you can also place your modules inside a folder and load them by providing
    the folder path. Let''s say you moved your `hello` module to a `modules` folder.
    The application file would have to change, so Node would look for the module in
    the new relative path:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您看到了 Node 如何直接从文件加载模块。这些例子描述了文件位于同一文件夹中的情况。但是，您也可以将模块放在文件夹中，并通过提供文件夹路径来加载它们。假设您将
    `hello` 模块移动到一个名为 `modules` 的文件夹中。应用程序文件将不得不更改，因此 Node 将在新的相对路径中寻找模块：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that the path can also be an absolute path, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，路径也可以是绝对路径，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Node will then look for the `hello` module in that path.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 Node 将在该路径中查找 `hello` 模块。
- en: Node.js folder modules
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 文件夹模块
- en: 'Although this is not common with developers who aren''t writing third-party
    Node modules, Node also supports the loading of folder modules. Requiring folder
    modules is done in the same way as file modules, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这对于不编写第三方 Node 模块的开发人员来说并不常见，但 Node 也支持加载文件夹模块。加载文件夹模块的方式与加载文件模块相同，如下所示：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, if a folder named `hello` exists, Node will go through that folder looking
    for a `package.json` file. If Node finds a `package.json` file, it will try parsing
    it, looking for the main property, with a `package.json` file that looks like
    the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果存在一个名为 `hello` 的文件夹，Node 将浏览该文件夹，寻找一个 `package.json` 文件。如果 Node 找到了 `package.json`
    文件，它将尝试解析它，寻找 main 属性，一个看起来像以下代码片段的 `package.json` 文件：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Node will try to load the `./hello/hello-module.js` file. If the `package.json`
    file doesn't exist or the main property isn't defined, Node will automatically
    try to load the `./hello/index.js` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Node 将尝试加载 `./hello/hello-module.js` 文件。如果 `package.json` 文件不存在或 main 属性未定义，Node
    将自动尝试加载 `./hello/index.js` 文件。
- en: Node.js modules have been found to be a great solution to write complex JavaScript
    applications. They have helped developers organize their code better, while npm
    and its third-party module registry helped them find and install one of the many
    third-party modules created by the community. Ryan Dahl's dream of building a
    better web framework ended up as a platform that supports a huge variety of solutions.
    However, the dream was not abandoned; it was just implemented as a third-party
    module named `express`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 模块被发现是编写复杂 JavaScript 应用程序的一个很好的解决方案。它们帮助开发人员更好地组织他们的代码，而 npm 及其第三方模块注册表帮助他们找到并安装了社区创建的众多第三方模块之一。Ryan
    Dahl 建立更好的 Web 框架的梦想最终成为了一个支持各种解决方案的平台。然而，这个梦想并没有被放弃；它只是作为一个名为 `express` 的第三方模块实现了。
- en: Developing Node.js web applications
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 Node.js Web 应用程序
- en: Node.js is a platform that supports various types of application, but the most
    popular kind is the development of web applications. Node's style of coding depends
    on the community to extend the platform through third-party modules. These modules
    are then built upon to create new modules, and so on. Companies and single developers
    around the globe are participating in this process by creating modules that wrap
    the basic Node APIs and deliver a better starting point for application development.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是一个支持各种类型应用程序的平台，但最流行的是 Web 应用程序的开发。Node 的编码风格取决于社区通过第三方模块扩展平台。然后，这些模块被用来创建新模块，以此类推。全球的公司和单个开发人员都参与到这个过程中，通过创建包装基本
    Node API 的模块，为应用程序开发提供更好的起点。
- en: 'There are many modules to support web application development, but none as
    popular as the Connect module. The Connect module delivers a set of wrappers around
    the Node.js low-level APIs to enable the development of rich web application frameworks.
    To understand what Connect is all about, let''s begin with a basic example of
    a basic Node web server. In your working folder, create a file named `server.js`
    that contains the following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多模块支持 Web 应用程序开发，但没有一个像 Connect 模块那样受欢迎。Connect 模块提供了一组包装器，围绕 Node.js 低级 API，以实现丰富的
    Web 应用程序框架的开发。要了解 Connect 的全部内容，让我们从一个基本的 Node Web 服务器的基本示例开始。在您的工作文件夹中，创建一个名为
    `server.js` 的文件，其中包含以下代码片段：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To start your web server, use your command-line tool and navigate to your working
    folder. Then, run the Node.js CLI tool and run the `server.js` file as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您的 Web 服务器，使用命令行工具并导航到您的工作文件夹。然后，运行 Node.js CLI 工具，并运行 `server.js` 文件如下：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, open `http://localhost:3000` in your browser and you'll see the **Hello
    World** response.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开 `http://localhost:3000`，您将看到 **Hello World** 的响应。
- en: So, how does this work? In this example, the `http` module is used to create
    a small web server listening to the `3000` port. You begin by requiring the `http`
    module and then use the `createServer()` method to return a new server object.
    The `listen()` method is then used to listen to the `3000` port. Notice the callback
    function that is passed as an argument to the `createServer()` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是如何工作的呢？在这个例子中，`http` 模块用于创建一个监听 `3000` 端口的小型 Web 服务器。您首先需要引入 `http` 模块，然后使用
    `createServer()` 方法返回一个新的服务器对象。然后使用 `listen()` 方法来监听 `3000` 端口。请注意，回调函数作为参数传递给
    `createServer()` 方法。
- en: 'The callback function gets called whenever there''s an HTTP request sent to
    the web server. The server object will then pass it the `req` and `res` arguments,
    which contain the information and functionality needed to send back an HTTP response.
    The callback function will then follow these two steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 Web 服务器收到 HTTP 请求时，回调函数都会被调用。然后服务器对象将传递 `req` 和 `res` 参数，其中包含发送 HTTP 响应所需的信息和功能。然后回调函数将遵循以下两个步骤：
- en: First, it will call the `writeHead()` method of the `res` object. This method
    is used to set the response HTTP headers. In this example, it will set the content-type
    header value to `text/plain`. For instance, when responding with HTML, you just
    need to replace `text/plain` with `html/plain`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将调用 `res` 对象的 `writeHead()` 方法。此方法用于设置响应的 HTTP 标头。在这个例子中，它将把 content-type
    标头值设置为 `text/plain`。例如，当响应 HTML 时，只需用 `html/plain` 替换 `text/plain`。
- en: 'Then, it will call the `end()` method of the `res` object. This method is used
    to finalize the response. The `end()` method takes a single-string argument that
    it will use as the HTTP response body. Another common way of writing this is to
    add a `write()` method before the `end()` method and then call the `end()` method
    as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将调用`res`对象的`end()`方法。这个方法用于完成响应。`end()`方法接受一个单字符串参数，它将作为HTTP响应主体使用。另一种常见的写法是在`end()`方法之前添加一个`write()`方法，然后调用`end()`方法，如下所示：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This simple application illustrates the Node coding style, where low-level APIs
    are used to simply achieve certain functionality. While this is a nice example,
    running a full web application using the low-level APIs will require you to write
    a lot of supplementary code to support common requirements. Fortunately, a company
    called Sencha has already created this scaffolding code for you in the form of
    a Node.js module called Connect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的应用程序展示了Node的编码风格，其中使用低级API来简单实现某些功能。虽然这是一个很好的例子，但是使用低级API运行完整的web应用程序将需要您编写大量的辅助代码来支持常见的需求。幸运的是，一个名为Sencha的公司已经为您创建了这个脚手架代码，以Node.js模块的形式称为Connect。
- en: Meet the Connect module
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Connect模块
- en: Connect is a module built to support the interception of requests in a more
    modular approach. In the first web server example, you learned how to build a
    simple web server using the `http` module. If you wish to extend this example,
    you'd have to write code that manages the different HTTP requests sent to your
    server, handles them properly, and provides the correct response to each request.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Connect是一个模块，旨在以更模块化的方式支持请求的拦截。在第一个web服务器示例中，您学习了如何使用`http`模块构建一个简单的web服务器。如果您希望扩展此示例，您将需要编写代码来管理发送到服务器的不同HTTP请求，正确处理它们，并为每个请求提供正确的响应。
- en: Connect creates an API exactly for that purpose. It uses a modular component
    called *middleware*, which allows you to simply register your application logic
    to predefined HTTP request scenarios. Connect middlewares are basically callback
    functions, which get executed when an HTTP request occurs. The middleware can
    then perform some logic, return a response, or call the next registered middleware.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Connect创建了一个专门用于此目的的API。它使用了一个名为*middleware*的模块化组件，允许您简单地将应用逻辑注册到预定义的HTTP请求场景中。Connect中间件基本上是回调函数，当发生HTTP请求时会被执行。然后中间件可以执行一些逻辑，返回一个响应，或者调用下一个注册的中间件。
- en: While you will mostly write custom middleware to support your application needs,
    Connect also includes some common middleware to support logging, static file serving,
    and more.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您大多数情况下会编写自定义中间件来支持应用程序的需求，但Connect还包括一些常见的中间件，以支持日志记录、静态文件服务等。
- en: 'The way a Connect application works is using an object called *dispatcher*.
    The dispatcher object handles each HTTP request received by the server and then
    decides the order of middleware execution in a cascading form. To understand Connect
    better, take a look at the following diagram:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Connect应用程序的工作方式是使用一个名为*dispatcher*的对象。调度程序对象处理服务器接收到的每个HTTP请求，然后以级联形式决定中间件执行的顺序。要更好地理解Connect，请查看以下图示：
- en: '![Meet the Connect module](img/B05071_02_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![了解Connect模块](img/B05071_02_05.jpg)'
- en: Requests execution using middleware
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中间件执行请求
- en: 'The preceding diagram illustrates two calls made to the Connect application:
    the first is handled by a custom middleware and the second is handled by the static
    files middleware. Connect''s dispatcher initiates the process, moving on to the
    next handler using the `next()` method, until it gets to a middleware responding
    with the `res.end()` method, which will end the request handling.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示了对Connect应用程序的两个调用：第一个由自定义中间件处理，第二个由静态文件中间件处理。Connect的调度程序启动了这个过程，使用`next()`方法继续到下一个处理程序，直到它到达一个使用`res.end()`方法响应的中间件，这将结束请求处理。
- en: In the next chapter, you'll create your first Express application, but Express
    is based on Connect's approach. So, in order to understand how Express works,
    we'll begin by creating a Connect application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将创建您的第一个Express应用程序，但Express是基于Connect的方法。因此，为了理解Express的工作原理，我们将从创建一个Connect应用程序开始。
- en: 'In your working folder, create a file named `server.js` that contains the following
    code snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的工作文件夹中，创建一个名为`server.js`的文件，其中包含以下代码片段：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, your application file is using the `connect` module to create
    a new web server. However, Connect isn''t a core module, so you''ll have to install
    it using npm. As you already know, there are several ways of installing third-party
    modules. The easiest one is to install it directly using the `npm install` command.
    To do so, use your command-line tool, and navigate to your working folder. Then,
    execute the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您的应用程序文件正在使用`connect`模块创建一个新的web服务器。但是，Connect不是一个核心模块，因此您需要使用npm安装它。正如您已经知道的，有几种安装第三方模块的方法。最简单的方法是直接使用`npm
    install`命令进行安装。要这样做，使用命令行工具，导航到您的工作文件夹。然后，执行以下命令：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'npm will install the `connect` module inside a `node_modules` folder, which
    will enable you to require it in your application file. To run your Connect web
    server, just use Node''s CLI and execute the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: npm将在`node_modules`文件夹中安装`connect`模块，这将使您能够在应用程序文件中引用它。要运行Connect web服务器，只需使用Node的CLI并执行以下命令：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Node will run your application, reporting the server status using the `console.log()`
    method. You can try reaching your application in the browser by visiting `http://localhost:3000`.
    However, you should get a response similar to what is shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Node将运行您的应用程序，并使用`console.log()`方法报告服务器状态。您可以尝试在浏览器中访问`http://localhost:3000`来访问您的应用程序。但是，您应该会得到类似以下截图所示的响应：
- en: '![Meet the Connect module](img/B05071_02_06.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![了解Connect模块](img/B05071_02_06.jpg)'
- en: What this response means is that there isn't any middleware registered to handle
    the GET HTTP request. This means that first, you've successfully managed to install
    and use the Connect module, and second, it's time for you to write your first
    Connect middleware.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应的意思是没有任何中间件注册来处理GET HTTP请求。这意味着首先，您成功安装并使用了Connect模块，其次，现在是时候编写您的第一个Connect中间件了。
- en: Connect middleware
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Connect中间件
- en: 'Connect middleware is basically a JavaScript function with a unique signature.
    Each middleware function is defined with the following three arguments:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Connect中间件基本上是一个具有独特签名的JavaScript函数。每个中间件函数都使用以下三个参数定义：
- en: '`req`: This is an object that holds the HTTP request information'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req`：这是一个保存HTTP请求信息的对象'
- en: '`res`: This is an object that holds the HTTP response information and allows
    you to set the response properties'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res`：这是一个保存HTTP响应信息并允许您设置响应属性的对象'
- en: '`next`: This is the next middleware function defined in the ordered set of
    Connect middleware'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`：这是在有序的Connect中间件集合中定义的下一个中间件函数'
- en: 'When you have a middleware defined, you''ll just have to register it with the
    Connect application using the `app.use()` method. Let''s revise the previous example
    to include your first middleware. Change your `server.js` file to look like the
    following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义了一个中间件时，您只需使用`app.use()`方法将其注册到Connect应用程序中。让我们修改前面的例子，包括您的第一个中间件。将您的`server.js`文件更改为以下代码片段：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, start your Connect server again by issuing the following command in your
    command-line tool:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在命令行工具中发出以下命令，再次启动您的Connect服务器：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Try visiting `http://localhost:3000` again. You will now get a response similar
    to that in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次访问`http://localhost:3000`。您现在将会得到与以下截图中类似的响应：
- en: '![Connect middleware](img/B05071_02_07.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Connect middleware](img/B05071_02_07.jpg)'
- en: If you see the Connect application's response as that of the previous screenshot,
    then congratulations! You've just created your first Connect middleware!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到Connect应用程序的响应与之前的截图相同，那么恭喜您！您刚刚创建了您的第一个Connect中间件！
- en: 'Let''s recap. First, you added a middleware function named `helloWorld()`,
    which has three arguments: `req`, `res`, and `next`. Inside your middleware function,
    you used the `res.setHeader()` method to set the response `Content-Type` header
    and the `res.end()` method to set the response text. Finally, you used the `app.use()`
    method to register your middleware with the Connect application.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下。首先，您添加了一个名为`helloWorld()`的中间件函数，它有三个参数：`req`、`res`和`next`。在您的中间件函数内部，您使用了`res.setHeader()`方法来设置响应的`Content-Type`头部和`res.end()`方法来设置响应文本。最后，您使用了`app.use()`方法来将您的中间件注册到Connect应用程序中。
- en: Understanding the order of Connect middleware
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解Connect中间件的顺序
- en: One of Connect's greatest features is the ability to register as many middleware
    functions as you want. Using the `app.use()` method, you'll be able to set a series
    of middleware functions that will be executed in a row to achieve maximum flexibility
    when writing your application. Connect will then pass the next middleware function
    to the currently executing middleware function, using the `next` argument. In
    each middleware function, you can decide whether to call the next middleware function
    or stop at the current one. Notice that each middleware function will be executed
    in a **First-In-First-Out** (**FIFO**) basis using the next arguments, until there
    are no more middleware functions to execute or the next middleware function is
    not called.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Connect最大的特点之一是能够注册尽可能多的中间件函数。使用`app.use()`方法，您可以设置一系列中间件函数，这些函数将按顺序执行，以实现编写应用程序时的最大灵活性。Connect将使用`next`参数将下一个中间件函数传递给当前执行的中间件函数。在每个中间件函数中，您可以决定是调用下一个中间件函数还是停在当前中间件函数。请注意，每个中间件函数将使用下一个参数按照**先进先出**（**FIFO**）的顺序执行，直到没有更多的中间件函数要执行或者没有调用下一个中间件函数。
- en: 'To understand this better, we will go back to the previous example and add
    a logger function that will log all the requests made to the server in the command
    line. To do so, go back to the `server.js` file and update it as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我们将回到之前的例子，并添加一个记录器函数，它将在命令行中记录发送到服务器的所有请求。为此，返回到`server.js`文件，并更新如下：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, you added another middleware called `logger()`. The
    `logger()` middleware uses the `console.log()` method to simply log the request
    information to the console. Notice how the `logger()` middleware is registered
    before the `helloWorld()` middleware. This is important, as it determines the
    order in which each middleware is executed. Another thing to notice is the `next()`
    call in the `logger()` middleware, which is responsible for calling the `helloWorld()`
    middleware. Removing the `next()` call would stop the execution of middleware
    functions at the `logger()` middleware, which means that the request would hang
    forever as the response is never ended by calling the `res.end()` method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您添加了另一个名为`logger()`的中间件。`logger()`中间件使用`console.log()`方法简单地将请求信息记录到控制台。请注意，`logger()`中间件在`helloWorld()`中间件之前注册。这很重要，因为它决定了每个中间件执行的顺序。还要注意的一点是`logger()`中间件中的`next()`调用，它负责调用`helloWorld()`中间件。如果删除`next()`调用，将会停止在`logger()`中间件处执行中间件函数，这意味着请求将永远挂起，因为没有调用`res.end()`方法来结束响应。
- en: 'To test your changes, start your Connect server again by issuing the following
    command in your command-line tool:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的更改，请通过在命令行工具中发出以下命令，再次启动您的Connect服务器：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, visit `http://localhost:3000` in your browser and notice the console output
    in your command-line tool.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在浏览器中访问`http://localhost:3000`，注意命令行工具中的控制台输出。
- en: Mounting Connect middleware
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载Connect中间件
- en: 'As you may have noticed, the middleware you registered responds to any request,
    regardless of the request path. This does not comply with modern web application
    development because responding to different paths is an integral part of all web
    applications. Fortunately, Connect middleware supports a feature called mounting,
    which enables you to determine which request path is required for the middleware
    function to get executed. Mounting is done by adding the path argument to the
    `app.use()` method. To understand this better, let''s revisit our previous example.
    Modify your `server.js` file to look like the following code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，你注册的中间件会响应任何请求，而不管请求路径如何。这不符合现代Web应用程序开发的要求，因为响应不同路径是所有Web应用程序的一个重要部分。幸运的是，Connect中间件支持一种称为挂载的功能，它使你能够确定中间件函数需要执行的请求路径。挂载是通过向`app.use()`方法添加路径参数来完成的。为了更好地理解这一点，让我们重新访问我们之前的例子。修改你的`server.js`文件，使其看起来像以下代码片段：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A few things have been changed in the previous example. First, you mounted the
    `helloWorld()` middleware to respond only to requests made to the `/hello` path.
    Then, you added another (a bit morbid) middleware called `goodbyeWorld()` that
    will respond to requests made to the `/goodbye` path. Notice how, as a `logger`
    should do, we left the `logger()` middleware to respond to all the requests made
    to the server. Another thing you should be aware of is that any requests made
    to the base path will not be responded to by any middleware because we mounted
    the `helloWorld()` middleware to a specific path.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中有一些变化。首先，你将`helloWorld()`中间件挂载到仅响应对`/hello`路径发出的请求。然后，你添加了另一个（有点令人沮丧）中间件，名为`goodbyeWorld()`，它将响应对`/goodbye`路径发出的请求。请注意，正如`logger`应该做的那样，我们让`logger()`中间件响应服务器上的所有请求。另一件你应该注意的事情是，任何发往基本路径的请求都不会被任何中间件响应，因为我们将`helloWorld()`中间件挂载到了特定路径。
- en: 'Connect is a great module that supports various features of common web applications.
    Connect middleware is super simple, as it is built with a JavaScript style in
    mind. It allows the endless extension of your application logic without breaking
    the nimble philosophy of the Node platform. While Connect is a great improvement
    over writing your web application infrastructure, it deliberately lacks some basic
    features you''re used to having in other web frameworks. The reason lies in one
    of the basic principles of the Node community: create your modules lean and let
    other developers build their modules on top of the module you created. The community
    is supposed to extend Connect with its own modules and create its own web infrastructures.
    In fact, one very energetic developer named TJ Holowaychuk did it better than
    most when he released a Connect-based web framework known as Express.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Connect是一个很棒的模块，支持常见Web应用程序的各种功能。Connect中间件非常简单，因为它是以JavaScript风格构建的。它允许无限扩展应用逻辑，而不会破坏Node平台的灵活哲学。虽然Connect在编写Web应用程序基础设施方面有很大改进，但它故意缺少一些你在其他Web框架中习惯拥有的基本功能。原因在于Node社区的一个基本原则：创建精简的模块，让其他开发人员在你创建的模块基础上构建自己的模块。社区应该用自己的模块扩展Connect，并创建自己的Web基础设施。事实上，一个名叫TJ
    Holowaychuk的非常有活力的开发人员做得比大多数人都好，他发布了一个基于Connect的Web框架，名为Express。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how Node.js harnesses JavaScript's event-driven
    behavior to its benefit. You also learned how Node.js uses the CommonJS module
    system to extend its core functionality. Moreover, you learned about the basic
    principles of Node.js web applications and discovered the Connect web module.
    Finally, you created your first Connect application and learned how to use middleware
    functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了Node.js如何利用JavaScript的事件驱动行为来获益。你还了解了Node.js如何使用CommonJS模块系统来扩展其核心功能。此外，你还了解了Node.js
    Web应用程序的基本原则，并发现了Connect Web模块。最后，你创建了你的第一个Connect应用程序，并学会了如何使用中间件函数。
- en: In the next chapter, we'll tackle the first piece of the MEAN puzzle, when we
    discuss the Connect-based web framework called Express.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我们讨论基于Connect的Web框架Express时，我们将解决MEAN拼图的第一部分。
