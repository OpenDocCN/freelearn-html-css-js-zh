- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Measuring and Optimizing Performance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量和优化性能
- en: In software engineering circles, it’s common to hear the expression “premature
    optimization is the root of all evil.” This is usually bestowed very knowingly
    from a more Senior developer to a more Junior one. Stroking of the chin – whether
    a beard is present or not – is almost always required to attain the Solemn Air
    of Pronouncement accompanying such declarations. Strange delivery or not, it is
    good advice to follow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程领域，人们经常听到这样的说法：“过早优化是万恶之源。”这通常是由资深的开发者对资历较浅的开发者非常了解地传授的。无论是刮胡子还是不刮胡子，几乎总是需要做出严肃的声明，以获得这种声明所伴随的庄严气氛。不管传达方式如何奇怪，遵循这些建议是明智的。
- en: There aren’t many worse ways to approach software design than by starting to
    make performance-related changes while that software is still largely being built.
    That, in turn, is because the optimization of a code base is inversely related
    to the code’s readability, its maintainability, and ultimately the facility to
    which new features and changes can be introduced. To put it another way, the more
    optimized a code base tends to be, the harder it is for someone to understand
    the code and subsequently make changes to that code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计方面，没有比在软件仍在大量构建时开始进行性能相关更改更糟糕的方法了。这反过来是因为代码库的优化与代码的可读性、可维护性以及引入新功能和更改的便利性成反比。换句话说，代码库越优化，人们理解代码并对其进行更改就越困难。
- en: 'At this point in our journey, we have established a full end-to-end application
    experience. Though there may still be some rough edges, all the major features
    have been implemented in the application, making this an ideal time to examine
    our application’s performance. At the same time, though, we don’t have much insight
    into how *Space-Truckers* performs at really any other level than the bare basics.
    Our first task is clear: we must capture a baseline performance profile, or rather
    one profile each for both the Route Planning and Driving phases.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的旅程的这个阶段，我们已经建立了一个完整的端到端应用程序体验。尽管可能还有一些粗糙的边缘，但所有主要功能都已在该应用程序中实现，这使得检查应用程序的性能成为一个理想的时间点。然而，与此同时，我们对
    Space-Truckers 在除最基本层面之外的其他层面上的性能了解不多。我们的第一个任务是明确的：我们必须捕捉一个基准性能配置文件，或者说为路线规划和驾驶阶段各捕捉一个配置文件。
- en: The Babylon.js **Real-time performance viewer** can record real-time performance
    statistics across a wide range of metrics relevant to a Babylon.js Scene. With
    these tools in hand, we’ll be able to identify “hotspots” in the Space-Truckers
    code base that we can then target for selective performance enhancements, but
    that doesn’t tell us anything about how we can improve the performance or what
    to look for in our tooling. Not yet at least!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 的 **实时性能查看器** 可以记录 Babylon.js 场景中与性能相关的广泛指标的实时性能统计。有了这些工具，我们将能够识别
    Space-Truckers 代码库中的“热点”，然后针对这些热点进行选择性的性能优化，但这并不能告诉我们如何提高性能或在我们工具中寻找什么。至少目前还不是这样！
- en: Something we haven’t discussed so far has been how the very breadth and reach
    of a web application also means a greater number of different potential hardware
    and software configurations that must then be supported by you, the developer.
    How do we avoid having to go down the rabbit hole of testing, verifying, and fixing
    functionality for every combination of device, software, and display? By knowing
    what areas or scenarios in a Scene put the most stress on which part of the system,
    we can defer the optimization from design time to runtime and handle it in real
    time. The Babylon.js **Scene Optimizer** is the ideal solution to dynamically
    balance performance and render quality with its ability to turn on and off different
    performance optimizations based on the difference between a target and the current
    frame rates, or **frames per second** (**FPS**).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前还没有讨论过，一个网络应用的广泛性和覆盖面也意味着必须由开发者支持更多不同类型的潜在硬件和软件配置。我们如何避免必须测试、验证和修复每个设备、软件和显示组合的功能？通过了解场景中哪些区域或场景对系统哪个部分施加了最大压力，我们可以将优化从设计时间推迟到运行时，并在实时进行处理。Babylon.js
    的 **场景优化器** 是动态平衡性能和渲染质量的理想解决方案，它可以根据目标帧率和当前帧率之间的差异，开启和关闭不同的性能优化。
- en: Aside from the runtime **Scene Optimizer**, there are other things we can do
    to improve an application’s performance in Babylon.js. We’ll continue to use and
    re-measure the impact of any changes we make, first individually, then all together,
    because how can you know if any improvement has been made if you don’t have something
    for comparison? The rhetorical answer is that you can’t – not unless you are consistent
    in your measurement procedure and capturing measurements, but as the fastidious
    and methodical creator of Software That Does Magic™, you’ve already got that part
    down!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行时的 **场景优化器** 之外，我们还可以做其他事情来提高 Babylon.js 应用程序的性能。我们将继续使用并重新测量我们做出的任何更改的影响，首先是单独的，然后是全部的，因为如果你没有比较的东西，你怎么知道是否有所改进？修辞的回答是，你不能——除非你在测量程序和捕获测量方面保持一致，但作为
    Software That Does Magic™ 的挑剔和有条理的创造者，你已经掌握了这一点！
- en: Important note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Levity aside, something that will help enforce and facilitate this kind of development
    work greatly is to leverage the mighty power of Git. Any time you save a change
    to a source code file, consider at least staging that change, if not committing
    it. Revert commits that don’t work instead of plowing ahead. In other words, by
    working with, not against, Source Control, you might be amazed at how fast you
    can get things done!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 严肃地说，有助于加强和促进这种开发工作的强大力量是利用 Git 的强大功能。每次你保存源代码文件的更改时，至少考虑暂存该更改，如果可能的话，提交它。对于不起作用的提交，选择回滚而不是继续前进。换句话说，通过与源代码控制合作，而不是对抗它，你可能会惊讶地发现你可以多么快地完成任务！
- en: Our last port of call for this, the penultimate stage of our Babylon.js long-haul,
    will be looking at the network performance of our app. Specifically, we’ll see
    how our asset and data resources affect both loading time and bandwidth usage.
    Today’s web browsers almost all support both robust caching functionality, as
    well as local storage mechanisms such as **IndexedDb**, which is a mini SQL server
    made available by the browser to scripts running inside it. Why is this relevant?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，我们 Babylon.js 长途旅行的倒数第二个阶段，将查看我们应用程序的网络性能。具体来说，我们将看到我们的资产和数据资源如何影响加载时间和带宽使用。今天的网络浏览器几乎都支持强大的缓存功能，以及本地存储机制，如
    **IndexedDb**，这是一个浏览器提供给其内部运行的脚本的微型 SQL 服务器。这有什么相关性？
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In case you missed it, rhetorical questions are back in style!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你错过了，修辞问题又流行起来了！
- en: The relevance of **IndexedDB** is that we can use it to stuff all our assets
    – textures, sounds, JSON, and more. Instead of having to download everything from
    the server, we store resources locally on the browser. It’s a great place to cache
    assets. This positions us well for the next chapter’s look at making Space-Truckers
    into an installable publishable **Progressive Web Application** (**PWA**). But
    first things first, let’s go over the topics covered in this chapter and some
    technical requirements and recommendations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**IndexedDB** 的相关性在于我们可以用它来存放所有我们的资产——纹理、声音、JSON 等。我们不需要从服务器下载所有内容，而是在浏览器本地存储资源。这是一个缓存资产的绝佳位置。这使我们为下一章探讨将
    Space-Truckers 转换为可安装发布的 **渐进式网络应用**（**PWA**）做好了准备。但首先，让我们回顾一下本章涵盖的主题以及一些技术要求和推荐。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Knowing What To Measure
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道要测量什么
- en: Measuring Performance and Identifying Bottlenecks
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量性能和识别瓶颈
- en: Improving Runtime Performance with the Scene Optimizer
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用场景优化器提高运行时性能
- en: Technical Requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Most of the requirements in this chapter are the same as they have been for
    the previous chapters, but some new tools can be incredibly useful for performance
    measurement and improvement. Here are the tools that are new and/or specific to
    this chapter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大多数要求与之前章节的要求相同，但一些新工具对于性能测量和改进非常有用。以下是本章新引入的或特定的工具：
- en: This is not a requirement, but it is very helpful to have multiple displays
    available while working on performance captures. Accurate and consistent measurements
    can be tough enough – don’t add more variables into the mix if you can help it!
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不是必需的，但在进行性能捕获工作时拥有多个显示器非常有帮助。准确和一致性的测量可能已经足够困难——如果可能的话，不要在混合中添加更多变量！
- en: 'The Scene Optimizer: [https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer](https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景优化器：[https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer](https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer)
- en: 'Optimizing with Octrees: [https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees](https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用八叉树优化：[https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees](https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees)
- en: BVH article/information link
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BVH文章/信息链接
- en: Knowing What To Measure
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知道要测量什么
- en: 'Quantum Mechanics has a concept called the **Uncertainty Principle**. Named
    after physicist Werner Heisenberg, the principle can be summarized for our purposes
    as the act of measuring some quantity itself affecting the observed value of that
    quantity. Although merely an analogy for us currently bound to non-quantum systems,
    it serves as a useful warning as we take our measures and metrics: don’t let the
    instrumentation impact the measurements that are being taken for our app’s performance.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 量子力学有一个叫做**不确定性原理**的概念。以物理学家维尔纳·海森堡的名字命名，这个原理可以概括为：测量某个数量本身会影响该数量的观测值。虽然对我们目前受限于非量子系统的人来说，这仅仅是一个类比，但它作为我们在采取测量和指标时的一个有用警告：不要让仪器影响我们对应用程序性能的测量。
- en: Starting with some general guidelines, we’ll look at some key factors that need
    to be attended to and accounted for to gather meaningful test data. Using those
    guidelines to establish a basic context, we’ll start learning some key terminology
    that will allow us to get into more specifics in future sections of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从一些一般性指南开始，我们将查看一些需要关注和考虑的关键因素，以便收集有意义的测试数据。使用这些指南来建立基本背景，我们将开始学习一些关键术语，这将使我们能够在本章的后续部分中更具体地了解。
- en: General Guidelines
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般性指南
- en: As we review and examine the various means and procedures for taking our performance
    profile, we’ll go over the tooling-specific steps as they come up. But first,
    let’s look at a few guidelines that generally apply.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾和检查获取性能配置文件的各种方法和程序时，我们会根据需要介绍工具特定的步骤。但首先，让我们看看一些普遍适用的指南。
- en: Keep External Factors To a Minimum
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将外部因素降至最低
- en: Computers are quite good at sharing slices of computing time between processes,
    but we’re better off closing all our other browser windows and shutting down any
    other non-essential programs that may compete with ours for resources. No, it’s
    not as “real world” as might be expected, but the goal here is to gather clean,
    consistent data, and that doesn’t have to stick to the “real world” rules. Rebel.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在在进程之间共享计算时间切片方面相当出色，但我们最好关闭所有其他浏览器窗口并关闭任何可能与我们竞争资源的非必要程序。不，这并不像预期的那样“真实世界”，但这里的目的是收集干净、一致的数据，这不必遵守“真实世界”的规则。反抗。
- en: Choose a Target Resolution and Stick To It
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择一个目标分辨率并坚持使用
- en: This is a bit trickier than it might seem. Simply going with the highest resolution
    possible and putting on the highest pixel-dense display is certainly a good way
    to stress-test a graphical application, but it won’t yield a very useful performance
    profile. Too low of a resolution and the GPU won’t break a sweat, also not yielding
    a very useful profile. Going for a Veruca Salt-meets-goldilocks approach, select
    a value somewhere in the upper-middle range that avoids “redlining” either CPU
    or GPU but still makes those components work for their electrons!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比看起来要复杂一些。仅仅选择最高可能的分辨率并使用最高像素密度的显示确实是一种很好的方法来压力测试图形应用程序，但这不会产生一个非常有用的性能配置文件。分辨率太低，GPU也不会感到压力，同样也不会产生一个非常有用的配置文件。采用类似Veruca
    Salt和Goldilocks的方法，选择一个位于中上范围的值，避免“红线”CPU或GPU，但仍然让这些组件为它们的电子工作！
- en: Compare Apples to Apples
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较苹果和苹果
- en: Always make sure your comparisons are equivalent, all other things considered.
    Follow the same testing procedure – resist the urge to “improve” or take shortcuts
    – and collect data in the same fashion between test runs. If methodologies differ,
    then there’s a good possibility that your results won’t tell you what you think
    they say.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的比较是等效的，考虑所有其他因素。遵循相同的测试程序——抵制“改进”或走捷径的诱惑——并在测试运行之间以相同的方式收集数据。如果方法不同，那么你的结果很可能不会告诉你你所认为的。
- en: Change Only One Thing Between Measurements
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在测量之间只改变一个因素
- en: One of the less helpful things you might do to yourself is put off re-measuring
    after making one set of changes. For example, say you refactor one method, then
    make another set of changes somewhere else in the application. Repeat this a few
    times, and you’ve now lost the ability to definitively say whether your change
    has improved anything – regardless of whether the app performs better or worse!
    This is also a poor situation to be in because you’re also restrained in the changes
    you can safely make in the future without risking regression in the code you’re
    trying to change. Avoid getting into this in the first place by committing each
    cohesive set of changes together, and by re-measuring after each major change
    to validate your assumptions about how the code behaves.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能对自己做的最不有帮助的事情之一就是在进行一组更改后推迟重新测量。例如，假设您重构了一个方法，然后在应用程序的其他地方进行了一组更改。重复几次，现在您已经失去了确定您的更改是否改善了任何东西的能力——无论应用程序的性能是变好还是变差！这种情况也很糟糕，因为您在未来的更改中也受到限制，这些更改可能不会导致您试图更改的代码回归。通过将每个连贯的更改集一起提交，并在每次主要更改后重新测量以验证您对代码行为的假设，来避免陷入这种境地。
- en: The preceding guidelines aren’t rules set in stone – they’re pieces of advice
    aimed at helping you proactively avoid arriving at false conclusions and the resulting
    consequences. This is surely helpful, but not directly so. To help connect this
    advice to a useful context, we’ll first look at what sorts of metrics are important.
    Then, we’ll look at the tools that collect this data. Finally, we’ll apply what
    we’ve learned to find and fix performance bottlenecks and resource pressures that
    lurk in the Space-Truckers code base.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指南并非不可更改的规则——它们是旨在帮助您主动避免得出错误结论及其后果的建议。这当然很有帮助，但并非直接相关。为了帮助将这些建议与有用的背景联系起来，我们首先将探讨哪些类型的指标很重要。然后，我们将探讨收集这些数据的工具。最后，我们将应用所学知识来查找和修复Space-Truckers代码库中潜伏的性能瓶颈和资源压力。
- en: Performance-Related Terminology
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能相关术语
- en: “*I Wanna Go Fast!*”
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: “*我想变得更快!*”
- en: Yes, Ricky Bobby, so do we all. When referring to cars or racing, the meaning
    of the phrase is clear, but what does “[going] Fast!” mean for a 3D application?
    Sure, it cannot be a good thing for a laptop to suddenly take off in a cloud of
    burning plastic at 200 kph! At least, not a laptop without wheels. Brakes too
    – those are also important.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Ricky Bobby，我们所有人都是这样。当提到汽车或赛车时，这个短语的含义是明确的，但对于一个3D应用程序来说，“[快速]”意味着什么呢？当然，对于一台笔记本电脑来说，突然以200公里每小时的速度在燃烧的塑料云中起飞绝不是什么好事！至少，不是没有轮子的笔记本电脑。刹车也同样重要。
- en: The equivalent measure for 3D applications and games is, of course, the Frame
    Rate, or **Frames Per Second** (**FPS**).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于3D应用程序和游戏来说，相应的度量标准当然是帧率，或**每秒帧数**（**FPS**）。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Positioned unfortunately close in proximity to a **First-Person Shooter** (**FPS**),
    noting that the two are not directly related is yet another reminder that context
    is important.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸地靠近**第一人称射击游戏**（**FPS**），值得注意的是这两个并不是直接相关的，这再次提醒我们上下文很重要。
- en: 'Similar to how a speed limit posted on a highway serves to limit (in theory,
    at least) the top speed of drivers on the road, the number of frames that can
    be rendered every second is limited at the end by an intrinsic maximum that matches
    the refresh rate of the display device or monitor doing the rendering. In the
    Old Days, this was limited by the speed at which the electron gun of a **Cathode
    Ray Tube** (**CRT**) display could traverse the width and height of the screen.
    Barbarian times, they were. In today’s era of more Enlightened Display Technologies,
    **Light Emitting Diode** (**LED**) displays can switch on or off with incredible
    speed. Here are some typical FPS values and examples that you may recognize from
    the real world:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像高速公路上发布的限速标志旨在限制（至少在理论上）道路上驾驶员的最高速度一样，每秒可以渲染的帧数最终受到一个内在最大值的限制，这个最大值与进行渲染的显示设备或监视器的刷新率相匹配。在旧时代，这受到**阴极射线管**（**CRT**）显示器中电子枪穿越屏幕宽度和高度速度的限制。那是野蛮的时代。在当今更加先进的显示技术时代，**发光二极管**（**LED**）显示器可以以惊人的速度开关。以下是一些典型的FPS值和例子，您可能从现实世界中认识：
- en: '![](img/Table_12.01_B17266.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_12.01_B17266.jpg)'
- en: FPS is a convenient metric because it is almost completely unambiguous – higher
    values are almost always better. The only real exception to this is in scenarios
    where power consumption is a higher priority than maintaining a high frame rate.
    Because that deals with actions taken at runtime, we’re going to look at how to
    approach a scenario like that later in this chapter in the *Improving Runtime
    Performance with the Scene Optimizer* section. The ugly downside of a higher FPS
    is that there’s less time to get all the needed inter-frame processing that goes
    on, whether inside the GPU or in the CPU.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: FPS是一个方便的指标，因为它几乎完全无歧义——更高的值几乎总是更好的。唯一的真正例外是在功率消耗比保持高帧率更重要的场景中。因为这与运行时采取的行动有关，所以我们将在本章的*使用场景优化器提高运行时性能*部分稍后探讨如何处理这种情况。更高的FPS的丑陋副作用是，用于获取所有所需帧间处理的时间更少，无论是在GPU内部还是在CPU上。
- en: This **Frame Budget**, depicted in the second-to-left-most column in the previous
    table, dictates what can happen during the inter-frame time. Go over the budget
    and the frame rate drops. Go too much under budget and time is being wasted that
    could be rendering additional frames or running other processing tasks. Performance
    management can be approached by either reducing the CPU Frame Time or by reducing
    the GPU Frame Time. Sometimes, there’s crossover between the two – a good example
    of this is the Thin Instances used for the Route Planning phases’ asteroid belt
    (see the *A Detour into Particle Systems* section of [*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142),
    *Processing Route Data*, for more).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**帧预算**，在上一张表的第二左列中显示，决定了在帧间时间期间可能发生的事情。超过预算，帧率会下降。预算过低，就会浪费本可以渲染额外帧或运行其他处理任务的时间。可以通过减少CPU帧时间或GPU帧时间来管理性能。有时，两者之间会有交叉——一个很好的例子是用于路线规划阶段的小行星带的薄实例（有关更多信息，请参阅[*第7章*](B17266_07_Final_AM.xhtml#_idTextAnchor142)的*粒子系统中的偏离*部分，*处理路线数据*）。
- en: Every frame, the asteroid’s rotation and position matrices are updated by code
    running on the CPU, which is then copied over into the GPU. These matrixes are
    then passed into the vertex and fragment shaders, which apply them during a single
    Draw call to every instance in the Scene. While this is an extremely fast process,
    there is one potential bottleneck on the CPU, and that’s the loop over each Thin
    Instance that recalculates the two matrices. Any improvements there would theoretically
    improve either the performance or the maximum number of asteroids that can be
    rendered without severe performance degradation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧，小行星的旋转和位置矩阵由在CPU上运行的代码更新，然后这些矩阵被复制到GPU中。然后这些矩阵被传递到顶点和片段着色器中，它们在单个Draw调用中将这些矩阵应用于场景中的每个实例。虽然这是一个非常快速的过程，但在CPU上存在一个潜在的瓶颈，那就是对每个薄实例的循环，它重新计算这两个矩阵。理论上，任何对此处的改进都会提高性能或在不严重降低性能的情况下渲染的小行星的最大数量。
- en: Shifting over to the GPU, bottlenecks can occur when the device is tasked with
    too many (or fewer, slower) shader programs competing for the same limited frame
    budget. The raw number of shader executions is expressed as the number of **Draw**
    calls made in each second and serves as a complement to the GPU intra-frame time
    spent executing shaders. As each Draw call is associated with a single material
    (some materials will make multiple calls to Draw), the number of different materials
    in a Scene is directly related to the number of times the GPU is being asked to
    switch contexts to run that material’s shader programs every second.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将计算任务转移到GPU上时，当设备被分配了太多（或更少、更慢）的着色器程序，这些程序竞争相同的有限帧预算时，可能会出现瓶颈。着色器执行的原始数量以每秒进行的**Draw**调用次数表示，并作为执行着色器所花费的GPU帧内时间的补充。由于每个Draw调用都与一个单一的材料相关联（某些材料会对Draw进行多次调用），场景中不同材料的数量与GPU每秒被要求切换上下文以运行该材料的着色器程序的次数直接相关。
- en: Switching the GPU between contexts (shaders) has been brutally optimized in
    hardware, but it isn’t completely free. Each shift carries a small amount of overhead,
    and though trivial individually, this can add up to substantial losses with large
    numbers. Thus, reducing the number of draw calls can improve performance directly
    from the reduced context switches and indirectly through the shader code that
    is no longer being invoked.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件上，GPU在上下文（着色器）之间的切换已经进行了残酷的优化，但这并不是完全免费的。每次切换都会带来一小部分开销，虽然单个切换微不足道，但大量切换累积起来可能会导致显著的损失。因此，减少绘制调用次数可以直接通过减少上下文切换来提高性能，间接地通过不再调用的着色器代码。
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The fastest code is code that doesn’t exist. Think about that.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最快的代码是不存在的代码。想想看。
- en: There are a few other metrics that are worth defining but are most obvious from
    their name or context. One exception, though, is Absolute FPS. Absolute FPS is
    the number of frames that can be processed each second, not counting any actual
    render timings. This is a measure of how well the CPU side of things is performing
    through its update loop.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他值得定义的指标，但它们从名称或上下文中最为明显。然而，有一个例外，那就是绝对帧率（Absolute FPS）。绝对帧率是指每秒可以处理的帧数，不计实际渲染时间。这是衡量CPU方面通过其更新循环表现如何的一个指标。
- en: As with most of the content in this book, the preceding terms aren’t a comprehensive
    survey of the 3D performance programming landscape, but as a primer for what comes
    next, it is as comprehensive as needed. A comfortably high frame rate – one at
    or above 60 FPS – carries a frame budget of around 16 milliseconds, during which
    all processing needed to process a simulation and prepare it for the next frame
    must be completed. GPUs are screamingly fast at doing this type of thing, but
    just as an overburdened CPU can spin and churn trying to service too many competing
    processes, so can a GPU become overburdened by shader programs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的大多数内容一样，前面的术语并不是对3D性能编程领域的全面概述，但作为下一部分的入门，它已经足够全面。一个舒适的帧率——至少达到60 FPS——大约有16毫秒的帧预算，在这段时间内，必须完成处理模拟和为下一帧做准备所需的所有处理。GPU在执行这类任务时非常快，但就像过载的CPU可能会因为服务过多的竞争进程而旋转和翻滚一样，GPU也可能因为着色器程序而过载。
- en: To help us understand what all of that talk about CPUs, GPUs, burdens, and everything
    else that plays out in an actual scenario, we need to learn about how and what
    to measure. Simply measuring things is rarely enough. Like chemistry students
    planning their lab procedures out in their notebooks, we’ll need to learn how
    to plan our testing strategies, as well as how to interpret the results. In the
    next section, we’re going to take on the tasks of planning out, executing, and
    interpreting a performance test, but not before we learn more about the tools
    that will help accomplish those tasks for us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解关于CPU、GPU、负担以及在实际场景中发生的所有其他内容的讨论，我们需要了解如何以及测量什么。仅仅测量事物通常是不够的。就像化学学生在笔记本上规划他们的实验步骤一样，我们需要学习如何规划我们的测试策略，以及如何解读结果。在下一节中，我们将承担规划、执行和解读性能测试的任务，但在那之前，我们需要更多地了解那些将帮助我们完成这些任务的工具。
- en: Measuring Performance and Identifying Bottlenecks
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量性能和识别瓶颈
- en: 'Effective problem-solving starts by clearly defining the problem that needs
    to be solved. Sometimes, this is less than obvious, or sometimes, there’s more
    than one problem that appears to be front and center. Oftentimes, the thing that
    makes defining a problem difficult is that it is presented as a qualitative statement,
    like this one: “The Route Planning Screen doesn’t perform well.”'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的解决问题的开始是明确界定需要解决的问题。有时，这并不明显，有时，可能存在多个问题似乎是最重要的。通常，使界定问题困难的是它被呈现为一个定性陈述，就像这样：“路线规划屏幕性能不佳。”
- en: A statement such as that one is unambiguIus in one sense – there’s no doubt
    as to its meaning – but it is completely opaque in another, for we have no understanding
    to what degree the performance is poor. That’s the basic difference between having
    qualitative data and having specific, qualitative measures. Without the former,
    there’s no understanding of the overall picture, and without the latter, there’s
    no way to know whether any actions have been resolved, mitigated, or even made
    worse. So, gathering quantitative data on how the Route Planning screen performs
    is the first step we need to take so that we can better define our conditions
    for victory, as it were.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的声明在一个意义上是不含糊的——对其含义没有疑问——但在另一个意义上是完全晦涩的，因为我们不了解性能有多差。这就是定性数据和具体、定性的度量之间的基本区别。没有前者，就无法理解整体情况，没有后者，就无法知道是否任何行动已经解决、缓解，甚至变得更糟。因此，收集有关路线规划屏幕性能的定量数据是我们需要采取的第一步，以便我们能够更好地定义我们的胜利条件。
- en: Inspecting the Performance of Route Planning
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查路线规划性能
- en: 'The Babylon.js Inspector is a Swiss-army knife of useful goodness. If you’re
    as-yet-unfamiliar with the Inspector, now wouldn’t be a bad time to check out
    the docs at [https://doc.babylonjs.com/toolsAndResources/tools/inspector](https://doc.babylonjs.com/toolsAndResources/tools/inspector),
    as well as take another refresher through [*Chapter 2*](B17266_02_Final_AM.xhtml#_idTextAnchor030),
    *Ramping up On Babylon.js*, to set you straight. The Inspector has long had a
    **Performance** tab that displays all manner of statistics regarding the currently
    running Scene, but until the Babylon.js v5.0 release, there wasn’t an easy way
    to capture and analyze those metrics as they progress over time. The **Performance
    Profiler** is an extensible tool that has two similar concepts but different practice
    modes: headless and real time.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 检查器是一个多功能的有用工具。如果你对检查器还不熟悉，现在查看[https://doc.babylonjs.com/toolsAndResources/tools/inspector](https://doc.babylonjs.com/toolsAndResources/tools/inspector)文档，以及再次回顾[*第2章*](B17266_02_Final_AM.xhtml#_idTextAnchor030)，*Babylon.js
    入门*，将是一个不错的时间，以帮助你入门。检查器长期以来一直有一个 **性能** 选项卡，显示有关当前运行场景的各种统计数据，但直到 Babylon.js
    v5.0 版本发布，还没有简单的方法来捕获和分析这些指标随时间进展的情况。**性能分析器**是一个可扩展的工具，有两个类似的概念但不同的实践模式：无头和实时。
- en: Important note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: In case you don’t recall, the keyboard shortcut for bringing up the Inspector
    when running Space-Truckers is *Shift* + *Alt* + *I*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不记得，在运行 Space-Truckers 时打开检查器的快捷键是 *Shift* + *Alt* + *I*。
- en: Real-Time Performance Viewer Metrics
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时性能查看器指标
- en: 'When running in Real Time mode, a live graph is rendered showing the selected
    metrics from a list of the available metrics. Headless mode, in contrast, displays
    nothing but captures data that can later be exported to CSV format for further
    analysis. All three of these options (Start/Stop, Real Time, Headless, and Import/Export
    to CSV) are covered in more detail in the BJS docs at [https://doc.babylonjs.com/toolsAndResources/tools/performanceProfiler](https://doc.babylonjs.com/toolsAndResources/tools/performanceProfiler).
    The following table lists the out-of-the-box metrics collected by the Performance
    Profiler, along with a basic explanation of these metrics:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时模式下运行时，会渲染一个实时图表，显示从可用指标列表中选择的指标。相比之下，无头模式只显示内容，但会捕获可以稍后导出为 CSV 格式以进行进一步分析的数据。这三个选项（启动/停止、实时、无头和导出到
    CSV）在 BJS 文档中有更详细的介绍，请参阅[https://doc.babylonjs.com/toolsAndResources/tools/performanceProfiler](https://doc.babylonjs.com/toolsAndResources/tools/performanceProfiler)。以下表格列出了性能分析器收集的默认指标，以及这些指标的基本说明：
- en: '![](img/Table_12.02_B17266.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_12.02_B17266.jpg)'
- en: The specific values for each of the preceding metrics will depend on the hardware
    and software environment, so specific target values aren’t very useful. The different
    property groupings of metrics tend to reflect the dimension or unit that values
    assume. The top section focuses on counted metrics – things such as the number
    of meshes, vertices, textures, and more. After that, there are timing metrics,
    which show the amount of time that specific parts of the scene are consuming during
    and in-between frames. It’s this base set of metrics that the Performance Profiler
    captures and displays in a visual graph. Let’s move on and look at what a procedure
    looks like for our profiling.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前述每个指标的具体值将取决于硬件和软件环境，因此特定的目标值并不很有用。指标的不同属性分组通常反映了值所采用的维度或单位。顶部部分侧重于计数指标——例如网格、顶点、纹理等的数量。之后，是时间指标，显示了场景的特定部分在帧内和帧间消耗的时间量。性能分析器捕获并以此基础集的指标在视觉图表中显示。让我们继续看看我们的分析过程是什么样的。
- en: Defining the Testing Procedure
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义测试程序
- en: Following the guidelines laid out previously in this chapter, we need to define
    a repeatable procedure for profiling the application. There’s no need to over-complicate
    this, so let’s do the Simplest Thing That Could Possibly Work. We want to refresh
    the web page for the application to reset and clear memory and such, and then
    we want to let the application settle for a bit and find its groove before we
    launch some cargo and take some more measurements. The last part is to save our
    performance profile to a CSV file for posterity before loading it into the Performance
    Viewer for basic analysis.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本章之前提出的指南，我们需要定义一个可重复的过程来分析应用程序。没有必要过度复杂化这一点，所以我们来做最简单的事情。我们希望刷新应用程序的网页以重置和清除内存等，然后我们希望让应用程序稍微稳定一下，找到它的节奏，在我们投放一些货物并获取更多测量数据之前。最后一步是将我们的性能配置文件保存到CSV文件中，以便将来加载到性能查看器中进行基本分析。
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Unless there’s a specific reason to not do it, always evaluate performance and
    capture metrics against code built in Production environment mode!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定的原因不这样做，否则始终评估在生产环境模式下构建的代码的性能和捕获指标！
- en: 'Here’s what our testing procedure looks like. Remember, we want to repeat this
    same series of steps every time we make a significant change to the code so that
    we can understand the impact of that change:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们测试过程的样子。记住，我们希望在每次对代码进行重大更改时重复这一系列步骤，以便我们可以理解该更改的影响：
- en: Refresh the browser, launch the game, and navigate to route planning
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新浏览器，启动游戏，并导航到路线规划
- en: Allow game to stabilize for 10s
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许游戏稳定10秒
- en: Begin capture
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始捕获
- en: Allow 10 seconds to stabilize and establish a baseline
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许10秒稳定并建立基线
- en: Launch cargo unit into an empty space
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将货物单元发射到空旷的空间
- en: Collect data for 10 seconds
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集数据10秒
- en: Stop capture and export to CSV
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止捕获并导出到CSV
- en: A more thorough testing procedure would also want to include camera panning
    and zooming, but this procedure will serve our purposes adequately. At this point
    in this book, *Step 1* shouldn’t need further elaboration. *Step 2* is also straightforward
    and to the point. It is *Step 3* where we need to pause to get into the details
    of what the step entails.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更彻底的测试过程还应该包括摄像头的平移和缩放，但这个程序将充分满足我们的需求。在本书的这个阶段，*步骤1*不需要进一步阐述。*步骤2*也很直接，切中要点。*步骤3*是我们需要暂停以详细了解该步骤包含的内容。
- en: 'Before we start capturing our profile, we need to launch the BJS Inspector
    by pressing the *Shift* + *Alt* + *I* key combination. The **Statistics** tab
    in the right-hand pane contains our target information, but first, detach the
    **Inspector** panes from the browser window (you can close the Scene Explorer
    instead if desired) so that they do not take up or cover up any part of the app
    window. If you’re using multiple monitors, it can be convenient to dedicate one
    monitor to the browser window, but it’s not required. Just remember the Guideline
    About Using the Same Screen Size and Resolution! When you’re ready, press the
    **Begin Recording** button circled in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始捕获配置文件之前，我们需要通过按*Shift* + *Alt* + *I*键组合来启动BJS检查器。右侧窗格中的**统计信息**选项卡包含我们的目标信息，但首先，请从浏览器窗口中分离**检查器**窗格（如果需要，可以关闭场景浏览器），以免占用或覆盖应用程序窗口的任何部分。如果您使用多个显示器，将一个显示器专用于浏览器窗口可能很方便，但这不是必需的。只需记住关于使用相同屏幕尺寸和分辨率的指南！准备好后，请按以下截图中的**开始录制**按钮：
- en: '![Figure 12.1 – The Statistics tab of the Inspector contains controls for starting,
    stopping, exporting, and viewing Performance Profile data'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 检查器的统计标签页包含用于启动、停止、导出和查看性能配置文件数据的控件'
- en: '](img/Figure_12.01_B17266.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.01_B17266.jpg)'
- en: Figure 12.1 – The Statistics tab of the Inspector contains controls for starting,
    stopping, exporting, and viewing Performance Profile data
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 检查器的统计标签页包含用于启动、停止、导出和查看性能配置文件数据的控件
- en: By clicking the **Begin Recording** button, we can initiate a performance profile
    in Headless mode. This gives us better accuracy because, in a nod to Dr. Heisenberg,
    our measurements won’t be affecting the application’s execution to as much of
    a degree.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**开始录制**按钮，我们可以以无头模式启动性能配置文件。这使我们获得了更好的准确性，因为，向海森堡博士致敬，我们的测量不会对应用程序的执行产生太大的影响。
- en: '*Step 4* involves the difficult task of waiting – without touching anything
    – for 10 seconds to allow stabilization to occur in the application. These first
    10 seconds also help establish a runtime baseline profile that we can use to compare
    different actions taken during a test. When the allotted time has passed, *Step
    5* is to point the launcher toward an empty patch of space and fire away – we
    want to capture the behavior of the game during flight. After letting the Cargo
    Unit cruise for another 10 seconds, *Step 6* has been completed, and thus *Step
    7* comes, where we click the **Stop Recording** button, followed by the **Export
    Perf to CSV** button, to download it. Now that we’ve finished capturing our profile,
    it’s time to examine it.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 4* 包含一个困难的任务，那就是在10秒内不触碰任何东西，等待应用稳定。这前10秒也有助于建立运行时的基准配置文件，我们可以用它来比较测试期间采取的不同操作。当规定的时间过去后，*步骤
    5* 是将发射器指向一片空旷的空间并发射——我们想要捕捉游戏在飞行中的行为。让货物单元再巡航10秒后，*步骤 6* 已经完成，因此 *步骤 7* 接着到来，我们点击**停止录制**按钮，然后点击**导出性能到CSV**按钮，以下载它。现在我们已经完成了配置文件的捕获，是时候检查它了。'
- en: Viewing and Analyzing a Captured Profile
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看和分析捕获的配置文件
- en: The fastest way to view a performance profile is to choose **Load Perf Viewer**
    using the **CSV** button, then select the freshly downloaded CSV file previously
    captured to launch the Perf Viewer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 查看性能配置文件最快的方式是使用**CSV**按钮选择**加载性能查看器**，然后选择之前捕获并新鲜下载的CSV文件以启动性能查看器。
- en: Important note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Depending on whether you’re doing this locally or against a deployed environment,
    your browser’s pop-up blocker may engage and prevent the **Realtime Performance
    Viewer** window from showing. Make sure you disable or add exceptions to your
    blocker rules to allow the window to appear!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你是本地操作还是针对已部署的环境，你的浏览器的弹出窗口阻止程序可能会激活并阻止**实时性能查看器**窗口显示。确保你禁用或添加例外到你的阻止规则，以允许窗口出现！
- en: Your first impression of the performance graph might be that someone spilled
    a box of colored spaghetti or perhaps Pick-up-Stix and now it’s going to need
    to be cleaned up. That’s because all metrics are selected for display at the time
    of load. Click the master toggles on the group headers to disable all the Count
    items, leaving FPS. Selectively remove items that have very small values – if
    something is taking less than a millisecond to complete, there are better things
    to worry about! The graph is a lot easier to comprehend now! Zoom in and out with
    the mouse wheel, while panning across the timeline by dragging.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你对性能图的第一个印象可能是有人洒了一盒彩色意大利面或可能是拾取棒，现在需要清理。这是因为所有指标都是在加载时选定的。点击组标题上的主切换按钮以禁用所有计数项，只留下FPS。有选择地移除具有非常小值的项——如果某件事完成所需时间少于毫秒，有更好的事情要担心！现在图表更容易理解了！使用鼠标滚轮放大和缩小，同时通过拖动在时间轴上平移。
- en: This will transition us from looking at a larger overall picture to a progressively
    more granular view of things, where there are a few things of interest to note.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们从观察一个更大的整体画面转变为对事物进行越来越细粒度的观察，其中有一些值得注意的事项。
- en: Initial Assessments
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始评估
- en: Notice how the Inter-frame time seems to correlate inversely with FPS? That
    is, if you look carefully at the two data series, you’ll see how the FPS drops
    dramatically any time there is a similar shift in the opposite direction by the
    Inter-frame time. Something else obvious to see in this format is the statement
    that whenever it takes more time between frames, there are fewer frames as a result.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意帧间时间似乎与FPS成反比？也就是说，如果你仔细观察这两个数据系列，你会看到每当帧间时间在相反方向上有类似的位移时，FPS都会急剧下降。在这个格式中，另一个显而易见的是，每当帧与帧之间的时间增加时，帧数就会相应减少。
- en: 'If we add the GPU frame time to this graph, a more nuanced picture starts to
    emerge. Although there are exceptions and outliers, in most of the areas where
    Inter-frame time increases (followed immediately by a drop in FPS), there is a
    corresponding *decrease* in GPU frame time:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将GPU帧时间添加到这张图中，一个更加细致的画面开始显现。尽管存在例外和异常值，但在大多数帧间时间增加（紧接着FPS下降）的区域，GPU帧时间会有相应的*减少*：
- en: '![Figure 12.2 – A snapshot of a portion of a performance profile'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 性能配置文件的一部分快照'
- en: '](img/Figure_12.02_B17266.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.02_B17266.jpg]'
- en: Figure 12.2 – A snapshot of a portion of a performance profile
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 性能配置文件的一部分快照
- en: In the preceding figure, the darker line at the top initially is the FPS, while
    the bottom-most line is the Inter-frame time. In the middle is the GPU frame time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，顶部较深的线条最初是FPS，而最底部的线条是帧间时间。中间的是GPU帧时间。
- en: If the GPU frame time is improving, why is the FPS dropping? Without knowledge
    of the Space-Truckers application and how it’s put together, it might take an
    expert a bit of time to puzzle out the source of this strange connection, but
    seasoned coders of the Space-Highways followers of this book will likely already
    know exactly what this means and what’s causing it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果GPU帧时间在改善，为什么FPS却在下降？如果没有关于Space-Truckers应用程序及其组成的了解，专家可能需要一些时间来弄清楚这种奇怪联系的原因，但本书Space-Highways的资深程序员读者可能已经确切知道这意味着什么以及是什么导致了这种情况。
- en: Integrating External Knowledge
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整合外部知识
- en: Even though the CPU and the GPU operate pretty much independently from each
    other, events or conditions affecting one can still indirectly affect the other.
    In the case of our **Route Planning Screen**, we can infer that the GPU frame
    time drops because it is waiting to be told what to do by the CPU. Therefore,
    it is the increase in the Inter-frame time that is the proximate cause of both
    the FPS drop and the GPU frame time decrease.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CPU和GPU基本上是独立运行的，但影响一个的事件或条件仍然可以间接影响另一个。在我们的**路线规划屏幕**的情况下，我们可以推断GPU帧时间下降是因为它在等待CPU告诉它做什么。因此，帧间时间的增加是FPS下降和GPU帧时间减少的直接原因。
- en: Reach back into your memories of [*Chapter 6*](B17266_06_Final_AM.xhtml#_idTextAnchor120),
    *Implementing Game Mechanics*, and recall how we went about implementing the asteroid
    belt in the *Building the Asteroid Belt* section. The belt is comprised of many
    hundreds of individual rock meshes that have been procedurally generated as a
    set of **Thin Instances**. Note that as we discussed in [*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142),
    *Processing Route Data*, Thin Instances are blazing fast because they run on the
    GPU.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[*第6章*](B17266_06_Final_AM.xhtml#_idTextAnchor120)，*实现游戏机制*，并回忆我们在*构建小行星带*部分是如何实现小行星带的。带子由成百上千个单独的岩石网格组成，这些网格作为一组**薄实例**以程序方式生成。请注意，正如我们在[*第7章*](B17266_07_Final_AM.xhtml#_idTextAnchor142)，*处理路线数据*中讨论的那样，薄实例运行在GPU上，因此速度极快。
- en: 'Checking the Particle frame steps timing tends to support that assertion as
    the amount of time the CPU spends managing particles is small enough that it is
    unlikely to account for the two distinctly different systems in use in the Scene
    (the Sun Particle System is also a GPU-based **ParticleSystem**, with the asteroid
    **Thin Instances** being the other). Why, then, focus on the asteroid belt as
    the source of our high Inter-frame bottleneck? This is because our Thin Instances
    are not statically held in place – they individually rotate. To accomplish this
    rotation, we implemented a scheme wherein we stored a set of rotation, position,
    and scaling data locally on the CPU. Every frame, we looped through the set of
    asteroids and adjusted the rotation values for each asteroid, updating their matrices
    before signaling to the GPU that it should refresh the **Thin Instance Buffer**
    to update the objects on screen:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 检查粒子帧步骤的时间通常支持这一说法，因为CPU在管理粒子上的时间足够短，不太可能是场景中使用的两个明显不同的系统（太阳粒子系统也是一个基于GPU的**粒子系统**，而小行星**薄实例**是另一个）的原因。那么，为什么我们要关注小行星带作为我们高帧间瓶颈的来源呢？这是因为我们的薄实例并不是静态保持在原地的——它们各自旋转。为了实现这种旋转，我们实施了一个方案，在该方案中，我们在CPU上本地存储了一组旋转、位置和缩放数据。每一帧，我们遍历小行星集合，调整每个小行星的旋转值，在向GPU发出刷新**薄实例缓冲区**的信号以更新屏幕上的对象之前，更新它们的矩阵：
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`gameData` for the Route Planning screen contains an `asteroidBeltOptions`
    configuration object, which, in turn, contains the number property that controls
    the number of asteroids (**Thin Instances**) to create and manage. Next, it’s
    time to test our hypothesis by running an experiment.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameData` 用于路线规划屏幕的数据包含一个 `asteroidBeltOptions` 配置对象，该对象反过来包含一个控制创建和管理小行星（**薄实例**）数量的数字属性。接下来，是时候通过运行实验来测试我们的假设了。'
- en: Validating Assumptions
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证假设
- en: Change the number of asteroids to about 75% percent of its current value, then
    re-run the performance profile. It should be immediately apparent that the Inter-frame
    time improves, along with the overall FPS. As we are hoping to see, the GPU frame
    time either stays constant or trends upwards, supporting our conjecture about
    the GPU waiting for work from an over-taxed CPU.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将小行星的数量更改为当前值的约75%，然后重新运行性能配置文件。应该立即明显地看出，帧间时间得到了改善，整体FPS也有所提高。正如我们所希望的，GPU帧时间要么保持不变，要么呈上升趋势，支持我们关于GPU等待过载CPU工作的推测。
- en: If you wish to be extra thorough (and you should if you’re still learning!),
    change the asteroid count again, but this time in the opposite direction, re-doing
    the test afterward. The results, once again, should support our proposed explanation
    that the number of asteroids is inversely correlated to the FPS, and the degree
    to which it correlates should be consistent between runs as well, showing both
    quantitative and qualitative sides of the story.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望做得更彻底（而且你应该这样做，如果你还在学习的话！），再次更改小行星的数量，但这次朝相反的方向，然后在测试之后重新进行。结果，再次支持我们提出的解释，即小行星的数量与FPS成反比，并且这种相关性在运行之间应该是一致的，展示了故事的定量和定性两个方面。
- en: Be sure to revert the change to the asteroid count since this is a situation
    where one size doesn’t fit all – different CPUs will be able to support a varying
    number of asteroids without tanking performance. We need to be able to dynamically
    change the asteroid count at runtime based on how well the app is performing.
    Once again Babylon.js has the perfect tool for the job – the Scene Optimizer.
    The **Babylon.js Inspector** is the launching pad for engaging in performance
    analysis and improvement. The **Statistics** tab contains a whole set of aggregated
    Counts – textures, meshes, and more – and timings, such as GPU time and FPS. Supplementing
    that, the metric display is the new Real-time Performance Viewer, which uses the
    same metrics to draw a time-evolving graph of performance. It can run in Real-Time
    and Headless mode, but Headless will have the least impact on performance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要将小行星的数量更改恢复原状，因为这是一个“一刀切”不适用的情况——不同的CPU能够支持不同数量的小行星而不会影响性能。我们需要能够在运行时根据应用程序的性能动态更改小行星的数量。再次证明，Babylon.js拥有完成这项工作的完美工具——场景优化器。**Babylon.js检查器**是进行性能分析和改进的起点。**统计信息**标签包含了一系列汇总的计数——纹理、网格等等——以及时间，如GPU时间和FPS。补充这些，指标显示是新的实时性能查看器，它使用相同的指标绘制性能随时间演变的图表。它可以在实时和头身模式下运行，但头身模式对性能的影响最小。
- en: Capturing and exporting performance data to CSV can be done with a click of
    the button but having a testing procedure in place is just as crucial as the data
    collected (if not more!). After defining our procedure, we saw how to execute
    it to capture a performance profile. Upon analysis of the profile, a trend appeared
    to emerge that indicated there might be a bottleneck in the CPU due to the number
    of asteroid Thin Instances involved in the Scene. Because it’s so easy to capture
    profiles – changing the number of asteroids and re-running the test doesn’t take
    long, and the results appear to confirm our assertion of connecting the number
    of asteroids to the overall frame rate.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击按钮即可捕获和导出性能数据到CSV文件，但建立一个测试程序与收集到的数据一样重要（如果不是更重要的话！）！在定义我们的程序后，我们看到了如何执行它以捕获性能配置文件。在分析配置文件后，出现了一种趋势，表明CPU可能存在瓶颈，这是由于场景中涉及的行星薄实例数量造成的。由于捕获配置文件非常容易——改变行星数量并重新运行测试不需要很长时间，而且结果似乎证实了我们将行星数量与整体帧率联系起来的断言。
- en: Improving this situation isn’t as simple as just lowering the number of asteroids,
    though. Because this is so heavily bound to the CPU’s ability to chug through
    the various matrix calculations, different CPUs are going to have different responses
    to the same variables. A dynamically set number of asteroids, matching the number
    the CPU can handle, would be the perfect solution. In the next section, we’ll
    learn all about how to use the Scene Optimizer in both its vanilla, out-of-the-box
    configuration and with a custom stratagem.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 改善这种情况并不像仅仅减少行星数量那么简单。因为这与CPU处理各种矩阵计算的能力紧密相关，不同的CPU对相同的变量会有不同的反应。一个动态设置的行星数量，与CPU可以处理的数量相匹配，将是完美的解决方案。在下一节中，我们将了解如何使用场景优化器，无论是其原始的、开箱即用的配置，还是使用自定义策略。
- en: Improving Runtime Performance with the Scene Optimizer
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用场景优化器提高运行时性能
- en: Developing games for a given platform comes with its own set of unique challenges
    and benefits. Console games have the benefit of having standard hardware specifications
    and drivers to target, but at the expense of those same hardware specifications
    creating severe limitations in other areas, such as RAM or **video RAM** (**vRAM**).
    Browser-based games have their own bag of double-edged swords too – the ubiquitous
    nature of JavaScript and the web brings similar problems to console developers
    with restricted hardware specs, and some of the same problems that PC developers
    must face with a wide variety of hardware combinations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为特定平台开发游戏有其独特的挑战和好处。控制台游戏的好处是具有标准硬件规格和驱动程序可以针对，但代价是相同的硬件规格在其他领域，如RAM或**视频RAM**（**vRAM**），造成了严重的限制。基于浏览器的游戏也有自己的双刃剑——JavaScript和网络的普遍性给硬件规格受限的控制台开发者带来了类似的问题，以及PC开发者必须面对的某些问题，这些问题是由于广泛的硬件组合造成的。
- en: Using the tools and lessons from this chapter and the preceding chapters of
    this book, it’s easy to imagine writing some code – a coroutine perhaps – that
    monitors the real-time performance of the application and makes tweaks to various
    settings in response to bring frame rates up to target. However, it is easy to
    imagine and probably easy to prototype or create a proof-of-concept that works
    in a few limited situations. The devil is always in the details though, and considerable
    time and effort would have to be expended that could otherwise be put to other
    uses.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章和本书前几章的工具和课程，很容易想象编写一些代码——可能是一个协程——来监控应用程序的实时性能，并根据需要调整各种设置以提高帧率。然而，想象起来可能很容易，也许原型设计或创建一个在少数有限情况下工作的概念验证原型也很容易。但魔鬼总是在细节中，而且需要投入相当的时间和精力，这些时间和精力本可以用于其他用途。
- en: Fortunately, and hopefully getting somewhat repetitive to hear at this point,
    is that Babylon.js has got you covered with **SceneOptimizer** ([https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer](https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer)).
    Every time the specified sampling interval passes (by default, every 2,000 ms),
    **SceneOptimizer** checks the current frame rate, and if it isn’t close to or
    at the target, the next optimization in the queue is applied. If the optimization
    is capable of further action, it remains in the queue until it reports it can’t
    help any longer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，并且希望到这一点已经有些重复了，Babylon.js已经通过**SceneOptimizer**为您提供了支持([https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer](https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer))。每当指定的采样间隔通过（默认情况下，每2,000毫秒），**SceneOptimizer**会检查当前帧率，如果它没有接近或达到目标，则应用队列中的下一个优化。如果优化能够采取进一步行动，它将保留在队列中，直到报告它不能再提供帮助。
- en: Through the `SceneOptimizerOptions` object, **SceneOptimizer** works from a
    queue of strategies that each offer a different type of performance optimization,
    allowing for graceful degradation of scene quality while maintaining a stable
    frame rate.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`SceneOptimizerOptions`对象，**SceneOptimizer**从一系列策略队列中工作，每个策略提供不同类型的性能优化，允许在保持稳定帧率的同时优雅地降低场景质量。
- en: 'Some examples of operations that the built-in optimization strategies can perform
    are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 内置优化策略可以执行的一些操作示例如下：
- en: Merging multiple similar meshes into a single mesh
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个相似网格合并成一个网格
- en: Disabling shadows and/or post-processes
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用阴影和/或后期处理
- en: Reducing texture resolution or hardware scaling
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低纹理分辨率或硬件缩放
- en: Particle count reductions
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少粒子数量
- en: Each specific **Optimization** has a priority value assigned to it, with lower
    valued optimizations being applied first. To make it more convenient, **SceneOptimizerOptions**
    has a set of static factory methods that allow you to specify a set of optimizations
    according to the amount of visual degradation you’re willing to allow in the scene
    – low, moderate, or high. See the docs at the link mentioned previously for more
    details on the specifics of which optimizations are used for what degradation
    level. Interestingly, **SceneOptimizer** can be configured to run in the opposite
    direction – instead of degrading scene quality, it will enable or apply effects
    until the point where the FPS drops to or below the target. This is useful in
    power-limited scenarios where energy usage is an important consideration but isn’t
    an area that we’re going to cover here (see *Extended Topics* for more though!).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个具体的**优化**都有一个优先级值，数值较低的优化首先应用。为了更方便，**SceneOptimizerOptions**提供了一套静态工厂方法，允许您根据愿意在场景中允许的视觉降级程度指定一组优化
    - 低、中或高。有关具体优化用于何种降级级别的详细信息，请参阅之前提到的链接中的文档。有趣的是，**SceneOptimizer**可以被配置为反向运行 -
    而不是降低场景质量，它将启用或应用效果，直到帧率下降到或低于目标。这在能量受限的场景中很有用，其中能量消耗是一个重要考虑因素，但不是我们将要讨论的领域（有关更多内容，请参阅*扩展主题*！）。
- en: In addition to the built-in optimization strategies, it’s possible to define
    custom optimization strategies. This is quite useful for our salient purpose and
    doesn’t require more than a line or two of JavaScript. We’re going to use this
    to create a custom strategy later in the *Creating a Custom Optimization Strategy
    for the Asteroid Belt* section, but first, let’s learn to crawl before we walk
    by learning a bit about **SceneOptimizer** on its own. Don’t be fooled by the
    tall Section Headers – it’s quite simple when we look at the mechanics of it!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的优化策略之外，还可以定义自定义优化策略。这对于我们的主要目的非常有用，并且不需要超过一行或两行的JavaScript代码。我们将在*为小行星带创建自定义优化策略*部分稍后创建一个自定义策略，但首先，在我们学习走路之前，让我们先学习如何爬行，通过学习一些关于**SceneOptimizer**的知识。不要被高大的章节标题所迷惑
    - 当我们查看其机制时，它相当简单！
- en: Understanding the Scene Optimizer and its Operating Modes
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解场景优化器及其工作模式
- en: 'The Babylon.js Scene Optimizer executes in one of two modes: Improvement and…
    `!isInImprovementMode`. That’s a bit of an insider joke because that’s the property
    set by the last parameter to the `true` is set, optimizations are applied until
    the target frame rate has been reached or we run out of strategies to apply. When
    `false`, it does the opposite or enhances the visuals while the frame rate is
    *above* the target. Each Optimization (even Custom ones) adapts its behavior to
    whichever mode is set, so a strategy that tries to increase frame rate might turn
    off shadows when in optimization mode and turn them on when in enhancement mode.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 场景优化器以两种模式之一执行：改进模式和…`!isInImprovementMode`。这有点像内部玩笑，因为这是由`true`设置的最后一个参数确定的属性，优化会一直应用，直到达到目标帧率或我们用完了可应用的策略。当设置为`false`时，它执行相反的操作或增强视觉效果，同时帧率在目标帧率之上。每个优化（即使是自定义优化）都会根据设置的任何模式调整其行为，因此一个试图提高帧率的策略在优化模式下可能会关闭阴影，而在增强模式下会打开它们。
- en: The list of optimization/enhancement strategies used by `SceneOptimizerOptions`
    module. Although it’s possible to start with a blank set of options and manually
    create and add strategies, a set of static factory methods for `SceneOptimizerOptions`
    are available that will create a pre-defined set of strategies based on how aggressive
    or extensive the actions are. The three methods range from `LowDegradationAllowed`
    to `HighDegradationAllowed` (see [https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer#options](https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer#options)
    for more on the specific strategies included in each).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`SceneOptimizerOptions`模块使用的优化/增强策略列表。虽然可以从空白选项集开始，手动创建和添加策略，但`SceneOptimizerOptions`提供了一套静态工厂方法，可以根据动作的激进程度或广泛程度创建预定义的策略集。这三种方法从`LowDegradationAllowed`到`HighDegradationAllowed`（有关每个策略中包含的具体策略的更多信息，请参阅[https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer#options](https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer#options)）。'
- en: Important note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Changing the value of `isInImprovementMode` will not affect the behavior of
    **SceneOptimizer**– the only place that it can be set is in the constructor!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 改变`isInImprovementMode`的值不会影响**SceneOptimizer**的行为——它只能设置的唯一地方是在构造函数中！
- en: Once you’ve set up `sceneOptimizer.start()` and halted with `sceneOptimizer.stop()`.
    To help with debugging and troubleshooting (among other potential uses), **SceneOptimizer**
    has a set of three Observables that are triggered whenever an optimization is
    applied, succeeds, or fails, respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了`sceneOptimizer.start()`并使用`sceneOptimizer.stop()`停止，为了帮助调试和故障排除（以及其他潜在用途），**SceneOptimizer**有一组三个可观察对象，分别在应用优化、成功或失败时触发。
- en: Any Optimizer (that is, a Strategy for those who like Code Patterns) that is
    to be used with `apply` and `getDescription`. The `apply(scene, optimizer)` method
    is called against each Optimization with a `priority` matching the current `priority`
    of `getDescription` is responsible for returning a human-readable textual description
    of what the Optimization does to the given Scene. That’s all there is to it at
    a basic level – simple as promised! Building from this simple foundation, and
    now that we’re ready for it, let’s focus on that custom Optimization hinted at
    earlier.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 任何要用于`apply`和`getDescription`的**Optimizer**（对于那些喜欢代码模式的人来说，这是一个策略）。`apply(scene,
    optimizer)`方法针对每个优化调用，并带有与`getDescription`当前`priority`匹配的`priority`，负责返回一个人类可读的文本描述，说明优化对给定场景做了什么。这就是基本水平上的全部内容——简单如承诺！从这个简单的基础上构建，现在我们已经准备好了，让我们关注之前提到的那个自定义优化。
- en: Creating a Custom Optimization Strategy for the Asteroid Belt
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为小行星带创建自定义优化策略
- en: Earlier in this chapter, we used the `thinInstanceCount` property, this seems
    like a good candidate for a custom Optimization Strategy.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们使用了`thinInstanceCount`属性，这似乎是一个自定义优化策略的良好候选者。
- en: Though several different ways exist to define an `sceneOptimizerOptions.addCustomOptimization`
    method. This function takes three parameters – callbacks for `apply` and `getDescription`
    and a value for `priority` that, by not-much-of-a-coincidence, happens to be the
    interface contract for an **Optimizer** that we so recently discussed!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在多种定义`sceneOptimizerOptions.addCustomOptimization`方法的方式。这个函数接受三个参数——`apply`和`getDescription`的回调以及一个表示`priority`的值，这个值并非巧合地恰好是我们最近讨论过的**Optimizer**接口合同！
- en: 'The Playground at [https://playground.babylonjs.com/#17ZX41#10](https://playground.babylonjs.com/%2317ZX41%2310)
    is a modified and stripped-down version of some earlier PGs that we looked at
    during [*Chapter 6*](B17266_06_Final_AM.xhtml#_idTextAnchor120), *Implementing
    Game Mechanics*. This PG just contains the central star and the TI asteroid belt.
    Play with `asteroidBeltOptions.number` until you get a value that gives you a
    low-ish frame rate, then click the `fastOptimizer` to see `createScene` method
    body. Most of this should be easy to understand, but one potential head-scratcher
    is this line of code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[游乐场](https://playground.babylonjs.com/%2317ZX41%2310)是我们在[*第6章*](B17266_06_Final_AM.xhtml#_idTextAnchor120)，“实现游戏机制”中查看的一些早期PGs的修改和简化版本。这个PG只包含中心恒星和TI小行星带。调整`asteroidBeltOptions.number`的值，直到你得到一个较低的帧率，然后点击`fastOptimizer`来查看`createScene`方法体。大部分内容应该很容易理解，但一个可能的难题是这一行代码：'
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What’s happening here? Well, we want our TI Optimizer to run first before any
    other Optimizers do. Yes, it’s like we’re an only or a first-born child – incredibly
    selfish and self-centered – but this is our application, and we know what we’re
    doing. For the most part. But we also can’t allow other Optimizations to run at
    the same priority because we don’t want to change anything except for the TI count
    before trying anything else to improve things. So, we loop over every existing
    priority in the `optimizerOptions` object and bump its priority to be one greater
    than whatever it previously was at (the default value is zero). That way, in the
    very next line, when we call `addCustomOptimization` with a priority of `0`, we
    know our stuff comes first. Take that, younger Sibs! The custom optimization definition
    can account for either mode of operation, and in its full version, it is capable
    of automatically computing min and max values for the instance count based on
    degradation requirements. The following code has been abridged for brevity and
    clarity but otherwise, it is the same as its big brother at [https://github.com/jelster/space-truckers/blob/ch12/src/thinInstanceCountOptimization.js](https://github.com/jelster/space-truckers/blob/ch12/src/thinInstanceCountOptimization.js):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？嗯，我们希望我们的TI优化器在尝试其他任何优化器之前先运行。是的，就像我们是一个独生子或第一个孩子一样——极其自私和以自我为中心——但这是我们自己的应用程序，我们知道我们在做什么。大部分时间是这样。但我们也不能允许其他优化以相同的优先级运行，因为我们不想在尝试其他任何改进措施之前改变除了TI数量之外的其他任何东西。因此，我们在`optimizerOptions`对象中的每个现有优先级上循环，将其优先级提升到比之前更高的值（默认值为零）。这样，在下一行，当我们以优先级`0`调用`addCustomOptimization`时，我们知道我们的东西是第一位的。去你的，年轻的兄弟姐妹们！自定义优化定义可以适应两种操作模式，在其完整版本中，它能够根据退化要求自动计算实例数量的最小值和最大值。以下代码为了简洁和清晰而进行了缩减，但除此之外，它与它的“大哥”在[https://github.com/jelster/space-truckers/blob/ch12/src/thinInstanceCountOptimization.js](https://github.com/jelster/space-truckers/blob/ch12/src/thinInstanceCountOptimization.js)上是一样的：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The interesting thing in the preceding code is that instead of changing the
    TI count by a fixed, set amount, we are changing it in increments of roughly 9%.
    This allows designers and developers to make changes more freely to the base asteroid
    count without needing to make other changes to accommodate different scales of
    values. Hopefully, it’s easy to see how easy it can be to make runtime adaptations
    to an application’s visual quality to meet a target frame rate, because that’s
    the extent of what we’re going to be covering in this topic, at least for this
    edition of this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中有趣的地方在于，我们不是通过固定的、固定的数量来改变TI的数量，而是以大约9%的增量来改变它。这使得设计师和开发者可以更自由地对基本小行星数量进行更改，而无需对其他不同规模的价值进行其他更改。希望这很容易看出，如何轻松地对应用程序的视觉质量进行运行时调整，以满足目标帧率，因为这就是我们将要讨论的主题的范围，至少在本版书中是这样。
- en: There’s nothing magical about **SceneOptimizer**, even though the effect it
    has of saving developers’ time certainly can be that way. With the incredible
    number of individual performance characteristics accessible to web applications,
    the amount of hand-optimization that is possible or practical becomes more difficult
    and expensive. Balancing performance optimizations done at design time with ones
    dynamically applied at runtime can be the key to getting beautiful and smooth
    visuals for the widest possible range of audiences.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**SceneOptimizer**并没有什么神奇之处，尽管它为开发者节省时间的效果确实可能让人感觉如此。考虑到网络应用可以访问的无数个单独的性能特性，可能或实际的手动优化变得更为困难且昂贵。在设计时进行的性能优化与在运行时动态应用的优化之间的平衡可能是为尽可能广泛的受众获得美丽和流畅视觉效果的关键。'
- en: '`SceneOptimizerOptions` object that defines the set of Optimizations that will
    be executed and whether they should be run to improve the frame rate to improve
    the visuals. Many built-in optimizations are provided and can be quickly created
    with `SceneOptimizerOptions.LowDegradationAllowed` and its companion methods,
    but custom Optimizations are almost as quick and easy to use too. Our custom optimizer
    changes the number of TIs until the target frame rate has been achieved. By adding
    it to the Optimization collection by passing an `apply` function, a `getDescription`
    function, and a priority number to `optimizerOptions.addCustomOptimization`, the
    custom optimizer is intended to run solo. Therefore, before we even do that, we
    must nudge the existing Optimization priorities up to keep ours both first and
    on its own in the queue.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`SceneOptimizerOptions`对象定义了将要执行的一组优化以及是否应该运行它们以提高帧率以改善视觉效果。提供了许多内置优化，可以使用`SceneOptimizerOptions.LowDegradationAllowed`及其配套方法快速创建，但自定义优化几乎同样快速且易于使用。我们的自定义优化器会改变TIs的数量，直到达到目标帧率。通过传递一个`apply`函数、一个`getDescription`函数和一个优先级数字到`optimizerOptions.addCustomOptimization`，将自定义优化器添加到优化集合中，目的是让它独立运行。因此，在我们这样做之前，我们必须调整现有的优化优先级，以确保我们的优化既排在第一位，又独立于队列中。'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When condensed down to an outline form, it may not seem like we covered a whole
    lot of ground in this chapter, but nothing could be further from the truth! Sure,
    there has been little to no mention of many important areas of performance optimization
    and measurement. We’ve covered nothing about the use of **Octtrees** to speed
    up collisions and mesh selection ([https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees](https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees)),
    toggling various convenience caches to reduce memory footprints ([https://doc.babylonjs.com/divingDeeper/scene/reducingMemoryUsage](https://doc.babylonjs.com/divingDeeper/scene/reducingMemoryUsage)),
    or any other of the almost two-dozen specific optimization heuristics ([https://doc.babylonjs.com/divingDeeper/scene/optimize_your_scene](https://doc.babylonjs.com/divingDeeper/scene/optimize_your_scene))
    that constitute “low-hanging fruit” areas for improvement. That’s OK, though.
    This book’s title starts with *Going the Distance*, not *Plumbing the Depths*,
    and we can always detour into those details in the Second Edition (should there
    ever be one!).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当将内容浓缩成提纲形式时，可能看起来我们在这章中并没有涵盖很多内容，但事实远非如此！当然，关于性能优化和测量的许多重要领域几乎没有提及。我们没有涉及使用**八叉树**来加速碰撞和网格选择([https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees](https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees))，切换各种便利缓存以减少内存占用([https://doc.babylonjs.com/divingDeeper/scene/reducingMemoryUsage](https://doc.babylonjs.com/divingDeeper/scene/reducingMemoryUsage))，或者任何其他几乎二十种具体的优化启发式方法([https://doc.babylonjs.com/divingDeeper/scene/optimize_your_scene](https://doc.babylonjs.com/divingDeeper/scene/optimize_your_scene))，这些方法构成了改进的“低垂的果实”领域。尽管如此，这也是可以的。这本书的标题是以“走得更远”开头，而不是“深入挖掘”，我们总可以在第二版（如果有的话！）中深入这些细节。
- en: What we have covered are the basics of how to approach thinking and learning
    about performance testing and profiling, starting with general guidelines and
    advice before progressing to the **Real-Time Performance Viewer** tool new to
    Babylon.js v5\. Using those skills, we took a capture of our application and used
    it to identify factors that show that performance is sensitive to changes, such
    as the number of asteroids rendered in the Route Planning Asteroid Belt. Finally,
    we saw how easy basic scene optimization at runtime can be with **SceneOptimizer**.
    We solved the previously identified performance bottleneck with a custom optimization
    strategy that will gradually lower the number of thin instances until the frame
    rate reaches acceptable levels.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所涵盖的是如何思考和学习性能测试和剖析的基础知识，从一般指南和建议开始，然后过渡到Babylon.js v5新引入的**实时性能查看器**工具。利用这些技能，我们捕获了我们的应用程序，并使用它来识别表明性能对变化敏感的因素，例如在路线规划小行星带中渲染的小行星数量。最后，我们看到了如何通过**场景优化器**轻松进行基本场景优化。我们通过一个自定义优化策略解决了之前识别的性能瓶颈，该策略将逐渐减少薄实例的数量，直到帧率达到可接受的水平。
- en: In the next chapter, we’ll learn how to enhance our game and level it up from
    a regular web application to a Progressive Web Application. This will be the final
    step of making our game fully playable and accessible to everyone at any time;
    by the end of the next chapter, we’ll have an application ready to run offline
    and be published to the major app stores!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将我们的游戏从普通Web应用提升到渐进式Web应用。这将是我们使游戏完全可玩并随时可供所有人访问的最终步骤；到下一章结束时，我们将有一个可以离线运行并发布到主要应用商店的应用程序！
- en: Extended Topics
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: 'As always, there’s more to learn and explore in the topics we’ve looked at
    in this chapter. The following are ways you can engage further and practice the
    knowledge you’ve gained in the chapter. Don’t forget to post your questions and
    share your accomplishments on the Babylon.js forums or in the Space-Truckers discussion
    boards at [https://forum.babylonjs.com](https://forum.babylonjs.com) and [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如往常一样，在本章中我们探讨的主题还有更多值得学习和探索的内容。以下是一些你可以进一步参与和实践本章所学知识的方法。别忘了在Babylon.js论坛或[https://forum.babylonjs.com](https://forum.babylonjs.com)和[https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions)的Space-Truckers讨论板上发布你的问题和分享你的成就：
- en: Perform a more comprehensive quantitative analysis of the asteroid belt data
    to extract the precise relationship between the FPS and asteroid count. What is
    the specific FPS to asteroid ratio? Having the CSV file is handy here because
    spreadsheet tools such as Excel, Sheets, and Google Sheets are the best way to
    compare and calculate these figures.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对小行星带数据进行更全面的定量分析，以提取帧数和 asteroid 数量之间的精确关系。具体的帧数与 asteroid 比率是多少？拥有CSV文件在这里很有用，因为像Excel、Sheets和Google
    Sheets这样的电子表格工具是对比和计算这些数字的最佳方式。
- en: Are there ways to rewrite the `AsteroidBelt.update` method to reduce the CPU
    inter-frame time? Maybe it isn’t necessary to loop through every asteroid individually
    if they could be addressed in bundles or batches…
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有没有方法可以重写`AsteroidBelt.update`方法来减少CPU帧间时间？也许如果可以将小行星以包或批次处理，就不必逐个循环遍历每个小行星了…
- en: Along the lines of the previous bullet point, is it possible to refactor the
    Asteroid Belt so that it behaves identically to how it does currently, but happen
    entirely on the GPU? Given what we learned about Shaders and Node Materials in
    the previous chapter, the answer should be an enthusiastic “YES!”. Now go prove
    it by making it happen!
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着前面提到的要点，我们是否可以重构小行星带，使其行为与当前完全相同，但全部在GPU上完成？鉴于我们在上一章中学到的关于着色器和节点材料的知识，答案应该是热情的“YES!”。现在就去证明这一点吧！
- en: Invert the custom asteroid scene optimization strategy to add thin instances
    instead of removing them. Integrate this with the application so that the scene
    tries to maintain a comfortable FPS range between 24 and 60.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自定义小行星场景优化策略反转，以添加薄实例而不是移除它们。将此集成到应用程序中，以便场景尝试保持24到60帧每秒之间的舒适FPS范围。
- en: Add the ability for users to configure an overall graphics quality preference
    setting. Their choice could influence the specific `SceneOptimizerOptions` that
    are included to either improve visuals or performance.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户提供配置整体图形质量偏好设置的选项。他们的选择可能会影响包含以改善视觉效果或性能的特定`SceneOptimizerOptions`。
