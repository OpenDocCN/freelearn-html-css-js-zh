- en: Web and Service Workers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和服务工作者
- en: Let's suppose that you are building a cool web app, say, to factorize a number
    to two prime numbers. Now, this involves a lot of CPU-intensive work, which will
    block the main UI thread. The main UI thread is the traffic lane that the end
    user directly observes and perceives. If it seems congested (laggy) or blocked,
    even for a few seconds, it destroys the user experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个酷炫的Web应用，比如说，将一个数分解为两个质数。现在，这涉及到大量的CPU密集型工作，这将阻塞主UI线程。主UI线程是最终用户直接观察和感知的交通车道。如果它看起来拥堵（卡顿）或阻塞，即使只有几秒钟，也会破坏用户体验。
- en: This is where web workers come into the picture. Web workers can be thought
    of as those side-lanes available on the road where you can divert heavy and slow
    (CPU-intensive) trucks so that you don't block a user's shining Lamborghini on
    the main road (the main UI thread).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是web工作者发挥作用的地方。可以将web工作者想象为道路上的那些侧车道，你可以将重型和缓慢（CPU密集型）的卡车转移到那里，这样你就不至于阻塞主路上的用户闪亮的兰博基尼（主UI线程）。
- en: On the other hand, service workers are quite cool, too. A service worker is
    your own programmable network proxy, which sits right in between the user's internet
    connection and your website. There will be more on that in the *Working with service
    workers* section.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，服务工作者也非常酷。服务工作者是你自己的可编程网络代理，它位于用户互联网连接和你的网站之间。在*与服务工作者一起工作*部分将有更多关于这个话题的介绍。
- en: 'In this chapter, we''ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Introduction to threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程的介绍
- en: Introduction to web workers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络工作者的介绍
- en: Introduction to dedicated workers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用工作者的介绍
- en: Setting up dedicated workers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置专用工作者
- en: Introduction to shared workers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享工作者的介绍
- en: Setting up shared workers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置共享工作者
- en: Setting up inline web workers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置内联web工作者
- en: Communication with the main thread
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与主线程的通信
- en: Introduction to service workers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者的介绍
- en: Setting up service workers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置服务工作者
- en: An introduction to the concept of threads
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程概念的介绍
- en: Simply put, a thread is a simple and independent snippet of running code. It
    is a container in which your tasks get executed. Before web workers, JavaScript
    provided just a single thread; that is, the main thread for the developers to
    do everything in.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，线程是一个简单且独立的运行代码片段。它是你的任务被执行的容器。在web工作者之前，JavaScript只提供了一个线程；即开发者的主线程，用于做所有事情。
- en: This created some problems with advancements in tech. Suppose you're running
    a smooth CSS3 animation, and suddenly you need to do a heavy calculation on the
    JavaScript end for some reason. This'll make the animation sluggish if you do
    it on the main thread. However, if you offload it to a web worker that runs in
    its own thread, it will have no effect on the user experience.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这在技术进步方面造成了一些问题。假设你正在运行一个平滑的CSS3动画，突然你需要因为某种原因在JavaScript端进行一些重量级的计算。如果你在主线程上这样做，这会使动画变得迟缓。然而，如果你将其卸载到在其自己的线程中运行的web
    worker，它将不会对用户体验产生影响。
- en: 'Because web workers run in their own threads, they cannot have access to the
    following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于web workers在其自己的线程中运行，它们无法访问以下内容：
- en: '`DOM`: It is not thread-safe to access it from web workers and the main UI
    script'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOM`：从web工作者和主UI脚本访问它不是线程安全的'
- en: '`parent` object: Basically, this gives access to some DOM APIs that for the
    same reason as stated above, would be thread-unsafe to access'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`对象：基本上，这提供了访问一些DOM API的权限，正如上述原因，访问这些API也是线程不安全的'
- en: '`window` object: BOM (Browser Object Model); access to this is also thread-unsafe'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window`对象：浏览器对象模型（BOM）；访问此对象也是线程不安全的'
- en: '`document` object: `DOM` object; hence, thread-unsafe'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document`对象：`DOM`对象；因此，线程不安全'
- en: Web workers lack access to all of the aforementioned items because it is not
    thread-safe to give workers access to them. Let's learn more about what I mean
    by that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Web工作者无法访问上述所有内容，因为给予工作者访问它们不是线程安全的。让我们更深入地了解我所说的意思。
- en: What makes something thread-safe?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是线程安全？
- en: When two or more threads access a common data source, extreme care must be taken,
    because there is a high chance of data corruption and thread safety conditions
    such as deadlocks, preconditions, race conditions, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程访问一个公共数据源时，必须非常小心，因为数据损坏和线程安全条件（如死锁、先决条件、竞争条件等）的可能性很高。
- en: JavaScript did not add thread support from the very start. With web workers
    introducing a **sort-of** threading environment in JavaScript, it'll help to understand
    a few conditions associated with threads in general.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript从一开始就没有添加线程支持。随着网页工作者在JavaScript中引入了一种**类似**的线程环境，这将有助于理解与线程相关的一些条件。
- en: What, exactly, is a deadlock?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是死锁？
- en: 'A deadlock is a situation where two threads are waiting for each other, for
    whatever reasons, and the reasons of both threads depend on each other. The following
    figure will explain what deadlock means:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁是一种情况，其中两个线程因为各种原因而相互等待，两个线程的原因相互依赖。以下图将解释什么是死锁：
- en: '![](img/2baf6d73-527e-4759-b8b3-762242b2d7c9.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2baf6d73-527e-4759-b8b3-762242b2d7c9.png)'
- en: Clearly, both threads (people with guns) need the other thread's resource in
    order to proceed. So, nobody proceeds.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，两个线程（持有枪支的人）都需要对方的资源才能继续进行，所以没有人能继续进行。
- en: What, exactly, is a race condition?
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是竞争条件？
- en: A **race condition** is a problem that can happen if a DOM is allowed to be
    accessed by web workers. A race condition is a condition where two threads race,
    or compete, to read/modify a single data source. This is dangerous because when
    both threads try to modify the data at same time, and it is unknown which one
    will modify the data first. Consider the following example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许网页工作者访问DOM，可能会发生**竞争条件**问题。竞争条件是指两个线程竞争或竞争读取/修改单个数据源的情况。这是危险的，因为当两个线程同时尝试修改数据时，无法确定哪个线程会先修改数据。考虑以下示例。
- en: 'Suppose two threads are working on the same variable in memory:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个线程正在内存中处理相同的变量：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Race conditions can be avoided by using **semaphores**, which is nothing but
    locking a shared data resource, until one thread is done with it and releases
    it back.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**信号量**可以避免竞争条件，这实际上就是锁定共享数据资源，直到一个线程完成并释放它。
- en: '**Just a fun fact:** If you ever use `sudo apt-get update` on Ubuntu or any
    Linux distro supporting `apt-get` as the package manager, and try to run another
    `apt-get update` command in another Terminal, you''ll get this error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**有趣的事实：**如果你在Ubuntu或任何支持`apt-get`作为包管理器的Linux发行版上使用`sudo apt-get update`，然后在另一个终端中尝试运行另一个`apt-get
    update`命令，你会得到这个错误：'
- en: '`E: Unable to lock the administration directory (/var/lib/dpkg/) is another
    process using it?`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`E: 无法锁定管理目录 (/var/lib/dpkg/)，另一个进程正在使用它？`'
- en: Linux locks the directory to avoid a possible race condition in which two commands
    overwrite each other's results.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Linux锁定目录是为了避免两个命令相互覆盖结果的潜在竞争条件。
- en: Most languages have just a single thread that interacts with and updates the
    UI, and other threads can only post messages to the main thread to update the
    UI.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言只有一个线程与UI交互并更新UI，其他线程只能向主线程发送消息以更新UI。
- en: Introduction to web workers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页工作者的简介
- en: The web worker is, essentially, a piece of JS code which does not run in the
    same thread as your main application. And by thread, I literally mean a different
    thread. The web workers truly enable JS to work in a multi-threaded mode. A question
    that might arise here is, What are the differences between asynchronous operations
    and web workers?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 网页工作者本质上是一段不在你的主应用程序线程中运行的JS代码。而且，我说的线程字面意思是不同的线程。网页工作者真正使JavaScript能够在多线程模式下工作。这里可能会出现的一个问题是，异步操作和网页工作者之间有什么区别？
- en: If you think about it, they are more or less the same thing. The web workers
    take away loads from the main thread for a while and then come back with the results.
    However understand the fact that `async` functions run on the UI thread, whereas
    web workers do not. Also, web workers are long-lived, and live inside a separate
    thread, whereas asynchronous operators, as we discussed in *Chapter 4, Asynchronous
    Programming,* follow the *Event loop*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，它们基本上是同一件事。网页工作者会暂时从主线程中卸载一些负载，然后带着结果回来。然而，要理解的是，`async`函数在UI线程上运行，而网页工作者则不是。此外，网页工作者是长期存在的，它们存在于一个单独的线程中，而异步操作符，如我们在*第4章，异步编程*中讨论的，遵循*事件循环*。
- en: 'Performance-wise, web workers are also much faster than traditional asynchronous
    operations. Here''s a test which sorts randomly generated arrays of lengths **10K**
    and **1M** as an asynchronous operation and web worker:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，网页工作者也比传统的异步操作快得多。这里有一个测试，它将随机生成的长度为**10K**和**1M**的数组作为异步操作和网页工作者进行排序：
- en: '![](img/0fd49ce5-f3e9-4e78-9db0-669da6798119.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fd49ce5-f3e9-4e78-9db0-669da6798119.png)'
- en: Take note that **2,493 ops/sec** means that JS was able to sort **2,493** arrays
    of length **10K** in **1** second! Async JS, on the other hand, was able to sort
    about 67 arrays of length **10K** in **1** second, which is still pretty darn
    fast, but quite a lot slower than its competitor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**2,493 ops/sec** 意味着JS能够在1秒内对**2,493**个长度为**10K**的数组进行排序！另一方面，异步JS在1秒内能够对大约67个长度为**10K**的数组进行排序，这仍然非常快，但比其竞争对手慢得多。
- en: Checking if worker support is available
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查工作支持是否可用
- en: Although web workers have been around for quite a long time and support is very
    strong, you still might want to check if web worker support is available in a
    client's browser (for example, Opera Mini doesn't support it). If it isn't, then
    just load the web worker file in the main script as well, and let your user feel
    the heat.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Web工作器已经存在很长时间，并且支持非常强大，但你仍然可能想要检查客户端浏览器中是否支持Web工作器（例如，Opera Mini不支持它）。如果不支持，那么只需在主脚本中也加载Web工作器文件，让你的用户感受到这种热感。
- en: 'Web workers are available as a `window` object, so that is pretty much all
    you have to check in order to get started:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Web 工作器作为 `window` 对象可用，因此你只需检查这一点就可以开始：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Working with dedicated web workers
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用专用 Web 工作器
- en: '**Dedicated workers** are the workers dedicated to a single main script. That
    means the worker cannot interact with any other script, apart from the main script
    on the page or any other domain.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**专用工作器**是专门为单个主脚本服务的工作器。这意味着工作器不能与任何其他脚本交互，除了页面上或任何其他域的主脚本。'
- en: Let us try to understand dedicated workers by setting one up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过设置一个专用工作器来尝试理解专用工作器。
- en: Setting up a dedicated worker
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置专用工作器
- en: 'Calling a `new Worker()` with a filename in the constructor argument is all
    you need to do to spawn a dedicated worker:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数中的文件名调用 `new Worker()` 是创建专用工作器所需做的全部事情：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `new Worker` constructor, we created a `Worker` instance. This will
    make the browser download the `myworker.js` file and start a new OS thread for
    it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `new Worker` 构造函数，我们创建了一个 `Worker` 实例。这将使浏览器下载 `myworker.js` 文件并为它启动一个新的操作系统线程。
- en: 'This is what we can place in the `myworker.js` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `myworker.js` 文件中放置以下内容：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This logs `Hello world` inside the console.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台内打印 `Hello world`。
- en: A worker can create a sub-worker itself, and everything below will apply to
    that, as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 工作器可以自己创建子工作器，以下所有内容也适用于该子工作器。
- en: Working with dedicated workers
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用专用工作器
- en: Dedicated workers can communicate with their spawning script, listening to certain
    events which trigger when either of the scripts sends/receives a message.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 专用工作器可以与其启动脚本通信，监听某些事件，这些事件在任一脚本发送/接收消息时触发。
- en: These events can be handled in both scripts (worker and main script) using certain
    event handlers. Let us learn how to achieve that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件可以通过某些事件处理器在两个脚本（工作器和主脚本）中处理。让我们学习如何实现这一点。
- en: Listening for messages on the main script
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在主脚本上监听消息
- en: 'We can listen to what a worker sent to the main script with the `onmessage`
    event. This is how it''ll look:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `onmessage` 事件监听一个工作器发送到主脚本的任何内容。这将是它的样子：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, our script is listening for messages sent by the worker. Every time a
    worker sends a message (which we'll see how to do in a minute, in the *Sending
    messages from the main script* section), the previous event is triggered and we
    console the data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的脚本正在监听工作器发送的消息。每次工作器发送消息（我们将在下一节“从主脚本发送消息”中看到如何做），都会触发前一个事件，并且我们在控制台中打印数据。
- en: Listening for messages on the worker script
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在工作脚本上监听消息
- en: 'Workers themselves have access to the `self` object, to which you can attach
    similar event listeners, as previously discussed. Let us see how that goes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者本身可以访问 `self` 对象，你可以附加类似的事件监听器，如之前讨论的那样。让我们看看结果：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the message event listener is fired whenever the main script sends a message
    to this particular web worker. We simply console-log what the main script sent
    with `console.log(e.data)`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当主脚本向这个特定的Web工作器发送消息时，消息事件监听器就会被触发。我们简单地使用 `console.log(e.data)` 打印主脚本发送的内容。
- en: You can omit the `self` keyword here if you wish. By default, in workers, events
    will be attached to `self`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以省略 `self` 关键字。默认情况下，在工作者中，事件将附加到 `self`。
- en: Sending messages from the main script
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从主脚本发送消息
- en: 'Okay! Once you''ve set up the listener event correctly, you will want to send
    some tasks to the worker for it to do. This is how to achieve that:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！一旦你正确设置了监听事件，你将想要向工作器发送一些任务以便它执行。这是如何实现这一点的：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Alright. Here, we're giving a task to the worker to add two numbers. Note that
    we are able to pass objects/arrays to the `postMessage` method, which is actually
    used to post/deliver a message to the worker which is spawned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。在这里，我们给工作器分配了一个加两个数字的任务。请注意，我们能够通过 `postMessage` 方法传递对象/数组，这实际上用于向生成的工作器发送/传递消息。
- en: Objects messaged through `postMessage` are copied and not referenced. This means
    that, if the worker script modifies this object in any way, it will not reflect
    in the main `script` object. This is important for message passing consistency.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `postMessage` 发送的对象是复制的而不是引用。这意味着，如果工作器脚本以任何方式修改此对象，它将不会反映在主 `script` 对象中。这对于消息传递的一致性很重要。
- en: 'Now we can receive this object at the other end (that is, the worker) and process
    it in the following way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在另一端（即工作器）接收此对象，并按以下方式处理它：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, on receiving the message, we check if the main script wants the worker
    to add numbers. If that's the case, we reduce the array value to a single value
    using the inbuilt `reduce` method to add all numbers in the passed array.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在接收到消息后，我们检查主脚本是否希望工作器添加数字。如果是这种情况，我们使用内置的 `reduce` 方法将传递的数组中的所有数字减少到一个单一值。
- en: Sending messages from the worker script
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从工作器脚本发送消息
- en: 'Similar to the main script, `postMessage` is used in the worker script to communicate
    to the main script. Let us see how to post the previous result to the main script:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与主脚本类似，`postMessage` 在工作器脚本中也用于与主脚本通信。让我们看看如何将前面的结果发送到主脚本：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, just like in the preceding code, we're reducing the array value to the
    `sum`, and then actually sending back whatever we did to the main UI script with
    the `postMessage` function. The passed object can be received by calling the script
    inside its own listening method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就像在先前的代码中一样，我们将数组值减少到 `sum`，然后实际上通过 `postMessage` 函数将我们执行的操作发送回主 UI 脚本。传递的对象可以通过调用其自身的监听方法来接收。
- en: '`script.js` would look like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`script.js` 将如下所示：'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you can see that we're sending the `task` to the worker in the form of
    an object, and the worker nicely performs the calculation and sends it to the
    main script, which is further handled by the message event listener attached to
    the `awesomeworker`, which simply writes the result to the document.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们将 `task` 以对象的形式发送到工作器，工作器很好地执行了计算并将结果发送回主脚本，这进一步由附加到 `awesomeworker`
    的消息事件监听器处理，该监听器简单地将结果写入文档。
- en: Error handling in workers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作器中的错误处理
- en: 'It is possible that your worker might throw an error because of malformed data
    sent by the main script. In that case, the `onerror` method of the worker is called
    in the main script:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能你的工作器可能会因为主脚本发送的格式不正确的数据而抛出错误。在这种情况下，主脚本中的工作器 `onerror` 方法被调用：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we attached an error event listener, and for now, we're just logging it
    to the console. You might want to send it to a server to actually log it for further
    analysis in a production app.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们附加了一个错误事件监听器，目前我们只是将其记录到控制台。你可能希望将其发送到服务器以在生产应用程序中进行进一步分析。
- en: 'The worker is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 工作器如下所示：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous case, the worker throws an error, which is visible in the main
    script as an `ErrorEvent` object. From there, you can handle the error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子中，工作器抛出一个错误，这在主脚本中表现为一个 `ErrorEvent` 对象。从那里，你可以处理这个错误。
- en: Throwing an error from a web worker doesn't permanently stop it from working.
    It is still usable unless terminated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Web Worker 抛出的错误不会永久停止其工作。除非终止，否则它仍然可用。
- en: Terminating workers
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止工作器
- en: You can terminate a worker when you think it is no longer required. You can
    terminate a worker from either the worker itself or the parent script. Let us
    see how to do this in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你认为工作器不再需要时，你可以终止工作器。你可以从工作器本身或父脚本中终止工作器。让我们在下一节中看看如何操作。
- en: Terminating from the worker script
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从工作器脚本终止
- en: 'Sometimes, it might be required to terminate a worker within the worker when
    the worker is performing some sort of async task whose duration can be variable.
    There is a method called `close()` available inside the worker for that purpose:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当工作器在进行某种可能持续不同时间段的异步任务时，可能需要在工作器内部终止工作器。为此，工作器内部提供了一个名为 `close()` 的方法：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Terminating from the main script
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从主脚本终止
- en: 'Similarly, you can terminate a worker from the main script, as well, if you
    wish to. After terminating, your worker instance can no longer be used to post
    messages to. It also kills any executing process in your worker:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你愿意，你也可以从主脚本中终止一个工作线程。终止后，你的工作线程实例将无法再用于发送消息。它还会终止你工作线程中正在执行的所有进程：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `myworker.js` file for this would be:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，相应的 `myworker.js` 文件将是：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Killing from within the worker involves calling `close()`, while from the parent
    script it involves calling `terminate()` methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作线程内部终止涉及调用 `close()`，而从父脚本中终止则涉及调用 `terminate()` 方法。
- en: Transferring (not copying) data through postMessage
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 `postMessage` 传输（而非复制）数据
- en: It is possible to actually just transfer large amounts of data using the `postMessage`
    function. What does that mean, and how it is different from what we've been doing
    so far with `postMessage`?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用 `postMessage` 函数传输大量数据。这意味着什么，它与到目前为止我们使用 `postMessage` 所做的事情有什么不同？
- en: 'Well, the actual syntax of `postMessage` is: `postMessage(aMessage, transferList)`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`postMessage` 的实际语法是：`postMessage(aMessage, transferList)`。
- en: What this means is, whatever you pass as `transferList` is apparently lost in
    the worker that sent it. You actually gave the other script the authority to own
    that data. You transferred the ownership of that data to that other script. Remember,
    this is different from what used to usually happen (that is, you can still access
    the object in the same script that sent it to the web worker/main script) because
    in this case, the data is not copied. Its ownership is transferred.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，你传递给 `transferList` 的任何内容在发送它的那个工作线程中似乎都丢失了。实际上，你赋予了其他脚本拥有那些数据的权限。你将那些数据的所有权转让给了那个其他脚本。记住，这与通常发生的情况不同（即，你仍然可以访问发送到
    Web 工作线程/主脚本的同一脚本中的对象），因为在这种情况下，数据并没有被复制。其所有权已被转让。
- en: 'This makes it lightning fast to transfer very large amounts of data across
    web workers. Transferable objects include things like `ArrayBuffer`. Here''s an
    example of how to work with it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在 Web 工作线程之间传输大量数据变得非常快。可传输的对象包括 `ArrayBuffer` 等内容。以下是如何处理它的一个示例：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see that the size of our `ArrayBuffer` went from 100 to 0\. This is
    because you no longer have access to the `ArrayBuffer` memory, because you transferred
    it to some other script.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们的 `ArrayBuffer` 的大小从 100 变为 0。这是因为你不再可以访问 `ArrayBuffer` 内存，因为你已经将其传输给了其他脚本。
- en: Working with shared workers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与共享工作线程一起工作
- en: As discussed previously, shared workers are workers that multiple scripts can
    access, given that they follow the same origin policy (more on this in a later
    section named *Same origin policy*).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，共享工作线程是多个脚本可以访问的工作线程，前提是它们遵循相同的源策略（更多内容将在名为 *Same origin policy* 的后续部分中介绍）。
- en: The API is a little different from dedicated workers, because these workers
    can be accessed by any script, so there's a need to manage all the connections
    via different ports baked into the `SharedWorker` object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与专用工作线程相比，API 略有不同，因为这些工作线程可以被任何脚本访问，因此需要通过 `SharedWorker` 对象中嵌入的不同端口来管理所有连接。
- en: Setting up a shared worker
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置共享工作线程
- en: 'A shared worker can be created by calling the `SharedWorker` constructor and
    providing the name of the file as the argument:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用 `SharedWorker` 构造函数并传入文件名作为参数来创建一个共享工作线程：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we used the `SharedWorker` constructor to create an instance of a `sharedworker`
    object. Unlike with dedicated workers, you won''t be able to see the HTTP network
    request in the browser made to the `myworker.js` file. This is important because
    the browser has to maintain only one instance of this file across multiple scripts
    calling this web worker:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `SharedWorker` 构造函数来创建一个 `sharedworker` 对象的实例。与专用工作线程不同，你将无法在浏览器中看到对
    `myworker.js` 文件进行的 HTTP 网络请求。这很重要，因为浏览器只需要维护多个脚本调用此 Web 工作线程时该文件的一个实例：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unlike dedicated workers, this does not log `Hello World!` in the main website's
    console. This is because shared workers do not get loaded into only that page.
    A shared worker is loaded once for every file accessing it. Therefore, it has
    its own console.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与专用工作线程不同，共享工作线程不会在主网站的控制台中输出 `Hello World!`。这是因为共享工作线程不会只加载到那个页面。共享工作线程为每个访问它的文件加载一次。因此，它有自己的控制台。
- en: 'In Google Chrome, to debug a shared worker, open `chrome://inspect/#workers`
    after opening the page which is responsible for launching the shared worker. There,
    you''ll have the option to debug it: ("Inspect" link)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Chrome 中，要调试共享工作线程，请在打开负责启动共享工作线程的页面后，打开 `chrome://inspect/#workers`。在那里，你可以选择调试它：（“检查”链接）
- en: '![](img/57bd90a5-58ae-4621-b2c6-872208f41713.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57bd90a5-58ae-4621-b2c6-872208f41713.png)'
- en: With that done, let's proceed to the guide to setting up listeners on shared
    workers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，让我们继续设置共享工作者监听器的指南。
- en: Working with shared workers
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与共享工作者一起工作
- en: Shared workers can communicate with their spawning script, listening to certain
    events which trigger when either of the scripts sends/receives a message. However,
    unlike dedicated workers, here we have to explicitly register the `onmessage`
    event on every connection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 共享工作者可以与其启动脚本通信，监听某些事件，这些事件在任一脚本发送/接收消息时触发。然而，与专用工作者不同，在这里我们必须在每个连接上显式注册 `onmessage`
    事件。
- en: Listening for messages on the main script
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在主脚本上监听消息
- en: 'Here, unlike with dedicated workers, we have to add the `onmessage` event on
    the port property which is available on the shared worker object:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与专用工作者不同，我们必须在共享工作者对象上可用的端口属性上添加 `onmessage` 事件：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This event is triggered whenever our `SharedWorker` replies to this particular
    script.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 `SharedWorker` 对这个特定的脚本做出回应时，会触发此事件。
- en: Notice the line `awesomeworker.port.start();`, which instructs the shared worker
    to interact with this script. When using `addEventListener`, it is mandatory to
    start the communication with the `port.start()` line from both files (worker and
    script) for two-way communication.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `awesomeworker.port.start();` 这一行，它指示共享工作者与这个脚本进行交互。当使用 `addEventListener`
    时，从两个文件（工作者和脚本）中都必须使用 `port.start()` 行来启动双向通信。
- en: Listening for messages on the worker script
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在工作者脚本上监听消息
- en: 'Similarly, `self` is defined here; however, `window` is not. So, you can use  `self.addEventListener`
    or `addEventListener` (or just `onconnect = function()`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`self` 在这里被定义；然而，`window` 并没有被定义。所以，你可以使用 `self.addEventListener` 或 `addEventListener`（或者直接
    `onconnect = function()`）：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the event contains the details about the ports our script is connected
    to. We pick up the connecting port and establish a connection with it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，事件包含了关于我们的脚本连接到的端口的详细信息。我们获取连接端口并与之建立连接。
- en: Similar to our main script, we have to specify `port.start()` here for a successful
    communication between the two files.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的主脚本类似，我们必须在这里指定 `port.start()` 以确保两个文件之间通信成功。
- en: Sending messages from parent scripts
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从父脚本发送消息
- en: Note that any script in the same origin (basically, same origin means that you're
    accessing it from multiple URLs covered under the same domain; for example, [https://www.google.co.in/](https://www.google.co.in/)[ ](https://www.google.co.in/)accessing
    `google.com/script.js` follows the same origin, but [facebook.com](https://www.facebook.com/)
    accessing `google.com/script.js` does not. There will be more on same origin in
    a later section named *Same origin policy*) can access the shared worker in the
    same way our previous `script.js`  accesses it, with the worker being in the same
    state for every file which accesses it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何同源的脚本（基本上，同源意味着你从属于同一域的多个 URL 访问它；例如，[https://www.google.co.in/](https://www.google.co.in/)
    访问 `google.com/script.js` 符合同源，但 [facebook.com](https://www.facebook.com/) 访问
    `google.com/script.js` 则不符合。关于同源的内容将在稍后的名为 *同源策略* 的部分中详细介绍）可以以与我们之前 `script.js`
    访问它相同的方式访问共享工作者，工作者对于每个访问它的文件都处于相同的状态。
- en: 'Here''s how you''ll send a message from a script to a worker:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是从脚本向工作者发送消息的方式：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is similar to dedicated workers, with the exception that we have to explicitly
    mention the port object here.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这与专用工作者类似，但我们必须在这里明确提到端口对象。
- en: 'The `myworker.js` file looks like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`myworker.js` 文件看起来像：'
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As mentioned previously, we need to do a `port.start()` to establish the communication
    between the worker and the main script if we use `addEventListener` to add the
    callbacks. Then we assign an event listener for `onmessage` for this particular
    port.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果我们使用 `addEventListener` 添加回调，则需要执行 `port.start()` 来建立工作者和主脚本之间的通信。然后我们为这个特定的端口分配一个
    `onmessage` 事件监听器。
- en: Finally, we just log to console what the calling script has to say to the worker.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需将调用脚本要告诉工作者的内容记录到控制台。
- en: Sending messages from the worker script
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从工作者脚本发送消息
- en: 'If you''ve recognized the difference between how we call methods in dedicated
    workers versus how we call them in shared workers, well done! Instead of just
    calling methods on `self`, we''re calling all the dedicated web worker methods
    on the port object, which is how the worker distinguishes between so many scripts
    that (can possibly) talk to it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经认识到我们在专用工作者和共享工作者中调用方法的方式之间的区别，做得好！我们不是在`self`上调用方法，而是在端口对象上调用所有专用Web工作者方法，这是工作者区分许多（可能）与之通信的脚本的方式：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is exactly like the code above, but with the exception that this time our
    shared worker replies to whoever sent the message and says `Hello` to it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它与上面的代码完全一样，但这次我们的共享工作者回复了发送消息的人，并向它说“你好”。
- en: If you have two instances of the HTML page which loads `script.js` (that is,
    the new `SharedWorker`) running, both have separate port connections with the
    shared worker.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有两个实例的HTML页面正在运行，加载`script.js`（即新的`SharedWorker`），它们都与共享工作者有独立的端口连接。
- en: Error handling
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Here, error handling is a bit tricky. Since the error can occur anywhere in
    the script by any port (any parent file), you have to manually send the error
    to every port. But for that, you''ll have to store the ports, as well (when they''re
    connected). Here''s how it should look:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，错误处理有点棘手。由于错误可能由任何端口（任何父文件）在任何脚本中发生，您必须手动将错误发送到每个端口。但为此，您还必须存储端口（当它们连接时）。以下是它应该看起来像什么：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here you can see that we are manually sending the error information to every
    parent file. Thereafter, you can handle the error in the parent file itself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们正在手动将错误信息发送到每个父文件。之后，您可以在父文件本身中处理错误。
- en: As a side note, it is good practice to have access to all connections in an
    array inside your shared worker. It might be helpful in some cases, such as when
    you want different pages to communicate with each other!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在您的共享工作者内部有一个数组访问所有连接是一个好习惯。在某些情况下可能会有所帮助，例如，当您想要不同的页面相互通信时！
- en: Terminating a shared worker connection
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断开共享工作者连接
- en: You can terminate a parent's connection from the shared worker, or completely
    shut down the shared worker. However, the latter can only be done by the worker's
    JS. The following sections talk about how you can terminate a single parent's
    connection with the worker.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从共享工作者那里断开父进程的连接，或者完全关闭共享工作者。然而，后者只能由工作者的JS完成。以下章节将讨论您如何断开单个父进程与工作者的连接。
- en: Terminating a single parent-worker connection
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断开单个父-工作者连接
- en: 'When this code is called, the connection between the parent and worker is shut
    down, and you''ll no longer be able to make use of that worker object to post
    messages:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此代码时，父进程与工作者之间的连接被关闭，您将无法再使用该工作者对象来发送消息：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Although the worker still lives, it loses its connection from the script which
    calls `.port.close()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管工作者仍然存在，但它失去了调用`.port.close()`的脚本的连接。
- en: After the connection is closed, the worker won't be able to send/receive messages
    from the main script. However, the main script can always call the shared web
    worker again by creating a new instance with the `new SharedWorker` constructor.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 连接关闭后，工作者将无法从主脚本发送/接收消息。然而，主脚本始终可以通过使用`new SharedWorker`构造函数创建一个新的实例来再次调用共享Web工作者。
- en: Terminating a shared worker completely
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全断开共享工作者
- en: 'A shared worker can itself be permanently terminated by calling `self.close()`
    inside its JS. You can also send a message from the parent script to kill the
    worker:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在其JS内部调用`self.close()`来永久终止共享工作者。您也可以从父脚本发送消息来杀死工作者：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We simply sent a message from our main script to our shared worker and passed
    the message that the shared worker should be terminated permanently.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是从我们的主脚本向我们的共享工作者发送了一条消息，并传递了共享工作者应该被永久终止的消息。
- en: 'The worker file looks like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者文件看起来像：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After verifying that the main script really wants to terminate the worker for
    all instances, the worker calls the `close` method on itself, which terminates
    it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证主脚本确实想要终止所有实例的工作者之后，工作者在其自身上调用`close`方法，从而终止它。
- en: Introduction to inline web workers
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联Web工作者的介绍
- en: It is possible to create a web worker from a single file without actually having
    a separate JS file for your web worker. However, I still recommend that you create
    a different file for your web workers, for the sake of clarity of code and to
    make it more modular. Modularity is always preferred in programming.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个文件创建Web Worker而不实际为你的Web Worker创建一个单独的JS文件是可能的。然而，我仍然建议你为你的Web Worker创建一个不同的文件，为了代码的清晰性和模块化。在编程中，模块化总是首选。
- en: 'We can make use of `blob` URLs to actually point data in memory to a URL, and
    then load the `blob` URL instead of an actual file URL. Since this URL is generated
    dynamically only on the user''s computer, you do not need to create a separate
    file for that particular web worker. Here''s how we''ll do that:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`blob` URL来实际上将内存中的数据指向一个URL，然后加载`blob` URL而不是实际的文件URL。由于这个URL仅在用户的计算机上动态生成，因此你不需要为特定的Web
    Worker创建一个单独的文件。以下是我们将如何做到这一点：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It sometimes makes it easy to quickly fire a small web worker. However, this
    approach won't work for shared web workers. You'll need to have a separate file
    for them. This is because `SharedWorker` relies on the fact that all instances
    are loaded from one single file. However, creating a URL for blob data creates
    different URLs every time. So two pages, even if they have the same JS code, would
    have different URLs, and hence, different instances of `SharedWorker`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有时快速启动一个小型Web Worker很容易。然而，这种方法不适用于共享Web Worker。你需要为它们创建一个单独的文件。这是因为`SharedWorker`依赖于所有实例都从一个单独的文件加载的事实。然而，创建blob数据的URL每次都会创建不同的URL。所以两个页面，即使它们有相同的JS代码，也会有不同的URL，因此会有不同的`SharedWorker`实例。
- en: Same origin policy
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同源策略
- en: Earlier, I said a couple of times that shared workers will be available only
    to those parent files which share the same origin. What does that mean?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我说了几次，共享工作者将仅对与它们共享相同源的父母文件可用。这意味着什么？
- en: Let us consider the URL [http://www.packtpub.com/all.](http://www.packtpub.com/all)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑URL [http://www.packtpub.com/all.](http://www.packtpub.com/all)
- en: 'Here''s a table demonstrating which URLs will be of the same origin with this
    domain, and which won''t be:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个表格，展示了哪些URL将与该域名具有相同的源，哪些不会：
- en: '| **New URL** | **Same** **Origin** | **Reason** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **新URL** | **同源** | **原因** |'
- en: '| [http://www.packtpub.com/support](http://www.packtpub.com/support) | Yes
    | - |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| [http://www.packtpub.com/support](http://www.packtpub.com/support) | 是 |
    - |'
- en: '| `http://www.packtpub.com/account/abc/xyz` | Yes | - |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `http://www.packtpub.com/account/abc/xyz` | 是 | - |'
- en: '| [https://www.packtpub.com/all](https://www.packtpub.com/all) | No | Different
    protocol |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| [https://www.packtpub.com/all](https://www.packtpub.com/all) | 否 | 不同的协议
    |'
- en: '| [http://username:password@www.packtpub.com/all](http://username:password@www.packtpub.com/all)
    | Yes | - |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| [http://username:password@www.packtpub.com/all](http://username:password@www.packtpub.com/all)
    | 是 | - |'
- en: '| `http://www.packtpub.com:8000/somepage` | No | Different port number |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `http://www.packtpub.com:8000/somepage` | 否 | 不同的端口号 |'
- en: '| `http://packtpub.com/somepage` | No | Different host |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `http://packtpub.com/somepage` | 否 | 不同的主机 |'
- en: '| `http://dev.packtpub.com/somepage` | No | Different host |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `http://dev.packtpub.com/somepage` | 否 | 不同的主机 |'
- en: By now, I believe that you will be able to guess what makes something the same
    origin and what does not. Yes, you're right! The same host, port, and protocol
    make two URLs under the same origin. For listed URLs which have their answers
    as yes, only those URLs will be able to access the shared worker spun by [http://www.packtpub.com/all](http://www.packtpub.com/all).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我相信你能够猜出什么使得某些内容具有相同的源，什么不具有。是的，你是对的！相同的主机、端口和协议使得两个URL处于相同的源。对于列表中的URL，其答案为“是”的，只有那些URL才能访问由[http://www.packtpub.com/all](http://www.packtpub.com/all)启动的共享工作者。
- en: Working with service workers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务工作者一起工作
- en: Service workers! They finally give developers precise control of the network
    layer by creating a network proxy in JavaScript. Using service workers, you can
    intercept and modify network resource requests, handle how caching is done, and
    respond appropriately when the user's network is down.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者！它们最终通过在JavaScript中创建网络代理，为开发者提供了对网络层的精确控制。使用服务工作者，你可以拦截和修改网络资源请求，处理缓存方式，并在用户网络断开时做出适当的响应。
- en: Let us show, step-by-step, how to set up a service worker and its associated
    methods.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地展示如何设置服务工作者及其相关方法。
- en: Prerequisites for service workers
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者的先决条件
- en: 'Prerequisites for service workers are:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者的先决条件是：
- en: Because service workers are so powerful (almost like a network proxy) to avoid
    certain attacks, they're only available for domains running on HTTPS. However,
    they run fine on `localhost`, as well.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于service worker功能强大（几乎像网络代理），为了避免某些攻击，它们仅适用于运行在HTTPS上的域名。然而，它们在`localhost`上也能正常运行。
- en: They heavily depend on promises, which we've already covered in depth in *Chapter
    4, Asynchronous Programming*.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们大量依赖于我们已经在*第4章，异步编程*中深入讨论过的promises。
- en: Checking for browser support
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查浏览器支持
- en: 'It is easy to check whether a client''s browser supports service workers or
    not:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 检查客户端的浏览器是否支持service workers很容易：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, I'll assume that a service worker is available in the user's browser,
    to avoid unnecessary code indentations every time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我将假设用户的浏览器中已经可用了一个service worker，以避免每次都进行不必要的代码缩进。
- en: The service worker life cycle
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: service worker的生命周期
- en: 'The following figure illustrates how a service worker lives:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了service worker的生命周期：
- en: '![](img/bae86247-0f7d-4967-accd-515a09c38a9c.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bae86247-0f7d-4967-accd-515a09c38a9c.png)'
- en: It is clear from the diagram that first a service worker needs to be installed.
    Then it triggers certain events which we can catch in our code to handle different
    stuff. Let us now discuss how to implement all of these steps, in detail.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中可以看出，首先需要安装service worker。然后它触发某些事件，我们可以在代码中捕获这些事件来处理不同的事情。现在让我们详细讨论如何实现所有这些步骤。
- en: Registering a service worker
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册service worker
- en: 'First, your main script has to register the service worker to the browser.
    Here''s how:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你的主脚本必须将service worker注册到浏览器中。以下是操作方法：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `reg` object is associated with information about the registration of your
    service worker.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`reg`对象与你的service worker注册信息相关联。'
- en: A service worker registration code can be safely run multiple times. If already
    registered, the browser will not re-register it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: service worker注册代码可以安全地多次运行。如果已经注册，浏览器将不会重新注册它。
- en: 'You can debug service workers here: Chrome-->Inspect-->Service Workers.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里调试service workers：Chrome-->检查-->Service Workers。
- en: Note that a service worker script's scope is the scope where it is located.
    For example, the preceding file is located in the root directory (`localhost/sw.js`),
    so it can intercept all `localhost/*` requests. If it were located in, say, `localhost/directory/sw.js`,
    then it would be able to intercept only `localhost/directory/*` requests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，service worker脚本的作用域是它所在的作用域。例如，前面的文件位于根目录（`localhost/sw.js`），因此它可以拦截所有`localhost/*`请求。如果它位于，比如说，`localhost/directory/sw.js`，那么它只能拦截`localhost/directory/*`请求。
- en: Installing service workers
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装service workers
- en: 'Once your worker is registered, an install event is triggered inside your service
    worker file. Here, we''ll set up caching of our resources. A lot of new terms
    are coming your way; hold tight:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的worker注册成功，你的service worker文件内部会触发一个安装事件。在这里，我们将设置资源的缓存。接下来会有很多新术语出现；请耐心等待：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Okay! What happened?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！发生了什么？
- en: We added an install event listener to our `sw.js` file, which is triggered when
    our service worker is registered.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在我们的`sw.js`文件中添加了一个安装事件监听器，当我们的service worker被注册时，它会触发。
- en: '`e.waitUntil` accepts a promise (and we do give it a promise; remember that
    the `async function` returns a promise, and we invoked that function, as well).'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`e.waitUntil`接受一个promise（我们确实提供了一个promise；记得`async function`返回一个promise，我们也调用了那个函数）。'
- en: Then we have something known as **CacheStorage** in browsers. We add resources
    to the cache by naming that cache and then using the `addAll` method to add the
    resources we want to cache.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在浏览器中有一个名为**CacheStorage**的东西。我们通过命名缓存并使用`addAll`方法添加我们想要缓存的资源来将资源添加到缓存中。
- en: We pass an array of all the files/paths we want to add to our cache storage.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们传递一个包含所有想要添加到缓存存储的文件/路径的数组。
- en: The installation event is over.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装事件已经结束。
- en: It is completely optional to set up caching inside the installation event itself.
    We can do it later, after the install event, as well. For example, you can set
    up caching on the go when fetching new resources.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装事件本身中设置缓存是完全可选的。我们可以在安装事件之后，稍后进行设置。例如，在获取新资源时，可以边走边设置缓存。
- en: Fetching with service workers
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用service workers进行获取
- en: 'Once everything is ready, you should be able to intercept requests with your
    service workers with the `fetch` event, in the following way:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，你应该能够通过`fetch`事件以以下方式拦截请求：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Hang on! Let''s see what happened here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！让我们看看这里发生了什么：
- en: This listener will be fired whenever the browser makes a fetch request under
    its registration scope (we discussed that earlier).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个监听器将在浏览器在其注册范围内进行fetch请求时被触发（我们之前讨论过这一点）。
- en: '`respondWith` also accepts a promise, which we gave it.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`respondWith`也接受一个承诺，这是我们给它提供的。'
- en: Then, we check whether or not the requested file is already present in our cache
    (using `catches.match(e.request)`). If it is, we return the cached file directly.
    If not, we use the fetch API (we discussed this in the previous chapter) to fetch
    the response, and the execution continues.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查请求的文件是否已经存在于我们的缓存中（使用`catches.match(e.request)`）。如果是，我们直接返回缓存的文件。如果不是，我们使用fetch
    API（我们之前章节讨论过）来获取响应，然后继续执行。
- en: You can also console-log `e.request` and play around with it a little to modify
    the request. It gives the developer of the site immense power over his own site,
    and thus should not be handled by anyone else. This is the reason service workers
    are available only over the  HTTPS protocol, to avoid a man-in-the-middle attack.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在控制台中打印出`e.request`并稍作修改以修改请求。这给了网站开发者对其自己网站巨大的控制权，因此不应由其他人处理。这也是为什么service
    workers仅在HTTPS协议上可用，以避免中间人攻击。
- en: Service workers are a relatively new technology, and a lot of work is going
    on in their spec. Check out ;[http://bit.ly/serviceworkers ](http://bit.ly/serviceworkers)for
    any updates.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Service workers是一项相对较新的技术，它们的标准正在经历许多工作。查看[http://bit.ly/serviceworkers](http://bit.ly/serviceworkers)获取任何更新。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, finally, we've had the chance to take a look at web workers and service
    workers and the great parts of the multi-threading environment provided by JavaScript!
    While service workers are the future of progressive web apps, web workers will
    be there to back them for any high-load task.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终，我们有机会查看web workers和service workers以及JavaScript提供的多线程环境中的精彩部分！虽然service
    workers是渐进式Web应用的未来，但web workers将支持它们处理任何高负载任务。
- en: 'Combine these techs in just the right way, and everything seems possible! In
    the next chapter, we''re going to take a look at very interesting concepts introduced
    in JavaScript for the first time: shared memory and atomics.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地结合这些技术，似乎一切皆有可能！在下一章中，我们将探讨JavaScript首次引入的非常有趣的概念：共享内存和原子操作。
