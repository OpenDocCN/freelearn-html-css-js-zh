- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Creating and Loading Advanced Meshes and Geometries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和加载高级网格和几何体
- en: 'In this chapter, we’ll look at a couple of different ways that you can create
    and load advanced and complex geometries and meshes. In [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081),
    *Learning to Work with Geometries*, and [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101),
    *Exploring Advanced Geometries*, we showed you how to create a few advanced geometries
    using the built-in objects from Three.js. In this chapter, we’ll use the following
    two approaches to create advanced geometries and meshes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几种不同的方法来创建和加载高级和复杂的几何体和网格。在第[*5章*](B18726_05.xhtml#_idTextAnchor081)“学习与几何体一起工作”和第[*6章*](B18726_06.xhtml#_idTextAnchor101)“探索高级几何体”中，我们向您展示了如何使用Three.js的内置对象创建一些高级几何体。在本章中，我们将使用以下两种方法来创建高级几何体和网格：
- en: Geometry grouping and merging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何分组和合并
- en: Loading geometries from external resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部资源加载几何体
- en: We start with the “group and merge” approach. With this approach, we use the
    standard Three.js grouping (`THREE.Group`) and the `BufferGeometryUtils.mergeBufferGeometries()`
    function to create new objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从“分组和合并”方法开始。使用这种方法，我们使用标准的Three.js分组（`THREE.Group`）和`BufferGeometryUtils.mergeBufferGeometries()`函数来创建新的对象。
- en: Geometry grouping and merging
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何分组和合并
- en: 'In this section, we’ll look at two basic features of Three.js: grouping objects
    together and merging multiple geometries into a single geometry. We’ll start with
    grouping objects.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Three.js的两个基本功能：将对象分组在一起以及将多个几何体合并成一个单一的几何体。我们将从分组对象开始。
- en: Grouping objects together
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象分组在一起
- en: In some of the previous chapters, you already saw how you can group objects
    when working with multiple materials. When you create a mesh from a geometry using
    multiple materials, Three.js creates a group. Multiple copies of your geometry
    are added to this group, each with its own specific material. This group is returned,
    so it looks like a mesh that uses multiple materials. In truth, however, it is
    a group that contains a number of meshes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些前面的章节中，您已经看到了在处理多个材质时如何分组对象。当您使用多个材质从几何体创建网格时，Three.js会创建一个组。您的几何体的多个副本被添加到这个组中，每个副本都有其特定的材质。这个组被返回，所以它看起来像是一个使用多个材质的网格。然而，实际上，它是一个包含多个网格的组。
- en: Creating groups is very easy. Every mesh you create can contain child elements,
    which can be added using the `add` function. The effect of adding a child object
    to a group is that you can move, scale, rotate, and translate the parent object,
    and all the child objects will also be affected. When using a group, you can still
    refer to, modify, and position the individual geometries. The only thing you need
    to remember is that all positions, rotations, and translations are done relative
    to the parent object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组非常简单。你创建的每个网格都可以包含子元素，可以使用`add`函数添加。将子对象添加到组中的效果是，你可以移动、缩放、旋转和平移父对象，所有子对象也会受到影响。当使用组时，你仍然可以引用、修改和定位单个几何体。你需要记住的唯一一点是，所有位置、旋转和平移都是相对于父对象进行的。
- en: 'Let’s look at an example (`grouping.html`) in the following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下截图中的示例（`grouping.html`）：
- en: '![Figure 8.1 – Using a THREE.Group object to group objects together](img/Figure_8.1_B18726.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 使用THREE.Group对象将对象分组在一起](img/Figure_8.1_B18726.jpg)'
- en: Figure 8.1 – Using a THREE.Group object to group objects together
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 使用THREE.Group对象将对象分组在一起
- en: 'In this example, you see a large number of cubes, which are added to the scene
    as a single group. Before we look at the controls and the effect of using a group,
    let’s have a quick look at how we’ve created this mesh:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您可以看到大量被作为一个单一组添加到场景中的立方体。在我们查看控件和使用组的效果之前，让我们快速看看我们是如何创建这个网格的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code snippet, you can see that we create a `THREE.Group` instance.
    This object is almost identical to `THREE.Object3D`, which is the base class of
    `THREE.Mesh` and `THREE.Scene`, but by itself, it doesn’t contain anything or
    cause anything to be rendered. In this example, we use the `add` function to add
    a large number of cubes to this scene. For this example, we’ve added the controls
    you can use to change the position of a mesh. Whenever you change a property using
    this menu, the relevant property of the `THREE.Group` object is changed. For instance,
    in the next example, you can see that when we scale this `THREE.Group` object,
    all the nested cubes get scaled as well:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你可以看到我们创建了一个 `THREE.Group` 实例。这个对象几乎与 `THREE.Object3D` 相同，它是 `THREE.Mesh`
    和 `THREE.Scene` 的基类，但本身不包含任何内容或导致任何渲染。在这个示例中，我们使用 `add` 函数将大量立方体添加到这个场景中。对于这个示例，我们添加了你可以用来改变网格位置的控件。每次你使用这个菜单改变一个属性时，`THREE.Group`
    对象的相关属性也会改变。例如，在下一个示例中，你可以看到当我们缩放这个 `THREE.Group` 对象时，所有嵌套的立方体也会相应缩放：
- en: '![Figure 8.2 – Scaling a group](img/Figure_8.2_B18726.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 缩放一个组](img/Figure_8.2_B18726.jpg)'
- en: Figure 8.2 – Scaling a group
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 缩放一个组
- en: If you want to experiment a bit more with the `THREE.Group` object, a good exercise
    would be to alter the example so that the `THREE.Group` instance itself is rotating
    on the *x* axis while the individual cubes are rotating on their *y* axis.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要对 `THREE.Group` 对象进行更多实验，一个很好的练习是修改示例，使得 `THREE.Group` 实例本身在 *x* 轴上旋转，而单个立方体在其
    *y* 轴上旋转。
- en: Performance impact of using THREE.Group
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 THREE.Group 的性能影响
- en: Before we move on to the next section where we look at merging, a quick note
    on performance. When you use `THREE.Group`, all the individual meshes inside this
    group are treated as individual objects, which Three.js needs to manage and render.
    If you’ve got a large number of objects in the scene, you’ll see a noticeable
    drop in performance. If you look at the top-left corner of *Figure 8**.2*, you
    can see that with 5,000 cubes on screen, we get around 56 **frames per second**
    (**FPS**). Not too bad, but normally we would run at around 120 FPS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节，探讨合并之前，先快速说明一下性能问题。当你使用 `THREE.Group` 时，这个组内所有的单个网格都被当作独立对象处理，Three.js
    需要管理并渲染这些对象。如果你场景中有大量对象，你会注意到性能的明显下降。如果你查看图8.2的左上角，你可以看到，当屏幕上有5,000个立方体时，我们大约得到56
    **帧每秒**（**FPS**）。还不错，但通常我们会以大约120 FPS的速度运行。
- en: Three.js provides an additional way where we can still control the individual
    meshes, but get much better performance. This is done through `THREE.InstancedMesh`.
    This object works great if you want to render a large number of objects with the
    same geometry but with different transformations (for example, rotation, scale,
    color, or any other matrix transformation).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 提供了一种额外的方法，我们可以仍然控制单个网格，但获得更好的性能。这是通过 `THREE.InstancedMesh` 实现的。如果你想要渲染大量具有相同几何形状但具有不同变换（例如，旋转、缩放、颜色或任何其他矩阵变换）的对象，这个对象工作得非常好。
- en: 'We’ve created an example called `instanced-mesh.html`, which shows how this
    works. In this example, we render 250,000 cubes and still have great performance:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `instanced-mesh.html` 的示例，展示了这是如何工作的。在这个示例中，我们渲染了250,000个立方体，但性能依然出色：
- en: '![Figure 8.3 – Using an InstancedMesh object for grouping](img/Figure_8.3_B18726.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 使用 InstancedMesh 对象进行分组](img/Figure_8.3_B18726.jpg)'
- en: Figure 8.3 – Using an InstancedMesh object for grouping
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 使用实例网格对象进行分组
- en: 'To work with a `THREE.InstancedMesh` object, we create it similarly to how
    we created the `THREE.Group` instance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 `THREE.InstancedMesh` 对象一起工作，我们创建它的方式与创建 `THREE.Group` 实例的方式类似：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The main difference in creating a `THREE.InstancedMesh` object compared to `THREE.Group`
    is that we need to define beforehand which material and geometry we want to use
    and how many instances of this geometry we want to create. To position or rotate
    one of our instances, we need to provide the transformation using a `THREE.Matrix4`
    instance. Luckily, we don’t need to go into the math behind matrices, since Three.js
    provides us with a couple of helper functions on the `THREE.Matrix4` instance
    to define a rotation, a translation, and a couple of other transformations. In
    this example, we simply position each instance at a random location.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建 `THREE.InstancedMesh` 对象相比，与 `THREE.Group` 的主要区别在于，我们需要事先定义我们想要使用哪种材质和几何形状，以及我们想要创建多少个这种几何形状的实例。为了定位或旋转我们的一个实例，我们需要提供一个使用
    `THREE.Matrix4` 实例的变换。幸运的是，我们不需要深入研究矩阵背后的数学，因为 Three.js 在 `THREE.Matrix4` 实例上为我们提供了一些辅助函数来定义旋转、平移以及其他一些变换。在这个例子中，我们只是将每个实例随机定位。
- en: So, if you’re working with a small number of meshes (or meshes using different
    geometries), you should use a `THREE.Group` object if you want to group them together.
    If you’re dealing with a large number of meshes that share a geometry and material,
    you can use a `THREE.InstancedMesh` object or a `THREE.InstancedBufferGeometry`
    object for a great performance boost.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你正在处理少量网格（或使用不同几何形状的网格），如果你想将它们组合在一起，你应该使用 `THREE.Group` 对象。如果你处理的是大量共享几何和材质的网格，你可以使用
    `THREE.InstancedMesh` 对象或 `THREE.InstancedBufferGeometry` 对象以获得极大的性能提升。
- en: In the next section, we’ll look at merging, where you’ll combine multiple separate
    geometries and end up with a single `THREE.Geometry` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨合并，你将结合多个单独的几何形状，最终得到一个单一的 `THREE.Geometry` 对象。
- en: Merging geometries
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何形状合并
- en: 'In most cases, using groups allows you to easily manipulate and manage a large
    number of meshes. When you’re dealing with a very large number of objects, however,
    performance will become an issue since Three.js has to treat all the children
    of the group individually. With `BufferGeometryUtils.mergeBufferGeometries`, you
    can merge geometries together and create a combined one, so Three.js would only
    have to manage this single geometry. In *Figure 8**.4*, you can see how this works
    and the effect it has on performance. If you open the `merging.html` example,
    you see a scene again with the same set of randomly distributed semi-transparent
    cubes, which we merged into a single `THREE.BufferGeometry` object:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用组可以让你轻松地操作和管理大量网格。然而，当你处理一个非常大的对象数量时，性能将成为一个问题，因为 Three.js 必须单独处理组的所有子对象。使用
    `BufferGeometryUtils.mergeBufferGeometries`，你可以将几何形状合并在一起，创建一个组合的几何形状，这样 Three.js
    就只需要管理这个单一的几何形状。在 *图 8.4* 中，你可以看到这是如何工作的以及它对性能的影响。如果你打开 `merging.html` 示例，你会再次看到一个场景，其中包含相同的一组随机分布的半透明立方体，我们将它们合并成了一个单一的
    `THREE.BufferGeometry` 对象：
- en: '![Figure 8.4 – 500,000 geometries merged into a single geometry](img/Figure_8.4_B18726.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 500,000 个几何形状合并成一个单一的几何形状](img/Figure_8.4_B18726.jpg)'
- en: Figure 8.4 – 500,000 geometries merged into a single geometry
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 500,000 个几何形状合并成一个单一的几何形状
- en: 'As you can see, we can easily render 50,000 cubes without any drop in performance.
    To do this, we use the following few lines of code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以轻松渲染 50,000 个立方体而不会出现任何性能下降。为此，我们使用了以下几行代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code snippet, we create a large number of `THREE.BoxGeometry` objects,
    which we merge together using the `BufferGeometryUtils.mergeBufferGeometries(geoms)`
    function. The result is a single large geometry, which we can add to the scene.
    The biggest drawback is that you lose control over the individual cubes since
    they are all merged into a single large geometry. If you want to move, rotate,
    or scale a single cube, you can’t (unless you search for the correct faces and
    vertices and position them individually).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们创建了大量 `THREE.BoxGeometry` 对象，我们使用 `BufferGeometryUtils.mergeBufferGeometries(geoms)`
    函数将它们合并在一起。结果是单个大几何形状，我们可以将其添加到场景中。最大的缺点是，由于它们都被合并成了一个单一的几何形状，你将失去对单个立方体的控制。如果你想移动、旋转或缩放单个立方体，你无法做到（除非你搜索正确的面和顶点并将它们单独定位）。
- en: Creating new geometries through Constructive Solid Geometry
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造实体几何创建新的几何形状
- en: Besides merging geometries in the way we saw in this chapter, we can also create
    geometries using `three-bvh-csg` ([https://github.com/gkjohnson/three-bvh-csg](https://github.com/gkjohnson/three-bvh-csg))
    and `Three.csg` ([https://github.com/looeee/threejs-csg](https://github.com/looeee/threejs-csg)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在本章中看到的方式合并几何形状外，我们还可以使用 `three-bvh-csg` ([https://github.com/gkjohnson/three-bvh-csg](https://github.com/gkjohnson/three-bvh-csg))
    和 `Three.csg` ([https://github.com/looeee/threejs-csg](https://github.com/looeee/threejs-csg))
    创建几何形状。
- en: With the grouping and merging approach, you can create large and complex geometries
    using the basic geometries provided by Three.js. If you want to create more advanced
    geometries, then using the programmatic approach provided by Three.js isn’t always
    the best and easiest option. Three.js, luckily, offers a couple of other options
    to create geometries. In the next section, we’ll look at how you can load geometries
    and meshes from external resources.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分组和合并方法，您可以使用 Three.js 提供的基本几何形状创建大型且复杂的几何形状。如果您想创建更高级的几何形状，那么使用 Three.js
    提供的程序化方法并不总是最佳和最简单的方法。幸运的是，Three.js 提供了其他一些创建几何形状的选项。在下一节中，我们将探讨如何从外部资源加载几何形状和网格。
- en: Loading geometries from external resources
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部资源加载几何形状
- en: Three.js can read a large number of 3D file formats and import geometries and
    meshes defined in those files. A note here is that not all the features of these
    formats are always supported. So, sometimes there might be an issue with the textures,
    or materials might not be set up correctly. The new de facto standard for exchanging
    models and textures is **glTF**, so if you want to load externally created models,
    exporting those models to glTF format will usually give you the best results in
    Three.js.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 可以读取大量 3D 文件格式，并导入这些文件中定义的几何形状和网格。这里需要注意的是，这些格式并非所有功能都始终得到支持。因此，有时可能会出现纹理问题，或者材质可能设置不正确。用于交换模型和纹理的新事实标准是
    **glTF**，因此如果您想加载外部创建的模型，通常将那些模型导出为 glTF 格式会在 Three.js 中获得最佳结果。
- en: 'In this section, we’ll dive a bit deeper into some of the formats that are
    supported by Three.js, but we won’t show you all the loaders. The following list
    shows an overview of the formats supported by Three.js:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨一些 Three.js 支持的格式，但不会向您展示所有加载器。以下列表显示了 Three.js 支持的格式概述：
- en: '**AMF**: AMF is another 3D printing standard, but isn’t under active development
    anymore. The following *Wikipedia* page has additional information on this standard:
    [https://www.sculpteo.com/en/glossary/amf-definition/](https://www.sculpteo.com/en/glossary/amf-definition/).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AMF**: AMF 是另一种 3D 打印标准，但现在已经不再处于积极开发状态。有关此标准的更多信息，请参阅以下 *维基百科* 页面：[https://www.sculpteo.com/en/glossary/amf-definition/](https://www.sculpteo.com/en/glossary/amf-definition/).'
- en: '**3DM**: 3DM is the format used by Rhinoceros, which is a tool to create 3D
    models. More information on Rhinoceros can be found here: [https://www.rhino3d.com/](https://www.rhino3d.com/).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3DM**: 3DM 是 Rhinoceros 所使用的格式，这是一个用于创建 3D 模型的工具。有关 Rhinoceros 的更多信息请在此处查看：[https://www.rhino3d.com/](https://www.rhino3d.com/).'
- en: '**3MF**: 3MF is one of the standards used in 3D printing. Information about
    this format can be found on the *3MF Consortium* home page: [https://3mf.io](https://3mf.io).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3MF**: 3MF 是 3D 打印中使用的标准之一。有关此格式的信息可以在 *3MF 联盟* 主页上找到：[https://3mf.io](https://3mf.io).'
- en: '**COLLAborative Design Activity (COLLADA**): COLLADA is a format for defining
    digital assets in an XML-based format. This is a widely used format that is supported
    by pretty much all 3D applications and rendering engines.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COLLAborative Design Activity (COLLADA**): COLLADA 是一种基于 XML 格式定义数字资产的格式。这是一个广泛使用的格式，几乎所有
    3D 应用程序和渲染引擎都支持它。'
- en: '**Draco**: Draco is a file format for storing geometries and point clouds in
    a very efficient way. It specifies how these elements are best compressed and
    decompressed. Details about how Draco works can be found on its GitHub page: [https://github.com/google/draco](https://github.com/google/draco).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Draco**: Draco 是一种高效存储几何形状和点云的文件格式。它指定了这些元素的最佳压缩和解压缩方式。有关 Draco 如何工作的详细信息可以在其
    GitHub 页面上找到：[https://github.com/google/draco](https://github.com/google/draco).'
- en: '**GCode**: GCode is a standard way of talking to 3D printers or **CNC** machines.
    When a model is printed, one of the ways a 3D printer can be controlled is by
    sending it GCode commands. The details of this standard are described in the following
    paper: [https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374](https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GCode**: GCode是与3D打印机或**CNC**机器通信的标准方式。当模型打印时，3D打印机可以通过发送GCode命令来控制。此标准的详细信息在以下论文中描述：[https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374](https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374)。'
- en: '`.glb` extension and a text-based format with the `.gltf` extension. More information
    on this standard can be found here: [https://www.khronos.org/gltf/](https://www.khronos.org/gltf/).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.glb`扩展名和以`.gltf`扩展名的基于文本的格式。更多关于此标准的信息请参阅：[https://www.khronos.org/gltf/](https://www.khronos.org/gltf/)。'
- en: '**Industry Foundation Classes (IFC)**: This is an open file format used by
    **building information modeling** (**BIM**) tools. It contains a model of a building
    and a lot of additional information on the materials used. More information about
    this standard can be found here: [https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/](https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Industry Foundation Classes (IFC)**: 这是一个由**建筑信息模型**（**BIM**）工具使用的开放文件格式。它包含了一个建筑模型以及大量关于所用材料的附加信息。更多关于此标准的信息请参阅：[https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/](https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/)。'
- en: '**JSON**: Three.js has its own JSON format that you can use to declaratively
    define a geometry or a scene. Even though this isn’t an official format, it’s
    very easy to use and comes in very handy when you want to reuse complex geometries
    or scenes.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON**: Three.js拥有自己的JSON格式，您可以使用它声明性地定义几何形状或场景。尽管这不是一个官方格式，但它非常易于使用，当您想要重用复杂的几何形状或场景时非常有用。'
- en: '**KMZ**: This is the format used for 3D assets on Google Earth. More information
    can be found here: [https://developers.google.com/kml/documentation/kmzarchives](https://developers.google.com/kml/documentation/kmzarchives).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KMZ**: 这是用于Google Earth上3D资产的格式。更多信息请参阅：[https://developers.google.com/kml/documentation/kmzarchives](https://developers.google.com/kml/documentation/kmzarchives)。'
- en: '**LDraw**: LDraw is an open standard you can use to create virtual LEGO models
    and scenes. More information can be found on the LDraw home page: [https://ldraw.org](https://ldraw.org).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LDraw**: LDraw是一个开放标准，您可以使用它创建虚拟乐高模型和场景。更多信息请参阅LDraw主页：[https://ldraw.org](https://ldraw.org)。'
- en: '**LWO**: This is the file format used by LightWave 3D. More information on
    LightWave 3D can be found here: [https://www.lightwave3d.com/](https://www.lightwave3d.com/).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LWO**: 这是LightWave 3D使用的文件格式。更多关于LightWave 3D的信息请参阅：[https://www.lightwave3d.com/](https://www.lightwave3d.com/)。'
- en: '**NRRD**: NRRD is a file format used to visualize volumetric data. It can,
    for instance, be used to render CT scans. A lot of information and samples can
    be found here: [http://teem.sourceforge.net/nrrd/](http://teem.sourceforge.net/nrrd/).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NRRD**: NRRD是一种用于可视化体积数据的文件格式。例如，它可以用于渲染CT扫描。大量信息和示例可以在以下网站找到：[http://teem.sourceforge.net/nrrd/](http://teem.sourceforge.net/nrrd/)。'
- en: '`OBJExporter`, should you want to export your models to OBJ from Three.js.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJExporter`，如果您想从Three.js导出模型到OBJ格式。'
- en: '**PCD**: This is an open format for describing point clouds. More information
    can be found here: [https://pointclouds.org/documentation/tutorials/pcd_file_format.html](https://pointclouds.org/documentation/tutorials/pcd_file_format.html).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PCD**: 这是一个用于描述点云的开放格式。更多信息请参阅：[https://pointclouds.org/documentation/tutorials/pcd_file_format.html](https://pointclouds.org/documentation/tutorials/pcd_file_format.html)。'
- en: '**PDB**: This is a very specialized format, created by **Protein Data Bank**
    (**PDB**), which is used to specify what proteins look like. Three.js can load
    and visualize proteins specified in this format.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PDB**: 这是一个非常专业的格式，由**蛋白质数据银行**（**PDB**）创建，用于指定蛋白质的外观。Three.js可以加载并可视化指定在此格式中的蛋白质。'
- en: '**Polygon File Format (PLY)**: This is most often used to store information
    from 3D scanners.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Polygon File Format (PLY)**: 这是最常用于存储3D扫描器信息的格式。'
- en: '**Packed Raw WebGL Model (PRWM)**: This is another format focusing on the efficient
    storage and parsing of 3D geometries. More information on this standard and how
    you can use it is described here: [https://github.com/kchapelier/PRWM](https://github.com/kchapelier/PRWM).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包原始WebGL模型 (PRWM)**: 这是一个专注于高效存储和解析3D几何形状的格式。有关此标准和如何使用它的更多信息，请参阅此处：[https://github.com/kchapelier/PRWM](https://github.com/kchapelier/PRWM).'
- en: '`STLExporter.js`, should you want to export your models to STL from Three.js.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STLExporter.js`，如果您想从Three.js导出模型到STL。'
- en: '`THREE.Path` elements that you can use for extruding or rendering in 2D.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Path`元素，您可以使用它进行挤出或2D渲染。'
- en: '**3DS**: The Autodesk 3DS format. More information can be found at [https://www.autodesk.com/](https://www.autodesk.com/).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3DS**: 这是Autodesk 3DS格式。更多信息请参阅[https://www.autodesk.com/](https://www.autodesk.com/).'
- en: '**TILT**: TILT is the format used by Tilt Brush, a VR tool that allows you
    to paint in VR. More information is available here: [https://www.tiltbrush.com/](https://www.tiltbrush.com/).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TILT**: TILT是Tilt Brush使用的格式，Tilt Brush是一个VR工具，允许您在VR中绘画。更多信息请参阅此处：[https://www.tiltbrush.com/](https://www.tiltbrush.com/).'
- en: '**VOX**: The format used by MagicaVoxel, a free tool you can use to create
    voxel art. More information is available on the home page of MagicaVoxel: [https://ephtracy.github.io/](https://ephtracy.github.io/).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VOX**: 这是MagicaVoxel使用的格式，MagicaVoxel是一个免费工具，可用于创建体素艺术。更多信息可以在MagicaVoxel的主页上找到：[https://ephtracy.github.io/](https://ephtracy.github.io/).'
- en: '**Virtual Reality Modeling Language (VRML)**: This is a text-based format that
    allows you to specify 3D objects and worlds. It has been superseded by the X3D
    file format. Three.js doesn’t support loading **X3D** models, but these models
    can be easily converted to other formats. More information can be found at [http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟现实建模语言 (VRML)**: 这是一个基于文本的格式，允许您指定3D对象和世界。它已被X3D文件格式取代。Three.js不支持加载**X3D**模型，但这些模型可以轻松转换为其他格式。更多信息请参阅[http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#).'
- en: '**Visualization Toolkit (VTK)**: This is the file format defined by and used
    to specify vertices and faces. There are two formats available: a binary one and
    a text-based **ASCII** one. Three.js only supports the ASCII-based format.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视化工具包 (VTK)**: 这是用于定义和指定顶点和面的文件格式。有两种格式可供选择：一种二进制格式和基于文本的**ASCII**格式。Three.js仅支持基于ASCII的格式。'
- en: '**XYZ**: This is a very simple file format for describing points in 3D space.
    More information is available here: [https://people.math.sc.edu/Burkardt/data/xyz/xyz.html](https://people.math.sc.edu/Burkardt/data/xyz/xyz.html).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XYZ**: 这是一个用于描述3D空间中点的非常简单的文件格式。更多信息请参阅此处：[https://people.math.sc.edu/Burkardt/data/xyz/xyz.html](https://people.math.sc.edu/Burkardt/data/xyz/xyz.html).'
- en: In [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148), *Animations and Moving the
    Camera*, we’ll revisit some of these formats (and look at a number of additional
    ones) when we look at animations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18726_09.xhtml#_idTextAnchor148)，“动画和移动相机”中，当我们研究动画时，我们将重新审视这些格式（并查看一些额外的格式）。
- en: As you can see from this list, Three.js supports a very large number of 3D file
    formats. We won’t be describing all of them, just the most interesting ones. We’ll
    start with the JSON loader since that provides a nice way to store and retrieve
    scenes you’ve created yourself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从列表中看到的，Three.js支持非常多的3D文件格式。我们不会描述所有这些格式，只描述其中最有趣的一些。我们将从JSON加载器开始，因为它提供了一种存储和检索您自己创建的场景的好方法。
- en: Saving and loading in Three.js JSON format
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Three.js JSON格式中保存和加载
- en: You can use the Three.js JSON format for two different scenarios in Three.js.
    You can use it to save and load a single `THREE.Object3D` object (which means
    you can also use it to export a `THREE.Scene` object).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Three.js中使用JSON格式进行两种不同的场景。您可以使用它来保存和加载单个`THREE.Object3D`对象（这意味着您也可以使用它来导出`THREE.Scene`对象）。
- en: 'To demonstrate saving and loading, we created a simple example based on `THREE.TorusKnotGeometry`.
    With this example, you can create a torus knot, just as we did in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081)*,*
    and, using the **save** button from the **Save/load** menu, you can save the current
    geometry. For this example, we save using the HTML5 local storage API. This API
    allows us to easily store persistent information in the client’s browser and retrieve
    it at a later time (even after the browser has been shut down and restarted):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示保存和加载，我们基于 `THREE.TorusKnotGeometry` 创建了一个简单的示例。使用这个示例，你可以创建一个环面结，就像我们在
    [*第 5 章*](B18726_05.xhtml#_idTextAnchor081)* 中所做的那样，并且，使用 **保存/加载** 菜单中的 **保存**
    按钮，你可以保存当前的几何形状。对于这个示例，我们使用 HTML5 本地存储 API 进行保存。这个 API 允许我们轻松地在客户端浏览器中存储持久信息，并在稍后时间检索它（即使在浏览器关闭并重新启动之后）：
- en: '![Figure 8.5 – Showing the loaded and the current mesh](img/Figure_8.5_B18726.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 显示加载的网格和当前网格](img/Figure_8.5_B18726.jpg)'
- en: Figure 8.5 – Showing the loaded and the current mesh
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 显示加载的网格和当前网格
- en: In the previous screenshot, you can see two meshes—the red one is the one we
    loaded, and the yellow one is the original one. If you open this example yourself
    and click the **save** button, the current state of the mesh will be stored. Now,
    you can refresh the browser and click **load**, and the saved state will be shown
    in red.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到两个网格——红色的是我们加载的，黄色的是原始的。如果你自己打开这个示例并点击 **保存** 按钮，网格的当前状态将被存储。现在，你可以刷新浏览器并点击
    **加载**，保存的状态将以红色显示。
- en: 'Exporting in JSON from Three.js is very easy and doesn’t require you to include
    any additional libraries. The only thing you need to do is to export `THREE.Mesh`
    as JSON and store it in the browser’s `localstorage`, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Three.js 中导出 JSON 非常简单，不需要你包含任何额外的库。你需要做的只是将 `THREE.Mesh` 作为 JSON 导出，并将其存储在浏览器的
    `localstorage` 中，如下所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Before saving it, we first convert the result from the `toJSON` function (a
    JavaScript object) to a string using the `JSON.stringify` function. To save this
    information using the HTML5 local storage API, all we have to do is call the `localStorage.setItem`
    function. The first argument is the key value (json) that we can later use to
    retrieve the information we passed in as the second argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存之前，我们首先使用 `JSON.stringify` 函数将 `toJSON` 函数的结果（一个 JavaScript 对象）转换成字符串。要使用
    HTML5 本地存储 API 保存这些信息，我们只需调用 `localStorage.setItem` 函数。第一个参数是键值（json），我们稍后可以用它来检索我们作为第二个参数传递的信息。
- en: 'This JSON string looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JSON 字符串看起来是这样的：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, Three.js saves all the information about the `THREE.Mesh` object.
    Loading `THREE.Mesh` back into Three.js also requires just a few lines of code,
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Three.js 保存了关于 `THREE.Mesh` 对象的所有信息。将 `THREE.Mesh` 加载回 Three.js 也只需要几行代码，如下所示：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we first get the JSON from local storage using the name we saved it with
    (json, in this case). For this, we use the `localStorage.getItem` function provided
    by the HTML5 local storage API. Next, we need to convert the string back to a
    JavaScript object (`JSON.parse`) and convert the JSON object back to `THREE.Mesh`.
    Three.js provides a helper object called `THREE.ObjectLoader`, which you can use
    to convert JSON to `THREE.Mesh`. In this example, we used the `parse` method on
    the loader to directly parse a JSON string. The loader also provides a load function,
    where you can pass the URL to a file containing the JSON definition.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用保存时的名称（在这个例子中是 json）从本地存储中获取 JSON。为此，我们使用 HTML5 本地存储 API 提供的 `localStorage.getItem`
    函数。接下来，我们需要将字符串转换回 JavaScript 对象（`JSON.parse`），并将 JSON 对象转换回 `THREE.Mesh`。Three.js
    提供了一个名为 `THREE.ObjectLoader` 的辅助对象，你可以使用它将 JSON 转换为 `THREE.Mesh`。在这个例子中，我们使用了加载器的
    `parse` 方法来直接解析 JSON 字符串。加载器还提供了一个加载函数，你可以传递包含 JSON 定义的文件的 URL。
- en: 'As you can see here, we only saved a `THREE.Mesh` object, so we lose everything
    else. If you want to save the complete scene, including the lights and the cameras,
    you can use the same approach to export a scene:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只保存了一个 `THREE.Mesh` 对象，因此我们失去了其他所有信息。如果你想保存完整的场景，包括灯光和相机，你可以使用相同的方法导出场景：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result of this is a complete scene description in JSON:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结果是一个完整的场景描述，以 JSON 格式呈现：
- en: '![Figure 8.6 – Exporting a scene to JSON](img/Figure_8.5_B18726.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 将场景导出为 JSON](img/Figure_8.5_B18726.jpg)'
- en: Figure 8.6 – Exporting a scene to JSON
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 将场景导出为 JSON
- en: This can be loaded in the same way as we already showed for a `THREE.Mesh` object.
    While storing your current scene and objects in JSON comes in very handy when
    you’re working exclusively in Three.js, this isn’t a format that can easily be
    exchanged with or created by other tools and programs. In the next section, we’ll
    look a bit deeper into some of the 3D formats supported by Three.js.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过与我们之前展示的 `THREE.Mesh` 对象相同的方式进行加载。当你在 Three.js 中独立工作并存储当前场景和对象为 JSON 时，这非常有用，但这并不是一个可以轻松与其他工具和程序交换或创建的格式。在下一节中，我们将更深入地探讨
    Three.js 支持的一些 3D 格式。
- en: Importing from 3D file formats
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 3D 文件格式导入
- en: At the beginning of this chapter, we listed a number of formats that are supported
    by Three.js. In this section, we’ll quickly walk through a few examples of those
    formats.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我们列出了一些 Three.js 支持的格式。在本节中，我们将快速浏览这些格式的几个示例。
- en: The OBJ and MTL formats
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OBJ 和 MTL 格式
- en: 'OBJ and MTL are companion formats and are often used together. An OBJ file
    defines the geometry, and an MTL file defines the materials that are used. Both
    OBJ and MTL are text-based formats. A part of an OBJ file looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ 和 MTL 是配套格式，通常一起使用。OBJ 文件定义几何形状，MTL 文件定义使用的材质。OBJ 和 MTL 都是文本格式。OBJ 文件的一部分看起来像这样：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An MTL file defines materials, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: MTL 文件定义材质，如下所示：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The OBJ and MTL formats are well supported by Three.js, so this is a good format
    to choose if you want to exchange 3D models. Three.js has two different loaders
    you can use. If you only want to load the geometry, you use `OBJLoader`. We used
    this loader for our example (`load-obj.html`). The following screenshot shows
    this example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ 和 MTL 格式在 Three.js 中得到了很好的支持，因此如果你想要交换 3D 模型，这是一个不错的选择。Three.js 有两个不同的加载器你可以使用。如果你只想加载几何形状，你使用
    `OBJLoader`。我们使用了这个加载器作为我们的示例（`load-obj.html`）。以下截图显示了此示例：
- en: '![Figure 8.7 – OBJ model that just defines the geometry](img/Figure_8.7_B18726.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 仅定义几何形状的 OBJ 模型](img/Figure_8.7_B18726.jpg)'
- en: Figure 8.7 – OBJ model that just defines the geometry
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 仅定义几何形状的 OBJ 模型
- en: 'Loading an OBJ model from an external file is done like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部文件加载 OBJ 模型的操作如下：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this code, we use `OBJLoader` to load the model from a URL asynchronously.
    This returns a JavaScript promise, which, when resolved, will contain the mesh.
    Once the model is loaded, we do some fine-tuning and make sure the model casts
    shadows and receives shadows as well. Besides `loadAsync`, each loader also provides
    a `load` function, which, instead of working with promises, works with callbacks.
    This same code would then look something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用 `OBJLoader` 从 URL 异步加载模型。这返回一个 JavaScript promise，当解析时，将包含网格。一旦模型加载完成，我们进行一些微调，并确保模型可以投射阴影并接收阴影。除了
    `loadAsync`，每个加载器还提供了一个 `load` 函数，它不使用 promises，而是使用回调。这段代码将看起来像这样：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this chapter, we’ll use the `Promise`-based `loadAsync` approach, since
    that avoids having nested callbacks and makes it a bit easier to chain these kinds
    of calls together. The next example (`oad-obj-mtl.html`) uses `OBJLoader`, together
    with `MTLLoader`, to load a model and directly assign a material. The following
    screenshot shows this example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用基于 `Promise` 的 `loadAsync` 方法，因为它避免了嵌套回调，并使这些调用更容易串联。下一个示例（`oad-obj-mtl.html`）使用
    `OBJLoader` 和 `MTLLoader` 一起加载模型并直接分配材质。以下截图显示了此示例：
- en: '![Figure 8.8 – OBJ.MTL model with a model and materials](img/Figure_8.8_B18726.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 带有模型和材质的 OBJ.MTL 模型](img/Figure_8.8_B18726.jpg)'
- en: Figure 8.8 – OBJ.MTL model with a model and materials
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 带有模型和材质的 OBJ.MTL 模型
- en: 'Using an `MTL` file besides the `OBJ` file follows the same principle we saw
    earlier in this section:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 OBJ 文件外，使用 `MTL` 文件遵循本节前面看到的相同原则：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing to mention before we look at the code is that if you receive
    an `OBJ` file, an `MTL` file, and the required texture files, you’ll have to check
    how the `MTL` file references the textures. These should be referenced relative
    to the `MTL` file and not as an absolute path. The code itself isn’t that different
    than the one we saw for `THREE.ObjLoader`. The first thing we do is load the `MTL`
    file with a `THREE.MTLLoader` object and the loaded materials are set in `THREE.ObjLoader`
    through the `setMaterials` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码之前，首先要提到的是，如果你收到一个`OBJ`文件、一个`MTL`文件和所需的纹理文件，你必须检查`MTL`文件如何引用纹理。这些应该相对于`MTL`文件进行引用，而不是绝对路径。代码本身与我们之前看到的`THREE.ObjLoader`代码没有太大区别。我们首先使用`THREE.MTLLoader`对象加载`MTL`文件，并通过`setMaterials`函数将加载的材质设置在`THREE.ObjLoader`中。
- en: 'The model we’ve used as an example, in this case, is complex. So, we set some
    specific properties in the callback to fix a number of rendering issues, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用作示例的模型很复杂。因此，我们在回调中设置了一些特定的属性来修复多个渲染问题，如下所示：
- en: We needed to merge the vertices in the model so that it is rendered as a smooth
    model. For this, we first needed to remove the already defined `normal` vectors
    from the loaded model so that we could use the `BufferGeometryUtils.mergeVertices`
    and `computeVertexNormals` functions to provide Three.js with the information
    to correctly render the model.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要合并模型中的顶点，以便将其渲染为平滑的模型。为此，我们首先需要从加载的模型中移除已定义的`normal`向量，以便我们可以使用`BufferGeometryUtils.mergeVertices`和`computeVertexNormals`函数来为Three.js提供正确渲染模型所需的信息。
- en: The opacity in the source files was set incorrectly, which caused the wings
    to be invisible. So, to fix that, we set the `opacity` and `transparent` properties
    ourselves.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件中的不透明度设置不正确，导致翅膀不可见。因此，为了修复这个问题，我们自行设置了`opacity`和`transparent`属性。
- en: By default, Three.js only renders one side of an object. Since we look at the
    wings from two sides, we needed to set the `side` property to the `THREE.DoubleSide`
    value.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Three.js只渲染对象的单侧。由于我们从两个侧面观察翅膀，我们需要将`side`属性设置为`THREE.DoubleSide`值。
- en: The wings caused some unwanted artifacts when they needed to be rendered on
    top of one another. We fixed that by setting the `alphaTest` property.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翅膀需要叠加渲染时，它们产生了一些不希望出现的伪影。我们通过设置`alphaTest`属性来解决这个问题。
- en: But as you can see, you can easily load complex models directly into Three.js
    and render them in real time in your browser. You might need to fine-tune various
    material properties, though.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如您所看到的，您可以直接将复杂模型加载到Three.js中，并在浏览器中实时渲染它们。尽管如此，您可能需要调整各种材质属性。
- en: Loading a gLTF model
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载gltf模型
- en: 'We already mentioned that glTF is a great format to use when importing data
    in Three.js. Just to show you how easy it is to import and show even complex scenes,
    we’ve added an example where we just took a model from [https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d](https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，glTF是导入Three.js数据时使用的一个非常好的格式。为了展示导入和显示甚至复杂场景的简单性，我们添加了一个示例，其中我们只是从[https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d](https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d)取了一个模型：
- en: '![Figure 8.9 – Complex 3D scene loaded from glTF with Three.js](img/Figure_8.9_B18726.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 使用Three.js从glTF加载的复杂3D场景](img/Figure_8.9_B18726.jpg)'
- en: Figure 8.9 – Complex 3D scene loaded from glTF with Three.js
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 使用Three.js加载的复杂3D场景
- en: 'As you can see from the previous screenshot, this isn’t a simple scene but
    a complex one, with lots of models, textures, shadows, and other elements. To
    get this in Three.js, all we had to do was this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从之前的屏幕截图中所见，这不仅仅是一个简单的场景，而是一个复杂的场景，包含许多模型、纹理、阴影和其他元素。要在Three.js中实现这一点，我们只需做以下操作：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You’re already familiar with the async loader, and the only thing we needed
    to fix was to make sure the `depthWrite` property of the materials was set correctly
    (this seems to be a common issue with some glTF models). And that’s it—it just
    works. glTF also allows us to define animations, which is something we’ll look
    at a bit closer in the next chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了异步加载器，我们唯一需要修复的是确保材质的`depthWrite`属性设置正确（这似乎是一些glTF模型中常见的问题）。就这样了——它就是那么简单。glTF还允许我们定义动画，我们将在下一章中更详细地探讨这一点。
- en: Showing complete LEGO models
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示完整的乐高模型
- en: 'Besides 3D models, where the model defines the vertices, materials, lights,
    and more, there are also various file formats that don’t explicitly define the
    geometries but have more specific usage. The `LDrawLoader` loader, which we’ll
    be looking at in this section, was created to render LEGO models in 3D. Using
    this loader works in the same way as we’ve already seen a couple of times:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义顶点、材质、灯光等3D模型的文件格式外，还有各种文件格式不明确定义几何形状，但具有更具体的用途。在本节中，我们将探讨的`LDrawLoader`加载器是为了在3D中渲染LEGO模型而创建的。使用此加载器的方式与我们之前已经看到几次的方式相同：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the results look really great:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来非常棒：
- en: '![Figure 8.10 – LEGO Imperial AT-ST model](img/Figure_8.10_B18726.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – LEGO帝国AT-ST模型](img/Figure_8.10_B18726.jpg)'
- en: Figure 8.10 – LEGO Imperial AT-ST model
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – LEGO帝国AT-ST模型
- en: 'As you can see, it shows the complete structure of a LEGO set. There are many
    different models out there that you can use:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它显示了乐高套装的完整结构。有许多不同的模型可供您使用：
- en: "![Figure 8.11 – L\uFEFFEGO X-Wing Fighter](img/Figure_8.11_B18726.jpg)"
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – LEGO X-Wing战斗机](img/Figure_8.11_B18726.jpg)'
- en: Figure 8.11 – LEGO X-Wing Fighter
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – LEGO X-Wing战斗机
- en: 'If you want to explore more models, you can download them from the LDraw repository:
    [https://omr.ldraw.org/](https://omr.ldraw.org/).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想探索更多模型，您可以从LDraw仓库下载它们：[https://omr.ldraw.org/](https://omr.ldraw.org/)。
- en: Loading voxel-based models
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载基于体素的模型
- en: 'Another interesting approach to creating 3D models is by using voxels. This
    allows you to build models using small cubes and render them using Three.js. For
    instance, you can create Minecraft structures outside of Minecraft using such
    a tool and import them into Minecraft at a later time. A free tool to experiment
    with voxels is MagicaVoxel ([https://ephtracy.github.io/](https://ephtracy.github.io/)).
    This tool allows you to create voxel models such as this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建3D模型的另一种有趣的方法是使用体素。这允许您使用小立方体构建模型，并使用Three.js进行渲染。例如，您可以使用这样的工具在Minecraft之外创建Minecraft结构，并在稍后将其导入Minecraft。一个用于实验体素的免费工具是MagicaVoxel
    ([https://ephtracy.github.io/](https://ephtracy.github.io/))。此工具允许您创建如上所示的体素模型：
- en: '![Figure 8.12 – Example model created with MagicaVoxel](img/Figure_8.12_B18726.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 使用MagicaVoxel创建的示例模型](img/Figure_8.12_B18726.jpg)'
- en: Figure 8.12 – Example model created with MagicaVoxel
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 使用MagicaVoxel创建的示例模型
- en: 'The interesting part is that you can easily import these models in Three.js
    using the `VOXLoader` loader, like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，您可以使用`VOXLoader`加载器轻松地将这些模型导入Three.js，如下所示：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `models` folder, you can find a couple of vox models. The following
    screenshot shows what it looks like loaded with Three.js:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models`文件夹中，您可以找到一些体素模型。以下截图显示了使用Three.js加载后的样子：
- en: '![Figure 8.13 – Vox model loading with Three.js](img/Figure_8.13_B18726.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 使用Three.js加载Vox模型](img/Figure_8.13_B18726.jpg)'
- en: Figure 8.13 – Vox model loading with Three.js
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 使用Three.js加载Vox模型
- en: The next loader is another very specific one. We’ll look at how to render proteins
    from PDB format.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个加载器是另一个非常具体的加载器。我们将探讨如何从PDB格式渲染蛋白质。
- en: Showing proteins from PDB
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从PDB显示蛋白质
- en: The PDB website ([www.rcsb.org](http://www.rcsb.org)) contains detailed information
    about many different molecules and proteins. Besides an explanation of these proteins,
    it also provides a way to download the structure of these molecules in PDB format.
    Three.js provides a loader for files specified in the PDB format. In this section,
    we’ll give an example of how you can parse PDB files and visualize them with Three.js.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: PDB网站 ([www.rcsb.org](http://www.rcsb.org)) 包含有关许多不同分子和蛋白质的详细信息。除了对这些蛋白质的解释外，它还提供了下载这些分子PDB格式的结构的方法。Three.js为PDB格式的文件提供了加载器。在本节中，我们将给出一个示例，说明您如何解析PDB文件并使用Three.js进行可视化。
- en: 'With this loader included, we’re going to create the following 3D model of
    the molecule description provided (see the `load-pdb.html` example):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 包含此加载器后，我们将创建以下分子描述的3D模型（请参阅`load-pdb.html`示例）：
- en: '![Figure 8.14 – Visualizing a protein using Three.js and PDBLoader](img/Figure_8.14_B18726.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 使用Three.js和PDBLoader可视化蛋白质](img/Figure_8.14_B18726.jpg)'
- en: Figure 8.14 – Visualizing a protein using Three.js and PDBLoader
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 使用Three.js和PDBLoader可视化蛋白质
- en: 'Loading a PDB file is done in the same manner as the previous formats, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 加载PDB文件的方式与之前的格式相同，如下所示：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see from this example code, we instantiate a `THREE.PDBLoader` object
    and pass in the model file we want to load, and once the model is loaded, we process
    it. In this case, the model consists of two properties: `geometryAtoms` and `geometryBonds`.
    The position attributes from `geometryAtoms` contain the positions of the individual
    atoms, and the color attributes can be used to color the individual atoms. For
    a link between the atoms, `geometryBonds` is used.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例代码所示，我们实例化了一个 `THREE.PDBLoader` 对象，并传入我们想要加载的模型文件，一旦模型加载完成，我们就对其进行处理。在这种情况下，模型包含两个属性：`geometryAtoms`
    和 `geometryBonds`。`geometryAtoms` 中的位置属性包含单个原子的位置，而颜色属性可以用来为单个原子着色。对于原子之间的连接，使用
    `geometryBonds`。
- en: 'Based on the position and color, we create a `THREE.Mesh` object and add it
    to a group:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据位置和颜色，我们创建一个 `THREE.Mesh` 对象并将其添加到一个组中：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With regard to the connection between the atoms, we follow the same approach.
    We get the start and end positions of the connection and use those to draw the
    connection:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于原子之间的连接，我们采用相同的方法。我们获取连接的起始和结束位置，并使用这些位置来绘制连接：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the connection, we first create a 3D path using `THREE.CatmullRomCurve3`.
    This path is used as input for `THREE.TubeGeometry` and is used to create a connection
    between the atoms. All the connections and atoms are added to a group, and this
    group is added to the scene. There are many models you can download from PDB.
    For instance, the following screenshot shows the structure of a diamond:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接，我们首先使用 `THREE.CatmullRomCurve3` 创建一个 3D 路径。此路径用作 `THREE.TubeGeometry` 的输入，并用于在原子之间创建连接。所有连接和原子都添加到一个组中，然后将该组添加到场景中。您可以从
    PDB 下载许多模型。例如，以下截图显示了钻石的结构：
- en: '![Figure 8.15 – The structure of a diamond](img/Figure_8.15_B18726.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.15 – 钻石的结构](img/Figure_8.15_B18726.jpg)'
- en: Figure 8.15 – The structure of a diamond
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 钻石的结构
- en: In the next section, we’re looking at the support Three.js has for the PLY model,
    which can be used to load point cloud data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 Three.js 对 PLY 模型的支持，该支持可用于加载点云数据。
- en: Loading a point cloud from a PLY model
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 PLY 模型加载点云
- en: 'Working with the PLY format isn’t that much different than the other formats.
    You include the loader and handle the loaded model. For this last example, however,
    we’re going to do something different. Instead of rendering the model as a mesh,
    we’ll use the information from this model to create a particle system (see the
    `load-ply.html` example in the following screenshot):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PLY 格式一起工作并不比其他格式复杂多少。您包含加载器并处理加载的模型。然而，对于最后一个示例，我们将做一些不同的事情。我们不会将模型作为网格渲染，而是将使用此模型的信息来创建一个粒子系统（请参阅以下截图中的
    `load-ply.html` 示例）：
- en: '![Figure 8.16 – Point cloud loaded from a PLY model](img/Figure_8.16_B18726.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.16 – 从 PLY 模型加载的点云](img/Figure_8.16_B18726.jpg)'
- en: Figure 8.16 – Point cloud loaded from a PLY model
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 从 PLY 模型加载的点云
- en: 'The JavaScript code to render the preceding screenshot is actually very simple;
    it looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染前面截图的 JavaScript 代码实际上非常简单；它看起来像这样：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we use `THREE.PLYLoader` to load the model and use this geometry
    as input for `THREE.Points`. The material we use is the same as what we used for
    the last example in [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122), *Points and
    Sprites*. As you can see, with Three.js, it is very easy to combine models from
    various sources and render them in different ways, all with a few lines of code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用 `THREE.PLYLoader` 来加载模型，并将此几何形状作为 `THREE.Points` 的输入。我们使用的材质与我们在 [*第
    7 章*](B18726_07.xhtml#_idTextAnchor122) 的最后一个示例中使用的材质相同，即 *点和精灵*。如您所见，使用 Three.js，结合来自不同来源的模型并以不同方式渲染它们非常容易，所有这些只需几行代码即可完成。
- en: Other loaders
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他加载器
- en: 'At the beginning of this chapter, in the *Loading geometries from external
    resources* section, we showed you a list of all the different loaders provided
    by Three.js. We’ve provided examples of all these in the sources for `chapter-8`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，在 *从外部资源加载几何形状* 部分中，我们向您展示了一个由 Three.js 提供的所有不同加载器的列表。我们在 `chapter-8`
    的源代码中提供了所有这些示例：
- en: '![Figure 8.17 – Directory showing examples of all the loaders](img/Figure_8.17_B18726.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.17 – 显示所有加载器示例的目录](img/Figure_8.17_B18726.jpg)'
- en: Figure 8.17 – Directory showing examples of all the loaders
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 显示所有加载器示例的目录
- en: The source code for all these loaders follows the same patterns as we’ve seen
    for the loaders we have explained in this chapter. Just load the model, determine
    which part of the loaded model you want to show, make sure scaling and positions
    are correct, and add it to the scene.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些加载器的源代码遵循我们在这章中解释的加载器相同的模式。只需加载模型，确定你想显示加载模型的哪一部分，确保缩放和位置正确，然后将其添加到场景中。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Using models from external sources isn’t that hard to do in Three.js, especially
    for simple models—you only have to take a few easy steps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中使用外部模型并不困难，特别是对于简单的模型——你只需要进行几个简单的步骤。
- en: When working with external models, or creating them using grouping and merging,
    it is good to keep a couple of things in mind. The first thing you need to remember
    is that when you group objects, they remain available as individual objects. Transformations
    applied to the parent also affect the children, but you can still transform the
    children individually. Besides grouping, you can also merge geometries together.
    With this approach, you lose the individual geometries and get a single new geometry.
    This is especially useful when you’re dealing with thousands of geometries you
    need to render and you’re running into performance issues. The final approach
    if you want to control a large number of meshes of the same geometry is to use
    a `THREE.InstancedMesh` object or a `THREE.InstancedBufferGeometry` object, which
    allows you to position and transform the individual meshes, but still get great
    performance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当与外部模型一起工作，或者通过分组和合并创建它们时，有一些事情需要牢记。首先，你需要记住的是，当你对对象进行分组时，它们仍然作为单独的对象可用。应用于父对象的变化也会影响子对象，但你仍然可以单独变换子对象。除了分组之外，你还可以合并几何体。采用这种方法，你会失去单独的几何体，而得到一个单一的新几何体。这在处理需要渲染成千上万的几何体且遇到性能问题时特别有用。如果你想要控制大量相同几何体的网格，最终的方法是使用`THREE.InstancedMesh`对象或`THREE.InstancedBufferGeometry`对象，这允许你定位和变换单独的网格，同时仍然获得良好的性能。
- en: Three.js supports a large number of external formats. When using these format
    loaders, it’s a good idea to look through the source code and add `console.log`
    statements to determine what the data loaded really looks like. This will help
    you to understand the steps you need to take to get the correct mesh and set it
    to the correct position and scale. Often, when the model doesn’t show correctly,
    this is caused by its material settings. It could be that incompatible texture
    formats are used, opacity is incorrectly defined, or the format contains incorrect
    links to the texture images. It is usually a good idea to use a test material
    to determine whether the model itself is loaded correctly and log the loaded material
    to the JavaScript console to check for unexpected values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js支持大量外部格式。当使用这些格式加载器时，查看源代码并添加`console.log`语句以确定加载数据的真实外观是个好主意。这将帮助你理解需要采取的步骤以获取正确的网格并将其设置为正确的位置和比例。通常，当模型显示不正确时，这是由于其材质设置引起的。可能是使用了不兼容的纹理格式，不透明度定义不正确，或者格式包含指向纹理图像的错误链接。通常，使用测试材质来确定模型本身是否正确加载，并将加载的材质记录到JavaScript控制台以检查意外值是个好主意。
- en: If you want to reuse your own scenes or models, you can simply export these
    by just calling the `asJson` function and loading them again with `ObjectLoader`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要重用你自己的场景或模型，你可以通过调用`asJson`函数简单地导出它们，然后使用`ObjectLoader`再次加载它们。
- en: The models you worked with in this chapter, and in the previous chapters, are
    mostly static models. They aren’t animated, don’t move around, and don’t change
    shape. In [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148), you’ll learn how you
    can animate your models to make them come to life. Besides animations, the next
    chapter will also explain the various camera controls provided by Three.js. With
    a camera control, you can move, pan, and rotate the camera around your scene.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及前几章中你使用的模型大多是静态模型。它们没有动画，不会移动，也不会改变形状。在[*第9章*](B18726_09.xhtml#_idTextAnchor148)中，你将学习如何使你的模型动起来，使其栩栩如生。除了动画之外，下一章还将解释Three.js提供的各种相机控制。通过相机控制，你可以移动、平移和旋转相机，使其围绕场景移动。
