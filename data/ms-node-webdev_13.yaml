- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Using Databases
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库
- en: In this chapter, I will demonstrate how Node.js applications can use a relational
    database to store and query data. This chapter explains how to work directly with
    a database by executing SQL queries, and how to take a more hands-off approach
    with an **Object Relational Mapping** (**ORM**) package. *Table 12.1* puts this
    chapter into context.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将演示 Node.js 应用程序如何使用关系型数据库来存储和查询数据。本章解释了如何通过执行 SQL 查询直接与数据库交互，以及如何使用 ORM
    包采取更少干预的方法。*表 12.1* 将本章置于上下文中。
- en: 'Table 12.1: Putting databases into context'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1：将数据库置于上下文中
- en: '| **Question** | **Answer** |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | **答案** |'
- en: '| What are they? | Databases are the most common means of persistently storing
    data. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 它们是什么？ | 数据库是持久存储数据最常见的方式。 |'
- en: '| Why are they useful? | Databases can store large volumes of data and enforce
    a data structure that makes it possible to perform efficient queries. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 为什么它们有用？ | 数据库可以存储大量数据，并强制执行一种数据结构，这使得执行高效查询成为可能。 |'
- en: '| How are they used? | Databases are managed by database engines, which can
    be installed as npm packages, run on dedicated servers, or consumed as cloud services.
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 如何使用它们？ | 数据库由数据库引擎管理，这些引擎可以作为 npm 包安装，在专用服务器上运行，或作为云服务使用。 |'
- en: '| Are there any pitfalls or limitations? | Databases can be complex and require
    additional knowledge, such as being able to formulate queries in SQL. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 有没有陷阱或限制？ | 数据库可能很复杂，需要额外的知识，例如能够用 SQL 表达查询。 |'
- en: '| Are there any alternatives? | Databases are not the only way to store data,
    but they are the most common, and, generally, the most effective because they
    are robust and scale up easily. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 有没有替代方案？ | 数据库不是存储数据的唯一方式，但它们是最常见的，通常也是最有效的，因为它们具有鲁棒性并且易于扩展。 |'
- en: '*Table 12.2* summarizes what we will do in the chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 12.2* 总结了本章我们将做什么。'
- en: 'Table 12.2: Chapter summary'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.2：本章总结
- en: '| Problem | Solution | Listing |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 列表 |'
- en: '| Store data persistently. | Use a database. | *7, 8, 12, 13* |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 持久存储数据。 | 使用数据库。 | *7, 8, 12, 13* |'
- en: '| Simplify the process of changing how data is stored. | Use a repository layer.
    | *9–11* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 简化更改数据存储方式的过程。 | 使用存储库层。 | *9–11* |'
- en: '| Display stored data. | Include query results when rendering templates. |
    *14, 15* |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 显示存储的数据。 | 在渲染模板时包含查询结果。 | *14, 15* |'
- en: '| Prevent user-submitted values from being interpreted as SQL. | Use query
    parameters. | *16, 17* |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 防止用户提交的值被解释为 SQL。 | 使用查询参数。 | *16, 17* |'
- en: '| Ensure that data is updated consistently. | Use a transaction. | *18–21*
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 确保数据的一致性更新。 | 使用事务。 | *18–21* |'
- en: '| Use a database without needing to write SQL queries. | Use an ORM package
    and describe the data used by the application using JavaScript code. | *22–25,
    27, 28* |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 无需编写 SQL 查询即可使用数据库。 | 使用 ORM 包，并使用 JavaScript 代码描述应用程序使用的数据。 | *22–25, 27,
    28* |'
- en: '| Perform operations that are too complex to describe using model classes.
    | Use the ORM package facility for executing SQL. | *26* |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 执行使用模型类难以描述的操作。 | 使用 ORM 包的执行 SQL 功能。 | *26* |'
- en: '| Query for and update data using an ORM. | Use the methods defined by the
    model classes, with constraints specified using JavaScript objects. | *29–32*
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 使用 ORM 查询和更新数据。 | 使用模型类定义的方法，并通过 JavaScript 对象指定约束。 | *29–32* |'
- en: Preparing for this chapter
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备本章内容
- en: This chapter uses the `part2app` project from *Chapter 11*. To prepare for this
    chapter, *Listing 12.1* removes the client-side validation code, which won’t be
    used in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用 *第 11 章* 中的 `part2app` 项目。为了准备本章，*列表 12.1* 删除了客户端验证代码，因为本章不会使用它。
- en: '**Tip**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development)
    下载本章的示例项目——以及本书中所有其他章节的示例项目。有关如何获取帮助以运行示例的说明，请参阅 *第 1 章*。
- en: 'Listing 12.1: The contents of the client.js file in the src/client folder'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.1：src/client 文件夹中 client.js 文件的内容
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 12.2* updates the routing configuration for the example application.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12.2* 更新了示例应用的路由配置。'
- en: 'Listing 12.2: The contents of the server.ts file in the src/server folder'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2：src/server 文件夹中 server.ts 文件的内容
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The new routing configuration removes entries that are no longer required.
    All the examples in this chapter use templates, and the new route matches requests
    for the default path and responds with a redirection to the `/form` URL. The new
    route uses Express support for matching URL patterns, like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 新的路由配置删除了不再需要的条目。本章中的所有示例都使用模板，新的路由匹配默认路径的请求，并响应重定向到 `/form` URL。新的路由使用 Express
    对 URL 模式的匹配支持，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The pattern is required to match requests for `http://localhost:5000` and not
    requests that are handled by other routes, such as `http://localhost:5000/css/bootstrap.min.css`
    (which is handled by the static content middleware) or `http://localhost:5000/bundle.js`
    (which is forwarded to the webpack development HTTP server).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式需要匹配对 `http://localhost:5000` 的请求，而不是由其他路由处理的请求，例如 `http://localhost:5000/css/bootstrap.min.css`（由静态内容中间件处理）或
    `http://localhost:5000/bundle.js`（转发到 webpack 开发 HTTP 服务器）。
- en: '*Listing 12.3* updates the `age` template to add a field that allows the user
    to specify a number of years, just to allow more variations in the results data.
    The structure of the HTML output has been changed to introduce a two-column layout
    and use a partial template named `history`. This listing also removes the validation
    error elements, which is something that should not be done in a real project,
    but they are not needed in this chapter.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12.3* 更新了 `age` 模板，添加了一个允许用户指定年数的字段，以便在结果数据中允许更多的变化。HTML 输出的结构已更改，引入了两列布局并使用名为
    `history` 的部分模板。此列表还删除了验证错误元素，这在实际项目中是不应该做的，但在这个章节中它们不是必需的。'
- en: 'Listing 12.3: The contents of the age.handlebars file in the templates/server
    folder'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3：模板/服务器文件夹中 age.handlebars 文件的内容
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To create the partial view, add a file named `history.handlebars` to the `templates/server/partials`
    folder with the content shown in *Listing 12.4*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建部分视图，将名为 `history.handlebars` 的文件添加到 `templates/server/partials` 文件夹中，内容如
    *列表 12.4* 所示。
- en: 'Listing 12.4: The contents of the history.handlebars folder in the templates/server/partials
    folder'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4：模板/服务器/部分文件夹中 history.handlebars 文件夹的内容
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The partial template displays data provided through a `history` context property
    and displays a default message when no data is available. *Listing 12.5* revises
    the code that handles the `/form` URL to remove the validation checks introduced
    in the previous chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 部分模板显示通过 `history` 上下文属性提供的数据，当没有数据可用时显示默认消息。*列表 12.5* 修改了处理 `/form` URL 的代码，移除了上一章中引入的验证检查。
- en: 'Listing 12.5: The contents of the forms.ts file in the src/server folder'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.5：src/server 文件夹中 forms.ts 文件的内容
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the command shown in *Listing 12.6* in the `part2app` folder to start the
    development tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `part2app` 文件夹中运行 *列表 12.6* 中显示的命令以启动开发工具。
- en: 'Listing 12.6: Starting the development tools'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.6：启动开发工具
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Use a browser to request `http://localhost:5000`, fill out the form, and click
    the **Submit** button, as shown in *Figure 12.1*. No data will be displayed in
    the **Recent Queries** section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求 `http://localhost:5000`，填写表单，并点击**提交**按钮，如图 *图 12.1* 所示。在**最近查询**部分不会显示任何数据。
- en: '![](img/B21959_12_01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21959_12_01.png)'
- en: 'Figure 12.1: Running the example application'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：运行示例应用程序
- en: Using a database
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库
- en: Databases allow web applications to read and write data, which can be used to
    generate responses for HTTP requests. There are many types of database, with choices
    about how data is stored and queried, how the database software is deployed, and
    how changes to data are handled.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库允许网络应用程序读取和写入数据，这些数据可以用于生成对 HTTP 请求的响应。有许多类型的数据库，包括关于数据存储和查询的选择、数据库软件的部署方式以及如何处理数据变更。
- en: The database market is competitive and innovative, and there are excellent commercial
    and open-source products, but my advice is that the best database is one that
    you already understand and have worked with before. Most projects can use most
    databases, and the benefit that a particular database technology confers will
    be undermined by the time taken to learn and master that technology.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库市场具有竞争力和创新性，有优秀的商业和开源产品，但我的建议是，最好的数据库是你已经理解和之前使用过的数据库。大多数项目可以使用大多数数据库，而特定数据库技术带来的好处可能会因为学习并掌握该技术所需的时间而被削弱。
- en: If you don’t have a database, it is easy to get lost in the endless options,
    and my advice is to start with something as simple as possible. For small applications,
    I recommend SQLite, which is the database I will use in this chapter. For larger
    applications, especially where multiple instances of Node.js are used to handle
    HTTP requests, I recommend one of the excellent open-source relational databases,
    such as MySQL ([https://www.mysql.com](https://www.mysql.com)) or PostgreSQL ([https://www.postgresql.org](https://www.postgresql.org)).
    You can see an example of one such database in *Part 3* of this book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有数据库，很容易在无尽的选择中迷失方向，我的建议是从尽可能简单的东西开始。对于小型应用程序，我推荐SQLite，这是我在本章中将使用的数据库。对于大型应用程序，尤其是在使用多个Node.js实例来处理HTTP请求的情况下，我推荐使用一些优秀的开源关系型数据库，例如MySQL
    ([https://www.mysql.com](https://www.mysql.com)) 或 PostgreSQL ([https://www.postgresql.org](https://www.postgresql.org))。你可以在本书的第三部分中看到一个这样的数据库示例。
- en: If you don’t like using the **Structured Query Language** (**SQL**), then there
    are good NoSQL databases available and a good place to start is MongoDB ([https://www.mongodb.com](https://www.mongodb.com)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢使用**结构化查询语言**（**SQL**），那么有很好的NoSQL数据库可供选择，一个好的起点是MongoDB ([https://www.mongodb.com](https://www.mongodb.com))。
- en: '**Database Complaints**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库投诉**'
- en: I receive complaints whenever I write about choosing database products. Many
    developers have strong views about the superiority of a particular database or
    style of database and are upset when I don’t recommend their preferred product.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我写关于选择数据库产品时，我都会收到投诉。许多开发者对某个特定数据库或数据库风格的优越性有强烈的看法，当我不推荐他们偏好的产品时，他们会感到沮丧。
- en: It isn’t that I think any particular database engine is bad. In fact, the database
    market has never been so good, to the extent that just about any database product
    can be used in just about any project with little impact on productivity or scale.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 并非我认为任何特定的数据库引擎不好。事实上，数据库市场从未如此繁荣，以至于几乎任何数据库产品都可以在几乎任何项目中使用，对生产效率或规模的影响很小。
- en: 'Database engines are like automobiles: modern cars are so good that most people
    can get along with just about any car. If you already have a car, then the benefit
    of changing it is likely to be small when compared to the cost. If you don’t have
    a car, then a good place to start is with the car that most of your neighbors
    have and the local mechanics often work on. Some people get really into cars and
    have strong views about a particular make or model, and that’s fine, but it can
    be taken to excess, and most people don’t drive in a way where marginal improvements
    become significant.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库引擎就像汽车：现代汽车如此出色，以至于大多数人几乎可以用任何汽车来应对。如果你已经有了汽车，那么与更换汽车的成本相比，改变它的好处可能很小。如果你没有汽车，那么一个好的起点就是从大多数邻居都有的汽车开始，当地的机械师经常对其进行维修。有些人对汽车非常着迷，并对某个品牌或型号有强烈的看法，这很正常，但可能会过度，而且大多数人不会以使边际改进变得显著的方式驾驶。
- en: So, I absolutely understand why some developers become deeply invested in a
    particular database engine – and I respect that level of commitment and understanding
    – but most projects don’t have the kinds of data storage or processing requirements
    that make the differences between database products important.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我完全理解为什么一些开发者会深深投入到特定的数据库引擎中——我尊重这种承诺和理解水平——但大多数项目并没有那些使数据库产品之间差异重要的数据存储或处理需求。
- en: Installing the database package
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装数据库包
- en: The database engine used in this chapter is SQLite. It operates within the Node.js
    process and is a good choice for applications where data doesn’t need to be shared
    between multiple instances of Node.js, which SQLite doesn’t support because it
    doesn’t run as a separate server. SQLite is widely used and is, at least according
    to [https://sqlite.org](https://sqlite.org), the most popular database engine
    in the world.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的数据库引擎是SQLite。它在Node.js进程中运行，是数据不需要在多个Node.js实例之间共享的应用程序的良好选择。由于SQLite不作为单独的服务器运行，因此它不支持这一点。SQLite被广泛使用，至少根据[https://sqlite.org](https://sqlite.org)，它是世界上最受欢迎的数据库引擎。
- en: Run the command shown in *Listing 12.7* in the `part2app` folder to add SQLite
    to the project. No additional TypeScript type packages are required.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`part2app`文件夹中运行*列表12.7*中显示的命令，将SQLite添加到项目中。不需要额外的TypeScript类型包。
- en: 'Listing 12.7: Adding the database package to the project'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.7：将数据库包添加到项目中
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This package includes the database engine, a Node.js API, and descriptions of
    those APIs for the TypeScript compiler. To describe the database that will be
    used in this section, add a file named `age.sql` to the `part2app` folder with
    the content shown in *Listing 12.8*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此包包括数据库引擎、Node.js API以及这些API对TypeScript编译器的描述。为了描述本节中将使用的数据库，将一个名为`age.sql`的文件添加到`part2app`文件夹中，其内容如*列出12.8*所示。
- en: 'Listing 12.8: The contents of the age.sql file in the part2app folder'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列出12.8：`part2app`文件夹中age.sql文件的内容
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The SQL statements in *Listing 12.8* create three tables, which will record
    the age calculations performed by the application. The `Calculations` table keeps
    track of the age calculations that have been performed and has columns for the
    age and year values provided by the user and the future age that has been calculated.
    The `People` table keeps track of the names that users provide. The `Results`
    table keeps track of results by referencing a name and a calculation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出12.8*中的SQL语句创建了三个表，这些表将记录应用程序执行的计算年龄。`Calculations`表跟踪已执行的计算年龄，并包含用户提供的年龄和年份值以及已计算的未来年龄的列。`People`表跟踪用户提供的名字。`Results`表通过引用名字和计算来跟踪结果。'
- en: '**Note**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The data the application works with doesn’t justify three tables, but simple
    data combined with multiple tables allows some common problems to be more easily
    demonstrated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序处理的数据不必要三个表，但简单数据与多个表的结合可以更容易地展示一些常见问题。
- en: Creating a repository layer
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建存储库层
- en: A repository is a layer of code that isolates the database from the rest of
    the application, which makes it easier to change the way that data is read and
    written without needing to change the code that uses that data. Not everyone finds
    a repository layer useful, but my advice is to use one unless you are completely
    certain that your application’s use of data or database products won’t change.
    Create the `src/server/data` folder and add to it a file named `repository.ts`
    with the contents shown in *Listing 12.9*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库是一层代码，将数据库与应用程序的其余部分隔离开来，这使得在不更改使用该数据的代码的情况下更容易更改数据的读取和写入方式。并不是每个人都认为存储库层有用，但我的建议是除非你完全确信你的应用程序对数据或数据库产品的使用不会改变，否则请使用它。创建`src/server/data`文件夹，并向其中添加一个名为`repository.ts`的文件，其内容如*列出12.9*所示。
- en: 'Listing 12.9: The contents of the repository.ts file in the src/server/data
    folder'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列出12.9：`src/server/data`文件夹中repository.ts文件的内容
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Repository` interface defines methods for storing new `Result` objects,
    querying for all results, and results that have a specific name. The `Result`
    type defines properties for all of the data columns in the database tables in
    a simple, flat structure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repository`接口定义了存储新的`Result`对象、查询所有结果以及具有特定名字的结果的方法。`Result`类型定义了数据库表中所有数据列的属性，以简单、平面结构的形式。'
- en: Projects can use data types that match the structure of the database, but that
    often means that the data that arrives from the user has to be assembled into
    a complex structure before being extracted and used to create an SQL statement,
    while the reverse process assembles data from the database into the same structure,
    only for it to be extracted for use in templates. It isn’t always possible, but
    using simple, flat data structures often simplifies development.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以使用与数据库结构匹配的数据类型，但这通常意味着从用户那里到达的数据必须在提取并用于创建SQL语句之前组装成一个复杂结构，而反向过程将数据库中的数据组装成相同的结构，只是为了从模板中提取出来使用。这并不总是可能的，但使用简单的平面数据结构通常可以简化开发。
- en: Implementing the repository
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现存储库
- en: The next step is to implement the `Repository` interface with a class that uses
    the SQLite database engine. I am going to implement the repository in stages,
    which will make it easier to understand the relationship between the data in the
    database and the JavaScript objects in the application. To start the implementation,
    create a file named `sql_repository.ts` file in the `src/server/data` folder with
    the content shown in *Listing 12.10*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现使用SQLite数据库引擎的`Repository`接口的类。我打算分阶段实现存储库，这将有助于理解数据库中的数据与应用程序中的JavaScript对象之间的关系。为了开始实现，在`src/server/data`文件夹中创建一个名为`sql_repository.ts`的文件，其内容如*列出12.10*所示。
- en: 'Listing 12.10: The contents of the sql_repository.ts file in the src/server/data
    folder'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列出12.10：`src/server/data`文件夹中sql_repository.ts文件的内容
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `SqlRepository` class implements the `Repository` interface, and its constructor
    prepares the database. The `sqlite3` module contains the database API and creates
    a new `Database` object, specifying `age.db` as the filename. The `Database` object
    provides methods for using the database and the `exec` method is used to execute
    SQL statements – in this case, to execute the statements in the `age.sql` file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlRepository`类实现了`Repository`接口，其构造函数准备数据库。`sqlite3`模块包含数据库API并创建一个新的`Database`对象，指定`age.db`作为文件名。`Database`对象提供了使用数据库的方法，`exec`方法用于执行SQL语句——在这种情况下，用于执行`age.sql`文件中的语句。'
- en: '**Note**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Real projects don’t need to execute SQL to create the database every time, but
    doing so allows the example to be reset, and it is for this reason that the SQL
    in *Listing 12.8* will drop and recreate the database tables if they already exist.
    Databases are usually initialized only when an application is deployed, and you
    can see an example of this in *Part 3* of this book.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 真实项目不需要每次都执行SQL来创建数据库，但这样做可以让示例重置，这就是为什么*清单12.8*中的SQL将删除并重新创建数据库表的原因。数据库通常仅在应用程序部署时初始化，您可以在本书的*第3部分*中看到一个示例。
- en: To make the repository available to the rest of the application, add a file
    named `index.ts` to the `src/server/data` folder with the content shown in *Listing
    12.11*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使存储库可供应用程序的其余部分使用，在`src/server/data`文件夹中添加一个名为`index.ts`的文件，其内容如*清单12.11*所示。
- en: 'Listing 12.11: The contents of the index.ts file in the src/server/data folder'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12.11：`src/server/data`文件夹中`index.ts`文件的内容
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This file is responsible for instantiating the repository so that the rest of
    the application can access data through the `Repository` interface without needing
    to know which implementation has been used.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件负责实例化存储库，以便应用程序的其余部分可以通过`Repository`接口访问数据，而无需知道使用了哪种实现。
- en: Querying the database
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询数据库
- en: The next step is to implement the methods that provide access to the database,
    starting with those that query for data. Add a file named `sql_queries.ts` to
    the `src/server/data` folder, with the content shown in *Listing 12.12*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现提供数据库访问的方法，从查询数据的方法开始。在`src/server/data`文件夹中添加一个名为`sql_queries.ts`的文件，其内容如*清单12.12*所示。
- en: 'Listing 12.12: The contents of the sql_queries.ts file in the src/server/data
    folder'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12.12：`src/server/data`文件夹中`sql_queries.ts`文件的内容
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'SQL queries can be formulated like any other JavaScript string, and my preference
    is to avoid duplication by defining a base query and then building on it to create
    the variations needed. In this case, I have defined `baseSql` and `endSql` strings,
    which are combined to create queries, so that the query for data matching a name
    will be as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: SQL查询可以像任何其他JavaScript字符串一样编写，我的偏好是避免重复，通过定义基本查询然后在此基础上构建所需的变化来创建查询。在这种情况下，我定义了`baseSql`和`endSql`字符串，它们被组合起来创建查询，因此匹配名称的数据查询如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These queries use named parameters, which are denoted by a `$` sign and allow
    values to be provided when the query is executed. As I explain in the *Understanding
    SQL query parameters* section, this is a feature that should always be used and
    is supported by every database package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询使用命名参数，由一个`$`符号表示，允许在执行查询时提供值。正如我在*理解SQL查询参数*部分所解释的，这是一个应该始终使用且每个数据库包都支持的功能。
- en: 'I am not a professional database administrator, and there are more efficient
    ways to compose queries, but using a database is easier when the queries return
    data that can be easily parsed to create JavaScript objects. In this case, the
    queries will return tables of data like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是专业的数据库管理员，有更有效的方法来编写查询，但使用数据库在查询返回的数据可以轻松解析为JavaScript对象时更为简单。在这种情况下，查询将返回类似以下的数据表：
- en: '| `id` | `calculationId` | `personId` | `name` | `age` | `years` | `nextage`
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `calculationId` | `personId` | `name` | `age` | `years` | `nextage`
    |'
- en: '| `1` | `1` | `1` | `Alice` | `35` | `5` | `40` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `Alice` | `35` | `5` | `40` |'
- en: '| `3` | `2` | `1` | `Alice` | `35` | `10` | `45` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `2` | `1` | `Alice` | `35` | `10` | `45` |'
- en: 'The SQLite package will convert the table of data into an array of JavaScript
    objects whose properties correspond to the table column names, like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite包将数据表转换为JavaScript对象的数组，其属性对应于表列名，如下所示：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The structure of the data received from the database is a superset of the `Result`
    interface defined in *Listing 12.9*, which means that data received from the database
    can be used without needing further processing. *Listing 12.13* uses the SQL defined
    in *Listing 12.12* to query the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库接收到的数据结构是 *列表 12.9* 中定义的 `Result` 接口的超集，这意味着从数据库接收到的数据可以不经过进一步处理而使用。*列表
    12.13* 使用 *列表 12.12* 中定义的 SQL 查询数据库。
- en: 'Listing 12.13: Querying the database in the sql_repository.ts file in the src/server/data
    folder'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.13：在 src/server/data 文件夹中的 sql_repository.ts 文件中查询数据库
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Database` object created in the constructor provides methods for querying
    the database. The `executeQuery` method uses the `Database.all` method, which
    executes a SQL query and returns all the rows that the database produces. For
    quick reference, *Table 12.3* describes the most useful methods provided by the
    `Database` class. Most of these methods accept values for query parameters, which
    I explain in the *Understanding SQL query parameters* section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中创建的 `Database` 对象提供了查询数据库的方法。`executeQuery` 方法使用 `Database.all` 方法，该方法执行
    SQL 查询并返回数据库产生的所有行。为了快速参考，*表 12.3* 描述了 `Database` 类提供的最有用的方法。大多数这些方法接受查询参数的值，我在
    *理解 SQL 查询参数* 部分中解释了这些。
- en: 'Table 12.3: Useful Database Methods'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.3：有用的数据库方法
- en: '| Name | Description |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| This method executes a SQL statement with an optional set of parameters.
    No result data is returned. The optional callback function is invoked if there
    is an error or when execution is complete. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 此方法执行一个带有可选参数集的 SQL 语句。不返回结果数据。如果发生错误或执行完成时，将调用可选的回调函数。|'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| This method executes a SQL statement with an optional set of parameters and
    passes the first result row as an object to the callback function, with type `T`.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 此方法执行一个带有可选参数集的 SQL 语句，并将第一个结果行作为类型为 `T` 的对象传递给回调函数。|'
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| This method executes a SQL statement with an optional set of parameters and
    passes all result rows to the callback function as an array of type `T`. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 此方法执行一个带有可选参数集的 SQL 语句，并将所有结果行作为类型为 `T` 的数组传递给回调函数。|'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This method creates a prepared statement, which is represented with a `Statement`
    object, and can improve performance because the database doesn’t have to process
    SQL every time the query is executed. This method does not accept query parameters.
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 此方法创建一个预处理语句，用 `Statement` 对象表示，可以提高性能，因为数据库不需要在每次查询执行时处理 SQL。此方法不接受查询参数。|'
- en: Displaying data
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示数据
- en: '*Listing 12.14* updates the code that handles HTTP requests to create an instance
    of the SQL repository and uses the methods it provides to query the database and
    pass the results to the template.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12.14* 更新了处理 HTTP 请求的代码，以创建 SQL 存储库的实例，并使用它提供的方法查询数据库并将结果传递给模板。'
- en: 'Listing 12.14: Using the repository in the forms.ts file in the src/server
    folder'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.14：在 src/server 文件夹中的 forms.ts 文件中使用存储库
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `async` keyword is applied to the handler functions, which allows the use
    of the `await` keyword when calling the repository methods. The results are passed
    to the template using a property named `history`, which is used to populate the
    table in *Listing 12.15*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `async` 关键字应用于处理函数，这允许在调用存储库方法时使用 `await` 关键字。结果通过名为 `history` 的属性传递给模板，该属性用于填充
    *列表 12.15* 中的表格。
- en: 'Listing 12.15: Populating the table in the history.handlebars file in the templates/server/partials
    folder'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.15：在模板/服务器/部分文件夹中的 history.handlebars 文件中填充表格
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Use a browser to request `http://localhost:5000/form` and you will see that
    the right-hand side shows data from all users. Fill out and submit the form and
    only queries from that user will be displayed, as shown in *Figure 12.2*. The
    queries in the database from other users are no longer shown.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器请求 `http://localhost:5000/form`，你会看到右侧显示了所有用户的数据。填写并提交表单后，只会显示该用户的查询，如图
    *图 12.2* 所示。其他用户的数据库中的查询不再显示。
- en: '![](img/B21959_12_02.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_12_02.png)'
- en: 'Figure 12.2: Querying the database'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：查询数据库
- en: Understanding SQL query parameters
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 SQL 查询参数
- en: Care must be taken when including values received from users in SQL queries.
    As a demonstration, *Listing 12.16* alters the implementation of the `getResultsByName`
    defined by the `SQLRepository` class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 查询中包含从用户接收到的值时必须小心。作为一个示例，*列表 12.16* 修改了由 `SQLRepository` 类定义的 `getResultsByName`
    的实现。
- en: 'Listing 12.16: Including user input in the sql_repository.ts file in the src/server/data
    folder'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12.16：在src/server/data文件夹中的sql_repository.ts文件中包含用户输入
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The mistake being made in this example is to include the value received from
    the form directly in the query. If the user enters `Alice` into the form, then
    the query will look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中犯的错误是将从表单接收到的值直接包含在查询中。如果用户在表单中输入`Alice`，那么查询将看起来像这样：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the anticipated behavior, and it retrieves the queries made using that
    name. But it is easy to craft strings that alter the query. If the user enters
    `Alice" or name = "Bob`, for example, then the query will look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的行为，并且它检索使用该名称进行的查询。但是，很容易构建更改查询的字符串。例如，如果用户输入`Alice`或`name = "Bob"`，那么查询将看起来像这样：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This isn’t what the developer expects, and it means that queries made by two
    users are displayed, as shown in *Figure 12.3*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是开发者预期的结果，这意味着两个用户的查询将显示，如图12.3所示。
- en: '![](img/B21959_12_03.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_12_03.png)'
- en: 'Figure 12.3: Executing a query with user input'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：执行包含用户输入的查询
- en: This is a benign example, but it shows that including user-supplied values directly
    in queries allows malicious users to change how queries are processed. This problem
    isn’t addressed by the HTML sanitization described in *Chapter 11* because the
    values are not sanitized until they are included in a response. Instead, databases
    provide support for *query parameters*, which allow values to be inserted into
    queries safely.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个良性示例，但它表明直接在查询中包含用户提供的值允许恶意用户更改查询的处理方式。这个问题并没有通过第11章中描述的HTML清理来解决，因为值是在它们包含在响应中之前才被清理的。相反，数据库提供了对*查询参数*的支持，这允许安全地将值插入到查询中。
- en: 'The parameter is defined in the SQL query and is denoted with an initial `$`
    character, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 参数在SQL查询中定义，并用初始的`$`字符表示，如下所示：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This statement is combined with the base query, which means that the overall
    SQL statement looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句与基本查询相结合，这意味着整个SQL语句看起来像这样：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The two query parameters are marked in bold, and they indicate values that
    will be supplied when the statement is executed by the `executeQuery` method in
    the `SqlRepository` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 两个查询参数被加粗，并且它们指示在`SqlRepository`类的`executeQuery`方法执行语句时将提供的值：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 12.17* reverts the changes to the `SqlRepository` class so that the
    query performed by the `getResultsByName` method uses the `executeQuery` method
    and provides query parameters.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12.17*将`SqlRepository`类的更改恢复，以便`getResultsByName`方法执行的查询使用`executeQuery`方法并提供查询参数。'
- en: 'Listing 12.17: Using query parameters in the sql_repository.ts file in the
    src/server/data folder'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12.17：在src/server/data文件夹中的sql_repository.ts文件中使用查询参数
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The object that contains the parameter values has property names that match
    the parameters in the SQL statement: `$name` and `$limit`. The `$` sign isn’t
    the only way to denote a query parameter in SQL, but it works well with JavaScript
    because the `$` sign is allowed in variable names. It is for this reason that
    the `getResultsByName` method defines `$name` and `$limit` parameters, allowing
    the values to be passed along without needing to alter the names.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 包含参数值的对象具有与SQL语句中的参数匹配的属性名称：`$name`和`$limit`。`$`符号不是在SQL中表示查询参数的唯一方式，但它与JavaScript配合得很好，因为`$`符号允许在变量名称中使用。这就是为什么`getResultsByName`方法定义了`$name`和`$limit`参数，允许值传递而不需要更改名称。
- en: 'The last piece of the puzzle is provided by the code that handles the form
    data:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是由处理表单数据的代码提供的：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The value the user entered for the name field in the form is read from the body
    and used as the value for the `$name` query parameter. The methods described in
    *Table 12.3* automatically sanitize query parameters, so they do not alter the
    way the query is executed, as shown in *Figure 12.4*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在表单中输入的名称字段的值从主体中读取，并用作`$name`查询参数的值。*表12.3*中描述的方法会自动清理查询参数，因此它们不会改变查询的执行方式，如图12.4所示。
- en: '![](img/B21959_12_04.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_12_04.png)'
- en: 'Figure 12.4: The effect of a sanitized query parameter'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：清理后的查询参数的效果
- en: Writing to the database
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入数据库
- en: The next step is to write data so that the database contains more than just
    the seed data added when the database is created. *Listing 12.18* defines SQL
    statements that will insert rows into the database tables.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是写入数据，以便数据库包含在创建数据库时添加的种子数据之外的数据。*清单12.18*定义了将行插入数据库表的SQL语句。
- en: 'Listing 12.18: Adding statements in the sql_queries.ts file in the src/server/data
    folder'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.18：src/server/data 文件夹中 sql_queries.ts 文件添加语句
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `insertPerson` and `insertCalculation` statements will insert new rows in
    the `People` and `Calculation` tables only if there are no existing rows that
    have the same details. The `insertResult` statement creates a row in the `Results`
    table, with references to the other tables.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertPerson` 和 `insertCalculation` 语句只有在 `People` 和 `Calculation` 表中没有具有相同详细信息的现有行时，才会向这些表中插入新行。`insertResult`
    语句在 `Results` 表中创建一行，并引用其他表。'
- en: These statements need to be executed within a transaction to ensure consistency.
    The SQLite database engine supports transactions, but these are not exposed conveniently
    to Node.js and additional work is required to run SQL statements in a transaction.
    Add a file named `sql_helpers.ts` to the `src/server/data` folder with the content
    shown in *Listing 12.19*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句需要在事务中执行以确保一致性。SQLite 数据库引擎支持事务，但这些事务并没有方便地暴露给 Node.js，因此需要额外的工作来在事务中运行
    SQL 语句。将名为 `sql_helpers.ts` 的文件添加到 `src/server/data` 文件夹中，其内容如 *列表 12.19* 所示。
- en: 'Listing 12.19: The contents of the sql_helpers.ts file in the src/server/data
    folder'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.19：src/server/data 文件夹中 sql_helpers.ts 文件的内容
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `TransactionHelper` class defines an `add` method that is used to build
    up a list of SQL statements and query parameters. When the `run` method is called,
    the `BEGIN` command is sent to SQLite, and each of the SQL statements is run.
    If all the statements execute successfully, the `COMMIT` command is sent, and
    SQLite applies the changes to the database. The `ROLLBACK` command is sent if
    any of the statements fail and SQLite abandons the changes made by earlier statements.
    SQLite provides the ID of the row modified by `INSERT` statements, and the `run`
    method returns the value produced by the most recent statement. Knowing the ID
    of the most recently inserted row is generally a good idea because it makes it
    easy to query for new data, as *Chapter 14* will demonstrate.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransactionHelper` 类定义了一个 `add` 方法，用于构建 SQL 语句和查询参数的列表。当调用 `run` 方法时，向 SQLite
    发送 `BEGIN` 命令，并运行每个 SQL 语句。如果所有语句都成功执行，则发送 `COMMIT` 命令，SQLite 将更改应用到数据库中。如果任何语句失败，则发送
    `ROLLBACK` 命令，SQLite 放弃之前语句所做的更改。SQLite 提供由 `INSERT` 语句修改的行的 ID，`run` 方法返回最新语句产生的值。知道最近插入行的
    ID 通常是一个好主意，因为它使得查询新数据变得容易，正如 *第 14 章* 将展示的那样。'
- en: '*Listing 12.20* uses the `TransactionHelper` class to perform an update by
    running the three statements from *Listing 12.18* within a SQL transaction.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12.20* 使用 `TransactionHelper` 类通过在 SQL 事务中运行 *列表 12.18* 中的三个语句来执行更新。'
- en: 'Listing 12.20: Inserting data in the sql_repository.ts file in the src/server/data
    folder'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.20：src/server/data 文件夹中 sql_repository.ts 文件插入数据
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The implementation of the `saveResult` method executes the three SQL statements.
    Each statement requires a separate object for its query parameters because SQLite
    produces an error if there are unused properties in the parameters object. *Listing
    12.21* updates the handler for HTTP POST requests to write data to the database
    through the repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveResult` 方法的实现执行了三个 SQL 语句。每个语句都需要一个单独的对象来存储其查询参数，因为 SQLite 如果参数对象中有未使用的属性会报错。*列表
    12.21* 更新了处理 HTTP POST 请求以通过存储库写入数据库的处理程序。'
- en: 'Listing 12.21: Writing data in the forms.ts file in the src/server folder'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.21：src/server 文件夹中 forms.ts 文件写入数据
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using consistent names for each part of the application means that the request
    body can be used as the basis for the `Result` interface expected by the repository.
    The effect is that each new request is stored in the database and reflected in
    the response presented to the user, as shown in *Figure 12.5*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序的每个部分使用一致的名称意味着请求体可以用作符合存储库期望的 `Result` 接口的基础。结果是，每个新的请求都存储在数据库中，并反映在向用户展示的响应中，如图
    *图 12.5* 所示。
- en: '![](img/B21959_12_05.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_12_05.png)'
- en: 'Figure 12.5: Writing data to the database'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：向数据库写入数据
- en: Using an ORM package
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ORM 包
- en: The advantage of working directly with the database is that you have control
    over how every statement is written and executed. The drawback is that can be
    a complex and time-consuming process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 直接与数据库工作的优点是你可以控制每个语句的编写和执行方式。缺点是这可能是一个复杂且耗时的过程。
- en: An alternative is to use an ORM package that deals with the database on behalf
    of the developer, hiding some aspects of SQL and taking care of mapping between
    the database and JavaScript objects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用代表开发者处理数据库的ORM包，隐藏一些SQL方面，并负责数据库与JavaScript对象之间的映射。
- en: The range of features provided by ORM packages varies widely. Some take a light-touch
    approach and focus on transforming data, but most packages deal with most aspects
    of using a database, including defining the SQL schema, creating the database,
    and even generating queries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ORM包提供的功能范围差异很大。有些采用轻量级方法，专注于转换数据，但大多数包处理数据库使用的各个方面，包括定义SQL模式、创建数据库，甚至生成查询。
- en: ORM packages can be great, but you still have to have a basic understanding
    of SQL, which is why I started this chapter with a direct-to-database example.
    ORM packages expect the developer to understand how their features will be used
    to create and use databases, and you won’t be able to get useful results or diagnose
    problems without some SQL skills.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ORM包可能很好，但你仍然需要具备基本的SQL理解，这就是为什么我以直接到数据库的示例开始本章。ORM包期望开发者理解如何使用其功能来创建和使用数据库，没有一些SQL技能，你将无法获得有用的结果或诊断问题。
- en: '**The Argument for Object Databases**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象数据库的论点**'
- en: An alternative to using SQL and an ORM package is to use a database that stores
    objects directly, such as MongoDB ([https://www.mongodb.com](https://www.mongodb.com)).
    The reason that I have not covered object databases in this book is that most
    projects use relational databases, and most companies standardize on a specific
    relational database engine. Object databases can be a good choice, but they are
    not the technology that most developers end up using. SQL databases remain dominant,
    even though there are some excellent alternatives available.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQL和ORM包的替代方案是使用直接存储对象的数据库，例如MongoDB ([https://www.mongodb.com](https://www.mongodb.com))。我没有在这本书中涵盖对象数据库的原因是，大多数项目使用关系数据库，而大多数公司对特定的关系数据库引擎进行标准化。对象数据库可能是一个不错的选择，但它们并不是大多数开发者最终使用的技术。尽管有一些出色的替代方案可用，但SQL数据库仍然占据主导地位。
- en: The ORM package that I use in this chapter is called Sequelize ([https://www.npmjs.com/package/sequelize](https://www.npmjs.com/package/sequelize)),
    which is the most popular JavaScript ORM package. Sequelize has a comprehensive
    set of features and supports the most popular database engines, including SQLite.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中使用的ORM包名为Sequelize ([https://www.npmjs.com/package/sequelize](https://www.npmjs.com/package/sequelize))，这是最受欢迎的JavaScript
    ORM包。Sequelize具有一套全面的功能，并支持包括SQLite在内的最流行的数据库引擎。
- en: Run the command shown in *Listing 12.22* in the `part2app` folder to install
    the Sequelize package, which includes TypeScript type information.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`part2app`文件夹中运行*清单12.22*中显示的命令以安装Sequelize包，该包包括TypeScript类型信息。
- en: 'Listing 12.22: Installing the ORM packages'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12.22：安装ORM包
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Defining the database using JavaScript objects
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript对象定义数据库
- en: When working directly with a database, the first step is to write the SQL statements
    that create the tables and the relationships between them, which is how this chapter
    started. When using an ORM, the database is described using JavaScript objects.
    Each ORM package has its own process and, for Sequelize, three steps are required.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当直接与数据库交互时，第一步是编写创建表及其之间关系的SQL语句，这也是本章开始的方式。当使用ORM时，数据库使用JavaScript对象进行描述。每个ORM包都有自己的流程，对于Sequelize来说，需要三个步骤。
- en: Creating the model classes
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模型类
- en: The first step is to define the classes that will represent the data in the
    database. Add a file named `orm_models.ts` to the `src/server/data` folder, with
    the content shown in *Listing 12.23*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义将代表数据库中数据的类。在`src/server/data`文件夹中添加一个名为`orm_models.ts`的文件，其内容如*清单12.23*所示。
- en: 'Listing 12.23: The contents of the orm_models.ts file in the src/server/data
    folder'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12.23：`src/server/data`文件夹中`orm_models.ts`文件的内容
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Sequelize will use each class to create a database table and each property will
    be a column in that table. These classes also describe the data in the database
    to the TypeScript compiler.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize将使用每个类创建一个数据库表，每个属性都将成为该表中的一列。这些类还向TypeScript编译器描述数据库中的数据。
- en: All the class properties in *Listing 12.23* are defined with the `declare` keyword,
    which tells the TypeScript compiler to behave as though the properties have been
    defined but not to include those properties in the compiled JavaScript. This is
    important because Sequelize will add getters and setters to objects to provide
    access to data, and defining properties conventionally will prevent that feature
    from working properly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12.23* 中的所有类属性都使用 `declare` 关键字定义，这告诉 TypeScript 编译器表现得好像属性已经被定义，但不要将这些属性包含在编译后的
    JavaScript 中。这很重要，因为 Sequelize 将向对象添加获取器和设置器以提供对数据的访问，而按常规定义属性将防止该功能正常工作。'
- en: '**Note**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The names of the model classes should be meaningful. I have chosen `Person`
    and `Calculation`, which are obvious enough, but I have used `ResultModel` to
    avoid conflicting with the name of the type used by the `Repository` interface.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类的名称应该是具有意义的。我选择了 `Person` 和 `Calculation`，它们足够明显，但我使用了 `ResultModel` 以避免与
    `Repository` 接口使用的类型名称冲突。
- en: 'Class properties whose type is a regular JavaScript type will be represented
    by regular columns in the database, such as the `name` property defined by the
    `Person` class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为常规 JavaScript 类型的类属性将在数据库中以常规列的形式表示，例如 `Person` 类定义的 `name` 属性：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `CreationOptional<T>` type is used to describe a property that doesn’t
    have to be supplied when a new instance of the model class is created, like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreationOptional<T>` 类型用于描述在创建模型类的新实例时不必提供的属性，如下所示：'
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `id` property represents the primary key for a `Person` object when it is
    stored as a row in a database table. The database will be configured to automatically
    assign a key when a new row is stored, and so using the `CreationOptional<number>`
    type will prevent TypeScript from reporting an error when a `Person` object is
    created without an `id` value.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 属性代表当 `Person` 对象作为数据库表中的一行存储时的主键。数据库将被配置为在存储新行时自动分配键，因此使用 `CreationOptional<number>`
    类型将防止 TypeScript 在创建没有 `id` 值的 `Person` 对象时报告错误。'
- en: 'The base class is used to build a list of the properties defined by the class,
    which are used to enforce type safety when data is read or written:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 基类用于构建由类定义的属性列表，这些属性用于在读取或写入数据时强制类型安全：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `InferAttributes<Person>` type selects all of the properties defined by
    the `Person` class, while the `InferCreationAttributes<Person>` type excludes
    the properties whose type is `CreationOptional<T>`. The model classes also contain
    properties for representing relationships between tables in the database:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`InferAttributes<Person>` 类型选择 `Person` 类定义的所有属性，而 `InferCreationAttributes<Person>`
    类型排除了类型为 `CreationOptional<T>` 的属性。模型类还包含表示数据库表中关系属性：'
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `personId` and `calculationId` properties will store the primary keys of
    related data, while the `Person` and `Calculation` properties will be populated
    with objects created by Sequelize, as part of the process of making data available
    as objects.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`personId` 和 `calculationId` 属性将存储相关数据的主键，而 `Person` 和 `Calculation` 属性将填充由
    Sequelize 创建的对象，作为将数据作为对象提供的过程的一部分。'
- en: Initializing the data model
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化数据模型
- en: The next step is to tell Sequelize how each property defined by the model classes
    should be represented in the database. Add a file named `orm_helpers.ts` to the
    `src/server/data` folder, with the content shown in *Listing 12.24*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是告诉 Sequelize 如何在数据库中表示模型类定义的每个属性。将名为 `orm_helpers.ts` 的文件添加到 `src/server/data`
    文件夹中，内容如 *清单 12.24* 所示。
- en: 'Listing 12.24: The contents of the orm_helpers.ts file in the src/server/data
    folder'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12.24：src/server/data 文件夹中 orm_helpers.ts 文件的内容
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Model` base class used in *Listing 12.24* defines the `init` method, which
    accepts an object whose properties correspond to those defined by the class. Each
    property is assigned a configuration object that tells Sequelize how to represent
    the data in the database.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12.24* 中使用的 `Model` 基类定义了 `init` 方法，该方法接受一个对象，其属性对应于类中定义的属性。每个属性都被分配一个配置对象，该对象告诉
    Sequelize 如何在数据库中表示数据。'
- en: All three model classes have an `id` property that is configured as the primary
    key. For the other properties, a value from the `DataTypes` class is selected
    to specify the SQL data type that will be used when the database is created.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个模型类都有一个 `id` 属性，该属性被配置为主键。对于其他属性，从 `DataTypes` 类中选择一个值来指定在创建数据库时将使用的 SQL
    数据类型。
- en: The second argument accepted by the `init` method is used to configure the overall
    data model. Only the `sequelize` property is specified in *Listing 12.24*, which
    is a `Sequelize` object that will be created to manage the database. Other options
    are available, allowing the name of the database table to be changed, setting
    up database triggers, and configuring other database features.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`方法接受的第二个参数用于配置整体数据模型。*列表12.24*中只指定了`sequelize`属性，这是一个将用于管理数据库的`Sequelize`对象。其他选项允许更改数据库表名，设置数据库触发器，以及配置其他数据库功能。'
- en: Configuring the model relationships
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置模型关系
- en: The `Model` base class provides methods to describe the relationships between
    model classes, as shown in *Listing 12.25*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Model`基类提供方法来描述模型类之间的关系，如*列表12.25*所示。'
- en: 'Listing 12.25: Defining model relationships in the orm_helpers.ts file in the
    src/server/data folder'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.25：在src/server/data文件夹中的orm_helpers.ts文件中定义模型关系
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Sequelize defines four kinds of *association*, which are used to describe the
    relationship between data model classes, as described in *Table 12.4*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize定义了四种类型的*关联*，用于描述数据模型类之间的关系，如*表12.4*中所述。
- en: 'Table 12.4: The Sequelize association methods'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.4：Sequelize关联方法
- en: '| Name | Description |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| This method denotes a one-to-one relationship between the model class and
    `T`, with the foreign key defined on `T`. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 此方法表示模型类与`T`之间的一对一关系，外键在`T`上定义。|'
- en: '|'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '| This method denotes a one-to-one relationship between the model class and
    `T`, with the foreign key defined by the model class. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 此方法表示模型类与`T`之间的一对一关系，外键由模型类定义。|'
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| This method denotes a one-to-many relationship, with the foreign key defined
    by `T`. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 此方法表示一对多关系，外键由`T`定义。|'
- en: '|'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '| This method denotes a many-to-many relationship using a junction table. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 此方法表示使用连接表的多对多关系。|'
- en: Each of the methods defined in *Table 12.4* accepts an options argument that
    is used to configure the relationship. In *Listing 12.25*, the `foreignKey` property
    is used to specify the foreign key on the `ResultModel` class for the one-to-one
    relationships with the `Person` and `Calculation` types. (There are other options,
    described at [https://sequelize.org/api/v6/identifiers.html#associations](https://sequelize.org/api/v6/identifiers.html#associations),
    and you can see a more complex example in *Chapter 15*, which uses a many-to-many
    relationship.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*表12.4*中定义的每个方法都接受一个选项参数，用于配置关系。在*列表12.25*中，使用`foreignKey`属性指定`ResultModel`类与`Person`和`Calculation`类型的一对一关系的外键。（还有其他选项，请参阅[https://sequelize.org/api/v6/identifiers.html#associations](https://sequelize.org/api/v6/identifiers.html#associations)，您可以在*第15章*中看到一个更复杂的示例，该示例使用多对多关系。）'
- en: Defining the seed data
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义种子数据
- en: Although ORM packages take care of a lot of the details, there can be tasks
    that are more easily performed simply by executing SQL expressions directly, rather
    than using JavaScript objects. To demonstrate, *Listing 12.26* uses SQL to seed
    the database. (Later chapters show seeding databases using JavaScript objects
    so you can compare techniques.)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ORM包处理了很多细节，但有些任务可能通过直接执行SQL表达式而不是使用JavaScript对象更容易完成。为了演示，*列表12.26*使用SQL来初始化数据库。（后面的章节将展示使用JavaScript对象初始化数据库，以便您可以比较技术。）
- en: 'Listing 12.26: Adding seed data in the orm_helpers.ts file in the src/server/data
    folder'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.26：在src/server/data文件夹中的orm_helpers.ts文件中添加种子数据
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Sequelize.query` method accepts a string containing an SQL statement. The
    statements in *Listing 12.26* create the same seed data used earlier in the chapter
    but with the addition of values for `createdAt` and `updatedAt` columns. One consequence
    of using an ORM package to create a database is that additional features and constraints
    are often introduced and Sequelize adds these columns to keep track of when table
    rows are created and modified. The queries that create the seed data use the `date()`
    function, which returns the current date and time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sequelize.query`方法接受一个包含SQL语句的字符串。*列表12.26*中的语句创建了本章前面使用的相同种子数据，但增加了`createdAt`和`updatedAt`列的值。使用ORM包创建数据库的一个后果是通常会引入额外的功能和约束，Sequelize添加这些列以跟踪表行何时创建和修改。创建种子数据的查询使用`date()`函数，该函数返回当前日期和时间。'
- en: Converting data models to flat objects
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据模型转换为扁平对象
- en: Using JavaScript objects to represent data can be a more natural development
    experience, but it can mean that the data model objects are not in the format
    expected elsewhere in the application. In the case of the example application,
    the ORM data model objects do not conform to the requirements of the `Result`
    type used by the `Repository` interface. One approach would be to modify the interface,
    but this would undermine the benefit of isolating the database from the rest of
    the application. *Listing 12.27* defines a function that transforms `ResultModel`
    objects provided by the ORM package into `Result` objects required by the `Repository`
    interface.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript对象来表示数据可能是一种更自然的发展体验，但这可能意味着数据模型对象不符合应用程序其他部分的预期格式。在示例应用程序的情况下，ORM数据模型对象不符合`Repository`接口使用的`Result`类型的规范。一种方法可能是修改接口，但这会损害将数据库从应用程序其余部分隔离出来的好处。*列表12.27*定义了一个函数，该函数将ORM包提供的`ResultModel`对象转换为`Repository`接口所需的`Result`对象。
- en: 'Listing 12.27: Transforming data in the orm_helpers.ts file in the src/server/data
    folder'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.27：src/server/data文件夹中orm_helpers.ts文件中的数据转换
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This kind of transformation can seem clunky, but JavaScript makes it easy to
    compose new objects in this way, and it is a useful technique that eases integration
    between modules and packages, which is something that most JavaScript projects
    have to deal with.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换可能看起来有些笨拙，但JavaScript使得以这种方式组合新对象变得容易，这是一种有用的技术，它简化了模块和包之间的集成，这是大多数JavaScript项目必须处理的问题。
- en: Implementing the repository
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现存储库
- en: The plumbing is all in place and it is time to implement the `Repository` interface.
    Add a file named `orm_repository.ts` to the `src/server/data` folder with the
    content shown in *Listing 12.28*, which sets up the ORM but doesn’t yet implement
    queries or store data.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的管道都已经就绪，现在是时候实现`Repository`接口了。向`src/server/data`文件夹添加一个名为`orm_repository.ts`的文件，其内容如*列表12.28*所示，该文件设置了ORM，但尚未实现查询或存储数据。
- en: 'Listing 12.28: The contents of the orm_repository.ts file in the src/server/data
    folder'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.28：src/server/data文件夹中orm_repository.ts文件的内容
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Sequelize supports a range of database engines, including SQLite, and so the
    first step is to create a `Sequelize` object, providing a configuration object
    that specifies the database engine, and the options for its use. In *Listing 12.28*,
    the `dialect` option specifies SQLite and the `storage` option specifies the name
    of the file. When using an ORM, it can be useful to see the SQL queries that are
    generated, which is why the `logging` and `logQueryParameters` options are set.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize支持一系列数据库引擎，包括SQLite，因此第一步是创建一个`Sequelize`对象，提供一个配置对象，指定数据库引擎及其使用选项。在*列表12.28*中，`dialect`选项指定SQLite，而`storage`选项指定文件名。在使用ORM时，查看生成的SQL查询可能很有用，这就是为什么设置了`logging`和`logQueryParameters`选项。
- en: 'Once a `Sequelize` object has been created, it can be configured. The `initModelAndDatabase`
    method calls the `initializeModels` and `defineRelationships` functions to configure
    the data model objects, and then calls these methods:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了`Sequelize`对象，就可以对其进行配置。`initModelAndDatabase`方法调用`initializeModels`和`defineRelationships`函数来配置数据模型对象，然后调用以下方法：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `drop` method tells Sequelize to drop the tables in the database. This isn’t
    something that should be done in a real project, but it recreates the earlier
    examples in this chapter. The `sync` method tells Sequelize to synchronize the
    database with the data model objects, which has the effect of creating tables
    for the `ResultModel`, `Person`, and `Calculation` data. Once the tables have
    been created, the `addSeedData` function is called to add the initial data to
    the database. Some of these operations are asynchronous, which is why they are
    performed with the `await` keyword inside an `async` method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop`方法告诉Sequelize删除数据库中的表。这并不是应该在真实项目中执行的操作，但它重新创建了本章早期示例。`sync`方法告诉Sequelize将数据库与数据模型对象同步，这会产生为`ResultModel`、`Person`和`Calculation`数据创建表的效果。一旦创建了表，就会调用`addSeedData`函数向数据库添加初始数据。一些操作是异步的，这就是为什么它们在`async`方法内部使用`await`关键字执行的原因。'
- en: Querying for data
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询数据
- en: Queries in an ORM are made using an API that returns objects, without any direct
    interaction with the SQL that is sent to the database. ORM packages have different
    philosophies about how queries are expressed. With Sequelize, queries are performed
    using the data model classes, with methods that are inherited from the `Model`
    base class, the most useful of which are described in *Table 12.5*. (The full
    set of **Model** features can be found at [https://sequelize.org/api/v6/class/src/model.js~model](https://sequelize.org/api/v6/class/src/model.js~model).)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 中，使用返回对象的 API 进行查询，而不直接与发送到数据库的 SQL 进行交互。ORM 包含不同的关于如何表达查询的哲学。在 Sequelize
    中，查询是通过继承自 `Model` 基类的方法和数据模型类来执行的，其中最有用的方法在 *表 12.5* 中进行了描述。（完整的 **Model** 功能可以在
    [https://sequelize.org/api/v6/class/src/model.js~model](https://sequelize.org/api/v6/class/src/model.js~model)
    找到。）|
- en: 'Table 12.5: Useful Model methods'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.5：有用的模型方法
- en: '| Name | Description |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '| This method finds all matching records and presents them as model objects.
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 此方法查找所有匹配的记录并将它们作为模型对象展示。|'
- en: '|'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '| This method finds the first matching record and presents it as a model object.
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 此方法查找第一个匹配的记录并将其作为模型对象展示。|'
- en: '|'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '| This method finds the record with a specified primary key. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 此方法查找具有指定主键的记录。|'
- en: '|'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE53]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '| This method finds a matching record or creates one if there is no match.
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 此方法查找匹配的记录或在没有匹配项时创建一个。|'
- en: '|'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE54]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '| This method creates a new record. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 此方法创建一个新的记录。|'
- en: '|'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '| This method updates data in the database. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 此方法更新数据库中的数据。|'
- en: '|'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '| This method updates a single row of data or creates a row if there is no
    match. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 此方法更新单行数据或在没有匹配项时创建行。|'
- en: The methods in *Table 12.5* are configured with a configuration object that
    changes the way the query or update is executed. The most useful configuration
    properties are described in *Table 12.6*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 12.5* 中的方法通过一个配置对象进行配置，该对象改变了查询或更新的执行方式。最有用的配置属性在 *表 12.6* 中进行了描述。'
- en: 'Table 12.6: Useful query configuration properties'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.6：有用的查询配置属性
- en: '| Name | Description |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '|'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE57]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '| This property loads data from related tables by following foreign keys. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 此属性通过跟踪外键从相关表中加载数据。|'
- en: '|'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '| This property is used to narrow a query, which is passed to the database
    using the SQL `WHERE` keyword. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 此属性用于缩小查询，该查询通过 SQL 的 `WHERE` 关键字传递给数据库。|'
- en: '|'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE59]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '| This property configures the query order, which is passed to the database
    using the SQL `ORDER BY` keywords. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 此属性配置查询顺序，该顺序通过 SQL 的 `ORDER BY` 关键字传递给数据库。|'
- en: '|'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '| This property specifies query grouping, which is passed to the database using
    the SQL `GROUP BY` keywords. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 此属性指定查询分组，该分组通过 SQL 的 `GROUP BY` 关键字传递给数据库。|'
- en: '|'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '| This property specifies the number of records required, which is passed to
    the database using the SQL `LIMIT` keyword. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 此属性指定所需的记录数，该数通过 SQL 的 `LIMIT` 关键字传递给数据库。|'
- en: '|'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE62]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '| This property performs the query within the specified transaction, as demonstrated
    in the *Writing data* section. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 此属性在指定的事务内执行查询，如 *写入数据* 部分所示。|'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE63]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '| This property restricts results, so they include only the specified attributes/columns.
    |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 此属性限制了结果，以便它们只包含指定的属性/列。|'
- en: '*Listing 12.29* shows a basic Sequelize query that implements the `getAllResults`
    method.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12.29* 展示了一个基本的 Sequelize 查询，该查询实现了 `getAllResults` 方法。'
- en: 'Listing 12.29: Performing a Query in the orm_repository.ts File in the src/server/data
    Folder'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.29：在 src/server/data 文件夹中的 orm_repository.ts 文件中执行查询
- en: '[PRE64]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `findAll` method is called on the `ResultModel` class and is configured
    with an object that has `include`, `limit`, and `order` properties. The most important
    property is `include`, which tells Sequelize to follow foreign key relationships
    to load related data and create objects from the results. In this case, the result
    will be a `ResultModel` object whose `Person` and `Calculation` properties are
    populated. The `limit` property restricts the number of results, and the `order`
    property is used to specify how results are ordered.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ResultModel` 类上调用 `findAll` 方法，并配置了一个具有 `include`、`limit` 和 `order` 属性的对象。最重要的属性是
    `include`，它告诉 Sequelize 跟踪外键关系以加载相关数据并从结果中创建对象。在这种情况下，结果将是一个 `ResultModel` 对象，其
    `Person` 和 `Calculation` 属性被填充。`limit` 属性限制了结果的数量，而 `order` 属性用于指定结果的排序方式。
- en: The query is performed asynchronously, and the result is a `Promise` that yields
    an array of `ResultModel` objects, which are mapped to the `Result` objects required
    by the `Repository` interface using the `fromOrmModel` function defined in *Listing
    12.27*.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是异步执行的，结果是返回一个 `Promise`，该 `Promise` 产生一个 `ResultModel` 对象数组，这些对象使用在 *列表 12.27*
    中定义的 `fromOrmModel` 函数映射到 `Repository` 接口所需的 `Result` 对象。
- en: The `where` configuration property can be used to select specific data, as demonstrated
    in *Listing 12.30*, which implements the `getResultsByName` method.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `where` 配置属性来选择特定数据，如 *列表 12.30* 所示，该列表实现了 `getResultsByName` 方法。
- en: 'Listing 12.30: Searching for data in the orm_repository.ts file in the src/server/data
    folder'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.30：在 src/server/data 文件夹中的 orm_repository.ts 文件中搜索数据
- en: '[PRE65]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is the same query used in *Listing 12.29* but with the addition of the
    `where` property, which tells Sequelize to follow the foreign key relationship
    and match `Person` objects using the `name` property. The syntax for the `where`
    property can take some getting used to, but you will see additional examples in
    later chapters.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与 *列表 12.29* 中相同的查询，但增加了 `where` 属性，该属性告诉 Sequelize 跟随外键关系，并使用 `name` 属性匹配
    `Person` 对象。`where` 属性的语法可能需要一些时间来适应，但您将在后面的章节中看到更多的示例。
- en: Writing data
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入数据
- en: '*Listing 12.31* completes the repository by implementing the `saveResult` method,
    which only stores `Person` and `Calculation` objects if there isn’t already matching
    data in the database and performs all of its changes using a transaction.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12.31* 通过实现 `saveResult` 方法来完成仓库，该方法仅在数据库中不存在匹配数据时存储 `Person` 和 `Calculation`
    对象，并且使用事务执行所有更改。'
- en: 'Listing 12.31: Writing data in the orm_repository.ts file in the src/server/data
    folder'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.31：在 src/server/data 文件夹中的 orm_repository.ts 文件中写入数据
- en: '[PRE66]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `transaction` is created with the `Sequelize.transaction` method, which
    accepts a callback function that receives a `Transaction` object. The `transaction`
    property is used to enroll each operation in the transaction, which will be committed
    or rolled back automatically.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Sequelize.transaction` 方法创建 `transaction`，该方法接受一个回调函数，该函数接收一个 `Transaction`
    对象。使用 `transaction` 属性将每个操作注册到事务中，这些操作将自动提交或回滚。
- en: Within the transaction, the `findOrCreate` method is used to see if there are
    `Person` and `Calculation` objects in the database that match the data received
    by the `saveResult` method. The result is the existing object, if there is one,
    or the newly created object if there is no match.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务中，使用 `findOrCreate` 方法来查看数据库中是否存在与 `saveResult` 方法接收到的数据匹配的 `Person` 和 `Calculation`
    对象。结果是如果存在，则为现有对象，如果不存在匹配项，则为新创建的对象。
- en: A new `ResultModel` object must be stored for every request, and this is done
    using the `create` method. The values for the `personId` and `calculationId` properties
    are set using the results from the `findOrCreate` method and the write operation
    is enrolled in the transaction. No value is required for the `id` property, which
    will be assigned by the database when the new data is stored, and which is contained
    in the result of the `create` method.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都必须存储一个新的 `ResultModel` 对象，这可以通过 `create` 方法完成。`personId` 和 `calculationId`
    属性的值使用 `findOrCreate` 方法的输出设置，写操作注册到事务中。对于 `id` 属性不需要值，数据库在存储新数据时将分配该值，并且该值包含在
    `create` 方法的输出中。
- en: '**Note**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `create` method allows objects to be created and stored in a single step.
    An alternative is to use the `build` method, which creates a model object that
    isn’t stored until the `save` method is called, which allows changes to be made
    before data is written to the database.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 方法允许在单个步骤中创建和存储对象。另一种选择是使用 `build` 方法，该方法创建一个模型对象，该对象在调用 `save` 方法之前不会存储，这允许在数据写入数据库之前进行更改。'
- en: Applying the repository
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用仓库
- en: The benefit of using a repository is that the details of how data is stored
    can be changed without affecting the parts of the application that use that data.
    To complete the transition to the ORM package, *Listing 12.32* replaces the existing
    repository with the ORM.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仓库的好处是，可以更改数据存储的细节，而不会影响使用该数据的应用程序部分。为了完成向 ORM 包的过渡，*列表 12.32* 用 ORM 替换了现有的仓库。
- en: 'Listing 12.32: Using the ORM repository in the index.ts file in the src/server/data
    folder'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.32：在 src/server/data 文件夹中的 index.ts 文件中使用 ORM 仓库
- en: '[PRE67]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: No other changes are required because the repository isolates data management
    from the templates and request handling code. Use a browser to request `http://localhost:5000`
    and you will see the seed data. Fill out and submit the form and you will see
    the response shown in *Figure 12.6*, showing that data has been stored in the
    database. If you examine the Node.js console output, you will see the SQL queries
    that `Sequelize` is formulating from the operations performed on the data model
    objects.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仓库将数据管理从模板和请求处理代码中隔离出来，因此无需进行其他更改。使用浏览器请求`http://localhost:5000`，你将看到种子数据。填写并提交表单后，你将在*图12.6*中看到响应，显示数据已存储在数据库中。如果你检查Node.js控制台输出，你将看到`Sequelize`从对数据模型对象执行的操作中构建的SQL查询。
- en: '![](img/B21959_12_06.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21959_12_06.png)'
- en: 'Figure 12.6: Using an ORM package'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：使用ORM包
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I explained how a JavaScript web application can use a database,
    both directly using SQL and indirectly using an ORM package.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我解释了JavaScript网络应用如何使用数据库，无论是直接使用SQL还是间接使用ORM包。
- en: Databases are the most common choice for persistent data storage.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库是最常见的持久数据存储选择。
- en: Node.js can be used with popular database engines, for which there is a wide
    range of open-source packages.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js可以与流行的数据库引擎一起使用，为此有大量的开源包。
- en: Databases can be used directly or through packages that express data as objects
    and generate queries automatically.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库可以直接使用或通过将数据表示为对象并自动生成查询的包来使用。
- en: A basic knowledge of how databases work and the ability to understand the core
    SQL syntax makes it easier to work with databases, even when an ORM package is
    used.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据库工作原理的基本了解以及理解核心SQL语法的技能，使得即使在使用ORM包的情况下，与数据库工作也变得更加容易。
- en: In the next chapter, I will describe how related HTTP requests can be identified
    to create sessions.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将描述如何识别相关的HTTP请求以创建会话。
