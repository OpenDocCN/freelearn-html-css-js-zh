- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Points and Sprites
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点和精灵
- en: 'In the previous chapters, we discussed the most important concepts, objects,
    and APIs that Three.js has to offer. In this chapter, we’ll look into the only
    concepts we’ve skipped until now: points and sprites. With `THREE.Points` (sometimes
    also called sprites), it is very easy to create many small rectangles that always
    face the camera and you can use to simulate rain, snow, smoke, and other interesting
    effects. For instance, you can render individual geometries as a set of points
    and control these points separately. In this chapter, we’ll explore the various
    point- and sprite-related features provided by Three.js.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了 Three.js 提供的最重要概念、对象和 API。在本章中，我们将探讨我们至今为止跳过的唯一概念：点和精灵。使用 `THREE.Points`（有时也称为精灵），可以非常容易地创建许多始终面向相机的矩形，您可以使用它们来模拟雨、雪、烟雾和其他有趣的效果。例如，您可以将单个几何体渲染为点集，并分别控制这些点。在本章中，我们将探索
    Three.js 提供的各个点和精灵相关功能。
- en: 'To be more specific, we’ll look at the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在本章中，我们将探讨以下主题：
- en: Creating and styling particles using `THREE.SpriteMaterial` and `THREE.PointsMaterial`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `THREE.SpriteMaterial` 和 `THREE.PointsMaterial` 创建和样式化粒子
- en: Using `THREE.Points` to create a group of points
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `THREE.Points` 创建一组点
- en: Using the canvas to style each point individually
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用画布来单独样式化每个点
- en: Using a texture to style the individual points
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理来样式化单个点
- en: Animating `THREE.Points` objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画 `THREE.Points` 对象
- en: Creating a `THREE.Points` object from existing geometries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有几何体创建 `THREE.Points` 对象
- en: A quick note on some of the names used in this chapter
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章中使用的某些名称的简要说明
- en: In newer versions of Three.js, the names of the objects related to points have
    changed several times. The `THREE.Points` object was previously named `THREE.PointCloud`
    and, in even older versions, it was called `THREE.ParticleSystem`. `THREE.Sprite`
    used to be called `THREE.Particle`, and the materials have also undergone several
    name changes. So, if you see online examples using these old names, remember that
    they are talking about the same concepts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 的新版本中，与点相关的对象名称已经更改了几次。`THREE.Points` 对象之前被称为 `THREE.PointCloud`，在更早的版本中被称为
    `THREE.ParticleSystem`。`THREE.Sprite` 之前被称为 `THREE.Particle`，材质也经历了多次名称更改。因此，如果您在网上看到使用这些旧名称的示例，请记住，它们讨论的是相同的概念。
- en: Let’s start by exploring what a particle is and how you can create one.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索粒子是什么以及如何创建一个粒子开始。
- en: Understanding points and sprites
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解点和精灵
- en: 'As we do with most new concepts, we’ll start with an example. In the sources
    for this chapter, you’ll find an example called `sprite.html`. Upon opening this
    example, you’ll see a minimalistic scene, containing a simple colored square:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数新概念一样，我们将从一个示例开始。在本章的源代码中，您将找到一个名为 `sprite.html` 的示例。打开此示例后，您将看到一个简约的场景，包含一个简单的彩色正方形：
- en: '![Figure 7.1 – A single rendered sprite](img/Figure_7.01_B18726.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 单个渲染的精灵](img/Figure_7.01_B18726.jpg)'
- en: Figure 7.1 – A single rendered sprite
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 单个渲染的精灵
- en: 'You can use your mouse to rotate around this scene. One thing you’ll notice
    is that no matter how you look at the square, it will always look the same. For
    instance, the following screenshot shows a view of the same scene from a different
    position:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用鼠标旋转场景。您会注意到的一件事是，无论您如何看这个正方形，它总是看起来一样。例如，下面的截图显示了从不同位置查看同一场景的视图：
- en: '![Figure 7.2 – A single rendered sprite will always be facing the camera](img/Figure_7.02_B18726.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 单个渲染的精灵将始终面向相机](img/Figure_7.02_B18726.jpg)'
- en: Figure 7.2 – A single rendered sprite will always be facing the camera
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 单个渲染的精灵将始终面向相机
- en: 'As you can see, the sprite is still angled toward the camera, and you can’t
    look behind it. You can think of a sprite as a 2D plane that always faces the
    camera. If you create a sprite without any properties, they are rendered as small,
    white, two-dimensional squares. To create a sprite, we only need to provide a
    material:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，精灵仍然朝向相机倾斜，您无法看到其背后。您可以将精灵想象成一个始终面向相机的二维平面。如果您创建的精灵没有任何属性，它们将被渲染成小而白色的二维正方形。要创建精灵，我们只需要提供一个材质：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can configure how the sprite appears using `THREE.SpriteMaterial`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `THREE.SpriteMaterial` 配置精灵的外观：
- en: '`color`: This is the color of the sprite. The default color is white.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`: 这是精灵的颜色。默认颜色是白色。'
- en: '`sizeAttenuation`: If this is set to `false`, the sprite will have the same
    size, regardless of how far from the camera it is positioned. If this is set to
    `true`, the size is based on the distance from the camera. The default value is
    `true`. Note that this only has an effect when using `THREE.PerspectiveCamera`.
    For `THREE.OrthographicCamera`, it always acts if set to `false`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeAttenuation`：如果设置为 `false`，精灵将具有相同的大小，无论其相对于摄像机的位置有多远。如果设置为 `true`，大小基于与摄像机的距离。默认值是
    `true`。注意，这仅在使用 `THREE.PerspectiveCamera` 时才有影响。对于 `THREE.OrthographicCamera`，如果设置为
    `false`，它始终起作用。'
- en: '`map`: With this property, you can apply a texture to the sprite. You can,
    for instance, make them look like snowflakes. This property isn’t shown in this
    example but is explained in the *Styling particles using textures* section in
    this chapter.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`：使用这个属性，你可以将纹理应用到精灵上。例如，你可以使它们看起来像雪花。这个属性在这个示例中没有展示，但在本章的 *使用纹理来样式化粒子*
    部分中有解释。'
- en: '`opacity`: This, together with the `transparent` property, sets the opacity
    of the sprite. The default value is `1` (fully opaque).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opacity`：这个属性与 `transparent` 属性一起设置精灵的不透明度。默认值是 `1`（完全不透明）。'
- en: '`transparent`: If this is set to `true`, the sprite will be rendered with the
    opacity set by the `opacity` property. The default value is `false`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transparent`：如果设置为 `true`，精灵将以 `opacity` 属性设置的透明度渲染。默认值是 `false`。'
- en: '`blending`: This is the blend mode to use when rendering the sprite.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blending`：这是渲染精灵时要使用的混合模式。'
- en: Note that `THREE.SpriteMaterial` extends from the base `THREE.Material` object,
    so all the properties from that object also can be used on `THREE.SpriteMaterial`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`THREE.SpriteMaterial` 是从基础 `THREE.Material` 对象扩展而来的，因此该对象的所有属性也可以用于 `THREE.SpriteMaterial`。
- en: Before we move on to more interesting `THREE.Points` objects, let’s look a bit
    closer at the `THREE.Sprite` object. A `THREE.Sprite` object extends from the
    `THREE.Object3D` object just as `THREE.Mesh` does. This means that most of the
    properties and functions you know from `THREE.Mesh` can be used on `THREE.Sprite`.
    You can set its position using the `position` attribute, scale it using the `scale`
    property, and move it along its axes using the `translate` property.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续探讨更有趣的 `THREE.Points` 对象之前，让我们更仔细地看看 `THREE.Sprite` 对象。一个 `THREE.Sprite`
    对象就像 `THREE.Mesh` 一样，是从 `THREE.Object3D` 对象扩展而来的。这意味着你从 `THREE.Mesh` 所了解的大部分属性和函数都可以用于
    `THREE.Sprite`。你可以使用 `position` 属性设置其位置，使用 `scale` 属性缩放它，并使用 `translate` 属性沿着其轴移动它。
- en: 'With `THREE.Sprite`, you can very easily create a set of objects and move them
    around the scene. This works well when you’re working with a small number of objects,
    but you’ll quickly run into performance issues when you want to work with a high
    number of `THREE.Sprite` objects. This is because each of the objects needs to
    be managed separately by Three.js. Three.js provides an alternative way of handling
    a large number of sprites using a `THREE.Points` object. With `THREE.Points`,
    Three.js doesn’t have to manage many individual `THREE.Sprite` objects, just the
    `THREE.Points` instance. This will allow Three.js to optimize how it draws the
    sprites and will result in better performance. The following screenshot shows
    several sprites rendered with the `THREE.Points` object:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.Sprite`，你可以非常容易地创建一组对象并在场景中移动它们。当你处理少量对象时，这效果很好，但当你想要处理大量 `THREE.Sprite`
    对象时，你会很快遇到性能问题。这是因为每个对象都需要由 Three.js 分别管理。Three.js 提供了一种使用 `THREE.Points` 对象处理大量精灵的替代方法。使用
    `THREE.Points`，Three.js 不需要管理许多单独的 `THREE.Sprite` 对象，只需管理 `THREE.Points` 实例即可。这将允许
    Three.js 优化绘制精灵的方式，从而获得更好的性能。以下截图显示了使用 `THREE.Points` 对象渲染的几个精灵：
- en: "![Figure 7.3 – Multiple points rendered from \uFEFFTHREE.BufferGeometry](img/Figure_7.03_B18726.jpg)"
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 从 THREE.BufferGeometry 渲染的多个点](img/Figure_7.03_B18726.jpg)'
- en: Figure 7.3 – Multiple points rendered from THREE.BufferGeometry
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 从 THREE.BufferGeometry 渲染的多个点
- en: 'To create a `THREE.Points` object, we need to provide it with `THREE.BufferGeometry`.
    For the previous screenshot, we can create a `THREE.BufferGeometry` like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 `THREE.Points` 对象，我们需要提供它一个 `THREE.BufferGeometry`。对于之前的截图，我们可以创建一个 `THREE.BufferGeometry`，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see from this code fragment, first, we create an array of `THREE.Vector3`
    objects – one for each position where we want to create a sprite. Additionally,
    we set the `color` attribute on `THREE.BufferGeometry`, which is used to color
    each sprite. With `THREE.BufferGeometry` and an instance of `THREE.PointsMaterial`,
    we can create the `THREE.Points` object. The properties of `THREE.PointsMaterial`
    are pretty much the same as they are for `THREE.SpriteMaterial`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码片段中看到的，首先，我们创建了一个 `THREE.Vector3` 对象数组 – 每个对象对应我们想要创建精灵的位置。此外，我们在 `THREE.BufferGeometry`
    上设置了 `color` 属性，该属性用于为每个精灵着色。使用 `THREE.BufferGeometry` 和一个 `THREE.PointsMaterial`
    实例，我们可以创建 `THREE.Points` 对象。`THREE.PointsMaterial` 的属性几乎与 `THREE.SpriteMaterial`
    的属性相同：
- en: '`color`: This is the color of the point. The default color is `0xffffff`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`: 这是点的颜色。默认颜色是 `0xffffff`。'
- en: '`sizeAttenuation` If this is set to `false`, all the points will have the same
    size, regardless of how far from the camera they are positioned. If this is set
    to `true`, the size is based on the distance from the camera. The default value
    is `true`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeAttenuation` 如果设置为 `false`，所有点将具有相同的大小，无论它们距离相机有多远。如果设置为 `true`，大小将基于距离相机的距离。默认值是
    `true`。'
- en: '`map`: With this property, you can apply a texture to the point. You can, for
    instance, make them look like snowflakes. This property isn’t shown in this example
    but is explained in the *Styling particles using textures* section later in this
    chapter.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`: 使用这个属性，你可以将纹理应用到点上。例如，你可以使它们看起来像雪花。这个属性在这个例子中没有展示，但会在本章后面的“使用纹理样式化粒子”部分进行解释。'
- en: '`opacity`: This, together with the `transparent` property, sets the opacity
    of the sprites. The default value is `1` (no opacity).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opacity`: 这与 `transparent` 属性一起设置精灵的不透明度。默认值是 `1`（无不透明度）。'
- en: '`transparent`: If this is set to `true`, the sprites will be rendered with
    the opacity set by the `opacity` property. The default value is `false`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transparent`: 如果设置为 `true`，精灵将以 `opacity` 属性设置的不透明度渲染。默认值是 `false`。'
- en: '`blending`: This is the blend mode to use when rendering the sprites.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blending`: 这是渲染精灵时要使用的混合模式。'
- en: '`vertexColors`: Normally, all the points in `THREE.Points` have the same color.
    If this property is set to `true` and the color’s buffer attribute has been set
    on the geometry, each point will take the color from that array. The default value
    is `false`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexColors`: 通常，`THREE.Points` 中的所有点都有相同的颜色。如果将此属性设置为 `true`，并且几何体的颜色缓冲区属性已设置，则每个点将从该数组中获取颜色。默认值是
    `false`。'
- en: As always, you can play around with these properties using the menu on the right
    in each of the examples.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，您可以通过每个例子右侧的菜单来调整这些属性。
- en: So far, we’ve only rendered the particles as small squares, which is the default
    behavior. There are, however, two additional ways you can style particles, which
    we’ll show in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只以小方块的形式渲染了粒子，这是默认行为。然而，还有两种额外的样式化粒子的方式，我们将在下一节展示。
- en: Styling particles using textures
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理样式化粒子
- en: 'In this section, we’ll look at the following two ways of changing what the
    sprite looks like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下两种改变精灵外观的方式：
- en: Use an HTML canvas to draw an image and show that for each sprite
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTML 画布绘制图像并显示每个精灵
- en: Load an external image file to define what each sprite looks like
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载一个外部图像文件来定义每个精灵的外观
- en: Let’s start by drawing the image ourselves.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先自己绘制图像。
- en: Drawing an image on the canvas
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布上绘制图像
- en: 'In the attributes for `THREE.PointsMaterial`, we mentioned the `map` property.
    With the `map` property, we can load a texture for the individual points. With
    Three.js, this texture can also be the output from an HTML5 canvas. Before we
    look at the code, let’s look at an example (`canvastexture.js`):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `THREE.PointsMaterial` 的属性中，我们提到了 `map` 属性。使用 `map` 属性，我们可以为单个点加载纹理。使用 Three.js，这个纹理也可以是
    HTML5 画布的输出。在我们查看代码之前，让我们看一个例子（`canvastexture.js`）：
- en: '![Figure 7.4 – Creating sprites using a canvas-based texture](img/Figure_7.04_B18726.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 使用基于画布的纹理创建精灵](img/Figure_7.04_B18726.jpg)'
- en: Figure 7.4 – Creating sprites using a canvas-based texture
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 使用基于画布的纹理创建精灵
- en: 'Here, you can see that we’ve got a large set of Pac-Man-like ghosts on the
    screen. This uses the same approach that we saw in the *Understanding points and
    sprites* section earlier. This time, though, we aren’t showing a simple square
    but an image. To create this texture, we can use the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到屏幕上有一大群类似《吃豆人》的幽灵。这使用了我们在之前*理解点和精灵*部分看到的方法。不过，这次我们不是显示一个简单的正方形，而是一个图像。为了创建这个纹理，我们可以使用以下代码：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, first, we create an HTML canvas, on which we start drawing using
    the various `ctx.` functions. In the end, we convert this canvas into a `THREE.Texture`
    by calling `new THREE.Texture(canvas)`, which results in a `texture` we can use
    for our sprites. Remember to set `texture.needsUpdate` to `true`, which triggers
    Three.js to load the actual canvas data into the texture.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，首先，我们创建一个HTML画布，然后开始使用各种`ctx.`函数在上面绘制。最后，我们通过调用`new THREE.Texture(canvas)`将这个画布转换为一个`THREE.Texture`，这样就得到了我们可以用于精灵的纹理。记得将`texture.needsUpdate`设置为`true`，这将触发Three.js将实际的画布数据加载到纹理中。
- en: 'Now that we’ve got a texture, we can use it to create a `THREE.PointsMaterial`,
    just like we did in the *Understanding points and* *sprites* section:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了一个纹理，我们可以用它来创建一个`THREE.PointsMaterial`，就像我们在*理解点和精灵*部分做的那样：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, we create `15000` points for this example and position them
    randomly in the specified range. What you might notice is that even if you turn
    on `transparency`, some sprites seem to overlap other sprites. This is because
    Three.js doesn’t sort sprites based on their z-index, so during rendering, it
    can’t correctly determine which one is before another one. There are two ways
    you can work around this: you can turn off `depthWrite`, or you can play around
    with the `alphaTest` property (starting with 0.5 is a good starting point).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们为这个示例创建了`15000`个点，并将它们随机地放置在指定的范围内。你可能注意到，即使你打开了`transparency`，一些精灵似乎重叠在其他精灵上。这是因为Three.js不是根据精灵的z-index来排序精灵的，所以在渲染时，它不能正确地确定哪个在另一个之前。你可以通过两种方法来解决这个问题：你可以关闭`depthWrite`，或者你可以调整`alphaTest`属性（从0.5开始是一个好的起点）。
- en: 'If you zoom out, you will see the 15,000 individual sprites:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你放大，你会看到15,000个单独的精灵：
- en: '![Figure 7.5 – Showing 15,000 sprites all at once](img/Figure_7.05_B18726.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 同时显示15,000个精灵](img/Figure_7.05_B18726.jpg)'
- en: Figure 7.5 – Showing 15,000 sprites all at once
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 同时显示15,000个精灵
- en: 'The amazing thing is that even with 1 million points, everything is still rendered
    very smoothly (of course, this depends on the hardware you’re running these examples
    on):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 奇妙的是，即使有100万个点，一切仍然渲染得非常平滑（当然，这取决于你运行这些示例的硬件）：
- en: '![Figure 7.6 – Showing 1 million sprites all at once](img/Figure_7.06_B18726.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 同时显示1百万个精灵](img/Figure_7.06_B18726.jpg)'
- en: Figure 7.6 – Showing 1 million sprites all at once
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 同时显示1百万个精灵
- en: In the next section, we’ll load some textures from external images and use those
    instead of drawing the texture ourselves.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从外部图像加载一些纹理，并使用这些纹理而不是自己绘制纹理。
- en: Using textures to style particles
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纹理来样式化粒子
- en: 'In the example shown in the *Drawing an image on the canvas* section, we saw
    how to style `THREE.Points` using an HTML canvas. Since you can draw anything
    you want and even load external images, you can use this approach to add all kinds
    of styles to the particle system. There is, however, a more direct way to use
    an image to style your particles: you can use the `THREE.TextureLoader().load()`
    function to load an image as a `THREE.Texture` object. This `THREE.Texture` object
    can then be assigned to the `map` property of a material.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在*在画布上绘制图像*部分的示例中，我们看到了如何使用HTML画布来样式化`THREE.Points`。由于你可以绘制任何你想要的东西，甚至可以加载外部图像，你可以使用这种方法为粒子系统添加各种样式。然而，有一个更直接的方法来使用图像来样式化你的粒子：你可以使用`THREE.TextureLoader().load()`函数将图像加载为一个`THREE.Texture`对象。这个`THREE.Texture`对象然后可以被分配给材质的`map`属性。
- en: 'In this section, we’ll show you two examples and explain how to create them.
    Both these examples use an image as a texture for your particles. In the first
    example, we’ll create a simulation of rain (`rain.html`):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示两个示例，并解释如何创建它们。这两个示例都使用图像作为粒子的纹理。在第一个示例中，我们将创建一个雨的模拟（`rain.html`）：
- en: '![Figure 7.7 – Simulating rain falling down](img/Figure_7.07_B18726.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 模拟雨滴下落](img/Figure_7.07_B18726.jpg)'
- en: Figure 7.7 – Simulating rain falling down
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 模拟雨滴下落
- en: 'The first thing we need to do is get a texture that will represent our raindrop.
    You can find a couple of examples in the `assets/textures/particles` folder. In
    the upcoming chapters, we will explain all the details and requirements for textures.
    For now, all you need to know is that the texture should be square and preferably
    a power of 2 (for example, 64 x 64, 128 x 128, or 256 x 256). For this example,
    we’ll use this texture:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取一个代表我们雨滴的纹理。你可以在 `assets/textures/particles` 文件夹中找到一些示例。在接下来的章节中，我们将解释纹理的所有细节和要求。现在，你需要知道的是，纹理应该是正方形的，最好是
    2 的幂（例如，64 x 64、128 x 128 或 256 x 256）。对于这个例子，我们将使用这个纹理：
- en: '![Figure 7.8 – Raindrop texture](img/Figure_7.08_B18726.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 雨滴纹理](img/Figure_7.08_B18726.jpg)'
- en: Figure 7.8 – Raindrop texture
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 雨滴纹理
- en: 'This texture is a simple transparent image and shows the shape and color of
    a raindrop. Before we can use this texture in `THREE.PointsMaterial`, we need
    to load it. This can be done with the following line of code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个纹理是一个简单的透明图像，显示了雨滴的形状和颜色。在我们能够在 `THREE.PointsMaterial` 中使用这个纹理之前，我们需要加载它。这可以通过以下行代码完成：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this line of code, Three.js will load the texture, and we can use it in
    our material. For this example, we defined the material as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这一行代码，Three.js 将加载纹理，我们可以在我们的材质中使用它。对于这个例子，我们定义了材质如下：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this chapter, we’ve discussed all of these properties. The main thing to
    understand here is that the `map` property points to the texture we loaded with
    the `THREE.TextureLoader.load` function. Note that we used the `alphaTest` property
    again to make sure there are no weird artifacts when two sprites are moving in
    front of one another.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了所有这些属性。这里要理解的主要是 `map` 属性指向我们使用 `THREE.TextureLoader.load` 函数加载的纹理。请注意，我们再次使用了
    `alphaTest` 属性，以确保当两个精灵在彼此前面移动时没有奇怪的纹理。
- en: 'That takes care of styling the `THREE.Points` object. What you’ll also see
    when you open this example is that the points themselves are moving. Doing this
    is very simple. Each point is represented as a vertex that makes up the geometry
    that was used to create the `THREE.Points` object. Let’s look at how we can add
    the points for this `THREE.Points` object:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就处理了 `THREE.Points` 对象的样式。当你打开这个例子时，你还会看到点本身在移动。这样做非常简单。每个点都是一个顶点，它构成了创建 `THREE.Points`
    对象所使用的几何形状。让我们看看我们如何为这个 `THREE.Points` 对象添加点：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This isn’t that different than the previous examples we saw in this chapter.
    Here, we added another property to each particle called `velocity`. This property
    consists of two values: `velocityX` and `velocityY`. The first one defines how
    a particle (a raindrop) moves horizontally, while the second one defines how fast
    the raindrop falls. Now that each raindrop has its own speed, we can move the
    individual particles inside the render loop:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在本章中看到的先前的例子并没有太大的不同。在这里，我们为每个粒子添加了一个名为 `velocity` 的属性。这个属性由两个值组成：`velocityX`
    和 `velocityY`。第一个值定义了粒子（雨滴）如何水平移动，而第二个值定义了雨滴下落的速度。现在每个雨滴都有自己的速度，我们可以在渲染循环中移动单个粒子：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this piece of code, we get all the vertices (particles) from the geometry
    that was used to create `THREE.Points`. For each of the particles, we take `velocityX`
    and `velocityY` and use them to change the current position of the particle. Then,
    we make sure the particles stay within the range we’ve defined. If the `v.y` position
    drops below `0`, we add the raindrop back to the top, and if the `v.x` position
    reaches any of the edges, we make it bounce back by inverting the horizontal velocity.
    Finally, we need to tell Three.js we’ve changed some things in `bufferGeometry`
    so that it knows the correct values next time we’re rendering.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们从创建 `THREE.Points` 所使用的几何形状中获取所有顶点（粒子）。对于每个粒子，我们取 `velocityX` 和 `velocityY`
    并使用它们来改变粒子的当前位置。然后，我们确保粒子保持在定义的范围内。如果 `v.y` 位置下降到 `0` 以下，我们将雨滴重新添加到顶部，如果 `v.x`
    位置达到任何边缘，我们将通过反转水平速度使其弹回。最后，我们需要告诉 Three.js 我们在 `bufferGeometry` 中更改了一些内容，这样它下次渲染时就知道正确的值了。
- en: 'Let’s look at another example. This time, we won’t make rain; instead, we’ll
    make snow. Additionally, we won’t be using just a single texture – we’ll use three
    separate images (taken from the Three.js examples). Let’s start by looking at
    the result first (`snow.html`):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。这次，我们不会制作雨，而是制作雪。此外，我们不会只使用一个纹理——我们将使用三张单独的图片（来自 Three.js 的示例）。让我们首先看看结果（`snow.html`）：
- en: '![Figure 7.9 – Snowy scene based on multiple textures](img/Figure_7.09_B18726.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 基于多个纹理的雪景](img/Figure_7.09_B18726.jpg)'
- en: Figure 7.9 – Snowy scene based on multiple textures
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 基于多个纹理的雪景
- en: 'In the preceding screenshot, if you look closely, you can see that instead
    of using just a single image as a texture, we’ve used multiple images that have
    transparent backgrounds. You might be wondering how we did this. As you probably
    remember, we can only have a single material for a `THREE.Points` object. If we
    want to have multiple materials, we just have to make multiple `THREE.Points`
    instances, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，如果您仔细观察，可以看到我们并没有只使用单个图像作为纹理，而是使用了具有透明背景的多个图像。您可能想知道我们是如何做到这一点的。如您所记得，我们只能为`THREE.Points`对象使用单个材质。如果我们想使用多个材质，我们只需创建多个`THREE.Points`实例，如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code fragment, you can see that we create three different `THREE.Points`
    instances, each with its own materials. To move the snowflakes around, we use
    the same approach as for the rain, so we don’t show the details of `createPoint`
    and the render loop here. One thing to note here is that it is possible to have
    a single `THREE.Points` instance, where the individual sprites have different
    textures. However, this would require a custom `fragment-shader` and your own
    instance of `THREE.ShaderMaterial`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，您可以看到我们创建了三个不同的`THREE.Points`实例，每个实例都有自己的材质。为了移动雪花，我们使用了与雨相同的方法，因此这里不展示`createPoint`和渲染循环的细节。这里需要注意的是，可以有一个单一的`THREE.Points`实例，其中各个精灵有不同的纹理。然而，这需要自定义的`fragment-shader`和您自己的`THREE.ShaderMaterial`实例。
- en: 'Before we move on to the next section, note that using `THREE.Points` is a
    great way to add visual effects to an existing scene. For instance, the snow we
    saw in the previous example can quickly turn a standard scene into a snowy one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，请注意，使用`THREE.Points`是向现有场景添加视觉效果的好方法。例如，我们在前面的例子中看到的雪可以迅速将一个标准场景变成雪景：
- en: '![Figure 7.10 – THREE.Points together with a cube map](img/Figure_7.10_B18726.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – `THREE.Points`与立方体贴图一起](img/Figure_7.10_B18726.jpg)'
- en: Figure 7.10 – THREE.Points together with a cube map
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – `THREE.Points`与立方体贴图一起
- en: Another way we can use sprites is to create a simple 2D **heads-up display**
    (**HUD**) on top of an existing scene. We’ll explore how to do this in the next
    section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用精灵的另一种方式是在现有场景的上方创建一个简单的2D**抬头显示**（**HUD**）。我们将在下一节中探讨如何做到这一点。
- en: Working with sprite maps
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用精灵图
- en: 'At the beginning of this chapter, we used a `THREE.Sprite` object to render
    single points. These sprites were positioned somewhere in the 3D world, and their
    size was based on the distance from the camera (this is also sometimes called
    `THREE.Sprite` object: we’ll show you how you can use `THREE.Sprite` to create
    a layer similar to a HUD for your 3D content using an extra `THREE.OrthographicCamera`
    instance and an additional `THREE.Scene`. We will also show you how to select
    the image for a `THREE.Sprite` object using a sprite map.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们使用了一个`THREE.Sprite`对象来渲染单个点。这些精灵被定位在3D世界的某个位置，它们的大小基于与相机的距离（这有时也被称为`THREE.Sprite`对象：我们将向您展示如何使用额外的`THREE.OrthographicCamera`实例和一个额外的`THREE.Scene`来使用`THREE.Sprite`创建一个类似于HUD的层，用于您的3D内容。我们还将向您展示如何使用精灵图来选择`THREE.Sprite`对象的图像。
- en: 'As an example, we’re going to create a simple `THREE.Sprite` object that moves
    from left to right over the screen. In the background, we’ll render a 3D scene
    with a camera, which you can move to illustrate that the `THREE.Sprite` object
    moves independently of the camera. The following screenshot shows what we’ll be
    creating for the first example (`spritemap.html`):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将创建一个简单的`THREE.Sprite`对象，它在屏幕上从左到右移动。在背景中，我们将渲染一个带有相机的3D场景，您可以通过移动相机来展示`THREE.Sprite`对象是独立于相机移动的。以下屏幕截图显示了我们将为第一个示例创建的内容（`spritemap.html`）：
- en: '![Figure 7.11 – Using two scenes and cameras to create a HUD](img/Figure_7.11_B18726.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 使用两个场景和相机创建HUD](img/Figure_7.11_B18726.jpg)'
- en: Figure 7.11 – Using two scenes and cameras to create a HUD
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 使用两个场景和相机创建HUD
- en: 'If you open this example in your browser, you’ll see a Pac-Man ghost-like sprite
    moving across the screen that changes color and form whenever it hits the right
    edge. The first thing we’ll do is look at how we can create `THREE.OrthographicCamera`
    and a separate scene to render this `THREE.Sprite`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开这个示例，您会看到一个类似Pac-Man幽灵的精灵在屏幕上移动，每当它碰到右边时，它的颜色和形状都会改变。我们首先要做的是看看我们如何创建`THREE.OrthographicCamera`和单独的场景来渲染这个`THREE.Sprite`：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, let’s look at the construction of the `THREE.Sprite` object and how the
    various shapes the sprite can take are loaded:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何构建 `THREE.Sprite` 对象以及加载精灵可以采取的各种形状：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `getTexture()` function, we load a texture. However, instead of loading
    five different images for each ghost, we load a single texture that contains all
    the sprites (also called a sprite map). The image we have as a texture looks like
    this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getTexture()` 函数中，我们加载一个纹理。然而，我们不是为每个幽灵加载五张不同的图片，而是加载一个包含所有精灵的单个纹理（也称为精灵图）。作为纹理的图像看起来像这样：
- en: '![Figure 7.12 – Input sprite sheet](img/Figure_7.12_B18726.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 输入精灵图](img/Figure_7.12_B18726.jpg)'
- en: Figure 7.12 – Input sprite sheet
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 输入精灵图
- en: With the `map.offset` and `map.repeat` properties, we can select the correct
    sprite to show on the screen. With the `map.offset` property, we determine the
    offset for the *x a*xis (`u`) and the *y a*xis (`v`) for the texture we loaded.
    The scale for these properties runs from `0` to `1`. In our example, if we want
    to select the third ghost, we must set the `u`-offset (*x a*xis) to `0.4`, and,
    because we’ve only got one row, we don’t need to change the `v`-offset (*y a*xis).
    If we only set this property, the texture shows the third, fourth, and fifth ghosts
    compressed together on screen. To only show one ghost, we need to zoom in. We
    can do this by setting the `map.repeat` property for the `u`-value to `1/5`. This
    means that we zoom in (only for the *x a*xis) to only show 20% of the texture,
    which is exactly one ghost.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map.offset` 和 `map.repeat` 属性，我们可以选择屏幕上要显示的正确精灵。使用 `map.offset` 属性，我们确定加载的纹理的
    *x 轴*（`u`）和 *y 轴*（`v`）的偏移量。这些属性的缩放范围从 `0` 到 `1`。在我们的例子中，如果我们想选择第三个幽灵，我们必须将 `u`
    偏移量（`x 轴`）设置为 `0.4`，因为我们只有一行，所以我们不需要改变 `v` 偏移量（`y 轴`）。如果我们只设置这个属性，纹理会在屏幕上显示压缩在一起的第三个、第四个和第五个幽灵。如果我们只想显示一个幽灵，我们需要放大。我们可以通过将
    `map.repeat` 属性的 `u` 值设置为 `1/5` 来做到这一点。这意味着我们只放大（仅针对 `x 轴`）以只显示纹理的 20%，这正好是一个幽灵。
- en: 'Finally, we need to update the `render` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新 `render` 函数：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we render the scene with the normal camera and the two meshes; after
    that, we render the scene containing our sprite. In the render loop, we also switch
    some properties to show the next sprite when it hits the right wall and change
    the sprite’s direction (code not shown).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用普通相机和两个网格渲染场景；然后，我们渲染包含我们的精灵的场景。在渲染循环中，我们还会切换一些属性，以便当精灵碰到右侧墙壁时显示下一个精灵并改变精灵的方向（代码未显示）。
- en: So far in this chapter, we’ve mainly looked at creating sprites and point clouds
    from scratch. An interesting option, though, is to create `THREE.Points` from
    an existing geometry.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们主要关注从头开始创建精灵和点云。然而，一个有趣的选择是从现有的几何体创建 `THREE.Points`。
- en: Creating THREE.Points from existing geometry
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从现有几何体创建 THREE.Points
- en: As you may recall, `THREE.Points` renders each point based on the vertices from
    the supplied `THREE.BufferGeometry`. This means that if we provide a complex geometry
    (for example, a torus knot or a tube), we can create `THREE.Points` based on the
    vertices from that specific geometry. In this final section of this chapter, we’ll
    create a torus knot, like the one we saw in [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101),
    *Exploring Advanced Geometries*, and render it as a `THREE.Points` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所回忆的，`THREE.Points` 根据提供的 `THREE.BufferGeometry` 中的顶点渲染每个点。这意味着如果我们提供一个复杂的几何体（例如，环面结或管），我们可以根据该特定几何体的顶点创建
    `THREE.Points`。在本章的最后一节中，我们将创建一个环面结，就像我们在 [*第 6 章*](B18726_06.xhtml#_idTextAnchor101)
    中看到的那样，*探索高级几何体*，并将其渲染为 `THREE.Points` 对象。
- en: 'We explained the torus knot in [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101),
    so we won’t go into much detail here. The following screenshot shows the example
    (`points-from-geom.html`):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 6 章*](B18726_06.xhtml#_idTextAnchor101) 中解释了环面结，所以这里我们不会过多详细说明。下面的屏幕截图显示了示例（`points-from-geom.html`）：
- en: '![Figure 7.13 – Torus knot rendered as points with a small animation](img/Figure_7.13_B18726.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 以点形式渲染的环面结，带有小动画](img/Figure_7.13_B18726.jpg)'
- en: Figure 7.13 – Torus knot rendered as points with a small animation
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 以点形式渲染的环面结，带有小动画
- en: 'As you can see from the preceding screenshot, every vertex used to generate
    the torus knot is used as a point. We can set this up like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的屏幕截图中所见，用于生成环面结的每个顶点都用作一个点。我们可以这样设置：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we simply create a geometry and use that as input for the `THREE.Points`
    object. This way, we can render every geometry as a points object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是创建了一个几何形状，并将其用作`THREE.Points`对象的输入。这样，我们可以将每个几何形状渲染为点对象。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you load external models using a Three.js model loader (for example, a glTF
    model), you’ll often end up with a hierarchy of objects – often grouped in `THREE.Group`
    or `THREE.Object3D` objects. In those cases, you’ll have to convert each geometry
    in each group into a `THREE.Points` object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Three.js模型加载器（例如，glTF模型）加载外部模型，你通常会得到一个对象层次结构——通常分组在`THREE.Group`或`THREE.Object3D`对象中。在这些情况下，你必须将每个组中的每个几何形状转换为`THREE.Points`对象。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That’s a wrap for this chapter. We’ve explained what sprites and points are
    and how you can style these objects with the materials available. In this chapter,
    you saw how you can use `THREE.Sprite` directly, and that if you want to create
    a large number of particles, you should use a `THREE.Points` object. With `THREE.Points`,
    all the elements share the same material, and the only property you can change
    for an individual particle is its color by setting the `vertexColors` property
    of the material to `true` and providing a color value in the `colors` array of
    `THREE.BufferGeometry`, which is used to create `THREE.Points`. We also showed
    how you can easily animate particles by changing their position. This works the
    same for an individual `THREE.Sprite` instance and the vertices from the geometry
    used to create `THREE.Points` objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此结束。我们解释了精灵和点是什么，以及如何使用可用的材质来样式化这些对象。在本章中，你看到了如何直接使用`THREE.Sprite`，以及如果你想要创建大量的粒子，你应该使用一个`THREE.Points`对象。使用`THREE.Points`，所有元素共享相同的材质，你可以为单个粒子更改的唯一属性是其颜色，通过将材质的`vertexColors`属性设置为`true`并在`THREE.BufferGeometry`的`colors`数组中提供一个颜色值来实现，该数组用于创建`THREE.Points`。我们还展示了如何通过改变它们的位置来轻松地动画化粒子。这对于单个`THREE.Sprite`实例以及用于创建`THREE.Points`对象的几何形状的顶点都是一样的。
- en: So far, we have created meshes based on geometries provided by Three.js. This
    works well for simple models, such as spheres and cubes, but isn’t the best approach
    when you want to create complex 3D models. For those models, you’d usually use
    a 3D modeling application, such as Blender or 3D Studio Max. In the next chapter,
    you’ll learn how you can load and display models created by such 3D modeling applications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了基于Three.js提供的几何形状的网格。这对于简单的模型，如球体和立方体，效果很好，但当你想要创建复杂的3D模型时，这并不是最佳方法。对于这些模型，你通常会使用3D建模应用程序，例如Blender或3D
    Studio Max。在下一章中，你将学习如何加载和显示由这样的3D建模应用程序创建的模型。
- en: 'Part 3: Particle Clouds, Loading and Animating Models'
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：粒子云，加载和动画模型
- en: In this third part, we’ll show you how you can load data from external models
    and how Three.js supports animations. We’ll also dive into the different types
    of textures that are supported by Three.js and how you can use them to enhance
    your models.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本第三部分，我们将向你展示如何从外部模型加载数据以及Three.js如何支持动画。我们还将深入了解Three.js支持的纹理类型以及如何使用它们来增强你的模型。
- en: 'In this part, there are the following chapters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，有以下章节：
- en: '[*Chapter 8*](B18726_08.xhtml#_idTextAnchor132), *Creating and Loading Advanced
    Meshes and Geometries*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18726_08.xhtml#_idTextAnchor132)，*创建和加载高级网格和几何形状*'
- en: '[*Chapter 9*](B18726_09.xhtml#_idTextAnchor148), *Animations and Moving the
    Camera*'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18726_09.xhtml#_idTextAnchor148)，*动画和移动相机*'
- en: '[*Chapter 10*](B18726_10.xhtml#_idTextAnchor171), *Loading and Working with
    Textures*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18726_10.xhtml#_idTextAnchor171)，*加载和使用纹理*'
