- en: Textures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理
- en: In the previous chapter, we covered colors, multiple lights, and important concepts
    about depth and alpha testing for various blending techniques. So far, we've added
    details to our scene with geometry, vertex colors, and lighting; but often, that
    won't be enough to achieve the results we're looking for. Wouldn't it be great
    if we could "paint" additional details onto our scene without needing additional
    geometry? We can! This requires us to use a technique called texture mapping.
    In this chapter, we'll examine how we can use textures to make our scene more
    detailed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了颜色、多个光源以及关于深度和 alpha 测试的各种混合技术的重要概念。到目前为止，我们已经通过几何、顶点颜色和光照为场景添加了细节；但通常，这还不足以达到我们想要的结果。如果我们能够在不需要额外几何的情况下“绘制”额外的细节到场景中，那岂不是很好？我们可以做到！这需要我们使用一种称为纹理映射的技术。在本章中，我们将探讨如何使用纹理使场景更加详细。
- en: 'In this chapter, you will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将完成以下任务：
- en: Learn how to create a texture.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建纹理。
- en: Learn how to use a texture when rendering.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在渲染时使用纹理。
- en: Learn about filter and wrapping modes and how they affect the texture's use.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于过滤和包裹模式以及它们如何影响纹理的使用。
- en: Learn how to use multi-texturing.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用多纹理。
- en: Learn about cube mapping.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习关于立方贴图。
- en: What Is Texture Mapping?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是纹理映射？
- en: 'Texture mapping is simply a method for adding detail to a geometry being rendered
    by displaying an image on the surface. Consider the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理映射简单来说是一种在渲染几何体时通过在表面上显示图像来添加细节的方法。考虑以下截图：
- en: '![](img/b50e4c7c-20ba-4e9e-8864-10fc993fab91.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b50e4c7c-20ba-4e9e-8864-10fc993fab91.png)'
- en: Using only the techniques we've learned so far, this relatively simple scene
    would be very difficult to build. The WebGL logo alone would have to be carefully
    constructed out of many triangle primitives. Although this is a possible approach,
    the additional geometry construction would be impractical for a marginally complex
    scene.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用我们迄今为止学到的技术，构建这样一个相对简单的场景将会非常困难。仅 WebGL 标志就需要仔细由许多三角形原语构建。虽然这是一个可能的方法，但对于稍微复杂一些的场景，额外的几何构造将是不切实际的。
- en: Fortunately, texture mapping makes such requirements incredibly simple. All
    that's required is an image in an appropriate file format, an additional vertex
    attribute on the mesh, and a few additions to our shader code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，纹理映射使这样的要求变得极其简单。所需的一切只是一个适当文件格式的图像，一个额外的网格顶点属性，以及对我们着色器代码的一些修改。
- en: Creating and Uploading a Texture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和上传纹理
- en: 'Unlike traditional native OpenGL applications, browsers load textures "upside
    down". As a result, many WebGL applications set textures to be loaded with the
    `Y` coordinate flipped. This is done with a single call:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的原生 OpenGL 应用程序不同，浏览器以“颠倒”的方式加载纹理。因此，许多 WebGL 应用程序将纹理设置为使用 `Y` 坐标翻转加载。这可以通过一个单独的调用完成：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inverted Textures
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 反转纹理
- en: Textures can either be manually flipped or flipped via WebGL. We will programmatically
    flip them with WebGL.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理可以手动翻转，也可以通过 WebGL 翻转。我们将使用 WebGL 逐行编程地翻转它们。
- en: 'The process of creating a texture is similar to creating a vertex or an index
    buffer. We start by creating the texture object, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建纹理的过程类似于创建顶点或索引缓冲区。我们首先创建纹理对象，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Textures, like buffers, must be bound before we can manipulate them:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理，就像缓冲区一样，在我们可以操作它们之前必须绑定：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first parameter indicates the type of texture we're binding, or the texture
    target. For now, we'll focus on 2D textures, indicated with `gl.TEXTURE_2D`. More
    targets will be introduced later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数表示我们正在绑定的纹理类型，或纹理目标。现在，我们将专注于 2D 纹理，用 `gl.TEXTURE_2D` 表示。在本章的后面部分将介绍更多目标。
- en: 'Once we''ve bound the texture, we can provide it with image data. The simplest
    way to do that is to pass a DOM image into the `texImage2D` function, as shown
    in the following code snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们绑定了纹理，我们就可以提供图像数据。最简单的方法是将 DOM 图像传递给 `texImage2D` 函数，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous snippet, we selected an image element from our page with the
    ID of `texture-image` as the source texture. This is **uploading** the texture,
    since the image will be stored in the GPU's memory for fast access during rendering.
    The source can be in any image format that can be displayed on a web page, such
    as JPEG, PNG, GIF, and BMP files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用 ID 为 `texture-image` 的元素从我们的页面中选择了一个图像元素作为源纹理。这是**上传**纹理，因为图像将被存储在
    GPU 的内存中，以便在渲染期间快速访问。源可以是任何可以在网页上显示的图像格式，例如 JPEG、PNG、GIF 和 BMP 文件。
- en: The image source for the texture is passed in as the last parameter of the `texImage2D`
    call. When `texImage2D` is called with an image, WebGL will automatically determine
    the dimensions of the provided texture. The remainder of the parameters instruct
    WebGL about the type of information the image contains and how to store it. Most
    of the time, the only values you need to worry about changing are the third and
    fourth parameters, which can also be `gl.RGB`, to indicate that your texture has
    no alpha (transparency) channel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的图像源作为`texImage2D`调用的最后一个参数传入。当`texImage2D`与图像一起调用时，WebGL将自动确定提供的纹理的尺寸。其余的参数指导WebGL有关图像包含的信息类型以及如何存储它。大多数情况下，您只需要担心更改第三个和第四个参数，这些参数也可以是`gl.RGB`，表示您的纹理没有alpha（透明度）通道。
- en: 'In addition to the image, we also need to instruct WebGL on how to filter the
    texture when rendering. We''ll get into what filtering means and what the different
    filtering modes do in a bit. In the meantime, let''s use the simplest one to get
    us started:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图像之外，我们还需要指导WebGL在渲染时如何过滤纹理。我们将在稍后讨论过滤的含义以及不同的过滤模式做什么。同时，让我们使用最简单的一个来开始：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Just as with buffers, it''s good practice to unbind a texture when you are
    finished using it. You can do so by binding `null` as the active texture:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像缓冲区一样，当您完成使用纹理后，解绑纹理是一个好的实践。您可以通过绑定`null`作为活动纹理来完成此操作：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Of course, in many cases, you won''t want to have all of the textures for your
    scene embedded in your web page, so it''s often more convenient to create the
    element in JavaScript and load it without adding it to the document. Putting all
    of this together gives us a simple function that will load any image URL that
    we provide as a texture:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在许多情况下，您可能不希望将场景中的所有纹理都嵌入到您的网页中，因此通常更方便在JavaScript中创建元素并加载它，而不将其添加到文档中。将这些放在一起，我们得到一个简单的函数，可以加载我们提供的任何图像URL作为纹理：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Asynchronous Loading
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 异步加载
- en: There is a slight gotcha when loading images this way. The image loading is
    **asynchronous**, which means that your program won't stop and wait for the image
    to finish loading before continuing execution. So what happens if you try to use
    a texture before it's been populated with image data? Your scene will still render,
    but any texture values you sample will be black.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式加载图像时，有一个小问题。图像加载是**异步的**，这意味着您的程序不会停止等待图像加载完成后再继续执行。那么，如果在图像数据尚未填充之前尝试使用纹理会发生什么？您的场景仍然会渲染，但您采样到的任何纹理值都将为黑色。
- en: 'In short, creating textures follows the same pattern as using buffers. For
    every texture we create, we want to do the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，创建纹理遵循与使用缓冲区相同的模式。对于每个我们创建的纹理，我们希望执行以下操作：
- en: Create a new texture
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的纹理
- en: Bind it to make it the current texture
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定它以使其成为当前纹理
- en: Pass the texture contents, typically from an image
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递纹理内容，通常是来自图像
- en: Set the filter mode or other texture parameters
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置过滤器模式或其他纹理参数
- en: Unbind the texture
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解绑纹理
- en: 'If we reach a point where we no longer need a texture, we can remove it and
    free up the associated memory by using `deleteTexture`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们达到不再需要纹理的点，我们可以通过使用`deleteTexture`来删除它并释放相关的内存：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After this, the texture is no longer valid. Any attempt to use it will react
    as though `null` has been passed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，纹理就不再有效。任何尝试使用它的操作都将像传递了`null`一样响应。
- en: Using Texture Coordinates
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理坐标
- en: Before we apply our texture to our surface, we need to figure out which part
    of the texture maps onto which part of the surface. We do this through another
    vertex attribute known as **texture coordinates**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将纹理应用到表面之前，我们需要确定纹理的哪一部分映射到表面的哪一部分。我们通过另一个称为**纹理坐标**的顶点属性来完成这项工作。
- en: 'Texture coordinates are two-element float vectors that describe a location
    on the texture that coincides with that vertex. You may think that it would be
    most natural to have this vector be an actual pixel location on the image; instead,
    WebGL forces all of the texture coordinates into a `0` to `1` range, where `(0,
    0)` represents the top left-hand side corner of the texture and `(1, 1)` represents
    the bottom right-hand side corner, as shown in the following image:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标是描述与该顶点相对应的纹理位置的二维浮点向量。您可能会认为这个向量应该是图像上的实际像素位置；相反，WebGL将所有纹理坐标强制转换为`0`到`1`的范围，其中`(0,
    0)`代表纹理的左上角，`(1, 1)`代表纹理的右下角，如下面的图像所示：
- en: '![](img/6b0f89d4-52ad-43fe-9ae8-d40bf5cbd3f0.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b0f89d4-52ad-43fe-9ae8-d40bf5cbd3f0.png)'
- en: This means that, in order to map a vertex to the center of any texture, you
    would give it a texture coordinate of `(0.5, 0.5)`. This coordinate system holds
    true even for rectangular textures.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，为了将顶点映射到任何纹理的中心，你需要给它一个纹理坐标 `(0.5, 0.5)`。这个坐标系对矩形纹理同样适用。
- en: This may seem strange at first; after all, it's easier to determine the pixel
    coordinates of a particular point than the percentage of an image's height and
    width of the point's location. That said, there is a benefit to the coordinate
    system that WebGL uses.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这一开始可能看起来有些奇怪；毕竟，确定特定点的像素坐标比确定图像高度和宽度中点的百分比要容易。话虽如此，WebGL 使用的坐标系确实有其好处。
- en: For example, we could build a WebGL application comprised of high resolution
    textures. Then, at some later point, we will receive feedback that the textures
    are taking too long to load or the application is causing devices to render slowly.
    As a result, we may decide to offer a lower resolution texture option for these
    situations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以构建一个由高分辨率纹理组成的 WebGL 应用程序。然后，在某个后续时刻，我们可能会收到反馈，指出纹理加载时间过长或应用程序导致设备渲染缓慢。因此，我们可能会决定为这些情况提供较低分辨率的纹理选项。
- en: If your texture coordinates were defined in terms of pixels, you would now have
    to modify every mesh used by your application to ensure that the texture coordinates
    match up to the new, smaller textures correctly. However, when using WebGL's normalized
    `0` to `1` coordinate range, the smaller textures can use the exact same coordinates
    as the larger ones and still display correctly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的纹理坐标是以像素为单位的，你现在必须修改应用程序中使用的每个网格，以确保纹理坐标正确地匹配到新的、较小的纹理。然而，当使用 WebGL 的归一化
    `0` 到 `1` 坐标范围时，较小的纹理可以使用与较大纹理完全相同的坐标，并且仍然可以正确显示。
- en: Figuring out texture coordinates for your mesh is often a tricky part of creating
    3D resources, especially with complex meshes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 确定网格的纹理坐标通常是创建 3D 资源的一个棘手部分，尤其是对于复杂的网格。
- en: Polygon Mesh
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形网格
- en: A polygon **mesh** is a collection of vertices, edges, and faces that defines
    the shape of a polyhedral object in 3D computer graphics and solid modeling.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形网格是一个顶点、边和面的集合，它定义了 3D 计算机图形和实体建模中多面体对象的形状。
- en: Fortunately, most 3D modeling tools come with excellent utilities for laying
    out textures and generating texture coordinates—this process is called **unwrapping**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数 3D 建模工具都配备了出色的纹理布局和纹理坐标生成工具——这个过程被称为**展开**。
- en: Texture Coordinates
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标
- en: Just as vertex position components are commonly represented with `(x, y, z)`,
    texture coordinates also have a common symbolic representation. Unfortunately,
    it's not consistent across all 3D software applications. OpenGL and WebGL refer
    to these coordinates as `s` and `t` for the `x` and `y` components, respectively.
    However, DirectX and many popular modeling packages refer to them as `u` and `v`.
    As a result, you'll often see people referring to texture coordinates as "UVs"
    and unwrapping as "UV Mapping."
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如顶点位置组件通常用 `(x, y, z)` 表示一样，纹理坐标也有一个常见的符号表示。不幸的是，这种表示在所有 3D 软件应用中并不一致。OpenGL
    和 WebGL 分别将这些坐标称为 `s` 和 `t`，分别对应 `x` 和 `y` 组件。然而，DirectX 和许多流行的建模软件包将它们称为 `u`
    和 `v`。因此，你经常会看到人们将纹理坐标称为“UVs”，将展开称为“UV 映射”。
- en: To be consistent with WebGL's usage, we will use `st` for the remainder of this
    book.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 WebGL 的使用保持一致，我们将在这本书的剩余部分使用 `st`。
- en: Using Textures in a Shader
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在着色器中使用纹理
- en: 'Texture coordinates are exposed to the shader code in the same way that they
    are with any other vertex attribute. We''ll want to include a two-element vector
    attribute in our vertex shader that will map to our texture coordinates:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标以与任何其他顶点属性相同的方式暴露给着色器代码。我们希望在顶点着色器中包含一个两个元素的向量属性，它将映射到我们的纹理坐标：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Additionally, we will also want to add a new uniform to the fragment shader
    that uses a type we haven''t seen before: `sampler2D`. The `sampler2D` uniform
    is what allows us to access the texture data in the shader:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想在片段着色器中添加一个新的统一变量，使用我们之前未见过的类型：`sampler2D`。`sampler2D` 统一变量允许我们在着色器中访问纹理数据：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the past, when we''ve used uniforms, we set them to the value that we want
    them to be in the shader, such as a light color. **Samplers** work a bit differently.
    The following code shows how to associate a texture with a specific sampler uniform:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当我们使用统一变量时，我们会将其设置为在着色器中想要它们具有的值，例如光颜色。**采样器**的工作方式略有不同。以下代码显示了如何将纹理与特定的采样器统一变量关联起来：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, what's going on here? First off, we are changing the active texture index
    with `gl.activeTexture`. WebGL supports the use of multiple textures at once (which
    we'll talk about later in this chapter), so it's good practice to specify which
    texture index we're working with, even though it won't change for the duration
    of this program. Next, we bind the texture we wish to use, which associates it
    with the currently active texture, `TEXTURE0`. Finally, we tell the sampler uniform
    which texture it should be associated with given the texture unit provided via
    `gl.uniform1i`. Here, we give it `0` to indicate that the sampler should use `TEXTURE0`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？首先，我们使用`gl.activeTexture`更改活动纹理索引。WebGL支持同时使用多个纹理（我们将在本章后面讨论），因此指定我们正在使用的纹理索引是一个好习惯，尽管在本程序期间它不会改变。接下来，我们绑定我们希望使用的纹理，将其与当前活动纹理`TEXTURE0`关联。最后，我们通过`gl.uniform1i`提供的纹理单元告诉采样器统一变量它应该与哪个纹理关联。在这里，我们给出`0`以指示采样器应使用`TEXTURE0`。
- en: 'We are now ready to use our texture in the fragment shader! The simplest way
    to use a texture is to return its value as the fragment color, as shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的纹理在片段着色器中了！使用纹理的最简单方法是将它的值作为片段颜色返回，如下所示：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`texture` takes in the sampler uniform we wish to query and the coordinates
    to lookup, and returns the color of the texture image at those coordinates as
    `vec4`. If the image has no alpha channel, `vec4` will still be returned with
    the alpha component always set to `1`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`texture`函数接受我们希望查询的采样器统一变量和查找的坐标，并返回在那些坐标处的纹理图像颜色作为`vec4`。如果图像没有alpha通道，`vec4`仍然会被返回，其alpha组件始终设置为`1`。'
- en: 'Time for Action: Texturing the Cube'
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践：给立方体贴图
- en: 'Let''s cover an example where we add a texture map to a cube:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，我们将纹理映射添加到一个立方体上：
- en: 'Open the `ch07_01_textured-cube.html` file in your editor. If you open it in
    a browser, you should see a scene that looks like the following screenshot:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开`ch07_01_textured-cube.html`文件。如果在浏览器中打开，您应该会看到一个类似于以下截图的场景：
- en: '![](img/1e1e7440-0416-4246-a033-d81b9693dcfe.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e1e7440-0416-4246-a033-d81b9693dcfe.png)'
- en: 'Let''s load the texture image. At the top of the script block, add a new variable
    to hold the texture:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载纹理图像。在脚本块的顶部，添加一个新的变量来保存纹理：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the bottom of the `configure` function, add the following code, which creates
    the texture object, loads an image, and sets the image as the texture data. In
    this case, we''ll use a PNG image with the WebGL logo as our texture:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`configure`函数的底部，添加以下代码，它创建纹理对象，加载图像，并将图像设置为纹理数据。在这种情况下，我们将使用带有WebGL标志的PNG图像作为我们的纹理：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `render` function after the `vertexColors` binding block, add the following
    code to bind the texture to the shader sampler uniform:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`函数中的`vertexColors`绑定块之后，添加以下代码以将纹理绑定到着色器采样器统一变量：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we need to add the texture-specific code to the shader. In the vertex shader,
    add the following attribute and varying to the variable declarations:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将纹理特定的代码添加到着色器中。在顶点着色器中，将以下属性和变量添加到变量声明中：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At the end of the vertex shader''s `main` function, make sure to copy the texture
    coordinate attribute into the varying so that the fragment shader can access it:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器的`main`函数的末尾，确保将纹理坐标属性复制到变量中，以便片段着色器可以访问它：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The fragment shader also needs two new variable declarations—the sampler uniform
    and the varying from the vertex shader:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器还需要两个新的变量声明——采样器统一变量和来自顶点着色器的变量：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We must also remember to add `aVertexTextureCoords` to the `attributes` list
    and `uSampler` to the `uniforms` list in the `configure` function so that the
    new variables can be accessed from our JavaScript binding code.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须记住在`configure`函数中向`attributes`列表添加`aVertexTextureCoords`并将`uSampler`添加到`uniforms`列表中，以便可以从我们的JavaScript绑定代码访问新变量。
- en: 'To access the texture color, we call `texture` with the sampler and the texture
    coordinates. Since we want the textured surface to retain the lighting, we''ll
    multiply the lighting color and the texture color together, giving us the following
    line to calculate the fragment color:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问纹理颜色，我们调用`texture`函数，传入采样器和纹理坐标。由于我们希望纹理表面保留光照，我们将光照颜色和纹理颜色相乘，得到以下行来计算片段颜色：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open the file now in browser and you should see a scene like this one:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在浏览器中打开文件，您应该会看到这样的场景：
- en: '![](img/90ee294d-de73-4d47-a9a7-55e606ec2b75.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90ee294d-de73-4d47-a9a7-55e606ec2b75.png)'
- en: If you're having trouble with a particular step and would like a reference,
    the completed code is available in `ch07_02_textured-cube-final.html`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你遇到某个步骤有困难并且需要参考，完整的代码可以在 `ch07_02_textured-cube-final.html` 中找到。
- en: '***What just happened?***'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We've just loaded a texture from a file, uploaded it to the GPU, rendered it
    on the cube geometry, and blended it with the lighting information that was already
    being calculated.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚从文件中加载了一个纹理，将其上传到 GPU，并在立方体几何体上渲染它，并将其与已经计算出的光照信息混合。
- en: The remaining examples in this chapter will omit the calculation of lighting
    for simplicity and clarity, but lighting could be applied to all of them if desired.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余的示例将为了简洁和清晰省略光照计算，但如果需要，可以应用到所有这些示例中。
- en: 'Have a Go: Try a Different Texture'
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试不同的纹理
- en: Try one of your own images to see if you can get it to display as the texture.
    What happens if you provide a rectangular image rather than a square one?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你自己的图片，看看你是否能将其显示为纹理。如果你提供一个矩形图像而不是正方形图像会发生什么？
- en: Texture Filter Modes
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理过滤模式
- en: So far, we've seen how textures can be used to sample image data in a fragment
    shader, but we've only used them in a limited context. Some interesting issues
    arise when you start to investigate textures more closely.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在片段着色器中使用纹理来采样图像数据，但我们只在一个有限的上下文中使用了它们。当你开始更仔细地研究纹理时，会出现一些有趣的问题。
- en: 'For example, if you were to zoom in on the cube from the previous demo, you
    would see that the texture begins to alias:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你从上一个演示中放大立方体，你会看到纹理开始出现走样：
- en: '![](img/c17e305b-65e0-4d6d-b7e3-fb60575854cb.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c17e305b-65e0-4d6d-b7e3-fb60575854cb.png)'
- en: As we zoom in, we can see that jagged edges develop around the WebGL logo. Similar
    problems become apparent when the texture is very small on the screen. Isolated
    to a single object, such artifacts are easy to overlook, but they can become very
    distracting in complex scenes. Why do we see these artifacts in the first place?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们放大时，可以看到 WebGL 标志周围出现了锯齿边缘。当纹理在屏幕上非常小的时候，类似的问题也会变得明显。将这些瑕疵孤立于单个对象中，它们很容易被忽视，但在复杂场景中可能会非常分散注意力。我们最初为什么能看到这些瑕疵？
- en: 'From the previous chapter, you should remember how vertex colors are interpolated
    so that the fragment shader is provided with a smooth gradient of color. Texture
    coordinates are interpolated in the exact same way, with the resulting coordinates
    being provided to the fragment shader and used to sample color values from the
    texture. In a perfect situation, the texture would display at a `1:1` ratio on
    screen, meaning each pixel of the texture (known as **texels**) would take up
    exactly one pixel on screen. In this scenario, there would be no artifacts:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，你应该记得顶点颜色是如何插值，以便片段着色器提供平滑的颜色渐变。纹理坐标以完全相同的方式进行插值，结果坐标被提供给片段着色器，并用于从纹理中采样颜色值。在理想情况下，纹理会在屏幕上以
    `1:1` 的比例显示，这意味着纹理的每个像素（称为 **纹理元素**）将占据屏幕上的一个像素。在这种情况下，将不会有任何瑕疵：
- en: '![](img/8311bff0-9b3e-40c9-8739-bc71b889e018.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8311bff0-9b3e-40c9-8739-bc71b889e018.png)'
- en: Pixel Versus TexelSometimes, the pixels in a texture are called **texels**.
    Pixel is short for Picture Element. Texel is short for Texture Element.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 像素与纹理元素有时，纹理中的像素被称为 **纹理元素**。像素是图像元素的简称。纹理元素是纹理元素的简称。
- en: 'The reality of 3D applications, however, is that textures are almost never
    displayed at their native resolution. We refer to these scenarios as **magnification**
    and **minification**, depending on whether the texture has a lower or higher resolution
    than the screen space it occupies:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，3D 应用程序的现实情况是，纹理几乎从不以它们的原始分辨率显示。我们根据纹理的分辨率是否低于或高于它占据的屏幕空间将其称为 **放大** 和 **缩小**：
- en: '![](img/366bbeed-d14a-42df-86cf-27667bf130bb.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/366bbeed-d14a-42df-86cf-27667bf130bb.png)'
- en: 'When a texture is magnified or minified, there can be some ambiguity about
    what color the texture sampler should return. For example, consider the following
    diagram of sample points against a slightly magnified texture:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当纹理被放大或缩小的时候，可能会对纹理采样器应该返回什么颜色存在一些模糊性。例如，考虑以下样本点与略微放大的纹理的示意图：
- en: '![](img/a672fc80-bf56-4470-a439-6bf6d8ef388a.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a672fc80-bf56-4470-a439-6bf6d8ef388a.png)'
- en: It's pretty obvious what color you would want the top left-hand side or middle
    sample points to return, but what about those texels in the middle? What color
    should they return? The answer is determined by your filter mode. Texture filtering
    allows us to control how textures are sampled and achieve the look we want.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你想要左上角或中间的样本点返回什么颜色，但中间的这些 texel 呢？它们应该返回什么颜色？答案取决于你的过滤器模式。纹理过滤允许我们控制纹理的采样方式，并达到我们想要的外观。
- en: 'Setting a texture''s filter mode is very straightforward, and we already saw
    an example of how it works when we talked about creating textures:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 设置纹理的过滤器模式非常直接，当我们讨论创建纹理时已经看到了一个例子：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As with most WebGL calls, `texParameteri` operates on the currently bound texture,
    and must be set for every texture you create. This also means that different textures
    can have different filters, which can be useful when trying to achieve specific
    effects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 WebGL 调用一样，`texParameteri` 操作于当前绑定的纹理，并且必须为每个创建的纹理设置。这也意味着不同的纹理可以有不同的过滤器，这在尝试实现特定效果时可能很有用。
- en: In this example, we are setting both the magnification filter (`TEXTURE_MAG_FILTER`)
    and the minification filter (`TEXTURE_MIN_FILTER`) to `NEAREST`. There are several
    modes that can be passed for the third parameter, and the best way to understand
    the visual impact they have on a scene is to see the various filter modes in action.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将放大过滤器（`TEXTURE_MAG_FILTER`）和缩小过滤器（`TEXTURE_MIN_FILTER`）都设置为 `NEAREST`。对于第三个参数可以传递几种模式，了解它们对场景产生的视觉影响最好的方式是看到各种过滤器模式的效果。
- en: Let's look at a demonstration of the filters in your browser while we discuss
    different parameters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论不同的参数时，让我们在你的浏览器中查看过滤器的一个演示。
- en: 'Time for Action: Trying Different Filter Modes'
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：尝试不同的过滤器模式
- en: 'Let''s cover an example of seeing different filter modes in action:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，看看不同的过滤器模式是如何工作的：
- en: 'Open the `ch07_03_texture-filters.html` file using your browser:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的浏览器打开 `ch07_03_texture-filters.html` 文件：
- en: '![](img/73bca57f-91a9-4594-8999-dfcb0ea4ff29.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73bca57f-91a9-4594-8999-dfcb0ea4ff29.png)'
- en: The controls include a slider to adjust the distance of the box from the viewer,
    while the buttons modify the magnification and minification filters.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制包括一个滑块来调整盒子与观察者之间的距离，而按钮则修改放大和缩小过滤器。
- en: Experiment with different modes to observe the effect they have on the texture.
    Magnification filters take effect when the cube's textures are being rendered
    larger than their source image size; minification filters when it is further away.
    Be sure to rotate the cube as well to observe what the texture looks like when
    viewed at an angle with each mode.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的模式来观察它们对纹理产生的影响。放大过滤器在立方体的纹理渲染大于其源图像大小时生效；缩小过滤器当它更远时生效。务必旋转立方体，以观察以每个模式从角度观看纹理时的样子。
- en: '***What just happened?***'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We learned how to create and load textures into our 3D scene. We also covered
    various techniques for mapping textures onto objects, along with an interactive
    example to demonstrate these capabilities.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何创建和加载纹理到我们的 3D 场景中。我们还介绍了将纹理映射到对象上的各种技术，以及一个交互式示例来展示这些功能。
- en: Let's look at each of the filter modes in depth and discuss how they work.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨每种过滤器模式，并讨论它们是如何工作的。
- en: NEAREST
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEAREST
- en: 'Textures using the `NEAREST` filter always return the color of the texel whose
    center is nearest to the sample point. Using this mode, textures will look blocky
    and pixilated when viewed up close, which can be useful for creating "retro" graphics.
    `NEAREST` can be used for both the `MIN` and `MAG` filters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NEAREST` 过滤器的纹理始终返回最近的样本点的 texel 的颜色。使用此模式，纹理在近距离观看时看起来会显得块状和像素化，这可以用于创建“复古”图形。`NEAREST`
    可以用于 `MIN` 和 `MAG` 过滤器：
- en: '![](img/0d78ee73-5df7-4bb9-bfc5-be418fd971f1.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d78ee73-5df7-4bb9-bfc5-be418fd971f1.png)'
- en: LINEAR
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINEAR
- en: 'The `LINEAR` filter returns the weighted average of the four pixels whose centers
    are nearest to the sample point. This provides a smooth blending of texel colors
    when looking at textures close up—it''s generally the more desirable effect. This
    does mean that the graphics hardware has to read four times as many pixels per
    fragment there is, so naturally, it''s slower than `NEAREST`, but modern graphics
    hardware is so fast that this is almost never an issue. `LINEAR` can be used for
    both the `MIN` and `MAG` filters. This filtering mode is also known as **bilinear
    filtering**:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`LINEAR` 过滤返回与采样点最近的四个像素的加权平均值。当近距离观察纹理时，这提供了平滑的纹理元素颜色混合——这通常是更期望的效果。这也意味着图形硬件必须读取每个片段的四倍像素，因此，它比
    `NEAREST` 慢，但现代图形硬件如此之快，这几乎从未成为问题。`LINEAR` 可以用于 `MIN` 和 `MAG` 过滤器。这种过滤模式也称为 **双线性过滤**：'
- en: '![](img/b70f249f-fa09-400f-985c-8b146c6b0a04.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b70f249f-fa09-400f-985c-8b146c6b0a04.png)'
- en: 'Returning to the close-up example image we showed earlier in this chapter,
    had we used `LINEAR` filtering, it would have looked like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们在本章前面展示的近距离示例图像，如果我们使用了 `LINEAR` 过滤，它看起来会是这样：
- en: '![](img/89d602f9-f910-460a-bf2b-6534964c419d.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89d602f9-f910-460a-bf2b-6534964c419d.png)'
- en: Mipmapping
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mipmapping
- en: 'Before we can discuss the remaining filter modes that are only applicable to
    `TEXTURE_MIN_FILTER`, we need to introduce a new concept: **mipmapping**.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论仅适用于 `TEXTURE_MIN_FILTER` 的剩余过滤模式之前，我们需要介绍一个新概念：**Mipmapping**。
- en: 'A problem arises when sampling minified textures. In cases where we use `LINEAR`
    filtering and the sample points are so far apart, we can completely miss some
    details of the texture. As the view shifts, the texture fragments that we miss
    change, which results in a shimmering effect. You can see this in action by setting
    the `MIN` filter in the demo to `NEAREST` or `LINEAR`, zooming out, and rotating
    the cube:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当采样缩小后的纹理时会出现问题。在使用 `LINEAR` 过滤且采样点相距甚远的情况下，我们可能会完全错过纹理的一些细节。随着视角的变化，我们错过的纹理碎片也会变化，这会导致闪烁效果。你可以在演示中将
    `MIN` 过滤设置为 `NEAREST` 或 `LINEAR`，然后缩小并旋转立方体来观察这一效果：
- en: '![](img/b8233e1c-b064-4437-885a-e2e089fa7200.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8233e1c-b064-4437-885a-e2e089fa7200.png)'
- en: To avoid this, graphics cards can utilize a **mipmap chain**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，显卡可以利用 **Mipmap 链**。
- en: 'Mipmaps are scaled-down copies of a texture, with each copy being exactly half
    the size of the previous one. If you were to show a texture and all of its mipmaps
    in a row, it would look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Mipmaps 是纹理的缩小副本，每个副本的大小正好是前一个副本的一半。如果你将一个纹理及其所有 Mipmaps 按顺序展示，它看起来会是这样：
- en: '![](img/79e5c391-6b74-4fac-a30b-3c0c86d16d85.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79e5c391-6b74-4fac-a30b-3c0c86d16d85.png)'
- en: The advantage is that when rendering, the graphics hardware can choose the copy
    of the texture that most closely matches the size of the texture on screen and
    samples from it instead. This reduces the number of skipped texels and the jittery
    artifacts that accompany them. However, mipmapping is only used if you use the
    appropriate texture filters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是，在渲染时，图形硬件可以选择与屏幕上纹理大小最接近的纹理副本，并从中采样。这减少了跳过的纹理元素数量以及伴随它们的抖动伪影。然而，只有在使用适当的纹理过滤器时才会使用
    Mipmapping。
- en: NEAREST_MIPMAP_NEAREST
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEAREST_MIPMAP_NEAREST
- en: This filter will select the mipmap that most closely matches the size of the
    texture on screen and samples from it using the `NEAREST` algorithm.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器将选择与屏幕上纹理大小最接近的 Mipmap，并使用 `NEAREST` 算法从中采样。
- en: LINEAR_MIPMAP_NEAREST
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINEAR_MIPMAP_NEAREST
- en: This filter selects the mipmap that most closely matches the size of the texture
    on screen and samples from it using the `LINEAR` algorithm.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器选择与屏幕上纹理大小最接近的 Mipmap，并使用 `LINEAR` 算法从中采样。
- en: NEAREST_MIPMAP_LINEAR
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEAREST_MIPMAP_LINEAR
- en: This filter selects two mipmaps that most closely match the size of the texture
    on screen and samples from both of them by using the `NEAREST` algorithm. The
    color returned is a weighted average of those two samples.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器选择两个与屏幕上纹理大小最接近的 Mipmap，并使用 `NEAREST` 算法从这两个 Mipmap 中采样。返回的颜色是这两个样本的加权平均值。
- en: LINEAR_MIPMAP_LINEAR
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINEAR_MIPMAP_LINEAR
- en: 'This filter selects two mipmaps that most closely match the size of the texture
    on screen and samples from both of them using the `LINEAR` algorithm. The color
    returned is a weighted average of those two samples. This mode is also known as
    **trilinear filtering**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器选择两个与屏幕上纹理大小最接近的 Mipmap，并使用 `LINEAR` 算法从这两个 Mipmap 中采样。返回的颜色是这两个样本的加权平均值。这种模式也称为
    **三线性过滤**：
- en: '![](img/be2654c4-556f-41c8-9e62-6942d710fdb5.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be2654c4-556f-41c8-9e62-6942d710fdb5.png)'
- en: Of the `*_MIPMAP_*` filter modes, `NEAREST_MIPMAP_NEAREST` is the fastest and
    lowest quality while `LINEAR_MIPMAP_LINEAR` will provide the best quality but
    the lowest performance. The other two modes sit somewhere in between on the quality/speed
    scale. In most cases, the performance trade-off will be small enough that it's
    common to use `LINEAR_MIPMAP_LINEAR`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`*_MIPMAP_*`过滤模式中，`NEAREST_MIPMAP_NEAREST`是最快且质量最低的，而`LINEAR_MIPMAP_LINEAR`将提供最佳质量但性能最低。其他两种模式在质量/速度尺度上介于两者之间。在大多数情况下，性能权衡将足够小，以至于通常使用`LINEAR_MIPMAP_LINEAR`。
- en: Generating Mipmaps
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成米普图
- en: 'WebGL doesn''t automatically create mipmaps for every texture; so, if we want
    to use one of the `*_MIPMAP_*` filter modes, we have to create the mipmaps for
    the texture first. Fortunately, all this takes is a single function call:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL不会自动为每个纹理创建米普图；因此，如果我们想使用`*_MIPMAP_*`过滤模式之一，我们必须首先为纹理创建米普图。幸运的是，所有这些只需要一个函数调用：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`generateMipmap` must be called after the texture has been populated with `texImage2D`
    and will automatically create a full mipmap chain for the image.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateMipmap`必须在用`texImage2D`填充纹理之后调用，并将自动为图像创建完整的米普图链。'
- en: 'Alternatively, if you want to provide the mipmaps manually, you can always
    specify that you are providing a mipmap level rather than the source texture when
    calling `texImage2D` by passing a number other than `0` as the second parameter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想手动提供米普图，你可以在调用`texImage2D`时指定你提供的是米普图级别而不是源纹理，通过传递除`0`以外的数字作为第二个参数：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we're manually creating the first mipmap level, which is half the height
    and width of the normal texture. The second level would be a quarter of the dimensions
    of the normal texture, and so on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在手动创建第一个米普图级别，其高度和宽度是正常纹理的一半。第二个级别将是正常纹理尺寸的四分之一，以此类推。
- en: This can be useful for some advanced effects or when using compressed textures
    that cannot be used with `generateMipmap`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于一些高级效果或使用不能与`generateMipmap`一起使用的压缩纹理时可能很有用。
- en: If you are familiar with WebGL 1, you'll remember its limit that textures with
    dimensions that were not a power of two (**not** `1`, `2`, `4`, `8`, `16`, `32`,
    `64`, `128`, `256`, `512`, and so on) could not use mips and could not repeat.
    In WebGL 2, these restrictions are gone.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉WebGL 1，你会记得它的限制，即维度不是2的幂（**不是** `1`、`2`、`4`、`8`、`16`、`32`、`64`、`128`、`256`、`512`等等）的纹理不能使用米普图，也不能重复。在WebGL
    2中，这些限制已经不存在了。
- en: Non Power of Two (NPOT)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 非二进制幂（NPOT）
- en: In order to use mipmaps with a texture in WebGL 1, mipmaps need to satisfy some
    dimension restrictions. Namely, the texture width and height must both be **Powers
    of Two** (**POT**). That is, the width and height can be `pow(2, n)` pixels, where
    `n` is any integer. Examples are `16px`, `32px`, `64px`, `128px`, `256px`, `512px`,
    `1024px`, and so on. Also, note that the width and height do not have to be the
    same as long as both are powers of two. For example, a `512x128` texture can still
    be mipmapped. NPOT textures can still be used with WebGL 1, but are restricted
    to only using `NEAREST` and `LINEAR` filters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在WebGL 1中使用米普图，米普图需要满足一些维度限制。具体来说，纹理的宽度和高度都必须是**2的幂**（**POT**）。也就是说，宽度和高度可以是`pow(2,
    n)`像素，其中`n`是任何整数。例如，`16px`、`32px`、`64px`、`128px`、`256px`、`512px`、`1024px`等等。此外，只要两者都是2的幂，宽度和高度不必相同。例如，一个`512x128`的纹理仍然可以进行米普图处理。NPOT纹理仍然可以与WebGL
    1一起使用，但仅限于使用`NEAREST`和`LINEAR`过滤器。
- en: Why, then, is power restricted for two textures? Recall that the mipmap chain
    is made up of textures whose sizes are half the previous level. When the dimensions
    are powers of two, this will always produce integer numbers, which means that
    the number of pixels never needs to be rounded off, and hence produces clean and
    fast scaling algorithms.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么对两种纹理进行功率限制呢？回想一下，米普链是由尺寸是前一个级别一半的纹理组成的。当维度是2的幂时，这总会产生整数，这意味着像素数永远不需要四舍五入，因此产生干净且快速的缩放算法。
- en: For all of the texture code samples after this point, we'll be using a simple
    texture class that cleanly wraps up the texture's download, creation, and setup.
    Any textures created with the class will automatically have mipmaps generated
    for them and be set to use `LINEAR` for the magnification filter and `LINEAR_MIPMAP_LINEAR`
    for the minification filter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从此点之后的所有纹理代码示例中，我们将使用一个简单的纹理类，该类可以干净地封装纹理的下载、创建和设置。使用该类创建的任何纹理都将自动为其生成米普图，并设置为使用`LINEAR`进行放大过滤器，以及使用`LINEAR_MIPMAP_LINEAR`进行缩小过滤器。
- en: Texture Wrapping
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理包裹
- en: In the previous section, we used `texParameteri` to set the filter mode for
    textures but, as you might expect from the generic function name, that's not all
    it can do. Another texture behavior that we can manipulate is the **texture wrapping**
    mode.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们使用了 `texParameteri` 来设置纹理的过滤器模式，但正如您从通用函数名称中预期的那样，这并不是它能做的全部。我们可以操纵的另一种纹理行为是**纹理包裹**模式。
- en: Texture wrapping describes the behavior of the sampler when the texture coordinates
    fall outside the range of `0` and `1`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理包裹描述了当纹理坐标超出 `0` 和 `1` 范围时采样器的行为。
- en: 'The wrapping mode can be set independently for both the `S` and `T` coordinates,
    so changing the wrapping mode typically takes two calls:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 包裹模式可以独立地为 `S` 和 `T` 坐标设置，因此更改包裹模式通常需要两次调用：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we're setting both the `S` and `T` wrapping modes for the currently bound
    texture to `CLAMP_TO_EDGE`, the effects of which we will see in a moment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将当前绑定的纹理的 `S` 和 `T` 包裹模式都设置为 `CLAMP_TO_EDGE`，其效果我们将在下面看到。
- en: As with texture filters, it's easiest to demonstrate the effects of the different
    wrapping modes via an example and then discuss the results. Please open your browser
    again for another demonstration.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与纹理过滤器一样，通过一个例子演示不同包裹模式的效果，然后讨论结果是最容易的。请再次打开您的浏览器进行另一个演示。
- en: 'Time for Action: Trying Different Wrap Modes'
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：尝试不同的包裹模式
- en: 'Let''s cover an example of seeing different wrap modes in action:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看不同的包裹模式是如何起作用的：
- en: 'Open the `ch07_04_texture-wrapping.html` file using your browser:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的浏览器打开 `ch07_04_texture-wrapping.html` 文件：
- en: '![](img/22809f44-7d56-4dda-97bd-144a8d886e3c.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22809f44-7d56-4dda-97bd-144a8d886e3c.png)'
- en: The cube shown in the preceding screenshot has texture coordinates that range
    from `-1` to `2`, which forces the texture wrapping mode to be used for everything
    but the center tile of the texture.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中显示的立方体具有从 `-1` 到 `2` 的纹理坐标，这迫使纹理包裹模式应用于纹理的中心瓷砖以外的所有内容。
- en: Experiment with the controls to see the effect that different wrap modes have
    on the texture.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试调整控件以查看不同的包裹模式对纹理的影响。
- en: '***What just happened?***'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We experimented with various approaches to texture interpolation and mipmapping
    techniques, along with interactive examples demonstrating these capabilities.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了各种纹理插值和米普映射技术的方法，以及展示这些功能的交互式示例。
- en: Now, let's investigate each of the wrap modes and discuss how they function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调查每种包裹模式，并讨论它们是如何工作的。
- en: CLAMP_TO_EDGE
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLAMP_TO_EDGE
- en: 'This wrap mode rounds any texture coordinates greater than `1` down to `1`;
    any coordinates lower than `0` are rounded up to `0`, "clamping" the values to
    the `0`-`1` range. Visually, this has the effect of repeating the texture''s border
    pixels indefinitely once the coordinates go out of the `0`-`1` range. Note that
    this is the only wrapping mode that''s compatible with **NPOT** textures:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种包裹模式将任何大于 `1` 的纹理坐标向下舍入到 `1`；任何小于 `0` 的坐标向上舍入到 `0`，将值“夹”在 `0`-`1` 范围内。从视觉上看，这会在坐标超出
    `0`-`1` 范围后无限期地重复纹理的边界像素。请注意，这是唯一与**非幂次方**纹理兼容的包裹模式：
- en: '![](img/7cdc7623-4392-4973-8f88-252489ad40a6.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cdc7623-4392-4973-8f88-252489ad40a6.png)'
- en: REPEAT
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPEAT
- en: 'This is the default wrap mode, and the one that you''ll probably use most often.
    In mathematical terms, this wrap mode simply ignores the integer part of the texture
    coordinate. This creates the visual effect of the texture repeating as you move
    outside of the `0`-`1` range. This is a useful effect for displaying surfaces
    that have a natural repeating pattern to them, such as a tile floor or brick wall:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认的包裹模式，也是您可能最常使用的模式。用数学术语来说，这种包裹模式简单地忽略了纹理坐标的整数部分。这会产生纹理在您移动到 `0`-`1` 范围之外时重复的视觉效果。这对于显示具有自然重复图案的表面非常有用，例如瓷砖地板或砖墙：
- en: '![](img/1339edfd-2dde-4f8d-a0a1-61d27f982e5d.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1339edfd-2dde-4f8d-a0a1-61d27f982e5d.png)'
- en: MIRRORED_REPEAT
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MIRRORED_REPEAT
- en: 'The algorithm for this mode is a little more complicated. If the coordinate''s
    integer portion is even, the texture coordinates will be the same as they were
    with `REPEAT`. If the integer portion of the coordinate is odd, the resulting
    coordinate is `1` minus the fractional portion of the coordinate. This results
    in a texture that "flip-flops" as it repeats, with every other repetition being
    a mirror image:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的算法稍微复杂一些。如果坐标的整数部分是偶数，纹理坐标将与使用 `REPEAT` 时的相同。如果坐标的整数部分是奇数，则结果坐标是坐标的分数部分的
    `1` 减去。这导致纹理在重复时“翻转”，每隔一次重复都是镜像图像：
- en: '![](img/12cd5797-553d-4893-9d29-e4d8e8c4cdab.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12cd5797-553d-4893-9d29-e4d8e8c4cdab.png)'
- en: 'As we mentioned earlier, these modes can be mixed and matched. For example,
    consider the following code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这些模式可以混合使用。例如，考虑以下代码片段：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This would produce the following effect on the texture from the sample:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对样本纹理产生以下效果：
- en: '![](img/f3dbeeb7-9e96-431c-8f4b-194618d69cbc.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3dbeeb7-9e96-431c-8f4b-194618d69cbc.png)'
- en: Samplers Versus Textures
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Samplers 与 Textures 的比较
- en: Wondering why the shader uniforms are called *samplers* instead of *textures*?
    A texture is just the image data stored on the GPU, while a sampler contains all
    of the information about how to look up texture information, including filter
    and wrap modes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 惊奇地想知道为什么着色器统一变量被称为 *samplers* 而不是 *textures* 吗？纹理只是存储在 GPU 上的图像数据，而 sampler
    包含了查找纹理信息所需的所有信息，包括过滤器和包裹模式。
- en: Using Multiple Textures
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个纹理
- en: So far, we've done all of our rendering by using a single texture. However,
    there are times when we may want to have multiple textures contribute to a fragment
    to create more complex effects. In such cases, we can use WebGL's ability to access
    multiple textures in a single draw call, commonly referred to as **multi-texturing**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直通过使用单个纹理来进行所有渲染。然而，有时我们可能希望多个纹理共同作用于一个片段以创建更复杂的效果。在这种情况下，我们可以使用 WebGL
    在单个绘制调用中访问多个纹理的能力，这通常被称为 **多纹理**。
- en: 'We briefly covered multi-texturing earlier, so let''s go back and look at it
    again. When talking about exposing a texture to a shader as a sampler uniform,
    we used the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前简要介绍了多纹理，现在让我们再次回顾一下。当我们谈论将纹理作为 sampler 统一变量暴露给着色器时，我们使用了以下代码：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first line, `gl.activeTexture`, is the key to utilizing multi-texturing.
    We use it to tell the WebGL state machine which texture we're going to use in
    subsequent texture functions. In this case, we passed `gl.TEXTURE0`, which means
    that any following texture calls (such as `gl.bindTexture`) will alter the state
    of the first texture unit. If we want to attach a different texture to the second
    texture unit, we would use `gl.TEXTURE1` instead.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，`gl.activeTexture`，是利用多纹理的关键。我们使用它来告诉 WebGL 状态机在后续的纹理函数中将使用哪个纹理。在这种情况下，我们传递了
    `gl.TEXTURE0`，这意味着任何后续的纹理调用（如 `gl.bindTexture`）都将改变第一个纹理单元的状态。如果我们想将不同的纹理附加到第二个纹理单元，我们将使用
    `gl.TEXTURE1`。
- en: 'Different devices will support different numbers of texture units, but WebGL
    specifies that compatible hardware must always support at least two texture units.
    We can find out how many texture units the current device supports with the following
    function call:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不同设备将支持不同数量的纹理单元，但 WebGL 规定兼容的硬件必须始终支持至少两个纹理单元。我们可以使用以下函数调用来找出当前设备支持多少个纹理单元：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'WebGL provides explicit enumerations for `gl.TEXTURE0` through `gl.TEXTURE31`.
    It may be more convenient to specify the texture unit programmatically or find
    a need to refer to a texture unit above `31`. In such situations, you can always
    substitute `gl.TEXTURE0 + i` for `gl.TEXTUREi`, as in the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 为 `gl.TEXTURE0` 到 `gl.TEXTURE31` 提供了显式的枚举。可能更方便的是以程序方式指定纹理单元或需要引用 `31`
    以上的纹理单元。在这种情况下，您始终可以用 `gl.TEXTURE0 + i` 替换 `gl.TEXTUREi`，如下例所示：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Accessing multiple textures in a shader is as simple as declaring multiple
    samplers:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器中访问多个纹理就像声明多个 sampler 一样简单：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When setting up your draw call, tell the shader which texture is associated
    with which sampler by providing the texture unit to `gl.uniform1i`. The code to
    bind two textures to the samplers above would look something like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置绘制调用时，通过提供纹理单元到 `gl.uniform1i` 来告诉着色器哪个纹理与哪个 sampler 相关联。将两个纹理绑定到上面 sampler
    的代码可能看起来像这样：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We now have two textures available for our fragment shader, but what do we want
    to do with them?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个纹理可供我们的片段着色器使用，但我们想对它们做什么？
- en: As an example, we're going to implement a simple multi-texture effect that layers
    another texture on top of a simple textured cube to simulate static lighting.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将实现一个简单的多纹理效果，将另一个纹理叠加到简单的纹理立方体上，以模拟静态光照。
- en: 'Time for Action: Using Multi-Texturing'
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多纹理的时间：使用多纹理
- en: 'Let''s cover an example of multi-texturing in action:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个多纹理应用的例子：
- en: Open the `ch07_05_multi-texture.html` file with your editor.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的编辑器打开`ch07_05_multi-texture.html`文件。
- en: 'At the top of the script block, add another texture variable:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本块的顶部添加另一个纹理变量：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At the bottom of the `configure` function, add the code to load the second
    texture. We''re using a class to make this process easier, so the new code is
    as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`configure`函数的底部，添加加载第二个纹理的代码。我们使用一个类来简化这个过程，所以新的代码如下：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The texture we''re using is a white radial gradient that simulates a spot light:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用的纹理是一个模拟聚光灯的白色径向渐变纹理：
- en: '![](img/0af51617-be91-4d55-9a8d-9875e6e8df98.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0af51617-be91-4d55-9a8d-9875e6e8df98.png)'
- en: 'In the `render` function, directly below the code that binds the first texture,
    add the following to expose the new texture to the shader:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`函数中，在绑定第一个纹理的代码下方，添加以下代码以将新纹理暴露给着色器：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We need to add the new sampler uniform to the fragment shader:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在片段着色器中添加新的采样器统一变量：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Don't forget to add the corresponding string to the uniforms list in the `configure`
    function.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在`configure`函数的统一变量列表中添加相应的字符串。
- en: 'We add the code to sample the new texture value and blend it with the first
    texture. Since we want the second texture to simulate a light, we multiply the
    two values together as we did with the per-vertex lighting in the first texture
    example:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了采样新纹理值并将其与第一个纹理混合的代码。由于我们希望第二个纹理模拟光，所以我们像在第一个纹理示例中的每个顶点光照一样将两个值相乘：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that we're re-using the same texture coordinate for both textures. This
    is more convenient but, if needed, a second texture coordinate attribute could
    be provided or we could calculate a new texture coordinate from the vertex position
    or some other criteria.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们正在重用相同的纹理坐标来处理两个纹理。这更方便，但如果需要，可以提供第二个纹理坐标属性，或者我们可以从顶点位置或其他标准计算一个新的纹理坐标。
- en: 'You should see a scene that looks like this when you open the file in your
    browser:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在浏览器中打开文件时，你应该看到如下场景：
- en: '![](img/3b30f924-5ce4-4574-92d2-46115915aa43.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b30f924-5ce4-4574-92d2-46115915aa43.png)'
- en: You can see the completed example in `ch07_06_multi-texture-final.html`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在`ch07_06_multi-texture-final.html`中看到完成的示例。
- en: '***What just happened?***'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We've added a second texture to the `render` call and blended it with the first
    to create a new effect, which, in this case, simulates a simple static spotlight.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`render`调用中添加了第二个纹理，并将其与第一个纹理混合，以创建一个新的效果，在这种情况下，模拟了一个简单的静态聚光灯。
- en: It's important to realize that the colors sampled from a texture are treated
    like any other color in the shader—that is, as a generic 4-dimensional vector.
    As a result, we can combine textures just as we would combine vertex and light
    colors, or any other color manipulation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到从纹理中采样的颜色被当作着色器中的任何其他颜色一样处理——也就是说，作为一个通用的四维向量。因此，我们可以像结合顶点和光照颜色，或者任何其他颜色操作一样结合纹理。
- en: 'Have a Go: Moving Beyond Multiply'
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用乘法之外的混合
- en: 'Multiplication is one of the most common ways to blend colors in a shader,
    but there''s really no limit to how you can combine color values. Try experimenting
    with different algorithms in the fragment shader to see what effect it has on
    the output. What happens when you add values instead of multiply? What if you
    use the red channel from one texture and the blue and green from the other? Try
    out the following algorithm and see what the result is:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法是在着色器中混合颜色最常见的方式之一，但实际上你结合颜色值的方式并没有限制。尝试在片段着色器中实验不同的算法，看看它对输出的影响。当你用加法代替乘法时会发生什么？如果你使用一个纹理的红色通道，而另一个纹理的蓝色和绿色呢？尝试以下算法并看看结果：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/af682a41-586b-4863-b5de-f190665f37ae.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af682a41-586b-4863-b5de-f190665f37ae.png)'
- en: 'Have a Go: Using Multi-Dimensional Textures'
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用多维纹理
- en: 'As you may have noticed, the challenges in maintaining multiple textures resembles
    the same challenges we faced in [Chapter 6](65e942d0-5402-4006-9b64-6811ade8f46c.xhtml),
    *Colors, Depth Testing, and Alpha Blending,* in managing multiple lights. That
    being said, does WebGL provide a similar feature as uniform arrays for managing
    multiple textures? Yes, of course! We can leverage two different solutions that
    WebGL 2 provides for managing multi-dimensional textures: **3D textures** and
    **texture arrays**.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，维护多个纹理的挑战与我们在[第6章](65e942d0-5402-4006-9b64-6811ade8f46c.xhtml)，“颜色、深度测试和Alpha混合”中管理多个灯光所面临的挑战相似。话虽如此，WebGL是否提供了与统一数组类似的功能来管理多个纹理？是的，当然！我们可以利用WebGL
    2提供的两种不同的解决方案来管理多维纹理：**3D纹理**和**纹理数组**。
- en: Although, we will discuss these features in [Chapter 11](9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml),
    *WebGL 2 Highlights,* it may be useful to think about how these features can be
    useful in reducing complexity, improving code maintainability, and increasing
    the number of textures that can be used.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将在[第11章](9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml)，“WebGL 2亮点”中讨论这些功能，但考虑这些功能如何有助于减少复杂性、提高代码可维护性以及增加可使用的纹理数量可能是有用的。
- en: Cube Maps
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立方图
- en: Earlier in this chapter, we mentioned 2D textures and cube maps for creating
    complex effects using images. We covered textures, but exactly what are cube maps
    and how do we use them?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们提到了2D纹理和立方图，用于使用图像创建复杂效果。我们讨论了纹理，但立方图究竟是什么，我们如何使用它们？
- en: A **cube map** is, very much like it sounds, a cube of textures. Six individual
    textures are created, each assigned to a different face of the cube. The graphics
    hardware can sample them as a single entity, by using a 3D texture coordinate.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**立方图**，正如其名，是一个纹理的立方体。创建了六个单独的纹理，每个纹理分配给立方体的一个不同面。图形硬件可以通过使用3D纹理坐标将它们作为一个单一实体进行采样。'
- en: 'The faces of the cube are identified by the axis they face and whether they
    are on the positive or negative side of that axis:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体的面通过它们面对的轴以及它们位于该轴的正面还是负面来识别：
- en: '![](img/5762d179-58de-4c54-b10f-b50f1d66f965.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5762d179-58de-4c54-b10f-b50f1d66f965.png)'
- en: 'So far, we have manipulated a texture by specifying a texture target of `TEXTURE_2D`.
    Cube mapping introduces a few new texture targets that indicate we are working
    with cube maps. These targets also indicate which face of the cube map we''re
    manipulating:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过指定`TEXTURE_2D`纹理目标来操作纹理。立方图引入了一些新的纹理目标，这些目标表明我们正在处理立方图。这些目标还表明我们正在操作立方图的哪个面：
- en: '`TEXTURE_CUBE_MAP`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXTURE_CUBE_MAP`'
- en: '`TEXTURE_CUBE_MAP_POSITIVE_X`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXTURE_CUBE_MAP_POSITIVE_X`'
- en: '`TEXTURE_CUBE_MAP_NEGATIVE_X`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXTURE_CUBE_MAP_NEGATIVE_X`'
- en: '`TEXTURE_CUBE_MAP_POSITIVE_Y`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXTURE_CUBE_MAP_POSITIVE_Y`'
- en: '`TEXTURE_CUBE_MAP_NEGATIVE_Y`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXTURE_CUBE_MAP_NEGATIVE_Y`'
- en: '`TEXTURE_CUBE_MAP_POSITIVE_Z`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXTURE_CUBE_MAP_POSITIVE_Z`'
- en: '`TEXTURE_CUBE_MAP_NEGATIVE_Z`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXTURE_CUBE_MAP_NEGATIVE_Z`'
- en: These targets are collectively known as the `gl.TEXTURE_CUBE_MAP_*` targets.
    Which one you need to use depends on the function you're calling.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目标共同被称为`gl.TEXTURE_CUBE_MAP_*`目标。您需要使用哪个取决于您调用的函数。
- en: 'Cube maps are created like a normal texture, but binding and property manipulation
    happen with the `TEXTURE_CUBE_MAP` target, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 立方图就像普通纹理一样创建，但绑定和属性操作使用`TEXTURE_CUBE_MAP`目标，如下所示：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When uploading the image data for the texture, you need to specify the side
    that you are manipulating, as shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当上传纹理的图像数据时，您需要指定您正在操作的侧面，如下所示：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Exposing the cube map texture to the shader is done in the same way as a normal
    texture, just with the cube map target:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将立方图纹理暴露给着色器的方式与普通纹理相同，只是使用立方图目标：
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, the uniform type within the shader is specific to cube maps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，着色器内的统一类型是针对立方图的特定类型：
- en: '[PRE38]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When sampling from the cube map, you also use a cube map-specific function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从立方图中采样时，您也使用一个针对立方图特定的函数：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The 3D coordinates you provide are normalized by the graphics hardware into
    a unit vector, which specifies a direction from the center of the "cube." A ray
    is traced along that vector, and where it intersects the cube face is where the
    texture is sampled:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您提供的3D坐标被图形硬件归一化成一个单位向量，该向量指定了从“立方体”中心的方向。沿着该向量绘制一条射线，它与立方体面的交点就是纹理被采样的位置：
- en: '![](img/1e0f5c69-128a-49a8-ad7a-ae4b8ad6bb7b.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e0f5c69-128a-49a8-ad7a-ae4b8ad6bb7b.png)'
- en: 'Time for Action: Trying out Cube Maps'
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：尝试使用立方图
- en: 'Let''s cover an example of seeing cube maps in action:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看立方图的实际应用：
- en: Open the `ch07_07_cubemap.html` file in your browser. Once again, this contains
    a simple textured cube example on top of which we'll build the cube map example.
    We want to use the cube map to create a reflective-looking surface.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`ch07_07_cubemap.html`文件。这又包含了一个简单的纹理立方体示例，我们将在其上构建立方体贴图示例。我们想使用立方体贴图来创建一个看起来像反射的表面。
- en: 'Creating the cube map is a bit more complicated than the textures we''ve loaded
    in the past, so this time, we''ll use a function to simplify the asynchronous
    loading of individual cube faces. It''s called `loadCubemapFace` and has already
    been to the file. Inside of the `configure` function, at the bottom, add the following
    code, which creates and loads the cube map faces:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建立方体贴图比我们之前加载的纹理要复杂一些，所以这次我们将使用一个函数来简化单个立方体贴面的异步加载。这个函数叫做`loadCubemapFace`，并且已经添加到了文件中。在`configure`函数的底部，添加以下代码，用于创建和加载立方体贴图面：
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `render` function, add the code to bind the cube map to the appropriate
    sampler:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`render`函数中，添加代码将立方体贴图绑定到适当的采样器：
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Turning to the shader now, we want to add a new varying to the vertex shader:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转向着色器，我们想在顶点着色器中添加一个新的变量：
- en: '[PRE42]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We''ll be using the vertex normals instead of a dedicated texture coordinate
    to do the cube map sampling, which will give us the mirror effect we''re looking
    for. Unfortunately, the actual normals of each face on the cube point straight
    out. If we were to use them, we would only get a single color per face from the
    cube map. In this case, we can "cheat" and use the vertex position as the normal
    instead (for most models, using the normals would be appropriate):'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用顶点法线而不是专门的纹理坐标来进行立方体贴图采样，这将给我们带来我们想要的镜像效果。不幸的是，立方体每个面上的实际法线都直接指向外。如果我们使用它们，我们只会从立方体贴图中得到每个面的单色。在这种情况下，我们可以“作弊”并使用顶点位置作为法线（对于大多数模型，使用法线是合适的）：
- en: '[PRE43]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We need to define the following varying inside of the fragment shader:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在片段着色器中定义以下变量：
- en: '[PRE44]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We also need to add the new sampler uniform inside of the fragment shader.
    Be sure to also include this in the `uniforms` list inside of the `configure`
    function:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在片段着色器中添加新的采样器统一变量。确保在`configure`函数中的`uniforms`列表中也包含这个变量：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And then, in the fragment shader''s `main` function, add the code to actually
    sample the cube map and blend it with the base texture:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在片段着色器的`main`函数中，添加代码来实际采样立方体贴图并将其与基本纹理混合：
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We should now be able to reload the file in a browser and see the scene shown
    in the following screenshot:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该能够在浏览器中重新加载文件并看到以下截图所示的场景：
- en: '![](img/ac07b294-5ebb-4afe-b292-d4266523ad4c.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac07b294-5ebb-4afe-b292-d4266523ad4c.png)'
- en: The completed example is available in `ch07_08_cubemap-final.html`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成的示例可以在`ch07_08_cubemap-final.html`中找到。
- en: '***What just happened?***'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: As you rotate the cube, you'll notice that the scene displayed on the cube map
    does not rotate along, creating a "mirror" effect on the cube faces. This is due
    to multiplication of the normals by the Normal matrix when assigning the `vVertexNormal`
    varying, which puts the normals in world space.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你旋转立方体时，你会注意到立方体贴图上显示的场景并没有随之旋转，从而在立方体贴图面上产生了一个“镜像”效果。这是因为在分配`vVertexNormal`变量时，法线与法线矩阵相乘，将法线放置在世界空间中。
- en: Using cube maps for reflective surfaces is a common technique, but it's not
    the only use for cube maps. Other common uses include skyboxes and advanced lighting
    models.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用立方体贴图进行反射表面是一个常见的技巧，但立方体贴图不仅仅有这个用途。其他常见的用途包括Skybox和高级光照模型。
- en: 'SkyboxA skybox is a method that''s used for creating backgrounds to make computer
    and video game levels look bigger than they really are. When a skybox is used,
    the level is enclosed in a cuboid. The sky, distant mountains, distant buildings,
    and other unreachable objects are projected onto the cube''s faces (using a technique
    called cube mapping), hence creating the illusion of distant, three-dimensional
    surroundings. A skydome employs the same concept but uses either a sphere or a
    hemisphere instead of a cube. For more information, check out the following URL:
    [https://en.wikipedia.org/wiki/Skybox_(video_games)](https://en.wikipedia.org/wiki/Skybox_(video_games)).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: SkyboxA 立方体贴图是一种用于创建背景的方法，使计算机和视频游戏关卡看起来比实际更大。当使用立方体贴图时，关卡被一个长方体包围。天空、远处的山脉、远处的建筑和其他不可达的对象被投影到立方体的面上（使用称为立方体贴图的技术），从而产生遥远的三维环境错觉。Skydome
    采用相同的概念，但使用球体或半球体而不是立方体。更多信息，请查看以下链接：[https://en.wikipedia.org/wiki/Skybox_(video_games)](https://en.wikipedia.org/wiki/Skybox_(video_games))。
- en: 'Have a Go: Shiny Logo'
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试：闪亮的标志
- en: In this example, we've created a reflective "mirrored" cube. But what if we
    only wanted the logo to be reflective? How could we constrain the cube map to
    only be displayed within the red portion of the texture?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个反射的“镜像”立方体。但如果我们只想让标志具有反射效果呢？我们如何将立方体贴图限制只显示在纹理的红色部分？
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Let''s summarize what we''ve learned in this chapter:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章所学的内容：
- en: How to use textures to add a new level of detail to our scenes.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用纹理为我们的场景添加新的细节层次。
- en: How to create and manage texture objects and use HTML images as textures.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和管理纹理对象，以及如何将HTML图像用作纹理。
- en: We covered texture coordinates and the ability to mipmap for various rendering
    techniques.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们涵盖了纹理坐标和用于各种渲染技术的mipmap能力。
- en: We examined the various filter modes and how they affect the texture's appearance
    and usage, as well as the available texture wrapping modes and how they alter
    the way texture coordinates are interpreted.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查了各种过滤模式以及它们如何影响纹理的外观和使用，以及可用的纹理包裹模式以及它们如何改变纹理坐标的解释方式。
- en: We learned how to use multiple textures in a single draw call, and how to combine
    them in a shader.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何在单个绘制调用中使用多个纹理，以及如何在着色器中将它们组合。
- en: We learned how to create and render cube maps and saw how they can be used to
    simulate reflective surfaces.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何创建和渲染立方体贴图，并看到了它们如何用于模拟反射表面。
- en: In the next chapter, we will look at selecting and interacting with objects
    in our WebGL scene by using a clever technique known as picking.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用一种称为拾取的巧妙技术来查看如何选择和交互我们的WebGL场景中的对象。
