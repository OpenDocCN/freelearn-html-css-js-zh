- en: Chapter 9. Writing Your Own Node Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。编写自己的Node模块
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a test-driven module API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个测试驱动的模块API
- en: Writing a functional module mock-up
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个功能模块的模拟
- en: Refactoring from functional to prototypical
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从功能到原型的重构
- en: Extending a module's API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展模块的API
- en: Deploying a module to npm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块部署到npm
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: A thriving module ecosystem has been one of the core goals of Node since its
    inception. The framework leans heavily toward modularization. Even the core functionality
    (such as HTTP) is made available through the module system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自从诞生以来，一个蓬勃发展的模块生态系统一直是Node的核心目标之一。该框架倾向于模块化。即使是核心功能（如HTTP）也是通过模块系统提供的。
- en: It's almost as easy to create our own modules as it is to use core and third-party
    modules. All we need to know is how the module system works and a few best practices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的模块几乎和使用核心和第三方模块一样容易。我们只需要了解模块系统的工作原理和一些最佳实践。
- en: A great module is one that performs a specific function to a high standard and
    great code is the result of multiple development cycles. In this chapter, we're
    going to develop a module from scratch, beginning with defining its Application
    Programming Interface (API), to creating our module over a series of development
    cycle iterations. We'll finally deploy it to npm for the benefit of all.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀的模块是执行特定功能的高标准，而优秀的代码是多个开发周期的结果。在本章中，我们将从头开始开发一个模块，从定义其应用程序编程接口（API）开始，逐步创建我们的模块。最后，我们将把它部署到npm以造福所有人。
- en: Creating a test-driven module API
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试驱动的模块API
- en: We're going to create our module by loosely following the test-driven development
    (TDD) model (See [http://en.wikipedia.org/wiki/Test-driven_development](http://en.wikipedia.org/wiki/Test-driven_development)
    for more info). JavaScript is asynchronous so code can be executed in multiple
    time streams at once. This can sometimes make for a challenging mental puzzle.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过松散地遵循测试驱动开发（TDD）模型（参见[http://en.wikipedia.org/wiki/Test-driven_development](http://en.wikipedia.org/wiki/Test-driven_development)了解更多信息）来创建我们的模块。JavaScript是异步的，因此代码可以在多个时间流中执行。这有时可能会构成一个具有挑战性的心智难题。
- en: A test suite is a particularly powerful tool when it comes to JavaScript development.
    It provides a quality assurance process and inspires confidence in a module's
    users base when tests are passed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件在JavaScript开发中是一个特别强大的工具。当测试通过时，它提供了一个质量保证过程，并且能够激发模块用户的信心。
- en: What's more, we can define our tests up front as a way to map out the intended
    API before we even begin development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以预先定义我们的测试，作为一种在开始开发之前规划预期API的方式。
- en: In this recipe, we'll be doing just that by creating a test suite for a module
    that extracts stats information from MP3 files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过创建一个模块的测试套件来提取MP3文件的统计信息。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s create a new folder called `mp3dat`, with a file inside called `index.js`.
    Then two subfolders: `lib` and `test`, both containing `index.js`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`mp3dat`的新文件夹，里面有一个名为`index.js`的文件。然后再创建两个子文件夹：`lib`和`test`，它们都包含`index.js`。
- en: We'll also need MP3 files to test on. For simplicity, our module will only support
    MPEG-1 Layer 3 files with error protection turned off. Other types of MP3 files
    include MPEG-2 and MPEG-2.5\. MPEG-1 (no error protection) would be the most common
    type, but our module could easily be extended later. We can retrieve an MPEG-1
    Layer 3 file from [http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3](http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3).
    Let's place this file in our new `mp3dat/test` folder and call it `test.mp3`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要MP3文件进行测试。为简单起见，我们的模块只支持关闭错误保护的MPEG-1 Layer 3文件。其他类型的MP3文件包括MPEG-2和MPEG-2.5。MPEG-1（无错误保护）可能是最常见的类型，但我们的模块可以很容易地进行扩展。我们可以从[http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3](http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3)获取一个MPEG-1
    Layer 3文件。让我们把这个文件放在我们的新`mp3dat/test`文件夹中，并将其命名为`test.mp3`。
- en: The focus of this chapter is to create a fully functioning module, prior knowledge
    of MP3 file structures is not required. Details regarding MP3s in this chapter
    can safely be scanned over while the information pertaining to module creation
    is of key importance. However, we can learn more about MP3 files and their structure
    from [http://en.wikipedia.org/wiki/MP3](http://en.wikipedia.org/wiki/MP3).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是创建一个完全功能的模块，不需要对MP3文件结构有先验知识。在本章中，关于MP3的细节可以安全地略过，而有关模块创建的信息则至关重要。然而，我们可以从[http://en.wikipedia.org/wiki/MP3](http://en.wikipedia.org/wiki/MP3)了解更多关于MP3文件及其结构的信息。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s open `test/index.js` and set up some variables as shown in the following
    code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`test/index.js`并设置一些变量，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`assert` is a core Node module specifically for building test suites. The general
    idea is we assert that something should be true (or false), and if the assertion
    is correct the test passes. The `mp3dat` variable requires our primary (currently
    blank) `index.js` file that will in turn load the `lib/index.js` file, which holds
    the actual module code.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`是一个专门用于构建测试套件的核心Node模块。总体思路是我们断言某件事应该是真的（或假的），如果断言是正确的，测试就通过了。`mp3dat`变量需要我们的主要（当前为空白的）`index.js`文件，该文件将加载`lib/index.js`文件，其中包含实际的模块代码。'
- en: The `testFile` variable points to our `test.mp3` file from the perspective of
    the root of our module (the `mp3dat` folder). This is because we run our tests
    from the root of the module directory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`testFile`变量从我们模块的根目录（`mp3dat`文件夹）的角度指向我们的`test.mp3`文件。这是因为我们从模块目录的根目录运行测试。'
- en: 'Now we''ll decide our API and write the corresponding tests. Let''s model our
    module after the `fs.stat` method. We''ll retrieve data about the MP3 file using
    an `mp3dat.stat` method, which will take two arguments: a file path and a callback
    function to be invoked once the stats have been gathered.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将决定我们的API并编写相应的测试。让我们模仿`fs.stat`方法来设计我们的模块。我们将使用`mp3dat.stat`方法获取有关MP3文件的数据，该方法将接受两个参数：文件路径和一次收集统计信息后要调用的回调函数。
- en: The `mp3dat.stat` callback will take two arguments. The first will be the error
    object which should be set to `null` if there is no error, and the second will
    contain our `stats` object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`mp3dat.stat`回调将接受两个参数。第一个将是错误对象，如果没有错误，应将其设置为`null`，第二个将包含我们的`stats`对象。'
- en: The `stats` object will contain `duration, bitrate, filesize, timestamp`, and
    `timesig` properties. The `duration` property will in turn contain an object holding
    `hours, minutes, seconds`, and `milliseconds` keys.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats`对象将包含`duration, bitrate, filesize, timestamp`和`timesig`属性。`duration`属性将包含一个对象，其中包含`hours,
    minutes, seconds`和`milliseconds`键。'
- en: 'For example, our `test.mp3` file should return something like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的`test.mp3`文件应该返回类似以下的内容：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we've conceptualized our API, we can map it out to assertion tests
    as a means of enforcing that API throughout the modules development.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构想出我们的API，我们可以将其映射到断言测试中，作为强制执行API在整个模块开发过程中的手段。
- en: Let's start with `mp3dat` and `mp3dat.stat`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`mp3dat`和`mp3dat.stat`开始。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To test the `mp3dat.stat` function we actually have to call it, then we perform
    further tests within its callback.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`mp3dat.stat`函数，我们实际上必须调用它，然后在其回调函数中执行进一步的测试。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we''ve established expected `stats` properties, we can go further
    and specify what these properties should look like, still within the callback
    we write the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了预期的`stats`属性，我们可以进一步指定这些属性应该是什么样子的，在回调函数中，我们写下以下代码：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s run our test. From the `mp3dat` folder we say:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行我们的测试。从`mp3dat`文件夹中，我们说：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should return text containing the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回包含以下内容的文本：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Which is exactly right, we haven't written the `stat` method yet.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全正确，我们还没有编写`stat`方法。
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the tests are run, the `assert` module will throw `AssertionError` to let
    the developer know that their code is not currently lining up with their predefined
    assertions regarding the desired API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，`assert`模块将抛出`AssertionError`，以让开发人员知道他们的代码目前与他们对所需API的预定义断言不一致。
- en: In our unit test file (`test/index.js`), we mainly used the simple `assert`
    function (an alias for `assert.ok). assert` requires that the first argument passed
    to it be truthy. Otherwise it throws `AssertionError` where the second provided
    argument is given for the error message (the opposite of `assert.ok` is `assert.fail`,
    which expects a falsey value).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单元测试文件（`test/index.js`）中，我们主要使用简单的`assert`函数（`assert.ok`的别名）。`assert`要求传递给它的第一个参数为真值。否则，它会抛出`AssertionError`，其中第二个提供的参数用于错误消息（`assert.ok`的相反是`assert.fail`，它期望一个假值）。
- en: 'Our test fails at:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试失败了：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is because `mp3dat.stat` is `undefined` (a falsey value).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`mp3dat.stat`是`undefined`（一个假值）。
- en: The first argument of `assert` can be an expression. For instance, we use `stats.duration.minutes
    < 60` to set a constraint for the `duration.minutes` property, and use the `match`
    method on `timesig` to verify a correct time pattern of HH:MM:SS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`的第一个参数可以是一个表达式。例如，我们使用`stats.duration.minutes < 60`来为`duration.minutes`属性设置约束，并在`timesig`上使用`match`方法来验证正确的时间模式HH:MM:SS。'
- en: We also use `assert.equal` and `assert.notStrictEqual. assert.equal` is a test
    that applies equality with type coercion (e.g. equivalent to `==)` and `assert.strictEqual`
    requires that values and types match `assert.notEqual` and `assert.notStrictEqual`
    are the corresponding antipathies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`assert.equal`和`assert.notStrictEqual`。`assert.equal`是一个应用类型强制相等的测试（例如，等同于`==`），`assert.strictEqual`要求值和类型匹配，`assert.notEqual`和`assert.notStrictEqual`是相应的对立面。
- en: We use `assert.notStrictEqual` to ensure the existence of the `duration` object's
    sub-properties `(hours, minutes`, and so on).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`assert.notStrictEqual`来确保`duration`对象的子属性`(hours, minutes`等)的存在。
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many testing frameworks providing extra descriptive syntax, enhanced
    functionality, asynchronous testing capabilities, and more. Let's sample one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多测试框架提供额外的描述性语法、增强功能、异步测试能力等。让我们尝试一个。
- en: Unit tests with should.js
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用should.js进行单元测试
- en: The third-party `should` module sits nicely on top of the core `assert` module,
    adding some syntactic sugar to both simplify and increase the descriptive powers
    of our tests. Let's install it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方的`should`模块很好地放在核心`assert`模块之上，为我们的测试添加了一些语法糖，以简化和增强描述能力。让我们安装它。
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can rewrite our tests with `should` as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`should`来重写我们的测试，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`should` allows us to write more concise and descriptive tests. Its syntax
    is natural and self-explanatory. We can read up on various `should` methods at
    its Github page: [https://www.github.com/visionmedia/should.js.](https://www.github.com/visionmedia/should.js.)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`should`允许我们编写更简洁和描述性的测试。它的语法是自然和不言自明的。我们可以在其Github页面上阅读各种`should`方法：[https://www.github.com/visionmedia/should.js.](https://www.github.com/visionmedia/should.js.)'
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Writing a functional module mock-up* discussed in this chapter'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的编写功能模块原型*'
- en: '*Extending the module''s API* discussed in this chapter'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的模块API扩展*'
- en: '*Deploying a module to npm* discussed in this chapter'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的将模块部署到npm*'
- en: Writing a functional module mock-up
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个功能模块原型
- en: Now that we have our tests written (see previous recipe), we are ready to create
    our module (incidentally, from here on we'll be using the `should` version of
    our unit tests as opposed to `assert)`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了我们的测试（参见前面的配方），我们准备创建我们的模块（顺便说一句，从现在开始，我们将使用我们的单元测试的`should`版本，而不是`assert`）。
- en: In this recipe, we'll write our module in simple functional style to demonstrate
    proof of concept. In the next recipe, we'll refactor our code into a more common
    modular format centered on reusability and extendibility.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将以简单的功能风格编写我们的模块，以证明概念。在下一个配方中，我们将把我们的代码重构成一个更常见的以可重用性和可扩展性为中心的模块化格式。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's open our main `index.js` and link it to the `lib` directory via `module.exports`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的主要`index.js`文件，并通过`module.exports`将其链接到`lib`目录。
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This allows us to place the meat of our module code neatly inside the `lib`
    directory.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以将模块代码的核心整齐地放在`lib`目录中。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll open up `lib/index.js` and begin by requiring the `fs` module, which will
    be used to read an MP3 file, and setting up a `bitrates` map that cross references
    hex-represented values to bitrate values as defined by the MPEG-1 specification.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打开`lib/index.js`，并开始引入`fs`模块，用于读取MP3文件，并设置一个`bitrates`映射，将十六进制表示的值与MPEG-1规范定义的比特率值进行交叉引用。
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we'll define two functions, `findBitRate` to locate and translate the bitrate
    half-byte and `buildStats` to crunch all gathered information into our previously
    determined final `stats` object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义两个函数，`findBitRate`用于定位和转换半字节比特率，`buildStats`用于将所有收集到的信息压缩成先前确定的最终`stats`对象。
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`buildStats` takes `bitrate, size`, and `cb` arguments. It uses `bitrate` and
    `size` to calculate the amount of seconds in the track and then uses this information
    to generate the `stats` object, which it passes through the `cb` function.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildStats`接受`bitrate, size`和`cb`参数。它使用`bitrate`和`size`来计算音轨中的秒数，然后使用这些信息生成`stats`对象，并通过`cb`函数传递。'
- en: 'To get `bitrate` into `buildStats`, let''s write the `findBitRate` function
    as shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`bitrate`传递给`buildStats`，让我们按照以下代码编写`findBitRate`函数：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we expose a `stat` method, which utilizes our functions to produce
    the `stats` object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们公开了一个`stat`方法，它利用我们的函数来生成`stats`对象：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let''s run our (`should`) tests from the previous recipe:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行我们从上一个示例中的(`should`)测试：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It should output the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该输出以下内容：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `exports` object is a central part of the Node platform. It''s the other
    half of `require`. When we require a module, any properties added to `exports`
    are exposed through `require`. So when we do:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`exports`对象是Node平台的核心部分。它是`require`的另一半。当我们需要一个模块时，添加到`exports`的任何属性都通过`require`暴露出来。因此，当我们这样做时：'
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can access `exports.stat` through `mp3dat.stat`, or even through `require('mp3dat').stat`
    (assuming we have `mp3dat` installed as a module, see *Deploying a module to npm)*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`mp3dat.stat`访问`exports.stat`，甚至可以通过`require('mp3dat').stat`访问（假设我们已经将`mp3dat`安装为一个模块，参见*将模块部署到npm*）。
- en: If we want to expose one function for the entire module, we use `module.exports`,
    as in our top `index.js` file which we set up in the *Getting ready* section of
    this recipe.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为整个模块公开一个函数，我们使用`module.exports`，就像我们在本示例的*准备就绪*部分中设置的顶级`index.js`文件一样。
- en: Our `stat` method first calls `fs.stat` with the user-supplied filename (f).
    We use the supplied `fstats` object to retrieve the size of our file, which we
    pass to `buildStats`. That is, after we have called `findBitRate` to retrieve
    the MP3's `bitrate`, which we also pass to `buildStats`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`stat`方法首先调用`fs.stat`，并传递用户提供的文件名（f）。我们使用提供的`fstats`对象来检索文件的大小，然后将其传递给`buildStats`。也就是说，在我们调用`findBitRate`来检索MP3的`bitrate`之后，我们也将其传递给`buildStats`。
- en: The `buildStats` callback is passed straight up through to our `stat` method's
    callback, the execution of the user callback originates within `buildStats`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildStats`回调直接通过我们的`stat`方法的回调传递，用户回调的执行起源于`buildStats`。'
- en: '`findBitRate` creates a `readStream` of the user-supplied file (f) and loops
    through each emitted `data` chunk two bytes at a time, thus halving the search
    time. We can do this because we''re looking for a two-byte sync word, which will
    always be at a position divisible by two. In hex the sync word is `FFFB` , as
    a 16-byte little-endian unsigned integer it''s `64511` (this is true only for
    MPEG-1 MP3 files without error protection).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`findBitRate`创建了用户提供文件（f）的`readStream`，并循环遍历每个发出的`data`块，每次两个字节，从而减少搜索时间。我们之所以能这样做，是因为我们正在寻找两个字节的同步字，它们总是在可以被二整除的位置。在十六进制中，同步字是`FFFB`，作为16字节的小端无符号整数是`64511`（这仅适用于没有错误保护的MPEG-1
    MP3文件）。'
- en: The next four bits (half-byte) following the MP3 sync word contain the bitrate
    value. So we pass this through the `Buffer.toString` method, requiring hex output
    which we match against our `bitrates` object map. In the case of our `test.mp3`
    file, the half-byte hex value is `9` representing a bitrate of `128000` bits per
    second.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: MP3同步字后面的四个比特（半字节）包含比特率值。因此，我们通过`Buffer.toString`方法将其传递，要求十六进制输出，然后与我们的`bitrates`对象映射进行匹配。在我们的`test.mp3`文件的情况下，半字节的十六进制值为`9`，表示每秒`128000`比特的比特率。
- en: Once we find our bitrate, we execute the callback and invoke `this.destroy`,
    which abruptly terminates our `readStream`, preventing the `end` event from ever
    being triggered. The `end` event will only occur when a bitrate has not been discovered,
    in which case we send an error back through the callback.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到比特率，我们执行回调并调用`this.destroy`，这会突然终止我们的`readStream`，防止`end`事件被触发。只有在没有发现比特率的情况下，`end`事件才会发生，此时我们通过回调发送错误。
- en: '`buildStats` receives `bitrate` and divides it by `8` giving us the bytes per
    second (8 bits to a byte). Dividing the total bytes of the MP3 by the bytes per
    second renders the amount of seconds. We then further divide it by 3,600 to get
    the `hours` variable, which is then passed into the embedded `timeProcessor` function.
    `timeProcessor` simply recurses through the `magnitudes` array (hours, `minutes,
    seconds, milliseconds)` until `seconds` have been accurately converted and apportioned
    to each magnitude, which gives us our `duration` object. Again, we use the calculated
    duration (in whatever form) to construct our `timestamp` and `timesig` properties.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildStats`接收`bitrate`并将其除以`8`得到每秒的字节数（8位为1字节）。将MP3的总字节数除以每秒的字节数得到秒数。然后我们再除以3,600得到`hours`变量，然后将其传递到嵌入的`timeProcessor`函数中。`timeProcessor`简单地通过`magnitudes`数组（小时，分钟，秒，毫秒）进行递归，直到`seconds`被准确转换并分配到每个数量级，从而得到我们的`duration`对象。然后，我们使用计算出的持续时间（以任何形式）来构建我们的`timestamp`和`timesig`属性。'
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Examples of how to use a module can be a great resource for end users. Let's
    write an example for our new module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的使用示例可以成为最终用户的重要资源。让我们为我们的新模块编写一个示例。
- en: Writing a module use case example
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写模块使用示例
- en: 'We''ll create an `examples` folder within the `mp3dat` folder, and create a
    file called `basic.js` (for a basic usage example) writing the following into
    it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`mp3dat`文件夹中创建一个`examples`文件夹，并创建一个名为`basic.js`的文件（用于基本用法示例），将以下内容写入其中：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should cause the console to output the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致控制台输出以下内容：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating a test-driven module API* discussed in this chapter'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的创建测试驱动模块API*'
- en: '*Refactoring from functional to prototypical* discussed in this chapter'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从功能到原型的重构*在本章中讨论'
- en: '*Deploying a module to npm* discussed in this chapter'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将模块部署到npm*在本章中讨论'
- en: Refactoring from functional to prototypical
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从功能到原型的重构
- en: The functional mock-up created in the previous recipe can be useful for gaining
    mental traction with a concept (that is, getting our head around it), and may
    be perfectly adequate for small, simple modules with narrow scope.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中创建的功能模拟可以帮助我们对概念有所了解，并且对于范围较小、简单的模块可能是完全足够的。
- en: However, the prototype pattern (among others) is commonly used by module creators,
    often used in Node's core modules and is fundamental to native JavaScript methods
    and objects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，原型模式（以及其他模式）通常被模块创建者使用，经常用于Node的核心模块，并且是原生JavaScript方法和对象的基础。
- en: '**Prototypical inheritance** is marginally more memory efficient. Methods sitting
    on a prototype are not instantiated until called, and they''re reused instead
    of recreated on each invocation.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**原型继承**稍微更节省内存。原型上的方法在调用之前不会被实例化，并且它们会被重复使用，而不是在每次调用时重新创建。'
- en: On the other hand, it can be slightly slower than our previous recipe's procedural
    style because the JavaScript engine has the added overhead of traversing prototype
    chains. Nevertheless, it's (arguably) more appropriate to think of and implement
    modules as entities in their own right, which a user can create instances of (for
    example, a prototype-oriented approach). For one, it makes them easier to programmatically
    extend through cloning and prototype modifications. This leads to great flexibility
    being afforded to the end user while the core integrity of the module's code stays
    intact.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它可能比我们上一个配方的过程式风格稍慢，因为JavaScript引擎需要额外的开销来遍历原型链。尽管如此，将模块视为用户可以创建实例的实体，并以（例如，基于原型的方法）实现它们可能更合适。首先，这样可以更容易地通过克隆和原型修改进行编程扩展。这为最终用户提供了极大的灵活性，同时模块代码的核心完整性保持不变。
- en: In this recipe, we'll rewrite our code from the previous task according to the
    prototype pattern.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将根据原型模式重写上一个任务中的代码。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start editing `index.js` in `mp3dat/lib`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编辑`mp3dat/lib`中的`index.js`。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To begin, we'll need to create a constructor function (a function called using
    `new)`, which we'll name `Mp3dat:`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个构造函数（使用`new`调用的函数），我们将其命名为`Mp3dat`：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've also required the `fs` module as in the previous task.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还像上一个任务一样需要`fs`模块。
- en: 'Let''s add some objects and methods to our constructor''s prototype:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向构造函数的原型添加一些对象和方法：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Three of our new `Mp3dat` properties (`_magnitudes, _pad`, and `_timesig)` were
    contained in the `buildStats` function in some form. We've prefixed their names
    with the underscore (_) to signify that they are private. This is merely a convention,
    JavaScript doesn't actually privatize them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`Mp3dat`属性中的三个（`_magnitudes、_pad`和`_timesig`）在`buildStats`函数中以某种形式被包含。我们在它们的名称前加上下划线(_)来表示它们是私有的。这只是一个约定，JavaScript实际上并没有将它们私有化。
- en: 'Now we''ll reincarnate the previous recipe''s `findBitRate` function as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将上一个配方的`findBitRate`函数转换如下：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The only differences here are that we load the filename from the object (`self.f`)
    instead of via the first parameter, and we load `bitrate` onto the object instead
    of sending it through the second parameter of `cb`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我们从对象（`self.f`）中加载文件名，而不是通过第一个参数，我们将`bitrate`加载到对象上，而不是通过`cb`的第二个参数发送它。
- en: 'Now to convert `buildStats` into the prototype pattern, we write the following
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将`buildStats`转换为原型模式，我们编写以下代码：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `_buildStats` prototype method is significantly smaller than its `buildStats`
    cousin from the previous task. Not only have we pulled its internal `magnitudes`
    array, `pad` utility function, and time signature functionality (wrapping it into
    its own `_timesig` method), we've also outsourced the internal recursive `timeProcessor`
    function to a prototype method equivalent.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`_buildStats`原型方法比上一个任务中的`buildStats`方法要小得多。我们不仅提取了它的内部`magnitudes`数组、`pad`实用函数和时间签名功能（将其包装成自己的`_timesig`方法），还将内部递归的`timeProcessor`函数外包到了一个原型方法中。
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we write the `stat` method (with no underscore prefix since it's intended
    for public use), and export the `Mp3dat` object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编写`stat`方法（没有下划线前缀，因为它是供公共使用的），并导出`Mp3dat`对象。
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can ensure all is present and correct by running the tests we built in the
    first recipe. On the command line from the `mp3dat` folder we say:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行我们在第一个配方中构建的测试来确保一切都正确。在`mp3dat`文件夹的命令行中，我们说：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Which should output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 应该输出：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous recipe, we had an `exports.stat` function which called the `findBitRate`
    and `buildStats` functions to get the `stats` object. In our refactored module,
    we add the `stat` method onto the prototype and export the entire `Mp3dat` constructor
    function via `module.exports.`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们有一个`exports.stat`函数，它调用`findBitRate`和`buildStats`函数来获取`stats`对象。在我们重构的模块中，我们将`stat`方法添加到原型上，并通过`module.exports`导出整个`Mp3dat`构造函数。
- en: 'We don''t have to pass `Mp3dat` to `module.exports` using `new`. Our function
    generates the new instance when invoked directly, with the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必使用`new`将`Mp3dat`传递给`module.exports`。我们的函数在直接调用时生成新的实例，代码如下：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is really a failsafe strategy. It's more efficient (though marginally)
    to initialize the constructor with `new`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的是一个保险策略。使用`new`初始化构造函数更有效（尽管在边缘上）。
- en: The `stat` method in our refactored code differs from the `exports.stat` function
    in the prior task. Instead of passing the filename and size of the specified MP3
    as parameters to `findBitRate` and `buildStats` respectively, it assigns them
    to the parent object via `this` (which is assigned to `self` to avoid new callbacks
    scopes reassignment of `this)`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构的代码中的`stat`方法与先前任务中的`exports.stat`函数不同。它不是将文件名和指定MP3的大小作为参数传递给`findBitRate`和`buildStats`，而是通过`this`将它们分配给父对象（将其分配给`self`以避免`this`的新回调范围重新分配）。
- en: It then invokes the `_findBitRate` and `_buildStats` methods to ultimately generate
    the `stats` object and pass it back to the users callback.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`_findBitRate`和`_buildStats`方法，最终生成`stats`对象并将其传递回用户的回调。
- en: 'After running `mp3dat.stats` on our `test.mp3` file, our refactored `mp3dat`
    module object will hold the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`test.mp3`文件上运行`mp3dat.stats`之后，我们重构的`mp3dat`模块对象将包含以下内容：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the former recipe however, the returned object would simply be as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在前一个示例中，返回的对象将简单地如下所示：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The functional style reveals the API. Our refactored code allows the user to
    interact with the information in multiple ways (through the `stats` and `mp3dat`
    objects). We can also extend our module and populate `mp3dat` with other properties
    later on, outside of the `stats` object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 功能风格揭示了API。我们重构的代码允许用户以多种方式与信息进行交互（通过`stats`和`mp3dat`对象）。我们还可以扩展我们的模块，并在`stats`对象之外的其他时间填充`mp3dat`。
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can structure our module to make it even easier to use.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建我们的模块，使其更容易使用。
- en: Adding the stat function to the initialized mp3dat object
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将stat函数添加到初始化的mp3dat对象中
- en: 'If we want to expose our `stat` function directly to the `mp3dat` object, thus
    allowing us to view the API directly (for example, with `console.log)`, we can
    add it by removing `Mp3dat.prototype.stat` and altering `Mp3dat` as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想直接将我们的“stat”函数暴露给“mp3dat”对象，从而允许我们直接查看API（例如，使用`console.log`），我们可以通过删除`Mp3dat.prototype.stat`并修改`Mp3dat`来添加它如下：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then our final object becomes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的最终对象变成：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Alternatively, if we''re not concerned about pushing the `stats` object and
    other `Mp3dat` properties through to the module user, we can leave everything
    as it is, except change the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们不关心将“stats”对象和其他“Mp3dat”属性推送到模块用户，我们可以将一切保持原样，只需更改以下代码：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This uses the `call` method to apply the `Mp3dat` scope to the `stat` method
    (allowing us to piggyback off of the `stat` method) and will return an object
    with the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`call`方法将`Mp3dat`范围应用于`stat`方法（允许我们依赖`stat`方法），并将返回一个具有以下内容的对象：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just as in the first write of our module, except we still have the prototype
    pattern in place. This second approach is ever so slightly more efficient.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的模块的第一次写作一样，只是我们仍然保留了原型模式。这种第二种方法稍微更有效。
- en: Allowing for multiple instances
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许多个实例
- en: Our module is a singleton since returns the already initialized `Mp3dat` object.
    This means no matter how many times we require it and assign it to variables,
    a module user will always be referring to the same object, even if `Mp3dat` is
    required in different submodules loaded by a parent script.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模块是一个单例，因为它返回已初始化的`Mp3dat`对象。这意味着无论我们需要多少次并将其分配给变量，模块用户始终将引用相同的对象，即使`Mp3dat`在父脚本加载的不同子模块中被需要。
- en: This means bad things will happen if we try to run two `mp3dat.stat` methods
    at the same time. In a situation where our module is required multiple times,
    two variables holding the same object could end up overwriting each other's properties,
    resulting in unpredictable (and frustrating) code. The most likely upshot is that
    `readStreams` will clash.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们尝试同时运行两个`mp3dat.stat`方法，将会发生糟糕的事情。在需要多次引用我们的模块的情况下，持有相同对象的两个变量最终可能会互相覆盖属性，导致不可预测（和令人沮丧）的代码。最有可能的结果是`readStreams`会发生冲突。
- en: 'One way to overcome this is to alter the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这一点的一种方法是修改以下内容：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And then load two instances with the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下代码加载两个实例：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we wanted to provide both singletons and multiple instances, we could add
    a `spawnInstance` method to our constructor''s prototype:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要提供单例和多个实例，我们可以在构造函数的原型中添加一个`spawnInstance`方法：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Which then allows us to do something as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以做如下事情：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Both `mp3dat` and `mp3dat2` would be separate `Mp3dat` instances, whereas in
    the following case:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`mp3dat`和`mp3dat2`都将是单独的`Mp3dat`实例，而在以下情况下：'
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Both would be the same instance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 两者将是相同的实例。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Writing a functional module mock-up* discussed in this chapter'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的编写功能模块模拟*'
- en: '*Extending the module''s API* discussed in this chapter'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的扩展模块的API*'
- en: '*Deploying a module to npm* discussed in this chapter'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的将模块部署到npm*'
- en: Extending the module's API
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展模块的API
- en: There are many ways we can extend our module, for example, we could make it
    support more MP3 types, but this is merely leg work. It just takes finding out
    the different sync words and bitrates for different types of MP3, and then adding
    these to the relevant places.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以许多方式扩展我们的模块，例如，我们可以使其支持更多的MP3类型，但这只是例行工作。只需找出不同的同步字和不同类型的MP3的比特率，然后将它们添加到相关位置。
- en: For a more interesting venture, we could extend the API, creating more options
    for our module users.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更有趣的冒险，我们可以扩展API，为我们的模块用户创建更多选项。
- en: Since we use a stream to read our MP3 file, we could allow the user to pass
    in either a filename or a stream of MP3 data, offering both ease (with a simple
    filename) and flexibility (with streams). This way we could start a download stream,
    STDIN stream, or in fact any stream of MP3 data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用流来读取我们的MP3文件，我们可以允许用户传入文件名或MP3数据流，提供简单（使用简单文件名）和灵活（使用流）两种方式。这样我们就可以启动下载流、STDIN流，或者实际上任何MP3数据流。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll pick up our module from where we left it at the end of *Allowing for multiple
    instances* in the *There's more..*. section of the previous recipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从前一篇食谱的*允许多个实例*部分的*还有更多..*中继续使用我们的模块。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we'll add some more tests for our new API. In `tests/index.js`, we'll
    pull out the callback function from the `mp3dat.stat` call into the global scope,
    and we'll call it `cb:`
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为我们的新API添加一些更多的测试。在`tests/index.js`中，我们将从`mp3dat.stat`调用中提取回调函数到全局范围，并将其命名为`cb:`。
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we''ll call `stat` along with a method which we''re going to write and
    name: `statStream:`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将调用`stat`以及一个我们将要编写并命名为`statStream`的方法：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice we're using two `Mp3dat` instances `(mp3dat` and `mp3dat2)`. So we can
    run `stat` and `statStream` tests side by side. Since we're creating a `readStream`,
    we require `fs` at the top of our `[tests/index.js]` file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了两个`Mp3dat`实例（`mp3dat`和`mp3dat2`）。所以我们可以同时运行`stat`和`statStream`测试。由于我们正在创建一个`readStream`，我们需要在我们的`[tests/index.js]`文件的顶部引入`fs`。
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll also put a few top-level `should` tests in for the `statStream` method
    as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为`statStream`方法添加一些顶层的`should`测试，如下所示：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now to live up to our tests expectations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来满足我们测试的期望。
- en: 'Within `lib/index.js`, we add a new method to the prototype of `Mp3dat`. Instead
    of taking a filename for the first parameter, it will accept an object (which
    we''ll call `opts)` that must contain `stream` and `size` properties:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lib/index.js`中，我们向`Mp3dat`的原型添加了一个新的方法。它不再接受第一个参数的文件名，而是接受一个对象（我们将其称为`opts`），该对象必须包含`stream`和`size`属性：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, just a few modifications to `_findBitRate` and we're done.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对`_findBitRate`进行一些修改，我们就完成了。
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We conditionally hook onto either a passed in stream, or we create a stream
    from a given filename.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有条件地挂接到传入的流，或者我们从给定的文件名创建一个流。
- en: 'Let''s run our tests (from the `mp3dat` folder):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试（从`mp3dat`文件夹）：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The result should be:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: One for `stat`, one for `statStream`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于`stat`，一个用于`statStream`。
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We were already using a stream to retrieve our data. We simply expose this interface
    to the user by modifying `_findBitRate` so it either generates its own stream
    from a filename, or if a stream is present in the parent constructors properties
    (`self.stream`), it simply plugs that stream into the process that was already
    in place.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在使用流来检索我们的数据。我们只需通过修改`_findBitRate`来向用户公开这个接口，使其可以从文件名生成自己的流，或者如果流存在于父构造函数的属性中（`self.stream`），它只需将该流插入到已经存在的流程中。
- en: 'We then make this functionality available to the module user by defining a
    new API method: `statStream`. We conceptualize this first by making tests for
    it, then define it through `Mp3dat.prototype`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过定义一个新的API方法`statStream`来使这个功能对模块用户可用。我们首先通过为其制定测试来概念化它，然后通过`Mp3dat.prototype`来定义它。
- en: 'The `statStream` method is similar to the `stat` method (in fact, we could
    merge them, see *There''s more...)*. Aside from checking the validity of the input,
    it simply adds one more property to an `Mp3dat` instance: the `stream` property,
    which is taken from `opts.stream`. For convenience, we cross reference `opts.stream.path`
    with `self.f` (this may or may not be available depending on the type of stream).
    This is essentially redundant but may be useful for debugging purposes on the
    users part.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`statStream`方法类似于`stat`方法（实际上，我们可以将它们合并，参见*还有更多..*）。除了检查输入的有效性之外，它只是向`Mp3dat`实例添加了一个属性：`stream`属性，它取自`opts.stream`。为了方便起见，我们将`opts.stream.path`与`self.f`进行交叉引用（这取决于流的类型，这可能有或者没有）。这基本上是多余的，但对于用户的调试目的可能是有用的。'
- en: At the top of `statStream` we have the `validOpts` variable, which has a series
    of expressions connected by`&&` conditionals. This is shorthand for a bunch of
    `if` statements. If any of these expression tests fail, the `opts` object is not
    valid. One expression of interest is`'pause'` in `opts.stream`, which tests whether
    `opts.stream` is definitely a stream or inherited from a stream (all streams have
    a `pause` method, and `in` checks for the property throughout the entire prototype
    chain). Another noteworthy expression among the `validOpts` tests is `!isNaN(+opts.size)`,
    which checks whether `opts.size` is a valid number. The `+` which precedes it
    converts it to a `Number` type and `!isNaN` checks that it isn't`"not a number"`
    (there is no `isNumber` in JavaScript so we use `!isNaN)`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`statStream`的顶部，我们有`validOpts`变量，其中有一系列由`&&`条件连接的表达式。这是一堆`if`语句的简写。如果这些表达式中的任何一个测试失败，`opts`对象就无效。一个有趣的表达式是`opts.stream`中的`'pause'`，它测试`opts.stream`是否绝对是一个流或者是从流继承而来的（所有流都有一个`pause`方法，`in`检查整个原型链中的属性）。在`validOpts`测试中另一个值得注意的表达式是`!isNaN(+opts.size)`，它检查`opts.size`是否是一个有效的数字。前面的`+`将其转换为`Number`类型，`!isNaN`检查它是否不是`"not
    a number"`（JavaScript中没有`isNumber`，所以我们使用`!isNaN`）。
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now we have this new method. Let's write some more examples. We'll also see
    how we can merge `statStream` and `stat` together, and further enhance our module
    by causing it to emit events.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个新方法。让我们写一些更多的例子。我们还将看到如何将`statStream`和`stat`合并在一起，并通过使其发出事件来进一步增强我们的模块。
- en: Making the STDIN stream example
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作标准输入流示例
- en: 'To demonstrate usage with other streams we might write an example using the
    `process.stdin` stream as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示与其他流的使用，我们可以编写一个使用`process.stdin`流的示例，如下所示：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've included comments in the example to ensure our users understand how to
    use it. All we do here is receive the `process.stdin` stream and the file size,
    then pass them to our `statStream` method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中包含了注释，以确保我们的用户了解如何使用它。我们在这里所做的就是接收`process.stdin`流和文件大小，然后将它们传递给我们的`statStream`方法。
- en: Making the PUT upload stream example
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作PUT上传流示例
- en: In the *Handling file uploads recipe* of[Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"), *Exploring the HTTP Object*, we created a PUT upload implementation
    in the *There's more..*. section of that recipe.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。探索HTTP对象")的*处理文件上传食谱*中，*探索HTTP对象*，我们在那个食谱的*还有更多..*部分创建了一个PUT上传实现。
- en: We'll take the `put_upload_form.html` file from that recipe, and create a new
    file called `HTTP_PUT_stream.js` in our `mp3dat/examples` folder.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从该示例中获取`put_upload_form.html`文件，并在`mp3dat/examples`文件夹中创建一个名为`HTTP_PUT_stream.js`的新文件。
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we create a server that serves the `put_upload_form.html` file. The HTML
    file allows us to specify a file to upload (which must be a valid MP3 file), and
    then sends it to the server.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个服务器，用于提供`put_upload_form.html`文件。HTML文件允许我们指定要上传的文件（必须是有效的MP3文件），然后将其发送到服务器。
- en: In our server, we pass `req` (which is a stream) to the `stream` property and
    `req.headers['content-length']` which gives us the size of MP3 in bytes as specified
    by the browser via the `Content-Length` header.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务器中，我们将`req`（一个流）传递给`stream`属性和`req.headers['content-length']`，这样我们就可以得到MP3的大小（以浏览器通过`Content-Length`头部指定的字节为单位）。
- en: We then finish by logging `stats` to the console (we could also extend this
    example by sending `stats` back to the browser in JSON form).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过在控制台上记录`stats`来完成（我们还可以通过以JSON形式将`stats`发送回浏览器来扩展此示例）。
- en: Merging stat and statStream
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并stat和statStream
- en: There's a lot of similar code between `stat` and `statStream`. With a bit of
    restructuring, we can merge them into one method, allowing the user to pass either
    a string containing a filename or an object containing stream and size properties
    straight into the `stat` method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`stat`和`statStream`之间有很多相似的代码。通过一些重构，我们可以将它们合并成一个方法，允许用户将包含文件名的字符串或包含流和大小属性的对象直接传递给`stat`方法。'
- en: 'First, we''d need to update our tests and examples. In `test/index.js`, we
    should remove the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更新我们的测试和示例。在`test/index.js`中，我们应该删除以下代码：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Since we''re merging `statStream` into `stat`, our two calls to `stat` and
    `statStream` should become:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在将`statStream`合并到`stat`中，我们对`stat`和`statStream`的两次调用应该变成：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `statStream` line in `examples/stdin_stream.js` should become:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`examples/stdin_stream.js`中的`statStream`行应该变成：'
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `HTTP_PUT_stream.js` it should be:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HTTP_PUT_stream.js`中应该是：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In `lib/index.js`, we trash the `streamStat` method, inserting a `_compile`
    method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lib/index.js`中，我们删除`streamStat`方法，插入`_compile`方法：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we modify our `Mp3dat.prototype.stat` method as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们修改我们的`Mp3dat.prototype.stat`方法如下：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The code that actually generates the `stats` has been placed into the `_compile`
    method. If the first argument is an object, we assume a stream and `stats` take
    on the role of the former `statStream`, calling `_compile` and returning from
    the function early. If not, we assume a filename and invoke `_compile` within
    the `fs.stat` callback with JavaScript's `call` method, ensuring our `this` /
    `self` variable carries through the `_compile` method.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际生成`stats`的代码已放入`_compile`方法中。如果第一个参数是一个对象，我们假设是一个流，`stats`就承担了以前的`statStream`的角色，调用`_compile`并从函数中提前返回。如果不是，我们假设是一个文件名，并使用JavaScript的`call`方法在`fs.stat`回调中调用`_compile`，确保我们的`this`/`self`变量通过`_compile`方法传递。
- en: Integrating the EventEmitter
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成EventEmitter
- en: Throughout this book, we have generally received data from modules via callback
    parameters or through listening for events. We can extend our `modules` interface
    further, allowing users to listen for events by causing Node's `EventEmitter`
    to adopt our `Mp3dat` constructor.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们通常通过回调参数或通过侦听事件来从模块中接收数据。我们可以进一步扩展我们的`modules`接口，允许用户通过使Node的`EventEmitter`采用我们的`Mp3dat`构造函数来侦听事件。
- en: We need to require the `events` and `util` modules, then hook up `Mp3dat` with
    `EventEmitter` by assigning the `this` object of `Mp3dat` to it, and then give
    it the super powers of `Mp3dat EventEmitter` by using `util.inherits:`
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要引入`events`和`util`模块，然后通过将`Mp3dat`的`this`对象分配给它来将`Mp3dat`与`EventEmitter`连接起来，然后使用`util.inherits`给它`Mp3dat
    EventEmitter`的超级能力：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'All we do now is go through the existing methods of `Mp3dat` and insert the
    `emit` events in relevant places. We can `emit` the `bitrate` once it''s found
    as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需遍历`Mp3dat`的现有方法，并在相关位置插入`emit`事件。一旦找到`bitrate`，我们就可以像下面这样`emit`它：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Where we would callback with an error, we can also emit that error as shown
    in the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回调错误的地方，我们也可以像下面的代码一样发出错误：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then there''s the time signature:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是时间签名：
- en: '[PRE61]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And of course, the `stats` object:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`stats`对象：
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We've also added `if (cb)` to `_buildStats`, since a callback may no longer
    be necessary if the user opts to listen for events instead.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`_buildStats`中添加了`if (cb)`，因为如果用户选择侦听事件，则回调可能不再必要。
- en: 'If a module user is dynamically generating the `Mp3dat` instances, they may
    wish to have a way to hook into a spawned instance event:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块用户动态生成`Mp3dat`实例，他们可能希望有一种方法来连接到生成的实例事件：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, to allow chaining, we can also return the `Mp3dat` instance from the
    `stat` function from two places. First within the `isOptsObj` block as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了允许链接，我们还可以从两个地方的`stat`函数返回`Mp3dat`实例。首先在`isOptsObj`块内如下：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then right at the end of the function, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在函数的最后，如下所示的代码：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is because we return early from the function depending on the detected
    input (filename or stream), so we have to return `self` from two places.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们根据检测到的输入（文件名或流）从函数中提前返回，所以我们必须从两个地方返回`self`。
- en: Now we can write an example for our new user interface. Let's make a new file
    in `mp3dat/examples` called `event_emissions.js`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为我们的新用户界面编写一个示例。让我们在`mp3dat/examples`中创建一个名为`event_emissions.js`的新文件。
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: See also
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating a test-driven module API* discussed in this chapter'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论创建一个测试驱动的模块API*'
- en: '*Handling file uploads* discussed In [Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"),Exploring the HTTP Object'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理文件上传*在[第2章](ch02.html "第2章。探索HTTP对象")中讨论，探索HTTP对象'
- en: '*Deploying a module to npm* discussed in this chapter'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论将模块部署到npm*'
- en: Deploying a module to npm
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模块部署到npm
- en: 'Now that we''ve created a module, we can share it with the rest of the world
    using the same integrated tool that we retrieve modules with: `npm`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个模块，我们可以使用相同的集成工具与世界其他地方分享它：`npm`。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'Before we can deploy to npm we need to make a `package.json` file, so let''s
    do that for our module. In `mp3dat`, we''ll create `package.json` and add the
    following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以部署到npm之前，我们需要创建一个`package.json`文件，所以让我们为我们的模块做这个。在`mp3dat`中，我们将创建`package.json`并添加以下代码：
- en: '[PRE67]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We can of course insert our own name and the name of the package. Another way
    to create a `package.json` file is to use `npm init` which asks a series of questions
    via the command line, then generates the `package.json` file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以插入我们自己的名称和包的名称。创建`package.json`文件的另一种方法是使用`npm init`，它通过命令行询问一系列问题，然后生成`package.json`文件。
- en: We can specify a repository in `package.json`. It's a good idea to use an online
    repository such as GitHub to manage version control, share code, and allow others
    to work on your code. See [http://help.github.com/](http://help.github.com/) to
    get started.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`package.json`中指定一个存储库。使用在线存储库（如GitHub）来管理版本控制、共享代码并允许其他人在您的代码上工作是一个好主意。请参阅[http://help.github.com/](http://help.github.com/)开始使用。
- en: The `main` property is important. It defines the entry point to our module,
    which in our case is `./lib/index.js` (although we could have specified `./index.js`
    which loads `./lib/index.js)`. By defining `scripts.test` as `node test`, we can
    now run `npm test` (or `npm mp3dat test` once `mp3dat` is installed via `npm)`
    to execute our unit tests.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`属性很重要。它定义了我们模块的入口点，在我们的情况下是`./lib/index.js`（尽管我们也可以指定`./index.js`来加载`./lib/index.js`）。通过将`scripts.test`定义为`node
    test`，我们现在可以运行`npm test`（或者一旦通过`npm`安装了`mp3dat`，就可以运行`npm mp3dat test`）来执行我们的单元测试。'
- en: We'll be deploying our module to npm as we left it in the previous recipe, where
    `stat` and `statStream` were both merged into `stat`, and we have integrated with
    `EventEmitter`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照上一个步骤中的方式将我们的模块部署到npm，其中`stat`和`statStream`都合并到了`stat`中，并且我们已经集成了`EventEmitter`。
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To deploy to `npm`, we must have a developer account. We do this by executing
    the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署到`npm`，我们必须拥有开发者账户。我们通过执行以下操作来实现这一点：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: And filling in our desired username, password, and contact email. That's it,
    we are now registered.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 填写我们想要的用户名、密码和联系邮箱。就这样，我们现在注册了。
- en: 'Before we go ahead and publish our module, we''ll want to test that `npm` will
    install it on our system without a hitch. Inside `mp3dat` we do the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续发布我们的模块之前，我们会想要测试`npm`是否会在我们的系统上安装它。在`mp3dat`中，我们执行以下操作：
- en: '[PRE69]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then if we run `node` from the command line, we should be able to:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们从命令行运行`node`，我们应该能够：
- en: '[PRE70]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Without getting an error message. If it worked, we can go ahead and publish
    our module! Within `mp3dat` we say the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有收到错误消息。如果成功了，我们可以继续发布我们的模块！在`mp3dat`中，我们说以下内容：
- en: '[PRE71]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now if we go to a completely different folder (say our home folder) and type
    the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们转到一个完全不同的文件夹（比如我们的主文件夹）并输入以下内容：
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`npm` should install our package from its repository.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`应该从其存储库中安装我们的包。'
- en: 'We can double check if it''s there with the following command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下命令来双重检查它是否存在：
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Or, if that's taking too long, we can go to [http://search.npmjs.org/](http://search.npmjs.org/)
    in our browser. Our module will probably be on the home page (which contains the
    most recently published modules). Or we can hit [http://search.npmjs.org/#/mp3dat](http://search.npmjs.org/#/mp3dat)
    to head to our module's npm registry page directly.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果这花费的时间太长，我们可以在浏览器中转到[http://search.npmjs.org/](http://search.npmjs.org/)。我们的模块可能会出现在主页上（其中包含最近发布的模块）。或者我们可以点击[http://search.npmjs.org/#/mp3dat](http://search.npmjs.org/#/mp3dat)直接转到我们模块的npm注册页面。
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`npm` is a command-line script written in Node which provides some excellent
    tools for developing and publishing modules. The tools really do what they say
    on the tin, `adduser` adds a user, `install` installs, and `publish` publishes.
    It''s really very elegant.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`是一个用Node编写的命令行脚本，为开发和发布模块提供了一些出色的工具。这些工具确实做到了它们所说的，`adduser`添加用户，`install`安装，`publish`发布。这真的非常优雅。'
- en: 'On the server side, the `npm` registry is backed by a CouchDB database that
    holds all the JSON-like data for each package. There''s even a CouchDB `_changes`
    field we could hook into. On the command line, we could do:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，`npm`注册表由一个CouchDB数据库支持，该数据库保存了每个包的类似JSON的数据。甚至有一个我们可以连接到的CouchDB `_changes`字段。在命令行上，我们可以这样做：
- en: '[PRE74]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And watch modules as they are added and modified in real time. If nothing is
    happening, we could always open another terminal and type the following commands:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 观察模块在实时中添加和修改。如果没有发生任何事情，我们可以打开另一个终端并输入以下命令：
- en: '[PRE75]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Which will cause the CouchDB changes feed to update.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致CouchDB更改反馈更新。
- en: There's more...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`npm` has some really nice features, let''s take a look at some.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`有一些非常好的功能，让我们来看看其中的一些。'
- en: npm link
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: npm link
- en: The `npm link` command can be useful for module authors.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm link`命令对于模块作者来说可能很有用。'
- en: 'Throughout development, if we wanted to require `mp3dat` as a global module,
    for example as `require(''mp3dat'')`, each time we make changes we could update
    the global package by running:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，如果我们想要将`mp3dat`作为全局模块进行引用，例如`require('mp3dat')`，每次进行更改时，我们可以通过运行以下命令来更新全局包：
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'However, `npm link` provides an easier solution, when we run the following
    command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们运行以下命令时，`npm link`提供了一个更简单的解决方案：
- en: '[PRE77]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Within our `mp3dat` folder, a symlink is created from our global `node_modules`
    folder to our working directory. This causes Node to treat `mp3dat` as an installed
    global module, but any changes we make to our development copy will be reflected
    globally. When we are finished developing, and want to freeze the module on our
    system, we simply unlink as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`mp3dat`文件夹中，从我们的全局`node_modules`文件夹到我们的工作目录创建了一个符号链接。这会导致Node将`mp3dat`视为已安装的全局模块，但我们对开发副本所做的任何更改都将在全局范围内反映出来。当我们完成开发并希望在系统上冻结模块时，我们只需取消链接，如下所示：
- en: '[PRE78]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: .npmignore and npm version
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .npmignore和npm版本
- en: 'Our `example` files may be handy on GitHub, but we may decide they''re of little
    benefit within `npm`. We can use an `.npmignore` file to keep certain files out
    of published `npm` packages. Let''s create `.npmignore` in the `mp3dat` folder,
    and put:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`example`文件可能在GitHub上很方便，但我们可能会决定它们在`npm`中没有什么好处。我们可以使用`.npmignore`文件来阻止某些文件被发布到`npm`包中。让我们在`mp3dat`文件夹中创建`.npmignore`，并放入：
- en: '[PRE79]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, when we re-publish to the `npm` registry, our new package will be minus
    the `examples` folder. Before we can publish though, we either have to unpublish,
    or change the version of our package (or we could use the `--force` argument).
    Let''s change the version, then publish again:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们重新发布到`npm`注册表时，我们的新包将不包括`examples`文件夹。在我们可以发布之前，我们要么取消发布，要么更改我们包的版本（或者我们可以使用`--force`参数）。让我们改变版本，然后再次发布：
- en: '[PRE80]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Changing the version will also alter our `package.json` file to the new version
    number.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 更改版本还将改变我们的`package.json`文件到新的版本号。
- en: See also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing a functional module mock-up* discussed in this chapter'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写一个功能模块的模拟*在本章讨论'
- en: '*Refactoring from functional to prototypical* discussed in this chapter'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从功能到原型的重构*在本章讨论'
- en: '*Extending the module''s API* discussed in this chapter'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章讨论的扩展模块的API*'
- en: '*Accessing CouchDB changes stream with Cradle* discussed In [Chapter 4](ch04.html
    "Chapter 4. Interfacing with Databases"),Interfacing with Databases'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Cradle访问CouchDB更改流*在[第4章](ch04.html "第4章。与数据库交互")中讨论，与数据库交互'
