- en: Chapter 4. Interfacing with Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。与数据库交互
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Writing to a CSV file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入CSV文件
- en: Connecting and sending SQL to a MySQL server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接并向MySQL服务器发送SQL
- en: Storing and retrieving data with MongoDB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB存储和检索数据
- en: Storing and retrieving data with Mongoskin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mongoskin存储和检索数据
- en: Storing data to CouchDB with Cradle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cradle将数据存储到CouchDB
- en: Retrieving data from CouchDB with Cradle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cradle从CouchDB检索数据
- en: Accessing CouchDB changes stream with Cradle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cradle访问CouchDB更改流
- en: Storing and retrieving data with Redis
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis存储和检索数据
- en: Implementing PubSub with Redis
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis实现PubSub
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: As the complexity of our code and the demands of our objectives increase, we
    soon realize the need for a place to store our data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们代码的复杂性和目标的要求增加，我们很快意识到需要一个地方来存储我们的数据。
- en: 'We then have to ask the question: What is the best way to store our data? The
    answer depends on the type of data we are working with since different challenges
    require different solutions.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须问一个问题：存储我们的数据的最佳方式是什么？答案取决于我们正在处理的数据类型，因为不同的挑战需要不同的解决方案。
- en: If we're doing something very simple, we could save our data as a flat CSV file,
    which has the added benefit of enabling users to view the CSV file in a spreadsheet
    application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在做一些非常简单的事情，我们可以将我们的数据保存为一个平面的CSV文件，这样做的好处是使用户能够在电子表格应用程序中查看CSV文件。
- en: If we are working with data that has clearly relational qualities, for instance
    accounting data whereby there are clear, distinct relationships between two sides
    of a transaction, then we would choose a relational database such as the popular
    MySQL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是具有明显关系特性的数据，例如会计数据，其中交易的两个方面之间存在明显的关系，那么我们会选择关系数据库，比如流行的MySQL。
- en: In many cases relational databases became a de facto standard for nearly all
    data scenarios. This led to the necessity of imposing relationships upon otherwise
    loosely-related data (such as website content) in an attempt to squeeze it into
    our relational mental model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，关系数据库成为了几乎所有数据场景的事实标准。这导致了对本来松散相关的数据（例如网站内容）施加关系的必要性，试图将其挤入我们的关系心理模型中。
- en: In recent times, though, there has been a movement away from relational databases
    towards NoSQL, a non-relational paradigm. The driving force being that we tailor
    our technology to best suit our data rather than trying to fit our data into our
    technology.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，近年来，人们已经开始从关系数据库转向NoSQL，一种非关系范式。推动力是我们要根据数据最适合我们的技术，而不是试图将我们的数据适应我们的技术。
- en: In this chapter, we will look into various data storage technologies with examples
    of their usage in Node.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨各种数据存储技术，并举例说明它们在Node中的使用。
- en: Writing to a CSV file
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入CSV文件
- en: A flat file structure is one of the most elementary database models. Columns
    can either be fixed length, or use delimiters. The Comma Separated Values (CSV)
    convention conforms to the idea of delimited flat file structure databases. While
    it's called CSV, the term CSV is also applied as a broad blanket term for any
    basic delimited structure consisting of one record per line (for example, tab-separated
    values).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 平面文件结构是最基本的数据库模型之一。列可以是固定长度，也可以使用分隔符。逗号分隔值（CSV）约定符合分隔的平面文件结构数据库的概念。虽然它被称为CSV，但CSV这个术语也被广泛应用于任何基本的分隔结构，每行一个记录（例如，制表符分隔的值）。
- en: 'We could follow a brittle approach for constructing CSV structures, simply
    by using a multidimensional array and the `join` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用多维数组和`join`方法来遵循一个脆弱的方法来构建CSV结构：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, the limitations of this technique quickly become apparent. What if
    one of our fields contains a comma? Now one field becomes two, thus corrupting
    our data. Furthermore, we are limited to just using commas as delimiters.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种技术的局限性很快变得明显。如果我们的字段中包含逗号怎么办？现在一个字段变成了两个，从而破坏了我们的数据。此外，我们只能使用逗号作为分隔符。
- en: In this recipe we will use the third-party `ya-csv` module to store data in
    the CSV format.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用第三方的`ya-csv`模块以CSV格式存储数据。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create a file called `write_to_csv.js`, we'll also need to retrieve `ya-csv`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`write_to_csv.js`的文件，我们还需要检索`ya-csv`。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We require the `ya-csv` module, call its `createCsvFileWriter` method to instantiate
    a CSV file writer and loop through our array, calling the `writeRecord` method
    of the CSV file writer:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`ya-csv`模块，调用它的`createCsvFileWriter`方法来实例化一个CSV文件写入器，并循环遍历我们的数组，调用CSV文件写入器的`writeRecord`方法：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's take a look at the file we saved to, `data.csv:`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们保存的文件，`data.csv:`
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The difficulty with writing to and reading from CSV files is the edge cases,
    such as commas or quotes embedded in text. `ya-csv` handles these edge cases for
    us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 写入和读取CSV文件的困难之处在于边缘情况，比如嵌入在文本中的逗号或引号。`ya-csv`为我们处理了这些边缘情况。
- en: We load an instance of `CsvWriter` of `ya-csv` into the `writer` variable with
    `createCsvFileWriter`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`createCsvFileWriter`将`ya-csv`的`CsvWriter`的实例加载到`writer`变量中。
- en: Then we simply loop through each array as `rec`, passing it to the `writeRecord`
    method of `CsvWriter` of `ya-csv`. Behind the scenes it re-factors each array
    and passes it to an instance of `fs.WriteStream`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们简单地循环遍历每个数组作为`rec`，将其传递给`ya-csv`的`CsvWriter`的`writeRecord`方法。在幕后，它会重新构造每个数组并将其传递给`fs.WriteStream`的实例。
- en: This recipe depends upon us using a basic data structure in our code. Multidimensional
    objects would have to be massaged into the right format as `writeRecord` only
    functions with arrays.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例取决于我们在代码中使用基本的数据结构。多维对象必须被转换成正确的格式，因为`writeRecord`只能处理数组。
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Could we easily create this functionality ourselves? Without a doubt. However,
    `ya-csv` provides an API for us to seamlessly customize the elements of our CSV
    files, and implements the more involved CSV parsing functionality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否轻松地自己创建这个功能？毫无疑问。然而，`ya-csv`为我们提供了一个API，可以无缝地定制我们的CSV文件的元素，并实现更复杂的CSV解析功能。
- en: Customizing the CSV elements
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义CSV元素
- en: 'If we save our recipe file as `write_to_custom_csv.js`, and pass an `options`
    object to `createCsvFileWriter`, we can alter the way our CSV files are constructed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的配方文件保存为 `write_to_custom_csv.js`，并将一个 `options` 对象传递给 `createCsvFileWriter`，我们可以改变我们的
    CSV 文件构造方式：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice the `escape` option. This sets the character which will prevent accidental
    closure of a CSV field. Let''s slip one into our array to see how `ya-csv` handles
    it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `escape` 选项。这将设置防止意外关闭 CSV 字段的字符。让我们将其插入到我们的数组中，看看 `ya-csv` 如何处理它：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After running our new code, let's take a look at `custom_data.csv:`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的新代码后，让我们看看 `custom_data.csv`：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See how our pipe character in the `e` field has another pipe appended to it
    in order to escape it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们在 `e` 字段中的管道字符后面添加了另一个管道以进行转义。
- en: Reading a CSV file
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取 CSV 文件
- en: We can also use `ya-csv` to read from a CSV file, its built-in parser converts
    each CSV record back into an array. Let's make `read_from_csv.js`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `ya-csv` 从 CSV 文件中读取，其内置解析器将每个 CSV 记录转换回数组。让我们制作 `read_from_csv.js`。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we want it to parse alternative delimiters and quotes, we simply pass these
    into the `options` object of `createCsvFileReader:`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望解析替代分隔符和引号，我们只需将它们传递到 `createCsvFileReader` 的 `options` 对象中：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Manipulating CSV as a stream
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作 CSV 作为流
- en: '`ya-csv` interacts with CSV files as streams. This can reduce operational memory
    since streams allow us to process small chunks of information as they are loaded,
    instead of buffering the entire file into memory first.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`ya-csv` 与 CSV 文件交互作为流。这可以减少操作内存，因为流允许我们在加载时处理小块信息，而不是首先将整个文件缓冲到内存中。'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Connecting and sending SQL to a MySQL* server discussed in this chapter'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了连接并向 MySQL 服务器发送 SQL*'
- en: '*Storing and retrieving data with Mongoskin* discussed in this chapter'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用 Mongoskin 存储和检索数据*'
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Cradle 将数据存储到 CouchDB* 在本章中讨论'
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用 Redis 存储和检索数据*'
- en: Connecting and sending SQL to a MySQL server
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接并向 MySQL 服务器发送 SQL
- en: Structured Query Language has been a standard since 1986 and it's the prevailing
    language for relational databases. MySQL is the most popular SQL relational database
    server around, often appearing in the prevalent LAMP (Linux Apache MySQL PHP)
    stack.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 自1986年以来，结构化查询语言一直是标准，也是关系数据库的主要语言。MySQL 是最流行的 SQL 关系数据库服务器，经常出现在流行的 LAMP（Linux
    Apache MySQL PHP）堆栈中。
- en: If a relational database was conceptually relevant to our goals in a new project,
    or we were migrating a MySQL-backed project from another framework to Node, the
    third-party `mysql` module would be particularly useful.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关系数据库在新项目的目标中概念上相关，或者我们正在将基于 MySQL 的项目从另一个框架迁移到 Node，第三方 `mysql` 模块将特别有用。
- en: In this task, we will discover how to connect to a MySQL server with Node and
    execute SQL queries across the wire.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将发现如何使用 Node 连接到 MySQL 服务器并在网络上执行 SQL 查询。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's grab `mysql`, which is a pure JavaScript (as opposed to C++ bound) MySQL
    client module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取 `mysql`，这是一个纯 JavaScript（而不是 C++ 绑定）的 MySQL 客户端模块。
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll need a MySQL server to connect to. By default, the `mysql` client module
    connects to `localhost`, so we'll have MySQL running locally.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 MySQL 服务器进行连接。默认情况下，`mysql` 客户端模块连接到 `localhost`，因此我们将在本地运行 MySQL。
- en: 'On Linux and Mac OSX we can see if MySQL is already installed with the following
    command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 Mac OSX 上，我们可以使用以下命令查看 MySQL 是否已安装：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And we can see if it is running using the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令查看它是否正在运行：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If it is installed but not running, we can do:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已安装但未运行，我们可以执行：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If MySQL isn't installed we can use the relevant package manager for our system
    (homebrew, apt-get/synaptic, yum, and so on), or if we're using Node on Windows
    we can head to [http://dev.mysql.com/downloads/mysql](http://dev.mysql.com/downloads/mysql)
    and download the installer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 MySQL 没有安装，我们可以使用系统的相关软件包管理器（homebrew、apt-get/synaptic、yum 等），或者如果我们在 Windows
    上使用 Node，我们可以前往 [http://dev.mysql.com/downloads/mysql](http://dev.mysql.com/downloads/mysql)
    并下载安装程序。
- en: Once we're ready to go, let's create a file and call it `mysql.js`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好，让我们创建一个文件并将其命名为 `mysql.js`。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we require the third-party `mysql` driver, and create a connection to
    the server:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要第三方的 `mysql` 驱动程序，并创建与服务器的连接：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need a database to connect to. Let''s keep things interesting and make a
    `quotes` database. We can do that by passing SQL to the `query` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要连接的数据库。让我们保持有趣，创建一个 `quotes` 数据库。我们可以通过将 SQL 传递给 `query` 方法来实现：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've also called the `useDatabase` method to connect to the database, although
    we could achieve the same with `client.query('USE quotes')`. Now we'll create
    a table by the same name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调用了 `useDatabase` 方法来连接到数据库，尽管我们可以通过 `client.query('USE quotes')` 实现相同的效果。现在我们将创建一个同名的表。
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we were to run our code more than once, we'd notice that an unhandled error
    is thrown and the program fails. This is due to the `mysql` driver emitting an
    error event in reflection of a MySQL server error. It's throwing an unhandled
    error because the `quotes` database (and table) cannot be created as they already
    exist.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的代码超过一次，我们会注意到一个未处理的错误被抛出，程序失败。这是因为 `mysql` 驱动程序发出了一个错误事件，反映了 MySQL
    服务器的错误。它抛出了一个未处理的错误，因为 `quotes` 数据库（和表）无法创建，因为它们已经存在。
- en: 'We want our code to be versatile enough to create a database if necessary,
    but not throw an error if it''s not there. To do this, we''re going to catch any
    errors emitted by our client instance, filtering out the database/table exists
    errors:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的代码足够灵活，可以在必要时创建数据库，但如果不存在则不会抛出错误。为此，我们将捕获客户端实例发出的任何错误，过滤掉数据库/表存在的错误：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We'll place our error catcher just before the `client.query` method invocations.
    Finally, at the end of our code, we'll insert our first quote into the table and
    send a `COM_QUIT` packet (using `client.end)` to the MySQL server. This will only
    close the connection once all queued SQL has been executed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`client.query`方法调用之前放置我们的错误捕获器。最后，在我们的代码末尾，我们将向表中插入我们的第一条引用，并发送一个`COM_QUIT`数据包（使用`client.end`）到MySQL服务器。这将只在所有排队的SQL被执行后关闭连接。
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `createClient` method establishes a connection to the server and returns
    a client instance for us to interact with. We can pass it as an `options` object
    that may contain `host, port, user, password, database, flags`, and `debug` .
    Other than `user` and `password`, the default options are fine for our purposes
    though. If we uncomment `debug` we can see the raw data being sent to and from
    the server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`createClient`方法建立与服务器的连接，并为我们返回一个客户端实例以便与之交互。我们可以将其作为一个`options`对象传递，该对象可能包含`host,
    port, user, password, database, flags`和`debug`。除了`user`和`password`之外，对于我们的目的来说，默认选项都是可以的。如果我们取消注释`debug`，我们可以看到被发送到服务器和从服务器接收的原始数据。'
- en: '`client.query` sends SQL to our database which is then executed by the MySQL
    server. With it, we `CREATE` a `DATABASE` named `quotes` and also a `TABLE` named
    `quotes`. Then we `INSERT` our first record (a quote by the inventor of C++) into
    our database.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.query`将SQL发送到我们的数据库，然后由MySQL服务器执行。使用它，我们`CREATE`一个名为`quotes`的`DATABASE`，还有一个名为`quotes`的`TABLE`。然后我们将我们的第一条记录（C++的发明者的引用）插入到我们的数据库中。'
- en: '`client.query` queues each piece of SQL passed to it, executing statements
    asynchronously alongside our other code, but sequentially within the SQL statement
    queue. When we call `client.end`, the connection closing task is added to the
    end of the queue. If we wanted to disregard the statement queue, and immediately
    end the connection, we would use `client.destroy`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.query`将每个传递给它的SQL语句排队，与我们的其他代码异步执行语句，但在SQL语句队列中是顺序执行的。当我们调用`client.end`时，连接关闭任务将被添加到队列的末尾。如果我们想要忽略语句队列，并立即结束连接，我们将使用`client.destroy`。'
- en: Our `ignore` array holds two numbers, `1007` and `1050 — we` grab these numbers
    from the `mysql` object, which holds MySQL error codes. We want to ignore MySQL
    errors that occur when a table or database already exists, otherwise we could
    only run `mysql.js` once. After the first run it would crash since the database
    and table would already exist. Ignoring these codes means we can implicitly set
    up our database, and have just one file rather than a setup app and a separate
    app for inserting code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ignore`数组包含两个数字，`1007`和`1050 — 我们从`mysql`对象中获取这些数字，该对象包含MySQL错误代码。我们希望忽略MySQL在表或数据库已经存在时发生的错误，否则我们只能运行`mysql.js`一次。第一次运行后，它会崩溃，因为数据库和表已经存在。忽略这些代码意味着我们可以隐式地设置我们的数据库，并且只有一个文件，而不是一个用于设置和一个用于插入代码的单独的应用程序。
- en: In the `error` event listener we check if `err.number` is within our `ignore`
    array. If it is, we simply `return`, thus ignoring the error and gracefully continuing
    execution. If the error is of some other nature, we fall through to the usual
    behavior of throwing the error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`error`事件监听器中，我们检查`err.number`是否在我们的`ignore`数组中。如果是，我们简单地`return`，从而忽略错误并优雅地继续执行。如果错误是其他性质的，我们将继续执行抛出错误的通常行为。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We don't just send data to MySQL, we retrieve it. Furthermore, SQL queries are
    often generated from user input, but this can be open to exploitation if precautions
    aren't taken.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅将数据发送到MySQL，还会检索数据。此外，SQL查询通常是从用户输入生成的，但如果不采取预防措施，这可能会被利用。
- en: Using and cleaning user input
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用和清理用户输入
- en: As in other languages that build SQL statements with string concatenation, we
    must prevent the possibilities of SQL injection attacks to keep our server safe.
    Essentially, we must clean (which is, escape) any user input to eradicate the
    potential for unwanted SQL manipulation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他使用字符串连接构建SQL语句的语言一样，我们必须防止SQL注入攻击的可能性，以保持服务器的安全。基本上，我们必须清理（即转义）任何用户输入，以消除不需要的SQL操纵的可能性。
- en: We'll copy `mysql.js` and call it `insert_quotes.js`. To implement the concept
    of user input in a simple way we'll pull arguments from the command line, but
    the principles and methods of data cleaning extend to any input method (for example,
    via a query string on a request).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制`mysql.js`并将其命名为`insert_quotes.js`。为了以简单的方式实现用户输入的概念，我们将从命令行中提取参数，但是数据清理的原则和方法适用于任何输入方法（例如，通过请求的查询字符串）。
- en: 'Our basic API will go like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本API将是这样的：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Quotation marks are essential to divide the command-line arguments, but for
    the sake of brevity we won't be implementing any validation checks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 引号是将命令行参数分隔的必要条件，但为了简洁起见，我们不会实现任何验证检查。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Command-line parsing module: optimist**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行解析模块：optimist**'
- en: For more advanced command-line functionality, check out the excellent `optimist`
    module , available at [https://www.github.com/substack/node-optimist](https://www.github.com/substack/node-optimist).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的命令行功能，请查看优秀的`optimist`模块，网址为[https://www.github.com/substack/node-optimist](https://www.github.com/substack/node-optimist)。
- en: To receive an author and quote, we'll load the two quotes arguments into a new
    `params` object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收作者和引用，我们将两个引用参数加载到一个新的`params`对象中。
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our first argument is at `2` in the `process.argv` array because `0` and `1`
    hold `node` and `quotes.js`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个参数在`process.argv`数组中是`2`，因为`0`和`1`分别是`node`和`quotes.js`。
- en: 'Now let''s slightly modify our `INSERT` statement:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们稍微修改我们的`INSERT`语句：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've placed this just before our final `client.end` call in the main recipe.
    The `mysql` module can seamlessly clean user input for us. We simply use the question
    mark (?) as a placeholder and then pass our values (in order) as an array into
    the second parameter of `client.query`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个放在主要的`client.end`调用之前。`mysql`模块可以无缝地为我们清理用户输入。我们只需使用问号（？）作为占位符，然后将我们的值（按顺序）作为数组传递到`client.query`的第二个参数中。
- en: Receiving results from the MySQL server
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从MySQL服务器接收结果
- en: Let's extend `insert_quotes.js` further by outputting all quotes for an author,
    whether or not a quote is provided. We'll save `insert_quotes.js` simply as `quotes.js`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过输出所有作者的引用来进一步扩展`insert_quotes.js`，无论是否提供了引用。我们将`insert_quotes.js`简单保存为`quotes.js`。
- en: 'Underneath our `INSERT` query, but above the final `client.end`, we''ll add
    the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`INSERT`查询下面，但在最终的`client.end`之上，我们将添加以下代码：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: On this occasion, we've used an alternative approach to clean user input with
    `client.escape`. This has exactly the same effect as the former, but only escapes
    a single input. Generally, if there's more than one variable, the former method
    would be preferable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了另一种方法来清理用户输入，即`client.escape`。这与前一种方法的效果完全相同，但只转义单个输入。通常，如果有多个变量，前一种方法更可取。
- en: The results of a `SELECT` statement can be accessed either by passing a callback
    function, or by listening for the `row` event. A `row` event listener allows us
    to interact with a MySQL server data stream, one row at a time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递回调函数或监听`row`事件来访问`SELECT`语句的结果。`row`事件监听器允许我们逐行与MySQL服务器数据流交互。
- en: We can safely call `client.end` without putting it in the `end` event of our
    `SELECT` query because `client.end` only terminates a connection when all queries
    are done.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地调用`client.end`，而不必将其放在我们的`SELECT`查询的`end`事件中，因为`client.end`只有在所有查询完成时才会终止连接。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用MongoDB存储和检索数据*'
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用Redis存储和检索数据*'
- en: Storing and retrieving data with MongoDB
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB存储和检索数据
- en: MongoDB is a NoSQL database offering that maintains a philosophy of performance
    over features. It's designed for speed and scalability. Instead of working relationally,
    it implements a document-based model that has no need for schemas (column definitions).
    The document model works well for scenarios where relationships between data are
    flexible and where minimal potential data loss is an acceptable cost for the speed
    enhancements (a blog for instance).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一种NoSQL数据库提供，坚持性能优于功能的理念。它专为速度和可扩展性而设计。它实现了一个基于文档的模型，不需要模式（列定义），而不是关系工作。文档模型适用于数据之间关系灵活且最小潜在数据丢失是速度增强的可接受成本的情况（例如博客）。
- en: While it's in the NoSQL family, MongoDB attempts to sit between two worlds,
    providing a syntax reminiscent of SQL but operating non-relationally.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它属于NoSQL家族，但MongoDB试图处于两个世界之间，提供类似SQL的语法，但以非关系方式运行。
- en: In this task, we'll implement the same `quotes` database as in the previous
    recipe, using MongoDB instead of MySQL.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将实现与之前的配方相同的`quotes`数据库，但使用MongoDB而不是MySQL。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll want to run a MongoDB server locally. It can be downloaded from [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要在本地运行一个MongoDB服务器。可以从[http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)下载。
- en: 'Let''s start the MongoDB service, `mongod`, in the default debug mode:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以默认的调试模式启动MongoDB服务`mongod`：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This allows us to observe the activities `mongod` as it interacts with our code,
    if we wanted to start it as a persistent background service we would use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够观察`mongod`与我们的代码交互的活动，如果我们想要将其作为持久后台服务启动，我们将使用。
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Where `[p]` is our desired path.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`[p]`是我们想要的路径。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on starting and correctly stopping `mongod` can be found at
    [http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo](http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有关启动和正确停止`mongod`的更多信息，请访问[http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo](http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo)。
- en: To interact with MongoDB from Node, we'll need to install the `mongodb` native
    bindings driver module.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Node与MongoDB交互，我们需要安装`mongodb`本机绑定驱动程序模块。
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We'll also create a new folder for our MongoDB-based project, with a new `quotes.js`
    file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为基于MongoDB的项目创建一个新文件夹，其中包含一个新的`quotes.js`文件。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: We must require the `mongodb` driver, initiate a MongoDB server instance, and
    create a client which loads the quotes database and connects to the MongoDB server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须要求`mongodb`驱动程序，启动一个MongoDB服务器实例，并创建一个客户端，加载引用数据库并连接到MongoDB服务器。
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice we've also inserted our `params` object for reading user input from the
    command line.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还插入了我们的`params`对象，以从命令行读取用户输入。
- en: Now we open a connection to our `quotes` database and load (or create if necessary)
    our `quotes` collection (a table would be the closest similar concept in SQL).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打开到我们的`quotes`数据库的连接，并加载（或创建如果需要）我们的`quotes`集合（在SQL中，表将是最接近的类似概念）。
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we'll insert a new document (in SQL terms this would be a record) according
    to a user-defined author and quote.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据用户定义的作者和引用插入一个新文档（在SQL术语中，这将是一条记录）。
- en: We'll also output any quotes by the specified author to the console.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在控制台上输出指定作者的任何引用。
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can see our MongoDB backed quotes application in action in the following
    screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到我们基于MongoDB的引用应用程序的运行情况：
- en: '![How to do it...](img/7188-04-01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/7188-04-01.jpg)'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we create a new instance of `mongo.Db`, we pass in the name of the database
    as the first parameter. MongoDB will intelligently create this database if it
    doesn't exist.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的`mongo.Db`实例时，我们将数据库的名称作为第一个参数传递进去。如果数据库不存在，MongoDB会智能地创建这个数据库。
- en: We use the `open` method of the `Db` instance, which we named `client`, to open
    a connection to our database. Once the connection is made, our callback function
    is executed where we can interact with the database via the `client` parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Db`实例的`open`方法，我们将其命名为`client`，以打开与数据库的连接。一旦连接建立，我们的回调函数就会被执行，我们可以通过`client`参数与数据库进行交互。
- en: We start off by making a `Collection` instance. `Collection` is similar to an
    SQL table in that it holds all our database fields. However, rather than field
    values being grouped by column, a collection contains multiple documents (like
    records) where each field holds both the field name and its value (documents are
    very much like JavaScript objects).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`Collection`实例。`Collection`类似于SQL表，它包含了所有我们的数据库字段。但是，与字段值按列分组不同，集合包含多个文档（类似记录），其中每个字段都包含字段名和其值（文档非常类似于JavaScript对象）。
- en: If both `quote` and `author` are defined, we invoke the `insert` method of our
    `Collection` instance, passing in an object as our document.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`quote`和`author`都被定义了，我们就调用我们的`Collection`实例的`insert`方法，传入一个对象作为我们的文档。
- en: Finally, we use `find` which is comparable to the `SELECT` SQL command, passing
    in an object that specifies the author field and desired value. The `mongodb`
    driver provides a convenience method (each) that can be chained with the `find`
    method. `each` executes the callback passed to it for each document as it's found.
    The last loop of `each` passes in `doc` as `null`, which conveniently signals
    that MongoDB has returned all records.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`find`，它类似于`SELECT` SQL命令，传入一个指定作者字段和所需值的对象。`mongodb`驱动程序提供了一个方便的方法（each），可以与`find`方法链接。`each`执行传递给它的回调，对于每个找到的文档都会执行。`each`的最后一个循环将`doc`作为`null`传递，这方便地表示MongoDB已经返回了所有记录。
- en: So as long as `doc` is truthy, we pass the `author` and `quote` properties of
    every `doc` found. Once `doc` is `null`, we allow the interpreter to discover
    the last part of the callback, `client.close`, by not returning early from the
    callback.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`doc`是真实的，我们就传递每个找到的`doc`的`author`和`quote`属性。一旦`doc`是`null`，我们允许解释器通过不从回调中提前返回来发现回调的最后部分，`client.close`。
- en: The second and final `client.close` situated at the end of the `client.open`
    callback is invoked only when there are no arguments defined via the command line.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client.open`回调的最后，第二个也是最后一个`client.close`只有在没有通过命令行定义参数时才会被调用。
- en: There's more...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's check out some other useful MongoDB features.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些其他有用的MongoDB功能。
- en: Indexing and aggregation
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引和聚合
- en: Indexing causes MongoDB to create a list of values from a chosen field. Indexed
    fields accelerate query speeds because a smaller set of data can be used to cross
    reference and pull from a larger set. We can apply an index to the author field
    and see performance benefits, especially as our data grows. Additionally, MongoDB
    has various commands allowing us to aggregate our data. We can group, count, and
    return distinct values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 索引会导致MongoDB从所选字段创建一个值列表。索引字段可以加快查询速度，因为可以使用更小的数据集来交叉引用和从更大的数据集中提取数据。我们可以将索引应用到作者字段，并看到性能的提升，特别是当我们的数据增长时。此外，MongoDB有各种命令允许我们对数据进行聚合。我们可以分组、计数和返回不同的值。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more advanced needs or larger sets of data, map/reduce functions can aggregate.
    CouchDB also uses map/reduce to generate views (stored queries), See *Retrieving
    data from CouchDB with Cradle*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的需求或更大的数据集，map/reduce函数可以进行聚合。CouchDB也使用map/reduce来生成视图（存储的查询），参见*使用Cradle从CouchDB检索数据*。
- en: Let's create and output a list of authors found in our database, and save our
    code to a file called `authors.js`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建并输出在我们的数据库中找到的作者列表，并将我们的代码保存到一个名为`authors.js`的文件中。
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As usual, we opened up a connection to our `quotes` database, grabbing our `quotes`
    collection. Using `ensureIndex` creates an index only if one doesn't already exist.
    We pass in `safe:true` so that MongoDB returns any errors and our callback works
    as expected. Inside the callback, we invoke the `distinct` method on our `collection`,
    passing in `author`. The result is passed as an array through as `result`. We
    `join` the array into a string using new lines and output to the console. .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们打开了与我们的“quotes”数据库的连接，获取了我们的“quotes”集合。使用`ensureIndex`只有在索引不存在时才会创建一个索引。我们传入`safe:true`，这样MongoDB会返回任何错误，并且我们的回调函数可以正常工作。在回调函数中，我们在我们的`collection`上调用`distinct`方法，传入`author`。结果作为数组传递，我们使用换行符将数组`join`成一个字符串并输出到控制台。
- en: Updating modifiers, sort, and limit
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新修改器、排序和限制
- en: We could make it possible for a hypothetical user to indicate if they were inspired
    by a quote (such as a **Like** button), then we could use the `sort` and `limit`
    commands to output the top ten most inspiring quotes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让一个假设的用户指示他们是否受到引用的启发（例如**Like**按钮），然后我们可以使用`sort`和`limit`命令来输出前十个最具启发性的引用。
- en: In reality, this would be implemented with some kind of user interface (for
    example, in a browser), but we'll again emulate user interactions using the command
    line; let's create a new file called `quotes_votes.js`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这将通过某种用户界面来实现（例如，在浏览器中），但我们将再次使用命令行来模拟用户交互；让我们创建一个名为`quotes_votes.js`的新文件。
- en: 'First, in order to vote for a quote, we''ll need to reference it, which can
    be done by the unique `_id` property. So in `quotes_votes.js` let''s write:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了对引用进行投票，我们需要引用它，这可以通过唯一的`_id`属性完成。因此在`quotes_votes.js`中，让我们写：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now when we run `quotes_votes.js` with `node`, we''ll see a list of IDs and
    quotes. To vote for a quote, we''ll simply copy an ID and use it as our command-line
    parameter. So let''s do our vote handling as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们用`node`运行`quotes_votes.js`时，我们将看到一个ID和引用列表。要为引用投票，我们只需复制一个ID并将其用作我们的命令行参数。因此，让我们按照以下代码所示进行投票处理：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: MongoDB IDs must be encoded as a BSON (Binary JSON) ObjectID. Otherwise, the
    `update` command will look for `param.id` as a string, failing to find it. So
    we create a `new mongo.ObjectID(param.id)` to convert `param.id` from a JavaScript
    string to a BSON ObjectID.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的ID必须编码为BSON（二进制JSON）ObjectID。否则，`update`命令将查找`param.id`作为字符串，找不到它。因此，我们创建一个`new
    mongo.ObjectID(param.id)`来将`param.id`从JavaScript字符串转换为BSON ObjectID。
- en: '`$inc` is a MongoDB modifier that performs the incrementing action inside the
    MongoDB server, essentially allowing us to outsource the calculation. To use it,
    we pass a document (object) alongside it containing the key to increment and the
    amount to increase it by. So we pass `votes` and `1`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`$inc` 是一个 MongoDB 修饰符，在 MongoDB 服务器内执行递增操作，从根本上允许我们外包计算。要使用它，我们传递一个文档（对象），其中包含要递增的键和要增加的数量。所以我们传递
    `votes` 和 `1`。'
- en: '`$inc` will create the `votes` field if it doesn''t exist, and increment it
    by one (we can also decrement using minus figures). Next are the options to be
    passed to MongoDB. We''ve set `safe` to `true`, which tells MongoDB to check that
    the command was successful and send any errors if it wasn''t. For the callback
    to work correctly, `safe:true` must be passed, otherwise errors are not caught,
    and the callback occurs immediately.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`$inc` 如果不存在将创建 `votes` 字段，并将其递增一（我们也可以使用负数递减）。接下来是要传递给 MongoDB 的选项。我们将 `safe`
    设置为 `true`，这告诉 MongoDB 检查命令是否成功，并在失败时发送任何错误。为了使回调正确工作，必须传递 `safe:true`，否则错误不会被捕获，回调会立即发生。'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Upserting**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Upserting**'
- en: Another useful option we can set is `upsert:true`. This is a really convenient
    MongoDB feature that either updates a record or inserts it if it doesn't exist.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置的另一个有用的选项是 `upsert:true`。这是 MongoDB 的一个非常方便的功能，可以更新记录，如果记录不存在则插入。
- en: Inside the `update` callback we run a chain of `find.sort.limit.each. find`,
    without any parameters, which returns all our records. `sort` requires keys and
    a positive or negative `1`, indicating ascending or descending. `limit` takes
    an integer of maximum records, and `each` loops through our records. Inside the
    `each` callback, we output every `author, quote`, and `votes` of `doc`, closing
    the connection when no `docs` are left.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `update` 回调中，我们运行一系列 `find.sort.limit.each. find`，不带任何参数，这将返回所有记录。`sort` 需要键和一个正数或负数
    `1`，表示升序或降序。`limit` 接受一个最大记录数的整数，`each` 循环遍历我们的记录。在 `each` 回调中，我们输出 `doc` 的每个
    `author, quote` 和 `votes`，当没有剩余的 `docs` 时关闭连接。
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Connecting and sending SQL to a MySQL server* discussed in this chapter'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接并向 MySQL 服务器发送 SQL* 在本章中讨论'
- en: '*Storing and retrieving data with Mongoskin* discussed in this chapter'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Mongoskin 存储和检索数据* 在本章中讨论'
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Cradle 将数据存储到 CouchDB* 在本章中讨论'
- en: Storing and retrieving data with Mongoskin
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mongoskin 存储和检索数据
- en: Mongoskin is a convenience library providing a high-level interface for `mongodb`
    without blocking access to the existing `mongodb` methods.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoskin 是一个方便的库，提供了一个高级接口，用于在不阻塞现有 `mongodb` 方法的情况下与 `mongodb` 进行交互。
- en: For this recipe, we'll re-implement the `quotes` database in MongoDB using Mongoskin.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用 Mongoskin 在 MongoDB 中重新实现 `quotes` 数据库。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need the `mongoskin` module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `mongoskin` 模块。
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can also create a new folder, with a new `quotes.js` file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个新的文件夹，带有一个新的 `quotes.js` 文件。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll require `mongoskin` and use it to make a `client` and a `collection` instance.
    We don't need to create a `server` instance, nor manually open the client as in
    the former recipe, `mongoskin` takes care of that.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要 `mongoskin` 并使用它来创建一个 `client` 和一个 `collection` 实例。我们不需要创建一个 `server`
    实例，也不需要像前一个示例中那样手动打开客户端，`mongoskin` 会处理这一切。
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As in the previous recipe, we've defined our `params` object for user input.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例一样，我们已经为用户输入定义了我们的 `params` 对象。
- en: Instead of requiring us to use JavaScript's potentially human error prone `new`
    keyword, `mongoskin` provides a builder method (`mongo.db`), allowing us to define
    our host, port, and database name with the familiar URI schema.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongoskin` 不需要我们使用 JavaScript 可能出现错误的 `new` 关键字，它提供了一个构建器方法（`mongo.db`），允许我们使用熟悉的
    URI 模式定义我们的主机、端口和数据库名称。'
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: See [http:// www. yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/](http://
    www. yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/) for why the `new`
    prefix could be considered error prone.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '有关为什么 `new` 前缀可能被认为是错误的，请参阅 [http:// www. yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/](http://
    www. yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/)。 '
- en: 'Since we don''t need to `open` our `client (mongoskin` opens it for us), we
    can just go ahead and implement our `insert` and `find` operations:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要手动 `open` 我们的 `client（mongoskin` 会为我们打开它），所以我们可以直接实现我们的 `insert` 和 `find`
    操作：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And we're done.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们就完成了。
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We transparently connect to our database using Mongoskin's `db` method, and
    we're immediately able to grab our collection.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Mongoskin 的 `db` 方法透明地连接到我们的数据库，并立即能够获取我们的集合。
- en: As in our previous recipe, we check for the `author` and `quote` command-line
    arguments, and then call the `mongodb insert` method which is inherently available
    through the `mongoskin` module.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们检查 `author` 和 `quote` 命令行参数，然后调用 `mongodb insert` 方法，该方法通过 `mongoskin`
    模块本身就可用。
- en: Next, after checking for author, we use the `findEach` method of `mongoskin`.
    The `findEach` method wraps `collection.find.each` as used in the previous recipe.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查作者之后，我们使用 `mongoskin` 的 `findEach` 方法。`findEach` 方法包装了前一个示例中使用的 `collection.find.each`。
- en: Within `findEach` we output the `author` and `quote` properties of each `doc`
    to the console. When there's no documents left, we explicitly `close` the `client`
    connection.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `findEach` 中，我们将每个 `doc` 的 `author` 和 `quote` 属性输出到控制台。当没有文档剩下时，我们明确地 `close`
    了 `client` 连接。
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Mongoskin does an excellent job of making our lives easier. Let's look at another
    Mongoskin feature that simplifies our interactions with MongoDB.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoskin 在使我们的生活更轻松方面做得非常出色。让我们看看另一个简化与 MongoDB 交互的 Mongoskin 功能。
- en: Collection binding
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合绑定
- en: 'Mongoskin provides a `bind` method that makes a collection available as a property
    of our `client` object. So if we did:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoskin 提供了一个 `bind` 方法，使集合作为 `client` 对象的属性可用。所以如果我们这样做：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We could access the quotes collection via `client.quotes`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `client.quotes` 访问引用集合。
- en: 'This means we can discard the `collection` variable and use binding instead.
    The `bind` method also accepts an object of methods, which then applies to the
    bound collection. For instance, if we defined a method called `store`, we would
    access it as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以丢弃`collection`变量并改用绑定。`bind`方法还接受一个方法对象，然后应用于绑定的集合。例如，如果我们定义了一个名为`store`的方法，我们将按以下方式访问它：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So let's create a new file called `quotes_bind.js` to re-implement `quotes.js`
    in Mongoskin, this time using the collection binding approach.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个名为`quotes_bind.js`的新文件，以使用集合绑定方法重新实现Mongoskin中的`quotes.js`。
- en: 'We''ll begin with our top-level variables:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的顶级变量开始：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We have no need for a `collection` variable since we'll be accessing our collection
    via `bind`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将通过`bind`访问我们的集合，因此我们不需要`collection`变量。
- en: 'Now let''s define a `store` method for inserts and a `show` method for displaying
    quotes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为插入定义一个`store`方法和一个用于显示引用的`show`方法：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then our logic to interact with our new bound methods:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的逻辑与我们的新绑定方法进行交互：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `bind` method of Mongoskin painlessly abstracts involved database operations
    into an easy dot-notation format.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoskin的`bind`方法将复杂的数据库操作无缝地抽象成易于使用的点符号格式。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We baked some of our `params` checking functionality into our `store` method,
    only calling `insert` if a quote exists. In all our recipes, we only needed to
    check for the second argument (`params.quote`), we couldn't have `params.quote`
    without `params.author`. Both arguments were checked in the prior recipes to demonstrate
    how it might work in other scenarios (for instance, if we received our parameters
    via a POST request).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一些`params`检查功能嵌入到我们的`store`方法中，只有在引用存在时才调用`insert`。在我们所有的示例中，我们只需要检查第二个参数（`params.quote`），我们不能有`params.quote`而没有`params.author`。在之前的示例中，这两个参数都进行了检查，以演示在其他情况下它可能如何工作（例如，如果我们通过POST请求接收到我们的参数）。
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用MongoDB存储和检索数据*'
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用Cradle将数据存储到CouchDB*'
- en: '*Retrieving data from CouchDB with Cradle* discussed in this chapter'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用Cradle从CouchDB检索数据*'
- en: Storing data to CouchDB with Cradle
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cradle将数据存储到CouchDB
- en: In order to achieve stellar performance speeds, MongoDB has a relaxed view towards
    ACID (Atomicity Consistency Isolation Durability) compliance. However, this means
    there is an (unlikely) chance that data can become corrupted (especially if there
    was a power cut in the middle of an operation). CouchDB, on the other hand, is
    ACID compliant to the extent that, when replicated and synchronized, data eventually
    becomes consistent. Therefore, while slower than MongoDB, it has the added reliability
    advantage.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现出色的性能速度，MongoDB对ACID（原子性一致性隔离持久性）合规性有一定的放松。然而，这意味着数据可能会变得损坏的可能性（尤其是在操作中断的情况下）。另一方面，CouchDB在复制和同步时是符合ACID的，数据最终变得一致。因此，虽然比MongoDB慢，但它具有更高的可靠性优势。
- en: CouchDB is entirely administrated via HTTP REST calls, so we could do all of
    our work with CouchDB using `http.request`. Nevertheless, we can use Cradle to
    interact with CouchDB in an easy, high-level way, along with the added speed enhancement
    of automated caching.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB完全通过HTTP REST调用进行管理，因此我们可以使用`http.request`来完成与CouchDB的所有工作。尽管如此，我们可以使用Cradle以一种简单、高级的方式与CouchDB进行交互，同时还可以获得自动缓存的速度增强。
- en: In this recipe, we'll use Cradle to store famous quotes to CouchDB.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Cradle将著名的引用存储到CouchDB中。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to install and run CouchDB, we can head on to [http://wiki.apache.org/couchdb/Installation](http://wiki.apache.org/couchdb/Installation)
    for instructions on how to install for your particular operating system.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装和运行CouchDB，可以前往[http://wiki.apache.org/couchdb/Installation](http://wiki.apache.org/couchdb/Installation)获取有关如何在特定操作系统上安装的说明。
- en: After installation, we can check if CouchDB is running and access the Futon
    administration panel by pointing our browser to [http://localhost:5984/_utils](http://localhost:5984/_utils).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以检查CouchDB是否正在运行，并通过将浏览器指向[http://localhost:5984/_utils](http://localhost:5984/_utils)来访问Futon管理面板。
- en: We'll also need the `cradle` module.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要`cradle`模块。
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And we can create a new folder with a new `quotes.js` file in it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在其中创建一个新的`quotes.js`文件的新文件夹。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we require `cradle` and load our quotes database, creating it if necessary.
    We''ll also define an error-handling function and our `params` object for easy
    command-line interaction:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要`cradle`并加载我们的引用数据库，如果需要的话创建它。我们还将定义一个错误处理函数和我们的`params`对象，以便轻松进行命令行交互：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Before we can write to our database, we need to know it exists:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以写入数据库之前，我们需要知道它是否存在：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that we pass in `checkAndSave` as the callback of `db.create`, the following
    function goes above the `db.exists` invocation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`checkAndSave`作为`db.create`的回调传入，以下函数位于`db.exists`调用之上：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `err` parameter we are handling in `checkAndSave` would have been passed
    in from `db.create`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`checkAndSave`中处理的`err`参数将从`db.create`中传入。
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'CouchDB is administrated via HTTP requests, but Cradle provides an interface
    for making these requests. When we invoke `db.exists`, Cradle sends a HEAD request
    to `http://localhost:5984/quotes` and checks whether the reply status is `404
    Not Found` or `200 OK`. We could perform the same check with command-line program''s
    `curl` and `grep` as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB通过HTTP请求进行管理，但Cradle提供了一个接口来进行这些请求。当我们调用`db.exists`时，Cradle会向`http://localhost:5984/quotes`发送一个HEAD请求，并检查回复状态是否为`404
    Not Found`或`200 OK`。我们可以使用命令行程序的`curl`和`grep`执行相同的检查，如下所示：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This would output `1` if the database exists, and `0` if it does not. If our
    database doesn''t exist, we call the `db.create` method of `cradle` which sends
    an HTTP PUT request to the CouchDB server. In `curl` this would be:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库存在，则会输出`1`，如果不存在，则会输出`0`。如果我们的数据库不存在，我们调用`cradle`的`db.create`方法，该方法会向CouchDB服务器发送一个HTTP
    PUT请求。在`curl`中，这将是：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We pass in our `checkAndSave` function as the callback of `db.create`, or we
    call it from the callback of `db.exists` if the database does exist. This is essential.
    We cannot save data to a database that doesn't exist and we have to wait for the
    HTTP response before we know whether it exists (or whether it has been created).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的`checkAndSave`函数作为`db.create`的回调传入，或者如果数据库存在，我们将它从`db.exists`的回调中调用。这是必要的。我们不能将数据保存到不存在的数据库中，我们必须等待HTTP响应，然后才知道它是否存在（或者是否已创建）。
- en: '`checkAndSave` looks for command-line arguments, and then saves the data accordingly.
    For instance, if we ran the following from the command line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkAndSave`查找命令行参数，然后相应地保存数据。例如，如果我们从命令行运行以下命令：'
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`checkAndSave` would realize there are two parameters passing these as `author`
    and `quote` to `db.save`. Cradle would then POST the following, with `Content-Type`
    set to `application/json:`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkAndSave`会意识到有两个参数传递给`author`和`quote`，然后将它们传递给`db.save`。Cradle然后会POST以下内容，`Content-Type`设置为`application/json:`'
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: On top of this, Cradle adds a caching layer, which in our example is of little
    use since caching data is lost whenever our application exits. However, in server
    implementation, the caching would become very useful in answering similar requests
    quickly and efficiently.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Cradle还添加了一个缓存层，在我们的示例中几乎没有用处，因为缓存数据在应用程序退出时会丢失。然而，在服务器实现中，缓存将在快速高效地响应类似请求时变得非常有用。
- en: There's more...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Couch stands for **Cluster Of Unreliable Commodity Hardware**, let's take a
    brief look at the clustering side of CouchDB.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Couch代表**Cluster Of Unreliable Commodity Hardware**，让我们简要看一下CouchDB的集群方面。
- en: Scaling CouchDB with BigCouch
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用BigCouch扩展CouchDB
- en: Scaling is about making your application responsive to an anticipated demand,
    but different projects have different characteristics. Therefore, each scaling
    venture requires an individualized approach.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展是关于使您的应用程序对预期需求做出响应的，但不同的项目具有不同的特点。因此，每个扩展项目都需要个性化的方法。
- en: If a web service was heavily built around database interaction, scaling the
    database layer would be a priority when responding to changes in service demand.
    Scaling CouchDB (or anything else) can be a very in-depth procedure, necessarily
    so for specialized projects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Web服务主要建立在数据库交互上，那么在响应服务需求变化时，扩展数据库层将成为一个优先考虑的问题。扩展CouchDB（或其他任何东西）可能是一个非常深入的过程，对于专门的项目来说是必要的。
- en: However, the Open Source BigCouch project has an ability to scale CouchDB in
    a transparent and generic fashion. With BigCouch, we can scale CouchDB across
    servers, but interact with it as if it was on one server. BigCouch can be found
    at [https://www. github.com/cloudant/bigcouch](https://www. github.com/cloudant/bigcouch).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开源的BigCouch项目具有以透明和通用的方式扩展CouchDB的能力。使用BigCouch，我们可以在服务器之间扩展CouchDB，但与之交互就像它在一个服务器上一样。BigCouch可以在[https://www.
    github.com/cloudant/bigcouch](https://www. github.com/cloudant/bigcouch)找到。
- en: See also
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Retrieving data from CouchDB with Cradle* discussed in this chapter'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用Cradle从CouchDB检索数据*'
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用MongoDB存储和检索数据*'
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用Redis存储和检索数据*'
- en: Retrieving data from CouchDB with Cradle
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cradle从CouchDB检索数据
- en: CouchDB doesn't use the same query paradigm that MySQL and MongoDB subscribe
    to. Instead, it uses a pre-created view to retrieve the desired data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB不使用与MySQL和MongoDB相同的查询范式。相反，它使用预先创建的视图来检索所需的数据。
- en: In this example, we'll use Cradle to obtain an array of quotes according to
    the specified author, outputting our quotes to the console.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Cradle根据指定的作者获取一个引用数组，并将我们的引用输出到控制台。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As in the previous recipe, *Storing data to CouchDB with Cradle*, we'll need
    CouchDB installed on our system, along with `cradle`. We can also take the `quotes.js`
    file from that recipe, placing it in a new directory.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个配方*使用Cradle将数据存储到CouchDB*一样，我们需要在系统上安装CouchDB，以及`cradle`。我们还可以从该配方中获取`quotes.js`文件，并将其放在一个新的目录中。
- en: How to do it...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''re working on the `quotes.js` file from the prior task where we called
    `checkAndSave` if our database existed, or we called it from the callback of `db.create`
    if it didn''t exist. Let''s modify `checkAndSave` slightly as shown in the following
    code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从之前的任务中的`quotes.js`文件中进行工作，在那里如果我们的数据库存在，我们调用`checkAndSave`，或者如果它不存在，我们就从`db.create`的回调中调用它。让我们稍微修改`checkAndSave`，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've added a new function invocation, `outputQuotes`, to the end of `checkAndSave`
    and also as the callback of `db.save. outputQuotes` is going to access a special
    CouchDB `_design` document called a view.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`checkAndSave`的末尾添加了一个新的函数调用`outputQuotes`，并且也作为`db.save`的回调。`outputQuotes`将访问一个名为视图的特殊CouchDB
    `_design`文档。
- en: 'Before we look at `outputQuotes`, let''s look into another new function we''ll
    be creating called `createQuotesView`. It should be placed just under `errorHandler`
    but above the rest of the code as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看`outputQuotes`之前，让我们来看看另一个我们将要创建的新函数，名为`createQuotesView`。它应该放在`errorHandler`的下面，但在代码的其余部分之上，如下所示：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`createQuotesView` also calls the `outputQuotes` function from the `db.save`
    callback parameter. `outputQuotes` is now called from three places: the `db.save`
    callback of `checkAndSave`, the end of `checkAndSave`, and in the `db.save` callback
    of `createQuotesView`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`createQuotesView`还从`db.save`的回调参数中调用`outputQuotes`函数。`outputQuotes`现在从三个地方调用：`checkAndSave`的`db.save`回调，`checkAndSave`的末尾，以及`createQuotesView`的`db.save`回调。'
- en: Let's take a look at `outputQuotes:`
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`outputQuotes:`
- en: '[PRE50]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`outputQuotes` goes before `checkAndSave`, but after `createQuotesView`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputQuotes`在`checkAndSave`之前，但在`createQuotesView`之后。'
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The key to querying a CouchDB database is views. There are two types of views:
    permanent and temporary. In `createQuotesView` we define a permanent view using
    `db.save`, setting the document ID to `_design/quotes`. We then define a `views`
    field containing an object called `byAuthor` which holds a key called `map` whose
    value is a string formatted function.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 查询CouchDB数据库的关键是视图。有两种类型的视图：永久视图和临时视图。在`createQuotesView`中，我们使用`db.save`定义了一个永久视图，将文档ID设置为`_design/quotes`。然后我们定义了一个包含名为`byAuthor`的对象的`views`字段，该对象包含一个名为`map`的键，其值是一个格式化的字符串函数。
- en: Temporary views would be stored with an ID of `quotes/_temp_view`. However,
    these should only be used for testing,. They're very expensive computationally
    and shouldn't be used for production.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 临时视图将存储一个ID为`quotes/_temp_view`。然而，这些只应该用于测试，它们在计算上非常昂贵，不应该用于生产。
- en: 'The mapping function is string formatted because it''s passed to CouchDB via
    an HTTP request. CouchDB `map` functions are not executed with Node, they run
    within the CouchDB server. A `map` function defines the query we wish to run on
    the database through the CouchDB servers `emit` function. The first argument of
    `emit` specifies which field to query, (in our case `doc.author)`, and the second
    specifies what to output as a result of the query (we want the whole `doc)`. If
    we wanted to search for Albert Einstein, we would make a GET request to: `http://localhost:5984/quotes/_design/quotes/_view/byAuthor?key="Albert
    Einstein"`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 映射函数是字符串格式化的，因为它通过HTTP请求传递给CouchDB。CouchDB的`map`函数不是在Node中执行的，它们在CouchDB服务器内运行。`map`函数定义了我们希望通过CouchDB服务器的`emit`函数在数据库上运行的查询。`emit`的第一个参数指定要查询的字段（在我们的例子中是`doc.author`），第二个指定查询的结果输出（我们想要整个`doc`）。如果我们想要搜索Albert
    Einstein，我们将发出GET请求：`http://localhost:5984/quotes/_design/quotes/_view/byAuthor?key="Albert
    Einstein"`。
- en: Cradle provides a shorthand method for this request, `db.view`, which appears
    in our `outputQuotes` function. `db.view` allows us to simply pass in `quotes/byAuthor`
    with a second object containing the `key` parameter (that is, our query), essentially
    filling in the special underscore routes for us.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Cradle为这个请求提供了一个简写方法`db.view`，它出现在我们的`outputQuotes`函数中。`db.view`允许我们简单地传递`quotes/byAuthor`和一个包含`key`参数（即我们的查询）的第二个对象，从根本上为我们填充了特殊的下划线路由。
- en: '`db.view` parses the incoming JSON and provides it via the second parameter
    of its callback, which we named `rowsArray`. We loop through the array using `forEach`
    and finish off by outputting `author` and `quote` to the console, as in previous
    recipes.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.view`解析传入的JSON并通过其回调的第二个参数提供它，我们将其命名为`rowsArray`。我们使用`forEach`循环数组，最后通过控制台输出`author`和`quote`，就像以前的配方一样。'
- en: However, before we loop through the array we need to check that our view actually
    exists. Views only need to be generated once. After this, they are stored in the
    CouchDB database. Therefore, we don't want to create a view every time we run
    our application. So when we call `db.view` we look to see if a `not_found` error
    occurs in the `db.view` callback. If our view isn't found, we call `createQuotesView`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在循环数组之前，我们需要检查我们的视图是否实际存在。视图只需要生成一次。之后，它们将存储在CouchDB数据库中。因此，我们不希望每次运行应用程序时都创建一个视图。因此，当我们调用`db.view`时，我们会查看`db.view`回调中是否发生`not_found`错误。如果我们的视图找不到，我们就调用`createQuotesView`。
- en: 'In broad terms, the process goes something like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个过程大致是这样的：
- en: '![How it works...](img/7188_04_02.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7188_04_02.jpg)'
- en: There's more...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: CouchDB is great for getting to grips right out of the box. However, there are
    certain security considerations we must be attuned to before deploying a CouchDB-backed
    app to the web.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB非常适合立即上手。然而，在将CouchDB支持的应用程序部署到网络之前，我们必须注意某些安全考虑。
- en: Creating an admin user
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建管理员用户
- en: 'CouchDB requires no initial authorization settings, which is fine for development.
    However, as soon as we expose CouchDB to the outside world, anyone on the Internet
    has permission to edit our entire database: data designs, configuration, users,
    and so on.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB不需要初始授权设置，这对开发来说是可以的。然而，一旦我们将CouchDB暴露给外部世界，互联网上的任何人都有权限编辑我们的整个数据库：数据设计、配置、用户等。
- en: 'So before deploying, we want to set a username and password. We can achieve
    this with the `_config` API:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在部署之前，我们希望设置用户名和密码。我们可以通过`_config` API实现这一点：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have created the admin user `dave` and set the password to `cookit`. Now
    the right to certain calls will be denied without authentication, including the
    creation or deletion of databases, modifying design documents (for example, for
    views), or access to the `_config` API.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了管理员用户`dave`并将密码设置为`cookit`。现在，未经身份验证将拒绝对某些调用的权限，包括创建或删除数据库，修改设计文档（例如视图），或访问`_config`
    API。
- en: 'For instance, say we wanted to view all admin users, we could say:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想查看所有管理员用户，我们可以说：
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'CouchDB will reply:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB将回复：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'However, if we include authentication information:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们包括身份验证信息：
- en: '[PRE54]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We get our only admin user along with a hash of his password:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们唯一的管理员用户以及他密码的哈希值：
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Using this method to remotely administer a CouchDB database is not without its
    security flaws. It forces us to send passwords as plain text over non-secure HTTP.
    Ideally, we need to host CouchDB behind an HTTPS proxy so the password becomes
    encrypted as it's sent. See the recipe *Setting up an HTTPS server* discussed
    In [Chapter 7](ch07.html "Chapter 7. Implementing Security, Encryption, and Authentication"),Implementing
    Security, Encryption, and Authentication
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法远程管理CouchDB数据库并不是没有安全漏洞。它强迫我们将密码以明文形式通过非安全的HTTP发送。理想情况下，我们需要将CouchDB托管在HTTPS代理后面，这样密码在发送时就会被加密。参见[第7章](ch07.html
    "第7章 实施安全、加密和身份验证")中讨论的*设置HTTPS服务器*配方，实施安全、加密和身份验证
- en: 'If CouchDB is behind HTTPS, `cradle` can connect to it as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CouchDB在HTTPS后面，`cradle`可以连接到它如下：
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We pass an `options` object when we create our connection. The `secure` property
    tells `cradle` we are using SSL, and `auth` contains a sub-object with login details.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建连接时传递一个`options`对象。`secure`属性告诉`cradle`我们正在使用SSL，`auth`包含一个包含登录详细信息的子对象。
- en: Alternatively, we create a Node app to authenticate with a local CouchDB instance
    (so that no password is sent to an external HTTP address) and act as a layer between
    external requests and CouchDB.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们创建一个Node应用程序，用于与本地CouchDB实例进行身份验证（以便不将密码发送到外部HTTP地址），并充当外部请求和CouchDB之间的中间层。
- en: Locking all modifying operations to an admin user
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有修改操作锁定到管理员用户
- en: Even if an admin user is set, unauthenticated users still have permission to
    modify existing databases. If we were only writing to CouchDB server side (but
    reading from either server or clients), we could lock all write operations for
    non-admin users with a validation function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 即使设置了管理员用户，未经身份验证的用户仍然有权限修改现有数据库。如果我们只在CouchDB服务器端写入（但从服务器或客户端读取），我们可以使用验证函数锁定非管理员用户的所有写操作。
- en: 'A validation function is written in JavaScript and runs on the CouchDB server
    (like a map function). Once a validation function is defined, it''s executed against
    all user input for the database it is applied to. Three objects appear as parameters
    in the function: the new document (`newDoc`), the previous currently stored document
    (`savedDoc`), and the user context (`userCtx`), which holds authenticated user
    information.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 验证函数是用JavaScript编写的，并在CouchDB服务器上运行（类似于映射函数）。一旦定义了验证函数，它就会针对应用到的数据库的所有用户输入执行。函数中出现三个对象作为参数：新文档（`newDoc`），先前存储的文档（`savedDoc`）和用户上下文（`userCtx`），其中包含经过身份验证的用户信息。
- en: Within a validation function we can examine and qualify these objects, calling
    CouchDB's `throw` function to reject operation requests that fail to meet our
    requirements.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证函数中，我们可以检查和限定这些对象，调用CouchDB的`throw`函数来拒绝未能满足我们要求的操作请求。
- en: 'Let''s make a new file called `database_lockdown.js`, and begin by connecting
    to our database:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`database_lockdown.js`的新文件，并开始连接到我们的数据库：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We pass in an `options` object to the new cradle connection. It contains authentication
    information which will now be necessary to create a validation function if we
    have set a new admin user according to the previous subsection *Creating an admin
    user*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向新的cradle连接传递一个`options`对象。它包含了认证信息，如果我们根据上一小节*创建管理员用户*设置了新的管理员用户，那么现在将需要创建一个验证函数。
- en: 'Let''s create our validation function, and save it as a `_design` document:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的验证函数，并将其保存为`_design`文档：
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As soon as we execute:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行：
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: All write-related operations will now require authorization.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有与写操作相关的操作都需要授权。
- en: Like views, we store validation functions within a document that has a `_design/`
    prefixed ID. The other part of the ID can be anything, but we named it `_auth`
    which reflects conventional practice when a validation function serves this type
    of purpose. The field name, though, must be called `validate_doc_update`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与视图一样，我们将验证函数存储在具有`_design/`前缀ID的文档中。ID的另一部分可以是任何内容，但我们将其命名为`_auth`，这反映了当验证函数提供此类目的时的传统做法。但是，字段名称必须称为`validate_doc_update`。
- en: By default Cradle assumes any `_design` documents passed to `db.save` are a
    view. In order to prevent Cradle from wrapping our `validate_update_doc` field
    into a view, we specify an empty object to the `views` property.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Cradle假定传递给`db.save`的任何`_design`文档都是一个视图。为了防止Cradle将我们的`validate_update_doc`字段包装成视图，我们将一个空对象指定给`views`属性。
- en: '`validate_update_doc` must be passed a string-formatted function, so we define
    our function under the `admin_lock` variable and call `toString` on it as it''s
    passed into `db.save`.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_update_doc`必须传递一个字符串格式的函数，因此我们在`admin_lock`变量下定义我们的函数，并在传递到`db.save`时对其调用`toString`。'
- en: '`admin_lock` is never intended for execution by Node. It''s an aesthetic approach
    to constructing our function before passing it to CouchDB.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`admin_lock`永远不会被Node执行。这是一种在传递给CouchDB之前构建我们的函数的美学方法。'
- en: When an operation occurs on the database, our `admin_lock` function (which becomes
    CouchDB's `validate_update_doc` function) asks CouchDB to check if the user requesting
    the operation has the `_admin` user role. If not, it tells CouchDB to throw an
    unauthorized error thus denying access.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库发生操作时，我们的`admin_lock`函数（它成为CouchDB的`validate_update_doc`函数）要求CouchDB检查请求操作的用户是否具有`_admin`用户角色。如果没有，它告诉CouchDB抛出未经授权的错误，从而拒绝访问。
- en: Exposing the CouchDB HTTP interface to remote connections
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将CouchDB HTTP接口暴露给远程连接
- en: 'By default, CouchDB binds to `127.0.0.1`. This ensures that only local connections
    can be made to the database ensuring safety prior to security enforcements. Once
    we have CouchDB set up behind HTTPS with at least one admin user set, we can bind
    CouchDB to `0.0.0.0` which makes the REST interface accessible via any IP address.
    This means that remote users can access our CouchDB HTTP interface via our server''s
    public IP address, or more likely via our server''s domain name. We can set the
    bind address with `_config` as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CouchDB绑定到`127.0.0.1`。这确保只有本地连接可以连接到数据库，从而在安全执行之前确保安全性。一旦我们在HTTPS后设置了至少一个管理员用户，我们可以将CouchDB绑定到`0.0.0.0`，这样REST接口可以通过任何IP地址访问。这意味着远程用户可以通过我们服务器的公共IP地址或更可能通过我们服务器的域名访问我们的CouchDB
    HTTP接口。我们可以使用`_config`设置绑定地址如下：
- en: '[PRE60]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Where `u` and `p` are the admin username and password, respectively.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`u`和`p`分别是管理员用户名和密码。
- en: See also
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用Cradle将数据存储到CouchDB*'
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用MongoDB存储和检索数据*'
- en: '*Setting Up and HTTPS Web Server discussed in* [Chapter 7](ch07.html "Chapter 7. Implementing
    Security, Encryption, and Authentication"),Implementing Security, Encryption,
    and Authentication'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在* [第7章](ch07.html "第7章. 实施安全、加密和身份验证") *中讨论的设置和HTTPS Web服务器*，实施安全、加密和身份验证'
- en: Accessing CouchDB changes stream with Cradle
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cradle访问CouchDB更改流
- en: One of CouchDB's most noteworthy features is the `_changes` API. With it we
    can view all alterations to a database via HTTP.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB最引人注目的功能之一是`_changes` API。通过它，我们可以通过HTTP查看对数据库的所有更改。
- en: For instance, to see all changes made to our `quotes` database we can make a
    GET request to `http://localhost:5984/quotes/_changes`. Even better, if we wanted
    to hook up to a live stream, we would add the query parameter `?feed=continuous`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查看对我们的`quotes`数据库所做的所有更改，我们可以向`http://localhost:5984/quotes/_changes`发出GET请求。更好的是，如果我们想要连接到实时流，我们可以添加查询参数`?feed=continuous`。
- en: Cradle provides an attractive interface to the `_changes` API, which we'll explore
    in this recipe.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Cradle为`_changes` API提供了一个吸引人的接口，我们将在本食谱中探讨。
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: We'll need a functioning CouchDB database and a way to write to it. We can use
    the `quotes.js` example used in *Storing data to CouchDB with Cradle*, so let's
    copy that into a new directory and then create a file alongside it called `quotes_stream.js`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个可用的CouchDB数据库以及一种写入它的方法。我们可以使用*使用Cradle将数据存储到CouchDB*中使用的`quotes.js`示例，所以让我们将其复制到一个新目录中，然后在旁边创建一个名为`quotes_stream.js`的文件。
- en: 'If we followed the *Creating an admin user* and *Locking all modifying operations
    to an admin user* sections of the previous recipe''s *There''s more..*. section,
    we will need to modify the second line of `quotes.js` in order to continue to
    insert quotes in our database:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循了前一篇食谱*创建管理员用户*和*将所有修改操作锁定为管理员用户*部分中的步骤，我们需要修改`quotes.js`的第二行，以便继续向我们的数据库中插入引用：
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Where `dave` and `cookit` are the example username and password.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`dave`和`cookit`是示例用户名和密码。'
- en: How to do it...
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We require `cradle` and make a connection to our `quotes` database. Our stream
    is intended for use with a pre-existing database, so we won't be checking for
    database existence.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`cradle`并连接到我们的`quotes`数据库。我们的流适用于预先存在的数据库，因此我们不会检查数据库是否存在。
- en: '[PRE62]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we call the `changes` method of `cradle` and listen to its `response`
    event, in turn listening to the passed in `response` emitter''s `data` event:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`cradle`的`changes`方法，并监听其`response`事件，然后监听传入的`response`发射器的`data`事件：
- en: '[PRE63]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To test our `changes` stream implementation we''ll open two terminals. In one
    we''ll run the following command:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的`changes`流实现，我们将打开两个终端。在一个终端中，我们将运行以下命令：
- en: '[PRE64]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the other terminal window we can add some quotes using `quotes.js:`
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，我们可以使用`quotes.js`添加一些引用：
- en: '[PRE65]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![How to do it...](img/7188-04-03.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/7188-04-03.jpg)'
- en: As each new quote is added in the left-hand terminal, it appears in the right.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在左侧终端中添加新引用时，它会出现在右侧。
- en: '`quotes_stream.js` was opened up before any new quotes were added, and immediately
    displayed the `Albert Einstein` quote which was added in the *Storing data to
    CouchDB with Cradle* recipe. After this, new quotes appeared in the stream as
    they were added.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何新引用之前，`quotes_stream.js`被打开，并立即显示了在*使用Cradle将数据存储到CouchDB*食谱中添加的`Albert
    Einstein`引用。之后，随着添加的新引用，它们也会出现在流中。
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `changes` method can be passed a callback, which simply returns all changes
    up to the present and then exits. If we do not pass a callback to `changes` it
    adds the `?feed=continuous` parameter to the HTTP CouchDB REST call and returns
    `EventEmitter`. CouchDB then returns a streamed HTTP response to Cradle which
    is sent through as the `response` parameter of the `response` event. The `response`
    parameter is also `EventEmitter`, and we listen for changes via the `data` event.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`changes`方法可以传递一个回调，它简单地返回到目前为止的所有更改，然后退出。如果我们没有将回调传递给`changes`，它会将`?feed=continuous`参数添加到HTTP
    CouchDB REST调用中，并返回`EventEmitter`。然后，CouchDB将返回一个流式的HTTP响应给Cradle，作为`response`事件的`response`参数发送。`response`参数也是`EventEmitter`，我们通过`data`事件监听更改。'
- en: On each `data` event, the callback handles the `change` parameter. Two data
    events are fired for each change, one is a JSON string, the other is a JavaScript
    object containing the equivalent JSON data. We check that the `change` parameter's
    type is an object (`changeIsObj`) before proceeding. The `change` object holds
    metadata for our database entries. It has a sequence number (`change.seq`), a
    revision number (`change.changes[0].rev`), it sometimes contains a deleted property
    (`changes.deleted`), and always has an `id` property.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`data`事件上，回调处理`change`参数。每个更改都会触发两个数据事件，一个是JSON字符串，另一个是包含等效JSON数据的JavaScript对象。在继续之前，我们检查`change`参数的类型是否为对象（`changeIsObj`）。`change`对象保存了我们数据库条目的元数据。它有一个序列号（`change.seq`），一个修订号（`change.changes[0].rev`），有时包含一个已删除的属性（`changes.deleted`），并且始终有一个`id`属性。
- en: If the `deleted` property is found, we need to `return` early as `db.get` can't
    fetch a deleted record. Otherwise, we pass `change.id` into `db.get`, which provides
    access to a document ID. The `doc` is passed into the callback of `db.get`. We
    only want to output changes regarding our quotes, so we check for `author` and
    `quote` fields and log them to the console.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到`deleted`属性，我们需要提前`return`，因为`db.get`无法获取已删除的记录。否则，我们将`change.id`传递给`db.get`，这将提供对文档ID的访问。`doc`被传递到`db.get`的回调中。我们只想输出关于我们的引用的更改，因此我们检查`author`和`quote`字段，并将它们记录到控制台。
- en: See also
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Cradle将数据存储到CouchDB*在本章中讨论'
- en: '*Retrieving data from CouchDB with Cradle* discussed in this chapter'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Cradle从CouchDB检索数据*在本章中讨论'
- en: '*Implementing PubSub with Redis* discussed in this chapter'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Redis实现PubSub*在本章中讨论'
- en: Storing and retrieving data with Redis
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis存储和检索数据
- en: '**Redis** is a non-traditional database, dubbed a data structures server, which
    functions in operational memory with blazingly fast performance.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis**是一个非传统的数据库，被称为数据结构服务器，在操作内存中具有极快的性能。'
- en: Redis is excellent for certain tasks, as long as the data model is fairly simple
    and isn't so large that it swamps your server RAM. Good examples of where Redis
    shines are in site analytics, server-side session cookies, and providing a list
    of logged-in users in real time.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Redis非常适用于某些任务，只要数据模型相对简单，且数据量不会太大以至于淹没服务器的RAM。Redis擅长的示例包括网站分析、服务器端会话cookie和实时提供已登录用户列表。
- en: In the spirit of our theme, we will re-implement our quotes database with Redis.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的主题精神，我们将使用Redis重新实现我们的引用数据库。
- en: Getting ready
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: We'll be using the `node_redis` client.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`node_redis`客户端。
- en: '[PRE66]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We also need to install the Redis server, which can be downloaded from [http://www.redis.io/download](http://www.redis.io/download)
    along with installation instructions.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装Redis服务器，可以从[http://www.redis.io/download](http://www.redis.io/download)下载，并附有安装说明。
- en: Let's also create a new directory with a new `quotes.js` file.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还创建一个新的目录，其中包含一个新的`quotes.js`文件。
- en: How to do it...
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's create the `redis` module, create a connection, and listen for the `ready`
    event emitted by the `redis client`, not forgetting to load the command-line arguments
    into the `params` object.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`redis`模块，创建一个连接，并监听`redis client`发出的`ready`事件，不要忘记将命令行参数加载到`params`对象中。
- en: '[PRE67]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we''ll check for `author` and `quote` via the command line. If they''re
    defined, we''ll insert these as hash (an object structure) into Redis, inside
    our `ready` event callback:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过命令行检查`author`和`quote`。如果它们被定义，我们将在我们的`ready`事件回调中将它们作为哈希（对象结构）插入Redis中：
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Not only did we add our data to Redis, we also constructed a basic index on
    the fly enabling us to search for quotes by author in our next piece of code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅将数据添加到了Redis中，还在飞行中构建了一个基本的索引，使我们能够在下一段代码中按作者搜索引用。
- en: We check for the existence of the first command-line argument, the author, and
    then output quotes by that author.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查第一个命令行参数，作者的存在，并输出该作者的引用。
- en: '[PRE69]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works...
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If both `author` and `quote` are specified via the command line, we go ahead
    and generate a random key prefixed with `Quote:`. So each key will look something
    like `Quote:08d780a57b035f`. This helps us to identify keys in debugging and it's
    also common convention to prefix the Redis keys with names delimited by a colon.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过命令行指定了`author`和`quote`，我们继续并生成一个以`Quote:`为前缀的随机键。因此，每个键看起来都像`Quote:08d780a57b035f`。这有助于我们在调试中识别键，并且在Redis键前缀中使用名称是常见的约定。
- en: 'We pass this key into `client.hmset`, a wrapper for the Redis `HMSET` command,
    which allows us to create multiple hashes. Unlike the raw `HMSET, client.hmset`
    also accepts a JavaScript object (instead of an array) to create multiple key
    assignments. With the standard Redis command-line client, `redis-cli`, we would
    have to say:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个键传递给`client.hmset`，这是Redis `HMSET`命令的包装器，它允许我们创建多个哈希。与原始的`HMSET`不同，`client.hmset`还接受JavaScript对象（而不是数组）来创建多个键分配。使用标准的Redis命令行客户端`redis-cli`，我们需要这样说：
- en: '[PRE70]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We could hold to this format by using an array containing keys next to values,
    but an object seems kinder and more familiar to the eyes of a JavaScript folk.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用包含键和值的数组来保持这种格式，但是对象对于JavaScript开发者来说更友好和更熟悉。
- en: Every time we store a new quote with `client.hmset`, we add the `randKey` for
    that quote to the relevant author set via the second parameter of `client.sadd.
    client.sadd` allows us to add a member to a Redis set (a set is like an array
    of strings). The key for our `SADD` command is based on the intended author. So
    in the Steve Jobs quote used above, the key to pass into `client.sadd` would be
    `Author:Steve Jobs`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们使用`client.hmset`存储新引用时，我们通过`client.sadd`的第二个参数将该引用的`randKey`添加到相关的作者集合中。`client.sadd`允许我们向Redis集合（集合类似于字符串数组）中添加成员。我们的`SADD`命令的键是基于预期作者的。因此，在上面使用的Steve
    Jobs引用中，传递给`client.sadd`的键将是`Author:Steve Jobs`。
- en: Next, if an author is specified we perform an `SMEMBERS` using `client.smembers`.
    This returns all the values we stored to a specific authors' set, being the keys
    for all quotes relating to that author.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果指定了作者，我们使用`client.smembers`执行`SMEMBERS`。这将返回我们存储在特定作者集合中的所有引用的键。
- en: We loop through these keys using `forEach`, passing every key into `client.hgetall`.
    Redis `HGETALL` returns hash (object) that we passed into `client.hmset` earlier.
    Each author and quote is then logged to the console, and `client.quit` gracefully
    exits our script once all Redis commands have been executed.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`forEach`循环遍历这些键，将每个键传递给`client.hgetall`。Redis `HGETALL`返回我们之前传递给`client.hmset`的哈希（对象）。然后将每个作者和引用记录到控制台，并且一旦所有Redis命令都已执行，`client.quit`就会优雅地退出我们的脚本。
- en: A `client.quit` is also included at the end of the `ready` event on? occasions
    where no command-line arguments have been specified.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ready`事件的结尾处也包括了`client.quit`，在没有指定命令行参数的情况下会发生这种情况。
- en: There's more...
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Redis is a speed freak's dream, but we can still make optimizations.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是速度狂人的梦想，但我们仍然可以进行优化。
- en: Speeding up node Redis module
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加速node Redis模块
- en: 'By default, the `redis` module uses a pure JavaScript parser. However, the
    Redis project provides a Node `hiredis` module: a C bindings module which binds
    to the official Redis client, Hiredis. Hiredis is faster (being written in C)
    than the JavaScript parser.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`redis`模块使用纯JavaScript解析器。然而，Redis项目提供了一个Node `hiredis`模块：一个C绑定模块，它绑定到官方Redis客户端Hiredis。Hiredis比JavaScript解析器更快（因为它是用C编写的）。
- en: The `redis` module will interface with the `hiredis` module if it is installed.
    Therefore, we can achieve performance benefits simply by installing `hiredis:`
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装了`hiredis`模块，`redis`模块将与`hiredis`模块进行接口。因此，我们可以通过简单安装`hiredis`来获得性能优势：
- en: '[PRE71]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Overcoming network latency by pipelining commands
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过流水线化命令来克服网络延迟
- en: Redis can receive multiple commands at once. The `redis` module has a `multi`
    method which sends collated commands en masse. If the latency (time taken for
    data to travel) was 20 ms per command, for 10 combined commands we save 180 ms
    (10 x 20 - 20 = 180).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Redis可以一次接收多个命令。`redis`模块有一个`multi`方法，可以批量发送汇总的命令。如果每个命令的延迟（数据传输所需的时间）为20毫秒，对于10个组合命令，我们可以节省180毫秒（10
    x 20 - 20 = 180）。
- en: 'If we copy `quotes.js` to `quotes_multi.js` we can alter it accordingly:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`quotes.js`复制到`quotes_multi.js`，我们可以相应地进行修改：
- en: '[PRE72]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We can see our original Redis commands highlighted, only they have been chained
    with `client.multi`. Once all commands have been added to `client.multi`, we invoke
    its `exec` method. Finally, we use the callback of `exec` to verify that our data
    was successfully added.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的原始Redis命令已经突出显示，只是它们已经与`client.multi`链接在一起。一旦所有命令都添加到`client.multi`，我们调用它的`exec`方法。最后，我们使用`exec`的回调来验证我们的数据是否成功添加。
- en: We didn't provision `SMEMBERS` for pipelining. `SMEMBERS` must be called after
    the quote has been added, or else the new quote won't be displayed. If `SMEMBERS`
    was combined with `HMSET` and `SADD` it would be executed asynchronously alongside
    them. There's no guarantee that the new quote would be available to `SMEMBERS`.
    In fact, it's unlikely since `SMEMBERS` is more complex than `SADD`, so it takes
    longer to process.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为流水线提供`SMEMBERS`。必须在引语添加后调用`SMEMBERS`，否则新引语将不会显示。如果`SMEMBERS`与`HMSET`和`SADD`结合使用，它将与它们一起异步执行。不能保证新引语将对`SMEMBERS`可用。实际上，这是不太可能的，因为`SMEMBERS`比`SADD`更复杂，所以处理时间更长。
- en: See also
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Storing and retrieving data with Mongoskin* discussed in this chapter'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用Mongoskin存储和检索数据*'
- en: '*Connecting and sending SQL to a MySQL server* discussed in this chapter'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接并向MySQL服务器发送SQL*在本章中讨论'
- en: '*Implementing PubSub with Redis* discussed in this chapter'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用Redis实现PubSub*'
- en: Implementing PubSub with Redis
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis实现PubSub
- en: Redis exposes a Publish-Subscribe messaging pattern (not so dissimilar to the
    CouchDB `changes` stream), which can be used to listen to specific data change
    events. Data from these events could be passed between processes to, for instance,
    instantly update a web app with fresh new data.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Redis公开了发布-订阅消息模式（与CouchDB的`changes`流不那么相似），可以用于监听特定数据更改事件。这些事件的数据可以在进程之间传递，例如，立即使用新鲜数据更新Web应用程序。
- en: With PubSub, we publish a message to a specific channel, this channel can then
    be picked up by any amount of subscribers. The publishing mechanism doesn't care
    who's listening or how many, it chats away regardless.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通过PubSub，我们可以向特定频道发布消息，然后任何数量的订阅者都可以接收到该频道。发布机制不在乎谁在听或有多少人在听，它会继续聊天。
- en: In this recipe, we will create a publishing process and a subscribing process.
    For publishing, we'll extend our `quotes.js` file from the previous recipe *Storing
    and retrieving data with Redis*, and we'll write the code to a new file for the
    subscription mechanism.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个发布过程和一个订阅过程。对于发布，我们将扩展我们的`quotes.js`文件，从上一个配方*使用Redis存储和检索数据*，并为订阅机制编写新文件的代码。
- en: Getting ready
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Let's create a new directory, copy `quotes.js` from the previous recipe, and
    rename it to `quotes_publish.js`. We will also create a file called `quotes_subscribe.js`.
    We'll need to ensure that Redis is running. If it isn't installed and running
    globally, we can navigate to the directory Redis was unpacked to and run `./redis-server`
    from the `src` folder.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新目录，从上一个配方中复制`quotes.js`，并将其重命名为`quotes_publish.js`。我们还将创建一个名为`quotes_subscribe.js`的文件。我们需要确保Redis正在运行。如果它没有全局安装和运行，我们可以导航到Redis解压到的目录，并从`src`文件夹运行`./redis-server`。
- en: How to do it...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In `quotes_publish.js` we add one extra line of code inside our first conditional
    statement, just after our `client.sadd` call.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quotes_publish.js`中，我们在第一个条件语句内添加了一行额外的代码，就在我们的`client.sadd`调用之后。
- en: '[PRE73]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This means every time we add an author and quote, we publish the quote to a
    channel named after the author. We subscribe to channels using `quotes_subscribe.js`,
    so let's code it.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次我们添加一个作者和引语时，我们都会将引语发布到以作者命名的频道。我们使用`quotes_subscribe.js`订阅频道，所以让我们编写代码。
- en: 'First, it must require the `redis` module and create a client:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它必须要求`redis`模块并创建一个客户端：
- en: '[PRE74]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We're going to provide the option to subscribe to multiple channels, again using
    the command line as our elementary input method. To achieve this, we'll loop through
    `process.argv:`
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供订阅多个频道的选项，再次使用命令行作为我们的基本输入方法。为此，我们将循环遍历`process.argv:`
- en: '[PRE75]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now that we are subscribing to channels, we need to listen to messages:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在订阅频道，我们需要监听消息：
- en: '[PRE76]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can test our PubSub functionality by first running `quotes_subscribe.js`
    along with some specified authors:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过首先运行`quotes_subscribe.js`来测试我们的PubSub功能，并指定一些作者：
- en: '[PRE77]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Then we open a new terminal and run several authors and quotes through `quotes_publish.js`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打开一个新的终端，并通过`quotes_publish.js`运行几个作者和引语。
- en: '[PRE78]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let''s see it in action:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的运行情况：
- en: '![How to do it...](img/7188-04-04.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/7188-04-04.jpg)'
- en: Only the channels we subscribed to appeared on the `quotes_subscribe.js` terminal.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 只有我们订阅的频道才会出现在`quotes_subscribe.js`终端上。
- en: How it works...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We access the Redis `PUBLISH` command in `quotes_publish.js` via `client.publish`,
    setting the channel name by author name.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`client.publish`访问Redis的`PUBLISH`命令，在`quotes_publish.js`中设置频道名称为作者名称。
- en: In `quotes_subscribe.js` we loop through any arguments given via command line.
    (We apply `forEach` to `process.argv.slice(2)`. This removes the first two elements
    of the `process.argv` array, which would hold the command (`node`) and the path
    to our script. Each relevant argument is passed to `client.subscribe`, telling
    Redis we wish to `SUBSCRIBE` to that channel.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在`quotes_subscribe.js`中，我们循环遍历通过命令行给出的任何参数。（我们对`process.argv.slice(2)`应用`forEach`。这会删除`process.argv`数组的前两个元素，这些元素将保存命令（`node`）和我们脚本的路径。将每个相关参数传递给`client.subscribe`，告诉Redis我们希望`SUBSCRIBE`到该频道。
- en: When a message arrives due to a subscription, the `redis` module `client` will
    emit a `message` event. We listen for this event and pass the incoming `channel`
    and `msg` (which will be `author` and `quote` accordingly) to `console.log`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当由于订阅而到达消息时，`redis`模块的`client`将发出`message`事件。我们监听此事件，并将传入的`channel`和`msg`（将分别是`author`和`quote`）传递给`console.log`。
- en: There's more...
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Finally, we'll take a look at Redis security.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看一下Redis安全性。
- en: Redis authentication
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis身份验证
- en: We can set authentication for Redis with the `redis.conf` file, found in the
    directory we installed Redis to. To set a password in `redis.conf`, we simply
    add (or uncomment) `requirepass ourpassword`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Redis的`redis.conf`文件中设置身份验证，该文件位于我们安装Redis的目录中。要在`redis.conf`中设置密码，我们只需添加（或取消注释）`requirepass
    ourpassword`。
- en: 'Then we make sure that our Redis server points to the configuration file. If
    we are running it from the `src` directory, we would initiate with the following
    command:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们确保我们的Redis服务器指向配置文件。如果我们是从`src`目录运行它，我们将使用以下命令初始化：
- en: '[PRE79]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If we wanted to set a password quickly we could say:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想快速设置密码，我们可以说：
- en: '[PRE80]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We could set a password from within Node with the `CONFIG SET` Redis command:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Redis命令`CONFIG SET`从Node中设置密码：
- en: '[PRE81]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: To authenticate with a Redis server within Node, we can use the `redis` module's
    `auth` method, before any other calls (that is, prior to `client.ready)`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Node中与Redis服务器进行身份验证，我们可以使用`redis`模块的`auth`方法，在任何其他调用之前（即在`client.ready`之前）。
- en: '[PRE82]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The password has to be sent before any other commands. The `redis` module's
    `auth` function takes of things like reconnections by pushing the password into
    the `redis` module's internal operations. Essentially, we can call `auth` at the
    top of our code and never concern ourselves with authentication for that script
    again.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 密码必须在任何其他命令之前发送。`redis`模块的`auth`函数通过将密码推送到`redis`模块的内部操作来处理重新连接等问题。基本上，我们可以在我们的代码顶部调用`auth`，然后再也不用担心该脚本的身份验证。
- en: Securing Redis from external connections
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护Redis免受外部连接
- en: If there was no need for external connections to Redis, we could bind it to
    `127.0.0.1`, inhibiting all external traffic.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要将Redis绑定到`127.0.0.1`以阻止所有外部流量。
- en: 'We can achieve this with a configuration file, for instance `redis.conf`, and
    add (or uncomment):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过配置文件来实现这一点，例如`redis.conf`，并添加（或取消注释）：
- en: '[PRE83]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, if running from the `src` folder, initialize our Redis server with:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果从`src`文件夹运行，初始化我们的Redis服务器：
- en: '[PRE84]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Alternatively, we could do it as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样做：
- en: '[PRE85]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Or in Node with the `redis` module''s `config` method:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在Node中使用`redis`模块的`config`方法：
- en: '[PRE86]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we installed Redis via a package manager it may already be configured to
    block external connections.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过软件包管理器安装了Redis，它可能已经配置为阻止外部连接。
- en: See also
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Accessing CouchDB changes stream with Cradle* discussed in this chapter'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用Cradle访问CouchDB更改流*'
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用Redis存储和检索数据*'
