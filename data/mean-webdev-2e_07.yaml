- en: Chapter 7. Introduction to Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。Angular简介
- en: 'The last piece of the MEAN puzzle is, of course, Angular. Back in 2009, while
    building their JSON as platform service, developers Miško Hevery and Adam Abrons
    noticed that the common JavaScript libraries weren''t enough. The nature of their
    rich web applications raised the need for a more structured framework that would
    reduce redundant work and keep the project code organized. Abandoning their original
    idea, they decided to focus on the development of their framework, naming it AngularJS
    and releasing it under an open source license. The idea was to bridge the gap
    between JavaScript and HTML and help popularize single-page application development.
    In the years to come, AngularJS—now referred to as Angular—became one of the most
    popular frameworks in the JavaScript ecosystem, and it completely changed the
    frontend development world. However, in the past few years, there were a few major
    paradigm shifts. So, when the Google-sponsored team decided to work on Angular''s
    next version, they introduced a whole set of new ideas. In this chapter, we''ll
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MEAN拼图的最后一块当然是Angular。回到2009年，当开发人员Miško Hevery和Adam Abrons在构建他们的JSON作为平台服务时，他们注意到常见的JavaScript库并不够用。他们丰富的Web应用程序的性质引发了对更有结构的框架的需求，以减少冗余工作并保持项目代码有序。他们放弃了最初的想法，决定专注于开发他们的框架，将其命名为AngularJS，并在开源许可下发布。这个想法是弥合JavaScript和HTML之间的差距，并帮助推广单页面应用程序的开发。在接下来的几年里，AngularJS—现在被称为Angular—成为JavaScript生态系统中最受欢迎的框架之一，并彻底改变了前端开发世界。然而，在过去的几年里，发生了一些重大的范式转变。因此，当由谷歌赞助的团队决定开发Angular的下一个版本时，他们引入了一整套新的想法。在本章中，我们将涵盖以下主题：
- en: Introducing TypeScript
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍TypeScript
- en: Introducing Angular 2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Angular 2
- en: Understanding the building blocks of Angular 2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Angular 2的构建块
- en: Installing and configuring TypeScript and Angular 2
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置TypeScript和Angular 2
- en: Creating and organizing the Angular 2 application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和组织Angular 2应用程序
- en: Utilizing Angular's components architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Angular的组件架构
- en: Implementing the `Authentication` component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Authentication`组件
- en: Introducing Angular 2
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Angular 2
- en: AngularJS was a frontend JavaScript framework designed to build single-page
    applications using an MVC-like architecture. The Angular approach was to extend
    the functionality of HTML using special attributes that bind JavaScript logic
    with HTML elements. AngularJS's ability to extend HTML allowed cleaner DOM manipulation
    through client-side templating and two-way data binding that seamlessly synchronized
    between models and views. AngularJS also improved the application's code structure
    and testability using MVC and dependency injection. AngularJS 1 was and still
    is a great framework, but it was built with the concepts of ES5 in mind, and with
    the huge improvements brought by the new ES2015 specification coming up, the team
    had to rethink the entire approach.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS是一个前端JavaScript框架，旨在使用类似MVC的架构构建单页面应用程序。Angular的方法是通过特殊属性扩展HTML的功能，将JavaScript逻辑与HTML元素绑定在一起。AngularJS扩展HTML的能力允许通过客户端模板化进行更清晰的DOM操作，并实现了无缝同步的双向数据绑定，使模型和视图之间无缝同步。AngularJS还通过MVC和依赖注入改进了应用程序的代码结构和可测试性。AngularJS
    1是一个很棒的框架，但它是基于ES5的概念构建的，随着新的ES2015规范带来的巨大改进，团队不得不重新思考整个方法。
- en: From Angular 1.x to Angular 2.x
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Angular 1.x到Angular 2.x
- en: 'If you''re already familiar with Angular 1, moving to Angular 2 might seem
    like a big step. However, the Angular team made sure to keep the good parts of
    Angular 1 while leveraging ES2015''s new capabilities and maintaining a clearer
    path toward an improved framework. Here''s a quick summary of the changes made
    from Angular 1:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉Angular 1，转向Angular 2可能看起来是一个很大的步骤。然而，Angular团队确保保留了Angular 1的优点，同时利用ES2015的新功能，并保持了通向改进框架的更清晰的路径。以下是从Angular
    1所做的更改的快速总结：
- en: '**Syntax**: Angular 2 relies on the new ECMAScript specification formerly known
    as ES6 and now renamed ES2015\. However, the specification is still a work in
    progress and browser support is still lacking. To overcome this issue, the Angular
    2 team decided to use TypeScript.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**：Angular 2依赖于以前称为ES6的新ECMAScript规范，现在更名为ES2015。然而，该规范仍在不断发展，浏览器支持仍然不足。为了解决这个问题，Angular
    2团队决定使用TypeScript。'
- en: '**TypeScript**: TypeScript is a superset of ES2015, which means that it allows
    you to write strongly typed ES2015 code, which will later be compiled into the
    ES5 or ES2015 source depending on your needs and platform support. Angular 2 is
    pushing hard for TypeScript usage in their documentation and code examples, and
    so will we. Don''t worry, though; as vast and terrifying as TypeScript might seem,
    by the end of this chapter, you''ll be able to use it.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**：TypeScript是ES2015的超集，这意味着它允许您编写强类型的ES2015代码，稍后将根据您的需求和平台支持编译为ES5或ES2015源代码。Angular
    2在其文档和代码示例中大力推动TypeScript的使用，我们也会这样做。不过，不用担心；尽管TypeScript可能看起来广泛而可怕，但在本章结束时，您将能够使用它。'
- en: '**Modules**: Angular 1 introduced a modular architecture that required the
    usage of the `angular#module()` custom method. However, ES2015 introduced a built-in
    module system very similar to the one used in Node.js. So Angular 2 modules are
    much easier to create and use.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**：Angular 1引入了一个模块化架构，需要使用`angular#module()`自定义方法。然而，ES2015引入了一个类似于Node.js中使用的内置模块系统。因此，Angular
    2模块更容易创建和使用。'
- en: '**Controllers**: Angular 1 was all about controllers. In the first version
    of this book, this chapter was mainly focused on the Angular 1 MVC approach, but
    in Angular 2, the basic building block is components. This shift also represents
    a bigger shift in the JavaScript ecosystem, especially regarding web components.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：Angular 1主要关注控制器。在本书的第一个版本中，本章主要关注Angular 1的MVC方法，但在Angular 2中，基本构建块是组件。这种转变也代表了JavaScript生态系统的更大转变，特别是关于Web组件。'
- en: '**Scopes**: The famous `$scope` object is now obsolete. In Angular 2, the component
    model is cleaner and more readable. Generally, the introduction of classes in
    ES2015 and its support in TypeScript allows better design patterns.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域**：著名的`$scope`对象现在已经过时。在Angular 2中，组件模型更清晰、更可读。一般来说，ES2015中引入类的概念及其在TypeScript中的支持允许更好的设计模式。'
- en: '**Decorators**: Decorators is a design feature implemented in TypeScript and
    is probably going to be implemented in ES2016(ES7). Decorators allow developers
    to annotate classes and members in order to add features or data while not extending
    the entity. Angular 2 relies on decorators to implement certain features, and
    you''re going to deal with them later in this chapter.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**：装饰器是TypeScript中实现的一种设计特性，可能会在ES2016（ES7）中实现。装饰器允许开发人员注释类和成员，以添加功能或数据，而不扩展实体。Angular
    2依赖装饰器来实现某些功能，您将在本章后面处理它们。'
- en: '**Dependency Injection**: Angular 1 used the Dependency Injection paradigm
    quite intensively. Angular 2 made Dependency Injection simpler and now supports
    multiple injectors instead of one.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**：Angular 1非常强调依赖注入范式。Angular 2简化了依赖注入，现在支持多个注入器而不是一个。'
- en: All of these features mark a new era for Angular and JavaScript in general and
    it all starts with TypeScript.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性标志着Angular和JavaScript的新时代，一切都始于TypeScript。
- en: Introduction to TypeScript
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript简介
- en: TypeScript is a typed programming language created by Microsoft, which uses
    the object-oriented foundations of C#, Java, and now ES2015\. Code written in
    TypeScript is transpiled into JavaScript code either in ES3, ES5 or ES2015 and
    can be run on any of the modern web browsers. It is also a superset of ES2015,
    so basically, any JavaScript code is valid TypeScript code. The idea behind this
    was to create a strongly typed programming language for big projects that will
    allow big teams to better communicate the interface between their software components.
    As derived from its name, TypeScript has an optional type system that allows developers
    to enforce limits on their code in order to have better clarity. Since a lot of
    the features in TypeScript were already implemented in ES2015, we'll touch a few
    basic features that we'll need and didn't get in the current specifications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由微软创建的一种类型化编程语言，它使用了C＃、Java和现在的ES2015的面向对象基础。用TypeScript编写的代码会被转译成ES3、ES5或ES2015的JavaScript代码，并可以在任何现代Web浏览器上运行。它也是ES2015的超集，因此基本上任何JavaScript代码都是有效的TypeScript代码。其背后的想法是创建一个强类型的编程语言，用于大型项目，可以让大型团队更好地沟通其软件组件之间的接口。由于TypeScript中的许多特性已经在ES2015中实现，我们将介绍一些基本特性，这些特性是我们需要的，但在当前规范中没有得到。
- en: Types
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: Types are a major part of every programming language, including JavaScript.
    Unfortunately, static typing was not introduced in ES2015; however, TypeScript
    support the basic JavaScript types and also allows developers to create and use
    their own types.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是每种编程语言的重要部分，包括JavaScript。不幸的是，静态类型在ES2015中没有被引入；然而，TypeScript支持基本的JavaScript类型，并允许开发人员创建和使用自己的类型。
- en: Basic types
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本类型
- en: 'Types can be JavaScript primitive types, as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以是JavaScript原始类型，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Moreover, TypeScript also allows you to work with arrays:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，TypeScript还允许您使用数组：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both ways are then transpiled into the familiar JavaScript array declaration.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这两种方式都被转译成熟悉的JavaScript数组声明。
- en: The any type
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任意类型
- en: 'The `any` type represents any freeform JavaScript value. The value of `any`
    will go through a minimal static type checking by the transpiler and will support
    all operations as a JavaScript value. All properties on an `any` value can be
    accessed, and an `any` value can also be called as a function with an argument
    list. Actually, `any` is a supertype of all types, and whenever TypeScript cannot
    infer a type, the `any` type will be used. You''ll be able to use the `any` type
    either explicitly or not:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`类型表示任何自由形式的JavaScript值。`any`的值将通过转译器进行最小的静态类型检查，并支持作为JavaScript值的所有操作。可以访问`any`值上的所有属性，并且`any`值也可以作为带有参数列表的函数调用。实际上，`any`是所有类型的超类型，每当TypeScript无法推断类型时，将使用`any`类型。您可以显式或隐式地使用`any`类型：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Interfaces
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'As TypeScript is about keeping the structure of your project, highly important
    parts of the language are interfaces. An interface allows you shape your objects
    and keep your code solid and clear. Classes can implement interfaces, which means
    that they will have to conform to the properties or methods declared in the interface.
    Interfaces can also inherit from other interfaces, which means that their implementing
    classes will be able to implement the extended interfaces. An example TypeScript
    interface will look similar to this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TypeScript是关于保持项目结构的，语言的重要部分是接口。接口允许您塑造对象并保持代码的稳固和清晰。类可以实现接口，这意味着它们必须符合接口中声明的属性或方法。接口还可以继承自其他接口，这意味着它们的实现类将能够实现扩展的接口。一个示例的TypeScript接口将类似于这样：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we have an `IVehicle` interface with two properties and one method. An
    implementing class would look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`IVehicle`接口，有两个属性和一个方法。一个实现类会是这样的：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the `Car` class implements the `IVehicle` interface and follows
    the structure set by it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Car`类实现了`IVehicle`接口，并遵循了其设置的结构。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Interfaces are a powerful feature of TypeScript and are an important part of
    OOP. It is recommended that you continue reading about them here: [https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是TypeScript的一个强大特性，也是面向对象编程的重要部分。建议您继续阅读有关它们的内容：[https://www.typescriptlang.org/docs/handbook/interfaces.html](https://www.typescriptlang.org/docs/handbook/interfaces.html)。
- en: Decorators
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'While it''s still in the proposal stage for the new ES7 specifications, Angular
    2 relies heavily on decorators. A decorator is a special kind of declaration that
    can be attached to various entities, such as classes, methods, or properties.
    Decorators provide developers with a reusable way to annotate and modify classes
    and members. A decorator uses the `@decoratorName` form, where the `decoratorName`
    parameter must be a function that will be called at runtime with the decorated
    entity. A simple decorator would look as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于新的 ES7 规范来说，它仍处于提案阶段，但 Angular 2 在装饰器上有很大的依赖。装饰器是一种特殊类型的声明，可以附加到各种实体上，比如类、方法或属性。装饰器为开发人员提供了一种可重用的方式来注释和修改类和成员。装饰器使用
    `@decoratorName` 的形式，其中 `decoratorName` 参数必须是一个函数，在运行时将被调用以装饰实体。一个简单的装饰器如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At runtime, the decorator will be executed with the target parameter populated
    with the `MyClass` constructor. Moreover, the decorator can also have arguments
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，装饰器将使用 `MyClass` 构造函数填充目标参数执行。此外，装饰器也可以带有参数，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This pattern is also know as a decorator factory. Decorators may seem a bit
    odd, but as soon as we dive into Angular 2, you'll begin to understand their robustness.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式也被称为装饰器工厂。装饰器可能看起来有点奇怪，但一旦我们深入了解 Angular 2，你就会开始理解它们的强大。
- en: Summary
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: TypeScript has been around for years and is being developed by a very strong
    team. This means that we've barely scratched the surface of its endless features
    and abilities. However, this introduction will provide us with the skills and
    knowledge required for diving into the great framework that Angular 2 is.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 已经存在多年，并且由一个非常强大的团队开发。这意味着我们仅仅触及了它无尽的功能和能力的表面。然而，这个介绍将为我们提供进入 Angular
    2 这个伟大框架所需的技能和知识。
- en: Angular 2 Architecture
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2 架构
- en: 'The goal of Angular 2 is simple: bring HTML and JavaScript together in a manageable
    and scalable way in order to build a client application. To do that, Angular 2
    uses a component-based approach with supporting entities, such as services and
    directives being injected into the components at runtime. This approach may seem
    a bit odd at first, but it allows us to keep a clear separation of concerns and
    generally maintain a clearer project structure. In order to understand the basics
    of Angular 2, take a look at the following figure:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 的目标很简单：以一种可管理和可扩展的方式将 HTML 和 JavaScript 结合起来，以构建客户端应用程序。为此，Angular
    2 使用了基于组件的方法，支持实体，如服务和指令，在运行时注入到组件中。这种方法一开始可能有点奇怪，但它允许我们保持关注点的清晰分离，并通常保持更清晰的项目结构。为了理解
    Angular 2 的基础知识，请看下面的图：
- en: '![Angular 2 Architecture](img/B05071_07_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2 架构](img/B05071_07_01.jpg)'
- en: The preceding figure presents a simplistic architecture for an Angular 2 application
    consisting of two components. The center entities are the components. Each component
    performs data binding and event handling with its template in order to present
    the user with an interactive UI. Services are created for any other task, such
    as loading data, performing calculations, and so on. The services are then consumed
    by the components that delegate these tasks. Directives are the instructions for
    the rendering of the component's templates. In order to understand this better,
    let's dive in a little deeper.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了一个由两个组件组成的 Angular 2 应用程序的简单架构。中心实体是组件。每个组件都通过其模板执行数据绑定和事件处理，以向用户呈现交互式用户界面。服务用于执行任何其他任务，比如加载数据、执行计算等。然后组件消耗这些服务并委托这些任务。指令是组件模板的渲染指令。为了更好地理解这一点，让我们深入了解一下。
- en: Angular 2 Modules
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 模块
- en: 'Angular 2 applications are usually modular applications. This means that an
    Angular 2 application consists of multiple modules, and each one is a piece of
    code usually dedicated to a single task. In fact, the entire framework is built
    in a modular way that allows developer to import only the features they need.
    Fortunately, Angular 2 uses the ES2015 module syntax we covered earlier. Our application
    will be built of custom modules as well, and a sample application module would
    look as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 应用通常是模块化的应用程序。这意味着 Angular 2 应用程序由多个模块组成，每个模块通常都是专门用于单个任务的一段代码。事实上，整个框架都是以模块化的方式构建的，允许开发人员只导入他们需要的功能。幸运的是，Angular
    2 使用了我们之前介绍过的 ES2015 模块语法。我们的应用程序也将由自定义模块构建，一个示例应用程序模块如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, we use the `@NgModule` decorator to create the application
    module, which uses the application component and routes to bootstrap our application.
    To understand this better, let''s take a look at the first and foremost building
    block of an Angular 2 application: the component.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用 `@NgModule` 装饰器来创建应用程序模块，该模块使用应用程序组件和路由来启动我们的应用程序。为了更好地理解这一点，让我们来看看
    Angular 2 应用程序的第一个和最重要的构建块：组件。
- en: Angular 2 Components
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 组件
- en: 'A component is the essential building block of an Angular 2 application. Its
    job is to control a dedicated part of a user interface usually referred to as
    a view. Most applications will consist of at least one root application component
    and, usually, multiple components that control different views. Components are
    usually defined as a regular ES2015 class with a `@Component` decorator that defines
    it as a component and includes the component metadata. The component class is
    then exported as a module that can be imported and used in other parts of your
    application. A simple application component will be as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是 Angular 2 应用程序的基本构建块。它的工作是控制用户界面的一个专用部分，通常称为视图。大多数应用程序至少包含一个根应用程序组件，通常还包含多个控制不同视图的组件。组件通常被定义为一个常规的
    ES2015 类，带有一个 `@Component` 装饰器，用于将其定义为组件并包含组件元数据。然后将组件类导出为一个模块，可以在应用程序的其他部分导入和使用。一个简单的应用程序组件如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note how we import the `@Component` decorator from the `@angular/core` module
    library and then use it to define our component DOM selector and the template
    we want to use. In the end, we export a class called `AppComponent`. Components
    are one side of the view management, and we have the template on the other side.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何从 `@angular/core` 模块库中导入 `@Component` 装饰器，然后使用它来定义我们的组件 DOM 选择器和我们想要使用的模板。最后，我们导出一个名为
    `AppComponent` 的类。组件是视图管理的一方，另一方是模板。
- en: Angular 2 Templates
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 模板
- en: 'Templates are used by the components to render a component view. They are formed
    from a mix of basic HTML combined with Angular-dedicated annotations, which tells
    the component how to render the final view. In the previous example, you can see
    that a simple template is passed directly to the `AppComponent` class. However,
    you can also save your template in an external template file and change your component
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 模板由组件用于呈现组件视图。它们由基本的 HTML 与 Angular 专用的注解组合而成，告诉组件如何呈现最终视图。在前面的例子中，你可以看到一个简单的模板直接传递给了
    `AppComponent` 类。然而，你也可以将模板保存在外部模板文件中，并将组件更改为如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see here, our current template is static, so in order to create more
    useful templates, it's time to discuss data binding.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们当前的模板是静态的，所以为了创建更有用的模板，现在是时候讨论数据绑定了。
- en: Angular 2 data binding
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 数据绑定
- en: One of Angular's greatest features is its sophisticated data binding abilities.
    If you're used to working outside a framework, you know the nightmare that it
    is to manage data updates between the view and your data model. Luckily, Angular's
    data binding provides you with a straightforward way of managing the binding between
    your component class and the rendered view.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 最大的特点之一是其复杂的数据绑定能力。如果你习惯于在框架之外工作，你就知道在视图和数据模型之间管理数据更新是一种噩梦。幸运的是，Angular
    的数据绑定为你提供了一种简单的方式来管理组件类和渲染视图之间的绑定。
- en: Interpolation binding
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插值绑定
- en: 'The simplest way of binding data from your component class to your template
    is called interpolation. An interpolation binds a value of the class property
    with your template using the double curly brackets syntax. A simple example of
    this mechanism will be as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从组件类绑定到模板的最简单方法称为插值。插值使用双大括号语法将类属性的值与模板绑定。这种机制的一个简单例子如下：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note how we bind the `title` property of our `AppComponent` class inside the
    template HTML.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在模板 HTML 中绑定了 `AppComponent` 类的 `title` 属性。
- en: Property binding
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性绑定
- en: 'Another example of one-way data binding would be property binding, which allows
    you to bind an HTML element property value with a component property value or
    any other template expression. This is done using square brackets, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 单向数据绑定的另一个例子是属性绑定，它允许你将 HTML 元素的属性值与组件属性值或任何其他模板表达式绑定。这是使用方括号来完成的，如下所示：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, Angular will render the button as disabled since we set the
    `isButtonDisabled` property to `true`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Angular 会将按钮呈现为禁用状态，因为我们将 `isButtonDisabled` 属性设置为 `true`。
- en: Event binding
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件绑定
- en: 'In order for your component to respond to the DOM event generated from the
    view, Angular 2 provides you with the mechanism of event binding. To bind a DOM
    event to a component method, all you have to do is set the event name inside round
    brackets, as shown in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的组件响应从视图生成的 DOM 事件，Angular 2 为你提供了事件绑定的机制。要将 DOM 事件绑定到组件方法，你只需要在圆括号内设置事件名称，如下例所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, a click event of the view button will call the `showMessage()`
    method inside our `AppComponent` class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，视图按钮的点击事件将调用我们的 `AppComponent` 类内的 `showMessage()` 方法。
- en: Two-way binding
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向绑定
- en: 'Up until now, we''ve only discussed one-way data binding where either the view
    calls a component function or the component changes the view. However, when dealing
    with user inputs, we''ll need to be able to do two-way data binding in a seamless
    way. This can be done by adding the `ngModel` property to your input HTML element
    and binding it to a component property. To do that, we''ll need to use a combination
    syntax of round and square brackets, as shown in the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了单向数据绑定，其中视图调用组件函数或组件改变视图。然而，当处理用户输入时，我们需要以一种无缝的方式进行双向数据绑定。这可以通过将
    `ngModel` 属性添加到你的输入 HTML 元素并将其绑定到组件属性来完成。为了做到这一点，我们需要使用圆括号和方括号的组合语法，如下例所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, a user will see a title element that will be updated live according
    to the input. The input binds the name property both ways, so every change to
    the input value will be updated in the `AppComponent` class and rendered into
    the view. The `ngModel` property we used here is called a directive, so naturally,
    it's time to discuss directives.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户将看到一个标题元素，它将根据输入实时更新。输入双向绑定了名称属性，因此对输入值的每次更改都将更新到 `AppComponent` 类并呈现到视图中。我们在这里使用的
    `ngModel` 属性被称为指令，因此自然而然地，现在是时候讨论指令了。
- en: Angular 2 Directives
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 指令
- en: Angular's basic operation is to transform our dynamic templates into views using
    a set of instructions that are usually directives. There are several types of
    directives, but the most basic and surprising one is the component. The `@Component`
    decorator actually extends the `@Directive` decorator by adding a template to
    it. Remember the selector property in previous examples? If you use this selector
    as a tag inside another component, it will render our component inside. But this
    is just one type of a directive; the other would be our `ngModel` directive in
    the previous example. All in all, we have three types of directives.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的基本操作是使用一组通常是指令的指令将我们的动态模板转换为视图。有几种类型的指令，但最基本和令人惊讶的是组件。`@Component`
    装饰器实际上通过向其添加模板来扩展了 `@Directive` 装饰器。还记得之前例子中的选择器属性吗？如果你在另一个组件内使用这个选择器作为标签，它将呈现我们的组件内部。但这只是一种指令的类型；另一种是我们在之前例子中使用的
    `ngModel` 指令。总而言之，我们有三种类型的指令。
- en: Attribute directives
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性指令
- en: 'Attribute directives change the behavior or appearance of a DOM element. We
    use these directives as HTML attributes on the given DOM element that we want
    to change. Angular 2 comes with several prebuilt attribute directives, such as
    the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令改变DOM元素的行为或外观。我们将这些指令作为HTML属性应用于要更改的DOM元素上。Angular 2 包含了几个预定义的属性指令，例如以下内容：
- en: '`ngClass`: Provides a way to bind singular or multiple classes to an element'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngClass`：为元素绑定单个或多个类的方法'
- en: '`ngStyle`: Provides a way to bind singular or multiple inline styles to an
    element'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngStyle`：为元素绑定单个或多个内联样式的方法'
- en: '`ngModel`: Creates a two-way data binding over form elements'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`：为表单元素创建双向数据绑定'
- en: These are just a few examples, but you should keep in mind that you can and
    should write your own custom directives.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一些例子，但您应该记住，您可以并且应该编写自己的自定义指令。
- en: Structural directives
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构指令
- en: 'Structural directives change our application''s DOM layout by removing and
    adding DOM elements. Angular 2 contains three major structural directives you
    should know about:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令通过移除和添加DOM元素来改变我们应用程序的DOM布局。Angular 2包含了三个您应该了解的主要结构指令：
- en: '`ngIf`: Provides a way to add or remove elements according to the condition'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngIf`：提供一种根据条件添加或移除元素的方法'
- en: '`ngFor`: Provides a way to create copies of an element based on a list of objects'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`：提供一种根据对象列表创建元素副本的方法'
- en: '`ngSwitch`: Provides a way to display a single element out of a list of elements
    based on a property value'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitch`：提供一种根据属性值从元素列表中显示单个元素的方法'
- en: All structural directives use a mechanism called the HTML5 template, which allows
    our DOM to hold an HTML template without rendering using the template tag. This
    has a consequence that we'll discuss when we use these directives.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有结构指令都使用一种称为HTML5模板的机制，它允许我们的DOM保留一个HTML模板，而不使用模板标签进行渲染。当我们使用这些指令时，这会产生一个我们将讨论的后果。
- en: Component directives
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件指令
- en: 'As described previously, every component is basically a directive. For instance,
    let''s say we have component called `SampleComponent`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所述，每个组件基本上都是一个指令。例如，假设我们有一个名为`SampleComponent`的组件：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can use it as a directive in our `AppComponent` class, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`AppComponent`类中将其作为指令使用，如下所示：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice how we use the sample-component tag and include our `SampleComponent`
    module in the `AppComponent` list of directives.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何在`AppComponent`类中使用`sample-component`标签并包含我们的`SampleComponent`模块在指令列表中。
- en: To conclude, directives used to be a frightening concept for many Angular 1
    developers, but now they're simple, easy to understand, and fun to use. Later
    in this book, you'll learn how to use the majority of the concepts presented in
    this section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，对于许多Angular 1开发人员来说，指令曾经是一个令人恐惧的概念，但现在它们变得简单、易于理解和有趣。在本书的后面，您将学习如何使用本节中介绍的大部分概念。
- en: Angular 2 Services
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 服务
- en: Services are an essential part of Angular 2\. They are basically just classes
    that a single purpose or feature needs in the application. Since we want to keep
    our components clean and focused on the user experience, services come with pretty
    much everything else. For instance, any data management, logging, application
    configuration, or otherwise a functionality that does not belong in a component
    will be implemented as a service. It is also worth noting that there is absolutely
    nothing special about Angular 2 services; they are just plain classes with a defined
    functionality. What is special about them is that we can make these services available
    for components using a mechanism called Dependency Injection.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是Angular 2的一个重要部分。它们基本上只是应用程序中单一目的或功能所需的类。由于我们希望保持组件的清晰并专注于用户体验，服务几乎包含了其他所有内容。例如，任何数据管理、日志记录、应用程序配置或其他不属于组件的功能都将作为服务实现。值得注意的是，Angular
    2服务并没有什么特别之处；它们只是具有定义功能的普通类。它们之所以特别，是因为我们可以使用一种称为依赖注入的机制将这些服务提供给组件。
- en: Angular 2 Dependency Injection
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2 依赖注入
- en: 'A Dependency Injection is a software design pattern popularized by a software
    engineer named Martin Fowler. The main principle behind Dependency Injection is
    the inversion of control in a software development architecture. To understand
    this better, let''s take a look at the following `notifier` example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种软件设计模式，由软件工程师马丁·福勒（Martin Fowler）推广。依赖注入背后的主要原则是软件开发架构中的控制反转。为了更好地理解这一点，让我们来看一下以下的“notifier”示例：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our `Notifier` class creates an instance of `userService`, and when the `notify()`
    method is called, it alerts a different message based on the user role. Now this
    can work pretty well, but what happens when you want to test your `Notifier` class?
    You will create a `Notifier` instance in your test, but you won''t be able to
    pass a mock `userService` object to test the different results of the `notify`
    method. Dependency injection solves this by moving the responsibility of creating
    the `userService` object to the creator of the `Notifier` instance, whether it
    is another object or a test. This creator is often referred to as the injector.
    A revised, injection-dependent version of this example will be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Notifier`类创建了一个`userService`的实例，当调用`notify()`方法时，它会根据用户角色发出不同的消息。现在这样做可能效果很好，但当您想要测试您的`Notifier`类时会发生什么呢？您将在测试中创建一个`Notifier`实例，但您将无法传递一个模拟的`userService`对象来测试`notify`方法的不同结果。依赖注入通过将创建`userService`对象的责任移交给`Notifier`实例的创建者来解决了这个问题，无论是另一个对象还是一个测试。这个创建者通常被称为注入器。这个示例的一个经过修订的、依赖注入的版本将如下所示：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now whenever you create an instance of the `Notifier` class, the injector will
    be responsible for injecting a `userService` object into the constructor, making
    it possible to control the behavior of the `Notifier` instance outside of its
    constructor, a design often described as the inversion of control.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当您创建`Notifier`类的实例时，注入器将负责将`userService`对象注入到构造函数中，从而使得在构造函数之外控制`Notifier`实例的行为成为可能，这种设计通常被描述为控制反转。
- en: Using Dependency Injection in Angular 2
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Angular 2中使用依赖注入
- en: 'In Angular 2, Dependency Injection is used to inject services into components.
    Services are injected in the constructor function of the components, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 2中，依赖注入用于将服务注入到组件中。服务是在构造函数中注入到组件中的，如下所示：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When Angular 2 creates an instance of a component class, it will first request
    an injector that will resolve the needed services to call the constructor function.
    If an Injector contains a previous instance of the service, it will provide it;
    otherwise, the Injector will create a new instance. To do that, you'll need to
    provide the component injector with the service provider. This is why we add the
    `providers` property to the `@Component` decorator. Furthermore, we can register
    providers at any level of our component tree, and a common pattern is to register
    providers at the root level when the application is being bootstrapped, so the
    same instance of the service will be available throughout the application component
    tree.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular 2创建组件类的实例时，它将首先请求一个注入器来解析所需的服务以调用构造函数。如果注入器包含服务的先前实例，它将提供它；否则，注入器将创建一个新实例。为此，您需要为组件注入器提供服务提供程序。这就是为什么我们在`@Component`装饰器中添加`providers`属性。此外，我们可以在组件树的任何级别注册提供程序，一个常见的模式是在应用程序启动时在根级别注册提供程序，这样服务的相同实例将在整个应用程序组件树中可用。
- en: Angular 2 Routing
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2路由
- en: Our last topic before we set out to implement our application would be navigation
    and routing. Using web applications, users expect a certain type of URL routing.
    For this purpose, the Angular team created a module called the component router.
    The component router interprets the browser URL and then looks up in its definition
    to find and load a component view. Supporting the modern browser's history API,
    the router will respond to any URL change whether it's coming from the browser
    URL bar or a user interaction. So let's see how it works.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们着手实现应用程序之前，我们最后一个主题将是导航和路由。使用Web应用程序，用户期望一定类型的URL路由。为此，Angular团队创建了一个名为组件路由器的模块。组件路由器解释浏览器URL，然后在其定义中查找并加载组件视图。支持现代浏览器的历史API，路由器将响应来自浏览器URL栏或用户交互的任何URL更改。让我们看看它是如何工作的。
- en: Setup
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: Since the Angular 2 team is focused on the modular approach, you'll need to
    load the router file separately—either from a local file or using a CDN. Furthermore,
    you'll also have to set up the `<base href="/">` tag inside the head section of
    your main HTML file. But don't worry about it for now. We'll take care of these
    changes in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular 2团队专注于模块化方法，您需要单独加载路由文件 - 无论是从本地文件还是使用CDN。此外，您还需要在主HTML文件的头部设置`<base
    href="/">`标签。但现在不用担心这些。我们将在下一节中处理这些更改。
- en: Routes
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由
- en: 'Every application will have one router, so when a URL navigation occurs, the
    router will look for the routing configuration made inside the application in
    order to determine which component to load. In order to configure the application
    routing, Angular provides a special array class called `Routes`, which includes
    a list mapping between URLs and components. An example for this mechanism is as
    follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序将有一个路由器，因此当发生URL导航时，路由器将查找应用程序内部的路由配置，以确定要加载哪个组件。为了配置应用程序路由，Angular提供了一个特殊的数组类，称为`Routes`，其中包括URL和组件之间的映射列表。这种机制的示例如下：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Router outlet
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由出口
- en: 'The component router uses a hierarchical component structure which means that
    every component decorated and loaded by the component router can have child paths
    configured. So, the root component is loaded, and it renders its view in the main
    application tag; however, when child components are loaded, how and where are
    they going to be rendered? To solve this, the router module includes a directive
    called `RouterOutlet`. To render your child components, all you have to do is
    include the `RouterOutlet` directive inside your parent component''s template.
    An example component is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 组件路由器使用分层组件结构，这意味着每个由组件路由器装饰和加载的组件都可以配置子路径。因此，加载根组件并在主应用程序标签中呈现其视图；然而，当加载子组件时，它们将如何以及在哪里呈现？为了解决这个问题，路由器模块包括一个名为`RouterOutlet`的指令。要呈现您的子组件，您只需在父组件的模板中包含`RouterOutlet`指令。一个示例组件如下：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the `router-outlet` tag will be replaced with your child component's
    view.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`router-outlet`标签将被替换为您的子组件的视图。
- en: Router links
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由链接
- en: 'After we configure our application routes, we''ll be able to navigate through
    our application either by changing the browser URL or using the `RouterLink` directive
    to generate anchor tags pointing to a link inside our app. The `RouterLink` directive
    uses an array of link parameters, which the router will later resolve into a URL
    matching a component mapping. An example anchor with the `RouterLink` directive
    will look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们配置应用程序路由之后，我们将能够通过更改浏览器URL或使用`RouterLink`指令来生成指向应用程序内部链接的锚标签来浏览我们的应用程序。`RouterLink`指令使用链接参数数组，路由器将稍后解析为与组件映射匹配的URL。带有`RouterLink`指令的示例锚标签如下：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: As we've progressed in this chapter, we've learned about TypeScript and Angular
    2\. We've now covered everything we need in order create an Angular application
    inside our MEAN application. So let's start by setting up our project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本章的进展，我们已经了解了TypeScript和Angular 2。我们现在已经涵盖了我们在MEAN应用程序中创建Angular应用程序所需的一切。所以让我们开始设置我们的项目。
- en: The project setup
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: In order to use Angular in our project, we'll need to install both TypeScript
    and Angular. We'll need to use the TypeScript transpiler to convert our TypeScript
    files into valid ES5 or ES6 JavaScript files. Furthermore, since Angular is a
    frontend framework, installing it requires the inclusion of JavaScript files in
    the main page of your application. This can be done in various ways, and the easiest
    one would be to download the files you need and store them in the `public` folder.
    Another approach is to use Angular's CDN and load the files directly from the
    CDN server. While these two approaches are simple and easy to understand, they
    both have a strong flaw. Loading a single third-party JavaScript file is readable
    and direct, but what happens when you start adding more vendor libraries to your
    project? More importantly, how can you manage your dependencies' versions?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的项目中使用Angular，我们需要安装TypeScript和Angular。我们需要使用TypeScript转译器将我们的TypeScript文件转换为有效的ES5或ES6
    JavaScript文件。此外，由于Angular是一个前端框架，安装它需要在应用程序的主页面中包含JavaScript文件。这可以通过各种方式完成，最简单的方式是下载你需要的文件并将它们存储在`public`文件夹中。另一种方法是使用Angular的CDN并直接从CDN服务器加载文件。虽然这两种方法都简单易懂，但它们都有一个严重的缺陷。加载单个第三方JavaScript文件是可读和直接的，但当你开始向项目中添加更多的供应商库时会发生什么？更重要的是，你如何管理你的依赖版本？
- en: 'The answer to all of these questions is NPM! NPM will allow us to install all
    of our dependencies and run the TypeScript transpiler while we develop our application.
    In order to do that, you''ll need to change your `package.json` file, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题的答案都是NPM！NPM将允许我们在开发应用程序时安装所有依赖项并运行TypeScript转译器。为了做到这一点，你需要修改你的`package.json`文件，如下所示：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In our new `package.json` file, we did a few things; first, we added our project''s
    Angular dependencies, including a few supportive libraries:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新`package.json`文件中，我们做了一些事情；首先，我们添加了我们项目的Angular依赖，包括一些支持库：
- en: '**CoreJS**: This will provide us with some ES6 polyfills'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CoreJS**：这将为我们提供一些ES6 polyfills'
- en: '**ReflectMetadata**: This will provide us with some a metadata reflection polyfill'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReflectMetadata**：这将为我们提供一些元数据反射polyfill'
- en: '**Rx.JS**: This is a Reactive framework that we''ll use later'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rx.JS**：这是一个我们以后会使用的响应式框架'
- en: '**SystemJS**: This will help with loading our application modules'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SystemJS**：这将帮助加载我们的应用程序模块'
- en: '**Zone.js**: This allows the creation of different execution context zones
    and is used by the Angular library'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zone.js**：这允许创建不同的执行上下文区域，并被Angular库使用'
- en: '**Concurrently**: This will allow us to run both the TypeScript transplier
    and our server concurrently'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Concurrently**：这将允许我们同时运行TypeScript转译器和我们的服务器'
- en: '**Typings**: This will help us with downloading predefined TypeScript definitions
    for our external libraries'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Typings**：这将帮助我们下载预定义的外部库的TypeScript定义'
- en: At the top, we added a scripts property, where we defined different scripts
    we would like npm to run for us. For instance, we have a script that installs
    our typings for third-party libraries, another one that runs the TypeScript compiler
    called `tsc`, a script called `app` that we use to run our node server, and one
    called `start` to run both of these scripts together using the concurrency tool.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们添加了一个scripts属性，其中我们定义了希望npm为我们运行的不同脚本。例如，我们有一个脚本用于安装第三方库的类型定义，另一个用于运行名为`tsc`的TypeScript编译器的脚本，一个名为`app`的脚本用于运行我们的节点服务器，以及一个名为`start`的脚本，使用并发工具同时运行这两个脚本。
- en: Next, we're going to configure the way we want the TypeScript compiler to run.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置TypeScript编译器的运行方式。
- en: Configuring TypeScript
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置TypeScript
- en: 'In order to configure the way TypeScript works, we''ll need to add a new file
    called `tsconfig.json` to our application''s root folder. In your new file, paste
    the following JSON:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置TypeScript的工作方式，我们需要在应用程序的根目录下添加一个名为`tsconfig.json`的新文件。在你的新文件中，粘贴以下JSON：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our `tsconfig.json` file, we configured the TypeScript compiler to:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`tsconfig.json`文件中，我们配置了TypeScript编译器：
- en: Compile our TypeScript code into ES5 code
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的TypeScript代码编译成ES5代码
- en: Compile our modules into a system module pattern
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的模块编译成系统模块模式
- en: Use Node for module resolution
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node进行模块解析
- en: Generate source maps
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成源映射
- en: Include decorators and emit their metadata
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括装饰器并发出它们的元数据
- en: Keep comments
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留注释
- en: Cancel the error for any implicit declarations
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消任何隐式声明的错误
- en: Not include the `node_modules` folder and typings files
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不包括`node_modules`文件夹和类型文件
- en: 'When we run our application, the TypeScript will use the `tsconfig.json` configuration
    file by default. Next, you''ll need to add a new file called `typings.json` to
    your application''s root folder. In your new file, paste the following JSON:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的应用程序时，TypeScript将默认使用`tsconfig.json`配置文件。接下来，你需要在应用程序的根目录下添加一个名为`typings.json`的新文件。在你的新文件中，粘贴以下JSON：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, we''ve added all third-party libraries we need in order for
    the TypeScript transpiler to compile our code properly. Once you''re done, go
    ahead and install your new dependencies:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经添加了所有我们需要的第三方库，以便让TypeScript转译器正确编译我们的代码。完成后，继续安装你的新依赖：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All the packages we need will be installed along with external type definitions
    we'll need in order to support the TypeScript compiling. Now that we have installed
    our new packages and configured our TypeScript implementation, it is time to set
    up Angular.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的所有包都将与我们需要的外部类型定义一起安装，以支持TypeScript编译。现在我们已经安装了新的包并配置了我们的TypeScript实现，是时候设置Angular了。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that you continue reading about Typings at the official documentation
    at [https://github.com/typings/typings](https://github.com/typings/typings).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你继续阅读Typings的官方文档[https://github.com/typings/typings](https://github.com/typings/typings)。
- en: Configuring Express
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Express
- en: 'To start using Angular, you will need to include the new JavaScript library
    files in our main EJS view. So, we will use the `app/views/index.ejs` file as
    the main application page. However, NPM installed all of our dependencies in the
    `node_module` folder, which is not accessible to our client side. To solve this
    issue, we''ll have to change our `config/express.js` file as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Angular，你需要在我们的主EJS视图中包含新的JavaScript库文件。因此，我们将使用`app/views/index.ejs`文件作为主应用程序页面。然而，NPM将所有依赖项安装在`node_module`文件夹中，这对我们的客户端不可访问。为了解决这个问题，我们将不得不修改我们的`config/express.js`文件如下：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A major change here involves the creation of a `/lib` static route that directs
    to our `node_modules` folder. While we were here, we also switched the order of
    the routes users and index routes. This will come in handy when we start dealing
    with Angular''s routing mechanism. In this regard, there is one more thing we
    have to do, and that is making sure our Express application always return the
    main application view when receiving routes that are not defined. This is for
    the case where the browser''s initial request is made using a URL that was generated
    by the Angular Router and is not supported by our Express configuration. To do
    this, go back to the `app/routes/index.server.routes.js` file, and change it as
    follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重大变化涉及创建一个指向我们`node_modules`文件夹的`/lib`静态路由。当我们在这里时，我们还切换了用户和索引路由的顺序。当我们开始处理Angular的路由机制时，这将非常方便。在这方面，我们还需要做一件事，那就是确保我们的Express应用程序在接收到未定义路由时始终返回主应用程序视图。这是为了处理浏览器初始请求使用的URL是由Angular路由器生成的，而不受我们的Express配置支持的情况。为此，返回到`app/routes/index.server.routes.js`文件，并进行如下更改：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, that we have configured TypeScript and Express, it is time to set up Angular,
    but before we do that, let's talk a bit about our application structure.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经配置了TypeScript和Express，是时候设置Angular了，但在我们这样做之前，让我们稍微谈谈我们的应用程序结构。
- en: Restructuring the application
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新构建应用程序
- en: As you might remember from [Chapter 3](ch03.html "Chapter 3. Building an Express
    Web Application"), *Building an Express Web Application*, your application's structure
    depends on the complexity of your application. We previously decided to use the
    horizontal approach for the entire MEAN application; however, as we stated earlier,
    MEAN applications can be constructed in various ways, and an Angular application
    structure is a different topic, which is often discussed by the community and
    the Angular development team. There are many doctrines for different purposes,
    some of which are a bit more complicated, while others offer a simpler approach.
    In this section, we'll introduce a recommended structure. With the move from Angular
    1 to Angular 2, this discussion is now even more complicated. For us, the easiest
    approach would be to start by using the `public` folder of our Express application
    as the root folder for the Angular application so that every file is available
    statically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的来自[第3章](ch03.html "第3章。构建Express Web应用程序")，*构建Express Web应用程序*，你的应用程序结构取决于你的应用程序的复杂性。我们之前决定对整个MEAN应用程序使用水平方法；然而，正如我们之前所述，MEAN应用程序可以以各种方式构建，而Angular应用程序结构是一个不同的话题，经常由社区和Angular开发团队讨论。有许多用于不同目的的原则，其中一些有点复杂，而其他一些则提供了更简单的方法。在本节中，我们将介绍一个推荐的结构。随着从Angular
    1到Angular 2的转变，这个讨论现在变得更加复杂。对我们来说，最简单的方法是从我们Express应用程序的`public`文件夹开始，作为Angular应用程序的根文件夹，以便每个文件都可以静态地使用。
- en: 'There are several options to structure your application according to its complexity.
    A simple application can have a horizontal structure where entities are arranged
    in folders according to their type, and a main application file is placed at the
    root folder of the application. An example application structure of this kind
    can be seen in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其复杂性，有几种选项可以结构化应用程序。简单的应用程序可以具有水平结构，其中实体根据其类型排列在文件夹中，并且主应用程序文件放置在应用程序的根文件夹中。这种类型的示例应用程序结构可以在以下截图中看到：
- en: '![Restructuring the application](img/B05071_07_02.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![重新构建应用程序](img/B05071_07_02.jpg)'
- en: 'As you can see, this is a very comfortable solution for small applications
    with a few entities. However, your application might be more complex with several
    different features and many more entities. This structure cannot handle an application
    of this sort since it obfuscates the behavior of each application file, will have
    a bloated folder with too many files, and will generally be very difficult to
    maintain. For this purpose, there is a different approach to organizing your files
    in a vertical manner. A vertical structure positions every file according to its
    functional context, so different types of entities can be sorted together according
    to their role in a feature or a section. This is similar to the vertical approach
    we introduced in [Chapter 3](ch03.html "Chapter 3. Building an Express Web Application"),
    *Building an Express Web Application*. However, the difference is that only Angular''s
    logical units will have a standalone module folder structure, usually with a component
    and a template files. An example of an Angular application vertical structure
    can be seen in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一个非常舒适的解决方案，适用于具有少量实体的小型应用程序。然而，你的应用程序可能更复杂，具有多种不同的功能和更多的实体。这种结构无法处理这种类型的应用程序，因为它会混淆每个应用程序文件的行为，将会有一个文件过多的臃肿文件夹，并且通常会非常难以维护。为此，有一种不同的方法来以垂直方式组织文件。垂直结构根据其功能上下文定位每个文件，因此不同类型的实体可以根据其在功能或部分中的角色进行排序。这类似于我们在[第3章](ch03.html
    "第3章。构建Express Web应用程序")中介绍的垂直方法，*构建Express Web应用程序*。然而，不同之处在于只有Angular的逻辑单元将具有独立的模块文件夹结构，通常包括组件和模板文件。Angular应用程序垂直结构的示例可以在以下截图中看到：
- en: '![Restructuring the application](img/B05071_07_03.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![重新构建应用程序](img/B05071_07_03.jpg)'
- en: As you can see, each module has its own folder structure, which allows you to
    encapsulate each component. We're also using the file naming convention that we
    introduced in [Chapter 3](ch03.html "Chapter 3. Building an Express Web Application"),
    *Building an Express Web Application*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个模块都有自己的文件夹结构，这使你可以封装每个组件。我们还使用了我们在[第3章](ch03.html "第3章。构建Express Web应用程序")中介绍的文件命名约定，*构建Express
    Web应用程序*。
- en: Now that you know the basic best practices of naming and structuring your application,
    let's continue and create the application module.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了命名和结构化应用程序的基本最佳实践，让我们继续创建应用程序模块。
- en: Creating the application module
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序模块
- en: 'To begin, clear the contents of the `public` folder and create the folder named
    `app` inside it. Inside your new folder, create a file named `app.module.ts`.
    In your file, add the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，清空`public`文件夹的内容，并在其中创建一个名为`app`的文件夹。在你的新文件夹中，创建一个名为`app.module.ts`的文件。在你的文件中，添加以下代码：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we basically just created a simple module that declares the
    application component and uses it for bootstrapping. Next we'll need to create
    the application component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们基本上只是创建了一个声明应用程序组件并将其用于引导的简单模块。接下来我们需要创建应用程序组件。
- en: Creating the application component
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序组件
- en: 'Inside your `public/app` folder, create a new file named `app.component.ts`.
    In your file, add the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`public/app`文件夹中，创建一个名为`app.component.ts`的新文件。在你的文件中，添加以下代码：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we basically just created the simplest component. Next we'll
    learn how to bootstrap our `AppModule` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们基本上只是创建了最简单的组件。接下来我们将学习如何引导我们的`AppModule`类。
- en: Bootstrapping the application module
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导应用程序模块
- en: 'To bootstrap your application module, go to your `app` folder and create a
    new file named `bootstrap.ts`. In your file, add the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要引导你的应用程序模块，转到你的`app`文件夹并创建一个名为`bootstrap.ts`的新文件。在你的文件中，添加以下代码：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Basically, this code is using the browser platform module to bootstrap the application
    module for browsers. Once we have these configured, it's time to learn how to
    load our bootstrap code using the SystemJS module loader.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这段代码使用浏览器平台模块来为浏览器引导应用程序模块。一旦我们配置好这些，就是时候学习如何使用SystemJS模块加载器加载我们的引导代码了。
- en: Starting your Angular application
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动你的Angular应用程序
- en: 'To use SystemJS as our module loader, we''ll create a new file named `systemjs.config.js`
    inside our `public` folder. In your new file, paste the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SystemJS作为我们的模块加载器，我们将在`public`文件夹中创建一个名为`systemjs.config.js`的新文件。在你的新文件中，粘贴以下代码：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this file, we''re telling SystemJS about our application package and from
    where to load the Angular and Rx modules. We then describe the main file for each
    package of Angular; in this case, we ask it to load the UMD file of each package.
    We then use the `System.config` method to configure SystemJS. Finally, we revisit
    our `app/views/index.ejs` file and change it, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们告诉SystemJS关于我们的应用程序包以及从哪里加载Angular和Rx模块。然后我们描述了每个Angular包的主文件；在这种情况下，我们要求它加载每个包的UMD文件。然后我们使用`System.config`方法来配置SystemJS。最后，我们重新访问我们的`app/views/index.ejs`文件并进行更改，如下所示：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we're loading our module files directly from the `node_modules`
    package folder and include our SystemJS configuration file. The last script tells
    SystemJS to load the application package we defined in the configuration file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们直接从`node_modules`包文件夹中加载我们的模块文件，并包括我们的SystemJS配置文件。最后一个脚本告诉SystemJS加载我们在配置文件中定义的应用程序包。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about SystemJS, it is recommended that you visit the official
    documentation at [https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于SystemJS的信息，建议你访问官方文档[https://github.com/systemjs/systemjs](https://github.com/systemjs/systemjs)。
- en: 'Now all you have left to do is run your application by invoking the following
    command in your command line:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你所要做的就是在命令行中调用以下命令来运行你的应用程序：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When your application is running, use your browser and open your application
    URL at `http://localhost:3000`. You should see a header tag saying `Hello World`
    being rendered. Congratulations! You've created your first Angular 2 module and
    component and successfully bootstrapped your application. Next, we'll refactor
    the authentication part of our application and create a new authentication module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序正在运行时，使用浏览器打开你的应用程序URL，地址为`http://localhost:3000`。你应该看到一个标题标签显示`Hello
    World`。恭喜！你已经创建了你的第一个Angular 2模块和组件，并成功地引导了你的应用程序。接下来，我们将重构应用程序的身份验证部分并创建一个新的身份验证模块。
- en: Managing authentication
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理身份验证
- en: Managing an Angular application authentication is a complex issue. The problem
    is that while the server holds the information about the authenticated user, the
    Angular application is not aware of that information. One solution is to use a
    service and ask the server about the authentication status; however, this solution
    is flawed since all the Angular components will have to wait for the response
    to return, causing inconsistencies and development overhead. This can be solved
    using an advanced Angular router object; however, a simpler solution would be
    to make the Express application render the `user` object directly in the EJS view
    and then use an Angular service to serve the object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Angular应用程序的身份验证是一个复杂的问题。问题在于，虽然服务器保存了关于经过身份验证的用户的信息，但Angular应用程序并不知道这些信息。一个解决方案是使用一个服务并向服务器询问身份验证状态；然而，这个解决方案存在缺陷，因为所有的Angular组件都必须等待响应返回，导致不一致和开发开销。这可以通过使用高级的Angular路由对象来解决；然而，一个更简单的解决方案是让Express应用程序直接在EJS视图中渲染`user`对象，然后使用Angular服务来提供该对象。
- en: Rendering the user object
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染用户对象
- en: 'To render the authenticated `user` object, you''ll have to make several changes.
    Let''s begin by changing the `app/controllers/index.server.controller.js` file,
    as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染经过身份验证的`user`对象，你需要进行一些更改。让我们从更改`app/controllers/index.server.controller.js`文件开始，如下所示：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, go to your `app/views/index.ejs` file and make the following changes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到你的`app/views/index.ejs`文件并进行以下更改：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will render the user object as a JSON representation right in your main
    view application. When the Angular application bootstraps, the authentication
    state will already be available. If the user is authenticated, the `user` object
    will become available; otherwise, the `user` object will be Null.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的主视图应用程序中以JSON表示形式呈现用户对象。当Angular应用程序启动时，身份验证状态将已经可用。如果用户已经通过身份验证，`user`对象将变为可用；否则，`user`对象将为Null。
- en: Modifying the users' server controller
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改用户服务器控制器
- en: 'To support our authentication refactoring, we''ll need to make sure our user''s
    server controller is able to process the Angular service requests. To do that,
    you''ll need to change the code in your `app/controllers/users.server.controller.js`
    file to look like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持我们的身份验证重构，我们需要确保我们的用户服务器控制器能够处理Angular服务请求。为此，您需要更改您的`app/controllers/users.server.controller.js`文件中的代码如下：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We basically just encapsulated the authentication logic inside two methods
    that can accept and respond with a JSON object. Now let''s go ahead and change
    the `app/routes/users.server.routes.js` directory as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上只是将身份验证逻辑封装在两个可以接受和响应JSON对象的方法中。现在让我们继续并按照以下方式更改`app/routes/users.server.routes.js`目录：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how we removed the routes that we used to render our authentication views.
    More importantly, look at the way in which we added an `/api` prefix for all the
    routes. It is a very good practice to keep all your routes under one prefix, since
    we want the Angular router to be able to have routes that do not interfere with
    our server routes. Now that we have our server side ready, it's time to create
    our Angular authentication module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们删除了用于渲染身份验证视图的路由。更重要的是，看看我们为所有路由添加了`/api`前缀的方式。将所有路由放在一个前缀下是一个很好的做法，因为我们希望Angular路由器能够拥有不干扰我们服务器路由的路由。现在我们的服务器端准备好了，是时候创建我们的Angular身份验证模块了。
- en: Creating the authentication module
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建身份验证模块
- en: 'Now that we''re done with laying the ground for our Angular application, we
    can move forward and refactor our authentication logic into a cohesive authentication
    module. To do that, we''ll begin by creating a new folder inside our `public/app`
    folder, called `authentication`. In our new folder, create a file named `authentication.module.ts`
    with the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的Angular应用程序奠定了基础，我们可以继续并将我们的身份验证逻辑重构为一个统一的身份验证模块。为此，我们将首先在我们的`public/app`文件夹内创建一个名为`authentication`的新文件夹。在我们的新文件夹中，创建一个名为`authentication.module.ts`的文件，并添加以下代码：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our module consists of three components:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模块由三个组件组成：
- en: An authentication component
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个身份验证组件
- en: A signup component
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个注册组件
- en: A signin component
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个登录组件
- en: We also included an authentication routing configuration and the Angular's Forms
    module to support our signin and signup forms. Let's begin by implementing the
    base authentication component.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括了一个身份验证路由配置和Angular的Forms模块来支持我们的登录和注册表单。让我们开始实现基本的身份验证组件。
- en: Creating the authentication component
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建身份验证组件
- en: 'We''ll begin by creating our authentication component hierarchy. Then, we will
    convert our server signin and signup views into Angular templates, add the authentication
    functionality to `AuthenticationService`, and refactor our server logic. Let''s
    start by creating a file named `authentication.component.ts` inside our `public/app/authentication`
    folder. In the new file, paste the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建我们的身份验证组件层次结构。然后，我们将把我们的服务器登录和注册视图转换为Angular模板，将身份验证功能添加到`AuthenticationService`中，并重构我们的服务器逻辑。让我们首先在我们的`public/app/authentication`文件夹内创建一个名为`authentication.component.ts`的文件。在新文件中，粘贴以下代码：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this code, we implement our new authentication component. We begin by importing
    the authentication service and a signup and signin component, all of which we
    haven't created yet. Another thing to notice is that this time, we used an external
    template file for our component. We'll continue by creating a routing configuration
    for our authentication module.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们实现了我们的新身份验证组件。我们首先导入了身份验证服务和注册和登录组件，这些组件我们还没有创建。另一个需要注意的是，这次我们为我们的组件使用了外部模板文件。接下来，我们将为我们的身份验证模块创建路由配置。
- en: Configuring the authentication routes
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置身份验证路由
- en: 'To do that, create a new file named `authentication.routes.ts` inside our `public/app/authentication`
    folder. In the new file, paste the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在我们的`public/app/authentication`文件夹内创建一个名为`authentication.routes.ts`的新文件。在新文件中，粘贴以下代码：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you can see, we create a new `Routes` instance with a parent route of `authentication`
    and two child routes for the `signin` and `signup` components. We''ll continue
    by creating the template file named `authentication.template.html` inside our
    component''s folder. In the new file, paste the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个具有`authentication`父路由和`signin`和`signup`组件两个子路由的新`Routes`实例。接下来，我们将在我们的组件文件夹内创建名为`authentication.template.html`的模板文件。在新文件中，粘贴以下代码：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note how we used the `RouterOutlet` directive inside our code. This is where
    our subcomponents will be rendered. We'll continue with creating these subcomponents.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在代码中使用了`RouterOutlet`指令。这是我们的子组件将被渲染的地方。我们将继续创建这些子组件。
- en: Creating the signin component
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建登录组件
- en: 'To implement the `signin` component, create a new folder named `signin` inside
    your `public/app/authentication` folder. Inside your new folder, create a new
    file named `signin.component.ts` with the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`signin`组件，请在您的`public/app/authentication`文件夹内创建一个名为`signin`的新文件夹。在您的新文件夹中，创建一个名为`signin.component.ts`的新文件，并添加以下代码：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note how our `signin` component uses the authentication service in order to
    perform a `signin` action. Don''t worry; we''ll implement this in the next section.
    Next, you''ll need to create a file named `signin.template.html` in the same folder
    as your component. In your new file, add the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的`signin`组件如何使用身份验证服务来执行`signin`操作。不用担心，我们将在下一节中实现这一点。接下来，您需要在与您的组件相同的文件夹中创建一个名为`signin.template.html`的文件。在您的新文件中，添加以下代码：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We've just created a new component to handle our authentication signin operation!
    The signup component will look quite similar.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个新的组件来处理我们的身份验证登录操作！注册组件看起来会非常相似。
- en: Creating the signup component
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建注册组件
- en: 'To implement the signup component, create a new folder named `signup` inside
    your `public/app/authentication` folder. Inside your new folder, create a new
    file named `signup.component.ts` with the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现注册组件，请在您的`public/app/authentication`文件夹内创建一个名为`signup`的新文件夹。在您的新文件夹内，创建一个名为`signup.component.ts`的新文件，并包含以下代码：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note how our signup component uses the authentication service in order to perform
    a `signup` action. Next, you''ll need to create a file named `signup.template.html`
    in the same folder as your component. In your new file, add the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们的注册组件如何使用身份验证服务来执行`注册`操作。接下来，您需要在与您的组件相同的文件夹中创建一个名为`signup.template.html`的文件。在您的新文件中，添加以下代码：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that we have our authentication components in place, let's go back and handle
    the authentication service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的身份验证组件，让我们回过头来处理身份验证服务。
- en: Creating the authentication service
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建身份验证服务
- en: 'In order to support our new components, we would need to create an authentication
    service to provide them with the needed functionality. To do that, create a new
    file named `authentication.service.ts` inside your `public/app/authentication`
    folder. In your new file, paste the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持我们的新组件，我们需要创建一个身份验证服务，以为它们提供所需的功能。为此，请在您的`public/app/authentication`文件夹内创建一个名为`authentication.service.ts`的新文件。在您的新文件中，粘贴以下代码：
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note how we decorated the `AuthenticationService` class with an `@Injectable`
    decorator. While that's not needed in this case, it is a good practice to decorate
    your services that way. The reason is that if you'd like to inject a service with
    another service, you'll need to use this decorator, so for the sake of uniformity,
    it is better to stay safe and decorate all your services. Another thing to note
    is the way we get our user object from the window object.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何使用`@Injectable`装饰器装饰了`AuthenticationService`类。虽然在这种情况下不需要，但用这种装饰器装饰您的服务是一个好习惯。原因是，如果您想要用另一个服务来注入一个服务，您将需要使用这个装饰器，所以为了统一起见，最好是保险起见，装饰所有的服务。另一个需要注意的是我们如何从窗口对象中获取我们的用户对象。
- en: 'We also added three methods to our service: one that handles signin, another
    that handles signup, and a last one for error handling. Inside our methods, we
    use the HTTP module provided by Angular to call our server endpoints. In the next
    chapter, we''ll elaborate further on this module, but in the meantime, all you
    need to know is that we just used it to send POST a request to our server. To
    finish up the Angular part, our application will need to modify our application
    module and add a simple home component.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们的服务添加了三种方法：一个处理登录的方法，另一个处理注册的方法，以及一个用于错误处理的方法。在我们的方法内部，我们使用Angular提供的HTTP模块来调用我们的服务器端点。在下一章中，我们将进一步阐述这个模块，但与此同时，您需要知道的是，我们只是用它来向服务器发送POST请求。为了完成Angular部分，我们的应用程序将需要修改我们的应用程序模块，并添加一个简单的主页组件。
- en: Creating the home module
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建主页模块
- en: 'To extend our simple example, we''ll need to have a home component that will
    provide the view for our base root and will present different information for
    the logged-in and logged-out users. To do that, create a folder named `home` inside
    your `public/app` folder. Then, create a file inside this folder called `home.module.ts`,
    which contains the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展我们的简单示例，我们需要一个主页组件，它将为我们的基本根提供视图，并为已登录和未登录的用户呈现不同的信息。为此，请在您的`public/app`文件夹内创建一个名为`home`的文件夹。然后，在此文件夹内创建一个名为`home.module.ts`的文件，其中包含以下代码：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you may have probably noticed, our module is only importing a new home component
    and the routing configuration. Let's continue by creating our home component.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们的模块只导入了一个新的主页组件和路由配置。让我们继续创建我们的主页组件。
- en: Creating the home component
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建主页组件
- en: 'Next, we''ll create our home component. To do that, go to your `public/app/home`
    folder and create a new file called `home.component.ts` containing the following
    code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的主页组件。为此，请转到您的`public/app/home`文件夹，并创建一个名为`home.component.ts`的新文件，其中包含以下代码：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, this is just a simple component, which has the authentication
    service injected and which is used to provide the component with the user object.
    Next, we''ll need to create our home component template. To do that, go to your
    `public/app/home` folder and create a file named `home.template.html` with the
    following code inside it:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这只是一个简单的组件，它注入了身份验证服务，并用于为组件提供用户对象。接下来，我们需要创建我们的主页组件模板。为此，请转到您的`public/app/home`文件夹，并创建一个名为`home.template.html`的文件，其中包含以下代码：
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This template's code nicely demonstrates a few of the topics we previously discussed.
    Note the use of the `ngIf` and `routerLink` directives we talked about earlier
    in this chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板的代码很好地演示了我们之前讨论过的一些主题。请注意我们在本章前面讨论过的`ngIf`和`routerLink`指令的使用。
- en: Configuring the home routes
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置主页路由
- en: 'To finish with our module, we''ll need to create a routing configuration for
    our home component. To do that, create a new file named `home.routes.ts` inside
    your `public/app/home` folder. In your new file, paste the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的模块，我们需要为我们的主页组件创建一个路由配置。为此，请在您的`public/app/home`文件夹内创建一个名为`home.routes.ts`的新文件。在您的新文件中，粘贴以下代码：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, this is just a simple component routing. To complete our implementation,
    we'll need to modify our application module a bit.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这只是一个简单的组件路由。为了完成我们的实现，我们需要稍微修改我们的应用程序模块。
- en: Refactoring the application module
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构应用程序模块
- en: 'To include our authentication and home component modules, we''ll need to change
    our `app.module.ts` file as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了包含我们的身份验证和主页组件模块，我们需要修改我们的`app.module.ts`文件如下：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, this is quite a big change to our application module. First,
    we imported the HTTP module and our new home and authentication modules along
    with our new Application routing configuration. We injected the authentication
    service in the `providers` property so that it is available for all of our submodules.
    The last thing we have to do is implement our application routing configuration.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这对我们的应用程序模块来说是一个相当大的改变。首先，我们导入了HTTP模块和我们的新主页和身份验证模块，以及我们的新应用程序路由配置。我们在`providers`属性中注入了身份验证服务，以便它对我们所有的子模块都可用。我们需要做的最后一件事就是实现我们的应用程序路由配置。
- en: Configuring the application routes
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置应用程序路由
- en: 'To configure our application routes, we''ll need to create a new file named
    `app.routes.ts` inside the `public/app` folder. In the new file, paste the following
    code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 配置我们的应用程序路由，我们需要在`public/app`文件夹内创建一个名为`app.routes.ts`的新文件。在新文件中，粘贴以下代码：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, our application consists of a very simple, single configuration,
    which redirects any unknown routing requests to our home component.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的应用程序由一个非常简单的单一配置组成，它将任何未知的路由请求重定向到我们的主页组件。
- en: 'That is it. Your application is ready for use! All you need to do is to run
    it by invoking the following command in your command line:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。您的应用程序已经准备好使用了！您需要做的就是在命令行中调用以下命令来运行它：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When your application is running, use your browser and open your application
    URL at `http://localhost:3000`. You should see two links for signing up and signing
    in. Use them and see what happens. Try to refresh your application and see how
    it keeps its state and route.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序正在运行时，请使用浏览器打开您的应用程序URL，地址为`http://localhost:3000`。您应该会看到两个链接，用于注册和登录。尝试使用它们，看看会发生什么。尝试刷新您的应用程序，看看它如何保持其状态和路由。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the basic principles of TypeScript. You went
    through Angular's building blocks and learned how they fit in the architecture
    of an Angular 2 application. You also learned how to use NPM to install frontend
    libraries and how to structure and bootstrap your application. You discovered
    Angular's entities and how they work together. You also used Angular's Router
    to configure your application routing scheme. Near the end of this chapter, we
    made use of all of this in order to refactor our authentication module. In the
    next chapter, you'll connect everything you learned so far to create your first
    MEAN CRUD module.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了TypeScript的基本原理。您学习了Angular的构建模块，并了解了它们如何适用于Angular 2应用程序的架构。您还学会了如何使用NPM安装前端库以及如何结构化和引导您的应用程序。您发现了Angular的实体以及它们如何协同工作。您还使用了Angular的路由器来配置您的应用程序路由方案。在本章的末尾，我们利用了所有这些知识来重构我们的身份验证模块。在下一章中，您将把迄今为止学到的所有内容连接起来，创建您的第一个MEAN
    CRUD模块。
