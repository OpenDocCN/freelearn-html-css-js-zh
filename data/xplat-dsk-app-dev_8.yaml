- en: 'Creating RSS Aggregator with Electron, TypeScript, React, and Redux: Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Electron、TypeScript、React和Redux创建RSS聚合器：开发
- en: In the previous chapter, we embraced TypeScript and came up with a static prototype.
    Now, we are about unleash the try power of the language. We are going to write
    application services and cover them with interfaces. We will describe actions
    and Reducers. On the way, we will examine the creation of Promise-based asynchronous
    actions and optimistic updates with the `redux-promise` and `redux-actions` modules.
    We will connect the store to the application and bring the intended functionality
    to the components. We will also create a simple router and bind it to the store.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们拥抱了TypeScript，并提出了一个静态原型。现在，我们将释放语言的强大力量。我们将编写应用程序服务并用接口覆盖它们。我们将描述操作和Reducers。在这个过程中，我们将研究基于Promise的异步操作的创建以及使用`redux-promise`和`redux-actions`模块进行乐观更新。我们将连接存储到应用程序并将预期的功能带到组件中。我们还将创建一个简单的路由器并将其绑定到存储中。
- en: Creating a service to fetch RSS
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个获取RSS的服务
- en: 'In a nutshell, our application is about reading RSS feeds. So, it would be
    the right thing to start with the service, which fetches the feed by a given URL
    and parses it into a structure that we could attach to the applications state.
    I suggest retrieving the feed XML with the `request` ([https://www.npmjs.com/package/request](https://www.npmjs.com/package/request))
    module and parsing it using the `feedme` module ([https://www.npmjs.com/package/feedme](https://www.npmjs.com/package/feedme)).
    Let''s do it first in plain JavaScript. So, we need to install both the packages:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们的应用程序是关于阅读RSS订阅。因此，从获取给定URL的feed并将其解析为我们可以附加到应用程序状态的结构的服务开始是正确的事情。我建议使用`request`（[https://www.npmjs.com/package/request](https://www.npmjs.com/package/request)）模块获取feed
    XML，并使用`feedme`模块（[https://www.npmjs.com/package/feedme](https://www.npmjs.com/package/feedme)）进行解析。让我们首先在纯JavaScript中做这件事。因此，我们需要安装这两个包：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are going to have a function `rss` that uses `request` to fetch feed contents
    though HTTP(s). This function will accept two arguments: feed URL and a callback
    function written in a thunk-like manner of Node.js:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个名为`rss`的函数，它使用`request`通过HTTP(s)获取feed内容。这个函数将接受两个参数：feed URL和一个以Node.js的thunk-like方式编写的回调函数：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we define the feed data container as a plain object (`feed`). We obtain
    a Writable Stream ([https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html))
    from the not yet written `createFeedParserStream` function and pipe it into the
    Readable Stream produced by `request` for the specified feed URL. Now, let''s
    add the missing function:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将feed数据容器定义为一个普通对象（`feed`）。我们从尚未编写的`createFeedParserStream`函数中获取一个可写流（[https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html)），并将其传送到由`request`生成的可读流中，用于指定的feed
    URL。现在，让我们添加缺失的函数：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we get the stream as the `FeedMe` instance and subscribe for its parsing
    events. On receiving the feed title, we assign it to `feed.title`. On receiving
    every item's details, we push them into the `feed.items` array. This function
    returns the derived parse stream and modifies the `feed` object by the reference
    passed in with the arguments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将流作为`FeedMe`实例，并订阅其解析事件。在接收到feed标题时，我们将其分配给`feed.title`。在接收到每个项目的详细信息时，我们将它们推送到`feed.items`数组中。该函数返回派生的解析流，并通过传入的引用修改`feed`对象。
- en: 'Now, we can consume the `rss` function as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按以下方式使用`rss`函数：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Despite the fact that, by default, the Node.js core modules still imply long
    nesting of asynchronous functions, we are quite aware of the undesirable impact
    known as *Callback Hell.* So, we will convert the service into a Promise:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认情况下，Node.js核心模块仍然意味着长时间嵌套的异步函数，但我们非常清楚所谓的*回调地狱*的不良影响。因此，我们将将服务转换为Promise：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, it leads to a notably improved development experience:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它导致了明显改进的开发体验：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Being a Promise, it''s also available via the `async`/`await` syntax:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Promise，它也可以通过`async`/`await`语法使用：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, we can jump back to TypeScript and describe the types that we
    have in the code. Firstly, we expect the declared `feed` structure to implement
    the following interface:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以回到TypeScript并描述代码中的类型。首先，我们期望声明的`feed`结构实现以下接口：
- en: '`./app/ts/Interfaces/Rss.ts`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Interfaces/Rss.ts`'
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But wait! The module `feedme` doesn''t have a declaration file. It looks like
    we have to provide it with an interface too. In the previous chapter, I showed
    a way to introduce a global library into the TypeScript scope by using triple-slash
    directives and ambient declarations. That''s not the only possible solution. We
    can declare the interface in a module:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！模块`feedme`没有声明文件。看起来我们也必须为它提供一个接口。在上一章中，我展示了一种通过使用三斜杠指令和环境声明将全局库引入TypeScript范围的方法。这不是唯一可能的解决方案。我们可以在一个模块中声明接口：
- en: '`./app/ts/Services/IFeedMe.ts`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Services/IFeedMe.ts`'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the service, we import the `IFeedMe` interface and assign the `feedme` export
    to a constant of type `IFeedMe`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中，我们导入`IFeedMe`接口，并将`feedme`导出分配给类型为`IFeedMe`的常量：
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After rewriting our service in TypeScript, its source will look as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的服务重写为TypeScript后，其源代码将如下所示：
- en: '`/app/ts/Services/rss.ts`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`/app/ts/Services/rss.ts`'
- en: '[PRE10]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What is changed? We regarded the export `feedme` module with an interface (`FeedMe:
    IFeedMe`). We defined the contract for the `createFeedParserStream` function.
    It accepts the `IFeed` type as input and returns `NodeJS.WritableStream`. We did
    the same for the service function `rss`. It expects a string and returns a Promise,
    which resolves in the `IFeed` type.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '有什么变化？我们用接口（`FeedMe: IFeedMe`）考虑了`feedme`模块的导出。我们为`createFeedParserStream`函数定义了合同。它接受`IFeed`类型作为输入，并返回`NodeJS.WritableStream`。我们对服务函数`rss`也做了同样的事情。它期望一个字符串并返回一个解析为`IFeed`类型的Promise。'
- en: Creating a service to manage feed menu
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个管理feed菜单的服务
- en: 'Well, now we can fetch RSS feeds. But the plan was to have a manageable menu
    of feeds. I think, we can represent the menu in an array of items, where each
    item can be described with the following interface:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以获取RSS feed了。但计划是拥有一个可管理的feed菜单。我认为，我们可以用一个项目数组来表示菜单，其中每个项目可以用以下接口描述：
- en: '`./app/ts/Interfaces/index.ts`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Interfaces/index.ts`'
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As for the service itself, let''s also start with the interface:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 至于服务本身，让我们也从接口开始：
- en: '`./app/ts/Services/IMenu.ts`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Services/IMenu.ts`'
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To some degree, it''s like Test-Driven development. We describe the contents
    of the class without implementation to get the whole picture. Then, we populate
    the members one by one:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，这有点像测试驱动开发。我们描述类的内容而不实现来获得整体图像。然后，我们逐一填充成员：
- en: '`./app/ts/Services/Menu.ts`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Services/Menu.ts`'
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What is going on here? Firstly, we import the `sha1` module ([https://www.npmjs.com/package/sha1](https://www.npmjs.com/package/sha1))
    that we are going to use to calculate SHA1 hash ([https://en.wikipedia.org/wiki/SHA-1](https://en.wikipedia.org/wiki/SHA-1))
    of a feed URL. That's an external module, which resolves to a non-module entity
    and, therefore, cannot be imported using the ES6 syntax. That's why, we go with
    the `require` function. But we still want TypeScript to consider the module declaration
    file (`@types/sha1`), so we declare its container as `import sha1`. We also import,
    in the module scope, the service interface (`IMenu`) and menu item type (`IMenuItem`).
    Our constructor accepts namespace as a string. By prefixing the parameter with
    an accessibility modifier, we declare the `ns` property and assign the parameter's
    value to it. The instance of `Menu` will keep the actual menu state in the property
    `items`. Private method `save` stores the value of the `items` property to `localStorage`.
    All the three `add`, `remove`, and `clear` methods modify the `this.items` array
    and synchronize with `localStorage` by using the save method. Finally, the method
    load updates `this.item` with the array stored in `localStorage`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？首先，我们导入了`sha1`模块（[https://www.npmjs.com/package/sha1](https://www.npmjs.com/package/sha1)），我们将使用它来计算feed
    URL的SHA1哈希（[https://en.wikipedia.org/wiki/SHA-1](https://en.wikipedia.org/wiki/SHA-1)）。这是一个外部模块，它解析为非模块实体，因此不能使用ES6语法导入。这就是为什么我们使用`require`函数。但我们仍然希望TypeScript考虑模块声明文件（`@types/sha1`），所以我们将其容器声明为`import
    sha1`。我们还在模块范围内导入了服务接口（`IMenu`）和菜单项类型（`IMenuItem`）。我们的构造函数接受一个字符串作为命名空间。通过给参数加上可访问性修饰符，我们声明了`ns`属性并将参数的值赋给它。`Menu`的实例将在`items`属性中保持实际菜单状态。私有方法`save`将`items`属性的值存储到`localStorage`中。`add`、`remove`和`clear`方法都修改`this.items`数组，并使用save方法与`localStorage`同步。最后，load方法更新`this.item`，使用存储在`localStorage`中的数组。
- en: Actions and Reducers
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作和减速器
- en: 'So, we have our core services and can start designing the Redux store. We can
    describe the intended state mutations in a table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了核心服务，可以开始设计Redux存储。我们可以在表格中描述预期的状态变化：
- en: '| **Action creator** | **Action Type** | **State Impact** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **操作创建者** | **操作类型** | **状态影响** |'
- en: '| `toggleOpenAddFeed` | `TOGGLE_ADD_FEED` | `state.isOpenAddFeed` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `toggleOpenAddFeed` | `TOGGLE_ADD_FEED` | `state.isOpenAddFeed` |'
- en: '| `addFeed` | `ADD_FEED` | `state.isOpenAddFeed``state.feedError` `state.items`
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `addFeed` | `ADD_FEED` | `state.isOpenAddFeed``state.feedError` `state.items`
    |'
- en: '| `setFeedError` | `SET_FEED_ERROR` | `state.feedError` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `setFeedError` | `SET_FEED_ERROR` | `state.feedError` |'
- en: '| `removeFeed` | `REMOVE_FEED` | `state.feedError` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `removeFeed` | `REMOVE_FEED` | `state.feedError` |'
- en: '| `fetchFeed` | `FETCH_FEED` | `state.items` `state.feedError` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `fetchFeed` | `FETCH_FEED` | `state.items` `state.feedError` |'
- en: '| `fetchMenu` | `FETCH_MENU` | `state.menu` `state.items``state.activeFeedUrl`
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `fetchMenu` | `FETCH_MENU` | `state.menu` `state.items``state.activeFeedUrl`
    |'
- en: '| `setActiveFeed` | `SET_ACTIVE_FEED` | `state.activeFeedUrl` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `setActiveFeed` | `SET_ACTIVE_FEED` | `state.activeFeedUrl` |'
- en: First of all, we need to populate our feed menu. For that, we are going to have
    a modal window with a form to add a feed. The action creator function `toggleOpenAddFeed`
    will be used to toggle the visibility of the modal window.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要填充我们的feed菜单。为此，我们将有一个带有表单的模态窗口来添加feed。操作创建者函数`toggleOpenAddFeed`将用于切换模态窗口的可见性。
- en: When the form in the modal window is submitted, the component will call the
    `addFeed` function. The function fetches the feed by the supplied URL, obtains
    its title, and appends the menu with a new item. As it involves user input and
    network operations, we have to cover the failure scenario. So, we introduce the
    `setFeedError` function that sets a message in the application state. When we
    update the menu, the corresponding service synchronizes the change with `localStorage`.
    That means we need an action to read the menu. The function `fetchMenu` will take
    care of it. Besides, it will utilize the `rss` service to fetch the items of all
    the feeds in the menu in an aggregative list. What's more, we are going to provide
    the option to navigate through the menu. When a user clicks on an item, the component
    calls `setActiveFeed` to mark the item as active and the function `fetchFeed`
    to update the `Feed` component with the items of the selected feed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当模态窗口中的表单提交时，组件将调用`addFeed`函数。该函数通过提供的URL获取feed，获取其标题，并向菜单添加新项。由于涉及用户输入和网络操作，我们必须覆盖失败场景。因此，我们引入了`setFeedError`函数，它在应用程序状态中设置消息。当我们更新菜单时，相应的服务将使用`localStorage`同步更改。这意味着我们需要一个读取菜单的操作。`fetchMenu`函数将负责此事。此外，它将利用`rss`服务来获取菜单中所有feed的项目，并以聚合列表的形式提供。此外，我们将提供通过菜单导航的选项。当用户点击一个项目时，组件将调用`setActiveFeed`来标记项目为活动状态，并调用`fetchFeed`函数来更新所选feed的`Feed`组件中的项目。
- en: 'When working on action creator functions, we declare the types and use them
    as references from the Reducers. That means we need a module with a bunch of constants
    representing action types:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写操作创建者函数时，我们声明类型并将它们用作Reducers的引用。这意味着我们需要一个模块，其中包含一堆表示操作类型的常量：
- en: '`./app/ts/Constants/index.ts`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Constants/index.ts`'
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since we are here, let''s also define a few configuration constants:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在这里，让我们也定义一些配置常量：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first (`MENU_STORAGE_NS`) specifies the namespace that we are going to use
    in `localStorage` for the menu. The second (`FEED_ITEM_PER_PAGE`) determines how
    many items we display per page. That applies for both a selected feed and aggregative
    one.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个（`MENU_STORAGE_NS`）指定了我们将在`localStorage`中使用的命名空间。第二个（`FEED_ITEM_PER_PAGE`）确定我们每页显示多少项。这适用于所选的feed和聚合feed。
- en: 'In [Chapter 5](5fc3eae1-8e13-4273-a9a3-c79d5384db4c.xhtml), *Creating a Screen
    Capturer with NW.js, React, and Redux: Planning, Design, and Development*, we
    used the third-party module `redux-act` to abstract the creation of actions and
    Reducers. It was really handy, but it doesn''t fit if you need asynchronous actions.
    So, this time, we are going to use the `redux-actions` module ([https://github.com/acdlite/redux-actions](https://github.com/acdlite/redux-actions))
    instead. Let''s check what that is on a JavaScript example. First, we create a
    synchronous action by calling the `createAction` function of `redux-actions`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](5fc3eae1-8e13-4273-a9a3-c79d5384db4c.xhtml)，*使用NW.js、React和Redux创建屏幕捕捉器：规划、设计和开发*中，我们使用第三方模块`redux-act`来抽象创建actions和Reducers。这真的很方便，但如果需要异步操作，它就不适用了。因此，这一次，我们将使用`redux-actions`模块（[https://github.com/acdlite/redux-actions](https://github.com/acdlite/redux-actions)）。让我们在JavaScript示例中检查一下。首先，我们通过调用`redux-actions`的`createAction`函数创建一个同步action：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So far, it looks pretty much similar to the syntax of `redux-act`. We can run
    the newly created function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它看起来与`redux-act`的语法非常相似。我们可以运行新创建的函数：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then get an action object with a mandatory `type` property and a multipurpose
    `payload` one:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到一个具有强制`type`属性和多用途`payload`属性的操作对象：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can make a Reducer by using the `handleActions` function of `redux-actions`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`redux-actions`的`handleActions`函数来创建一个Reducer：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The function `handleActions` expects a plain object that maps handlers to actions
    using the action type as a reference. Every handler callback takes in the latest
    state object and the dispatched action--the same as the canonical Reducer ([http://redux.js.org/docs/basics/Reducers.html](http://redux.js.org/docs/basics/Reducers.html)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleActions`函数期望一个普通对象，该对象使用action类型作为参考将处理程序映射到操作。每个处理程序回调都接收最新的状态对象和分派的操作，与经典的Reducer相同（[http://redux.js.org/docs/basics/Reducers.html](http://redux.js.org/docs/basics/Reducers.html)）。'
- en: 'But what about asynchronous actions? For example, we are going use the `rss`
    services for fetching feeds. The service returns a Promise. Thanks to `redux-actions`,
    we can create an action as simple as the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是异步操作呢？例如，我们将使用`rss`服务来获取feeds。该服务返回一个Promise。由于`redux-actions`，我们可以创建一个如下简单的action：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Isn''t it beautiful? We just pass, for the handler, an asynchronous function.
    The action will be dispatched as soon as the Promise of the handler resolves:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 是不是很美？我们只需传递一个异步函数作为处理程序。一旦处理程序的Promise解析，操作将被分派：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Hold on! But what if the Promise gets rejected? The module `redux-actions`
    relies on optimistic updates. In the case of failure, incoming action acquires
    an extra property `error` when we can find an error message:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！但是如果Promise被拒绝会怎么样？模块`redux-actions`依赖于乐观更新。在失败的情况下，传入的操作会获得额外的`error`属性，我们可以在其中找到错误消息：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now after considering how we are going to implement action creators and Reducers,
    we can cover the store assets with interfaces. First, we declare the interface
    for the state:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在考虑如何实现action creators和Reducers之后，我们可以使用接口来覆盖存储资产。首先，我们声明状态的接口：
- en: '`./app/ts/Interfaces/index.ts`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Interfaces/index.ts`'
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The property `isOpenAddFeed` is a `boolean` determining if the modal window
    with the form for adding a new feed is visible. The property `menu` contains the
    list of menu items and is used in the `Menu` component to build the menu. The
    property `items` consists of RSS items and is used to build the list in the `Feed`
    component. The property `feedError` stores the last error message and `activeFeedUrl`
    keeps the last requested feed URL.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`isOpenAddFeed`属性是一个`boolean`，用于确定是否显示具有添加新feed表单的模态窗口。`menu`属性包含菜单项列表，并在`Menu`组件中用于构建菜单。`items`属性包含RSS项，并用于在`Feed`组件中构建列表。`feedError`属性存储最后的错误消息，`activeFeedUrl`保留最后请求的feed
    URL。'
- en: 'Next, we describe the actions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们描述actions：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The module `redux-actions` exports though the declaration file `Action` type.
    So, we state that the functions `toggleOpenAddFeed`, `setActiveFeed`, and `setFeedError`
    return plain objects that confront the `Action` type constraints. In other words,
    in addition to the `type` property, those may have `payload` and `error`. `Action`
    is a generic type, so we clarify what type is expected in payload, for example,
    `Action<boolean>` means `{ type: string, payload: boolean }`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '模块`redux-actions`通过声明文件`Action`类型进行导出。因此，我们声明`toggleOpenAddFeed`、`setActiveFeed`和`setFeedError`函数返回符合`Action`类型约束的普通对象。换句话说，除了`type`属性之外，这些函数可能还有`payload`和`error`。`Action`是一个通用类型，因此我们澄清了payload中预期的类型，例如，`Action<boolean>`表示`{
    type: string, payload: boolean }`。'
- en: 'Asynchronous actions `fetchMenu`, `addFeed`, `removeFeed`, and `fetchFeed`
    return Promises. Again, we specify explicitly what type is expected when a Promise
    resolves. Speaking of which, the function `fetchMenu` refers to the missing `IMenuRssPayload`
    type. Let''s add it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作`fetchMenu`、`addFeed`、`removeFeed`和`fetchFeed`返回Promises。再次，当Promise解析时，我们明确指定了预期的类型。说到这一点，函数`fetchMenu`引用了缺少的`IMenuRssPayload`类型。让我们添加它：
- en: '`./app/ts/Interfaces/index.ts`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Interfaces/index.ts`'
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function resolves with an object containing both menu items and RSS items
    of the aggregative list.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能解析为包含聚合列表的菜单项和RSS项的对象。
- en: 'It seems like we are ready to implement the store. So, we will start with actions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经准备好实现存储了。因此，我们将从actions开始：
- en: '`./app/ts/Actions/actions.ts`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Actions/actions.ts`'
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First, we import `createAction`, the earlier defined constants and interfaces,
    and both the services such as `rss` and `Menu` constructor. We create an instance
    of the menu in the namespace imported from the configuration constants. Next,
    we add synchronous actions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入了`createAction`，之前定义的常量和接口，以及`rss`和`Menu`构造函数等服务。我们在从配置常量导入的命名空间中创建了菜单的实例。接下来，我们添加了同步动作：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we use the pattern we examined earlier in the JavaScript example for `createAction`.
    The only difference is that `createAction` is a generic type in the TypeScript
    scope, so we have to specify what type the action creator will pass in the `payload`
    property and what it expects with the first parameter. All of these functions
    take in a single argument. If we needed more, we would express it as `createAction<Payload,
    Arg1, Arg2>` or even `createAction<Payload, Arg1, Arg2, Arg3, Arg4>`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了我们在JavaScript示例中早些时候检查过的模式来创建`createAction`。唯一的区别是`createAction`在TypeScript范围内是一个泛型类型，因此我们必须指定动作创建者将在`payload`属性中传递什么类型，并且第一个参数期望什么类型。所有这些函数都接受一个参数。如果我们需要更多，我们可以将其表示为`createAction<Payload,
    Arg1, Arg2>`甚至`createAction<Payload, Arg1, Arg2, Arg3, Arg4>`。
- en: 'Now, we extend `feedActions` with asynchronous actions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们用异步动作扩展了`feedActions`：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The function `fetchFeed` simply delegates the Promise of the `rss` service.
    The function `addFeed` first checks whether a given URL already exists in the
    menu. If `true`, it throws an exception. Then, the function obtains the feed from
    the `rss` service and adds the item into the menu. Finally, `fetchMenu` performs
    a number of tasks. It reloads the menu from `localStorage`. That is exactly what
    one may expect of the action. But I want the function to generate the aggregative
    list as well. So, it collects the Promises of the `rss` service for every feed
    available in the menu. It applies `Promise.all` to resolve the collected set of
    Promises. The method results in the list of feeds. We need to combine all the
    items in a flat array, sort it by publication date, and limit it to the number
    we set in the `FEED_ITEM_PER_PAGE` constant.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`fetchFeed`简单地委托了`rss`服务的Promise。函数`addFeed`首先检查给定的URL是否已经存在于菜单中。如果是，它会抛出一个异常。然后，函数从`rss`服务获取feed并将项添加到菜单中。最后，`fetchMenu`执行了一些任务。它从`localStorage`重新加载菜单。这正是一个动作所期望的。但我希望这个函数也能生成聚合列表。因此，它收集了菜单中每个可用feed的`rss`服务的Promise。它应用`Promise.all`来解析收集到的Promise集合。该方法的结果是feed列表。我们需要将所有项组合成一个扁平数组，按发布日期排序，并将其限制在我们在`FEED_ITEM_PER_PAGE`常量中设置的数量。
- en: 'Now, we start on the Reducer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们开始Reducer：
- en: '`./app/ts/Reducers/app.ts`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Reducers/app.ts`'
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we imported the `handleActions` function and the `Action` interface, and
    from `redux-actions`, our interfaces and constants. We also defined the default
    state for the Reducer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了`handleActions`函数和`Action`接口，以及来自`redux-actions`的接口和常量。我们还为Reducer定义了默认状态。
- en: 'Next, we create the Reducer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建Reducer：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`handleActions` is generic type, so we can specify the constraints for the
    `state` object it operates with. In the supplied object, we describe how every
    dispatched action shall modify the state. Thus, `toggleOpenAddFeed` (`TOGGLE_ADD_FEED`)
    toggles the `isOpenAddFeed` property. The function `addFeed` (`ADD_FEED`), in
    case of success, populates the `menu` property from the action payload and, besides,
    resets `feedError` and `isOpenAddFeed`. If the Promise was rejected, it sets `feedError`
    with an error message. The function `setFeedError` (`SET_FEED_ERROR`) simply sets
    `feedError` from the action payload. The function `removeFeed` (`REMOVE_FEED`)
    updates the menu, so here, it populates the `menu` state property with the updated
    list. The function `fetchFeed` (`FETCH_FEED`) updates the `items` property with
    just the fetched feed items. The function `fetchMenu` (`FETCH_MENU`) reloads the
    menu and generates the aggregative list, so it updates both `menu` and (RSS) `items`.
    Finally, the function `setActiveFeed` (`SET_ACTIVE_FEED`) simply saves the selected
    item URL in the state.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleActions`是泛型类型，因此我们可以为它操作的`state`对象指定约束。在提供的对象中，我们描述了每个分发的动作如何修改状态。因此，`toggleOpenAddFeed`（`TOGGLE_ADD_FEED`）切换`isOpenAddFeed`属性。函数`addFeed`（`ADD_FEED`）在成功的情况下，从动作有效负载中填充`menu`属性，并且重置`feedError`和`isOpenAddFeed`。如果Promise被拒绝，它会用错误消息设置`feedError`。函数`setFeedError`（`SET_FEED_ERROR`）简单地从动作有效负载中设置`feedError`。函数`removeFeed`（`REMOVE_FEED`）更新菜单，因此在这里，它用更新后的列表填充了`menu`状态属性。函数`fetchFeed`（`FETCH_FEED`）用刚刚获取的feed项更新了`items`属性。函数`fetchMenu`（`FETCH_MENU`）重新加载菜单并生成聚合列表，因此它同时更新了`menu`和（RSS）`items`。最后，函数`setActiveFeed`（`SET_ACTIVE_FEED`）简单地将选定的项URL保存在状态中。'
- en: 'In a large scalable application, we use multiple Reducers combined together
    with the `combineReducers` function of `redux`. For this little application, only
    the Reducer will be sufficient. Yet, I suggest, we follow the practice:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型可扩展的应用程序中，我们使用多个Reducer与`redux`的`combineReducers`函数组合在一起。对于这个小应用程序，只有Reducer就足够了。然而，我建议我们遵循这个做法：
- en: '`./app/ts/Reducers/index.ts`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Reducers/index.ts`'
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This changes our state tree. So, the top level state object can be described
    now with the following interface:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这改变了我们的状态树。因此，顶层状态对象现在可以用以下接口描述：
- en: '`./app/ts/Interfaces/index.ts`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Interfaces/index.ts`'
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Connecting to the store
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到store
- en: 'We have action creators and we have Reducers and, now, we are about to make
    them available across the application. As you can remember from [Chapter 5](5fc3eae1-8e13-4273-a9a3-c79d5384db4c.xhtml),
    *Creating a Screen Capturer with NW.js, React, and Redux: Planning, Design, and
    Development*, the module `redux` provides the function `createStore`, which takes
    in combined reducers to produce the store. The module `react-redux` exports the
    provider higher-order component that accepts the store with the props and makes
    it available through `connect` across the inner component tree. The function `createStore`
    accepts middleware that is combined with the compose function of `redux`. As we
    already discussed in this application, we need asynchronous actions. Here, we
    can use the `redux-thunk` (https://www.npmjs.com/package/redux-thunk) middleware
    that allows us to write action creators, which return functions instead of plain
    objects. These functions take in references to the `dispatch` and `getState` functions
    as parameters. So, we can dispatch deferred actions. For example, we need to read
    the RSS feed by URL, so we reflect it on the application state with the following
    action creator:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有动作创建者和减速器，现在，我们将使它们在整个应用程序中可用。正如您可以从[第5章](5fc3eae1-8e13-4273-a9a3-c79d5384db4c.xhtml)中记得的那样，*使用NW.js、React和Redux创建屏幕捕捉器：规划、设计和开发*，模块`redux`提供了函数`createStore`，它接受组合的减速器来生成存储。模块`react-redux`导出了提供程序高阶组件，它接受带有props的存储并通过`connect`在内部组件树中使其可用。函数`createStore`接受与`redux`的compose函数组合的中间件。正如我们在这个应用程序中已经讨论过的，我们需要异步操作。在这里，我们可以使用`redux-thunk`（https://www.npmjs.com/package/redux-thunk）中间件，它允许我们编写动作创建者，这些动作创建者返回的是函数而不是普通对象。这些函数将`dispatch`和`getState`函数的引用作为参数。因此，我们可以派发延迟的动作。例如，我们需要通过URL读取RSS源，因此我们可以使用以下动作创建者在应用程序状态上反映它：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Before making asynchronous HTTP request for the feed contents, we dispatch `fetchFeedRequest`
    and, when the request is resolved, `fetchFeedSuccess` or `fetchFeedFailure` if
    it was rejected.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在为feed内容进行异步HTTP请求之前，我们派发`fetchFeedRequest`，当请求解析时，派发`fetchFeedSuccess`，如果请求被拒绝，则派发`fetchFeedFailure`。
- en: 'It is all nice, but is too verbose. Just to get the data retrieved through
    HTTP, we write four (!) action creators. Instead we can follow an optimistic updates
    approach and go with a single action creator. That involves an additional middleware
    `redux-promise` ([https://www.npmjs.com/package/redux-promise](https://www.npmjs.com/package/redux-promise)),
    which plays nicely with `redux-actions`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但太啰嗦了。仅仅为了获取通过HTTP检索的数据，我们写了四个（！）动作创建者。相反，我们可以采用乐观更新方法，并使用单个动作创建者。这涉及到一个额外的中间件`redux-promise`（[https://www.npmjs.com/package/redux-promise](https://www.npmjs.com/package/redux-promise)），它与`redux-actions`很好地配合：
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, when combining all together, we come up with the following update for
    the entry script:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当将所有内容组合在一起时，我们得到了入口脚本的以下更新：
- en: '`./app/ts/index.tsx`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/index.tsx`'
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the container component, we need to add two functions that inform `connect`
    of how we want to map state and action creators to the component props:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器组件中，我们需要添加两个函数，通知`connect`我们希望如何将状态和动作创建者映射到组件的props中：
- en: '`./app/ts/Containers/App.tsx`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Containers/App.tsx`'
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we have mapped the state to the props simply one to one. As we have the
    store expressed as `{ state: applicationStateTree }`, we receive, in the props,
    an extra property `state` pointing at the actual state tree. As for the action
    creators, we destructure the namespace and attach every available function as
    a new property to the props. So the props of the container components can now
    be described with the following type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们将状态简单地一对一地映射到了props。由于我们将存储表示为`{ state: applicationStateTree }`，因此我们在props中接收到一个额外的指向实际状态树的`state`属性。至于动作创建者，我们解构命名空间并将每个可用函数作为新属性附加到props上。因此，容器组件的props现在可以用以下类型描述：'
- en: '`./app/ts/Interfaces/index.ts`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Interfaces/index.ts`'
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We shall refer to the props with this type in the `React.Component` generic.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`React.Component`泛型中引用这种类型的props。
- en: 'We pass the container component''s properties downward by destructuring `store={this.props}`.
    Thus, every child component receives an object of the `TStore` type with the property
    store:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过解构`store={this.props}`将容器组件的属性向下传递。因此，每个子组件都会收到一个具有属性`store`的`TStore`类型的对象：
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Personally, I find the container to be a good place for bootstrap logic. In
    particular, I would like the load menu from `localStorage` in the start of the
    application. Actually, it can be done straight after the container component is
    mounted:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我认为容器是引导逻辑的好地方。特别是，我希望在应用程序启动时从`localStorage`加载菜单。实际上，可以在容器组件挂载后立即完成：
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, we call the `fetchMenu` action creator, which is now available in the props.
    This dispatches the action, the Reducer modifies the state and any component,
    and all the components reflect the state change.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们调用了现在在props中可用的`fetchMenu`动作创建者。这将派发动作，减速器修改状态，任何组件，所有组件都反映状态变化。
- en: Consuming store from the components
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从组件中使用存储。
- en: 'If you were attentive enough, you didn''t miss that, in container''s JSX, we
    introduced a new component `ErrorAlert`. Since we have an error state (`state.feedError`),
    we need to visualize it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够注意，你不会错过，在容器的JSX中，我们引入了一个新的组件`ErrorAlert`。由于我们有一个错误状态（`state.feedError`），我们需要将其可视化：
- en: '`./app/ts/Components/ErrorAlert.tsx`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Components/ErrorAlert.tsx`'
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By using `Dialog` and related components of the React MDL library, we describe
    a modal window, which shows up when `state.feedError` is not empty. The window
    has a button `Close`, which has a handler `onClose` subscribed for the click event.
    The handler calls the `setFeedError` action to reset `state.feedError`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用React MDL库的`Dialog`和相关组件，我们描述了一个模态窗口，当`state.feedError`不为空时显示。窗口有一个`Close`按钮，它有一个`onClose`处理程序订阅了点击事件。处理程序调用`setFeedError`动作来重置`state.feedError`：
- en: '![](img/b95092e9-0414-4490-ad39-c35ffc9d14d3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b95092e9-0414-4490-ad39-c35ffc9d14d3.png)'
- en: 'We can now modify the `Menu` components to display and manage the RSS menu
    from the state:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改`Menu`组件以从状态中显示和管理RSS菜单：
- en: '`./app/ts/Components/Menu.tsx`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Components/Menu.tsx`'
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we take `state.menu` from the property `store` and map it to build the
    list of menu items. We represent items as links with `item.title` as contents
    and `item.id` (sha1 of URL) in `href`. We use the static method `makeClassName`
    to build the item `className`. It will be `"mdl-navigation__link"` normally and
    `"mdl-navigation__link mdl-navigation__link--current"` when the item is an active
    one. We also subscribe to the handlers for click events on the `Add`, `Remove`,
    and `Refresh` (`Autorenew` icon) buttons. The first one calls the `toggleOpenAddFeed`
    action with `true` to display the modal window for adding a feed. The second uses
    the `removeFeed` action with `activeFeedUrl` from the state. It also calls the
    `fetchMenu` action to refresh the aggregative list. The last one simply calls
    the `fetchMenu` action.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`store`属性中获取`state.menu`，并将其映射到构建菜单项列表。我们将项目表示为带有`item.title`作为内容和`item.id`（URL的sha1）作为`href`的链接。我们使用静态方法`makeClassName`来构建项目的`className`。它通常是`"mdl-navigation__link"`，当项目是活动项目时，它将是`"mdl-navigation__link
    mdl-navigation__link--current"`。我们还订阅了`Add`，`Remove`和`Refresh`（`Autorenew`图标）按钮的点击事件处理程序。第一个调用`toggleOpenAddFeed`动作，并传入`true`来显示添加反馈的模态窗口。第二个使用`removeFeed`动作，并使用来自状态的`activeFeedUrl`。它还调用`fetchMenu`动作来刷新聚合列表。最后一个简单地调用`fetchMenu`动作。
- en: 'Now, we have to create a component representing the modal window with the form
    to add a feed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个代表带有添加反馈表单的模态窗口的组件：
- en: '`./app/ts/Components/AddFeedDialog.tsx`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Components/AddFeedDialog.tsx`'
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Similar to `ErrorAlert`, we use `Dialog` and the related components of React
    MDL to render the modal window. The window has a form and an input represented
    with the `Textfield` component of React MDL. We make both elements available in
    the instance scope by using the `ref` attribute. We subscribe the `onSubmit` method
    for the form `submit` event. In the handler, we take the value from the input
    field by the reference (`Textfield` is referenced as `this.urlEl`; thus, internal
    input can be accessed as `this.urlEl.inputRef` according to React MDL API) and
    pass it to the private method `save`. The `save` method calls `addFeed` and `fetchMenu`
    to update the aggregative list. The window also includes the `Close` button, which
    invokes the `toggleOpenAddFeed` action with false on a click event.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ErrorAlert`类似，我们使用`Dialog`和React MDL的相关组件来渲染模态窗口。窗口中有一个表单和一个由React MDL的`Textfield`组件表示的输入。我们通过使用`ref`属性将这两个元素都放在实例范围内。我们订阅了表单`submit`事件的`onSubmit`方法。在处理程序中，我们通过引用从输入字段中获取值（`Textfield`被引用为`this.urlEl`；因此，根据React
    MDL API，内部输入可以被访问为`this.urlEl.inputRef`），并将其传递给私有方法`save`。`save`方法调用`addFeed`和`fetchMenu`来更新聚合列表。窗口还包括`Close`按钮，它在点击事件上调用`toggleOpenAddFeed`动作，并传入false。
- en: 'That''s left just to update the `Feed` component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下更新`Feed`组件了。
- en: '`./app/ts/Components/Feed.tsx`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Components/Feed.tsx`'
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we map `state.items` to render RSS items, while we use the `stripHtml`
    static method to sanitize item description. Every item is provided with the `Open`
    button that has a subscriber `onOpenLink`. This method makes visible, the `.feed-contents`
    column and changes the `src` attribute of `WebView`. This causes `WebView` to
    load the feed item URL. Why do we use `WebView` and not iFrame? Because `WebView`
    is the intended container for guest contents in both Electron and NW.js ([https://electron.atom.io/docs/api/webview-tag/](https://electron.atom.io/docs/api/webview-tag/)).
    `WebView` runs in a separate process and it doesn't have the same permission as
    your page. So, it's supposed to prevent third-party pages, and scripts that are
    affecting and harmful to your application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`state.items`映射到渲染RSS项目，同时我们使用`stripHtml`静态方法来清理项目描述。每个项目都配有一个`Open`按钮，它有一个订阅者`onOpenLink`。这个方法会使`.feed-contents`列可见，并改变`WebView`的`src`属性。这会导致`WebView`加载反馈项目的URL。为什么我们使用`WebView`而不是iFrame？因为`WebView`是Electron和NW.js中用于嵌入内容的容器（[https://electron.atom.io/docs/api/webview-tag/](https://electron.atom.io/docs/api/webview-tag/)）。`WebView`在一个单独的进程中运行，它没有与您的页面相同的权限。因此，它应该防止第三方页面和对您的应用程序有害的脚本。
- en: We could not reference `WebView` directly because JSX doesn't have such an element
    and we had to inject it. So, we use the `componentDidMount` life-cycle method
    to reach it via DOM. What is more, we subscribe to the `new-window` event, which
    happens when the page loaded within `WebView` tries to open a new window/tab.
    We prevent that from happening, but open the requested page in the external browser
    instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法直接引用`WebView`，因为JSX没有这样的元素，我们必须注入它。因此，我们使用`componentDidMount`生命周期方法通过DOM来访问它。此外，我们订阅了`new-window`事件，当在`WebView`中加载的页面尝试打开新窗口/标签时会触发该事件。我们阻止了这种情况发生，而是在外部浏览器中打开请求的页面。
- en: 'Chin-chin! It''s a working application now. So, we can build it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 干杯！现在是一个工作中的应用程序。所以，我们可以构建它：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And we can run:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以运行：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output will be:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '![](img/51ef4b5f-8cb8-4b25-aa3c-51703139710e.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51ef4b5f-8cb8-4b25-aa3c-51703139710e.png)'
- en: 'If we hit "open" link on any of RSS items the content panel slides in and it
    loads the corresponding contents into the WebView:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击RSS项目中的“打开”链接，内容面板会滑入，并将相应的内容加载到WebView中：
- en: '![](img/f936b23c-30b2-44dd-8a4f-bb1fe1474060.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f936b23c-30b2-44dd-8a4f-bb1fe1474060.png)'
- en: Creating router service
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建路由器服务
- en: 'Everything is fine, except we cannot really select a feed from the menu. We
    have the state property `activeFeedUrl`, which is already considered by the `Menu`
    component, but we have never used the `setActiveFeed` action so far to set this
    state. Nonetheless, in the `Menu` component, we provided all the items with hash
    links. To serve browser location navigation, we need a router. There are many
    implementations available as installable modules. Yet, in this simple example,
    we will create our own:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好，除了我们实际上无法从菜单中选择一个反馈。我们有状态属性`activeFeedUrl`，已经被`Menu`组件考虑到了，但到目前为止我们从未使用`setActiveFeed`动作来设置这个状态。尽管如此，在`Menu`组件中，我们为所有项目提供了哈希链接。为了提供浏览器位置导航，我们需要一个路由器。有许多可安装的模块可用的实现。然而，在这个简单的例子中，我们将创建我们自己的：
- en: '`./app/ts/Services/Router.ts`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/Services/Router.ts`'
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: On the construction, the service takes in the store instance and assigns it
    to the private property `store`. With the `register` method, we subscribe to the
    document `hashchange` event, which triggers every time the `location.hash` changes.
    It happens, for example, when we request from the address bar something like `#some-id`.
    In the handler function, we extract SHA1 from `location.hash` (everything what
    follows `#` symbol) and use the `getFeedUrlById` method to find the associated
    feed URL (we provide items with IDs in the `add` method of the `Menu` service).
    As we have the URL, we dispatch the `setActiveFeed` action to set the `activeFeedUrl`
    state property. In addition, we dispatch `fetchFeed` to fetch the selected feed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造过程中，服务接收存储实例并将其分配给私有属性`store`。通过`register`方法，我们订阅文档的`hashchange`事件，每当`location.hash`更改时触发。例如，当我们从地址栏请求类似`#some-id`的内容时。在处理函数中，我们从`location.hash`中提取SHA1（跟在`#`符号后面的所有内容），并使用`getFeedUrlById`方法来查找相关的feed
    URL（我们在`Menu`服务的`add`方法中为项目提供了ID）。当我们有了URL时，我们会分派`setActiveFeed`操作来设置`activeFeedUrl`状态属性。此外，我们分派`fetchFeed`来获取所选的feed。
- en: 'We can now enable the service in entry script as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在入口脚本中启用该服务，如下所示：
- en: '`./app/ts/index.tsx`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/ts/index.tsx`'
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by implementing the `rss` service. We used the `request`
    module to fetch feed contents. We obtained a Writable Stream from the `feedme`
    module and configured it to parse the input into our feed container object. We
    piped the `feedme` parser into the Readable Stream produced by `request`. The
    module `feedme` was missing the declaration file, so we provided it with an interface.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现`rss`服务开始了这一章。我们使用`request`模块来获取源内容。我们从`feedme`模块中获得了一个可写流，并配置它来解析输入到我们的feed容器对象中。我们将`feedme`解析器连接到`request`生成的可读流上。`feedme`模块缺少声明文件，所以我们为其提供了一个接口。
- en: Then, we created the `Menu` service, which can be used to manage and persist
    the menu of feeds. We considered actions and state structure required by the application.
    We applied the `redux-actions` module for creating actions and the Reducer. On
    the way, we examined the optimistic updates approach. While creating the store,
    we practiced two store enhancers `redux-thunk` and `redux-promise` that help to
    deal with asynchronous actions. We connected our existing components to the store
    and modified them accordingly. Besides this, we have written two new components,
    both utilizing the `Dialog` component of React MDL library. The first one displays
    an application error if it occurs. The second shows and handles the feed adding
    form. Among other things, we made the `Feed` component to load the feed item URL
    on demand. So, you learned to use the `WebView` tag for the guest contents. What
    is more, we subscribed to the new-window event to force any request for opening
    a new window from the WebView to open in an external browser. Finally, we created
    a simple router to serve navigation in the feed menu.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了`Menu`服务，用于管理和持久化feed菜单。我们考虑了应用程序所需的操作和状态结构。我们应用了`redux-actions`模块来创建操作和Reducer。在此过程中，我们研究了乐观更新方法。在创建存储时，我们使用了两个存储增强器`redux-thunk`和`redux-promise`，这有助于处理异步操作。我们将现有组件连接到存储并相应地修改它们。除此之外，我们编写了两个新组件，都使用了React
    MDL库的`Dialog`组件。第一个显示应用程序错误（如果发生）。第二个显示并处理feed添加表单。除此之外，我们使`Feed`组件能够按需加载feed项的URL。因此，您学会了使用`WebView`标签来显示来宾内容。此外，我们订阅了新窗口事件，以强制WebView中打开新窗口的任何请求在外部浏览器中打开。最后，我们创建了一个简单的路由器来为feed菜单提供导航。
