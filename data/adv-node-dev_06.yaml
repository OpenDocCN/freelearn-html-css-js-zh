- en: Generating newMessage and newLocationMessage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成newMessage和newLocationMessage
- en: In the previous chapter, we looked into Socket.io and WebSockets, to enable
    two-way communication between the server and the client. In this chapter, we'll
    discuss how to generate text and geolocation messages. We looked into generating
    `newMessage` and `newLocationMessage` objects and then writing test case for both
    type of messages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了Socket.io和WebSockets，以实现服务器和客户端之间的双向通信。在本章中，我们将讨论如何生成文本和地理位置消息。我们研究了生成`newMessage`和`newLocationMessage`对象，然后为两种类型的消息编写了测试用例。
- en: Message generator and tests
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息生成器和测试
- en: In this section you are going to break out some functionality currently in `server.js`
    into a separate file, and we're also going to set up our test suite so that we
    can verify if those utility functions are working as expected.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将把`server.js`中的一些功能分解成一个单独的文件，并且我们还将设置我们的测试套件，以便我们可以验证这些实用函数是否按预期工作。
- en: For the moment, our goal is going to be to create a function that helps us generate
    the `newMessage` object. Instead of having to define the object every single time,
    we'll simply pass in two arguments to a function, the name and the text, and it'll
    generate the object so we don't have to do that work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的目标是创建一个帮助我们生成`newMessage`对象的函数。我们将不再需要每次都定义对象，而是只需将两个参数传递给一个函数，即名称和文本，它将生成对象，这样我们就不必做这项工作了。
- en: Generating the newMessage object using the utility function
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实用函数生成newMessage对象
- en: To generate `newMessage`, we are going to make a separate file that we load
    into `server.js` with a method we call instead of defining the object. Inside
    the `server` folder, we'll make a new directory called `utils`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成`newMessage`，我们将制作一个单独的文件，然后将其加载到`server.js`中，而不是定义对象。在`server`文件夹中，我们将创建一个名为`utils`的新目录。
- en: 'Inside `utils` we''ll make a file called `message.js`. This will store our
    utility functions related to messaging, and in our case, we''ll make a new one
    called `generateMessage`. Let''s make a variable called `generateMessage`. This
    is going to be a function and will take the two arguments I talked about earlier,
    `from` and `text`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utils`中，我们将创建一个名为`message.js`的文件。这将存储与消息相关的实用函数，而在我们的情况下，我们将创建一个名为`generateMessage`的新函数。让我们创建一个名为`generateMessage`的变量。这将是一个函数，并将使用我之前提到的两个参数，`from`和`text`：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It will then return an object just like the objects we pass in as the second
    argument to emit in `server.js`. Now all we need to do is `return` an object,
    specifying `from` as the from argument, `text` as the text argument, and `createdAt`,
    which is going to get generated by calling a `new Date` and calling its `getTime`
    method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将返回一个对象，就像我们在`server.js`中作为第二个参数传递给emit的对象一样。现在我们需要做的就是`return`一个对象，指定`from`作为from参数，`text`作为text参数，以及`createdAt`，它将通过调用`new
    Date`并调用其`getTime`方法来生成：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With this in place our utility function is now done. All we need to do is export
    it down below, `module.exports`. We''ll set that equal to an object that has a
    `generateMessage` property equal to the `generateMessage` variable we have defined:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的实用函数现在已经完成。我们需要做的就是在下面导出它，`module.exports`。我们将把它设置为一个对象，该对象具有一个`generateMessage`属性，该属性等于我们定义的`generateMessage`变量：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll eventually be able to integrate this into `server.js`, but before we do
    that let's go ahead and write some test cases to make sure it works as expected.
    This means we will need to install Mocha, and we'll also need to install the Expect
    assertion library. Then we'll set up our `package.json` scripts and write the
    test case.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将能够将其集成到`server.js`中，但在这样做之前，让我们先编写一些测试用例，以确保它按预期工作。这意味着我们需要安装Mocha，并且还需要安装Expect断言库。然后我们将设置我们的`package.json`脚本并编写测试用例。
- en: Writing test cases
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: 'First up, inside the Terminal, we''re going to install, using `npm install`,
    two modules. We need Expect, which is our assertion library, `@1.20.2`, and `mocha`
    to run our test suite at version `5.0.5`. We''ll then use the `--save-dev` flag
    to add these as development dependencies:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在终端中，我们将使用`npm install`安装两个模块。我们需要Expect，这是我们的断言库，版本为`@1.20.2`，以及`mocha`来运行我们的测试套件，版本为`5.0.5`。然后，我们将使用`--save-dev`标志将它们添加为开发依赖项：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's go ahead and run this command, and once it's done we can move into `package.json`
    and set up those test scripts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个命令，一旦完成，我们就可以进入`package.json`并设置这些测试脚本。
- en: They're going to be identical to the ones we used in the last project in the
    previous chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将与我们在上一章的上一个项目中使用的测试用例相同。
- en: 'Inside `package.json` we now have our two `dev` dependencies, and inside the
    scripts we can get started by removing the old test script. We''ll add those two
    scripts, `test` and `test-watch`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，我们现在有两个`dev`依赖项，在脚本中，我们可以通过删除旧的测试脚本来开始。我们将添加这两个脚本，`test`和`test-watch`：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding the test-watch script
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加test-watch脚本
- en: 'Let''s go ahead and fill out the basics first. We''ll set `test` equal to an
    empty string for the moment, and `test-watch`. The `test-watch` script, as we
    know, simply calls `nodemon`, calling the `npm test` script, `nodemom --exec`,
    then `npm test` inside single quotes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先填写基础知识。我们将把`test`设置为空字符串，然后是`test-watch`。我们知道，`test-watch`脚本只是调用`nodemon`，调用`npm
    test`脚本，`nodemom --exec`，然后在单引号内调用`npm test`：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will get the job done. Now when we run `nodemon` here, we're actually running
    the globally-installed `nodemon`; we can also install it locally to fix that.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完成任务。现在当我们在这里运行`nodemon`时，我们实际上正在运行全局安装的`nodemon`；我们也可以在本地安装它来修复这个问题。
- en: 'To get that done, all we''re going to do is run `npm install nodemon`, add
    the most recent version, which is version `1.17.2`, and use the `--save-dev` flag
    to install it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们要做的就是运行`npm install nodemon`，添加最新版本，即版本`1.17.2`，并使用`--save-dev`标志进行安装：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now when we install `nodemon` like this, our application no longer relies on
    that global `nodemon` installation. So if someone else grabs this from GitHub,
    they're going to be able to get started without needing to install anything globally.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们像这样安装 `nodemon` 时，我们的应用程序不再依赖于全局的 `nodemon` 安装。因此，如果其他人从 GitHub 获取这个应用程序，他们将能够开始而无需全局安装任何东西。
- en: Adding the test script
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加测试脚本
- en: Next up is the `test` script. It first has to set up those environment variables
    that we're going to be configuring; we'll do that later. For now, all we're going
    to do is run `mocha`, passing in the pattern for the files we want to test.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `test` 脚本。它首先必须设置我们将要配置的环境变量；我们稍后会这样做。现在，我们要做的只是运行 `mocha`，传入我们要测试的文件的模式。
- en: 'The files we want to test are in that `server` directory. They could be in
    any subdirectory, so we''ll use `**`, and the files, regardless of their name,
    are going to end in `test.js`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测试的文件在 `server` 目录中。它们可以在任何子目录中，所以我们将使用 `**`，而文件，无论它们的名称如何，都将以 `test.js`
    结尾：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this in place, we are done. We can now run our test suite.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们就完成了。现在我们可以运行我们的测试套件。
- en: Running the test suite for the message utility
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行消息实用程序的测试套件
- en: 'Over in the Terminal, if I run `npm test`, all we''re going to see is that
    we have zero tests in place:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，如果我运行 `npm test`，我们将看到的是我们没有任何测试：
- en: '![](img/df69226c-ef6e-4c23-aece-44589f81f192.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df69226c-ef6e-4c23-aece-44589f81f192.png)'
- en: 'Here we have the `server-test` file globbing pattern; it could not resolve
    any files. We can fix this issue by simply adding a test file. I''m going to add
    a test file for the message utility, `message.test.js`. Now we can go ahead and
    rerun the `npm test` command. This time around it does indeed find a file and
    we see we have zero passing tests, which is a great starting point:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有 `server-test` 文件的 globbing 模式；它无法解析任何文件。我们可以通过简单地添加一个测试文件来解决这个问题。我将为消息实用程序添加一个测试文件，`message.test.js`。现在我们可以继续重新运行
    `npm test` 命令。这一次它确实找到了一个文件，我们看到我们没有通过测试，这是一个很好的起点：
- en: '![](img/7f043155-68af-43f7-aae5-66b040c5e59b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f043155-68af-43f7-aae5-66b040c5e59b.png)'
- en: Inside `message.test.js`, we'll need to add a test for the message function
    we just defined. Now this test is going to verify that the object we get back
    is what we would expect given the parameters we passed in. We'll set up the basic
    structure of the test file together, and you'll write the individual test case.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `message.test.js` 中，我们需要为刚刚定义的消息函数添加一个测试。现在这个测试将验证我们得到的对象是否符合我们根据传入的参数所期望的。我们将一起设置测试文件的基本结构，然后你将编写单个测试用例。
- en: 'First up we need to load in Expect using `var expect = require(''expect'')`.
    This will let us make our assertions about the return value from our `generateMessage`
    function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 `var expect = require('expect')` 加载 Expect。这将让我们对从我们的 `generateMessage`
    函数返回的值进行断言：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next thing we''re going to do is add a `describe` block. Here, we''re going
    to add a `describe` block for the function `generateMessage`, and inside the callback
    function we''ll have all of the test cases for that function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是添加一个 `describe` 块。在这里，我们将为函数 `generateMessage` 添加一个 `describe` 块，并在回调函数中添加该函数的所有测试用例：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before we can actually create a test case and fill it out, we do need to load
    in the module we''re testing. I''ll make a variable and using ES6 destructuring.
    We''re going to pull off `generateMessage`, and then we can go ahead and require
    it using `require`, specifying the local path, `./message`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际创建测试用例并填写之前，我们确实需要加载我们正在测试的模块。我将创建一个变量并使用 ES6 解构。我们将取出 `generateMessage`，然后我们可以使用
    `require` 来引入它，指定本地路径 `./message`：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It''s in the same directory as the test file where we currently are, so there''s
    no reason to do any directory moving. With this in place we can now add the individual
    test case, `it (''should generate the correct message object'')`. This is going
    to be a synchronous test, so there is no need to provide done. All you need to
    do is call `generateMessage` with two values, `from` and `text`. You''re going
    to get the response back, and store the response in variable:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我们当前所在的测试文件相同的目录中，所以没有理由进行任何目录移动。有了这个设置，我们现在可以添加单个测试用例，`it ('should generate
    the correct message object')`。这将是一个同步测试，因此无需提供 done。你只需要调用 `generateMessage` 传入两个值，`from`
    和 `text`。你将得到响应，并将响应存储在变量中：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then you''re going to make some assertions about the response. First up, assert
    that from is correct, assert from matches the value you passed in. You''re also
    going to assert that the text matches up, and lastly you''re going to assert that
    the `createdAt` value is a number:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将对响应进行一些断言。首先，断言 from 是正确的，断言 from 与你传入的值匹配。你还将断言文本匹配，最后你将断言 `createdAt`
    值是一个数字：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It doesn't matter what number it is; you're going to use the `toBeA` method
    to check the type and assert `createdAt` is number. To get this done, the first
    thing I'll do is define some variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它不管是什么数字；你将使用 `toBeA` 方法来检查类型并断言 `createdAt` 是数字。为了完成这个任务，我将首先定义一些变量。
- en: 'To get started I''ll make a from variable to store the from value. I''ll go
    ahead and use `Jen`. I''ll also make a `text` variable to store the text value,
    `Some message`. Now what I want to do is make my final variable, which is going
    to store the response, the `message` that comes back from the `generateMessage`
    function, which is exactly what I''m going to call. I''m going to call `generateMessage`
    passing in the two necessary arguments, the `from` argument and the `text` argument:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将创建一个 from 变量来存储 from 的值。我将使用 `Jen`。我还将创建一个 `text` 变量来存储文本值，`Some message`。现在我想做的是创建我的最终变量，它将存储响应，即从
    `generateMessage` 函数返回的 `message`，这正是我要调用的。我将调用 `generateMessage`，传入两个必要的参数，`from`
    参数和 `text` 参数：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next up, and the final thing, we need to do is make assertions about this object
    that comes back. I''m going to expect that `message.createdAt` is a number using
    `toBeA` and passing in the type `number`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，最后一件事，我们需要对返回的对象进行断言。我期望`message.createdAt`是一个使用`toBeA`和传入类型`number`的数字：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This was the first assertion you needed to make to verify the property is correct.
    Next up we''re going to `expect` that message has certain properties inside it.
    We''re going to do this using the `toInclude` assertion, though you could have
    created two separate statements: one for `message.from` and a separate one for
    `message.text`. All of those are valid solutions. I''ll just use `toInclude` and
    specify some things that message should include:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要做的第一个断言，以验证属性是否正确。接下来，我们将期望该消息内部具有某些属性。我们将使用`toInclude`断言来做到这一点，尽管你可以创建两个单独的语句：一个用于`message.from`，另一个用于`message.text`。所有这些都是有效的解决方案。我将只使用`toInclude`并指定消息应该包含的一些内容：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First up, it should have a `from` property equal to the `from` variable. We
    can go ahead and use ES6 to define that; and the same thing is going to happen
    for `text`, `text` should equal `text` and we''re going to use ES6 to set that
    up. We can even simplify this further using `from, text`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它应该有一个`from`属性等于`from`变量。我们可以继续使用ES6来定义；对于`text`，`text`应该等于`text`，我们将使用ES6来设置。我们甚至可以使用`from,
    text`来进一步简化这个过程：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this in place our test case is now done and we can go ahead and remove
    these commented outlines, and the final thing you needed to do was run the test
    suite from the Terminal by running `npm test`. When we do it what do we get? We
    get our one test under `generateMessage`, should generate correct message object,
    and it is indeed passing, which is fantastic:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的测试用例现在已经完成，我们可以继续删除这些注释轮廓，你需要做的最后一件事是通过在终端运行`npm test`来运行测试套件。当我们这样做时，我们会得到什么？我们得到了我们在`generateMessage`下的一个测试，应该生成正确的消息对象，它确实通过了，这太棒了：
- en: '![](img/f79e1123-da6d-446d-b698-e5c2eda9b07b.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f79e1123-da6d-446d-b698-e5c2eda9b07b.png)'
- en: Now that we have some tests verifying our function works as expected, let's
    go ahead and integrate it into our application by moving into `server.js` and
    replacing all of the objects we pass to the emit function with calls to our new
    function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些测试来验证我们的函数是否按预期工作，让我们继续将其集成到我们的应用程序中，方法是进入`server.js`，并用我们的新函数调用替换传递给emit函数的所有对象。
- en: Integrate the utility function into our application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将实用函数集成到我们的应用程序中
- en: 'The first step in this process will be to import the function we just created.
    I''m going to do that creating a constant in `server.js`. We''ll use ES6 destructuring
    to grab `generateMessage`, and we''re going to grab it off of a call to `require`.
    Now we''re requiring a local file in a different directory. We''re going to start
    with `./`, go into the `utils` directory since we''re currently in the `server`
    directory, and then grab the file message by specifying it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的第一步是导入我们刚刚创建的函数。我将在`server.js`中创建一个常量来做到这一点。我们将使用ES6解构来获取`generateMessage`，并且我们将从`require`的调用中获取它。现在我们正在要求一个不同目录中的本地文件。我们将从`./`开始，进入`utils`目录，因为我们当前在`server`目录中，然后通过指定文件名`message`来获取它：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we have access to `generateMessage`, and instead of creating these objects
    we can call `generateMessage`. In `socket.emit`, we''re going to replace `Welcome
    to the chat app` and the `Admin` variables with arguments `generateMessage (''Admin'',
    ''Welcome to the chat app'')`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问`generateMessage`，而不是创建这些对象，我们可以调用`generateMessage`。在`socket.emit`中，我们将用参数`generateMessage ('Admin',
    'Welcome to the chat app')`替换`Welcome to the chat app`和`Admin`变量：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have the exact same functionality but now we're using a function to generate
    that object for us, which is going to make scaling that out a lot easier. It's
    also going to make updating what is inside a message much easier as well. Next
    up, we can change the one we have down below for *New user joined*. We're going
    to go ahead and replace this with the call to `generateMessage` as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有完全相同的功能，但现在我们使用一个函数来为我们生成该对象，这将使得扩展变得更容易。这也将使得更新消息内部的内容变得更容易。接下来，我们可以更改下面的*New
    user joined*。我们也将用对`generateMessage`的调用来替换这个。
- en: 'Once again this one''s from the `Admin` so the first argument will be the string
    `Admin`, the second argument is the text `New user joined`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这次也是来自`Admin`，所以第一个参数将是字符串`Admin`，第二个参数是文本`New user joined`：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This one is done too, and the final one is the one that actually gets sent
    to the user from a user, which means we have `message.from` and `message.text`;
    those are going to be our arguments. We''re going to call `generateMessage` with
    those two arguments, `message.from`, and `message.text` as the second argument:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个也完成了，最后一个是实际从用户那里发送给用户的，这意味着我们有`message.from`和`message.text`；这些将是我们的参数。我们将使用这两个参数`message.from`和`message.text`调用`generateMessage`作为第二个参数：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this in place we are done. The last thing left to do for this section
    is test that this is working as expected. I''m going to start up the server using
    `nodemon`, without a space between `node` and `mon`, `server/server.js`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了。这一部分剩下的最后一件事是测试它是否按预期工作。我将使用`nodemon`启动服务器，`node`和`mon`之间没有空格，`server/server.js`：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once the server is up, we can go ahead and test things out by opening up a couple
    of tabs with the Developer Tools open.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，我们可以通过打开几个带有开发者工具的标签页来测试一下。
- en: 'For the first tab I''m going to visit `localhost:3000`. Inside the console
    we should see our new message printing, the object looks the same even though
    it''s now generated by the function, and we can test that everything else is working
    as expected too by opening up a second tab and opening up its Developer Tools:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个标签页，我将访问`localhost:3000`。在控制台中，我们应该看到我们的新消息打印出来，即使它现在是由函数生成的，对象看起来是一样的，我们也可以通过打开第二个标签页并打开其开发者工具来测试其他一切是否按预期工作：
- en: '![](img/1e0c1175-3c4c-4958-a83f-0109b0922d06.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e0c1175-3c4c-4958-a83f-0109b0922d06.png)'
- en: This time around the first tab should see a new message, here we have a `New
    user joined` text, that's still working. If we emit a custom message from this
    second tab, it should show up in the first. I'm going to use the up arrow key
    to run one of our previous `createMessage` event emitters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，第一个选项卡应该看到一个新消息，这里有一个`New user joined`的文本，仍然有效。如果我们从第二个选项卡发出自定义消息，它应该出现在第一个选项卡中。我将使用上箭头键运行我们之前的`createMessage`事件发射器之一。
- en: 'I''m going to fire off the function, and if I go to the first tab we do indeed
    get the message, which is fantastic:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我将触发这个函数，如果我去第一个选项卡，我们确实会收到消息，这太棒了：
- en: '![](img/adfa80a5-d2de-4918-9ff2-f3a4d95a839e.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adfa80a5-d2de-4918-9ff2-f3a4d95a839e.png)'
- en: This should work, prints in the first tab and it also prints in the second since
    we're calling `io.emit` as opposed to the broadcast method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该有效，在第一个选项卡中打印，也会在第二个选项卡中打印，因为我们调用的是`io.emit`而不是广播方法。
- en: 'Now that everything is working, we are done; we can make a commit and wrap
    this section. I''m going to call `git status` from the Terminal. Here we have
    new files as well as modified ones, which means we''re going to want to call `git
    add .`. Next up, we can call `git commit` with a message flag, `create generateMessage
    utility`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都正常了，我们完成了；我们可以提交并结束这一部分。我将从终端调用`git status`。这里我们有新文件和修改过的文件，这意味着我们需要调用`git
    add .`。接下来，我们可以调用`git commit`并使用消息标志，`create generateMessage utility`：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I'm going to push this up to GitHub and that is it for this one. In the next
    section, we're going to take a look at `Socket.io` acknowledgments.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个推送到GitHub，这就是这个部分的全部内容。在下一节中，我们将看一下`Socket.io`的确认。
- en: Event acknowledgements
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件确认
- en: 'In this section you''re going to learn how to use event acknowledgments. That''s
    a fantastic feature inside `Socket.io`. In order to illustrate exactly what they
    are and why you''d ever want to use them, we''re going to quickly run through
    the diagram for the chat app. These are the two events that we actually have in
    our application, if you remember the first one is the newMessage Event, it gets
    emitted by the server and it gets listened to by the client, it sends across the
    from, text, and createdAt properties, all of which are required to render the
    message to the screen:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将学习如何使用事件确认。这是`Socket.io`中的一个很棒的功能。为了准确说明它们是什么以及为什么你想要使用它们，我们将快速浏览一下聊天应用程序的图表。这是我们应用程序中实际存在的两个事件，如果你还记得，第一个是newMessage事件，它由服务器发出，并由客户端监听，它发送from、text和createdAt属性，所有这些属性都是必需的，以便将消息呈现到屏幕上。
- en: '![](img/7644a516-1cea-4937-a566-8b47601df728.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7644a516-1cea-4937-a566-8b47601df728.png)'
- en: 'Now the event that we''re going to be updating is the createMessage Event.
    This one gets emitted by the client and listened to by the server:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要更新的事件是createMessage事件。这个事件由客户端发出，服务器监听：
- en: '![](img/c844762f-db12-40b6-b6d6-ff93e3404b20.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c844762f-db12-40b6-b6d6-ff93e3404b20.png)'
- en: Once again we are sending some data across from and text. Now the problem with
    our createMessage Event is that the data flows in one direction. The data comes
    from a form inside the browser. It then gets sent over to the server and the server
    is kind of stuck. Sure, the data might be valid, the from and text fields might
    be correctly set up. In that case, we can emit a newMessage Event, rendering it
    to every browser who's connected to the server, but if the server receives invalid
    data it has no way to let the client know that something went wrong.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从文本中发送一些数据。现在我们的createMessage事件存在的问题是数据只能单向流动。数据来自浏览器内的表单，然后发送到服务器，服务器就有点卡住了。当然，数据可能是有效的，from和text字段可能设置正确。在这种情况下，我们可以发出newMessage事件，将其呈现给连接到服务器的每个浏览器，但是如果服务器接收到无效数据，它就无法让客户端知道出了什么问题。
- en: 'What we need is a way to acknowledge we got a request and have the option to
    send some data back. In this case we''re going to add an acknowledgment for createMessage.
    If the client emits a valid request with valid from and text properties, we''re
    going to acknowledge it, sending back no error message. If the data sent from
    client to server is invalid we''re going to acknowledge it sending back the errors,
    so the client knows exactly what it needs to do to send a valid request. Now the
    result is going to look a little bit like this, and the data flow from server
    to client is going to be done via a callback:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种确认我们收到请求并有选项发送一些数据的方法。在这种情况下，我们将为createMessage添加一个确认。如果客户端发出有效的请求，并且from和text属性有效，我们将确认它，发送回无错误消息。如果从客户端发送到服务器的数据无效，我们将确认它，发送回错误消息，这样客户端就知道需要做什么才能发送有效的请求。现在结果看起来会有点像这样，服务器到客户端的数据流将通过回调完成：
- en: '![](img/f788065b-0262-41bf-965b-6df284c1d5a8.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f788065b-0262-41bf-965b-6df284c1d5a8.png)'
- en: Your acknowledgment could be anything you like. In our case it could be was
    the message data valid? If you're creating an email application, you might only
    send the acknowledgement back to the client when the email was successfully sent.
    You don't need to send data, which is what we're going to do when valid data is
    sent across the pipeline. We're simply going to say, hey we got that message,
    everything's good to go, and the client can respond to that.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你的确认可以是任何你喜欢的。在我们的情况下，它可能是消息数据有效吗？如果你正在创建一个电子邮件应用程序，你可能只在成功发送电子邮件时向客户端发送确认。当有效数据通过管道发送时，你不需要发送数据，这就是当有效数据发送时我们要做的。我们只需要说，嘿，我们收到了那条消息，一切都很顺利，客户端可以对此做出响应。
- en: Now that we've gone through this, let's go ahead and implement it into our application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了这一部分，让我们继续将其实现到我们的应用程序中。
- en: Setting up acknowledgements
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置确认
- en: Setting up acknowledgments really isn't that bad if you already have a listener
    in place. All you have to do is make a quick change to the listener and a quick
    change to the emitter, and everything will work as expected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个监听器，设置确认真的不难。你只需要快速更改监听器和发射器，一切都会按预期工作。
- en: Now in this case, the listener happens to be on the server and the emitter is
    going to be on the client, but acknowledgments also work in the other direction.
    I can emit an event from the server and I can acknowledge it from the client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这种情况下，监听器恰好在服务器上，发射器将在客户端上，但确认也可以在另一个方向上工作。我可以从服务器发射一个事件，并且可以在客户端上确认它。
- en: 'In order to set this up we are going to emit a `createMessage` event over inside
    `index.js` using `socket.emit`, and we''re going to pass in the same arguments
    we would otherwise. The first one is the event name, `createMessage`, and we''re
    going to pass in some valid data, an object with those two properties. We can
    set `from` equal to something like `Frank`, and we can set a `text` property equal
    to something like `Hi`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这个，我们将使用`socket.emit`在`index.js`中发射一个`createMessage`事件，并且我们将传递相同的参数。第一个是事件名称，`createMessage`，然后我们将传递一些有效的数据，一个具有这两个属性的对象。我们可以将`from`设置为`Frank`，并且我们可以将`text`属性设置为`Hi`：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now with this in place we have a standard event emitter and a standard event
    listener. I can go ahead and start up the app using `nodemon` and we can make
    sure everything is working as expected, `nodemon server/server.js`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这个，我们有了一个标准的事件发射器和一个标准的事件监听器。我可以继续使用`nodemon`启动应用程序，确保一切都按预期工作，`nodemon
    server/server.js`：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the server is up we can visit it in the browser, I''m going to open up
    the Developer Tools as well. Then we''re going to go to `localhost:3000`, and
    you can see over inside of the Terminal we have `createMessage` showing up, and
    we also have `newMessage` showing up here. We have the `newMessage` for our little
    `Welcome to the chat app` greeting, and we have the `newMessage` from `Frank`,
    which we emitted:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，我们可以在浏览器中访问它，我也会打开开发者工具。然后我们将转到`localhost:3000`，你可以看到在终端中我们有`createMessage`显示出来，我们还有`newMessage`显示在这里。我们有`newMessage`用于我们的小`Welcome
    to the chat app`问候语，以及我们从`Frank`那里发射的`newMessage`：
- en: '![](img/98585275-6297-4746-8a5a-459b8ce85cdc.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98585275-6297-4746-8a5a-459b8ce85cdc.png)'
- en: Now the goal here is to send an acknowledgement from the server back to the
    client that we got the data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这里的目标是从服务器发送一个确认回到客户端，证明我们已经收到了数据。
- en: Sending an acknowledgement from server to the client
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器发送确认到客户端
- en: In order to get this done we have to make a change to both the listener and
    the emitter. If you only make a change to one it is not going to work as expected.
    We're going to start with the event emitter. We want a way to run some code when
    the acknowledgement has been sent from the server back to the client.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们必须对监听器和发射器进行更改。如果你只对其中一个进行更改，它将不会按预期工作。我们将从事件发射器开始。我们希望在从服务器发送确认到客户端时运行一些代码。
- en: Updating the event emitter
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新事件发射器
- en: 'To send acknowledgement `d=from` server to client, we''re going to add a third
    argument which is going to be a callback function. This function is going to fire
    when the acknowledgement arrives at the client, and we can do anything we like.
    For now we''ll just print using `console.log(''Got it'')`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从服务器向客户端发送确认，我们将添加一个第三个参数，这将是一个回调函数。当确认到达客户端时，这个函数将被触发，我们可以做任何我们喜欢的事情。现在我们只是使用`console.log('Got
    it')`打印：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now this is all we need to do bare-bones style to add an acknowledgement to
    the client.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这就是我们需要做的最基本的事情，为客户端添加一个确认。
- en: Updating the event listener
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新事件监听器
- en: 'It''s also pretty simple on the server; we''re going to add a second argument
    to our `callback` argument list. The first one is still going to be the data that
    was emitted, the second one though is going to be a function that we''re going
    to refer to as `callback`. And we can call it anywhere in `socket.on` to acknowledge
    that we got the request:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上也很简单；我们将在`callback`参数列表中添加第二个参数。第一个仍然是被发射的数据，但第二个将是一个我们将称之为`callback`的函数。我们可以在`socket.on`中的任何地方调用它来确认我们已经收到了请求：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When we call this function, like we're going to call it right here, it is in
    turn going to send an event back to the frontend and it is going to call the function
    as we have it in event emitter in `index.js`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，就像我们现在要调用它一样，它将会向前端发送一个事件，然后会调用`index.js`中的事件发射器中的函数。
- en: 'This means that if I save both files we can play around with acknowledgments
    over in the browser. I''m going to refresh the app, and what do we get? We get
    Got it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我保存这两个文件，我们可以在浏览器中玩一下确认。我将刷新应用程序，我们会得到什么？我们得到了Got it：
- en: '![](img/8fd062aa-1af4-494f-a8c4-0937594e2184.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fd062aa-1af4-494f-a8c4-0937594e2184.png)'
- en: 'That means our data successfully went to the server; we can prove that by seeing
    the `console.log` statement in the Terminal, the server acknowledged it got the
    data by calling callback:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的数据成功传输到了服务器；我们可以通过在终端中看到`console.log`语句来证明这一点，服务器通过调用回调函数确认它已经收到了数据：
- en: '![](img/1b37a8ea-3715-47c2-ba77-a991b4ce67a3.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b37a8ea-3715-47c2-ba77-a991b4ce67a3.png)'
- en: And in the Developers Tool, Got it prints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者工具中，Got it打印出来了。
- en: Now acknowledgments are pretty useful, but they're even more useful when you
    send data back. If the data for the message is invalid, for example, we're probably
    going to want to send some errors back, something we will be doing a little later.
    For now though, we can play around with an acknowledgment by sending anything
    we want back.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确认是非常有用的，但当你发送数据回去时，它们会更有用。例如，如果消息的数据无效，我们可能会想要发送一些错误回去，这是我们稍后将要做的事情。不过，现在我们可以通过发送任何我们想要的东西来玩一下确认。
- en: 'We send data back by providing one argument to callback, if you want to add
    multiple things simply specify an object adding as many properties as you like.
    In our case, though, we can send a string as the only argument to `callback`.
    I''m going to set my string to `This is from the server`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向回调提供一个参数来发送数据回去，如果你想添加多个东西，只需指定一个对象，添加尽可能多的属性。不过，在我们的情况下，我们可以将一个字符串作为`callback`的唯一参数发送。我将把我的字符串设置为`This
    is from the server`：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This string is going to be passed into the callback and it''s going to end
    up inside of our callback in `index.js`. This means I can create a variable for
    that value, we can call it `data` or anything else you like, and we can print
    it to the screen or do something with it. For now we''re just going to print it
    to the screen:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串将被传递到回调函数中，并最终出现在我们的`index.js`回调中。这意味着我可以为该值创建一个变量，我们可以称之为`data`或者其他你喜欢的名称，并且我们可以将其打印到屏幕上或者对其进行操作。现在我们只是打印到屏幕上：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If I save `index.js`, we can test that everything is working as expected. I'm
    going to go ahead and give the app a refresh, and what do we see?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我保存`index.js`，我们可以测试一切是否按预期工作。我将继续刷新应用程序，我们会看到什么？
- en: '![](img/4f9d2613-c564-4e64-b9ba-b9f5599c8cdc.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f9d2613-c564-4e64-b9ba-b9f5599c8cdc.png)'
- en: We see Got it, meaning we got the acknowledgment, and we see the data, the data
    that was sent from the server to the client.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了“收到”，这意味着我们收到了确认，我们也看到了数据，从服务器发送到客户端的数据。
- en: Acknowledgments play an important role in real-time applications. Let's go back
    to that email app example for a second, imagine I type in some values like a to
    value and a text value when I send the e-mail. I want to get an acknowledgement
    back that either email sent successfully, or email was not sent, in which case
    I want to know why; maybe it was a form error where I can show some error messages
    to the user or maybe the server was down for maintenance or something like that.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 确认在实时应用程序中扮演着重要的角色。让我们回到电子邮件应用程序的例子，想象一下，当我发送电子邮件时，我键入了一些值，比如收件人和文本值。我希望得到一个确认，要么是电子邮件成功发送，要么是电子邮件未发送，这种情况下我想知道原因；也许是表单错误，我可以向用户显示一些错误消息，或者服务器正在维护中等等。
- en: Either way, acknowledgments allow the request listener to send something back
    to the request emitter. Now that we know how to use acknowledgments we're going
    to integrate them into our application. That is coming up in the next section,
    as we add an actual form field to our `index.html` file where users can submit
    new messages and view them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，确认允许请求监听器向请求发射器发送一些内容。现在我们知道如何使用确认，我们将把它们整合到我们的应用程序中。这将在下一节中进行，我们将在`index.html`文件中添加一个实际的表单字段，用户可以提交新消息并查看它们。
- en: The message form and jQuery
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息表单和jQuery
- en: In this section you're going to add a form field to your `index.html` file.
    This is going to render an input field and a button to the screen, and the user
    is going to be able to interact with that as opposed to having to call `socket.emit`
    from the Developer Tools, which is not a sustainable option for real users. This
    only works for us developers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将向你的`index.html`文件中添加一个表单字段。这将在屏幕上呈现一个输入字段和一个按钮，用户将能够与之交互，而不是必须从开发者工具中调用`socket.emit`，这对于真实用户来说并不是一个可持续的选项。这只对我们开发人员有效。
- en: Now in order to get started we're going to be editing `index.html`, then we're
    going to move into `index.js`. We're going to add a listener that's going to wait
    for the form to be submitted, and inside of that listener callback, we are going
    to fire `socket.emit` with the data typed in the field. We're also going to take
    a moment to render all incoming messages to the screen. At the end of this section,
    we'll have a ugly, yet working, chat application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了开始，我们将编辑`index.html`，然后我们将转到`index.js`。我们将添加一个监听器，等待表单提交，然后在该监听器回调中，我们将使用表单中键入的数据来触发`socket.emit`。我们还将花一些时间将所有传入的消息呈现到屏幕上。在本节结束时，我们将拥有一个丑陋但工作的聊天应用程序。
- en: Using the jQuery library
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery库
- en: 'Now before we do any of that, we are going to be using a library called jQuery
    to do DOM manipulation, which means that we want to be able to do stuff with our
    rendered HTML, but we want to be able to do that from our JavaScript file. We''re
    going to use jQuery to make that a lot easier in terms of cross-browser compatibility.
    To grab this library, we''re going to head over to Google Chrome, go to [jquery.com](http://jquery.com/),
    and you can grab the most recent version. The version is not going to matter for
    here, as we''re using very basic features available in all versions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做任何操作之前，我们将使用一个名为jQuery的库来进行DOM操作，这意味着我们希望能够处理我们呈现的HTML，但我们希望能够从我们的JavaScript文件中进行操作。我们将使用jQuery来使跨浏览器兼容性更容易。为了获取这个库，我们将前往Google
    Chrome，转到[jquery.com](http://jquery.com/)，然后你可以获取最新版本。版本对于这里并不重要，因为我们使用的是所有版本中可用的非常基本的功能：
- en: '![](img/ddd476fc-950d-4a25-8a42-dc7c52cf7bc7.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddd476fc-950d-4a25-8a42-dc7c52cf7bc7.png)'
- en: 'I''ll grab the most recent version 3.3.1\. Then I''ll go ahead and download
    the compressed production version by right-clicking and opening it in a new tab:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我将获取最新版本3.3.1。然后我将右键单击并在新标签中打开压缩的生产版本进行下载：
- en: '![](img/a9539a35-4ea1-4cf5-baab-348758914222.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9539a35-4ea1-4cf5-baab-348758914222.png)'
- en: Here we have the actual JavaScript that we want to load in to our application,
    which means we can right-click some sort of empty area, click on Save As, and
    go into our projects folder, `Desktop` | `node-chat-app` | `public` | `js`. Inside
    of `js`, I'm going to create a new directory called `libs`, where we'll store
    third-party JavaScript. We're going to be working with a few more client-side
    JavaScript libraries throughout the section, so it's nice to create a folder to
    stay organized. I'm going to save that in there, close the tab as well as the
    downloads area, and now we can go ahead and load it in to `index.html` and add
    our form.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有我们想要加载到我们应用程序中的实际JavaScript，这意味着我们可以右键单击某个空白区域，点击“另存为”，然后进入我们的项目文件夹，`桌面`
    | `node-chat-app` | `public` | `js`。在`js`文件夹中，我将创建一个名为`libs`的新目录，我们将在其中存储第三方JavaScript。在这个目录中保存，关闭标签以及下载区域，现在我们可以继续加载到`index.html`中并添加我们的表单。
- en: Adding the form field in index.html
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在index.html中添加表单字段
- en: 'Down here just between `socket.io` and `index.js` we''re going to add a new
    script tag to load in jQuery. We''ve got to specify that `src` attribute with
    the path to the file `/js/libs`, followed by a forward slash and the file name,
    `jquery-3.3.1.min.js`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就在`socket.io`和`index.js`之间，我们要添加一个新的脚本标签来加载jQuery。我们必须指定`src`属性，路径是`/js/libs`，后面跟着一个斜杠和文件名`jquery-3.3.1.min.js`：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now let's go ahead and set up our `form` tag; this is going to render our form
    fields to the browser. If you're not familiar with these tags that is perfectly
    fine, simply follow along and I'll explain as we go.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置我们的`form`标签；这将把我们的表单字段呈现到浏览器上。如果你对这些标签不熟悉，那没关系，跟着做，我会一边解释。
- en: Setting up the form tag
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置表单标签
- en: 'First step, we need a `form` tag; this creates a form that''s submittable by
    the user. This is exactly what we''re going to use to submit our messages. And
    on this `form` tag we''re going to add one attribute; it''s the `id` attribute
    which lets us give this element a unique identifier, making it really easy to
    target with our JavaScript a bit later on:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，我们需要一个`form`标签；这会创建一个用户可以提交的表单。这正是我们要用来提交我们的消息的。在这个`form`标签上，我们要添加一个属性；就是`id`属性，它让我们给这个元素一个唯一的标识符，这样以后用JavaScript就很容易定位它：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember, we're going to want to add a listener to this element. When the form
    gets submitted, we're going to want to do something in our JavaScript file. Notably
    what we're going to want to do is call `socket.emit`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们要给这个元素添加一个监听器。当表单被提交时，我们要在我们的JavaScript文件中做一些事情。特别是我们要做的是调用`socket.emit`。
- en: 'I''m going to set `id` equal to, inside quotes, `message-form`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我要把`id`设置为，引号内，`message-form`：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have our form tag complete we can add some tags inside of it. To
    get started we''re going to add a `button` which is going to appear at the `bottom`
    of the `form`. This `button` on click is going to submit the `form`. I''m opening
    and closing my tag, and just inside I can type whatever text I want to appear
    on the `button`. I''m going to go with `Send`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的表单标签完成了，我们可以在里面添加一些标签。首先，我们要添加一个`button`，它会出现在`form`的`底部`。这个`button`在点击时会提交`form`。我打开并关闭我的标签，然后在里面可以输入任何我想要出现在`button`上的文本。我要选择`Send`：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding the text field
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加文本字段
- en: 'Now that we have our `button` in place, the only thing we need to do is add
    the little text field. This is going to be the text field where a user types their
    message. This is going to require us to use an `input tag`, and instead of opening
    and closing an `input` tag, we''re going to use the self-closing syntax:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`button`就位了，唯一需要做的就是添加一个小文本字段。这将是用户输入消息的文本字段。这将需要我们使用一个`input`标签，而不是打开和关闭一个`input`标签，我们将使用自关闭的语法：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Because we don''t need to actually put anything inside it like we do for `button`,
    or for `form`, we are going to be adding quite a few attributes onto input, first
    up, name, we want to give this field a unique name, something like `message` is
    going to get the job done. We also want to go ahead and set the type. There are
    a lot of different types for `input` tags. Types could include something like
    a checkbox, or in our case the type we''re going to use inside quotes is `text`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不需要像`button`或`form`那样在里面放任何东西，我们要给`input`添加很多属性，首先是`name`，我们要给这个字段一个唯一的名称，类似`message`就可以了。我们还要设置类型。`input`标签有很多不同的类型。类型可以包括复选框之类的，或者在我们的情况下，我们要在引号内使用的类型是`text`：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last attribute we''re going to add to `input` is called `placeholder`.
    We''re going to set this value equal to, inside quotes, a string. This string
    is going to get rendered in the field in a light gray before the user actually
    enters a value. I''m going to tell the user that this is where their `Message`
    goes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加到`input`的最后一个属性叫做`placeholder`。我们要把这个值设置为，引号内，一个字符串。在用户实际输入值之前，这个字符串会以浅灰色呈现在字段中。我要告诉用户这就是他们的`Message`的地方：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this in place we can actually test out our form's rendering.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们实际上可以测试一下我们表单的渲染。
- en: Testing the form's rendering
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试表单的渲染
- en: 'We can do the testing by starting at the server using `nodemon`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启动服务器使用`nodemon`来进行测试：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The server is up, I'm going to visit Google Chrome, and go to `localhost:3000`.
    You'll notice something kind of cool, I haven't actually visited the URL yet but
    you can see that the connection has already occurred. Chrome does some lazy loading,
    if it thinks you're going to go to a URL it's actually going to make the request;
    so when I do visit it, it loads even faster. Now if I visit `localhost:3000` what
    do we get?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已经启动，我要访问Google Chrome，然后转到`localhost:3000`。你会注意到一些很酷的东西，我实际上还没有访问过这个URL，但你可以看到连接已经发生了。Chrome进行了一些懒加载，如果它认为你要去一个URL，它实际上会发出请求；所以当我访问它时，它加载得更快。现在如果我访问`localhost:3000`，我们会得到什么？
- en: '![](img/fa4e5cb4-2f38-4897-99a8-068369aad5ea.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa4e5cb4-2f38-4897-99a8-068369aad5ea.png)'
- en: We get our little form, we can type in a message like `Test` and we can send
    it off. Now by default forms are very old school. If I try to submit this form,
    it's actually going to go through a full page refresh, and then it's going to
    add the data, like our message text, as a query string on the URL. This is not
    what we want to do, we want to run some custom JavaScript on form submit. So we're
    going to attach a custom event listener and override the default behavior. To
    get that done we are going to have to use jQuery, and we're going to need to select
    this `form` field.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们的小表单，我们可以输入一个消息，比如`Test`，然后发送出去。现在默认情况下，表单非常老式。如果我试图提交这个表单，它实际上会进行完整的页面刷新，然后会把数据，比如我们的消息文本，作为查询字符串添加到URL上。这不是我们想要做的，我们想要在表单提交时运行一些自定义JavaScript。所以我们要附加一个自定义事件监听器并覆盖默认行为。为了完成这个，我们需要使用jQuery，并且需要选择这个`form`字段。
- en: Using jQuery to select element
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery选择元素
- en: 'Before we dive into `index.js` let''s take a quick moment to talk about how
    we can use `jQuery` to select elements. `jQuery`, which is accessible via the
    `jQuery` variable, takes your selector as its argument. Then, we''re going to
    add a string and we can select our elements. For example, if we want to select
    all the paragraph tags on the screen we would type `p` in the quotes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究`index.js`之前，让我们简要谈一下如何使用`jQuery`来选择元素。`jQuery`，可以通过`jQuery`变量访问，将您的选择器作为其参数。然后，我们将添加一个字符串，我们可以选择我们的元素。例如，如果我们想在屏幕上选择所有段落标签，我们将在引号中输入`p`：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These are really similar to CSS selectors if you're familiar with them, and
    as shown, we've selected our paragraph tag.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与CSS选择器非常相似，如果您熟悉它们的话，如图所示，我们已经选择了我们的段落标签。
- en: 'I could also go ahead and select all of the `div` inside my program, or I could
    select elements by ID or class, and that''s what we''re going to do. In order
    to select an element by ID we first start with the pound sign (`#`), then we type
    the name. In our case we have a `form` called `message-form`, and if I fire this
    off we do indeed get that back:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以选择程序中的所有`div`，或者可以按ID或类选择元素，这就是我们要做的。为了通过ID选择元素，我们首先以井号（`#`）开始，然后输入名称。在我们的情况下，我们有一个名为`message-form`的`form`，如果我执行这个操作，我们确实会得到它：
- en: '![](img/a3b37ba2-bfaf-485b-8833-c56ef7191a1e.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3b37ba2-bfaf-485b-8833-c56ef7191a1e.png)'
- en: This is going to allow us to add an event listener.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们添加一个事件监听器。
- en: Adding the selector element to index.js
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将选择器元素添加到index.js
- en: 'Inside `index.js` we''re going to add that exact same selector near the bottom,
    `jQuery`, calling it with our selector `#message-form`. Now we''re going to add
    an event listener, and the event listener is going to look pretty similar to our
    `Socket.io` event listeners. We are going to be calling on, and we are going to
    be providing, those two arguments, the event name inside quotes, `submit`, and
    a `function`, which is going to fire when a user tries to submit the `form`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.js`中，我们将在底部附近添加完全相同的选择器，`jQuery`，使用我们的选择器`#message-form`进行调用。现在我们将添加一个事件监听器，事件监听器看起来与我们的`Socket.io`事件监听器非常相似。我们将调用`on`，并且我们将提供这两个参数，事件名称在引号内，`submit`，和一个`function`，当用户尝试提交`form`时将触发该`function`：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now unlike our `Socket.io` event listeners, we are going to get one argument
    in the `function`, an `e` event argument, and we are going to need to access this.
    We''re going to need to access this event argument in order to override that default
    behavior that causes the page refresh. Right here we''re going to call `e.preventDefault`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与我们的`Socket.io`事件监听器不同，我们将在`function`中得到一个参数，一个`e`事件参数，并且我们需要访问它。我们需要访问这个事件参数，以覆盖导致页面刷新的默认行为。在这里，我们将调用`e.preventDefault`：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `preventDefault` method prevents the default behavior for the event, and
    by default a submit event goes through that page refresh process.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`preventDefault`方法可以阻止事件的默认行为，默认情况下，提交事件会经过页面刷新过程。'
- en: 'We can go ahead and test that everything is working by going into Google Chrome,
    giving the page a refresh. I''m also going to remove the query string from the
    URL. Now we can type in some sort of message like `test`, hit Send, and you can
    see that nothing happens. Nothing happens because we overrode the default behavior,
    all we need to do to make something happen is call `socket.emit` in `index.js`.
    We''re going to emit the `createMessage`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过进入Google Chrome，刷新页面来测试一切是否正常。我还将从URL中删除查询字符串。现在我们可以输入一些消息，比如`test`，点击发送，您会看到什么都没有发生。之所以什么都没有发生，是因为我们覆盖了默认行为，要使某些事情发生，我们只需要在`index.js`中调用`socket.emit`。我们将发出`createMessage`：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we''re going to go ahead and provide our data. Now the name `from` field
    for now is just going to be `User` in uppercase. We''re going to leave this as
    anonymous for the moment, although we will be updating that a bit later. Now for
    the text field, this is going to come from the `form`. We''re going to want to
    add a selector and get the value back. Let''s go ahead and do that using `jQuery`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将继续提供我们的数据。现在，`from`字段的名称暂时只是大写的`User`。我们暂时将其保留为匿名，尽管稍后我们将对其进行更新。现在对于文本字段，这将来自`form`。我们将要添加一个选择器并获取值。让我们使用`jQuery`来做到这一点：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''re going to call `jQuery` once again, and we''re going to select the input
    in the `index.html` file. We can go ahead and select it by its name, `name="message"`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次调用`jQuery`，并且我们将选择`index.html`文件中的输入。我们可以通过其名称`name="message"`来选择它：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In order to get that done we''re going to open up brackets in `socket.emit`
    in `index.js`, setting `name` equal to `message`. This is going to select any
    element that has a `name` attribute equal to `message`, which is just our one,
    and we can go ahead and get its value using the `.val` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们将在`index.js`中的`socket.emit`中打开括号，将`name`设置为`message`。这将选择任何具有`name`属性等于`message`的元素，这就是我们的一个元素，我们可以使用`.val`方法获取其值：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'No semicolon required since we''re inside object creation. With this in place
    we can now go ahead and add our callback function for our acknowledgment. For
    the moment it doesn''t really do anything, but that''s perfectly fine. We have
    to add it in order to fulfill the acknowledgement set up we currently have in
    place:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在对象创建内部，不需要分号。有了这个，我们现在可以继续添加我们的回调函数以进行确认。目前它实际上并没有做任何事情，但这完全没问题。我们必须添加它以满足我们当前设置的确认：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now that we have our event listener set up, let's go ahead and test this out.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了事件监听器，让我们继续测试一下。
- en: Testing the update event listener
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试更新事件监听器
- en: 'I''m going to head back into Chrome, give the page a refresh, type in some
    message like `This should work`, and when we submit the form we should see it
    show up over here as a new message:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我将回到Chrome，刷新页面，输入一些消息，比如`This should work`，当我们提交表单时，我们应该在这里看到它显示为新消息：
- en: '![](img/745dcf89-0e1d-46ef-a43d-059101886cec.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/745dcf89-0e1d-46ef-a43d-059101886cec.png)'
- en: 'I''m going to send it off and you can see that right inside the Terminal, we
    have a user sending `This should work`, and it also shows up in Chrome:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我将发送它，你可以看到在终端内，我们有一个用户发送`This should work`，它也显示在Chrome中：
- en: '![](img/ff37e724-ba40-4ed2-8df6-08a1e49a739e.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff37e724-ba40-4ed2-8df6-08a1e49a739e.png)'
- en: 'The same thing is true if I open up a second connection, I''m going to open
    up the Developer Tools so we can see exactly what''s happening behind the scenes.
    I''m going to type some message like `From tab 2`, Send it off:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我打开第二个连接，情况也是如此，我将打开开发者工具，这样我们就可以看到幕后发生了什么。我将输入一些消息，比如`From tab 2`，发送出去：
- en: '![](img/b6c66dd6-dde0-453a-9cd3-8ead6fd3cb2f.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6c66dd6-dde0-453a-9cd3-8ead6fd3cb2f.png)'
- en: 'We should see it over in tab 1, and we do:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在选项卡1中看到它，我们确实看到了：
- en: '![](img/8a22faa0-6e61-4131-87a8-1a2cdf5fcfd6.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a22faa0-6e61-4131-87a8-1a2cdf5fcfd6.png)'
- en: Perfect, everything is working as expected. Now obviously the setup is not complete;
    we want to wipe that form value after we send the message, and we want to take
    care of a few other UI-related things, but for now it is working pretty well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，一切都按预期工作。现在显然设置还没有完成；我们希望在发送消息后清除表单值，并且我们希望处理一些其他与用户界面相关的事情，但目前它运行得相当好。
- en: With a basic form in place, the second thing we're going to do is render incoming
    messages to the screen. Now once again it is going to look pretty ugly, but it
    will get the job done.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个基本的表单，我们要做的第二件事是将传入的消息渲染到屏幕上。现在再次看起来可能会很丑，但它会完成工作。
- en: Rendering incoming messages to the screen
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将传入的消息渲染到屏幕上
- en: To get this done we have to create a place inside our DOM, inside our `index.html`
    file, where we can render the messages. Once again we're going to give this element
    an ID that we can easily access over inside `index.js`, so we can render those
    messages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们必须在我们的`index.html`文件内创建一个地方，我们可以在其中渲染消息。再次，我们将给这个元素一个ID，这样我们就可以在`index.js`内部轻松访问它，以便渲染这些消息。
- en: Creating an ordered list to render messages
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个有序列表来渲染消息
- en: 'First up, what we''re going to do is create an ordered list by creating an
    `ol` tag just like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要做的是创建一个有序列表，方法是创建一个`ol`标签，就像这样：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This list is going to let us add items to it, and those items are going to
    be the individual messages. Now we are going to be giving this an `id` attribute.
    I''m going to call `id`, in this case, `messages`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表将允许我们向其中添加项目，这些项目将是单独的消息。现在我们将给它一个`id`属性。在这种情况下，我将称之为`messages`：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now this is all we need to do in `index.html`, all of the heavy lifting is going
    to happen over inside `index.js`. When a new message comes in we want to add something
    inside of the ordered list so that gets rendered to the screen.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这就是我们在`index.html`中需要做的全部，所有的重活将在`index.js`内部进行。当有新消息到达时，我们希望在有序列表内添加一些内容，以便将其渲染到屏幕上。
- en: Over inside `index.js` we can get this done by modifying our callback function
    when a new message arrives.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.js`内部，当新消息到达时，我们可以通过修改回调函数来完成这个任务。
- en: Using jQuery to create element in index.js
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery在index.js中创建元素
- en: 'The first thing we''re going to do is create a list item, and we''re going
    to do this once again using jQuery. We''re going to make a variable, this variable
    is going to be called `li`, and we''re going to go ahead and use jQuery slightly
    differently:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一个列表项，我们将再次使用jQuery来完成这个任务。我们将创建一个变量，这个变量将被称为`li`，然后我们将稍微不同地使用jQuery：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Rather than using `jQuery` to select an element, we''re going to use `jQuery`
    to create an element, then we can modify that element and add it into the markup,
    making it visible. Inside quotes, we''re going to open and close an `li` tag,
    just like we would inside `index.html`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用`jQuery`来选择元素，而是使用`jQuery`来创建一个元素，然后我们可以修改该元素并将其添加到标记中，使其可见。在引号内，我们将打开和关闭一个`li`标签，就像我们在`index.html`中一样：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we have this in place we have to go ahead and set its text property,
    I'm going to set `li.text`, by calling `li.text` with the value I want to use.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一步，我们必须继续设置它的文本属性，我将通过调用`li.text`来设置`li.text`，并传入我想要使用的值。
- en: 'In this case the text is going to require us to set up a little template string,
    inside the template string we are going to go ahead and use the data that comes
    back. For now we''re going to use the `from` attribute and the `text` attribute.
    Let''s get started with who it''s `from`, then we''ll add a little colon and a
    space to separate that from the actual `message`, and finally, we''ll inject `message.text`
    at the end:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文本将要求我们设置一个小模板字符串，在模板字符串内，我们将使用返回的数据。现在我们将使用`from`属性和`text`属性。让我们从`from`开始，然后添加一个小冒号和一个空格来将其与实际的`message`分开，最后，我们将在末尾注入`message.text`：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now at this point we''ve created an element but we haven''t rendered it to
    the DOM. What we''re going to do is use `jQuery` to select that brand new element
    we created, we gave it an ID of `messages`, and we''re going to `append` something
    to it by calling the `append` method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个元素，但我们还没有将它渲染到DOM中。我们将使用`jQuery`来选择我们创建的全新元素，我们给它一个ID为`messages`，然后我们将通过调用`append`方法向其添加一些内容：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is going to add it as its last child, so there''s already three items
    in the list; the newest one will show up below those three as the fourth item
    in our ordered list. All we have to do is call `append` as a function, passing
    in our list item:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把它添加为其最后一个子元素，因此列表中已经有三个项目；最新的项目将显示在这三个项目下方，作为有序列表中的第四个项目。我们只需要调用`append`作为一个函数，传入我们的列表项：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And with this in place we are done. Now if you're not familiar with `jQuery`
    this can be a bit overwhelming, but I promise the techniques we use here we'll
    be using throughout the book. By the end, you'll be much more comfortable selecting
    and creating elements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们就完成了。现在，如果你不熟悉`jQuery`，这可能有点令人不知所措，但我保证我们在这里使用的技术将贯穿整本书。到最后，你会更加舒适地选择和创建元素。
- en: Testing the incoming messages
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试传入的消息
- en: 'Let''s go ahead and test things out over inside Google Chrome. I''m going to
    refresh tab 1, and when I do you can see our two messages, Welcome to the chat
    app shows up and Frank says Hi:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在Google Chrome中测试。我将刷新标签1，当我这样做时，你可以看到我们的两条消息，欢迎来到聊天应用显示出来，Frank说Hi：
- en: '![](img/8ad84232-822d-4f69-9d40-42a821b92550.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ad84232-822d-4f69-9d40-42a821b92550.png)'
- en: 'Now Welcome to the chat app should show up. The Frank Hi message is coming
    from `socket.emit` inside `index.js`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在欢迎来到聊天应用应该显示出来。Frank Hi消息来自`index.js`中的`socket.emit`：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can actually go ahead and remove that, we no longer need to automatically
    emit messages since we have a `form` set up to get that done for us. Once again
    we can save the file, refresh the browser and this time around we have a nice
    little setup, Welcome to the chat app:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以去掉它，我们不再需要自动发送消息，因为我们已经设置了一个`form`来完成这项工作。再次保存文件，刷新浏览器，这一次我们有了一个很好的设置，欢迎来到聊天应用：
- en: '![](img/4b6c4e36-7bc6-439f-b553-469dbbe85937.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b6c4e36-7bc6-439f-b553-469dbbe85937.png)'
- en: 'I''m going to do the same thing for our second tab. This time around we get
    Welcome to the chat app and in the first tab we get New user joined; this is fantastic:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我将为我们的第二个标签做同样的事情。这一次我们会得到欢迎来到聊天应用，在第一个标签中我们会得到新用户加入；这太棒了：
- en: '![](img/2c0342a2-a143-475b-9cd2-ab6b3bd8a2f6.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c0342a2-a143-475b-9cd2-ab6b3bd8a2f6.png)'
- en: 'Now the true test is going to be to send a message from one tab to the other,
    `This should go to tab 2`. I''m going to Send this off, and when I click on this
    button, it''s going to emit the event that''s going to go to the server, and the
    server is going to send it to everyone connected:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正的测试将是从一个标签发送消息到另一个标签，“这应该发送到标签2”。我将发送这条消息，当我点击这个按钮时，它将触发事件发送到服务器，服务器将把它发送给所有连接的人：
- en: '![](img/5df3ee7d-73a7-4064-b55c-7b55a44b986e.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5df3ee7d-73a7-4064-b55c-7b55a44b986e.png)'
- en: 'Here, I can see This should go to tab 2 renders, and over inside my second
    tab we get the message as well:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我可以看到“This should go to tab 2”被渲染出来，在我的第二个标签中也收到了这条消息：
- en: '![](img/2bf72bc9-0838-4109-aa72-b64cfd615bf2.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bf72bc9-0838-4109-aa72-b64cfd615bf2.png)'
- en: Now we're not quite done with the UI or the actual user experience; custom names
    and timestamps are coming up, but we do have a fantastic start. We now have a
    form where we can submit messages and we can see all the incoming messages inside
    the browser, which means we do not need to do anything in the Developer Tools
    anymore in terms of emitting or reading our messages. That is it for this one,
    let's go ahead and wrap things up by making a commit now that we have some working
    changes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的UI或实际用户体验还没有完成；自定义名称和时间戳即将到来，但我们已经有了一个很棒的开始。现在我们有一个表单，我们可以提交消息，并且我们可以在浏览器中看到所有传入的消息，这意味着我们不需要在开发者工具中再做任何关于发送或阅读消息的工作。就是这样，让我们继续通过做出一些工作变更来做出提交。
- en: Making a commit for the message form
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为消息表单做出提交
- en: 'I''m going to shut down the server, clear the output, and run `git status`
    so we can double-check all our changes; everything looks good here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我将关闭服务器，清除输出，并运行`git status`，以便我们可以仔细检查所有的更改；一切看起来都很好：
- en: '![](img/1c246efa-4f88-4d88-bec4-17b468d7a292.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c246efa-4f88-4d88-bec4-17b468d7a292.png)'
- en: 'I''m going to use `git add` to add all of the files, including my untracked
    jQuery file to the repo. Then I use `git commit` to make the `commit`. I''m going
    to use the `-m` flag here, and a good message for this one would be `Add form
    for messages and show incoming messages in browser`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`git add`命令将所有文件添加到仓库中，包括我的未跟踪的jQuery文件。然后我使用`git commit`进行`commit`。我将在这里使用`-m`标志，这次的好消息是`添加消息表单并在浏览器中显示传入消息`：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once we have this in place, we can go ahead and `push` this up to GitHub. I
    am going to take a moment to deploy to Heroku now that we have something real,
    visible, and tangible to use; `git push heroku master` is going to get that done:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这一步，我们就可以将其`push`到GitHub上。现在我们有了一些真实的、可见的、有形的东西可以使用，我要花一点时间部署到Heroku，`git
    push heroku master`就可以搞定：
- en: '![](img/bf7f1ecf-765a-48f4-a2e3-e344e1b27626.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf7f1ecf-765a-48f4-a2e3-e344e1b27626.png)'
- en: Once this is up, we'll be able to visit it in the browser. As you can see over
    inside my console, `Socket.io` is trying to reconnect to the server. Unfortunately,
    we're not going to be bringing it back up so it's going to try a little longer.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个就绪，我们就可以在浏览器中访问它。正如你在我的控制台中看到的，`Socket.io`正在尝试重新连接到服务器。不幸的是，我们不会再次将其带回来，所以它会尝试更长时间。
- en: Here we are, we're verifying the deploy and everything is up and running. You
    can either run `heroku open` or copy the URL directly. I'm going to go ahead and
    close my two localhost tabs and open up the actual Heroku app.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里，正在验证部署，一切都正常运行。你可以运行`heroku open`或直接复制URL。我将关闭我的两个本地主机标签，然后打开实际的Heroku应用。
- en: 'Right here, we do get our Welcome to the chat app message and we do get our
    form; everything looks good so far. I''m going to go ahead and open up a different
    browser like Safari. I''m going to go to the chat app as well, and we''re going
    to bring these windows side by side. Over inside Safari I''m going to type a little
    message, `This is live on Heroku`, click on Send or hit the *enter* key, and instantly
    it shows up in the other browser in the other tab. This is because our live socket
    server is transmitting this data:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了欢迎来到聊天应用的消息，我们也得到了我们的表单；一切看起来都很好。我将继续打开另一个浏览器，比如Safari。我也会去聊天应用，然后把这些窗口并排放在一起。在Safari中，我会输入一条小消息，“这是在Heroku上实时的”，点击发送或按下*enter*键，它立即出现在另一个浏览器的另一个标签中。这是因为我们的实时socket服务器正在传输这些数据：
- en: '![](img/54ddfc39-b0a9-40c7-9e68-8f8d39890d1c.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54ddfc39-b0a9-40c7-9e68-8f8d39890d1c.png)'
- en: This could happen between any computer in the world, you do not need to be on
    my machine since we're using a real Heroku URL. Now that everything is working
    on Heroku, we are done.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能发生在世界上的任何一台计算机上，你不需要在我的机器上，因为我们使用的是真实的Heroku URL。现在在Heroku上一切都正常了，我们完成了。
- en: Geolocation
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理位置
- en: In this section, you're going to start part one of a two-part series on geolocation.
    Instead of just sending text back and forth, we're also going to set it up so
    I can beam my actual coordinates, my longitude and latitude, to everyone else
    connected to the chat app. Then we can render a link and that link could go wherever
    we like; in our case, we're going to set it up to pull up a Google Maps page where
    the actual location of the user who sent their location is marked.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将开始地理位置的两部分系列的第一部分。我们不仅仅是互发文本，还将设置它，以便我可以将我的实际坐标，即我的经度和纬度，发送给连接到聊天应用程序的其他所有人。然后我们可以呈现一个链接，该链接可以指向任何我们喜欢的地方；在我们的情况下，我们将设置它以打开一个Google地图页面，其中标记了发送其位置的用户的实际位置。
- en: Now to actually fetch a user's location we're going to use the geolocation API,
    which is available in your client-side JavaScript, and it's actually a pretty
    well-supported API. It's available on all modern browsers, whether that's mobile
    or desktop, and the documentation can be found by Googling `geolocation api`,
    and looking for the MDN documentation page.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了实际获取用户的位置，我们将使用地理位置API，在客户端JavaScript中可用，并且实际上是一个非常受支持的API。它在所有现代浏览器上都可用，无论是移动设备还是桌面设备，可以通过谷歌搜索“地理位置API”找到文档，并查找MDN文档页面。
- en: 'The MDN Docs, or the Mozilla Developer Network, are my favorite docs for client-side
    technologies, such as your web APIs, your CSS and your HTML guidelines:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: MDN文档，或者Mozilla开发者网络，是我最喜欢的客户端技术文档，例如您的Web API、CSS和HTML指南：
- en: '![](img/90af9d91-82b8-4986-a747-86839916d9f0.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90af9d91-82b8-4986-a747-86839916d9f0.png)'
- en: Now as I mentioned this is a well supported feature, you can pretty much use
    it everywhere except for older versions of Internet Explorer and the Opera Mini
    browser. But all your major desktop and mobile browsers are going to support this,
    and if the browser is old, we will set up a little message to let them know their
    browser does not support geolocation. If you ever want to learn more about geolocation
    or explore features that we do not cover in this section, you can refer to this
    page, though we will be using most of the features geolocation has to offer.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我所提到的，这是一个受支持的功能，除了较旧版本的Internet Explorer和Opera Mini浏览器外，您几乎可以在任何地方使用它。但是，所有主要的桌面和移动浏览器都将支持此功能，如果浏览器过旧，我们将设置一个小消息来告诉他们他们的浏览器不支持地理位置。如果您想了解更多关于地理位置的信息，或者探索我们在本节中未涵盖的功能，您可以参考此页面，尽管我们将使用地理位置提供的大多数功能。
- en: Adding the Send Location button to the application
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将发送位置按钮添加到应用程序
- en: To get started what we're going to do is add a new button to our application.
    It's going to sit alongside of Send and it's going to say something like Send
    Location. When the user clicks that Send Location button we're going to use the
    geolocation API. Usually, this is going to require the user to confirm they want
    to share their location with this tab in the browser, that pop-up box is going
    to happen, it's going to be triggered by the browser, there's no way around that.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要做的是向我们的应用程序添加一个新按钮。它将与发送按钮并排，并且会显示类似“发送位置”的内容。当用户点击发送位置按钮时，我们将使用地理位置API。通常，这将需要用户确认他们是否要与浏览器中的此标签共享其位置，弹出框将会出现，这将由浏览器触发，没有其他方法可以绕过这一点。
- en: You're going to need to make sure the user actually wants to share their location.
    Once you have the coordinates you're going to emit an event, that's going to go
    to the server, the server is going to send it to all the other connected users
    and we're going to be able to render that information in a nice link.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保用户确实希望共享他们的位置。一旦您获得了坐标，您将发出一个事件，该事件将发送到服务器，服务器将将其发送给所有其他连接的用户，我们将能够以一个良好的链接呈现该信息。
- en: 'To kick things off we''re going to add that button, this is going to be the
    button that starts the entire process. Over inside Atom, inside `index.html`,
    we''re going to add a button just below our `form` tag. It''s going to be outside
    our existing form. We''re going to add the `button` tag, and we''re going to go
    ahead and give this an ID of `send-location`. Now as for the visible `button`
    text we can go ahead and use `Send``Location` as our string, and save the file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加该按钮，这将是启动整个过程的按钮。在Atom中的`index.html`中，我们将在我们现有的`form`标签下方添加一个按钮。它将位于我们现有的表单之外。我们将添加`button`标签，并为其分配`send-location`的ID。至于可见的`button`文本，我们可以使用`Send
    Location`作为我们的字符串，并保存文件：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we go ahead and refresh our app in the browser, we should now see we have
    our Send Location button showing up:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续在浏览器中刷新应用程序，现在应该会看到我们的发送位置按钮显示出来：
- en: '![](img/0ef04e95-11c7-460e-a0fd-903e4cbe19fd.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ef04e95-11c7-460e-a0fd-903e4cbe19fd.png)'
- en: We're going to fix all this later when we add the default styles, but for now
    this does get the job done.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将在添加默认样式时修复所有这些问题，但现在这确实完成了工作。
- en: Now clicking this button currently is not going to do anything, it's not tied
    to a `form` so it's not going to do any weird `form` submissions or page reloads.
    All we need to do is add a `click` listener to this button and we'll be able to
    run whatever code we like. In our case, we're going to run that geolocation code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，单击此按钮不会执行任何操作，它与`form`没有关联，因此不会执行任何奇怪的`form`提交或页面重新加载。我们只需要向此按钮添加一个`click`监听器，就可以运行任何我们喜欢的代码。在我们的情况下，我们将运行地理位置代码。
- en: Adding a click listener to the Send Location button
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给发送位置按钮添加点击监听器
- en: We are going to add a `click` listener, inside Atom, inside `index.js`, and
    we're going to add some code down near the bottom.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Atom中的`index.js`中添加一个`click`监听器，并在底部附近添加一些代码。
- en: 'Now the first thing I want to do is create a variable, and I''m going to call
    this variable `locationButton`; this is going to store our selector. This is the
    jQuery selector that targets the button we just created, because we''re going
    to need to reference it multiple times and storing it in a variable saves the
    need to make those calls again. We''re going to call `jQuery` like we''ve done
    for our other selectors, passing in one argument, a string, and we''re selecting
    something by ID, which means we got to start with that hash sign (`#`), and the
    actual ID is `send-location`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我想做的第一件事是创建一个变量，我将把这个变量称为`locationButton`；这将存储我们的选择器。这是一个jQuery选择器，它指向我们刚刚创建的按钮，因为我们需要多次引用它，并且将它存储在一个变量中可以节省再次调用的需要。我们将像我们为其他选择器所做的那样调用`jQuery`，传入一个参数，一个字符串，我们通过ID选择了某个东西，这意味着我们必须以`#`开始，并且实际的ID是`send-location`：
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now that we have this in place we can go ahead and do whatever we like. In
    our case, what we''re going to be doing is add a click event, and we want to do
    something when someone clicks that button. To get that done we''re going to go
    to `locationButton.on`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪，可以做任何我们喜欢的事情。在我们的情况下，我们要做的是添加一个点击事件，并且我们希望当有人点击按钮时做一些事情。为了完成这个目标，我们将转到`locationButton.on`：
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is identical to doing the `jQuery`, selecting the ID `send-location`, both
    of these are going to do the same thing. The benefit of the first solution is
    that we have a reusable variable,, which we are going to reference later on. Making
    two jQuery calls to the same selector, wastes time because it is going to require
    jQuery to manipulate the DOM, fetching that information, and that's expensive.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这与执行`jQuery`相同，选择ID`send-location`，这两者都会做同样的事情。第一个解决方案的好处是我们有一个可重用的变量，以后我们会引用它。对同一个选择器进行两次jQuery调用会浪费时间，因为它需要jQuery来操作DOM，获取信息，这是很昂贵的。
- en: '`locationButton.on` is going to be our event listener. We''re listening for
    the `click` event, inside quotes for the first argument, and the second argument
    as always is going to be our `function`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`locationButton.on`将是我们的事件监听器。我们正在监听`click`事件，第一个参数是引号内的`click`事件，第二个参数像往常一样将是我们的`function`：'
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This function is going to get called when someone clicks the button.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人点击按钮时，这个函数将被调用。
- en: Checking access to the geolocation API
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查对地理位置API的访问权限
- en: For now all we're going to do is check if the user has access to that geolocation
    API. If they don't we want to go ahead and print a message.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的只是检查用户是否有访问地理位置API的权限。如果没有，我们希望继续打印一条消息。
- en: 'We''re going to create an `if` statement. The geolocation API exists on `navigator.geolocation`,
    and we want to run some code if it doesn''t exist:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`if`语句。地理位置API存在于`navigator.geolocation`上，如果它不存在，我们想运行一些代码：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'So we''re going to flip it. If there is no geolocation object on navigator
    we want to do something. We''re going to use `return` to prevent the rest of the
    function from executing, and we''re going to call the `alert` function available
    in all browsers that pops up one of those default alert boxes that makes you click
    on OK:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们要翻转它。如果`navigator`上没有地理位置对象，我们要做一些事情。我们将使用`return`来防止函数的其余部分执行，并且我们将调用在所有浏览器中都可用的`alert`函数，弹出一个默认的警报框，让你点击`OK`：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We're going to use this as opposed to a fancier modal. If you are using something
    like Bootstrap or Foundation, you can implement one of their built-in tools.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个，而不是一个更复杂的模态框。如果你使用类似Bootstrap或Foundation的东西，你可以实现它们内置的工具。
- en: 'For now, though, we''re going to use `alert`, which takes just one argument
    (a string, your message) `Geolocation not supported by your browser`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，现在我们将使用`alert`，它只需要一个参数（一个字符串，你的消息）`您的浏览器不支持地理位置`：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now users who don't have support for this are going to see a little message,
    as opposed to wondering whether or not anything actually happened.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不支持此功能的用户将看到一条小消息，而不是想知道是否真的发生了什么。
- en: Fetching a user's position
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户的位置
- en: 'To actually fetch a user''s position we''re going to use a function available
    on geolocation. To access it we''ll add `navigator.geolocation.getCurrentPosition`
    inside the `locationButton.on` function next to the `if` statement. The `getCurrentPosition`
    function is a function that starts the process. It''s going to actively get the
    coordinates for the user. In this case, it''s going to find the coordinates based
    off of the browser, and this takes two functions. The first one is your `success`
    function, right here we can add our first callback. This is going to get called
    with the location information, we''re going to name this argument `position`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际获取用户的位置，我们将使用地理位置上可用的一个函数。为了访问它，我们将在`locationButton.on`函数中的`if`语句旁边添加`navigator.geolocation.getCurrentPosition`。`getCurrentPosition`函数是一个启动过程的函数。它将主动获取用户的坐标。在这种情况下，它将根据浏览器找到坐标，并且这需要两个函数。第一个是你的`success`函数，我们可以在这里添加我们的第一个回调。这将使用位置信息调用，我们将把这个参数命名为`position`：
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The second argument to `getCurrentPosition` is going to be our error handler
    if something goes wrong. We''re going to create a `function` and we''ll be alerting
    a message to the user when we''re not able to fetch the location using `alert`.
    Let''s go ahead and call `alert` a second time, printing a message like `Unable
    to fetch location`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCurrentPosition`的第二个参数将是我们的错误处理程序，如果出现问题。我们将创建一个`function`，当我们无法使用`alert`获取位置时，我们将向用户发出一条消息。让我们继续调用`alert`第二次，打印一条消息，比如`无法获取位置`：'
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is going to print `if` someone gets prompted to share their location with
    the browser but they click on Deny. We're going to say `Hey, we can't fetch the
    location if you don't give us that permission`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印`if`有人被提示与浏览器共享位置，但他们点击了拒绝。我们将说`嘿，如果你不给我们那个权限，我们就无法获取位置`。
- en: 'Now the only case left is the success case. This is where we''re going to `emit`
    the event. But before we do that, let''s go ahead and simply log it to the screen
    so we can take a peek at what is happening inside the `position` argument:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的情况是成功的情况。这是我们要“发出”事件的地方。但在这之前，让我们继续简单地将其记录到屏幕上，这样我们就可以窥探一下“位置”参数内部发生了什么：
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'I''m going to log this to the screen, our server is going to restart, and over
    inside Google Chrome we can open up the Developer Tools, refresh the page, and
    click on that Send Location button. Now this is going to work on desktop and mobile.
    Some mobile browsers are going to require you to be on HTTPS, which is something
    that we''re going to have set up for Heroku, as you know the Heroku URL is secure
    which means it''s not going to work on localhost. You can always test your mobile
    browsers by deploying the app to Heroku and running it there. For now, though,
    I will be able to click on Send Location. This is going to go ahead and start
    that process; the process can take up to a second:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个记录到屏幕上，我们的服务器将重新启动，在Google Chrome中，我们可以打开开发者工具，刷新页面，然后点击“发送位置”按钮。现在这将在桌面和移动设备上运行。一些移动浏览器可能需要您使用HTTPS，这是我们将为Heroku设置的内容，正如您所知，Heroku的URL是安全的，这意味着它在本地主机上不起作用。您可以通过将应用程序部署到Heroku并在那里运行来测试移动浏览器。不过，现在我将能够点击“发送位置”。这将继续进行该过程；该过程最多可能需要一秒钟：
- en: '![](img/95fc6021-4e94-4132-8aac-0c445c9736da.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95fc6021-4e94-4132-8aac-0c445c9736da.png)'
- en: Now as you can see I did get my geolocation position. But I was never prompted
    as to whether or not I wanted to share my location; that's because I've already
    given it permission. Over the top-right corner, I can go ahead and click on Clear
    these settings for future visits, this means that I'm going to need to reauthorize.
    If I refresh the page and click on Send Location again, you're going to see this
    little box, which is probably going to show up for you. You can either block it,
    if I block it it's going to print Unable to fetch location; or you can accept
    it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到，我确实获得了我的地理位置。但我从未被询问是否要共享我的位置；那是因为我已经获得了许可。在右上角，我可以点击“清除这些设置以供将来访问”，这意味着我需要重新授权。如果我刷新页面并再次点击“发送位置”，您将看到这个小框，这可能会出现在您的页面上。您可以选择阻止它，如果我阻止它，它将打印“无法获取位置”；或者您可以接受它。
- en: 'I''m going to clear those settings one more time, give the page a refresh,
    and this time I am going to accept the location sharing, And we''re going to get
    the geolocation printing out in the console:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我将再次清除这些设置，刷新页面，这次我将接受位置共享，然后我们将在控制台中打印出地理位置：
- en: '![](img/47a485e7-d9ed-43b7-aa3f-cfff1aabe748.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47a485e7-d9ed-43b7-aa3f-cfff1aabe748.png)'
- en: Now once we get it we can go ahead and dive in, the object itself is pretty
    simple, we have a timestamp of exactly when we fetched the data, this is useful
    if you're tracking a user over time, which we're not doing. We also have our coordinates,
    we have all sorts of properties we're not going to use like `accuracy`, `altitude`,
    which doesn't exist, and other related ones. We also have `speed` which is `null`.
    The only two we're ever going to use off this object is `latitude` and `longitude`,
    which do indeed exist.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一旦我们得到它，我们就可以继续深入，对象本身非常简单，我们有一个时间戳，精确记录了我们获取数据的时间，如果您要跟踪用户的活动，这将非常有用，但我们不需要。我们还有我们的坐标，还有一些我们不打算使用的属性，比如“准确度”，“高度”，这些都不存在，还有其他相关的属性。我们还有“速度”，它是“null”。我们将从这个对象中使用的唯一两个是“纬度”和“经度”，它们确实存在。
- en: This is the information we want to pass to the server so the server can send
    it to everybody else. This means we're going to go into the `position` object,
    go into the `coords` object, and grab those two.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要传递给服务器的信息，以便服务器可以将其发送给其他人。这意味着我们将进入“position”对象，进入“coords”对象，并获取这两个。
- en: Adding the coordinates object in the users position
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在用户位置中添加坐标对象
- en: 'Let''s go ahead and do that over inside Atom, we are going to call `socket.emit` and
    `emit` a brand new event, one we do not have registered yet. We''re going to call
    this one `createLocationMessage`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Atom中继续进行，我们将调用`socket.emit`并`emit`一个全新的事件，一个我们尚未注册的事件。我们将称之为`createLocationMessage`：
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `createLocationMessage` event is not going to take the standard text; instead,
    it''s going to take those `longitude` and `latitude` coordinates. We''re going
    to specify both of them starting with `latitude`; we want to set `latitude` equal
    to `position.coords.latitude`. This is the variable that we explored over inside
    of the console, and we''re going to do the same thing for `longitude`, setting
    it equal to `position.coords.longitude`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: “createLocationMessage”事件不会采用标准文本；相反，它将采用那些“经度”和“纬度”坐标。我们将指定它们两个，从“纬度”开始；我们要将“纬度”设置为“position.coords.latitude”。这是我们在控制台内探索的变量，我们将对“经度”做同样的操作，将其设置为“position.coords.longitude”：
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now that we have this in place we can actually go ahead and listen for this
    event over in the server, and when we get it what we're going to do is pass the
    above data along to all the connected users.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经做好了准备，我们实际上可以继续在服务器上监听这个事件，当我们收到它时，我们要做的是将上述数据传递给所有连接的用户。
- en: Passing coordinates data with the connected users
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将坐标数据传递给连接的用户
- en: Let's go ahead and do just that over inside `server.js`, registering a new event
    listener. I'm going to remove the old commented out broadcast call that's no longer
    needed in `createMessage`. Just below `createMessage`, we're going to call `socket.on`
    again, specifying a listener for this event, `createLocationMessage`, just as
    we defined it over inside `index.js`. Now we are using ES6 since we're in Node,
    which means we can go ahead and set up our arrow function. We're going to have
    one argument, this is going to be the `coords`, and we can go ahead and finish
    off the arrow function.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在`server.js`中注册一个新的事件监听器。我将删除旧的已注释掉的`broadcast`调用，因为在`createMessage`中不再需要。就在`createMessage`下面，我们将再次调用`socket.on`，指定一个监听器来监听这个事件`createLocationMessage`，就像我们在`index.js`中定义的那样。现在我们使用ES6，因为我们在Node中，这意味着我们可以设置箭头函数。我们将有一个参数，这将是`coords`，然后我们可以继续完成箭头函数。
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In here we''re going to be able to run whatever code we like. For the moment
    all we''re going to do is `emit` a `newMessage` event passing along the coordinates,
    although later in the chapter, we''ll be making this a lot nicer, setting up that
    URL for Google Maps. Right now, though, we''re going to call `io.emit`, `emit`
    a `newMessage` event, and provide the necessary data by calling `generateMessage`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将能够运行任何我们喜欢的代码。目前我们要做的只是通过调用`emit`一个`newMessage`事件传递坐标，尽管在本章的后面，我们将会做得更好，设置谷歌地图的URL。不过，现在我们要调用`io.emit`，`emit`一个`newMessage`事件，并通过调用`generateMessage`提供必要的数据：
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For the moment `generateMessage` is going to take some bogus username, I''m
    going to go ahead and type in `Admin`, and we are going to set the text, for now
    we''re simply going to set it equal to the coordinates. Let''s go ahead and use
    a template string to set that up. We''re going to first inject the `latitude`,
    which is available on `coords.latitude`, then we''re going to go ahead and add
    a comma, a space, and we''ll inject the `longitude`, `coords.longitude`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`generateMessage`将采用一些虚假的用户名，我将输入`管理员`，并且我们将设置文本，目前我们只是将其设置为坐标。让我们使用模板字符串来设置它。我们将首先注入`纬度`，它在`coords.latitude`上可用，然后我们将继续添加逗号、空格，然后我们将注入`经度`，`coords.longitude`：
- en: '[PRE68]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that we have this call in place the location information is going to get
    passed back and forth between the users, and we can go ahead and actually prove
    this.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了这个调用，位置信息将在用户之间传递，我们可以继续证明这一点。
- en: 'Over inside the browser I''m going to give this page a refresh, and I''m also
    going to open up a second tab. In this second tab I''m going to click on Send
    Location. It''s not going to prompt me if I want to share my location since I''ve
    already told it I do want to share my location with this tab. You can see we have
    our Admin message and we have our `latitude`, and the `longitude`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我将刷新此页面，并且我还将打开第二个标签页。在第二个标签页中，我将点击“发送位置”。它不会提示我是否要共享我的位置，因为我已经告诉它我要与这个标签页共享我的位置。您可以看到我们有我们的管理员消息和我们的`纬度`和`经度`：
- en: '![](img/c4cd2187-d6cf-48cd-a45d-11e04a1fdbce.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4cd2187-d6cf-48cd-a45d-11e04a1fdbce.png)'
- en: We also have it over inside the second tab. If I take this information we can
    actually Google it and prove that it is working as expected. Later in the chapter,
    we're going to be setting up a nice link so this information isn't visible; it'll
    be there but the user doesn't really need to know the coordinates, what they really
    want is a link to a map. That's what we're going to set up, but for now we can
    put this in Google, Google is going to show us exactly where it is and the coordinates
    are indeed correct. I am in Philadelphia, which means the location was correctly
    fetched for these localhost tabs.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在第二个标签页中有它。如果我拿到这些信息，我们实际上可以谷歌一下，证明它按预期工作。在本章的后面，我们将设置一个漂亮的链接，因此这些信息不可见；它会在那里，但用户实际上不需要知道坐标，他们真正想要的是地图的链接。这就是我们要设置的，但现在我们可以把这个放在谷歌上，谷歌会准确显示我们的位置，坐标确实是正确的。我在费城，这意味着这些本地主机标签的位置被正确获取。
- en: Rendering clickable link in place of text coordinates
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 呈现可点击链接，而不是文本坐标
- en: So far, we got the data flowing, and now we're going to make it a little more
    useful. Instead of rendering `latitude` and `longitude` information as text, we're
    going to render a clickable link. A user will be able to click that link; when
    they receive the location from someone else, it's going to bring them over to
    Google Maps and they'll be able to view exactly where the other user is. This
    is going to be much more useful than spitting out the text `latitude` and `longitude`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经让数据流动起来，现在我们要让它变得更有用。我们不再将“纬度”和“经度”信息呈现为文本，而是要呈现为可点击的链接。用户将能够点击该链接；当他们从他人那里收到位置时，它将把他们带到谷歌地图上，他们将能够准确查看其他用户的位置。这比简单输出文本“纬度”和“经度”要有用得多。
- en: Now in order to get that done we are going to need to tweak how we transmit
    the coordinate data. The way we send the data is still fine over inside `index.js`,
    we are still going to `emit`, `createLocationMessage`. But inside `server.js`
    instead of emitting a new message, we need to `emit` something else entirely.
    We're going to set up a new event called `newLocationMessage`, we're going to
    `emit` that, and then over inside `index.js` we'll write a handler for `newLocationMessage`
    similar to `newMessage` but distinctly different. Instead of rendering some text,
    it's going to help us render a link.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个，我们需要调整如何传输坐标数据。我们发送数据的方式在`index.js`中仍然可以，我们仍然会`emit`，`createLocationMessage`。但是在`server.js`中，我们不再需要发出新消息，而是需要完全发出其他内容。我们将设置一个名为`newLocationMessage`的新事件，我们将`emit`它，然后在`index.js`中，我们将编写一个处理程序`newLocationMessage`，类似于`newMessage`但有明显不同。它不会呈现一些文本，而是帮助我们呈现一个链接。
- en: Sorting out the URL structure
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整理URL结构
- en: Now in order to get started before we can do any of this we have to figure out
    exactly what sort of URL structure we're going to use to get that data, the `latitude`
    and `longitude` information, showing up correctly in Google Maps. And there's
    actually a pretty uniform way to set up the URL, which is going to make this really
    easy.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始之前，我们必须确切地弄清楚我们将使用什么样的URL结构来获取数据，`纬度`和`经度`信息，在Google地图中正确显示。实际上有一种非常统一的设置URL的方式，这将使得这个过程非常容易。
- en: 'To show you exactly what URL we''re going to be using, let''s go ahead and
    open up a new tab. The URL is going to go to `https://www.google.com/maps`. Now
    from here we are going to be providing a query parameter, and the query parameter
    will be specifying; it''s called `q`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示我们将要使用的确切URL，让我们继续打开一个新标签。URL将转到`https://www.google.com/maps`。现在从这里我们将提供一个查询参数，查询参数将指定；它被称为`q`：
- en: '![](img/8b1d69b0-0c11-4dd7-8938-7f9e30e4807b.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b1d69b0-0c11-4dd7-8938-7f9e30e4807b.png)'
- en: And it is going to expect the `latitude` and `longitude` to be the value separated
    by a comma. Now we actually have that here in the `localhost:3000` tab. Although
    there will be a little space between the comma, either way we can copy that value,
    head back over into the other tab, paste it in, and just remove the space.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 它将期望`纬度`和`经度`是由逗号分隔的值。现在我们实际上在`localhost:3000`标签中有这个。虽然逗号之间会有一点空间，但无论如何我们都可以复制该值，返回到另一个标签，粘贴进去，并删除空格。
- en: With this in place we now have a URL that we can use inside our application.
    Now when I hit *enter*, we are going to view a map at the correct location, but
    you'll notice the URL changes. That's perfectly fine; as long as we send the user
    to this URL, it doesn't really matter what it ends up becoming. I'm going to hit
    *enter*; you can see right away we are getting a Google Map, and as the page loads
    the URL is indeed going to change.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在有一个可以在我们的应用程序中使用的URL。现在当我按下*enter*，我们将在正确的位置看到地图，但您会注意到URL已经改变了。这完全没问题；只要我们将用户发送到这个URL，它最终变成什么并不重要。我要按下*enter*；您可以立即看到我们得到了一个谷歌地图，当页面加载时，URL确实会改变。
- en: Now we're looking at something completely different from what we typed in, but
    the actual pin, the red pin, it is correct within a couple of houses. Now with
    that knowledge we can generate a URL that follows that same format, spit that
    out inside the website, and we'll have that clickable link where someone can view
    the location of someone else.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到的与我们输入的完全不同，但实际的图钉，红色的图钉，它在几栋房子内是正确的。有了这个知识，我们可以生成一个遵循相同格式的URL，在网站内部输出它，我们将有一个可点击的链接，别人可以查看别人的位置。
- en: Emitting newLoactionMessage
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出newLoactionMessage
- en: 'To get started, let''s go ahead and move into Atom into `server.js`, and instead
    of emitting a `newMessage` event we''re going to emit `newLocationMessage`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们继续进入Atom到`server.js`，而不是发出`newMessage`事件，我们将发出`newLocationMessage`：
- en: '[PRE69]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now we don't have a handler for that over in `index.js`, but that's perfectly
    fine, we'll set that up later in the section. Now we are going to need to change
    the data we send across too. Currently, we're sending the plain text data; what
    we want to do is generate a URL. We're actually going to create a completely separate
    function for generating a location message, and we'll call it `generateLocationMessage`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`index.js`中没有处理程序，但这完全没问题，我们稍后会在本节中设置。现在我们还需要改变我们发送的数据。目前，我们发送的是纯文本数据；我们想要生成一个URL。我们实际上将创建一个完全独立的函数来生成位置消息，并且我们将称之为`generateLocationMessage`。
- en: '[PRE70]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now this function is going to take some arguments to generate the data; Just
    like we have for the `generateMessage` function, we're going to start with the
    from name and then move on to the data specific to this function, that's going
    to be the `latitude` and `longitude`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个函数将需要一些参数来生成数据；就像我们为`generateMessage`函数所做的那样，我们将从名称开始，然后转到这个函数特定的数据，那将是`纬度`和`经度`。
- en: 'I''m going to remove our template string and we''re going to pass in the raw
    values. The first value will be `coords.latitude` and the second one will be `coords.longitude`.
    Now it''s the second coordinate value but it is indeed the third argument:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我要删除我们的模板字符串，我们将传入原始值。第一个值将是`coords.latitude`，第二个值将是`coords.longitude`。现在是第二个坐标值，但确实是第三个参数：
- en: '[PRE71]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'With this arguments list set up, we can actually go ahead and define `generateLocation`.
    We''ll be able to export it, require it in this file and then everything is going
    to work as expected. Let''s go ahead and load it in up top before we actually
    add it to the message file. We are going to load `generateLocationMessage` alongside
    `generateMessage`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个参数列表设置，我们实际上可以继续定义`generateLocation`。我们将能够导出它，在这个文件中要求它，然后一切都会按预期工作。让我们继续在添加到消息文件之前在顶部加载它。我们将同时加载`generateLocationMessage`和`generateMessage`：
- en: '[PRE72]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Let's save `server.js` and move into our `message` file.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存`server.js`并进入我们的`message`文件。
- en: Adding generateLocationMessage in the message.js file
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在message.js文件中添加generateLocationMessage
- en: Now the function that we're about to create is going to look really similar
    to this, we're going to take some data in and we're going to return an object.
    The big difference is that we'll be generating that URL as well. Instead of `from`,
    `text`, and `createdAt`, we're going to have `from`, `URL`, and `createdAt`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们即将创建的函数将看起来非常类似于这个，我们将输入一些数据，然后返回一个对象。最大的区别是我们也将生成该URL。而不是`from`，`text`和`createdAt`，我们将有`from`，`URL`和`createdAt`。
- en: 'We can make a new variable, we can call this variable `generateLocationMessage`,
    and we can go ahead and set it equal to a function that takes those three arguments
    `from`, `latitude`, and `longitude`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新变量，我们可以称这个变量为`generateLocationMessage`，然后我们可以设置它等于一个接受这三个参数`from`，`latitude`和`longitude`的函数：
- en: '[PRE73]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now we can finish off the arrow function (`=>`) adding the arrow and our curly
    braces, and inside of here we can get started by returning the empty object:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以完成箭头函数(`=>`)添加箭头和我们的花括号，里面我们可以开始通过返回空对象：
- en: '[PRE74]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we''re going to set up those three properties from property, the URL property
    and `createdAt`. Here `from` is going to be easy; just like we do for `generateMessage`,
    we''re simply going to reference the argument. The URL one is going to be a little
    trickier; for now we''ll set that equal to an empty template string, we''ll come
    back to it in a moment. And finally, `createdAt`, we''ve done that before; we''re
    going to set it equal to a timestamp by getting a `new Date` and calling `getTime`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置来自属性的这三个属性，URL属性和`createdAt`。这里`from`将很容易；就像我们为`generateMessage`所做的那样，我们只需引用参数。URL将会有点棘手；现在我们将把它设置为一个空的模板字符串，我们稍后会回来。最后，`createdAt`，我们以前做过；我们将把它设置为通过获取`new
    Date`并调用`getTime`来获得时间戳：
- en: '[PRE75]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now for the URL we''re going to need to use that exact same format that we
    just typed into the browser, [https://www.google.com/maps](https://www.google.com/maps).
    Then we''ve got to set up our query parameter, adding our question mark and our
    `q` param, setting it equal to the `latitude` followed by a comma, and followed
    by the `longitude`. We''re going to inject the `latitude`, add a comma, and then
    inject the `longitude`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于URL，我们需要使用刚刚在浏览器中输入的完全相同的格式，[https://www.google.com/maps](https://www.google.com/maps)。然后我们必须设置我们的查询参数，添加我们的问号和`q`参数，将其设置为`latitude`后跟一个逗号，然后是`longitude`。我们将注入`latitude`，添加一个逗号，然后注入`longitude`：
- en: '[PRE76]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now we''re done! `generateLocationMessage` is going to work as expected, although
    you will be writing a test case a little later on. For now we can simply export
    it. I''m going to export `generateLocationMessage`, like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了！`generateLocationMessage`将按预期工作，尽管您稍后将编写一个测试用例。现在我们可以简单地导出它。我将导出`generateLocationMessage`，就像这样：
- en: '[PRE77]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now the data is going to flow from the client by calling `emit`, passing in
    `generateLocationMessage`. We''re going to get the `latitude` and `longitude`.
    Over inside the `server.js`, we are then going to `emit` the `newLocationMessage`
    event with the object that we just defined over inside `generateLocationMessage`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据将通过调用`emit`从客户端流出，传入`generateLocationMessage`。我们将获取`latitude`和`longitude`。在`server.js`中，我们将使用我们刚刚在`generateLocationMessage`中定义的对象`emit`
    `newLocationMessage`事件：
- en: '[PRE78]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Adding an event listener for newLocationMessage
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`newLocationMessage`添加事件监听器
- en: 'The last piece to the puzzle to really get all this working is to add an event
    listener for the `newLocationMessage` event. In `index.js` we can call `socket.on`
    to do just that. We''re going to pass in our two arguments. First up is the event
    name we want to listen for, `newLocationMessage`, and the second and final argument
    is our `function`. This is going to get called with the `message` information
    once the event occurs:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后一块拼图真正使所有这些工作起来的是为`newLocationMessage`事件添加一个事件监听器。在`index.js`中，我们可以调用`socket.on`来做到这一点。我们将传入我们的两个参数。首先是我们想要监听的事件名称`newLocationMessage`，第二个和最后一个参数是我们的`function`。一旦事件发生，这将被调用与`message`信息：
- en: '[PRE79]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now that we have this, we can go ahead and start generating the DOM elements
    that we want to spit out to the user, and just like we did above, we're going
    to make a list item and we're going to add our anchor tag, our link inside of
    it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，我们可以开始生成我们想要输出给用户的DOM元素，就像我们上面做的一样，我们将制作一个列表项，并在其中添加我们的锚标签，我们的链接。
- en: 'We''re going to make a variable called `list item` and we''re going to make
    a new element using `jQuery`. As that first argument we''re going to pass in our
    string and we are going to go ahead and set it equal to the list item:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`list item`的变量，并使用`jQuery`创建一个新元素。作为第一个参数，我们将传入我们的字符串，并将其设置为列表项：
- en: '[PRE80]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next up we can go ahead and create the second element we''re going to need.
    I''m going to make a variable, call this variable `a` for the anchor tag, and
    set it equal to the return value once again to a call to `jQuery`. This time around
    we''re going to create the anchor tag. Now the anchor tag uses the `a` tag, and
    the contents inside of the tag, that''s the link text; in our case, we''re going
    to go with `My current location`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以继续创建我们需要的第二个元素。我将创建一个变量，将这个变量称为`a`，用返回值再次设置为对`jQuery`的调用。这一次我们将创建锚标签。现在锚标签使用`a`标签，标签内的内容，那就是链接文本；在我们的情况下，我们将选择`My
    current location`：
- en: '[PRE81]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we are going to be specifying one attribute on the anchor tag. This is
    going to be a non-dynamic attribute, meaning it''s not going to come from the
    message object, this one is going to be called `target`, and we''re going to set
    `target` equal to `" _blank"`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在锚标签上指定一个属性。这将是一个非动态属性，意味着它不会来自消息对象，这个将被称为`target`，我们将把`target`设置为`"_blank"`：
- en: '[PRE82]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When you set target equal to `_blank`, it tells the browser to open up the
    URL in a new tab as opposed to redirecting the current tab. If we redirected the
    current tab, I''d get kicked out of the chatroom. If I clicked one of the links
    with the target set to `blank`, we''ll simply open up a new tab to view the Google
    Maps information:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将目标设置为`_blank`时，它告诉浏览器在新标签页中打开URL，而不是重定向当前标签页。如果我们重定向当前标签页，我将被踢出聊天室。如果我点击了其中一个目标设置为`blank`的链接，我们将简单地打开一个新标签页来查看Google地图信息：
- en: '[PRE83]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next up, we''re going to go ahead and set some properties on these attributes.
    We''re going to set the text using `li.text`. This is going to let us set the
    person''s name as well as that colon. Right inside template strings, we are going
    to inject the value `message.from`. After that value, we''re going to add a colon
    and a space:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置这些属性的一些属性。我们将使用`li.text`设置文本。这将让我们设置人的名字以及冒号。在模板字符串中，我们将注入值`message.from`。在该值之后，我们将添加一个冒号和一个空格：
- en: '[PRE84]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next up, we''re going to go ahead and update our anchor tag, `a.attr`. You
    can set and fetch attributes on your jQuery-selected elements using this method.
    If you provide one argument, like `target`, it fetches the value, in which case
    it would return the string `_blank`. If you specify two arguments, it actually
    sets the value. Here, we can set the `href` value equal to our URL, which we have
    under `message.url`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续更新我们的锚标签，`a.attr`。你可以使用这种方法在你选择的jQuery元素上设置和获取属性。如果你提供一个参数，比如`target`，它会获取值，这种情况下它会返回字符串`_blank`。如果你指定两个参数，它实际上会设置值。在这里，我们可以将`href`的值设置为我们在`message.url`下的URL：
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now you'll notice for all these dynamic values, I'm not simply adding them in
    template strings. Instead, I'm using these safe methods like `li.text` and `a.attribute`.
    This prevents any malicious behavior; if someone tries to inject HTML, they shouldn't
    be injecting using this code.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会注意到，对于所有这些动态值，我不是简单地将它们添加到模板字符串中。相反，我使用这些安全方法，比如`li.text`和`a.attribute`。这可以防止任何恶意行为；如果有人试图注入HTML，他们不应该使用这段代码进行注入。
- en: 'With this in place we can now go ahead and append the anchor tag to the end
    of the list item, which is going to add it after the text we just set using `li.append`,
    and we''re going to append the anchor tag. And now we can go ahead and add all
    of this to the DOM using the exact same statement in case of `newMessage` event
    listener. I''m going to copy and paste it in the `newLocagtionMesaage` event listener:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以将锚标签附加到列表项的末尾，这将在我们使用`li.append`设置文本后添加它，并且我们将附加锚标签。现在我们可以使用完全相同的语句将所有这些添加到DOM中，以便在`newLocagtionMesaage`事件监听器中进行复制和粘贴：
- en: '[PRE86]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: With this in place we are done. Now I'm going to save `index.js` and restart
    things over in the browser. We made quite a few changes so it's alright if you
    had a few typos; as long as you're able to track them down it's no big deal.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了。现在我要保存`index.js`并在浏览器中重新启动。我们做了很多改动，所以如果你有一些拼写错误也没关系；只要你能找到它们，就没什么大不了的。
- en: 'I''m going to refresh both of my tabs over inside Chrome; this is going to
    get the new connections up and running using the latest client-side code, and
    to kick things off I''m going to send a simple message from the second tab to
    the first tab. It''s showing up here in the second tab, and if I go over to the
    first tab we see User: test. Now I can click on Send Location, this is going to
    take about one to three seconds to actually get the location. Then it''s going
    to go through the `Socket.io` chain and what do we get? We get the link My current
    location showing up for user one:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在Chrome浏览器中刷新我的两个标签页；这将使用最新的客户端代码启动新的连接，并开始发送一个简单的消息从第二个标签到第一个标签。它在第二个标签中显示出来，如果我切换到第一个标签，我们会看到用户：测试。现在我可以点击“发送位置”，这将花费一到三秒钟来获取位置。然后它将通过`Socket.io`链，我们得到了什么？我们得到了链接“我的当前位置”显示给用户一：
- en: '![](img/d5a7b4c9-9e97-44e3-a1c2-421e7aac51f2.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5a7b4c9-9e97-44e3-a1c2-421e7aac51f2.png)'
- en: And for user two as well. Now if I click on that link, it should open up a brand
    new tab with the proper URL, `latitude`, and `longitude` information rendered
    in it.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户二也是一样。现在如果我点击那个链接，它应该在一个全新的标签页中打开，里面包含正确的URL、`纬度`和`经度`信息。
- en: Right here, we have the location for the user who clicked that Send Location
    button. With this in place, we have a fantastic geolocation feature. All you do
    is you click on the button; it fetches your current location no matter where you
    are, and it renders a clickable link so anyone else can view it inside Google
    Maps. Now before we go, I would like you to add a single test case for that brand
    new `generateLocationMessage` function.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这里，我们有了点击“发送位置”按钮的用户的位置。有了这个，我们有了一个很棒的地理位置功能。你所要做的就是点击按钮；它会获取你当前的位置，无论你在哪里，然后渲染一个可点击的链接，这样任何其他人都可以在Google地图中查看它。现在在我们离开之前，我希望你为这个全新的`generateLocationMessage`函数添加一个单独的测试用例。
- en: Adding test case for generateLocationMessage
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`generateLocationMessage`添加测试用例
- en: 'Over inside the Terminal, I can shut down the server and use `clear` to clear
    the output. If I run our test suite using `npm test`, we see that we have our
    one test and it''s passing:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我可以关闭服务器并使用`clear`来清除输出。如果我使用`npm test`运行我们的测试套件，我们会看到我们有一个测试，并且它通过了：
- en: '![](img/da8ce85e-06f6-43db-8b43-970298c45298.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da8ce85e-06f6-43db-8b43-970298c45298.png)'
- en: Your job is going to be to add a second test case over inside of `message.test.js`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作是在`message.test.js`中添加第二个测试用例。
- en: 'We''ll get started together. Right here, we''re going to add a `describe` block,
    describe the `generateLocationMessage` function, and you''re going to be responsible
    for adding a test case inside of the callback:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一起开始。就在这里，我们将添加一个`describe`块，描述`generateLocationMessage`函数，你将负责在回调函数内添加一个测试用例：
- en: '[PRE87]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In here, you''re going to call `it (''should generate correct location object'')`.
    Next up, we can go ahead and add our function, this is going to be a synchronous
    test so there is no need to add the done argument:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将调用`it ('should generate correct location object')`。接下来，我们可以继续添加我们的函数，这将是一个同步测试，所以不需要添加`done`参数：
- en: '[PRE88]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now, we are going to write a test case pretty similar to one for `generateMessage`
    event, although instead of passing in `from` and `text`, you're going to pass
    in `from`, `latitude`, and `longitude`. Then you're going to make some assertions
    about the values you get back. Then we're going to run the test case and make
    sure everything passes over inside the Terminal.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个与`generateMessage`事件非常相似的测试用例，尽管不是传递`from`和`text`，而是传递`from`、`latitude`和`longitude`。然后你将对返回的值进行一些断言。然后我们将运行测试用例，确保一切都通过了终端。
- en: Adding variables for the test case
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试用例添加变量
- en: 'To get started I''m going to make two variables. I''m going to make a `from`
    variable and I''ll set that equal to something like `Deb`. Then we can go ahead
    and create a `latitude` variable, I''m going to set that equal to `15`. And we
    can go ahead and create a variable `longitude` setting that equal to something
    like `19`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将创建两个变量。我将创建一个`from`变量，并将其设置为`Deb`之类的内容。然后我们可以继续创建一个`latitude`变量，我将其设置为`15`。然后我们可以创建一个`longitude`变量，将其设置为`19`之类的内容：
- en: '[PRE89]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then I can go ahead and finally create a `url` variable. The `url` variable
    is going to be the final result, the URL I would expect to get back. Now that
    URL is going to be inside of quotes [https://www.google.com/maps](https://www.google.com/maps),
    and then we''re going to add the appropriate query parameter given the information
    we''re going to pass in. If the latitude is `15`, we would expect `15` after the
    equal sign, and if the longitude is `19` after the comma, we would expect `19`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将最终创建一个`url`变量。`url`变量将是最终结果，我期望得到的URL。现在该URL将在引号内[https://www.google.com/maps](https://www.google.com/maps)，然后我们将根据我们要传入的信息添加适当的查询参数。如果纬度是`15`，我们期望在等号后得到`15`，如果经度是`19`，我们期望在逗号后得到`19`：
- en: '[PRE90]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now that we have that in place we can actually go ahead and call our function
    storing the response. I''m going to make a variable called `message`, then we''re
    going to go ahead and call `generateLocationMessage`, which currently isn''t required,
    we can do that in just a second. And we''re going to pass in our three arguments
    `from`, `latitude`, and `longitude`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了，我们可以调用我们的函数存储响应。我将创建一个名为`message`的变量，然后我们将调用`generateLocationMessage`，目前不需要，我们可以在下一秒钟内完成。然后我们将传入我们的三个参数`from`，`latitude`和`longitude`：
- en: '[PRE91]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now let''s go ahead and also pull off `generateLocationMessage` along with
    `generateMessage`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续并且也执行`generateLocationMessage`和`generateMessage`：
- en: '[PRE92]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now the only thing left to do is make our assertions.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的事情就是进行我们的断言。
- en: Making assertion for generateLocationMessage
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`generateLocationMessage`进行断言
- en: 'We''re going to start much the same way. I''m actually going to copy these
    two lines from `generateMessage` to the `generateLocationMessage` test case:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以类似的方式开始。我实际上要将这两行从`generateMessage`复制到`generateLocationMessage`的测试用例中：
- en: '[PRE93]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We''re expecting the `message.createdAt` property to be a number which it should
    be, then we''re expecting message to include a `from` property equal to `Deb`,
    and we''re going to expect it to have a `url` property equal to the `url` string
    we defined:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望`message.createdAt`属性是一个数字，它应该是，然后我们期望消息包含一个`from`属性等于`Deb`，我们期望它有一个`url`属性等于我们定义的`url`字符串：
- en: '[PRE94]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If both of these assertions pass then we know the object returned from `generateLocationMessage`
    is correct.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个断言都通过了，那么我们就知道从`generateLocationMessage`返回的对象是正确的。
- en: Running the test case for generateLocationMessage
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行`generateLocationMessage`的测试用例
- en: 'I''m going to rerun the test suite over inside the Terminal, and everything
    should work as expected:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在终端中重新运行测试套件，一切都应该如预期般工作：
- en: '![](img/21812fff-2637-4f3a-8b45-0be53bdc281f.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21812fff-2637-4f3a-8b45-0be53bdc281f.png)'
- en: 'And that''s it for this one! We have geolocation all set up, we have our link
    rendered, we are in great shape to continue on. I''m going to go ahead and add
    a `commit` over inside the Terminal. I''m going to run the `clear` command to
    clear the `Terminal` output, then we''ll run `git status` to see all our changed
    files and we can use `git commit` with the `-am` flag to add a message for this
    one, `Add geolocation support via geolocation api`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样了！我们已经设置好了地理位置，我们的链接已经呈现，我们可以继续进行。我将在终端中添加一个`commit`。我将运行`clear`命令来清除`Terminal`输出，然后我们将运行`git
    status`来查看所有更改的文件，然后我们可以使用`git commit`和`-am`标志为此添加一条消息，`Add geolocation support
    via geolocation api`：
- en: '[PRE95]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: I'm going to go ahead and commit this and push it up to GitHub, and we can also
    take a quick moment to deploy this to Heroku as well using `git push heroku master`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续提交并将其推送到GitHub，并且我们还可以花一点时间将其部署到Heroku，使用`git push heroku master`。
- en: This is going to deploy our latest code which has geolocation stuff built in.
    We'll be able to run this, and this code is going to run on things like the Chrome
    mobile browser because we'll be on HTTPS. Google Chrome's browser on mobile and
    other mobile browsers have pretty strict security guidelines as to when they'll
    send geolocation information. It is going to need to be over an HTTPS connection,
    which is exactly what we have here. I'm going to open up our Heroku app in a few
    tabs. We'll open it up in tab one and we'll also open it up in a second tab. I'm
    going to click on that Send Location button. I do need to approve this since it's
    a different URL, yes I do want them to be able to use my location. It's going
    to grab the location, send it off, and the first tab gets the link. I click on
    the link and hopefully we get the same spot.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这将部署我们最新的代码，其中包含地理位置信息。我们将能够运行此代码，因为我们将在HTTPS上运行，这将在Chrome移动浏览器等上运行。Google Chrome的移动浏览器和其他移动浏览器对何时发送地理位置信息有相当严格的安全准则。它需要通过HTTPS连接，这正是我们现在所拥有的。我将在几个标签中打开我们的Heroku应用程序。我们将在标签一中打开它，然后在第二个标签中也打开它。我将点击“发送位置”按钮。我需要批准这一点，因为它是不同的URL，是的，我希望他们能够使用我的位置。它将获取位置，发送位置，第一个标签获取链接。我点击链接，希望我们得到相同的位置。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we worked on generating text and location messages. We looked
    into generating the `newMessage` object and then writing a test case for it. Then,
    we learned about how to use event acknowledgments. Then we added the message form
    field and rendered an input field and a button to the screen. We also discussed
    the concept of jQuery and used that to select and create incoming message elements.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们致力于生成文本和位置消息。我们研究了生成`newMessage`对象，然后为其编写了一个测试用例。然后，我们学习了如何使用事件确认。然后我们添加了消息表单字段，并在屏幕上呈现了一个输入字段和一个按钮。我们还讨论了jQuery的概念，并使用它来选择和创建传入消息元素。
- en: In the geoloaction section, we gave a new button to the user. This new button
    allow the users to send their location. We set up a `click` listener for that
    Send Location button, which means every time a user clicks it, we do something
    as per their access to geoloaction API. If they do not have access to the geolocation
    API, we simply print a message. If they do have access we try to fetch the location.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在地理位置部分，我们为用户提供了一个新按钮。这个新按钮允许用户发送他们的位置。我们为发送位置按钮设置了一个`click`监听器，这意味着每当用户点击它时，我们会根据他们对地理位置API的访问执行一些操作。如果他们没有访问地理位置API，我们只是打印一条消息。如果他们有访问权限，我们会尝试获取位置。
- en: In the next chapter, we'll look into styling our chat page and make it look
    more like a real web app.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究如何为我们的聊天页面设置样式，使其看起来更像一个真正的网络应用程序。
