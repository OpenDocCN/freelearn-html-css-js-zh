- en: Building Authentication with passport.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用passport.js构建身份验证
- en: Authentication is a vital part of any application. Authentication is a way to
    secure the applications we build. Every application needs some kind of mechanism
    for authentication. It helps us to identify the users making requests to the application
    server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是任何应用的重要部分。身份验证是保护我们构建的应用程序的一种方式。每个应用程序都需要某种身份验证机制。它帮助我们识别向应用服务器发出请求的用户。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating a login and a register page
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建登录和注册页面
- en: Installing and configuring `passport.js`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置`passport.js`
- en: Learning more about the `passport.js` strategy, that is, the **JSON Web Token**
    (**JWT**) strategy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习更多关于`passport.js`策略，即**JSON Web Token**（**JWT**）策略
- en: Learn more about `passport.js` Local Strategy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于`passport.js`本地策略
- en: Creating necessary endpoints in the application server to handle register and
    login requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用服务器中创建必要的端点来处理注册和登录请求
- en: We can build the user authentication by ourselves. However, it adds a lot of
    configuration and lot of headaches. `passport.js` is a package that allows us
    to configure authentication efficiently, taking a very small amount of time. If
    you want to learn and develop all by yourself, I encourage you to do so. That
    will give you more insights into how everything works. However, for this book,
    we will use this awesome tool called `passport.js`, which is very easy to integrate
    and learn.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自己构建用户身份验证。然而，这会增加很多配置和很多麻烦。`passport.js`是一个允许我们高效配置身份验证的包，只需要很少的时间。如果你想自己学习和开发，我鼓励你这样做。这将让你更深入地了解一切是如何工作的。然而，在本书中，我们将使用这个名为`passport.js`的很棒的工具，它非常容易集成和学习。
- en: Up until this chapter, we have created a dynamic web application that displays
    all the movies that we have added via the Movie Add form and the API on the home
    page. We have a way of adding these movies to the database via the frontend as
    well. Now, since this will be a public web application, we cannot allow everyone
    to add movies by themselves without logging in. Only a user who logs in will have
    access and be able to add movies. Also, in order to rate a movie, a user should
    log in first and then rate the movie.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 直到本章为止，我们已经创建了一个动态的Web应用程序，它显示了我们通过电影添加表单和主页上的API添加的所有电影。我们还有一种通过前端将这些电影添加到数据库的方法。现在，由于这将是一个公共的Web应用程序，我们不能允许每个人都在没有登录的情况下自行添加电影。只有登录的用户才能访问并能够添加电影。此外，为了对电影进行评分，用户应该首先登录，然后再对电影进行评分。
- en: Introduction to passport.js
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍passport.js
- en: '`passport.js` is a middleware provided by Node.js for authentication. The functionality
    of `passport.js` is to authenticate the requests that are made to the server.
    It provides several strategies for authentication. `passport.js` provides strategies
    to such as local strategy, Facebook strategy, Google strategy, Twitter strategy,
    and JWT strategy. In this chapter, we will focus on using the JWT strategy.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`passport.js`是Node.js提供的用于身份验证的中间件。`passport.js`的功能是对发送到服务器的请求进行身份验证。它提供了几种身份验证策略。`passport.js`提供了本地策略、Facebook策略、Google策略、Twitter策略和JWT策略等策略。在本章中，我们将专注于使用JWT策略。'
- en: JWT
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT
- en: 'JWT is a way of authenticating the requests using a token-based approach. There
    are two methods of authenticating requests: cookie-based authentication, and token-based
    authentication. The cookie-based authentication mechanism saves the user''s session
    ID in the browser''s cookie, whereas the token-based mechanism uses a signed token
    that will look like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一种使用基于令牌的方法对请求进行身份验证的方式。有两种方法可以对请求进行身份验证：基于cookie的身份验证和基于令牌的身份验证。基于cookie的身份验证机制将用户的会话ID保存在浏览器的cookie中，而基于令牌的机制使用一个签名令牌，看起来像这样：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This token is then validated on every request that we make to the `controllers`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在每次我们向`controllers`发出请求时验证该令牌。
- en: For our application, we will use a combination of both. When a user requests
    to log in to the app, we will create a signed token for them and then add that
    token to the browser's cookie. The next time when the user logs in, we will read
    that token from the cookie and validate that token using the `passport-jwt` module
    in the server, and then decide whether or not to log that user in.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将两者结合使用。当用户请求登录应用时，我们将为他们创建一个签名令牌，然后将该令牌添加到浏览器的cookie中。下次用户登录时，我们将从cookie中读取该令牌，并使用服务器中的`passport-jwt`模块验证该令牌，然后决定是否登录该用户。
- en: 'If you look at the preceding token carefully, you will see that the token has
    three parts separated by a period (`.`); each part has its own meaning:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看前面的令牌，你会发现令牌由一个句点（`.`）分隔的三部分组成；每部分都有自己的含义：
- en: The first part represents the header
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分代表头部
- en: The second part represents the payload
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分代表有效载荷
- en: The third part represents the signature
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三部分代表签名
- en: 'To be able to use this JWT, we will need to add a package. To do that, we can
    just run the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用这个JWT，我们需要添加一个包。为此，我们只需运行以下命令：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To start using this package, let''s define it in `server.js` as well:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用这个包，让我们在`server.js`中定义它：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing passport.js
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装passport.js
- en: 'Just like any other `npm` package, we can install `passport.js` by running
    the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他`npm`包一样，我们可以通过运行以下命令来安装`passport.js`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On successful installation, you should have those package listed on your `package.json`
    as well:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装后，您还应该在您的`package.json`中列出这些包：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also do this by first adding the package to your `package.json` file
    and then running the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过首先将包添加到您的`package.json`文件，然后运行以下命令来执行此操作：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Configuring passport
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置passport
- en: 'Just like any other `node` package, we will need to configure the package for `passport.js`.
    In our `server.js` file, add the following lines of code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他`node`包一样，我们需要为`passport.js`配置包。在我们的`server.js`文件中，添加以下代码：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code just initialized `passport.js` in our application. We still
    need to configure a couple of things to start using the JWT authentication mechanism.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码只是在我们的应用程序中初始化了`passport.js`。我们仍然需要配置一些东西来开始使用JWT身份验证机制。
- en: passport.js strategies
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: passport.js策略
- en: As mentioned previously, `passport.js` provides a lot of strategies for easy
    integration. One of the strategies that we will be working on with is the JWT
    strategy. We have already added `passport.js` and initialized it. Now, let's add
    this strategy as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`passport.js`提供了许多策略，便于集成。我们将要使用的策略之一是JWT策略。我们已经添加了`passport.js`并对其进行了初始化。现在，让我们也添加这个策略。
- en: Installing the passport-jwt strategy
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装passport-jwt策略
- en: 'Just installing passport module is not sufficient for our needs. `passport.js`
    provides its strategies in separate `npm` packages. For `jwt` authentication,
    we have to install the `passport-jwt` module, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 仅安装passport模块对我们的需求来说是不够的。`passport.js`将其策略提供在单独的`npm`包中。对于`jwt`身份验证，我们必须安装`passport-jwt`模块，如下所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On successful installation, you should have these packages listed in the `package.json` file
    of the application:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装成功后，您应该在应用程序的`package.json`文件中列出这些包：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Configuring the passport-jwt strategy
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置passport-jwt策略
- en: 'Now that we have all the things we need, let''s jump into the configuration
    setting for the JWT strategy. Add the following lines of code in `server.js`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的东西，让我们开始配置JWT策略。在`server.js`中添加以下代码行：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is enough to get us started. We will need `JwtStrategy` from `passport.js`,
    and `ExtractJwT` will be used to extract the payload data in the `jwt` token.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码足以让我们开始。我们将需要从`passport.js`中获取`JwtStrategy`，并且`ExtractJwT`将用于提取`jwt`令牌中的有效负载数据。
- en: We have also defined a variable to set the JWT `auth` settings, which has a
    secret key configured. This secret key will be used to sign the payloads of any
    requests.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个变量来设置JWT `auth`设置，其中配置了一个秘密密钥。这个秘密密钥将用于签署任何请求的有效负载。
- en: You can also create a separate file to store your important keys.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个单独的文件来存储重要的密钥。
- en: Using the JWT strategy
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JWT策略
- en: 'Now we are all set up to use the services provided by `passport.js`. Let''s
    quickly recap what we have done so far:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用`passport.js`提供的服务。让我们快速回顾一下我们到目前为止所做的事情：
- en: Installed passport, `passport-jwt`, and `jsonwebtoken`
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了passport，`passport-jwt`和`jsonwebtoken`
- en: Configured all settings for these three packages
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置了这三个包的所有设置
- en: 'The next steps are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤如下：
- en: Creating our user model
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的用户模型
- en: Creating API endpoints for the user entity, that is, sign in and sign up
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户实体创建API端点，即登录和注册
- en: Building our authentication views,  that is, the login page and register page
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们的身份验证视图，即登录页面和注册页面
- en: Using the JWT strategy to finally authenticate the requests
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JWT策略最终对请求进行身份验证
- en: Setting up user registration
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户注册
- en: Let's start with adding the functionality to sign up users to our app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的应用程序中添加注册用户的功能开始。
- en: Creating a User model
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用户模型
- en: 'We don''t have a collection yet to manage the users. We will have three parameters
    in our `User` model: `name`, `email`, and `password`. Let''s go ahead and create
    our `User` model called `User.js` in the `models` directory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有一个集合来管理用户。我们的`User`模型将有三个参数：`name`，`email`和`password`。让我们继续在`models`目录中创建名为`User.js`的`User`模型：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the following are the three attributes for the user: `name`,
    `email`, and `password`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，用户的三个属性是：`name`，`email`和`password`。
- en: Installing bcryptjs
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装bcryptjs
- en: 'Now, we cannot save these user''s passwords in plain text, so we will need
    a mechanism to encrypt them. Fortunately, we already have a package designed to
    encrypt passwords, which is `bcryptjs`. Let''s first add this package to our application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不能以明文保存这些用户的密码，所以我们需要一种加密机制。幸运的是，我们已经有一个专门用于加密密码的包，那就是`bcryptjs`。让我们首先将这个包添加到我们的应用程序中：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the package is installed, let''s add the initialization block in the `User.js` model:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当包安装完成后，让我们在`User.js`模型中添加初始化块：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, when we save a user, we should create our own method to add users to the
    database, as we want to encrypt their passwords. So, let''s add the following
    code to `models/User.js`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们保存一个用户时，我们应该创建我们自己的方法将用户添加到数据库中，因为我们想要加密他们的密码。因此，让我们将以下代码添加到`models/User.js`中：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we have used the `bcrypt` library, which uses a `genSalt`
    mechanism to convert a password into an encrypted string. The preceding method—`createUser`—in
    the `User` model takes the `user` object, converts the user-provided password
    into a bcrypted password, and then saves it to the database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用了`bcrypt`库，它使用`genSalt`机制将密码转换为加密字符串。`User`模型中的上述方法`createUser`接受`user`对象，将用户提供的密码转换为加密密码，然后保存到数据库中。
- en: Adding API endpoint to register a user
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加API端点以注册用户
- en: Now that we have our model ready, let's move on to creating an endpoint to create
    a user. For that, let's first create a controller called  `users.js` in the `controllers`
    folder to manage all user related requests. Since we have added a code block to
    initialize all the files inside the `controllers` directory in `server.js`, we
    do not need to require those files here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模型已经准备好了，让我们继续创建一个端点来创建用户。为此，让我们首先在`controllers`文件夹中创建一个名为`users.js`的控制器，以管理所有与用户相关的请求。由于我们已经添加了一个代码块来初始化`server.js`中`controllers`目录中的所有文件，所以我们不需要在这里要求这些文件。
- en: 'In `users.js`, replace the file''s contents with the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`users.js`中，用以下代码替换文件的内容：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we have added an endpoint, that makes a POST request
    to the `http://localhost:8081/users/register`  URL, takes the `name`, `email`,
    and `password` of the user, and saves them to our database. In the response, it
    returns the user that was just created. It's quite simple.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们添加了一个端点，向`http://localhost:8081/users/register`发出POST请求，获取用户的`name`，`email`和`password`，并将它们保存到我们的数据库中。在响应中，它返回刚刚创建的用户。非常简单。
- en: 'Now, let''s test this endpoint in Postman. You should be able to see the user
    returned in the response:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Postman中测试这个端点。您应该能够在响应中看到返回的用户：
- en: '![](img/64757a12-83f6-4ab9-a3d9-a61e0f19b6fd.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64757a12-83f6-4ab9-a3d9-a61e0f19b6fd.png)'
- en: Creating a register view page
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建注册视图页面
- en: 'Let''s add a view page for the users to sign up. For that, we will need to
    create a form that takes the `name`, `email`, and `password` parameters. Create
    a file called `Register.vue` inside `src/components`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为用户添加一个注册视图页面。为此，我们需要创建一个接受`name`、`email`和`password`参数的表单。在`src/components`中创建一个名为`Register.vue`的文件：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `vue` file is a simple template file that contains the form components.
    The next step is to add a route for that file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`vue`文件是一个包含表单组件的简单模板文件。下一步是为该文件添加一个路由。'
- en: 'In `src/router/index.js`, add the following lines of code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/router/index.js`中，添加以下代码行：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s it! Now, let''s navigate to `http://localhost.com:8080/users/register`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，让我们导航到`http://localhost.com:8080/users/register`：
- en: '![](img/45360b7b-0695-4de3-a24c-25b3bcdf6448.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45360b7b-0695-4de3-a24c-25b3bcdf6448.png)'
- en: Adding submit and clear methods in the register form
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在注册表单中添加submit和clear方法
- en: 'The next step is to add functionality to the `submit` and `clear` methods.
    Let''s add some methods to `Register.vue`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为`submit`和`clear`方法添加功能。让我们在`Register.vue`中添加一些方法：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have also added some validations for the registration form here. It validates
    the email provided by the user according to the given regex.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这里为注册表单添加了一些验证。它根据用户提供的电子邮件进行验证，根据给定的正则表达式。
- en: We have added two methods, `submit` and `clear`. The `clear` method resets the
    form values; pretty straightforward, right?  Now, when we click on the `submit`
    button, the validations are run first. If all the validations pass, then only
    the logic inside the `submit` method is processed. Here, we need to make a request
    to the server with the user parameters where `axios` comes into play.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个方法，`submit`和`clear`。`clear`方法重置表单值；非常简单，对吧？现在，当我们点击`submit`按钮时，首先运行验证。如果所有验证都通过，那么只有`submit`方法内的逻辑才会被处理。在这里，我们需要向服务器发出带有用户参数的请求，这就是`axios`发挥作用的地方。
- en: Introducing axios
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入axios
- en: The axios is a mechanism to send request data to the server. You can think of
    it as an AJAX request in JavaScript. With `axios`, we can handle success and error
    responses from the server effectively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: axios是一种将请求数据发送到服务器的机制。您可以将其视为JavaScript中的AJAX请求。使用`axios`，我们可以有效地处理来自服务器的成功和错误响应。
- en: 'To install `axios`, run the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`axios`，运行以下命令：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using axios
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用axios
- en: 'Now, let''s modify our `Register.vue` file to implement `axios`—replace the
    content inside the `script` tag as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改我们的`Register.vue`文件以实现`axios`——将`script`标签内的内容替换为以下内容：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you are familiar with `ajax`, you should be able to quickly understand the
    code. If not, don't worry, it's actually quite simple. The `axios` method takes
    important parameters, such as the `request` method (in preceding case, `post`),
    the data parameters or the payloads, and a URL endpoint to hit. It takes these
    parameters and routes them to either the `then()` method or `catch()` method depending
    on the server's response.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉`ajax`，您应该能够快速理解代码。如果不熟悉，不用担心，它实际上非常简单。`axios`方法接受重要参数，如`request`方法（在前面的情况下是`post`）、数据参数或有效载荷，以及要命中的URL端点。它接受这些参数并将它们路由到`then()`方法或`catch()`方法，具体取决于服务器的响应。
- en: If the request is successful, it goes to the `then()` method; if not, it goes
    to the `catch()` method. Now, the success and failure of the requests are also
    customizable according to our needs. For the preceding scenario, we will simply
    pass an error response if the `user` is not saved to the database. We can also
    do it for the validations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求成功，它进入`then()`方法；如果不成功，它进入`catch()`方法。现在，请求的成功和失败也可以根据我们的需求进行自定义。对于前面的情况，如果`user`未保存到数据库，我们将简单地传递错误响应。我们也可以对验证进行同样的操作。
- en: 'So, let''s also modify `users.js` inside the `controller` method to accommodate
    these changes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们还修改`controller`方法中的`users.js`以适应这些更改：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see in the preceding code, if there is a failure in the request,
    we will send a message saying `Something went wrong`. We can also display different
    types of message depending on the server's response.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上述代码中所见，如果请求失败，我们将发送一条消息，说`出了些问题`。我们还可以根据服务器的响应显示不同类型的消息。
- en: Setting up the user login
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户登录
- en: Now that we have successfully implemented the login process for a user, let's start
    building the functionality to log users in to our app.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功实现了用户的登录过程，让我们开始构建将用户登录到我们的应用程序的功能。
- en: Modifying the User model
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改用户模型
- en: 'To log in users to the app, we will take the following two parameters: the
    user''s email and their password. We will need to query the database to find the
    record with their given email; so, let''s add a method that will extract the user
    according to the username:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 登录用户到应用程序，我们将使用以下两个参数：用户的电子邮件和他们的密码。我们需要查询数据库以找到具有给定电子邮件的记录；因此，让我们添加一个方法，根据用户名提取用户：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding method will return the user that has the given email.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法将返回具有给定电子邮件的用户。
- en: 'As I mentioned, another thing that we will need to check is the password. Let''s
    add method that compares the password provided by the user while logging in to
    the password that is saved in our database:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，我们还需要检查的另一件事是密码。让我们添加一个方法，比较用户登录时提供的密码和保存在我们的数据库中的密码：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding method takes both user-provided password and the saved password
    and returns `true` or `false` depending on whether the passwords match or not.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法接受用户提供的密码和保存的密码，并根据密码是否匹配返回`true`或`false`。
- en: Now we are all set to jump into the controller part.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进入控制器部分了。
- en: Adding an API endpoint to log a user in
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个用于登录用户的API端点
- en: We have added the methods required for a user to be able to log in. Now, the
    most important part of this chapter lies here. We need to set up the JWT `auth`
    mechanism to enable a user to log in.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了用户能够登录所需的方法。现在，本章最重要的部分在于此。我们需要设置JWT `auth`机制以使用户能够登录。
- en: 'In `users.js`, add the following lines of code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`users.js`中，添加以下代码行：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since the JWT strategy is a part of `passport.js`, we will need to initialize
    that as well. We also need to add some configurations for JWT options to extract
    the data from the payload, and unencrypt it and then encrypt it again when a request
    is made to the server.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JWT策略是`passport.js`的一部分，我们还需要初始化它。我们还需要为JWT选项添加一些配置，以从有效负载中提取数据，并在向服务器发出请求时对其进行解密和再次加密。
- en: The secret key is something that you can configure. It basically represents
    the token of your app. Ensure that it is not easily guessable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 秘钥是可以配置的。它基本上代表了您的应用程序的令牌。确保它不容易被猜到。
- en: 'Also, we have added an endpoint, which makes a POST request to `localhost:8081/users/login` and
    takes the user''s email and password. The following are a couple of things that
    this method does:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们添加了一个端点，它向`localhost:8081/users/login`发出POST请求，并获取用户的电子邮件和密码。以下是此方法执行的一些事项：
- en: Checks whether the user with the given email exists. If it does not exist, it
    sends a status code of 404, stating that the user does not exist in our app.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查给定电子邮件的用户是否存在。如果不存在，它会发送状态码404，说明用户在我们的应用程序中不存在。
- en: Compares the provided password with our user's password in the app. If there
    is no match, it sends an error response stating that passwords do not match.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将提供的密码与我们应用程序中用户的密码进行比较。如果没有匹配，它会发送一个错误响应，说明密码不匹配。
- en: If everything goes fine, it signs the user's payload with the JWT signature,
    generates a token, and responds with that token.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一切顺利，它会使用JWT签名对用户的有效负载进行签名，生成一个令牌，并用该令牌做出响应。
- en: 'Now, let''s test this endpoint in Postman. You should be able to see the token
    returned in the response, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Postman中测试这个端点。您应该能够在响应中看到返回的令牌，如下所示：
- en: '![](img/9d43f252-4443-4cdb-b915-48e3fd30c63f.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d43f252-4443-4cdb-b915-48e3fd30c63f.png)'
- en: In the preceding screenshot, note that JWT takes the payload, signs it, and
    generates a random token.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，请注意JWT获取有效负载，对其进行签名，并生成一个随机令牌。
- en: Creating a register view page
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个注册视图页面
- en: 'Let''s add a view page for the users to log in now. For that, like we did on
    the register page, we will need to create a form that takes the email and password
    parameters. Create a file called `Login.vue` inside `src/components`, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为用户添加一个登录视图页面。为此，就像我们在注册页面上所做的那样，我们需要创建一个接受电子邮件和密码参数的表单。创建一个名为`Login.vue`的文件，放在`src/components`中，如下所示：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `vue` file is a simple template file that contains the form components.
    The next thing to do is to add a route for that file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`vue`文件是一个包含表单组件的简单模板文件。接下来要做的是为该文件添加一个路由。'
- en: 'In `src/router/index.js`, add the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/router/index.js`中，添加以下代码：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That''s it. Now, let''s navigate to `http://localhost.com:8080/users/login`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，让我们导航到`http://localhost.com:8080/users/login`：
- en: '![](img/36840d36-9b09-4219-9797-57ad3e10df90.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36840d36-9b09-4219-9797-57ad3e10df90.png)'
- en: Adding submit and clear methods to the login form
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向登录表单添加提交和清除方法
- en: 'The next step is to add functionality in the `submit` and `clear` methods.
    Let''s add some methods to `Login.vue`. The `clear` method is the same as on the
    register page. For the `submit` method, we will use the `axios` method here. We
    have already categorized our success and error messages in the controller. Now
    we just need to make sure that they are displayed in the UI:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在`submit`和`clear`方法中添加功能。让我们在`Login.vue`中添加一些方法。`clear`方法与注册页面上的相同。对于`submit`方法，我们将在这里使用`axios`方法。我们已经在控制器中对成功和错误消息进行了分类。现在我们只需要确保它们在UI中显示：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The validations are the same as on the register page. We have added two methods, `submit`
    and `clear`. The `clear` method resets the form values, and the `submit` method
    simply hits the API endpoint, taking the parameter from the form, and responds
    with the correct message, which is then displayed in the UI. Upon successful completion,
    the user will be redirected to the home page.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 验证与注册页面上相同。我们添加了两个方法，`submit`和`clear`。`clear`方法重置表单值，`submit`方法只是简单地命中API端点，从表单中获取参数，并以正确的消息做出响应，然后在UI中显示。成功完成后，用户将被重定向到主页。
- en: The important part here is that since we are interacting on the client side,
    we will need the previously generated JWT token to be saved somewhere. The best
    way to access the token is by saving it to the browser's session. So, we have
    set a key called `auth`, which saves the JWT token in the local storage. Whenever
    any other requests are made, the request will first check whether it is a valid
    token or not and perform the action accordingly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要部分是，由于我们是在客户端进行交互，我们需要将先前生成的JWT令牌保存在某个地方。访问令牌的最佳方式是将其保存到浏览器的会话中。因此，我们设置了一个名为`auth`的键，它将JWT令牌保存在本地存储中。每当进行任何其他请求时，请求将首先检查它是否是有效令牌，然后相应地执行操作。
- en: 'The following is what we have done so far:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经做了以下工作：
- en: Added `getUserByEmail()` and `comparePassword()` to the Users model
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Users模型添加`getUserByEmail()`和`comparePassword()`
- en: Created a login view page
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个登录视图页面
- en: Added methods to be able to submit and clear the form
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加能够提交和清除表单的方法
- en: Generated a JWT signed token and saved it to the session for reuse later
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成了一个JWT签名令牌，并将其保存到会话中以供以后重用。
- en: Displayed success and error messages
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示成功和错误消息
- en: Authenticating our user in Home.vue
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Home.vue中对我们的用户进行身份验证
- en: The last thing we need to do is check whether the current logged in user is
    authorized to view the movie listing page or not. Although it makes sense to make
    the home page (movie listing page) accessible to all users, for learning purpose,
    let's add JWT authorization when a user goes to the home page. Let's make the
    home page not accessible to the outside users who are not in our app.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是检查当前登录的用户是否有权查看电影列表页面。虽然让所有用户访问主页（电影列表页面）是有道理的，但出于学习目的，让我们在用户访问主页时添加JWT授权。让我们不让外部用户访问我们应用程序的主页。
- en: 'In `movies.js`, add the following piece of code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`movies.js`中，添加以下代码：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Yup, that''s it! We will need to initialize passport and just add `passport.authenticate(''jwt'',
    { session: false })`. We have to pass the JWT token and the passport JWT strategy
    automatically authenticates the current user.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '是的，就是这样！我们需要初始化护照并只添加`passport.authenticate(''jwt'', { session: false })`。我们必须传递JWT令牌，护照JWT策略会自动验证当前用户。'
- en: 'Now, let''s also send the JWT token while making a request to the movie listing
    page. In `Home.vue`, add the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在请求电影列表页面时，让我们也发送JWT令牌。在`Home.vue`中，添加以下代码：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While making the `axios` call, we will have to pass one extra parameter in the
    headers. We need to read the token from the local storage and pass it to the movies
    API through the headers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行`axios`调用时，我们将不得不在标头中传递一个额外的参数。我们需要从本地存储中读取令牌并通过标头传递给电影API。
- en: With this, any user who is not logged in to the app will not be able to view
    the movie listing page.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，任何未登录应用的用户将无法查看电影列表页面。
- en: Serving static files for Vue components
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Vue组件提供静态文件
- en: 'Before jumping into the Local Strategy, let''s learn a little bit about how
    we can make our Vue.js components to be served statically. Since we are using
    a separate frontend and backend, it can be a daunting task to keep maintaining
    these two versions, and especially while deploying the app, it can take a lot
    longer to configure everything. So, to manage our app better, we will build the
    Vue.js app, which will be a production build, and use the Node.js server only
    to serve the files. For that, we will be using a separate package called serve-static.
    So, let''s go ahead and install the package:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解本地策略之前，让我们先了解一下如何使我们的Vue.js组件静态提供。由于我们使用单独的前端和后端，要保持这两个版本并进行部署可能是一项艰巨的任务。因此，为了更好地管理我们的应用程序，我们将构建Vue.js应用程序，这将是一个生产构建，并且仅使用Node.js服务器来提供文件。为此，我们将使用一个名为`serve-static`的单独包。因此，让我们继续安装该软件包：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s add the following contents to our `server.js` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将以下内容添加到我们的`server.js`文件中：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With this, let''s now build our application with the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，现在让我们用以下命令构建我们的应用程序：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding command will create the necessary static files inside the `dist` folder
    in the application that will be served by the Node.js server, which is in the 8081 port.
    After the build, we now do not need to run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在应用程序的`dist`文件夹中创建必要的静态文件，这些文件将由位于8081端口的Node.js服务器提供。构建后，我们现在不需要运行以下命令：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Also, now since we will be running our node server only, the application should
    be available at the URL `http://localhost:8081`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在我们只运行我们的节点服务器，应用程序应该在`http://localhost:8081`的URL上可用。
- en: 'The preceding command starts our frontend server. We only need to run the Node.js
    server with the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令启动我们的前端服务器。我们只需要使用以下命令运行Node.js服务器：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we now only have one port, 8081, we do not need to add the prefix `/api` in
    every backend API like we did earlier, we can get rid of those as well. So, let''s
    update the `controllers` and `vue` files as well:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在我们只有一个端口8081，我们不需要像之前那样在每个后端API中添加`/api`前缀，我们也可以摆脱这些。因此，让我们也更新`controllers`和`vue`文件：
- en: 'Replace the contents in `controllers/movies.js`, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，替换`controllers/movies.js`中的内容：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Replace the contents in `controllers/users.js`, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，替换`controllers/users.js`中的内容：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Replace the contents of the `script` tag of `AddMovie.vue` with the following
    code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`AddMovie.vue`的`script`标签中的内容：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Replace the contents of the `script` tag of `Home.vue` with the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`Home.vue`的`script`标签中的内容：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replace the contents of the `script` tag of `Login.vue` with the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`Login.vue`的`script`标签中的内容：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Replace the contents of the `script` tag of `Register.vue` with the following
    code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`Register.vue`的`script`标签中的内容：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, we don't need to use the proxy anymore, so we can remove the proxy
    we set up earlier from `webpack.dev.conf.js`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不再需要使用代理，因此可以从`webpack.dev.conf.js`中删除我们之前设置的代理。
- en: 'Replace the contents inside `devServer` with the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`devServer`中的内容：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With these updated, let''s build our application once more with the following
    command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更新，让我们再次用以下命令构建我们的应用程序：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Our application should work as expected.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序应该按预期工作。
- en: Since our application is a **Single Page Application **(**SPA**), when we browse
    through the nested routes and reload the page, we will get an error. For example,
    if we browse the `http://localhost:8081/contact` page by clicking the link in
    the home page, it will work. However, if we try to navigate to the `http://localhost:8081/contact` page
    directly, we will get an error because this is an SPA, which means that the browser
    only renders the static `index.html` file. When we try to access the `/contact` page,
    it will look for the page called `contact`, which does not exist.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序是**单页应用程序**（**SPA**），当我们浏览嵌套路由并重新加载页面时，我们将收到错误。例如，如果我们通过在主页中点击链接来浏览`http://localhost:8081/contact`页面，它将起作用。但是，如果我们尝试直接导航到`http://localhost:8081/contact`页面，我们将收到错误，因为这是一个SPA，这意味着浏览器只呈现静态的`index.html`文件。当我们尝试访问`/contact`页面时，它将寻找名为`contact`的页面，但该页面不存在。
- en: For this, we will need to add a middleware, which acts as a fallback and renders
    the same `index.html` file when we try to reload the page directly or try to access
    the pages with dynamic IDs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要添加一个中间件，当我们尝试直接重新加载页面或尝试访问带有动态ID的页面时，它充当回退并呈现相同的`index.html`文件。
- en: 'There is a middleware provided by `npm` to serve our purpose. Let''s go ahead
    and install the following package:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`提供了一个中间件来满足我们的需求。让我们继续安装以下包：'
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After the installation, let''s modify our `server.js` file to use the middleware:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，让我们修改`server.js`文件以使用中间件：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With these in place, we should now be able to access all the routes directly.
    We can also reload the pages now.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在应该能够直接访问所有路由。我们现在也可以重新加载页面。
- en: Since we are building our Vue.js components and running our app solely on the
    Node.js server, whenever we make a change to the Vue.js components, we will need
    to build the application again with the `npm run build` command.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建我们的Vue.js组件并仅在Node.js服务器上运行我们的应用程序，每当我们对Vue.js组件进行更改时，我们都需要使用`npm run
    build`命令重新构建应用程序。
- en: Passport's Local Strategy
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Passport的本地策略
- en: Passport's Local Strategy is easy to integrate. As always, let's start with
    the installation of this strategy as follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Passport的本地策略很容易集成。和往常一样，让我们从安装这个策略开始。
- en: Installing Passport's Local Strategy
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Passport的本地策略
- en: 'We can install passport''s Local Strategy by running the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来安装passport的本地策略：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following code should add the package to your package.json file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码应该将包添加到您的package.json文件中：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Configuring Passport's Local Strategy
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Passport的本地策略
- en: 'There are a few steps to configure the Passport''s Local Strategy. We will
    discuss each step in detail:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Passport的本地策略有几个步骤。我们将详细讨论每个步骤：
- en: Add necessary routes for Local authentication.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为本地认证添加必要的路由。
- en: Add a middleware method to check whether authentication is successful.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个中间件方法来检查认证是否成功。
- en: Let's dive into the details for each of the preceding steps.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解前面每个步骤的细节。
- en: Adding necessary routes for Local Authentication
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为本地认证添加必要的路由
- en: 'Let''s go ahead and add the necessary routes when we click on the login button.
    Replace the contents of `controllers/users.js` with the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加必要的路由，当我们点击登录按钮时。使用以下代码替换`controllers/users.js`的内容：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we have added a route for users login as `/users/login` which then uses
    `passport.js` local authentication mechanism to log in the user to the app.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个用于用户登录的路由`/users/login`，然后使用`passport.js`本地认证机制将用户登录到应用程序中。
- en: Also, we configured `passport.js` to use LocalStrategy when user logs in which
    takes the `username` and `password` of the user.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们配置了`passport.js`在用户登录时使用LocalStrategy，该策略获取用户的`username`和`password`。
- en: Installing express-session
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装express-session
- en: 'The next thing we need to do is setup a `session` so that when a user successfully
    logs in, the `user` data can be stored in the `session` and can be retrieved easily
    when we make other requests. For this, we need to add a package called `express-session`.
    Let''s go ahead and install the package with the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是设置一个`session`，这样当用户成功登录时，`user`数据可以存储在`session`中，并且在我们进行其他请求时可以轻松检索。为此，我们需要添加一个名为`express-session`的包。让我们继续使用以下命令安装包：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Configuring express-session
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置express-session
- en: Now, that we have the package, let's configure this package to fulfill our needs
    to save the user in the `session`.  Add the following lines of code in it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了这个包，让我们配置这个包以满足我们保存用户在`session`中的需求。在其中添加以下代码行。
- en: If `username` and `password` matches, the user object is saved in the session
    in the server and can be access via `req.user` in every request.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`username`和`password`匹配，用户对象将保存在服务器的会话中，并且可以通过每个请求中的`req.user`访问。
- en: Also, let's updated our vue files as well since we do not need the passport
    JWT strategy now.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们也需要更新我们的vue文件，因为我们现在不需要passport JWT策略。
- en: 'Update the contents in `server.js` with the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`server.js`中的内容：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we added the configuration for express-session with the following code
    block:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了express-session的配置，使用以下代码块：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The above code blocks uses a secret token required to save the user details.
    We will be defining the token in a separate file so that all of our configuration
    token reside in a single place.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块使用了一个需要保存用户详细信息的秘密令牌。我们将在一个单独的文件中定义令牌，以便我们所有的配置令牌都驻留在一个地方。
- en: 'So, let''s go ahead and create a file called `Config.js` inside the `config`
    directory and the following lines of code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续在`config`目录中创建一个名为`Config.js`的文件，并添加以下代码行：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We also added a `GET` route called `/api/current_user` to fetch the current
    logged in user details. This api uses a middleware method called `isLoggedIn`
    which checks if the user's data is on the session or not. And if the user's data
    exists in the session, the current user details is sent back as the response.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个名为`/api/current_user`的`GET`路由，用于获取当前登录用户的详细信息。此api使用一个名为`isLoggedIn`的中间件方法，用于检查用户的数据是否在会话中。如果用户的数据存在于会话中，则当前用户的详细信息将作为响应返回。
- en: Another endpoint which we added is the `/logout` which simply logs out the user
    and destroys the session.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的另一个端点是`/logout`，它简单地注销用户并销毁会话。
- en: Hence, with this configuration, now we should be able to log in successfully
    using the `passport.js` Local Strategy.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这个配置，现在我们应该能够成功使用`passport.js`本地策略登录。
- en: The only problem that we have now is  there is no way to know if the user successfully
    logged in or not. For that we need to display some user's information such as
    `email` to indicate the logged in user.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在唯一的问题是我们无法知道用户是否成功登录。为此，我们需要显示一些用户信息，比如`email`来指示已登录的用户。
- en: For this, we need to pass the user's information from `Login.vue` to `App.vue`
    so that we can display the user's email in the top bar. We can use a method called
    `emit` provided by `Vue` which is used to pass the information between the `Vue`
    components. Let's go ahead and configure that.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要将用户的信息从`Login.vue`传递到`App.vue`，以便我们可以在顶部栏中显示用户的电子邮件。我们可以使用`Vue`提供的`emit`方法来在`Vue`组件之间传递信息。让我们继续配置。
- en: Configuring emit method
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置emit方法
- en: 'Let''s first create a transmitter which can communicate between the different
    Vue components. Create a file called `bus.js` inside `src` directory and add the
    following contents:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个可以在不同的Vue组件之间通信的传输器。在`src`目录下创建一个名为`bus.js`的文件，并添加以下内容：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, replace the contents inside `script` tag of `Login.vue` with the following
    code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用以下代码替换`Login.vue`中`script`标签内的内容：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here we are emitting a method called `refreshUser` which will be defined in
    the App.vue. Replace the contents inside `App.vue` with the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们正在发出一个名为`refreshUser`的方法，该方法将在App.vue中定义。用以下代码替换`App.vue`中的内容：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here we have added the method called `refreshUser` which is being listened by
    `App.vue` in the mounted method. Whenever a user logs in to the app, the method
    called `refreshUser` in `App.vue` gets called and fetches the logged in user's
    information.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们添加了一个名为`refreshUser`的方法，该方法在`mounted`方法中被`App.vue`监听。每当用户登录应用程序时，`App.vue`中的`refreshUser`方法被调用，并获取已登录用户的信息。
- en: Also, we are displaying the user's email in the top bar so that we can know
    if the user is logged in or not.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在顶部栏中显示用户的电子邮件，以便我们知道用户是否已登录。
- en: 'Also, let''s remove the JWT authentication from movies controller as well.
    Replace the contents in `controllers/movies.js` with the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们也从电影控制器中删除JWT身份验证。用以下代码替换`controllers/movies.js`中的内容：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With this, we should be able to view the following screen when a user logs
    in to the app:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，当用户登录应用程序时，我们应该能够看到以下屏幕：
- en: '![](img/2a7fa817-15de-4d8c-acf8-5d78928920ff.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a7fa817-15de-4d8c-acf8-5d78928920ff.png)'
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we covered `passport.js` and how it works. We also covered
    how to use a simple JWT strategy with a MEVN application and handle register and
    login for users.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了`passport.js`及其工作原理。我们还介绍了如何在MEVN应用程序中使用简单的JWT策略，并处理用户的注册和登录。
- en: In the next chapter, we will dig into different `passport.js` strategies, such
    as the Facebook strategy, the Google strategy, and the Twitter strategy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究不同的`passport.js`策略，如Facebook策略、Google策略和Twitter策略。
