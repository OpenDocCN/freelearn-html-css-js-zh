- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Working with Creational Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与创建型设计模式一起工作
- en: JavaScript design patterns are techniques that allow us to write more robust,
    scalable, and extensible applications in JavaScript. JavaScript is a very popular
    programming language, in part due to its place as a way to deliver interactive
    functionality on web pages. The other reason for its popularity is JavaScript’s
    lightweight, dynamic, multi-paradigm nature, which means that design patterns
    from other ecosystems can be adapted to take advantage of JavaScript’s strengths.
    JavaScript’s specific strengths and weaknesses can also inform new patterns specific
    to the language and the contexts in which it’s used.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript设计模式是允许我们在JavaScript中编写更健壮、可扩展和可扩展的应用程序的技术。JavaScript是一种非常流行的编程语言，部分原因是它作为在网页上提供交互功能的一种方式。其受欢迎的另一个原因是JavaScript的轻量级、动态、多范式特性，这意味着其他生态系统的设计模式可以适应以利用JavaScript的优势。JavaScript的具体优势和劣势也可以为语言及其使用环境中的新模式提供信息。
- en: Creational design patterns give structure to object creation, which enables
    the development of systems and applications where different modules, classes,
    and objects don’t need to know how to create instances of each other. The design
    patterns most relevant to JavaScript – the prototype, singleton, and factory patterns
    – will be explored, as well as situations where they’re helpful and how to implement
    them in an idiomatic fashion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型设计模式为对象创建提供结构，这使得开发不需要知道如何创建彼此实例的不同模块、类和对象的应用程序和系统成为可能。与JavaScript最相关的模式——原型、单例和工厂模式——将被探讨，以及它们何时有用以及如何以惯用的方式实现。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: A comprehensive definition of creational design patterns and definitions for
    the prototype, singleton, and factory patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型设计模式的全面定义以及原型、单例和工厂模式的定义
- en: Multiple implementations of the prototype pattern and its use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式的多种实现及其用例
- en: An implementation of the singleton design pattern, eager and lazy initialization,
    use cases for singleton, and what a singleton pattern in modern JavaScript looks
    like
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例设计模式的实现，包括急切和延迟初始化，单例的用例以及现代JavaScript中的单例模式是什么样的
- en: How to implement the factory pattern using classes, a modern JavaScript alternative,
    and use cases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用类、现代JavaScript的替代方案以及用例来实现工厂模式
- en: By the end of this chapter, you’ll be able to identify when a creational design
    pattern is useful and make an informed decision on which of its multiple implementations
    to use, ranging from a more idiomatic JavaScript form to a classical form.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够识别何时使用创建型设计模式是有用的，并就其多种实现中选择一个明智的决定，从更惯用的JavaScript形式到经典形式。
- en: What are creational design patterns?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是创建型设计模式？
- en: Creational design patterns handle object creation. They allow a consumer to
    create object instances without knowing the details of how to instantiate the
    object. Since, in object-oriented languages, instantiation of objects is limited
    to a class’s constructor, allowing object instances to be created without calling
    the constructor is useful to reduce noise and tight coupling between the consumer
    and the class being instantiated.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型设计模式处理对象创建。它们允许消费者创建对象实例，而无需了解如何实例化对象的具体细节。由于在面向对象的语言中，对象的实例化仅限于类的构造函数，因此允许不调用构造函数就创建对象实例可以减少消费者和被实例化的类之间的噪声和紧密耦合。
- en: 'In JavaScript, there’s ambiguity when we discuss “object creation,” since JavaScript’s
    multi-paradigm nature means we can create objects without a class or a constructor.
    For example, in JavaScript this is an object creation using an object literal
    – `const config = { forceUpdate: true` `}`. In fact, modern idiomatic JavaScript
    tends to lean more toward procedural and function paradigms than object orientation.
    This means that creational design patterns may have to be adapted to be fully
    useful in JavaScript.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '在JavaScript中，当我们讨论“对象创建”时存在歧义，因为JavaScript的多范式特性意味着我们可以不使用类或构造函数来创建对象。例如，在JavaScript中，这是一个使用对象字面量进行对象创建的例子
    – `const config = { forceUpdate: true` `}`。实际上，现代惯用的JavaScript往往更倾向于过程和函数范式，而不是面向对象。这意味着创建型设计模式可能需要调整才能在JavaScript中完全有用。'
- en: In summary, creational design patterns are useful in object-oriented JavaScript,
    since they hide instantiation details from consumers, which keeps coupling low,
    thereby allowing better module separation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在面向对象的 JavaScript 中，创建型设计模式非常有用，因为它们隐藏了实例化细节，从而降低了耦合度，允许更好的模块分离。
- en: In the next section, we’ll encounter our first creational design pattern – the
    prototype design pattern.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将遇到第一个创建型设计模式——原型设计模式。
- en: Implementing the prototype pattern in JavaScript
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JavaScript 中实现原型模式
- en: Let’s start with a definition of the prototype pattern first.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一下原型模式。
- en: The prototype design pattern allows us to create an instance based on another
    existing instance (our prototype).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式允许我们根据另一个现有实例（我们的原型）创建一个实例。
- en: In more formal terms, a `prototype` class exposes a `clone()` method. Consuming
    code, instead of calling `new SomeClass`, will call `new` `SomeClassPrototype(someClassInstance).clone()`.
    This method call will return a `new SomeClass` instance with all the values copied
    from `someClassInstance`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，一个 `prototype` 类公开了一个 `clone()` 方法。消费代码，而不是调用 `new SomeClass`，将调用 `new
    SomeClassPrototype(someClassInstance).clone()`。这个方法调用将返回一个带有从 `someClassInstance`
    复制的所有值的 `new SomeClass` 实例。
- en: Implementation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Let’s imagine a scenario where we’re building a chessboard. There are two key
    types of squares – white and black. In addition to this information, each square
    contains information such as its row, file, and which piece sits atop it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个场景，我们正在构建一个棋盘。有两种关键的方块类型——白色和黑色。除了这些信息之外，每个方块还包含其行、列以及位于其上的棋子信息。
- en: 'A `BoardSquare` class constructor might look like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `BoardSquare` 类构造函数可能看起来如下：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A set of useful methods on `BoardSquare` might be `occupySquare` and `clearSquare`,
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoardSquare` 上可能有一组有用的方法，例如 `occupySquare` 和 `clearSquare`，如下所示：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instantiating `BoardSquare` is quite cumbersome, due to all its properties:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `BoardSquare` 有很多属性，实例化它相当繁琐：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the repetition of arguments being passed to `new BoardSquare`, which will
    cause issues if we want to change all board squares to black. We would need to
    change the parameter passed to each call of `BoardSquare` is one by one for each
    `new BoardSquare` call. This can be quite error-prone; all it takes is one hard-to-find
    mistake in the `color` value to cause a bug:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意传递给 `new BoardSquare` 的参数重复，如果我们想将所有棋盘方块变为黑色，我们需要逐个更改每个 `new BoardSquare`
    调用的参数。这可能会非常容易出错；只需在 `color` 值中犯一个难以发现的错误就可能导致错误：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implementing our instantiation logic using a classical prototype looks as follows.
    We need a `BoardSquarePrototype` class; its constructor takes a `prototype` property,
    which it stores on the instance. `BoardSquarePrototype` exposes a `clone()` method
    that takes no arguments and returns a `BoardSquare` instance, with all the properties
    of `prototype` copied onto it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用经典的原型实现我们的实例化逻辑如下。我们需要一个 `BoardSquarePrototype` 类；其构造函数接受一个 `prototype` 属性，并将其存储在实例上。`BoardSquarePrototype`
    公开了一个 `clone()` 方法，该方法不接受任何参数，并返回一个带有 `prototype` 上所有属性的 `BoardSquare` 实例：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using `BoardSquarePrototype` requires the following steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `BoardSquarePrototype` 需要以下步骤：
- en: 'First, we want an instance of **BoardSquare** to initialize – in this case,
    with **''white''**. It will then be passed as the **prototype** property during
    the **BoardSquarePrototype** constructor call:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们想要一个 **BoardSquare** 的实例来初始化——在这种情况下，使用 **'white'**。然后，它将在调用 **BoardSquarePrototype**
    构造函数时作为 **prototype** 属性传递：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can then use **whiteSquarePrototype** with **.clone()** to create our copies
    of **whiteSquare**. Note that **color** is copied over but each call to **clone()**
    returns a new instance.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 **whiteSquarePrototype** 与 **.clone()** 方法来创建 **whiteSquare** 的副本。注意，**color**
    被复制，但每次调用 **clone()** 都会返回一个新的实例。
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Per the assertions in the code, the cloned instances contain the same value
    for `color` but are different instances of the `Square` object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码中的断言，克隆的实例具有相同的 `color` 值，但它们是 `Square` 对象的不同实例。
- en: A use case
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个用例
- en: 'To illustrate what it would take to change from a white square to a black square,
    let’s look at some sample code where `''white''` is not referenced in the variable
    names:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明从白色方块变为黑色方块需要改变什么，让我们看看一些示例代码，其中变量名中没有引用 `'white'`：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this scenario, we would only have to change the `color` value passed to
    `BoardSquare` to change the color of all the instances cloned from the prototype:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需更改传递给 `BoardSquare` 的 `color` 值，就可以改变从原型克隆的所有实例的颜色：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The prototype pattern is useful in situations where a “template” for the object
    instances is useful. It’s a good pattern to create a “default object” but with
    custom values. It allows faster and easier changes, since they are implemented
    once on the template object but are applied to all `clone()`-ed instances.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式在需要对象实例的“模板”的情况下很有用。这是一个创建“默认对象”但带有自定义值的好模式。它允许更快、更轻松地进行更改，因为它们在模板对象上只实现一次，但应用于所有
    `clone()`-ed 实例。
- en: Increasing robustness to change in the prototype’s instance variables with modern
    JavaScript
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用现代 JavaScript 增强对原型实例变量变化的鲁棒性
- en: There are improvements we can make to our prototype implementation in JavaScript.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 JavaScript 的原型实现中做出一些改进。
- en: The first is in the `clone()` method. To make our prototype class robust to
    changes in the prototype’s constructor/instance variables, we should avoid copying
    the properties one by one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是在 `clone()` 方法中。为了使我们的原型类对原型构造函数/实例变量的变化具有鲁棒性，我们应该避免逐个复制属性。
- en: 'For example, if we add a new `startingPiece` parameter that the `BoardSquare`
    constructor takes and sets the `piece` instance variable to, our current implementation
    of `BoardSquarePrototype` will fail to copy it, since it only copies `color`,
    `row`, and `file`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们添加一个新的 `startingPiece` 参数，该参数由 `BoardSquare` 构造函数接受并将 `piece` 实例变量设置为，我们当前的
    `BoardSquarePrototype` 实现将无法复制它，因为它只复制 `color`、`row` 和 `file`：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Reference for **Object.assign**: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Object.assign** 的参考：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)。'
- en: 'If we amend our `BoardSquarePrototype` class to use `Object.assign(new BoardSquare(),
    this.prototype)`, it will copy all the enumerable properties of `prototype`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `BoardSquarePrototype` 类修改为使用 `Object.assign(new BoardSquare(), this.prototype)`，它将复制
    `prototype` 的所有可枚举属性：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The prototype pattern without classes in JavaScript
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 中没有类的原型模式
- en: For historical reasons, JavaScript has a prototype concept deeply embedded into
    the language. In fact, classes were introduced much later into the ECMAScript
    standard, with ECMAScript 6, which was released in 2015 (for reference, ECMAScript
    1 was published in 1997).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，JavaScript 在语言中深深嵌入了一个原型概念。实际上，类是在 ECMAScript 标准中后来引入的，ECMAScript 6 在
    2015 年发布（参考，ECMAScript 1 在 1997 年发布）。
- en: This is why a lot of JavaScript completely forgoes the use of classes. The JavaScript
    “object prototype” can be used to make objects inherit methods and variables from
    each other.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么很多 JavaScript 完全放弃了使用类的使用。JavaScript 的“对象原型”可以用来使对象相互继承方法和变量。
- en: 'One way to clone objects is by using the `Object.create` to clone objects with
    their methods. This relies on the JavaScript prototype system:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆对象的一种方法是通过使用 `Object.create` 来克隆具有其方法的对象。这依赖于 JavaScript 原型系统：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One subtlety here is that `Object.create` does not actually copy anything;
    it simply creates a new object and sets its prototype to `square`. This means
    that if properties are not found on `otherSquare`, they’re accessed on `square`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个细微差别是 `Object.create` 实际上并没有复制任何东西；它只是创建了一个新对象，并将其原型设置为 `square`。这意味着如果
    `otherSquare` 上没有找到属性，它们将在 `square` 上访问：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A further note on the JavaScript prototype, and its existence before classes
    were part of JavaScript, is that subclassing in JavaScript is another syntax for
    setting an object’s prototype. Have a look at the following `extends` example.
    `BlackSquare extends Square` sets the `prototype.__proto__` property of `BlackSquare`
    to `Square.prototype`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JavaScript 原型的进一步说明，以及它在类成为 JavaScript 部分之前就存在，是 JavaScript 中的子类化是设置对象原型的另一种语法。看看下面的
    `extends` 示例。`BlackSquare extends Square` 将 `BlackSquare` 的 `prototype.__proto__`
    属性设置为 `Square.prototype`：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this section, we learned how to implement the prototype pattern with a prototype
    class that exposes a `clone()` method, which code situations the prototype patterns
    can help with, and how to further improve our prototype implementation with modern
    JavaScript features. We also covered the JavaScript “prototype,” why it exists,
    and its relationship with the prototype design pattern.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用具有公开 `clone()` 方法的原型类实现原型模式，原型模式可以帮助的代码情况，以及如何使用现代 JavaScript
    功能进一步改进我们的原型实现。我们还涵盖了 JavaScript 的“原型”，为什么它存在，以及它与原型设计模式的关系。
- en: In the next part of the chapter, we’ll look at another creational design pattern,
    the singleton design pattern, with some implementation approaches in JavaScript
    and its use cases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分，我们将探讨另一种创建型设计模式，即单例设计模式，以及一些在JavaScript中的实现方法和用例。
- en: The singleton pattern with eager and lazy initialization in JavaScript
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的单例模式，具有 eager 和 lazy 初始化
- en: To begin, let’s define the singleton design pattern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义单例设计模式。
- en: The singleton pattern allows an object to be instantiated only once, exposes
    this single instance to consumers, and controls the instantiation of the single
    instance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式允许一个对象只被实例化一次，向消费者公开这个单一实例，并控制单一实例的实例化。
- en: The singleton is another way of getting access to an object instance without
    using a constructor, although it’s necessary for the object to be designed as
    a singleton.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是另一种在不使用构造函数的情况下获取对象实例的方法，尽管对象必须设计为单例。
- en: Implementation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: A classic example of a singleton is a logger. It’s rarely necessary (and often,
    it’s a problem) to instantiate multiple loggers in an application. Having a singleton
    means the initialization site is controlled, and the logger configuration will
    be consistent across the application – for example, the log level won’t change
    depending on where in the application we call the logger from.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 单例的一个经典例子是日志记录器。在应用程序中很少需要（并且通常，这是一个问题）实例化多个日志记录器。拥有单例意味着初始化位置受到控制，并且日志记录器配置将在整个应用程序中保持一致——例如，日志级别不会根据我们在应用程序中从哪里调用日志记录器而改变。
- en: A simple logger looks something as follows, with a constructor taking `logLevel`
    and `transport`, and an `isLevelEnabled` private method, which allows us to drop
    logs that the logger is not configured to keep (for example, when the level is
    `warn` we drop `info` messages). The logger finally implements the `info`, `warn`,
    and `error` methods, which behave as previously described; they only call the
    relevant `transport` method if the level is “enabled” (i.e., “above” what the
    configured log level is).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的日志记录器看起来如下，它有一个接受 `logLevel` 和 `transport` 的构造函数，以及一个私有的 `isLevelEnabled`
    方法，它允许我们丢弃日志记录器未配置保留的日志（例如，当级别是 `warn` 时，我们丢弃 `info` 消息）。日志记录器最终实现了 `info`、`warn`
    和 `error` 方法，它们的行为如前所述；它们只有在级别“启用”时（即，“高于”配置的日志级别）才会调用相关的 `transport` 方法。
- en: 'The possible `logLevel` values that power `isLevelEnabled` are stored as a
    static field on `Logger`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 `isLevelEnabled` 的可能 `logLevel` 值存储在 `Logger` 的静态字段上：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to make `Logger` a singleton, we need to implement a `getInstance`
    static method that returns a cached instance. In order to do, this we’ll use a
    static `loggerInstance` on `Logger`. `getInstance` will check whether `Logger.loggerInstance`
    exists and return it if it does; otherwise, it will create a new `Logger` instance,
    set that as `loggerInstance`, and return it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `Logger` 成为单例，我们需要实现一个返回缓存实例的 `getInstance` 静态方法。为了做到这一点，我们将在 `Logger` 上使用一个静态的
    `loggerInstance`。`getInstance` 将检查 `Logger.loggerInstance` 是否存在，如果存在则返回它；否则，它将创建一个新的
    `Logger` 实例，将其设置为 `loggerInstance`，然后返回它：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using this in another module is as simple as calling `Logger.getInstance()`.
    All `getInstance` calls will return the same instance of `Logger`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个模块中使用它就像调用 `Logger.getInstance()` 一样简单。所有的 `getInstance` 调用都将返回同一个 `Logger`
    实例：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve implemented a singleton with “lazy” initialization. The initialization
    occurs when the first `getInstance` call is made. In the next section, we’ll see
    how we might extend our code to have an “eager” initialization of `loggerInstance`,
    where `loggerInstance` will be initialized when the `Logger` code is evaluated.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个具有“lazy”初始化的单例。初始化发生在第一次调用 `getInstance` 时。在下一节中，我们将看到如何扩展我们的代码以实现 `loggerInstance`
    的“eager”初始化，其中 `loggerInstance` 将在 `Logger` 代码评估时初始化。
- en: Ensuring only one singleton instance is constructed
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保只构建一个单例实例
- en: A characteristic of a singleton is the “single instance” concept. We want to
    “force” consumers to use the `getInstance` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 单例的一个特点是“单一实例”概念。我们希望“强制”消费者使用 `getInstance` 方法。
- en: 'In order to do this, we can check for the existence of `loggerInstance` when
    the contructor is called:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以在构造函数被调用时检查 `loggerInstance` 的存在：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the case where we call `getInstance` (and, therefore, `Logger.loggerInstance`
    is populated), the constructor will now throw an error:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用 `getInstance`（因此，`Logger.loggerInstance` 被填充）的情况下，构造函数现在将抛出一个错误：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This behavior is useful to ensure that consumers don’t instantiate their own
    Logger and they use `getInstance` instead. All consumers using `getInstance` means
    the configuration to set up the logger is encapsulated by the `Logger` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为有助于确保消费者不会实例化自己的记录器，而是使用`getInstance`。所有使用`getInstance`的消费者意味着设置记录器的配置被`Logger`类封装。
- en: 'There’s still a gap in the implementation, as constructing `new Logger()` before
    any `getInstance()` calls will succeed, as shown in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中仍然存在一个差距，因为如以下示例所示，在调用`getInstance()`之前构造`new Logger()`将成功：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In multithreaded languages, our implementation would also have a potential race
    condition – multiple consumers calling `Logger.getInstance()` concurrently could
    cause multiple instances to exist. However, since popular JavaScript runtimes
    are single-threaded, we won’t have to worry about such a race condition – `getInstance`
    is a “synchronous” method, so multiple calls to it would be interpreted one after
    the other. For reference, Node.js, Deno, and the mainstream browsers Chrome, Safari,
    Edge, and Firefox provide a single-threaded JavaScript runtime.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程语言中，我们的实现也可能存在潜在的竞争条件——多个消费者并发调用`Logger.getInstance()`可能会导致存在多个实例。然而，由于流行的JavaScript运行时是单线程的，我们不必担心这种竞争条件——`getInstance`是一个“同步”方法，所以对它的多次调用会被依次解释。作为参考，Node.js、Deno以及主流浏览器Chrome、Safari、Edge和Firefox都提供了一个单线程的JavaScript运行时。
- en: Singleton with eager initialization
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eager-initialization 的单例
- en: Eager initialization can be useful to ensure that the singleton is ready for
    use and features, such as disabling the constructor when an instance exists, work
    for all cases.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: eager-initialization 可以用来确保单例已准备好使用，并且像在实例存在时禁用构造函数这样的特性对所有情况都有效。
- en: 'We can eager-initialize by setting `Logger.loggerInstance` in the `Logger`
    constructor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`Logger`构造函数中设置`Logger.loggerInstance`来 eager-initialize：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This approach has the downside of the constructor performing a global state
    mutation, which isn’t ideal from a “single responsibility principle” standpoint;
    the constructor now has a side-effect of sorts (mutating global state) beyond
    its responsibility to set up an object instance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是构造函数执行全局状态突变，这在“单一职责原则”的角度来看并不理想；构造函数现在除了设置对象实例的责任之外，还有某种副作用（突变全局状态）。
- en: 'An alternative way to eager-initialize is by running `Logger.getInstance()`
    in the logger’s module; it’s useful to pair it with an `export` `default` statement:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在记录器的模块中运行`Logger.getInstance()`来 eager-initialize 的另一种方法是，它与一个`export` `default`语句配对很有用：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the preceding exports added, there are now two ways to access a logger
    instance. The first is to import `Logger` by name and call `Logger.getInstance()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了前面的导出之后，现在有两种方式可以访问记录器实例。第一种是通过按名称导入`Logger`并调用`Logger.getInstance()`：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second way to use the logger is by importing the default export:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记录器的第二种方式是通过导入默认导出：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Any code now importing `Logger` will get a pre-determined singleton instance
    of the logger.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现在导入`Logger`的代码都将获得一个预先确定的记录器单例实例。
- en: Use cases
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: A singleton shines when there should only be one instance of an object in an
    application – for example, a logger that shouldn’t be set up/torn down on every
    request.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式在应用程序中仅应有一个对象实例时特别出色——例如，一个不需要在每次请求中设置/拆除的记录器。
- en: Since the singleton class controls how it gets instantiated, it’s also a good
    fit for objects that are tricky to configure (again, a logger, a metrics exporter,
    and an API client are good examples). The instantiation is completely encapsulated
    if, like in our example, we “disable” the constructor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单例类控制其实例化方式，因此它也适合难以配置的对象（再次以记录器为例，以及度量导出器和API客户端都是很好的例子）。如果像我们的例子一样“禁用”构造函数，实例化过程将完全封装。
- en: There’s a performance benefit to constraining the application to a single instance
    of an object in terms of memory footprint.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 限制应用程序使用单个对象实例在内存占用方面具有性能优势。
- en: The major drawbacks of singletons are an effect of their reliance on global
    state (in our example, the static `loggerInstance`). It’s hard to test a singleton,
    especially in a case where the constructor is “disabled” (like in our example),
    since our tests will want to always have a single instance of the singleton.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 单例的主要缺点是其对全局状态的依赖（在我们的例子中，是静态的`loggerInstance`）。测试单例很困难，尤其是在构造函数被“禁用”的情况下（就像我们的例子一样），因为我们的测试总是希望有一个单例实例。
- en: Singletons can also be considered “global state” to some extent, which comes
    with all its drawbacks. Global state can sometimes be a sign of poor design, and
    updating/consuming global state is error-prone (e.g., if a consumer is reading
    state but it is then updated and not read again).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，单例也可以被认为是“全局状态”，这带来了所有缺点。全局状态有时可能是设计不佳的标志，更新/消费全局状态容易出错（例如，如果消费者正在读取状态，但随后状态被更新而没有再次读取）。
- en: Improvements with the “class singleton” pattern
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “类单例”模式的改进
- en: With our singleton logger implementation, it’s possible to modify the internal
    state of the singleton from outside of it. This is nothing specific to our singleton;
    it’s the nature of JavaScript. By default, its fields and methods are public.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单例日志实现中，从外部修改单例的内部状态是可能的。这并不是我们单例特有的；这是JavaScript的本质。默认情况下，它的字段和方法是公开的。
- en: 'However, this is a bigger issue in our singleton scenario, since a consumer
    could reset `loggerInstance` using a statement such as `Logger.loggerInstance
    = null` or `delete` `Logger.loggerInstance`. See the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的单例场景中，这是一个更大的问题，因为消费者可以使用诸如`Logger.loggerInstance = null`或`delete Logger.loggerInstance`之类的语句重置`loggerInstance`。请看以下示例：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In order to stop consumers from modifying the `loggerInstance` static field,
    we can make it a private field. Private fields in JavaScript are part of the ECMAScript
    2023 specification (the 13th ECMAScript edition).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阻止消费者修改`loggerInstance`静态字段，我们可以将其设为私有字段。JavaScript中的私有字段是ECMAScript 2023规范（第13版ECMAScript）的一部分。
- en: 'To define a private field, we use the `#` prefix for the field name – in this
    case, `loggerInstance` becomes `#loggerInstance`. The `isLevelEnabled` method
    becomes `#isLevelEnabled`, and we also declare `logLevel` and `transport` as `#logLevel`
    and `#``transport`, respectively:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义私有字段，我们使用字段名称前的`#`前缀——在这种情况下，`loggerInstance`变为`#loggerInstance`。`isLevelEnabled`方法变为`#isLevelEnabled`，我们还声明`logLevel`和`transport`分别为`#logLevel`和`#transport`：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It’s not possible to delete `loggerInstace` or set it to `null`, since attempting
    to access `Logger.#loggerInstance` is a syntax error:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 无法删除`loggerInstace`或将其设置为`null`，因为尝试访问`Logger.#loggerInstance`是一个语法错误：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Another useful technique is to disallow modification of fields on an object.
    In order to disallow modification, we can use `Object.freeze` to freeze the instance
    once it’s created.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的技术是不允许修改对象上的字段。为了禁止修改，我们可以在实例创建后使用`Object.freeze`将其冻结。
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, when someone attempts to change a field on the `Logger` instance, they’ll
    get `TypeError`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当有人尝试更改`Logger`实例的字段时，他们会收到`TypeError`：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We’ve now refactored our singleton implementation to disallow external modifications
    to it by using private fields and `Object.freeze`. Next, we’ll see how to use
    **EcmaScript** (**ES**) modules to deliver singleton functionality.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经重构了单例实现，通过使用私有字段和`Object.freeze`来禁止外部对其进行修改。接下来，我们将看到如何使用**EcmaScript**（**ES**）模块来提供单例功能。
- en: A singleton without class fields using ES module behavior
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用类字段且使用ES模块行为的单例
- en: The JavaScript module system has the following caching behavior – if a module
    is loaded, any further imports of the module’s exports will be cached instances
    of exports.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript模块系统具有以下缓存行为——如果加载了一个模块，任何进一步的导入该模块的导出都将被缓存为导出的实例。
- en: Therefore, it’s possible to create a singleton as follows in JavaScript.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在JavaScript中可以如下创建单例。
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Multiple imports of the default export will result in only one existing instance
    of the `MySingleton` object. Furthermore, if we don’t export the class, then the
    constructor doesn’t need to be “protected.”
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 多次导入默认导出将只存在一个`MySingleton`对象的实例。此外，如果我们不导出类，那么构造函数不需要是“受保护的”。
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For our logger, this means we could implement an eager-initialized singleton
    in JavaScript without any of the heavy-handed guarding of the constructor or even
    a `getInstance` method. Note the use of `logLevel` and `isLevelEnabled` as a public
    instance property and a public method, respectively (since it might be useful
    to have access to them from a consumer). In the meantime, `#transport` remains
    private, and we’ve dropped `loggerInstance` and `getInstance`. We’ve kept `Object.freeze()`,
    which means that even though `logLevel` is readable from a consumer, it’s not
    available to modify:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的日志记录器，这意味着我们可以在JavaScript中实现一个急切初始化的单例，而不需要任何对构造函数或`getInstance`方法的严格保护。注意`logLevel`和`isLevelEnabled`分别作为公共实例属性和公共方法的使用（因为可能需要从消费者那里访问它们）。同时，`#transport`保持私有，我们已经删除了`loggerInstance`和`getInstance`。我们保留了`Object.freeze()`，这意味着尽管`logLevel`可以从消费者那里读取，但它不可修改：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this part of the chapter, we learned how to implement the singleton pattern
    with a class that exposes a `getInstance()` method, as well as the difference
    between the eager and lazy initialization of a singleton. We’ve covered some JavaScript
    features, such as private class fields and `Object.freeze`, which can be useful
    when implementing the singleton pattern. Finally, we explored how JavaScript/ECMAScript
    modules have singleton-like behavior and can be relied upon to provide this behavior
    for a class instance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们学习了如何使用公开`getInstance()`方法的类来实现单例模式，以及单例的急切初始化和懒加载初始化之间的区别。我们介绍了一些JavaScript特性，如私有类字段和`Object.freeze`，这些特性在实现单例模式时可能很有用。最后，我们探讨了JavaScript/ECMAScript模块具有单例类似的行为，并且可以依赖它们为类实例提供这种行为。
- en: In the next section, we’ll explore the final creational design pattern covered
    in this chapter – the factory design pattern.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨本章涵盖的最后一个创建型设计模式——工厂设计模式。
- en: The factory pattern in JavaScript
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的工厂模式
- en: In a similar fashion to the discussion about the JavaScript “prototype” versus
    the prototype creational design pattern, “factory” refers to related but different
    concepts when it comes to general program design discussions and design patterns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于关于JavaScript“原型”与原型创建型设计模式的讨论，“工厂”在一般程序设计讨论和设计模式中指的是相关但不同的概念。
- en: 'A “factory,” in the general programming sense, is an object that’s built with
    the goal of creating other objects. This is hinted at by the name that refers
    to a facility that processes items from one shape into another (or from one type
    of item to another). This factory denomination means that the output of a function
    or method is a new object. In JavaScript, this means that something as simple
    as a function that returns an object literal is a factory function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般编程意义上，“工厂”是一个旨在创建其他对象的实体。这一点从其名称中可以体现出来，该名称指的是一个将物品从一个形状加工成另一个形状（或从一种类型的物品加工成另一种类型的物品）的设施。这种工厂的命名意味着函数或方法的输出是一个新对象。在JavaScript中，这意味着像返回一个对象字面量的函数这样简单的东西也是一个工厂函数：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This definition of a factory is useful, but this section of the chapter is about
    the factory design pattern, which does fit into this overall “factory” definition.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工厂的定义很有用，但本章的这一节是关于工厂设计模式的，它确实符合这个整体的“工厂”定义。
- en: The factory or factory method design pattern solves a class inheritance problem.
    A base or superclass is extended (the extended class is a subclass). The base
    class’s role is to provide orchestration for the methods implemented in the subclasses,
    as we want the subclasses to control which other objects to populate an instance
    with.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂或工厂方法设计模式解决了一个类继承问题。一个基类或超类被扩展（扩展的类是一个子类）。基类的角色是为子类实现的方法提供协调，因为我们希望子类控制用哪些其他对象填充实例。
- en: Implementation
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'A factory example is as follows. We have a `Building` base class that implements
    a `generateBuilding()` method. For now, it’s going to create a top floor using
    the `makeTopFloor` instance method. In the base class (`Building`), `makeTopFloor`
    is implemented, mainly because JavaScript doesn’t provide a way to define abstract
    methods. The `makeTopFloor` implementation throws an error because subclasses
    should override it; `makeTopFloor` is the “factory method” in this case. It’s
    how the base class defers the instantiation of objects to the subclasses:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工厂示例如下。我们有一个实现`generateBuilding()`方法的`Building`基类。目前，它将使用`makeTopFloor`实例方法创建顶层。在基类（`Building`）中，`makeTopFloor`被实现，主要是因为JavaScript没有提供定义抽象方法的方式。`makeTopFloor`的实现会抛出错误，因为子类应该重写它；在这种情况下，`makeTopFloor`是“工厂方法”。这是基类如何将对象的实例化推迟到子类的方法：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we wanted to implement a single-story house, we would extend `Building`
    and override `makeTopFloor`; in this instance, `topFloor` will have `level: 1`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们想要实现一个单层房屋，我们会扩展`Building`并重写`makeTopFloor`；在这种情况下，`topFloor`将具有`level:
    1`。'
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we instantiate `House`, which is a subclass of `Building`, we have access
    to the `generateBuilding` method; when called, it sets `topFloor` correctly (to
    `{ level:` `1 }`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们实例化`House`，它是`Building`的子类时，我们可以访问`generateBuilding`方法；当调用它时，它会正确设置`topFloor`（为`{
    level: `1` }`）。'
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, if we want to create a different type of building that has a very different
    top floor, we can still extend `Building`; we simply override `makeTopFloor` to
    return a different floor. In the case of a skyscraper, we want the top floor to
    be very high, so we’ll do the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要创建一个具有非常不同顶层的新型建筑，我们仍然可以扩展`Building`；我们只需重写`makeTopFloor`以返回不同的楼层。在摩天大楼的情况下，我们希望顶层非常高，所以我们将会这样做：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Having defined our `SkyScraper`, which is a subclass of `Building`, we can
    instantiate it and call `generateBuilding`. As in the preceding `House` case,
    the `generateBuilding` method will use `SkyScraper`’s `makeTopFloor` method to
    populate the `topFloor` instance property:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的`SkyScraper`，它是`Building`的子类后，我们可以实例化它并调用`generateBuilding`。正如前面的`House`案例一样，`generateBuilding`方法将使用`SkyScraper`的`makeTopFloor`方法来填充`topFloor`实例属性：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The “factory method” in this case is `makeTopFloor`. The `makeTopFloor` method
    is “not implemented” in the base class, in the sense that it’s implemented in
    a manner that forces subclasses that wish to use `generateBuilding` to define
    a `makeTopFloor` override.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“工厂方法”是`makeTopFloor`。在基类中，`makeTopFloor`方法是“未实现”的，也就是说，它以一种强制子类在希望使用`generateBuilding`时定义`makeTopFloor`重写的方式实现。
- en: Note that `makeTopFloor` in our examples returned object literals, as mentioned
    earlier in the chapter; this is a feature of JavaScript not available in all object-oriented
    languages (JavaScript is multi-paradigm). We’ll see different ways to implement
    the factory pattern later in this section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的示例中，`makeTopFloor`返回了对象字面量，如本章前面提到的；这是JavaScript中不是所有面向对象语言都有的特性（JavaScript是多范式的）。我们将在本节后面看到实现工厂模式的不同方法。
- en: Use cases
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: The benefit of using a factory method is that we can create a wide variety of
    subclasses without modifying the base class. This is the “open/closed principle”
    at play – the `Building` class in our example is “open” to extension (i.e., can
    be subclassed to infinity for different types of buildings) but “closed” to modification
    (i.e., we don’t need to make changes in `Building` for every subclass, only when
    we want to add new behaviors).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂方法的好处是，我们可以在不修改基类的情况下创建各种子类。这是“开/闭原则”在起作用——我们例子中的`Building`类是“开放”的，可以扩展（即可以无限地子类化以创建不同类型的建筑），但“封闭”的，不允许修改（即我们不需要为每个子类在`Building`中进行更改，只有在我们要添加新行为时才需要）。
- en: Improvements with modern JavaScript
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代JavaScript的改进
- en: The key improvement we can make with JavaScript is enabled by its first-class
    support for functions and the ability to define objects using literals (instead
    of classes being instantiated).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用JavaScript实现的关键改进是由其对函数的第一级支持以及使用字面量定义对象的能力（而不是类实例化）所启用的。
- en: JavaScript having “first-class functions” means functions are like any other
    type – they can be passed as parameters, set as variable values, and returned
    from other functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有“第一级函数”意味着函数就像任何其他类型一样——它们可以作为参数传递，设置为变量值，并从其他函数返回。
- en: 'A more idiomatic implementation of this pattern would probably involve a `generateBuilding`
    standalone function instead of a `Building` class. `generateBuilding` would take
    `makeTopFloor` either as a parameter or take an object parameter with a `makeTopFloor`
    key. The output of `generateBuilding` would be an object created using an object
    literal, which takes the output of `makeTopFloor()` and sets it as the value to
    a `topFloor` key:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的更自然实现可能涉及一个 `generateBuilding` 独立函数，而不是 `Building` 类。`generateBuilding`
    将 `makeTopFloor` 作为参数，或者接受一个包含 `makeTopFloor` 键的对象参数。`generateBuilding` 的输出将是一个使用对象字面量创建的对象，它将
    `makeTopFloor()` 的输出设置为 `topFloor` 键的值：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In order to create our house and skyscraper, we would call `generateBuilding`
    with the relevant `makeTopFloor` functions. In the case of the house, we want
    a top floor that is on level 1; in the case of the skyscraper, we want a top floor
    on level 125.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的房屋和摩天大楼，我们将使用相关的 `makeTopFloor` 函数调用 `generateBuilding`。在房屋的情况下，我们想要一个位于第
    1 层的顶层；在摩天大楼的情况下，我们想要一个位于第 125 层的顶层。
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: One reason why using functions directly works better in JavaScript is that we
    didn’t have to implement a “throw an error to remind consumers to override me”
    `makeFloor` method that we had with the `Building` class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数直接在 JavaScript 中工作得更好的一个原因是，我们不必实现一个“抛出错误以提醒消费者覆盖我”的 `makeFloor` 方法，就像我们在
    `Building` 类中做的那样。
- en: In languages other than JavaScript that have support for abstract methods, this
    pattern is more useful and natural to implement than in JavaScript, where we have
    first-class functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持抽象方法的除 JavaScript 之外的语言中，这种模式比在具有一等函数的 JavaScript 中更有用和自然实现。
- en: You also have to bear in mind that the original versions of JavaScript/ECMAScript
    didn’t include a `class` construct.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须记住，JavaScript/ECMAScript 的原始版本并没有包含 `class` 构造。
- en: In the final section of the chapter, we learned what the factory method pattern
    is and how it contrasts with the factory programming concept. We then implemented
    a class-based factory pattern scenario as well as a more idiomatic JavaScript
    version. Interspersed through this section, we covered the use cases, benefits,
    and drawbacks of the factory method pattern in JavaScript.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们学习了工厂方法模式是什么，以及它与工厂编程概念的对比。然后我们实现了一个基于类的工厂模式场景，以及一个更自然的 JavaScript
    版本。在这一节中，我们涵盖了工厂方法模式在 JavaScript 中的用例、优点和缺点。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we discussed how creational design patterns allow us
    to build more extensible and maintainable systems in JavaScript.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用创建型设计模式在 JavaScript 中构建更可扩展和可维护的系统。
- en: The prototype design pattern shines when creating many instances of objects
    that contain the same values. This design pattern allows us to change the initial
    values of the prototype and affect all the cloned instances.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式在创建包含相同值的多个对象实例时特别出色。这种设计模式允许我们更改原型的初始值，并影响所有克隆实例。
- en: The singleton design pattern is useful to completely hide initialization details
    of a class that should really only be instantiated once. We saw how JavaScript’s
    module system generates singletons and how that can be leveraged to simplify a
    singleton implementation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计模式对于完全隐藏应该只实例化一次的类的初始化细节非常有用。我们看到了 JavaScript 的模块系统如何生成单例，以及如何利用这一点来简化单例实现。
- en: The factory method design pattern allows a base class to defer the implementation
    of some object creations to subclasses. We saw which features would make this
    pattern more useful in JavaScript, as well as an alternative idiomatic JavaScript
    approach with factory functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法设计模式允许基类将一些对象创建的实现推迟到子类。我们看到了哪些特性会使这种模式在 JavaScript 中更有用，以及一个使用工厂函数的替代的
    JavaScript 习惯用法。
- en: We can now leverage creational design patterns to build classes that are composable
    and can be evolved as necessary to cover different use cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用创建型设计模式来构建可组合的类，这些类可以根据需要进化以覆盖不同的用例。
- en: Now that we know how to create objects efficiently with creational design patterns,
    in the next chapter, we’ll cover how to use structural design patterns to organize
    relationships between different objects and classes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用创建型设计模式高效地创建对象，在下一章中，我们将介绍如何使用结构型设计模式来组织不同对象和类之间的关系。
