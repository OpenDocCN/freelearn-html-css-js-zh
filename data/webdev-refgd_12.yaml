- en: Chapter 12. Server-side JavaScript – NodeJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章. 服务器端 JavaScript – NodeJS
- en: Node.js is a relatively new server platform that is built on JavaScript. One
    of the main features of Node is that it is a non-blocking server. This means that
    resource-intensive tasks will not tie up the server. Node.js can then handle many
    concurrent connections. It can also handle real-time communications more easily
    than a blocking server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是一个相对较新的基于 JavaScript 的服务器平台。Node 的一大特点是它是一个非阻塞服务器。这意味着资源密集型任务不会占用服务器。然后
    Node.js 可以处理许多并发连接。它也比阻塞服务器更容易处理实时通信。
- en: One of the main uses of Node.js is as a web server. This is a perfect task as
    serving web pages usually involves reading files and connecting to a database.
    It is able to serve more clients while either of these two actions are executing.
    This is very different compared to a blocking server. A blocking server would
    have to wait for all the resources to return before it could respond to more requests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的主要用途之一是作为 Web 服务器。这是一个完美的任务，因为服务网页通常涉及读取文件和连接到数据库。它能够在执行这两个动作中的任何一个时服务更多客户端。这与阻塞服务器非常不同。阻塞服务器必须等待所有资源返回，然后才能响应更多请求。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Note
- en: Note that this reference will only be Node.js specific; we will not cover any
    frameworks or libraries in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个参考将仅限于 Node.js 特定的；我们不会在本章中涵盖任何框架或库。
- en: The most popular frameworks are useful and should be utilized whenever possible,
    but our focus will only be on functions and modules that are included with Node.js.
    There will be no coverage of **Express** (arguably, the most used Node.js framework).
    Most importantly, we will cover the building blocks of Node.js that Express and
    its dependencies are built on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的框架是有用的，并且应该在可能的情况下使用，但我们的重点将仅限于 Node.js 内置的函数和模块。我们将不涉及 **Express**（据说是最常用的
    Node.js 框架）。最重要的是，我们将涵盖 Express 及其依赖项构建的基础。
- en: A great book that covers frameworks and more is *Building Scalable Apps with
    Redis and Node.js* by Packt Publishing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一本涵盖框架等内容的好书是 Packt Publishing 出版的 *使用 Redis 和 Node.js 构建可扩展应用程序*。
- en: 'In this chapter, the following groups of references will be described, accompanied
    with examples:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将描述以下几组参考，并附上示例：
- en: 'File and process management:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和进程管理：
- en: Modules
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Modules
- en: OS (operating system)
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS (operating system)
- en: Process
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Process
- en: File
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: File
- en: Path
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Path
- en: REPL (Read Eval Print Loop)
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: REPL (Read Eval Print Loop)
- en: Errors
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Errors
- en: 'Utilities:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Utilities:'
- en: Events
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Events
- en: Crypto
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Crypto
- en: Buffer
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buffer
- en: Console
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Console
- en: Npm (Node Package Manager)
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Npm (Node Package Manager)
- en: Stream
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stream
- en: 'Net modules:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Net 模块：
- en: createServer
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: createServer
- en: net.Server
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: net.Server
- en: 'HTTP:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'HTTP:'
- en: Server
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Server
- en: IncomingMessage
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: IncomingMessage
- en: ServerResponse
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServerResponse
- en: clientRequest
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: clientRequest
- en: File and process management
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和进程管理
- en: We will start our overview of Node.js with the basics. This will include loading
    modules, managing processes, handling files and paths, and **REPL** (**Read Eval
    Print Loop**). These are things that virtually any Node.js project will need.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始对 Node.js 的概述，从基础知识开始。这包括加载模块、管理进程、处理文件和路径，以及 **REPL** (**读取-评估-打印循环**)。这些都是几乎任何
    Node.js 项目都需要的东西。
- en: Modules
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Modules
- en: 'Node.js is a modular system. Much of the functionality of Node.js is contained
    in modules that must be loaded at runtime. This makes the knowledge of loading
    and building modules a core requirement to using Node. Here are the references
    you can use for your Node modules:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是一个模块化系统。Node.js 的许多功能都包含在必须在运行时加载的模块中。这使得了解加载和构建模块成为使用 Node 的核心要求。以下是你可以用于你的
    Node 模块的参考：
- en: '`require()`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require()`'
- en: '`modules.export`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules.export`'
- en: require()
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: require()
- en: 'This loads the module at the given path:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在给定路径加载模块：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Return value
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The return value will be an object. The properties of this object will vary,
    depending on what is loaded. We will cover `module.exports` next, which is what
    module designers and even you can use to set the value of this return value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值将是一个对象。这个对象的属性将根据加载的内容而变化。我们将在下一节介绍 `module.exports`，这是模块设计者和甚至你可以用来设置这个返回值值的。
- en: Description
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Description
- en: 'The `require()` function is used to load the module at a path, where the path
    can be a core module (a module packaged with Node.js), directory, file, or module
    (a project that you or someone else has built). As a result, it is very versatile.
    The `require()` function will try to resolve the passed-in path in this order:
    the core module, the directory or file if the path begins with "./", "/", "../",
    and then the module, take a look at the following description for more information.
    You then need to check the require function in different locations for all of
    this to work:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`require()` 函数用于在指定路径加载模块，其中路径可以是核心模块（与 Node.js 一起打包的模块）、目录、文件或模块（你或其他人构建的项目）。因此，它非常灵活。`require()`
    函数将按照以下顺序尝试解析传入的路径：核心模块、如果路径以 "./"、"/" 或 "../" 开头，则目录或文件，然后是模块。有关更多信息，请参阅以下描述。你需要检查不同位置的
    require 函数，以便所有这些都能正常工作：'
- en: You will first look for a core module. The core modules can be viewed in the
    source of Node.js under the lib directory. We will cover the most prolifically
    used modules in this chapter.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你首先会查找核心模块。核心模块可以在 Node.js 的源代码中在 lib 目录下查看。在本章中，我们将介绍最常用的模块。
- en: Next, require would load the path as a file if the string begins with "./" ,"/",
    or "../". These are current directory, root directory, and parent directory, respectively.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，如果字符串以 "./"、"/" 或 "../" 开头，require 将会将其作为文件加载路径。这些分别是当前目录、根目录和父目录。
- en: If the filename is not found, require will then try appending `.js`, `.json`,
    or `.node`. This means that the `require (./data/models)` function and `require
    (./data/models,js)` will load the same file. If require does not find a file,
    then it will try to load the path as a directory. This means it will look for
    either an `index.js` file or the main property inside `package.json`. Require
    will then either use `index.js` or `package.json` to load as a file.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到文件名，require 将尝试添加 `.js`、`.json` 或 `.node` 扩展名。这意味着 `require (./data/models)`
    函数和 `require (./data/models,js)` 将加载相同的文件。如果 require 找不到文件，它将尝试将路径作为目录加载。这意味着它会寻找
    `index.js` 文件或 `package.json` 中的主属性。require 将使用 `index.js` 或 `package.json` 来加载文件。
- en: Finally, if the path does not start with "./", "/", or "../" and it is not a
    core module, require will search for a `node_modules` folder. The first directory
    will be the `current` directory. After that, each directory will be a parent directory,
    all the way up to the `root` directory. In addition to this, require will also
    search the paths in the `NODE_PATH` environment variable.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果路径不以 "./"、"/" 或 "../" 开头，并且不是核心模块，require 将搜索 `node_modules` 文件夹。第一个目录将是
    `current` 目录。之后，每个目录将是一个父目录，一直到 `root` 目录。此外，require 还会在 `NODE_PATH` 环境变量中搜索路径。
- en: 'As a quick summary, here is the order that require will use:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 简要总结一下，require 将会使用的顺序是：
- en: Core module (no relative path)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心模块（无相对路径）
- en: File module (relative path)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件模块（相对路径）
- en: Folder module (relative path)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹模块（相对路径）
- en: The `node_modules` module (no relative path)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules` 模块（无相对路径）'
- en: 'Here are some examples of how the require function is used to load core modules,
    files, or modules:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些如何使用 require 函数加载核心模块、文件或模块的示例：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see from the comment, this example will load the HTTP core module:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如注释所示，此示例将加载 HTTP 核心模块：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This example shows you how to load a directory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何加载一个目录：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This one will load a file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个将会加载一个文件：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, this one will load a module.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个将会加载一个模块。
- en: Every Node.js project will use require many times, so knowing how and where
    it will load is important.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Node.js 项目都会多次使用 require，因此了解它如何以及在哪里加载是很重要的。
- en: Here is a simple example that demonstrates require and how it works with `module.exports`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例，演示了 require 以及它与 `module.exports` 的工作方式。
- en: 'Here is the file that will be loaded with require, `requireTest.js`, and it
    will be loaded from a relative path:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是将会用 require 加载的文件，`requireTest.js`，它将从相对路径加载：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is how to load this value in a Node.js script:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在 Node.js 脚本中加载这个值的：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: module.exports
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`module.exports`'
- en: The `module.exports` property is a convenience property used in a module to
    expose the functionality of the module outside the scope of the current file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports` 属性是一个便利属性，用于在模块中暴露模块的功能，使其超出当前文件的作用域。'
- en: Return value
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: The `module.exports` property is the return value from the module. This can
    seem misleading though. We will not return `module.exports`. It is the object
    or properties set at `module.exports` that are available from this module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports` 属性是模块的返回值。这可能会让人产生误解。我们不会返回 `module.exports`。实际上，是设置在 `module.exports`
    上的对象或属性可以从该模块中访问。'
- en: Description
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'The `module.exports` property is the link from the current file into the scope
    of the calling file. Any variables defined in the current file will not be in
    the scope of file that calls it. To make the variables available, you must either
    set them as the value of `module.exports` or as properties of `module.exports`.
    This functionality is the mechanism that Node.js uses with require. Exports can
    be set to any type: string, integer, function, object, and many others. Functions
    allow us to either pass in values or create a `constructor()` function. Objects
    can be created and then used to overwrite the exports object or can be added to
    the exports object as properties. We have all of JavaScript''s function- and object-creation
    tricks at our disposal.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports` 属性是从当前文件链接到调用文件的作用域。在当前文件中定义的任何变量都不会在调用它的文件的作用域中。为了使变量可用，你必须将它们设置为
    `module.exports` 的值或作为 `module.exports` 的属性。这种功能是 Node.js 使用 require 的机制。导出可以设置为任何类型：字符串、整数、函数、对象等。函数允许我们传递值或创建
    `constructor()` 函数。对象可以创建并用于覆盖导出对象或将其作为属性添加到导出对象中。我们拥有 JavaScript 的所有函数和对象创建技巧。'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A quick note is that require will cache output. This means consecutive calls
    to the same module will return the same instance of an object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简短的说明是，require 会缓存输出。这意味着对同一模块的连续调用将返回相同实例的对象。
- en: 'Examples of the `constructor()` function being used are shown here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了 `constructor()` 函数的使用示例：
- en: 'This allows an object to be passed in:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许传递一个对象：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This allows the export function to be executed:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许导出函数被执行：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `foo` property will be used in the following two examples:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下两个示例中，将使用 `foo` 属性：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The OS module
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OS 模块
- en: Here are the most important functions and properties of the `os` module. The
    `os` module allows you to get information from the operating system. This is important
    as we may need to know the hostname or how many CPUs are currently available.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `os` 模块最重要的函数和属性。`os` 模块允许你从操作系统中获取信息。这很重要，因为我们可能需要知道主机名或当前有多少个 CPU 可用。
- en: All the functions that we will look at now assume that `var os = require('os')`
    is already in the file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要查看的所有函数都假设 `var os = require('os')` 已经在文件中。
- en: hostname()
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hostname()
- en: 'This will return the hostname of the device:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回设备的主机名：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Description
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'An example of how the `os.hostname()` function is used is shown here. In this
    case, it will return the hostname of the current computer used. It will not return
    the domain suffix of the computer:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了如何使用 `os.hostname()` 函数的示例。在这种情况下，它将返回当前计算机使用的计算机名。它不会返回计算机的域名后缀：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: cpus()
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cpus()
- en: 'This will return the number of CPUs of the current device:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回当前设备的 CPU 数量：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Description
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'We will get an array of objects that map to each CPU. The objects will have
    the model, speed, and times:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到一个映射到每个 CPU 的对象的数组。这些对象将包含型号、速度和 times：
- en: Model and speed are the processor model and speed of the CPU, respectively.
    Note that, most of the time, model and speed will not be relevant to our code.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型和速度分别代表 CPU 的型号和速度。请注意，大多数情况下，型号和速度与我们的代码无关。
- en: Times has the breakdown of how many milliseconds the CPU has spent in `user`,
    `nice`, `sys`, `idle`, and `irq`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Times 展示了 CPU 在 `user`、`nice`、`sys`、`idle` 和 `irq` 中的耗时分布。
- en: This information can be used, most of the time, to find out how many CPUs the
    machine has. It is good to know this information, as Node.js is single threaded
    and we can launch multiple processes in a cluster for each CPU.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些信息可以用来找出机器有多少个 CPU。了解这些信息是有好处的，因为 Node.js 是单线程的，我们可以为每个 CPU 在集群中启动多个进程。
- en: 'Here is an example of getting the number of CPUs on a computer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个获取计算机上 CPU 数量的示例：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: networkInterfaces()
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: networkInterfaces()
- en: 'This gets a list of network interfaces:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取网络接口列表：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Description
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This will be an object that contains all the network interfaces. Each property
    maps to an interface and it will have an array of all the IP addresses (IPv4 and
    IPv6).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含所有网络接口的对象。每个属性映射到一个接口，并且它将有一个包含所有 IP 地址（IPv4 和 IPv6）的数组。
- en: 'As an example, this is how you can get the object that has all the interfaces
    for a computer:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是获取计算机所有接口的对象的方法：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The process module
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程模块
- en: Process is an object that allows us to get access to events on the process.
    We can also get access to `stdin`, `stdout`, and `stderr`. These are global objects
    that will be available in any file or context.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是一个对象，它允许我们访问进程上的事件。我们还可以访问`stdin`、`stdout`和`stderr`。这些是全局对象，在任何文件或上下文中都可用。
- en: stdout
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stdout
- en: The `stdout` object is a writable stream.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout`对象是一个可写流。'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Description
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is the stream that will connect to `stdout`. Note that streams will be
    covered later in this chapter under Utilites. If we are running Node.js as a console
    application, this is where we could write to `stdout` if needed. Most streams
    in Node are non-blocking, but writes to stdout and stderr are blocking.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是连接到`stdout`的流。请注意，流将在本章的“实用工具”部分稍后介绍。如果我们以控制台应用程序的形式运行Node.js，如果需要，我们可以在这里写入`stdout`。Node.js中的大多数流都是非阻塞的，但写入stdout和stderr是阻塞的。
- en: We also can use `stdout` to find out whether Node.js is running in TTY. We can
    access `process.stdout.isTTY`. This is a Boolean value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`stdout`来找出Node.js是否在TTY中运行。我们可以访问`process.stdout.isTTY`。这是一个布尔值。
- en: The example here will show us how to write a message to the `stdout` stream.
    By default, this will be sent to the `process.stdout.write` console. This will
    write to `stdout`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的示例将展示如何将消息写入`stdout`流。默认情况下，这将发送到`process.stdout.write`控制台。这将写入`stdout`。
- en: stderr
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stderr
- en: The `stderr` object is a writable stream.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`stderr`对象是一个可写流。'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Description
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is similar to `stdout`, with the key difference being it writes to `stderr`.
    This is very useful for console applications as we can write to the console what
    is happening.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`stdout`类似，关键区别在于它写入`stderr`。这对于控制台应用程序非常有用，因为我们可以将正在发生的事情写入控制台。
- en: As an example, this writes to the `stderr` stream. By default this will write
    to the console.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这会将内容写入`stderr`流。默认情况下，这将写入控制台。
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: stdin
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stdin
- en: This is a readable stream that maps to `stdin`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个映射到`stdin`的可读流。
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Description
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This maps to the standard stream, `stdin`, in the same way `stdout` and `stderr`
    map to the `stderr` streams. The difference is that the `stdin` object is readable,
    while the others are writable. Anything that is piped into this process can be
    read out using `process.stdin`. To read from a readable stream, we will have to
    listen for two possible events that let us know how we can retrieve data. The
    first is readable, and the other is data. We will cover this more in depth when
    we get to the stream section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这与标准流`stdin`相对应，就像`stdout`和`stderr`映射到`stderr`流一样。区别在于`stdin`对象是可读的，而其他的是可写的。任何通过管道输入此进程的内容都可以使用`process.stdin`读取出来。要从可读流中读取，我们需要监听两个可能的事件，这些事件会告诉我们如何检索数据。第一个是可读事件，另一个是数据事件。当我们到达流部分时，我们将更深入地介绍这一点。
- en: 'For instance, this example takes the data that is sent in through `stdin` and
    sends it to `stdout` using the readable event:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个例子将`stdin`中发送的数据通过可读事件发送到`stdout`：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: argv
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: argv
- en: 'This is all the command-line arguments passed in:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有传递的命令行参数：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Description
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `argv` commands will be an array of all the arguments passed into this script.
    Arguments are split by spaces. This means that `debug=true` (which has no spaces)
    will be one argument, and `debug = true` (a space between each word) will be three.
    This is an important distinction to keep in mind if you want to pass values in
    arguments. Arguments `0` and `1` will always be the node and the path and filename
    of the current script.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv`命令将是一个包含传递给此脚本的全部参数的数组。参数通过空格分隔。这意味着`debug=true`（没有空格）将是一个参数，而`debug
    = true`（每个单词之间有空格）将是三个。如果你想在参数中传递值，这是一个需要记住的重要区别。参数`0`和`1`将始终是节点和当前脚本的路径和文件名。'
- en: 'Here is an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Signal events
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号事件
- en: 'Signal events allow you to listen for the standard POSIX signals:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 信号事件允许你监听标准的POSIX信号：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Description
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'All of the `POSIX` signals, except `SIGKILL` and `SIGSTOP`, can be listened
    for. In addition to these signals, you can also listen for some Windows signals.
    Here is the list of signals:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`SIGKILL`和`SIGSTOP`之外的所有`POSIX`信号都可以监听。除了这些信号之外，你还可以监听一些Windows信号。以下是信号的列表：
- en: '`SIGUSR1`: This is a user-defined signal. In Node.js, it is usually used to
    start the debugger.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGUSR1`：这是一个用户定义的信号。在Node.js中，它通常用于启动调试器。'
- en: '`SIGTERM`: This is the signal to terminate.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTERM`：这是一个终止信号。'
- en: '`SIGINT`: This is the signal to interrupt. It is usually sent by pressing *Ctrl*
    + *C*.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGINT`：这是中断的信号。通常通过按下 *Ctrl* + *C* 发送。'
- en: '`SIGPIPE`: This lets a process know when it is trying to pipe to a nonexistent
    process.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGPIPE`：这会让进程知道它正在尝试向一个不存在的进程进行管道操作。'
- en: '`SIGHUP`: This is the signal that tells a process that the terminal it was
    running in has hung up.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGHUP`：这是告诉进程它运行的终端已经挂起的信号。'
- en: '`SIGBREAK`: This is non-POSIX and is used by Windows. It should be used in
    a manner similar to `SIGINT`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGBREAK`：这是一个非POSIX信号，由Windows使用。它应该以类似于`SIGINT`的方式使用。'
- en: '`SIGWINCH`: This is the signal to tell the process that the window has changed
    size.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGWINCH`：这是告诉进程窗口已更改大小的信号。'
- en: 'Here is an example of listening for `SIGINT`, which recognizes that *Ctrl*
    + *C* was pressed:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个监听 `SIGINT` 的示例，它识别出按下了 *Ctrl* + *C*：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: process.env
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: process.env
- en: 'This object contains the environment variables:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象包含环境变量：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Description
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `process.env` object is a simple JavaScript object that contains all the
    environment variables. Each property will be a string.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.env` 对象是一个简单的JavaScript对象，包含所有环境变量。每个属性都将是一个字符串。'
- en: A great place to put configuration settings is in the environment when building
    an extensible application. The `process.env` object can then be used to check
    whether the current environment is in production or even to just store the configuration
    settings.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建可扩展应用程序时，将配置设置放在环境变量中是一个很好的地方。然后可以使用 `process.env` 对象来检查当前环境是否为生产环境，甚至只是存储配置设置。
- en: 'Here is an example of checking for environment and setting a value from the
    environment:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个检查环境和从环境中设置值的示例：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: kill
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: kill
- en: 'This will send a signal event to a process:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向进程发送一个信号事件：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Description
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This will send any of the signal events that are defined in the signal events
    section, which that we covered earlier. This is essentially running the `POSIX`
    kill command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发送信号事件部分中定义的任何信号事件，我们在前面已经讨论过。这本质上是在运行 `POSIX` kill 命令。
- en: We can use this kill command to send the current process a signal, using `process.pid`,
    or to send another process that we have a reference to the kill signal.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个kill命令向当前进程发送信号，使用 `process.pid`，或者向另一个我们有引用的进程发送kill信号。
- en: 'Here is an example of killing the specific process ID `4634`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个杀死特定进程ID `4634` 的示例：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: pid
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pid
- en: 'This gets the current `pid`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取当前的 `pid`：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Description
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: It is the `pid` (process ID) of the process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是进程的 `pid`（进程ID）。
- en: 'This is an example of `process.kill` and `process.pid` used together:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `process.kill` 和 `process.pid` 一起使用的示例：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: cwd
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cwd
- en: 'This gets the current working directory:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取当前工作目录：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is an example that set the `cwd` variable to the current working directory
    of the process:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将 `cwd` 变量设置为进程当前工作目录的示例：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: File functions
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件函数
- en: This section is not a true module, like the previous section on process. This
    section will focus on any of the functions or modules that allow us to read, write,
    or find files and directories.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不是一个真正的模块，就像之前关于进程的章节。本节将关注任何允许我们读取、写入或查找文件和目录的函数或模块。
- en: __filename
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: __filename
- en: 'This returns a string of the current filename:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回当前文件名的字符串：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Description
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `__filename` command returns the current filename. This can be different,
    depending on which file is being executed. A module that is being executed will
    return its filename instead of the main entry point.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`__filename` 命令返回当前文件名。这可能会根据正在执行的文件而有所不同。正在执行的模块将返回其文件名而不是主入口点。'
- en: 'Here is an example of logging the current filename to the console:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将当前文件名记录到控制台的示例：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: __dirname
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: __dirname
- en: 'This is a string of the current directory:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个当前目录的字符串：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Description
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Much like `__filename`, this will return the currently executing file's directory.
    The `__dirname` command is used many times when a relative path needs to be created.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `__filename` 类似，这将返回当前正在执行的文件的目录。`__dirname` 命令在需要创建相对路径时经常被使用。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both the `__filename` and `__dirname` variables are available in any file being
    executed by Node.js. They are determined per file, so they are correct for each
    file that gets executed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`__filename` 和 `__dirname` 变量在Node.js执行的任何文件中都是可用的。它们按文件确定，因此对于每个执行的文件都是正确的。'
- en: 'This example assumes Express has been loaded as express:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例假设Express已经被加载为express：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The file module
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件模块
- en: We will now look at a list of key functions in the file module. All of these
    functions just run the underlying `POSIX` commands.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看文件模块中的关键函数列表。所有这些函数只是运行底层的 `POSIX` 命令。
- en: Each of the commands we cover will have an asynchronous and synchronous version
    of each function. The synchronous function will be the same name, with Sync appended,
    for example, `open` and `openSync`. In a way, the asynchronous versions are more
    like Node.js, in that, they let the event loop process without holding up execution.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的每个命令都会有每个函数的异步和同步版本。同步函数将使用相同的名称，并在后面添加 Sync，例如 `open` 和 `openSync`。从某种意义上说，异步版本更像是
    Node.js，因为它们允许事件循环处理而不阻塞执行。
- en: Each asynchronous function will need a callback function defined as the last
    parameter. This function will be in the form of `function(err, result)`. We will
    cover this when we get to handling errors. The quick takeaway is that the first
    parameter, `err`, will be `null` if no error occurred, or it will have the error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个异步函数都需要定义一个作为最后一个参数的回调函数。这个函数的形式将是 `function(err, result)`。我们将在处理错误时介绍这一点。快速总结是，如果没有发生错误，第一个参数
    `err` 将是 `null`，或者它将包含错误。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the current versions of Node.js, you need not use a callback function, but
    this will become an exception in v0.12.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本的 Node.js 中，您不需要使用回调函数，但在 v0.12 版本中这将成为一个例外。
- en: The synchronous functions will not process anything in the event loop until
    the function returns. While this seems against the Node.js non-blocking paradigm,
    it makes sense in certain cases, for example, when a specific file must be opened
    before anything else can process. This means that the classic `try/catch` is needed
    to handle any exceptions or errors.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 同步函数将在函数返回之前不在事件循环中处理任何内容。虽然这似乎与 Node.js 的非阻塞范式相矛盾，但在某些情况下是有意义的，例如，在处理其他任何内容之前必须打开特定文件时。这意味着需要使用经典的
    `try/catch` 来处理任何异常或错误。
- en: In almost every circumstance, the asynchronous version is the one that should
    be used.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，都应该使用异步版本。
- en: 'Each example is under the assumption that the `fs` variable already exists.
    Here is the code that sets the `fs` variable to the `fs` module:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例都基于 `fs` 变量已经存在的假设。以下是设置 `fs` 变量为 `fs` 模块的代码：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: stat
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stat
- en: 'This returns `fs.Stats`, which is an object with information about the queried
    file or directory:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 `fs.Stats`，这是一个包含查询的文件或目录信息的对象：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Description
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `stat` variable gets the the data that would be returned after running `stat()`
    on the operating system. The `stat` object is an instance of `fs.Stats`. This
    object gives us useful functions such as `isFile()` and `isDirectory()`. In addition
    to this, `fs.Stats` has many properties. We can see the modified time, access
    time, and file size.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`stat` 变量获取在操作系统上运行 `stat()` 后返回的数据。`stat` 对象是 `fs.Stats` 的一个实例。该对象提供了诸如 `isFile()`
    和 `isDirectory()` 等有用的函数。此外，`fs.Stats` 还有许多属性。我们可以看到修改时间、访问时间和文件大小。'
- en: There are more functions and properties, but these are the most likely used.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多函数和属性，但这些都是最可能使用的。
- en: The `fs.lstat()` and `fs.fstat()` functions will both return an `fs.Stats` object
    when pointed to a file. The difference is that `lstat` will run against a link
    instead of following the link to the file or directory. The `fstat` runs against
    a file descriptor instead of a path.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.lstat()` 和 `fs.fstat()` 函数都会在指向文件时返回一个 `fs.Stats` 对象。区别在于 `lstat` 将针对链接运行而不是跟随链接到文件或目录。`fstat`
    将针对文件描述符而不是路径运行。'
- en: 'Here is an example that loads a file named `test.txt` in the same directory
    as the code file and logs the `fs.Stats` object:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，它加载与代码文件相同的目录下的名为 `test.txt` 的文件，并记录 `fs.Stats` 对象：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: open
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: open
- en: 'This returns a file descriptor of the path passed in:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回传入路径的文件描述符：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Description
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'This will open a file in the path passed in. There are many flags that can
    be passed. They are described here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在传入的路径中打开一个文件。可以传入许多标志。它们在这里进行了描述：
- en: '`r`: Read only, errors when file does not exist'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`: 只读，当文件不存在时出错'
- en: '`r+`: Read and write, errors when file does not exist'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r+`: 读写，当文件不存在时出错'
- en: '`rs`: Read synchronous, here, "synchronous" only refers to the filesystem caching
    data and not synchronous such as `openSync`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rs`: 只读同步，这里的“同步”仅指文件系统缓存数据，而不是像 `openSync` 这样的同步'
- en: '`rs+`: Read and write synchronous'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rs+`: 读写同步'
- en: '`w`: Write'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`: 写入'
- en: '`wx`: Write, errors when file exists'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx`: 写入，当文件存在时出错'
- en: '`w+`: Read and write, file is created or truncated'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w+`: 读写，文件被创建或截断'
- en: '`a`: Append, file is created'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`: 追加，文件被创建'
- en: '`ax`: Append, errors when file exists'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax`: 追加，当文件存在时出错'
- en: '`a+`: Read and append, file is created'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a+`: 读取和追加，文件被创建'
- en: '`ax+`: Read and append, errors when file exists'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax+`: 读取和追加，当文件存在时出错'
- en: The flags allow you to open, read, and write a file, whether it exists or not.
    This means that most of the time, a call to `fs.exists` is not required as one
    of the flags will give you the answer you need.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 标志允许你打开、读取和写入文件，无论它是否存在。这意味着大多数时候，不需要调用 `fs.exists` 作为标志之一，因为其中一个标志会给你需要的答案。
- en: The mode parameter is the permissions that are used if a file is created. It
    defaults to `0666`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 模式参数是在创建文件时使用的权限。默认为 `0666`。
- en: Finally, the callback returns a file descriptor. With this, data can be read
    or written using `fs.read` or `fs.write`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回调返回一个文件描述符。有了这个，可以使用 `fs.read` 或 `fs.write` 来读取或写入数据。
- en: 'This is an example of opening the file `test.txt`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个打开文件 `test.txt` 的示例：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: read
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: read
- en: 'This reads from a file descriptor:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件描述符读取：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Description
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `read()` function takes a lot of parameters to run. We need a file descriptor,
    which we get from open, a buffer, and the size of the file. In the example, we
    used `fs.stat` to get the file size.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()` 函数运行需要很多参数。我们需要一个文件描述符，这是从打开中获得的，一个缓冲区，以及文件的大小。在示例中，我们使用了 `fs.stat`
    来获取文件大小。'
- en: 'Here is a full example of opening a file and reading from it:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个打开文件并从中读取的完整示例：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: readFile
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: readFile
- en: 'This is a simplified version for reading a file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个读取文件的简化版本：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Description
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `readFile()` function greatly simplifies the process of reading a file in
    Node.js. In the previous function, `fs.read`, we needed to set everything up before
    we tried to read the file. The `readFile()` function allows us to just pass a
    filename and get a buffer back of what is in the file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile()` 函数极大地简化了在 Node.js 中读取文件的过程。在之前的 `fs.read` 函数中，我们需要在尝试读取文件之前设置好一切。`readFile()`
    函数允许我们只传递一个文件名，然后返回文件中的缓冲区。'
- en: The `optional options` object takes a flag and an encoding property. The flag
    property is the same as the flag from `fs.open`, so any of them can be used. The
    encoding is used for the buffer that is returned in the callback.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional options` 对象接受一个标志和一个编码属性。标志属性与 `fs.open` 中的标志相同，因此可以使用任何一个。编码用于回调中返回的缓冲区。'
- en: 'Here is an example that demonstrates how much easier it is to load a file with
    `readFile`. The example is also using the `optional options` parameter:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了使用 `readFile` 加载文件有多容易。该示例还使用了 `optional options` 参数：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: close
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: close
- en: 'This will close a file descriptor:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将关闭一个文件描述符：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Description
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: It is important to close any files that we open in our scripts. If we get a
    file descriptor from `fs.open`, we will need to call `fs.close` on that file descriptor
    at some point.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中打开的任何文件都很重要。如果我们从 `fs.open` 获取文件描述符，我们将在某个时候调用 `fs.close` 来关闭该文件描述符。
- en: 'This is an example of closing a file descriptor:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关闭文件描述符的示例：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: write
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: write
- en: 'This writes to a file descriptor:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是写入文件描述符的示例：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Description
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `write()` function takes a file descriptor and buffer to write to a file.
    Much like read, we have to pass in quite a few parameters to make this work.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`write()` 函数接受一个文件描述符和一个要写入文件的缓冲区。与读取类似，我们必须传递相当多的参数才能使其工作。'
- en: In the following example, we are reading a file into a buffer and then writing
    that buffer back out to another file. The offset and length are both integers
    that we need to pass in. The position can be an integer, but it can also be `null`.
    `Null` will start writing at the current position in the file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将文件读入缓冲区，然后将该缓冲区写回另一个文件。偏移量和长度都是需要传递的整数。位置可以是整数，也可以是 `null`。`Null`
    将从文件当前位置开始写入。
- en: 'Just like read, write can be complex. Here is a full example of reading from
    one file and writing to another:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 就像读取一样，写入也可以很复杂。这里有一个从文件读取并写入另一个文件的完整示例：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: writeFile
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: writeFile
- en: 'This is a simplified function to write to a file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个写入文件的简化函数：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Description
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Exactly like the difference between read and `readFile`, `writeFile` is a simplified
    version of write. We just pass in a filename and a string or buffer, and it will
    write the file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如读取和 `readFile` 之间的区别一样，`writeFile` 是写入的简化版本。我们只需传递一个文件名和一个字符串或缓冲区，它就会写入文件。
- en: The callback only returns an error when it occurs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，回调只返回错误。
- en: '`readFile` and `writeFile` seem like the best choices in most cases, and in
    fact, this is most likely true. The main thing that you give up using these functions
    is control. You can only read an entire file or write an entire file.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`readFile`和`writeFile`似乎是最佳选择，实际上，这很可能就是真的。使用这些函数所放弃的主要是控制权。你只能读取整个文件或写入整个文件。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With read or write, you can read any portion and write any portion of a file.
    This is an important difference to keep in mind.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用读取或写入，你可以读取文件中的任何部分，也可以写入文件中的任何部分。这一点很重要，需要记住。
- en: 'Here is an example of `writeFile`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`writeFile`的一个例子：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: appendFile
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: appendFile
- en: 'This function allows us to append a file:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数允许我们追加文件：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Description
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: '`appendFile` exists because `writeFile` will only write an entire file. So,
    we need another function to add to a file. This is where giving up some control
    for ease comes in. If we were using a file descriptor and write, then we could
    choose to start writing at the end of the file. This is effectively appending
    the file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendFile`存在的原因是`writeFile`只会写入整个文件。因此，我们需要另一个函数来向文件中添加内容。这就是为了方便而放弃一些控制权的地方。如果我们使用文件描述符和写入操作，那么我们可以选择从文件的末尾开始写入。这实际上就是追加文件：'
- en: 'Here is an example of `appendFile`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`appendFile`的一个例子：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The path module
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`path`模块'
- en: The `path` module is separate from the file module. Path is concerned with fixing
    paths, whereas file is concerned with working with files and directories. Many
    times, these modules will be used together.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`模块与文件模块是分开的。`path`模块关注的是路径的修正，而文件模块关注的是文件和目录的操作。很多时候，这两个模块会一起使用。'
- en: 'The functions covered are the most used and most useful. You will most likely
    need to locate paths relative to your current project, and this is what the path
    module is for:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖的函数是最常用且最有用的。你很可能需要定位到当前项目相对的路径，这正是`path`模块的作用所在：
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `path` module does not check for the existence of path modifications.
    It essentially only makes changes to the string value of a path.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`path`模块不会检查路径修改的存在性。它本质上只对路径的字符串值进行修改。
- en: 'Just like the other modules, the example assumes that the path module has been
    loaded:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他模块一样，这个例子假设`path`模块已经被加载：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: normalize
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: normalize
- en: 'This returns a string of the path with any oddities fixed:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个经过修正的路径字符串：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Description
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Normalize will fix many problems associated with reading paths. A great example
    of this is the difference between Windows and Unix paths. Unix uses forward slashes,
    and Windows uses backslashes. Normalize will return the correct slashes based
    on the system it is executed on.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`normalize`函数将修复与读取路径相关联的许多问题。一个很好的例子是Windows和Unix路径之间的差异。Unix使用正斜杠，而Windows使用反斜杠。`normalize`将根据执行的环境返回正确的斜杠。'
- en: In addition to this, normalize will also remove the current directory and parent
    directory shortcuts, (`.` and `..` respectively). It will also remove double slashes
    from a directory. It normalizes any paths passed in.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`normalize`还会移除当前目录和父目录的快捷方式（分别是`.`和`..`），也会从目录中移除多余的斜杠。它会规范化传入的所有路径。
- en: 'Here is an example of using Unix slashes on a Windows system. This example
    will change all the slashes to backslashes:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在Windows系统上使用Unix斜杠的例子。这个例子会将所有的斜杠都转换为反斜杠：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: join
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: join
- en: 'This returns a string of all the paths joined together:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有路径连接在一起形成的字符串：
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Description
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Join makes it easy to create a path from partial paths. This seems like something
    that can be done with concatenation, but it is easy to forget about path separators.
    Join will make sure that the path separators will all be in the correct spots.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`函数使得从部分路径创建完整路径变得简单。这看起来像是可以通过连接操作完成的，但很容易忘记路径分隔符。`join`函数会确保路径分隔符都位于正确的位置。'
- en: 'Here is an example of `join`. The example will take all the parameters and
    join them together with the correct slash for your system:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`join`的一个例子。这个例子将接受所有参数，并使用系统正确的斜杠将它们连接起来：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: resolve
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: resolve
- en: 'This returns the string of the path based on the parameters:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据参数返回路径的字符串：
- en: '[PRE59]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Description
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This can be viewed as the cd command executed for each parameter. The paths
    passed in can be relative or full paths. A relative path will add to the returned
    path, and a full path will be used whole.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以看作是对每个参数执行的cd命令。传入的路径可以是相对路径或完整路径。相对路径将添加到返回的路径中，而完整路径将被整个使用。
- en: 'Here are two examples:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个例子：
- en: 'Relative paths, will return `/home/josh/test`:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对路径将返回`/home/josh/test`：
- en: '[PRE60]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A full path will return `/home/brian/node`:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整路径将返回`/home/brian/node`：
- en: '[PRE61]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: relative
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: relative
- en: 'This returns the difference between the `to` and `from` paths:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回`to`和`from`路径之间的差异：
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Description
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The path returned can be used with `cd` to change to the new directory.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的路径可以用`cd`来更改到新目录。
- en: 'Here is an example that will return `../../brian/node`, because you must go
    up two parent folders and over to `brian/node` to get from one to the other:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，将返回`../../brian/node`，因为您必须向上移动两个父目录，然后转到`brian/node`才能从一个移动到另一个：
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: dirname
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dirname
- en: 'This returns a string of the directory name:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回目录名字符串：
- en: '[PRE64]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This example will return the directory that the current file is in. If the
    file was in the directory `/home/users/jjohanan/node`, then the example will return
    `/home/users/jjohanan/node`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将返回当前文件所在的目录。如果文件位于`/home/users/jjohanan/node`目录中，则示例将返回`/home/users/jjohanan/node`：
- en: '[PRE65]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: basename
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: basename
- en: 'This returns a string of the final part of a path:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回路径的最后一部分字符串：
- en: '[PRE66]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Description
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This will either return the filename or directory depending on what path is
    passed in. The optional `ext` parameter will remove that portion from the return
    value if it exists.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据传入的路径返回文件名或目录。如果存在，可选的`ext`参数将从返回值中移除该部分。
- en: 'Here are two examples, one involving a file and the other a directory:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个示例，一个涉及文件，另一个涉及目录：
- en: 'This will return `test`:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将返回`test`：
- en: '[PRE67]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This will return `josh`:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将返回`josh`：
- en: '[PRE68]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: extname
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: extname
- en: 'This returns a string of the extension of the path. If there is no extension,
    a blank string is returned:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回路径的扩展名字符串。如果没有扩展名，则返回一个空字符串：
- en: '[PRE69]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here are two examples:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个示例：
- en: 'This example will return `.js`:'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此示例将返回`.js`：
- en: '[PRE70]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This example will return a blank string:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此示例将返回一个空字符串：
- en: '[PRE71]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: REPL
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REPL
- en: REPL stands for **Read Eval Print Loop**. What this means is that it is an interactive
    console. We can enter in a command (**Read**). The command will be executed (**Eval**).
    The output of the command will will be printed to the console (**Print**). Finally,
    we can do this as many times as we want (**Loop**). REPL is great to run a few
    lines of code to see what they will do.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: REPL代表**读取-评估-打印循环**。这意味着它是一个交互式控制台。我们可以输入一个命令（**读取**）。命令将被执行（**评估**）。命令的输出将被打印到控制台（**打印**）。最后，我们可以多次这样做（**循环**）。REPL非常适合运行几行代码以查看它们将做什么。
- en: node
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: node
- en: 'This starts Node.js in the REPL mode:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在REPL模式下启动Node.js：
- en: '[PRE72]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Description
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The main way REPL will be used is by calling it directly. This can be done by
    executing Node.js without a file to serve, by running just `node`. Once `node`
    has returned with a prompt, we can add commands and see what happens when we run
    them. This is perfect to test a few lines of code.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: REPL的主要使用方式是通过直接调用它。这可以通过运行不带文件服务的Node.js来实现，只需运行`node`。一旦`node`返回提示符，我们就可以添加命令并查看运行它们时会发生什么。这对于测试几行代码非常完美。
- en: 'Here is a quick example of logging in to the console; first run `node` to get
    a prompt and then run the command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速示例，说明如何在控制台中登录；首先运行`node`以获取提示符，然后运行命令：
- en: '[PRE73]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Handling errors
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: Errors are a part of any development project. We must be able to handle errors
    in a graceful way. If we do not, then we are creating bad experiences for our
    users. Even worse, we could be opening up a vector for attack. A stack trace that
    gets sent to an end user can give out many details.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是任何开发项目的一部分。我们必须能够优雅地处理错误。如果我们不这样做，那么我们正在为我们的用户提供糟糕的体验。更糟糕的是，我们可能会打开攻击的途径。发送给最终用户的堆栈跟踪可能会泄露许多细节。
- en: This will be a special section that deals more with design patterns than with
    actual code reference. Node.js is an asynchronous event-driven platform. For the
    major part, most people have not worked on a platform like this and can make mistakes
    when handling errors. We feel that handling errors is very important.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个专门处理设计模式而不是实际代码引用的特殊部分。Node.js是一个异步事件驱动平台。对于大多数人来说，他们没有在类似这样的平台上工作过，处理错误时可能会犯错。我们认为处理错误非常重要。
- en: The core of this information comes from Joyent, one the major forces behind
    `Node.js` today. You can find more information on Joyent at [https://www.joyent.com/developers/node/design/errors](https://www.joyent.com/developers/node/design/errors).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息的核心来自Joyent，它是今天`Node.js`背后的主要力量之一。您可以在[https://www.joyent.com/developers/node/design/errors](https://www.joyent.com/developers/node/design/errors)上找到有关Joyent的更多信息。
- en: Types of errors
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误类型
- en: 'Errors can be split into two types: **operational** and **programmer** errors.
    Operational errors are errors that occur during the operation of an application.
    A database server not being accessible is an example. These errors can be planned
    for and handled gracefully.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可以分为两种类型：**操作**错误和**程序员**错误。操作错误是在应用程序操作期间发生的错误。例如，数据库服务器不可访问就是一个例子。这些错误可以计划并优雅地处理。
- en: Next is programmer errors, which are errors in the literal sense. For example,
    a piece of code is malformed or an unexpected condition has come up. These are
    very hard to plan for (if we had planned for them, then they wouldn't be errors!).
    These will almost always break the server, so we can come back through the logs
    to find what went wrong.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是程序员错误，这在字面上是错误。例如，一段代码格式不正确或出现了意外的条件。这些很难计划（如果我们已经计划了它们，那么它们就不会是错误了！）。这些几乎总是会破坏服务器，因此我们可以通过日志回溯来找出出了什么问题。
- en: Error design patterns
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误设计模式
- en: 'Now that we know the two different types of errors, let''s look at the three
    ways of alerting an application that has an error. The three ways are throwing
    the error, asynchronous callback, and emitting an error event:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了两种不同类型的错误，让我们看看三种通知应用程序有错误的方式。这三种方式是抛出错误、异步回调和发出错误事件：
- en: 'The first pattern of throwing the error is built into JavaScript. This pattern
    is great for any synchronous code. If we are doing any synchronous operations
    and an error occurs, we should throw it. When handling a synchronous call, we
    should wrap the function call in a `try/catch` block. Here is an example with
    `JSON.parse`, which runs synchronously and throws an error when a non-JSON string
    is passed to it:'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出错误的第一个模式是内置于 JavaScript 中的。这种模式非常适合任何同步代码。如果我们进行任何同步操作并且发生错误，我们应该抛出它。在处理同步调用时，我们应该在函数调用周围包裹一个
    `try/catch` 块。以下是一个使用 `JSON.parse` 的示例，它同步运行，并在传递非 JSON 字符串时抛出错误：
- en: '[PRE74]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The next pattern is using an asynchronous callback. Many built-in Node functions
    do this already. The pattern is to use a callback that has the signature `function(error,
    result)`. The first parameter will either have an error or be null or undefined.
    We can implement this ourselves whenever we write an asynchronous function. If
    there is an error, return it in the callback as the first parameter.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个模式是使用异步回调。许多内置的 Node 函数已经这样做了。模式是使用一个具有签名 `function(error, result)` 的回调函数。第一个参数将要么包含一个错误，要么是
    null 或 undefined。我们可以在编写任何异步函数时自行实现这一点。如果有错误，请在回调中将它作为第一个参数返回。
- en: Note
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When handling errors like these, we must put an error check in every callback
    function. This is important, as not doing this can silently swallow errors.
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当处理这些错误时，我们必须在每个回调函数中放置一个错误检查。这是非常重要的，因为不这样做可能会默默地吞下错误。
- en: A good example of this is asynchronous and synchronous `filesystem` module calls.
    For example, read takes a callback, and `readSync` should be wrapped in a `try/catch`
    block.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个好例子是异步和同步的 `filesystem` 模块调用。例如，读取操作需要一个回调，而 `readSync` 应该被包裹在一个 `try/catch`
    块中。
- en: 'Here is an example callback and check for error:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例回调和错误检查：
- en: '[PRE75]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, we can emit an error event. This is used for asynchronous functions
    as well. Whether we implement a callback or event is a personal choice, but it
    should be clear which one is being used. It is also a best practice to just implement
    one. Many times, an event is used when there is a long running asynchronous process.
    Reading data from a network socket is an example. A socket does not always give
    the data in one simple pass, so events are set up. One of those events is an error
    event. To handle this, we just need to listen for that event. Here is an example
    of listening for the error event of a socket:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以发出一个错误事件。这也用于异步函数。我们实现回调或事件是个人选择，但应该清楚使用的是哪一个。这也是一个最佳实践，只实现一个。很多时候，当存在长时间运行的异步过程时，会使用事件。从网络套接字读取数据就是一个例子。套接字并不总是简单地在一次传递中提供数据，因此会设置事件。其中之一就是错误事件。要处理这个问题，我们只需要监听那个事件。以下是一个监听套接字错误事件的示例：
- en: '[PRE76]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Utilities
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: In the next group of modules, we will look at utilities. The functions chosen
    here are used across many different types of applications. We will cover everything
    from events and cryptology to buffers and npm.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一组模块中，我们将查看工具。这里选择的功能被用于许多不同类型的应用程序。我们将涵盖从事件和密码学到缓冲区和 npm 的所有内容。
- en: Events
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'Events are used in many built-in Node objects. This is because emitting and
    listening for events is the perfect way to let another function know when to start
    executing. This is especially true in the asynchronous world of Node.js. Anytime
    we use the `on` function of an object, it means that it has inherited from `EventEmitter`.
    All of the examples will assume that the events variable is already created as
    follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 事件被用于许多内置的 Node 对象中。这是因为触发和监听事件是让另一个函数知道何时开始执行的最佳方式。这在 Node.js 的异步世界中尤其如此。任何时候我们使用对象的
    `on` 函数，就意味着它已经继承了 `EventEmitter`。所有示例都将假设事件变量已经按照以下方式创建：
- en: '[PRE77]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: EventEmitter
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EventEmitter
- en: 'This is the parent class that can be inherited from to create a new `EventEmitter`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以继承以创建新 `EventEmitter` 的父类：
- en: '[PRE78]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Description
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Node.js has a fully featured event system that we can easily inherit from and
    implement. We do not need any extra frameworks or custom code. `EventEmitter`
    is the class to inherit from, and we will get every function in the rest of this
    section available.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 拥有一个功能齐全的事件系统，我们可以轻松地继承并实现。我们不需要任何额外的框架或自定义代码。`EventEmitter` 是要继承的类，我们将获得本节其余部分的所有函数。
- en: 'Here is an example of setting up a custom the `EventEmitter` parameter:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是设置自定义 `EventEmitter` 参数的示例：
- en: '[PRE79]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'on'
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'on'
- en: 'This function adds a listener for a specific event:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数为特定事件添加监听器：
- en: '[PRE80]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Description
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `on` function has become the preferred naming convention to add listeners
    to events. As an example, jQuery uses the exact same function name for their event
    listeners. The `event` handler is a string name of the event that will be emitted.
    The `listenerFunction` parameter is what will be executed when the event is emitted.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`on` 函数已成为添加事件监听器的首选命名约定。例如，jQuery 使用完全相同的函数名作为它们的事件监听器。`event` 处理器是即将触发的事件的字符串名称。`listenerFunction`
    参数是事件触发时将要执行的函数。'
- en: The `listenerFunction` parameter can be an anonymous function or a reference
    to a function. The preferred way of adding a listener is with a reference to a
    function. This will allow us to remove this specific listener at a later time.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`listenerFunction` 参数可以是一个匿名函数或对函数的引用。添加监听器的首选方式是对函数的引用。这将允许我们在稍后时间移除这个特定的监听器。'
- en: 'Here is an example based on our new `MyEventEmitter` class:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个基于我们新的 `MyEventEmitter` 类的示例：
- en: '[PRE81]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: once
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: once
- en: 'This works just like `on`, except it only executes once and then removes itself
    as a listener:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `on` 函数的工作方式相同，但它只执行一次，然后作为监听器移除自己：
- en: '[PRE82]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: removeListener
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: removeListener
- en: 'This is the function that is used to remove a listener from an event:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于从事件中移除监听器的函数：
- en: '[PRE83]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Description
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'When we are done listening for this event, we will want to remove our listener.
    This will help prevent memory leaks. If we added an anonymous function as the
    listener, then we cannot remove it as we do not have a reference to it. Using
    our previous example from `on`, we will remove the listener:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成对事件的监听后，我们希望移除我们的监听器。这将有助于防止内存泄漏。如果我们添加了一个匿名函数作为监听器，那么我们无法像之前那样移除它，因为我们没有对这个函数的引用。使用我们之前的
    `on` 示例，我们将移除监听器：
- en: '[PRE84]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: removeAllListeners
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: removeAllListeners
- en: 'This function will remove every listener for all events or a specific event:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将移除所有事件或特定事件的监听器：
- en: '[PRE85]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Description
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is essentially the nuclear option to remove listeners. This is indiscriminate
    with listeners. The `removeAllListeners` parameter will even remove listeners
    we did not add. Use this as a last resort.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一种移除监听器的核选项。它对监听器没有选择性。`removeAllListeners` 参数甚至会移除我们没有添加的监听器。请将此作为最后的手段使用。
- en: 'An example that removes all the listeners from this event is shown here. If
    the event was left blank, it would remove all listeners for all events:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个移除此事件所有监听器的示例。如果事件留空，它将移除所有事件的监听器：
- en: '[PRE86]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: setMaxListeners
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setMaxListeners
- en: 'This function sets the number of listeners before Node.js and warns about a
    possible memory leak:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数设置了在 Node.js 之前监听器的数量，并警告可能存在的内存泄漏：
- en: '[PRE87]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Node.js has a helpful warning when the number of listeners exceeds a threshold.
    The default value is `10`, so when you add the eleventh listener, Node.js will
    warn:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当监听器的数量超过阈值时，Node.js 会提供一个有用的警告。默认值是 `10`，所以当你添加第十一个监听器时，Node.js 将会警告：
- en: '[PRE88]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As a general rule, this is true. If we keep adding listeners to an event, there
    is a great chance for a memory leak. However, there will be times when we will
    need more than `10` listeners on an event. This is where we use `setMaxListeners`.
    If we set the max listeners to zero, then we can add as many as we want.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，这是正确的。如果我们继续向事件添加监听器，就有很大的内存泄漏风险。然而，有时我们可能需要在事件上添加超过 `10` 个监听器。这就是我们使用
    `setMaxListeners` 的地方。如果我们把最大监听器数设置为零，那么我们可以添加任意多个。
- en: 'Here is an example of setting the max listeners to `50`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个将最大监听器数设置为 `50` 的示例：
- en: '[PRE89]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: emit
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: emit
- en: 'This is how we fire off an event:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何触发一个事件的方式：
- en: '[PRE90]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: If we have extended an object to be an event emitter, then we will want to emit
    some events! This is the function to do that. It will execute all the event listeners
    that have attached themselves to this event based on `eventName`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展了一个对象使其成为事件发射器，那么我们可能想要发射一些事件！这是执行此操作的函数。它将根据 `eventName` 执行已附加到该事件的全部事件监听器。
- en: 'Here is an example that shows a listener being added and then emitting an event:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了添加监听器然后触发事件的操作：
- en: '[PRE91]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Crypto
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Crypto
- en: Every modern application needs cryptography. A great example of Node.js using
    cryptography is with HTTPS. We will not explore the inner workings of HTTPS as
    there is a module (the https module) that does this for us. We will look at the
    cryptographic functions used to hash, store, and check passwords.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 每个现代应用程序都需要加密。Node.js 使用加密的一个很好的例子是与 HTTPS 一起使用。我们不会探索 HTTPS 的内部工作原理，因为有一个模块（https
    模块）为我们做了这件事。我们将查看用于哈希、存储和检查密码的加密函数。
- en: 'In the same way as the other modules, we will require the `crypto` module and
    have it available for use in our examples. Here is what we will need:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他模块一样，我们将需要 `crypto` 模块，并在我们的示例中使用它。以下是我们需要的内容：
- en: '[PRE92]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: createHash
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: createHash
- en: 'This function will return a `crypto.Hash` object:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将返回一个 `crypto.Hash` 对象：
- en: '[PRE93]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Description
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Description
- en: The algorithms that can be used will be different for each system as it relies
    on OpenSSL. We can find out the algorithms that crypto can use by calling `crypto.getHashes()`.
    This will return an array of strings that can then be passed into `createHash`
    as the algorithm.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的算法将因系统而异，因为它依赖于 OpenSSL。我们可以通过调用 `crypto.getHashes()` 来找出 crypto 可以使用的算法。这将返回一个字符串数组，然后可以将其传递给
    `createHash` 作为算法。
- en: The return object from this function is a `crypto.Hash` object, which is covered
    in the next section.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的返回对象是一个 `crypto.Hash` 对象，这在下一节中会介绍。
- en: 'Here is an example that creates an MD5 hash:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个创建 MD5 哈希的示例：
- en: '[PRE94]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The hash object
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希对象
- en: 'This is the object that is returned from `crypto.createHash`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `crypto.createHash` 返回的对象：
- en: '[PRE95]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Description
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Description
- en: Once we get a reference to the Hash object that has been returned, you will
    see that it has two functions. The first is update, which allows us to add to
    the data that will be hashed. This can be called multiple times. This is important
    if we want to hash a stream input.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了返回的哈希对象的引用，您会看到它有两个函数。第一个是 update，它允许我们添加到将被哈希的数据。这可以多次调用。如果我们想要哈希流输入，这很重要。
- en: The next function is digest. This will return digest based on the algorithm
    the hash object was created with. The string encoding for this function can be
    hex, binary, or BASE64\.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是 digest。这将根据创建哈希对象时使用的算法返回摘要。此函数的字符串编码可以是十六进制、二进制或 BASE64\。
- en: Here is a full example of reading data from a file and then calculating the
    MD5 hash of the file.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个从文件中读取数据然后计算文件 MD5 哈希的完整示例。
- en: '[PRE96]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Tip
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tip
- en: Do not use hashing for passwords. The next function we will cover is much more
    secure than a simple hash. A digest hash is great for checking if some data has
    changed, as the hashes will be different if even one bit is different. In addition
    to this, it can be used as a key or identifier. A great example is using it for
    a memory cache and using the hash as the key. If the data is the same, the key
    will be the same.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用哈希来存储密码。我们将要介绍的下一个函数比简单的哈希更安全。摘要哈希非常适合检查数据是否已更改，因为即使是一个比特位不同，哈希值也会不同。此外，它可以用作密钥或标识符。一个很好的例子是将其用于内存缓存，并使用哈希作为密钥。如果数据相同，密钥也将相同。
- en: pbkdf2
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pbkdf2
- en: 'This function will use HMAC-SHA1 multiple times to create a derived key:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将多次使用 HMAC-SHA1 来创建派生密钥：
- en: '[PRE97]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Return Type
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回类型
- en: Both `pbkdf2` and `pbkdf2Sync` will return a derived key as a buffer.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`pbkdf2` 和 `pbkdf2Sync` 都会返回一个作为缓冲区的派生密钥。'
- en: Description
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Description
- en: '**Pbkdf2** (**password-based key derivation function 2**) is designed for password
    storage. It is better than hashing because it is difficult. Hashing is designed
    to be a quick calculation. This is bad because modern CPUs can calculate thousands
    upon thousands of hashes a second. This makes cracking a hashed password easy.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pbkdf2**（基于密码的派生函数 2）是为密码存储而设计的。它比哈希更安全，因为它更难。哈希是为了快速计算而设计的。这是不好的，因为现代 CPU
    每秒可以计算数千个哈希值。这使得破解哈希密码变得容易。'
- en: Pbkdf2 fixes this using a work factor in iterations. The higher the iterations,
    the longer the calculation will take. Now, instead of calculating thousands a
    second, we can slow a CPU down to just a few a second. This is a significant decrease.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Pbkdf2 通过在迭代中使用工作因子来解决这个问题。迭代次数越高，计算时间越长。现在，我们不再每秒计算数千次，而是可以将 CPU 速度降低到每秒仅几个。这是一个显著的降低。
- en: 'These are the parameters used:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用的参数：
- en: '`password`: This is the string we want to create a derived key for.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`：这是我们想要创建派生密钥的字符串。'
- en: '`salt`: This is a string that is combined with the password. Doing this ensures
    that the same password will not have the same hash if `salt` is different.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`salt`：这是一个与密码结合的字符串。这样做可以确保即使 `salt` 不同，相同的密码也不会有相同的哈希值。'
- en: '`iterations`: This is the work factor that instructs the function how many
    times to repeat. This can be increased as CPUs become faster. Currently, at least
    10,000 should create a reasonably secure derived key.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterations`：这是工作因子，指示函数重复的次数。随着 CPU 的变快，这可以增加。目前，至少 10,000 次可以创建一个相当安全的派生密钥。'
- en: '`keyLength`: This is the desired length of the returned derived key.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyLength`：这是返回的派生密钥的期望长度。'
- en: 'Here is an example of creating a derived key for the string `password` and
    `salt`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个为字符串 `password` 和 `salt` 创建派生密钥的示例：
- en: '[PRE98]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: randomBytes
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: randomBytes
- en: 'This returns cryptographically strong pseudo-random data:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回具有加密强度的伪随机数据：
- en: '[PRE99]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Return type
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回类型
- en: A buffer is returned.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个缓冲区。
- en: Description
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Random data is needed for various functions. While no data can truly be random,
    there are varying levels of randomness. The `randomBytes` parameter is random
    enough to use for cryptographic functions. A perfect use of `randomBytes` is for
    a `salt` to be used in `pbkdf2`. The `salt` variable is combined with the password
    to create a different hash even if the passwords are the same.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 需要随机数据用于各种函数。虽然没有任何数据可以真正是随机的，但存在不同级别的随机性。`randomBytes` 参数的随机性足以用于加密函数。`randomBytes`
    的一个完美用途是在 `pbkdf2` 中用作 `salt`。`salt` 变量与密码结合，即使密码相同，也会创建不同的哈希值。
- en: This function can be executed asynchronously or synchronously. It depends on
    whether there is a callback, which it would then execute asynchronously.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以异步或同步执行。这取决于是否有回调，如果有，它将异步执行。
- en: 'Here is a function to create a random `salt` for `pbkdf2`. If you compare this
    example to the previous one, you will see that this example outputs a unique string
    each time, while the previous one does not:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个为 `pbkdf2` 创建随机 `salt` 的函数。如果您将此示例与上一个示例进行比较，您将看到此示例每次输出一个独特的字符串，而上一个示例则不是：
- en: '[PRE100]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: pseudoRandomBytes
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pseudoRandomBytes
- en: 'This returns pseudo-random data:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回伪随机数据：
- en: '[PRE101]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Return Type
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回类型
- en: A buffer is returned.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个缓冲区。
- en: Description
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This functions exactly like `randomBytes`, except it is not cryptographically
    strong. This means that we should not use it with any cryptographic functions
    such as `pbkdf2`.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与 `randomBytes` 完全一样，但它不是加密强度的。这意味着我们不应该将其与任何加密函数（如 `pbkdf2`）一起使用。
- en: We can use it for anything else that requires randomness, a filename, or a cache
    key for example.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它做任何需要随机性、文件名或缓存键等其他事情。
- en: 'Here is a simple example of executing this function asynchronously:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个异步执行此函数的简单示例：
- en: '[PRE102]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Buffer
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲区
- en: Node.js uses buffers internally for many things. We have seen this as we have
    had buffers returned for many functions. This is because anytime raw data or binary
    data needs to be stored, it will be stored in a buffer.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 在许多方面都使用缓冲区。我们已经在许多函数返回缓冲区时看到了这一点。这是因为任何需要存储原始数据或二进制数据时，它都会存储在缓冲区中。
- en: Buffers have a few quirks about them that we must keep in mind. First, buffers
    store data, but to utilize the data held inside them, we must encode it. We will
    cover the encodings and how to do this in this section. Second, buffers cannot
    be resized. When they are created, we must give a length, and that will always
    be the length of that buffer. We can, of course, create a new buffer that is larger
    and then copy over the data. Finally, a buffer is a global. We do not need to
    have `var buffer = require('buffer')`. Also, it can be utilized in any file at
    any time.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区有几个需要注意的特性。首先，缓冲区存储数据，但为了利用其中存储的数据，我们必须对其进行编码。本节将介绍编码方式以及如何进行编码。其次，缓冲区的大小不能调整。当创建缓冲区时，我们必须指定一个长度，这个长度将始终是缓冲区的长度。当然，我们可以创建一个新的更大的缓冲区，然后将数据复制过去。最后，缓冲区是全局的。我们不需要使用
    `var buffer = require('buffer')`。此外，它可以在任何文件中的任何时间被使用。
- en: Buffer creation
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区创建
- en: 'The initialization function of a buffer is as shown in the following code snippet:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区的初始化函数如下代码片段所示：
- en: '[PRE103]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Return value
  id: totrans-490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a buffer object.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个缓冲区对象。
- en: Description
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: There are three different ways to initialize a buffer. The first function uses
    an integer of the given size, the next one uses an array, and the final method
    can use just a string. The encoding is optional, as it defaults to UFT8.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的方式可以初始化缓冲区。第一个函数使用给定大小的整数，下一个函数使用数组，最后一种方法可以使用字符串。编码是可选的，默认为UFT8。
- en: 'This example demonstrates initializing using an array with the `hello` string
    in ASCII:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了使用包含ASCII码中`hello`字符串的数组进行初始化：
- en: '[PRE104]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: index
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: index
- en: 'This gets the value at the specific index in the buffer:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这在缓冲区的特定索引处获取值：
- en: '[PRE105]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Return Value
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns the value at the index.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回指定索引处的值。
- en: Description
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'This works much like an array. Here is an example of getting the first index
    in the buffer:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这与数组的工作方式非常相似。以下是一个获取缓冲区第一个索引的示例：
- en: '[PRE106]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: toString
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: toString
- en: 'This returns the buffer as a string based on the encoding:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据编码返回缓冲区作为字符串：
- en: '[PRE107]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Return Value
  id: totrans-507
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a string.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个字符串。
- en: Description
  id: totrans-509
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'This is most likely the function that you will use to get the data out of a
    buffer. The first parameter is encoding, which is one of the following:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这很可能是您将用于从缓冲区获取数据的函数。第一个参数是编码，它可以是以下之一：
- en: ASCII
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASCII
- en: UTF8
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF8
- en: UTF16LE
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF16LE
- en: BASE64
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BASE64
- en: Binary
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Binary
- en: Hex
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hex
- en: All the parameters are optional, so this means that they all have default values.
    Encoding is defaulted to UTF8, `start` is `0`, and `end` is the end of the buffer.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都是可选的，这意味着它们都有默认值。编码默认为UTF8，`start`为`0`，`end`为缓冲区的末尾。
- en: 'Here is an example of creating a buffer and retrieving the data out of it.
    It explicitly defines each of the parameters:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个创建缓冲区并从中检索数据的示例。它明确定义了每个参数：
- en: '[PRE108]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: toJSON
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: toJSON
- en: 'This returns the contents of the buffer as a JavaScript object:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回缓冲区的内容作为JavaScript对象：
- en: '[PRE109]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Return Value
  id: totrans-523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns an array with the contents of the buffer.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含缓冲区内容的数组。
- en: Description
  id: totrans-525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'This will return contents of the buffer mapped to an array. This example is
    similar to the previous example, but with `toJSON`:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回缓冲区内容映射到数组。此示例类似于上一个示例，但使用了`toJSON`：
- en: '[PRE110]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: isBuffer
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isBuffer
- en: 'This is a class method that will determine whether an object is a buffer:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类方法，用于确定一个对象是否是缓冲区：
- en: '[PRE111]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Return Value
  id: totrans-531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a Boolean value.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个布尔值。
- en: Description
  id: totrans-533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'Remember that this is a class method, so it can be executed without a new instance
    of buffer. Here is an example of using the function:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这是一个类方法，因此可以在没有缓冲区新实例的情况下执行。以下是一个使用该函数的示例：
- en: '[PRE112]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: write
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: write
- en: The following code writes to the buffer.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码向缓冲区写入数据。
- en: '[PRE113]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Return value
  id: totrans-539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns an integer of the number of bytes written.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回写入的字节数的整数。
- en: Description
  id: totrans-541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This function will write the string passed into the buffer. Much like the other
    buffer functions, there are many optional parameters that have defaults. The default
    offset is `0`, the length is `buffer.length – offset`, and the encoding is UTF8.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将写入传递到缓冲区的字符串。与其他缓冲区函数一样，有许多可选参数具有默认值。默认偏移量为`0`，长度为`buffer.length – offset`，编码为UTF8。
- en: 'This example writes to a buffer twice using the return value from the first
    write to append the second string:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用第一次写入的返回值向缓冲区写入两次，以附加第二个字符串：
- en: '[PRE114]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: byteLength
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: byteLength
- en: 'This function will get the length of a string in bytes based on the encoding:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将根据编码获取字符串的字节长度：
- en: '[PRE115]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Return value
  id: totrans-548
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns an integer of the number of bytes needed.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个整数，表示所需的字节数。
- en: Description
  id: totrans-550
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Buffers cannot be resized after initializing, so we may need to know how big
    a string is beforehand. This is where `byteLength` comes in.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区初始化后不能调整大小，因此我们可能需要事先知道字符串的大小。这就是 `byteLength` 发挥作用的地方。
- en: 'Here is an example that determines the size of a string and then writes it
    to the buffer:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个确定字符串大小并将其写入缓冲区的示例：
- en: '[PRE116]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: readUInt
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: readUInt
- en: 'This will get an unsigned integer at a certain spot in the buffer:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在缓冲区的某个位置获取一个无符号整数：
- en: '[PRE117]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Return Value
  id: totrans-557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns an unsigned integer of the size used, `8` for `readUInt8`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个表示使用大小的无符号整数，`readUInt8` 为 `8`。
- en: Description
  id: totrans-559
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Not all data stored in a buffer is exactly a byte. Sometimes, data will need
    to be read in 16-bit or 32-bit chunks. In addition to this, you can also specify
    whether the data is little endian or big endian, denoted by `LE` or `BE` in the
    function name, respectively.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在缓冲区中的数据并不总是精确的字节。有时，数据需要以 16 位或 32 位块读取。此外，您还可以指定数据是低位字节序还是高位字节序，分别由函数名中的
    `LE` 或 `BE` 表示。
- en: The offset is which spot in the buffer to start at. The `noAssert` parameter
    will run validation if the offset size is in the buffer. By default, it is `false`.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量是指从缓冲区的哪个位置开始。如果偏移量大小在缓冲区中，`noAssert` 参数将运行验证。默认情况下，它是 `false`。
- en: 'Here is an example of setting data and then reading the data out with `readUInt16`:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个设置数据然后使用 `readUInt16` 读取数据的示例：
- en: '[PRE118]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: writeUInt
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: writeUInt
- en: 'This writes an unsigned integer to a buffer:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个无符号整数写入缓冲区：
- en: '[PRE119]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Description
  id: totrans-567
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is the exact opposite of the `readUInt` function. Sometimes, we need to
    write data that is larger than one byte in length. These functions make it simple.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `readUInt` 函数正好相反。有时，我们需要写入长度大于一个字节的 数据。这些函数使这变得简单。
- en: The `noAssert` parameter is optional, and it defaults to `false`. This will
    not run any validation on the value or offset.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`noAssert` 参数是可选的，默认为 `false`。这不会对值或偏移量执行任何验证。'
- en: 'Here is an example of writing `UInt16` to the buffer:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将 `UInt16` 写入缓冲区的示例：
- en: '[PRE120]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Tip
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Note that there are more read and write functions of this type for the buffer
    class. Instead of creating a very redundant section, I will list them. Remember
    that they work in the same fashion as the functions we have covered: `readInt8`,
    `readInt16LE`, `readInt16BE`, `readInt32LE`, `readInt32BE`, `readDoubleLE`, `readDoubleBE`,
    `readFloatLE`, and `readFloatBE`. There is a `write()` function that maps to each
    one of these as well.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，缓冲区类还有更多此类读写函数。而不是创建一个非常冗余的部分，我将列出它们。请记住，它们与我们所讨论的函数以相同的方式工作：`readInt8`、`readInt16LE`、`readInt16BE`、`readInt32LE`、`readInt32BE`、`readDoubleLE`、`readDoubleBE`、`readFloatLE`
    和 `readFloatBE`。还有一个 `write()` 函数映射到这些函数中的每一个。
- en: Console
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台
- en: This is much like the console that is present in most modern browsers. The console
    essentially maps to `stdout` and `stderr`. This isn't a module, and each function
    is not very complex, so let's jump right in.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这与大多数现代浏览器中存在的控制台非常相似。控制台本质上映射到 `stdout` 和 `stderr`。这不是一个模块，每个函数都不太复杂，所以让我们直接进入。
- en: log
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: log
- en: 'This writes to `stdout`:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这写入到 `stdout`：
- en: '[PRE121]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Description
  id: totrans-579
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is probably the most used console function. It is great for debugging,
    and the output can be combined with piping to write to a file for a history. The
    multiple parameters create a string-like function.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最常用的控制台函数。它非常适合调试，输出可以与管道结合写入文件以保存历史记录。多个参数创建了一个类似字符串的函数。
- en: 'Here is an example of using multiple parameters:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用多个参数的示例：
- en: '[PRE122]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: dir
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dir
- en: 'This is an alias for `util.inspect`:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `util.inspect` 的别名：
- en: '[PRE123]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Description
  id: totrans-586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Many times, the output of `console.log` and `console.dir` will be similar. However,
    when trying to look at an object, `console.dir` should be preferred.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，`console.log` 和 `console.dir` 的输出将是相似的。然而，当试图查看一个对象时，应该首选 `console.dir`。
- en: time and timeEnd
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: time 和 timeEnd
- en: 'These two functions are used together to mark the start and end of a timer:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数一起使用来标记计时器的开始和结束：
- en: '[PRE124]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Description
  id: totrans-591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: These two functions will always be used together. The `console.time` parameter
    will start a timer that can be stopped with `console.timeEnd` by passing the same
    label. When `timeEnd` is called, it will log the elapsed time between start and
    end in milliseconds.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数总是一起使用。`console.time` 参数将启动一个计时器，可以通过传递相同的标签使用 `console.timeEnd` 来停止。当调用
    `timeEnd` 时，它将在毫秒中记录开始和结束之间的经过时间。
- en: 'Here is an example that uses `setTimeout`:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `setTimeout` 的示例：
- en: '[PRE125]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: trace
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: trace
- en: 'This logs to the console and includes a stack trace:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在控制台记录并包含堆栈跟踪：
- en: '[PRE126]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Description
  id: totrans-598
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This works much like `console.log`. The first parameter can be treated like
    a formatted string, with the other parameters supplying the additional input.
    The main difference is that `console.trace` will include a stack trace when it
    logs to the console.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`console.log`的工作方式非常相似。第一个参数可以被视为格式化字符串，其他参数提供额外的输入。主要区别是`console.trace`在记录到控制台时会包含堆栈跟踪。
- en: 'Here is a simple example:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE127]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: npm (Node Package Manager)
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: npm（Node包管理器）
- en: npm is not a Node.js module like. We will look at some of npm's features and
    uses, as almost every Node.js project will use npm.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: npm不是一个Node.js模块。我们将探讨一些npm的功能和用法，因为几乎每个Node.js项目都会使用npm。
- en: Most modern platforms have a way of grouping together code that serves a function
    or purpose called packages. Node.js uses npm to track, update, pin, and install
    these packages.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代平台都有一种将执行特定功能或目的的代码分组在一起的方式，称为包。Node.js使用npm来跟踪、更新、固定和安装这些包。
- en: init
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: init
- en: 'This initializes a node module by creating `package.json` in the current directory:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过在当前目录中创建`package.json`来初始化一个node模块：
- en: '[PRE128]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Description
  id: totrans-608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: An interactive console session will ask you quite a few questions and use the
    answers to build a `package.json` file for you. This is a great way to kick off
    a new module. This will not delete your current the `package.json` file or any
    of the current properties if the `package.json` file exists.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 一个交互式控制台会问你很多问题，并使用这些答案为你构建一个`package.json`文件。这是一个启动新模块的好方法。如果`package.json`文件存在，这将不会删除当前的`package.json`文件或任何当前属性。
- en: package.json
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: package.json
- en: This is the file that has all the information about your project.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含你项目所有信息的文件。
- en: Description
  id: totrans-612
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'This is not a function or command, but it is the most important file in your
    project. It is what determines all the information about your project. Although
    technically, the only properties needed are name and version, there are many properties
    that can be set. If this file was created using npm in it, you will have quite
    a few already filled out. It would be tedious to list out all the possibilities.
    Here are just a few of the most useful: name, version, scripts, dependencies,
    devDependencies, authors, and license.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个函数或命令，但它是你项目中最重要的文件。它决定了关于你项目所有信息。虽然技术上只需要name和version这两个属性，但可以设置许多属性。如果你使用npm创建了这个文件，你将会有很多已经填写好的。列出所有可能性将会很繁琐。这里只列出一些最有用的：name、version、scripts、dependencies、devDependencies、authors和license。
- en: The npm docs at [https://www.npmjs.org/doc/files/package.json.html](https://www.npmjs.org/doc/files/package.json.html)
    go through all the settings their uses.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: npm文档在[https://www.npmjs.org/doc/files/package.json.html](https://www.npmjs.org/doc/files/package.json.html)中详细介绍了所有设置及其用法。
- en: install
  id: totrans-615
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: install
- en: 'This is the command to install a package:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 这是安装包的命令：
- en: '[PRE129]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Description
  id: totrans-618
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is the main way to install new packages and their dependencies. If `npm
    install` is called without any parameters, it will use `package.json` and install
    all the dependencies.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这是安装新包及其依赖项的主要方式。如果没有参数调用`npm install`，它将使用`package.json`并安装所有依赖项。
- en: This command also allows you to install packages by executing it with the name
    of the package. This can be augmented by adding a version. If the version is omitted,
    it will install the newest version. In addition to this, you can use save flags
    that create a property in dependencies or devDependcies.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令还允许你通过执行包名来安装包。可以通过添加版本来增强这一点。如果省略版本，它将安装最新版本。此外，你可以使用save标志在dependencies或devDependcies中创建属性。
- en: This is not the entire list of what `npm install` can do, but it is the most
    used list.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是`npm install`能做的全部列表，但这是最常用的列表。
- en: update
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: update
- en: 'This will update a package to the newest version:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新一个包到最新版本：
- en: '[PRE130]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Description
  id: totrans-625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This command will update all the packages or a specific package to the newest
    version.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将更新所有包或特定包到最新版本。
- en: shrinkwrap
  id: totrans-627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: shrinkwrap
- en: 'This will explicitly define all the dependencies for a project:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这将明确定义项目的所有依赖项：
- en: '[PRE131]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Description
  id: totrans-630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is different from the basic list of dependencies in `package.json`. Most
    packages have requirements of their own. When a package is installed, npm will
    go out and find the newest version that matches the dependency's specified version.
    This can lead to different versions of packages installed when run at different
    times. This is something that most developers want to avoid.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `package.json` 中基本依赖列表不同。大多数包都有自己的要求。当安装一个包时，npm 将出去寻找与依赖指定的版本匹配的最新版本。这可能导致在运行不同时间时安装不同版本的包。这是大多数开发者想要避免的事情。
- en: One way to combat this is to run `npm shrinkwrap`. It will create `npm-shrinkwrap.json`.
    This file will explicitly define the versions currently installed recursively
    for every package installed. This ensures that when you run `npm install` again,
    you will know what package versions will get installed.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 一种对抗这种情况的方法是运行 `npm shrinkwrap`。它将创建 `npm-shrinkwrap.json` 文件。这个文件将明确定义每个已安装的包递归安装的当前版本。这确保了当你再次运行
    `npm install` 时，你会知道将安装哪些包版本。
- en: run
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: run
- en: 'This will run an arbitrary command:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行一个任意命令：
- en: '[PRE132]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Description
  id: totrans-636
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `package.json` file has a property named scripts. This is an object that
    can have a list of commands that can be run by npm. These scripts can be anything
    that runs from the command line.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件中有一个名为 scripts 的属性。这是一个对象，可以包含可以被 npm 运行的命令列表。这些脚本可以是任何可以通过命令行运行的命令。'
- en: There are three commands on npm that use these scripts objects. These are `npm
    test`, `npm start`, and `npm stop`. These commands map to test, start, and stop
    the scripts object, respectively.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在 npm 中有三个命令使用这些脚本对象。这些是 `npm test`、`npm start` 和 `npm stop`。这些命令分别映射到测试、启动和停止脚本对象。
- en: 'Here is an example for a scripts object from `package.json` and the way to
    call it from `npm`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个来自 `package.json` 的脚本对象示例以及从 `npm` 调用它的方法：
- en: '[PRE133]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Stream
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stream
- en: Stream is an interface that is used by many internal objects. Any time data
    needs to be read or written, it is most likely done through a stream. This fits
    with the Node.js asynchronous paradigm. If we are reading a large file from the
    filesystem, we would create a listener to tell us when each chunk of data is ready
    to be read. This does not change if that file is coming from the network, an HTTP
    request, or `stdin`.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: Stream 是许多内部对象使用的接口。每当需要读取或写入数据时，最有可能通过流来完成。这与 Node.js 的异步范式相符合。如果我们从文件系统中读取一个大文件，我们会创建一个监听器来告诉我们每个数据块何时准备好读取。如果这个文件来自网络、HTTP
    请求或 `stdin`，这也不会改变。
- en: We are only going to cover using a stream, in this book. The stream interface
    can be implemented with your own objects as well.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们只将涵盖使用流。流接口也可以用你自己的对象实现。
- en: Streams can be readable, writable, or duplex (both). We will cover readable
    and writable streams separately.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 流可以是可读的、可写的，或者双工（两者都是）。我们将分别介绍可读流和可写流。
- en: Readable
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Readable
- en: This is, of course, a stream that we can get data out of. A readable stream
    can be in one of the two different modes, flowing, or non-flowing. Which mode
    it is in depends on which events are listened for.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个我们可以从中获取数据的流。一个可读流可以在两种不同的模式中，流动模式或非流动模式。它处于哪种模式取决于监听哪些事件。
- en: To put a stream in the flowing mode, you will just have to listen for the data
    event. Conversely, to put a stream in the non-flowing mode, you will have to listen
    for the readable event and then call the `stream.read()` function to retrieve
    data. The easiest way to understand the modes is to think about the data as a
    lot of chunks. In the flowing mode, every time a chunk is ready, the data event
    will fire, and you can read that chunk in the callback of the data event. In the
    non-flowing mode, the chunk will fire a readable event, and then, you will have
    to call read to get the chunk.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 要将流置于流动模式，你只需监听数据事件。相反，要将流置于非流动模式，你必须监听可读事件，然后调用 `stream.read()` 函数来检索数据。理解这些模式的最简单方法是将数据视为许多块。在流动模式下，每次一个块准备好时，数据事件就会触发，你可以在数据事件的回调中读取该块。在非流动模式下，块会触发一个可读事件，然后你必须调用
    read 来获取块。
- en: 'Here is a list of events:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个事件列表：
- en: readable
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: readable
- en: data
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: data
- en: end
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: end
- en: close
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: close
- en: error
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Here are two examples, one that uses flowing and one that uses non-flowing:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个例子，一个使用流动模式，一个使用非流动模式：
- en: '[PRE134]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: read
  id: totrans-656
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: read
- en: 'Use with a non-flowing readable stream:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非流动的 readable 流：
- en: '[PRE135]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Return value
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns either a string, buffer, or null. A string is returned if the encoding
    is set. A buffer is returned if the encoding is not set. Finally, null is returned
    when there is no data in the stream.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回字符串、缓冲区或null。如果设置了编码，则返回字符串。如果没有设置编码，则返回缓冲区。最后，当流中没有数据时返回null。
- en: Description
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: This reads from a stream. Most of the time, the optional parameter size is not
    needed and should be avoided. Only use this with a non-flowing stream.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 这从流中读取。大多数时候，可选参数大小是不需要的，应该避免使用。仅与非流动流一起使用。
- en: 'Here is a simple example that reads a file:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，用于读取文件：
- en: '[PRE136]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: setEncoding
  id: totrans-665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: setEncoding
- en: 'This sets the encoding of the stream:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了流的编码：
- en: '[PRE137]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Description
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: By default, a readable stream will output a buffer. This will set the encoding
    of the buffer, so a string is returned.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可读流将输出一个缓冲区。这将设置缓冲区的编码，因此返回一个字符串。
- en: 'Here is the opening example with `setEncoding` used:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`setEncoding`的打开示例：
- en: '[PRE138]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: resume and pause
  id: totrans-672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 恢复和暂停
- en: 'These functions pause and resume a stream:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数暂停和恢复流：
- en: '[PRE139]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Description
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: Pause will stop a stream from emitting data events. If this is called on a non-flowing
    stream, it will be changed into a flowing stream and be paused. Resume will cause
    the stream to start emitting data events again.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停将停止流发出数据事件。如果在对非流动流调用此函数，它将被更改为流动流并暂停。恢复将使流再次开始发出数据事件。
- en: 'Here is an example that pauses the stream for a few seconds before reading
    it:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，在读取之前暂停流几秒钟：
- en: '[PRE140]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: pipe
  id: totrans-679
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道
- en: 'This allows you to take the output of a readable stream and send it to the
    input of a writable stream:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你将可读流的输出发送到可写流的输入：
- en: '[PRE141]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Return Value
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns the writable stream so that piping can be chained.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回可写流，以便可以链式管道。
- en: Description
  id: totrans-684
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: This is exactly the same as piping output in a shell.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在shell中管道输出完全相同。
- en: A great design paradigm is to pipe from a stream to another stream that transforms
    the stream and then pipe that to the output. For example, you want to send a file
    over the network. You would open the file as a readable stream, pass it to a duplex
    stream that would compress it, and pipe the output of the compression to a socket.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的设计范例是从一个流管道到另一个转换流的流，然后再将其管道到输出。例如，你想通过网络发送文件。你会以可读流打开文件，将其传递给一个双工流，该流将压缩它，然后将压缩输出管道到套接字。
- en: 'Here is a simple example of piping output to `stdout`:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的示例，将输出管道输出到`stdout`：
- en: '[PRE142]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: writable
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可写
- en: 'This is the stream the data goes to. This is a little simpler as there are
    really only two functions that matter: write and end.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据流向的流。这有点简单，因为实际上只有两个重要的函数：写入和结束。
- en: 'Here are the events and details of when they fire:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它们触发时的事件和详细信息：
- en: '`drain`: This fires when the internal buffer has written all the data'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drain`：当内部缓冲区已写入所有数据时触发'
- en: '`finish`: This fires when the stream has been ended and all the data has been
    written'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish`：当流已结束并且所有数据都已写入时触发'
- en: '`error`: This fires when an error occurs'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：当发生错误时触发'
- en: Note
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that a stream can be given more data than it can write
    in a timely fashion. This is especially true when writing to a network stream.
    Because of this, the events `finish` and `drain` to let your program know that
    the data has been sent.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，流可以接收比它能及时写入更多的数据。这在写入网络流时尤其如此。正因为如此，`finish`和`drain`事件让程序知道数据已被发送。
- en: write
  id: totrans-697
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: write
- en: 'This function writes to the stream:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数写入流：
- en: '[PRE143]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Return value
  id: totrans-700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a Boolean value if the stream has written completely.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流已完全写入，则返回一个布尔值。
- en: Description
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: This is the main function of a writable stream. Data can be a buffer or string,
    encoding defaults to UTF8, and the callback is called when the current chunk of
    data has been written.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可写流的主要功能。数据可以是缓冲区或字符串，编码默认为UTF8，当当前数据块被写入时，将调用回调函数。
- en: 'Here is a simple example:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例：
- en: '[PRE144]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'This will close the stream, and no more data can be written:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 这将关闭流，并且无法再写入更多数据：
- en: '[PRE145]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Description
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: When you are done writing to a stream, the end function should be called on
    it. All the parameters are optional, a chunk is data that you can write before
    the stream ends, encoding will default to UTF8, and the callback will be attached
    to the finish event.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成向流写入时，应该在它上调用end函数。所有参数都是可选的，块是在流结束之前可以写入的数据，编码默认为UTF8，回调将附加到finish事件。
- en: 'Here is an example to end a writable stream:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个结束可写流的例子：
- en: '[PRE146]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The net module
  id: totrans-712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`net`模块'
- en: The `net` module in Node.js allows us to create network connections. The connections
    that are created will be streams that we can write to and read from. This section
    will focus on just network connections and not HTTP. Node.js has a full HTTP module,
    and we will cover that in the next section.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的`net`模块允许我们创建网络连接。创建的连接将是我们可以写入和读取的流。本节将仅关注网络连接，而不是HTTP。Node.js有一个完整的HTTP模块，我们将在下一节中介绍。
- en: 'All the functions assume that the `net` module has been loaded like this:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都假设`net`模块已经以这种方式加载：
- en: '[PRE147]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: createServer
  id: totrans-716
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: createServer
- en: 'This function will create a TCP server:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将创建一个TCP服务器：
- en: '[PRE148]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Return value
  id: totrans-719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a `net.Server` object.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个`net.Server`对象。
- en: Description
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This function allows us to listen for connections. The returned object will
    be a `net.Server` object, and the connection listener will be passed to a `net.Socket`
    object. We will cover both of these objects shortly.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数允许我们监听连接。返回的对象将是一个`net.Server`对象，连接监听器将被传递给一个`net.Socket`对象。我们将在稍后介绍这两个对象。
- en: 'Here is a simple example that shows us how to listen and write to a socket.
    Each connection will have to be manually closed:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，展示了我们如何监听并写入套接字。每个连接都必须手动关闭：
- en: '[PRE149]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: net.Server
  id: totrans-725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: net.Server
- en: We will now look at the `net.Server` object. All of the functions in the next
    section will need to a have a `Server` object created through `createServer`.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看`net.Server`对象。下一节中的所有函数都需要通过`createServer`创建一个`Server`对象。
- en: 'The `net.Server` parameter is an `EventEmitter` that will emit events. Here
    is a list of the events with the event argument if there is one:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Server`参数是一个`EventEmitter`，它将发出事件。以下是一个包含事件及其事件参数（如果有）的列表：'
- en: 'Connection: `net.Socket`'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接：`net.Socket`
- en: '`close`'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close`'
- en: 'Error: `Error`'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误：`Error`
- en: '`listening`'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listening`'
- en: 'Here is an example that uses all of the events:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用所有事件的例子：
- en: '[PRE150]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: listen
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: listen
- en: 'This starts accepting connections:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始接受连接：
- en: '[PRE151]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Description
  id: totrans-737
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Creating a server does not get it to start listening to requests. We will have
    to give the listen function at least a port. The host is optional, as it will
    listen on all IPv4 addresses, and the backlog will be the queue of connections.
    Finally, the callback will be called when the server starts listening.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务器并不会让它开始监听请求。我们必须至少提供一个端口号给监听函数。主机是可选的，因为它将监听所有IPv4地址，而backlog将是连接队列。最后，当服务器开始监听时，回调函数将被调用。
- en: You may get `EADDRINUSE`. This just means that the port is already being used
    by another process.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到`EADDRINUSE`错误。这仅仅意味着该端口已经被另一个进程使用。
- en: 'Here is an example that defines all the parameters:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个定义所有参数的例子：
- en: '[PRE152]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: close
  id: totrans-742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: close
- en: 'This closes the current server:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 这关闭当前服务器：
- en: '[PRE153]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Description
  id: totrans-745
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This will stop the server from creating new connections. This is important to
    remember because it will not close the current connections.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止服务器创建新的连接。这一点很重要，因为它不会关闭当前连接。
- en: The callback is called when there are no more connections.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多连接时，回调将被调用。
- en: address
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: address
- en: 'This gets the port and address:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 这获取端口号和地址：
- en: '[PRE154]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Description
  id: totrans-751
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This will give you the port and IP address where this server is listening.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出服务器监听的端口号和IP地址。
- en: getConnections
  id: totrans-753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: getConnections
- en: 'This gets the number of connections:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这获取连接数量：
- en: '[PRE155]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Return Value
  id: totrans-756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns an integer.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个整数。
- en: Description
  id: totrans-758
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This does not give any information on each connection. It only returns the number.
    This is a great way to see whether there are any connections. The callback function
    will need to be in the form of *function(err, connections)*.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会给出每个连接的任何信息。它只返回数量。这是一个查看是否有连接的好方法。回调函数将需要是*function(err, connections)*的形式。
- en: connect
  id: totrans-760
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: connect
- en: 'This easily creates a connection to the specified address:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以轻松地创建到指定地址的连接：
- en: '[PRE156]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Return value
  id: totrans-763
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a `net.Socket` object.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个`net.Socket`对象。
- en: Description
  id: totrans-765
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This function does not do anything that you cannot do with a socket. It is a
    convenient function that returns a `net.Socket` object.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数并不做任何你不能用套接字做的事情。这是一个方便的函数，它返回一个`net.Socket`对象。
- en: For the parameters, a port is required, the host will default to localhost,
    and `connectListener` will be added to the connect event of the newly formed `net.Socket`
    object.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 对于参数，需要一个端口号，主机将默认为localhost，`connectListener`将被添加到新形成的`net.Socket`对象的连接事件中。
- en: 'Here is an example that will connect to a server we just created and send data
    every second:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，它将连接到我们刚刚创建的服务器，并且每秒发送数据：
- en: '[PRE157]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: net.Socket
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: net.Socket
- en: This section will be similar to the `net.Server` section. The `net.Socket` parameter
    is the object that is returned anytime a connection is made. It can also be used
    to create a new connection.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节将与`net.Server`部分类似。`net.Socket`参数是在建立连接时返回的对象。它也可以用来创建新的连接。
- en: It is a readable and writable stream. This is the only way to send and receive
    data from a `net.Socket`.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个可读和可写流。这是从`net.Socket`发送和接收数据的唯一方式。
- en: 'Here is the list of events along with details of when they fire:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是事件列表以及它们触发时的详细信息：
- en: '`connect`: On connection.'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect`：在连接时。'
- en: '`data`: When data is received.'
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：当接收到数据时。'
- en: '`end`: When the socket has ended.'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：当套接字结束时。'
- en: '`timeout`: When the socket has timed out from inactivity. The socket is still
    open at this point.'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`：当套接字由于不活动而超时时。此时套接字仍然打开。'
- en: '`drain`: When all the data in the write buffer has been sent.'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drain`：当写入缓冲区中的所有数据都已发送时。'
- en: '`Error`: On error.'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Error`：在出错时。'
- en: '`close`: When the socket closes.'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close`：当套接字关闭时。'
- en: As `net.Socket` is a readable stream, there is no read function. You will have
    to listen for the data event to the get the data.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`net.Socket`是一个可读流，没有读取函数。你必须监听数据事件以获取数据。
- en: 'Here is an example of using a socket to connect to a local server:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用套接字连接到本地服务器的示例：
- en: '[PRE158]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: connect
  id: totrans-784
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: connect
- en: 'This creates a connection:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个连接：
- en: '[PRE159]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Description
  id: totrans-787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: This is the function that actually creates a connection. Much like `net.connection`,
    the port is required, the host will default to localhost, and the listener just
    maps the function to the connection event.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际创建连接的函数。与`net.connection`类似，端口是必需的，主机默认为localhost，监听器将函数映射到连接事件。
- en: 'Here is an example that connects locally and writes to the connection:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个本地连接并写入连接的示例：
- en: '[PRE160]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: write
  id: totrans-791
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: write
- en: 'This sends data out on the socket:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在套接字上发送数据：
- en: '[PRE161]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Description
  id: totrans-794
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: The socket is buffered because it is very easy to queue up more data than can
    be sent over the network. This is done automatically by Node.js, but you should
    be aware of this, as buffering will use up memory as it is holding the data to
    be sent.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是缓冲的，因为很容易排队比可以通过网络发送的数据更多的数据。这是Node.js自动完成的，但你应该意识到这一点，因为缓冲会使用内存来保存要发送的数据。
- en: The encoding parameter will default to UTF8, but any of the encodings we have
    discussed can be used. The callback will be called once the data has been written
    over the socket.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 编码参数默认为UTF8，但可以使用我们讨论过的任何编码。数据写入套接字后，将调用回调函数。
- en: 'Here is an example with all of the parameters defined:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个定义了所有参数的示例：
- en: '[PRE162]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: end
  id: totrans-799
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: end
- en: 'This starts the closing process of the socket:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始关闭套接字的过程：
- en: '[PRE163]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Description
  id: totrans-802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: This is effectively closing the socket. We cannot say for sure, but the reason
    could be that the server could send some data back, although the socket will close
    shortly.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是关闭套接字。我们无法确定，但原因可能是服务器可能发送一些数据，尽管套接字将很快关闭。
- en: 'You can send some data before the socket closes, and this is what the optional
    parameters are for:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字关闭之前，你可以发送一些数据，这就是可选参数的作用：
- en: '[PRE164]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The HTTP module
  id: totrans-806
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP模块
- en: We will cover the HTTP server module. Technically, you could write your HTTP
    server using the `net` module, but you do not have to.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍HTTP服务器模块。技术上，你可以使用`net`模块编写你的HTTP服务器，但你不必这样做。
- en: Some of these functions are very similar to the `net` module functions. This
    should make sense as HTTP, at its core, is a network server.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些函数与`net`模块的函数非常相似。这应该是有意义的，因为HTTP在本质上是一个网络服务器。
- en: All of these functions and objects are also used with the HTTPS module. The
    only difference is that for the options of `createServer` and `https.request`,
    you can pass certificates.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数和对象也用于HTTPS模块。唯一的区别是，对于`createServer`和`https.request`的选项，你可以传递证书。
- en: 'All of the following examples assume that the module has been loaded:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的以下示例都假设模块已经被加载：
- en: '[PRE165]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: createServer
  id: totrans-812
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: createServer
- en: 'This creates an HTTP server:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个HTTP服务器：
- en: '[PRE166]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Return Value
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns an `http.Server` object.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个`http.Server`对象。
- en: Description
  id: totrans-817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: Much like `net.createServer`, this is required to serve anything. The `requestListener`
    parameter is attached to the request event.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 与`net.createServer`类似，这是提供任何内容所必需的。`requestListener`参数附加到请求事件。
- en: 'Here is a simple example that just logs to the console any time a request is
    made:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例，它会在请求被制作时记录到控制台：
- en: '[PRE167]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: http.Server
  id: totrans-821
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: http.Server
- en: This is the server object that is returned from `http.createServer`. This is
    the object that will respond to all requests.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`http.createServer`返回的服务器对象。这是将响应所有请求的对象。
- en: We will start with the functions and look at each event separately as the events
    are important to handling requests.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从函数开始，并单独查看每个事件，因为事件对于处理请求非常重要。
- en: listen
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听
- en: 'This tells the server to listen on the supplied port, path, or file descriptor:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉服务器在提供的端口、路径或文件描述符上监听：
- en: '[PRE168]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Description
  id: totrans-827
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: Although this function has three different ways to execute, you will most likely
    only use the network listener. In fact, the other two listeners are difficult,
    if not impossible, to even execute on Windows. Let's cover the last two quickly.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个函数有三种不同的执行方式，但你最可能只会使用网络监听器。实际上，其他两个监听器在Windows上执行起来可能很困难，甚至不可能。让我们快速了解一下最后两个。
- en: The path listener will use a local socket server, and the file descriptor will
    need a handle. If this sounds foreign, it means you will use the other method.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 路径监听器将使用本地套接字服务器，并且文件描述符需要一个句柄。如果这听起来很陌生，这意味着你将使用另一种方法。
- en: The network listener requires that the port be used. The host will default to
    localhost if nothing is passed in. In all the functions, a callback will be attached
    to the listening event.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 网络监听器要求使用端口。如果没有传入任何内容，主机将默认为localhost。在所有函数中，都会将一个回调函数附加到监听事件。
- en: 'Here is an example of listening on a network port with all the parameters defined:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在定义了所有参数的网络端口上监听的示例：
- en: '[PRE169]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: close
  id: totrans-833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭
- en: 'This closes the server:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 这将关闭服务器：
- en: '[PRE170]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Description
  id: totrans-836
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This will stop the server from listening. The callback will be attached to the
    close event.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止服务器监听。回调函数将附加到关闭事件。
- en: 'Here is a simple example:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例：
- en: '[PRE171]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Events
  id: totrans-840
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: The `http.Server` parameter is an `EventEmitter` object. The events are also
    where the majority of work will be done.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Server`参数是一个`EventEmitter`对象。事件也是大多数工作将完成的地方。'
- en: request
  id: totrans-842
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 请求
- en: 'This event fires when a request comes in:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 当有请求进来时，此事件会被触发：
- en: '[PRE172]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Description
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: If you only listen to one event, this is the event to listen for. It has the
    `request` and the server's response. The `req` attribute will be `http.IncomingMessage`,
    and the `res` attribute will be `http.ServerResponse`. We will look at both of
    these objects in this section. In addition to this, `req` implements a readable
    stream interface, and `res` implements a writable stream interface.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只监听一个事件，这就是你要监听的事件。它包含`request`和服务器响应。`req`属性将是`http.IncomingMessage`，而`res`属性将是`http.ServerResponse`。在本节中，我们将查看这两个对象。此外，`req`实现了一个可读流接口，而`res`实现了一个可写流接口。
- en: 'Here is an example of listening for a request:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个监听请求的示例：
- en: '[PRE173]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: close
  id: totrans-849
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关闭
- en: 'This event fires when the server closes:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器关闭时，此事件会被触发：
- en: '[PRE174]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: upgrade
  id: totrans-852
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 升级
- en: 'This event fires when the client sends an HTTP upgrade:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发送HTTP升级时，此事件会被触发：
- en: '[PRE175]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Description
  id: totrans-855
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述
- en: An upgrade request asks the web server to change protocols. If you are implementing
    another protocol other than HTTP you should listen and deal with this event. A
    great example of this is a `WebSocket` upgrade.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 升级请求要求Web服务器更改协议。如果你正在实现HTTP之外的协议，你应该监听并处理此事件。一个很好的例子是`WebSocket`升级。
- en: The `req` attribute is the request, the socket will be a `net.Socket`, and `buffer`
    is a Buffer.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '`req`属性是请求，套接字将是一个`net.Socket`，而`buffer`是一个Buffer。'
- en: IncomingMessage
  id: totrans-858
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IncomingMessage
- en: This is the request object when listening for the request event or from `http.clientRequest`.
    This is a readable stream.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 这是监听请求事件或从`http.clientRequest`返回的请求对象。这是一个可读的流。
- en: headers
  id: totrans-860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头部信息
- en: 'The HTTP headers from the request:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的HTTP头信息：
- en: '[PRE176]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Description
  id: totrans-863
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'Sometimes, you will want to make decisions based on the information in the
    headers. Here is an example using headers to check for basic authentication:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要根据头部信息中的信息做出决策。以下是一个使用头部信息检查基本身份验证的示例：
- en: '[PRE177]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: method
  id: totrans-866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'This gets the HTTP method of the request:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取请求的HTTP方法：
- en: '[PRE178]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Description
  id: totrans-869
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'This returns the method as a string in uppercase. Here is an example for `GET`:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个字符串形式的函数，并且是大写的。以下是一个`GET`方法的示例：
- en: '[PRE179]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: url
  id: totrans-872
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: url
- en: 'This is the URL that was requested:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这是请求的URL：
- en: '[PRE180]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Description
  id: totrans-875
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This will be a string of the URL, including any query parameters. You can parse
    the string yourself or use Node's query string module and use the `parse` function.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个包含任何查询参数的URL字符串。你可以自己解析这个字符串，或者使用Node的查询字符串模块并使用`parse`函数。
- en: 'Here is a simple example that will serve any files in the current directory.
    Remember that this is only an example and does no error checking:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的示例，它将服务当前目录中的任何文件。请记住，这只是一个示例，并且没有进行错误检查：
- en: '[PRE181]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: data
  id: totrans-879
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: data
- en: This is the data event from the readable stream interface.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可读流接口的数据事件。
- en: Description
  id: totrans-881
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: If you have an incoming message, most likely, you would want to know what is
    in the message. As it is a readable stream, we will need to listen for the data
    event to get all the data out. When the data is exhausted, the end event will
    fire.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个传入的消息，你很可能会想知道消息的内容。由于它是一个可读流，我们需要监听数据事件以获取所有数据。当数据耗尽时，将触发结束事件。
- en: 'Here is an example that creates listeners for the data and end event:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个创建数据事件和结束事件的监听器的示例：
- en: '[PRE182]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: ServerResponse
  id: totrans-885
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ServerResponse
- en: This is the response that the HTTP server creates for the event request. Each
    request needs a response, and this is it. This implements a writable interface.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTTP服务器为事件请求创建的响应。每个请求都需要一个响应，这就是它。这实现了可写接口。
- en: writeHead
  id: totrans-887
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: writeHead
- en: 'This will write the HTTP response header:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 这将写入HTTP响应头：
- en: '[PRE183]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Description
  id: totrans-890
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This writes the header for the response. This needs to be called before `response.write`.
    If it is not, then the server will send it for you with the headers you have set.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为响应写入头。这个方法必须在`response.write`之前调用。如果不这样做，服务器将自动为你发送带有你设置的头的响应。
- en: '`statusCode` is the HTTP status code of the response. A `header` is an object
    with the name of the header as a property and the value as the value.'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '`statusCode`是响应的HTTP状态码。一个`header`是一个对象，其属性是头的名称，值是头的值。'
- en: 'Here is an example that writes the header:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个写入头的示例：
- en: '[PRE184]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: statusCode
  id: totrans-895
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: statusCode
- en: 'This sets the status code of the response:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置响应的状态码：
- en: '[PRE185]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Description
  id: totrans-898
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This is used instead of `response.writeHead`. If this is called after `writeHead`
    has been executed, then it will not change the response header. It must be called
    instead of it.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`response.writeHead`被调用后使用的方法。如果在这个方法被调用之后`writeHead`已经被执行，那么它将不会改变响应头。它必须替代`writeHead`来调用。
- en: 'Here is an example that uses `statusCode`:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`statusCode`的示例：
- en: '[PRE186]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: setHeader
  id: totrans-902
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setHeader
- en: 'This writes a specific header:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 这将写入特定的头：
- en: '[PRE187]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Description
  id: totrans-905
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: In the same way that `statusCode` must be called instead of `writeHead`, `setHeader`
    must be called instead of `writeHead`. This can be called multiple times to set
    multiple headers.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 与`statusCode`必须替代`writeHead`一样，`setHeader`也必须替代`writeHead`来调用。这个方法可以多次调用以设置多个头。
- en: 'Here is an example of using `statusCode` and `setHeader` together:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`statusCode`和`setHeader`一起使用的示例：
- en: '[PRE188]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: write
  id: totrans-909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: write
- en: 'This is the function that writes the response body:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 这是写入响应体的函数：
- en: '[PRE189]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Description
  id: totrans-912
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: 'The `response.write` parameter is a writable stream, so this interface can
    be used. A chunk can be a buffer or string. The encoding is optional as it will
    default to UTF8\. Here is an example that writes a simple HTML page as the response:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '`response.write`参数是一个可写流，因此可以使用这个接口。一个块可以是一个缓冲区或字符串。编码是可选的，因为它将默认为UTF8。下面是一个写入简单HTML页面的示例：'
- en: '[PRE190]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: end
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: end
- en: 'This ends the response:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束响应：
- en: '[PRE191]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Description
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `response` parameter is a writable stream, so we must end the stream when
    we are done writing. Data is any optional data that needs to be written, and encoding
    will default to UTF8\. All of the examples for response have used `res.end`. If
    you do not end the response, the browser will wait for a response from the server.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '`response`参数是一个可写流，因此当我们完成写入时，我们必须结束流。数据是需要写入的任何可选数据，编码将默认为UTF8。所有的响应示例都使用了`res.end`。如果你不结束响应，浏览器将等待来自服务器的响应。'
- en: http.request
  id: totrans-920
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: http.request
- en: 'This makes a request using HTTP:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用HTTP发起请求：
- en: '[PRE192]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Return value
  id: totrans-923
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns an `http.ClientRequest` object.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个`http.ClientRequest`对象。
- en: Description
  id: totrans-925
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: 'Node.js allows you to consume HTTP as well as serve it. The options object
    has many properties that can be set. Here is a list of them:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 允许你消费HTTP请求以及提供HTTP服务。选项对象有许多可以设置的属性。以下是一个列表：
- en: '`host`'
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`'
- en: '`hostname`'
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostname`'
- en: '`port`'
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`'
- en: '`localAddress`'
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localAddress`'
- en: '`socketPath`'
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socketPath`'
- en: '`method`'
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`'
- en: '`path`'
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`'
- en: '`headers`'
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`'
- en: '`auth`'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth`'
- en: '`agent`'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`agent`'
- en: Every option is not required for each request. Most of the time, only `hostname`,
    `port`, `path`, and `method` are needed to make a request. The options parameter
    can also be a URL as a string.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个请求都需要每个选项。大多数时候，只需要 `hostname`、`port`、`path` 和 `method` 来进行请求。选项参数也可以是一个字符串形式的
    URL。
- en: 'The callback will be attached to the response event. The request object is
    a writable stream so that data can be sent to the server. Here is an example that
    makes a request to Packt Publishing:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 回调将被附加到响应事件。请求对象是一个可写流，因此可以向服务器发送数据。以下是一个向 Packt Publishing 发送请求的示例：
- en: '[PRE193]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: http.get
  id: totrans-940
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: http.get
- en: 'This is the convenience method for a `GET` request:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `GET` 请求的便捷方法：
- en: '[PRE194]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Return value
  id: totrans-943
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: This returns a `http.ClientRequest` object.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个 `http.ClientRequest` 对象。
- en: Description
  id: totrans-945
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: This works in a manner similar to `http.request`, except it automatically sends
    an empty request and calls the end function. If you are only making a `GET` request,
    this can save some boilerplate code.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与 `http.request` 类似，但会自动发送一个空请求并调用结束函数。如果你只进行 `GET` 请求，这可以节省一些样板代码。
- en: 'Here is an example that requests Packt Publishing:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个请求 Packt Publishing 的示例：
- en: '[PRE195]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: http.clientRequest
  id: totrans-949
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: http.clientRequest
- en: This is the object that is returned from `http.request`.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `http.request` 返回的对象。
- en: write
  id: totrans-951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: write
- en: 'This writes to the server in the request:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 这在请求中向服务器写入：
- en: '[PRE196]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Description
  id: totrans-954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: The `http.clientRequest` attribute is a writable stream. It is writable as you
    may need to send data to the remote server, for example, when making a `POST`
    request.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.clientRequest` 属性是一个可写流。当你需要向远程服务器发送数据时，它可以被写入，例如，在执行 `POST` 请求时。'
- en: This works like all the other writable streams, so data can be a buffer or string,
    and encoding will default to UTF8.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 它与所有其他可写流的工作方式相同，因此数据可以是缓冲区或字符串，编码将默认为 UTF8。
- en: end
  id: totrans-957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: end
- en: 'This ends the request:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了请求：
- en: '[PRE197]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Description
  id: totrans-960
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: When you are writing to a stream, you must end the stream with this function.
    Without doing this, the connection will stay and/or timeout. Data is optional
    and can be a buffer or string, while encoding will default to UTF8.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向流写入数据时，你必须使用此函数结束流。如果不这样做，连接将保持并/或超时。数据是可选的，可以是缓冲区或字符串，而编码将默认为 UTF8。
- en: response
  id: totrans-962
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应
- en: 'This is the response event. It lets you know that the remote server has responded:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 这是响应事件。它让你知道远程服务器已经响应：
- en: '[PRE198]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Description
  id: totrans-965
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 描述
- en: This event fires when the remote server responds. The response object in the
    callback will be `http.incomingMessage`.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 当远程服务器响应时，此事件会被触发。回调中的响应对象将是 `http.incomingMessage`。
- en: If no response handler is added, the server response will be discarded. If there
    is a response handler, then Node.js will start to buffer the response to memory.
    If you do not read it back out, you can cause the server to crash.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有添加响应处理程序，服务器响应将被丢弃。如果有响应处理程序，那么 Node.js 将开始将响应缓冲到内存中。如果你不将其读回，可能会导致服务器崩溃。
- en: 'Here is an example listener that reads the data from the response:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个读取响应数据的示例监听器：
- en: '[PRE199]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
