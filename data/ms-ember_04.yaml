- en: Chapter 4. Writing Application Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 编写应用程序模板
- en: 'Now that we know how to manage the states in Ember.js applications using routes,
    this chapter will help us master how to present application logic to users using
    templates. You will soon realize that the bulk of your application resides in
    templates. This being said, the chapter will frequently revisit what we already
    learned so far. Therefore, by the end of this chapter, the following concepts
    will be learned:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用路由来管理Ember.js应用程序中的状态，本章将帮助我们掌握如何使用模板向用户展示应用程序逻辑。你很快就会意识到，你应用程序的大部分内容都驻留在模板中。因此，本章将经常回顾我们迄今为止所学的内容。因此，在本章结束时，以下概念将被学习：
- en: Creating templates
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板
- en: Writing binding template expressions and conditionals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写绑定模板表达式和条件
- en: Changing contexts in templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中更改上下文
- en: Creating event listeners in templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中创建事件监听器
- en: Extending templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展模板
- en: Writing custom template helpers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义模板助手
- en: Registering templates
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册模板
- en: 'As promised, we will continue to explore the chapter sample introduced in the
    previous chapter in the context of templates. When an application transitions
    into a state, each of the route handlers in that state path renders a template
    into the page. These templates are defined in the following signature:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如承诺，我们将继续在模板的背景下探索上一章中引入的章节示例。当应用程序过渡到一个状态时，该状态路径中的每个路由处理程序都会在页面上渲染一个模板。这些模板在以下签名中定义：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As shown, templates are registered using **script** tags of the `text/x-handlebars`
    type. The `id` or `data-template-name` attribute is used to identify the template.
    For instance, the chapter sample `contacts` template was defined as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，模板是通过`text/x-handlebars`类型的`script`标签进行注册的。使用`id`或`data-template-name`属性来识别模板。例如，章节示例中的`contacts`模板被定义为：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'One thing to note is that it''s wiser to identify templates using the `data-template-name`
    attribute instead of the `id` attribute, as the former is more likely to collide
    with other existing elements. Also, notice that the first template was not *identified*.
    This is because any unidentified template is considered as the `application` template:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，使用`data-template-name`属性来识别模板比使用`id`属性更明智，因为前者更可能与其他现有元素冲突。此外，请注意，第一个模板没有被*识别*。这是因为任何未识别的模板都被视为`application`模板：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Inserting templates
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入模板
- en: In the previous chapter, we discussed how a state in an application is composed
    of various routes whose handlers are sequentially called in order to perform various
    functions that make up this state. As a recap, when the user loaded the application
    in the chapter sample, the application transitioned into the `application` state.
    The `application` route handler then rendered its corresponding `application`
    template into the DOM. The next route handler to be called was the `contacts`
    route handler that also loaded and rendered its template into the `application`
    template. We already discussed that the `{{outlet}}` Handlebars expression was
    the portion of the `application` template that got swapped out. This process repeated
    itself until the application settled on the destination state.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了应用程序中的状态是如何由各种路由组成的，这些路由的处理程序按顺序调用以执行构成此状态的各种功能。作为回顾，当用户在章节示例中加载应用程序时，应用程序过渡到`application`状态。然后，`application`路由处理程序将其相应的`application`模板渲染到DOM中。下一个要调用的路由处理程序是`contacts`路由处理程序，它也加载并渲染其模板到`application`模板中。我们已经讨论过，`{{outlet}}`
    Handlebars表达式是`application`模板中被替换的部分。这个过程一直重复，直到应用程序稳定在目标状态。
- en: As we will discuss later, a *parent* template can specify named outlets into
    which multiple *child* templates can be rendered. Route (not resource) handlers
    need not include this expression because they usually render the final template.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将要讨论的，一个*父*模板可以指定多个*子*模板可以渲染的命名出口。路由（不是资源）处理程序不需要包含这个表达式，因为它们通常渲染最终的模板。
- en: Writing out templates
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出模板
- en: As discussed earlier, Ember.js templates are written in the Handlebars ([www.handlebarsjs.com](http://www.handlebarsjs.com))
    syntax whose library was created by the same authors to simplify the creation
    of client-side templates. Handlebars is a powerful templating library that offers
    many features, which will be discussed in the upcoming sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ember.js模板是用Handlebars（[www.handlebarsjs.com](http://www.handlebarsjs.com)）语法编写的，该库由相同的作者创建，以简化客户端模板的创建。Handlebars是一个功能强大的模板库，它提供了许多功能，这些功能将在接下来的章节中讨论。
- en: Expressing variables
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达变量
- en: 'We just mentioned that templates are backed by data that is proxied by the
    corresponding controller. Handlebars walks down a template, replacing defined
    expressions with matching values obtained from this data. These expressions are
    usually variable names enclosed in curly braces. The `{{outlet}}` expression we
    just discussed is one such expression. In the chapter sample, the `contact.index`
    state is responsible for displaying a contact''s detail on the right-hand side
    of the page. In its corresponding template, we notice that the contact''s attributes
    are expressed using these expressions, but later get replaced, as shown in the
    following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚提到模板由数据支持，这些数据由相应的控制器代理。Handlebars遍历模板，用从这些数据中获得匹配值替换定义的表达式。这些表达式通常是括在花括号内的变量名。我们刚刚讨论的`{{outlet}}`表达式就是这样一种表达式。在章节示例中，`contact.index`状态负责在页面右侧显示联系人的详细信息。在其对应的模板中，我们注意到联系人的属性是用这些表达式表达的，但后来被替换，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, Handlebars finds the name expression, retrieves this
    variable from the provided model, and performs the swap. Handlebars always works
    in the provided controller context, which in turn proxies requests to its model.
    Therefore, the value used to swap the preceding expression is evaluated as:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，Handlebars找到了名称表达式，从提供的模型中检索这个变量，并执行了交换。Handlebars始终在提供的控制器上下文中工作，这反过来又代理了对模型的请求。因此，用于交换前面表达式的值被评估为：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This value can also be:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此值也可以是：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Whenever the `name` variable reference request is made, Ember.js first checks
    if the controller defines the variable. Since this is not true, the controller
    *proxies* this request to its model.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发出对`name`变量引用的请求时，Ember.js首先检查控制器是否定义了该变量。由于这不是真的，控制器*代理*这个请求到其模型。
- en: Writing bound and unbound expressions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写绑定和未绑定表达式
- en: We just learned that an expression is resolved by referencing the specified
    variable from the binding context. Ember.js goes further and makes these expressions
    *reactive*. This means that if the underlying variable changes, the replaced expression
    portion will also be updated. Sometimes, we might not want to suppress this behavior,
    especially when the variable is too large and constitutes unbound expressions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解到，表达式通过引用绑定上下文中指定的变量来解析。Ember.js更进一步，使这些表达式变得*响应式*。这意味着如果底层变量发生变化，被替换的表达式部分也将更新。有时，我们可能不希望抑制这种行为，特别是当变量太大并且构成未绑定表达式时。
- en: 'These expressions only resolve once on render, and no further changes of the
    corresponding variable are subscribed. These expressions are written using three
    braces instead of two, as shown in the following example, where the main content
    of an Ember.js-powered blog post can be rendered:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式在渲染时只解析一次，并且不会订阅相应变量的进一步更改。这些表达式使用三个花括号而不是两个，如下面的示例所示，其中Ember.js驱动的博客文章的主要内容可以被渲染：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Adding comments in templates
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板中添加注释
- en: 'Comments in Handlebars have the `{{! … }}` signature. For example, we can add
    a documentation that signifies the end of a footer:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars中的注释具有`{{! … }}`签名。例如，我们可以添加文档来表示页脚的结束：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These expressions serve the same purpose as normal HTML comments, other than
    the fact that they are not actually converted to the latter. Therefore, a good
    reason to use them is when we don't want comments to appear in the rendered output.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式与普通HTML注释具有相同的作用，只是它们实际上并没有被转换为后者。因此，使用它们的良好理由是当我们不希望注释出现在渲染的输出中时。
- en: Writing conditionals
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写条件语句
- en: 'Handlebars supports the `if`, `if...else`, `unless`, and `unless...else` conditionals.
    This means that we can render different portions of our templates based on specified
    conditions. They are block expressions that wrap template portions and usually
    begin and end with the `{{#` and `{{/` template tags, respectively. For example,
    if the user has no stored contacts in the `contacts` template of the chapter sample,
    the application will transition into the `contacts.new` state to force the user
    to add one. Therefore, we need to display a placeholder string in the now blank
    left-hand side of the page. We do this by checking whether the passed contact
    list is indeed empty, as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 支持使用 `if`、`if...else`、`unless` 和 `unless...else` 条件语句。这意味着我们可以根据指定的条件渲染模板的不同部分。它们是封装模板部分的块表达式，通常分别以
    `{{#` 和 `{{/` 模板标签开始和结束。例如，如果用户在章节示例的 `contacts` 模板中没有存储联系人，应用程序将过渡到 `contacts.new`
    状态，强制用户添加一个。因此，我们需要在页面现在空白的左侧显示一个占位符字符串。我们通过检查传递的联系人列表是否确实为空来实现这一点，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The placeholder element is placed inside the `else` block. As illustrated,
    the block expression is only met when the value passed evaluates to `True`. Hence,
    the following values will result in the `else` block being rendered instead:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符元素放置在 `else` 块中。如图所示，块表达式仅在传递的值评估为 `True` 时才会满足。因此，以下值将导致渲染 `else` 块：
- en: '`false`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`undefined`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: '`null`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`[] (empty array)`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[] (空数组)`'
- en: '`''''`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''''`'
- en: '`0`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`'
- en: '`NaN`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`'
- en: The `unless` expression, on the other hand, is only met when the variable evaluated
    is `False`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，`unless` 表达式仅在评估的变量为 `False` 时才会满足。
- en: 'Note that Handlebars is `logic-less`, hence we cannot express conditions using
    the bitwise operators, as in the following cases:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Handlebars 是“无逻辑”的，因此我们无法使用位运算符来表示条件，如下面的情况：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can, however, define these conditions in the controller layer using computed
    properties or bindings. For example, the preceding samples can be implemented
    correctly as:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用计算属性或绑定在控制器层定义这些条件。例如，前面的示例可以正确实现如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Switching contexts
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换上下文
- en: 'As previously discussed, Ember.js resolves expressions against the model context.
    The `{{#with}}...{{/with}}` helper allows us to specify the context to prioritize
    during the check. A good case is illustrated in the chapter sample, where we need
    to reuse the form used to create or update contacts. This form is contained in
    the `contacts/form` template. The only problem is that while the context of the
    `contacts/new` template is a newly created contact object, the `contact/edit`
    template has to reference the contact proxied by the contact controller. Thanks
    to the `with` helper and controller dependencies, we are able to change the context
    of the latter template as:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ember.js 会将表达式解析为模型上下文。`{{#with}}...{{/with}}` 辅助函数允许我们在检查期间指定优先级较高的上下文。一个很好的例子是在章节示例中，我们需要重复使用创建或更新联系人的表单。这个表单包含在
    `contacts/form` 模板中。唯一的问题是，虽然 `contacts/new` 模板的上下文是一个新创建的联系人对象，但 `contact/edit`
    模板必须引用由联系人控制器代理的联系人。多亏了 `with` 辅助函数和控制器依赖项，我们能够改变后者的上下文，如下所示：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will revisit this case when discussing the `partial` helper, but the important
    thing to note is that the main context is not the corresponding route handler
    model now, it is rather the `contact` controller.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在讨论 `partial` 辅助函数时再次回到这个案例，但重要的是要注意，主要上下文现在不是相应的路由处理程序模型，而是 `contact` 控制器。
- en: 'Just like the `each` helper, we can create a new context without losing the
    existing one, as shown in the following examples:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `each` 辅助函数一样，我们可以创建一个新的上下文而不丢失现有的上下文，如下面的示例所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the two cases, the `email` field in the form, for example, will now need
    to bind to the contact context as:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，表单中的 `email` 字段，例如，现在需要绑定到联系人上下文：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rendering enumerable data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染可枚举数据
- en: 'Often, applications will need to display enumerable data that can be accomplished
    using the `{{#each}} ... {{/each}}` block expression. For example, our `contacts`
    template used this expression to display the list of contacts on the left as:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序需要显示可枚举数据，可以使用 `{{#each}} ... {{/each}}` 块表达式来实现。例如，我们的 `contacts` 模板使用这个表达式来显示左侧的联系人列表：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We left out the `link-to` expression, which we''ll discuss shortly. The `each`
    block expression switches the working context on each iteration, as discussed
    in the previous section. If we don''t wish to do so, we can specify the name of
    the current iteration object, as shown in the following reimplementation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了`link-to`表达式，稍后我们将讨论它。`each`块表达式在每次迭代时切换工作上下文，正如前一小节所讨论的那样。如果我们不想这样做，我们可以指定当前迭代对象的名称，如下面的重新实现所示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One good thing about this block expression is that we can check if the iterator
    is empty using the `else` expression. For example, the use of the `else` and `if...else`
    expressions in our `contacts` template can be reduced to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块表达式的优点之一是我们可以使用`else`表达式检查迭代器是否为空。例如，我们可以在`contacts`模板中减少`else`和`if...else`表达式的使用，如下所示：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Writing template bindings
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模板绑定
- en: 'In the *Writing bound and unbound expressions* section, we mentioned that the
    Ember.js Handlers library enables a variable defined in an expression to subscribe
    and, hence, updates to the changes of the bound context. The library also enables
    us to bind these variables to HTML element attributes, including classes using
    the `{{bind-attr .. }}` helper. In the following example, we define a link whose
    `href` property is bound to the provided user profile as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在*编写已绑定和未绑定表达式*部分中，我们提到Ember.js处理器库允许在表达式中定义的变量订阅并因此更新绑定上下文的变化。该库还允许我们将这些变量绑定到HTML元素属性，包括使用`{{bind-attr
    .. }}`辅助器绑定类。以下示例定义了一个其`href`属性绑定到提供的用户配置文件的链接：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By now we all know how the profile context will be provided by the route handler''s
    model hook. For example, if this is the application''s template, the corresponding
    route handler will provide the context as:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们都知道配置文件上下文将由路由处理器的模型钩子提供。例如，如果这是应用程序的模板，相应的路由处理器将提供上下文如下：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The resulting rendered template will then resemble:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果渲染的模板将如下所示：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Every time the profile link changes, the link element's `href` property will
    automatically be updated.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每次配置文件链接更改时，链接元素的`href`属性将自动更新。
- en: 'We might also wish to toggle states in attributes, for example, the commonly
    used `required` and `disabled` attributes. A common use case is when we want to
    allow single clicks in e-commerce applications, as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能希望切换属性的状态，例如，常用的`required`和`disabled`属性。一个常见的用例是我们希望在电子商务应用程序中允许单次点击，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, when the user clicks on the checkout button, the checkout
    action should toggle the `isCheckedOut` property, which will result in the button
    being disabled. Therefore, attributes can be added or removed from DOM elements
    if the passed conditions become `True` or `False`, respectively.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当用户点击结账按钮时，结账操作应该切换`isCheckedOut`属性，这将导致按钮被禁用。因此，如果传递的条件变为`True`或`False`，则可以添加或删除DOM元素上的属性。
- en: 'Element class names can also be dynamically updated in the same way, with a
    little difference in the binding behavior. For example, we might wish to add an
    `active` property to a clicked link in an application, as shown:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 元素类名也可以以相同的方式动态更新，只是在绑定行为上略有不同。例如，我们可能希望在应用程序中向点击的链接添加一个`active`属性，如下所示：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the context''s `selected` property evaluates to `active`, the link will
    be updated to:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下文的`selected`属性评估为`active`时，链接将更新为：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On the other hand, if the property becomes undefined, the link changes to:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果属性变为未定义，链接将更改为：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just like an attribute''s presence can be updated dynamically, class names
    can also be inserted and removed from elements, depending on specified bound conditions.
    Hence, the preceding example can be reimplemented as:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像属性的存在可以动态更新一样，类名也可以根据指定的绑定条件从元素中插入和删除。因此，前面的示例可以重新实现为：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, the element's class will be `active` and `inactive` when the context's
    `selected` property becomes `True` and `False`, respectively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当上下文的`selected`属性变为`True`和`False`时，元素的类将是`active`和`inactive`。
- en: 'If only one argument is passed after the semicolon, the passed argument will
    be used as the class name instead. For example, the following code demonstrates
    this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在分号之后只传递一个参数，则传递的参数将用作类名。例如，以下代码演示了这一点：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This yields the following if the context''s `isSelected` property becomes `True`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上下文的`isSelected`属性变为`True`，则会产生以下结果：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It''s also worth noting that `camelCase` class names get *dasherized*, as shown
    in the following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`camelCase` 类名会被转换为 *dasherized*，如下面的示例所示：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This becomes the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变为以下形式：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Unlike other attributes, we can bind to multiple classes with the same signature,
    as shown in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他属性不同，我们可以使用相同的签名绑定多个类，如下面的示例所示：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This becomes the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变为以下形式：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Sometimes, we might want to use both bound and unbound classes in an element.
    The following example demonstrates this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能想在元素中使用绑定的和未绑定的类。以下示例演示了这一点：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This yields the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这就产生了以下结果：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As shown, the unbound class names begin with a semicolon. Note that the following
    example won''t work since all the class names should be defined inside the `bind-attr`
    expression if one of them is bound:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，未绑定的类名以分号开头。请注意，以下示例将不会工作，因为如果其中一个类名被绑定，所有类名都应该定义在 `bind-attr` 表达式内部：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Defining route links
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义路由链接
- en: 'A typical Ember.js application has several routes that we might need to link
    to in templates. The `{{#link-to}}...{{/link-to}}` helper serves this purpose
    and lets the application create anchors to these routes easily. For example, the
    list on the left-hand side of our sample application is composed of links that
    the user can use to view the details of the various contacts. We use this helper
    to generate these links as:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 Ember.js 应用程序有几个我们需要在模板中链接的路由。`{{#link-to}}...{{/link-to}}` 辅助函数用于此目的，并允许应用程序轻松创建指向这些路由的锚点。例如，我们样本应用程序左侧的列表由用户可以使用来查看各种联系人详情的链接组成。我们使用此辅助函数生成这些链接如下：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we inspect one of the generated links, we notice that it resembles the following
    line of code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查生成的链接之一，我们会注意到它类似于以下代码行：
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The helper takes the route name as the first handler, followed by the resources
    needed by the corresponding route. As discussed in the previous chapter, since
    the path of the affected route has dynamic segments, its handler is responsible
    for resolving the required parameters to replace these segments. In this case,
    the `contact` route path has one dynamic segment, `contact_id`, which is used
    as discussed in the previous chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数将路由名称作为第一个处理程序，然后是相应路由所需的资源。如前一章所述，由于受影响的路由路径有动态段，其处理程序负责解析所需的参数以替换这些段。在这种情况下，`contact`
    路由路径有一个动态段，即 `contact_id`，正如前一章所讨论的那样。
- en: 'If we want to link to the blog route, we only need to specify the route name
    as:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要链接到博客路由，我们只需指定路由名称如下：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Just like the `bind-to` expression, the `link-to` expression also accepts other
    element attributes such as `rel`, `target`, or `class`. The following example
    opens the link in a new tab or window:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `bind-to` 表达式一样，`link-to` 表达式也接受其他元素属性，如 `rel`、`target` 或 `class`。以下示例在新的标签页或窗口中打开链接：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Registering DOM element event listeners
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册 DOM 元素事件监听器
- en: 'In vanilla JavaScript, an application script traverses the DOM, setting up
    event listeners along the way. A typical form might look like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯 JavaScript 中，应用程序脚本遍历 DOM，沿途设置事件监听器。一个典型的表单可能看起来如下：
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Ember.js provides an abstraction over this, which allows developers to easily
    subscribe to element-specific events using the `{{action ...}}` helper. Our chapter
    contains such a form, as shown in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 提供了一个抽象层，允许开发者使用 `{{action ...}}` 辅助函数轻松订阅元素特定的事件。我们的章节包含如下所示的形式：
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The function to call is usually defined in the `actions` property of the route
    and takes an unlimited number of arguments. By default, the default event type
    to bind to is usually the `click` event. However, you can specify this type using
    the `on` attribute. The `actions` property can be defined on either the corresponding
    route or controller. For example, the action handler for the preceding action
    was defined in the `contacts` route as:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用的函数通常定义在路由的 `actions` 属性中，并接受任意数量的参数。默认情况下，绑定的事件类型通常是 `click` 事件。然而，您可以使用
    `on` 属性来指定此类型。`actions` 属性可以定义在相应的路由或控制器上。例如，前面动作的动作处理程序是在 `contacts` 路由中定义的：
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As mentioned, this action can still be defined in the controller layer as:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此动作仍然可以在控制器层中定义如下：
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The main point to consider when deciding where to put an action is when we need
    to take advantage of the **bubbling** action. When an action is triggered, the
    function specified is looked up in the corresponding controller. If this action
    is defined, it gets executed. If the action is not defined, Ember.js performs
    the check in the corresponding route handler. If this action is defined in either
    controller or route handler and returns a value equal to `True`, Ember.js goes
    ahead and checks for a similar function in the parent route handlers, until one
    of them doesn't contain the function or does not define it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定将动作放置何处时需要考虑的主要点是何时我们需要利用**冒泡**动作。当一个动作被触发时，会在相应的控制器中查找指定的函数。如果这个动作被定义，它就会被执行。如果没有定义这个动作，Ember.js会在相应的路由处理程序中进行检查。如果这个动作在控制器或路由处理程序中定义，并且返回的值等于`True`，Ember.js就会继续检查父路由处理程序中是否有类似的功能，直到其中一个不包含该功能或没有定义它。
- en: 'One important thing to note is that the bubbling action occurs in the route
    handler layer only. This is one of the reasons we will opt to define the function
    in the route handler. For example, since we should be able to call the `saveContact`
    action from both the `contacts.new` and `contact.edit` templates, we define it
    in the `contacts` route. Here''s an illustration of how the action is propagated
    in both cases:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，冒泡动作仅在路由处理程序层发生。这是我们选择在路由处理程序中定义函数的原因之一。例如，我们应该能够从`contacts.new`和`contact.edit`模板中调用`saveContact`动作，所以我们将其定义在`contacts`路由中。以下是两种情况下动作传播的说明图：
- en: '![Registering DOM element event listeners](img/00007.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![注册DOM元素事件监听器](img/00007.jpeg)'
- en: 'The preceding action function can still be located in any controller if we
    specify the `target` object of the action. The `target` object contains the `actions`
    hash that Ember.js checks for the `action` function. By default, it is usually
    the corresponding controller of the template, as shown in the preceding figure.
    Therefore, we can define the `action` function in the `contact` controller, and
    then set the target as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定了动作的`target`对象，先前的动作函数仍然可以位于任何控制器中。`target`对象包含 Ember.js 检查`action`函数的`actions`哈希。默认情况下，它通常是模板的相应控制器，如前图所示。因此，我们可以在`contact`控制器中定义`action`函数，然后将目标设置为：
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Writing form inputs
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写表单输入
- en: 'Writing forms is a common practice that Ember.js simplifies by providing template
    helpers of the many HTML5 form controls. The following table shows these common
    controls and the attributes they can accept:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 编写表单是 Ember.js 通过提供许多 HTML5 表单控件模板辅助函数来简化的常见做法。以下表格显示了这些常见控件及其可以接受的属性：
- en: '| Control | Attributes |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 控件 | 属性 |'
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `input` | `value``size``name``pattern``placeholder``disabled``maxlength``tabindex`
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `input` | `value` `size` `name` `pattern` `placeholder` `disabled` `maxlength`
    `tabindex` |'
- en: '| `textarea` | `checked``disabled``tabindex``indeterminate``name` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `textarea` | `checked` `disabled` `tabindex` `indeterminate` `name` |'
- en: '| `checkbox` | `rows``cols``placeholder``disabled``maxlength``tabindex` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `checkbox` | `rows` `cols` `placeholder` `disabled` `maxlength` `tabindex`
    |'
- en: 'In the sample application, the user is able to edit a contact by clicking on
    the **edit** button in the footer, as shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用程序中，用户可以通过点击页脚中的**编辑**按钮来编辑联系人，如下面的截图所示：
- en: '![Writing form inputs](img/00008.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![编写表单输入](img/00008.jpeg)'
- en: 'If the user edits the first name of the contact, we notice that their names
    are updated in the sidebar. The input helper is used in the `contacts/form` template
    to *bind* the input element''s value with the first name of the contact as:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户编辑联系人的名字，我们会注意到侧边栏中的名字也进行了更新。`input`辅助函数在`contacts/form`模板中被用来**绑定**输入元素的值与联系人的名字，如下所示：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we defined four attributes that were either bound or unbound. A bound
    attribute gets updated each time the specified variable changes and vice versa.
    For example, in the preceding case, the `value` attribute was bound while the
    `required` attribute was not. Unbound attributes are quoted while those bound
    are not.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了四个属性，它们要么是已绑定要么是未绑定的。已绑定的属性会在指定的变量更改时更新，反之亦然。例如，在前面的例子中，`value`属性是已绑定的，而`required`属性则不是。未绑定的属性用引号括起来，而绑定的则不用。
- en: 'Here are more examples that show how to use the other two form helpers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例，展示了如何使用其他两个表单辅助函数：
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Extending templates
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展模板
- en: 'In the course of application development, you might find the need to abstract
    templates for reuse. There are several helpers that can help us implement this
    easily:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发的过程中，您可能会发现需要抽象模板以供重用。有几个辅助函数可以帮助我们轻松实现这一点：
- en: '`partial`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partial`'
- en: '`view`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view`'
- en: '`render`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`'
- en: '`named outlets`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`named outlets`'
- en: 'The `partial` helper is used to include templates inside others. It simply
    inserts the desired template where the `partial` expression has been specified.
    As discussed earlier, the chapter sample used this helper in two instances:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`辅助函数用于在模板中包含其他模板。它简单地将所需的模板插入到`partial`表达式指定的位置。如前所述，章节示例在两个地方使用了此辅助函数：'
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This helper takes the template that should be inserted into the current template
    as the only argument. One thing to note is that using the helper doesn't lead
    to the loss of context, as seen in the `contact/edit` case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此辅助函数将应插入到当前模板中的模板作为唯一参数。需要注意的是，使用此辅助函数不会导致上下文丢失，正如在`contact/edit`案例中看到的那样。
- en: 'We might also wish to insert views inside other templates. In this case, the
    view''s template will be inserted into the specified portion of the current template
    and the defined event listeners will be set up. For example, the first name input
    we saw earlier can also be written as:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还希望在其他模板中插入视图。在这种情况下，视图的模板将被插入到当前模板的指定部分，并且将设置定义的事件监听器。例如，我们之前看到的第一个名字输入也可以写成：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will discuss this in more detail in [Chapter 6](part0069_split_000.html#page
    "Chapter 6. Views and Event Management"), *Views and Event Management*, where
    we will deal with views. The important thing to note here is that the input helpers
    named are actually Handlebars helpers defined from these views. We will discuss
    how these helpers are created in a moment. The `render` helper works in the same
    way as the `partial` helper, except that it takes an optional context as the second
    argument. For example, we will define the `contact/edit` and `contact/edit` templates
    as:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](part0069_split_000.html#page "第6章。视图和事件管理")中更详细地讨论这个问题，*视图和事件管理*，我们将处理视图。这里需要注意的是，所命名的输入辅助函数实际上是这些视图中定义的Handlebars辅助函数。我们将在稍后讨论这些辅助函数是如何创建的。`render`辅助函数与`partial`辅助函数的工作方式相同，不同之处在于它接受一个可选的上下文作为第二个参数。例如，我们将定义`contact/edit`和`contact/edit`模板如下：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Instead of switching the context in the first template, we simply passed the
    controller to be used as the context. Note that, by default, the context passed
    is the corresponding controller instance, and so we did not need to specify this
    context in the case of the `contacts/new` template.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在第一个模板中切换上下文，而是简单地传递了要使用的控制器作为上下文。请注意，默认情况下，传递的上下文是对应的控制器实例，因此在这种情况下我们不需要指定此上下文。
- en: 'The last way to extend templates is by the use of named outlets we already
    discussed in the preceding chapter. Here is the example we used:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种扩展模板的方法是使用我们在前一章中讨论过的命名出口。以下是我们的示例：
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We then render the outlets via the handler as:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过处理程序渲染出口：
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It's very similar to how the `partial` helper is used, but in this case, we
    also specify the template in the route handler's `renderTemplate` hook.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`partial`辅助函数的使用非常相似，但在这个情况下，我们还在路由处理器的`renderTemplate`钩子中指定了模板。
- en: Defining custom helpers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自定义辅助函数
- en: 'Handlebars provides ways to create your own helpers. The following is the format
    used to register new helpers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars提供了创建自定义辅助函数的方法。以下是新注册辅助函数的格式：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For example, let''s create a `heading` helper that creates `h1` tags:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个`heading`辅助函数，用于创建`h1`标签：
- en: '[PRE52]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This can then be used in our application templates as:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在我们的应用程序模板中使用，如下所示：
- en: '[PRE53]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, yield the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，生成以下内容：
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following example also demonstrates how to create helpers from existing
    views:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例还演示了如何从现有视图中创建辅助函数：
- en: '[PRE55]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This can now be used simply as:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以简单地使用如下：
- en: '[PRE56]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is equivalent to the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下：
- en: '[PRE57]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Creating subexpressions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建子表达式
- en: 'A subexpression, as the name suggests, is an expression contained in another
    expression, which takes the following signature:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 子表达式，正如其名所示，是包含在其他表达式中的表达式，它具有以下签名：
- en: '[PRE58]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here''s an example that implements a `Number.toFixed` helper:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个实现`Number.toFixed`辅助函数的示例：
- en: '[PRE59]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This can be used inside a `link-to` helper as:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在`link-to`辅助函数中使用，如下所示：
- en: '[PRE60]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This will result in something like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下类似的结果：
- en: '[PRE61]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This has been an exciting chapter that walked us through the template layer.
    This chapter will be revisited when we will discuss controllers in the next chapter.
    Here are the key concepts we learned and those that will be revisited in the next
    chapters:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章令人兴奋的章节，它引导我们了解了模板层。当我们讨论下一章中的控制器时，这一章将会被重新回顾。以下是我们在本章中学到的关键概念，以及将在下一章中回顾的概念：
- en: Writing binding template expressions
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写绑定模板表达式
- en: Writing conditionals in templates
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中编写条件语句
- en: Changing contexts in templates
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板中的上下文切换
- en: Creating event listeners in templates
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中创建事件监听器
- en: Extending templates
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展模板
- en: Writing custom template helpers
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义模板助手
