- en: About Node.js
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Node.js
- en: JavaScript is at the fingertips of every frontend web developer, making it a
    very popular programming language, so much so that it is stereotyped as being
    for client-side code in web pages. The chances are that, having picked up this
    book, you've heard of Node.js, a programming platform for coding in JavaScript
    outside web browsers. Now about ten years old, Node.js is becoming a mature programming
    platform that's widely used in projects both big and small.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是每个前端Web开发人员的得心应手，使其成为一种非常流行的编程语言，以至于被刻板地认为是用于Web页面中的客户端代码。有可能，拿起这本书的时候，你已经听说过Node.js，这是一个用于在Web浏览器之外编写JavaScript代码的编程平台。现在大约有十年的历史，Node.js正在成为一个成熟的编程平台，在大大小小的项目中被广泛使用。
- en: 'This book will give you an introduction to Node.js. By the end of this book,
    you will have learned about the complete lifecycle of developing server-side web
    applications using Node.js, from concept to deployment and security. In writing
    this book, we have presumed the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将为您介绍Node.js。通过本书，您将学习使用Node.js开发服务器端Web应用程序的完整生命周期，从概念到部署和安全性。在撰写本书时，我们假设以下内容：
- en: You already know how to write software.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经知道如何编写软件。
- en: You are familiar with JavaScript.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你熟悉JavaScript。
- en: You know something about developing web applications in other languages.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对其他语言中开发Web应用程序有所了解。
- en: When we evaluate a new programming tool, do we latch on because it's the popular
    new tool? Maybe some of us do that, but the mature approach is to weigh one tool
    against another. That's what this chapter is about, presenting the technical rationale
    for using Node.js. Before getting to the code, we must consider what Node.js is
    and how it fits in the overall marketplace of software development tools. Then
    we will dive right into developing working applications and recognize that often
    the best way to learn is by rummaging around in working code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估一个新的编程工具时，我们是因为它是流行的新工具而抓住它吗？也许我们中的一些人会这样做，但成熟的方法是将一个工具与另一个工具进行比较。这就是本章的内容，介绍使用Node.js的技术基础。在着手编写代码之前，我们必须考虑Node.js是什么，以及它如何适应软件开发工具的整体市场。然后我们将立即着手开发工作应用程序，并认识到通常学习的最佳方式是通过在工作代码中进行搜索。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: An introduction to Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js简介
- en: What you can do with Node.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js可以做什么
- en: Why you should use Node.js
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该使用Node.js
- en: The architecture of Node.js
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js的架构
- en: Performance, utilization, and scalability with Node.js
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js的性能、利用率和可扩展性
- en: Node.js, microservice architecture, and testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js、微服务架构和测试
- en: Implementing the twelve-factor app model with Node.js
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js实现十二要素应用程序模型
- en: Overview of Node.js
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js概述
- en: Node.js is an exciting new platform for developing web applications, application
    servers, any sort of network server or client, and general-purpose programming.
    It is designed for extreme scalability in networked applications through an ingenious
    combination of server-side JavaScript, asynchronous I/O, and asynchronous programming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个令人兴奋的新平台，用于开发Web应用程序、应用服务器、任何类型的网络服务器或客户端以及通用编程。它旨在通过服务器端JavaScript、异步I/O和异步编程的巧妙组合，在网络应用程序中实现极端可扩展性。
- en: While only ten years old, Node.js has quickly grown in prominence and is now
    playing a significant role. Companies, both large and small, are using it for
    large-scale and small-scale projects. PayPal, for example, has converted many
    services from Java to Node.js.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只有十年的历史，Node.js迅速崭露头角，现在正发挥着重要作用。无论是大公司还是小公司，都在大规模和小规模项目中使用它。例如，PayPal已经将许多服务从Java转换为Node.js。
- en: The Node.js architecture departs from a typical choice made by other application
    platforms. Where threads are widely used to scale an application to fill the CPU,
    Node.js eschews threads because of their inherent complexity. It's claimed that
    with single-thread event-driven architectures, the memory footprint is low, throughput
    is high, the latency profile under load is better, and the programming model is
    simpler. The Node.js platform is in a phase of rapid growth, and many see it as
    a compelling alternative to the traditional web application architectures using Java,
    PHP, Python, or Ruby on Rails.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的架构与其他应用平台通常选择的方式有所不同。在其他应用平台中，线程被广泛使用来扩展应用程序以填充CPU，而Node.js则避免使用线程，因为线程具有固有的复杂性。据称，采用单线程事件驱动架构，内存占用低，吞吐量高，负载下的延迟配置文件更好，并且编程模型更简单。Node.js平台正处于快速增长阶段，许多人认为它是传统的使用Java、PHP、Python或Ruby
    on Rails的Web应用程序架构的一个引人注目的替代方案。
- en: At its heart, it is a standalone JavaScript engine with extensions that is suitable
    for general-purpose programming and that has a clear focus on application server
    development. Even though we're comparing Node.js to application-server platforms,
    it is not an application server. Instead, Node.js is a programming runtime akin
    to Python, Go, or Java SE. While there are web application frameworks and application
    servers written in Node.js, it is simply a system to execute JavaScript programs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，它是一个独立的JavaScript引擎，具有适用于通用编程的扩展，并且专注于应用服务器开发。尽管我们正在将Node.js与应用服务器平台进行比较，但它并不是一个应用服务器。相反，Node.js是一个类似于Python、Go或Java
    SE的编程运行时。虽然有一些用Node.js编写的Web应用程序框架和应用服务器，但它只是一个执行JavaScript程序的系统。
- en: The key architectural choice is that Node.js is event-driven, rather than multithreaded.
    The Node.js architecture rests on dispatching blocking operations to a single-threaded
    event loop, with results arriving back to the caller as an event that invokes
    an event handler function. In most cases, the event is converted into a promise
    that is handled by an `async` function. Because Node.js is based on Chrome's V8
    JavaScript engine, the performance and feature improvements implemented in Chrome
    quickly flow through to the Node.js platform.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的架构选择是Node.js是事件驱动的，而不是多线程的。Node.js架构基于将阻塞操作分派到单线程事件循环，结果以调用事件处理程序的事件返回给调用者。在大多数情况下，事件被转换为由`async`函数处理的promise。由于Node.js基于Chrome的V8
    JavaScript引擎，Chrome中实现的性能和功能改进很快就会流入Node.js平台。
- en: The Node.js core modules are general enough to implement any sort of server
    that is executing any TCP or UDP protocol, whether it's a **D****omain Name System** (**DNS**),
    HTTP, **internet relay chat** (**IRC**), or FTP. While it supports the development
    of internet servers or clients, its biggest use case is regular website development,
    in place of technology such as an Apache/PHP or Rails stack, or to complement
    existing websites—for example, adding real-time chat or monitoring existing websites
    can easily be done with the Socket.IO library for Node.js. Its lightweight, high-performance
    nature often sees Node.js used as a **glue** service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js核心模块足够通用，可以实现执行任何TCP或UDP协议的服务器，无论是DNS、HTTP、互联网中继聊天（IRC）还是FTP。虽然它支持互联网服务器或客户端的开发，但它最大的用例是常规网站开发，取代了像Apache/PHP或Rails堆栈这样的技术，或者作为现有网站的补充，例如，使用Node.js的Socket.IO库可以轻松地添加实时聊天或监控现有网站。它的轻量级、高性能的特性经常被用作Node.js的“胶水”服务。
- en: A particularly intriguing combination is the deployment of small services on
    modern cloud infrastructure using tools such as Docker and Kubernetes, or function-as-a-service
    platforms, such as AWS Lambda. Node.js works well when dividing a large application
    into easily deployable microservices at scale.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 特别有趣的组合是在现代云基础设施上部署小型服务，使用诸如Docker和Kubernetes之类的工具，或者像AWS Lambda这样的函数即服务平台。将大型应用程序划分为易于部署的微服务时，Node.js在规模上表现良好。
- en: With a high-level understanding of Node.js under our belt, let's dig a little
    deeper.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了Node.js的高级理解后，让我们深入一点。
- en: The capabilities of Node.js
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js的能力
- en: Node.js is a platform for writing JavaScript applications outside web browsers.
    This is not the JavaScript environment we are familiar with in web browsers! While
    Node.js executes the same JavaScript language that we use in browsers, it doesn't
    have some of the features associated with the browser. For example, there is no
    HTML DOM built into Node.js.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个在Web浏览器之外编写JavaScript应用程序的平台。这不是我们在Web浏览器中熟悉的JavaScript环境！虽然Node.js执行与我们在浏览器中使用的相同的JavaScript语言，但它没有一些与浏览器相关的功能。例如，Node.js中没有内置HTML
    DOM。
- en: 'Beyond its native ability to execute JavaScript, the built-in modules provide
    capabilities of the following sort:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其本身执行JavaScript的能力外，内置模块提供了以下类型的功能：
- en: Command-line tools (in shell script style)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行工具（以shell脚本风格）
- en: An interactive-terminal style of program—that is, a **read-eval-print loop**
    (**REPL**)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式终端风格的程序，即REPL
- en: Excellent process control functions to oversee child processes
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀的进程控制功能来监督子进程
- en: A buffer object to deal with binary data
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理二进制数据的缓冲对象
- en: TCP or UDP sockets with comprehensive, event-driven callbacks
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP或UDP套接字与全面的事件驱动回调
- en: DNS lookup
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS查找
- en: An HTTP, HTTPS, and HTTP/2-client server layered on top of the TCP library filesystem
    access
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP、HTTPS和HTTP/2客户端服务器在TCP库文件系统访问之上
- en: Built-in rudimentary unit testing support through assertions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的基本单元测试支持通过断言
- en: The network layer of Node.js is low level while being simple to use—for example,
    the HTTP modules allow you to write an HTTP server (or client) using a few lines
    of code. This is powerful, but it puts you, the programmer, very close to the
    protocol requests and makes you implement precisely those HTTP headers that you
    should return in request responses.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的网络层是低级的，同时使用起来很简单，例如，HTTP模块允许您使用几行代码编写HTTP服务器（或客户端）。这很强大，但它让您，程序员，非常接近协议请求，并让您实现应该在请求响应中返回的那些HTTP头部。
- en: Typical web-application developers don't need to work at a low level of the
    HTTP or other protocols; instead, we tend to be more productive working with higher-level
    interfaces—for example, PHP coders assume that Apache/Nginx/and so on are already
    there providing the HTTP, and that they don't have to implement the HTTP server
    portion of the stack. By contrast, a Node.js programmer does implement an HTTP
    server, to which their application code is attached.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Web应用程序开发人员不需要在HTTP或其他协议的低级别上工作；相反，我们倾向于使用更高级别的接口更加高效，例如，PHP程序员假设Apache/Nginx等已经提供了HTTP，并且他们不必实现堆栈的HTTP服务器部分。相比之下，Node.js程序员确实实现了一个HTTP服务器，他们的应用代码附加到其中。
- en: To simplify the situation, the Node.js community has several web application
    frameworks, such as Express, providing the higher-level interfaces required by
    typical programmers. You can quickly configure an HTTP server with baked-in capabilities,
    such as sessions, cookies, serving static files, and logging, letting developers
    focus on their business logic. Other frameworks provide OAuth 2 support or focus
    on REST APIs, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化情况，Node.js社区有几个Web应用程序框架，比如Express，提供了典型程序员所需的更高级别的接口。您可以快速配置一个具有内置功能的HTTP服务器，比如会话、cookie、提供静态文件和日志记录，让开发人员专注于业务逻辑。其他框架提供OAuth
    2支持或专注于REST API等等。
- en: The community of folks using Node.js has built an amazing variety of things
    on this foundation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js的社区在这个基础上构建了各种令人惊叹的东西。
- en: What are folks doing with Node.js?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人们如何使用Node.js？
- en: 'Node.js is not limited to web service application development; the community
    around Node.js has taken it in many other directions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js不仅限于Web服务应用程序开发；Node.js周围的社区已经将其引向了许多其他方向：
- en: '**Build tools**: Node.js has become a popular choice for developing command-line
    tools that are used in software development or communicating with service infrastructure.
    Grunt, Gulp, and Webpack are widely used by frontend developers to build assets
    for websites. Babel is widely used for transpiling modern ES-2016 code to run
    on older browsers. Popular CSS optimizers and processors, such as PostCSS, are
    written in Node.js. static website generation systems, such as Metalsmith, Punch,
    and AkashaCMS, run at the command line, and generate website content that you
    upload to a web server.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具：Node.js已经成为开发命令行工具的热门选择，这些工具用于软件开发或与服务基础设施通信。Grunt、Gulp和Webpack被广泛用于前端开发人员构建网站资产。Babel被广泛用于将现代ES-2016代码转译为在旧版浏览器上运行。流行的CSS优化器和处理器，如PostCSS，都是用Node.js编写的。静态网站生成系统，如Metalsmith、Punch和AkashaCMS，在命令行上运行，并生成您上传到Web服务器的网站内容。
- en: '**Web UI testing**: Puppeteer gives you control over a headless Chrome web-browser
    instance. With it, you can develop Node.js scripts by controlling a modern, full-featured
    web browser. Some typical use cases are web scraping and web application testing.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web UI测试：Puppeteer让您控制一个无头Chrome浏览器实例。借助它，您可以通过控制现代、功能齐全的Web浏览器来开发Node.js脚本。一些典型的用例是Web抓取和Web应用程序测试。
- en: '**Desktop applications**: Both Electron and **node-webkit** (**NW.js**) are
    frameworks for developing desktop applications for Windows, macOS, and Linux.
    These frameworks utilize a large chunk of Chrome, wrapped by Node.js libraries,
    to develop desktop applications using web UI technologies. Applications are written
    with modern HTML5, CSS3, and JavaScript, and can utilize leading-edge web frameworks,
    such as Bootstrap, React, VueJS, and AngularJS. Many popular applications have
    been built using Electron, including the Slack desktop client application, the
    Atom, Microsoft Visual Code programming editors, the Postman REST client, the
    GitKraken GIT client, and Etcher, which makes it incredibly easy to burn OS images
    to flash drives to run on single-board computers.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面应用程序：Electron和node-webkit（NW.js）都是用于开发Windows、macOS和Linux桌面应用程序的框架。这些框架利用大量的Chrome，由Node.js库包装，使用Web
    UI技术开发桌面应用程序。应用程序使用现代的HTML5、CSS3和JavaScript编写，并可以利用领先的Web框架，如Bootstrap、React、VueJS和AngularJS。许多流行的应用程序都是使用Electron构建的，包括Slack桌面客户端应用程序、Atom、Microsoft
    Visual Code编程编辑器、Postman REST客户端、GitKraken GIT客户端和Etcher等。
- en: '**Mobile applications**: The Node.js for Mobile Systems project lets you develop
    smartphone or tablet computer applications using Node.js for both iOS and Android.
    Apple''s App Store rules preclude incorporating a JavaScript engine with JIT capabilities,
    meaning that normal Node.js cannot be used in an iOS application. For iOS application
    development, the project uses Node.js-on-ChakraCore to skirt around the App Store
    rules. For Android application development, the project uses regular Node.js on
    Android. At the time of writing, the project is in an early stage of development,
    but it looks promising.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动应用程序：Node.js for Mobile Systems项目允许您使用Node.js开发iOS和Android的智能手机或平板电脑应用程序。苹果的App
    Store规定不允许将具有JIT功能的JavaScript引擎纳入其中，这意味着普通的Node.js不能在iOS应用程序中使用。对于iOS应用程序开发，该项目使用Node.js-on-ChakraCore来规避App
    Store规定。对于Android应用程序开发，该项目使用常规的Node.js在Android上运行。在撰写本文时，该项目处于早期开发阶段，但看起来很有前景。
- en: '**Internet of things** (**IoT**): Node.js is a very popular language for Internet-of-Things
    projects, and Node.js runs on most ARM-based, single-board computers. The clearest
    example is the NodeRED project. It offers a graphical programming environment,
    letting you draw programs by connecting blocks together. It features hardware-oriented
    input and output mechanisms—for example, to interact with **General Purpose I/O**
    (**GPIO**) pins on Raspberry Pi or Beaglebone single-board computers.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网（IoT）：Node.js是物联网项目中非常流行的语言，Node.js可以在大多数基于ARM的单板计算机上运行。最明显的例子是NodeRED项目。它提供了一个图形化的编程环境，让您通过连接块来绘制程序。它具有面向硬件的输入和输出机制，例如与树莓派或Beaglebone单板计算机上的通用I/O（GPIO）引脚进行交互。
- en: You may already be using Node.js applications without realizing it! JavaScript
    has a place outside the web browser, and it's not just thanks to Node.js.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在使用Node.js应用程序而没有意识到！JavaScript在Web浏览器之外也有用武之地，这不仅仅是因为Node.js。
- en: Server-side JavaScript
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端JavaScript
- en: Quit scratching your head, already! Of course, you're doing it, scratching your head
    and mumbling to yourself, "What's a browser language doing on the server?" In
    truth, JavaScript has a long and largely unknown history outside the browser.
    JavaScript is a programming language, just like any other language, and the better
    question to ask is "Why should JavaScript remain trapped inside web browsers?"
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 别再挠头了！当然，您正在这样做，挠头并自言自语地说：“浏览器语言在服务器上做什么？”事实上，JavaScript在浏览器之外有着悠久而鲜为人知的历史。JavaScript是一种编程语言，就像任何其他语言一样，更好的问题是“为什么JavaScript应该被困在Web浏览器内部？”
- en: Back in the dawn of the web age, the tools for writing web applications were
    at a fledgling stage. Some developers were experimenting with Perl or TCL to write
    CGI scripts, and the PHP and Java languages had just been developed. Even then,
    JavaScript saw use on the server side. One early web application server was Netscape's
    LiveWire server, which used JavaScript. Some versions of Microsoft's ASP used
    JScript, their version of JavaScript. A more recent server-side JavaScript project
    is the RingoJS application framework in the Java universe. Java 6 and Java 7 were
    both shipped with the Rhino JavaScript engine. In Java 8, Rhino was dropped in
    favor of the newer Nashorn JavaScript engine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回到网络时代的黎明，编写Web应用程序的工具处于萌芽阶段。一些开发人员尝试使用Perl或TCL编写CGI脚本，PHP和Java语言刚刚被开发出来。即便那时，JavaScript也在服务器端使用。早期的Web应用程序服务器之一是网景的LiveWire服务器，它使用了JavaScript。微软的ASP的一些版本使用了JScript，他们的JavaScript版本。一个更近期的服务器端JavaScript项目是Java领域的RingoJS应用程序框架。Java
    6和Java 7都附带了Rhino JavaScript引擎。在Java 8中，Rhino被新的Nashorn JavaScript引擎所取代。
- en: In other words, JavaScript outside the browser is not a new thing, even if it
    is uncommon.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，JavaScript在浏览器之外并不是一件新事物，尽管它并不常见。
- en: You have learned that Node.js is a platform for writing JavaScript applications
    outside of web browsers. The Node.js community uses this platform for a huge array
    of application types, far more than was originally conceived for the platform.
    This proves that Node.js is popular, but we must still consider the technical
    rationale for using it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到Node.js是一个用于在Web浏览器之外编写JavaScript应用程序的平台。Node.js社区使用这个平台进行各种类型的应用程序开发，远远超出了最初为该平台构思的范围。这证明了Node.js的受欢迎程度，但我们仍然必须考虑使用它的技术原因。
- en: Why should you use Node.js?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用Node.js？
- en: Of the many available web-application development platforms, why should you
    choose Node.js? There are many stacks to choose from; what is it about Node.js
    that makes it rise above the others? We will learn the answer to this in the following
    sections.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多可用的Web应用程序开发平台中，为什么应该选择Node.js？有很多选择，那么Node.js有什么特点使其脱颖而出呢？我们将在接下来的部分中找到答案。
- en: Popularity
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行度
- en: Node.js is quickly becoming a popular development platform, and is being adopted
    by plenty of big and small players. One of these players is PayPal, who are replacing
    their incumbent Java-based system with one written in Node.js. Other large Node.js
    adopters include Walmart's online e-commerce platform, LinkedIn, and eBay.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js迅速成为一种受欢迎的开发平台，并被许多大大小小的参与者所采用。其中之一是PayPal，他们正在用Node.js替换其现有的基于Java的系统。其他大型Node.js采用者包括沃尔玛的在线电子商务平台、LinkedIn和eBay。
- en: For PayPal's blog post about this, visit [https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/](https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PayPal关于此的博客文章，请访问[https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/](https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/)。
- en: According to NodeSource, Node.js usage is growing rapidly (for more information,
    visit [https://nodesource.com/node-by-numbers](https://nodesource.com/node-by-numbers)). The
    evidence for this growth includes increasing bandwidth for downloading Node.js
    releases, increasing activity in Node.js-related GitHub projects, and more.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据NodeSource的说法，Node.js的使用量正在迅速增长（有关更多信息，请访问[https://nodesource.com/node-by-numbers](https://nodesource.com/node-by-numbers)）。这种增长的证据包括下载Node.js版本的带宽增加，与Node.js相关的GitHub项目的活动增加等。
- en: Interest in JavaScript itself remains very strong but has been at a plateau
    for years, measured in search volume (Google Insights) and its use as a programming
    skill (Dice Skills Center). Node.js interest has been growing rapidly, but is
    showing signs of plateauing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对JavaScript本身的兴趣仍然非常强烈，但在搜索量（Google Insights）和作为编程技能的使用方面（Dice Skills Center）已经停滞多年。Node.js的兴趣一直在迅速增长，但正在显示出停滞的迹象。
- en: For more on this, see [https://itnext.io/choosing-typescript-vs-javascript-technology-popularity-ea978afd6b5f](https://itnext.io/choosing-typescript-vs-javascript-technology-popularity-ea978afd6b5f) or [http://bit.ly/2q5cu0w](http://bit.ly/2q5cu0w).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[https://itnext.io/choosing-typescript-vs-javascript-technology-popularity-ea978afd6b5f](https://itnext.io/choosing-typescript-vs-javascript-technology-popularity-ea978afd6b5f)或[http://bit.ly/2q5cu0w](http://bit.ly/2q5cu0w)。
- en: It's best to not just follow the crowd because there are different crowds, and
    each one claims that their software platform does cool things. Node.js does some
    cool things, but what is more important is its technical merit.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要只是跟随潮流，因为有不同的潮流，每一个都声称他们的软件平台有很酷的功能。Node.js确实有一些很酷的功能，但更重要的是它的技术价值。
- en: JavaScript everywhere
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript无处不在
- en: Having the same programming language on the server and client has been a long-time
    dream on the web. This dream dates back to the early days of Java, where Java
    applets in the browser were to be the frontend to server applications written
    in Java, and JavaScript was originally envisioned as a lightweight scripting language
    for those applets. Java never fulfilled its hype as a client-side programming
    language, and even the phrase "Java Applets" is fading into a dim memory of the
    abandoned client-side application model. We ended up with JavaScript as the principle
    in-browser, client-side language, rather than Java. Typically, the frontend JavaScript
    developers were in a different language universe than the server-side team, which
    was likely to be coding in PHP, Java, Ruby, or Python.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器和客户端上使用相同的编程语言一直是网络上的一个长期梦想。这个梦想可以追溯到早期的Java时代，当时Java小程序在浏览器中被视为用于Java编写的服务器应用程序的前端，而JavaScript最初被设想为这些小程序的轻量级脚本语言。然而，Java从未实现其作为客户端编程语言的炒作，甚至“Java小程序”这个词组也正在逐渐消失，成为被放弃的客户端应用程序模型的模糊记忆。最终，我们选择了JavaScript作为浏览器中的主要客户端语言，而不是Java。通常情况下，前端JavaScript开发人员使用的是与服务器端团队不同的语言，后者可能是PHP、Java、Ruby或Python。
- en: Over time, in-browser JavaScript engines became incredibly powerful, letting
    us write ever-more-complex browser-side applications. With Node.js, we are finally
    able to implement applications with the same programming language on the client
    and server by having JavaScript at both ends of the web, in the browser and server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，在浏览器中的JavaScript引擎变得非常强大，让我们能够编写越来越复杂的浏览器端应用程序。有了Node.js，我们终于能够使用相同的编程语言在客户端和服务器上实现应用程序，因为JavaScript在网络的两端，即浏览器和服务器上。
- en: 'A common language for frontend and backend offers several potential benefits:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和后端使用相同的编程语言具有几个潜在的好处：
- en: The same programming staff can work on both ends of the wire.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一编程人员可以在网络两端工作。
- en: Code can be migrated between the server and client more easily.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以更轻松地在服务器和客户端之间迁移。
- en: Common data formats (JSON) between the server and client.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端之间的常见数据格式（JSON）。
- en: Common software tools exist for the server and client.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端存在常见的软件工具。
- en: Common testing or quality-reporting tools for the server and client.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端的常见测试或质量报告工具。
- en: When writing web applications, view templates can be used on both sides.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写Web应用程序时，视图模板可以在两端使用。
- en: The JavaScript language is very popular because of its ubiquity in web browsers.
    It compares favorably with other languages while having many modern, advanced
    language concepts. Thanks to its popularity, there is a deep talent pool of experienced
    JavaScript programmers out there.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言非常受欢迎，因为它在Web浏览器中非常普遍。它与其他语言相比具有许多现代、先进的语言概念。由于其受欢迎程度，有许多经验丰富的JavaScript程序员。
- en: Leveraging Google's investment in V8
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用谷歌对V8的投资
- en: To make Chrome a popular and excellent web browser, Google invested in making
    V8 a super-fast JavaScript engine. Google, therefore, has a huge motivation to
    keep on improving V8. V8 is the JavaScript engine for Chrome, and it can also
    be executed in a standalone manner.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Chrome成为一款受欢迎且出色的Web浏览器，谷歌投资于使V8成为一个超快的JavaScript引擎。因此，谷歌有巨大的动力继续改进V8。V8是Chrome的JavaScript引擎，也可以独立执行。
- en: Node.js is built on top of the V8 JavaScript engine, letting it take advantage
    of all that work on V8\. As a result, Node.js was able to quickly adopt new JavaScript
    language features as they were implemented by V8 and reap performance wins for
    the same reason.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js建立在V8 JavaScript引擎之上，使其能够利用V8的所有工作。因此，Node.js能够在V8实现新的JavaScript语言特性时迅速采用，并因此获得性能优势。
- en: Leaner, asynchronous, event-driven model
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更精简、异步、事件驱动的模型
- en: The Node.js architecture, built on a single execution thread, with an ingenious
    event-oriented, asynchronous-programming model, and a fast JavaScript engine,
    is claimed to have less overhead than thread-based architectures. Other systems
    using threads for concurrency tend to have memory overhead and complexity, which
    Node.js does not have. We'll get into this more later in the chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js架构建立在单个执行线程上，具有巧妙的事件驱动、异步编程模型和快速的JavaScript引擎，据称比基于线程的架构具有更少的开销。其他使用线程进行并发的系统往往具有内存开销和复杂性，而Node.js没有。我们稍后会更深入地讨论这一点。
- en: Microservice architecture
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构
- en: A new sensation in software development is the idea of the microservice. Microservices
    are focused on splitting a large web application into small, tightly-focused services
    that can be easily developed by small teams. While they aren't exactly a new idea—they're
    more of a reframing of old client–server computing models—the microservice pattern
    fits well with agile project-management techniques, and gives us a more granular
    application deployment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的一个新感觉是微服务的概念。微服务专注于将大型Web应用程序拆分为小型、紧密专注的服务，可以由小团队轻松开发。虽然它们并不是一个全新的想法，它们更像是对旧的客户端-服务器计算模型的重新构架，但是微服务模式与敏捷项目管理技术很匹配，并且为我们提供了更精细的应用部署。
- en: Node.js is an excellent platform for implementing microservices. We'll get into
    this later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是实现微服务的优秀平台。我们稍后会详细介绍。
- en: Node.js is stronger after a major schism and hostile fork
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js在一次重大分裂和敌对分支之后变得更加强大
- en: During 2014 and 2015, the Node.js community faced a major split over policy,
    direction, and control. The **io.js** project was a hostile fork driven by a group
    that wanted to incorporate several features and change who was in the decision-making
    process. The end result was a merge of the Node.js and io.js repositories, an
    independent Node.js foundation to run the show, and the community working together
    to move forward in a common direction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年和2015年，Node.js社区因政策、方向和控制而发生了重大分裂。**io.js**项目是一个敌对的分支，由一群人驱动，他们希望合并几个功能并改变决策过程中的人员。最终的结果是合并了Node.js和io.js存储库，成立了独立的Node.js基金会来运作，并且社区共同努力朝着共同的方向前进。
- en: A concrete result of healing that rift is the rapid adoption of new ECMAScript language
    features. The V8 engine is adopting these new features quickly to advance the
    state of web development. The Node.js team, in turn, is adopting these features
    as quickly as they show up in V8, meaning that promises and `async` functions
    are quickly becoming a reality for Node.js programmers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 弥合这一分歧的一个具体结果是快速采用新的ECMAScript语言特性。V8引擎迅速采用这些新特性来推进Web开发的状态。Node.js团队也在V8中尽快采用这些特性，这意味着承诺和`async`函数很快就会成为Node.js程序员的现实。
- en: The bottom line is that the Node.js community not only survived the io.js fork
    and the later ayo.js fork, but the community and the platform it nurtured grew
    stronger as a result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Node.js社区不仅在io.js分支和后来的ayo.js分支中幸存下来，而且社区和它培育的平台因此变得更加强大。
- en: In this section, you have learned several reasons to use Node.js. Not only is
    it a popular platform, with a strong community behind it, but there are also serious
    technical reasons to use it. Its architecture has some key technical benefits,
    so let's take a deeper look at these.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经了解了使用Node.js的几个原因。它不仅是一个受欢迎的平台，有一个强大的社区支持，而且还有一些严肃的技术原因可以使用它。它的架构具有一些关键的技术优势，让我们更深入地了解一下这些优势。
- en: The Node.js event-driven architecture
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js事件驱动架构
- en: 'Node.js''s blistering performance is said to be because of its asynchronous
    event-driven architecture and its use of the V8 JavaScript engine. This enables
    it to handle multiple tasks concurrently, such as juggling between requests from
    multiple web browsers. The original creator of Node.js, Ryan Dahl, followed these
    key points:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 据说Node.js的出色性能是因为其异步事件驱动架构和使用V8 JavaScript引擎。这使其能够同时处理多个任务，例如在多个Web浏览器的请求之间进行协调。Node.js的原始创始人Ryan
    Dahl遵循了这些关键点：
- en: A single-thread, event-driven programming model is simpler to code and has less
    complexity and less overhead than application servers that rely on threads to
    handle multiple concurrent tasks.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单线程、事件驱动的编程模型比依赖线程处理多个并发任务的应用服务器更简单，复杂性更低，开销更小。
- en: By converting blocking function calls into asynchronous code execution, you
    can configure the systems so that it issues an event when the blocking request
    is satisfied.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将阻塞函数调用转换为异步代码执行，可以配置系统以在满足阻塞请求时发出事件。
- en: You can leverage the V8 JavaScript engine from the Chrome browser, and all the
    work goes into improving V8; all the performance enhancements going into V8, therefore,
    benefits Node.js.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以利用来自Chrome浏览器的V8 JavaScript引擎，并且所有工作都用于改进V8；所有性能增强都进入V8，因此也有益于Node.js。
- en: In most application servers, concurrency, or the ability to handle multiple
    concurrent requests, is implemented with a multithreaded architecture. In such
    a system, any request for data, or any other blocking function call, causes the
    current execution thread to suspend and wait for the result. Handling concurrent
    requests requires there to be multiple execution threads. When one thread is suspended,
    another thread can execute. This causes churn as the application server starts
    and stops the threads to handle requests. Each suspended thread (typically waiting
    on an input/output operation to finish) consumes a full call stack of memory,
    adding to overhead. Threads add complexity to the application server as well as server
    overhead.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用服务器中，并发或处理多个并发请求的能力是通过多线程架构实现的。在这样的系统中，对数据的任何请求或任何其他阻塞函数调用都会导致当前执行线程暂停并等待结果。处理并发请求需要有多个执行线程。当一个线程被暂停时，另一个线程可以执行。这会导致应用服务器启动和停止线程来处理请求。每个暂停的线程（通常在输入/输出操作完成时等待）都会消耗完整的内存调用堆栈，增加开销。线程会给应用服务器增加复杂性和服务器开销。
- en: 'To help us wrap our heads around why this would be, Ryan Dahl, the creator
    of Node.js, offered the following example. In his Cinco de NodeJS presentation
    in May 2010 ([https://www.youtube.com/watch?v=M-sc73Y-zQA](https://www.youtube.com/watch?v=M-sc73Y-zQA))
    Dahl asked us what happens when we execute a line of code such as this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解为什么会这样，Node.js的创始人Ryan Dahl在2010年5月的Cinco de NodeJS演示中提供了以下示例。([https://www.youtube.com/watch?v=M-sc73Y-zQA](https://www.youtube.com/watch?v=M-sc73Y-zQA))
    Dahl问我们当我们执行这样的代码行时会发生什么：
- en: '[PRE0]js\1'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: The programmer supplies a function that is called (hence the name *callback
    function*) when the result (or error) is available. The `query` function still
    takes the same amount of time. Instead of blocking the execution thread, it returns
    to the event loop, which is then free to handle other requests. The Node.js will
    eventually fire an event that causes this callback function to be called with
    the result or error indication.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员提供一个在结果（或错误）可用时被调用的函数（因此称为*回调函数*）。`query`函数仍然需要相同的时间。它不会阻塞执行线程，而是返回到事件循环，然后可以处理其他请求。Node.js最终会触发一个事件，导致调用此回调函数并返回结果或错误指示。
- en: A similar paradigm is used in client-side JavaScript, where we write event handler
    functions all the time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端JavaScript中使用类似的范例，我们经常编写事件处理程序函数。
- en: 'Advances in the JavaScript language have given us new options. When used with
    ES2015 promises, the equivalent code would look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言的进步为我们提供了新的选择。与ES2015 promises一起使用时，等效的代码如下：
- en: '[PRE1]js\1'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: Other than the `async` and `await` keywords, this looks like code we'd write
    in other languages, and is much easier to read. Because of what `await` does,
    it is still asynchronous code execution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`async`和`await`关键字之外，这看起来像我们在其他语言中编写的代码，并且更容易阅读。由于`await`的作用，它仍然是异步代码执行。
- en: All three of these code snippets perform the same query that we wrote earlier.
    Instead of `query` being a blocking function call, it is asynchronous and does
    not block the execution thread.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个代码片段都执行了我们之前编写的相同查询。`query`不再是阻塞函数调用，而是异步的，不会阻塞执行线程。
- en: With both the callback functions and the promise's asynchronous coding, Node.js
    had its own complexity issue. Oftentimes, we call one asynchronous function after
    another. With callback functions, that meant deeply nested callback functions,
    and with promises, that meant a long chain of `.then` handler functions. In addition
    to the complexity of the coding, we have errors and results landing in unnatural
    places. Instead of landing on the next line of code, the asynchronously executed
    callback function is invoked. The order of execution is not one line after another,
    as it is in synchronous programming languages; instead, the order of execution
    is determined by the order of the callback function execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调函数和promise的异步编码，Node.js也存在自己的复杂性问题。我们经常在一个异步函数之后调用另一个异步函数。使用回调函数意味着深度嵌套的回调函数，而使用promise则意味着长长的`.then`处理程序函数链。除了编码的复杂性，我们还有错误和结果出现在不自然的位置。异步执行的回调函数被调用时，不会落在下一行代码上。执行顺序不是像同步编程语言中一行接一行的，而是由回调函数执行的顺序决定的。
- en: The `async` function approach solves that coding complexity. The coding style
    is more natural since the results and errors land in the natural place, at the
    next line of code. The `await` keyword integrates asynchronous result handling
    without blocking the execution thread. A lot is buried under the covers of the
    `async/await` feature, and we'll be covering this model extensively throughout
    this book.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`函数的方法解决了这种编码复杂性。编码风格更自然，因为结果和错误出现在自然的位置，即下一行代码。`await`关键字集成了异步结果处理，而不会阻塞执行线程。`async/await`功能的背后有很多东西，我们将在本书中广泛涵盖这个模型。'
- en: But does the asynchronous architecture of Node.js actually improve performance?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Node.js的异步架构实际上改善了性能吗？
- en: Performance and utilization
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能和利用率
- en: Some of the excitement over Node.js is due to its throughput (the requests per
    second that it can serve). Comparative benchmarks of similar applications—for
    example, Apache—show that Node.js has tremendous performance gains.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js引起了一些兴奋是因为它的吞吐量（每秒请求量）。对比类似应用的基准测试，比如Apache，显示出Node.js有巨大的性能提升。
- en: 'One benchmark going around is the following simple HTTP server (borrowed from [https://nodejs.org/en/](https://nodejs.org/en/)),
    which simply returns a `Hello World` message directly from memory:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流传的基准是以下简单的HTTP服务器（从[https://nodejs.org/en/](https://nodejs.org/en/)借来的），它直接从内存中返回一个`Hello
    World`消息：
- en: '[PRE2]js\1'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: 'This is a particularly simplistic approach to calculating Fibonacci numbers.
    Yes, there are many ways to calculate Fibonacci numbers more quickly. We are showing
    this as a general example of what happens to Node.js when event handlers are slow
    and not to debate the best ways to calculate mathematical functions. Consider
    the following server:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特别简单的方法来计算斐波那契数。是的，有很多更快的计算斐波那契数的方法。我们展示这个作为Node.js在事件处理程序缓慢时会发生什么的一个一般性例子，而不是讨论计算数学函数的最佳方法。考虑以下服务器：
- en: '[PRE3]js\1'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]js\1'
- en: This is an equally silly way to calculate Fibonacci numbers, but by using `process.nextTick`,
    the event loop has an opportunity to execute.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个同样愚蠢的计算斐波那契数的方法，但是通过使用`process.nextTick`，事件循环有机会执行。
- en: 'Because this is an asynchronous function that takes a callback function, it
    necessitates a small refactoring of the server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个需要回调函数的异步函数，它需要对服务器进行小的重构：
- en: '[PRE4]js\1'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]js\1'
- en: This was an important insight on Ryan Dahl's part, and is what propelled Node.js's
    popularity. Certain actions take a long time to run, such as database queries,
    and should not be treated the same as operations that quickly retrieve data from
    memory. Because of the nature of the JavaScript language, Node.js had to express
    this asynchronous coding construct in an unnatural way. The results do not appear
    at the next line of code, but instead appear within this callback function. Furthermore,
    errors have to be handled in an unnatural way, inside that callback function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Ryan Dahl的一个重要洞察，也是推动Node.js流行的原因。某些操作需要很长时间才能运行，比如数据库查询，不应该和快速从内存中检索数据的操作一样对待。由于JavaScript语言的特性，Node.js必须以一种不自然的方式表达这种异步编码结构。结果不会出现在下一行代码，而是出现在这个回调函数中。此外，错误必须以一种不自然的方式处理，出现在那个回调函数中。
- en: The convention in Node.js is that the first parameter to a callback function
    is an error indicator and the subsequent parameters are the results. This is a
    useful convention that you'll find all across the Node.js landscape; however,
    it complicates working with results and errors because both land in an inconvenient
    location—that callback function. The natural place for errors and results to land
    is on the subsequent line(s) of code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中的约定是回调函数的第一个参数是一个错误指示器，随后的参数是结果。这是一个有用的约定，你会在整个Node.js领域找到它；然而，它使得处理结果和错误变得复杂，因为两者都出现在一个不方便的位置——那个回调函数。错误和结果自然地应该出现在随后的代码行上。
- en: We descend further into callback hell with each layer of callback function nesting.
    The seventh layer of callback nesting is more complex than the sixth layer of
    callback nesting. Why? If nothing else, it's because the special considerations
    for error handling become ever more complex as callbacks are nested more deeply.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每一层回调函数嵌套，我们陷入了回调地狱。第七层回调嵌套比第六层回调嵌套更复杂。为什么？至少有一点是因为随着回调的嵌套更深，错误处理的特殊考虑变得更加复杂。
- en: 'But as we saw earlier, this is the new preferred way to write asynchronous
    code in Node.js:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们之前所看到的，这是在Node.js中编写异步代码的新首选方式：
- en: '```js'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '```js'
- en: Instead, ES2017 `async` functions return us to this very natural expression
    of programming intent. Results and errors land in the correct location while preserving
    the excellent event-driven asynchronous programming model that made Node.js great.
    We'll see how this works later in the book.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，ES2017的`async`函数使我们回到了这种非常自然的编程意图表达。结果和错误会在正确的位置上，同时保持了使Node.js变得伟大的出色的事件驱动的异步编程模型。我们将在本书的后面看到这是如何工作的。
- en: 'The TC-39 committee added many more new features to JavaScript, such as the
    following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: TC-39委员会为JavaScript添加了许多新功能，比如以下的：
- en: An improved syntax for class declarations, making object inheritance and getter/setter
    functions very natural.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的类声明语法，使对象继承和getter/setter函数非常自然。
- en: A new module format that is standardized across browsers and Node.js.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在浏览器和Node.js中标准化的新模块格式。
- en: New methods for strings, such as the template string notation.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的新方法，比如模板字符串表示法。
- en: New methods for collections and arrays—for example, operations for `map`/`reduce`/`filter`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合和数组的新方法，例如`map`/`reduce`/`filter`的操作。
- en: The `const` keyword to define variables that cannot be changed and the `let`
    keyword to define variables whose scope is limited to the block in which they're
    declared, rather than hoisted to the front of the function.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`const`关键字来定义不能被改变的变量，使用`let`关键字来定义变量的作用域仅限于它们声明的块，而不是被提升到函数的前面。
- en: New looping constructs and an iteration protocol that works with those new loops.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的循环结构和与这些新循环配合使用的迭代协议。
- en: A new kind of function, the arrow function, which is lighter in weight, meaning
    less memory and execution time impact.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种新类型的函数，箭头函数，它更轻量，意味着更少的内存和执行时间影响。
- en: The `Promise` object represents a result that is promised to be delivered in
    the future. By themselves, promises can mitigate the callback hell problem, and
    they form part of the basis for `async` functions.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise`对象表示将来承诺交付的结果。单独使用，承诺可以缓解回调地狱问题，并且它们构成了`async`函数的一部分基础。'
- en: Generator functions are an intriguing way to represent asynchronous iteration
    over a set of values. More importantly, they form the other half of the basis
    for async functions.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数是一种有趣的方式，用于表示一组值的异步迭代。更重要的是，它们构成了异步函数的基础的另一半。
- en: You may see the new JavaScript described as ES6 or ES2017\. What's the preferred
    name to describe the version of JavaScript that is being used?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到新的JavaScript被描述为ES6或ES2017。描述正在使用的JavaScript版本的首选名称是什么？
- en: ES1 through ES5 marked various phases of JavaScript's development. ES5 was released
    in 2009 and is widely implemented in modern browsers. Starting with ES6, the TC-39
    committee decided to change the naming convention because of their intention to
    add new language features every year. Therefore, the language version name now
    includes the year—for example, ES2015 was released in 2015, ES2016 was released
    in 2016, and ES2017 was released in 2017.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ES1到ES5标志着JavaScript发展的各个阶段。ES5于2009年发布，并在现代浏览器中得到广泛实现。从ES6开始，TC-39委员会决定改变命名约定，因为他们打算每年添加新的语言特性。因此，语言版本现在包括年份，例如，ES2015于2015年发布，ES2016于2016年发布，ES2017于2017年发布。
- en: Deploying ES2015/2016/2017/2018 JavaScript code
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署ES2015/2016/2017/2018 JavaScript代码
- en: The elephant in the room is that often JavaScript developers are unable to use
    the latest features. Frontend JavaScript developers are limited by the deployed
    web browsers and the large number of old browsers in use on machines whose OS
    hasn't been updated for years. Internet Explorer version 6 has fortunately been
    almost completely retired, but there are still plenty of old browsers installed
    on older computers that are still serving a valid role for their owners. Old browsers
    mean old JavaScript implementations, and if we want our code to work, we need
    it to be compatible with old browsers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，通常JavaScript开发人员无法使用最新的功能。前端JavaScript开发人员受到部署的网络浏览器和大量旧浏览器的限制，这些浏览器在长时间未更新操作系统的计算机上使用。幸运的是，Internet
    Explorer 6版本几乎已经完全退出使用，但仍然有大量旧浏览器安装在老旧计算机上，仍然为其所有者提供有效的角色。旧浏览器意味着旧的JavaScript实现，如果我们希望我们的代码能够运行，我们需要它与旧浏览器兼容。
- en: One of the uses for Babel and other code-rewriting tools is to deal with this
    issue. Many products must be usable by folks using an old browser. Developers
    can still write their code with the latest JavaScript or TypeScript features,
    then use Babel to rewrite their code so that it runs on the old browser. This
    way, frontend JavaScript programmers can adopt (some of) the new features at the
    cost of a more complex build toolchain and the risk of bugs being introduced by
    the code-rewriting process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Babel和其他代码重写工具的一个用途是处理这个问题。许多产品必须能够被使用旧浏览器的人使用。开发人员仍然可以使用最新的JavaScript或TypeScript功能编写他们的代码，然后使用Babel重写他们的代码，以便在旧浏览器上运行。这样，前端JavaScript程序员可以采用（部分）新功能，但需要更复杂的构建工具链，并且代码重写过程可能引入错误的风险。
- en: The Node.js world doesn't have this problem. Node.js has rapidly adopted ES2015/2016/2017
    features as quickly as they were implemented in the V8 engine. Starting with Node.js
    8, we were able to freely use `async` functions as a native feature. The new module
    format was first supported in Node.js version 10.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js世界没有这个问题。Node.js迅速采用了ES2015/2016/2017功能，就像它们在V8引擎中实现一样。从Node.js 8开始，我们可以自由地使用`async`函数作为一种原生功能。新的模块格式首次在Node.js版本10中得到支持。
- en: In other words, while frontend JavaScript programmers can argue that they must
    wait a couple of years before adopting ES2015/2016/2017 features, Node.js programmers
    have no need to wait. We can simply use the new features without needing any code-rewriting
    tools, unless our managers insist on supporting older Node.js releases that predate
    the adoption of these features. In that case, it is recommended that you use Babel.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，虽然前端JavaScript程序员可以主张他们必须等待几年才能采用ES2015/2016/2017功能，但Node.js程序员无需等待。我们可以简单地使用新功能，而无需任何代码重写工具，除非我们的管理人员坚持支持早于这些功能采用的旧Node.js版本。在这种情况下，建议您使用Babel。
- en: Some advances in the JavaScript world are happening outside the TC-39 community.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript世界的一些进步是在TC-39社区之外发生的。
- en: TypeScript and Node.js
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript和Node.js
- en: The TypeScript language is an interesting offshoot of the JavaScript environment.
    Because JavaScript is increasingly able to be used for complex applications, it
    is increasingly useful for the compiler to help catch programming errors. Enterprise
    programmers in other languages, such as Java, are accustomed to strong type checking
    as a way of preventing certain classes of bugs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript语言是JavaScript环境的一个有趣的分支。因为JavaScript越来越能够用于复杂的应用程序，编译器帮助捕捉编程错误变得越来越有用。其他语言的企业程序员，如Java，习惯于强类型检查作为防止某些类别的错误的一种方式。
- en: Strong type checking is somewhat anathema to JavaScript programmers, but is
    demonstrably useful. The TypeScript project aims to bring enough rigor from languages
    such as Java and C# while leaving enough of the looseness that makes JavaScript
    so popular. The result is compile-time type checking without the heavy baggage
    carried by programmers in some other languages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型检查在某种程度上与JavaScript程序员相悖，但它确实很有用。TypeScript项目旨在从Java和C#等语言中引入足够的严谨性，同时保留JavaScript的松散性。结果是编译时类型检查，而不会像其他语言中的程序员那样承载沉重的负担。
- en: While we won't use TypeScript in this book, its toolchain is very easy to adopt
    in Node.js applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本书中不会使用TypeScript，但它的工具链在Node.js应用程序中非常容易采用。
- en: In this section, we've learned that as the JavaScript language changes, the
    Node.js platform has kept up with those changes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到随着JavaScript语言的变化，Node.js平台也跟上了这些变化。
- en: Developing microservices or maxiservices with Node.js
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js开发微服务或最大服务
- en: New capabilities, such as cloud deployment systems and Docker, make it possible
    to implement a new kind of service architecture. Docker makes it possible to define
    server process configuration in a repeatable container that's easy to deploy by
    the millions into a cloud-hosting system. It lends itself best to small, single-purpose
    service instances that can be connected together to make a complete system. Docker
    isn't the only tool to help simplify cloud deployments; however, its features
    are well attuned to modern application deployment needs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 新的功能，如云部署系统和Docker，使得实现一种新的服务架构成为可能。Docker使得可以在可重复部署到云托管系统中的数百万个容器中定义服务器进程配置。它最适合小型、单一用途的服务实例，可以连接在一起组成一个完整的系统。Docker并不是唯一可以帮助简化云部署的工具；然而，它的特性非常适合现代应用部署需求。
- en: Some have popularized the microservice concept as a way to describe this kind
    of system. According to the [microservices.io](http://microservices.io/) website,
    a microservice consists of a set of narrowly focused, independently deployable
    services. They contrast this with the monolithic application-deployment pattern
    where every aspect of the system is integrated into one bundle (such as a single
    WAR file for a Java EE app server). The microservice model gives developers much-needed
    flexibility.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人将微服务概念作为描述这种系统的一种方式。根据[microservices.io](http://microservices.io/)网站，微服务由一组狭义、独立可部署的服务组成。他们将其与单片应用部署模式进行对比，单片应用将系统的每个方面集成到一个捆绑包中（例如Java
    EE应用服务器的单个WAR文件）。微服务模型为开发人员提供了非常需要的灵活性。
- en: 'Some advantages of microservices are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的一些优势如下：
- en: Each microservice can be managed by a small team.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务可以由一个小团队管理。
- en: Each team can work on its own schedule, so long as the service API compatibility
    is maintained.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个团队可以按照自己的时间表工作，只要保持服务API的兼容性。
- en: Microservices can be deployed independently should this be required, such as
    for easier testing.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务可以独立部署，如果需要的话，比如为了更容易进行测试。
- en: It's easier to switch technology stack choices.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易切换技术栈选择。
- en: 'Where does Node.js fit in with this? Its design fits the microservice model
    like a glove:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js在这方面的定位如何？它的设计与微服务模型非常契合：
- en: Node.js encourages small, tightly focused, single-purpose modules.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js鼓励小型、紧密专注、单一用途的模块。
- en: These modules are composed into an application by the excellent npm package
    management system.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些模块由出色的npm包管理系统组成应用程序。
- en: Publishing modules is incredibly simple, whether via the NPM repository or a
    Git URL.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布模块非常简单，无论是通过NPM仓库还是Git URL。
- en: While an app framework such as Express can be used with large services, it works
    very well for small lightweight services and supports easy, simple deployment.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然Express等应用框架可以用于大型服务，但它非常适用于小型轻量级服务，并支持简单易用的部署。
- en: In short, it's easy to use Node.js in a lean and agile fashion, building large
    or small services depending on your architecture preferences.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用Node.js以精益和敏捷的方式非常容易，可以根据您的架构偏好构建大型或小型服务。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You learned a lot in this chapter. Specifically, you saw that JavaScript has
    a life outside web browsers and that Node.js is an excellent programming platform
    with many interesting attributes. While it is a relatively young project, Node.js
    has become very popular and is widely used not just for web applications but for
    command-line developer tools and much more. Because the Node.js platform is based
    on Chrome's V8 JavaScript engine, the project has been able to keep up with the
    rapid improvements to the JavaScript language.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了很多东西。特别是，您看到了JavaScript在Web浏览器之外的生活，以及Node.js是一个具有许多有趣特性的优秀编程平台。虽然它是一个相对年轻的项目，但Node.js已经变得非常流行，不仅广泛用于Web应用程序，还用于命令行开发工具等。由于Node.js平台基于Chrome的V8
    JavaScript引擎，该项目已经能够跟上JavaScript语言的快速改进。
- en: The Node.js architecture consists of asynchronous functions managed by an event
    loop triggering callback functions, rather than using threads and blocking I/O.
    This architecture has claimed performance benefits that seem to offer many benefits,
    including the ability to do more work with less hardware. But we also learned
    that inefficient algorithms can erase any performance benefits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js架构由事件循环触发回调函数管理的异步函数组成，而不是使用线程和阻塞I/O。这种架构声称具有性能优势，似乎提供了许多好处，包括能够在更少的硬件上完成更多的工作。但我们也了解到低效的算法可能会抵消任何性能优势。
- en: Our focus in this book is the real-world considerations of developing and deploying
    Node.js applications. We'll cover as many aspects of developing, refining, testing,
    and deploying Node.js applications as we can.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的重点是开发和部署Node.js应用程序的现实考虑。我们将尽可能涵盖开发、完善、测试和部署Node.js应用程序的许多方面。
- en: Now that we've had this introduction to Node.js, we're ready to dive in and
    start using it. In [Chapter 2](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml), *Setting
    up Node.js*, we'll go over how to set up a Node.js development environment on
    Mac, Linux, or Windows, and even write some code. So let's get started.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对Node.js有了介绍，我们准备好开始使用它了。在[第2章](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml)
    *设置Node.js*中，我们将介绍如何在Mac、Linux或Windows上设置Node.js开发环境，甚至编写一些代码。让我们开始吧。
