- en: Chapter 1. Reducing Boilerplate with Plugin Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 通过插件开发减少样板代码
- en: '"When working on a web application that involves a lot of JavaScript, one of
    the first things you learn is to stop tying your data to the DOM. It''s all too
    easy to create JavaScript applications that end up as tangled piles of jQuery
    selectors and callbacks, all trying frantically to keep data in sync between the
    HTML UI, your JavaScript logic, and the database on your server. For rich client-side
    applications, a more structured approach is often helpful."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"当你在涉及大量JavaScript的Web应用上工作时，你最先学到的一件事就是停止将你的数据绑定到DOM上。创建JavaScript应用变得过于简单，最终结果可能是一堆混乱的jQuery选择器和回调函数，它们疯狂地试图在HTML
    UI、你的JavaScript逻辑和服务器上的数据库之间保持数据同步。对于富客户端应用，一种更结构化的方法通常更有帮助。"'
- en: The previous excerpt from [http://backbonejs.org](http://backbonejs.org) precisely
    specifies the problem that Backbone.js solves. Backbone.js provides a way to simplify
    the JavaScript application structure, which was clearly a nightmare, even a few
    years ago. Today, we have moved a long way from tightly coupled jQuery-based applications
    to heavy frontend applications, and a major portion of the application logic now
    relies on the UI part. This means organizing the application structure is now
    one of the most significant aspects of application development, and should take
    care of the reusability, modularity, and testability of the components of an application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[http://backbonejs.org](http://backbonejs.org)的上一段摘录精确地指定了Backbone.js解决的问题。Backbone.js提供了一种简化JavaScript应用程序结构的方法，这在几年前甚至是一个噩梦。今天，我们已经从紧密耦合的基于jQuery的应用程序发展到重型前端应用程序，现在应用程序逻辑的大部分现在依赖于UI部分。这意味着组织应用程序结构现在是应用程序开发中最重要的一面，应该注意应用程序组件的可重用性、模块化和可测试性。
- en: Being an extremely lightweight library, Backbone.js, along with the utility
    library Underscore.js, provides a set of tools that help to organize your code
    and makes it easier to develop single-page web applications. Backbone delivers
    a minimalistic solution to separate the concerns of your application; features
    include RESTful operations, persistent strategies, models, views with logic, event-driven
    component communication, templating, and routing facilities. Its simplistic nature,
    excellent documentation, and a large community of developers make it easy to learn
    how to use this library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常轻量级的库，Backbone.js，连同实用库Underscore.js，提供了一套工具，帮助您组织代码，并使开发单页Web应用变得更加容易。Backbone提供了一种简约的解决方案来分离应用程序的关注点；功能包括RESTful操作、持久策略、模型、带逻辑的视图、事件驱动的组件通信、模板和路由功能。其简洁的本质、优秀的文档以及庞大的开发者社区使得学习如何使用这个库变得容易。
- en: However, to develop a robust system, we do not depend only on the basic functional
    components of the framework; we have to use many other libraries, plugins, and
    reusable add-ons to support the core system as well. While Backbone.js with its
    core components provides a way to structure your application at the base level,
    it is really not enough until we either develop our own or use other open source
    extensions, plugins, and useful patterns. In order to create solid, software architecture,
    we need to make the best use of existing components and follow proper design patterns.
    This is what we intend to deliver in this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了开发一个健壮的系统，我们不仅仅依赖于框架的基本功能组件；我们必须使用许多其他库、插件和可重用的附加组件来支持核心系统。虽然Backbone.js及其核心组件提供了一种在基础级别结构化应用程序的方法，但直到我们开发自己的或使用其他开源扩展、插件和有用的模式，这还远远不够。为了创建坚实的软件架构，我们需要充分利用现有组件并遵循适当的设计模式。这正是我们在这本书中想要提供的。
- en: This is not a general introduction book, and we expect our readers to have a
    basic understanding of the Backbone.js framework. If you are a beginner and looking
    for good resources to start with Backbone.js, we will recommend you to refer [Appendix
    A](apa.html "Appendix A. Books, Tutorials, and References"), *Books, Tutorials,
    and References*, of this book, where we listed a number of useful resources to
    help you master Backbone.js.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本通用介绍书，我们期望我们的读者对Backbone.js框架有一个基本的了解。如果你是初学者，正在寻找开始Backbone.js的好资源，我们建议你参考这本书的附录A，即*书籍、教程和参考资料*，其中我们列出了一些有用的资源，以帮助你掌握Backbone.js。
- en: 'We will start with an understanding of how we can re-use our code and reduce
    a boilerplate by developing custom extensions, plugins, and mixins. In the latter
    chapters, we will start discussing the common problems, tips, patterns, best practices,
    and open source plugins for each Backbone.js component. We will also see how we
    can use Backbone.js to structure and architect complex web applications, and understand
    the basics of unit testing in JavaScript-based applications. In addition, instead
    of developing a single application spanning all the chapters, we have tried to
    provide simple and complete examples on each topic separately throughout this
    book. In this chapter, we will learn a few important topics with examples. These
    topics and concepts will be used many times in rest of the chapters. They are
    as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解如何通过开发自定义扩展、插件和混入来重用我们的代码并减少样板代码。在后面的章节中，我们将开始讨论每个Backbone.js组件的常见问题、技巧、模式、最佳实践和开源插件。我们还将了解如何使用Backbone.js来构建和设计复杂的Web应用程序，并理解基于JavaScript应用程序的基本单元测试。此外，我们不是开发跨越所有章节的单个应用程序，而是试图在本书的每个主题上提供简单而完整的示例。在本章中，我们将通过示例学习一些重要主题。这些主题和概念将在后续章节中多次使用。它们如下：
- en: '**Basic components of Backbone.js**: This consists of a brief discussion about
    the definitions of the Backbone components'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Backbone.js的基本组件**: 这包括对Backbone组件定义的简要讨论'
- en: '**Use of Underscore.js**: This consists of a brief discussion about Underscore.js
    and the utility of using this library for JavaScript-based projects'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Underscore.js的使用**: 这包括对Underscore.js的简要讨论以及使用此库进行基于JavaScript的项目的好处'
- en: '**Re-use code with extensions**: This consists of reusing the Backbone code
    by moving common code blocks to parent-level classes'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用扩展重用代码**: 这包括通过将常用代码块移动到父级类中来重用Backbone代码'
- en: '**Backbone mixins**: This consists of an explanation of what mixin is, and
    how and where to use mixins with Backbone'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Backbone混入**: 这包括对混入的解释以及如何以及在哪里与Backbone一起使用混入'
- en: Basic components of Backbone.js
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone.js的基本组件
- en: 'We will look into some basic concepts of Backbone.js and Underscore.js before
    moving to the plugin development section. Backbone.js is a client-side MV* framework
    that provides a set of tools and building blocks required to structure a JavaScript
    application. Important tools that Backbone.js offers are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入插件开发部分之前，我们将探讨Backbone.js和Underscore.js的一些基本概念。Backbone.js是一个客户端MV*框架，提供了一套构建JavaScript应用程序所需工具和构建块。Backbone.js提供的重要工具有以下几项：
- en: '`Backbone.Model`: Models are the entity of an application that store data and
    contain some logic around data such as validation, conversion, and data interaction.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.Model`: 模型是应用程序的实体，存储数据并包含一些与数据相关的逻辑，如验证、转换和数据交互。'
- en: '`Backbone.View`: Views present an idea of organizing your **Document Object
    Model** (**DOM**) interface into logical blocks, and represent the model and collection
    data in them. Views are excellent tools to organize all the JavaScript event handlers
    and to add dynamic HTML content in your application via optional use of JavaScript
    templates. As Backbone follows an MV* pattern, Backbone views mostly work as presenters
    and take care of the major portion of application functionality.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.View`: 视图将组织您的**文档对象模型**（**DOM**）界面到逻辑块中的概念呈现出来，并在其中表示模型和集合数据。视图是组织所有JavaScript事件处理程序和通过可选使用JavaScript模板在应用程序中添加动态HTML内容的优秀工具。由于Backbone遵循MV*模式，Backbone视图主要作为演示者工作，并负责应用程序功能的大部分。'
- en: '`Backbone.Collection`: A collection is a group of models. A collection includes
    a lot of functionality as well as Underscore utility methods to help you work
    on multiple data models.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.Collection`: 集合是一组模型。集合包含许多功能以及Underscore实用方法，以帮助您处理多个数据模型。'
- en: '`Backbone.Router`: A router provides methods for routing client-side pages
    and acts subsequently whenever there is a change in the browser''s URL. A router
    maintains the application state as per the URL change.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.Router`: 路由器提供客户端页面路由的方法，并在浏览器URL发生变化时相应地执行。路由器根据URL变化维护应用程序状态。'
- en: '`Backbone.Events`: Events are an important concept in Backbone, since they
    provide a mechanism to use the PubSub pattern and decouple your application components.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.Events`: 事件是Backbone中的一个重要概念，因为它们提供了一种使用发布/订阅模式并解耦应用程序组件的机制。'
- en: Apart from these, there are other tools such as `Backbone.History`, which manages
    the browser history and the back/forward buttons in accordance with the routers.
    Also, we have `Backbone.Sync`, which is a single method that provides a nice abstraction
    to the network access through Backbone models and collections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有一些其他工具，例如`Backbone.History`，它根据路由器管理浏览器历史记录和后退/前进按钮。还有`Backbone.Sync`，这是一个提供对Backbone模型和集合通过网络访问的优雅抽象的单个方法。
- en: Using Underscore.js
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Underscore.js
- en: 'Underscore.js ([http://underscorejs.org/](http://underscorejs.org/)) is a powerful
    utility library that provides a lot of functional programming support for your
    JavaScript code. In general, JavaScript comes up with a very low number of utility
    methods on its own, and most of the time we need to either develop our own functions
    or depend on another library for these methods. Underscore comes up with a bagful
    of highly efficient utility methods, which makes it an excellent tool for your
    JavaScript projects. The functions it provides can be grouped into the following
    sections:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Underscore.js ([http://underscorejs.org/](http://underscorejs.org/))是一个强大的实用库，为你的JavaScript代码提供了大量的函数式编程支持。一般来说，JavaScript本身提供的实用方法非常有限，大多数时候我们需要自己开发函数或者依赖其他库来获得这些方法。Underscore提供了一系列高效的实用方法，使其成为JavaScript项目的优秀工具。它提供的函数可以分为以下几类：
- en: Collections (Array or Object)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合（数组或对象）
- en: Arrays
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Functions
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Objects
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Utility
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具
- en: Chaining
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接操作
- en: 'These include functions for iterations, sorting, filtering, conversions, templating,
    comparisons, scope binding, and many more. The main benefits of using this small
    library are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括迭代、排序、过滤、转换、模板、比较、作用域绑定等功能。使用这个小型库的主要好处如下：
- en: It helps you to make the JavaScript code more intuitive and concise.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助你使JavaScript代码更加直观和简洁。
- en: In addition to the convenient methods, Underscore also implements cross-browser
    versions of newer JavaScript functions, which are only available in modern browsers.
    Underscore will detect whether the browser supports the method, and will use the
    native implementation if it is present. This boosts the function's performance
    to a great extent.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了方便的方法外，Underscore还实现了更现代浏览器中可用的JavaScript函数的跨浏览器版本。Underscore会检测浏览器是否支持该方法，如果存在，则使用原生实现。这在很大程度上提高了函数的性能。
- en: The minified and gzipped version of the library weighs only 4.9 KB, which leaves
    little excuse for not taking advantages of this library.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库的压缩和gzip版本仅重4.9 KB，这几乎没有任何理由不利用这个库。
- en: The library is completely DOM-free—so you can use it for your server-side JavaScript
    code as well.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库完全无DOM——因此你也可以在服务器端JavaScript代码中使用它。
- en: Excellent documentation similar to Backbone.js with examples is available at
    [http://underscorejs.org/](http://underscorejs.org/).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Backbone.js类似的优秀文档，包含示例，可在[http://underscorejs.org/](http://underscorejs.org/)找到。
- en: Backbone.js has a hard dependency on Underscore.js, and you are bound to use
    it if you are developing your applications with Backbone.js. However, even when
    you are not using Backbone, we encourage you to use Underscore.js for your JavaScript
    projects. It adds no overhead, integrates easily, and makes your code more robust
    even when you are not aware of all the underlying engineering principles employed
    by this library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js对Underscore.js有硬依赖，如果你使用Backbone.js开发应用程序，你必然会用到它。然而，即使你不使用Backbone，我们也鼓励你在JavaScript项目中使用Underscore.js。它不会增加任何开销，易于集成，即使你并不了解这个库所使用的所有底层工程原理，它也能让你的代码更加健壮。
- en: There is another library named `Lo-dash` ([http://lodash.com](http://lodash.com)),
    which provides an Underscore built to perform drop-in replacement of the Underscore.js
    library. It is said to have a slightly better performance than Underscore.js.
    You can try either of them to achieve the same result.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为`Lo-dash` ([http://lodash.com](http://lodash.com))的库，它提供了一个Underscore库，用于替换Underscore.js库。据说它的性能略优于Underscore.js。你可以尝试使用它们中的任何一个来实现相同的结果。
- en: Re-using code with extensions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用扩展重用代码
- en: Backbone is quite a small library in comparison with other libraries. Any complex
    application can be structured and developed with Backbone, but the framework itself
    doesn't come with prebuilt widgets or reusable UI components. In this section,
    we will talk about some Backbone and JavaScript techniques that will help you
    build a reusable interface library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他库相比，Backbone 是一个非常小的库。任何复杂的应用程序都可以使用 Backbone 来构建和开发，但该框架本身并不包含预构建的小部件或可重用的
    UI 组件。在本节中，我们将讨论一些 Backbone 和 JavaScript 技巧，这些技巧将帮助您构建一个可重用的界面库。
- en: 'For simple and small applications, code reusability doesn''t always seem much
    of a necessity. But as you proceed to create an application with multiple views,
    models, and collections, you find that a certain portion of your code gets repeated
    several times. Creating reusable extensions and plugins in such cases improves
    the performance of the application by enhancing modularity and reducing the code
    size. Let''s create a simple Backbone view to understand how we can create an
    extension, shown in the following code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单和小的应用程序，代码的可重用性并不总是那么必要。但随着您继续创建具有多个视图、模型和集合的应用程序，您会发现代码的某个部分被重复多次。在这种情况下创建可重用的扩展和插件可以通过增强模块化和减少代码大小来提高应用程序的性能。让我们创建一个简单的
    Backbone 视图来了解我们如何创建扩展，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The view named `UserItemView` is a simple Backbone view where we want to display
    our model data inside a template and append this view element to the DOM. This
    is a fundamental functionality of Backbone where the primary requirement is to
    display a model's data as a view. If we have another similar view with a model,
    and this has the same functionality, the `render()` function will also be identical.
    That said, won't it be beneficial if we move the common code to a base class and
    extend that class to inherit the functionality? The answer is yes. Let's see how
    we can do that in the example in the following section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `UserItemView` 的视图是一个简单的 Backbone 视图，我们想在模板中显示我们的模型数据，并将此视图元素附加到 DOM 中。这是
    Backbone 的基本功能，其主要要求是以视图的形式显示模型的数据。如果我们有另一个具有相同模型的类似视图，并且它具有相同的功能，那么 `render()`
    函数也将是相同的。那么，如果我们把通用代码移动到基类并将该类扩展以继承功能，这不是很有益吗？答案是肯定的。让我们看看以下示例部分中我们如何做到这一点。
- en: Creating a base class
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基类
- en: 'We create a `BaseView` class where common functionality such as the `render()`
    method is added. Then all other view classes can extend from this base class,
    and eventually inherit the rendering functionality. The following is the `BaseView`
    class with minimal rendering functionality:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `BaseView` 类，其中添加了如 `render()` 方法等常见功能。然后所有其他视图类都可以从这个基类扩展，并最终继承渲染功能。以下是一个具有最小渲染功能的
    `BaseView` 类：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, `UserItemView` will look much better. We will extend the `BaseView` class
    and will provide only the template as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`UserItemView` 将会看起来更好。我们将扩展 `BaseView` 类，并只提供以下模板：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 购买的所有 Packt 书籍的账户中下载示例代码文件。如果您在其他地方购买了这本书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给您。
- en: 'If you wish to add some extra functionality such as calling another function
    in your view''s `render()` method, you can override the render method of the base
    class. Check the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在视图的 `render()` 方法中添加一些额外的功能，例如调用另一个函数，您可以覆盖基类的 `render` 方法。请查看以下示例：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are a number of functionalities that you can move to your base class depending
    on your requirements. For example, in a non-trivial application, we often need
    to replace a view with another, destroy the old view by removing it from DOM,
    and clean up other dependencies. So, we can add a `close()` method to `BaseView`
    (as shown in the following code) that can take care of every view removal mechanism.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求，您可以将许多功能移动到您的基类中。例如，在一个非平凡的应用程序中，我们经常需要用另一个视图替换一个视图，通过从 DOM 中移除旧视图来销毁它，并清理其他依赖项。因此，我们可以在
    `BaseView` 中添加一个 `close()` 方法（如下面的代码所示），它可以处理每个视图移除机制。
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Developing plugins without extending base classes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不扩展基类开发插件
- en: 'Sometimes we find that creating a constructor function and adding methods to
    its prototype can be a better choice than extending the Backbone base classes.
    For example, in the `Pagination` plugin in the following code, instead of creating
    a `PaginationCollection` class by extending `Backbone.Collection`, we will prefer
    to go for a simpler class—a constructor function that accepts two arguments: a
    collection and the number of the items to be shown in a page.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们发现，创建一个构造函数并向其原型添加方法，可能比扩展 Backbone 基础类更好。例如，在以下代码的`Pagination`插件中，我们不会通过扩展`Backbone.Collection`来创建`PaginationCollection`类，我们更倾向于选择一个更简单的类——一个接受两个参数的构造函数：一个集合和每页要显示的项目数量。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We didn't add the actual functionality, but just showed a skeleton of how the
    `Pagination` class may look. The benefit can be observed when you already have
    a collection and you want to implement pagination without extending a parent collection
    class. We added the member variables in constructor function so that individual
    instances of this class can have their own set of variables. On the other hand,
    the methods are added to the prototype of the class so that they are shared by
    all instances of the class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有添加实际的功能，只是展示了`Pagination`类可能的样子。当你已经有一个集合并且想要实现分页而不扩展父集合类时，你可以观察到这种好处。我们在构造函数中添加了成员变量，这样这个类的单个实例就可以有自己的变量集。另一方面，方法被添加到类的原型中，这样它们就可以被类的所有实例共享。
- en: This mechanism can be useful when you need a custom plugin that is not a type
    of Backbone view, model, or collection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个不是 Backbone 视图、模型或集合类型的自定义插件时，这种机制可能很有用。
- en: Understanding JavaScript mixins
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 JavaScript 混入
- en: In the previous section, we saw that inheriting properties from a parent class
    prototype provides a great deal of reusability. In some cases, we may want to
    re-use similar methods in multiple views, models, or collections. This can be
    achieved by creating a parent class that they can extend; however, it is not always
    a good practice as it creates some unnecessary layers and meaningless subtypes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了从父类原型继承属性提供了大量的可重用性。在某些情况下，我们可能希望在多个视图、模型或集合中重用类似的方法。这可以通过创建一个它们可以扩展的父类来实现；然而，这并不总是一个好的做法，因为它创建了一些不必要的层和无意义的子类型。
- en: 'For example, assume that you want the view element of `UserItemView`, which
    already extends `BaseView`, to be draggable. So you include a `DraggableView`
    class that extends the `BaseView` class, and your `UserItemView` extends `DraggableView`.
    Now there is a sudden change in the requirement and you are asked to make the
    view named `UserItemView` a sortable view as well. Will you introduce another
    new class, `SortableView`, and put it somewhere in the chain? If yes, then this
    multitiered inheritance will surely create a logic that is absolutely unmanageable
    and frustrating. Look at the following figure that describes the situation in
    a better way:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要将`UserItemView`视图元素（它已经扩展了`BaseView`）设置为可拖动的。因此，你包含一个扩展`BaseView`类的`DraggableView`类，并且你的`UserItemView`扩展了`DraggableView`。现在突然出现了需求变更，你被要求将名为`UserItemView`的视图也设置为可排序视图。你会引入另一个新的类`SortableView`并将其放在某个链中吗？如果是的话，那么这种多层继承肯定会创建一个绝对难以管理和令人沮丧的逻辑。看看以下图表，它以更好的方式描述了这种情况：
- en: '![Understanding JavaScript mixins](img/3576_01_01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![理解 JavaScript 混入](img/3576_01_01.jpg)'
- en: What is a mixin?
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是混入？
- en: 'Fortunately, there is a feasible alternative in JavaScript, which is called
    **m** **ixin**. In general computer science, a mixin is a class that provides
    a set of functions relating to a particular type. These mixin classes are not
    instantiated, but their functions are just copied to the main class to achieve
    a similar inheriting behavior without entering into the inheritance chain. Look
    at the following figure to understand the concept:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript 中有一个可行的替代方案，称为 **混入**。在一般计算机科学中，混入是一个提供与特定类型相关的一组函数的类。这些混入类不会被实例化，但它们的函数只是被复制到主类中，以在不进入继承链的情况下实现类似继承的行为。看看以下图表来理解这个概念：
- en: '![What is a mixin?](img/3576_01_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![什么是混入？](img/3576_01_02.jpg)'
- en: We have a `ListItemView` class that extends the `BaseView` class and represents
    an individual item of a list. Now we want these items to be draggable. How we
    can achieve this? How about adding a few methods in the `ListItemView` class that
    will take care of the dragging functionality? This approach will work, but what
    if we have few more components that need to be draggable too? Then we have to
    make a reusable object with these methods and use that object in all the required
    classes. This is what the mixin concept is—a collection of methods that will be
    copied to the class that wants this functionality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `ListItemView` 类，它扩展了 `BaseView` 类，并代表列表的一个单独的项目。现在我们想让这些项目可拖动。我们如何实现这一点？在
    `ListItemView` 类中添加一些处理拖动功能的方法怎么样？这种方法是可行的，但如果还有更多组件也需要可拖动，那么我们必须创建一个具有这些方法的可重用对象，并在所有所需的类中使用该对象。这就是混入概念——一组将被复制到需要此功能的类中的方法。
- en: Creating classic mixins
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建经典混入
- en: 'The most basic mixin definition will be a simple object with some properties
    such as the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的混入定义将是一个具有一些属性（如下面的代码片段所示）的简单对象：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will use the Underscore method, `_.extend()`, to copy the mixin properties
    to the main class''s prototype:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Underscore 方法，`_.extend()`，将混入属性复制到主类的原型：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the drag-related methods are now copied from `DraggableMixin` to its
    prototype. Similarly, we can use the same `_.extend()` method to copy the methods
    of `SortableMixin` to implement the sortable behavior without creating any multilayered
    inheritance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与阻力相关的现在方法已从 `DraggableMixin` 复制到其原型。同样，我们可以使用相同的 `_.extend()` 方法将 `SortableMixin`
    的方法复制到实现可排序行为，而不需要创建任何多层继承。
- en: 'Sometimes you may not want to copy all the methods of a mixin in your class.
    In that case, simply create a property in your class and copy the required function
    from the mixin in that property:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能不想在类中复制混入的所有方法。在这种情况下，只需在类中创建一个属性，并将从混入中复制所需函数到该属性中：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is helpful when you need only a part of the functionality from the mixin.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只需要混入的部分功能时，这很有帮助。
- en: Creating functional mixins
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建功能混入
- en: 'There are some other ways of defining a mixin too. The following is an example
    of a functional pattern:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 定义混入还有其他一些方法。以下是一个功能模式的示例：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The mixin here works as a verb, and this functional approach is well accepted
    in the community. The `this` function always refers to the receiver, that is,
    `UserItemView`. The functionality is exactly same but with a major difference—the
    `_.extend()` method is no longer needed and the mixin methods are not copied this
    time but are cloned instead. This is not a major problem—just the functions are
    redefined every time the mixin is used. However, this can also be minimized by
    caching the functions within the mixin. Let's see how we can achieve that in the
    next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的混入作为一个动词使用，这种功能方法在社区中得到了很好的接受。`this` 函数始终指向接收器，即 `UserItemView`。功能完全相同，但有一个主要区别——这次不再需要
    `_.extend()` 方法，混入方法也不是复制，而是克隆。这并不是一个大问题——只是每次使用混入时都会重新定义函数。然而，这也可以通过在混入中缓存函数来最小化。让我们看看我们如何在下一节中实现这一点。
- en: Caching mixin functions
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存混入函数
- en: 'We can cache the initial function definitions by wrapping up the mixin in a
    closure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将混入包裹在闭包中来缓存初始函数定义：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The closure executes only once to define the methods even if the mixin is called
    several times. However, it raises another concern—inside the mixin methods, how
    are we going to use the `config` object that we are passing? This issue can be
    resolved by using an interesting pattern named `curry`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管混入被多次调用，闭包只执行一次来定义方法。然而，这又提出了另一个问题——在混入方法内部，我们如何使用我们传递的 `config` 对象？这个问题可以通过使用一个名为
    `curry` 的有趣模式来解决。
- en: Using curry to combine a function and arguments
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用柯里化组合函数和参数
- en: 'As described by *Douglas Crockford* in his book *Javascript: The Good Parts*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '如 *Douglas Crockford* 在其书籍 *JavaScript: The Good Parts* 中所述：'
- en: '"Currying allows us to produce a new function by combining a function and an
    argument."'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"柯里化允许我们通过组合一个函数和一个参数来生成一个新的函数。"'
- en: 'Assume that you have a function and a set of arguments. You want these arguments
    to be combined with the function someway, so that when you will call that function
    without passing anything, the arguments will still be available to the function.
    See the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个函数和一组参数。你希望以某种方式将这些参数与函数结合，以便当你调用该函数而不传递任何内容时，这些参数仍然可用于该函数。请看以下示例：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `curry()` pattern''s definition is quite simple where this method is added
    to the function prototype, so when it is called on any function, it merges the
    arguments passed to itself with the arguments of the main function, as shown in
    the following code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`curry()` 模式的定义相当简单，即该方法被添加到函数原型中，因此当它被调用在任何函数上时，它会将传递给自身的参数与主函数的参数合并，如下面的代码片段所示：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s see how we can apply `curry` to our `DraggableMixin` function, so
    that the `config` object is available to all its methods, as shown in the following
    code snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看如何将 `curry` 应用到我们的 `DraggableMixin` 函数中，以便 `config` 对象对所有方法都可用，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, when we call `curry` on the `startDrag()` method, we pass the `config` object
    that we received while applying mixin, and it becomes available to `startDrag`
    as an argument. You can use either the classic or functional approaches for defining
    a mixin, though I personally prefer the latter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们对 `startDrag()` 方法调用 `curry` 时，我们传递了在应用混入时接收到的 `config` 对象，它作为参数对 `startDrag`
    可用。你可以使用经典或函数式方法来定义混入，尽管我个人更喜欢后者。
- en: Mixin is an important concept that many popular JavaScript libraries such as
    Sencha and Dojo follow. While the concept is quite easy, finding a proper context
    in an application to use a mixin is bit difficult. However, once you are aware
    of its use, you may soon find it beneficial to enforce reusability in your application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是一个重要的概念，许多流行的 JavaScript 库如 Sencha 和 Dojo 都遵循这个概念。虽然这个概念相当简单，但在应用程序中找到一个合适的上下文来使用混入有点困难。然而，一旦你意识到它的用途，你很快就会发现在你的应用程序中强制重用性是有益的。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you ever checked the annotated source code ([http://backbonejs.org/docs/backbone.html](http://backbonejs.org/docs/backbone.html))
    of Backbone, you might have found that the library footprint is very small (the
    production file is only 6.4 KB at v1.1.0). Its sole purpose is to improve the
    structure and maintainability of your code with the least complexity. So, once
    you start using Backbone, you will find that in every step of the development,
    you need to write custom widgets and plugins. In this chapter, we learned the
    basics of Backbone.js and the utility of using Underscore.js with Backbone.js.
    We also saw how developing reusable components and custom pugins can reduce boilerplate
    from our code. In the end, we understood the concept of JavaScript plugins and
    discussed different approaches for defining mixins. We are going to use all these
    concepts several times in the following chapters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经检查过 Backbone 的注释源代码（[http://backbonejs.org/docs/backbone.html](http://backbonejs.org/docs/backbone.html)），你可能会发现库的体积非常小（v1.1.0
    版本的生产文件只有 6.4 KB）。它的唯一目的是以最少的复杂性提高你代码的结构和可维护性。因此，一旦你开始使用 Backbone，你就会发现，在开发的每一步，你都需要编写自定义小部件和插件。在本章中，我们学习了
    Backbone.js 的基础知识以及与 Backbone.js 一起使用 Underscore.js 的实用性。我们还看到了如何开发可重用组件和自定义插件可以减少代码中的样板。最后，我们了解了
    JavaScript 插件的概念，并讨论了定义混入的不同方法。在接下来的章节中，我们将多次使用这些概念。
- en: In the next chapter, we will discuss different problems associated with Backbone
    views and possible solutions to them. We will also see how custom-view plugins
    or mixins can solve most of the problems.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论与 Backbone 视图相关的问题以及可能的解决方案。我们还将看到自定义视图插件或混入如何解决大多数问题。
