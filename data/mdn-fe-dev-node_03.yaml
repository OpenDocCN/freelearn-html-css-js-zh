- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Choosing a Package Manager
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择包管理器
- en: So far, we have learned a bit about Node.js and its internal modules. We also
    started to write our own modules, but we have either avoided or worked around
    using third-party packages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对 Node.js 和其内部模块有了一些了解。我们还开始编写自己的模块，但要么避免使用第三方包，要么绕过使用第三方包。
- en: One of the big advantages of Node.js is that using other people’s code is actually
    quite easy. The path to doing so leads us directly to package managers. A package
    manager helps us to handle the life cycle of packages containing modules that
    can be used in Node.js.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的一大优点是使用他人的代码实际上相当容易。这样做的方法直接引我们到包管理器。包管理器帮助我们处理包含可用于 Node.js 的模块的包的生命周期。
- en: In this chapter, we’ll learn how Node.js’s de facto standard package manager
    **npm** works. We will then go on to learn about other package managers, such
    as **Yarn** and **pnpm**. They all promise some advantages in terms of usability,
    performance, or reliability. We will take a deeper look at them to understand
    these advantages and who might benefit from using each of the different package
    managers. Finally, we’ll also look at alternatives.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Node.js 的实际标准包管理器 **npm** 的工作原理。然后我们将继续学习其他包管理器，例如 **Yarn** 和 **pnpm**。它们在可用性、性能或可靠性方面都承诺提供一些优势。我们将更深入地研究它们，以了解这些优势以及谁可能从使用每个不同的包管理器中受益。最后，我们还将探讨替代方案。
- en: This chapter will help you to use third-party libraries in your code. Third-party
    dependencies will make you more productive and focused, and a package manager
    will be useful for installing and updating third-party dependencies. By the end
    of the chapter, you’ll know the most important package managers and which one
    you want to pick in the context of your project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您在代码中使用第三方库。第三方依赖将使您更高效、更专注，而包管理器将有助于安装和更新第三方依赖。到本章结束时，您将了解最重要的包管理器，以及您在项目背景下想选择哪一个。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下关键主题：
- en: Using npm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 npm
- en: Using Yarn
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Yarn
- en: Using pnpm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pnpm
- en: More alternatives
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多替代方案
- en: Technical Requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Some code examples for this chapter are available at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter03](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter03).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些代码示例可在 [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter03](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter03)
    找到。
- en: The CiA videos for this chapter can be accessed at [http://bit.ly/3TmZr22](http://bit.ly/3TmZr22).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可通过 [http://bit.ly/3TmZr22](http://bit.ly/3TmZr22) 访问。
- en: Using npm
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm
- en: When you install Node.js from the official sources, you get a bit more than
    just Node.js. For convenience, Node.js will also add a few more programs and settings
    to your system. One of the most important additions is a tool called npm. Originally,
    npm was intended to stand for *Node.js Package Manager*, but today, it is essentially
    its own standalone name.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从官方来源安装 Node.js 时，您将获得比 Node.js 更多的东西。为了方便起见，Node.js 还会将一些额外的程序和设置添加到您的系统中。其中最重要的添加之一是一个名为
    npm 的工具。最初，npm 的缩写是 *Node.js Package Manager*，但如今，它基本上是一个独立的名称。
- en: The goal of npm is to allow developers to manage third-party dependencies. This
    includes installing and updating packages, as well as handling their versioning
    and transitive dependencies. A transitive dependency is established when dependencies
    that are installed also include dependencies, which therefore need to be installed,
    too.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: npm 的目标是让开发者能够管理第三方依赖。这包括安装和更新包，以及处理它们的版本和传递依赖。当安装的依赖项也包括依赖项时，就会建立传递依赖，因此也需要安装这些依赖项。
- en: For `npm` to know what dependencies exist and what their dependencies are, the
    npm registry was created. It is a web service that hosts all packages on a file
    server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `npm` 了解存在哪些依赖以及它们的依赖关系，创建了 npm 注册表。它是一个托管在文件服务器上的所有包的 Web 服务。
- en: Changing the used npm registry
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更改使用的 npm 注册表
- en: Today, many npm registries exist – but only the official one located at [https://registry.npmjs.org/](https://registry.npmjs.org/)
    is used by default. To change the registry consistently, a special file, `.npmrc`,
    needs to be created. If the file is created in the home directory, then the change
    applies to all usages. Otherwise, this file could also be created next to a `package.json`
    – only being applied to the designated project. Finally, to only temporarily use
    another registry, the `--registry` command-line flag can be used. The format of
    the `.npmrc` file is outlined at [https://docs.npmjs.com/cli/v8/configuring-npm/npmrc](https://docs.npmjs.com/cli/v8/configuring-npm/npmrc).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，存在许多npm注册表——但默认情况下，只有位于[https://registry.npmjs.org/](https://registry.npmjs.org/)的官方注册表被使用。要一致地更改注册表，需要创建一个特殊的文件，`.npmrc`。如果该文件创建在主目录中，那么更改将适用于所有使用情况。否则，此文件也可以创建在`package.json`旁边——仅适用于指定的项目。最后，要仅临时使用另一个注册表，可以使用`--registry`命令行标志。`.npmrc`文件的格式在[https://docs.npmjs.com/cli/v8/configuring-npm/npmrc](https://docs.npmjs.com/cli/v8/configuring-npm/npmrc)中概述。
- en: 'To use packages from the npm registry, we’ll need to use the `npm` command-line
    utility. In fact, the first thing we should do when we copy or clone the source
    code of a Node.js project is to run `npm install` in the directory of the project’s
    `package.json`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用npm注册表中的包，我们需要使用`npm`命令行工具。实际上，当我们复制或克隆Node.js项目的源代码时，我们应该首先在项目`package.json`所在的目录中运行`npm
    install`：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will install all packages that are mentioned as runtime and development
    dependencies in the `package.json`. The packages are downloaded from the configured
    npm registry and then stored in the `node_modules` directory. It is good practice
    to avoid adding the `node_modules` directory to your source control. For instance,
    for Git, you should add `node_modules` to your repository’s `.gitignore` file.
    There are several reasons for this – for example, the installation might be platform-specific
    or the installation may be reproducible anyway.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装`package.json`中提到的所有运行时和开发依赖项的包。这些包将从配置的npm注册表中下载，然后存储在`node_modules`目录中。避免将`node_modules`目录添加到源控制中是一种良好的做法。例如，对于Git，你应该将`node_modules`添加到你的仓库的`.gitignore`文件中。这样做有几个原因——例如，安装可能是平台特定的，或者安装可能无论如何都是可重复的。
- en: 'The `npm` command-line utility comes with a set of integrated commands – such
    as the previously shown `install` command. To see what commands are available
    to you, the utility can be used with the `--``help` flag:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm`命令行工具自带一系列集成命令——例如之前展示的`install`命令。要查看可用的命令，可以使用`--help`标志来使用该工具：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `--help` flag also works in combination with a specific command. If you
    want to know which options exist for the `install` command, you can just type
    the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`--help`标志也可以与特定命令结合使用。如果你想了解`install`命令有哪些选项，只需输入以下内容：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The principle of getting context-specific help is vital to many command-line
    utilities. All of the package managers that we’ll look at in this chapter feature
    this approach. In the end, for us as users, this has some advantages. Instead
    of needing to look up the online documentation, other books, or tutorials to see
    the syntax for a command every time, we can just get all the required information
    directly in the command line which is tailored to the specific version that we
    use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 获取特定上下文帮助的原则对于许多命令行工具至关重要。在本章中我们将要探讨的所有包管理器都具备这种功能。最终，对我们这些用户来说，这带来了一些优势。我们无需每次都查找在线文档、其他书籍或教程来查看命令的语法，我们只需在针对我们使用的特定版本定制的命令行中直接获取所有所需信息。
- en: 'A command that is highly useful is `init`. While `install` is great to use
    for existing projects, `init` can be used to create a new project. When you run
    `npm init`, you’ll be guided through all the options in a kind of survey. The
    result is shown as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的命令是`init`。虽然`install`对于现有项目来说很棒，但`init`可以用来创建一个新的项目。当你运行`npm init`时，你将引导通过一系列选项，就像进行一次调查。结果如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An alternative would be to specify the `-y` flag. This way, all the defaults
    will be taken – a much quicker alternative if you just want to initialize a new
    project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是指定`-y`标志。这样，所有默认值都将被采用——如果你只是想初始化一个新的项目，这是一个更快的选择。
- en: The initializer function of npm can even be extended. If you provide another
    name after `npm init`, then npm will try to look for a package using the `create-`
    prefix. For instance, when you run `npm init react-app`, npm will look for a package
    called `create-react-app` and run it. Running a package refers to looking for
    a `bin` field in the package’s `package.json` file and using the given reference
    to start a new process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: npm的初始化函数甚至可以被扩展。如果你在`npm init`之后提供了另一个名称，那么npm将尝试使用`create-`前缀查找一个包。例如，当你运行`npm
    init react-app`时，npm将查找名为`create-react-app`的包并运行它。运行一个包指的是在包的`package.json`文件中查找`bin`字段，并使用给定的引用启动一个新的进程。
- en: If you want to add dependencies to your project instead, you can use `npm install`,
    too. For instance, adding React as a dependency is `npm` `install react`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要向你的项目中添加依赖项，你也可以使用`npm install`。例如，将React作为依赖项添加是`npm install react`。
- en: 'The dependency life cycle also requires us to know when dependencies are outdated.
    For this purpose, npm offers the `npm` `outdated` command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的生命周期还要求我们了解依赖项何时过时。为此，npm 提供了 `npm outdated` 命令：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The command only shows packages that have a more recent release than the currently
    installed version. In some cases, that is fine – that is, when the current version
    matches the wanted version. In other cases, running `npm update` will actually
    update the installed version.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 命令仅显示比当前安装版本更新的软件包。在某些情况下，这是可以接受的——也就是说，当当前版本与所需版本相匹配时。在其他情况下，运行 `npm update`
    实际上会更新安装的版本。
- en: Using different versions of npm
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同版本的npm
- en: npm is already packaged together with Node.js. Therefore, each release of Node.js
    also selects a version of npm. For instance, Node.js 14 was bundled with npm 6\.
    In Node.js 15, npm 7 was included. With Node.js 16 onward, you’ll get npm 8\.
    One way to stay flexible is to use **nvm** instead. nvm is a small tool that allows
    you to select the version of Node.js to use. It can also be used to change the
    default version and quickly update and install new versions of Node.js and npm.
    More information is available at [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: npm已经与Node.js打包在一起。因此，Node.js的每个版本也会选择一个npm版本。例如，Node.js 14捆绑了npm 6。在Node.js
    15中，包含了npm 7。从Node.js 16开始，你将获得npm 8。保持灵活的一种方法是使用**nvm**。nvm是一个小工具，允许你选择要使用的Node.js版本。它还可以用来更改默认版本，快速更新和安装新的Node.js和npm版本。更多信息请访问[https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)。
- en: npm also provides a lot of useful, convenient features – for example, to improve
    security. The `npm audit` command checks the currently installed packages against
    an online database containing security vulnerabilities. Quite often, a fix in
    vulnerable packages is just one call of `npm audit --fix` flag away. Furthermore,
    using a command such as `npm view` – for example, in `npm view react` – we can
    directly interact with the npm registry containing most of the publicly available
    packages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: npm还提供许多有用的便捷功能——例如，提高安全性。`npm audit`命令将当前安装的软件包与包含安全漏洞的在线数据库进行比对。通常，在易受攻击的软件包中的修复只需一个`npm
    audit --fix`标志的调用即可。此外，使用如`npm view`之类的命令——例如，在`npm view react`中——我们可以直接与包含大多数公开可用软件包的npm注册表进行交互。
- en: While the npm registry is a great source for packages, the `npm` command-line
    utility is not the only way to use it. In fact, the API of the web service is
    public and could be used by anyone – or any program for that matter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然npm注册表是软件包的绝佳来源，但npm命令行工具并非使用它的唯一方式。实际上，该网络服务的API是公开的，任何人——或者任何程序——都可以使用。 '
- en: One of the first companies to use a public API of the npm registry was Facebook.
    They suffered from slow installation times in their large projects and wanted
    to improve on this by providing a better algorithm to actually resolve the dependencies
    of a project – especially transitive dependencies. The result was a new package
    manager named **Yarn**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首批使用npm注册表公开API的公司之一是Facebook。他们在大型项目中遇到了安装时间慢的问题，并希望通过提供一个更好的算法来实际解决项目的依赖项——特别是传递依赖项。结果是出现了一个名为**Yarn**的新包管理器。
- en: Using Yarn
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Yarn
- en: 'The issue with the original npm package resolution algorithm was that it was
    created in a resilient but naïve way. This does not mean that the algorithm was
    simple. Rather, here, we refer to the fact that no exotic tricks or experience
    optimizations have been considered. Instead of trying to optimize (that is, lower)
    the number of packages available on the local disk, it was designed to put the
    packages into the same hierarchy as they were declared in. This results in a filesystem
    view as shown in *Figure 3**.1*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 npm 包解析算法的问题在于它是以一种弹性但天真的方式创建的。这并不意味着算法很简单。相反，这里我们指的是没有考虑过任何异国情调的技巧或经验优化。它不是试图优化（即降低）本地磁盘上可用的包的数量，而是设计成将包放入与它们声明时相同的层次结构中。这导致了一个如
    *图 3**.1* 所示的文件系统视图：
- en: '![Figure 3.1 – Example filesystem snapshot after installing packages using
    npm ](img/Figure_3.1_B18989.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 使用 npm 安装包后的示例文件系统快照](img/Figure_3.1_B18989.jpg)'
- en: Figure 3.1 – Example filesystem snapshot after installing packages using npm
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 使用 npm 安装包后的示例文件系统快照
- en: The naïve way of handling package installations is certainly a great way to
    ensure that everything is installed correctly, but not ideal in terms of performance.
    Looking at *Figure 3**.1*, there may be some optimizations possible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 处理包安装的简单方式当然是一种确保一切安装正确无误的绝佳方法，但在性能方面并不理想。查看 *图 3**.1*，可能有一些优化空间。
- en: 'Let’s add some example package names and versions to *Figure 3**.1* to see
    the opportunities for optimization. In *Figure 3**.2*, the same snapshot is shown
    – just with example package names:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 *图 3**.1* 中添加一些示例包名和版本，以查看优化的机会。在 *图 3**.2* 中，显示了相同的快照——只是带有示例包名：
- en: '![Figure 3.2 – Filesystem snapshot with example package names after npm installation
    ](img/Figure_3.2_B18989.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 使用 npm 安装后带有示例包名的文件系统快照](img/Figure_3.2_B18989.jpg)'
- en: Figure 3.2 – Filesystem snapshot with example package names after npm installation
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 使用 npm 安装后带有示例包名的文件系统快照
- en: Instead of duplicating the `bar` dependency, it could be just used once. The
    `foo` dependency, on the other hand, has to be duplicated due to conflicting versions.
    Other transitive dependencies, such as `abc` or `def`, can be brought to the top
    level.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于重复使用 `bar` 依赖，它只需使用一次。另一方面，由于版本冲突，`foo` 依赖必须重复。其他传递依赖，如 `abc` 或 `def`，可以被提升到顶级。
- en: 'The resulting image is shown in *Figure 3**.3*. This flattens the structure
    where possible. This optimization was key to the first version of Yarn. Actually,
    it was so successful that npm improved its algorithm, too. Today, npm resolves
    the packages in a similar way to the sketch shown in *Figure 3**.3*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像显示在 *图 3**.3* 中。尽可能简化了结构。这种优化是 Yarn 第一版的关键。实际上，它非常成功，npm 也改进了其算法。今天，npm
    以类似 *图 3**.3* 中所示草图的方式解决包：
- en: '![Figure 3.3 – Filesystem snapshot with example package names after installation
    using Yarn ](img/Figure_3.3_B18989.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 使用 Yarn 安装后带有示例包名的文件系统快照](img/Figure_3.3_B18989.jpg)'
- en: Figure 3.3 – Filesystem snapshot with example package names after installation
    using Yarn
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 使用 Yarn 安装后带有示例包名的文件系统快照
- en: For the team at Yarn, the optimizations gained were not enough. They started
    to look for different ways to improve even further. However, the more they looked,
    the more they were convinced that something completely new was needed to make
    any further enhancements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Yarn 团队来说，获得的优化并不足够。他们开始寻找不同的方法来进一步提高。然而，他们越寻找，就越确信需要一些全新的东西来做出任何进一步的改进。
- en: The result was introduced with `node_modules` directory. Instead, a special
    file called `.pnp.cjs` is created to give information on how the dependencies
    can be resolved. With the `.pnp.cjs` file, every package can be resolved – just
    as with `node_modules` beforehand.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是通过引入 `node_modules` 目录来实现的。相反，创建了一个名为 `.pnp.cjs` 的特殊文件，以提供有关如何解决依赖项的信息。有了
    `.pnp.cjs` 文件，每个包都可以被解决——就像之前的 `node_modules` 一样。
- en: The specific location of the packages depends on the project’s settings. With
    Yarn 2, a new concept called *zero-installs* has been introduced. This way, each
    dependency will be available within the project – just in a `.yarn/cache` subfolder.
    To actually achieve zero-installs, the `.yarn` folder should be checked into source
    control. Now, when the project is cloned, no installation needs to be performed.
    The dependencies are already part of the repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 包的具体位置取决于项目的设置。在 Yarn 2 中，引入了一个名为 *zero-installs* 的新概念。这样，每个依赖项都将可在项目内部使用——只是在
    `.yarn/cache` 子文件夹中。要真正实现零安装，`.yarn` 文件夹应该被提交到源代码控制。现在，当项目被克隆时，不需要执行安装。依赖项已经是存储库的一部分。
- en: 'While most commands are very similar, Yarn takes a different approach to adding
    new dependencies. Here, dependencies are added using `yarn add` – for example,
    `yarn add react`. The installation of packages using the `yarn` command-line utility
    is quite similar to the previous usage with `npm`, though:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数命令非常相似，但 Yarn 在添加新依赖项方面采取了不同的方法。在这里，依赖项是通过 `yarn add` 添加的——例如，`yarn add
    react`。使用 `yarn` 命令行工具安装包与之前使用 `npm` 的用法相当，尽管如此：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In *Figure 3**.4*, the new PnP mechanism is shown using the previous example.
    By using fully qualified names consisting of the package name and version, unique
    identifiers are created, allowing multiple versions of the same package to be
    located in a flat structure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3.4* 中，使用前一个示例展示了新的 PnP 机制。通过使用由包名和版本组成的完全限定名称，创建了唯一标识符，允许在扁平结构中定位同一包的多个版本。
- en: 'The downside of the PnP mechanism is the custom resolution method, which requires
    some patching in Node.js. The standard resolution mechanism of Node.js uses `node_modules`
    to actually find modules within packages. The custom resolution method teaches
    Node.js to use a different directory with a different structure to find modules:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PnP 机制的一个缺点是自定义的解析方法，这需要在 Node.js 中进行一些修补。Node.js 的标准解析机制使用 `node_modules` 来实际查找包内的模块。自定义解析方法教会
    Node.js 使用不同结构的不同目录来查找模块：
- en: '![Figure 3.4 – Filesystem snapshot with example package names after installation
    using Yarn PnP ](img/Figure_3.4_B18989.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 使用 Yarn PnP 安装后的文件系统快照，包含示例包名](img/Figure_3.4_B18989.jpg)'
- en: Figure 3.4 – Filesystem snapshot with example package names after installation
    using Yarn PnP
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 使用 Yarn PnP 安装后的文件系统快照，包含示例包名
- en: While using a custom resolution method is not a problem for many packages, some
    may depend on the classic structure involving `node_modules` with packages just
    resolving to directories and files. In PnP, however, the structure is flat, with
    each package being a zip archive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于许多包来说，使用自定义解析方法不是问题，但某些包可能依赖于涉及 `node_modules` 的经典结构，其中包仅解析为目录和文件。然而，在 PnP
    中，结构是扁平的，每个包都是一个压缩存档。
- en: As of today, many plugins and patches are available for packages to be compatible
    with PnP. Many – especially less popular – packages are still not usable with
    PnP. Luckily, Yarn 3 fixed many of these issues, providing a compatibility mode
    that works for most of these problematic packages. At the end of the day, it’s,
    unfortunately, mostly a matter of trial and error. Luckily, Yarn PnP is not the
    only solution that exists for speeding up npm even more.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，许多插件和补丁可以使包与 PnP 兼容。许多——尤其是不太受欢迎的——包仍然不能与 PnP 一起使用。幸运的是，Yarn 3 解决了许多这些问题，为大多数有问题的包提供了一个兼容模式。最终，这仍然主要是一个试错的问题。幸运的是，Yarn
    PnP 不是唯一可以加快 npm 速度的解决方案。
- en: Even before Yarn 2 with PnP was released, other developers started thinking
    of alternative strategies to speed up installation times and preserve network
    bandwidth and storage capacity. The best-known attempt is a utility called pnpm.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Yarn 2 的 PnP 发布之前，其他开发者已经开始考虑替代策略来加快安装时间并节省网络带宽和存储容量。最著名的尝试是一个名为 pnpm 的实用工具。
- en: Using pnpm
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pnpm
- en: The approach of pnpm feels a bit like the original package resolution of npm.
    Here, each package is essentially isolated and puts its own dependencies into
    a local `node_modules` subfolder.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: pnpm 的方法有点像 npm 的原始包解析。在这里，每个包基本上是隔离的，并将自己的依赖项放入一个本地的 `node_modules` 子文件夹中。
- en: 'There is, however, one crucial difference: instead of having a hard copy of
    each dependency, the different dependencies are made available through symbolic
    links. The advantage of this approach is that every dependency only needs to be
    resolved once per system.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个关键的区别：不是每个依赖项都有一个硬拷贝，而是通过符号链接提供不同的依赖项。这种方法的优点是每个依赖项只需要在每个系统中解析一次。
- en: The other advantage is that for most packages everything is as it should be.
    There is nothing hiding behind an archive or via some custom mapping defined by
    a module that would run in the beginning. The whole package resolution just works.
    The exception to this rule is packages that use their path to find other packages
    or work against a root directory. Since the physical location of the packages
    is global, and therefore different from the project’s location, these approaches
    do not work with pnpm.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，对于大多数包来说，一切如常。没有任何东西隐藏在存档后面或通过模块定义的某些自定义映射中，这些映射将在开始时运行。整个包解析过程正常工作。这个规则的例外是使用其路径来查找其他包或针对根目录工作的包。由于包的物理位置是全局的，因此与项目的位置不同，这些方法与
    pnpm 不兼容。
- en: 'Installing packages with the `pnpm` command-line utility works very similarly
    to `npm`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pnpm` 命令行工具安装包的工作方式与 `npm` 非常相似：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Overall, most commands of the `pnpm` command-line utility have either the same
    or a very similar name to their `npm` counterpart.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`pnpm` 命令行工具的大多数命令要么与 `npm` 的对应命令同名，要么非常相似。
- en: 'On installation, `pnpm` adds the unavailable packages to a local store. A local
    store is just a special directory from `pnpm` that is not bound to your project,
    but rather your user account. It is pnpm’s package storage that is actually the
    source of its miraculous performance. Afterward, `pnpm` creates all the symbolic
    links to wire everything together. The result looks similar to *Figure 3**.5*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，`pnpm` 将不可用的包添加到本地存储中。本地存储只是 `pnpm` 的一个特殊目录，它并不绑定到你的项目，而是你的用户账户。实际上，pnpm
    的包存储是其神奇性能的来源。之后，`pnpm` 创建所有符号链接来连接一切。结果看起来类似于 *图 3.5*：
- en: '![Figure 3.5 – Filesystem snapshot with example package names after installation
    using pnpm ](img/Figure_3.5_B18989.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 使用 pnpm 安装后的文件系统快照，包含示例包名](img/Figure_3.5_B18989.jpg)'
- en: Figure 3.5 – Filesystem snapshot with example package names after installation
    using pnpm
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 使用 pnpm 安装后的文件系统快照，包含示例包名
- en: Only direct dependencies are listed in the `node_modules` folder. The content
    of each subfolder is not available in the original `node_modules` – rather, in
    the global `.pnpm` cache. The same is then applied to all sub-dependencies.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `node_modules` 文件夹中只列出直接依赖项。每个子文件夹的内容在原始的 `node_modules` 中不可用，而是在全局 `.pnpm`
    缓存中。然后，相同的处理方式应用于所有子依赖项。
- en: 'The result is a massive performance boost. Already, on a clean install, `pnpm`
    is faster than the competition. However, in other scenarios, the relative gap
    may be even larger. In *Figure 3**.6*, the performance of `pnpm` is compared against
    other package managers. Lower bars refer to better performance:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是性能的大幅提升。在干净安装的情况下，`pnpm` 已经比竞争对手快。然而，在其他场景中，相对差距可能更大。在 *图 3.6* 中，`pnpm` 的性能与其他包管理器进行了比较。较低的柱状图表示更好的性能：
- en: '![Figure 3.6 – Performance benchmark comparing pnpm against npm, Yarn, and
    Yarn with PnP (source: https://pnpm.io/benchmarks)](img/Figure_3.6_B18989.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 与 npm、Yarn 和带有 PnP 的 Yarn 的性能基准比较（来源：https://pnpm.io/benchmarks）](img/Figure_3.6_B18989.jpg)'
- en: 'Figure 3.6 – Performance benchmark comparing pnpm against npm, Yarn, and Yarn
    with PnP (source: https://pnpm.io/benchmarks)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 与 npm、Yarn 和带有 PnP 的 Yarn 的性能基准比较（来源：https://pnpm.io/benchmarks）
- en: Only in the case of an up-to-date installation can npm be considered the fastest
    option. In other cases, pnpm and sometimes Yarn PnP can be considered faster.
    With this in mind, the key question is whether there are other alternatives to
    consider. Let’s see what else we can do to simplify dependency management.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在安装是最新的情况下，npm 才可以被认为是最快的选项。在其他情况下，pnpm 和有时 Yarn PnP 可以被认为是更快的。考虑到这一点，关键问题是是否还有其他替代方案可以考虑。让我们看看我们还能做些什么来简化依赖项管理。
- en: More alternatives
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多替代方案
- en: There is no strict requirement when using a package manager. Theoretically,
    it does not matter where the code comes from. You could, for instance, download
    the packages directly, extract them, and refer to them via their local path.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用包管理器时没有严格的要求。从理论上讲，代码的来源并不重要。例如，您可以直接下载包，提取它们，并通过它们的本地路径引用它们。
- en: Alternatively, a system such as **Deno** could be interesting. On the surface,
    Deno is quite similar to Node.js. However, there are a few crucial differences
    under the hood. The most striking one is that there is no package manager for
    Deno. Instead, packages are just URLs that are resolved once needed. This way,
    the package installation is just a download – which happens to run when needed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用像**Deno**这样的系统。表面上，Deno与Node.js非常相似。然而，在底层有一些关键的区别。最显著的区别是Deno没有包管理器。相反，包只是URL，一旦需要才会解析。这样，包安装就只是下载——它恰好发生在需要的时候。
- en: Deno in a nutshell
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Deno
- en: Deno was created by Ryan Dahl – the creator of Node.js. As such, Deno shares
    many features with Node.js but deviates in some aspects. Deno aims to be a lot
    more compatible with JavaScript running in the browser than Node.js. Deno also
    tries to be secure by default. When running a script with Deno, the provided security
    context has to be defined by the user. Otherwise, access to the network or the
    filesystem may be impossible for the code running. You can get more information
    at [https://deno.land/](https://deno.land/).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Deno是由Node.js的创造者Ryan Dahl创建的。因此，Deno与Node.js共享许多功能，但在某些方面有所不同。Deno旨在比Node.js更兼容在浏览器中运行的JavaScript。Deno还试图默认提供安全性。当使用Deno运行脚本时，必须由用户定义提供的安全上下文。否则，代码运行时可能无法访问网络或文件系统。您可以在[https://deno.land/](https://deno.land/)获取更多信息。
- en: Another option is to use a tool that actually leverages one of the existing
    package managers underneath but in a more efficient or user-friendly fashion.
    One example in this category is **Turborepo**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用一个工具，它实际上在底层利用现有的包管理器，但以更高效或用户友好的方式。这个类别中的一个例子是**Turborepo**。
- en: Turborepo works with any of the popular package managers and claims to provide
    improved performance for many tasks, including package installation and updates.
    The most efficient way, however, to utilize Turborepo is to use it for a so-called
    monorepo, which will be discussed in greater length in [*Chapter 9*](B18989_09.xhtml#_idTextAnchor088),
    *Structuring Code* *in Monorepos*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Turborepo可以与任何流行的包管理器协同工作，并声称为许多任务提供了改进的性能，包括包安装和更新。然而，最有效利用Turborepo的方式是将其用于所谓的单一代码库（monorepo），这一点将在[*第9章*](B18989_09.xhtml#_idTextAnchor088)“在单一代码库中*结构化代码*”中更详细地讨论。
- en: Besides the question of how the packages can be installed, updated, and published,
    the other part of package management is the package registry. In this space, you
    can choose from many commercial offerings to open source projects such as **Verdaccio**.
    Having your own package registry can be great for larger projects, where missing
    dependencies or downtimes of the public npm registry may be problematic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了如何安装、更新和发布包的问题之外，包管理的另一部分是包注册库。在这个领域，你可以从许多商业产品中选择，例如**Verdaccio**。对于大型项目来说，拥有自己的包注册库可能非常好，因为缺少依赖项或公共npm注册库的宕机可能成为问题。
- en: In general, there are not many alternatives to the established package managers
    npm, Yarn, and pnpm. While optimizing the use of package managers or using cached
    registries instead might be appealing, they are certainly not worth the effort
    for most projects. Right now, npm and Yarn seem to be most appealing in the broadest
    range of scenarios, whereas pnpm could be considered the desired choice for really
    big repositories.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与已建立的包管理器npm、Yarn和pnpm相比，替代品并不多。虽然优化包管理器的使用或使用缓存的注册库可能很有吸引力，但它们对于大多数项目来说肯定不值得付出努力。目前，npm和Yarn似乎在广泛的场景中最具吸引力，而pnpm可能被认为是大型仓库的理想选择。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use a package manager to handle everything
    related to packages. You’ve leveraged the default `npm` command-line utility.
    You got in touch with the most important alternatives, Yarn and pnpm. You should
    know what Yarn brings to the table – after all, PnP and zero-installs are neat
    features. Furthermore, you checked out some alternatives and learned about custom
    registries and repository task runners such as Turborepo.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用包管理器来处理与包相关的所有事情。你利用了默认的`npm`命令行工具。你接触到了最重要的替代品，Yarn和pnpm。你应该知道Yarn带来了什么——毕竟，PnP和零安装是很好的特性。此外，你还检查了一些替代品，并了解了自定义注册库和仓库任务运行器，如Turborepo。
- en: At this point, you have everything to clone and run existing Node.js projects.
    You can install new dependencies, check for outdated dependencies, and update
    them. This gives you the power to integrate all of the over-a-million packages
    that have been published over the years in the npm registry.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经拥有了克隆和运行现有Node.js项目所需的一切。您可以安装新的依赖项，检查过时的依赖项，并更新它们。这使得您能够整合npm注册表中多年来发布的超过一百万个包。
- en: In the next chapter, we will discuss how different flavors of JavaScript, such
    as more modern specifications or languages that use JavaScript as a compilation
    target, can be used in Node.js.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何使用不同版本的JavaScript，例如更现代的规范或以JavaScript作为编译目标的语言，在Node.js中使用。
- en: 'Part 2: Tooling'
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：工具
- en: In this part, you’ll strengthen your knowledge of the Node.js ecosystem by getting
    in touch with a variety of tools and utilities. You’ll learn how you can use different
    flavors of JavaScript in Node.js. Examples here include TypeScript and Flow. You’ll
    also see which code verification and style checkers exist and how to use them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，您将通过接触各种工具和实用程序来加强您对Node.js生态系统的了解。您将学习如何在Node.js中使用不同版本的JavaScript。这里包括TypeScript和Flow。您还将看到哪些代码验证和样式检查器存在以及如何使用它们。
- en: The main focus of this part is to enable you to set up and maintain a new web
    development project from scratch. This also includes knowledge about quality assurance.
    As part of these topics, utilities such as Jest or Playwright are discussed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分的主要重点是让您从头开始设置和维护一个新的Web开发项目。这还包括质量保证方面的知识。作为这些主题的一部分，讨论了诸如Jest或Playwright之类的实用工具。
- en: 'This part of the book comprises the following chapters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本书这部分包含以下章节：
- en: '[*Chapter 4*](B18989_04.xhtml#_idTextAnchor042), *Using Different Flavors of
    JavaScript*'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18989_04.xhtml#_idTextAnchor042), *使用不同版本的JavaScript*'
- en: '[*Chapter 5*](B18989_05.xhtml#_idTextAnchor049), *Enhancing Code Quality with
    Linters and Formatters*'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18989_05.xhtml#_idTextAnchor049), *使用代码检查器和格式化工具提高代码质量*'
- en: '[*Chapter 6*](B18989_06.xhtml#_idTextAnchor057), *Building Web Apps with Bundlers*'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18989_06.xhtml#_idTextAnchor057), *使用打包器构建Web应用*'
- en: '[*Chapter 7*](B18989_07.xhtml#_idTextAnchor067), *Improving Reliability with
    Testing Tools*'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18989_07.xhtml#_idTextAnchor067), *使用测试工具提高可靠性*'
