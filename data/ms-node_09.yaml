- en: Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: Let everyone sweep in front of his own door, and the whole world will be clean.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让每个人都打扫自己门前的雪，那么整个世界都会变得干净。
- en: – Goethe
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 歌德'
- en: As software has grown more complex, it has become impossible for any one person,
    or even a single team, to maintain total awareness of an entire architecture.
    The rise of the internet promoted the concepts of *frontend* (a browser on one
    computer processing JavaScript, CSS, HTML) and *backend* (another computer running
    a database and an HTTP server) unified on a single server to deliver one product—the
    *web page*. A user might click on a button, a call is made to a server, that server
    might check a database, and will ultimately deliver an HTML page.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件变得更加复杂，任何一个人，甚至一个团队，都无法完全了解整个架构。互联网的兴起促进了“前端”（一台计算机上运行JavaScript、CSS、HTML的浏览器）和“后端”（另一台计算机运行数据库和HTTP服务器）的概念，在单个服务器上统一交付一个产品——网页。用户可能会点击一个按钮，服务器会发出一个调用，该服务器可能会检查数据库，并最终交付一个HTML页面。
- en: The pace has picked up. The modern user expects powerful and highly-interactive
    mobile apps to entertain them or drive their business, at a low cost, with regular
    updates. Now, one person can create an app that gains millions of users within
    months. To scale from one person to a company supporting millions of concurrent
    users in a few months—even a few years—requires efficient teams and engineering
    management.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 速度已经加快。现代用户期望功能强大且高度互动的移动应用程序能够以低成本进行娱乐或推动业务，并进行定期更新。现在，一个人可以创建一个在几个月内获得数百万用户的应用程序。从一个人到在几个月甚至几年内支持数百万并发用户的公司规模扩展，需要高效的团队和工程管理。
- en: Today's network-based applications are composed of several independent subsystems
    that must cooperate to fulfil the business or other requirements of the larger
    system. For example, many web applications will present browser-based interfaces
    composed of one or several libraries and/or UI frameworks translating user actions
    against JavaScript controllers running on phones, microcontrollers, and laptops,
    into formalized network requests issued across several web protocols, ultimately
    communicating with any number of servers executing units of business logic programmed
    in different languages, all sharing one or several databases, maybe across several
    data centers, themselves initiating and coordinating even longer chains of requests
    to a cloud API or other servers, and so on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如今的基于网络的应用程序由几个独立的子系统组成，它们必须合作来满足更大系统的业务或其他要求。例如，许多Web应用程序将呈现基于浏览器的界面，由一个或多个库和/或UI框架组成，将用户操作转换为在手机、微控制器和笔记本电脑上运行的JavaScript控制器发出的正式网络请求，最终与执行用不同语言编程的业务逻辑单元的任意数量的服务器通信，这些服务器可能共享一个或多个数据库，甚至跨多个数据中心，它们本身会发起和协调更长的一系列请求到云API或其他服务器等等。
- en: Software of any complexity is today rarely contained on one machine or within
    a single code base. In this chapter, we will look into the recently popular technique
    of composing distributed architectures out of independent actors, each in the
    form of a small, delineated, hot-reloadable service, or microservices. Microservices
    allow you to rewire, rewrite, reuse, and redeploy modular parts of your application,
    making change easier.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，任何复杂的软件很少仅限于一台机器或单一代码库。在本章中，我们将探讨将独立的组件组合成分布式架构的最新流行技术，每个组件都是一个小的、明确定义的、可热重载的服务，或者称为微服务。微服务允许您重连、重写、重用和重新部署应用程序的模块化部分，使变更更容易。
- en: Why microservices?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用微服务？
- en: Building larger systems out of smaller, dedicated units is not a new idea. Object-oriented
    programming follows the same principle. Unix is built this way. Architectures
    facilitating composable networked software (CORBA, WebObjects, NetBeans) are decades-old
    ideas. What is new is the scale of profits networked software generates. Customers
    across nearly every business sector require new software and new features, and
    software developers are constantly delivering and/or refining those features in
    response to changing market conditions. Microservices are really a management
    idea whose goal is to decrease the time it takes to reflect changing business/customer
    needs in code. The goal is to reduce the cost of change.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将较大的系统构建成较小的专用单元并不是一个新的想法。面向对象编程遵循相同的原则。Unix就是这样构建的。支持可组合网络软件的架构（CORBA、WebObjects、NetBeans）是几十年前的想法。新的是网络软件带来的利润规模。几乎每个业务领域的客户都需要新的软件和新的功能，软件开发人员不断根据不断变化的市场条件交付和/或完善这些功能。微服务实际上是一个管理理念，其目标是减少将业务/客户需求变化反映到代码中所需的时间。目标是降低变更成本。
- en: 'As there is no absolute *right way* to build software, every language design
    is biased toward one or a few key principles, in particular, principles guiding
    how a system should scale, which normally affects how it is deployed. Some of
    the key principles informing the Node community—modular systems composed of small
    programs that do one thing well, event-driven, I/O focused, network focused—align
    closely with those underpinning microservices:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件没有绝对的“正确方式”，每种语言设计都偏向于一个或几个关键原则，特别是指导系统如何扩展的原则，通常会影响部署方式。Node社区的一些关键原则——由小程序组成的模块化系统，事件驱动，I/O聚焦，网络聚焦——与支持微服务的原则密切相关：
- en: A system should be broken out into many small services where each does one thing,
    and no more. This helps with clarity.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个系统应该被分解成许多小服务，每个服务只做一件事，而不是更多。这有助于清晰度。
- en: The code powering services should be short and simple. A common guideline in
    the Node community is to limit programs to somewhere near 100 lines of code. This
    helps with maintainability.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持服务的代码应该简短而简单。Node社区的一个常见指导原则是将程序限制在大约100行代码附近。这有助于可维护性。
- en: No service should depend on the existence of another service—or even know of
    the existence of other services. Services are decoupled. This helps with scalability,
    clarity, and maintainability.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有服务应该依赖于另一个服务的存在，甚至不应该知道其他服务的存在。服务是解耦的。这有助于可扩展性、清晰度和可维护性。
- en: Data models should be decentralized, with a common (but not required) microservice
    pattern being each service maintaining its own database or similar model. Services
    are stateless. This reinforces (3).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据模型应该是分散的，一个常见（但不是必需的）微服务模式是每个服务维护自己的数据库或类似模型。服务是无状态的。这加强了（3）。
- en: Independent services are easy to replicate (or cull). Scaling (in both directions)
    is a natural feature of microservice architectures as new *nodes* can be added
    or removed as necessary. This also enables easy experimentation, where prototype
    services can be tested, new features can be tested or deployed temporarily, and
    so forth.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立的服务易于复制（或删除）。在微服务架构中，扩展（双向）是一个自然的特性，因为可以根据需要添加或删除新的*节点*。这也使得轻松进行实验，可以测试原型服务，测试或临时部署新功能等。
- en: Independent, stateless, services can be replaced or upgraded (or downgraded)
    independently, regardless of the state of any system they form a part of. This
    opens the possibility of more focused, discreet deployments and refactors.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立的无状态服务可以独立替换或升级（或降级），而不受它们所属系统的状态的影响。这打开了更加专注、离散的部署和重构的可能性。
- en: Failure is unavoidable, so systems should be designed to fail gracefully. Localize
    points of failure (1, 2), isolate failure (3, 4), and implement recovery mechanisms
    (easier when error boundaries are clearly defined, small, and non-critical), promoting
    robustness by reducing the scope of unreliability.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 失败是不可避免的，因此系统应设计成能够优雅地失败。局部化故障点（1, 2），隔离故障（3, 4），并实施恢复机制（当错误边界明确定义、小且非关键时更容易），通过减少不可靠性的范围来促进健壮性。
- en: Testing is essential to any non-trivial system. Unambiguous and simple stateless
    services are easy to test. A key aspect of testing is simulation—the *stubbing* or
    *mocking* of services in order to test service interoperability. Clearly delineated
    services are also easy to simulate, and can, therefore, be intelligently composed
    into testable systems.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试对于任何非平凡的系统都是必不可少的。明确简单的无状态服务易于测试。测试的一个关键方面是模拟——*存根*或*模拟*服务，以测试服务的互操作性。清晰界定的服务也易于模拟，因此可以智能地组合成可测试的系统。
- en: 'The idea is simple: smaller services are easy to reason about individually,
    encouraging correctness of specification (little or no grey area) and clarity
    of API (constrained sets of outputs follow constrained sets of inputs). Being
    stateless and decoupled, services promote system composability, helping with scaling
    and maintainability, making them easier to deploy. Also, very precise, discrete
    monitoring of these sorts of systems is possible.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单：更小的服务更容易单独思考，鼓励规范的正确性（几乎没有灰色地带）和API的清晰性（受限的输出集遵循受限的输入集）。作为无状态和解耦的服务，有助于系统的可组合性，有助于扩展和可维护性，使它们更容易部署。此外，这种类型的系统可以进行非常精确、离散的监控。
- en: With that rough sketch in mind, let's go back in time and survey some foundational
    architectural patterns such as "3-Tier" architectures, and how their character
    led to the idea of a *microservice*. Bringing that progression up to the present,
    we'll then take a look at how the incredible scale of modern networked applications
    has forced a reimagining of the classic client->server->database setup, a new
    world often best composed with microservices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个大致的草图，让我们回到过去，调查一些基础架构模式，比如“3层”架构，以及它们的特点如何导致了*微服务*的概念。将这一进展带到现在，然后我们将看看现代网络应用程序的不可思议的规模如何迫使重新构想经典的客户端->服务器->数据库设置，这个新世界通常最好由微服务组成。
- en: When building web-based APIs using microservices, it will be useful to have
    tools that give you precise control over handling calls, headers, POST bodies,
    responses and so on, especially when debugging. I recommend installing **Postman**
    ([https://www.getpostman.com/](https://www.getpostman.com/)), and an extension
    for your browser that "prettifies" JSON objects. For Chrome, a good one is **JSON
    Formatter** ([https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?hl=en](https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?hl=en)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建基于微服务的Web API时，拥有能够精确控制处理调用、标头、POST主体、响应等的工具将非常有用，特别是在调试时。我建议安装**Postman**（[https://www.getpostman.com/](https://www.getpostman.com/)），以及浏览器的扩展程序，可以“美化”JSON对象。对于Chrome来说，一个很好的选择是**JSON
    Formatter**（[https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?hl=en](https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?hl=en)）。
- en: From 3-Tiers to 4-Tiers
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从3层到4层
- en: To understand how microservices can improve your Node application, you must
    understand the problems they are designed to solve, and how those problems were
    solved previously. It is important to know *where* a microservice-oriented architecture
    might apply, and *why* such a change will help you. Let's look at how multitiered,
    distributed network architectures have developed over time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解微服务如何改进您的Node应用程序，您必须了解它们旨在解决的问题，以及以前如何解决这些问题。重要的是要知道*微服务*导向架构可能适用的*地方*，以及*为什么*这样的变化将帮助您。让我们看看多层分布式网络架构是如何随着时间的推移发展的。
- en: Monoliths
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体
- en: 'This is a monolith:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单体：
- en: '![](img/474961f2-296d-4989-890e-c8d86d0d938f.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/474961f2-296d-4989-890e-c8d86d0d938f.jpg)'
- en: It is big, of one piece, and grows vertically. It would probably be difficult
    to reshape, or otherwise modify without great effort, great danger, and great
    cost. When someone describes an architecture as *monolithic*, they are using the
    preceding metaphor to suggest something very large and immovable and so massive
    as to discourage those attempting to improve it or to survey its total constituent
    parts in a comprehensive way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它很大，是一个整体，是垂直增长的。可能很难在没有巨大的努力、巨大的危险和巨大的成本的情况下重新塑造或修改。当有人将架构描述为*单片式*时，他们使用前面的隐喻来暗示某种非常庞大、不可移动的东西，以至于使试图改进它或全面调查其全部组成部分的人望而却步。
- en: 'Consider a simple application, like a *to-do* list. A list manager requires
    functionality to `create`, `add`, `delete`, and otherwise change lists. The code
    for that application might resemble this pseudo-code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的应用，比如一个*待办*清单。清单管理器需要`创建`、`添加`、`删除`和其他改变清单的功能。该应用的代码可能类似于这样的伪代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example shows monolithic design thinking. The data is on the same machine
    as the UI controllers as the process logic, functionality resides within the same
    context (the enclosing Node module), the same file, and the same OS process. You
    need not be pro-microservices to understand that as you add user accounts, drafts,
    and media attachments, sharing, multi-device synchronization, and other features
    to your to-do app, the original singular, monolithic repository for all application
    logic has grown too dense, and will need to be broken up into pieces.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了单体设计思维。数据在同一台机器上，UI控制器和进程逻辑在同一上下文中（封闭的Node模块），功能在同一个文件和同一个操作系统进程中。你不需要支持微服务来理解，随着用户账户、草稿和媒体附件、共享、多设备同步和其他功能被添加到你的待办应用中，最初的单一的、单体化的存储所有应用逻辑的仓库变得过于密集，需要被分解成多个部分。
- en: What if you broke each of those functions off into an independent process, running
    in its own memory space, so pure and unattached to any other process that it can
    be updated, shut down, duplicated, deployed, tested, or even replaced with no
    impact on any other part of the system? Microservices come out of that kind of
    thinking.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些函数中的每一个都分解成一个独立的进程，在自己的内存空间中运行，纯粹且不依赖于任何其他进程，以至于可以更新、关闭、复制、部署、测试，甚至替换而不对系统的任何其他部分产生影响，那么微服务就是从这种思维方式中产生的。
- en: It is perfectly okay to construct your software using standard OO, or a list
    of functions or structures all in one file or a small collection of files, and
    to expect your software to be running on a single machine. That architectural
    model probably works for most people; on modern hardware, a single-core machine
    running a simple Node server can likely handle several thousand concurrent users
    performing non-trivial, database-driven tasks. It is perfectly okay to scale a
    growing application by adding more cores or more memory to scale an architecture
    vertically. It's also okay to scale an architecture by standing up several already
    vertically-scaled servers and balancing the load between them. That strategy is
    still used by some billion-dollar companies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件时，使用标准的面向对象编程，或者将所有函数或结构都放在一个文件或一小组文件中，期望软件在单台机器上运行是完全可以的。这种架构模型可能适用于大多数人；在现代硬件上，运行简单的Node服务器的单核机器可能能够处理数千个并发用户执行非平凡的、数据库驱动的任务。通过增加更多的核心或内存来扩展垂直架构来扩展不断增长的应用程序是完全可以的。通过启动几台已经垂直扩展的服务器并在它们之间平衡负载来扩展架构也是可以的。这种策略仍然被一些价值数十亿美元的公司使用。
- en: It is okay to build a monolith *if it's the right choice for your needs*. At
    other times, microservices will be the right choice. You may not need to use decentralized
    data sources; you might have no need to *hot-reload* your services when they change.
    The widely used database MYSQL is commonly scaled vertically. When limits are
    being pushed, one simply adds more processing cores, memory, and storage space
    to your database server, or creates multiple copies of the same database and balances
    requests between them. This sort of monolithic architecture is easy to reason
    about and is typically resilient.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建单体架构是符合你需求的正确选择，那是可以的。在其他时候，微服务可能是正确的选择。你可能不需要使用去中心化的数据源；当服务发生变化时，你可能不需要*热重载*。广泛使用的数据库MYSQL通常是垂直扩展的。当限制被推动时，只需向数据库服务器添加更多的处理核心、内存和存储空间，或者创建同一数据库的多个副本并在它们之间平衡请求。这种单体架构易于理解，通常是有弹性的。
- en: 'What are the advantages of vertically scaled architectures (monoliths)?:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展架构（单体架构）的优势是什么？：
- en: '**Testing and debugging**: What happens in the application begins and ends
    with the application itself, independent of random network effects. This can be
    helpful when testing and debugging.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试和调试**：应用程序中发生的事情始于应用程序本身，独立于随机网络效应。这在测试和调试时可能会有所帮助。'
- en: '**Strong consistency**: A persistent local database connection can help guarantee
    transactional integrity, including rollbacks. Distributed databases, especially
    those being accessed concurrently by many thousands of clients, are much more
    difficult to keep synchronized, and are typically described as *eventually consistent*,
    which may be a problem, especially if you''re a bank.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强一致性**：持久的本地数据库连接可以帮助保证事务完整性，包括回滚。分布式数据库，特别是被许多客户端并发访问的数据库，要保持同步要困难得多，并且通常被描述为*最终一致*，这可能是一个问题，特别是如果你是一家银行。'
- en: '**Simplicity**: A well-designed application with, for example, a single REST
    API locally bounded within the same logical space as a single database can be
    easily described, and is predictable. Often, an individual can understand the
    entire system and even run it singlehandedly! This is a non-trivial advantage,
    especially in terms of the increased velocity of employee onboarding, and the
    opportunity for individual entrepreneurship.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：一个设计良好的应用，例如一个在同一逻辑空间内与单个数据库绑定的单个REST API，可以很容易地描述，并且是可预测的。通常，一个人可以理解整个系统，甚至可以独自运行它！这是一个非常重要的优势，特别是在员工入职速度增加和个人创业机会方面。'
- en: '**Linear scaling**: If you can, hypothetically, double your capacity by doubling
    memory on a single machine, that is a very easy upgrade. At some point, this solution
    won''t suffice, but that point is probably much farther out than you might think.
    It is relatively easy to predict the cost of increased load and the steps needed
    to scale the system.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性扩展**：如果可能的话，通过在单台机器上加倍内存容量来加倍容量是一个非常简单的升级。在某些时候，这种解决方案可能不够用，但这一点可能比你想象的要远得多。相对容易预测增加负载的成本和扩展系统所需的步骤。'
- en: A few companies, or developers, will encounter scales absolutely requiring a
    distributed architecture. Some smart data object design and componentized UI related
    through a single database, well-designed and maintained, can be enough for a very
    long time, or even forever. In many ways, the popular Ruby on Rails framework
    continues to champion the monolith and the value of integrated systems, a position
    strongly argued for by its creator *David Heinemeier Hansson* at: [http://rubyonrails.org/doctrine/#integrated-systems](http://rubyonrails.org/doctrine/#integrated-systems).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司或开发者将遇到绝对需要分布式架构的规模。一些聪明的数据对象设计和通过单个数据库相关的组件化UI，设计良好并且维护良好，可能足够长时间，甚至永远。在许多方面，流行的Ruby
    on Rails框架继续支持单体和集成系统的价值，这是其创始人David Heinemeier Hansson在[http://rubyonrails.org/doctrine/#integrated-systems](http://rubyonrails.org/doctrine/#integrated-systems)上强烈主张的立场。
- en: From monoliths to 3-Tiered architectures
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单片到三层架构
- en: 'You might say with some precision that few people are truly building monolithic
    applications anymore. What people call *monolith* nowadays is typically a 3-Tiered
    application, which concretizes the following conceptual layers:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，现在很少有人真正构建单片应用程序。人们现在所谓的单片通常是一个三层应用程序，具体化了以下概念层：
- en: '**Presentation tier**: Interfaces for clients to request, view, and modify
    information. Typically communicates with the Application tier.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示层：客户端请求、查看和修改信息的接口。通常与应用程序层通信。
- en: '**Application tier:** Logic to connect the Presentation and Data tiers'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序层：连接表示层和数据层的逻辑
- en: '**Data-tier**: Where information is persisted and organized'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据层：信息持久化和组织
- en: A Node developer will likely recognize applications composed of a client framework
    such as React (Presentation), *served* by an application layer built using Express,
    communicating with a MongoDB database via some sort of connector, such as Mongoose.
    These are the **LAMP** stacks, the **MEAN** stacks. System architects have known
    for a long time that the separation of an application into distinct systems is
    a smart strategy. In many ways, this architecture reflects the **Model View Controller**(**MVC**)
    model, where  M=Data, V=Presentation, and C=Application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Node开发者可能会认识到，应用程序由一个客户端框架（如React）（表示层）组成，由使用Express构建的应用程序层提供服务，通过某种连接器与MongoDB数据库通信，例如Mongoose。这些是LAMP堆栈，MEAN堆栈。系统架构师很久以来就知道将应用程序分离成不同的系统是一种明智的策略。在许多方面，这种架构反映了模型视图控制（MVC）模型，其中M=数据，V=表示，C=应用程序。
- en: How did this architecture come about?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这种架构是如何产生的？
- en: Firstly, it was recognized that there are very clearly distinct parts of systems
    that should be understood separately. A browser-based UI has nothing to do with
    your database or with your web server. It may, through various layers of abstraction,
    come to *reflect* your database structure (the display of profiles linked by interests,
    for example), but that characteristic of your system is ultimately a design decision,
    not a necessary condition. Maintaining and updating your database independent
    of your layout grid or interactive components just makes sense. Unfortunately,
    these distinct things can end up entangled, through lazy design or the vicissitudes
    of fast-paced business environments, and for other reasons.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，人们认识到系统中有非常明显的应该分开理解的部分。基于浏览器的UI与您的数据库或Web服务器无关。它可能通过各种抽象层来反映您的数据库结构（例如，通过兴趣链接的个人资料显示），但这种系统特性最终是一个设计决策，而不是一个必要条件。独立于布局网格或交互组件维护和更新您的数据库是有道理的。不幸的是，这些不同的东西可能会因为懒惰的设计或快节奏的商业环境的变化而纠缠在一起，还有其他原因。
- en: Secondly, rapid, continuous deployment and integration is much more difficult
    when changing one part of one of the tiers ultimately requires retesting the entire
    system. Integration tests must either touch on real systems or create artificial
    simulations, neither of which are dependable, and both of which can lead to destructive
    results. Similarly, deployments are holistic—each part, even if conceptually distinct,
    is in reality intimately bound with the others, where the integrity of each must
    be validated by validating the integrity of the whole. Enormous test suites reflect
    the enormity and density of the application designs they attempt to cover.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当更改一个层的一部分最终需要重新测试整个系统时，快速、持续的部署和集成就会变得更加困难。集成测试必须要么涉及真实系统，要么创建人工模拟，两者都不可靠，都可能导致破坏性结果。同样，部署是整体的——即使在概念上是不同的，实际上每个部分都与其他部分紧密相连，每个部分的完整性都必须通过验证整体的完整性来验证。庞大的测试套件反映了它们试图覆盖的应用程序设计的巨大和密集。
- en: The focus on having exactly three tiers makes elasticity difficult. New data
    models, functions, services, even UIs that might be *one-off* additions (a completely
    independent login system from Facebook, for instance) must be linked across the
    three tiers, and its integration with many or all the existing data models, functions,
    business logic, UIs must be done carefully (and somewhat artificially) both initially
    and on every change. As new caching mechanisms (CDNs) and API-driven development
    has taken hold, the artificiality of the 3-tier system has begun to frustrate
    developers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于确切的三层使弹性变得困难。新的数据模型、功能、服务，甚至可能是一次性的UI添加（例如来自Facebook的完全独立的登录系统）必须在三个层之间进行链接，并且必须仔细地（有些是人为地）进行与许多或所有现有数据模型、功能、业务逻辑、UI的集成。随着新的缓存机制（CDN）和API驱动的开发的出现，三层系统的人为性开始让开发人员感到沮丧。
- en: Service-Oriented Architectures
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的体系结构
- en: 'The idea of microservices is largely a refinement and recontextualization of
    the ideas around **Service-Oriented Architectures (SOA)**, which Wikipedia defines
    this way:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的概念在很大程度上是对围绕面向服务的体系结构（SOA）的想法的改进和重新定义，维基百科对此的定义如下：
- en: <q>"A [SOA] is a style of software design where services are provided to the
    other components by application components, through a communication protocol over
    a network. ... A service is a discrete unit of functionality that can be accessed
    remotely and acted upon and updated independently, such as retrieving a credit
    card statement online."</q>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <q>“[SOA]是一种软件设计风格，应用组件通过网络上的通信协议向其他组件提供服务。...服务是可以远程访问并独立操作和更新的离散功能单元，例如在线检索信用卡对账单。”</q>
- en: An SOA makes a lot of sense when a distinct piece of functionality can be delineated.
    If you are running an online store, you'll probably want to separate the search
    functionality and the payments functionality from the signup system and the client
    UI server. We can see that the foundational idea here is to create functionality
    that is logically self-contained and accessible via a network—useful services
    that other system components (including services) can work with without colliding
    with each other.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构在明确定义功能时非常有意义。如果您正在运行在线商店，您可能希望将搜索功能和付款功能与注册系统和客户端UI服务器分开。我们可以看到这里的基本思想是创建逻辑上自包含并通过网络访问的功能——其他系统组件（包括服务）可以使用而不会相互冲突。
- en: Separating like functionality into individual services is a common adjustment
    to 3-Tier architectures, where the business logic on a server might delegate its
    responsibilities to a third-party API. For example, one might use an identity
    management service like **Auth0** to manage user accounts, rather than store them
    locally in a database. This means the business logic for logins functions as a
    proxy to an external service. Financial transactions, like sales, are often delegated
    to external providers, as are log collection and storage. For companies that might
    offer up their services as an API, the entirety of the API management might be
    delegated to a cloud service such as Swagger or Apiary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将类似功能分离为单独的服务是对3层架构的常见调整，在该架构中，服务器上的业务逻辑可能将其职责委托给第三方API。例如，一个身份管理服务如**Auth0**可能用于管理用户帐户，而不是将其本地存储在数据库中。这意味着登录的业务逻辑作为外部服务的代理。财务交易，如销售，通常被委托给外部提供者，日志收集和存储也是如此。对于可能将其服务作为API提供的公司，整个API管理可能被委托给云服务，如Swagger或Apiary。
- en: Possibly as a result of architectural trend toward services, driven by third-party
    services managing once *on-site* functionality such as caching and other APIs,
    a new basket of ideas generally referred to as "4-Tier architecture" has attracted
    the attention of system architects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是由于架构趋势向服务的方向发展，由第三方服务管理曾经在现场功能上的功能（如缓存和其他API），一种通常称为“4层架构”的新思想引起了系统架构师的关注。
- en: 4-Tiers and microservices
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4层和微服务
- en: The last several years of modern distributed application development has led
    to somewhat of a consensus of patterns advantageous to scaling. Let's consider
    first what is generally meant by a "4-Tier Architecture", and then how microservices
    have come to define the design of these types of systems.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现代分布式应用程序开发的最近几年已经形成了一种有利于扩展的模式共识。首先让我们考虑一下“4层架构”通常指的是什么，然后再看微服务是如何定义这类系统设计的。
- en: '4-Tier architectures extend and expand 3-Tier architectures:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 4层架构扩展和扩展了3层架构：
- en: '**Tier 1:** The Data tier in a 3-Tier architecture is replaced by a **Services**
    tier. The thinking is straightforward: data is stored at such scale, in so many
    different ways, across so many different technologies, and changes so often in
    quality and type that the idea of a "single source of truth", like a single database,
    is no longer workable. Data is exposed through abstract interfaces whose internal
    design (calling a Redis database and/or pulling your inbox from Gmail and/or reading
    weather data from government databases) is a "black box" that need simply return
    data in the expected format.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层1：** 3层架构中的数据层被**服务**层取代。这种思路很简单：数据以如此之大的规模、以如此多种不同的方式、通过如此多种不同的技术存储，并且在质量和类型上变化如此之快，以至于“单一真相来源”的概念，比如单一数据库，已经不再可行。数据通过抽象接口公开，其内部设计（调用Redis数据库和/或从Gmail收取收件箱和/或从政府数据库读取天气数据）是一个“黑匣子”，只需返回预期格式的数据。'
- en: '**Tier 2:** 4-Tier architectures introduce the concept of an **Aggregation**
    tier. Just as data is now broken into services (1), business logic is also being
    isolated into individual services. As we''ll see later when discussing Lambda
    architectures, the distinction between the way you fetch data or call a *subroutine* has
    blurred into a general API driven model, where individual services with consistent
    interfaces generate protocol-aware data. This tier assembles and transforms data,
    augmenting and filtering aggregated source data into data modeled in structured,
    predictable ways. This is the layer that might have been called the *backend*,
    or the Application tier. This is where developers program the channels through
    which data flows as agreed upon (programmed) protocols. Generally, we want to
    produce structured data here.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层2：** 4层架构引入了**聚合**层的概念。正如数据现在被分解为服务（1），业务逻辑也被隔离到单独的服务中。正如我们稍后将在讨论Lambda架构时看到的，获取数据或调用*子例程*的方式已经模糊成了一个通用的API驱动模型，其中具有一致接口的单独服务生成协议感知数据。这一层组装和转换数据，将聚合的源数据增加和过滤成以结构化、可预测的方式建模的数据。这一层可能被称为*后端*或应用层。这是开发人员编程数据流通道的地方，按照约定（编程）的协议。通常，我们希望在这里生成结构化数据。'
- en: 'The remaining tiers are created by splitting the Presentation tier into two:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余层是通过将表示层分为两个部分来创建的：
- en: '**Tier 3:** The **Delivery** Tier: This tier, aware of client profile (mobile,
    desktop, IOT, and so on), transforms data delivered by the Aggregation tier into
    client-specific formats. Cached data would be fetched here, via CDN or otherwise.
    Selection of ads to insert into a *webpage* might be done here. This tier is responsible
    for optimizing data received from the Aggregation tier for an individual user.
    This layer can often be fully automated.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三层：** **交付**层：此层意识到客户端配置文件（移动设备、桌面、物联网等），将聚合层提供的数据转换为特定于客户端的格式。缓存数据可以通过CDN或其他方式在此处获取。在这里可能会选择要插入*网页*的广告。此层负责优化从聚合层接收到的数据，以适应个别用户。这一层通常可以完全自动化。'
- en: '**Tier 4:** The **Client** Tier: This tier customizes what is generally returned
    from the Delivery tier for the specific clients. This can be as simple as rendering
    a data stream for a mobile device (perhaps a responsive CSS structure or device
    specific native format) or the reflection of a personalized view (only images,
    or language translation). Here''s where the same data source can be aligned with
    a specific business partnership, made to conform with an **SLA (Service Level
    Agreement)** or other business function.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四层：** **客户端**层：此层定制了交付层通常为特定客户返回的内容。这可以是为移动设备呈现数据流（可能是响应式CSS结构或特定设备的本机格式），也可以是个性化视图的反映（仅图像或语言翻译）。在这里，相同的数据源可以与特定的业务合作伙伴对齐，符合**SLA（服务级别协议）**或其他业务功能。'
- en: The notable change is the splitting of the Presentation tier into two. Node
    often appears in the Delivery tier, querying the Aggregation tier on behalf of
    the Client, customizing the data response it receives for the Client.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 显著的变化是将呈现层分成两个部分。Node经常出现在交付层，代表客户端查询聚合层，定制从聚合层接收到的数据响应给客户端。
- en: 'In general, we have moved to an architecture where individual services are
    not expected to reflect the needs of the caller in any specific way, like a browser-focused
    templating engine in an Express server might have. Services need not share the
    same technology or programming language, or even the same OS version or kind.
    Architects instead declare a certain type of topology, with clearly defined communication
    points and protocols, generally distributed into: 1) data sources, 2) data aggregators,
    3) data shapers, and 4) data displayers.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们已经转向了一个架构，其中不再期望个别服务以任何特定方式反映调用者的需求，就像Express服务器中的面向浏览器的模板引擎可能会有的那样。服务无需共享相同的技术或编程语言，甚至不需要相同的操作系统版本或类型。架构师们相反宣布了一定类型的拓扑结构，具有明确定义的通信点和协议，通常分布在：1）数据源，2）数据聚合器，3）数据整形器和4）数据显示器。
- en: Deploying microservices
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署微服务
- en: In this section, we'll consider several variations on microservices, looking
    at a few common ways in which developers are using microservices with Node. We'll
    start with **Seneca**, a microservices framework for Node. Then, we'll move on
    to developing cloud-based microservices using **Amazon Lambda**. From there, we
    will attempt to model a **Kubernetes** cluster out of **Docker** containers, exploring
    modern containerized microservice orchestration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑微服务的几种变体，看一看开发人员如何使用Node进行微服务的一些常见方式。我们将从**Seneca**开始，这是一个用于Node的微服务框架。然后，我们将继续使用**Amazon
    Lambda**开发基于云的微服务。从那里，我们将尝试使用**Docker**容器模拟一个**Kubernetes**集群，探索现代容器化微服务编排。
- en: Microservices with Seneca
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Seneca的微服务
- en: 'Seneca is a Node-based microservice construction kit that helps you organize
    your code into distinct actions triggered by patterns. Seneca applications are
    composed of services that can accept JSON messages and optionally return some
    JSON. Services register an interest in messages with certain characteristics.
    For example, a service might run whenever a JSON message displaying the `{ cmd:
    "doSomething" }` pattern is broadcast.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'Seneca是一个基于Node的微服务构建工具包，可以帮助您将代码组织成由模式触发的不同操作。Seneca应用程序由可以接受JSON消息并可选返回一些JSON的服务组成。服务注册对具有特定特征的消息感兴趣。例如，每当广播显示`{
    cmd: "doSomething" }`模式的JSON消息时，服务可能会运行。'
- en: To start, let’s create a service that responds to three patterns, one pattern
    returning “Hello!”, and the other two different ways of saying “Goodbye!”.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个响应三种模式的服务，其中一种模式返回“Hello!”，另外两种模式是不同的说“Goodbye!”的方式。
- en: 'Create a `hellogoodbye.js` file containing the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`hellogoodbye.js`的文件，其中包含以下代码：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Seneca works on the idea of service clients listening for certain command patterns,
    and routing to the right handler based on pattern matching. Our first job is to
    set up two Seneca service clients, listening on ports `8080` and `8081`. Already,
    we can see how services are being organized into two groups, the "hello service"
    with one method, and the "goodbye service" with another. We now need to add actions
    to those services. To do that, we need to tell Seneca how to act when a service
    call matching a certain pattern is made, here defined using certain object keys.
    It is left open how to define your service objects, but the "cmd" and "role" pattern
    is common—it helps you create logical groups and a standard command call signature.
    We'll be using that pattern in the examples that follow.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca的工作原理是服务客户端监听特定的命令模式，并根据模式匹配将其路由到正确的处理程序。我们的第一项工作是设置两个Seneca服务客户端，监听端口`8080`和`8081`。可以看到服务已经被组织成两个组，一个是“hello服务”有一个方法，另一个是“goodbye服务”有另一个方法。现在我们需要向这些服务添加操作。为此，我们需要告诉Seneca在进行匹配特定模式的服务调用时如何操作，这里使用特定的对象键进行定义。如何定义您的服务对象是开放的，但“cmd”和“role”模式是常见的——它可以帮助您创建逻辑组和标准的命令调用签名。我们将在接下来的示例中使用该模式。
- en: 'Considering the preceding code, we see that when a JSON object is received
    with the `cmd` field set to `sayHello` and a `role` of `hello`, the service handler
    should return  `{ message: "Hello!" }`. The "goodbye" role methods are similarly
    defined. At the bottom of the file, you see how we can directly call those services
    via Node. It is easy to imagine how these service definitions can be broken out
    into several module exports in individual files, dynamically imported as needed,
    and otherwise used to compose applications in an organized way (a goal of microservice-based
    architectures).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑到上述代码，我们看到当收到一个JSON对象，其中`cmd`字段设置为`sayHello`，`role`为`hello`时，服务处理程序应该返回`{
    message: "Hello!" }`。 "goodbye"角色方法同样被定义。在文件底部，您可以看到我们如何可以通过Node直接调用这些服务。很容易想象这些服务定义如何可以分解成几个模块导出到单独的文件中，根据需要动态导入，并以有组织的方式组合应用程序（这是微服务架构的目标）。'
- en: 'To get rid of the log data being displayed, you can initialize your Seneca
    instance with `require(''seneca'')({ log: ''silent'' })`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '为了摆脱显示的日志数据，您可以使用`require(''seneca'')({ log: ''silent'' })`来初始化您的Seneca实例。'
- en: 'As the Seneca service is listening on HTTP by default, you can achieve the
    same result by making a direct call over HTTP, operating against the `/act` route:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Seneca服务默认监听HTTP，您可以通过直接调用HTTP，在`/act`路由上进行操作，从而实现相同的结果：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This automatic HTTP interface gets us network-discoverable services for free,
    which is handy. We can already get a sense of the microservice pattern: simple,
    independent, small bits of functionality that communicate using standard network
    data patterns. Seneca gives us both a programmatic and networked interface for
    free, and that''s a bonus.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动的HTTP接口为我们提供了可自动发现的网络服务，这非常方便。我们已经可以感受到微服务模式：简单、独立、小的功能块，使用标准的网络数据模式进行通信。Seneca为我们提供了免费的编程和网络接口，这是一个额外的好处。
- en: Once you start creating a lot of services, it will become difficult to keep
    track of which service group operates out of which port. Service discovery is
    a difficult, new problem that microservice architectures introduce. Seneca solves
    this via its **mesh** plugin, which adds service discovery to your Seneca cluster.
    Let's create a simple calculator service to demonstrate. We’ll create two services,
    each listening on a distinct port, one that performs addition and the other subtraction,
    as well as a base service to instantiate the mesh. Finally, we'll create a simple
    script that performs addition/subtraction operations using services whose location
    it need not know, via the mesh.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始创建大量的服务，就会变得难以跟踪哪个服务组在哪个端口上运行。服务发现是微服务架构引入的一个困难的新问题。Seneca通过其**mesh**插件解决了这个问题，该插件将服务发现添加到您的Seneca集群中。让我们创建一个简单的计算器服务来演示。我们将创建两个服务，每个服务监听不同的端口，一个执行加法，另一个执行减法，以及一个基本服务来实例化网格。最后，我们将创建一个简单的脚本，使用不需要知道其位置的服务执行加法/减法操作，通过网格。
- en: 'The code for this example is in the `/seneca` folder in your code bundle. To
    start, you will need to install two modules:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码位于您的代码包中的`/seneca`文件夹中。首先，您需要安装两个模块：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we create a base node that will enable the mesh:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个基本节点，将启用网格：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once this node is started, other services will be automatically discovered once
    connected to the mesh.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了这个节点，其他服务一旦连接到网格，就会自动被发现。
- en: 'The `add` service block looks like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`服务块如下所示：'
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (The **subtract** service looks exactly the same, changing only the math operator
    it uses, and of course its `cmd` will be "subtract").
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: （**subtract**服务看起来完全相同，只是更改了它使用的数学运算符，当然它的`cmd`将是“subtract”）。
- en: Using the familiar role/cmd pattern, we attach the `add` command to the `calculator`
    group, similar to how we defined the "hello" service in our earlier example, with
    a handler to perform the addition operation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用熟悉的角色/cmd模式，我们将`add`命令附加到`calculator`组，类似于我们在之前的示例中定义“hello”服务的方式，具有执行加法操作的处理程序。
- en: We also instruct our service to `listen` for calls on localhost to a specific
    port, as we normally do. What is new is that we `use` the mesh network, using
    the `pin` attribute to indicate the role and cmd that this service will respond
    to, making it discoverable in the mesh.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指示我们的服务`listen`在本地主机上的特定端口接收调用，就像我们通常做的那样。新的是我们使用`use`网格网络，使用`pin`属性指示此服务将响应的角色和cmd，使其在网格中可发现。
- en: 'Jump into the `/seneca` folder in your code bundle and start the following
    three files in separate terminals, in the following order: `base.js` -> `add.js `-> `subtract.js`.
    The logical units for our calculator are set up and running independently, which
    is the general goal of microservices. The last step is to interact with them,
    for which we''ll use the following `calculator.js` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 进入您的代码包中的`/seneca`文件夹，并在单独的终端中按照以下顺序启动以下三个文件：`base.js`->`add.js`->`subtract.js`。我们的计算器的逻辑单元已经独立设置并独立运行，这是微服务的一般目标。最后一步是与它们进行交互，我们将使用以下`calculator.js`文件：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Apart from running our actions from within the `ready` handler for Seneca (a
    useful practice), and of course our `use` of `mesh`, the `seneca.act` statements
    look the same as the "hello" acts we used earlier, don''t they? They are the same,
    except for one important detail: we are not using the `.listen(<port>)` method!
    There is no need to create new Seneca clients bound to certain ports as there
    were in the `hellogoodbye.js` example, because the mesh network services are autodiscovered.
    We can simply make calls without needing to know which port services exist on.
    Go ahead and run the preceding code. You should see the following result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在Seneca的`ready`处理程序中运行我们的操作（这是一个有用的做法），当然还有我们对`mesh`的`use`，`seneca.act`语句看起来与我们之前使用的“hello”操作一样，不是吗？它们是相同的，除了一个重要的细节：我们没有使用`.listen(<port>)`方法！不需要像在`hellogoodbye.js`示例中那样创建绑定到特定端口的新Seneca客户端，因为网格网络服务是自动发现的。我们可以简单地进行调用，而不需要知道服务存在于哪个端口。继续运行上述代码。您应该会看到以下结果：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This allows great flexibility. By building out your calculator in this way,
    each operation can be isolated into its own service, and you can add or remove
    functionality as needed, without affecting the overall program. Should a service
    develop bugs, you can fix and replace it without stopping the general calculator
    application. If one operation requires more powerful hardware or more memory,
    you can shift it to its own server without stopping the calculator application
    or altering your application logic. It is easy to see how stringing together database,
    authentication, transaction, mapping, and other services can be more easily modeled,
    deployed, scaled, monitored, and maintained than if they were all coupled to a
    centralized service manager.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以提供很大的灵活性。通过以这种方式构建您的计算器，每个操作都可以被隔离到自己的服务中，并且您可以根据需要添加或删除功能，而不会影响整个程序。如果某个服务出现错误，您可以修复并替换它，而不会停止整个计算器应用程序。如果某个操作需要更强大的硬件或更多内存，您可以将其转移到自己的服务器上，而不会停止计算器应用程序或更改应用程序逻辑。很容易看出，与它们都耦合到一个集中的服务管理器相比，串联数据库、身份验证、事务、映射和其他服务可以更容易地进行建模、部署、扩展、监视和维护。
- en: Serverless applications
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器应用程序
- en: 'The abstractions that emerge from the design of these distributed systems,
    largely built on microservices, suggest a natural next step. Why have servers
    in the traditional sense at all? Servers are big, powerful machines designed in
    the age of monoliths. If our thinking is in terms of small, resource sipping,
    independent actors indifferent to the world around them, shouldn''t we be deploying
    microservices to "microservers"? This line of thought has led a revolutionary
    ideas: AWS Lamda.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些分布式系统的设计中产生的抽象，主要建立在微服务上，暗示了一个自然的下一步。为什么传统意义上还需要服务器？服务器是设计在单体时代的大型、强大的机器。如果我们的思维是以小型、资源节约、独立于周围环境的行为者为基础，那么我们应该部署微服务到“微服务器”上吗？这种思路导致了一个革命性的想法：AWS
    Lambda。
- en: AWS Lambda
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: 'The introduction of Amazon''s AWS Lambda technology boostrapped the serverless
    movement we have today. Amazon describes Lambda like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊的AWS Lambda技术的引入推动了我们今天所拥有的无服务器运动。亚马逊这样描述Lambda：
- en: '"AWS Lambda lets you run code without provisioning or managing servers...With
    Lambda, you can run code for virtually any type of application or backend service
    - all with zero administration. Just upload your code and Lambda takes care of
    everything required to run and scale your code with high availability. You can
    set up your code to automatically trigger from other AWS services or call it directly
    from any web or mobile app."'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '"AWS Lambda允许您在不需要预配或管理服务器的情况下运行代码...使用Lambda，您可以为几乎任何类型的应用程序或后端服务运行代码-而无需进行任何管理。只需上传您的代码，Lambda会处理运行和扩展您的代码所需的一切。您可以设置代码自动从其他AWS服务触发或直接从任何Web或移动应用程序调用它。"'
- en: Lambda is a technology allowing you to create an infinitely scalable computation
    cloud composed out of microservices written in JavaScript. You no longer manage
    servers, only functions (Lambda functions). The cost of scaling is measured on *usage*,
    not *counts*. It costs more to call 1 Lambda service 10 times than to call each
    of 9 Lambda services once. Similarly, your services can sit idle, never being
    called, without incurring any charges.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda是一种技术，允许您创建由JavaScript编写的微服务组成的无限可扩展的计算云。您不再管理服务器，只管理函数（Lambda函数）。扩展的成本是根据*使用*而不是*计数*来衡量的。调用1次Lambda服务的成本比调用每个9次Lambda服务一次要高。同样，您的服务可以处于空闲状态，从不被调用，而不会产生任何费用。
- en: Lambda functions are functional virtual machines. A Lambda function is essentially
    a containerized Node application which builds and deploys automatically, including
    security updates and further maintenance of the underlying services and infrastructure.
    You will never need to manage Lambda functions beyond writing the code they execute.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数是功能性虚拟机。Lambda函数本质上是一个容器化的Node应用程序，可以自动构建和部署，包括底层服务和基础设施的安全更新和进一步维护。您永远不需要管理Lambda函数，只需编写它们执行的代码。
- en: 'On the other hand, you trade off some of the flexibility developing on a server
    architecture provides. At the time of writing this, these are the limits for each
    Lambda function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您牺牲了在服务器架构上开发提供的一些灵活性。在撰写本文时，每个Lambda函数的限制如下：
- en: '| Resource | Limits |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 资源 | 限制 |'
- en: '| Memory allocation range | Minimum = 128 MB / Maximum = 1536 MB (with 64 MB
    increments). If the maximum memory use is exceeded, function invocation will be
    terminated. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 内存分配范围 | 最小= 128 MB / 最大= 1536 MB（每次增加64 MB）。如果超过最大内存使用量，函数调用将被终止。'
- en: '| Ephemeral disk capacity ("/tmp" space) | 512 MB |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 临时磁盘容量（"/tmp"空间） | 512 MB |'
- en: '| Number of file descriptors | 1,024 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: 文件描述符数量 | 1,024 |
- en: '| Number of processes and threads (combined total) | 1,024 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 进程和线程数量（总和） | 1,024 |'
- en: '| Maximum execution duration per request | 300 seconds |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 每个请求的最大执行持续时间 | 300秒 |'
- en: '| Invoke request body payload size (RequestResponse/synrchronous invocation)
    | 6 MB |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 调用请求体有效负载大小（请求响应/同步调用） | 6 MB |'
- en: '| Invoke request body payload size (Event/asynchronous invocation) | 128 K
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 调用请求体有效负载大小（事件/异步调用） | 128 K |'
- en: These limits need to be kept in mind when designing your application. Generally,
    Lambda functions should not depend on persistence, do one thing well, and do it
    quickly. These limits also imply that you cannot spin up a local database, or
    other in-process applications, within your Lambda function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，需要牢记这些限制。通常，Lambda函数不应依赖持久性，应做好一件事，并且快速完成。这些限制还意味着您不能在Lambda函数内部启动本地数据库或其他进程应用程序。
- en: When it was released, Lambda was exclusively designed for Node; you wrote Lambda
    functions in JavaScript via the Node runtime. This fact is at least some indication
    of just how important Node is to modern application development. While other languages
    are now supported, Lambda continues to treat Node as a first-class citizen. In
    this section, we'll develop an application using the Lambda compute cloud.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda发布时，它专门设计用于Node；您可以通过Node运行时使用JavaScript编写Lambda函数。这一事实至少表明了Node对于现代应用程序开发的重要性。虽然现在支持其他语言，但Lambda仍将Node视为一流公民。在本节中，我们将使用Lambda计算云开发一个应用程序。
- en: 'While the process of setting up with Lambda is much easier now than it was
    when the project was first released, there is still a lot of automatic boilerplate
    you will need to build, and a lot of manual work to make changes. For this reason
    a number of very high quality Lambda-focused "serverless" frameworks have sprung
    up in the Node ecosystem. Some of the leading frameworks are listed below:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与Lambda的设置过程现在比项目首次发布时要容易得多，但您仍然需要构建大量自动样板，并且需要进行大量手动工作来进行更改。因此，在Node生态系统中出现了许多非常高质量的Lambda专注的“无服务器”框架。以下是一些主要的框架：
- en: 'Serverless: [https://github.com/serverless/serverless](https://github.com/serverless/serverless)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Serverless: [https://github.com/serverless/serverless](https://github.com/serverless/serverless)'
- en: Apex: [https://github.com/apex/apex](https://github.com/apex/apex)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Apex: [https://github.com/apex/apex](https://github.com/apex/apex)'
- en: Claudia: [https://github.com/claudiajs/claudia](https://github.com/claudiajs/claudia)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Claudia: [https://github.com/claudiajs/claudia](https://github.com/claudiajs/claudia)'
- en: 'For the following examples, we''ll use `claudia`, which is well-designed, documented,
    and maintained, and is easy to use.  The `claudia` developer puts it this way:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将使用`claudia`，它设计良好、文档完善、维护良好，并且易于使用。`claudia`的开发者是这样说的：
- en: '"...if you want to build simple services and run them with AWS Lambda, and
    you''re looking for something low-overhead, easy to get started with, and you
    only want to use the Node.js runtime, Claudia is a good choice. If you want to
    export SDKs, need fine-grained control over the distribution, allocation or discovery
    of services, need support for different runtimes and so on, use one of the alternative
    tools."'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: “……如果您想构建简单的服务并使用AWS Lambda运行它们，而且您希望找到一个低开销、易于入门的工具，并且只想使用Node.js运行时，Claudia是一个不错的选择。如果您想要导出SDK，需要对服务的分发、分配或发现进行精细控制，需要支持不同的运行时等等，那么请使用其他工具。”
- en: '**API Gateway** is a fully-managed AWS service "that makes it easy for developers
    to create, publish, maintain, monitor, and secure APIs at any scale". We will
    now assemble a scalable web server out of Lambda-powered microservices using Claudia
    and AWS API Gateway.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**API网关**是一个完全托管的AWS服务，“使开发人员能够轻松创建、发布、维护、监控和保护任何规模的API”。我们现在将使用Claudia和AWS
    API网关来组装一个由Lambda驱动的微服务的可扩展Web服务器。'
- en: Scaling with Claudia and API Gateway
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Claudia和API网关进行扩展
- en: To begin, you will need to create a developer account with Amazon Web Services
    (AWS) [https://aws.amazon.com](https://aws.amazon.com). This account setup is
    free. Additionally, most AWS services have very generous free usage tiers, within
    which limits you may use AWS while learning and developing without incurring any
    cost. With Lambda, the first one million requests per month are free.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在Amazon Web Services（AWS）[https://aws.amazon.com](https://aws.amazon.com)创建一个开发者账户。这个账户设置是免费的。此外，大多数AWS服务都有非常慷慨的免费使用额度，在这些限制内，您可以在学习和开发过程中使用AWS而不产生任何费用。使用Lambda，每个月的前一百万个请求是免费的。
- en: Once you have a developer account, log in to your dashboard, and from the Services
    tab, select IAM. You will now add a user that we'll use for these examples. Claudia needs
    permission to communicate with your AWS account. You generally do not want to
    use your root account privileges in applications, which should be understood as
    "sub-users" of your account. AWS provides an **Identity and Access Management
    (IAM)** service to help with that. Let's create an AWS profile with IAM full access,
    Lambda full access, and API Gateway Administrator privileges.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建开发者账户后，登录到您的仪表板，然后从“服务”选项卡中选择IAM。现在，您将添加一个用户，我们将在这些示例中使用。Claudia需要权限与您的AWS账户通信。通常情况下，您不希望在应用程序中使用根账户权限，这应该被理解为您账户的“子用户”。AWS提供了一个**身份和访问管理（IAM）**服务来帮助处理这个问题。让我们创建一个具有IAM完全访问权限、Lambda完全访问权限和API网关管理员权限的AWS配置文件。
- en: 'From the side panel, select Users and click on Add user:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从侧边栏中，选择用户，然后点击“添加用户”：
- en: '![](img/c928b713-abb6-44ae-8d50-80fa5265a5a4.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c928b713-abb6-44ae-8d50-80fa5265a5a4.png)'
- en: As indicated, create a new user `claudia`, affording this user programmatic
    access.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，创建一个名为`claudia`的新用户，为该用户提供编程访问权限。
- en: 'Once you''re done, click on the Next: Permissions button. We now need to attach
    this IAM account to the Lambda and API Gateway services and give it administrative
    privileges:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，点击“下一步：权限”按钮。现在，我们需要将此IAM账户附加到Lambda和API网关服务，并赋予它管理员权限：
- en: '![](img/f0224d5e-a147-4472-8fdc-491c73f9d712.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0224d5e-a147-4472-8fdc-491c73f9d712.png)'
- en: After selecting Attach existing policies directly, you will see a long checklist
    of options appear below. Select the following three permissions for the `claudia` user: AdministratorAccess,
    AmazonAPIGatewayAdministrator, and of course, AWSLambdaFullAccess.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择“直接附加现有策略”后，您将看到下面出现一个长长的选项清单。为`claudia`用户选择以下三个权限：AdministratorAccess、AmazonAPIGatewayAdministrator，当然还有AWSLambdaFullAccess。
- en: 'After clicking on Review, you should see the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“审核”后，您应该会看到以下内容：
- en: '![](img/6e87983e-5f8c-4036-947a-d62012181666.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e87983e-5f8c-4036-947a-d62012181666.png)'
- en: Great. Click on Create User and copy the provided Access key ID and Secret access
    key (you'll need these later). You're now ready to start deploying Lambda functions
    using `claudia`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。点击“创建用户”，并复制提供的访问密钥ID和秘密访问密钥（稍后会用到）。现在，您已经准备好使用`claudia`部署Lambda函数了。
- en: Installing claudia and deploying a service
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装claudia并部署服务
- en: 'To begin installing the `claudia` module, type the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始安装`claudia`模块，请输入以下命令：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, you should store the credentials you just created for the `claudia` user.
    A good pattern here is to store an AWS configuration file in your home directory
    (on OSX, this would be` /Users/<yoursystemusername>`). Once you''re in your home
    directory, create the `.aws/credentials` directory and file with your IAM user
    keys:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该存储刚刚为`claudia`用户创建的凭证。这里的一个好模式是在您的主目录中存储一个AWS配置文件（在OSX上，这将是`/Users/<yoursystemusername>`）。一旦进入您的主目录，创建`.aws/credentials`目录和文件，并使用您的IAM用户密钥：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are indicating that `claudia` is the AWS profile name, targeting these
    IAM credentials. When we run our deployment, AWS will be informed of this profile
    and credentials.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指示`claudia`是AWS配置文件名称，针对这些IAM凭证。当我们运行部署时，AWS将被告知此配置文件和凭证。
- en: Now, let's create a web-accessible HTTP endpoint that returns the string "Hello
    from AWS!".
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个可通过网络访问的HTTP端点，返回字符串“Hello from AWS!”。
- en: 'Create a new directory and initialize an `npm` package with `npm init`, using
    any name that you''d like for the package. To work with AWS API Gateway, we''ll
    also need to install an extension to `claudia`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新目录，并使用`npm init`初始化一个`npm`包，使用任何您喜欢的名称。要使用AWS API Gateway，我们还需要安装`claudia`的扩展：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, add the following `app.js` file to this directory:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下`app.js`文件添加到此目录：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using `claudia` `ApiBuilder`, we attach a Lambda function to handle a GET on
    the `/hello` route. Surprisingly, we''re done! To deploy, enter the following
    into your terminal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`claudia` `ApiBuilder`，我们将一个Lambda函数附加到`/hello`路由上处理GET请求。令人惊讶的是，我们已经完成了！要部署，请在终端中输入以下内容：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `AWS_PROFILE` environment variable is referencing the `[claudia]` profile
    identifier in our credentials file, and we are using the `--region` flag to establish
    the deployment region.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`AWS_PROFILE`环境变量引用了我们凭证文件中的`[claudia]`配置文件标识符，并且我们使用`--region`标志来建立部署区域。'
- en: 'If everything goes right, your endpoint will be deployed, and information similar
    to the following will be returned:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您的端点将被部署，并且将返回类似以下的信息：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The returned URL points to our API gateway. Now, we need to add the name of
    our Lambda function, which was set as `''hello''` in the GET handler we defined
    earlier:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的URL指向我们的API网关。现在，我们需要添加我们Lambda函数的名称，该名称在我们之前定义的GET处理程序中设置为`'hello'`：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Copy and paste the returned URL in your browser and add the name of your Lambda
    function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并粘贴返回的URL到浏览器中，并添加您的Lambda函数的名称：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will see the following message:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下消息：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That was easy. Updating the function is just as easy. Return to the code and
    change the string message your function return''s to something else, then run:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易。更新函数同样容易。返回到代码并更改函数返回的字符串消息，然后运行：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A JSON object will be returned on success, indicating code size and other useful
    information about your function. Go ahead and reload the endpoint in your browser
    and you will see the updated message. These are zero-downtime updates—your service
    never stops working while the new code is deployed. Here, we satisfy the key goal
    of creating "independent, stateless, services [that] can be replaced or upgraded
    (or downgraded) independently, regardless of the state of any system they form
    a part of."
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时将返回一个JSON对象，指示有关函数的代码大小和其他有用信息。继续在浏览器中重新加载端点，您将看到更新的消息。这些是零停机时间更新——您的服务在部署新代码时永远不会停止工作。在这里，我们满足了创建“独立的，无状态的服务[可以独立地替换或升级（或降级）的关键目标，而不管它们所形成的任何系统的状态如何”。
- en: 'You can now validate the existence of your Lambda function by returning to
    the AWS dashboard and visiting your Lambda services:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过返回AWS仪表板并访问Lambda服务来验证Lambda函数的存在：
- en: '![](img/5137fa18-5bb4-4a06-bb8a-3753e1ae10e4.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5137fa18-5bb4-4a06-bb8a-3753e1ae10e4.png)'
- en: We can see the package name listed (`claudiaapi`) and the Node runtime we are
    using (the highest available version on AWS at the time of this writing). If you
    click on the function, you will see the management page for your Lambda function,
    including its code, and interfaces for managing maximum execution times and memory
    limits.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到列出的包名称（`claudiaapi`）和我们正在使用的Node运行时（在撰写本文时AWS上最高可用的版本）。如果单击函数，您将看到Lambda函数的管理页面，包括其代码以及用于管理最大执行时间和内存限制的界面。
- en: 'Change your handler function in `app.js` to the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将`app.js`中的处理程序函数更改为以下内容：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will see three new arguments are passed to the `handler`, `request`, `context`,
    and `callback`. The `context` argument contains useful information about the Lambda
    context for this call, such as the invocation ID, the name of the called function,
    and more. Usefully, `claudia` mirrors Lambda context in the passed `request` object
    at key `lambdaContext`. For this reason, when using `claudia`, you need to only
    work with the `request` argument, which simplifies things.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到三个新参数传递给`handler`，`request`，`context`和`callback`。`context`参数包含有关此调用的Lambda上下文的有用信息，例如调用ID，被调用函数的名称等。有用的是，`claudia`在传递的`request`对象的`lambdaContext`键中镜像Lambda上下文。因此，使用`claudia`时，您只需要处理`request`参数，这简化了事情。
- en: To learn more about Lambda event contexts, refer to: [http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html](http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关Lambda事件上下文的更多信息，请参阅：[http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html](http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html)。
- en: Now, update your Lambda function using `claudia update`, and check the URL.
    You should see a large amount of JSON data returned, the totality of the request
    event information available to you. For more on this data object, visit: [https://github.com/claudiajs/claudia-api-builder/blob/master/docs/api.md#the-request-object](https://github.com/claudiajs/claudia-api-builder/blob/master/docs/api.md#the-request-object).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`claudia update`更新您的Lambda函数，并检查URL。您应该看到返回大量JSON数据，这是您可以使用的请求事件信息的总和。有关此数据对象的更多信息，请访问：[https://github.com/claudiajs/claudia-api-builder/blob/master/docs/api.md#the-request-object](https://github.com/claudiajs/claudia-api-builder/blob/master/docs/api.md#the-request-object)。
- en: An interesting collection of serverless development information and links can
    be found at: [https://github.com/anaibol/awesome-serverless](https://github.com/anaibol/awesome-serverless).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/anaibol/awesome-serverless](https://github.com/anaibol/awesome-serverless)找到一些有关无服务器开发信息和链接的有趣集合。
- en: Containerized microservices
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化的微服务
- en: The Amazon AWS infrastructure is able to create services like Lambda because
    their engineers no longer provision hardware (ie. new physical servers) when customers
    create another cloud function or API. Instead, they provision lightweight **VM
    (Virtual Machines)**. Nobody is lifting a big new metal box onto a rack when you
    sign up. Software is the new hardware.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊AWS基础设施能够创建像Lambda这样的服务，因为他们的工程师在客户创建另一个云函数或API时不再提供硬件（即新的物理服务器）。相反，他们提供轻量级的虚拟机（VM）。当您注册时，没有人会将一个大的新金属箱放到机架上。软件是新的硬件。
- en: '**Containers** aim for the same general architectural idea and advantages that
    virtualized servers provide —to mass produce virtualized, independent, machines.
    The main difference is that while a VM provides its own OS (typically called a
    **Hypervisor**), a container requires a host OS to provide actual kernel services
    (such as a filesystem, other devices, and resource management and scheduling)
    as they do not need to carry around their own OS but operate parasitically on
    a host OS containers are very light, using fewer (host) resources and able to
    be started up much more quickly. In this section, we''ll go over how any developer
    can use **Docker**, a leading container technology, to cheaply manufacture and
    manage many virtualized servers.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的目标是提供与虚拟化服务器提供的相同的一般架构思想和优势——大规模生产虚拟化的独立机器。主要区别在于，虽然虚拟机提供自己的操作系统（通常称为**Hypervisor**），但容器需要主机操作系统提供实际的内核服务（例如文件系统、其他设备以及资源管理和调度），因为它们不需要携带自己的操作系统，而是寄生在主机操作系统上，容器非常轻便，使用更少的（主机）资源，并且能够更快地启动。在本节中，我们将介绍任何开发人员如何使用领先的容器技术Docker来廉价地制造和管理许多虚拟化服务器。
- en: This is a good StackOverflow discussion on the distinctions between virtual
    environments at: [https://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-normal-virtual-machine](https://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-normal-virtual-machine).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于虚拟环境之间区别的很好的StackOverflow讨论：[https://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-normal-virtual-machine](https://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-normal-virtual-machine)。
- en: 'This image from the Docker website ([http://www.docker.com/](http://www.docker.com/))
    gives some information on how, and why, the Docker team feels their technology
    fits into the future of application development:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Docker网站（[http://www.docker.com/](http://www.docker.com/)）上的这张图片提供了一些关于Docker团队如何以及为什么他们认为他们的技术适合未来应用程序开发的信息：
- en: '![](img/b059cb0b-cc0d-4ed2-b400-361e6bc1b0c7.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b059cb0b-cc0d-4ed2-b400-361e6bc1b0c7.png)'
- en: 'Recalling our discussion of 4-Tier architectures, here we can see that developers
    asked themselves a question: if my application is composed out of many independently
    developed, tested, deployed, and managed communicating services in the cloud running
    on their own infrastructure, couldn''t we just do the same with our "local" services
    and give each its own isolated container so that those can be independently developed,
    tested, deployed, and so forth? Reducing the cost of implementing change is the
    goal of containerization, and of microservices. A container generating one localized,
    independent service with protected local memory that can be started and restarted
    quickly, tested individually, and fail quietly fits right into a microservices
    architecture:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们对4层架构的讨论，我们可以看到开发人员问自己一个问题：如果我的应用程序由许多在云中独立开发、测试、部署和管理的通信服务组成，那么我们是否可以用“本地”服务做同样的事情，并为每个服务提供独立的容器，以便可以独立开发、测试、部署等？减少实施变更成本是容器化和微服务的目标。一个容器生成一个本地化的、独立的服务，具有受保护的本地内存，可以快速启动和重新启动，单独测试，并且可以静默失败，完全适合微服务架构：
- en: Clearly defined areas of responsibility
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确定义的责任领域
- en: Isolated dependencies and state
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离的依赖和状态
- en: Processes are disposable
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程是可丢弃的
- en: Lightweight and easy to start and replicate
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级且易于启动和复制
- en: Graceful termination with zero application downtime
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅的终止，零应用程序停机时间
- en: Can be independently tested
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以独立测试
- en: Can be independently monitored
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以独立监视
- en: Getting started with Docker
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Docker
- en: 'The Docker ecosystem has three main components. Here''s what the documentation
    says:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Docker生态系统有三个主要组件。文档中是这样说的：
- en: '**Docker containers**. A Docker container holds everything that is needed for
    an application to run. Each container is created from a Docker image. Docker containers
    can be run, started, stopped, moved, and deleted. Each container is an isolated
    and secure application platform. You can consider Docker containers as the run
    portion of the Docker framework.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器。 Docker容器包含应用程序运行所需的一切。每个容器都是从Docker镜像创建的。Docker容器可以运行、启动、停止、移动和删除。每个容器都是一个独立和安全的应用程序平台。您可以将Docker容器视为Docker框架的运行部分。
- en: '**Docker images**. The Docker image is a template, for example, an Ubuntu operating
    system with Apache and your web application installed. Docker containers are launched
    from images. Docker provides a simple way to build new images or update the existing
    images. You can consider Docker images to be the build portion of the Docker framework.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像。 Docker镜像是一个模板，例如，一个安装了Apache和您的Web应用程序的Ubuntu操作系统。 Docker容器是从镜像启动的。Docker提供了一种简单的方法来构建新的镜像或更新现有的镜像。您可以将Docker镜像视为Docker框架的构建部分。
- en: '**Docker Registries**. Docker registries hold images. These are public (or
    private!) stores that you can upload or download images to and from. These images
    can be images you create yourself or you can also make use of images that others
    have previously created. You can consider Docker registries to be the share portion
    of the Docker framework. You create images of applications to be run in any number
    of isolated containers, sharing those images with others if you’d like. The most
    popular is **Docker Hub** ([https://hub.docker.com/](https://hub.docker.com/)),
    but you can also operate your own.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker注册表**。Docker注册表保存镜像。这些是公共（或私有！）存储，你可以上传或下载镜像。这些镜像可以是你自己创建的，也可以使用其他人之前创建的镜像。你可以将Docker注册表视为Docker框架的共享部分。你可以创建应用程序的镜像，以在任意数量的隔离容器中运行，并与其他人共享这些镜像。最受欢迎的是**Docker
    Hub**（[https://hub.docker.com/](https://hub.docker.com/)），但你也可以自己操作。'
- en: The concept of composing Node applications out of many independent processes
    naturally aligns with the philosophy behind Docker. Docker containers are sandboxed,
    unable to without your knowledge execute instructions on their host. They can
    expose a port to their host OS, however, allowing many independent virtual containers
    to be linked together into a larger application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将Node应用程序组合成许多独立的进程的概念自然与Docker背后的哲学相吻合。Docker容器是沙箱化的，无法在没有你的知识的情况下在其主机上执行指令。然而，它们可以向它们的主机操作系统公开一个端口，从而允许许多独立的虚拟容器链接到一个更大的应用程序中。
- en: It will be a good idea to learn a little about how to find information about
    your OS, which ports are being used, by which processes, and so on. We've mentioned
    HTOP previously, and you should familiarize yourself with at least gathering network
    statistics—most OS's offer a `netstat` utility, useful to discover which ports
    are open and who is listening on them. For example, `netstat -an | grep -i "listen"`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一下如何找到关于你的操作系统的信息，哪些端口正在使用，由哪些进程使用等是个好主意。我们之前提到过HTOP，你应该至少熟悉一下如何收集网络统计信息——大多数操作系统都提供了`netstat`实用程序，用于发现哪些端口是打开的，谁在监听它们。例如，`netstat
    -an | grep -i "listen"`。
- en: 'Download and install **Docker Community Edition** ([https://www.docker.com/community-edition](https://www.docker.com/community-edition))
    or the **Docker Toolbox** ([https://docs.docker.com/toolbox/overview/](https://docs.docker.com/toolbox/overview/)). A
    comparison between the two can be found at: [https://docs.docker.com/docker-for-mac/docker-toolbox/](https://docs.docker.com/docker-for-mac/docker-toolbox/).
    If you''re using the toolbox, select the Docker Quickstart Terminal when prompted,
    which will spawn a terminal and install the necessary components on your system. 
    The installation process might take while, so don''t panic! When done, you should
    see something like the following in your terminal:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装**Docker社区版**（[https://www.docker.com/community-edition](https://www.docker.com/community-edition)）或**Docker工具箱**（[https://docs.docker.com/toolbox/overview/](https://docs.docker.com/toolbox/overview/)）。可以在以下网址找到两者之间的比较：[https://docs.docker.com/docker-for-mac/docker-toolbox/](https://docs.docker.com/docker-for-mac/docker-toolbox/)。如果你使用工具箱，在提示时选择Docker
    Quickstart Terminal，这将在你的系统上生成一个终端并安装必要的组件。安装过程可能需要一段时间，所以不要惊慌！完成后，你应该在终端中看到类似以下的内容：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the name of the Docker machine is "default".
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意Docker机器的名称是"default"。
- en: 'To get a sense of how images work, run the `docker run hello-world` command.
    You should see the machine pull an image and containerize it—full details of what
    is happening will be printed. If you now run the command docker images, you''ll
    see something like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解镜像是如何工作的，运行`docker run hello-world`命令。你应该看到机器拉取一个镜像并将其容器化——正在发生的详细信息将被打印出来。如果现在运行`docker
    images`命令，你会看到类似这样的东西：
- en: '![](img/16dc8107-f6a1-46e7-9566-86da2260fe2e.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16dc8107-f6a1-46e7-9566-86da2260fe2e.png)'
- en: 'This command will tell you something about your Docker installation: `docker
    info`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将告诉你一些关于你的Docker安装的信息：`docker info`。
- en: A Docker container runs an image of your application. You can create these images
    yourself, of course, but there does exist a large ecosystem of the existing images.
    Let’s create our own image of a Node server running Express.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器运行你的应用程序的镜像。当然，你可以自己创建这些镜像，但现有的镜像生态系统也存在着大量的镜像。让我们创建一个运行Express的Node服务器的自己的镜像。
- en: First, we’ll need to build an application to run. Create a folder to put your
    application files into. Within that folder, create an `/app` folder; this is where
    we will put our server files. As with all Node applications, we’ll need to create
    a `package.json` file. Enter the `/app` folder and `run npm init`, giving this
    package a name of "docker-example". Then, install Express with `npm i express`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要构建一个要运行的应用程序。创建一个文件夹来放置你的应用程序文件。在该文件夹中，创建一个`/app`文件夹；这是我们将放置服务器文件的地方。与所有Node应用程序一样，我们需要创建一个`package.json`文件。进入`/app`文件夹并运行`npm
    init`，给这个包一个名字"docker-example"。然后，用`npm i express`安装Express。
- en: 'Now, create a simple Express server and save it to `app/index.js`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个简单的Express服务器并将其保存到`app/index.js`中：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Go ahead and start the server:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 继续启动服务器：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can now point your browser to your host on port `8087` and see a unique
    message similar to `Service #1513534970093 responding` displayed. Great. There
    is a reason for creating a unique message (via `Date.now()`) that will make more
    sense later when we discuss scaling services. For now, let''s build these files
    into a container using Docker.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，你可以将浏览器指向端口`8087`的主机，看到类似`Service #1513534970093 responding`的唯一消息显示。很好。创建一个唯一消息（通过`Date.now()`）是有原因的，当我们讨论服务扩展时，这将更有意义。现在，让我们使用Docker将这些文件构建成一个容器。'
- en: Creating a Dockerfile
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Dockerfile
- en: Our goal is to describe the environment this application executes within, now,
    so that Docker can reproduce that environment in a container. Also, we want to
    add the source files of our application to run in this newly virtualized environment.
    Docker can act as a builder, in other words, following the instructions you provide
    on how to build an image of your application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是描述此应用程序在其中执行的环境，以便Docker可以在容器中复制该环境。此外，我们希望将我们应用程序的源文件添加到这个新的虚拟化环境中运行。换句话说，Docker可以充当构建器，遵循您提供的关于如何构建应用程序图像的指令。
- en: To begin with, you should have a folder containing your application files. This
    is your source code repository, which your docker image will build within. As
    mentioned, a Dockerfile is a list of instructions for building an application.
    A Dockerfile describes a build process. What you will normally declare in a Dockerfile
    is the OS version the container will run, and any OS installations you might need
    done, such as Node.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该有一个包含应用程序文件的文件夹。这是您的源代码存储库，您的docker图像将在其中构建。如前所述，Dockerfile是用于构建应用程序的指令列表。Dockerfile描述了构建过程。您通常会在Dockerfile中声明容器将运行的操作系统版本，以及您可能需要完成的任何操作系统安装，例如Node。
- en: 'Create a `Dockerfile` file (no extension):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Dockerfile`文件（无扩展名）：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You see in the this file various directives, and there are several others you
    might use for more complex builds. We'll keep it simple to start. To go deeper
    into Dockerfiles, you can run through the full documentation at: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此文件中看到各种指令，并且还有一些其他指令可用于更复杂的构建。我们将从简单开始。要深入了解Dockerfile，可以通过完整的文档运行：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。
- en: The `FROM` directive is used to set the base image you will build upon. We will
    be building upon `node:9`, an image containing the latest Node. More complex images
    are usually included here, typically built around common patterns. For example,
    this image implements the **MEAN (Mongo Express Angular Node)** stack: [https://hub.docker.com/r/meanjs/mean/](https://hub.docker.com/r/meanjs/mean/).
    `FROM` should be the very first directive in a Dockerfile.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令用于设置您将构建的基本图像。我们将基于`node:9`构建，这是包含最新Node的图像。更复杂的图像通常包括在此处，通常围绕常见模式构建。例如，此图像实现了**MEAN（Mongo
    Express Angular Node）**堆栈：[https://hub.docker.com/r/meanjs/mean/](https://hub.docker.com/r/meanjs/mean/)。`FROM`应该是Dockerfile中的第一个指令。'
- en: You can set (optional) metadata for your image via `LABEL`. There can be multiple
    `LABEL` declarations. This is useful for version management, credits, and so forth.
    We also set some environment variables (`ENV`) for the Node process (exposed as
    you would expect in `process.env`).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`LABEL`为图像设置（可选的）元数据。可以有多个`LABEL`声明。这对于版本管理、信用等非常有用。我们还为Node进程设置了一些环境变量（`ENV`），如您在`process.env`中所期望的那样。
- en: We state our working directory (`WORKDIR`) for the application, and `COPY` all
    the local files on our machine into the filesystem of the container; the container
    is isolated and has no access to a filesystem outside of itself, so we need to
    build its filesystem from ours.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为应用程序指定工作目录（`WORKDIR`），并将我们机器上的所有本地文件`COPY`到容器的文件系统中；容器是隔离的，无法访问自身以外的文件系统，因此我们需要从我们的文件系统构建其文件系统。
- en: Now, we establish startup directives. `RUN npm i` to install `package.json`,
    `EXPOSE` the port our server runs on (`8087`) to the outside world (again, containers
    are isolated and cannot expose internal ports without permission), and run the
    command (`CMD`) `npm start`. You may set multiple `RUN` and `CMD` directives,
    whatever is necessary to start your application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们建立启动指令。`RUN npm i`安装`package.json`，`EXPOSE`我们服务器运行的端口（`8087`）到外部世界（再次，容器是隔离的，没有权限的情况下无法暴露内部端口），并运行命令（`CMD`）`npm
    start`。您可以设置多个`RUN`和`CMD`指令，以启动应用程序所需的任何内容。
- en: We're now ready to build and run a container.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备构建和运行容器。
- en: Running containers
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'From within the directory containing your Dockerfile, run this command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含Dockerfile的目录中运行以下命令：
- en: '`docker build -t mastering-docker .` (note trailing dot).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build -t mastering-docker .`（注意末尾的句点）。'
- en: 'Docker will now fetch all base dependencies and build your image according
    to your directives:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Docker现在将获取所有基本依赖项并根据您的指令构建图像：
- en: '![](img/90224448-516e-4071-b6f7-c67b93255a3a.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90224448-516e-4071-b6f7-c67b93255a3a.png)'
- en: 'You just created your first Docker image! To see your image, use `docker images`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了您的第一个Docker图像！要查看您的图像，请使用`docker images`：
- en: '![](img/fedf510f-94b0-49f4-940e-54b251fbb325.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fedf510f-94b0-49f4-940e-54b251fbb325.png)'
- en: Here, we see the image we created—`mastering-docker`—and the image our image
    was based on—`node:9`. Note how the colon is used to created tagged versions of
    images -- we are ultimately using the **node** image tagged **9**. More on versioning
    later.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们创建的图像`mastering-docker`，以及我们的图像基于的图像`node:9`。请注意冒号是用于创建图像的标记版本 --
    我们最终使用的是**node**图像标记为**9**。稍后再讨论版本控制。
- en: 'The next step is to containerize and run the image. Use this command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将图像容器化并运行。使用此命令：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If all goes well, you will be able to list your running Docker process with
    the `docker ps` command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将能够使用`docker ps`命令列出正在运行的Docker进程：
- en: '![](img/0ccc76ea-dc15-4093-b26e-094bd36abb94.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ccc76ea-dc15-4093-b26e-094bd36abb94.png)'
- en: Recall the `EXPOSE 8087` directive? We needed to map the port our container
    exposed to the local OS network interface, which we flagged in the run command
    with `-p 8088:8087`, and which mapping we can see in the screenshot above under
    `PORTS`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下`EXPOSE 8087`指令？我们需要将容器暴露的端口映射到本地操作系统网络接口，我们在运行命令中使用`-p 8088:8087`标记了这个映射，我们可以在上面的屏幕截图中看到`PORTS`下的映射。
- en: The `-d` flag indicates to Docker that we'd like to run the container in detached
    mode. This is probably what you want to do, running your container in the background.
    Without this flag, you will terminate the container when you terminate your terminal
    session.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`标志指示Docker我们想要以分离模式运行容器。这可能是您想要做的，将容器在后台运行。没有这个标志，当您终止终端会话时，容器将终止。'
- en: You are now running a Node server in a container completely isolated from your
    local machine. Try it out by navigating a browser to `localhost:8088`. It's pretty
    great to be able to construct entirely isolated builds, with completely different
    operating systems, databases, software versions and so forth all on you local
    machine, knowing that you can take that exact same container and deploy it into
    a data center without changing a thing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在正在一个完全与本地机器隔离的容器中运行一个Node服务器。通过在浏览器中导航到`localhost:8088`来尝试它。能够构建完全隔离的构建，具有完全不同的操作系统、数据库、软件版本等，然后知道您可以将完全相同的容器部署到数据中心而不改变任何内容，这是非常棒的。
- en: 'Here are some more useful commands:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些更有用的命令：
- en: 'Delete a container: `docker rm <containerid>`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个容器：`docker rm <containerid>`
- en: Delete all containers: `docker rm $(docker ps -a -q)`
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除所有容器：`docker rm $(docker ps -a -q)`
- en: 'Delete an image: `docker rmi <imageid>`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个镜像：`docker rmi <imageid>`
- en: Delete all images: `docker rmi $(docker images -q)`
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除所有镜像：`docker rmi $(docker images -q)`
- en: 'Stop or start a container: `docker stop (or start) <containerid>`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止或启动一个容器：`docker stop (或 start) <containerid>`
- en: Orchestrating Containers with Kubernetes
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes编排容器
- en: A microservices-driven architecture is composed of independent services. We've
    just looked at how containers can be used to isolate distinct services. Now, the
    question is how to manage and coordinate these 10, 20, 100, 1,000 service containers?
    "By hand" doesn't seem like the right approach. **Kubernetes** automates container
    orchestration, helping you deal with questions of deployment and scaling and fleet
    health. Developed by Google, it is a mature technology used in Google's own incomprehensibly
    massive data centers to orchestrate millions of containers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务的架构由独立的服务组成。我们刚刚看到容器如何用于隔离不同的服务。现在，问题是如何管理和协调这10、20、100、1,000个服务容器？“手动”似乎不是正确的方法。Kubernetes自动化容器编排，帮助您处理部署、扩展和集群健康的问题。由Google开发，它是一种成熟的技术，用于在Google自己的庞大数据中心中编排数百万个容器。
- en: We'll install an application, **Minikube**, that runs a single-node Kubernetes
    cluster inside a VM on your local machine, so you can test develop a Kubernetes
    cluster locally before deploying. As the configuration of the cluster you do locally
    mirrors a "real" Kubernetes cluster, once you are satisfied, you can deploy your
    definitions to Kubernetes in production without any changes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装一个名为Minikube的应用程序，它在本地机器的VM中运行一个单节点Kubernetes集群，因此您可以在部署之前在本地测试开发Kubernetes集群。由于您在本地进行的集群配置与“真实”的Kubernetes集群镜像，一旦满意，您可以在生产环境中部署您的定义而不需要进行任何更改。
- en: Creating a basic Kubernetes cluster
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的Kubernetes集群
- en: You'll need some sort of VM driver for Minikube, and by default, Minikube uses
    **VirtualBox**. You can find installation instructions at: [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
    VirtualBox stands on its own as a free hypervisor, which is used to power other
    useful developer tools, like **Vagrant**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要某种VM驱动程序来运行Minikube，默认情况下，Minikube使用VirtualBox。您可以在以下网址找到安装说明：[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)。VirtualBox作为免费的hypervisor独立存在，用于支持其他有用的开发人员工具，如Vagrant。
- en: Now, we'll install `kubectl` (think of it as "Kube Control"), the Kubernetes
    command-line interface. Follow the instructions at: [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将安装kubectl（将其视为“Kube Control”），即Kubernetes命令行界面。请按照以下说明操作：[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)。
- en: Finally, we install Minikube: [https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们安装Minikube：[https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/)。
- en: 'Start the cluster up with `minikube start` (this can take a while, so be patient).
    The output is sufficiently descriptive: you will be starting a VM, getting an
    IP address, and building a Kubernetes cluster. The output should end with something
    like Kubectl is now configured to use the cluster. You can always check its status
    with `minikube status`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`minikube start`启动集群（这可能需要一段时间，所以请耐心等待）。输出足够描述：您将启动一个虚拟机，获取一个IP地址，并构建一个Kubernetes集群。输出应该以类似“Kubectl
    is now configured to use the cluster”的内容结束。您可以随时使用`minikube status`检查其状态：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To see that kubectl is configured to communicate with Minikube, try `kubectl
    get nodes`, which should show that the Minkube machine 'minikube' is 'Ready'.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看kubectl是否配置为与Minikube通信，请尝试`kubectl get nodes`，这应该显示Minkube机器'minikube'处于'就绪'状态。
- en: This VM is being run via VirtualBox. Open the Virtualbox Manager on your machine.
    You should see a machine named "minikube" listed. If you do, great; a Kubernetes
    cluster is running on your machine!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此虚拟机是通过VirtualBox运行的。在您的机器上打开Virtualbox Manager。您应该会看到列出了名为"minikube"的机器。如果是这样，太好了；Kubernetes集群正在您的机器上运行！
- en: You can test different Kubernetes versions with Minikube. To get available versions,
    run `minikube get-k8s-versions`. Once you have a version, start Minikube on that
    version with `minikube start --kubernetes-version v1.8.0`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Minikube测试不同的Kubernetes版本。要获取可用版本，请运行`minikube get-k8s-versions`。一旦有了版本，使用`minikube
    start --kubernetes-version v1.8.0`在该版本上启动Minikube。
- en: Now, we'll use Kubernetes to deploy the "hello world" server we earlier containerized
    with Docker. Usefully, Minikube manages its own Docker daemon and local repository.
    We'll use that to build what follows. First, link into Minikube's Docker with
    `eval $(minikube docker-env)`. When you want to return control back to your host
    Docker daemon, try `eval $(minikube docker-env -u)`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Kubernetes来部署我们之前使用Docker容器化的“hello world”服务器。有用的是，Minikube管理自己的Docker守护程序和本地存储库。我们将使用它来构建接下来的内容。首先，使用`eval
    $(minikube docker-env)`链接到Minikube的Docker。当您想要将控制权返回到主机Docker守护程序时，请尝试`eval $(minikube
    docker-env -u)`。
- en: 'Return to the folder containing our server and build our Docker image (note
    trailing dot):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到包含我们服务器的文件夹并构建我们的Docker镜像（注意末尾的点）：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When that process has completed, you should see something like this displayed
    in your terminal:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当该过程完成后，您应该在终端中看到类似这样的显示：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One thing that you may have noted is the `:v1` suffix on our image name. We
    saw that earlier when we declared Node in our Dockerfile (remember the `FROM Node:9`
    directive)? If you run `docker images`, you''ll see that tags are applied:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们的镜像名称上有 `:v1` 后缀。我们在 Dockerfile 中声明 Node 时就看到了这一点（还记得 `FROM Node:9`
    指令吗）？如果你运行 `docker images`，你会看到标签被应用了：
- en: '![](img/190bd58c-f298-4e14-9430-2cb4be0b265f.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/190bd58c-f298-4e14-9430-2cb4be0b265f.png)'
- en: Later on, if we want to release a new version of mastering-kube, we can simply
    build with a new tag, which creates an independent image. This is what you should
    do over time to manage versioning of your container images.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以后，如果我们想要发布 mastering-kube 的新版本，我们只需使用新标签构建，这将创建一个独立的镜像。这是您随着时间管理容器镜像版本的方法。
- en: 'Great, now let''s start a container with that image and **deploy** it into
    our Kubernetes cluster:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用该镜像启动一个容器，并将其**部署**到我们的 Kubernetes 集群中：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we declare a new deployment with the name `kubernetes-demo` that should
    import the `mastering-kube` image at version `v1`. If everything works, you should
    see deployment "kubernetes-demo" created in your terminal. You can list deployments
    with `kubectl get deployments`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为 `kubernetes-demo` 的新部署，应该导入版本为 `v1` 的 `mastering-kube` 镜像。如果一切正常，您应该在终端中看到部署
    "kubernetes-demo" 已创建。您可以使用 `kubectl get deployments` 列出部署：
- en: '![](img/25b518d0-d72b-4619-92dd-3650d4d7a9cf.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25b518d0-d72b-4619-92dd-3650d4d7a9cf.png)'
- en: We've just deployed a single **Pod** into a Kubernetes cluster. Pods are the
    basic organizational unit of Kubernetes, and they are an abstract wrapper around
    containers. Pods may contain one or more containers. Kubernetes manages pods,
    and Pods manage their own containers. Each Pod receives its own IP address and
    is isolated from other pods, but containers within pods are not isolated from
    each other (they can all communicate via `localhost`, for example).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在 Kubernetes 集群中部署了一个单个 **Pod**。Pod 是 Kubernetes 的基本组织单元，它们是容器的抽象包装。Pod
    可能包含一个或多个容器。Kubernetes 管理 Pod，Pod 管理它们自己的容器。每个 Pod 都有自己的 IP 地址，并且与其他 Pod 隔离，但是
    Pod 中的容器之间不相互隔离（例如，它们可以通过 `localhost` 进行通信）。
- en: A Pod presents the abstraction of a single machine running somewhere (locally,
    on AWS, in a data center) and all the containers running on that single machine.
    In this way you can have a single Kubernetes cluster running Pods located in different
    locations in the cloud. Kubernetes is an abstraction across differently located
    machine hosts that lets you orchestrate their behavior indifferent to whether
    one is a VM hosted on AWS or a laptop in your office, in the same way that you
    might use an ORM to abstract away database details, leaving you free to change
    the technical makeup of a deployment without altering configuration files.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 提供了一个抽象，即在某个地方（本地、AWS、数据中心）运行的单个机器，以及在该单个机器上运行的所有容器。通过这种方式，您可以在云中的不同位置运行
    Pod 的单个 Kubernetes 集群。Kubernetes 是跨不同位置的机器主机的抽象，它可以让您编排它们的行为，而不管它们是托管在 AWS 上的
    VM 还是您办公室的笔记本电脑，就像您可能使用 ORM 来抽象数据库细节一样，让您可以自由更改部署的技术组成，而不必更改配置文件。
- en: 'With the `kubectl get pods` command, you should now see something like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl get pods` 命令，您现在应该看到类似这样的内容：
- en: '![](img/fbda1b0e-1fa8-4d9b-a7e0-33b86dbdb59c.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbda1b0e-1fa8-4d9b-a7e0-33b86dbdb59c.png)'
- en: 'The final step is to expose this deployed pod as a service. Run this command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将此部署的 Pod 作为服务暴露出来。运行此命令：
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If successful, you should see the message service "kubernetes-demo" exposed.
    To view services, use `kubectl get services`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，您应该看到消息服务 "kubernetes-demo" 已暴露。要查看服务，请使用 `kubectl get services`：
- en: '![](img/311e19b0-e547-40f3-9ab4-bbacd6ad240e.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/311e19b0-e547-40f3-9ab4-bbacd6ad240e.png)'
- en: 'Note how we have created a load-balanced type of deployment, exposing a Kubernetes
    service mapped to our mastering-kube service (container), accessible through the
    unique IP this deployed Pod will be assigned. Let''s find that URL:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何创建一个负载均衡类型的部署的，暴露了一个映射到我们的 mastering-kube 服务（容器）的 Kubernetes 服务，可以通过为这个部署的
    Pod 分配的唯一 IP 进行访问。让我们找到那个 URL：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should get back a URL (note how Kubernetes is running its own DNS), and
    browsing to that URL, you should see something like this message:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到一个 URL（注意 Kubernetes 正在运行自己的 DNS），并浏览到该 URL，您应该看到类似这样的消息：
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Via Minikube, you can start your service in a browser in just one step: `minikube
    service kubernetes-demo`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Minikube，您可以在一个步骤中在浏览器中启动您的服务：`minikube service kubernetes-demo`。
- en: Great. However, the real magic with Kubernetes has to do with how deployments
    can be scaled and otherwise respond to network conditions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。然而，Kubernetes 的真正魔力在于部署如何扩展和响应网络条件。
- en: 'Recalling that this deployment is load balanced, let''s create multiple containers
    within the same pod sharing load (not unlike the way you might use Node''s Cluster
    module to balance load). Run the following command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下这个部署是负载均衡的，让我们在同一个 Pod 中创建多个共享负载的容器（不太像你可能会使用 Node 的 Cluster 模块来平衡负载的方式）。运行以下命令：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should get the message deployment "kubernetes-demo" scaled. Let''s make
    sure that''s true. Run `kubectl get pods` again. You should see that our deployment
    has autoscaled the number of pods that it balances:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到消息部署 "kubernetes-demo" 已扩展。让我们确保这是真的。再次运行 `kubectl get pods`。您应该看到我们的部署已经自动扩展了它平衡的
    Pod 数量：
- en: '![](img/9aa52dae-635a-44a4-a28a-fe1636e5fe9a.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9aa52dae-635a-44a4-a28a-fe1636e5fe9a.png)'
- en: 'That was easy. Let''s do a quick test to demonstrate that load is being balanced
    across more than one container. We''ll use **AB (Apache Bench)** for a quick benchmarking
    and display of responses. Use the following command against our service URL (replace
    the URL for your local service):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易。让我们进行一个快速测试，以证明负载正在跨多个容器进行平衡。我们将使用 **AB（Apache Bench）** 进行快速基准测试和响应显示。使用以下命令针对我们的服务
    URL 进行测试（用你本地服务的 URL 替换 URL）：
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'All that matters with the above is that we''ve simulated 100 calls to our server,
    which was done to check if it is responding as expected. We''ll receive output
    similar to the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的所有内容都是为了模拟对我们的服务器的100次调用，这是为了检查它是否如预期般响应。我们将收到类似以下的输出：
- en: '[PRE33]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Remember that the server we''ve scaled across 4 containers has a constant message
    with a unique timestamp?:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们已经在4个容器之间进行了缩放的服务器有一个带有唯一时间戳的常量消息：
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The variance in the responses `ab` returned proves that calls to one endpoint
    are being balanced across multiple servers/containers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`ab`返回的响应差异证明了对一个端点的调用是在多个服务器/容器之间进行负载均衡的。'
- en: If you ever find Minikube in a strange or unbalanced state, just clear its home
    directory and reinstall. For example: `rm -rf ~/.minikube; minikube start`. You
    can also delete the Kubernetes cluster entirely with `minikube delete`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现Minikube处于奇怪或不平衡的状态，只需清除它的主目录并重新安装。例如：`rm -rf ~/.minikube; minikube start`。你也可以使用`minikube
    delete`完全删除Kubernetes集群。
- en: 'While the command-line tools are extremely useful, you also have access to
    a dashboard for your Kubernetes cluster. You can start up a dashboard to monitor
    your cluster by typing `kubectl proxy` into your terminal. You''ll see something
    similar to this displayed: Starting to serve on 127.0.0.1:8001\. This points to
    the dashboard server. Open the `/ui` path on this server (`127.0.0.1:8001/ui`)
    in a browser. You should see a UI with your cluster fully described:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命令行工具非常有用，但你也可以访问Kubernetes集群的仪表板。你可以通过在终端中输入`kubectl proxy`来启动一个仪表板来监视你的集群。你会看到类似于这样的显示：`Starting
    to serve on 127.0.0.1:8001`。这指向仪表板服务器。在浏览器中打开这个服务器上的`/ui`路径（`127.0.0.1:8001/ui`），你应该会看到一个完整描述你的集群的UI：
- en: '![](img/fd87bab9-33d3-4452-b267-d953131fef11.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd87bab9-33d3-4452-b267-d953131fef11.png)'
- en: Here, we see all our pods, statuses, and so forth, in particular the 4/4 scaling
    of our Pod container. Later in the chapter, we'll go a little deeper into how
    you can use the dashboard to inspect your running clusters.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到所有的pod、状态等，特别是我们的Pod容器的4/4缩放。在本章的后面，我们将更深入地了解如何使用仪表板来检查正在运行的集群。
- en: Minikube provides a shortcut that will automatically open this dashboard: `minikube
    dashboard`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube提供了一个快捷方式，可以自动打开这个仪表板：`minikube dashboard`。
- en: Now, let's look at how to use **YAML (Yet Ain't Markup Language)** to create
    Pod declarations, avoiding the manual configuration we've been doing, and simplifying
    deployments later.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下如何使用**YAML（尚未标记语言）**来创建Pod声明，避免我们一直在做的手动配置，并简化后续的部署。
- en: Declaring Pod deployments
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明Pod部署
- en: In this section, we'll create one Pod with three containers, demonstrating both
    how managing configuration declarations using YAML files simplifies the deployment
    process, and how containers within the same Pod can communicate with each other.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个具有三个容器的Pod，演示使用YAML文件管理配置声明如何简化部署过程，以及同一Pod中的容器如何相互通信。
- en: 'In your code bundle, there will be a directory `/kubernetes` with this layout:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码包中，将有一个名为`/kubernetes`的目录，其布局如下：
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Each directory defines a Docker container which defines an Express server which
    will become containers in this Pod. We will treat each of these as an individual
    service, and demonstrate how they might communicate with each other via `localhost`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录定义了一个Docker容器，该容器定义了一个Express服务器，将成为这个Pod中的容器。我们将把这些视为单独的服务，并演示它们如何通过`localhost`相互通信。
- en: 'First, let''s look at the YAML file:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下YAML文件：
- en: '[PRE36]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This manifest is of a `kind` (`Pod`) with a specification (`spec`) defining
    three `containers`, with a shared `volume` (more on that in a second), and a `restartPolicy`
    indicating that containers should only be restarted if they exit with a failure
    code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单是一个`kind`（`Pod`）的清单，具有一个定义了三个`containers`的`spec`，一个共享的`volume`（稍后会详细介绍），以及一个`restartPolicy`，表明只有在容器以失败代码退出时才应重新启动容器。
- en: Volumes are used when containers need to share data. Within a container, data
    storage is ephemeral -- if your container is restarted, that data is lost. A shared
    volume is held external to the containers within a Pod, and therefore can persist
    data through container restarts and crashes. More importantly, many containers
    in a single Pod can write to and read from a shared volume, creating a shared
    data space. Our services will use this volume as a shared filesystem, and containers
    who wish to use it can add a mount path -- we'll see how that works in just a
    second. For more on volumes, visit: [https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器需要共享数据时，就会使用卷。在容器内部，数据存储是暂时的——如果容器重新启动，那些数据就会丢失。共享卷是在Pod内部容器之外保存的，因此可以通过容器的重新启动和崩溃来持久保存数据。更重要的是，单个Pod中的许多容器可以写入和读取共享卷，从而创建一个共享的数据空间。我们的服务将使用这个卷作为共享文件系统，希望使用它的容器可以添加一个挂载路径——我们马上就会看到它是如何工作的。有关卷的更多信息，请访问：[https://kubernetes.io/docs/concepts/storage/volumes/](https://kubernetes.io/docs/concepts/storage/volumes/)。
- en: 'To begin, navigate into the `/rerouter` folder and build the docker image: `docker
    build -t rerouter:v1 .`. Note how in the above Pod manifest this image is listed:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进入`/rerouter`文件夹并构建docker镜像：`docker build -t rerouter:v1 .`。请注意，在上面的Pod清单中列出了这个镜像：
- en: '[PRE37]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `name` for this container is `service-rerouter`, and it provides an Express
    server handling two routes:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器的`name`是`service-rerouter`，它提供了一个处理两个路由的Express服务器：
- en: When the root route is called (`/`), it will look for an `index.html` file in
    the `/public` directory.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用根路由（`/`）时，它将在`/public`目录中查找一个`index.html`文件。
- en: 'When `/rerouter` is called, it will redirect the user to another service in
    this Pod, the service listening on port `8086`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用`/rerouter`时，它将把用户重定向到这个Pod中的另一个服务，即监听端口`8086`的服务：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you look at the declaration for `service-rerouter`, you''ll see that it
    has mounted to the shared volume on the path `/app/public`. Any container in this
    Pod can now write to the shared volume and what it writes will end up in this
    container''s `/public` folder (making it available as a static file for serving).
    We create a container service that does just that:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`service-rerouter`的声明，您会看到它已经挂载到路径`/app/public`上的共享卷。此Pod中的任何容器现在都可以写入共享卷，它写入的内容将最终出现在此容器的`/public`文件夹中（可用作提供静态文件）。我们创建了一个容器服务，就是这样：
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `service-os` container will contain a Debian operating system, and will
    mount the shared volume at the path `/pod-data`. Now, any OS operation that writes
    to the filesystem will actually be writing to this shared volume. Using the system
    shell (`/bin/sh`), when this container starts up, it will `echo` an `index.html`
    file to the shared volume with the contents "Another service wrote this!". Since
    this container has nothing else to do after echoing, it will terminate. It is
    for this reason that we set our restart policy to only restart on failure -- we
    don't want this container to be endlessly restarted. This pattern of adding terminating
    "helper" services that contribute to the construction of Pod containers and then
    exit is a common one for Kubernetes deployments.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`service-os`容器将包含Debian操作系统，并将共享卷挂载到路径`/pod-data`。现在，任何写入文件系统的操作实际上都将写入此共享卷。使用系统shell（`/bin/sh`），当此容器启动时，它将向共享卷“echo”一个`index.html`文件，其中包含“另一个服务写了这个！”的内容。由于此容器在回显后没有其他事情要做，它将终止。因此，我们将重启策略设置为仅在失败时重启
    - 我们不希望此容器不断重启。添加终止的“辅助”服务，这些服务有助于构建Pod容器，然后退出的模式对于Kubernetes部署是常见的。'
- en: 'Recalling that `service-rerouter` also declared that its volume mounts `shared-data` on
    path `/app/public`, the `index.html` file generated by `service-os` will now appear
    in that folder, making it available for serving:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`service-rerouter`还声明了它的卷挂载`shared-data`在路径`/app/public`上，`service-os`生成的`index.html`文件现在将出现在该文件夹中，可用于提供服务：
- en: '[PRE40]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Go ahead and build the docker image for the application in folder `/responder` like
    you did for `/rerouter`. The `service-responder` container resolves a single route,
    `/oneroute`, returning a simple message:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并为`/responder`文件夹中的应用程序构建docker镜像，就像您为`/rerouter`一样。`service-responder`容器解析单个路由`/oneroute`，返回一个简单的消息：
- en: '[PRE41]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This container will be used to demonstrate how `service-rerouter` can redirect
    HTTP requests across the (shared) `localhost` Kubernetes has set up for this Pod.
    Since `service-responder` is bound on port `8086`, `service-rerouter` (running
    on port `8087`) can route to it via localhost:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此容器将用于演示`service-rerouter`如何跨（共享的）`localhost`重定向Kubernetes为此Pod设置的HTTP请求。由于`service-responder`绑定在端口`8086`上，`service-rerouter`（在端口`8087`上运行）可以通过localhost路由到它：
- en: '[PRE42]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, we have shown how containers within a Pod can share a common network and
    data volume. Assuming that you''ve successfully built the `rerouter:v1` and `responder:v1`
    Docker images, execute the Pod manifest with the following command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经展示了Pod内的容器如何共享共同的网络和数据卷。假设您已成功构建了`rerouter:v1`和`responder:v1`的Docker镜像，请使用以下命令执行Pod清单：
- en: '[PRE43]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see pod "three-containers" created displayed. Open up the dashboard
    with `minikube dashboard`. You should see the three-containers Pod:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到创建的Pod“three-containers”。使用`minikube dashboard`打开仪表板。您应该看到three-containers
    Pod：
- en: '![](img/a053b0b1-2e87-4362-a8bb-fedf0e1dff03.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a053b0b1-2e87-4362-a8bb-fedf0e1dff03.png)'
- en: 'Click on three-containers to bring up a description:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 单击three-containers以显示描述：
- en: '![](img/452ed631-cd9c-473f-a382-9938e77695d4.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/452ed631-cd9c-473f-a382-9938e77695d4.png)'
- en: Great, everything is running. Now, let's verify that things are working by connecting
    to our containers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，一切都在运行。现在，让我们通过连接到我们的容器来验证一切是否正常。
- en: 'Get a shell to `service-router`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`service-router`的shell：
- en: '[PRE44]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Install curl:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 安装curl：
- en: '[PRE45]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Your working directory should have a `/public` folder. There should be an `index.html`
    file in there, created by the `service-os` container. Fetch that file's contents: `cat
    public/index.html`. If everything is working you should see the message "Another
    service wrote this!", which you'll recall is what the `service-os` service created,
    via the shared volume -- a `public/index.html` file that `service-rerouter` will
    serve.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您的工作目录应该有一个`/public`文件夹。里面应该有一个`index.html`文件，由`service-os`容器创建。获取该文件的内容：`cat
    public/index.html`。如果一切正常，您应该看到消息“另一个服务写了这个！”，您会记得这是`service-os`服务创建的，通过共享卷 -
    `public/index.html`文件，`service-rerouter`将提供服务。
- en: 'Now, let''s call the `/rerouter` route, which should redirect to the `service-responder`
    server on `localhost:8086/oneroute/` and receive its response "routing service
    works!":'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用`/rerouter`路由，它应该重定向到`localhost:8086/oneroute/`上的`service-responder`服务器，并接收其响应“路由服务正常工作！”：
- en: '[PRE46]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This demonstrates how containers in the same Pod can communicate via localhost
    across port ranges, just as if their containing Pod was a single host machine.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了同一Pod中的容器如何通过本地主机跨端口范围进行通信，就像它们所包含的Pod是单个主机一样。
- en: Mesos is another option for orchestration ([http://mesos.apache.org/](http://mesos.apache.org/)),
    as is CoreOS: [https://coreos.com/](https://coreos.com/)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos是编排的另一个选择（[http://mesos.apache.org/](http://mesos.apache.org/)），CoreOS也是：[https://coreos.com/](https://coreos.com/)
- en: This just scratches the surface of how Docker and Kubernetes can be deployed
    to simplify scaling, especially on a microservice architecture. You can further 
    orchestrate your entire fleet through declarative manifests for services and deployments.
    For example, it is easy to see how the Seneca microservices we designed earlier
    might fit into Pods. It should be clear that you are now able to abstract away
    the implementation details of individual servers and begin to think declaratively,
    simply describing your desired deployment topology (replicas, volumes, recovery
    behavior, and so on) and letting Kubernetes make that a reality, which is much
    nicer than imperatively micromanaging hundreds of thousands of services.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Docker 和 Kubernetes 如何部署以简化扩展的表面。特别是在微服务架构上。您可以通过声明性清单进一步编排整个舰队的服务和部署。例如，很容易看出我们之前设计的
    Seneca 微服务如何适应 Pods。现在您可以抽象出个别服务器的实现细节，并开始以声明方式思考，简单地描述您所期望的部署拓扑（副本、卷、恢复行为等），并让
    Kubernetes 将其变为现实，这比命令式地微观管理成千上万的服务要好得多。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we did a deep dive into various architectural patterns, from
    monoliths to 4-Tier. In the process, we started to consider how we might start
    building highly dynamic applications out of microservices, exploring their general
    advantages in terms of scalability, flexibility, and maintainability. We took
    a look at the Seneca framework for microservices, whose pattern-based execution
    model is easy to construct against and follow, particularly when combined with
    the benefits of autodiscovered mesh services. Jumping into full distributed mode,
    we deployed serverless Lambda functions with Claudia, using API-Gateway to push
    a RESTful API into the AWS cloud, with always-on availability and nearly infinite
    scale at a low cost. With Docker and Kubernetes (with an assist from Minikube),
    we went deep into how to construct clusters of independent virtual machines, declaring
    and deploying Pods of containers that scale on demand.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了各种架构模式，从单体到 4 层。在这个过程中，我们开始考虑如何从微服务构建高度动态的应用程序，探索它们在可扩展性、灵活性和可维护性方面的一般优势。我们看了看微服务的
    Seneca 框架，其基于模式的执行模型易于构建和遵循，特别是在与自动发现的网格服务的优势相结合时。跳入完全分布式模式，我们使用 Claudia 部署了无服务器
    Lambda 函数，使用 API-Gateway 将 RESTful API 推送到 AWS 云中，始终可用并且成本低廉地实现了几乎无限的扩展。通过 Docker
    和 Kubernetes（在 Minikube 的帮助下），我们深入探讨了如何构建独立虚拟机的集群，声明和部署容器的 Pods，以满足需求。
- en: 'In the next and final chapter of this book, we will study possibly the most
    important skill a software developer can develop: how to test and debug your code.
    Now that we have learned to separate the logical parts of our applications out
    into independent pieces, we can start to explore the advantages of such a design
    in terms of testing, both in abstract test harnesses and live code situations.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章，我们将学习软件开发人员可能最重要的技能：如何测试和调试您的代码。现在我们已经学会将应用程序的逻辑部分分离成独立的部分，我们可以开始探索这种设计在测试方面的优势，无论是在抽象的测试工具中还是在实际的代码情况中。
