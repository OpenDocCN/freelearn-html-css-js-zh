- en: Connecting Your Alexa Skills to External APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的Alexa技能连接到外部API
- en: In this chapter, we will expand upon the basics we learned from the previous
    chapter, to improve the functionality and user experience of Alexa. We'll increase
    the functionality by learning to use external APIs to interact with services provided
    by other people. Then, we'll increase the user experience by giving our chatbot
    some memory of the existing conversation and also using a **speech synthesis markup
    language** (**SSML**) to control the way that Alexa talks to the user.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展我们在上一章中学到的基本知识，以改进Alexa的功能性和用户体验。我们将通过学习使用外部API与其他人提供的服务进行交互来增加功能。然后，我们将通过让我们的聊天机器人记住现有对话以及使用**语音合成标记语言**（**SSML**）来控制Alexa与用户交谈的方式来增加用户体验。
- en: To enable us to learn this, we're going to build a weather skill for Alexa.
    You will be able to ask for the current or five-day forecast for 200,000 cities
    across the world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够学习这一点，我们将为Alexa构建一个天气技能。您将能够要求全球200,000个城市当前或五天的天气预报。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Accessing and interacting with an external API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问和交互外部API
- en: Storing session memory using session attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话属性存储会话内存
- en: Using SSML to control the way that Alexa talks with the user
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SSML控制Alexa与用户交谈的方式
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be creating a Lambda function for our skill, and we
    will deploy it using the local development setup that we discussed in [Chapter
    2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting Started with AWS and
    Amazon CLI*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的技能创建一个Lambda函数，并使用我们在[第2章](ac448944-0559-408e-a9c4-972933a03611.xhtml)中讨论的本地开发设置来部署它，即*AWS和Amazon
    CLI入门*。
- en: We'll be using the **Open Weather Map API** to get weather data based on the
    user requests. We will go through the process of creating an account and getting
    an API key.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Open Weather Map API**根据用户请求获取天气数据。我们将通过创建账户和获取API密钥的过程。
- en: We'll use Postman to test the requests that we are going to make to the Open
    Weather Map API. It is a cross-platform app that can be installed at [getpostman.com](https://www.getpostman.com/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Postman来测试我们将要向Open Weather Map API发出的请求。这是一个跨平台的应用程序，可以在[getpostman.com](https://www.getpostman.com/)上安装。
- en: All of the code required for this chapter can be found at [http://bit.ly/chatbot-ch4](http://bit.ly/chatbot-ch4).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的所有代码都可以在[http://bit.ly/chatbot-ch4](http://bit.ly/chatbot-ch4)找到。
- en: External APIs
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部API
- en: An **Application Programming Interface** (**API**) is an interface that you
    can send requests to, and it will give you a response. These are used to let other
    people control parts of your software, whether that is getting information from
    the API database, changing a user's settings, or getting the API to send a text.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）是一个您可以发送请求的接口，它将给您一个响应。这些用于让其他人控制您的软件的部分，无论是从API数据库获取信息、更改用户的设置，还是让API发送文本。'
- en: They are a very powerful tool for developers, giving you access to more data
    and services than you could ever gather or build on your own.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是开发者的非常强大的工具，为您提供比您自己收集或构建更多的数据和服务的访问权限。
- en: External APIs don't have to be built by someone else. If you have a system that
    you want to access from the chatbot, you can add API access, or you might already
    have an API built for it. Using an API to separate sections of your code or company
    can be a good way to allow and improve modularization.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 外部API不必由他人构建。如果您有一个希望从聊天机器人访问的系统，您可以添加API访问，或者可能已经为它构建了一个API。使用API来分离代码或公司的部分可以是一个允许并改进模块化的好方法。
- en: Open Weather Map API
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Open Weather Map API
- en: The Open Weather Map API is a very powerful API that lets you get the current
    weather as well as the weather forecast for 200,000 cities around the world. The
    best part is that there is a free tier that allows you to make 60 requests a minute
    about current weather and five-day forecasts. This allows us to develop an Alexa
    Skill that uses real-world data without subscribing to a monthly fee.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Open Weather Map API是一个非常强大的API，让您能够获取全球200,000个城市的当前天气以及天气预报。最好的部分是，有一个免费层，允许您每分钟进行60次关于当前天气和五天预报的请求。这使得我们能够开发一个使用真实世界数据而不需要订阅月费费用的Alexa技能。
- en: To access this API, we need to create an account to get an API key. Go to [OpenWeatherMap.org](https://home.openweathermap.org)
    and go to Sign Up in the upper-right corner of the page. Enter your details, read
    the terms and conditions, and sign up. You'll then be prompted to give the reason
    that you are using the API. There's no *Alexa* option, so you can choose Mobile
    apps development, as that is the closest to our real usage.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此API，我们需要创建一个账户以获取API密钥。访问[OpenWeatherMap.org](https://home.openweathermap.org)，然后在页面右上角点击“注册”。输入您的详细信息，阅读条款和条件，然后注册。接下来，您将被提示说明您使用API的原因。没有“Alexa”选项，因此您可以选择移动应用开发，因为这最接近我们的实际使用。
- en: 'Now that you''re logged in, you can access your API key. This is used on any
    request you make to the API so that it can check that you have the right permissions
    for making the request. Navigate to API keys, and find the Default key for your
    account. We''ll be using that key throughout this project to make sure that you
    can find it again:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已登录，您可以访问您的API密钥。在您向API发出的任何请求中都会使用此密钥，以便它可以检查您是否有权发出请求。导航到API密钥，找到您账户的默认密钥。我们将在此项目中使用该密钥，以确保您可以再次找到它：
- en: '![](img/5d8aea21-53b3-47ae-be0c-29d82ddbaf9d.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d8aea21-53b3-47ae-be0c-29d82ddbaf9d.png)'
- en: OpenWeatherMap API key
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWeatherMap API密钥
- en: With our API key, we can now look at the requests we can make. On the API page,
    there is a list of different APIs, but the ones that we have access to are Current
    weather data and 5 day / 3-hour forecast. Underneath each of these sections is
    a button to go to the API doc, and we're going to look at the API docs for Current
    weather data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的API密钥，我们现在可以查看我们可以发出的请求。在API页面上，有一个不同API的列表，但我们有权访问的是当前天气数据和5天/3小时预报。在每个部分下方都有一个按钮可以进入API文档，我们将查看当前天气数据的API文档。
- en: 'There are three ways to request the data on the Current weather data API: Call
    current weather data for one location, Call current weather data for several cities,
    and Bulk downloading. We''re only going to be getting data for one location at
    a time.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Current weather data API上有三种方式请求数据：调用一个地点的当前天气数据，调用多个城市的当前天气数据，以及批量下载。我们每次只会获取一个地点的数据。
- en: Within the Call current weather data for one location section, there are also
    a few different ways to select the area. You can provide the city name, city ID,
    geographic coordinates, or the ZIP code. The user is going to be telling us a
    city name, so it makes the most sense to use that data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在“调用一个地点的当前天气数据”部分中，也有几种不同的方式来选择区域。您可以提供城市名称、城市ID、地理坐标或ZIP代码。用户将告诉我们一个城市名称，因此使用这些数据最有意义。
- en: 'There are two ways to get the current weather data for a city by name:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以通过城市名称获取当前天气数据：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Whenever we call either of these endpoints, we will get a response in a predefined
    format. It is good to know how the data will be returned so we can deal with it
    properly inside our skill. The Weather parameters in API respond section of the
    web page gives us examples of responses, as well as a list of the features, with
    a short description of each. This is an example of the response that can come
    back from a request:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们调用这些端点中的任何一个时，我们都会以预定义的格式获得响应。了解数据将如何返回，这样我们就可以在我们的技能内部正确处理它。网页上的API响应部分提供了响应示例，以及一个功能列表，每个功能都有简短描述。这是一个请求可能返回的响应示例：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating our weather skill
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的天气技能
- en: 'Creating the weather skill is going to follow the same steps as the previous
    skills that we have created. This is a great process to follow whenever you are
    creating any new Alexa skill. To recap the process, it is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建天气技能将遵循我们之前创建的技能相同的步骤。这是一个在创建任何新的Alexa技能时都值得遵循的绝佳流程。为了回顾这个过程，它如下所示：
- en: Create a conversational flow from perfect conversations
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从完美的对话中创建对话流程
- en: Create the skill on Alexa Skills Kit, including all intents, slots, and utterances
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Alexa Skills Kit上创建技能，包括所有意图、槽位和表述
- en: Create the Lambda to handle the requests
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Lambda来处理请求
- en: Test the skill
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试技能
- en: Improve the skill
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升技能
- en: Conversation flow design
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话流程设计
- en: 'Most of the conversations that the users will have with this skill are quite
    simple. There are only really two things that the user can ask about: the location
    and the data for the forecast. Here is an example of a perfect conversation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将与该技能进行的对话大多数都很简单。用户真正可以询问的只有两件事：位置和预报数据。以下是一个完美的对话示例：
- en: '![](img/02458ac1-95bd-4e64-9bed-a0b0c17cd516.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02458ac1-95bd-4e64-9bed-a0b0c17cd516.png)'
- en: Weather conversation
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 天气对话
- en: The interesting thing about this conversation is that both the questions are
    similar. What is the weather in {location} {date}?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对话的有趣之处在于两个问题都很相似。{位置} {日期}的天气怎么样？
- en: 'This means that we can handle them both with a single intent. That intent needs
    to check whether they have given a location and a date and then use those two
    things to call the API. The flow diagram for this intent will look as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以用单个意图来处理它们。这个意图需要检查他们是否提供了位置和日期，然后使用这两个东西来调用API。这个意图的流程图将如下所示：
- en: '![](img/23161391-e49a-459b-ba12-5883e114a3cf.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23161391-e49a-459b-ba12-5883e114a3cf.png)'
- en: Weather flow diagram
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 天气流程图
- en: The difference between this flow and the flows that we've worked with before
    is that the user can go through one intent multiple times in one conversation,
    usually with different slot values. We could build separate intents for `current
    weather`, `weather change Date`, and `weather change location`, but they would
    all do similar things.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前工作过的流程相比，这个流程的不同之处在于用户可以在一次对话中多次通过一个意图，通常带有不同的槽位值。我们可以为“当前天气”、“天气变化日期”和“天气变化位置”构建单独的意图，但它们都会做类似的事情。
- en: Creating the skill on Alexa Skills Kit
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Alexa Skills Kit上创建技能
- en: We need to get started using the Alexa Skills Kit developer console. Click the
    Create Skill button, name your skill, and select Custom as the skill type.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开始使用Alexa Skills Kit开发者控制台。点击创建技能按钮，给你的技能命名，并选择自定义作为技能类型。
- en: The first thing that we do whenever we create a new skill adds an invocation
    phrase.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个新技能时，我们首先添加一个调用短语。
- en: Doing it as soon as you create the skill means that you don't forget to fill
    it in later. You can change the phrase at any point before you publish your skill.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建技能时立即执行意味着你不会忘记稍后填充它。你可以在发布技能之前随时更改短语。
- en: Next, we need to create our `getWeather` intent. Add a new custom intent called
    `getWeather` and then we can start filling the intent out.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的`getWeather`意图。添加一个名为`getWeather`的新自定义意图，然后我们可以开始填充意图。
- en: 'Users are going to trigger this intent with lots of different utterances. We''re
    also going to learn how to populate slots from the user utterance. Start by adding
    our two slots to the intent, `location` and `date`. The slot type for location
    can be AMAZON.US_CITY, and data can be AMAZON.DATE. You can select `GB_CITY`,
    `AT_CITY`, `DE_CITY`, or `EUROPE_CITY` if you want a better city recognition for
    your area:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将使用许多不同的语句来触发这个意图。我们还将学习如何从用户语句中填充槽位。首先，将我们的两个槽位添加到意图中，“位置”和“日期”。位置槽位的类型可以是AMAZON.US_CITY，数据可以是AMAZON.DATE。如果你想在你所在地区获得更好的城市识别，可以选择`GB_CITY`、`AT_CITY`、`DE_CITY`或`EUROPE_CITY`：
- en: '![](img/0a23cab3-658d-41b0-8641-f950cd9bf8a2.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a23cab3-658d-41b0-8641-f950cd9bf8a2.png)'
- en: Intent slots
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 意图槽位
- en: With the slots created, we can create our utterances. These utterances will
    be different than our normal utterances, as we need to fill the slots at the same
    time. This can be demonstrated with an utterance such as `what is the weather
    like in London`. The slot that we are trying to fill is a `location` with the
    value of `London`. To capture this slot, we can use a curly brace method where
    the intent becomes `what is the weather like in {location}`. This means that whatever
    value is typed instead of `{location}` will be captured and stored in the location
    slot.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建好槽位后，我们可以创建我们的语句。这些语句将不同于我们的常规语句，因为我们需要在同一时间填充槽位。这可以通过一个如“伦敦的天气怎么样”这样的语句来演示。我们试图填充的槽位是一个值为“伦敦”的“位置”。为了捕获这个槽位，我们可以使用花括号方法，其中意图变为“伦敦的天气怎么样{位置}”。这意味着在花括号“{位置}”处输入的任何值都将被捕获并存储在位置槽中。
- en: 'This can be done for other similar utterances. `What about tomorrow` becomes
    `what about {date}` and an utterance of `what is the weather like tomorrow in
    New York` becomes `what is the weather like {date} in {location}`. This capture
    of slots from the initial utterance is very powerful, as it means that we don''t
    have to ask the user for the value of each slot. Asking a series of questions
    like that results in a very unnatural conversation. Here are a few examples of
    sample utterances:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以用于其他类似的语句。“明天怎么样”变为“关于{日期}”，而一个“纽约明天的天气怎么样”的语句变为“{日期}在{位置}的天气怎么样”。从初始语句中捕获槽位的功能非常强大，因为它意味着我们不必询问用户每个槽位的值。提出一系列这样的问题会导致非常不自然的对话。以下是一些示例样本语句：
- en: '![](img/5fcc1505-d45c-44fb-adf4-9c19d671c8a6.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5fcc1505-d45c-44fb-adf4-9c19d671c8a6.png)'
- en: Get weather utterances
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 获取天气语句
- en: With the intent slots and utterances completed, we can get the skill ID from
    the Endpoint section before moving on to creating the Lambda to handle the requests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成意图槽位和话语之后，我们可以在创建处理请求的Lambda之前，从端点部分获取技能ID。
- en: Building Lambda to handle the requests
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Lambda处理请求
- en: To create our Lambda, we can create a new folder within our `Lambdas` folder
    and call it `weatherGods`. Inside that folder, we can create an `index.js` file
    in which we will create our handler. To start, copy the text from the `boilerplate
    Lambda` folder in this chapter's code repository. We also need to run `npm init`
    so that we can install `npm` packages later on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的Lambda函数，我们可以在`Lambdas`文件夹内创建一个新的文件夹，并将其命名为`weatherGods`。在这个文件夹内，我们可以创建一个`index.js`文件，在其中我们将创建我们的处理程序。首先，从本章代码库中的`boilerplate
    Lambda`文件夹中复制文本。我们还需要运行`npm init`，以便我们稍后可以安装`npm`包。
- en: Before starting on the main code, we need to modify our `LaunchRequestHandler`.
    This can be done by changing the `speechText` variable. For this skill, we can
    enter a response message of `"You may ask the weather gods about the weather in
    your city or for a weather forecast"`. This prompts the user to say a phrase that
    will trigger the `getWeather` intent.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写主要代码之前，我们需要修改我们的`LaunchRequestHandler`。这可以通过更改`speechText`变量来完成。对于这个技能，我们可以输入一个响应消息“你可以向天气之神询问你所在城市的天气或天气预报”。这会提示用户说出一个将触发`getWeather`意图的短语。
- en: 'Now we can start on the logic to get the user the weather information that
    they want. We need to create another handler that will deal with the `getWeather`
    requests:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写逻辑，以获取用户想要的天气信息。我们需要创建另一个处理程序来处理`getWeather`请求：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before we can get the weather, we need to check that we have values for the
    location and the date. If we don''t have values for either of these, we need to
    get them:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够获取天气之前，我们需要检查我们是否有位置和日期的值。如果我们没有这两个值中的任何一个，我们需要获取它们：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will probably notice that the missing location and date are handled differently.
    If the location is missing, then we ask the user for the location. If we are missing
    the date, we set the date to `Date.now()`. This is a design choice because it
    feels more natural to say `"What's the weather like in LA?"` than `"What's the
    weather like in LA now?"`. It is often the smaller details such as this that make
    talking with a good chatbot so much better.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，缺失的位置和日期被处理得不同。如果位置缺失，我们会要求用户提供位置。如果我们缺少日期，我们将日期设置为`Date.now()`。这是一个设计选择，因为它感觉更自然地说“洛杉矶的天气怎么样？”而不是“洛杉矶现在的天气怎么样？”。正是这样的小细节使得与优秀的聊天机器人交谈变得如此愉快。
- en: We know that we have a location and a date so can proceed with the rest of the
    logic. With the location and the date, we can make the request to the Open Weather
    Maps API.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们有一个位置和一个日期，因此可以继续编写其余的逻辑。有了位置和日期，我们可以向Open Weather Maps API发起请求。
- en: Making an API request
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发起API请求
- en: Making a request to an API consists of using a `GET`, `PUT`, `POST`, or `DELETE`
    method on a URL with some optional data. A well-designed API will be designed
    to have most of the information about the request in the URL. This means that
    we will be changing the URL based on the user choices.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 发起API请求包括在URL上使用`GET`、`PUT`、`POST`或`DELETE`方法，并附带一些可选数据。一个设计良好的API将设计成在URL中包含大部分关于请求的信息。这意味着我们将根据用户的选择更改URL。
- en: 'For the Open Weather Maps API, the URLs that we need to send our requests to
    are structured as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Open Weather Maps API，我们需要发送请求的URL结构如下：
- en: 'For current weather: [https://api.openweathermap.org/data/2.5/weather?q={$city},us](https://api.openweathermap.org/data/2.5/weather?q=%7B%24city%7D,us)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于当前天气：[https://api.openweathermap.org/data/2.5/weather?q={$city},us](https://api.openweathermap.org/data/2.5/weather?q=%7B%24city%7D,us)
- en: 'For a five-day forecast: [https://api.openweathermap.org/data/2.5/forecast?q=${city},us](https://api.openweathermap.org/data/2.5/forecast?q=%24%7Bcity%7D,us)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于五天预报：[https://api.openweathermap.org/data/2.5/forecast?q=${city},us](https://api.openweathermap.org/data/2.5/forecast?q=%24%7Bcity%7D,us)
- en: Unfortunately, the API needs us to define a country code. In this example, we
    should use *US*, as we selected US_CITY as our slot type. If you chose a different
    slot type, make sure to enter the `ISO 3166` code for your country.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，API需要我们定义一个国家代码。在这个例子中，我们应该使用*US*，因为我们选择了US_CITY作为我们的槽类型。如果你选择了不同的槽类型，请确保输入你国家的`ISO
    3166`代码。
- en: 'To make a request to these URLs, we need to use a request library. There is
    an `HTTP` standard library built into a node that can make requests, but there
    are some other libraries that make our life much simpler. The one we will be using
    is called `axios`. There are two main reasons to use `axios` over the standard
    `HTTP` library:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要向这些URL发出请求，我们需要使用一个请求库。Node内置了一个`HTTP`标准库可以用来发出请求，但还有一些其他库可以使我们的生活更加简单。我们将使用的一个库叫做`axios`。使用`axios`而不是标准`HTTP`库有两个主要原因：
- en: It is more user-friendly
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更加用户友好
- en: It is *promise-based*, so you control the flow of the data
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是基于**承诺**的，因此你可以控制数据流
- en: To make a request using `axios`, we first need to install it and require it
    in. Navigate to your `weatherGods` Lambda folder and run `npm install --save axios`
    and add `const axios = require('axios');` to the top of the `index.js` file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`axios`发出请求，我们首先需要安装它并在代码中引入。导航到你的`weatherGods` Lambda文件夹，运行`npm install
    --save axios`并在`index.js`文件的顶部添加`const axios = require('axios');`。
- en: 'Making a request can now be as simple as adding this line of code wherever
    we want to make the request:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发出请求可以简单到只需在任何想要发出请求的地方添加这一行代码：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For our requests, we will also need to pass in our API key. For the Open Weather
    Maps API, we need to add a query string of `appid=${process.env.API_KEY}` at the
    end of our URL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的请求，我们还需要传递我们的API密钥。对于Open Weather Maps API，我们需要在URL的末尾添加查询字符串`appid=${process.env.API_KEY}`。
- en: 'We store our API key in environment variables so that it never gets committed
    to source control (GIT), where it could be accessed by someone else. They can
    be accessed and changed in your Lambda console. To store an environment variable,
    scroll down in your Lambda console to *Environment variables* and enter the key
    and value you want to store:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将API密钥存储在环境变量中，这样它就不会被提交到源代码控制（GIT），否则其他人可以访问它。它们可以在你的Lambda控制台中访问和更改。要存储环境变量，请在Lambda控制台中向下滚动到**环境变量**并输入你想要存储的键和值：
- en: '![](img/ff9c3ffe-1b75-42fc-aa84-ae9d4a18722f.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff9c3ffe-1b75-42fc-aa84-ae9d4a18722f.png)'
- en: Environment variables
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量
- en: 'While we make the request, we have no access to the result. There are a few
    different ways to get the result from a Promise, but we''re going to use `async`
    and `await` to keep our code as clean and readable as possible. To get `async`
    and `await` working, we need to modify our handler function slightly. Where we
    have declared the input values, we need to declare that this function is an `async`
    function. We also need to check that our Lambda is running node 8.10 so it supports
    `async` functions. If you are using the build script that we created in [Chapter
    2](ac448944-0559-408e-a9c4-972933a03611.xhtml), *Getting Started with AWS and
    Amazon CLI*, then all of our functions are automatically set up using node 8.10,
    but you can always check by looking at the runtime on your Lambda Console. We
    make our handle method asynchronous by adding `async` before the method name:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发出请求时，我们无法访问结果。从承诺中获取结果有几种不同的方法，但我们将使用`async`和`await`来使我们的代码尽可能干净和易于阅读。为了使`async`和`await`工作，我们需要稍微修改我们的处理函数。在我们声明输入值的地方，我们需要声明这个函数是一个`async`函数。我们还需要检查我们的Lambda是否运行在支持`async`函数的node
    8.10上。如果你使用的是我们在[第2章](ac448944-0559-408e-a9c4-972933a03611.xhtml)中创建的构建脚本，*使用AWS和Amazon
    CLI入门*，那么我们所有的函数都是自动使用node 8.10设置的，但你总是可以通过查看Lambda控制台上的运行时来检查。我们通过在方法名前添加`async`来使我们的处理方法异步：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the results from a promise using `async` and `await`, we need to put
    an `await` before the promise. This means that the rest of the code won''t start
    running until the promise has returned:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`async`和`await`从承诺中获取结果，我们需要在承诺前加上`await`。这意味着代码的其余部分将不会开始运行，直到承诺返回：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we've had a quick introduction to `axios` and `async`/`await`, we can
    start writing the requests that we are going to make. Because we have different
    URLs for *current weather* and *weather forecast*, we need to check whether the
    date selected is the current date or whether they are looking for a forecast.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对`axios`和`async`/`await`进行了快速介绍，我们可以开始编写我们将要发出的请求。因为我们有针对**当前天气**和**天气预报**的不同URL，我们需要检查所选日期是否是当前日期，或者他们是否在寻找预报。
- en: Comparing dates is a surprisingly complicated task, so we are going to use an
    `npm` package to make it much easier. This package is called `moment`, and it
    is a package that is made to work with dates. Install it to our Lambda using `npm
    install --save moment` and then require it into Lambda by adding `const moment
    = require('moment'); moment().format();` to the top of our `index.js` file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 比较日期是一个令人惊讶的复杂任务，因此我们将使用一个 `npm` 包来使它更容易。这个包叫做 `moment`，它是一个专为与日期一起使用而制作的包。使用
    `npm install --save moment` 在我们的 Lambda 中安装它，然后通过在 `index.js` 文件的顶部添加 `const moment
    = require('moment'); moment().format();` 来将其引入 Lambda。
- en: 'Back in `handler`, we can add the following check:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handler` 中，我们可以添加以下检查：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we need to add in the request that we are going to make to `openWeatherMaps`.
    The response that we get from `axios` is all of the information about the request.
    Because we only care about the data that is returned, we can destructure the response
    and rename the data. Destructuring allows us to select a key from an object and
    name it as something else:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加我们将要向 `openWeatherMaps` 发出的请求。我们从 `axios` 收到的响应包含了请求的所有信息。因为我们只关心返回的数据，所以我们可以解构响应并重命名数据。解构允许我们从对象中选择一个键并将其命名为其他名称：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can use this destructuring to rename the current weather data and forecast
    data differently, to avoid future confusion:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种解构来将当前天气数据和预报数据重命名为不同的名称，以避免未来的混淆：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the responses from these requests, we need to extract the information that
    we want to send to the user. For this, we need to know the data that we're going
    to receive and the data we want at the end.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些请求的响应，我们需要提取我们想要发送给用户的信息。为此，我们需要知道我们将要接收的数据和我们想要的数据。
- en: 'One great way to check the exact data you will receive is to make test requests
    to the API. A great tool for making API requests is [Postman](https://www.getpostman.com/),
    as it allows you to make `GET`, `PUT`, `POST`, and `DELETE` requests and see the
    results. To test our API request, we can open Postman and put `https://api.openweathermap.org/data/2.5/weather?q={$location},us,&APPID=${API_KEY}`
    into the request bar. Before making the request, just change `${location}` to
    be a test city and `${API_KEY}` to be the API key that we generated on the Open
    Weather Map website. It should look something like this: `https://api.openweathermap.org/data/2.5/weather?q=manchester,us,&APPID=12345678`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你将收到的确切数据的一个很好的方法是向 API 发送测试请求。制作 API 请求的一个很好的工具是 [Postman](https://www.getpostman.com/)，因为它允许你发送
    `GET`、`PUT`、`POST` 和 `DELETE` 请求并查看结果。为了测试我们的 API 请求，我们可以打开 Postman 并将 `https://api.openweathermap.org/data/2.5/weather?q={$location},us,&APPID=${API_KEY}`
    放入请求栏。在发送请求之前，只需将 `${location}` 改为测试城市，将 `${API_KEY}` 改为我们生成的 Open Weather Map
    网站上的 API 密钥。它看起来可能像这样：`https://api.openweathermap.org/data/2.5/weather?q=manchester,us,&APPID=12345678`。
- en: 'From this request, we will get a result similar to this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个请求中，我们将得到一个类似以下的结果：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From this data, the information that we are likely to want to tell the user
    will come from the weather and the main sections, with the rest of the data being
    less relevant for us. To remove this information, we can use destructuring again:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些数据中，我们可能想要告诉用户的信息将来自天气和主要部分，其余的数据对我们来说不太相关。为了删除这些信息，我们可以再次使用解构：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to do the same for the forecast requests. The data is different, so
    we will need to do a bit more processing to extract the data we want:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对预报请求做同样的事情。数据是不同的，因此我们需要进行一些额外的处理来提取我们想要的数据：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now have forecast data for every three hours for the next five days. This
    is too much data to try to tell a user, even if they are only asking for a single
    day. To cut the data down, we can reduce the forecast to one at 9:00 and one at
    18:00\. We can use a filter on the `usefulForecast` array so that the `dt_txt`
    has to end at `09:00:00` or `18:00:00`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了未来五天每三小时的预报数据。这些数据量太大，以至于很难告诉用户，即使他们只询问一天的数据。为了减少数据量，我们可以将预报减少到9:00和18:00各一个。我们可以使用
    `usefulForecast` 数组上的过滤器，使得 `dt_txt` 必须以 `09:00:00` 或 `18:00:00` 结尾：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now get the two forecasts for the day that the user requested. We can
    use `moment` again to compare the results and the date selected by the user:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以得到用户请求的那天的两个预报。我们可以再次使用 `moment` 来比较结果和用户选择的日期：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We should now have an array that contains two forecasts with the weather, temperature,
    and humidity for 9:00 and 18:00 on the day the user asked about.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有一个包含两个预报的数组，这些预报包含了用户询问的那天的9:00和18:00的天气、温度和湿度。
- en: 'With the data for the current weather and forecasts, we can start to create
    the user response. We''ll start with a current weather request. We can use template
    strings to make the formatting easy. You can modify the phrasing or the structure
    all that you want, as long as you use the correct variables:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前天气和预报的数据，我们可以开始创建用户响应。我们将从一个当前天气请求开始。我们可以使用模板字符串来简化格式化。你可以根据需要修改措辞或结构，只要使用正确的变量即可：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You have probably noticed that we used two variables that we haven't defined
    yet. Let's look into that.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们使用了两个尚未定义的变量。让我们来看看。
- en: 'The `weatherString` needs to be made from the array of weather types that are
    currently happening. To deal with these, we can create a new function that takes
    the `weather` array and returns a string that is more human-/Alexa-readable. This
    function should be placed outside of the handlers object as a new function declaration:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`weatherString` 需要从当前正在发生的天气类型数组中构建。为了处理这些，我们可以创建一个新的函数，该函数接受 `weather` 数组并返回一个更易于人类/Amazon
    Alexa 读取的字符串。这个函数应该放在 `handlers` 对象之外作为一个新的函数声明：'
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If there is only one weather type, this function returns the description. When
    there is more than one weather type, insert a comma between the types, apart from
    the last one, where it uses `and` to add it on. This would create strings such
    as *broken clouds, light rain and mist*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一种天气类型，此函数返回描述。当有多个天气类型时，在类型之间插入逗号，除了最后一个，它使用 `and` 来添加。这将创建如 *破碎的云，小雨和雾*
    这样的字符串。
- en: 'Next, we need to convert the temperature into a scale that more people understand.
    The temperature we''re given is in Kelvin, so we need to convert it to Celsius
    or Fahrenheit. I have provided the functions for both, but we only need to use
    one in our Lambda:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将温度转换为大多数人都能理解的尺度。我们给出的温度是开尔文，所以我们需要将其转换为摄氏度或华氏度。我已经提供了这两个函数，但我们只需要在
    Lambda 中使用一个：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Back inside our `getWeather` handler, we can now add the calls to these functions
    to our `isToday` if block. You can comment out the temperature function you don''t
    want to use:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `getWeather` 处理程序内部，我们现在可以向 `isToday` 块中添加对这些函数的调用。你可以取消注释你不想使用的温度函数：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have everything that we need to create the `speechText` variable
    that will be passed to the user, we need to follow a similar set of steps for
    the forecast data. We can start with the phrase that we want to build, which is
    a bit longer and more complex than the first one:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建将传递给用户的 `speechText` 变量的所有必要信息，我们需要为预报数据遵循类似的步骤集。我们可以从一个我们想要构建的短语开始，这个短语比第一个更长更复杂：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To populate these variables, we need to use the format `formatWeatherString()`
    and `tempC()` functions on both elements in the `dayForecast` array. You can switch
    `tempC()` for `tempC()` if you want to use Fahrenheit:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充这些变量，我们需要在 `dayForecast` 数组的两个元素上使用 `formatWeatherString()` 和 `tempC()`
    函数。如果你想使用华氏度，可以将 `tempC()` 替换为 `tempF()`：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will put the morning forecasts into the first index of the arrays as we
    required in our `speechText` string.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把早晨的预报放入数组的第一个索引中，正如我们在 `speechText` 字符串中所要求的。
- en: 'Now that we have the string responses for current weather and forecasts, we
    need to tell the user:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了当前天气和预报的字符串响应，我们需要告诉用户：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once we save this function, we are ready to deploy this Lambda. With our build
    script, this is done by navigating into the main Lambda folder and running `./build.sh
    weatherGods`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此函数后，我们就准备好部署这个 Lambda。使用我们的构建脚本，这通过进入主 Lambda 文件夹并运行 `./build.sh weatherGods`
    来完成。
- en: Final setup and testing
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终设置和测试
- en: 'With the Lambda created and uploaded, we can finish the last steps of the setup
    and then test out our skill. There are two things that we need to do before the
    skill starts working:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建并上传 Lambda 之后，我们可以完成设置的最后一步，然后测试我们的技能。在技能开始工作之前，我们需要做两件事：
- en: Add Alexa Skills Kit as a trigger to the Lambda
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Alexa 技能套件添加为 Lambda 的触发器
- en: Add the Lambda ARN to the skill endpoint
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Lambda ARN 添加到技能端点
- en: We've done this all twice before, so this will be a brief guide. Open the Lambda
    Console and navigate into the `weatherGods` Lambda. In the Designer section, add
    the Alexa Skills Kit as a trigger and then add the Skill ID to the configuration
    window, and save the Lambda. Copy the ARN of the Lambda and navigate into the
    Alexa Skills Kit Developer Console, where we can go into the `WeatherGods` skill
    and add the Lambda ARN to the skill endpoint.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经做过两次，所以这只是一个简要的指南。打开 Lambda 控制台并导航到 `weatherGods` Lambda。在设计部分，添加 Alexa
    技能套件作为触发器，然后添加技能 ID 到配置窗口中，并保存 Lambda。复制 Lambda 的 ARN 并导航到 Alexa 技能套件开发者控制台，在那里我们可以进入
    `WeatherGods` 技能并将 Lambda ARN 添加到技能端点。
- en: 'Now that the setup of the skill is done, we get to test it. In the Alexa Skill
    Kit console, make sure you are in the `WeatherGods` skill and that all of the
    items on the Skill builder checklist are complete. If you have any missing, then
    go back and complete that section:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在技能的设置已经完成，我们可以开始测试它。在 Alexa 技能套件控制台中，确保你处于 `WeatherGods` 技能，并且技能构建清单上的所有项目都已完整。如果你有任何缺失，请返回并完成该部分：
- en: '![](img/a5609c0f-1a0e-4122-87b2-4036c1253dff.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5609c0f-1a0e-4122-87b2-4036c1253dff.png)'
- en: Skill-building checklist
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 技能构建清单
- en: 'Now we can go into the Test tab and try out this skill. We can start this skill
    and then ask for a forecast, and we should be told the forecast for a given city:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进入测试选项卡并尝试这个技能。我们可以启动这个技能，然后请求预报，我们应该被告知给定城市的预报：
- en: '![](img/1223ec81-c4c3-4e51-8bdb-31d1d9a510cf.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1223ec81-c4c3-4e51-8bdb-31d1d9a510cf.png)'
- en: City forecast
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 城市天气预报
- en: This is a great place to try out different ways of asking the same thing and
    expanding the utterances for the intents.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个尝试不同方式询问相同内容并扩展意图表述的好地方。
- en: Improving user experience
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升用户体验
- en: While our first version of this skill works well, it can be improved in a few
    key sections.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们这个技能的第一个版本运行良好，但在几个关键部分可以进行改进。
- en: Error-handling
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误
- en: Session memory
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话内存
- en: SSML
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSML
- en: Error-handling our API calls
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理我们的 API 调用错误
- en: When we first set up this function, we didn't include any error-handling for
    our API calls. There is a chance that something happens with the API or with our
    call that causes it to fail. This could be a huge list of things such as broken
    internet connection, incorrect request, unknown location, expired API key, or
    the API going down.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初设置这个函数时，我们没有为我们的 API 调用包含任何错误处理。有可能 API 或我们的调用发生了一些导致它失败的事情。这可能是大量的事情，例如断开的互联网连接、不正确的请求、未知的位置、过期的
    API 密钥或 API 崩溃。
- en: 'To deal with this, we need to modify the way that our skill makes that request
    to the Open Weather Maps API. One of the limitations of using pure `async` and
    `await` is that we can''t tell whether the request has passed or failed. There
    are two ways to deal with this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，我们需要修改我们的技能向 Open Weather Maps API 发送请求的方式。使用纯 `async` 和 `await` 的一种限制是我们无法判断请求是否成功或失败。有两种处理方法：
- en: You can use `try…catch` blocks to catch any errors that occur. The way that
    we would do this would be to wrap everything inside the `isToday` block in a `try`
    block and then have a `catch` that tells the user that we couldn't deal with the
    request.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `try…catch` 块来捕获发生的任何错误。我们这样做的方式是将 `isToday` 块内的所有内容包裹在一个 `try` 块中，然后有一个
    `catch` 告诉用户我们无法处理这个请求。
- en: You can pass the request to a function that returns an array of `[error, result]`.
    If no error occurs, then it will be `null` so we can do logic based on that fact.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将请求传递给一个返回 `[error, result]` 数组的函数。如果没有发生错误，那么它将是 `null`，因此我们可以根据这个事实进行逻辑处理。
- en: Both of these methods are suitable, but they are best used in different situations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都适用，但它们最好在不同的情境中使用。
- en: 'The first `try…catch` method is used to catch errors across the code. We can
    take advantage of this by wrapping most of our logic in a single `try…catch`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `try…catch` 方法用于捕获代码中的错误。我们可以通过将大部分逻辑包裹在一个单独的 `try…catch` 中来利用这一点：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Keeping error messages light-hearted is often a good idea, as the user is less
    likely to be annoyed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 保持错误信息轻松愉快通常是个好主意，因为用户不太可能感到烦恼。
- en: 'The second method is often used when you want to catch when a specific promise
    errors. We need to create a new function that takes a promise and returns the
    error and result status. This function is usually called `to`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法通常用于当你想要捕获特定承诺错误时。我们需要创建一个新的函数，该函数接受一个承诺并返回错误和结果状态。这个函数通常被称为 `to`：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If this function gets a promise that resolves, it returns the error as `null`
    and the result. But if there is an error, it returns an error and a `null` result.
    The error always goes in the first position because of a standard design called
    **error-first programming**.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数得到一个解决的承诺，它将错误作为`null`返回并返回结果。但如果发生错误，它将返回一个错误和一个`null`结果。由于一个称为**错误优先编程**的标准设计，错误总是位于第一个位置。
- en: 'This method is good for catching errors at a very specific location, whether
    it is to handle it differently or just to log out more information at that point.
    We can use this on the current weather request to give a slightly different response:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常适合在非常具体的位置捕获错误，无论是要不同地处理它还是仅仅在那个点记录更多信息。我们可以在当前天气请求上使用这个方法，给出一个稍微不同的响应：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The last tool that we can use to handle errors is providing an error handler
    to the whole Alexa skill. We can create another handler that is called whenever
    there is an uncaught error in our code. This could be us returning an incorrect
    response, having an undefined variable, or an uncaught promise rejection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用来处理错误的最后一个工具是为整个Alexa技能提供一个错误处理器。我们可以创建另一个处理器，当我们的代码中发生未捕获的错误时会被调用。这可能是我们返回了不正确的响应，有一个未定义的变量，或者是一个未捕获的承诺拒绝。
- en: 'Because we want this to be called every time an error occurs, our `canHandle`
    function always returns true. Our handler then gets passed the `handlerInput`
    but also gets passed an `error` variable. We can `console.log` out the response
    from the error and then send the user an error message:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望每次发生错误时都调用这个函数，所以我们的`canHandle`函数总是返回true。然后处理器会接收到`handlerInput`，还会接收到一个`error`变量。我们可以`console.log`出错误的响应，然后向用户发送错误消息：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To apply this handler to our skill, we can add `.addErrorHandlers(ErrorHandler)`
    after `.addRequestHandlers` in our `Alexa.SkillBuilders`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此处理器应用于我们的技能，我们可以在`Alexa.SkillBuilders`中的`.addRequestHandlers`之后添加`.addErrorHandlers(ErrorHandler)`。
- en: With these measures in place, our skill will work much better if there is ever
    an error in our code or when making a request to the Open Weather Map API. You
    should always have some sort of error-handling process around API calls, as you
    never know when they might go wrong.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些措施，如果我们的代码或向Open Weather Map API发出请求时出现错误，我们的技能将工作得更好。你应该始终在API调用周围有一些错误处理过程，因为你永远不知道它们何时可能会出错。
- en: Session memory
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话内存
- en: One thing that doesn't currently work is asking follow-up questions. From the
    initial perfect conversation, we had to follow up questions such as *What about
    tomorrow**?* and *What about in Miami?* that use knowledge about previous requests
    to populate either the date or the location. Having a skill that can remember
    certain bits of information between interactions means that it can interact in
    a much more human way. There are very few interactions that we make that never
    depend on previous information.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有一件事不起作用，那就是询问后续问题。从最初的完美对话中，我们必须跟随问题，例如*明天怎么样**？*和*在迈阿密怎么样？*这些问题使用关于先前请求的知识来填充日期或位置。拥有能够在交互之间记住某些信息的技能意味着它可以以更人性化的方式进行交互。我们做出的交互中很少有完全不依赖于先前信息的。
- en: 'To maintain that information between interactions, we have the concept of **session
    attributes**. These are key value pairs that are attached to the session, not
    just the individual interaction. Once Alexa thinks she''s completed a task, she
    closes the session. In Alexa, session attributes are also really easy to set and
    retrieve. Getting session attributes is as simple as calling the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在交互之间保持信息，我们有**会话属性**的概念。这些是附加到会话上的键值对，而不仅仅是单个交互。一旦Alexa认为她已经完成了任务，她就会关闭会话。在Alexa中，设置和检索会话属性也非常简单。获取会话属性就像调用以下代码一样简单：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This means that we have access to the values that we have previously stored
    in session attributes. To store values in session attributes, we can pass an object
    into `.setSessionAttributes`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以访问我们之前存储在会话属性中的值。要存储值在会话属性中，我们可以将一个对象传递给`.setSessionAttributes`：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last thing that we need to do is to tell Alexa that the session hasn't finished
    yet. We do this by adding `.withShouldEndSession(false)` just before `.getResponse()`
    in our response builder when we want to keep the session attributes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是告诉Alexa会话还没有结束。我们通过在响应构建器中的`.getResponse()`之前添加`.withShouldEndSession(false)`来实现这一点，当我们想要保持会话属性时。
- en: 'If the user doesn''t respond within a set time, the session still gets closed:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在设定的时间内没有做出回应，会话仍然会被关闭：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can use this powerful tool to store the date and location of successful requests
    and then use them to fill location or date slots that aren't filled by the user.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个强大的工具来存储成功请求的日期和位置，然后使用它们来填充用户未填充的位置或日期槽位。
- en: 'The first thing that we need to do is to get the session attributes from storage.
    We can then use these values to populate the `date` and `location` variables.
    If we don''t get a value from the slots, we try the session attributes; otherwise,
    we set them to `null`. We then set out the local `sessionAttributes` variable
    to equal our `date` and `location`. This means that new values that come from
    slots override the existing session attribute values:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从存储中获取会话属性。然后我们可以使用这些值来填充`日期`和`位置`变量。如果我们从槽位中没有获取到值，我们尝试会话属性；否则，我们将它们设置为`null`。然后我们将本地的`sessionAttributes`变量设置为等于我们的`日期`和`位置`。这意味着来自槽位的新值会覆盖现有的会话属性值：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have changed the local session attributes, but we haven''t set them on the
    session yet. We leave this until just before we respond to the user. We choose
    not to save it straight away, as if the user provided an invalid slot, that would
    get stored. If we store it just before sending the message, then we know that
    the API calls have succeeded:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了本地会话属性，但还没有在会话中设置它们。我们留到即将响应用户之前再进行设置。我们选择不立即保存，因为如果用户提供了无效的槽位，它就会被存储。如果我们就在发送消息之前存储它，那么我们就知道API调用已经成功：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Similarly, we need to add `handlerInput.attributesManager.setSessionAttributes(sessionAttributes);`
    just before returning the forecast message.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们需要在返回预报消息之前添加`handlerInput.attributesManager.setSessionAttributes(sessionAttributes);`。
- en: This example makes good use of session attributes, but it can be used for so
    much more. It can be used to store information for certain intents, previous conversation
    topics, or information about the user.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很好地使用了会话属性，但它可以用于更多的事情。它可以用来存储特定意图的信息、之前的对话主题或关于用户的信息。
- en: One thing to note is that session attributes only last as long as the conversation
    session with the user. If you want to maintain attributes from one session to
    another, you can use persistent attributes, but this involves configuring your
    skill with a **Persistence Adapter**. More details are available at the end of
    the chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，会话属性只存在于与用户的对话会话期间。如果你想从一个会话保持属性到另一个会话，你可以使用持久属性，但这需要配置你的技能与**持久化适配器**。更多详细信息可以在本章末尾找到。
- en: SSML
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSML
- en: When you are sending a response to a user, you may not want Alexa to say it
    in her normal way. Alexa is already pretty smart and handles punctuation, increasing
    the tone at the end of a question and pausing after a period, but what if you
    want to have greater control?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向用户发送响应时，你可能不希望Alexa以她通常的方式说出它。Alexa已经很智能了，可以处理标点符号，在句末提高音调并在句点后暂停，但如果你想要更大的控制权呢？
- en: SSML is a standard markup for speech synthesis, and Alexa supports a subset
    of SSML, allowing the use of 13 different tags. These tags allow you to specify
    the way that the text is spoken. This means you can add `<break time="2s">` into
    your speech to add a two-second pause, emphasise a section of the speech using
    `<emphasis level="moderate">text to emphasise</emphasis>`, or `<prosody rate="slow"
    pitch="-2st">`to change the tone and speed, `</prosody>`, of the speech.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: SSML是语音合成的标准标记语言，Alexa支持SSML的一个子集，允许使用13个不同的标签。这些标签允许你指定文本的朗读方式。这意味着你可以在你的语音中添加`<break
    time="2s">`来添加两秒的停顿，使用`<emphasis level="moderate">要强调的文本</emphasis>`来强调语音的某个部分，或者使用`<prosody
    rate="slow" pitch="-2st">`来改变语音的音调和速度，`</prosody>`。
- en: There are lots of ways to change the way that Alexa talks, and they can all
    be found in the Alexa SSML reference page ([https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html#emphasis](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html#emphasis)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以改变Alexa说话的方式，所有这些都可以在Alexa SSML参考页面上找到（[https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html#emphasis](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html#emphasis))。
- en: The speech that we are saying to the user is already handled very well because
    of Alexa's handling of punctuation and questions. This means there isn't much
    of our existing messages we could improve with SSML. To give us something that
    always needs extra speech control, we're going to add a new intent—`tellAJoke`.
    If you've ever heard someone ruin a good joke, then you know that jokes need proper
    tone, speed, and timing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对用户说的语音已经被Alexa对标点符号和问题的处理处理得很好。这意味着我们现有的消息中，我们用SSML改进的并不多。为了给我们一些总是需要额外语音控制的东西，我们将添加一个新的意图——`tellAJoke`。如果你曾经听到有人把一个笑话讲砸了，那么你就知道笑话需要适当的语调、速度和时机。
- en: We need to add the `tellAJoke` intent in the Alexa Skills Kit console and then
    add a few utterances, but this time we don't need any slots.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在Alexa技能套件控制台中添加`tellAJoke`意图，然后添加一些语音，但这次我们不需要任何槽位。
- en: 'Once we''ve saved and built the model, we can move back to our code to handle
    this new intent:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并构建模型后，我们可以回到我们的代码来处理这个新的意图：
- en: '![](img/e25de44c-efb2-41e4-834f-18a11a3ff2ea.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e25de44c-efb2-41e4-834f-18a11a3ff2ea.png)'
- en: Adding the tell-a-joke intent
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 添加讲笑话的意图
- en: 'The handler for this intent is very simple. All that it needs to do is to get
    a random joke from the array of jokes and tell that to the user. We use `Math.floor(Math.random()
    * 3);` to get a random integer that is less than 3\. If you want to add more jokes,
    just change `3` to the number of jokes you have:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个意图的处理程序非常简单。它需要做的只是从笑话数组中随机获取一个笑话并告诉用户。我们使用`Math.floor(Math.random() * 3);`来获取一个小于3的随机整数。如果你想添加更多的笑话，只需将`3`改为你拥有的笑话数量：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The more interesting part is creating the jokes. We need to start by creating
    a variable called `jokes` that is an array. Inside this array, we can put a few
    weather-related jokes. I''ve added the first three, but feel free to add your
    own (and remove my less-funny ones):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的部分是创造笑话。我们需要先创建一个名为`jokes`的变量，它是一个数组。在这个数组中，我们可以放入一些与天气相关的笑话。我已经添加了前三个，但请随意添加你自己的（并移除我那些不太有趣的笑话）：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we published the skill now, those jokes would be even worse than they''re
    meant to be. The first thing that we will aim to fix will be the timing. Adding
    break tags before the punchline makes the jokes far better:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在发布这个技能，那些笑话会比预期得更糟糕。我们首先想要修复的是时间。在笑点前添加断句标签可以使笑话变得更好：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The exact timings may not be perfect, but they''re already delivered much better
    than before. Another key to telling a joke well is the emphasis you place on certain
    words. Adding emphasis to sections of speech in Alexa is done by wrapping those
    words in `emphasis` tags:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的时间可能并不完美，但它们已经比之前好得多。讲好笑话的另一个关键是你在某些词上所加的强调。在Alexa中为语音部分添加强调是通过将这些词包裹在`emphasis`标签中实现的：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Adding `emphasis` tags to our jokes, we get this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的笑话中添加`emphasis`标签，我们得到这个：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the `emphasis` tags are used but a level is not provided, a level of *moderate*
    is used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`emphasis`标签但没有提供级别时，默认使用*中等*级别。
- en: There are lots of other SSML tags that can be used to alter the way that Alexa
    says the response, and they can be found on the Alexa SSML page ([https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多其他的SSML标签可以用来改变Alexa说响应的方式，它们可以在Alexa SSML页面找到（[https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html))。
- en: Testing
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Now that we've added all of these changes to our Lambda, we can build it and
    test it out.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将这些更改添加到我们的Lambda中，我们可以构建并测试它。
- en: It's quite hard to test what happens when API errors occur, but we can test
    for session attributes and SSML.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 测试API错误发生时会发生什么相当困难，但我们可以测试会话属性和SSML。
- en: 'Session attributes can be tested by asking to follow up questions, where we
    expect that some data has been stored from the last question. We can ask for a
    forecast in one location, and then ask for a new location. The date should have
    been saved in session attributes, so we should get a forecast for the new location
    instead of the current weather. We can then ask about today''s weather, and the
    new location should have been saved, so we shouldn''t get prompted for the location:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 会话属性可以通过询问后续问题来测试，我们期望从上一个问题中存储了一些数据。我们可以询问一个地点的预报，然后询问一个新的地点。日期应该已经保存在会话属性中，所以我们应该得到新地点的预报而不是当前天气。然后我们可以询问今天的天气，新的地点应该已经被保存，所以我们不应该被提示输入地点：
- en: '![](img/90a19ab8-6d25-42d3-8fbf-2d99c267926c.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90a19ab8-6d25-42d3-8fbf-2d99c267926c.png)'
- en: Session attributes testing
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 会话属性测试
- en: 'We can also test SSML by asking for a joke. The joke you get back should have
    the break that we added and possibly some emphasis. When you test this yourself,
    you will be able to hear these clearly:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过请求一个笑话来测试 SSML。你收到的笑话应该包含我们添加的停顿，可能还有一些强调。当你自己测试时，你将能够清楚地听到这些：
- en: '![](img/f9762c3e-2641-4663-89ec-e75e11008e61.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9762c3e-2641-4663-89ec-e75e11008e61.png)'
- en: Jokes
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 笑话
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered how to use external APIs to increase the information
    that is available to the chatbot, allowing you to make much more powerful skills.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用外部 API 来增加聊天机器人可用的信息，从而让你能够创建更强大的技能。
- en: 'We then looked at how to make the experience more enjoyable for the user. The
    three ways we did this were as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了如何让用户体验更加愉快。我们采取了以下三种方式：
- en: We used error-handling to reduce the frustration when a user's request doesn't
    work.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用错误处理来减少用户请求不工作时产生的挫败感。
- en: We used session memory to remember details about the conversation so that we
    can use them later. This stopped us from repeating and prompting the user every
    time they didn't provide all of the information.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用会话内存来记住关于对话的细节，这样我们就可以稍后使用它们。这阻止了我们每次用户没有提供所有信息时重复和提示用户。
- en: We used SSML to modify the way that Alexa says our responses, to make the sentence
    feel more human. We also used SSML to make jokes funnier, but it can be used to
    emphasize points or change the tone of the speech.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 SSML 来修改 Alexa 说出我们响应的方式，使句子听起来更人性化。我们还使用 SSML 使笑话更有趣，但它可以用来强调要点或改变说话的语气。
- en: Questions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an API?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 API？
- en: How does Axios differ from the standard HTTP request library?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Axios 与标准 HTTP 请求库有何不同？
- en: What are the two common ways of handling `async` and `await` errors?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理 `async` 和 `await` 错误的两种常见方法是什么？
- en: How would we store *color* on the session attributes?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在会话属性中存储 *颜色*？
- en: What types of data can be stored on the session attributes?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在会话属性中存储哪些类型的数据？
- en: Why would you use SSML?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你会使用 SSML？
- en: Further reading
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you want to learn about *persistentAttributes*,then you can read about them
    in the ASK SDK documents ([https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Managing-Attributes.html](https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Managing-Attributes.html)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解 *持久属性*，你可以在 ASK SDK 文档中阅读它们（[https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Managing-Attributes.html](https://ask-sdk-for-nodejs.readthedocs.io/en/latest/Managing-Attributes.html)）。
- en: For a full list of the supported SMML tags in Alexa, go to the Alexa SSML reference
    page ([https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Alexa 支持的完整 SSML 标签列表，请访问 Alexa SSML 参考页面（[https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html)）。
- en: If you want to hear how different SSML tags change the way that text is spoken,
    check out the Google SSML reference page ([https://developers.google.com/actions/reference/ssml](https://developers.google.com/actions/reference/ssml)).
    It has working examples of lots of SSMLs, but you can't edit them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解不同的 SSML 标签如何改变文本的朗读方式，请查看 Google SSML 参考页面（[https://developers.google.com/actions/reference/ssml](https://developers.google.com/actions/reference/ssml)）。它包含许多
    SSML 的工作示例，但你不能编辑它们。
