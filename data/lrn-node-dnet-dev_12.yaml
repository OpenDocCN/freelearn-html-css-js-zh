- en: Chapter 12. Authentication in Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. Node.js中的认证
- en: The application we have built so far allows users to choose a username to identify
    themselves. However, they only retain this identity for the duration of their
    browser session. It's important to allow users to retain a consistent identity
    from one session to the next. This allows us to build richer user experiences.
    Some websites (such as Facebook) couldn't offer their main functionality at all
    without being able to identify users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止构建的应用程序允许用户选择一个用户名来识别自己。然而，他们只能在浏览器会话期间保留这个身份。允许用户从一个会话持续到下一个会话保持一致的身份是很重要的。这使我们能够构建更丰富的用户体验。一些网站（如Facebook）如果不能识别用户，甚至无法提供其主要功能。
- en: 'Identifying users requires us to implement authentication. In this chapter,
    we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 识别用户需要我们实现认证。在本章中，我们将涵盖以下主题：
- en: Implementing third-party authentication via social networking sites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过社交网站实现第三方认证
- en: Associating third-party identities with our own user data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第三方身份与我们的用户数据关联
- en: Simulating user authentication to support integration testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟用户认证以支持集成测试
- en: Introducing Passport
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Passport
- en: Passport is an authentication framework for Node.js. It can act as Express middleware,
    making it easy to integrate with our application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Passport是一个Node.js的认证框架。它可以作为Express中间件，使得与我们的应用程序集成变得容易。
- en: Like some of the other libraries we've discussed so far, Passport is very modular.
    Its core package provides a common paradigm for authentication. Passport's middleware
    performs authentication and augments the request object with a `user` property.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前讨论的一些其他库一样，Passport非常模块化。它的核心包提供了一个通用的认证范式。Passport的中间件执行认证，并在请求对象中添加一个`user`属性。
- en: Additional Passport npm packages support hundreds of different **strategies**
    for authentication. Each Passport strategy provides a different mechanism for
    identifying users. We'll look at a few of these strategies in this chapter. Passport
    makes it easy to add new strategies to suit the needs of each application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的Passport npm包支持数百种不同的**策略**进行认证。每个Passport策略都提供了识别用户的不同机制。在本章中，我们将探讨这些策略中的几个。Passport使得为每个应用程序添加新策略变得容易。
- en: Choosing an authentication strategy
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择认证策略
- en: A common introductory example is username/password-based authentication. This
    uses a login form to verify users' credentials against the application's database.
    Although this is one of the simplest authentication mechanisms to understand,
    it's not the most useful. Forcing users to create an account for our site is an
    extra hurdle to them using it. Users also get tired of creating an account and
    picking a password for every new website.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的入门示例是基于用户名/密码的认证。这使用登录表单来验证用户的凭据与应用程序数据库的匹配。尽管这是最容易理解的认证机制之一，但它并不是最有用的。强迫用户为我们的网站创建账户是使用它的额外障碍。用户也会厌倦为每个新网站创建账户和选择密码。
- en: Passport does support this kind of authentication, via the `passport-local`
    strategy. We'll make use of this strategy for test purposes later on in this chapter,
    but not in our production code. It's better to allow users to authenticate using
    an identity already established elsewhere. This saves users from having to pick
    new credentials and also saves our website from having to manage these. This is
    just good separation of concerns.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Passport支持这种类型的认证，通过`passport-local`策略。我们将在本章后面部分使用这个策略进行测试，但不会在我们的生产代码中使用。最好允许用户使用已在其他地方建立的身份进行认证。这可以节省用户挑选新凭据的时间和精力，也可以让我们的网站不必管理这些凭据。这只是良好的关注点分离。
- en: If you log in to StackOverflow, you'll notice that it suggests logging in using
    Google+ or Facebook. It also supports OpenID and other providers. Implementing
    support for each of these login mechanisms from scratch would be a lot of work.
    Fortunately there are Passport strategies for all of them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你登录StackOverflow，你会注意到它建议使用Google+或Facebook进行登录。它还支持OpenID和其他提供者。从头开始实现对这些每种登录机制的支持将会是一项大量工作。幸运的是，有Passport策略支持所有这些。
- en: Understanding third-party authentication
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解第三方认证
- en: Passport will do most of the heavy lifting for us, but it's still worth having
    a basic understanding of how third-party authentication works. When a client wants
    to log into a website, it sends them to a third-party provider. The third-party
    provider gives the client back a token they can use to authenticate with the website.
    When the client is a web browser, this process can be made almost invisible to
    the user, via automatic redirects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Passport将为我们做大部分繁重的工作，但仍然值得了解第三方认证的基本工作原理。当客户端想要登录网站时，它会将他们发送到第三方提供者。第三方提供者会向客户端返回一个他们可以使用来对网站进行身份验证的令牌。当客户端是网络浏览器时，这个过程可以通过自动重定向几乎对用户不可见。
- en: The website must then verify that the token presented to it by the client really
    came from the third-party provider. The website and the third-party provider might
    have established a pre-shared key for this purpose, which could be used to create
    a cryptographically verifiable token. Alternatively, the website might call the
    third-party provider directly to verify the token. In practice, a website will
    often want to call a third-party provider anyway to gain more information associated
    with the user's identity, for example, their username or other profile information.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 网站必须验证客户端向其展示的令牌确实来自第三方提供者。网站和第三方提供者可能已经为此目的建立了一个预共享密钥，该密钥可以用来创建一个可加密验证的令牌。或者，网站可能直接调用第三方提供者来验证令牌。在实践中，网站通常会调用第三方提供者以获取更多与用户身份相关的信息，例如他们的用户名或其他个人资料信息。
- en: Using Express sessions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express会话
- en: 'Many of Passport''s strategies are based on HTTP sessions. At the moment, our
    application is just using simple cookies to store user IDs. To use Passport for
    third-party authentication, we''ll need to add session support into our application.
    Express provides session support in the `express-session` module. First, we add
    this to our application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Passport的许多策略都是基于HTTP会话的。目前，我们的应用程序只是使用简单的cookie来存储用户ID。为了使用Passport进行第三方认证，我们需要在我们的应用程序中添加会话支持。Express在`express-session`模块中提供了会话支持。首先，我们将此添加到我们的应用程序中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also need somewhere to store session data. Express supports a variety of
    session stores via additional modules. Redis is well suited to this task and we
    already have a Redis instance available. We can use the `connect-redis` module
    to store sessions in Redis:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个地方来存储会话数据。Express通过额外的模块支持多种会话存储。Redis非常适合这项任务，我们已经有了一个Redis实例可用。我们可以使用`connect-redis`模块将会话存储在Redis中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now create a new configuration module to keep all our session logic
    in one place. Since this will return middleware, we''ll put it in the `middleware`
    folder here `src/middleware/sessions.js`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个新的配置模块，将所有的会话逻辑放在一个地方。由于这将返回中间件，我们将它放在这里的`middleware`文件夹中`src/middleware/sessions.js`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We configure the Express `session` module as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式配置Express的`session`模块：
- en: Use the value of an environment variable as the session secret
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境变量的值作为会话密钥
- en: Only save sessions that contain some data
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只保存包含某些数据的会话
- en: Do not resave sessions unless they have changed
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非会话已更改，否则不要重新保存会话
- en: If Redis is available, use it as the session store
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Redis可用，请将其用作会话存储
- en: Let's consider each of the configuration properties in turn.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一考虑每个配置属性。
- en: Specifying a session secret
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定会话密钥
- en: 'Express uses a session secret to protect session data from being tampering
    with. You should specify this by setting the `SESSION_SECRET` environment variable
    locally. The value is arbitrary and can be anything, as long as it''s not empty.
    We also need to specify this in our integration test so it can run on the CI server.
    The following code is from `gulpfile.js`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Express使用会话密钥来保护会话数据不被篡改。你应该通过设置本地的`SESSION_SECRET`环境变量来指定它。值是任意的，可以是任何内容，只要它不为空。我们还需要在我们的集成测试中指定这个值，以便它可以在CI服务器上运行。以下代码来自`gulpfile.js`：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Deciding when the session gets saved
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定何时保存会话
- en: Avoiding unnecessary saves is a minor optimization and can avoid certain race
    conditions. Only saving initialized sessions allows you to request user consent
    before storing any cookies. This might be necessary for compliance with regional
    laws, most notably in the EU. See [https://www.cookiechoices.org/](https://www.cookiechoices.org/)
    for more information.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 避免不必要的保存是一种小优化，可以避免某些竞态条件。只有保存已初始化的会话，你才能在存储任何cookie之前请求用户同意。这可能对于遵守区域法律是必要的，尤其是在欧盟。更多信息请参阅[https://www.cookiechoices.org/](https://www.cookiechoices.org/)。
- en: Using alternative session stores
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用替代会话存储
- en: By default, Express will use an in-memory session store. This is fine for development
    purposes and in test environments where we only have one application process,
    but is not suitable for production use. Storing sessions out of process in Redis
    is important if we want to scale across multiple instances. We configure the Redis
    store with our existing Redis URL.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Express将使用内存中的会话存储。这对于开发目的和在只有一个应用程序进程的测试环境中是可行的，但不适合生产使用。如果我们想要跨多个实例进行扩展，将会话存储在进程外部的Redis中很重要。我们使用现有的Redis
    URL配置Redis存储。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In practice, you might want to use different Redis instances for session data
    and other application data. These are quite different use cases, so they might
    benefit from a different configuration of Redis. For example, session data is
    likely to be higher load, but can afford to be more volatile. For small-scale
    applications such as our example application in this book, a single Redis instance
    will suffice.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您可能希望为会话数据和应用程序的其他数据使用不同的Redis实例。这些是相当不同的用例，因此它们可能从不同的Redis配置中受益。例如，会话数据可能负载更高，但可以承受更高的易变性。对于本书中的示例应用等小型应用，单个Redis实例就足够了。
- en: Using session middleware
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用会话中间件
- en: 'We can now use sessions elsewhere in our application instead of directly setting
    cookies. The following code is from `src/app.js`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在应用程序的其他地方使用会话，而不是直接设置cookie。以下代码来自`src/app.js`：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code is from `src/middleware/users.js`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自`src/middleware/users.js`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following code is from `src/server.js`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自`src/server.js`：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implementing social login
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现社交登录
- en: For our first example, we'll use Twitter as our third-party authentication provider.
    If you want to follow along with the example you will need a Twitter account,
    which is very quick to set up.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将使用Twitter作为第三方身份验证提供者。如果您想跟随示例，您需要一个Twitter账户，设置起来非常快。
- en: Setting up a Twitter application
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Twitter应用
- en: 'In order for Twitter to recognize our application, we need to create a new
    app in Twitter''s developer portal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Twitter识别我们的应用程序，我们需要在Twitter开发者门户中创建一个新的应用：
- en: Visit [https://apps.twitter.com/](https://apps.twitter.com/) and click on **Create
    New App**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://apps.twitter.com/](https://apps.twitter.com/)并点击**创建新应用**。
- en: 'Fill in the Name, Description, Website, and Callback URL fields:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写名称、描述、网站和回调URL字段：
- en: If you've deployed your application to Heroku, you can use its Heroku URL here
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您已将应用程序部署到Heroku，您可以使用其Heroku URL
- en: Otherwise, just fill in placeholder values for both fields (for example, `http://test.example.com/callback`)
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，只需为这两个字段填写占位符值（例如，`http://test.example.com/callback`）
- en: Click on **Create your Twitter application**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建您的Twitter应用**。
- en: Click on the **Settings** tab and ensure that **Enable Callback Locking** is
    unchecked (leaving this unchecked allows you to use placeholder values for the
    URLs and is also useful for local testing).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**设置**选项卡，并确保**启用回调锁定**未勾选（不勾选此选项允许您为URL使用占位符值，并且对于本地测试也很有用）。
- en: Click on the **Keys and Access Tokens** tab to view your application's **Consumer
    Key (API Key)** and **Consumer Secret (API Secret)**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**密钥和访问令牌**选项卡以查看您的应用程序的**消费者密钥（API密钥**）和**消费者密钥（API密钥**）。
- en: Set new local environment variables named `TWITTER_API_KEY` and `TWITTER_API_SECRET`,
    containing the corresponding values from Twitter. You might want to create a shell
    script or batch file to set these in the console or configure them as Heroku environment
    variables (see [Chapter 11](part0066.xhtml#aid-1UU542 "Chapter 11. Deploying Node.js
    Applications"), *Deploying Node.js Applications*)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 设置名为`TWITTER_API_KEY`和`TWITTER_API_SECRET`的新本地环境变量，包含来自Twitter的相应值。您可能希望创建一个shell脚本或批处理文件来在控制台设置这些变量，或者将它们配置为Heroku环境变量（见第11章，*部署Node.js应用程序*）
- en: Configuring Passport
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Passport
- en: 'We''ll now make use of Passport to allow users to log into our site via Twitter.
    First, we need to install the relevant npm packages:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用Passport允许用户通过Twitter登录我们的网站。首先，我们需要安装相关的npm包：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can configure Passport to authenticate with Twitter. We add the following
    code under `src/config/passport.js`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`src/config/passport.js`下配置Passport以使用Twitter进行身份验证。我们添加以下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This uses the `TwitterStrategy` for authentication with Twitter, passing in
    our API key and secret on a configuration object. The second constructor parameter
    is a function that Passport will invoke after authenticating with Twitter (referred
    to as the **verify callback** in Passport's documentation). Here we set the current
    user's name based on the `profile.username` or `profile.displayName` provided
    from Twitter by Passport.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`TwitterStrategy`进行Twitter认证，通过配置对象传递我们的API密钥和密钥。第二个构造函数参数是一个函数，Passport在通过Twitter认证后会调用此函数（在Passport文档中称为**验证回调**）。在这里，我们根据Passport提供的来自Twitter的`profile.username`或`profile.displayName`设置当前用户的名字。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `profile` object contains the user profile returned by the authentication
    provider. Passport standardizes profile data to make it easier to work with multiple
    strategies. There's a standard set of fields, such as `displayName`, which all
    Passport strategies will populate if possible. We'd prefer to use the Twitter
    username (for example, hgcummings) than the display name (for example, Harry Cummings).
    The `profile.username` field contains the Twitter username. This is not one of
    the standard fields, but many strategies will return a field with this name. So
    we use `profile.username` first, but fall back to the more standard `profile.displayName`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`profile`对象包含认证提供者返回的用户个人资料。Passport将个人资料数据标准化，以便更容易与多个策略一起使用。有一个标准的字段集，例如`displayName`，所有Passport策略如果可能都会填充这些字段。我们更愿意使用Twitter用户名（例如，hgcummings）而不是显示名称（例如，Harry
    Cummings）。`profile.username`字段包含Twitter用户名。这不是标准字段之一，但许多策略会返回一个具有此名称的字段。因此，我们首先使用`profile.username`，但会回退到更标准的`profile.displayName`。'
- en: 'Now we just need to make use of our new passport module in Express. The following
    code is from `src/app.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在我们的Express应用程序中使用新的passport模块。以下代码来自`src/app.js`：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This tells our application to do three things:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们的应用程序执行以下三件事：
- en: Use Passport's Express middleware
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Passport的Express中间件
- en: Authenticate users via Twitter when they POST to `/auth/twitter`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户向`/auth/twitter`发送POST请求时，通过Twitter进行用户认证
- en: Handle Twitter authentication results at `/auth/twitter/callback` before redirecting
    users to the homepage
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将用户重定向到主页之前，在`/auth/twitter/callback`处理Twitter身份验证结果
- en: 'Finally, we need to provide a login button to reach our new endpoint as shown
    here in `src/views/index.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要提供一个登录按钮来访问我们新的端点，如`src/views/index.js`中所示：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you run the application and click **Log in using Twitter**, the following
    will happen:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序并点击**使用Twitter登录**，以下将发生：
- en: The application will redirect your browser to Twitter
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序将重定向你的浏览器到Twitter
- en: Twitter will prompt you to log in if you have not already
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你尚未登录，Twitter将提示你登录
- en: Twitter will ask whether you're happy with the application seeing your profile
    details and other public data
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter将询问你是否愿意应用程序查看你的个人资料详情和其他公开数据
- en: Twitter will then redirect your browser to the `/auth/twitter/callback` endpoint
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter将然后重定向你的浏览器到`/auth/twitter/callback`端点
- en: Your browser will make a request to this endpoint with your authentication token
    from Twitter
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的浏览器将向此端点发送带有Twitter认证令牌的请求
- en: Passport will validate this token then invoke our login handler function
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Passport将验证此令牌然后调用我们的登录处理函数
- en: When our function completes, Passport will return a redirect response to the
    homepage
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的函数完成后，Passport将返回一个重定向响应到主页
- en: We have now integrated Twitter authentication with our application! However,
    we're not really using it to allow users to log in. We're just associating a Twitter
    username with our existing user IDs created for each session. You can see this
    by opening up two separate browser sessions. Try logging in with each of them.
    If you create a new game in one browser, it appears in the other browser in the
    list of games created by other users. This is because you now have two user IDs
    associated with the same Twitter username.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将Twitter身份验证集成到我们的应用程序中！然而，我们并没有真正使用它来允许用户登录。我们只是将Twitter用户名与为每个会话创建的现有用户ID关联起来。你可以通过打开两个不同的浏览器会话来查看这一点。尝试使用它们中的每一个登录。如果你在一个浏览器中创建了一个新游戏，它会在另一个浏览器中出现在其他用户创建的游戏列表中。这是因为你现在有两个用户ID与同一个Twitter用户名相关联。
- en: 'We need to recognize the same user whenever they log in with the same Twitter
    account. This should not depend on being in the same browser session. To address
    this, we''ll need to do the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在用户使用相同的Twitter账号登录时识别出相同的用户。这不应该依赖于是否在同一个浏览器会话中。为了解决这个问题，我们需要执行以下操作：
- en: Persist user accounts to our database
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户账户持久化到我们的数据库
- en: Tell Passport how to store and retrieve users
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉 Passport 如何存储和检索用户
- en: Let Passport associate a user with the current session
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 Passport 将用户与当前会话关联起来
- en: Persisting user data with Redis
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Redis 持久化用户数据
- en: We already use Redis to associate usernames with user IDs. Now we want to be
    able to associate user IDs with Twitter accounts as well. The first time a user
    logs in with an external provider, we want to create a new user with the name
    taken from the external profile. Subsequent requests authenticated with the same
    provider will see the same user.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 Redis 将用户名与用户 ID 关联。现在我们希望也能将用户 ID 与 Twitter 账户关联起来。当用户第一次使用外部提供者登录时，我们希望创建一个新的用户，其名称来自外部配置文件。后续使用相同提供者进行身份验证的请求将看到相同的用户。
- en: 'We can implement this functionality using Redis''s `SETNX` operation. This
    will only set a key if it does not already exist and return whether this was the
    case. Our implementation is as follows from `src/services/users.js`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Redis 的 `SETNX` 操作来实现这一功能。这只会设置一个键，如果它不存在，并返回这是否是这种情况。我们的实现如下，来自 `src/services/users.js`：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we create a new user ID and tell Redis to associate it with the external
    provider (for example, Twitter) account. If we have seen the external account
    before, we return the user that was already associated with it. Otherwise, we
    persist a new user ID and associate it with the username from the external profile.
    Tests for this functionality can be found in the companion code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的用户 ID，并告诉 Redis 将其与外部提供者（例如，Twitter）账户关联起来。如果我们之前已经看到过这个外部账户，我们将返回之前已经与之关联的用户。否则，我们将持久化一个新的用户
    ID，并将其与外部配置文件中的用户名关联起来。对此功能的测试可以在配套代码中找到。
- en: Configuring Passport with persistence
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Passport 以实现持久化
- en: 'Now that we have a way of persisting users, we need to tell Passport how to
    make use of this. First, we update our verify callback to make use of our new
    `getOrCreate` function rather than just setting a username. Then we need to tell
    Passport how to identify and retrieve users associated with a session by serializing
    users to and from a string.The following code is from `src/config/passport.js`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了持久化用户的方式，我们需要告诉 Passport 如何利用这一点。首先，我们更新我们的验证回调，使用新的 `getOrCreate` 函数而不是仅仅设置一个用户名。然后我们需要告诉
    Passport 如何通过将用户序列化为字符串并从字符串反序列化来识别和检索与会话关联的用户。以下代码来自 `src/config/passport.js`：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Passport stores the string version of the user (returned by our `serializeUser`
    callback) on the session. It uses our `deserializeUser` callback to turn this
    string into a user object which it adds to the request. In our case, the string
    representation of the user is just their ID and deserialization is just a lookup
    in the users service.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Passport 将用户（由我们的 `serializeUser` 回调返回）的字符串版本存储在会话中。它使用我们的 `deserializeUser`
    回调将此字符串转换为用户对象，并将其添加到请求中。在我们的例子中，用户的字符串表示只是他们的 ID，反序列化只是用户服务中的查找。
- en: 'In order for this to work, we also need to tell our application to use Passport''s
    own session middleware, which works together with Express sessions. To avoid repetition,
    we''ll specify all of our session-related middleware in our session middleware
    module. The following is the code from `src/middleware/sessions.js`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这生效，我们还需要告诉我们的应用程序使用 Passport 的自己的会话中间件，它与 Express 会话一起工作。为了避免重复，我们将在会话中间件模块中指定所有与会话相关的中间件。以下是从
    `src/middleware/sessions.js` 的代码：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This module now returns three middleware instances. We want to use this with
    both Express and Socket.IO. The first of these is simple, since we can pass multiple
    middleware objects to the Express `app.use` function as here `src/app.js`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块现在返回三个中间件实例。我们希望同时使用 Express 和 Socket.IO。其中第一个很简单，因为我们可以将多个中间件对象传递给 Express
    的 `app.use` 函数，就像在这里 `src/app.js` 一样：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For Socket.IO, we need to adapt each middleware in turn as here `src/server.js`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Socket.IO，我们需要逐个调整每个中间件，就像在这里 `src/server.js` 一样：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that, in both cases, our users middleware is no longer needed and can now
    be deleted. However, this middleware previously ensured that there was always
    a user object on the request. This will now only be the case when there is a logged
    in user, so we need to update the rest of our application accordingly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这两种情况下，我们的用户中间件不再需要，现在可以删除。然而，这个中间件之前确保请求中始终有一个用户对象。现在这只有在有登录用户的情况下才会发生，因此我们需要相应地更新我们的应用程序的其他部分。
- en: 'There are a few places in our application that assume there will always be
    a user on the request. Since this is no longer guaranteed, there are two ways
    to resolve this: we can update our code to cope with no user being present on
    the request or we can hide functionality from unauthenticated users.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中有几个地方假设请求中始终存在用户。由于这不再得到保证，有两种解决方法：我们可以更新我们的代码以处理请求中没有用户的情况，或者我们可以从未认证用户那里隐藏功能。
- en: 'We still want unauthenticated users to be able to view public chat and to see
    and play games, so we update this functionality accordingly. The code from `src/realtime/chat.js`
    is updated as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然希望未认证用户能够查看公共聊天室，并查看和玩游戏，因此我们将相应地更新这些功能。来自`src/realtime/chat.js`的代码更新如下：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following code is from `src/realtime/games.js`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自`src/realtime/games.js`：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code is from `src/routes/games.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自`src/routes/games.js`：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Hiding functionality from unauthenticated users
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏对未认证用户的功能
- en: 'We certainly want unauthenticated users to be able to visit the home page of
    our application, but might not want to display all of the application''s functionality
    to them. To achieve this, we''ll update our index route as follows from `src/routes/index.js`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然希望未认证用户能够访问我们应用程序的主页，但可能不希望向他们显示应用程序的所有功能。为了实现这一点，我们将更新我们的index路由，如下所示，来自`src/routes/index.js`：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that this adds a `loggedIn` property to the view data instead of the user
    ID. The value of this property comes from the `isAuthenticated` function, which
    is added to the request by Passport. We use this to hide features that will no
    longer work for unauthenticated users and hide the login button from authenticated
    users. The following code is from `src/views/index.hjs`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这将在视图数据中添加一个`loggedIn`属性，而不是用户ID。这个属性的值来自`isAuthenticated`函数，该函数由Passport添加到请求中。我们使用这个属性来隐藏对未认证用户不再起作用的特性，并从认证用户那里隐藏登录按钮。以下代码来自`src/views/index.hjs`：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Integration testing with Passport
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Passport进行集成测试
- en: We still have one problem, which is that our integration tests won't work anymore.
    Only logged-in users can create games now. It would be a good idea to write a
    new integration test to check that Twitter authentication works. We don't want
    to introduce a Twitter account dependency to our current test though.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有一个问题，即我们的集成测试将不再工作。现在只有登录用户可以创建游戏。写一个新的集成测试来检查Twitter认证是否工作将是一个好主意。但我们不想将Twitter账户依赖性引入当前的测试中。
- en: 'Instead, we''ll make use of the passport-local strategy to allow our test to
    log in. We''ll install this as a dev dependency so it can''t accidentally run
    in production:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将利用passport-local策略来允许我们的测试登录。我们将将其作为开发依赖项安装，这样它就不会意外地在生产环境中运行：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We configure Passport to accept any username and password. If using passport-local
    for real, this is where you would check against credentials in your data store.
    The following code is from `src/config/passport.js`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置Passport接受任何用户名和密码。如果实际使用passport-local，这就是你会在数据存储中检查凭据的地方。以下代码来自`src/config/passport.js`：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we add a new local authentication endpoint to our application as here
    `src/app.js`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在应用程序中添加一个新的本地认证端点，如下所示`src/app.js`：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And finally update our test to login as a first step as code from `integration-test/game.js`
    shown follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新我们的测试以登录为第一步，如下所示，来自`integration-test/game.js`的代码：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Allowing users to log out
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许用户注销
- en: 'Users will also expect us to provide a way to log out of our application. Passport
    makes this easy by adding a `logout` function to the request. We just need to
    make use of this in one of our routes here `src/routes/index.js`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用户也会期望我们提供一种注销我们应用程序的方法。Passport通过向请求添加一个`logout`函数来简化这一点。我们只需要在我们的其中一个路由中利用这个功能`src/routes/index.js`：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can add a log out button to our view to make use of this new route as in
    `src/views/index.hjs`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在视图中添加一个注销按钮来利用这个新路由，如下所示`src/views/index.hjs`：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding other login providers
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加其他登录提供者
- en: 'Now that we have all the general infrastructure for authentication, adding
    additional providers is easy. Let''s add Facebook authentication as an example.
    First, we need to install the relevant Passport strategy:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所有认证的一般基础设施，添加额外的提供者很容易。让我们以添加Facebook认证为例。首先，我们需要安装相关的Passport策略：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we can update our Passport config file from `src/config/passport.js` as
    follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更新我们的Passport配置文件，如下所示`src/config/passport.js`：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here we've generalized our verify callback function to take different provider
    names, then used this with both Twitter and Facebook authentication strategies.
    We can re-use this to add further strategies in the same way. We just need to
    set the relevant environment variables for them to work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将验证回调函数泛化，使其接受不同的提供者名称，然后使用它来处理Twitter和Facebook身份验证策略。我们可以以相同的方式重用此功能来添加更多策略。我们只需设置相关的环境变量，它们就可以工作。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To obtain a Facebook App ID and Secret, create a new Facebook application at
    [https://developers.facebook.com/apps/](https://developers.facebook.com/apps/)
    (which requires you to have a Facebook account). This is very similar to the process
    for Twitter. Just create a new application of type Website, with a URL that matches
    your development environment (for example, `http://localhost:3000`). Once created,
    the App ID and App Secret will be visible on the Dashboard page for the application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Facebook App ID和密钥，请在[https://developers.facebook.com/apps/](https://developers.facebook.com/apps/)（需要您有一个Facebook账户）创建一个新的Facebook应用程序。这个过程与Twitter非常相似。只需创建一个类型为网站的新应用程序，其URL与您的开发环境相匹配（例如，`http://localhost:3000`）。创建后，App
    ID和App Secret将在应用程序的仪表板页面上可见。
- en: 'We also need to add Facebook authentication routes to our application config
    file. These are just the same as the corresponding Twitter routes. As with the
    Passport `config` file, we can commonize by parameterizing the provider name.
    The code from `src/app.js` is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将Facebook身份验证路由添加到我们的应用程序配置文件中。这些路由与对应的Twitter路由相同。与Passport `config` 文件一样，我们可以通过参数化提供者名称来实现通用化。`src/app.js`中的代码如下：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we need to add a button to allow users to log in with Facebook. The
    following code is from `src/views/index.hjs`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个按钮，允许用户使用Facebook登录。以下代码来自`src/views/index.hjs`：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Adding additional providers is easy. To add Google+ authentication, we would
    just need to follow these steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 添加额外的提供者很容易。要添加Google+身份验证，我们只需遵循以下步骤：
- en: Install the `passport-google npm` module
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`passport-google npm`模块
- en: Create a new application as described at [https://developers.google.com/identity/protocols/OpenIDConnect](https://developers.google.com/identity/protocols/OpenIDConnect)
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照描述在[https://developers.google.com/identity/protocols/OpenIDConnect](https://developers.google.com/identity/protocols/OpenIDConnect)创建一个新的应用程序。
- en: Update the three files listed above, passing the Google provider to our new
    common functions
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新上述三个文件，将Google提供者传递给我们的新通用函数
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have added authentication to our Express application using
    Passport, introduced Express sessions using Redis for session storage, leveraged
    multiple Passport strategies to support different external providers, and persisted
    user data in Redis.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Passport在我们的Express应用程序中添加了身份验证，使用Redis作为会话存储引入了Express会话，利用多个Passport策略来支持不同的外部提供者，并在Redis中持久化用户数据。
- en: 'This completes our example web application. In the next chapter we will look
    at how to create different kinds of Node.js project: a library and a command-line
    tool.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的示例Web应用程序。在下一章中，我们将探讨如何创建不同类型的Node.js项目：一个库和一个命令行工具。
