- en: Chapter 1. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 引言
- en: Learning how to understand a single line of code, building that first "Hello
    World" script, and experiencing the thrill when it works as you expect are the
    small steps that draw us into the world of programming. This book is about the
    projects we can build in this world using Sencha's Ext JS 5 and how to ensure
    you're building on a strong foundation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何理解一行代码，构建第一个“Hello World”脚本，并在它按预期工作时的兴奋感，这些都是吸引我们进入编程世界的小步骤。这本书是关于我们在这个世界中可以使用Sencha的Ext
    JS 5构建的项目，以及如何确保你是在一个坚实的基础之上构建。
- en: 'In this chapter, we''re going to examine why strong application architecture
    is important from a theoretical and practical point of view. We''ll introduce
    the rest of the book and answer the following questions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从理论和实践的角度探讨为什么强大的应用程序架构很重要。我们将介绍本书的其余部分，并回答以下问题：
- en: What is application architecture?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序架构是什么？
- en: How is it important?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为什么很重要？
- en: How does Ext JS help with application design?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS 如何帮助进行应用程序设计？
- en: How will this book help your software architecture?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这本书将如何帮助您提升软件架构？
- en: Let's start with talking about what we mean by software architecture and why
    it's important for a successful project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来谈谈我们所说的软件架构是什么，以及为什么它对于一个成功的项目来说如此重要。
- en: Humble beginnings
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谦逊的起点
- en: As coders, many of us would have started our development career by writing scripts
    or code that we found helpful, which helped out with a hobby. That buzz, the insight
    that you can create something practical and useful, that's where the passion starts.
    It's from these hastily assembled first few lines on which many of us have built
    a career.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们中的许多人可能都是从编写对我们有帮助的脚本或代码开始的，这些脚本或代码帮助我们的爱好。那种兴奋感，那种你可以创建实用和有用的东西的洞察力，这就是激情的起点。正是这些匆忙拼凑起来的最初几行代码，许多人都建立了自己的职业生涯。
- en: In those early days, we found ourselves writing code that spanned hundreds of
    lines, but with no regard for how it might look if we came back to it in six months.
    Would it be understandable? Can a feature be added without breaking something
    else? Also, what if we want to share it with a friend or on the Internet? Trying
    to work out the cause of a bug is going to rapidly become a nightmare.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些早期日子里，我们发现自己编写了数百行的代码，但并没有考虑到如果我们六个月后回来会是什么样子。它是否容易理解？在不破坏其他东西的情况下能否添加一个功能？此外，如果我们想与他人或互联网上分享它怎么办？试图找出错误的原因将迅速变成一场噩梦。
- en: In fact, the Internet is littered with such code. Why is this a problem? Let's
    say you got roped into building a simple shopping cart for a friend. You knew
    enough to get it working, but also enough to be dangerous. A shopping cart is
    responsible for taking payment for goods, and a single security hole could result
    in someone being out of pocket. Suddenly, your favor for a friend has become something
    that has caused them to lose face and money.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，互联网上充斥着这样的代码。这为什么会成为问题？假设你被卷入为一个朋友构建一个简单的购物车。你足够了解使其工作，但也足够危险。购物车负责处理商品的支付，一个安全漏洞可能导致有人损失钱财。突然之间，你为朋友做的善事变成了让他们丢脸和损失金钱的事情。
- en: Fortunately, in my case, there were no drastic ramifications for my lack of
    development expertise as a newcomer to coding. I created a PHP script. This script
    generated a photo gallery for a website. It started off as a list of photos and
    expanded to include thumbnail generation, pagination, and an administration/upload
    facility. It was an example of traditionally bad PHP with HTML mixed in with logic
    code and spaghetti loops to try and make the thing work the way I wanted.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，就我而言，作为一个编码的新手，我缺乏开发专业知识并没有带来太大的影响。我创建了一个PHP脚本。这个脚本为网站生成相册。它最初是一系列照片，后来扩展到包括缩略图生成、分页和行政/上传功能。这是一个传统上糟糕的PHP示例，其中HTML与逻辑代码混合，以及意大利面般的循环来尝试使它按我的意愿工作。
- en: With time, the solution comes organically; we start to break our work into smaller
    chunks that make sense for the application. It will slowly become clear that there
    are sensible ways of working, which make life easier, as your codebase grows.
    In the photo gallery example, I could start to extract very simple aspects (such
    as headers, footers, and pagination links) in order to focus on the core functionality.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，解决方案会自然产生；我们开始将我们的工作分解成对应用程序有意义的更小的部分。随着代码库的增长，将逐渐变得清晰，有合理的工作方式会使生活变得更轻松。在相册示例中，我可以开始提取非常简单的方面（例如标题、页脚和分页链接），以便专注于核心功能。
- en: Of course, not everyone starts this way. Developing a hobby into a career is
    just one path by which the coding community develops its skillset. University
    or online courses, books, and forums contribute to our learning process. The important
    thing to bear in mind is that neither coder nor architect was born into the world
    knowing everything and it's okay, even essential, to admit when there's a gap
    in your knowledge. From a senior consultant to hobbyist hacker, we're going to
    try and fill some of these gaps, as you build larger and more complex applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并不是每个人都以这种方式开始。将爱好发展成为职业只是编码社区发展技能集的一条途径。大学或在线课程、书籍和论坛都有助于我们的学习过程。重要的是要记住，无论是程序员还是架构师，都不是生来就知道一切的，承认自己的知识有差距是正常的，甚至是必要的。从资深顾问到业余黑客，我们将尽力填补这些差距，随着你构建更大、更复杂的应用程序。
- en: Growing up
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成长
- en: Rather than writing code that is for a hobby or side project, we're now writing
    applications that help run businesses. Someone is paying for this development
    time, and someone's livelihood is relying on it. As professional software developers,
    we need to adopt a professional mindset and skillset to match. Rather than coming
    up with an idea and sitting down to code it immediately, we need to carefully
    consider how our application is constructed. We need to ensure that it will work
    as expected when real-world users get their hands on it; this will provide a strong
    platform for future developers to build on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与其编写仅供爱好或副项目的代码，我们现在编写的是帮助运营企业的应用程序。有人正在为这种开发时间付费，有人的生活依赖于它。作为专业的软件开发者，我们需要采取专业的心态和技能集。与其立即坐下来编码一个想法，我们需要仔细考虑我们的应用程序是如何构建的。我们需要确保它在现实世界的用户接触到它时能够按预期工作；这将提供一个强大的平台，供未来的开发者在此基础上构建。
- en: As software developers, we can be responsible for tens of thousands of lines
    of code—and in many cases more—and may be working in a team comprising a range
    of other individuals. At this scale, badly designed applications can become unwieldy,
    unreliable, and difficult to test.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发者，我们可能要负责成千上万行代码——在许多情况下更多——并且可能在一个由各种其他个人组成的团队中工作。在这个规模上，设计不良的应用程序可能会变得难以控制、不可靠且难以测试。
- en: It's unwieldy because without a strong design, functionality is tacked on as
    it's required, building on an already shaky foundation; unreliable because this
    shaky foundation has cracks crawling with bugs, and difficult to test because
    the system's parts are so intertwined that each component doesn't have a clear
    set of responsibilities and capabilities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它难以控制，因为没有强大的设计，功能是按需附加的，建立在已经摇摇欲坠的基础上；不可靠，因为这种摇摇欲坠的基础有裂缝，布满了虫子，难以测试，因为系统的各个部分如此交织在一起，以至于每个组件都没有一个明确的职责和能力集合。
- en: This is the danger of taking an idea and running with it; you may be creating
    code that grows out of control like a weed in a garden. A design is the key because
    it allows you to be the gardener (carefully tending each facet of the system as
    it grows). We want to create a clear, positive structure for our team members
    to start from and build on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将一个想法付诸实践的危险；你可能会创建出像花园里杂草一样失控的代码。设计是关键，因为它允许你成为园丁（仔细照料系统成长的每一个方面）。我们希望为我们的团队成员提供一个清晰、积极的起点，并在此基础上构建。
- en: The structure we want to create in an application should give us clear delineation
    between one component and another. Each part of the system should be responsible
    for itself and nothing more (a small part in a larger machine). The layers of
    our code (from data to presentation and all the wiring in between) should also
    be clear-cut because no one wants to see a template talking directly to a backend
    service.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在应用程序中创建的结构应该在我们想要创建的结构中，应该给我们清晰的划分，一个组件与另一个组件之间。系统的每个部分都应该对自己负责，而无需更多（在一个更大的机器中的一个小部分）。我们的代码层（从数据到展示以及所有中间的连接）也应该清晰明确，因为没有人想看到模板直接与后端服务对话。
- en: This is a classic example of overlapping concern. In this presentation, code
    should never have to worry about fetching data, only how to present it. This,
    and many more such issues, can be easily avoided with a strong structure and application
    design that is implemented from the start.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的重叠关注示例。在这个演示中，代码永远不应该担心获取数据，而应该关注如何展示。通过强大的结构和从一开始就实施的应用程序设计，可以轻松避免许多此类问题。
- en: The shoulders of giants
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 巨人的肩膀
- en: Many have gone on this journey of scalability before us. It's worth remembering
    that there are many formal metrics to help us determine whether our code is too
    complex. "Cyclomatic complexity" is one example, a technique that evaluates details
    (such as code cohesion and branching depth) and can be tied into automated systems
    that raise a warning when a threshold for complexity is crossed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前，许多人已经走上了可扩展性的道路。值得记住的是，有许多正式的指标可以帮助我们确定我们的代码是否过于复杂。“循环复杂度”就是一个例子，这是一种评估细节（如代码凝聚力和分支深度）的技术，并且可以与自动系统结合，当复杂度超过阈值时发出警告。
- en: In reality though, such metrics are a method of firefighting complexity rather
    than planning to avoid it. By looking at ways in which we can structure our code
    for success, we can minimize the need for such automated checks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实中，这样的指标是应对复杂性的方法，而不是避免复杂性的计划。通过考虑我们如何结构化代码以取得成功，我们可以最大限度地减少对这种自动检查的需求。
- en: The first stop must be **object-orientated programming** (**OOP**). By encouraging
    a piece of functionality to be encapsulated in a class, we immediately impose
    a sense of separation in our application. Just as splitting our multi-hundred-line
    script into separate chunks made sense, here we can formalize this approach by
    creating classes that take responsibility for a single piece of functionality.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步必须是**面向对象编程**（**OOP**）。通过鼓励将一部分功能封装在类中，我们立即在我们的应用程序中引入了一种分离感。正如将我们的多行脚本拆分成单独的块是有意义的一样，这里我们可以通过创建负责单一功能的类来正式化这种方法。
- en: With the photo gallery, the pagination is a great example of where concerns
    could overlap. My original implementation just had a lot of loops and conditional
    statements wrapped up with the HTML. Instead, we can have one class that does
    the logic of the pagination (for example, whether the "next" link is available)
    and another class responsible for generating the HTML based on this data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在相册中，分页是一个很好的例子，说明了关注点可能重叠。我的原始实现只是有很多循环和条件语句与 HTML 混合在一起。相反，我们可以有一个类来处理分页的逻辑（例如，是否可以点击“下一页”链接），另一个类则负责根据这些数据生成
    HTML。
- en: In Ext JS 4, Sencha brought in a new class system that allows you to better
    create objects that encapsulate application functionality as well as a strong
    application framework. Ext JS 5 builds on this and adds some extra features to
    make the Ext JS application architecture ideal for everyone (from individual developers
    to large teams). The structured approach that it makes available allows you to
    scale a code base while keeping its foundations strong.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 4 中，Sencha 引入了一种新的类系统，它允许你更好地创建封装应用程序功能以及强大应用程序框架的对象。Ext JS 5 在此基础上进行了扩展，并添加了一些额外功能，使
    Ext JS 应用程序架构对每个人（从个人开发者到大型团队）都理想化。它提供的结构化方法允许你在保持其基础稳固的同时扩展代码库。
- en: What is application architecture?
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序架构是什么？
- en: Most people have a general idea of the role of a traditional architect, creating
    precise diagrams to pass on to the builders and other craftsmen who will undertake
    construction. More than this, an architect needs to consider the materials used,
    the aesthetics of a building, and oversee the construction process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人对传统建筑师的角色有一个大致的了解，即创建精确的图表传递给建筑工人和其他工匠，他们将承担建设工作。更重要的是，建筑师需要考虑使用的材料、建筑的美学，并监督施工过程。
- en: 'In the world of software, the architect has a similar role: design and supervision.
    We need to invest in the role of an architect and ensure that we make it an end-to-end
    process that ensures we take responsibility of the quality of the final product.
    Design and supervision requires a comprehensive knowledge of the product requirements,
    the technologies involved, and the available resources. The architecture of a
    software program (our "raison d''etre") is multifaceted, from the quality of the
    up-front documentation that dictates how the project will be built, to the finesse
    of the end product, which users will love to work with.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件的世界里，架构师的角色类似：设计和监督。我们需要投资于架构师的角色，并确保我们将其打造为一个端到端的过程，以确保我们对最终产品的质量负责。设计和监督需要全面了解产品需求、涉及的技术和可用资源。软件程序（我们的“存在理由”）的架构是多方面的，从决定项目如何构建的前期文档的质量，到用户乐于使用的最终产品的精致程度。
- en: Requirement analysis
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求分析
- en: A software project should never begin without a list of requirements from the
    customer, client, or other stakeholder. This is often in the form of a detailed
    specification document. Requirement analysis involves the architect understanding
    the problem that needs to be solved and applying what they've learned to the next
    stages of the process.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目在没有客户、客户或其他利益相关者的需求列表的情况下不应开始。这通常以详细规范文档的形式出现。需求分析涉及建筑师理解需要解决的问题，并将他们所学应用到过程的下一阶段。
- en: 'Here''s a short example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简短的例子：
- en: '*Users should be able to log in, log out, register, and request a new password.
    Login should be persistent across browser sessions.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户应该能够登录、登出、注册和请求新密码。登录应跨浏览器会话持续。*'
- en: 'The architect reads this and the developers (in turn) end up with the following
    code to handle user logins:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑师阅读了这些内容，开发者（依次）得到了以下代码来处理用户登录：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should be familiar to a seasoned Ext JS developer: we use `Ext.define`
    to create a class called `MyApp.SessionManager`. The login method contains an
    invocation of a login method on the `User` class and triggers a callback if it
    succeeds. Using `Ext.bind`, we set the scope of the success callback to the `SessionManager`
    class and when it''s called, we set the `isLoggedIn` value to `true`. Further
    code would then redirect the authenticated user to the rest of the application.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于经验丰富的Ext JS开发者来说应该是熟悉的：我们使用`Ext.define`创建一个名为`MyApp.SessionManager`的类。登录方法包含对`User`类中登录方法的调用，并在成功时触发回调。使用`Ext.bind`，我们设置成功回调的作用域为`SessionManager`类，当它被调用时，我们将`isLoggedIn`值设置为`true`。进一步的代码将重定向认证用户到应用的其余部分。
- en: 'The problem is that the architect has not correctly processed the requirements.
    They have missed the second part (the part that mandates that logins should be
    persistent across sessions). In this code sample, we store the login state in
    memory. To support the requirements, we should use a cookie, `localStorage`, or
    some other storage mechanism to make the login available between browser sessions.
    What will this code look like? Let''s tweak this class a little, change one method,
    and add a few more methods:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于建筑师没有正确处理需求。他们遗漏了第二部分（这部分要求登录状态应在会话间持续）。在这个代码示例中，我们存储登录状态在内存中。为了支持这些需求，我们应该使用cookie、`localStorage`或某种其他存储机制，以便在浏览器会话之间使登录可用。这段代码会是什么样子呢？让我们稍微调整一下这个类，更改一个方法，并添加几个更多的方法：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The replacement `loginSuccess` method passes off to `setUser`, which makes use
    of `localStorage` to persist user details across browser sessions. We also provide
    an additional `isUserLoggedIn` method to check `localStorage` for any user details
    and a `getUser` method to grab these details. Note the use of `Ext.encode` and
    `Ext.decode` to convert JavaScript objects to strings that can be inserted into
    `localStorage`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 替换后的`loginSuccess`方法将调用`setUser`，它使用`localStorage`在浏览器会话之间持久化用户详情。我们还提供了一个额外的`isUserLoggedIn`方法来检查`localStorage`中是否有任何用户详情，以及一个`getUser`方法来获取这些详情。注意`Ext.encode`和`Ext.decode`的使用，它们将JavaScript对象转换为可以插入到`localStorage`中的字符串。
- en: This is a more realistic implementation of this functionality that needs to
    be better specified at a higher level. Without translating this requirement from
    the client's stipulations through to the developer's instructions, we'd be omitting
    an important part of the application's feature set.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个功能更现实的实现，需要在更高层次上更好地指定。如果不将这个需求从客户的规定翻译到开发者的指令，我们将遗漏应用功能集的一个重要部分。
- en: Data design
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据设计
- en: 'As with much of the application architecture, it will be a collaborative effort
    between the architect, developers, database administrators, and other members
    of the technical team. Data design is the result of a discussion about the data
    you need to store, where it will be stored, and how this will be reflected in
    the stores and models in your Ext JS. Let''s look at a theoretical requirement
    for an application:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像应用架构的许多方面一样，这将是建筑师、开发者、数据库管理员和技术团队其他成员之间的协作努力。数据设计是关于需要存储的数据、存储位置以及如何在Ext
    JS的存储和模型中反映这些数据的讨论结果。让我们看看一个应用的理论需求：
- en: '*After three failed login attempts, the user account will be locked for 30
    minutes.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*连续三次登录失败后，用户账户将被锁定30分钟。*'
- en: This means that we need to record the number of failed login attempts and the
    last login attempt in the `User` model or some other persistence method (such
    as a server-side database). Without it, we wouldn't be able to create the correct
    client-side logic and UI to support this requirement.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要在`User`模型或其他持久化方法（例如服务器端数据库）中记录失败的登录尝试次数和最后一次登录尝试。没有这些信息，我们就无法创建正确的客户端逻辑和UI来支持这一需求。
- en: Code design
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码设计
- en: 'Perhaps, the bulk of an architect''s work comes from structuring the application''s
    code base. Depending on the size of the team, the architect may or may not be
    involved in writing the code itself, but they will have intimate knowledge of
    the application at a higher level (almost certainly at the class level and in
    important situations at the method level). In many cases, UML or other diagramming
    tools will be used to provide a way of recording and sharing the design, as shown
    in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，架构师的大部分工作来自于构建应用程序的代码库。根据团队的大小，架构师可能或可能不直接编写代码，但他们将在更高层次（几乎肯定是在类级别，在重要情况下在方法级别）对应用程序有深入了解。在许多情况下，UML或其他绘图工具将被用来提供记录和共享设计的方式，如下面的图表所示：
- en: '![Code design](img/5308OT_01_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![代码设计](img/5308OT_01_01.jpg)'
- en: A UML-like diagram showing the models in a theoretical music application
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似于UML的图表，展示了理论音乐应用程序中的模型
- en: 'The `Album` class that comes from this would look like the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个模型中产生的`Album`类将如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We define fields with the `reference` config to set up a many-to-one relationship
    between artists and albums, and albums and tracks. The `getRunningTime` method,
    which was shown in the previous class diagram, is an example of an area that an
    architect might not get involved in (they can leave the implementation details
    of this method to a developer).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`reference`配置定义字段，以在艺术家和专辑、专辑和曲目之间设置多对一关系。在之前类图中展示的`getRunningTime`方法是一个架构师可能不会涉足的领域（他们可以将此方法的实现细节留给开发者）。
- en: This is the key aspect of architecture that we'll be covering in this book.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书将要涵盖的架构的关键方面。
- en: Technology evaluation
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术评估
- en: 'In this book, we will discuss Ext JS 5, so our technology choice should be
    fairly straightforward! Nonetheless, it''s important for an architect to evaluate
    all of the relevant parts of their technology stack to ensure that it supports
    the product requirements. Here are some technology questions that are still relevant
    in our situation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将讨论Ext JS 5，因此我们的技术选择应该是相当直接的！然而，对于架构师来说，评估他们技术栈的所有相关部分以确保其支持产品需求是非常重要的。以下是我们当前情况下仍然相关的一些技术问题：
- en: Do we need to cater to various form factors (such as mobile and tablet)?
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否需要适应各种形态（如移动和平板）？
- en: Do we need to support Internet Explorer 8?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否需要支持Internet Explorer 8？
- en: Do we need to talk to a SOAP service?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否需要与SOAP服务通信？
- en: All of these have potential ramifications that an architect must evaluate while
    planning a project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都有潜在的后果，架构师在规划项目时必须评估。
- en: Code standards and practices
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码标准和实践
- en: In the same way that a building architect must make sure the design they create
    adheres to building code and safety regulations as well as ensuring the materials
    they use will create a pleasing finish, software architects must also take steps
    to guarantee the quality of the finished product.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就像建筑架构师必须确保他们创建的设计遵守建筑规范和安全法规，并确保他们使用的材料将创造出令人愉悦的最终效果一样，软件架构师也必须采取措施来保证最终产品的质量。
- en: Naming conventions, formatting guidelines, a process to deploy the application—all
    these contribute to having a professional workflow that makes it easy for the
    developers and project to succeed. The architect is the guiding hand, bringing
    the customer something that exceeds their expectations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定、格式指南、部署应用程序的过程——所有这些都有助于建立一个专业的流程，使开发者和项目更容易成功。架构师是指导之手，为顾客带来超出他们期望的东西。
- en: Documentation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档
- en: 'There are many reasons why documenting the development process is a good idea.
    For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 记录开发过程有很多原因。例如：
- en: Transparency between team members
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队成员之间的透明度
- en: Providing a point of reference during development
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中提供参考点
- en: Offering a comparison for post-project review
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目后审查提供比较
- en: 'Having a single point of reference for the design documents helps in a large
    team and assists with bringing new team members up to speed. It''s a very bad
    idea for the architect to hold all of their ideas in their head, and it''s a very
    good idea for this knowledge to be shared, discussed, and recorded. Such documentation
    might come in a variety of forms:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型团队来说，拥有单一的设计文档参考点有助于提高效率，并帮助新团队成员快速熟悉情况。建筑师将所有想法都保留在头脑中是一个非常糟糕的想法，而让这些知识得到共享、讨论和记录则是一个非常好的主意。此类文档可能以多种形式出现：
- en: Class diagrams
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类图
- en: UI wireframes
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI线框
- en: User stories
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户故事
- en: Coding standards
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码标准
- en: Code documentation
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码文档
- en: Code documentation will often be automatically created as part of a build process,
    but an architect will be responsible for mandating this code to be documented
    and instituting a build step to generate it. Other forms will be part of a manual
    process and can involve the client, the development team, and the architect.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码文档通常会在构建过程中自动生成，但建筑师将负责强制要求这些代码得到文档化，并实施一个构建步骤来生成它。其他形式将是手动过程的一部分，可能涉及客户、开发团队和建筑师。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These definitions are up for discussion! Wikipedia's software architecture page
    is extensive and offers multiple points of view at [http://en.wikipedia.org/wiki/Software_architecture](http://en.wikipedia.org/wiki/Software_architecture).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义是值得讨论的！维基百科的软件架构页面内容丰富，提供了多个观点，请参阅[http://en.wikipedia.org/wiki/Software_architecture](http://en.wikipedia.org/wiki/Software_architecture)。
- en: In the next few pages, we'll look at how software and software developers can
    find themselves in possession of an unwieldy code base, what makes it unwieldy,
    why it's a problem. We'll also look at the attributes that make for a well-architected
    software product.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将探讨软件和软件开发人员如何发现自己拥有一个难以管理的代码库，是什么让它难以管理，为什么这是一个问题。我们还将探讨使软件产品架构良好的属性。
- en: Ext JS
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext JS
- en: Before version 4 of Ext JS, Sencha didn't try to impose any kind of structure
    on our applications. Components were split across multiple files, but other than
    this, we didn't have any guidance on how they should communicate or how they are
    pieced together to form an application. Ext JS began with version 1.0 on April
    15, 2007 as a library of user interface widgets—buttons, trees, grids, and features
    (such as layouts) to help them all hang together, but not much more than this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS 4.0版本之前，Sencha并没有试图对我们的应用程序施加任何结构。组件分散在多个文件中，但除此之外，我们没有关于它们应该如何通信或如何组合成应用程序的任何指导。Ext
    JS始于2007年4月15日的1.0版本，作为一个用户界面小部件库——按钮、树、网格和功能（如布局），以帮助它们保持一致，但仅此而已。
- en: At the time, this didn't seem to matter much. The idea of a single page application
    written in JavaScript still felt like the technology of the future, and while
    it was starting to happen, it certainly wasn't as ordinary as it was in 2014\.
    Augmenting existing web pages with slick Ajax-powered widgets was more than enough.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，这似乎并不重要。用JavaScript编写的单页应用程序仍然感觉像是未来的技术，尽管它已经开始出现，但它在2014年并不像现在这样普通。通过添加Ajax驱动的滑块小部件来增强现有网页已经足够了。
- en: As time went on, with lots of widgets and dynamic parts of the website all needing
    to interact, the requirement for a formal mechanism for intercommunication became
    obvious. People were using Ext JS to build enterprise-level applications that
    specified high levels of availability and therefore rigorous testing regimes.
    Spaghetti code just wasn't going to cut it anymore.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，随着许多小部件和网站动态部分都需要交互，正式的交互机制的需求变得明显。人们使用Ext JS构建需要高可用性的企业级应用程序，因此需要严格的测试制度。面条代码已经不再适用。
- en: The world that was
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那个世界
- en: 'Let''s take a look at a classic piece of example code from back in the days
    of Ext 3.4:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下Ext 3.4时代的一个经典示例代码：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This block of code should be familiar to the reader as something that generates
    a populated grid:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对于读者来说应该是熟悉的，因为它生成一个填充的网格：
- en: '![The world that was](img/5308OT_01_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![那个世界](img/5308OT_01_02.jpg)'
- en: When a row on the grid is clicked on, an alert box appears showing the index
    of the target row. This is all well and good. It represents a fairly typical example
    of what you'd have seen in the Ext JS documentation at the time of Ext JS 3.4.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当在网格上点击一行时，会出现一个警报框，显示目标行的索引。这很好。这是一个相当典型的例子，你在Ext JS 3.4时期的文档中可能会看到。
- en: So, what's the problem? The problem is that this code does everything. It sets
    up our data store, drawing JSON from either a remote or local source. It creates
    the grid itself along with its many configuration options. It sets up event handling
    code to pop up the alert box. And after all that's been done, it finally renders
    the grid to the screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，问题是什么？问题是这段代码做了一切。它设置了我们的数据存储，从远程或本地源绘制JSON。它创建了网格本身及其许多配置选项。它设置了事件处理代码以弹出警告框。在所有这些完成后，它最终将网格渲染到屏幕上。
- en: Within a simple piece of code like this, the problem is less pronounced. Although,
    when more functionality is added, such as paging or a detail window popping up
    with further information about a record and tying all of this into a larger application
    with server-side interaction, multiple screens, and so on, then things start to
    get tricky.This is the type of issue that Sencha tried to resolve by introducing
    defined architectural practices in Ext JS 4\. Rather than putting everything together
    and mixing all these different concerns, the idea was that they could be pulled
    apart into more logical, concise, and distinct objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样一段简单的代码中，问题并不明显。尽管如此，当添加更多功能时，例如分页或弹出包含关于记录的更多信息详情窗口，并将所有这些与一个更大的应用程序结合，包括服务器端交互、多个屏幕等，那么事情开始变得复杂。这正是Sencha试图通过在Ext
    JS 4中引入定义的架构实践来解决的问题。而不是把所有东西都放在一起，混合所有这些不同的关注点，想法是它们可以被拆分成更逻辑、简洁和明确的对象。
- en: State of the art
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最先进的技术
- en: The **model-view-controller** (**MVC**) pattern was the choice of the new wave
    of web developers. Ruby on Rails had already popularized MVC and many other major
    frameworks had brought their own ideas to the table.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）模式是新波Web开发者的选择。Ruby on Rails已经普及了MVC，许多其他主要框架也提出了自己的观点。'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While MVC has often been used in web development over recent years, it's used
    elsewhere in software development and, indeed, was originally developed for desktop
    GUI coding. Learning about MVC as a general concept is outside our scope, but
    there's plenty of information and examples on the Web.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MVC模式近年来在Web开发中经常被使用，但在软件开发的其他地方也被使用，实际上它最初是为桌面GUI编码开发的。关于MVC作为一个一般概念的了解超出了我们的范围，但在网上有大量的信息和示例。
- en: Ext JS 4.0 was released on April 26, 2011, over 4 years after v1.0, and many
    developers were already comfortable with using the MVC pattern in their server-side
    apps. Frameworks (such as Backbone.js) had slowly begun to give developers the
    tools to use such architectural patterns in their client-side code. Ext JS 4 needed
    to do the same and it delivered.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 4.0于2011年4月26日发布，距离v1.0版本已有4年多，许多开发者已经习惯了在他们的服务器端应用中使用MVC模式。框架（如Backbone.js）已经逐渐开始为开发者提供在客户端代码中使用这种架构模式的工具。Ext
    JS 4需要做到同样的事情，并且它做到了。
- en: Mostly very cool
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大部分都非常酷
- en: Prior to version 4, Ext JS had stores and records (the "model" in MVC). It had
    components or widgets (the "view" in MVC). The architectural issue was twofold;
    how did models and views talk to each other? How did we avoid making our views
    bloated with logic code?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本4之前，Ext JS有存储库和记录（MVC中的“模型”）。它有组件或小部件（MVC中的“视图”）。架构问题有两个方面；模型和视图如何相互通信？我们如何避免让我们的视图逻辑代码膨胀？
- en: One answer was to introduce the controller concept. This allowed us to create
    a layer of glue to create stores, hook them up to components, and use events to
    manage communication between all of these parts of the application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是引入控制器概念。这允许我们创建一个粘合层来创建存储库，将它们连接到组件上，并使用事件来管理应用程序所有这些部分之间的通信。
- en: In version 5 of Ext JS, a couple of extra features fully answered our architectural
    questions with ViewControllers and ViewModels. ViewControllers allow us to separate
    out logic code in our views into a distinct class, ensuring that both the view
    and ViewController can focus on their own set of responsibilities.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS的第五版中，通过ViewControllers和ViewModels引入了一些额外的功能，完全回答了我们的架构问题。ViewControllers允许我们将视图中的逻辑代码分离到一个独立的类中，确保视图和ViewController都能专注于它们自己的责任集。
- en: Supporting cast
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持角色
- en: As well as building classes into the Ext JS framework to help us build complicated
    applications, Sencha has also provided a number of supplementary tools that assist
    with the development process. In particular, Sencha Cmd is a powerful command-line
    tool that introduces some indispensable facilities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在Ext JS框架中构建类以帮助我们构建复杂的应用程序之外，Sencha还提供了一系列辅助工具，这些工具有助于开发过程。特别是，Sencha Cmd是一个强大的命令行工具，它引入了一些不可或缺的功能。
- en: From the beginning, Sencha Cmd can help by generating the directory structure
    of your application with a best practice layout, specifically created to help
    with the new Ext JS 5 cross-device support. You can add new models, controllers,
    and so on, all from the command line.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Sencha Cmd就可以通过生成具有最佳实践布局的应用程序目录结构来帮助你，这个布局是专门为帮助新的Ext JS 5跨设备支持而创建的。你可以从命令行添加新的模型、控制器等。
- en: As you're developing, Sencha Cmd can help you by compiling theme files, slicing
    and dicing images, and running a development web server to run your code locally.
    Also, during testing and deployment, it can package your code into an optimized
    bundle to give your users the minimum amount of code to download in their browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开发的过程中，Sencha Cmd可以通过编译主题文件、切割和切片图像以及运行本地开发Web服务器来运行你的代码，从而帮助你。此外，在测试和部署期间，它可以将你的代码打包成优化的包，以便你的用户在浏览器中下载最少的代码。
- en: Sencha Cmd is a great example of a product that is growing up. It represents
    a key piece of your development infrastructure and a fantastic complement to the
    Ext JS framework itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha Cmd是成长中的产品的绝佳例子。它代表了你开发基础设施的关键部分，也是Ext JS框架本身的绝佳补充。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We know about the issues we'd like to address and how we're going to learn to
    do so. So, now let's look at some of the non-architectural aspects of an application
    that you might want to think about even before starting to put pen to paper on
    the design. While everything we've discussed so far talks about the overarching
    method to shape the development of an application, the other parts of the puzzle
    can often be just as important.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了我们想要解决的问题以及我们将如何学习去解决这些问题。因此，现在让我们来看看一些在开始设计之前你可能需要考虑的应用的非架构方面。虽然我们之前讨论的每一件事都谈到了塑造应用发展的总体方法，但拼图的其他部分往往同样重要。
- en: The specification
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范
- en: 'How do you design an application without knowing what it is you''re designing?
    This is what a specification provides. A document or series of documents that
    describe in exacting detail how the features that make up your software should
    behave. It''s a continuing mistake in the software business that we don''t collect
    the requirements of our users and clients before we start writing code. In the
    same way that it''s irresponsible to build an application without architecting
    it correctly, it''s irresponsible to build an application without being as certain
    as possible that you''re creating the correct thing for a paying customer. What
    sort of issues can a specification avoid? Some of them are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你在不知道你要设计什么的情况下如何设计一个应用程序？这正是规范所提供的。一份或一系列文档，详细描述了构成你的软件的功能应该如何表现。在软件行业中，我们开始编写代码之前不收集用户和客户的需求是一个持续的错误。就像在没有正确架构的情况下构建应用程序是不负责任的一样，在没有尽可能确定你为付费客户创建的是正确的东西的情况下构建应用程序也是不负责任的。规范可以避免哪些问题？以下是一些例子：
- en: Missed deadlines
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赶不上截止日期
- en: Cost overruns
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出预算
- en: Developer stress
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者压力
- en: Customer dissatisfaction
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户不满
- en: This reads as a fairly generic list of things we don't want during our project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是我们项目期间不希望出现的一些相当通用的列表。
- en: More importantly for the purposes of this book, a specification allows you to
    have all of the information needed to create your application design. It doesn't
    necessarily mean our design will be right, but without a specification, you can
    guarantee the design will be wrong.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的目的来说，更重要的是，规范允许你拥有创建应用程序设计所需的所有信息。这并不一定意味着我们的设计将是正确的，但没有规范，你可以保证设计将是错误的。
- en: A good match
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个好的匹配
- en: Part of creating both a specification and a design is understanding the customer
    requirements; understanding the "problem domain" that represents their business.
    It's really hard to write a piece of computer software for a shipping business
    unless you understand at least a little bit about shipping, for example the way
    they calculate rates in relation to cargo weight and the distance it's travelling.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建规范和设计的一部分是理解客户需求；理解代表他们业务的“问题域”。除非你至少对航运有点了解，例如他们如何根据货物重量和运输距离计算运费，否则很难为航运公司编写计算机软件。
- en: In regard to Ext JS, we may be working with an external SOAP API that provides
    these shipping rates. Well, Ext JS supports working with SOAP (with a Sencha Complete
    license), but if it didn't, this would probably affect our design—we'd have to
    write more code to talk to the SOAP API—and therefore our timings.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Ext JS，我们可能正在与一个外部SOAP API合作，该API提供这些运费。嗯，Ext JS支持使用SOAP（需要Sencha Complete许可证），但如果它不支持，这可能会影响我们的设计——我们不得不编写更多代码来与SOAP
    API通信——因此我们的时间表。
- en: We're writing a content management system, but it needs to be very closely tied
    with the customer's branding due to agreements with third parties. Will the Ext
    JS theming system allow us to incorporate the extensive customization needed for
    the project?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写一个内容管理系统，但由于与第三方达成的协议，它需要与客户的品牌非常紧密地结合。Ext JS主题系统是否允许我们融入项目所需的广泛定制？
- en: We started working on a sales portal for a new client when the Finance Director
    reveals that all his work outside the office is done on an iPad mini. We now have
    to work backwards to incorporate touchscreen support. If we'd have consulted all
    of the stakeholders at the right time, we'd have saved weeks of work.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当财务总监透露他在办公室外的工作都是在iPad mini上完成的时，我们开始为一位新客户开发销售门户。我们现在必须回溯以融入触摸屏支持。如果我们能在适当的时候咨询所有利益相关者，我们就能节省几周的工作。
- en: These examples are somewhat contrived, but serve to highlight that application
    design is not only about software, but also a fusion of consulting the people
    involved, evaluating your resources, understanding the problem domain, and creating
    a software architecture. These requirements don't exist in isolation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子有些牵强，但有助于强调应用程序设计不仅关乎软件，而且是咨询相关人员、评估资源、理解问题域和创建软件架构的融合。这些需求不是孤立存在的。
- en: How we work
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们是如何工作的
- en: Consider bringing a new developer or tester in your team. How quickly can they
    get up and running with the latest build of your code? How can they track down
    the code change that resulted in a bug they're working on and then find the developer
    responsible for the bug? Is there a particular way in which automated tests should
    be created and new code should be written?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将新的开发人员或测试人员加入您的团队。他们需要多快才能开始使用您代码的最新版本？他们如何追踪导致他们正在工作的bug的代码更改，然后找到负责该bug的开发人员？自动测试应该以何种特定方式创建，新代码应该如何编写？
- en: 'These are all highly important questions when creating a successful application
    because they reduce the barrier between creating and improving the existing code
    base and keeping the quality of the resulting code high. Joel Spolsky, of Microsoft
    and Fog Creek fame, wrote a blog article back in 2000 that is still highly relevant
    today. Titled *The Joel Test: 12 Steps to Better Code*, it asked twelve questions
    of development houses based on Joel''s extensive experience working with a variety
    of coding teams and projects (from Microsoft Excel to Fog Creek''s own Trello).
    The whole article''s well worth a read, but we''re going to take a fresh look
    at it with regards to Ext JS development.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '这些都是创建成功应用程序时非常重要的问题，因为它们减少了创建和改进现有代码库之间的障碍，并保持最终代码的质量。以微软和Fog Creek著称的乔尔·斯波尔斯基（Joel
    Spolsky）在2000年写了一篇至今仍非常相关的博客文章。题为《乔尔测试：12步走向更好的代码》（*The Joel Test: 12 Steps to
    Better Code*），它基于乔尔与各种编码团队和项目（从微软的Excel到Fog Creek自己的Trello）的丰富经验，对开发公司提出了十二个问题。整篇文章值得一读，但我们将以Ext
    JS开发为背景，重新审视它。'
- en: In safe hands
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在安全的手中
- en: Joel's first question, "Do you use source control?"
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 乔尔的第一问，“你使用源代码控制吗？”
- en: Step one when a new developer arrives is where is your code kept? We're long
    past shared network drives and manually copying the code of other developers on
    your team, so you should be using some form of source control. This is definitely
    a situation in which something is better than nothing, so we won't specifically
    discuss the alternatives, but in my case, I'm using Git, which is created as the
    source control system for the Linux kernel and is now extremely popular in software
    development.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当新开发者加入时，第一步是确定你的代码存储在哪里？我们已经远远超过了共享网络驱动器和手动复制团队中其他开发者的代码，所以你应该使用某种形式的源代码控制。这肯定是一个“有比没有好”的情况，所以我们不会具体讨论替代方案，但在我个人的情况下，我使用
    Git，它是作为 Linux 内核的源代码控制系统创建的，现在在软件开发中非常流行。
- en: 'Each member of your team can now grab code from each other, roll back their
    mistakes, track changes, and find the origin of bugs. However, a source repository
    is not just a giant hole in which everyone''s files is up. There are some that
    are unique to each developer (such as configuration files for an IDE), and there
    are some that are automatically generated by a build process or other script.
    With Git, we''d use a `.gitignore` file to exclude several items that simply create
    a message of your repository and commits:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队中的每个成员现在都可以从彼此那里获取代码，回滚错误，跟踪更改，并找到错误的起源。然而，源代码库不仅仅是一个巨大的洞，其中每个人的文件都存在。有些是针对每个开发者的独特文件（例如，IDE
    的配置文件），还有一些是由构建过程或其他脚本自动生成的。使用 Git，我们会使用 `.gitignore` 文件来排除几个仅创建你的仓库和提交信息的项：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There will be a lot more than this in a `.gitignore` file if your Ext JS application
    shares a directory with any server-side code. Most large projects will have a
    heavily customized `.gitignore` file. Moreover, not all source control systems
    will have a similar feature and setting it up at the start of the project will
    keep your application history neat and tidy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Ext JS 应用程序与任何服务器端代码共享目录，`.gitignore` 文件中将会包含比这更多的内容。大多数大型项目都会有一个高度定制的
    `.gitignore` 文件。此外，并非所有的源代码控制系统都具备类似的功能，而在项目开始时设置它将使你的应用程序历史保持整洁有序。
- en: If you build it, they will come
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果你构建了它，他们就会来
- en: Joel's second question, "Can you make a build in one step?"
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 乔尔的第二个问题，“你能一步完成构建吗？”
- en: We mentioned earlier that it needs to be easy for developers and testers to
    build a final version of your application from the raw source code. This could
    be the process that compresses your CSS and JavaScript so that your users can
    download it more quickly. The key is that you want to be testing your work against
    the same final build as your users to avoid bugs creeping through.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，需要让开发者和测试者能够轻松地从原始源代码构建应用程序的最终版本。这可能是一个压缩你的 CSS 和 JavaScript 的过程，以便用户可以更快地下载。关键是，你希望对你的工作与用户使用的相同最终构建版本进行测试，以避免错误悄悄通过。
- en: In Ext JS 5, we can use the Sencha Cmd to create development, testing, and production
    builds and it can even be used to create a packaged version of your application
    for deployment on touch devices. In doing so, it gives a unified mechanism for
    your whole team to work from the same build with a single command, making Joel
    very happy. This also ties into his third question, "Do you make daily builds?"
    With the tools we've described so far, an automated build system can grab the
    latest and greatest code from source control, build it using the Sencha Cmd, and
    deploy it to a testing or beta server for evaluation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ext JS 5 中，我们可以使用 Sencha Cmd 来创建开发、测试和生产版本，甚至可以用来创建适用于触摸设备的应用程序打包版本。这样做可以提供一个统一的机制，让整个团队可以通过单个命令从相同的构建版本中工作，这让乔尔非常高兴。这也与他第三个问题“你每天都会进行构建吗？”相关。使用我们迄今为止描述的工具，自动构建系统可以从源代码控制中获取最新和最好的代码，使用
    Sencha Cmd 进行构建，并将其部署到测试或beta服务器进行评估。
- en: Managing your time
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理你的时间
- en: Joel's fourth question, "Do you have an up-to-date schedule?" and his fifth
    question, "Do you have a spec?"
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 乔尔的第四个问题，“你有一个最新的日程安排吗？”以及他的第五个问题，“你有一个规范吗？”
- en: Of course, neither of these is specific to Ext JS applications, but they're
    tightly related to the theme of this book. We've discussed having a specification
    that informs your application design, but it's an up-to-date schedule that goes
    hand in hand. By designing your application correctly, you are dividing it into
    sections that can be scheduled by yourself, your team, or your management.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这两者都不是特定于 Ext JS 应用程序的，但它们与本书的主题紧密相关。我们已经讨论了拥有一个规范来指导你的应用程序设计，但与之相伴的是最新的日程安排。通过正确设计你的应用程序，你可以将其划分为可以由你自己、你的团队或你的管理层安排的各个部分。
- en: A single controller with its associated views and the required models could
    be scheduled to take a month to complete, so an app designed to have three controllers
    could take three months. Joel's sixth question's a little bit more specific than
    this though, he asks for an up-to-date schedule. This means examining your work
    to ensure you're meeting your schedule and adjusting accordingly. It also means
    learning from a slipping schedule and realizing that your design may have been
    flawed in some ways. A more complex view with lots of interaction will clearly
    take more time than a simple view, so it's not as straightforward as our "one
    month per controller" suggestion.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个控制器及其关联的视图和所需模型可能需要一个月的时间才能完成，所以一个设计有三个控制器的应用程序可能需要三个月。然而，乔尔的第六个问题比这更具体，他要求一个最新的进度表。这意味着检查你的工作以确保你符合进度，并相应地进行调整。这也意味着从拖延的进度中学习，并意识到你的设计可能在某些方面有缺陷。一个具有大量交互的复杂视图显然会比一个简单的视图花费更多的时间，所以它并不像我们的“每个控制器一个月”的建议那样简单。
- en: You can buy fashion, but you can't buy style
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你可以购买时尚，但你不能购买风格
- en: 'The rest of Joel''s questions are more general, so we''ll skip them and talk
    about another important facet of setting up your development process: style. Not
    what your developers are wearing, but the way in which they write code. There
    are two things to consider here, the ones related to JavaScript and the ones specific
    to Ext JS.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 乔尔的其他问题更加普遍，所以我们跳过它们，来谈谈设置你的开发过程的一个重要方面：风格。这里不是指你的开发者穿什么，而是他们编写代码的方式。这里有两个需要考虑的因素，一个是与
    JavaScript 相关的，另一个是特定于 Ext JS 的。
- en: The developers of Twitter Bootstrap caused upset in 2012 by opting not to use
    semicolons at the end of lines of JavaScript and combining that with some slightly
    obtuse syntax. Refer to [https://github.com/twbs/bootstrap/issues/3057](https://github.com/twbs/bootstrap/issues/3057).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter Bootstrap 的开发者们在 2012 年通过选择不在 JavaScript 行尾使用分号，并结合一些稍微晦涩的语法，引起了人们的反感。请参阅[https://github.com/twbs/bootstrap/issues/3057](https://github.com/twbs/bootstrap/issues/3057)。
- en: In truth, it doesn't matter too much whether you use semicolons or not in most
    circumstances due to JavaScript's automatic semicolon insertion. Refer to [http://ecma262-5.com/ELS5_Section_7.htm#Section_7.9](http://ecma262-5.com/ELS5_Section_7.htm#Section_7.9).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在大多数情况下，由于 JavaScript 的自动分号插入，是否使用分号并不太重要。请参阅[http://ecma262-5.com/ELS5_Section_7.htm#Section_7.9](http://ecma262-5.com/ELS5_Section_7.htm#Section_7.9)。
- en: The more important point is that whatever you do, do it consistently and make
    sure everyone working on your application is doing it too. Not doing this will
    have severe consequences for the maintainability of your application as it's developed
    (imagine having files with two or three different styles of commenting, string
    quoting, and conditional statements).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，无论你做什么，都要保持一致性，并确保所有参与你应用程序开发的人都这样做。不这样做将会对你的应用程序的可维护性产生严重后果（想象一下拥有两种或三种不同风格的注释、字符串引号和条件语句的文件）。
- en: 'Ext JS itself has a couple of conventions that will make your life much easier
    if you adhere to them. When a controller requires a store, you can do it like
    this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 本身有一些约定，如果你遵守它们，将会使你的生活变得更加容易。当一个控制器需要存储时，你可以这样做：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is equivalent to:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the `Store` class was defined as `'MyApp.store.Albums'`, we can refer to
    it with the `'Albums'` shortcut. Likewise, controllers should always have "controller"
    as the middle part of the class name, "model" for models, and "view" for views.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Store` 类被定义为 `'MyApp.store.Albums'`，我们可以用 `'Albums'` 快捷方式来引用它。同样，控制器应该总是将
    "controller" 作为类名中间的部分，"model" 用于模型，"view" 用于视图。
- en: This is partially covered in the naming conventions segment of the Ext JS 5
    Core Concepts guide. What isn't explicitly mentioned is the way that these shortcuts
    are pervasive across Ext JS and how they can make your code much clearer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容在 Ext JS 5 核心概念指南的命名约定部分有所涉及。没有明确提到的是，这些快捷方式在 Ext JS 中无处不在，以及它们如何使你的代码更加清晰。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Although a lot of this book discusses the bigger picture of designing an application,
    there are many different criteria for developing a successful product. Attention
    must be paid to the smaller things that we've already mentioned (such as semicolon
    style or naming conventions) in order to not only provide a solid foundation for
    your code, but also to ensure everyone who is working with it feels invested and
    on the same page. You're not only painting a picture of a well-architected application,
    but you're also building an intricate machine with hundreds of moving parts. All
    of them need to be well oiled for your project to succeed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书讨论了很多关于设计应用程序的整体框架，但开发一个成功的产品有许多不同的标准。我们必须关注我们已提到的细节问题（例如分号风格或命名约定），这不仅是为了为你的代码提供一个坚实的基础，也是为了确保所有与之合作的人都感到投入并且意见一致。你不仅是在描绘一个结构良好的应用程序的图景，而且是在构建一个由数百个活动部件组成的复杂机器。所有这些部件都需要良好的润滑，以便你的项目能够成功。
- en: In the next chapter, we'll start to talk about the theory of application structure
    and discuss design patterns that will help shape our code base. We'll frame this
    in the context of Ext JS and show how it provides a strong set of features that
    build on these patterns and enable us to begin setting up the architecture for
    a robust application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始讨论应用程序结构的理论，并讨论那些将帮助我们塑造代码库的设计模式。我们将在这个背景下讨论Ext JS，并展示它如何提供一套强大的功能，这些功能建立在这些模式之上，并使我们能够开始为健壮的应用程序搭建架构。
