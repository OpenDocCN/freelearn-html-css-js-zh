- en: Chapter 4. Accessing Offline Content with Advanced Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 使用高级技术访问离线内容
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Templating
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板化
- en: Implementing read-through caching
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现读取缓存
- en: Allowing offline Google Analytics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许离线Google Analytics
- en: Allowing offline user interaction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许离线用户交互
- en: Implementing selective caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现选择性缓存
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will continue to improve on our experience working with
    offline content using the service worker.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续改进使用服务工作者处理离线内容的经验。
- en: We will look into advanced techniques, including how to use templating with
    a template engine, diving into Google Analytics, how to solve issues with offline
    user interaction, and implementing selective caching.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨高级技术，包括如何使用模板引擎进行模板化，深入Google Analytics，如何解决离线用户交互问题，以及实现选择性缓存。
- en: Let's start off this chapter by experimenting with templating for the service
    worker.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本章开始，通过实验服务工作者的模板化来开始。
- en: Templating
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板化
- en: Traditional server-side page rendering has become a thing of the past with modern-day
    **single page applications** (**SPAs**). Even though server-side rendering is
    faster, state data will prove hard to implement with the service worker. Instead,
    we can request JSON data and a template, allow the service worker to take in the
    data and the template, and render a response page. JavaScript templating is a
    client-side data binding method, implemented with the use of the JavaScript language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的服务器端页面渲染已成为现代**单页应用**（**SPA**）的过去式。尽管服务器端渲染更快，但使用服务工作者实现状态数据将变得困难。相反，我们可以请求JSON数据和模板，允许服务工作者接收数据和模板，并渲染响应页面。JavaScript模板化是一种客户端数据绑定方法，使用JavaScript语言实现。
- en: 'In order to learn more about templating, please refer the following link:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解更多关于模板化的信息，请参考以下链接：
- en: '[https://en.wikipedia.org/wiki/JavaScript_templating](https://en.wikipedia.org/wiki/JavaScript_templating)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/JavaScript_templating](https://en.wikipedia.org/wiki/JavaScript_templating)'
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the first recipe of [Chapter 1](ch01.html "Chapter 1. Learning Service
    Worker Basics"), *Learning Service Worker Basics*: *Setting up service workers*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes: *Setting
    up GitHub pages for SSL*, *Setting up SSL for Windows*, and *Setting up SSL for
    Mac*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工作者，您需要在浏览器设置中开启服务工作者实验功能。如果您还没有这样做，请参考[第1章](ch01.html "第1章. 学习服务工作者基础")的第一个食谱，*学习服务工作者基础*：*设置服务工作者*。服务工作者仅在HTTPS上运行。要了解如何设置支持此功能的发展环境，请参考以下食谱：*设置GitHub页面以支持SSL*，*在Windows上设置SSL*，和*在Mac上设置SSL*。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to set up your file structure. Alternatively, you
    can download the files from the following location:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明设置您的文件结构。或者，您可以从以下位置下载文件：
- en: '[https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/01/](https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/01/)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/01/](https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/01/)'
- en: 'First, we must create an `index.html` file as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个如下所示的`index.html`文件：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a JavaScript file called `service-worker.js`, in the same folder as
    the `index.html` file, with the following code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`service-worker.js`的JavaScript文件，包含以下代码：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a JSON file called `people.js`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`people.js`的JSON文件，包含以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Download the handlebars library from [http://handlebarsjs.com/installation.html](http://handlebarsjs.com/installation.html)
    and save as `handlebars.js` in the same directory as the `index.html` file, as
    shown in the following screenshot:![How to do it...](img/B05381_04_01.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://handlebarsjs.com/installation.html](http://handlebarsjs.com/installation.html)下载handlebars库，并将其保存为与`index.html`文件相同的目录下的`handlebars.js`，如图所示：![如何操作...](img/B05381_04_01.jpg)
- en: Open up a browser and go to the `index.html` file:![How to do it...](img/B05381_04_02.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并转到`index.html`文件：![如何操作...](img/B05381_04_02.jpg)
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We are using handlebars as our choice of templating engine for this example.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们选择使用 handlebars 作为模板引擎。
- en: 'The template for the service worker is the `index.html` file itself. We are
    using double curly braces, the `Handlebars` syntax, inside a table:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工人的模板是 `index.html` 文件本身。我们在表格中使用双大括号，`Handlebars` 语法：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The values are read from the JSON file that we feed into the template. The `{{#users}}`
    tag is an array, and it works like a loop, printing out the content inside the
    `users` property to the screen by replacing the placeholder, such as `{{twitter}}`,
    with the relevant value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值是从我们输入模板的 JSON 文件中读取的。`{{#users}}` 标签是一个数组，它就像一个循环，通过用相关值替换占位符，如 `{{twitter}}`，将
    `users` 属性中的内容打印到屏幕上。
- en: 'The `people.json` file contains data we need for our template. The `users`
    property contains an array of the users:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`people.json` 文件包含我们模板所需的数据。`users` 属性包含用户数组：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s move on to the `service-worker.js` file. There we handle two events:
    install and fetch. In the install event handler, we are caching all the dependencies:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到 `service-worker.js` 文件。在那里我们处理两个事件：安装和获取。在安装事件处理器中，我们正在缓存所有依赖项：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the fetch handler, we check to see whether the fetch request is the
    template, in our case the `index.html` file, and we send the response in text
    format:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取处理器内部，我们检查获取请求是否是模板，在我们的例子中是 `index.html` 文件，并以文本格式发送响应：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the fetch request is the JSON file, we return the result in JSON format:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获取请求是 JSON 文件，我们以 JSON 格式返回结果：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we render the template with the JSON data and then send the response
    back with a header:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 JSON 数据渲染模板，然后发送带有标题的响应：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Handlebars.compile()` function takes in a template and returns a function,
    which can in turn take in data and render an output.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handlebars.compile()` 函数接受一个模板并返回一个函数，该函数可以进一步接受数据并渲染输出。'
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Registering a service worker in detail* recipe in [Chapter 1](ch01.html
    "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker Basics*
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 1 章 *学习服务工人基础* 的 *详细注册服务工人* 菜谱中，*学习服务工人基础*
- en: Implementing read-through caching
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现读取缓存
- en: Read-through caching is an assertive approach to all-out caching for types of
    static content you visit regularly. This is not very suitable for dynamic content,
    such as news or sports. A selective caching approach would be better suited for
    such instances. Read-through caching saves us the necessary bandwidth for the
    server, as well as requests over the network. The way read-through caching works
    is that after the service worker takes control of your page, when the first `fetch()`
    request is called, the response will be cached, and subsequent requests to the
    same URL will be served from the cache.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 读取缓存是一种对所有经常访问的静态内容类型进行全面缓存的方法。这并不适合动态内容，如新闻或体育。在这种情况下，选择性的缓存方法会更好。读取缓存为我们节省了服务器必要的带宽，以及网络请求。读取缓存的工作方式是，在服务工人接管你的页面后，当第一次调用
    `fetch()` 请求时，响应将被缓存，并且对同一 URL 的后续请求将来自缓存。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the first recipe of [Chapter 1](ch01.html "Chapter 1. Learning Service
    Worker Basics"), *Learning Service Worker Basics*: *Setting up service workers*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes of [Chapter
    1](ch01.html "Chapter 1. Learning Service Worker Basics"), *Learning Service Worker
    Basics*: *Setting up GitHub pages for SSL*, *Setting up SSL for Windows*, and
    *Setting up SSL for Mac*.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工人，你需要在浏览器设置中开启服务工人实验功能。如果你还没有这样做，请参考第 1 章 *学习服务工人基础* 的第一个菜谱：*设置服务工人*。服务工人仅在
    HTTPS 上运行。要了解如何设置支持此功能的发展环境，请参考以下第 1 章 *学习服务工人基础* 的菜谱：*设置 GitHub 页面以支持 SSL*，*在
    Windows 上设置 SSL* 和 *在 Mac 上设置 SSL*。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the instructions to set up your file structure. Alternatively, you can
    download the files from the following location:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明设置你的文件结构。或者，你也可以从以下位置下载文件：
- en: '[https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/02](https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/02)/'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/02](https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/02)/'
- en: 'First, we must create an `index.html` file as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个如下的`index.html`文件：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a CSS file called `style.css` in the same folder as the `index.html`
    file:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`style.css`的CSS文件：
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a JavaScript file called `index.js` in the same folder as the `index.html`
    file:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`index.js`的JavaScript文件：
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a JavaScript file called `service-worker.js` in the same folder as the
    `index.html` file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`service-worker.js`的JavaScript文件：
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open up a browser and go to `index.html`:![How to do it...](img/B05381_04_03.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并转到`index.html`：![如何操作...](img/B05381_04_03.jpg)
- en: Open up Developer Tools (*Cmd* + *Alt* + *I* or *F12*). You will see messages
    logged on the console, saying most resources were not found in the cache, so were
    fetched from the network:![How to do it...](img/B05381_04_04.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开开发者工具（*Cmd* + *Alt* + *I* 或 *F12*）。你将在控制台看到记录的消息，表明大多数资源都没有在缓存中找到，因此从网络上获取：![如何操作...](img/B05381_04_04.jpg)
- en: If you refresh the page, you will see different messages appearing in the console.
    This time, the resources are fetched from the cache:![How to do it...](img/B05381_04_05.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你刷新页面，你将在控制台看到不同的消息。这次，资源是从缓存中获取的：![如何操作...](img/B05381_04_05.jpg)
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the `service-worker.js` file, we are setting a page-specific name for the
    cache, as the caches are origin-based, and no other page should use the same cache
    name. We are also versioning the cache, in order to address a scenario where you
    would want a fresh cache; in this instance, we can update the version:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service-worker.js`文件中，我们为缓存设置了一个特定于页面的名称，因为缓存是基于源的，其他页面不应使用相同的缓存名称。我们还对缓存进行了版本控制，以便解决你可能想要一个新缓存的情况；在这种情况下，我们可以更新版本：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also make sure that the old caches are purged at the time the service worker
    is activated. So, we delete all the caches that do not match the name we previously
    specified for our cache name:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还确保在服务工作者激活时清除旧缓存。因此，我们删除了所有与我们之前指定的缓存名称不匹配的缓存：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The fetch event listener looks into the cache to find whether our requested
    resource is in the cache; if it is found, it will respond with the entry:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: fetch事件监听器会检查缓存以确定我们请求的资源是否在缓存中；如果找到，它将响应条目：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Otherwise, if there is no entry for `event.request` in the cache, the response
    is going to be undefined, so we have to fetch the resource using `fetch()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果缓存中没有`event.request`的条目，响应将是未定义的，因此我们必须使用`fetch()`来获取资源：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `clone()` call is useful if we use `cache.put()` later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果之后我们使用`cache.put()`，`clone()`调用是有用的。
- en: Making a copy is necessary because both `cache.put()` and `fetch()` will consume
    the request.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 制作副本是必要的，因为`cache.put()`和`fetch()`都会消耗请求。
- en: 'We also make sure not to cache error responses by checking the `response.status`
    parameter is not 400 or above:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还确保通过检查`response.status`参数不是400或更高来避免缓存错误响应：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lastly, we call the `clone()` method on the response, in order to save a copy
    in the cache, and then return the response to the browser:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在响应上调用`clone()`方法，以便在缓存中保存一个副本，然后将响应返回给浏览器：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Allowing offline Google Analytics
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许离线Google Analytics
- en: We discussed read-through caching in the previous recipe. Let's quickly recap
    what read-through caching is. After a service worker gains control of the page,
    the first time a new resource has been requested, the response will be stored
    in the service worker cache.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们讨论了读透缓存。让我们快速回顾一下什么是读透缓存。当一个服务工作者获得页面控制权后，第一次请求新的资源时，响应将被存储在服务工作者缓存中。
- en: In this recipe, we are utilizing this feature to store any failed Google Analytics/collect
    pings in an IndexedDb database. IndexedDb is a client-side, user-specific storage
    specification that allows us to store data in an indexed manner, and is backed
    by an API that provides search capabilities. So any time the service worker starts
    up, any saved Google Analytics pings will be replayed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们利用这个功能将任何失败的Google Analytics/collect pings存储在IndexedDb数据库中。IndexedDb是一个客户端、用户特定的存储规范，它允许我们以索引的方式存储数据，并由一个提供搜索功能的API支持。因此，每次服务工作者启动时，任何保存的Google
    Analytics pings都将重新播放。
- en: 'To learn more about IndexedDb you can follow these links:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于IndexedDb的信息，可以参考以下链接：
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB)'
- en: '[http://seanamarasinghe.com/developer/indexeddb/](http://seanamarasinghe.com/developer/indexeddb/)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://seanamarasinghe.com/developer/indexeddb/](http://seanamarasinghe.com/developer/indexeddb/)'
- en: This will give you a great platform to perform transactions offline, regardless
    of connectivity and availability.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供一个在离线状态下执行交易的平台，无论连接性和可用性如何。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the first recipe of [Chapter 1](ch01.html "Chapter 1. Learning Service
    Worker Basics"), *Learning Service Worker Basics*: *Setting up service workers*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes: *Setting
    up GitHub pages for SSL*, *Setting up SSL for Windows*, and *Setting up SSL for
    Mac*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工作者，您需要在浏览器设置中开启服务工作者实验功能。如果您还没有这样做，请参考[第1章](ch01.html "第1章. 学习服务工作者基础")的第一个食谱，*学习服务工作者基础*：*设置服务工作者*。服务工作者仅在HTTPS上运行。要了解如何设置支持此功能的发展环境，请参考以下食谱：*设置GitHub页面以支持SSL*，*在Windows上设置SSL*，以及*在Mac上设置SSL*。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the instructions to set up your file structure. Alternatively, you can
    download the files from the following location:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明设置您的文件结构。或者，您也可以从以下位置下载文件：
- en: '[https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/03/](https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/03/)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/03/](https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/03/)'
- en: 'First, we must create an `index.html` file as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个如下所示的`index.html`文件：
- en: '[PRE19]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a CSS file called `style.css`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`style.css`的CSS文件，并包含以下代码：
- en: '[PRE20]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a JavaScript file called `index.js`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`index.js`的JavaScript文件，并包含以下代码：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a JavaScript file called `analytics.js`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`analytics.js`的JavaScript文件，并包含以下代码：
- en: '[PRE22]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Open up a browser and go to the `index.html` file:![How to do it...](img/B05381_04_06.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并访问`index.html`文件：![如何操作...](img/B05381_04_06.jpg)
- en: Now open up DevTools (*Cmd* + *Alt* + *I* or *F12*) and go to the **Network**
    tab. You will see the `/collect` requests have a state of **200**, which means
    successful:![How to do it...](img/B05381_04_07.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开开发者工具（*Cmd* + *Alt* + *I* 或 *F12*）并转到**网络**选项卡。您将看到`/collect`请求的状态为**200**，这意味着成功：![如何操作...](img/B05381_04_07.jpg)
- en: Refresh the page. You will see an image as shown in the following screenshot:![How
    to do it...](img/B05381_04_08.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面。您将看到如下截图所示的图像：![如何操作...](img/B05381_04_08.jpg)
- en: Go to the **Console** tab of DevTools:![How to do it...](img/B05381_04_09.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到开发者工具的**控制台**选项卡：![如何操作...](img/B05381_04_09.jpg)
- en: Now, go to the **Network** tab of DevTools and select **Offline**:![How to do
    it...](img/B05381_04_10.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到开发者工具的**网络**选项卡并选择**离线**：![如何操作...](img/B05381_04_10.jpg)
- en: Refresh the page and you will still see the same page, but if you view the network
    requests, you will be able to find out that the service worker has saved the analytics
    requests in IndexedDb:![How to do it...](img/B05381_04_11.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面，您仍然会看到相同的页面，但如果您查看网络请求，您将能够发现服务工作者已将分析请求保存到IndexedDb中：![如何操作...](img/B05381_04_11.jpg)
- en: Now change the **Offline** option to **No throttling** in DevTools:![How to
    do it...](img/B05381_04_12.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在开发者工具中将**离线**选项更改为**无节流**：![如何操作...](img/B05381_04_12.jpg)
- en: Click on the **Reset** button on this page to refresh the service worker, and
    monitor the console in DevTools. You will see that the replay message extracted
    from IndexedDb has been sent:![How to do it...](img/B05381_04_13.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击此页面的**重置**按钮以刷新服务工作者，并在开发者工具的控制台中进行监控。您将看到从IndexedDb提取的重放消息已被发送：![如何操作...](img/B05381_04_13.jpg)
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the `service-worker.js` file, we are accessing IndexedDb by getting a reference
    to it. Then we go on attaching event handlers for the `error`, `upgradeneed`,
    and `onsuccess` events of the database instance:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service-worker.js`文件中，我们通过获取其引用来访问IndexedDb。然后我们继续为数据库实例的`error`、`upgradeneed`和`onsuccess`事件附加事件处理器：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because of the read-through, caching will cache the initial requests; the subsequent
    requests to the same resource will be handled by the `fetch()` event handler of
    the service worker. The fetch event handler queries the cache for requests in
    the `currentCaches` cache, and sends the response back to the browser:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于读取穿透，缓存将缓存初始请求；对同一资源的后续请求将由服务工人的`fetch()`事件处理器处理。fetch事件处理器查询`currentCaches`缓存中的请求，并将响应发送回浏览器：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the response was not found, it will send a fetch request to the network:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应未找到，它将向网络发送fetch请求：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the response for the preceding request was successful, the response will
    be cloned and added to the cache, with the request as the key and the response
    as the value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前一个请求的响应是成功的，响应将被克隆并添加到缓存中，请求作为键，响应作为值：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we make sure that we resolve the current promise as soon as another one
    in the array gets resolved:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要确保在数组中的另一个promise被解析后，立即解析当前的promise：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the response is not a server error, and is likely to be a timeout, we pass
    the request URL to `checkForAnalyticsRequest()`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应不是服务器错误，并且可能是超时，我们将请求URL传递给`checkForAnalyticsRequest()`：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `checkForAnalyticsRequest()` function is in the `analytics.js` file. Let''s
    examine this method. The passed-in URL is first checked to make sure whether it''s
    a call to `google-analytics.com`, regardless of whether the subdomain is `www`
    or `ssl`, and the path name has `/collect` in it. This is to make sure this is
    an analytics ping:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkForAnalyticsRequest()`函数位于`analytics.js`文件中。让我们检查这个方法。传入的URL首先被检查以确保它是对`google-analytics.com`的调用，无论子域名是`www`还是`ssl`，路径名中是否有`/collect`。这是为了确保这是一个分析ping：'
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `saveGoogleAnalyticsRequest()` method will add the URL and the timestamp
    to the store, which in turn saves the entry.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveGoogleAnalyticsRequest()`方法将URL和时间戳添加到存储中，从而保存条目。'
- en: 'The `onsuccess()` method, back in the `service-worker.js` file, calls the `replayGoogleAnalyticsRequests()`
    method. Inside this method, the analytics requests will be saved in a queue called
    `savedGoogleAnalyticsRequests`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service-worker.js`文件中，`onsuccess()`方法调用`replayGoogleAnalyticsRequests()`方法。在这个方法中，分析请求将被保存到一个名为`savedGoogleAnalyticsRequests`的队列中：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `openCursor()` function is a pointer to the database where you can traverse
    records.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`openCursor()`函数是指向数据库的指针，你可以遍历记录。'
- en: 'The callback of the `onsuccess` event handler will pass in the value of `event.target.result`
    into the `savedGoogleAnalyticsRequests` array:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`onsuccess`事件处理器的回调将`event.target.result`的值传递到`savedGoogleAnalyticsRequests`数组中：'
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Otherwise, each saved Google Analytics request will be replayed:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，每个保存的Google Analytics请求将被重新播放：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing read-through caching* recipe
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现读取穿透缓存*菜谱'
- en: Allowing offline user interaction
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许离线用户交互
- en: Most websites out there, including news articles, sports videos, or music, are
    not quite able to be taken offline completely, given their amount of content.
    There is no real reason for having everything in your cache if you don't access
    them. But giving the user the option of saving the content in the cache to read
    later is the ideal solution. In this recipe, we are going to investigate how we
    can achieve this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站，包括新闻文章、体育视频或音乐，由于内容量很大，并不能完全离线。如果你不访问它们，没有必要在缓存中保存所有内容。但是，给用户保存内容到缓存以便稍后阅读的选项是理想的解决方案。在这个菜谱中，我们将探讨如何实现这一点。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the first recipe of [Chapter 1](ch01.html "Chapter 1. Learning Service
    Worker Basics"), *Learning Service Worker Basics*: *Setting up service workers*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes: *Setting
    up GitHub pages for SSL*, *Setting up SSL for Windows*, and *Setting up SSL for
    Mac*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工作者，你需要在浏览器设置中开启服务工作者实验功能。如果你还没有这样做，请参考[第1章](ch01.html "第1章. 学习服务工作者基础")的第一个食谱，*学习服务工作者基础*：*设置服务工作者*。服务工作者仅在HTTPS上运行。要了解如何设置开发环境以支持此功能，请参考以下食谱：*设置GitHub页面以支持SSL*，*设置Windows的SSL*，和*设置Mac的SSL*。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the instructions to set up your file structure. Alternatively, you can
    download the files from the following location:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明设置你的文件结构。或者，你也可以从以下位置下载文件：
- en: '[https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/04/](https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/04/)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/04/](https://github.com/szaranger/szaranger.github.io/tree/master/service-workers/04/04/)'
- en: 'First, we must create an `index.html` file as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个`index.html`文件，如下所示：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a JavaScript file called `index.js`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`index.js`的JavaScript文件，包含以下代码：
- en: '[PRE34]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a JavaScript file called `service-worker.js`, in the same folder as
    the `index.html` file, with the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`service-worker.js`的JavaScript文件，包含以下代码：
- en: '[PRE35]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a CSS file called `style.css`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`style.css`的CSS文件，包含以下代码：
- en: '[PRE36]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Open up a browser and go to the `index.html` file. You will see one prefetched
    bookmark:![How to do it...](img/B05381_04_14.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并访问`index.html`文件。你会看到一个预取的书签：![如何操作...](img/B05381_04_14.jpg)
- en: 'Add the video to the cache by clicking on the **Watch Later** button:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**稍后观看**按钮将视频添加到缓存中：
- en: Now, change the **Offline** option to **No throttling** in DevTools:![How to
    do it...](img/B05381_04_15.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在DevTools中将**离线**选项更改为**无节流**：![如何操作...](img/B05381_04_15.jpg)
- en: Now refresh the page. You will see that styles aren't loaded, but the video
    is still accessible:![How to do it...](img/B05381_04_16.jpg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在刷新页面。你会看到样式没有加载，但视频仍然可以访问：![如何操作...](img/B05381_04_16.jpg)
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In our `service-worker.js` file, we are only caching the `index.html` file
    in order to load the page:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`service-worker.js`文件中，我们只缓存`index.html`文件以加载页面：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `index.html` file, we have a video tag with its source pointing to a
    video file. If the `.mp4` extension is not supported by the browser, it will show
    the `Your browser does not support the video tag` message:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，我们有一个视频标签，其源指向一个视频文件。如果浏览器不支持`.mp4`扩展名，它将显示`您的浏览器不支持视频标签`的消息：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When you click the **Watch Later** button, the event handler gets fired, which
    is in turn is handled inside the `index.js` file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**稍后观看**按钮时，事件处理程序被触发，这反过来又在`index.js`文件内部处理：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `cache.add()` function adds the response URL to the cache. Back in `service-worker.js`,
    the event listener for fetch retrieves this saved response when we refresh the
    page in offline mode:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache.add()`函数将响应URL添加到缓存中。回到`service-worker.js`，fetch事件监听器在离线模式下刷新页面时检索这个保存的响应：'
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Implementing selective caching
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现选择性缓存
- en: In the second recipe of this chapter, *Implementing read-through caching*, we
    discussed caching all resources at the time of the first request, and we talked
    about how it does not suit some scenarios, such as news or sports, where most
    articles will become outdated and you will never access them again. The solution
    we pointed out at the time was selective caching. So let's look at a working example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，*实现读取缓存*，我们讨论了在第一次请求时缓存所有资源，并讨论了它不适合某些场景，例如新闻或体育，其中大多数文章都会过时，你将永远不会再次访问它们。当时我们提出的解决方案是选择性缓存。那么，让我们看看一个工作示例。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started with service workers, you will need to have the service worker
    experiment feature turned on in your browser settings. If you have not done this
    yet, refer to the first recipe of [Chapter 1](ch01.html "Chapter 1. Learning Service
    Worker Basics"), *Learning Service Worker Basics*: *Setting up service workers*.
    Service workers only run across HTTPS. To find out how to set up a development
    environment to support this feature, refer to the following recipes: *Setting
    up GitHub pages for SSL*, *Setting up SSL for Windows*, and *Setting up SSL for
    Mac*.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用服务工作者，你需要在浏览器设置中开启服务工作者实验功能。如果你还没有这样做，请参考[第1章](ch01.html "第1章. 学习服务工作者基础")的第一个菜谱，*学习服务工作者基础*：*设置服务工作者*。服务工作者仅在HTTPS上运行。要了解如何设置支持此功能的发展环境，请参考以下菜谱：*设置GitHub页面以支持SSL*，*在Windows上设置SSL*，和*在Mac上设置SSL*。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these instructions to set up your file structure:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明设置你的文件结构：
- en: 'First, we must create an `index.html` file as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个如下所示的`index.html`文件：
- en: '[PRE41]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a JavaScript file called `index.js`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`index.js`的JavaScript文件，并包含以下代码：
- en: '[PRE42]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Download the `webfont-serif.woff` file from the source code, or use your own
    font file, in the same folder as the `index.html` file.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源代码下载`webfont-serif.woff`文件，或者使用你自己的字体文件，与`index.html`文件在同一文件夹中。
- en: 'Create a JavaScript file called `service-worker.js`, in the same folder as
    the `index.html` file, with the following code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`service-worker.js`的JavaScript文件，并包含以下代码：
- en: '[PRE43]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a CSS file called `style.css`, in the same folder as the `index.html`
    file, with the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`index.html`文件相同的文件夹中创建一个名为`style.css`的CSS文件，并包含以下代码：
- en: '[PRE44]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Open up a browser and go to `index.html`. You will see the **Registration status:
    successful** message and the logo:![How to do it...](img/B05381_04_17.jpg)'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器并转到`index.html`。你会看到**注册状态：成功**的消息和标志：![如何操作...](img/B05381_04_17.jpg)
- en: Now, if you refresh the page and inspect the **Console** tab of the Developer
    Tools, you will be able to see that the `webfont-serif.woff` file has been fetched
    from the cache.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你刷新页面并检查开发者工具的**控制台**标签页，你将能够看到`webfont-serif.woff`文件已从缓存中获取。
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In our `index.html` file, we add a placeholder section for our message to be
    displayed:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`index.html`文件中，我们添加一个占位符部分以显示我们的消息：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `style.css` file, we declare the font family we are going to use, and
    then assign it to the paragraph we are targeting:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`style.css`文件中，我们声明我们将要使用的字体家族，然后将其分配给我们要针对的段落：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In our `service-worker.js` file, we make sure that if a cached version is available,
    we use it instead of a network request, but fetch an update the next time:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`service-worker.js`文件中，我们确保如果可用，则使用缓存的版本而不是网络请求，但下次会获取更新：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See also
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing read-through caching* recipe
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现读取缓存*菜谱'
