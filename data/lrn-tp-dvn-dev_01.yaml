- en: Starting Type-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始类型驱动开发
- en: 'In this book, we are exploring the techniques and idioms available in type-driven
    development. Some people also refer to type-driven development as type-level programming.
    Static types offer several benefits, including:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们正在探索类型驱动开发中可用的技术和惯例。有些人也将类型驱动开发称为类型级编程。静态类型提供了几个好处，包括：
- en: Preventing incorrect code from getting a chance to run
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止错误代码有机会运行
- en: Documenting the current codebase
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录当前的代码库
- en: Helping to correctly refactor the codebase by pointing out any parts of code
    you may have missed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指出你可能遗漏的代码部分来帮助正确重构代码库
- en: Offering richer IDE support, for example, auto-completion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供更丰富的 IDE 支持，例如自动完成
- en: Better performance when the compiler knows types and can optimize code accordingly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编译器知道类型并相应地优化代码时，性能更好
- en: Type-driven development is the practice of using static types to restrict what
    your code can do. Normally, your programming language gives you enough power to
    represent any computation. With type-driven development, you are essentially trying
    to make it impossible for your code to do undesirable things.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类型驱动开发是使用静态类型来限制代码可以做什么的实践。通常，你的编程语言给你足够的权力来表示任何计算。通过类型驱动开发，你本质上是在尝试让你的代码不可能做你不希望做的事情。
- en: In this chapter, we will do some basic critical analysis of a piece of code
    and look at the possible errors it may contain. We'll also introduce ReasonML,
    the language we will use to learn type-driven development and compare it with
    JavaScript. We'll get started with a basic Reason project and then introduce Reason,
    as well as its related communities and ecosystems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对一段代码进行一些基本的批判性分析，并查看它可能包含的错误。我们还将介绍 ReasonML，这是我们用来学习类型驱动开发的语言，并将其与
    JavaScript 进行比较。我们将从一个基本的 Reason 项目开始，然后介绍 Reason 以及其相关的社区和生态系统。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The main idea and benefits of type-driven development
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型驱动开发的主要思想和好处
- en: Dynamically typed code versus its statically typed ReasonML equivalent
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态类型代码与其静态类型 ReasonML 等效物
- en: The Reason language, ecosystem, and related projects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reason 语言、生态系统和相关项目
- en: How to set up a basic Reason project, which we will use throughout this book
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置一个基本的 Reason 项目，我们将在此书中使用它
- en: The Try Reason online playground
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线尝试 Reason 游戏场
- en: Analyzing code for hidden errors
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析代码中的隐藏错误
- en: 'Let''s suppose that you have the following JavaScript:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有以下 JavaScript 代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A lot of things can go wrong with the preceding code; they are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可能会出现很多问题；它们如下所示：
- en: The caller can pass in nulls or undefined values as arguments
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者可以将 null 或 undefined 值作为参数传递
- en: The caller can pass in unintended types of arguments
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者可以传递非预期的参数类型
- en: The caller can manipulate the returned `person` object any way they like, for
    example, they can add or remove properties
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者可以随意操作返回的 `person` 对象，例如，他们可以添加或删除属性
- en: In other words, this code doesn't prevent a number of potential errors. In JavaScript,
    we have linters, such as ESLint ([https://eslint.org/](https://eslint.org/)),
    that check for a lot of possible errors, but you have to remember to find them,
    enable them, and then work around their limitations. A linter can be helpful in
    various other ways, such as by pointing out the recommended best practices in
    a coding style. However, linters in JavaScript are often re-purposed to perform
    static type checking tasks as well; because they offer so much flexibility and
    need to be configured (in fact, people usually upload their preferred sets of
    configuration for different styles of programming), there may be large differences
    in what exactly gets checked across different codebases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这段代码并不能阻止许多潜在的错误。在 JavaScript 中，我们有像 ESLint ([https://eslint.org/](https://eslint.org/))
    这样的 linter，它可以检查许多可能出现的错误，但你必须记得去找到它们，启用它们，然后解决它们的限制。linter 可以以各种其他方式提供帮助，例如指出编码风格中的推荐最佳实践。然而，JavaScript
    中的 linter 往往被重新用于执行静态类型检查任务；因为它们提供了很大的灵活性并且需要配置（实际上，人们通常上传他们为不同编程风格首选的配置集），因此在不同代码库之间可能存在很大的差异。
- en: Adding types
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加类型
- en: 'With a static type system, we can restrict our `makePerson` function in quite
    a few ways. Here''s an example using ReasonML, the language that we''re using
    in this book to learn type-driven development:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态类型系统，我们可以以多种方式限制我们的 `makePerson` 函数。以下是一个使用 ReasonML 的例子，这是我们在这本书中用来学习类型驱动开发的语言：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we define a new data type, `person`, and a function that creates a value
    of the type given the required arguments. We have one more line in the preceding
    code than we do in the JavaScript code, but in exchange, we get the following
    guarantees:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个新的数据类型`person`和一个根据所需参数创建该类型值的函数。与前面的JavaScript代码相比，我们多了一行代码，但作为交换，我们得到了以下保证：
- en: The caller cannot pass in null or undefined arguments
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的调用者不能传入null或undefined参数
- en: The caller cannot pass in the wrong types of arguments
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的调用者不能传入错误的参数类型
- en: The caller cannot mutate the result value of the function
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的调用者不能修改函数的结果值
- en: Notice in the previous example that we didn't have to declare the argument or
    types for the `makePerson` function. This is because ReasonML has great type inference
    that automatically understands that `int`, `string`, and `person` must be the
    only possible types allowed for those parts of the function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在先前的例子中，我们不需要为`makePerson`函数声明参数或类型。这是因为ReasonML具有出色的类型推断，可以自动理解`int`、`string`和`person`必须是函数这些部分允许的唯一可能类型。
- en: 'ReasonML will compile the previous code into the following JavaScript:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonML将前面的代码编译成以下JavaScript：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the preceding code looks almost exactly like the JavaScript
    we wrote earlier—the main difference is that Reason's JavaScript compiler turns
    records (which we'll explore later) into JavaScript arrays to take advantage of
    their speed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的代码几乎与之前我们编写的JavaScript完全一样——主要区别在于Reason的JavaScript编译器将记录（我们将在后面探讨）转换为JavaScript数组，以利用它们的速度。
- en: This is just a glimpse of what static types can do to your codebase. In the
    coming chapters, we'll have a look at many more practical applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是静态类型对代码库能做的事情的一个缩影。在接下来的章节中，我们将探讨更多实际的应用。
- en: ReasonML
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReasonML
- en: We're going to explore type-driven development using ReasonML ([https://reasonml.github.io/](https://reasonml.github.io/)).
    Reason is a JavaScript-like syntax and is also a set of tools for OCaml ([https://ocaml.org/](https://ocaml.org/)).
    OCaml is a mature statically typed functional programming language with excellent
    support for object-oriented and modular programming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索使用ReasonML（[https://reasonml.github.io/](https://reasonml.github.io/)）进行类型驱动开发。Reason是一种类似于JavaScript的语法，同时也是一套用于OCaml（[https://ocaml.org/](https://ocaml.org/)）的工具。OCaml是一种成熟的静态类型函数式编程语言，它对面向对象和模块化编程提供了出色的支持。
- en: We're going to write Reason code and compile it to JavaScript using the BuckleScript
    compiler ([https://bucklescript.github.io/](https://bucklescript.github.io/)).
    BuckleScript takes input from Reason code and outputs essentially a simple subset
    of ES5 (that is, no ES2015-style classes, no arrow functions, and so on). This
    will allow us to write strongly statically typed code and see what the output
    JavaScript looks like with all the types stripped away.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用BuckleScript编译器（[https://bucklescript.github.io/](https://bucklescript.github.io/)）编写Reason代码并将其编译成JavaScript。BuckleScript从Reason代码中获取输入，并输出基本上是ES5的一个简单子集（即没有ES2015风格的类，没有箭头函数等）。这将使我们能够编写强静态类型代码，并看到所有类型被剥离后的输出JavaScript的样子。
- en: BuckleScript, by default, outputs JavaScript files with the extension `.bs.js`
    to distinguish them from your other JS files. You can see this in the example
    output file, `src/Ch01/Ch01_Demo.bs.js`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript默认输出扩展名为`.bs.js`的JavaScript文件，以区分您的其他JS文件。您可以在示例输出文件中看到这一点，`src/Ch01/Ch01_Demo.bs.js`。
- en: 'The Reason toolkit currently consists of:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Reason工具包目前包括：
- en: A code formatting and syntax translation tool, `refmt`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码格式化和语法转换工具，`refmt`
- en: An interactive code evaluation environment, `rtop`
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式代码评估环境，`rtop`
- en: A build manager for native-compilation projects (we won't need this one for
    this book), `rebuild`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于原生编译项目的构建管理器（我们在这本书中不需要这个），`rebuild`
- en: A tool that provides intellisense abilities to editors, `ocamlmerlin-reason`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为编辑器提供智能感知能力的工具，`ocamlmerlin-reason`
- en: These tools work together to provide a minimal, yet powerful, development experience.
    Together with a good editor (we recommend Visual Studio Code), they cover most
    of your day-to-day development needs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具协同工作，提供了一种最小化但强大的开发体验。与一个好的编辑器（我们推荐Visual Studio Code）一起，它们覆盖了您日常开发的大部分需求。
- en: Why ReasonML?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择ReasonML？
- en: 'So why have we chosen ReasonML over something else? For example, TypeScript
    and Flow are popular languages that target JavaScript today (among many others),
    but we chose Reason because:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么选择ReasonML而不是其他语言呢？例如，TypeScript和Flow是目前针对JavaScript（以及其他许多语言）的流行语言，但我们选择Reason是因为：
- en: It has a powerful and elegant type system, which neatly fits together many type-driven
    development concepts
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个强大而优雅的类型系统，它巧妙地结合了许多类型驱动开发概念
- en: Its JavaScript compiler (BuckleScript) has incredibly fast compiles, optimization,
    and high-quality dead-code elimination; fast compiles are great to have if you’re
    doing type-driven development, and performant code is great to have in any system
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的 JavaScript 编译器（BuckleScript）具有极快的编译、优化和高质量的死代码消除；如果你正在进行类型驱动开发，快速编译是非常有用的，而在任何系统中，性能良好的代码都是非常受欢迎的
- en: It has a very helpful and enthusiastic community that's very accessible
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个非常有帮助且热情的社区，非常易于接触
- en: It gives you access to the mature OCaml community and its aggregated knowledge
    base
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为你提供了访问成熟的 OCaml 社区和其聚合的知识库
- en: We will take advantage of the contrasts between the two languages to understand
    how statically typed Reason code is converted into dynamically typed JavaScript
    code yet still runs safely by design.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用两种语言之间的差异来理解静态类型 Reason 代码是如何转换为动态类型 JavaScript 代码，同时仍然通过设计安全地运行。
- en: Getting started with ReasonML
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReasonML 入门
- en: 'The Reason website has a great quickstart guide as well as tutorials for setting
    up editor support. First, install NodeJS to get the **node package manager** (**npm**).
    Then, run the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 网站还有一个很好的快速入门指南以及设置编辑器支持的教程。首先，安装 NodeJS 以获取 **node 包管理器**（**npm**）。然后，运行以下命令：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can do an initial compile with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令进行初始编译：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command builds your entire project and its dependencies recursively.
    It will be almost instantaneous.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令递归地构建你的整个项目和其依赖项。它将几乎是瞬间的。
- en: It's worth mentioning that we actually recommend running the preceding shell
    commands (substituting in your actual projects folder, of course), because throughout
    this book, we're going to arrange the code examples in the form of a single project,
    `learning-tydd-reason`, and the code examples that you type into the various given
    file names will fit together to make up that project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们实际上推荐运行前面的 shell 命令（当然，替换为你的实际项目文件夹），因为在这本书中，我们将把代码示例组织成单个项目，`learning-tydd-reason`，而你输入到各种给定文件名中的代码示例将组合在一起形成该项目。
- en: You will almost certainly want to set up editor support in Reason so that you
    can get things like autocompletion and go to definition. The guides available
    on the ReasonML website ([https://reasonml.github.io/docs/en/global-installation.html](https://reasonml.github.io/docs/en/global-installation.html))
    are very helpful for this. Currently, Visual Studio Code ([http://code.visualstudio.com/](http://code.visualstudio.com/))
    is the best-supported editor; you will probably get the best results from using
    that.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎肯定想在 Reason 中设置编辑器支持，以便你可以获得诸如自动完成和转到定义等功能。ReasonML 网站上可用的指南（[https://reasonml.github.io/docs/en/global-installation.html](https://reasonml.github.io/docs/en/global-installation.html)）对此非常有帮助。目前，Visual
    Studio Code ([http://code.visualstudio.com/](http://code.visualstudio.com/)) 是支持最好的编辑器；你可能会从使用它中获得最佳结果。
- en: If you are trying to decide on the install method, we would personally recommend
    the OPAM method (**OPAM** is the abbreviation of **OCaml Package Manager**).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试决定安装方法，我们个人推荐 OPAM 方法（**OPAM** 是 **OCaml 包管理器**的缩写）。
- en: Using Try Reason
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Try Reason
- en: 'Reason provides a fantastic resource for learners: an online Reason-to-JavaScript
    compiler and evaluator. To access it, go to the Reason website and click Try in
    the navigation bar at the top. You can use it to quickly try out different ideas.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 为学习者提供了一个极好的资源：一个在线 Reason 到 JavaScript 编译器和评估器。要访问它，请访问 Reason 网站，并在顶部导航栏中点击
    Try。你可以用它来快速尝试不同的想法。
- en: 'Let''s run through a quick example using Try Reason to get our bearings. Type
    in the example code from `src/Ch01/Ch01_Demo.re` into the Reason section of the
    Try Reason web app. Now add the following line after that:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例来使用 Try Reason 了解我们的方向。将 `src/Ch01/Ch01_Demo.re` 中的示例代码输入到 Try Reason
    网页应用中的 Reason 部分。现在在那之后添加以下行：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now if you examine the output JS, you should see that the following changes
    have been made:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你检查输出的 JS，你应该能看到以下更改：
- en: Types have been stripped away
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型已被移除
- en: Records have been transformed into arrays without field names (records are roughly
    like C structs or JavaScript objects)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录已被转换为没有字段名称的数组（记录大致类似于 C 结构体或 JavaScript 对象）
- en: Every declared value is explicitly exported (made public)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个声明的值都明确导出（公开）
- en: Note that we have purposely introduced very little actual Reason syntax in this
    chapter. If you are curious to explore the syntax (which is very similar to JavaScript
    at its core), it's best if you explore the excellent Reason website documentation.
    Since the focus of this book is type-driven development, in the upcoming chapters
    we will introduce all the syntax we will need and discuss its impact on our understanding
    of the code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这章中故意引入了非常少的实际 Reason 语法。如果你对探索语法（其核心与 JavaScript 非常相似）感兴趣，最好的方式是探索出色的
    Reason 网站文档。由于本书的重点是类型驱动开发，在接下来的章节中，我们将介绍我们将需要的所有语法，并讨论它对我们理解代码的影响。
- en: Going further
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入学习
- en: The ReasonML community is a helpful, fast-growing one. If you need help with
    anything, don't be afraid to ask. You'll only be a beginner once, and once you're
    comfortable, you'll be able to help other beginners. Check out the community page
    at [https://reasonml.github.io/docs/en/community.html](https://reasonml.github.io/docs/en/community.html)
    and drop by the discord chat as the first point of contact.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonML 社区是一个有帮助的、快速发展的社区。如果你需要任何帮助，不要害怕提问。你只会初学者一次，一旦你感到舒适，你就能帮助其他初学者。请访问社区页面
    [https://reasonml.github.io/docs/en/community.html](https://reasonml.github.io/docs/en/community.html)，并在
    discord 聊天中作为首次接触点。
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the basic ideas of type-driven development and
    critically analyzed a piece of dynamically-typed code to explore its potential
    error conditions that would be prevented by adding static types. We also introduced
    the ReasonML language and its ecosystem, set up our own Reason project, and got
    a glimpse of how it can compile statically typed code to JavaScript.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了类型驱动开发的初步概念，并批判性地分析了一块动态类型代码，以探索其潜在的错误条件，这些错误条件可以通过添加静态类型来防止。我们还介绍了
    ReasonML 语言及其生态系统，设置了我们的 Reason 项目，并瞥见了它如何将静态类型代码编译成 JavaScript。
- en: The next chapter will be an important one—we'll delve more into types, values,
    and working in Reason. See you there!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将非常重要——我们将更深入地探讨类型、值和在 Reason 中的工作方式。那里见！
