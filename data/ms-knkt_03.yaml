- en: Chapter 3. Extending Knockout with Preprocessors and Providers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用预处理器和提供者扩展Knockout
- en: 'In the previous chapter, we looked at adding custom binding handlers to Knockout
    in order to add features and integrate them with third-party tools. This capability
    was part of Knockout when it was first released, and it allows for powerful extensions
    to Knockout''s functionality. In this chapter, we are going to look at some more
    advanced techniques for extending, or even changing, Knockout binding behaviors.
    You will learn how to create:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了向Knockout添加自定义绑定处理器以添加功能和将它们与第三方工具集成的技术。这项功能是Knockout首次发布时就有的，它允许对Knockout的功能进行强大的扩展。在本章中，我们将探讨一些更高级的扩展或甚至改变Knockout绑定行为的技术。你将学习如何创建：
- en: Binding handler preprocessors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定处理器预处理程序
- en: Node preprocessors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点预处理程序
- en: Binding providers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定提供者
- en: After we cover this, we will take a look at the Knockout Punches library, which
    is a collection of preprocessors and extensions by Knockout developer Michael
    Best.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍完这些之后，我们将看看Knockout Punches库，这是一个由Knockout开发者Michael Best提供的预处理器和扩展集合。
- en: Binding the handler preprocessing
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定处理器预处理
- en: 'So far, we have looked at two properties of binding handlers: the `init` and
    `update` functions. Binding handlers have another optional function, which is
    `preprocess`, that is run before the `init` function. A preprocessor''s purpose
    is to modify the `data-binding` attribute before Knockout determines what bindings
    are to be applied.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了绑定处理器的两个属性：`init`和`update`函数。绑定处理器还有一个可选的函数，即`preprocess`，它在`init`函数之前运行。预处理器的目的是在Knockout确定要应用哪些绑定之前修改`data-binding`属性。
- en: 'Preprocessors don''t deal with elements or binding contexts; they just deal
    with the strings that the binding will evaluate. For example, if we had a preprocessor
    that converts all text bindings to uppercase, then the following `span` element
    will be processed:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理程序不处理元素或绑定上下文；它们只处理绑定将评估的字符串。例如，如果我们有一个将所有文本绑定转换为大写的预处理程序，那么以下`span`元素将被处理：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This `span` element would be processed as if it was written like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`span`元素将被处理成这样：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you were to inspect the HTML after this, you will still see the original
    `data-bind` attribute. This is because preprocessors don't actually deal with
    elements; they just modify the binding strings before the normal binding handler
    is applied.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个之后检查HTML，你仍然会看到原始的`data-bind`属性。这是因为预处理程序实际上并不处理元素；它们只是在正常绑定处理器应用之前修改绑定字符串。
- en: Creating preprocessors
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建预处理程序
- en: 'Adding a preprocessor is as simple as adding a `preprocess` property to the
    binding handler, just like we added the `init` and `update` functions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个预处理器的操作就像给绑定处理器添加一个`preprocess`属性一样简单，就像我们添加了`init`和`update`函数：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The three parameters of the `preprocess` function are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`preprocess`函数的三个参数如下：'
- en: '`value`: This is the expression given to the binding handler. For example,
    in `text: name`, the value is `name`; for `text: title() + ''. '' + name()`, the
    value is `"title() + ''. '' + name()"`. This value is always a string.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`: 这是绑定处理器给出的表达式。例如，在`text: name`中，值是`name`；在`text: title() + ''. ''
    + name()`中，值是`"title() + ''. '' + name()"`。这个值始终是一个字符串。'
- en: '`name`: This is the name of the binding handler, for example, `text` or `click`.
    This can be useful in cases where a single `preprocess` function is used by multiple
    binding handlers.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是绑定处理器的名称，例如，`text`或`click`。这在多个绑定处理器使用单个`preprocess`函数的情况下非常有用。'
- en: '`addBinding`: This is a callback function that takes the `name` and `value`
    string parameters, just like the previous ones. It will add the pair as a binding
    on the element.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addBinding`: 这是一个回调函数，它接受`name`和`value`字符串参数，就像之前的那些一样。它将这个对作为绑定添加到元素上。'
- en: The return value from the preprocessor will be the new value used for the entire
    binding.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理程序的返回值将是整个绑定使用的新值。
- en: Let's look at a few examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个例子。
- en: The uppercase preprocessor
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大写预处理程序
- en: 'The Knockout documentation provides an example for this preprocessor that,
    at the time of writing this, returns `value + ".toUpperCase()"`. The full preprocessor
    will look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout文档提供了一个关于这个预处理器的示例，在撰写本文时，它返回`value + ".toUpperCase()"`。完整的预处理程序将如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code would work, for example, at the beginning of this section
    when it took a string directly:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在例如本节开头直接取字符串时将有效。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result of our preprocessor will be `text: ''That Guy''.toUpperCase()` and
    the text binding will handle this without any error. Unfortunately, this will
    break in the normal case of binding against observable properties:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '我们预处理器的结果将是 `text: ''That Guy''.toUpperCase()`，并且文本绑定将无错误地处理这个结果。不幸的是，这将在绑定到可观察属性的正常情况下失败：'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Knockout''s normal binding process unwraps the expression it gets so that observables
    don''t need parentheses. Preprocessors, on the other hand, just output strings
    that are directly consumed by the binding handler. Our uppercase binding will
    produce an illegal result here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 的正常绑定过程会展开它得到的表达式，这样可观察的属性就不需要括号。另一方面，预处理器只是输出直接由绑定处理器消费的字符串。我们的大写绑定将在这里产生一个非法的结果：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will fail, as `firstName` is an observable and not a string, and observables
    don't have a `toUpperCase` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将失败，因为 `firstName` 是一个可观察的属性，而不是一个字符串，并且可观察的属性没有 `toUpperCase` 方法。
- en: 'Luckily, the solution to this is simple. Our preprocessor can safely handle
    all value expressions by applying an `unwrap` function to the output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个解决方案很简单。我们的预处理器可以通过应用一个 `unwrap` 函数安全地处理所有值表达式：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will ensure that any value—whether a primitive type, observable, or inline
    expression—is correctly evaluated by the binding handler.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保任何值——无论是原始类型、可观察的属性还是内联表达式——都能被绑定处理器正确评估。
- en: You can see an example of this preprocessor in the `cp3-uppercase` branch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `cp3-uppercase` 分支中看到这个预处理器的示例。
- en: Wrapping existing bindings
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装现有绑定
- en: Because Knockout provides default bindings for most standard scenarios, it's
    common to want for a custom binding to build on top of them. Preprocessors make
    wrapping other bindings very easy.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Knockout 为大多数标准场景提供了默认绑定，因此通常希望自定义绑定能够建立在它们之上。预处理器使得包装其他绑定变得非常容易。
- en: Let's say that we wanted a binding that caused an element to flash when a property
    was updated in addition to providing a `value` binding on it. Normally, you might
    want to divide these into two separate bindings, but if you are doing this a lot,
    a single binding will save time and keystrokes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个绑定，当属性更新时使元素闪烁，同时在它上面提供 `value` 绑定。通常，你可能会想要将这些分成两个单独的绑定，但如果你经常这样做，一个单独的绑定将节省时间和按键。
- en: 'As the `value` binding already exists, we can just use a preprocessor to add
    the binding with the `addBinding` callback:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `value` 绑定已经存在，我们只需使用预处理器通过 `addBinding` 回调添加绑定即可：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `addBinding` callback takes care of generating the `value` binding as if
    it had been applied normally, which includes running the preprocessor for the
    new binding (if it has one).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`addBinding` 回调负责生成 `value` 绑定，就像它被正常应用一样，这包括为新绑定（如果有的话）运行预处理器。'
- en: 'It''s important that we still return the original value after adding the `value`
    binding. If nothing is returned from the `preprocess` function, then the original
    binding is removed. After this, the rest of the binding handler is business as
    usual: add an `init` and `update` function (as required) and write your custom
    behavior. There is an example of this binding in the `cp3-wrap` branch.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加 `value` 绑定后，我们仍然需要返回原始值是很重要的。如果 `preprocess` 函数没有返回任何内容，那么原始绑定将被移除。之后，绑定处理器的其余部分就像往常一样：添加所需的
    `init` 和 `update` 函数，并编写你的自定义行为。在 `cp3-wrap` 分支中有一个这种绑定的示例。
- en: That's really all there is to creating binding handler preprocessors. For the
    extensibility they allow, they are simple and straightforward to use. We will
    look at some more real-world possibilities for binding preprocessors when we look
    at `Knockout.Punches` in the last section of this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是创建绑定处理器预处理器所需要做的全部。由于它们允许扩展性，它们的使用简单直接。当我们在本章的最后部分查看 `Knockout.Punches` 时，我们将探讨一些更多关于绑定预处理器在现实世界中的可能性。
- en: Node preprocessors
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点预处理器
- en: Binding handler preprocessors are attached to individual binding handlers and
    work by modifying the binding string. They only apply to nodes of their respective
    handler.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定处理器的预处理器附加到单个绑定处理器上，通过修改绑定字符串来工作。它们仅适用于各自处理器的节点。
- en: Node preprocessors, on the other hand, are called on every DOM node. They run
    when the UI is first bound and when it is modified by bindings such as `foreach`
    or `template`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，节点预处理器在每一个 DOM 节点上都会被调用。它们在 UI 首次绑定时运行，以及当 UI 被绑定如 `foreach` 或 `template`
    这样的绑定修改时运行。
- en: 'The purpose of a node preprocessor is to modify the DOM before data-binding
    occurs, as opposed to a binding preprocessor that only modifies the `data-bind`
    attribute. A node preprocessor is defined by adding a `preprocessNode` function
    to the binding provider:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 节点预处理器的目的是在数据绑定发生之前修改 DOM，与仅修改 `data-bind` 属性的绑定预处理器相反。节点预处理器是通过向绑定提供者添加一个 `preprocessNode`
    函数来定义的：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A preprocessor is called once for each node. If no changes need to be made,
    it should return nothing. Otherwise, it can use the standard DOM API to insert
    new nodes or remove the current node:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器为每个节点调用一次。如果不需要进行任何更改，它应该返回空值。否则，它可以使用标准的 DOM API 插入新节点或删除当前节点：
- en: 'New nodes should be inserted before the current node by using:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用以下方式在当前节点之前插入新节点：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Replacement can be done with:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换可以通过以下方式完成：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Removal can be done with:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用以下方式删除：
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Any nodes that are added need to be returned from `preprocessNode`; otherwise,
    Knockout will not apply bindings to them. As you do not have the binding context
    inside `preprocessNode` (you only have the current node), it is not possible to
    apply bindings yourself, unless they are applied to constant or global values.
    This is not recommended, though, as it creates a new binding context outside of
    the current context's hierarchy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的任何节点都需要从 `preprocessNode` 返回；否则，Knockout 不会将绑定应用于它们。由于在 `preprocessNode`
    中没有绑定上下文（你只有当前节点），因此无法自行应用绑定，除非它们应用于常量或全局值。然而，这并不推荐，因为它会在当前上下文层次结构之外创建一个新的绑定上下文。
- en: Closing virtual template nodes
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭虚拟模板节点
- en: 'The Knockout documentation provides a handy node preprocessor that self-closes
    virtual template bindings. Normally, when writing a containerless template binding,
    you would need two comment nodes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 文档提供了一个方便的节点预处理器，它可以自动关闭虚拟模板绑定。通常，在编写无容器的模板绑定时，你需要两个注释节点：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As a template binding never contains content when referencing an external template,
    the closing comment node feels unnecessary. A `preprocess` function will allow
    you to use a template without the closing tag so that you can write the binding
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板绑定在引用外部模板时永远不会包含内容，因此闭合注释节点看起来是不必要的。一个 `preprocess` 函数将允许你使用模板而不需要闭合标签，这样你可以将绑定写成这样：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Knockout requires a closing comment tag, which is `<!-- /ko -->`, for virtual
    bindings. We can provide this comment node automatically with a preprocessor:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 需要一个闭合的注释标签，即 `<!-- /ko -->`，用于虚拟绑定。我们可以通过预处理器自动提供这个注释节点：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This sample uses regex to identify template comments and extract the expression
    from the binding. Then, it replaces the original comment with the standard open/close
    pair of comments for a virtual template binding. Finally, it returns the new comment
    nodes, allowing Knockout to bind them; this will apply the template to the virtual
    container created by the comment nodes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用正则表达式来识别模板注释并从绑定中提取表达式。然后，它用虚拟模板绑定的标准开/闭注释对替换原始注释。最后，它返回新的注释节点，允许 Knockout
    将它们绑定；这将把模板应用到由注释节点创建的虚拟容器中。
- en: Supporting alternate syntaxes
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持不同的语法
- en: The previous example should have given you an idea of how node preprocessors
    work. However, the real power of node preprocessors comes from letting us extend
    the data binding syntax itself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子应该已经让你了解了节点预处理器的运作方式。然而，节点预处理器的真正威力在于它让我们能够扩展数据绑定语法本身。
- en: 'It''s not uncommon to see a series of text bindings like this one:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 看到一系列文本绑定，如这个例子，并不罕见：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We want to list out several properties, but these virtual elements are pretty
    verbose. On top of the property name, they add 29 characters, including spaces.
    We can also use `span` elements, of course, but they are about the same size,
    considering that they need the `data-bind` attributes in addition to the binding
    name.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想列出几个属性，但这些虚拟元素相当冗长。除了属性名外，它们还增加了 29 个字符，包括空格。当然，我们也可以使用 `span` 元素，但考虑到它们还需要
    `data-bind` 属性以及绑定名称，它们的大小几乎相同。
- en: 'If you''ve ever used AngularJS or Handlebars, you''ll probably appreciate the
    minimal requirement of using curly braces to access values as strings. The preceding
    example will look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 AngularJS 或 Handlebars，你可能会欣赏使用花括号以字符串形式访问值的最低要求。前面的例子将看起来像这样：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Look how much shorter and easier to read this is! These Handlebars guys have
    the right idea. I'm sure you know where we are going with this. A node preprocessor
    will allow us to take this same HTML and replace it with the HTML from the first
    example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这有多简短，阅读起来有多容易！这些 Handlebars 的人有正确的方法。我相信你知道我们接下来要做什么。一个节点预处理器将允许我们用第一个示例中的
    HTML 替换相同的 HTML。
- en: 'This example is long, so we are going to break it up a bit:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例很长，所以我们将把它分成几部分：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we have a regex pattern that finds these double curly brace chunks. As
    text nodes will contain any content up to the first real element they encounter,
    its possible that multiple curly brace chunks might be in a single node, so it
    needs to match globally. Then, the `preprocess` function starts out by checking
    for the text node type.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个正则表达式模式，它可以找到这些双大括号块。由于文本节点将包含任何内容，直到它们遇到第一个真实元素，所以单个节点中可能有多个大括号块，因此它需要全局匹配。然后，`preprocess`
    函数首先检查文本节点类型。
- en: I've omitted the section that actually scans the node to create new ones for
    now; we will come back to that in just a bit.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在省略了实际扫描节点以创建新节点的部分；我们稍后会回到这一点。
- en: If we have any nodes that need to be added, they get inserted, and then the
    original node is removed. Finally, the nodes we inserted are returned so that
    Knockout can bind them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何需要添加的节点，它们将被插入，然后删除原始节点。最后，返回我们插入的节点，以便 Knockout 可以绑定它们。
- en: This is almost boilerplate code for node preprocessors, and it's a very good
    pattern to follow. Check for a type, create any new nodes, replace the original
    nodes if there are any, and return the new nodes. If you are creating a node preprocessor,
    this is a good template to start with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是节点预处理器的大纲代码，并且是一个非常好的模式。检查类型，创建任何新节点，如果有，替换原始节点，并返回新节点。如果您正在创建节点预处理器，这是一个很好的模板开始。
- en: 'Okay, let''s get to the meat. To assign `newNodes`, we need to check the node
    for our regex pattern and build a pair of virtual text bindings for each match:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们进入正题。为了分配 `newNodes`，我们需要检查节点中的正则表达式模式并为每个匹配项构建一对虚拟文本绑定：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we are calling `replaceExpressionsInText` and passing the node''s contents,
    our regex pattern, and a callback that builds the correct replacements with the
    expression found by our regex. Then, we just need the actual search:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用 `replaceExpressionsInText` 并传递节点内容、我们的正则表达式模式和回调函数，该回调函数使用我们通过正则表达式找到的表达式构建正确的替换项。然后，我们只需要实际的搜索：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The search function loops on the regex pattern and pulls out the first match.
    It sends the match to the callback function and keeps the result, along with any
    leading or trailing spaces. When it's finished matching, it returns them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索函数在正则表达式模式上循环，提取第一个匹配项。它将匹配项发送到回调函数，并保留结果，包括任何前导或尾随空格。当完成匹配后，它返回它们。
- en: That's it. Now, our Handlebars code will be converted to virtual text bindings.
    You can see this example in the `cp3-interpolate` branch.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，我们的 Handlebars 代码将被转换为虚拟文本绑定。您可以在 `cp3-interpolate` 分支中查看这个示例。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code is adapted from the `StringInterpolatingBindingProvider` demo at [http://blog.stevensanderson.com/2013/07/09/](http://blog.stevensanderson.com/2013/07/09/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是从 [http://blog.stevensanderson.com/2013/07/09/](http://blog.stevensanderson.com/2013/07/09/)
    上的 `StringInterpolatingBindingProvider` 示例改编的。
- en: Multiple syntaxes
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多种语法
- en: If we wanted to push this example a bit farther, we could support additional
    interpolation syntaxes. `replaceExpressionsInText` is already set up to take regex
    input, and as it uses a callback, we can even construct nodes differently for
    different regex patterns.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想把这个示例做得更深入，我们可以支持额外的插值语法。`replaceExpressionsInText` 已经设置为接受正则表达式输入，并且因为它使用回调，我们可以为不同的正则表达式模式构造不同的节点。
- en: 'Let''s add the embedded Ruby syntax interpolation, which uses `<%= expression
    %>`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加嵌入式 Ruby 语法插值，它使用 `<%= expression %>`：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, we are replacing a `span` element instead of a virtual text element
    so that we can tell the resulting HTML apart. As this preprocessor can support
    both syntaxes, you can bind against a mixed syntax template:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们正在替换一个 `span` 元素而不是虚拟文本元素，这样我们就可以区分生成的 HTML。因为这个预处理器可以支持两种语法，所以您可以对混合语法的模板进行绑定：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The resulting HTML will look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 HTML 将看起来像这样：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see this example in the `cp3-interpolate2` branch.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `cp3-interpolate2` 分支中查看这个示例。
- en: Binding providers
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定提供者
- en: With a binding preprocessor, we have access to the binding expression and can
    modify it before the evaluation of bindings. With a node preprocessor, we have
    access to the node and can modify the DOM before bindings are applied. Both of
    these just transform things into the normal Knockout syntax. They are also limited
    to operating on the DOM, and they do not have access to the binding context.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定预处理程序，我们可以访问绑定表达式并在绑定评估之前对其进行修改。使用节点预处理程序，我们可以访问节点并在绑定应用之前修改DOM。这两者都只是将事物转换成正常的Knockout语法。它们也仅限于在DOM上操作，并且无法访问绑定上下文。
- en: Knockout binding providers are objects that receive both the DOM node and the
    binding context and determine which bindings handlers will be applied and what
    `valueAccessor` properties those bindings receive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout绑定提供程序是对象，它们接收DOM节点和绑定上下文，并确定将应用哪些绑定处理程序以及这些绑定接收哪些`valueAccessor`属性。
- en: 'A binding provider is expected to provide the following functions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 预期绑定提供程序提供以下函数：
- en: '`nodeHasBindings(node)`: This function should return a Boolean that indicates
    whether or not the node has any bindings defined on it.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodeHasBindings(node)`: 此函数应返回一个布尔值，指示节点是否定义了任何绑定。'
- en: '`getBindingAccessors(node, bindingContext)`: This function should return an
    object with a property for each binding to be applied whose value is a function
    that evaluates the binding expression. This function is used as the `valueAccessor`
    property in binding handlers.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getBindingAccessors(node, bindingContext)`: 此函数应返回一个对象，其中每个要应用的绑定都有一个属性，其值是一个评估绑定表达式的函数。此函数用作绑定处理程序中的`valueAccessor`属性。'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are targeting 2.x, you will need to support `getBindings`, which returns
    an object whose property values are the final binding values. This function was
    deprecated with Knockout 3.0.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你针对的是2.x版本，你需要支持`getBindings`函数，该函数返回一个对象，其属性值是最终的绑定值。这个函数在Knockout 3.0中被弃用。
- en: The default binding provider operates by looking for `data-bind` attributes
    on an element or a comment node that starts with `ko`. If it does, `nodeHasBindings`
    will return `true`. When `getBindingAccessors` is called, it returns the bindings
    by evaluating the `data-bind` attribute and getting the `valueAccessors` property
    from the binding context.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认绑定提供程序通过在元素或以`ko`开头的注释节点上查找`data-bind`属性来操作。如果存在，`nodeHasBindings`将返回`true`。当调用`getBindingAccessors`时，它通过评估`data-bind`属性并从绑定上下文中获取`valueAccessors`属性来返回绑定。
- en: Custom binding providers
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义绑定提供程序
- en: 'We''ve already seen how we can use preprocessors to allow for different syntaxes
    to be used for data binding. So, to get a better understanding of the capability
    of binding providers, we are going to look at something preprocessors can''t do:
    choosing bindings based on the data type.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用预处理程序允许使用不同的语法进行数据绑定。因此，为了更好地理解绑定提供程序的能力，我们将查看预处理程序无法做到的事情：根据数据类型选择绑定。
- en: 'The Knockout plugin `Knockout.BindingConventions` ([https://github.com/AndersMalmgren/Knockout.BindingConventions](https://github.com/AndersMalmgren/Knockout.BindingConventions))
    creates a binding provider that provides bindings on the `data-name` attribute
    by looking at the binding context for clues on the bindings that are to be used,
    which makes it a great example for a custom provider. As this is a big change
    from how Knockout works, let''s compare this to a standard viewmodel and binding
    setup:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout插件`Knockout.BindingConventions`([https://github.com/AndersMalmgren/Knockout.BindingConventions](https://github.com/AndersMalmgren/Knockout.BindingConventions))创建了一个绑定提供程序，该程序通过查看绑定上下文以获取要使用的绑定线索，在`data-name`属性上提供绑定，因此它是一个自定义提供程序的绝佳示例。由于这与Knockout的工作方式有很大不同，让我们将其与标准视图模型和绑定设置进行比较：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Binding to this with standard Knockout bindings might look something like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准Knockout绑定来绑定此内容可能看起来像这样：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've got three bound elements and four bindings. The first input is a `value`
    that is binding to `name`, the `select` element is binding to `options` on `locations`
    and `value` on `selectedLocation`, and the last input is binding `checked` to
    `isAdmin`. A simple case, such as having to specify that the binding on an input
    is a value, might seem verbose; in most cases, an input will be binding against
    the value, or in the case of a checkbox, binding against `checked`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个绑定元素和四个绑定。第一个输入是一个绑定到`name`的`value`，`select`元素绑定到`locations`上的`options`和`selectedLocation`上的`value`，最后一个输入将`checked`绑定到`isAdmin`。在需要指定输入绑定是一个值的情况下，这是一个简单的例子；在大多数情况下，输入将绑定到值，或者在这种情况下，复选框将绑定到`checked`。
- en: 'The convention-over-configuration philosophy aims to remove the need to specify
    what is happening in a conventional scenario. In other words, perform the standard
    action unless otherwise specified. Here is how the previous DOM would look using
    the `BindingConventions` plugin:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “约定优于配置”的哲学旨在消除在常规场景中指定发生什么的需求。换句话说，除非另有说明，否则执行标准操作。以下是使用`BindingConventions`插件查看之前DOM的方式：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, `BindingConventions` is doing all the work of figuring out the bindings.
    The `name` input is a string observable on our viewmodel, and it's on an input
    node, so it gets the `value` binding. The `isAdmin` input is a Boolean observable
    on our viewmodel, so the input node is converted into a checkbox, and it receives
    the `checked` binding. The `locations` property is an array on our viewmodel,
    so the `select` element gets an `options` binding. However, this is not all! Our
    viewmodel has a `selectedLocations` observable, which `BindingConventions` determines
    should get a `value` binding for the `select` element, as singularizing an array
    name and prepending `selected` is a binding convention.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`BindingConventions`正在做所有确定绑定的工作。`name`输入是我们viewmodel上的一个字符串可观察对象，它位于一个输入节点上，因此它获得`value`绑定。`isAdmin`输入是我们viewmodel上的布尔可观察对象，因此输入节点被转换成复选框，并接收`checked`绑定。`locations`属性是我们viewmodel上的一个数组，因此`select`元素获得一个`options`绑定。然而，这还不是全部！我们的viewmodel有一个`selectedLocations`可观察对象，`BindingConventions`确定它应该为`select`元素获得一个`value`绑定，因为将数组名称单数化并在前面添加`selected`是一个绑定约定。
- en: That last one might seem like magic, and personally, I think it's a bit too
    non-obvious, but it has a certain appeal to it. If you are following conventions,
    you can really simplify your bindings. You can see this example in action in the
    `cp3-provider` branch.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可能看起来像是魔法，我个人认为它有点不明显，但它确实有一定的吸引力。如果你遵循约定，你可以真正简化你的绑定。你可以在`cp3-provider`分支中看到这个示例的实际效果。
- en: Now that you can see what this binding provider is doing, let's look at how
    it works.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了这个绑定提供者正在做什么，让我们看看它是如何工作的。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will be looking at a simplified version of the binding provider in the `BindingConventions`
    plugin. The real provider supports more conventions and allows for custom conventions
    to be added. This sample is only meant to illustrate the type detection concept
    and the basics of creating a custom provider.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`BindingConventions`插件中查看绑定提供者的简化版本。真正的提供者支持更多的约定，并允许添加自定义约定。这个示例只是为了说明类型检测概念和创建自定义提供者的基础知识。
- en: The first thing that needs to be decided when creating a custom binding provider
    is whether you need to extend the default binding provider or replace it. The
    `BindingConventions` provider will support the `data-name` attribute. In this
    case, it makes sense to extend the default provider, as they do not conflict with
    each other and we will need the standard `data-bind` support for scenarios that
    are nonconventional (such as binding our select value to a `favoriteLocation`
    property).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义绑定提供者时，需要决定的第一件事是您是否需要扩展默认绑定提供者或替换它。`BindingConventions`提供者将支持`data-name`属性。在这种情况下，扩展默认提供者是有意义的，因为它们之间没有冲突，并且我们将需要标准的`data-bind`支持来处理非常规场景（例如，将我们的选择值绑定到`favoriteLocation`属性）。
- en: 'The easiest way to do this is to store a reference to the original binding
    provider and call it in our custom provider:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的最简单方法是存储对原始绑定提供者的引用，并在我们的自定义提供者中调用它：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is basically boilerplate for a binding provider that extends the default
    one. It stores the original provider and implements the `nodeHasBindings` and
    `getBindingAccessors` functions by calling the default provider first, calling
    its own implementation if the default provider returns nothing. If you want your
    provider to check for bindings before the default one, you can switch the order
    of the calls. Finally, you can combine the two by appending binding handlers to
    the result of the default provider.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是一个扩展默认提供者的绑定提供者的样板代码。它存储原始提供者，并通过首先调用默认提供者来实现`nodeHasBindings`和`getBindingAccessors`函数，如果默认提供者返回空值，则调用其自己的实现。如果您希望您的提供者在默认提供者之前检查绑定，您可以交换调用顺序。最后，您可以通过将绑定处理程序附加到默认提供者的结果来组合两者。
- en: After setting up the required functions, `ko.bindingProvider.instance` is replaced
    with the new custom provider. It's important to note that this must all be done
    prior to `ko.applyBindings` being called, as the binding provider is only constructed
    once for the root binding context.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置所需的函数之后，`ko.bindingProvider.instance`被替换为新的自定义提供者。重要的是要注意，所有这些都必须在调用`ko.applyBindings`之前完成，因为绑定提供者只为根绑定上下文构建一次。
- en: 'From here, all we have to do is provide the methods that check for bindings
    and create them. Checking for bindings just requires you to check for the `data-name`
    attribute:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们只需要提供检查绑定并创建它们的方法。检查绑定只需要检查`data-name`属性：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Getting the value from the binding context is a bit more work. Knockout has
    utility methods that can parse expressions under the `ko.expressionRewriting`
    object, which can read any of the supported Knockout binding syntaxes. The `BindingConventions`
    plugin does not support anything other than property references, but it does support
    deep references such as `person.firstName`. For simplicity''s sake, I am not going
    to cover this, but if you are interested in this, you can look at `getDataFromComplexObjectQuery`
    in the plugin''s source code. For now, we will assume that all `data-name` attributes
    refer directly to a property:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从绑定上下文获取值需要做更多的工作。Knockout在`ko.expressionRewriting`对象下提供了实用方法，可以解析任何支持的Knockout绑定语法。`BindingConventions`插件不支持除属性引用之外的内容，但它支持深层次引用，例如`person.firstName`。为了简单起见，我将不涉及这一点，但如果你对这个感兴趣，可以查看插件源代码中的`getDataFromComplexObjectQuery`。现在，我们假设所有`data-name`属性都直接引用一个属性：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we get the name of the viewmodel property from the `data-name` attribute,
    and then we perform a sanity check to make sure that it's there to bind against.
    Then, we get the data with `ko.utils.peekObservable` and check its type. All observables
    have a `peek` function that returns the underlying value without triggering dependency
    detection. The `peekObservable` function will call `peek` if the first parameter
    is observable; otherwise, it will just return the first parameter. It's a safety
    utility that is similar to `ko.uwrap`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`data-name`属性中获取viewmodel属性的名称，然后我们执行一个合理性检查以确保它存在以进行绑定。然后，我们使用`ko.utils.peekObservable`获取数据并检查其类型。所有可观察对象都有一个`peek`函数，它返回底层值而不触发依赖检测。`peekObservable`函数如果第一个参数是可观察的，将调用`peek`；否则，它将只返回第一个参数。这是一个类似于`ko.uwrap`的安全实用工具。
- en: 'After we have these two bits of information, we can build the binding object
    we need to return. Remember, this binding object should have a property named
    after the binding to be applied, whose value is the `valueAccessor` object for
    the binding. The bindings are returned to the binding provider''s `getBindingAccessors`
    function. To construct the bindings, we will loop over a set of conventions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了这两条信息之后，我们可以构建返回所需的绑定对象。记住，这个绑定对象应该有一个以要应用的绑定命名的属性，其值是绑定对应的`valueAccessor`对象。绑定被返回到绑定提供者的`getBindingAccessors`函数。为了构建绑定，我们将遍历一组约定：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will look through the `conventionBinders` array and check the rules for
    each one in order to find a match for the current node, data, and data type. If
    all of the rules for a convention handler pass, then we call `apply` for that
    convention and stop checking—only one convention should apply per node. The `apply`
    function gets all of the information we've collected so far as well as a `valueAccessor`
    property that can be used for the binding.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遍历`conventionBinders`数组，并按顺序检查每个元素的规则，以找到当前节点、数据和数据类型的匹配项。如果一个约定处理程序的规则都通过了，那么我们调用该约定的`apply`函数并停止检查——每个节点应该只应用一个约定。`apply`函数获取我们迄今为止收集的所有信息，以及一个可以用于绑定的`valueAccessor`属性。
- en: 'Our example is only using two conventions, which are `options` and `input`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子只使用了两种约定，即`options`和`input`：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The options have just one rule: the element must be a `select` element, and
    the data needs to be an array (which is being checked by looking for a `push`
    function).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 选项只有一个规则：元素必须是一个`select`元素，并且数据需要是一个数组（通过查找`push`函数来检查）。
- en: The `apply` function sets the options binding directly to the `valueAccessor`
    property. Then, it tries to find a property that matches the `'selected' + getPascalCased(singularized)`
    convention on the context. The `singularize` and `getPascalCased` functions are
    not included here, but you can see them in the example branch in the following
    code. Predictably, they find a singular conjugation of a word and capitalize the
    first letter. If a match is found, a `value` binding is added to the `bindings`
    object that was passed in.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 函数直接将选项绑定设置到 `valueAccessor` 属性。然后，它尝试在上下文中找到一个匹配 `''selected'' + getPascalCased(singularized)`
    约定的属性。`singularize` 和 `getPascalCased` 函数在此处未包含，但您可以在以下代码示例分支中看到它们。不出所料，它们找到一个单词的单数形式并将其首字母大写。如果找到匹配项，则将
    `value` 绑定添加到传入的 `bindings` 对象中。'
- en: 'The `input` handler is much simpler:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`input` 处理器要简单得多：'
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `input` handler's rules don't check the data type; it's just that the node
    is either `input` or `textarea`. The `apply` function will use a `value` binding
    if the type is not `Boolean`; otherwise, it sets the `checkbox` property on the
    node and uses the `checked` binding.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`input` 处理器的规则不检查数据类型；它只是节点是 `input` 或 `textarea`。如果类型不是 `Boolean`，则 `apply`
    函数将使用 `value` 绑定；否则，它将节点上的 `checkbox` 属性设置为 `checkbox` 并使用 `checked` 绑定。'
- en: That's it. This binding provider will allow binding to occur with the `data-name`
    attribute, requiring only a view model property as the value, and it intelligently
    sets up bindings for the conventional scenario. If we need more control, the regular
    `data-bind` attributes can still be used to apply bindings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。这个绑定提供程序将允许使用 `data-name` 属性进行绑定，只需要一个视图模型属性作为值，并且它智能地设置了常规场景的绑定。如果我们需要更多控制，仍然可以使用常规的
    `data-bind` 属性来应用绑定。
- en: This simplified implementation of the `BindingConventions` binding provider
    can be seen in the `cp3-provider2` branch. The `client/app` directory in the branch
    contains both the simplified implementation discussed here as well as the full
    implementation from the plugin.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `BindingConventions` 绑定提供程序的简化实现可以在 `cp3-provider2` 分支中看到。该分支的 `client/app`
    目录包含这里讨论的简化实现以及从插件中获取的完整实现。
- en: None of this would be possible with a binding or node preprocessor, as it relies
    on the type of data from the binding context. Hopefully, this will give you a
    good idea of what is possible with custom binding providers and the flexibility
    of the overall binding system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 没有绑定或节点预处理器可以实现这一点，因为它依赖于绑定上下文中的数据类型。希望这能给您一个关于使用自定义绑定提供程序和整体绑定系统灵活性的良好概念。
- en: Knockout punches
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout 拳击
- en: Now that you are familiar with the techniques that are used to modify the binding
    syntax and the general use of preprocessors, we are going to look at the popular
    Knockout plugin `Knockout.Punches (get it?)`. Punches is written by Michael Best,
    who is a Knockout developer and the creator of the Knockout preprocessor functionality
    and some of the best real-world use cases for preprocessors. We are going to look
    at some of them and dig in to see how they work. This section is not going to
    cover everything in Knockout Punches; if you want to learn more about it, you
    can check out the documentation online.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了用于修改绑定语法和预处理器的通用使用的技术，我们将探讨流行的 Knockout 插件 `Knockout.Punches (get it?)`。Punches
    由 Michael Best 编写，他是 Knockout 开发者，也是 Knockout 预处理器功能以及一些最佳预处理器的实际用例的创造者。我们将探讨其中的一些，并深入探讨它们是如何工作的。本节不会涵盖
    Knockout Punches 的所有内容；如果您想了解更多，可以查看在线文档。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The documentation for `Knockout.Punches` can be found at [http://mbest.github.io/knockout.punches](http://mbest.github.io/knockout.punches),
    which includes an API reference and the source code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Knockout.Punches` 的文档可以在 [http://mbest.github.io/knockout.punches](http://mbest.github.io/knockout.punches)
    找到，其中包含 API 参考和源代码。'
- en: Embedded text bindings
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内嵌文本绑定
- en: 'Embedded text bindings offer the same syntax that we created with the preprocessor
    in the *Supporting alternate syntaxes* section—converting curly braces into virtual
    text nodes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内嵌文本绑定提供了与我们在 *支持替代语法* 部分中创建的预处理器的相同语法——将花括号转换为虚拟文本节点：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The previous command becomes the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令变为以下内容：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The method Knockout Punches uses is more performant than the one we looked
    at, but it still offers the same customizability we used. If you want to use something
    besides virtual text nodes as the interpolation replacement, you can provide your
    own `node-array` returning function as a replacement for the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout Punches使用的方法比我们之前看过的更高效，但它仍然提供了我们使用的相同可定制性。如果你想使用除了虚拟文本节点之外的东西作为插值替换，你可以提供一个返回`node-array`的函数作为以下内容的替换：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Namespaced bindings
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间绑定
- en: 'Knockout Punches offers a shorthand binding syntax that expands `x.y: value`
    to `x : { y: value }`. By default, this namespace syntax is available for the
    `event`, `attr`, `style`, and `css` bindings. Using it on the `style` binding
    will cause the following to expand:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'Knockout Punches提供了一个简写绑定语法，将`x.y: value`展开为`x : { y: value }`。默认情况下，这种命名空间语法对`event`、`attr`、`style`和`css`绑定可用。在`style`绑定中使用它将导致以下内容展开：'
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will expand to the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将展开为以下内容：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This works by overriding the standard `ko.getBindingHandler` function, which
    just returns the binding handler normally. It is replaced by one that looks for
    a dot in the name of the binding with a matching `getNamespacedHandler` property
    and returns that one instead.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过覆盖标准的`ko.getBindingHandler`函数来实现，该函数通常只返回绑定处理程序。它被替换为一个查找绑定名称中具有匹配`getNamespacedHandler`属性的点的函数，并返回该函数。
- en: Dynamic namespaced bindings
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态命名空间绑定
- en: 'Because `ko.getBindingHandler` is overridden like this, it is possible to create
    your own binding namespaces by adding a `getNamespacedHandler` property to a binding
    handler:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ko.getBindingHandler`被这样覆盖，因此可以通过向绑定处理程序添加`getNamespacedHandler`属性来创建自己的绑定命名空间：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `binding` argument is the name of the binding; for `style.color`, it will
    be `color`. The function returns the binding handler to be used. This allows you
    to provide a single dynamic handler for all bindings in a namespace.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`binding`参数是绑定的名称；对于`style.color`，它将是`color`。该函数返回要使用的绑定处理程序。这允许你为命名空间中的所有绑定提供一个单一的动态处理程序。'
- en: 'Let''s say that we want to create a binding namespace for the Twitter Bootstrap
    tooltip plugin. We need to supply the text contents and the direction of the tooltip.
    Normally, we might write a binding that took each of these as options:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为Twitter Bootstrap提示插件创建一个绑定命名空间。我们需要提供提示文本内容和方向。通常，我们可能会编写一个绑定，将这些作为选项：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we could bind on it with an object:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用对象绑定到它上：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This works fine, but we can rewrite this using a namespaced binding handler
    in order to get the dot syntax for the placement:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，但我们可以使用命名空间绑定处理程序重写这个，以便获得放置的点语法：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This produces a much shorter binding attribute, which I think is easier to
    read:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个更短的绑定属性，我认为这更容易阅读：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: An example of this can be seen in the `cp3-namespace` branch.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在`cp3-namespace`分支中看到。
- en: Binding filters
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定过滤器
- en: 'It''s pretty common to perform filtering on viewmodel properties. The usual
    practice is to have a computed property on the viewmodel perform the filtering,
    but this can become verbose, especially if you have several different filtered
    properties. Knockout Punches provides syntax that applies filter expressions inside
    of bindings:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在视模型属性上执行过滤操作是很常见的。通常的做法是在视模型上有一个计算属性执行过滤，但这可能会变得冗长，尤其是如果你有多个不同的过滤属性。Knockout
    Punches提供了在绑定内应用过滤表达式的语法：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Filters are pipe-delimited, and multiple arguments are separated by colons.
    For example, `fit` takes up to three arguments, which can be specified with `fit:20:'…':'middle'`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器由管道分隔，多个参数由冒号分隔。例如，`fit`最多接受三个参数，可以用`fit:20:'…':'middle'`指定。
- en: It should be noted that `name` does not include the observable parentheses in
    the preceding example. While the entire binding with the filters is a single expression,
    which would normally require the parentheses, Knockout Punches intelligently handles
    each section by calling `ko.unwrap` on it. This means that the binding value and
    each filter are treated as their own expression.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在先前的例子中，`name`不包括可观察的括号。虽然带有过滤器的整个绑定是一个单独的表达式，通常需要括号，但Knockout Punches通过对其调用`ko.unwrap`来智能地处理每个部分。这意味着绑定值和每个过滤器都被视为它们自己的表达式。
- en: 'Filtering is accomplished with a binding preprocessor that parses the expression
    and recursively unwraps the piped sections into a call to the filter. The preceding
    example will end up returning the following from the `preprocess` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是通过一个绑定预处理器完成的，该预处理器解析表达式并将管道部分递归展开为对过滤器的调用。前面的示例最终将从`preprocess`函数返回以下内容：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Writing custom filters
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写自定义过滤器
- en: 'Adding your own filters is very similar to adding binding handlers. Just add
    a function to the `ko.filters` object that takes a value and any number of arguments
    and returns a modified value:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自己的过滤器与添加绑定处理器非常相似。只需向`ko.filters`对象添加一个函数，该函数接受一个值和任意数量的参数，并返回一个修改后的值：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first argument is the current value that is to be processed. All other arguments
    are those that are given to the filter in the binding expression.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要处理的当前值。所有其他参数都是在绑定表达式中传递给过滤器的参数。
- en: Filters can have zero arguments—as in the `uppercase` example—or optional arguments—as
    in the `fit` example. The filter preprocessor does not check the filter to see
    whether the number of arguments it's sending make sense; it just calls the filter
    with everything in the binding expression.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器可以有零个参数——就像`uppercase`示例中那样——或者可选参数——就像`fit`示例中那样。过滤器预处理器不会检查传递给它的参数数量是否合理；它只是使用绑定表达式中的所有内容调用过滤器。
- en: The filter preprocessor is simple to extend, and it offers considerable power.
    I think it is one of the best examples anywhere of the potential of binding preprocessors.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器预处理器很容易扩展，并且提供了相当大的功能。我认为它是绑定预处理器潜力的最佳示例之一。
- en: Filters on other bindings
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他绑定的过滤器
- en: By default, filters are enabled for the `text`, `attr`, and `html` bindings,
    but additional bindings can use filters by calling `ko.punches.textFilter.enableForBinding(<binding>)`.
    This can be useful if you wanted to take advantage of filters on a custom binding.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`text`、`attr`和`html`绑定启用了过滤器，但额外的绑定可以通过调用`ko.punches.textFilter.enableForBinding(<binding>)`来使用过滤器。如果你想在自定义绑定上利用过滤器，这可能很有用。
- en: Filters cannot be used in two-way bindings, such as the binding value, as they
    always produce inline expressions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器不能用于双向绑定，如绑定值，因为它们总是产生内联表达式。
- en: Adding additional preprocessors
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加额外的预处理器
- en: 'Knockout Punches provides two utility methods in order to add additional binding
    and node preprocessors that can be accessed from `ko.punches.utils`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout Punches提供了两个实用方法，用于添加额外的绑定和节点预处理器，这些方法可以通过`ko.punches.utils`访问：
- en: '`addBindingPreprocessor(bindingKeyOrHandler, preprocessFn)`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addBindingPreprocessor(bindingKeyOrHandler, preprocessFn)`'
- en: '`addNodePreprocessor(preprocessFn)`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addNodePreprocessor(preprocessFn)`'
- en: If you call either of these multiple times, the respective preprocessors will
    be chained together, with each new preprocessor being called at the end of the
    chain.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次调用这些函数中的任何一个，相应的预处理器将被链在一起，每个新的预处理器都在链的末尾被调用。
- en: The binding preprocessors will run until one of them removes the binding or
    until the end of the chain is reached. This stops the chain from trying to process
    a binding that no longer exists.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定预处理器将一直运行，直到其中一个移除绑定或直到链的末尾。这阻止了链尝试处理不再存在的绑定。
- en: The node preprocessors will run until one of them returns new nodes to add or
    until the end of the chain is reached. This stops the chain from trying to process
    a node that has already been modified. The new nodes will not be walked by the
    node preprocessors, so they should be added to the DOM and be made ready for data
    binding.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 节点预处理器将一直运行，直到其中一个返回要添加的新节点或直到链的末尾。这阻止了链尝试处理已经修改的节点。新节点不会被节点预处理器遍历，因此它们应该被添加到DOM中，并准备好进行数据绑定。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter was all about how to extend Knockout''s binding process and modify
    its syntax. We covered three ways of doing this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍了如何扩展Knockout的绑定过程并修改其语法。我们介绍了三种实现方式：
- en: '**Binding Preprocessors**: This is used to modify binding strings before binding
    handlers run'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定预处理器**：用于在绑定处理器运行之前修改绑定字符串'
- en: '**Node Preprocessors**: This is used to modify the DOM before the binding starts'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点预处理器**：用于在绑定开始之前修改DOM'
- en: '**Binding Providers**: This is used to control what bindings are applied to
    each DOM node'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定提供者**：用于控制应用于每个DOM节点的绑定'
- en: Finally, we looked at the `Knockout.Punches` plugin to see some real-world Knockout
    extensions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了`Knockout.Punches`插件，以了解一些实际的Knockout扩展。
- en: In the next chapter, we will cover Knockout's web component features, which
    let you tie view and viewmodel together into reusable controls.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Knockout的Web组件功能，这些功能允许您将视图和ViewModel绑定在一起，形成可重用的控件。
