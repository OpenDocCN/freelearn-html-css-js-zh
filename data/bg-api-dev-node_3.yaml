- en: Building the API - Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建API - 第2部分
- en: This chapter is intended to revisit the previous implementation, this time saving
    our data in a persistent storage (database). It will also cover authentication,
    and unit testing and hosting as additional good-to-know concepts (but not essential).
    It is therefore prudent to put more emphasis on working with the DB using knex.js
    and authenticating your API with JWT.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在重新审视以前的实现，这次将我们的数据保存在持久存储（数据库）中。它还将涵盖身份验证，单元测试和托管作为额外的值得了解的概念（但不是必要的）。因此，更加注重使用knex.js处理数据库和使用JWT对API进行身份验证。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Implement database connection with Knex.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Knex.js实现数据库连接
- en: Describe commonly used Knex.js methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述常用的Knex.js方法
- en: Rewrite our previous implementation of the todo routes with Knex.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Knex.js重写我们以前的todo路由实现
- en: Implement API authentication with JWT
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JWT实现API身份验证
- en: Describe the importance of having unit tests for your API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述为API编写单元测试的重要性
- en: Implement basic testing of the API with Lab
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lab对API进行基本测试
- en: Working with the DB Using Knex.js
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Knex.js处理数据库
- en: In this section, we're going to go through the fundamental concepts of working
    with the database. We will continue with the step-by-step build-up from our previous
    todo project. You will have noticed that our last project, we were storing our
    information in computer memory, and that it disappears immediately once our server
    returns. In real-life, you will want to store this data persistently for later
    access.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与数据库一起工作的基本概念。我们将继续从以前的todo项目逐步构建。您可能已经注意到，我们上一个项目中，我们将信息存储在计算机内存中，并且一旦服务器返回，它就会立即消失。在现实生活中，您将希望将这些数据持久存储以供以后访问。
- en: So, what is Knex.js? It is a SQL query-builder for relational databases like
    PostgreSQL, Microsoft SQL Server, MySQL, MariaDB, SQLite3, and Oracle. Basically,
    with something like Knex, you can write one code that will easily work with any
    of the mentioned databases, with no extra effort, just switching the configurations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是Knex.js？它是用于关系数据库的SQL查询构建器，如PostgreSQL，Microsoft SQL Server，MySQL，MariaDB，SQLite3和Oracle。基本上，使用类似Knex的东西，您可以编写一段代码，可以轻松地与提到的任何数据库中的任何一个工作，而不需要额外的努力，只需切换配置。
- en: Let's walk through the exercise as we explain the concepts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在解释概念的同时进行练习。
- en: 'Exercise 12: Setting up the Database'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习12：设置数据库
- en: 'Let''s go back to where we left off in the *Exercise 11: Validating a Request* of [Chapter
    2](part0038.html#147LC0-12af9adc04d045258c0a537819d419dc), *Building the API –
    Part 1*. In this example, we will be using MySQL as our database of choice. Make
    sure your machine is set up with MySQL and MySQL Workbench:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们在[第2章](part0038.html#147LC0-12af9adc04d045258c0a537819d419dc)的*练习11：验证请求*中停下的地方。在这个例子中，我们将使用MySQL作为我们的首选数据库。确保您的计算机已设置为使用MySQL和MySQL
    Workbench：
- en: Use the `Code/Lesson-3/exercise-a` folder for your reference.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Code/Lesson-3/exercise-a`文件夹作为参考。
- en: 'Open MySQL Workbench. Click on the + button to create a connection:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开MySQL Workbench。点击+按钮创建一个连接：
- en: '![](img/00023.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: 'Add the connection name as `packt`, username as `root`, and the password (if
    any). Click on Test Connection to see if the connection is correct, then click
    on OK:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将连接名称添加为`packt`，用户名添加为`root`，密码（如果有）。点击“测试连接”以查看连接是否正确，然后点击“确定”：
- en: '![](img/00024.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: Click on OK to create the connection.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确定以创建连接。
- en: 'Now, click on the connection, packt:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击连接，packt：
- en: '![](img/00025.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: 'Create the todo database by running the following query, and click on the Execute
    icon:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下查询来创建todo数据库，并点击执行图标：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/00026.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: 'The chapter files come with a basic SQL schema for our todo example project,
    almost similar to what we were using with the basic JavaScript array in the previous
    exercises:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章的文件包含了我们的todo示例项目的基本SQL模式，几乎与我们在以前的练习中使用的基本JavaScript数组类似：
- en: In the `Code/Lesson-3` folder, there is a file called `raw-sql.sql`. Open the
    file with your code editor and copy the contents of the file.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Code/Lesson-3`文件夹中，有一个名为`raw-sql.sql`的文件。用您的代码编辑器打开文件并复制文件的内容。
- en: Then, go back to the MySQL Workbench.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，回到MySQL Workbench。
- en: 'Paste what you copied from the file in the textbox and click on the Execute
    icon:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您从文件中复制的内容粘贴到文本框中，然后点击执行图标：
- en: '![](img/00027.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: 'You should see the list of the created tables (`todo`, `todo_item`, `user`)
    as below, when you click on the Refresh icon to the right of the SCHEMAS label,
    and click on Tables:'
  id: totrans-31
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击SCHEMAS标签右侧的刷新图标并点击表时，您应该会看到创建的表（`todo`，`todo_item`，`user`）的列表如下：
- en: '![](img/00028.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.jpeg)'
- en: 'Exercise 13: Connecting to the Database'
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习13：连接到数据库
- en: 'Now that we have created out database, in this exercise we are going to connect
    our application to our database using the necessary npm packages, that is, `knex`
    and `mysql`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了数据库，在这个练习中，我们将使用必要的npm包（即`knex`和`mysql`）将我们的应用程序连接到我们的数据库：
- en: 'On the Terminal, change directory to the root of our project, and run the following
    command:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上，切换到我们项目的根目录，并运行以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s create a file `db.js` and add the following code to it, replacing the
    user and password appropriately if need be:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`db.js`的文件，并添加以下代码，根据需要适当替换用户和密码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can find the complete code from the `db.js` file at `Code/Lesson-3/exercise-a`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-a`中找到`db.js`文件的完整代码。
- en: 'Let''s test that we have our configurations right. We will create a `test-db.js`
    file:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试一下我们的配置是否正确。我们将创建一个`test-db.js`文件：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s go to the Terminal and run the test file:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转到终端并运行测试文件：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should get the following printed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下打印：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Exercise 14: Creating a Record'
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习14：创建记录
- en: 'In this exercise, we''re going to write code for saving a todo and its *items*.
    To start off, let''s create a dummy user since we will hardcode the user ID for
    our code. Later, in *Exercise 19: Securing All the Routes*, we will have the ID
    picked from the authentication details:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写代码来保存todo及其*项目*。首先，让我们创建一个虚拟用户，因为我们将在代码中硬编码用户ID。稍后，在*练习19：保护所有路由*中，我们将从身份验证详细信息中选择ID：
- en: Go back to MySQL Workbench.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '返回MySQL Workbench。 '
- en: 'Clear the previous query and paste the following query, and click on the Execute
    icon:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除先前的查询并粘贴以下查询，并单击执行图标：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you click on the user table, you should see the following; our newly created
    user has an ID of `1`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击用户表时，您应该看到以下内容；我们新创建的用户的ID为`1`：
- en: '![](img/00029.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: 'Now, let''s go to our routes file, `/routes/todo.js` and modify the code, for
    the `POST: /todo` route; change the code to be as follows (it''s only the `handler`
    that is changing, notice the change to `async` function):'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，让我们转到我们的路由文件，`/routes/todo.js`，并修改代码，对于`POST: /todo`路由；将代码更改为如下（只有`handler`正在更改，注意更改为`async`函数）：'
- en: 'Let''s start by requiring our Knex instance that is in `./db.js`. Just after
    the line requiring Joi, add this:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`./db.js`中要求我们的Knex实例开始。在要求Joi的行后面，添加这个：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice the two dots, `../db.js`, since `db.js` is found in the parent folder.
    Recall our topic on requiring local modules in [Chapter 1](part0019.html#I3QM0-12af9adc04d045258c0a537819d419dc),
    *Introduction to Node.js*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个点，`../db.js`，因为`db.js`在父文件夹中。回想一下我们在[第1章](part0019.html#I3QM0-12af9adc04d045258c0a537819d419dc)中关于在Node.js中要求本地模块的主题，*Node.js简介*。
- en: 'Now, let''s modify our handler for the `POST: /todo` route. Here, were are
    using the `Knex.insert` method, and adding an optional `.returning` method so
    that we get back the ID of `todo` we have added:'
  id: totrans-57
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，让我们修改`POST: /todo`路由的处理程序。在这里，我们使用`Knex.insert`方法，并添加一个可选的`.returning`方法，以便我们得到添加的`todo`的ID：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can find the complete code from the `todo.js file` at `Code/Lesson-3/exercise-a/routes`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-a/routes`的`todo.js文件`中找到完整的代码。
- en: 'Unlike our previous exercises in [Chapter 2](part0038.html#147LC0-12af9adc04d045258c0a537819d419dc),
    *Building the API – Part 1*, we will split our `POST: /todo` route into two, `POST:
    /todo`, for adding a todo list, and `POST: /todo/<id>/item` for adding items to
    the list.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '与我们在[第2章](part0038.html#147LC0-12af9adc04d045258c0a537819d419dc)中的先前练习不同，*构建API
    - 第1部分*，我们将把`POST: /todo`路由拆分为两个，`POST: /todo`，用于添加todo列表，以及`POST: /todo/<id>/item`，用于向列表添加项目。'
- en: 'Now, let''s test our newly created endpoint. If you had stopped your server,
    go back to the Terminal and start it again, with `nodemon`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们新创建的端点。如果您已经停止了服务器，请返回终端并使用`nodemon`再次启动它：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Go to Insomnia and make the post request; you should get something like this
    (notice the `todo_id` returned, since we will use it in our next example):'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Insomnia并进行post请求；您应该会得到类似这样的东西（注意返回的`todo_id`，因为我们将在下一个示例中使用它）：
- en: '![](img/00030.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: 'Now, let''s add a route for adding todo items, `POST: /todo/<id>/item`; therefore,
    next to the previous `route` object, add this `route` object:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，让我们添加一个用于添加todo项目的路由，`POST: /todo/<id>/item`；因此，在上一个`route`对象旁边，添加这个`route`对象：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can find the complete code from the `todo.js` file at `Code/Lesson-3/exercise-a/routes`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-a/routes`的`todo.js`文件中找到完整的代码。
- en: 'Now, let''s test the route, `/todo/1/item`, `1` being the ID of `todo` we created
    in step 6:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试路由，`/todo/1/item`，`1`是我们在步骤6中创建的`todo`的ID：
- en: '![](img/00031.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: 'Exercise 15: Reading from the Database'
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习15：从数据库中读取
- en: 'In this exercise, we''re going to write the routes for:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写以下路由：
- en: Listing all `todo` for a particular user
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出特定用户的所有`todo`
- en: Getting details for a single todo item
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取单个todo项目的详细信息
- en: Listing items for a particular todo
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出特定todo的项目
- en: 'We will use a number `Knex` methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些`Knex`方法：
- en: '`Knex(''<table_name>'')`, this is equivalent to ''`SELECT * FROM <table_name>`'''
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Knex(''<table_name>'')`，这相当于''`SELECT * FROM <table_name>`'''
- en: '`.where()`, used for adding the where clause to the query'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.where()`，用于向查询添加where子句'
- en: 'To get a list of all todo, we will modify our previous `GET: /todo` route.
    Here, you only want to list todo items for a particular authenticated user. For
    now, we will be using our hardcoded test user:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要获取所有todo的列表，我们将修改之前的`GET: /todo`路由。在这里，您只想列出特定认证用户的todo项目。现在，我们将使用我们硬编码的测试用户：'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s modify the route for getting a single `todo` item, `GET: /todo/<id>`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们修改获取单个`todo`项目的路由，`GET: /todo/<id>`：'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can find the complete code from the `todo.js` file at `Code/Lesson-3/exercise-a/routes`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-a/routes`的`todo.js`文件中找到完整的代码。
- en: 'We are using array destructuring here too, since the result, if any, will be
    an array of length 1, so we''re getting the first and only element from the array
    with: `const [ todo ] = ...`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里也使用了数组解构，因为结果（如果有）将是长度为1的数组，所以我们从数组中获取第一个且唯一的元素：`const [ todo ] = ...`
- en: 'Now, let''s add the route object for getting a list of items for a particular
    `todo`, preferably just after the route for adding a `todo` item that we did in
    *Exercise 14: Creating a Record*:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加用于获取特定`todo`的项目列表的路由对象，最好是在我们在*练习14：创建记录*中添加`todo`项目的路由之后：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s test the route:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试路由：
- en: '![](img/00032.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: 'Exercise 16: Updating a Record'
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习16：更新记录
- en: 'In this exercise, we''re going to write routes for updating a todo title or
    a todo item, and here we will introduce a new Knex method, `.update()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写用于更新todo标题或todo项目的路由，这里我们将介绍一个新的Knex方法`.update()`：
- en: 'Let''s start by modifying our previous `PATCH: /todo/<id>` route. We have also
    added an extra validation to make sure that `title` is supplied as `payload`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们从修改之前的`PATCH: /todo/<id>`路由开始。我们还添加了额外的验证，以确保`title`作为`payload`提供：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s test the route:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试路由：
- en: '![](img/00033.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: 'Now, let''s add another `PATCH` route for `/todo/<id>/item`, this will help
    in editing a `todo` item''s text and also marking a `todo` item as done or not
    done:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为`/todo/<id>/item`添加另一个`PATCH`路由，这将有助于编辑`todo`项目的文本，并标记`todo`项目是否完成：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can find the complete code from the `todo.js` file at `Code/Lesson-3/exercise-a/routes`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-a/routes`的`todo.js`文件中找到完整的代码。
- en: 'This route can take each of the payload items one at a time (which will be
    the most practical case, when using, for example, a web or mobile UI), or all
    at once:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个路由可以一次接受每个负载项（当使用例如Web或移动UI时，这将是最实际的情况），或者一次接受所有负载项：
- en: 'For instance, changing the item from `Nairobi` to `Nigeria`, or:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，将项目从`内罗毕`更改为`尼日利亚`，或者：
- en: '![](img/00034.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: 'Marking the item as `done`:'
  id: totrans-100
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记项目为`done`：
- en: '![](img/00035.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: 'When we list the items again through the `GET: /todo/<id>/item` route, you
    will see the updated item:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们通过`GET：/todo/<id>/item`路由再次列出项目时，您将看到更新后的项目：
- en: '![](img/00036.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: 'Exercise 17: Deleting a Record'
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习17：删除记录
- en: 'In this exercise, we will be introducing the last vital Knex method to complete
    our **Create**, **Read**, **Update**, **Delete** (**CRUD**) journey, `.delete()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍最后一个重要的Knex方法，以完成我们的**创建**，**读取**，**更新**，**删除**（CRUD）之旅，`.delete()`：
- en: 'Let''s add a route for deleting a `todo` item:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个用于删除`todo`项目的路由：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s add one more item on our previous `todo` (of ID `1`), then delete
    it:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在之前的`todo`（ID为`1`）上添加一个项目，然后将其删除：
- en: 'Add item:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加项目：
- en: '![](img/00037.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: 'Now that we have its ID (`2`, in this case), delete it:'
  id: totrans-111
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了它的ID（在这种情况下是`2`），删除它：
- en: '![](img/00038.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: Exercise 18: Cleaning up the Code
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习18：清理代码
- en: 'Now that we have almost updated all our routes that we had from [Chapter 2](part0038.html#147LC0-12af9adc04d045258c0a537819d419dc)*,*
    *Building the API – Part 1*, let''s now remove all the code that is no longer
    needed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎更新了从[第2章](part0038.html#147LC0-12af9adc04d045258c0a537819d419dc)*,* *构建API
    - 第1部分*中获得的所有路由，现在让我们删除所有不再需要的代码：
- en: 'Remove the previously hardcoded list of todos:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除先前硬编码的todo列表：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Remove the `PUT: /todo/<id>` route object:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`PUT：/todo/<id>`路由对象：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Reimplement the `DELETE: /todo/<id>` route object, very similar to *Exercise
    17: Deleting a Record*; the difference is just the route:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新实现`DELETE：/todo/<id>`路由对象，与*练习17：删除记录*非常相似；区别只是路由：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since our SQL query had this line that adds a constraint which is possible
    when a `todo` is deleted, all the items for that `todo` are also deleted:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的SQL查询有这样一行，它添加了一个约束，当删除一个`todo`时可能发生，所有属于该`todo`的项目也会被删除：
- en: '`CREATE TABLE todo_item(`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE todo_item(`'
- en: '`  ''id'' INT PRIMARY KEY AUTO_INCREMENT,`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`  ''id'' INT PRIMARY KEY AUTO_INCREMENT,`'
- en: '`  ''text'' VARCHAR(50),`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`  ''text'' VARCHAR(50),`'
- en: '`  ''done'' BOOLEAN,`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`  ''done'' BOOLEAN,`'
- en: '`  ''date_created'' TIMESTAMP DEFAULT CURRENT_TIMESTAMP,`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`  ''date_created'' TIMESTAMP DEFAULT CURRENT_TIMESTAMP,`'
- en: '`  ''todo_id'' INT,`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`  ''todo_id'' INT,`'
- en: '`  FOREIGN KEY (`todo_id`) REFERENCES `todo` (`id`) ON DELETE CASCADE`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`  FOREIGN KEY (`todo_id`) REFERENCES `todo` (`id`) ON DELETE CASCADE`'
- en: '`);`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`）;`'
- en: Authenticating Your API with JWT
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JWT对API进行身份验证
- en: So far, we have been using our API without any authentication. This means that
    if this API is hosted at a public place, anyone can access any of the routes,
    including deleting all our records! Any proper API needs authentication (and authorization).
    Basically, we need to know who is doing what, and if they are authorized (allowed)
    to do that.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用我们的API而没有任何身份验证。这意味着如果这个API托管在公共场所，任何人都可以访问任何路由，包括删除我们所有的记录！任何合适的API都需要身份验证（和授权）。基本上，我们需要知道谁在做什么，以及他们是否被授权（允许）这样做。
- en: '**JSON Web Tokens** (**JWT**) is an open, industry standard method for representing
    claims securely between two parties. Claims are any bits of data that you want
    someone else to be able to read and/or verify but not alter.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Web Tokens**（**JWT**）是一种开放的、行业标准的方法，用于在两个参与方之间安全地表示声明。声明是您希望其他人能够读取和/或验证但不能更改的任何数据位。'
- en: To identify/authenticate users for our API, the user puts a standard-based token
    in the header (with the Authorization key) of the request (prefixing it with the
    word *Bearer*). We will see this practically in a short while.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别/验证用户的API，用户在请求的标头中放置一个基于标准的令牌（使用Authorization键），（在单词*Bearer*之前加上）。我们将很快在实践中看到这一点。
- en: 'Exercise 19: Securing All the Routes'
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习19：保护所有路由
- en: 'In this exercise, we''re going to secure all the `/todo/*` routes that we created
    so that no unauthenticated user can access them. In the *Exercise 21: Implementing
    Authorization*, we will differentiate between an *unauthenticated* and an *unauthorized*
    user:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将保护我们创建的所有`/todo/*`路由，以便没有经过身份验证的用户可以访问它们。在*练习21：实施授权*中，我们将区分*未经身份验证*和*未经授权*的用户：
- en: 'We will first start by installing a Hapi.js plugin for JWT, `hapi-auth-jwt`.
    Go to the Terminal and run:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先安装一个用于JWT的Hapi.js插件，`hapi-auth-jwt`。转到终端并运行：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Use the `Code/Lesson-3/exercise-b` for your reference.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Code/Lesson-3/exercise-b`作为您的参考。
- en: 'We will modify the routes array that we get from `./routes/todo.js` in the
    `server.js` file:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改从`./routes/todo.js`中获取的路由数组，在`server.js`文件中：
- en: 'First, begin by requiring the installed `hapi-auth-jwt` at the top of the file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从文件顶部要求安装的`hapi-auth-jwt`：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, replace the old line, `server.route`(`routes.todo`), with this:'
  id: totrans-142
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用这个替换旧的一行，`server.route`(`routes.todo`)：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can find the complete code from the `server.js` file at `Code/Lesson-3/exercise-b`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-b`的`server.js`文件中找到完整的代码。
- en: 'Now, try accessing any of the routes, for example, `GET: /todo`; you should
    get this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试访问任何路由，例如`GET：/todo`；你应该会得到这个：
- en: '![](img/00039.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: Exercise 20: Adding User Authentication
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习20：添加用户身份验证
- en: 'Now that we have secured all our todo routes, we need a way to issue tokens
    to valid users to access the API. We will have the users send their email and
    password to a route (`/auth`), and our API will issue back an authentication token
    which will be used for each request:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经保护了所有的待办事项路由，我们需要一种方法来为有效的用户发放令牌以访问API。用户将他们的电子邮件和密码发送到一个路由(`/auth`)，我们的API将返回一个用于每个请求的认证令牌：
- en: In the `/routes` folder, create a file `auth.js`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/routes`文件夹中，创建一个名为`auth.js`的文件。
- en: 'We will now need two more packages for this, `jsonwebtoken` for signing the
    authentication token, and `md5` for comparing the password since if you recall,
    we were using MySQL''s `md5` function to store the user''s password:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要另外两个包，`jsonwebtoken`用于签署认证令牌，`md5`用于比较密码，因为你可能还记得，我们之前使用了MySQL的`md5`函数来存储用户的密码：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `auth.js` file, have the following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`auth.js`文件中，添加以下代码：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can find the complete code from the `auth.js` file at `Code/Lesson-3/exercise-b/routes`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-b/routes`文件夹中找到`auth.js`文件的完整代码。
- en: 'Now, let''s register our `auth.js` route with the server. In `server.js`, after
    `routes.todo = ...`, add the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在服务器上注册我们的`auth.js`路由。在`server.js`中，在`routes.todo = ...`之后，添加以下代码：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the line initializing the server, we can add the `route` registration:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化服务器的行之后，我们可以添加`route`注册：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s try out our route, `POST: /auth`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，让我们尝试我们的路由，`POST: /auth`：'
- en: 'First, with the incorrect email/password combination:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用不正确的邮箱/密码组合：
- en: '![](img/00040.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: 'Then, with the correct password, remember *Exercise 14: Creating a Record*,
    *step 2* where we created the test user with the password:'
  id: totrans-162
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用正确的密码，记住*练习14：创建记录*，*步骤2*，我们创建了测试用户和密码：
- en: '![](img/00041.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: 'Now, we can copy the generated token and use it for our subsequent requests,
    for example, `GET: /todo`, by adding an Authorization header. Thus remember, we
    start with the word `Bearer`, then space, then paste the token; that''s the JWT
    convention:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们可以复制生成的令牌，并在以后的请求中使用，例如通过添加一个授权头来进行`GET: /todo`请求。因此，请记住，我们从单词`Bearer`开始，然后是一个空格，然后粘贴令牌；这是JWT的约定：'
- en: '![](img/00042.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: 'And we can now access the route without getting the unauthorized responses,
    like in *step 6* of 20th exercise:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以访问路由而不会收到未经授权的响应，就像在第20个练习的*步骤6*中一样：
- en: '![](img/00043.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: 'Now, let''s go back to the places in our `./routes/todo.js` file where we were
    hardcoding the users, and now get them from the authentication object, that is:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到`./routes/todo.js`文件中我们之前硬编码用户的地方，并从认证对象中获取它们，即：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Recall in the preceding *step 3*, when we were signing our token, we provided
    the user details, that is, `name`, `email`, and `id`. This is where we get the
    `.id` in `request.auth.credentials.id`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下之前的*步骤3*，当我们签署我们的令牌时，我们提供了用户的详细信息，即`name`，`email`和`id`。这就是我们在`request.auth.credentials.id`中得到`.id`的地方：
- en: '`jwt.sign(`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`jwt.sign(`'
- en: '`{`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`  name: user.name,`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`  name: user.name,`'
- en: '`  email: user.email,`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`  邮箱：user.email，`'
- en: '`  id: user.id,`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`  id: user.id,`'
- en: '`},`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`},`'
- en: '`...`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`...`'
- en: '`);`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`）;`'
- en: 'Now, let''s go back to our phpMyAdmin web interface and create another user,
    just like we did in *Exercise 14: Creating a Record*, *step 2*, and paste the
    following SQL in the SQL text area:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的phpMyAdmin网络界面，并创建另一个用户，就像我们在*练习14：创建记录*，*步骤2*中所做的一样，并将以下SQL粘贴到SQL文本区域中：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s go and do another `POST: /auth` request with the new user and obtain
    the token:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，让我们去做另一个`POST: /auth`请求，使用新用户并获取令牌：'
- en: '![](img/00044.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: 'Let''s use this new token to create another todo list by doing a `POST: /todo`
    request:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们使用这个新令牌通过`POST: /todo`请求创建另一个待办事项清单：'
- en: 'On Insomnia, go to the Header section, delete the previous Authorization header
    and replace it with the new one:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Insomnia中，转到头部部分，删除先前的授权头，并用新的替换它：
- en: '![](img/00045.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: 'Now, let''s make our request:'
  id: totrans-186
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们发出我们的请求：
- en: '![](img/00046.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: 'Let''s see the new list of todos, by doing `GET: /todo`:'
  id: totrans-188
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过`GET: /todo`请求，让我们看看新的待办事项清单：'
- en: '![](img/00047.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: 'As you can see, the newly created user can only see what they have created.
    We have done a good job so far, as far as authorization is concerned. However,
    let''s try and check the items for todo ID `1`, which belonged to the first user:'
  id: totrans-190
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，新创建的用户只能看到他们创建的内容。就授权而言，我们到目前为止做得很好。然而，让我们尝试并检查属于第一个用户的待办事项ID`1`的内容：
- en: '![](img/00048.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.jpeg)'
- en: Oops! We can see someone else's todo list items; this is a security flaw. This
    leads us to the final part of this topic, **authorization**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！我们可以看到别人的待办事项清单；这是一个安全漏洞。这将引导我们进入这个主题的最后一部分，**授权**。
- en: Authentication versus Authorization
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证与授权
- en: Through authentication, we get to know who is accessing our API; through authorization,
    we get to tell who can access what, within our API.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过认证，我们知道谁在访问我们的API；通过授权，我们可以告诉谁可以在我们的API中访问什么。
- en: 'Exercise 21: Implementing Authorization'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习21：实施授权
- en: 'In this exercise, we are going to refine our API to make sure that users are
    only authorized to access their todos and todo items:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将完善我们的API，以确保用户只有授权才能访问他们的待办事项和待办事项内容：
- en: 'Let''s first fix the flaw that we came across in *Exercise 20: Adding User
    Authentication*, *step 12*. So, we will modify the `GET: /todo/<id>` item route
    object in `/routes/todo.js`, by first checking if the todo belongs to the user
    before they can access its items:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，让我们修复我们在*练习20：添加用户认证*，*步骤12*中遇到的漏洞。因此，我们将修改`/routes/todo.js`中的`GET: /todo/<id>`路由对象，首先检查用户是否拥有该待办事项，然后才能访问其内容：'
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can find the complete code from the `todo.js` file at `Code/Lesson-3/exercise-b/routes`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-b/routes`文件夹中找到`todo.js`文件的完整代码。
- en: 'Now, when we go back to access `GET: /todo/1/item`, we get the right error
    message:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，当我们再次访问`GET: /todo/1/item`时，我们会得到正确的错误消息：'
- en: '![](img/00049.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.jpeg)'
- en: 'You can add extra authorization logic for the following routes:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以为以下路由添加额外的授权逻辑：
- en: '`POST`: `/todo/<id>/item`, to make sure that a user cannot add items to a todo
    that does not belong to them.'
  id: totrans-203
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：`/todo/<id>/item`，确保用户不能向不属于他们的待办事项添加项目。'
- en: '`PATCH`: `/todo/<id>`, that a user cannot patch a todo that does not belong
    to them.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：`/todo/<id>`，用户不能对不属于他们的待办事项进行修补。'
- en: '`PATCH`: `/todo/<todoId>/item/<id>`, that a user cannot patch a todo item that
    does not belong to them.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：`/todo/<todoId>/item/<id>`，用户不能对不属于他们的待办事项进行修补。'
- en: '`DELETE`: `/todo/<id>`, that a user cannot delete a todo that does not belong
    to them.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：`/todo/<id>`，用户不能删除不属于他们的待办事项。'
- en: '`DELETE`: `/todo/<todoId>/item/<id>`, that a user cannot patch a todo item
    that does not belong to them.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：`/todo/<todoId>/item/<id>`，用户不能对不属于他们的待办事项进行修补。'
- en: '**Cross-Origin Resource Sharing** (**CORS**) is a mechanism that uses additional
    HTTP headers to let a user agent (browser) gain permission to access selected
    resources from a server on a different origin (domain) than the site currently
    in use. For instance, when you are hosting a web application frontend on another
    domain, because of browser restriction, you will not be able to access the API.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域资源共享（CORS）是一种机制，它使用额外的HTTP头来让用户代理（浏览器）获得许可，以访问来自不同源（域）的服务器上选择的资源，而不是当前使用的站点。例如，当您在另一个域上托管Web应用程序前端时，由于浏览器限制，您将无法访问API。
- en: 'We therefore need to explicitly state that our API will allow cross-origin
    requests. We will modify the `server.js` file, at the place we were initializing
    the server connection, to enable CORS:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要明确声明我们的API将允许跨域请求。我们将修改`server.js`文件，在我们初始化服务器连接的地方，以启用CORS：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing Your API with Lab
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lab测试您的API
- en: In this section, we will have a brief look at writing unit tests for Hapi.js
    APIs. Testing is a huge topic that perhaps requires a whole course on its own,
    but in this section, we will be introducing the essential parts to get you up
    and running.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍为Hapi.js API编写单元测试。测试是一个庞大的主题，可能需要一个完整的课程来讲解，但在本节中，我们将介绍一些基本部分，让您能够开始运行。
- en: 'Let''s first underscore the importance of writing unit tests for your API:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先强调为您的API编写单元测试的重要性：
- en: '**Maintainability**: This is what I consider as the most important value of
    adding tests to your software. When you have tests, you can be confident to come
    back months later and, modify your code without worrying whether you broke anything
    by your update.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：这是我认为为软件添加测试最重要的价值。当您有了测试，您可以放心地在几个月后回来修改您的代码，而不必担心您的更新是否会破坏任何东西。'
- en: 'Requirement specifications: Tests make sure that your code meets the requirements.
    For our example, we started off by implementing the requirements since we wanted
    to pass across some basic concepts. But in practice, it is way better to start
    off with the tests before implementing your routes.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求规格：测试确保您的代码满足要求。对于我们的例子，我们开始时实现了要求，因为我们想传达一些基本概念。但实际上，最好是在实现路由之前先从测试开始。
- en: '**Automated testing**: You realized that in our previous examples, we kept
    checking our API client (Insomnia) to see if our API was working correctly; this
    can be a little cumbersome. With tests, you don''t have to worry about this once
    you have written correct tests.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化测试**：您意识到在我们之前的例子中，我们一直在检查我们的API客户端（Insomnia）以查看我们的API是否正常工作；这可能有点麻烦。有了测试，一旦您编写了正确的测试，您就不必担心这个问题。'
- en: Hapi.js conventionally uses **Lab** ([https://github.com/hapijs/lab](https://github.com/hapijs/lab))
    as its testing framework. We're going to write a few tests for our API in the
    next exercise.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Hapi.js通常使用Lab（https://github.com/hapijs/lab）作为其测试框架。我们将在下一个练习中为我们的API编写一些测试。
- en: 'Exercise 22: Writing Basic Tests with Lab'
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习22：使用Lab编写基本测试
- en: 'In this exercise, we will introduce the concept of writing unit tests for the
    Hapi.js web API, mainly using the third-party `lab` module and the built-in `assert`
    module. Ideally, we should have a separate database for our tests, but for the
    sake of simplicity here, we will share our development database for tests too:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍为Hapi.js web API编写单元测试的概念，主要使用第三方`lab`模块和内置的`assert`模块。理想情况下，我们应该为我们的测试有一个单独的数据库，但为了简单起见，我们也将分享我们的开发数据库用于测试：
- en: 'Let''s first start by installing the necessary packages. Notice that we are
    using `--save-dev` since tests are not needed for production, therefore, they
    are *development dependencies*:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先安装必要的软件包。请注意，我们使用`--save-dev`，因为测试不需要用于生产，因此它们是*开发依赖项*：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Use the `Code/Lesson-3/exercise-c` for your reference.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Code/Lesson-3/exercise-c`作为参考。
- en: Create a `test` folder at the root of the project—that is where we will have
    our tests. Since our API is a simple one, we will only have one file with all
    our tests.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下创建一个`test`文件夹，那里将有我们的测试。由于我们的API很简单，我们只会有一个文件包含所有的测试。
- en: In `test`, create a file `test-todo.js`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test`中，创建一个名为`test-todo.js`的文件。
- en: 'As a set up, `test/test-todo.js` requires the necessary modules that we need
    for our test:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为设置，`test/test-todo.js`需要我们测试所需的模块：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the first line, we are requiring assert, which is an inbuilt module if you
    recall from [Chapter 1](part0019.html#I3QM0-12af9adc04d045258c0a537819d419dc),
    *Introduction to Node.js*. Alternatively, you can use any other assertion libraries
    such as `chai` ([https://github.com/chaijs/chai](https://github.com/chaijs/chai)),
    `should.js` ([https://github.com/tj/should.js](https://github.com/tj/should.js)),
    and others.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们要求assert，如果您回忆起[第1章](part0019.html#I3QM0-12af9adc04d045258c0a537819d419dc)中的介绍，这是一个内置模块。或者，您也可以使用其他断言库，如`chai`（https://github.com/chaijs/chai）、`should.js`（https://github.com/tj/should.js）等。
- en: Lab test files must require the `lab` module and export a test script, as seen
    on line 4 prior. We will be getting the rest of the items from lab in the following
    line; we're going to see them in action shortly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Lab测试文件必须要求`lab`模块并导出一个测试脚本，如前面的第4行所示。我们将在接下来的行中获取lab的其余部分；我们很快就会看到它们发挥作用。
- en: 'Since we are requiring the server in line 6 of our `test-todo.js` file, we
    need to go back to our `server.js` file and export the `server` object, on the
    last line:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在`test-todo.js`文件的第6行中需要服务器，因此我们需要返回到我们的`server.js`文件，并在最后一行导出`server`对象。
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For the DB configuration, let''s modify our `db.js` file to include configurations
    for the test environment, pointing to the development configurations. Add this
    line right after the `configs` definition:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于DB配置，让我们修改我们的`db.js`文件，包括指向开发配置的测试环境配置。在`configs`定义之后添加这一行：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s modify the server connection setup code so that the port for our testing
    server is set from the environment variables when running the tests. This allows
    us to have the test server run on a different port, while our development server
    is running:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改服务器连接设置代码，以便在运行测试时从环境变量设置测试服务器的端口。这允许我们在不同端口上运行测试服务器，而我们的开发服务器正在运行：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are a number of methods that we will use from the `lab` module; we will
    need to use object destructuring to get them. Add the following line in our `test-todo.js`
    file:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`lab`模块中的一些方法；我们需要使用对象解构来获取它们。在我们的`test-todo.js`文件中添加以下行：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s start by writing a simple test that makes sure that the `GET: / request`
    goes through, and returns `{ message: ''hello, world'' }` as defined:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们从编写一个简单的测试开始，确保`GET: / request`被执行，并返回`{ message: ''hello, world'' }`。'
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can find the complete code from the `test-todo.js` file at `Code/Lesson-3/exercise-c/test`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-c/test`的`test-todo.js`文件中找到完整的代码。
- en: We now see `experiment`, `test`, and `assert.equal` methods in action. `experiment`
    is basically a way of grouping together the tests, and the actual tests are written
    within the `test` method's callback function (known as *test cases)*. `assert.equal`
    here is just comparing the two values to make sure they are equal, and if not,
    an *assertion error* will be thrown.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到`experiment`、`test`和`assert.equal`方法在起作用。`experiment`基本上是将测试组合在一起的一种方式，实际测试是在`test`方法的回调函数（称为*测试用例*）中编写的。这里的`assert.equal`只是比较两个值，以确保它们相等，如果不相等，将抛出*断言错误*。
- en: 'Now, let''s run our tests:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的测试：
- en: 'On the Terminal (open a new Terminal if you''re running the API on one of them),
    navigate to the root of our project and run the following command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端（如果您在其中一个终端上运行API，请打开一个新的终端），导航到我们项目的根目录并运行以下命令：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We're adding an optional `--leaks` option to turn off memory leak detection
    since we don't need it now.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在添加一个可选的`--leaks`选项来关闭内存泄漏检测，因为我们现在不需要它。
- en: At the beginning of the command, we're adding `PORT=8001`; this is a way of
    passing an environment variable to our script, which is why we changed our code
    at step 7 previously. We're now running our test server on port `8001` while our
    development server is still running on port `8000`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令的开头，我们添加了`PORT=8001`；这是一种向我们的脚本传递环境变量的方式，这就是为什么我们之前在步骤7中更改了我们的代码的原因。我们现在在端口`8001`上运行我们的测试服务器，而我们的开发服务器仍在端口`8000`上运行。
- en: 'When you run the command, you should see something close to this:'
  id: totrans-246
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行命令时，您应该看到与此类似的内容：
- en: '![](img/00050.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.jpeg)'
- en: 'We can make our test command shorter by adding it as a script on our `package.json`
    file:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将其添加到我们的`package.json`文件的脚本中来缩短我们的测试命令：
- en: 'Replace the following line of code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换以下代码行：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With the following line:'
  id: totrans-251
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, go back to the Terminal and just run:'
  id: totrans-253
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到终端，只需运行：
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, let's test that our authentication is working correctly. Add the following
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们的身份验证是否正常工作。添加以下内容
- en: 'segment after the previous one:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个段落之后的部分：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, go back and run `npm test`. Both tests should be passing:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回并运行`npm test`。两个测试都应该通过：
- en: '![](img/00051.jpeg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: 'You realize that we''re having to go back to the Terminal every other time
    to run the tests. This is just as cumbersome as testing on the API client (Insomnia);
    we need some automation:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会意识到我们不得不每隔一段时间回到终端运行测试。这与在API客户端（Insomnia）上进行测试一样麻烦；我们需要一些自动化：
- en: 'We will need gulp.js for this, and two other Gulp plugins. Let''s install them:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要gulp.js，并且还需要两个其他的Gulp插件。让我们安装它们：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s write a simple `gulpfile.js` at the root of our project to automate
    our testing task:'
  id: totrans-263
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在我们项目的根目录编写一个简单的`gulpfile.js`来自动化我们的测试任务：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can find the complete code from the `gulpfile.js` file at `Code/Lesson-3/exercise-c`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-c`的`gulpfile.js`文件中找到完整的代码。
- en: 'Now, let''s go to `package.json` and add another script option for our `gulp`
    task, next to the previous `test`:'
  id: totrans-266
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转到`package.json`并在之前的`test`旁边添加另一个`gulp`任务的脚本选项：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, go to the Terminal and instead of `npm test`, run the following:'
  id: totrans-268
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到终端，而不是`npm test`，运行以下命令：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The watch task will be fired up, and therefore, any changes made in any of
    the files within the `src` array in the preceding point, the test will automatically
    run. This mean you can go on with your development work and periodically check
    that the tests are all good:'
  id: totrans-270
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监视任务将被启动，因此，在前面一点中`src`数组中的任何文件进行的更改，测试将自动运行。这意味着您可以继续进行开发工作，并定期检查测试是否全部通过：
- en: '![](img/00052.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: 'Let''s now write a sample test for `GET: /todo` route. Remember that for all
    the authenticated routes, we need the token first, for us to make a successful
    request. We will therefore need a script to get us the token before any tests
    begin. This is where the `before` function that we got in step 8 kicks in. In
    our `test-todo.js` file, add the following segment:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，让我们为`GET: /todo`路由编写一个示例测试。请记住，对于所有经过身份验证的路由，我们需要首先获得令牌，以便我们能够成功发出请求。因此，在任何测试开始之前，我们将需要一个脚本来获取令牌。这就是我们在步骤8中得到的`before`函数发挥作用的地方。在我们的`test-todo.js`文件中，添加以下部分：'
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can find the complete code from the `test-todo.js` file at `Code/Lesson-3/exercise-c/test`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Code/Lesson-3/exercise-c/test`的`test-todo.js`文件中找到完整的代码。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored quite a lot. We started off with introducing
    Knex.js and how we can use it to connect and use the database. We went through
    the essential CRUD database methods. We then covered how we can authenticate our
    API and prevent it from unauthorized access, using the JWT mechanism. We also
    mentioned something important about CORS, how the browsers handle this and how
    we can enable this on our API. We finally finished off with covering concepts
    about testing our API, using the Lab library. We also covered, in passing, the
    concept of test automation using gulp.js.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了很多内容。我们首先介绍了Knex.js以及如何使用它来连接和使用数据库。我们了解了基本的CRUD数据库方法。然后，我们介绍了如何对我们的API进行身份验证，并防止未经授权的访问，使用JWT机制。我们还提到了关于CORS的一些重要内容，浏览器如何处理它，以及我们如何在我们的API上启用它。最后，我们涉及了关于使用Lab库测试我们的API的概念。我们还简要介绍了使用gulp.js进行测试自动化的概念。
- en: In this book, we started off with learning how to implement the necessary modules
    to get simple applications up and running. We then moved on to implementing the
    async and await functions to handle asynchronous code efficiently. After a primer
    on Node.js (the application building aspect), we graduated to building an API
    using Node.js. To do this, we initially used the built-in module and then utilized
    the rich Hapi.js framework. We also understood the advantages of the Hapi.js framework.
    Later on, we learned how to handle requests from API clients and finally, we completed
    the book by covering interactions with databases.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们首先学习了如何实现必要的模块，使简单的应用程序能够运行起来。然后，我们开始实现异步和等待函数，以高效处理异步代码。在介绍了Node.js（应用程序构建方面）之后，我们开始构建一个使用Node.js的API。为了做到这一点，我们最初使用了内置模块，然后利用了丰富的Hapi.js框架。我们也了解了Hapi.js框架的优势。之后，我们学会了如何处理来自API客户端的请求，最后，我们通过涉及与数据库的交互来完成了这本书。
- en: This is a practical quick-start guide. To further your knowledge, you should
    consider building real-time applications with Node.js. We have recommended a few
    books in the next section, but ensure you check our website to find other books
    that may interest you!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实用的快速入门指南。为了进一步提高您的知识，您应该考虑使用Node.js构建实时应用程序。我们在下一节推荐了一些书籍，但请确保您查看我们的网站，以找到其他可能对您感兴趣的书籍！
