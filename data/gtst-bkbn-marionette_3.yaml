- en: Chapter 3. Marionette View Types and Their Use
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 木偶视图类型及其用法
- en: 'In the previous chapter, we learned about components that help us provide a
    structure to our application; however, none of these components interacted with
    the DOM. This responsibility belongs to the views in Backbone development; however,
    the interaction and manipulation of the DOM can quickly become complicated inside
    our views. With the intention of having cleaner and meaningful objects to manipulate,
    the DOM Marionette introduces a powerful set of views. The following is a description
    of each one of those views provided in the official documentation at [https://github.com/marionettejs/backbone.marionette](https://github.com/marionettejs/backbone.marionette):'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了帮助我们为应用程序提供结构的组件；然而，这些组件都没有与DOM交互。这个责任属于Backbone开发中的视图；然而，在视图内部，DOM的交互和操作可能会迅速变得复杂。为了拥有更干净、更有意义的对象来操作，DOM
    Marionette引入了一套强大的视图。以下是对官方文档中提供的每个视图的描述，官方文档位于[https://github.com/marionettejs/backbone.marionette](https://github.com/marionettejs/backbone.marionette)：
- en: '`Marionette.ItemView`: This is the view that renders a single model'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette.ItemView`：这是一个渲染单个模型的视图'
- en: '`Marionette.CollectionView`: This is the view that iterates over a collection
    and renders the individual `ItemView` instances for each model'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette.CollectionView`：这是一个遍历集合并渲染每个模型的单个 `ItemView` 实例的视图'
- en: '`Marionette.CompositeView`: This is the collection view and item view for rendering
    leaf-branch/composite model hierarchies'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette.CompositeView`：这是一个用于渲染叶分支/组合模型层次结构的集合视图和项目视图'
- en: '`Marionette.Layout`: This is the view that renders a layout and creates region
    managers to manage areas within it'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette.Layout`：这是一个渲染布局并创建区域管理器来管理其内部的区域的视图'
- en: '`Marionette.View`: This is the base view type that other Marionette views extend
    from (not intended to be used directly)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Marionette.View`：这是其他Marionette视图从中扩展的基础视图类型（不打算直接使用）'
- en: In this chapter, we will learn the intention behind each one of them and how
    to start using them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解每个视图背后的意图以及如何开始使用它们。
- en: Marionette.View and Marionette.ItemView
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marionette.View 和 Marionette.ItemView
- en: The `Marionette.View` extends the `Backbone.View`, and it's important to remember
    this, because all the knowledge that we already have on creating a view will be
    useful while working with these new set of views of Marionette.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Marionette.View` 扩展了 `Backbone.View`，这一点很重要，因为我们在创建视图方面已经掌握的所有知识，在处理Marionette的新视图集时都将非常有用。'
- en: Each of them aims to provide a specific out of the box functionality so that
    you spend less time focusing on the glue code needed to make things work, and
    more time on things that are related to the needs of your application. This allows
    you to focus all your attention on the specific logic of your application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都旨在提供特定的开箱即用功能，这样你就可以花更少的时间关注使事物工作所需的粘合代码，更多的时间关注与你的应用程序需求相关的事情。这让你可以集中所有注意力在应用程序的具体逻辑上。
- en: We will start by describing the `Marionette.View` part of Marionette, as all
    of the other views extend from it; the reason we do this is because this view
    provides a very useful functionality. But it's important to notice that this view
    is not intended to be used directly. As it is the base view from which all the
    other views inherit from, it is an excellent place to contain some of the glue
    code that we just talked about.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从描述Marionette的 `Marionette.View` 部分开始，因为所有其他视图都从此扩展；我们这样做的原因是，这个视图提供了一些非常有用的功能。但重要的是要注意，这个视图并不打算直接使用。作为所有其他视图从中继承的基础视图，它是一个包含我们刚刚提到的粘合代码的绝佳位置。
- en: A good example of that functionality is the `close` method, which will be responsible
    for removing `.el` from DOM. This method will also take care of calling unbind
    to all your events, thus avoiding the problem called Zombie views. This an issue
    that you can have if you don't do this carefully in a regular Backbone view, where
    new instantiations of previously closed fire events are present. These events
    remain bound to the HTML elements used in the view. These are now present again
    in the DOM now that the view has been re-rendered, and during the recreation of
    the view, new event listeners are attached to these HTML elements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的良好示例是 `close` 方法，它将负责从 DOM 中移除 `.el`。此方法还将负责调用解绑所有事件，从而避免称为僵尸视图的问题。这是一个如果你在常规
    Backbone 视图中不小心这样做可能会遇到的问题，其中先前关闭的实例化会触发事件。这些事件现在绑定到了视图使用的 HTML 元素上。现在视图已重新渲染，在视图重新创建期间，新的事件监听器被附加到这些
    HTML 元素上。
- en: From the documentation of the `Marionette.View`, we exactly know what the `close`
    method does.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Marionette.View` 的文档中，我们确切地知道 `close` 方法的作用。
- en: It calls an `onBeforeClose` event on the view, if one is provided
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了，它会在视图中调用一个 `onBeforeClose` 事件
- en: It calls an `onClose` event on the view, if one is provided
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了，它会在视图中调用一个 `onClose` 事件
- en: It unbinds all custom view events
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解绑了所有自定义视图事件
- en: It unbinds all DOM events
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解绑了所有 DOM 事件
- en: It removes `this.el` from the DOM
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从 DOM 中移除 `this.el`
- en: It unbinds all `listenTo` events
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解绑了所有 `listenTo` 事件
- en: The link to the official documentation of the `Marionette.View` object is [https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.view.md](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.view.md).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Marionette.View` 对象的官方文档链接是 [https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.view.md](https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.view.md)。'
- en: It's important to mention that the third point, *unbind all custom view events*,
    will unbind events created using the `modelEvents` hash, those created on the
    events hash, and events created via `this.listenTo`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，第三点，*解绑所有自定义视图事件*，将解绑使用 `modelEvents` 哈希创建的事件、在事件哈希上创建的事件以及通过 `this.listenTo`
    创建的事件。
- en: As the `close` method is already provided and implemented, you don't need to
    perform the unbind and remove previously listed tasks. While most of the time
    this would be enough, at times, one of your views will need you to perform extra
    work in order to properly close it; in this case, two events will be fired at
    the same time to close a view.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `close` 方法已经提供并实现，你不需要执行之前列出的解绑和移除任务。虽然大多数情况下这已经足够，但有时你的某个视图可能需要你执行额外的工作才能正确关闭它；在这种情况下，将同时触发两个事件来关闭视图。
- en: The event `onBeforeClose`, as the name indicates, will be fired just before
    the `close` method. It will call a function of the same name, `onBeforeClose`,
    where we can add the code that needs to be executed at this point.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`onBeforeClose` 事件将在 `close` 方法之前触发。它将调用同名的函数 `onBeforeClose`，我们可以在该点添加需要执行的代码。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second event will be `onClose`, which will be fired after the `close` method
    so that the `.el` of the view won't be present anymore and all the unbind tasks
    will have been performed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个事件将是 `onClose`，它将在 `close` 方法之后触发，这样视图的 `.el` 就不再存在，并且所有解绑任务都已执行。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: One of the core ideas behind Marionette is to reduce the boilerplate code that
    you have to write when building apps with Backbone. A perfect example of which
    is the `render` method that you have to implement in every Backbone view, and
    the code there is pretty much the same in each of your views. Load the template
    with the underscore `_.template` function and then pass the model converted to
    JSON to the template.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette 背后的一个核心思想是减少你在使用 Backbone 构建应用程序时需要编写的样板代码。一个很好的例子是每个 Backbone 视图中都必须实现的
    `render` 方法，那里的代码在每一个视图中几乎都是相同的。使用 underscore 的 `_.template` 函数加载模板，然后将转换为 JSON
    的模型传递给模板。
- en: 'The following is an example of repetitive code needed to render a view in Backbone:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在 Backbone 中渲染视图所需的重复代码示例：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As Marionette defining a `render` function is no longer required, just like
    the `close` method, the preceding code will be called for you behind the scenes.
    In order to render a view, we just need to declare it with a template property
    set.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Marionette 不再需要定义 `render` 函数，就像 `close` 方法一样，前面的代码将在幕后为你调用。为了渲染一个视图，我们只需要声明它，并设置模板属性。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we just create a Backbone model, and we pass it to the `ItemView` constructor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需创建一个Backbone模型，并将其传递给`ItemView`构造函数。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And then the only thing left is to call the `render` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后剩下的唯一事情就是调用`render`函数。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to see it running, please go through this JSFiddle that illustrates
    the previous code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到它运行，请通过以下JSFiddle查看之前的代码：
- en: '[http://jsfiddle.net/rayweb_on/VS9hA/](http://jsfiddle.net/rayweb_on/VS9hA/)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://jsfiddle.net/rayweb_on/VS9hA/](http://jsfiddle.net/rayweb_on/VS9hA/)'
- en: One thing to note is that we just needed one line to specify the template, and
    Marionette did the rest by rendering our view with the specified template. Notice
    that in this example, we used the `ItemView` constructor; we should not use `Marionette.View`
    directly, as it does not have many functionalities of its own. It just serves
    as the base for other views.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只需一行代码来指定模板，Marionette就会通过使用指定的模板渲染我们的视图来完成剩余的工作。注意，在这个例子中，我们使用了`ItemView`构造函数；我们不应该直接使用`Marionette.View`，因为它本身没有很多功能。它只是作为其他视图的基础。
- en: So some of the following examples of the functionalities provided by `Marionette.View`
    will be demonstrated using `ItemView`, as this view inherits all of these functionalities
    through extension.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下将使用`ItemView`演示`Marionette.View`提供的部分功能，因为这个视图通过扩展继承了所有这些功能。
- en: As we saw in the previous example, `ItemView` works perfectly for rendering
    a single model using a template, but what about rendering a collection of models?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中看到的，`ItemView`在用模板渲染单个模型时工作得很好，但渲染模型集合怎么办？
- en: If you just need to render, for example, a list of books or categories, you
    still can use `ItemView`. To accomplish this, the template that you would assign
    to `ItemView` must know how to handle the creation of the DOM to properly display
    that list of items.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要渲染，例如，书籍或分类列表，你仍然可以使用`ItemView`。为了完成这个任务，分配给`ItemView`的模板必须知道如何处理DOM的创建，以正确显示该列表项。
- en: Let's render a list of books.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们渲染一本书籍列表。
- en: 'The Backbone model will have two properties: the book name and the book ID.
    We just want to create a list of links using the book name as the value to be
    displayed; the ID of the book will be used to create a link to see the specific
    book.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone模型将有两个属性：书籍名称和书籍ID。我们只想创建一个使用书籍名称作为显示值的链接列表；书籍的ID将用于创建查看特定书籍的链接。
- en: 'First, let''s create the book Backbone model for this example and its collection:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为这个例子创建书籍Backbone模型及其集合：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let''s instantiate the collection and add three models to it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实例化集合并向其中添加三个模型：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In our HTML, let''s create the template to be used in this view; the template
    should look like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML中，让我们创建一个用于此视图的模板；模板应如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we could render the book list using the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码片段来渲染书籍列表：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to see it in action, go to the working code in JSFiddle at [http://jsfiddle.net/rayweb_on/8QAgQ/](http://jsfiddle.net/rayweb_on/8QAgQ/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到它的实际效果，请访问JSFiddle中的工作代码，链接为[http://jsfiddle.net/rayweb_on/8QAgQ/](http://jsfiddle.net/rayweb_on/8QAgQ/)。
- en: The previous code would produce an unordered list of books with links to the
    specific book. Again, we gained the benefit of writing very little code once again,
    as we didn't need to specify the `Render` function, which could be misleading,
    because the `ItemView` is perfectly capable of rendering a model or a collection.
    Whether to use `CollectionView` or `ItemView` will depend on what we are trying
    to accomplish. If we need a set of individual views with its own functionality,
    `CollectionView` is the right choice, as we will see when we get to the point
    of reviewing it. But if we just need to render the values of a collection, `ItemView`
    would be the perfect choice.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将生成一个包含特定书籍链接的无序列表。再次强调，我们再次获得了编写少量代码的好处，因为我们不需要指定`Render`函数，这可能会产生误导，因为`ItemView`完全能够渲染模型或集合。是否使用`CollectionView`或`ItemView`将取决于我们想要实现的目标。如果我们需要一组具有自身功能的独立视图，`CollectionView`是正确的选择，正如我们在回顾它时将看到的。但如果我们只需要渲染集合的值，`ItemView`将是完美的选择。
- en: Handling events in the views
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图中处理事件
- en: 'To keep track of model events or collection events, we must write the following
    code snippet on a regular Backbone view:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪模型事件或集合事件，我们必须在常规Backbone视图中编写以下代码片段：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To start these events, we use the following handler functions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动这些事件，我们使用以下处理函数：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This still works fine in Marionette, but we can accomplish the same thing by
    declaring these events using the following configuration hash:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Marionette 中仍然有效，但我们可以通过以下配置哈希来声明这些事件，以实现相同的功能：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will give us exactly the same result, but the configuration hash is very
    convenient as we can keep adding events to our model or collection, and the code
    is cleaner and very easy to follow.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出完全相同的结果，但配置哈希非常方便，因为我们可以在我们的模型或集合中继续添加事件，代码更简洁，更容易理解。
- en: The `modelEvents` and `collectionEvents` are not the only configuration hash
    sets that we have available in each one of the Marionette views; the UI configuration
    hash is also available. It may be the case that one of the DOM elements on your
    view will be used many times to read its value, and doing this using jQuery can
    not be optimal in terms of performance. Also, we would have the jQuery reference
    in several places, repeating ourselves and making our code less DRY.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`modelEvents` 和 `collectionEvents` 不是我们在每个 Marionette 视图中可用的唯一配置哈希集；UI 配置哈希也是可用的。可能存在这样的情况，即您的视图中的一个
    DOM 元素将被多次使用以读取其值，并且使用 jQuery 来做这件事在性能方面可能不是最优的。此外，我们将在几个地方重复 jQuery 引用，这会使我们的代码更冗余。'
- en: Inside a Backbone view, we can define a set of events that will be fired once
    an action is taken in the DOM; for instance, we pass the function that we want
    to handle in this event at the click of a button.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 Backbone 视图中，我们可以定义一组事件，一旦在 DOM 中执行操作就会触发；例如，我们传递一个函数来处理按钮点击事件。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will invoke the `updateValue` function once we click on `button2`. This
    works fine, but what about calling a method that is not inside the view?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们点击 `button2` 时调用 `updateValue` 函数。这没问题，但如果我们想调用不在视图内的方法怎么办？
- en: 'To accomplish this, Marionette provides the `triggers` functionality that will
    fire events which can be listened to outside of your view. To declare a `trigger`,
    we can use the same syntax used in the `events` object as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，Marionette 提供了 `triggers` 功能，它将触发可以在视图外部监听的事件。要声明一个 `trigger`，我们可以使用与
    `events` 对象相同的语法，如下所示：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then, we can listen to that event somewhere else using the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码在别处监听该事件：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous code, we used the model to alert and display the value of the
    property, `value2`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了模型来警告并显示属性 `value2` 的值。
- en: 'The `args` parameter received by the function will contain objects that you
    can use:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接收到的 `args` 参数将包含您可以使用的对象：
- en: The view that fired the trigger
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发事件的视图
- en: The Backbone model or collection of that view
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该视图的 Backbone 模型或集合
- en: UI and templates
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI 和模板
- en: While working with a view, you will need a reference to a particular HTML element
    through jQuery in more than one place in your view. This means you will make a
    reference to a button during initialization and in few other methods of the view.
    To avoid having the jQuery selector duplicated on each of these methods, you can
    map that UI element in a hash so that the selector is preserved. If you need to
    change it, the change will be done in a single place.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当与视图一起工作时，您可能需要在视图的多个地方通过 jQuery 引用一个特定的 HTML 元素。这意味着您将在初始化和视图的几个其他方法中引用一个按钮。为了避免在每个这些方法中重复
    jQuery 选择器，您可以在哈希中映射该 UI 元素，以便保留选择器。如果您需要更改它，更改将在一个地方完成。
- en: 'To create this mapping of UI elements, we need to add the following declaration:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 UI 元素的映射，我们需要添加以下声明：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And to make use of these mapper UI elements, we just need to refer them inside
    any function by the name given in the configuration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些映射 UI 元素，我们只需在配置中给出的名称下，在任意函数中引用它们。
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There will be times when you need to pass a different template to your view.
    To do this in Marionette, we remove the template declaration and instead add a
    function called `getTemplate`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您需要向视图传递不同的模板。在 Marionette 中，我们移除模板声明，而是添加一个名为 `getTemplate` 的函数。
- en: 'The following code snippet would illustrate the use of this function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将说明该函数的使用：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, we check the existence of the property `foo`; if it's not present,
    we use a different template and that will be it. You don't need to specify the
    `render` function because it will work the same way as declaring a template variable
    as seen in one of the previous examples.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们检查属性 `foo` 的存在性；如果不存在，我们使用不同的模板，这就足够了。您不需要指定 `render` 函数，因为它将以与在先前的示例中声明模板变量相同的方式工作。
- en: If you want to learn more about all the concepts that we have discussed so far,
    please refer to the JSFiddle link [http://jsfiddle.net/rayweb_on/NaHQS/](http://jsfiddle.net/rayweb_on/NaHQS/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于我们迄今为止讨论的所有概念，请参考JSFiddle链接[http://jsfiddle.net/rayweb_on/NaHQS/](http://jsfiddle.net/rayweb_on/NaHQS/)。
- en: If you find yourself needing to make calculations involving a complicated process
    while rendering a value, you can make use of `templeteHelpers` that are functions
    contained in an object called `templateHelpers`. Let's look at an example that
    will illustrate its use better.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要在渲染值时进行涉及复杂过程的计算，你可以使用包含在名为`templateHelpers`的对象中的`templeteHelpers`函数。让我们看看一个更好的例子来展示它的使用。
- en: 'Suppose we need to show the value of a book but are offering a discount that
    we need to calculate, use the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要显示书籍的值，但提供了一个需要计算的折扣，可以使用以下代码：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see the in the previous code, we declared an object `literal` that
    will contain functions that can be called from the templates.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们声明了一个包含可以从中调用的函数的对象`literal`。
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Marionette.CollectionView
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Marionette.CollectionView
- en: Rendering a list of things like books inside one view is possible, but we want
    to be able to interact with each item. The solution for this will be to create
    a view one-by-one with the help of a loop. But Marionette solves this in a very
    elegant way by introducing the concept of `CollectionView` that will render a
    child view for each of the elements that we have in the collection we want to
    display.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个视图中渲染类似书籍的列表是可能的，但我们希望能够与每个项目进行交互。这个解决方案将是使用循环逐个创建视图。但是Marionette通过引入`CollectionView`的概念以非常优雅的方式解决了这个问题，该概念将为我们要显示的集合中的每个元素渲染一个子视图。
- en: A good example to put into practice could be to list the books by category and
    create a Collection view. This is incredible easy.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的实践例子可能是按类别列出书籍并创建一个集合视图。这非常简单。
- en: First, you need to define how each of your items should be displayed; this means
    how each item will be transformed in a view.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要定义每个项目应该如何显示；这意味着每个项目将如何在视图中转换。
- en: For our categories example, we want each item to be a list `<li>` element and
    part of our collection; the `<ul>` list will contain each category view.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的类别示例，我们希望每个项目都是一个列表`<li>`元素，并且是集合的一部分；`<ul>`列表将包含每个类别视图。
- en: 'We first declare `ItemView` as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明`ItemView`如下：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then we declare `CollectionView`, which specifies the view item to use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明`CollectionView`，它指定了要使用的视图项。
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A good thing to notice is that even when we are using Marionette views, we are
    still able to use the standard properties that Backbone views offer, such as `tagName`
    and `ClassName`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得注意的好事是，即使我们使用Marionette视图，我们仍然能够使用Backbone视图提供的标准属性，例如`tagName`和`ClassName`。
- en: Finally, we create a collection and we instantiate `CollectionView` by passing
    the collection as a parameter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个集合，并通过传递集合作为参数来实例化`CollectionView`。
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And that's it. Simple huh?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。简单吧？
- en: The advantage of using this view is that it will render a view for each item,
    and it can have a lot of functionality; we can control all those views in the
    `CollectionView` that serves as a container.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个视图的优势在于它将为每个项目渲染一个视图，并且它可以有很多功能；我们可以在作为容器的`CollectionView`中控制所有这些视图。
- en: You can see it in action at [http://jsfiddle.net/rayweb_on/7usdJ/](http://jsfiddle.net/rayweb_on/7usdJ/).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://jsfiddle.net/rayweb_on/7usdJ/](http://jsfiddle.net/rayweb_on/7usdJ/)中看到它的实际应用。
- en: Marionette.CompositeView
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Marionette.CompositeView
- en: The `Marionette.Composite` view offers the possibility of not only rendering
    a model or collection models, but also the possibility of rendering both a model
    and a collection. That's why this view fits perfectly in our BookStore website.
    We will be adding single items to the shopping cart, books in this case, and we
    will be storing these books in a collection. But we need to calculate the subtotal
    of the order, show the calculated tax, and an order total; all of these properties
    will be part of our `totals` model that we will be displaying along with the ordered
    books.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Marionette.Composite`视图不仅提供了渲染模型或集合模型的可能性，还提供了同时渲染模型和集合的可能性。这就是为什么这个视图非常适合我们的BookStore网站。我们将向购物车添加单个项目，在这种情况下是书籍，并将这些书籍存储在集合中。但是，我们需要计算订单的小计，显示计算出的税费和订单总额；所有这些属性都将是我们将要显示的`totals`模型的一部分，我们将与订购的书籍一起显示。'
- en: But there is a problem. What should we display in the order region when there
    are no items added? Well, in the `CompositeView` and the `CollectionView`, we
    can set an `emptyView` property, which will be a view to show in case there are
    no models in the collection. Once we add a model, we can then render the item
    and the `totals` model.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但存在一个问题。当没有添加项目时，我们应该在顺序区域显示什么？好吧，在 `CompositeView` 和 `CollectionView` 中，我们可以设置一个
    `emptyView` 属性，这个属性将是一个在集合中没有模型时要显示的视图。一旦我们添加了一个模型，我们就可以渲染项目以及 `totals` 模型。
- en: Perhaps at this point, you may think that you lost control over your render
    functionality, and there will be cases where you need to do things to modify your
    HTML. Well, in that scenario, you should use the `onRender()` function, which
    is a very helpful method that will allow you to manipulate the DOM just after
    your `render` method was called.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可能在这个时候，你可能认为你失去了对渲染功能的控制，并且会有一些需要你进行修改 HTML 的场景。好吧，在这种情况下，你应该使用 `onRender()`
    函数，这是一个非常有用的方法，它将允许你在 `render` 方法被调用后立即操作 DOM。
- en: Finally, we would like to set a template with some headers. These headers are
    not part of an `ItemView`, so how can we display it?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望设置一个带有一些标题的模板。这些标题不是 `ItemView` 的一部分，那么我们如何显示它？
- en: Let's have a look at part of the code snippet that explains how each part solves
    our needs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码片段的一部分，解释每个部分是如何解决我们的需求的。
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So far we defined the view and set the template; the `Itemview` and `EmptyView`
    properties will be used to render our view.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了视图并设置了模板；`Itemview` 和 `EmptyView` 属性将被用来渲染我们的视图。
- en: The `onBeforeRender` is a function that will be called, as the name indicates,
    before the `render` method; this function will allow us to calculate the totals
    that will be displayed in the `total` model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBeforeRender` 是一个函数，正如其名所示，它将在 `render` 方法之前被调用；这个函数将允许我们计算将在 `total` 模型中显示的总数。'
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `onRender` method is used here to check whether there are no models in the
    collection (that is, the user hasn't added a book to the shopping cart). If not,
    we should not display the header and footer regions of the view.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRender` 方法在这里用来检查集合中是否有模型（即用户没有将书籍添加到购物车）。如果没有，我们不应该显示视图的标题和页脚区域。'
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, Marionette does a great job offering functions that can remove
    a lot of boilerplate code and also give us full control over what is being rendered.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Marionette 提供了非常出色的函数，可以移除大量的样板代码，并让我们完全控制渲染的内容。
- en: Building the layout of our application with Marionette.Layout
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Marionette.Layout 构建我们应用程序的布局
- en: The final view that we need to review is the `Marionette.Layout` view. This
    view is the combination of `Itemview` and `Region`; we haven't reviewed the `Marionette.Region`
    component, but for now, it's enough to say that it's a component that will be
    in charge of rendering a view on its `el`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要最后审查的最终视图是 `Marionette.Layout` 视图。这个视图是 `Itemview` 和 `Region` 的组合；我们还没有审查
    `Marionette.Region` 组件，但到目前为止，只需要说它是一个负责在其 `el` 上渲染视图的组件。
- en: So the layout works as an `ItemView` because it requires a template to render
    itself. This template can be your initial HTML divided by logical regions, such
    as the navigation region that will contain a view which will display the navigation
    section of your site, the footer view that should be displayed at the footer region,
    and so on. You can start by rendering your layout and then rendering the view
    properly on each of the regions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，布局作为一个 `ItemView` 工作，因为它需要一个模板来自我渲染。这个模板可以是你的初始 HTML，通过逻辑区域划分，例如包含显示网站导航部分的导航区域，应该显示在页脚区域的页脚视图，等等。你可以先渲染布局，然后在每个区域上正确渲染视图。
- en: Let's create the `Marionette.Layout` view.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `Marionette.Layout` 视图。
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the HTML that you copied in [Chapter 2](ch02.html "Chapter 2. Our First Application"),
    *Our First Application*, you will find the corresponding `<div>` tags with the
    IDs of the regions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在你复制的 [第 2 章](ch02.html "第 2 章。我们的第一个应用程序") 的 HTML 中，你会找到对应区域的 `<div>` 标签。
- en: In this view, we specified the script/template that the view will use to render.
    This specified template was added to the initial HTML, and inside it were `<div>`
    tags that will serve as regions. Each of the regions is given a name that makes
    sense with the view that it will be displaying, and we used an object `literal`
    to define the regions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，我们指定了视图将使用的脚本/模板来渲染。这个指定的模板被添加到初始 HTML 中，并且其中包含了 `<div>` 标签，这些标签将作为区域。每个区域都有一个与将要显示的视图相匹配的名称，我们使用一个对象
    `literal` 来定义区域。
- en: The `Layout` view inherits the same functionality as for all the other views,
    so in case you want to listen to events, you can do it just like in any other
    view.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Layout` 视图继承了所有其他视图的功能，因此如果您想监听事件，可以像在其他任何视图中一样进行操作。'
- en: To render this initial layout, we just need to instantiate it and render it
    as any other view.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染这个初始布局，我们只需实例化它并将其渲染成任何其他视图。
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can still add and remove regions to your layout at runtime by calling the
    `addRegion` and `removeRegion` methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以通过调用 `addRegion` 和 `removeRegion` 方法在运行时向您的布局添加和删除区域。
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To add multiple regions, the `Layout` view provides an `addRegions` method that
    receives an object `literal` with the regions to be added.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加多个区域，`Layout` 视图提供了一个 `addRegions` 方法，该方法接收一个包含要添加的区域的对象 `literal`。
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The behavior of the `Close` function on this view will be a little different
    as it will call `close` on all of the regions. These regions will then call close
    on the views that they contain, making sure all of the views contained are closed
    properly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图上的 `Close` 函数的行为将略有不同，因为它将调用所有区域的 `close` 方法。然后，这些区域将调用它们包含的视图上的 `close`
    方法，确保所有包含的视图都正确关闭。
- en: A good way to start your application is to define a `Body` region; this region
    will then contain the application `Layout` that will contain all of the logical
    regions of the application. Maybe you need to display a sublayout in one of these
    regions, which is perfectly fine. There is no limit of nested layouts; use them
    as your application requires.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开始您应用程序的好方法是定义一个 `Body` 区域；这个区域将包含所有逻辑区域的应用程序 `Layout`。也许您需要在这些区域中的一个显示子布局，这是完全可以的。嵌套布局没有限制；根据您应用程序的需求使用它们。
- en: Extending Marionette views
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Marionette 视图
- en: A common need while working with Backbone and Marionette and in pretty much
    every language is to re-use code as much as possible. If you want all your views
    to behave in a certain way, you can achieve it by extending your Marionette views.
    In the following example, we will add a `log` method to all the item views by
    extending the `Marionette.ItemView`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Backbone 和 Marionette 以及几乎任何语言时，一个常见的需求是尽可能多地重用代码。如果您想让所有视图以某种方式表现，您可以通过扩展您的
    Marionette 视图来实现。在下面的示例中，我们将通过扩展 `Marionette.ItemView` 来为所有项目视图添加一个 `log` 方法。
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now you just need to start using your `HandyView` in order to get the benefit
    of the `logMessage` function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需开始使用您的 `HandyView`，以便获得 `logMessage` 函数的好处。
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The idea here is to let you know that you can extend Marionette views just like
    you can extend Backbone views, and take advantage of the benefits of inheritance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是让您知道，您可以像扩展 Backbone 视图一样扩展 Marionette 视图，并利用继承的好处。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got to learn about all the kinds of views that Marionette
    offers, when to use them, how to advantageously make use of its handy methods
    that will allow us to manage the DOM creation and interaction better, and finally
    how to extend them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Marionette 提供的所有类型的视图，何时使用它们，如何有效地利用其便捷的方法来更好地管理 DOM 创建和交互，以及最后如何扩展它们。
- en: In the next chapter, we will learn about how to manage a set of views with the
    help of the `Regions`, `RegionManager`, and `BabySitter` objects of Marionette.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何借助 Marionette 的 `Regions`、`RegionManager` 和 `BabySitter` 对象来管理一组视图。
