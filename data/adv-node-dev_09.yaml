- en: ES7 classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES7类
- en: As we discussed in the last chapter, we have our socket `join` listener but
    the problem is that the information inside the listener. It gets lost once the
    callback is complete, things like the username and the room name, they are not
    persisted anywhere. We're going to need that information to complete our event
    listeners. `createMessage` is going to need to know the user's name as well as
    the room name to send that message to the specific room, and same is the case
    with `createLocationMessage`. We'll discuss that in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，我们有我们的socket `join`监听器，但问题是监听器内部的信息。一旦回调完成，这些信息就会丢失，比如用户名和房间名，它们没有被持久化在任何地方。我们需要这些信息来完成我们的事件监听器。`createMessage`需要知道用户的名称以及房间名称，以便将消息发送到特定的房间，`createLocationMessage`也是如此。我们将在本章讨论这一点。
- en: We'll start with learning the ES6 class syntax and using it in creating `users`
    class and some other methods. We'll also see wiring up the users list, updating
    the people list when any user joins or leaves the chat. We'll also look into sending
    messages to a specific room and not to all the users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始学习ES6类语法，并在创建`users`类和其他一些方法中使用它。我们还将看到如何连接用户列表，在任何用户加入或离开聊天时更新People列表。我们还将研究如何向特定房间发送消息，而不是发送给所有用户。
- en: Storing users with ES6 classes – Part I
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES6类存储用户 - 第I部分
- en: We don't have access to the data (username and room name) that is inside `join`,
    but we do have access to one common thing, and that is the socket ID. We have
    access to the socket variable, `socket.id`, and we also have access to it inside
    our other event listeners. And this is going to be what we use inside of a data
    structure we're about to create. We're going to create an array of users where
    we can store this information, when we want to look up a user like we might want
    to do in `createMessage` and `createLocationMessage`. We'll simply pass the ID
    to some function, get back the name and the room name, and emit the event as we
    want.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法访问`join`中的数据（用户名和房间名），但我们可以访问一个共同的东西，那就是socket ID。我们可以访问socket变量，`socket.id`，并且我们也可以在其他事件监听器中访问它。这将是我们即将创建的数据结构中要使用的内容。我们将创建一个用户数组，可以在其中存储这些信息，当我们想要查找用户时，比如在`createMessage`和`createLocationMessage`中。我们只需将ID传递给某个函数，获取名称和房间名称，然后按照我们的意愿发出事件。
- en: Now in order to get that done, we are going to make a brand new file in `utils`.
    We're going to call this file `users.js`, and this is where we're going to store
    everything related to that user's data structure.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这项工作，我们将在`utils`中创建一个全新的文件。我们将称这个文件为`users.js`，这是我们将存储与用户数据结构相关的所有内容的地方。
- en: 'It''s going to be an array of objects, and on each object, we''re going to
    have the ID, which will be the socket ID, some sort of really long string:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 它将是一个对象数组，每个对象上都会有ID，这将是socket ID，一种非常长的字符串：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll also have our name. This is the display name for the user, mine might
    be `Andrew`; and finally the room the user joined, this could be something like
    `The Office Fans`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有我们的名称。这是用户的显示名称，我的可能是`Andrew`；最后是用户加入的房间，这可能是类似于`The Office Fans`的东西：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is all the information we need to store in our data structure for a user
    to be able to wire everything up.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要存储在我们的数据结构中的所有信息，以便用户能够连接一切。
- en: 'Now the real work is going to come inside the methods that we''ll be creating
    to manipulate the array. We''re going to have four methods:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正的工作将在我们将要创建的方法中进行。我们将有四种方法：
- en: We want to be able to add a user via an `addUser` method; this is going to take
    three pieces of information, the ID, the name, and the room name.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够通过`addUser`方法添加用户；这将需要三个信息，ID、名称和房间名称。
- en: We're also going to want to have a method for removing a user when they leave
    a room; remember we want to update that People list in the left-hand sidebar in
    the chatroom. We're going to need a way to remove them as well as add them, `removeUser`,
    and we're going to be removing users by the socket ID.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户离开房间时，我们还需要一种方法来移除用户；记住我们想要在聊天室的左侧边栏中更新People列表。我们需要一种方法来添加和移除用户，`removeUser`，我们将通过socket
    ID来移除用户。
- en: Next up, we're going to have a way to fetch a user, this is going to come in
    handy when we're trying to send a message like we do inside the `createMessage`
    listener. We're going to want access to the user's name as well as the room in
    order to fire off the `newMessage` event. That is going to happen via a `getUser`
    method, which is going to take an ID and it will return the object we have defined
    up above.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将有一种方法来获取用户，当我们尝试发送消息时，这将非常方便，就像我们在`createMessage`监听器中所做的那样。我们将希望访问用户的名称以及房间，以便触发`newMessage`事件。这将通过一个`getUser`方法来实现，它将接受一个ID，并返回我们在上面定义的对象。
- en: The last one we're going to be adding is `getUserList`. The `getUserList` method
    is going to take the room name, figure out exactly which users are in that room,
    and return an array of names and will print those names to the client.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要添加的最后一个是`getUserList`。`getUserList`方法将获取房间名称，确定在该房间中的确切用户，并返回一个名称数组，并将这些名称打印到客户端。
- en: 'These four methods are all we need to get this done. Now there are a couple
    of ways we could do this. We might make an array called `users`, setting it equal
    to an empty array and then we might define our functions. We''ll add `var addUser`
    and we''ll set that equal to a function that takes `id`, `name` and `room`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种方法就是我们需要完成这项工作的全部内容。现在我们有几种方法可以做到这一点。我们可以创建一个名为`users`的数组，将其设置为空数组，然后定义我们的函数。我们将添加`var
    addUser`，并将其设置为一个接受`id`、`name`和`room`的函数：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then inside the function, we''ll do something like manipulate `users` array
    with `users.push`, pushing on some object. Then we''ll export it using `modules.export`,
    exporting the `addUser` function as the `addUsers` property:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在函数内部，我们将做一些类似于使用`users.push`来操作`users`数组的操作。然后我们将使用`modules.export`导出它，将`addUser`函数作为`addUsers`属性导出：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then we would call `addUser` over in `server.js`. This approach works fine,
    but we're not going to be using this approach. Here, we have a `users` array and
    we can manipulate the array. It does get the job done but what we're going to
    do instead is use the ES6 class syntax. This is going to let us create a `users`
    class. We'll be able to make a new instance of that class and fire all of our
    methods, which we'll be defining.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会在`server.js`中调用`addUser`。这种方法也可以，但我们不打算使用这种方法。在这里，我们有一个`users`数组，我们可以操作这个数组。它确实完成了工作，但我们打算使用ES6类语法。这将让我们创建一个`users`类。我们将能够创建该类的新实例，并调用我们将要定义的所有方法。
- en: I'm going to do this as opposed to creating ad hoc functions that all work with
    one piece of information. Now to get this done we are going to have to learn something
    new; we're going to be learning about ES6 classes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我要这样做，而不是创建所有用于处理一条信息的特定函数。现在为了完成这个，我们将不得不学习一些新东西；我们将学习关于ES6类的知识。
- en: The ES6 class syntax
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6类语法
- en: In order to talk about ES6 classes, let's go ahead and simply create one. Now
    the syntax for creating a new class is going to look a little strange at first,
    it is unique to what we're about to do. But I promise that once you make one or
    two classes and add a few methods, you'll get really used to defining the methods
    and the classes themselves.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论ES6类，让我们继续简单地创建一个。现在创建一个新类的语法一开始看起来可能有点奇怪，它是独特于我们即将做的事情。但我保证一旦你创建了一个或两个类，并添加了一些方法，你会真的习惯于定义方法和类本身。
- en: Creating the ES6 class for a person
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个人的ES6类
- en: To kick things off, we're going to create a simple class for a person. This
    means that we're making a set of data and a set of methods that are useful to
    manipulate `Person`. Now in order to get started, we are going to use the `class`
    keyword followed by the class name, `Person`. We're going to use an uppercase
    first letter for our class definition since we are going to be creating new instances
    of them with the new keyword. You do not need to use an uppercase P; this is just
    common convention across JavaScript. If a function is meant to be used with `new`,
    like `new Person`, `new Object`, or anything else, it should have an uppercase
    first letter; this is just a styling convention.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将为一个人创建一个简单的类。这意味着我们正在创建一组数据和一组有用于操作`Person`的方法。现在为了开始，我们将使用`class`关键字，后面跟着类名`Person`。我们将使用大写字母开头来定义我们的类，因为我们将使用`new`关键字创建它们的新实例。你不需要使用大写P；这只是JavaScript中的常见约定。如果一个函数是用来与`new`一起使用的，比如`new
    Person`，`new Object`，或其他任何东西，它应该有一个大写字母开头；这只是一种样式约定。
- en: 'Now right after our name we can simply open and close some curly braces and
    there we have it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的名字后面，我们可以简单地打开和关闭一些大括号，就这样：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have a brand new class and we can even make an instance of it. We can make
    a variable called `me` and set it equal to `new Person` calling it as a function
    just like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个全新的类，甚至可以创建它的一个实例。我们可以创建一个名为`me`的变量，并将其设置为`new Person`，就像这样调用它作为一个函数：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we have a new instance of the class and we can do whatever we like with
    it. Currently, it doesn't do anything but we do have an instance created.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个类的新实例，我们可以随心所欲地使用它。目前它什么也不做，但我们已经创建了一个实例。
- en: The constructor function
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: Now one of the first things about a class that's really great is the ability
    to add a constructor function. A constructor function is a special function, it
    is specific to the class, automatically fires, and lets you initialize the instance
    of your class. In this case, we want to do something to customize an individual
    person when a `new Person` is created.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类的第一件很棒的事情之一是能够添加一个构造函数。构造函数是一个特殊的函数，它是特定于类的，会自动触发，并允许你初始化你的类的实例。在这种情况下，我们想要在创建`new
    Person`时对个体进行一些自定义。
- en: 'To define a constructor function we start with the name, `constructor`, but
    instead of adding a colon or anything else, we simply go right to our function
    arguments and right into the curly braces:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个构造函数，我们从名称`constructor`开始，但我们不是添加冒号或其他任何东西，我们直接进入我们的函数参数，然后进入大括号：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is our function, it's just like a regular function. The code inside is
    going to get executed and the brackets are our arguments, but the syntax for setting
    it up does look pretty different than what we would do on an object or on anything
    else.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的函数，就像一个普通的函数。里面的代码将被执行，括号里是我们的参数，但设置它的语法看起来与我们在对象或其他任何地方所做的事情非常不同。
- en: 'Now this `constructor` function gets called by default. You do not need to
    manually call it, and that actually gets called with the arguments that you specify
    right in `Person`, which means that we could have our `Person` constructor function
    take two arguments; maybe we want to initialize a new person with `name` and `age`.
    That means we would pass in name and age, I can say that name is a string, I''m
    going to set it as my name and age is a number like `25`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个`constructor`函数会被默认调用。你不需要手动调用它，它实际上会使用你在`Person`中指定的参数调用，这意味着我们的`Person`构造函数可以接受两个参数；也许我们想要用`name`和`age`初始化一个新的人。这意味着我们会传入name和age，我可以说name是一个字符串，我会把它设置为我的名字，age是一个像`25`这样的数字：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `constructor` function is now going to get called with this data, and we
    can prove this by using `console.log` to print out the name, and as the second
    argument the age:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor`函数现在将使用这些数据进行调用，我们可以通过使用`console.log`来证明这一点，打印出名字，作为第二个参数年龄：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s go ahead and run this file and see what we get; it''s sitting in
    `server/utils`. I''m going to shut down `nodemon` and run it using following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续运行这个文件，看看我们得到了什么；它位于`server/utils`中。我要关闭`nodemon`，并使用以下命令运行它：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When I run the file, we get `Andrew 25` because the arguments were properly
    passed into the constructor:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行文件时，我们得到`Andrew 25`，因为参数已经正确传递到构造函数中：
- en: '![](img/5d620617-2270-45be-9412-155d5f193d34.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d620617-2270-45be-9412-155d5f193d34.png)'
- en: 'Now passing data in really isn''t useful, what we want to do is modify the
    specific instance. We want to set this person''s name and age not the name and
    age for all people. In order to do that, we''re going to use the `this` keyword.
    In class methods and in the constructor function, `this` refers to the instance
    as opposed to the class, which means we can set a property on this individual
    person, `this.name = name`, just like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在传递数据实际上并不有用，我们想要做的是修改特定的实例。我们想要设置这个人的名字和年龄，而不是所有人的名字和年龄。为了做到这一点，我们将使用`this`关键字。在类方法和构造函数中，`this`指的是实例，而不是类，这意味着我们可以在这个个人实例上设置属性，就像这样：`this.name
    = name`。
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And we can do the exact same thing for age, `this.age = age`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对年龄做同样的事情，`this.age = age`：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using this is how we customize the individual instance. Now what we have is
    an object, and we can actually access those properties. The `me` variable we defined
    is identical to the `this` variable, which means that we can actually access those
    properties. We''ll add `console.log`, I''m going to print the string `this.name`
    for formatting only, and then I''m going to reference the actual `me.name` property.
    And we can do the exact same thing for age; we''re going to print what we had
    put in as `this.age`, only we''re going to access it via `me.age`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法可以自定义个体实例。现在我们有了一个对象，我们实际上可以访问这些属性。我们定义的`me`变量与`this`变量相同，这意味着我们实际上可以访问这些属性。我们将添加`console.log`，我将仅打印字符串`this.name`以进行格式化，然后我将引用实际的`me.name`属性。对于年龄，我们将做同样的事情；我们将打印我们放入的`this.age`，只是我们将通过`me.age`访问它：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now rerun the file using, `nodemon server/utils/users.js`, and we get
    exactly what we''d expect:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`nodemon server/utils/users.js`重新运行文件，我们得到了我们期望的结果：
- en: '![](img/1cbce7c5-ca5b-4dbe-9b3e-0a95e2fcceea.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cbce7c5-ca5b-4dbe-9b3e-0a95e2fcceea.png)'
- en: The individual person was updated; `this.name` was set to `Andrew` and it is
    indeed showing. Now that we have a basic idea as to how we can initialize a class,
    let's go ahead and talk about methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 个人已更新；`this.name`设置为`Andrew`，并且确实显示出来。现在我们对如何初始化类有了基本的了解，让我们继续谈论方法。
- en: The method function
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法函数
- en: 'Methods can be any function, they could take arguments, maybe they won''t take
    arguments, and to define them all we do is the following. Without adding a comma,
    another quirk of the class syntax, we specify our method name. I''m going to create
    one called `getUserDescription`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以是任何函数，它们可以接受参数，也许它们不会接受参数，我们只需要定义它们。在不添加逗号的情况下，我们指定我们的方法名称。我将创建一个名为`getUserDescription`的方法：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This one is not going to take any arguments so we can leave that arguments
    list empty. Inside the function itself, we''re going to go ahead and return a
    description, since the method after all is called `getUserDescription`. We''re
    going to `return` a template string injecting some values inside there, the general
    flow is going to be `Jen is 1 year(s) old`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法不会接受任何参数，所以我们可以将参数列表留空。在函数本身内部，我们将返回一个描述，因为方法毕竟被称为`getUserDescription`。我们将返回一个模板字符串，将一些值注入其中，一般的流程将是`Jen
    is 1 year(s) old`。
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is what we want to print, but we want to use those specific values for
    this individual person, and to do that we''re going to access those properties
    once again. Instead a static name, we''re going to inject `this.name`; and instead
    of a static age, we''re going to inject the age, `this.age`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们想要打印的内容，但我们想要为这个个人使用那些特定的值，为了做到这一点，我们将再次访问这些属性。我们将注入`this.name`，而不是静态名称；而不是静态年龄，我们将注入年龄`this.age`：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can go ahead and actually test out `getUserDescription` by calling it
    down below. We can make a variable called `description`, set it equal to `me.getUserDescription`,
    and can go ahead and do something with the return value, like print it to the
    screen using `console.log`. Inside the log argument list, I''m just going to pass
    in `description`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续测试`getUserDescription`，通过在下面调用它。我们可以创建一个名为`description`的变量，将其设置为`me.getUserDescription`，然后可以对返回值进行操作，比如使用`console.log`将其打印到屏幕上。在log参数列表中，我只会传入`description`：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can save the file and we should see over inside the Terminal our `description`;
    in this case, `Andrew` and `25`, `Andrew is 25` years old. When I save the file
    `nodemon` is going to restart, and right here we get just that `Andrew is 25 year(s)
    old` printed to the screen:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存文件，我们应该在终端中看到我们的`description`；在这种情况下，`Andrew`和`25`，`Andrew is 25`岁。当我保存文件时，`nodemon`会重新启动，然后我们就会在屏幕上看到`Andrew
    is 25 year(s) old`。
- en: '![](img/35ba3e85-cce3-4855-88e8-008cbb5a2c20.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35ba3e85-cce3-4855-88e8-008cbb5a2c20.png)'
- en: This is the very basics of classes, there's a ton of class-related features
    we won't be exploring just yet, but for now this gives us everything we need in
    order to get started. Instead of a `Person` class, we're going to create a `users`
    class, and instead of methods like `getUserDescription`, we're going to create
    the custom methods. We're also going to be adding test cases as we go to make
    sure they work as expected.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类的基础知识，有很多与类相关的特性我们暂时不会探索，但是现在这给了我们一切我们需要开始的东西。我们将创建一个`users`类，而不是`Person`类，我们将创建自定义方法，而不是像`getUserDescription`这样的方法。我们还将在进行时添加测试用例，以确保它们按预期工作。
- en: Adding the users class
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加`users`类
- en: First, we're going to get started adding the `users` class and `then`. We'll
    finish it up adding all the methods. For now though, we can start defining the
    class, I am going to comment out the `Person` class we just added, since we do
    want it in place as documentation. But we're not going to exactly use it inside
    the app. We'll delete it a bit later once we are more comfortable with classes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开始添加`users`类，然后。我们将完成添加所有的方法。不过，我们现在可以开始定义这个类，我将注释掉我们刚刚添加的`Person`类，因为我们确实希望它作为文档存在。但我们不会在应用程序中确切使用它。一旦我们对类更加熟悉，我们稍后会删除它。
- en: 'Now, we''re going to start by creating our `users` class using the `class`
    keyword, `class Users`. We''re then going to go ahead and open up and close our
    curly braces, and inside here we can specify any methods we like, such as the
    `constructor` function. We are going to define a `constructor` function, although
    they are completely optional when creating classes. We''re going to set up our
    `constructor` function by name, then we''ll have our arguments list followed by
    the opening and closing curly braces:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始使用`class`关键字创建我们的`users`类，`class Users`。然后我们将打开和关闭大括号，在这里我们可以指定任何我们喜欢的方法，比如`constructor`函数。我们将定义一个`constructor`函数，尽管在创建类时它们是完全可选的。我们将通过名称设置我们的`constructor`函数，然后是参数列表，然后是打开和关闭大括号：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now the constructor function for users, unlike person, is not going to take
    any arguments. When we make a new `users` instance, we just want to start with
    an empty array of users. We''re going to be making this new instance over inside
    `server.js` when we first start the app, that is going to happen up top of the
    code. And down below, we''ll actually be using the methods when someone joins
    a room, leaves a room, or manipulates a room in whatever way they want. That means
    that all we need to do is set `this.users`, the `users` property, equal to an
    empty array:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与`person`不同，`users`的构造函数不会接受任何参数。当我们创建一个新的`users`实例时，我们只想从一个空的用户数组开始。我们将在`server.js`中创建这个新实例，当我们首次启动应用程序时，这将发生在代码的顶部。在下面，当有人加入房间、离开房间或以任何方式操纵房间时，我们将实际使用这些方法。这意味着我们需要做的就是将`this.users`，即`users`属性，设置为一个空数组：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is going to be the array we''ve defined at the top of the `users.js` file.
    The next thing we''re going to do, now that we have our `constructor` function
    in place, is create the `addUser` method. We''re going to create that just below
    the `constructor` function by defining it like we did for `getUserDescription`.
    We''re going to set up the arguments list, this one is going to take some arguments
    we''ll specify those in a moment, and we''re going to open and close our curly
    braces for the actual function code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们在`users.js`文件顶部定义的数组。接下来，我们要做的事情是，既然我们已经有了`constructor`函数，那么我们要创建`addUser`方法。我们将在`constructor`函数的下方创建它，就像我们为`getUserDescription`所做的那样。我们将设置参数列表，这个方法将使用一些参数，我们稍后会指定这些参数，并且我们将打开和关闭大括号来编写实际的函数代码：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The three arguments we're going to require is `id`, `name`, and `room`. In order
    to add a user to the `users` array, we need those three pieces of information.
    Once we have them actually adding them to the list is going to be really easy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的三个参数是`id`，`name`和`room`。为了将用户添加到`users`数组中，我们需要这三个信息。一旦我们有了它们，将它们添加到列表中就会变得非常容易。
- en: 'I''m going to get started by creating a variable `user` so we can make an object
    to push on to the array. In `users`, we''ll set an `id` property equal to the
    `id` argument, and we''ll do the same thing for `name` and finally for `room`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先创建一个变量`user`，这样我们就可以创建一个对象并将其推送到数组中。在`users`中，我们将设置一个`id`属性等于`id`参数，对于`name`和最后对于`room`也是同样的操作：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we have a `user` object with those three properties we can go ahead and
    push it on the array, `this.users.push`, to add an object on to the end, and the
    thing we''re going to be adding on to our array is the `user` variable:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`user`对象，具有这三个属性，我们可以继续将其推送到数组中，`this.users.push`，将一个对象添加到末尾，我们要添加到数组中的是`user`变量：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have this in place, we are basically done. The last thing I''m
    going to do is go ahead and return the successfully created user, `return user
    just like this`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经准备就绪，基本上我们已经完成了。我要做的最后一件事是继续返回成功创建的用户，`return user`就像这样：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And there we go, `addUser` is complete. We're not going to wire it up just yet
    but we can add a test case for `addUser`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`addUser`已经完成。我们还没有将其连接起来，但我们可以为`addUser`添加一个测试用例。
- en: Adding the test case for addUser
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`addUser`添加测试用例
- en: We'll add the test case over inside a brand new file called `users.test.js`.
    In here, we'll be able to load in users, test it, and do whatever else we might
    need to do. Now, the first step is going to be to actually export users.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个全新的名为`users.test.js`的文件中添加测试用例。在这里，我们可以加载用户，对其进行测试，以及进行任何其他可能需要做的事情。现在，第一步是实际导出用户。
- en: Currently, inside the `user.js` file we have defined the class, but we do not
    export it. Exporting it is going to be the same as exporting anything else, there's
    nothing special there.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在`user.js`文件中，我们已经定义了类，但我们没有导出它。导出它与导出其他任何内容都是一样的，没有什么特别的地方。
- en: 'We''ll add `module.exports`, and we''re going to go ahead and export, inside
    of curly braces, an object where the users property equals the `Users` class definition
    we have, making sure to match the case:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加`module.exports`，并且我们将在大括号内导出一个对象，其中`users`属性等于我们的`Users`类定义，确保匹配大小写：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we have this in place, we can actually require our class and make new
    instances of it over inside the `users.test` file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经准备就绪，我们现在可以在`users.test`文件中要求我们的类并创建新的实例了。
- en: Adding new instances in the users.test file
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`users.test`文件中添加新的实例
- en: 'Let''s get started by loading in `expect`, `const expect = require(''expect'')`,
    and we can also go ahead and load in our users file, `const`. Using ES6 destructuring
    we''re going to grab `Users`, and we''re going to get that via the local file
    `./users`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始加载`expect`，`const expect = require('expect')`，我们还可以继续加载我们的用户文件，`const`。使用ES6解构，我们将通过本地文件`./users`获取`Users`：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now for the moment, we''re just going to add a test case for adding a user.
    We''ll make a quick `describe` block, most of the heavy lifting is going to happen
    later in the section. We''ll `describe` our `Users` class, we can then add our
    arrow function and we can go ahead and add a test case, `it`, inside quotes, `should
    add new user`. I''m going to go ahead and set up the function for this one. It''s
    going to be a synchronous function so there''s no need for the `done` argument,
    and we can create a new instance of users, `var users`, equals a `new Users`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只是要为添加用户添加一个测试用例。我们将快速创建一个`describe`块，大部分繁重的工作将在后面进行。我们将`describe`我们的`Users`类，然后我们可以添加我们的箭头函数，然后我们可以继续添加一个测试用例，`it`，在引号内，`should
    add new user`。我将为这个设置函数。这将是一个同步函数，所以不需要`done`参数，我们可以创建一个新的用户实例，`var users`，等于一个`new
    Users`：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now since we don't take any arguments in the `constructor` function, we're not
    going to pass any in when we actually create our instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们在`constructor`函数中没有传入任何参数，所以在实际创建实例时我们也不会传入任何参数。
- en: 'The next thing we''re going to do is make a user, then we''ll be passing its
    properties to `addUser` making sure the appropriate thing shows up in the end.
    Let''s go ahead and make a variable `user` and we''ll set that equal to an object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是创建一个用户，然后将其属性传递给`addUser`，确保最终显示出适当的内容。让我们创建一个名为`user`的变量，然后将其设置为一个对象：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I''m going to go ahead and set on this object three properties, an `id` equal
    to something like `123`, a `name` property equal to some name like `Andrew`, and
    you can go ahead and use your first name for example, `Andrew`, and a room name.
    I''m going to use `The Office Fans`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续在这个对象上设置三个属性，一个`id`等于`123`之类的东西，一个`name`属性等于像`Andrew`这样的名字，你可以使用你的名字，比如`Andrew`，还有一个房间名。我将使用`The
    Office Fans`：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we have the user in place and we can go ahead and call that method that
    we just created, the `addUser` method with the three necessary arguments, `id`,
    `name`, and `room`. I''m going to store the response in a variable called `resUser`,
    and we''ll set it equal to `users.addUser` passing in those three pieces of information,
    `user.id`, `user.name`, and `user.room` as the third argument:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了用户，我们可以调用我们刚刚创建的方法，`addUser`方法，使用三个必要的参数，`id`，`name`和`room`。我将把响应存储在一个名为`resUser`的变量中，并将其设置为`users.addUser`，传入这三个信息，`user.id`，`user.name`和`user.room`作为第三个参数：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the call in place we can now start making our assertions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个调用，我们现在可以开始做出我们的断言。
- en: Making the assertions for the users call
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为用户调用做出断言
- en: 'One assertion we want to make is that the actual `users` array was updated,
    it should have been updated when we called `this.users.push`. I''m going to expect
    that by calling `expect`. We''re going to expect something about `users.users`:
    the first user refers to the `users` variable and the second one actually accesses
    the `users` array as defined in `users` file. Then we''re going to call `toEqual`.
    Remember for arrays and objects, you have to use `toEqual` as opposed to `toBe`.
    We''re going to `expect` it to be an array with just one item. The item should
    look just like the `user` object we have defined in the code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的一个断言是实际的`users`数组已经更新，当我们调用`this.users.push`时，它应该已经更新。我期望通过调用`expect`来期望一些关于`users.users`的内容：第一个用户是指`users`变量，第二个实际上访问了`users`文件中定义的`users`数组。然后我们将调用`toEqual`。记住对于数组和对象，你必须使用`toEqual`而不是`toBe`。我们期望它是一个只有一个项目的数组。这个项目应该看起来像我们在代码中定义的`user`对象：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If this passes, then we know our user was indeed added to the `users` array.
    I'm going to go ahead and save the file and shut down `nodemon`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这通过了，那么我们知道我们的用户确实被添加到了`users`数组中。我将继续保存文件并关闭`nodemon`。
- en: Running the addUser test case
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行addUser测试用例
- en: 'I''m going to clear the Terminal output and run `npm test` to make sure our
    brand new test case is passing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我将清除终端输出并运行`npm test`，以确保我们全新的测试用例通过：
- en: '![](img/77a31d7e-dcaa-4e09-9a13-69043b428168.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77a31d7e-dcaa-4e09-9a13-69043b428168.png)'
- en: When I run it, it does indeed pass. We have our `Users` block and `should add
    new user` is working as expected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行它时，它确实通过了。我们有我们的`Users`块，`should add new user`按预期工作。
- en: Adding the removeUser, getUser, and getUserList methods
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加removeUser、getUser和getUserList方法
- en: Before we can integrate users into our application, let's go ahead and finish
    building it out. We have three more methods to add and test. The first one is
    `removeUser`, which is going to take an argument, the ID of the user you want
    to remove. This is also going to return the user that was just removed, so if
    I remove the user with an ID of 3, I want to get rid of it from the list but I
    do want to return the object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将用户集成到我们的应用程序之前，让我们继续完成它。我们还有三种方法要添加和测试。第一个是`removeUser`，它将接受一个参数，要删除的用户的ID。这也将返回刚刚删除的用户，所以如果我删除ID为3的用户，我想把它从列表中删除，但我确实想返回这个对象。
- en: 'We''ll leave a little note about that, `return user that was removed`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将留下一个关于`返回被删除的用户`的小注释：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now the next method that we''re going to be filling out is `getUser`. The `getUser`
    method is going to take the exact same arguments as `removeUser`. We''re going
    to find a user by ID returning the user object, but we''re not going to be removing
    it from the array:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要填写的下一个方法是`getUser`。`getUser`方法将接受与`removeUser`完全相同的参数。我们将通过ID找到一个用户并返回用户对象，但我们不会从数组中删除它：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The final one that we''re going to create, as specified up above, is a method
    called `getUserList`. This is going to get a list of all the users, just their
    names by the room name:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的最后一个方法，如上所述，是一个名为`getUserList`的方法。这将获取所有用户的列表，只显示他们的名字和房间名：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This means that we''re going to iterate through the `users` array looking for
    all the users whose room matches the room specified. This is going to return an
    array, something like: `''Mike'', ''Jen'', ''Caleb''`, assuming those are the
    people inside of the room:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将遍历`users`数组，寻找所有房间与指定房间匹配的用户。这将返回一个数组，类似于：`'Mike', 'Jen', 'Caleb'`，假设这些人在房间里：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, notice here that we're not specifying the room or the ID property; we're
    just returning an array of strings.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意，我们没有指定房间或ID属性；我们只是返回一个字符串数组。
- en: Adding seed data for the test file
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试文件添加种子数据
- en: Now let's go ahead and add one thing to our test file. In order to get these
    methods to work, we're going to need seed data, we're going to need users that
    already exist otherwise we can't remove one or get one, and we definitely can't
    get a list of the rooms these non-existent users are in.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在测试文件中添加一件事。为了使这些方法起作用，我们需要种子数据，我们需要已经存在的用户，否则我们无法删除一个或获取一个，绝对不能获取这些不存在用户所在的房间列表。
- en: 'In order to fix that over inside `user.test.js`, we''re going to add a `beforeEach`
    call, which we''ve used in the past. The `beforeEach` call, as we know, is going
    to get called before every single test case. It''s going to help us initialize
    some data. Now the data we''re going to initialize is going to be defined just
    above the `beforeEach` call, in a variable called `users`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在`user.test.js`中，我们将添加一个`beforeEach`调用，这是我们过去使用过的。`beforeEach`调用，正如我们所知，将在每个测试用例之前调用。它将帮助我们初始化一些数据。现在我们要初始化的数据将在`beforeEach`调用的上面定义，一个名为`users`的变量中：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The reason I'm defining it outside of `beforeEach` is so it's accessible inside
    of `beforeEach` and it's accessible inside of the test cases, we have defined
    down below.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`beforeEach`之外定义它的原因是为了让它在`beforeEach`内部和测试用例内部都可以访问到。
- en: 'Inside of `beforeEach` we''re going to set `users` equal to `new Users`, and
    we''re also going to set the `users.users` array. Here we can specify an array
    of objects, and this is going to let us add some initializing data:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`beforeEach`内部，我们将`users`设置为`new Users`，我们还将设置`users.users`数组。在这里，我们可以指定一个对象数组，这将让我们添加一些初始化数据：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s go ahead and provide three objects. The first one will have an `id`
    property equal to `2`, we''ll set the `name` property equal to something like
    `Mike`, and we can go ahead and set the `room` property equal to whatever we like,
    I''m going to go ahead and use a room name of `Node Course`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提供三个对象。第一个将有一个`id`属性等于`2`，我们将把`name`属性设置为类似`Mike`的东西，然后我们可以把`room`属性设置为任何我们喜欢的东西，我将使用一个房间名`Node
    Course`：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can take this object and copy it two more times. I''m going to add a comma,
    paste in what I just copied and do the same thing again, comma followed by a paste.
    I''m going to change it to an id of `2` for the second user, we''ll change the
    name to something like `Jen` and we''ll change the room name to `React Course`.
    Now for the last user, we are going to change `id` and `name`, we''ll make `id`
    equals `3`, and we''ll make the name something like `Julie`, but we''re going
    to leave the room as `Node Course` so we can test that our `getUserList` function
    does indeed return the correct results:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以拿这个对象并复制两次。我要加一个逗号，粘贴刚刚复制的内容，然后再做同样的事情，逗号后面是一个粘贴。我要把第二个用户的id改成`2`，我们会把名字改成`Jen`，把房间名改成`React
    Course`。现在对于最后一个用户，我们要改变`id`和`name`，我们会把`id`设为`3`，名字设为`Julie`，但是我们会把房间名留为`Node
    Course`，这样我们可以测试我们的`getUserList`函数是否确实返回了正确的结果：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The test cases aren''t going to be required to use our `users` variable as
    defined here. We can still define a custom one as we defined in case of adding
    new user. If I run the `test-watch script`, `npm run test-watch`, we''re going
    to see that our one test case is still passing:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例不需要使用我们在这里定义的`users`变量。我们仍然可以定义一个自定义的变量，就像我们在添加新用户的情况下定义的那样。如果我运行`test-watch`脚本，`npm
    run test-watch`，我们会看到我们的一个测试用例仍然通过：
- en: '![](img/f6bfc1d7-d005-4608-ae6e-44f8f791cc78.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6bfc1d7-d005-4608-ae6e-44f8f791cc78.png)'
- en: I'm going to save the file to rerun the test suite, and right here we have 6
    passing test cases. Regardless of whether or not we use this, we can still use
    a custom test case.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我要保存文件以重新运行测试套件，现在我们有6个通过的测试用例。无论我们是否使用这个，我们仍然可以使用自定义的测试用例。
- en: Now that we have this in place, we can go ahead and start filling out some of
    these methods. We're going to fill out `getUserList` together, and you're going
    to be responsible for `removeUser` and `getUser`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经准备就绪，我们可以继续填写一些这些方法。我们将一起填写`getUserList`，你将负责`removeUser`和`getUser`。
- en: Filling the getUserList
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充getUserList
- en: 'Now in order to fill out `getUserList`, we''re going to start by finding all
    of the users whose room matches the `room` argument specified. In order to do
    that we''re going to use the `filter` method on arrays, which we''ve used in the
    past. Let''s make a variable, we''ll call it `users` and we''ll set it equal to
    `this.users`, which is the array of `users.filter`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填写`getUserList`，我们将首先找到所有房间与指定`room`匹配的用户。为了做到这一点，我们将使用数组的`filter`方法，这是我们过去使用过的。让我们创建一个变量，我们将称之为`users`，然后将其设置为`this.users`，这是`users.filter`的数组：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now if you remember `filter` takes a function as its argument. This function
    gets called with each individual user. We can return `true` to keep this item
    in the array or we can return `false` to have it removed from the array. I''m
    going to go ahead and return `user.room`, and we''re going to check if that equals,
    using three equal signs, the `room` argument:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你记得，`filter`接受一个函数作为它的参数。这个函数会被每个单独的用户调用。我们可以返回`true`来保留数组中的这个项目，或者我们可以返回`false`来将其从数组中移除。我将返回`user.room`，然后我们会检查它是否等于，使用三个等号，`room`参数：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If they are equal, `user.room === room` is going to result in `true` that value
    will get returned; if they''re not equal it''s going to result in `false` and
    the user will not be added to the list above. Now we can go ahead and use the
    shortcut for our ES6 arrow function. Instead of adding the `return` keyword and
    specifying the actual arrow, we''ll use the shorthand like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们相等，`user.room === room`将返回`true`，该值将被返回；如果它们不相等，它将返回`false`，用户将不会被添加到上面的列表中。现在我们可以使用ES6箭头函数的快捷方式。我们将使用这样的简写，而不是添加`return`关键字并指定实际的箭头：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It''s the exact same functionality just a different technique. Now we have
    a list of all the users who do match the criteria. The next step in the process
    is to take that array of objects and convert it to an array of strings. All we
    care about is getting that list of names. In order to do that, we''re going to
    use map. I''m going to create a variable called `namesArray` and we''re going
    to set this equal to `users.map`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全相同的功能，只是不同的技术。现在我们有了所有符合条件的用户的列表。过程的下一步是将对象数组转换为字符串数组。我们只关心获取那个名单。为了做到这一点，我们将使用`map`。我将创建一个名为`namesArray`的变量，我们将把它设置为`users.map`：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we have used `map` in the past, as we know `map` also takes a function
    similar to `filter`. It also gets called with the individual item. In this case,
    an individual user, but `map` lets us return the value we want to use instead.
    So we''re going to get an object, it is going to have the `id` property, the `room`
    property and the `name` property, and all we want is the `name` property, so we''re
    going to return `user.name`. And we can simplify that even further using the shorthand
    for the arrow function. `user.name` is going to be implicitly returned:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们过去使用了`map`，因为我们知道`map`也需要一个类似于`filter`的函数。它也会被调用以处理单个项目。在这种情况下，是单个用户，但`map`让我们返回我们想要使用的值。所以我们将得到一个对象，它将有`id`属性、`room`属性和`name`属性，我们只想要`name`属性，所以我们将返回`user.name`。我们甚至可以使用箭头函数的简写来进一步简化它。`user.name`将被隐式返回：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we have our `namesArray` array, all we need to do is go ahead and
    return it by returning `namesArray`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`namesArray`数组，我们需要做的就是通过返回`namesArray`来返回它：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now this is going to get the job done, before we simplify it any further let's
    go ahead and write a test case to make sure it works.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这将完成任务，在我们进一步简化之前，让我们继续编写一个测试用例以确保它有效。
- en: Adding test case for getUserList
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为`getUserList`添加测试用例
- en: 'Inside `users.test.js` we can add the test case below our other test case,
    `it (''should return names for node course'')`. We''re going to write the case
    that returns all of the users inside the Node course, we should get the two users
    back, `Mike` and `Julie`. We''ll make a variable, we''ll call that variable `userList`,
    and what we''re going to do is call the `users` variable defined already:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`users.test.js`中，我们可以在其他测试用例下面添加测试用例，`it ('should return names for node course')`。我们将编写返回`Node`课程中所有用户的用例，我们应该得到两个用户，`Mike`和`Julie`。我们将创建一个变量，我们将称这个变量为`userList`，然后我们将调用已经定义的`users`变量：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is the one with our seed data. We do not need to create a custom one like
    we do for the other test case, `users.getUserList`. And we know `getUserList`
    takes one argument, the name of the room you want to fetch the list for, this
    one is called `Node Course`. Make sure your capitalization lines up. Then we can
    go ahead and add a semicolon at the end:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们种子数据的一个。我们不需要像为其他测试用例`users.getUserList`那样创建一个自定义的。我们知道`getUserList`需要一个参数，你想要获取列表的房间的名称，这个叫做`Node
    Course`。确保你的大写字母对齐。然后我们可以继续在末尾添加一个分号：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The last thing to do is add our assertion, making sure that what we get back
    is what''s expected. We''ll `expect` that `userList` equals, using `toEqual`,
    the following array. It''s going to be an array where the first item is `Mike`
    and the second item is `Julie`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的是添加我们的断言，确保我们得到的是预期的结果。我们将`expect` `userList`等于，使用`toEqual`，以下数组。它将是一个数组，其中第一项是`Mike`，第二项是`Julie`：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If that assertion passes, we know `getUserList` worked as expected because that's
    exactly what we have defined up above.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该断言通过，我们知道`getUserList`按预期工作，因为这正是我们在上面定义的。
- en: 'Now we can go ahead and copy this test case. Doing the exact same thing for
    the React Course should return names for `react` course, we''ll change `Node`
    to `React` and we''re going to go ahead and update what we `expect`. The React
    Course has just one user, that user has `name` equal to `Jen`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续复制这个测试用例。对`React Course`做完全相同的事情应该返回`react`课程的名称，我们将把`Node`改为`React`，然后我们将更新我们的`expect`。React课程只有一个用户，该用户的`name`等于`Jen`：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now this is a pretty good test case. If we save `users.test.js` it''s going
    to rerun the entire test suite. We should see we have our three tests under the
    `users` describe block, and they should all be passing, that is indeed the case:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个相当不错的测试用例。如果我们保存`users.test.js`，它将重新运行整个测试套件。我们应该看到我们在`users`描述块下有三个测试，它们都应该通过，确实是这样的：
- en: '![](img/bbd16203-7351-4ff7-95ff-db8fc7ec2c6c.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbd16203-7351-4ff7-95ff-db8fc7ec2c6c.png)'
- en: 'The next two methods that we''re going to be creating are `removeUser` and
    `getUser`. Let''s go ahead and write the `it` statements for the test cases together,
    and you''ll be responsible for actually filling out the method and filling out
    the test case:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的下两个方法是`removeUser`和`getUser`。让我们继续一起编写测试用例的`it`语句，你将负责填写方法和填写测试用例：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This method is going to take the ID of one of our seed users, whether it''s
    1, 2 or 3\. It''s going to pass it to the function `removeUser`, and your job
    is going to be to assert that the user was indeed removed. Next up, `it(''should
    not remove user'')`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将获取我们种子用户的ID，无论是1、2还是3。它将把它传递给`removeUser`函数，你的工作是断言用户确实被移除了。接下来，`it('should
    not remove user')`：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this case, I want you to pass in an ID that is not part of our seed `user`
    array, that means something like 44, 128, or basically any string that's not 1,
    2, or 3\. In this case, you should be asserting that the array has not changed;
    we should still have those three items.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我希望你传入一个不是我们种子`user`数组的一部分的ID，这意味着类似于44、128或者基本上任何不是1、2或3的字符串。在这种情况下，你应该断言数组没有改变；我们仍然应该有这三个项目。
- en: Now those are the two test cases for our `removeUser` method, next up is `getUser`.
    We're going to add two similar test cases. First up, `it('should find user')`,
    you should pass in a valid ID and you should get the user object back. And the
    other one is going to be `it ('should not find user')`, just like `it('should
    not remove a user')`. Pass in an invalid ID and make sure you do not get a user
    object back.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些是我们的`removeUser`方法的两个测试用例，接下来是`getUser`。我们将添加两个类似的测试用例。首先是`it('should find
    user')`，你应该传入一个有效的ID，然后你应该得到用户对象。另一个将是`it ('should not find user')`，就像`it('should
    not remove a user')`一样。传入一个无效的ID，并确保你没有得到用户对象。
- en: Filling the getUser
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填写getUser
- en: 'I''m going to start off with `getUser`, the goal here is to return the user
    object whose ID matches the ID of argument passed in `getUser`. To get that done,
    I am going to be using `filter`. We''re going to return the result from `this.users.filter`,
    we''re going to be filtering by ID, and here we filter by room. We''re going to
    pass in our arrow function using the expression syntax, the argument will be `user`,
    and we are going to go ahead and return `true` if the user''s `id` property equals
    the ID of the argument. If that is the case, we do want to keep this `user` in
    the array. And in the end, we should have just one user or 0 users, and all we''re
    going to do is return the first item:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从`getUser`开始，这里的目标是返回ID与`getUser`中传入的参数的ID匹配的用户对象。为了完成这个目标，我将使用`filter`。我们将返回`this.users.filter`的结果，我们将按ID进行过滤，这里我们按房间进行过滤。我们将传入我们的箭头函数，使用表达式语法，参数将是`user`，我们将继续返回`true`，如果用户的`id`属性等于参数的ID。如果是这种情况，我们确实希望在数组中保留这个`user`。最后，我们应该只有一个用户或0个用户，我们要做的就是返回第一个项目：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If there's one user in the array we're going to get its object back; if there's
    no users we're going to get undefined, which is exactly what we want. Now that
    we have `getUser` in place we can write the test case for that. We have two test
    cases, `it('should find user')` and `it('should not find user')`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组中有一个用户，我们将得到它的对象；如果没有用户，我们将得到undefined，这正是我们想要的。现在我们有了`getUser`，我们可以为此编写测试用例。我们有两个测试用例，`it('should
    find user')`和`it('should not find user')`。
- en: Test case – should find user
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例-应该找到用户
- en: 'For `it(''should find user'')`, I''m going to get started by making a variable
    called `userId` and I''m going to set this equal to the ID I want to use. I need
    a valid ID so I''m going to go ahead and use `2`. `1`, `2`, or `3` would have
    worked here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`it('should find user')`，我将首先创建一个名为`userId`的变量，并将其设置为我想要使用的ID。我需要一个有效的ID，所以我将继续使用`2`。`1`、`2`或`3`在这里都可以工作：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next up I am going to go ahead and make a `user` variable, this is going to
    be the return result from `getUser`. I''ll set it equal to `users.getUser`, and
    we''re going to try to fetch a user whose ID is `2` by passing in `userId`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将继续创建一个`user`变量，这将是从`getUser`返回的结果。我将把它设置为`users.getUser`，我们将尝试通过传入`userId`来获取ID为`2`的用户：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now the next thing we''re going to do is make an assertion about what we get
    back, we should have gotten our object back and we can `expect` that `user.id`
    equals, using `toBe`, and the ID, the `userId` variable:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的下一件事是对我们得到的结果进行断言，我们应该得到我们的对象，并且我们可以`expect` `user.id`等于，使用`toBe`，和ID，`userId`变量：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'I''m going to go ahead and save the test suite, and you can see all our test
    cases are still passing, which is fantastic. If it does not equal the ID, maybe
    the ID is `3`, you''re going to see the test case fail, and we do get a pretty
    clear error message:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我将保存测试套件，你可以看到我们所有的测试用例仍然通过，这太棒了。如果它不等于ID，也许ID是`3`，你将看到测试用例失败，我们会得到一个非常清晰的错误消息：
- en: '![](img/2bfa11b2-203d-4ed0-b43f-e1e2348bb5a4.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bfa11b2-203d-4ed0-b43f-e1e2348bb5a4.png)'
- en: We get `Expected 2 to be 3`, which clearly is not the case. This is the final
    test case though and we can move on to `it('should not find user')`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了`预期为2实际为3`，显然不是这样。这是最后的测试用例，我们可以继续进行`it('should not find user')`。
- en: Test case – should not find user
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例-不应该找到用户
- en: 'In this case, we''re going to follow a very similar format as in case of should
    find user, creating the `userId` variable and setting it equal to a user ID that
    does not exist inside of our built-in users; something like `99` would get the
    job done:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将遵循与应该找到用户相似的格式，创建`userId`变量，并将其设置为内置用户中不存在的用户ID，类似于`99`将完成任务：
- en: '[PRE54]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next up, we''ll be making a `user` variable, once again to store the return
    result from `getUser`, `users.getUser`, passing in our `userId`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`user`变量，再次存储从`getUser`中返回的结果，`users.getUser`，传入我们的`userId`：
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now in this case, we would expect that undefined comes back, `filter` should
    return nothing and if you try to fetch the first item in an empty array, you''re
    going to get undefined. We can prove that over in the Terminal by running `node`,
    and inside our little console we can create an empty array and we can access the
    first item:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这种情况下，我们期望得到undefined，`filter`应该返回空，如果你尝试获取空数组中的第一个项目，你将得到undefined。我们可以通过在终端中运行`node`来证明这一点，在我们的小控制台中，我们可以创建一个空数组，然后访问第一个项目：
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We get back `undefined`. I''m going to shut that down, restart our test suite,
    and over `inside users.test.js` file we are going to go ahead and make our assertion.
    We''re going to `expect(user).toNotExist`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了`undefined`。我将关闭它，重新启动我们的测试套件，在`inside users.test.js`文件中，我们将继续进行断言。我们将`expect(user).toNotExist`：
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'I''m going to save the file and all of our test cases should still be passing:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我将保存文件，我们所有的测试用例应该仍然通过：
- en: '![](img/3a29742c-939b-4ebd-842b-3a90f7cbb0bb.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a29742c-939b-4ebd-842b-3a90f7cbb0bb.png)'
- en: That's great. Next up, we need to write the `removeUser` method and we also
    need to fill out the test cases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。接下来，我们需要编写`removeUser`方法，还需要填写测试用例。
- en: Filling the removeUser method
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填写removeUser方法
- en: 'Over inside `user.js`, we can get started by finding the user, if any. That
    means, we''re going to use a similar technique to what we have in the `getUser`
    method. I''m going to actually copy the following line from the `getUser` method
    and paste it just right inside of `removeUser`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user.js`中，我们可以开始查找用户，如果有的话。这意味着，我们将使用与`getUser`方法类似的技术。我将从`getUser`方法中复制以下行，并将其粘贴到`removeUser`中。
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Creating a variable called `user`, setting it equal to the preceding line.
    Now you could also go ahead and actually call `getUser`. I could call `this.getUser`,
    passing in `id` just like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`user`的变量，将其设置为前一行。现在你也可以继续调用`getUser`。我可以调用`this.getUser`，传入`id`，就像这样：
- en: '[PRE59]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Both of those solutions are going to work as expected. Next up, if there is
    a user, we want to remove it, `if(user)`, we''re going to do something special,
    and regardless of whether or not a user did exist, we are going to return the
    `user` value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种解决方案都将按预期工作。接下来，如果有用户，我们想要删除它，`if(user)`，我们将做一些特殊的事情，无论用户是否存在，我们都将返回`user`值：
- en: '[PRE60]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If it didn't exist we're going to return undefined, which is great, if it did
    exist after we remove user, we'll be returning the object, also what we want.
    All we need to do is figure out how to remove it from the list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不存在，我们将返回undefined，这很好，如果它存在，我们将在删除用户后返回对象，这也是我们想要的。我们需要做的就是弄清楚如何从列表中删除它。
- en: 'To do this, I''m going to set `this.users` equal to `this.users`, and we''re
    going to call `filter` finding all users whose ID does not match the one specified
    up above. We''re going to call filter passing in our arrow function, we''re going
    to get the individual `user`, and all we''re going to do inside our arrow expression
    syntax is add `user.id` does not equal `id`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我将把`this.users`设置为`this.users`，然后我们将调用`filter`找到所有ID与上面指定的ID不匹配的用户。我们将调用filter，传入我们的箭头函数，我们将得到单个`user`，在箭头表达式语法中，我们要做的就是添加`user.id`不等于`id`：
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is going to create a new array, setting it equal to `this.users`, and we're
    going to have the item removed, if any. If there was no item that's fine; this
    statement is never going to run and will be able to continue on returning undefined.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新数组，将其设置为`this.users`，并且将删除项目，如果有的话。如果没有项目，那就没关系；这个语句永远不会运行，我们将能够继续返回undefined。
- en: Now that we have this in place, we can go ahead and write a test case that makes
    sure it works as expected. I'm going to save `user.js` and right inside `users.test`,
    we're going to fill both `it ('should remove a user')` and `it ('should not remove
    user')` test cases. Let's get started with `should remove a user`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了这个准备，我们可以继续编写一个测试用例，以确保它按预期工作。我将保存`user.js`，然后在`users.test`中，我们将填写`it
    ('should remove a user')`和`it ('should not remove user')`测试用例。让我们从`should remove
    a user`开始。
- en: Test case – should remove a user
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例-应删除用户
- en: 'I''m going to make a variable `userId` to store the ideal ID, which would be
    `1`, `2` or `3`, I''ll go with `1`, then we can go ahead and actually remove it
    storing the return result in a `user` variable. I''m going to call `users.removeUser`
    passing in my `userId` variable, which is `1`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个变量`userId`来存储理想的ID，可以是`1`、`2`或`3`，我将选择`1`，然后我们可以继续并实际删除它，将返回结果存储在一个`user`变量中。我将调用`users.removeUser`，传入我的`userId`变量，即`1`：
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we have the potentially removed user we should be able to go ahead
    and assert some stuff. We''re going to `expect` that the `user` object exists.
    We''re also going to expect that its `id` equals the `id` we have up above, and `expect`
    that the user removed has an `id` property using `toBe(userId)`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可能被删除的用户，我们应该能够继续断言一些东西。我们将期望`user`对象存在。我们还将期望它的`id`等于上面的`id`，并且期望被删除的用户具有`id`属性，使用`toBe(userId)`：
- en: '[PRE63]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next up, we''re going to make sure that the user was removed from the array.
    We''re going to `expect(users.users.length).toBe)` in this case `2`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将确保用户已从数组中删除。在这种情况下，我们将期望`users.users.length`为`2`：
- en: '[PRE64]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It should have been `3` in the beginning and once we removed a user, it should
    have been `2`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始应该是`3`，一旦我们删除了一个用户，它应该是`2`。
- en: Test case – should not remove user
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用例-不应删除用户
- en: 'In case of should not remove user, we''re going to do some similar stuff, we''re
    just going to tweak `userId`. I can actually copy the contents of our first test
    case, paste it into the second one, and all we need to do is make a few tweaks.
    I''m going to change the ID to an invalid ID like `99`. We are still going to
    call `removeUser` with the ID. In this case, though instead of expecting `user`
    to have an `id` property, we''re going to expect that `user` does not exist using
    `toNotExist`. Next up, we''re going to `expect` the length has not changed, and
    we''re going to make sure that the length still equals `3`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在`should not remove user`的情况下，我们将做一些类似的事情，只是我们将调整`userId`。我可以复制我们第一个测试用例的内容，粘贴到第二个测试用例中，我们只需要做一些调整。我将把ID更改为无效的ID，比如`99`。我们仍然将使用该ID调用`removeUser`。在这种情况下，我们不再期望`user`具有`id`属性，而是使用`toNotExist`来判断`user`不存在。接下来，我们将期望长度没有改变，并确保长度仍然等于`3`：
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now I can go ahead and save the `users.test` file. This is going to restart
    everything inside `nodemon`, and what we should get is a test suite that''s passing.
    It looks like it did already run although the content didn''t change so it''s
    a little hard to figure out if anything happened. I''m going to shut that down
    and run `npm test` just to verify, and right here you can see all 12 test cases
    are passing:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以保存`users.test`文件。这将重新启动`nodemon`中的所有内容，我们应该得到一个通过的测试套件。看起来好像已经运行了，尽管内容没有改变，所以很难弄清楚是否发生了什么。我将关闭它并运行`npm
    test`来验证，你可以看到这里有12个测试用例都通过了：
- en: '![](img/41065d67-9bad-45ed-9369-decf75a28d6a.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41065d67-9bad-45ed-9369-decf75a28d6a.png)'
- en: We now have all of the methods we need to persist a user across the different
    event listeners; whether they're sending a message, a location message, whether
    they're connecting or leaving, we're going to be able to keep track of them and
    send the right thing to the right people.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有我们需要的方法来跨不同的事件监听器持久化用户；无论他们是发送消息、位置消息，无论他们是连接还是离开，我们都将能够跟踪他们并向正确的人发送正确的东西。
- en: Wiring up user list
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接用户列表
- en: In this section we're going to start wiring up that users class we created,
    and to kick things off, we're going to wire up the `People` list, which means
    that we need to do something when a user joins, and when a user leaves. We want
    to keep that list up to date and every time we update it, we want to give a fresh
    copy of the list to the client. This means that the server is going to need to
    emit an event to the client, the client is then going to listen for that event
    and it's going to update the markup.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将开始连接我们创建的用户类，并且为了开始，我们将连接`People`列表，这意味着当用户加入和离开时，我们需要做一些事情。我们希望保持列表最新，并且每次更新时，我们都希望给客户端一个新的列表副本。这意味着服务器需要向客户端发出一个事件，然后客户端将监听该事件并更新标记。
- en: 'Now we can view exactly where this is going to happen by starting up the server
    with the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过以下命令启动服务器来查看这将发生在哪里：
- en: '[PRE66]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, I''m going to head over to `localhost:3000` and open up a chat page.
    I''m going to enter `Andrew` for Display name and `LOTR` for Room name. Now once
    we''re in, we have our People list, currently it should show us, since we are
    in the room, and when a new user joins it should automatically show that user:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将前往`localhost:3000`并打开聊天页面。我将输入`Andrew`作为显示名称，`LOTR`作为房间名称。现在一旦我们进入，我们有我们的People列表，当前应该显示我们，因为我们在房间里，当一个新用户加入时，它应该自动显示该用户：
- en: '![](img/a23fef41-72e4-4105-a876-ec2dfc51fc20.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a23fef41-72e4-4105-a876-ec2dfc51fc20.png)'
- en: Right now none of this is happening, but with our new event in place it's all
    going to happen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在没有任何这些正在发生，但是有了我们的新事件，这一切都将发生。
- en: Adding People list in the chat room
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在聊天室中添加People列表
- en: Now the first thing we're going to do is figure out exactly what this event
    is going to look like. Over inside `chat.js` we can add a listener figuring out
    what works for us, what does the client really need to get this done? Then we
    can go ahead and wire up the server to fulfill those needs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的第一件事是确切地弄清楚这个事件会是什么样子。在`chat.js`中，我们可以添加一个监听器来弄清楚对我们有用的是什么，客户端真正需要做什么？然后我们可以继续连接服务器来满足这些需求。
- en: 'Right inside of `chat.js`, just below `disconnect`, we''re going to add a new
    listener, `socket.on`, and we''re going to listen for a brand new event. This
    one is going to be called `updateUserList`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 就在`chat.js`中，就在`disconnect`下面，我们将添加一个新的监听器，`socket.on`，我们将监听一个全新的事件。这个事件将被称为`updateUserList`：
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now `updateUserList` is going to need to get passed some information. We're
    going to need the list of users to show instead of the currently displayed ones,
    which means we're going to expect one argument, a `users` array. And this `users`
    array is going to just be an array of names exactly like what we returned from
    `getUserList` over inside of the `users` class.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`updateUserList`需要传递一些信息。我们需要显示用户列表而不是当前显示的用户，这意味着我们将期望一个参数，一个`users`数组。这个`users`数组将只是一个名字数组，就像我们在`users`类中返回的那样。
- en: 'Back inside of `chat.js`, for the moment, all we''re going to do is log the
    list to the screen when it comes through, `console.log(''Users list'')`, and the
    second argument will be the actual `users` array:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`chat.js`，目前，我们只是在数据通过时将列表记录到屏幕上，`console.log('Users list')`，第二个参数将是实际的`users`数组：
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Once we have this wired up, all we need to do is add some jQuery to update the
    DOM. The harder part is going to be getting an updated and up-to-date list back
    to the client.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们连接好这个，我们只需要添加一些jQuery来更新DOM。更难的部分将是将更新和最新的列表返回给客户端。
- en: Adding jQuery to update the DOM
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加jQuery来更新DOM
- en: Over inside `server.js` step one to that process is going to be to import the
    class that we've been working so hard to create. I'm going to go ahead and get
    this done, just below where we load in `isRealString.`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.js`中，这个过程的第一步是导入我们努力创建的类。我将继续完成这个，就在我们加载`isRealString`的下面。
- en: 'We can make a constant and I''m going to go ahead and pull off the `users`
    property, which is the one we export at the bottom of `users.js`, and we can import
    that using `require`. I''m going to require the local file `./`. It''s in the
    `utils` folder and this one is called `users`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个常量，我将继续使用`users`属性，这是我们在`users.js`底部导出的属性，我们可以使用`require`导入它。我将要求本地文件`./`。它在`utils`文件夹中，这个文件叫做`users`：
- en: '[PRE69]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now that we have `Users` in place we can make a new instance of it. This is
    going to be the `users` instance. We need a way to run these methods, so right
    below our `io` variable, we can make a new variable called `users` setting it
    equal to `new Users`, just like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`Users`，我们可以创建一个新的实例。这将是`users`实例。我们需要一种方法来运行这些方法，所以就在我们的`io`变量下面，我们可以创建一个名为`users`的新变量，将其设置为`new
    Users`，就像这样：
- en: '[PRE70]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now we're going to be able to call all of our user methods to add, remove, fetch,
    and otherwise manipulate that data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将能够调用所有用户方法来添加、删除、获取和否则操作数据。
- en: Adding user to the user's list
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户添加到用户列表
- en: 'The first step in the process is going to be to add a user to the list when
    they join a chatroom. We can do that right after our call to `socket.join`. I''m
    going to remove the old comments, although you can choose to keep yours around
    if you find they are a good reference. Just below `socket.join`, we''re going
    to call `users.addUser`, adding our brand new user, and we need to pass in those
    three pieces of information, the socket ID, `socket.id` is where that''s stored,
    the name, that''s on `params.name`, and finally we''re going to go ahead and pass
    in the room name, `params.room`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的第一步将是在用户加入聊天室时将用户添加到列表中。我们可以在调用`socket.join`之后立即执行。我将删除旧的注释，尽管如果您发现它们是一个很好的参考，您可以选择保留它们。在`socket.join`下面，我们将调用`users.addUser`，添加我们全新的用户，我们需要传入这三个信息，socket
    ID，存储在`socket.id`中，名称，在`params.name`上，最后我们将传入房间名，`params.room`：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now as you notice this code is not supposed to run if there is a validation
    error, meaning that the name or the room name is not provided, but currently that''s
    not the case. We don''t actually stop the function execution, I''m going to use
    `return` to make sure none of the code down below ever fires if the data is not
    valid:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您注意到，如果存在验证错误，即名称或房间名称未提供，这段代码不应该运行，但目前情况并非如此。我们实际上没有停止函数执行，我将使用`return`来确保如果数据无效，则下面的代码不会执行：
- en: '[PRE72]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Adding users with unique ID
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用唯一ID添加用户
- en: 'The next step in the process is going to be to make sure that there is already
    no user with the same ID. I''m going to call `users.removeUser` to get that done,
    passing in the only argument requires the `socket.id` just like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的下一步将是确保没有具有相同ID的用户。我将调用`users.removeUser`来完成这个任务，传入唯一的参数需要`socket.id`就像这样：
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That means that user joins the room, and we remove them from any potential previous
    rooms. Finally, we add them to the new one. Now that we have this in place we
    can actually go ahead and emit that event.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户加入房间，我们将他们从任何可能的以前的房间中移除。最后，我们将他们添加到新的房间。现在我们已经做到了这一点，我们可以继续发出那个事件。
- en: Emitting the event to the clients
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向客户端发出事件
- en: We're going to emit the event the client expects, `updateUserList` with the
    `users` array. If we don't emit the event, the client is never going to get the
    new list and we just updated the list, so we definitely want them to get a fresh
    copy. This means we want to emit an event to everyone in the chat room via `io.to`.
    We're going to pass in the room name and then we're going to call `emit`, emitting
    the event.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发出客户端期望的事件`updateUserList`，带有`users`数组。如果我们不发出事件，客户端将永远无法获得新列表，而我们刚刚更新了列表，所以我们肯定希望他们获得一个新的副本。这意味着我们希望通过`io.to`向聊天室中的每个人发出事件。我们将传入房间名，然后调用`emit`，发出事件。
- en: 'Now we can go ahead and fill out to first, we want to pass in the room name,
    `params.room` has that information, and next up we want to emit the event, the
    event name as we just defined over in `chat.js` is `updateUserList`. And the last
    thing we need to do is get the user list. We already have that, `users.getUserList`,
    passing in the name of the room we want to get the list for. Once again, `params.room`,
    that''s going to be the only argument we pass in:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续填写第一步，我们要传入房间名，`params.room`中有这个信息，接下来我们要发出事件，我们刚刚在`chat.js`中定义的事件名是`updateUserList`。我们需要做的最后一件事是获取用户列表。我们已经有了，`users.getUserList`，传入我们想要获取列表的房间名。再次，`params.room`，这将是我们传入的唯一参数：
- en: '[PRE74]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: With this call in place, we should be able to actually view this over inside
    the Terminal.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个调用，我们应该能够在终端中查看这个。
- en: I'm going to save this file, which is going to restart the server in the Terminal.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我将保存这个文件，这将在终端中重新启动服务器。
- en: Testing the users list in the chatroom
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在聊天室中测试用户列表
- en: 'Inside the browser I can open up the Developer Tools to view the `console log`
    statements, and I''m going to give the app a refresh. If I do refresh the application
    we see a `Users` list and we have `Andrew` printing twice:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我可以打开开发者工具查看`控制台日志`，然后我将刷新应用程序。如果我刷新应用程序，我们会看到一个`用户`列表，我们有`Andrew`打印两次：
- en: '![](img/7e313227-7562-4e1d-b97e-efc032137bee.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e313227-7562-4e1d-b97e-efc032137bee.png)'
- en: 'If I refresh the page for a second time, we have `Andrew` printing three times:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我第二次刷新页面，我们有`Andrew`打印三次：
- en: '![](img/7244f884-2b2e-4a86-8102-2b362a216ec8.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7244f884-2b2e-4a86-8102-2b362a216ec8.png)'
- en: As you can see this is happening because we're not removing users from the list
    when they leave the chat application. That's the second goal in this section.
    We currently have a user list. All we need to do is update it when a user leaves
    as well, that's going to happen inside of Atom down near the bottom in the `disconnect`
    listener.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这是因为当用户离开聊天应用程序时，我们没有从列表中移除用户。这是本节中的第二个目标。我们目前有一个用户列表。当用户离开时，我们只需要更新它，这将发生在`disconnect`监听器的底部附近。
- en: Removing users when they leave the chatroom
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当他们离开聊天室时移除用户
- en: 'Inside the disconnect listener, we want to remove the user and then we want
    to update the list once again. I''m going to do that by doing a few separate things.
    First up, we''re going to make a variable called `user`, storing any potentially
    removed users, remember the `removeUser` method does return the user removed,
    `users.removeUser` passing in the ID, `socket.id`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在断开连接的监听器中，我们想要移除用户，然后再次更新用户列表。我将通过几个单独的步骤来实现这一点。首先，我们将创建一个名为`user`的变量，存储任何可能被移除的用户，记住`removeUser`方法会返回被移除的用户，`users.removeUser`传入ID，`socket.id`：
- en: '[PRE75]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now we only want to do something if we actually removed a user, if the person
    hadn''t joined a room, there''s no reason to actually do anything. If a user was
    removed we are going to emit two events, and we''re going to emit them to every
    single person connected to the chatroom, which means that we''re going to be using
    `io.to().emit`, just like we did in the preceding code. We''re going to do this
    two times, so I''m going to copy this line and paste it, like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只想在实际移除用户时才执行某些操作，如果这个人没有加入房间，实际上没有理由做任何事情。如果用户被移除，我们将发出两个事件，并且我们将把它们发出给连接到聊天室的每个人，这意味着我们将使用`io.to().emit`，就像我们在前面的代码中所做的那样。我们将这样做两次，所以我将复制这行并粘贴，就像这样：
- en: '[PRE76]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Updating the users list when someone left the chatroom
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当有人离开聊天室时更新用户列表
- en: The first one is going to update the `user` list and the second one is going
    to print a little message, like `Andrew has left the room`. The first one is going
    to take the user room property as the only argument, `user.room` stores the room
    string, we're going to provide that for both, and now we can start emitting our
    events.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将更新`user`列表，第二个将打印一条小消息，比如`Andrew已经离开房间`。第一个将以用户房间属性作为唯一参数，`user.room`存储房间字符串，我们将为两者提供这个参数，现在我们可以开始发出我们的事件。
- en: 'I''m going to emit the `updateUserList` event first, inside quotes, `updateUserList`,
    and we''re going to go ahead and call the exact same method we did right up above,
    `users.getUserList`, passing in the room, `user.room`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先发出`updateUserList`事件，在引号内，`updateUserList`，然后我们将继续调用我们在上面刚刚做过的完全相同的方法，`users.getUserList`，传入房间，`user.room`：
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now when someone leaves a room they're going to be removed from that list and
    we're not going to see those duplicates that we had over inside of the web developer
    console.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当有人离开房间时，他们将从列表中被移除，我们将不再看到那些在Web开发者控制台中出现的重复。
- en: Emitting custom message
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出自定义消息
- en: 'The next thing that we want to do is emit a message. We''re going to emit a
    message from the admin to everybody, kind of like we did up above. We greeted
    the user and we told all other users that someone joined, right here we''re going
    to `emit(''newMessage'')`, and we''re going to call `generateMessage` like we''ve
    done in the past. We''re going to pass in those two arguments, the first one is
    `Admin`. This is going to be an admin message, and the second one can be a template
    string, we''re going to inject the user''s name, `user.name`, and then we''re
    going to say that user has left:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的下一件事是发出一条消息。我们将从管理员向所有人发出一条消息，就像我们在上面做的那样。我们向用户致以问候，并告诉所有其他用户有人加入了，现在我们将`emit('newMessage')`，并且我们将调用`generateMessage`，就像我们以前做过的那样。我们将传入这两个参数，第一个是`Admin`。这将是一条管理员消息，第二个可以是一个模板字符串，我们将注入用户的名字，`user.name`，然后我们将说用户已经离开：
- en: '[PRE78]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now that we have this in place everything should be working as expected. Hopefully
    over inside of Chrome we no longer get those duplicates. I''m going to give the
    page a refresh and we see we have a users list with just one user, `Andrew`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了一切应该按预期工作。希望在Chrome中我们不再看到重复的用户。我将刷新页面，我们看到用户列表只有一个用户，`Andrew`：
- en: '![](img/80b8d679-53e0-46c1-842b-3498cdb7ec5e.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80b8d679-53e0-46c1-842b-3498cdb7ec5e.png)'
- en: If I refresh the page, we no longer get the duplicates because when I leave
    I get removed and when I come back. When the page finally finishes refreshing,
    I get added. Now the same thing is going to be true if I add a new user. For the
    moment, I'm going to switch the browser to just take up half the width on my screen.
    I'm going to open up a second tab and drag that to the other half so we can view
    both of these side by side. I'm also going to open up the Developer Tools for
    this second tab, and we're going to join the exact same room.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我刷新页面，我们不再会得到重复的用户，因为当我离开时，我被移除了，当我回来时，我被添加了。当页面最终完成刷新时，我被添加了。如果我添加一个新用户，情况也是一样的。暂时，我将把浏览器切换到屏幕的一半宽度。我将打开第二个标签并将其拖到另一半，这样我们可以并排查看这两个标签。我还将打开第二个标签的开发者工具，并且我们将加入完全相同的房间。
- en: 'Let''s go to `localhost:3000`, I''m going to join as `Mike`, and the room name
    is going to be the same, `LOTR`. Now as soon as I click on Join, I should see
    an updated list in both consoles. I''m going to click on Join. Inside the right
    browser window, we get `Andrew`, `Mike`, and inside the left browser window we
    also have `Andrew`, `Mike`, which is fantastic:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去`localhost:3000`，我将以`Mike`加入，房间名将是相同的，`LOTR`。现在当我点击`加入`，我应该在两个控制台中看到更新后的列表。我将点击`加入`。在右边的浏览器窗口中，我们得到`Andrew`，`Mike`，在左边的浏览器窗口中，我们也有`Andrew`，`Mike`，这太棒了：
- en: '![](img/79533352-84c4-4905-a57f-b8a9f5082987.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79533352-84c4-4905-a57f-b8a9f5082987.png)'
- en: 'I also get a little message saying Mike has joined, that was in place earlier;
    the real test is what happens when a user leaves. I''m going to kick Andrew out
    of the chat room, and over here inside our other chat window, we have Andrew has
    left printing to the screen, and we have our new user list with just one user,
    `Mike`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我还收到一条小消息，说Mike已经加入，这是之前的情况；真正的测试是当用户离开时会发生什么。我将把Andrew踢出聊天室，在我们的另一个聊天窗口中，我们看到Andrew已经离开打印到屏幕上，我们的新用户列表只有一个用户，`Mike`：
- en: '![](img/e6dc39bb-ea14-475d-97f3-9002282eb5cb.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6dc39bb-ea14-475d-97f3-9002282eb5cb.png)'
- en: This is fantastic. We're now keeping track of users as they come and go, which
    lets us do really cool things like printing custom messages and updating the People
    list.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了。我们现在可以跟踪用户的进出，这让我们可以做一些很酷的事情，比如打印自定义消息和更新用户列表。
- en: Rendering the users name to the chatroom
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户的名字呈现到聊天室
- en: The last thing to get done is to actually render the names to the screen. Instead
    of just printing them in the console, we want to go ahead and take these names
    and add them to the list, that's going to happen over inside of our event listener
    in `server.js`. We're going to use a jQuery like we have in the past. Inside `chat.js`
    we're going to do something with those `users`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是实际将名称呈现到屏幕上。我们不只是在控制台中打印它们，我们想要将这些名称添加到列表中，这将在`server.js`的事件监听器中发生。我们将像以前一样使用jQuery。在`chat.js`中，我们将对这些`users`做一些操作。
- en: Adding a jQuery to add the users to the list
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加jQuery以将用户添加到列表中
- en: 'First up let''s go ahead and make a new jQuery element. We''re going to make
    a variable called `ol`. This is going to store a new element using jQuery. We''re
    going to create an ordered list. We''ll create that `ol` tag:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们创建一个新的jQuery元素。我们将创建一个名为`ol`的变量。这将使用jQuery存储一个新元素。我们将创建一个有序列表。我们将创建`ol`标签：
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now we need to iterate over every user doing something with that user, `users.forEach`
    is going to let us get that done. We''re going to pass in our function and inside
    of that function we can add the individual user:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要遍历每个用户并对该用户进行一些操作，`users.forEach`将让我们完成这个任务。我们将传入我们的函数，并在该函数内部添加单个用户：
- en: '[PRE80]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The argument for the function is the name, the `user` string, and all we''re
    going to do is append something to our ordered list up above. That''s going to
    be `ol.append`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数是名称，`user`字符串，我们要做的就是向上面的有序列表附加一些东西。那就是`ol.append`：
- en: '[PRE81]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now what exactly do we want to append? Well we want to append a list item,
    the list item is going to have a `text` property equal to the name and that''s
    going to get everything rendering just right. We can use jQuery to create a new
    list item by opening and closing our list item tag. Then right after the closing
    parenthesis for jQuery we are going to call `text` so we can safely set the `text`
    property equal to the user''s name:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要附加什么？我们想要附加一个列表项，列表项的`text`属性将等于名称，这样就可以正确呈现所有内容。我们可以使用jQuery通过打开和关闭列表项标签来创建一个新的列表项。然后在jQuery的关闭括号后，我们将调用`text`，这样我们可以安全地将`text`属性设置为用户的名称：
- en: '[PRE82]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now we have an updated list but it's not actually getting rendered to the screen,
    the last step is to render it by adding it to the DOM.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个更新的列表，但实际上它并没有呈现到屏幕上，最后一步是通过将其添加到DOM来呈现它。
- en: Rendering the updated People list
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 呈现更新的用户列表
- en: 'Now over inside `chat.html` we do have a place for that. It''s the `div` tag
    with an `id` of `users`, which means that we can select it, `jQuery`, the selector
    is going to start with the hash sign(`#`) since we''re selecting by ID, and we''re
    selecting `users`, then we can go ahead and actually add the list. I''m going
    to set the `html` property equal to our ordered list, `ol`, as opposed to using
    append, we don''t want to update a list, we want to completely wipe the list replacing
    it with the new version:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`chat.html`中，我们有一个地方可以放置它。这是具有`id`为`users`的`div`标签，这意味着我们可以选择它，`jQuery`，选择器将以井号(`#`)开头，因为我们是按ID选择的，我们选择`users`，然后我们可以实际添加列表。我将把`html`属性设置为我们的有序列表`ol`，而不是使用append，我们不想更新列表，我们想完全清除列表，用新版本替换它：
- en: '[PRE83]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now we can save `chat.js` and test things out.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以保存`chat.js`并测试一下。
- en: Testing the users name in the chatroom
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在聊天室中测试用户名称
- en: 'Over inside of the browser I''m going to go ahead and close the console, refresh
    the page and we see the number 1 followed by Mike:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我将关闭控制台，刷新页面，我们会看到数字1，后面是Mike：
- en: '![](img/87de5892-268f-4519-bf94-eaca35f620a7.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87de5892-268f-4519-bf94-eaca35f620a7.png)'
- en: 'Now number 1 is coming from the fact that we''re using an ordered list. If
    I add a second user we''re going to see that second user. Let''s create a second
    user, we''re going to give it a display name of `Jen`, then we''ll go to the same
    room, `LOTR`, and when we join we get a little message and we get our two users,
    and the same thing is showing up:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数字1来自于我们使用有序列表。如果我添加第二个用户，我们将看到第二个用户。让我们创建第二个用户，我们将给它一个显示名称`Jen`，然后我们将进入相同的房间`LOTR`，当我们加入时，我们会收到一条小消息，我们会得到我们的两个用户，同样的东西也显示出来：
- en: '![](img/bb5367fe-c3ff-476f-a035-defaaca28e77.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb5367fe-c3ff-476f-a035-defaaca28e77.png)'
- en: 'Now I''m going to go to the second tab and I''m going to close the first. When
    I do that your list automatically updates and we also get our message saying that
    Mike has left:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将转到第二个标签，然后关闭第一个标签。当我这样做时，您的列表会自动更新，我们还会收到消息，说Mike已经离开了：
- en: '![](img/a30ad407-5eac-41f1-957d-f8a318bf4db3.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a30ad407-5eac-41f1-957d-f8a318bf4db3.png)'
- en: With this in place we are one step closer to being complete. The messages are
    still going to everybody, they're not specific to the room, but that is something
    we're going to take care of in the next section. For now we are done. I am going
    to make a commit, it has been a little while and we do have a completed feature,
    so let's go ahead and do that.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们离完成还有一步。消息仍然发送给每个人，它们不是特定于房间的，但这是我们将在下一节中处理的事情。目前我们完成了。我将进行提交，已经过了一段时间，我们有一个完成的功能，所以让我们继续进行。
- en: Making a commit for updated users list
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为更新的用户列表做出提交
- en: 'First up, we''ll run `git status`, we have some new files as well as some existing
    ones, I''ll be using `git add .` to add all of those to the next commit. Finally,
    we can use `git commit` to actually make the commit, I''m going to use the `-m`
    flag to add our message, and right inside of quotes `Add Users class and updateUserList
    event`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将运行`git status`，我们有一些新文件以及一些现有文件，我将使用`git add .`将所有这些文件添加到下一个提交中。最后，我们可以使用`git
    commit`来实际进行提交，我将使用`-m`标志来添加我们的消息，并在引号内添加`Add Users class and updateUserList event`：
- en: '[PRE84]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We can go ahead and make this commit and push it up to GitHub, feel free to
    push to Heroku if you want, I'm going to hold off a little bit longer, everything
    should be working there as well as locally.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续进行这个提交并将其推送到GitHub，如果你愿意，可以推送到Heroku，我会再等一会儿，那里的一切应该也能正常工作。
- en: In the next section we're going to be making sure the messages, whether it's
    a text message or a location message, only gets sent to the people in the room.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将确保消息，无论是文本消息还是位置消息，只发送给房间里的人。
- en: Sending messages to room only
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只向房间发送消息
- en: 'In the last section, we wired up that People list making sure that as new users
    come and go the list gets updated. In this section, we''re going to make sure
    that our text and location messages only get sent to users in the same room. Currently,
    it gets sent to everybody. We can prove that by opening up a new connection, I''m
    going to use `Mike` and we''re going to join a different room, `The Office Fans
    works`. When I join the room you can see that the People lists are indeed correct,
    a user in one room does not update the People list for a user in another room.
    The difference though is that the text messages do not follow those rules, neither
    do the location-based messages:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们连接了People列表，确保新用户进入和离开时列表会更新。在本节中，我们将确保我们的文本和位置消息只发送给同一个房间的用户。目前，它会发送给所有人。我们可以通过打开一个新连接来证明，我将使用`Mike`，我们将加入一个不同的房间，`The
    Office Fans works`。当我加入房间时，您可以看到People列表确实是正确的，一个房间的用户不会更新另一个房间的People列表。不同的是，文本消息不遵循这些规则，基于位置的消息也不遵循这些规则：
- en: '![](img/98912105-c010-4812-94a9-a6b8615dceed.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98912105-c010-4812-94a9-a6b8615dceed.png)'
- en: We'll have a text message and a location message as well, if I go over to the
    chat app for the other room we get both of those. And this is a problem. We also
    have the name problem, currently User displays for the text message and Admin
    displays for the location message, we want to make sure to use the actual user's
    name, whether it's Jen or whether it's Andrew. In order to get that done we are
    going to need to make some changes to both `server.js`. We have our event listeners
    for `creatMessage` and `createLocationMessage`, and we're also going to be making
    some updates inside of `chat.js`, and this is actually where we're going to start.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有文本消息和位置消息，如果我转到另一个房间的聊天应用程序，我们会得到这两个消息。这是一个问题。我们还有一个名称问题，当前文本消息显示为User，位置消息显示为Admin，我们希望确保使用实际用户的名称，无论是Jen还是Andrew。为了完成这个任务，我们需要对`server.js`和`chat.js`进行一些更改，这实际上是我们要开始的地方。
- en: Updating the chat.js and server.js files
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新chat.js和server.js文件
- en: 'Currently, the name `User`, the incorrect name we see inside of the browser
    that comes from `socket.emit` function in `chat.js`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，名称`User`，我们在浏览器中看到的错误名称来自`chat.js`中的`socket.emit`函数：
- en: '[PRE85]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The client originally sent the name but this is no longer going to be the case,
    the name is stored by the server so we're going to remove this as a required property
    from `createMessage`, we're just going to be sending the text across.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端最初发送了名称，但这将不再是情况，名称由服务器存储，因此我们将从`createMessage`中删除这个必需的属性，我们只会发送文本。
- en: '[PRE86]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Now with this in place we can modify the event listener over inside of `server.js`.
    Inside `server.js`, `createMessage` takes those two properties and it stuffs them
    right in to `generateMessage`. Instead, we're going to find the user using `users.getUser`
    and we're going to do something with it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改`server.js`中的事件监听器。在`server.js`中，`createMessage`获取这两个属性，并将它们直接放入`generateMessage`中。相反，我们将使用`users.getUser`找到用户，并对其进行操作。
- en: 'Right in `createMessage` we can go ahead and delete our `console.log` statement
    for `createMessage`, and we''re going to make a variable user, setting it equal
    to `users.getUser`. This is the method we created in `users.js`, `getUser`, which
    takes the `id` parameter. We can pass in the ID `socket.id like this`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createMessage`中，我们可以删除`createMessage`的`console.log`语句，并且我们将创建一个变量user，将其设置为`users.getUser`。这是我们在`users.js`中创建的方法，`getUser`，它接受`id`参数。我们可以像这样传入ID
    `socket.id`：
- en: '[PRE87]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now we can do something with `user`. We only want to do something if a user
    actually exists, which means that we''re going to check if the user exists using
    `if` statement, and we''re also going to make sure that the text that got passed
    along was a real string, using, after `&&`, `isRealString`. We''ll then pass in
    `message.text`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以对`user`进行操作。我们只希望在用户实际存在时执行操作，这意味着我们将使用`if`语句检查用户是否存在，并确保传递的文本是真实的字符串，使用`&&`之后的`isRealString`。然后传入`message.text`：
- en: '[PRE88]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This means if someone tries to send across an empty message or just a bunch
    of spaces, it''s not going to get sent to everybody else. Now inside the `if`
    statement, all we''re going to do is actually emit the message. We know it''s
    valid so we do want to emit something, and we''re going to take `io.emit` line,
    cut it out, and paste it in `if` statement:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果有人试图发送空消息或一堆空格，它不会发送给其他人。现在在`if`语句中，我们要做的就是实际发出消息。我们知道它是有效的，所以我们确实想要发出一些东西，我们将`io.emit`行剪切出来，并粘贴到`if`语句中：
- en: '[PRE89]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now currently the `io.emit` line emits to everybody, not just the room that
    user is connected to, but we also use `message.from`. We really want to use the
    `name` property on user. We're now going to make those two changes, emit this
    event just to the room the user is connected to, and make sure to provide their
    name as opposed to `message.from`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当前的`io.emit`行会向所有人发出，而不仅仅是用户连接到的房间，但我们也使用`message.from`。我们真的想要使用用户的`name`属性。我们现在要做这两个更改，只向用户连接的房间发出此事件，并确保提供他们的名称，而不是`message.from`。
- en: Emitting event to the individual room
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向单独的房间发出事件
- en: 'First up, we want to emit to just a specific room and we know we can tack on
    a to call right in the `io.emit` line to get that done, passing in the room name,
    with access to that on the `user` object `user.room`. Now that we''re emitting
    to just the individual room, we also do want to change the name we use. Instead
    of `message.from`, we''re going to access the name on the `user` object, `user.name`,
    and there we go:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要发出到特定的房间，我们知道我们可以在`io.emit`行中添加一个调用来完成这个操作，传入房间名称，通过`user`对象`user.room`访问。现在我们只是发出到单独的房间，我们也想要更改我们使用的名称。我们将访问`user`对象上的名称，而不是`message.from`，`user.name`，就这样：
- en: '[PRE90]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now we have a much better system for sending those text messages. I''m going
    to refresh my first tab and my second tab, and we''re going to send some text
    messages around. I''m going to send the number `1` from my second tab and we do
    get Andrew and we do see the number 1:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个更好的系统来发送这些文本消息。我将刷新我的第一个标签和第二个标签，然后我们将发送一些文本消息。我将从我的第二个标签发送数字`1`，我们会看到Andrew，我们会看到数字1：
- en: '![](img/940a763e-af6b-46b6-ae6c-aae91eec9a44.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/940a763e-af6b-46b6-ae6c-aae91eec9a44.png)'
- en: 'Over inside our other tab the message is nowhere to be found because we''re
    just emitting it to users in `The Office Fans` room:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的另一个标签页中，消息无处可寻，因为我们只是将它发送给“办公室粉丝”房间的用户：
- en: '![](img/e0141c09-2445-4ec2-9565-36d339746a6a.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0141c09-2445-4ec2-9565-36d339746a6a.png)'
- en: If I try to send a message from this first tab, we're going to see it there
    with the name Jen, and the second tab also looks good; we're not seeing that message
    from Jen.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我尝试从第一个标签发送消息，我们将在那里看到它的名字是Jen，第二个标签看起来也不错；我们没有看到Jen的消息。
- en: 'Now I can go ahead and join a room again. I''m going to use the name `Mike`
    and we''re going to join `The Office Fans` one more time. When I join the room
    I do see Andrew and Mike both connected:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以继续加入一个房间。我将使用名字`Mike`，我们将再次加入`The Office Fans`。当我加入房间时，我看到Andrew和Mike都连接了：
- en: '![](img/dd895204-c18d-460d-bdb3-daab3743d7b1.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd895204-c18d-460d-bdb3-daab3743d7b1.png)'
- en: If I send a message like `Should work` I see it there, and I also see it in
    the tab of the other user connected to `The Office Fans` room. Once again it's
    not visible to someone else connected to a different room. That is all we need
    to do to get our messages sending correctly. The last thing to do is to wire that
    up for `createLocationMessage`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我发送一条消息，比如`应该工作`，我会在那里看到它，并且也会在连接到`The Office Fans`房间的其他用户的标签中看到它。再一次，它对连接到不同房间的其他人是不可见的。这就是我们需要做的一切，以确保我们的消息发送正确。最后要做的就是为`createLocationMessage`进行连接。
- en: Now as we just saw we were also able to fix the validation issue, if I try to
    hit *enter* right now, nothing happens. I don't get moved out of the box, the
    focus doesn't change and no message is sent, which is great.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们刚才看到的，我们还能够解决验证问题，如果我现在尝试按*enter*，什么也不会发生。我不会被移出框，焦点不会改变，也不会发送消息，这很好。
- en: Wiring up createLoactionMessage for individual room
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为个别房间连接createLoactionMessage
- en: Now we're going to fix `createLocationMessage`. You're going to want to find
    the user just like we do above, incase of createMessage. If there is a user you're
    going to want to emit the location to just people in the same room. Instead of
    providing `Admin` as the name you're also going to want to use the user's real
    name. We need to make sure it still gets sent to users in the same room and make
    sure it does not get sent to users in other rooms.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要修复`createLocationMessage`。你将想要像我们在上面做的那样找到用户，以防出现createMessage。如果有用户，你将想要将位置发送给同一房间的人。而不是提供`Admin`作为名称，你还将想要使用用户的真实姓名。我们需要确保它仍然发送给同一房间的用户，并确保不会发送给其他房间的用户。
- en: 'To do this one, I am going to start by fetching the user since we are going
    to need to use the information on that object. We''re going to make a variable
    user calling `users.getUser`, and we''re going to pass in that socket ID, `socket.id`.
    This is identical to the line we used above in `createMesssage`. Now we only want
    to emit a message if we do find a user, so I''m going to check if the user object
    exists. If it does, we can take `io.emit` line, cut it out, and copy it inside
    the `if` statement. If it does exist, we are going to emit `newLocationMessage`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我将首先获取用户，因为我们需要使用该对象上的信息。我们将创建一个名为user的变量，调用`users.getUser`，并传入socket
    ID，`socket.id`。这与我们在`createMesssage`中使用的行相同。现在我们只想在找到用户时发送消息，所以我要检查用户对象是否存在。如果存在，我们可以将`io.emit`行剪切出来，并将其复制到`if`语句内。如果存在，我们将发出`newLocationMessage`：
- en: '[PRE91]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now we do still need to emit it to just a specific room by adding on a call
    to `to` and passing in the room name, `user.room` stores that information, and
    last but not least we do want to update the name. Instead of sending the static
    `Admin` name, we''re going to use the user''s real name, `user.name`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们仍然需要将其发出到特定的房间，通过添加一个调用`to`并传入房间名称，`user.room`存储了那些信息，最后但并非最不重要的是我们想要更新名称。我们将使用用户的真实姓名，而不是发送静态的`Admin`名称，`user.name`：
- en: '[PRE92]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'With this in place `createLocationMessage` is now wired up to be private and
    to send across the correct information. Over inside Chrome, I''m going to go through
    my tabs one at a time giving them a refresh, and on the second tab I am going
    to be sending the location. This is going to take just a couple of seconds to
    actually fetch it, and I see it right there with the name showing up correct:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个`createLocationMessage`，现在已经连接到私人，并发送了正确的信息。在Chrome中，我将逐个刷新我的标签，然后在第二个标签上，我将发送位置。这将需要几秒钟来获取，我看到它的名字显示正确：
- en: '![](img/acf17b34-bdc3-468c-bbc2-3acee666f394.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acf17b34-bdc3-468c-bbc2-3acee666f394.png)'
- en: 'We have Andrew and we have a link to view the location inside of Google Maps.
    Now if I go to the second tab, the user who is also connected to `The Office Fans`,
    I see the exact same location message:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有Andrew，我们有一个链接，可以在Google地图中查看位置。现在，如果我转到第二个标签，也连接到`The Office Fans`的用户，我会看到完全相同的位置消息：
- en: '![](img/26922a5e-a18e-4dc4-80e3-36eab19773de.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26922a5e-a18e-4dc4-80e3-36eab19773de.png)'
- en: 'If I go to the first one, you can see that Jen does not have access to that
    message because she''s in a different room:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我去第一个，你会看到Jen无法访问那条消息，因为她在另一个房间：
- en: '![](img/610c178d-3376-4d3e-97ef-74e18c941dc5.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/610c178d-3376-4d3e-97ef-74e18c941dc5.png)'
- en: She can always share her location with anybody in her room, that happens to
    be nobody, this message is not going to show up anywhere because no one else is
    connected to `LOTR`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 她可以随时与房间里的任何人分享她的位置，但实际上没有人，这条消息不会出现在任何地方，因为没有其他人连接到`LOTR`。
- en: With that in place we are now done, our messages are private, they're only going
    to be visible to folks in the same room. Let's go ahead and wrap this one up by
    committing our changes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在完成了，我们的消息是私密的，只有在同一房间的人才能看到。让我们继续提交这些更改。
- en: Committing the individual room changes
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交单独的房间更改
- en: 'I''m going to shut down the `nodemon` server, use `clear`, and we can run `git
    status` to see what kind of changes we have:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我将关闭`nodemon`服务器，使用`clear`，然后我们可以运行`git status`来查看我们有什么样的更改：
- en: '![](img/494fbbcd-6e75-4209-9e78-e3af2d70bcaf.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/494fbbcd-6e75-4209-9e78-e3af2d70bcaf.png)'
- en: 'Here we just have two files. They''re modified, which means we can use `git
    commit` with the `-am` flag, whether it''s separate or the same they have identical
    feature sets, and then we provide our message string, `Send messages to only people
    in same room`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们只有两个文件。它们被修改了，这意味着我们可以使用`git commit`和`-am`标志，无论是分开还是相同，它们都有相同的功能集，然后我们提供我们的消息字符串，`只向同一房间的人发送消息`：
- en: '[PRE93]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: With this in place we can go ahead and use `git push` to push this up to GitHub,
    and I'm also going to go ahead and deploy to Heroku using `git push heroku master`.
    Once it's deployed on Heroku, we can take just a quick moment to make sure all
    of those features we just added are still working as expected. I expect they will
    still work but it's definitely worth checking out because the environments are
    a little different and there's always a chance something can go wrong.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们可以继续使用`git push`将其推送到GitHub，我还将使用`git push heroku master`将其部署到Heroku。一旦在Heroku上部署完成，我们可以花一点时间来确保我们刚刚添加的所有这些功能仍然按预期工作。我期望它们仍然可以工作，但肯定值得检查，因为环境有些不同，总是有可能出错。
- en: 'Now if something does go wrong, as a reminder you can always use `heroku logs`,
    this is going to show you the logs on the server, it''s usually kind of cryptic
    but when an error occurs you''re going to see a really big block. It''s usually
    pretty easy to spot and it usually contains useful information as to what went
    wrong:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果出现问题，提醒一下，你总是可以使用`heroku logs`，这将显示服务器上的日志，通常有点神秘，但当出现错误时，你会看到一个非常大的块。通常很容易发现，通常包含有用的信息，说明出了什么问题：
- en: '![](img/d0e11bc9-b0fc-4b21-9656-d4871c8e964a.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0e11bc9-b0fc-4b21-9656-d4871c8e964a.png)'
- en: 'It looks like our app deployed successfully, so I can use `heroku open` to
    open it up inside my browser, and once it''s open we can actually visit some chat
    rooms. I''m going to close down my localhost tab and I''m going to join as `Andrew`,
    the room `Philadelphia`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的应用成功部署了，所以我可以使用`heroku open`在浏览器中打开它，一旦打开，我们实际上可以访问一些聊天室。我将关闭我的本地主机标签，然后以`Andrew`的身份加入房间`Philadelphia`：
- en: '![](img/b5920ceb-3354-4ee7-95c0-135a8393a6d9.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5920ceb-3354-4ee7-95c0-135a8393a6d9.png)'
- en: 'Once I''m in the room, I am going to send a message, and then I''m going to
    add a second user to the room. We want to visit our Heroku app website. I''m going
    to visit that, we''ll join the room as `Vikram`, and we can join the exact same
    room `Philadelphia`. When I join, I see the People list updates for both and sending
    messages does still work:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我进入房间，我会发送一条消息，然后我会将第二个用户添加到房间。我们想访问我们的Heroku应用网站。我将访问那个，我们将以`Vikram`的身份加入房间，我们可以加入完全相同的房间`Philadelphia`。当我加入时，我看到人员列表对两者都进行了更新，并且发送消息仍然有效：
- en: '![](img/abb82a8b-9020-4ea3-976a-42be923d7ccb.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abb82a8b-9020-4ea3-976a-42be923d7ccb.png)'
- en: Messages from the second tab do appear in first tab, this is great. All this
    is possible because we wired up `server.js`, keeping track of users over time.
    When they first join we add them to the list, when they send messages we make
    sure to use their information, and when they leave we remove them from the list.
    This ensures that the People list is always up to date and that messages are only
    getting sent to others in the same room.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个标签页的消息确实出现在第一个标签页中，这很好。所有这些都是可能的，因为我们已经连接了`server.js`，随时跟踪用户。当他们第一次加入时，我们将他们添加到列表中，当他们发送消息时，我们确保使用他们的信息，当他们离开时，我们将他们从列表中移除。这确保了人员列表始终是最新的，并且消息只发送给了同一房间的其他人。
- en: New feature ideas
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新功能点子
- en: Now that we have our People list in place and our messages are only getting
    sent to the users in the same chatroom, we are done. But that doesn't mean you
    have to stop developing the chat app, students always like to add on new features.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的人员列表，并且我们的消息只发送给了同一聊天室的用户，我们完成了。但这并不意味着你必须停止开发聊天应用，学生们总是喜欢添加新功能。
- en: I'd like to give you a few ideas as to what you can build right now. You might
    get stuck while adding these features. It might be a real pain in the neck and
    it might take forever, but I promise you're going to learn so much along the way
    when you're doing something on your own. Now you have all the skills to do these
    features so let's just go down the list really quick.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我想给你一些关于你现在可以构建的想法。在添加这些功能时，你可能会遇到困难。这可能会非常痛苦，可能需要很长时间，但我向你保证，在你自己做事情的过程中，你会学到很多。现在你有了所有的技能来做这些功能，所以让我们快速地按照列表进行。
- en: One awesome idea would be to make chatrooms case-insensitive. Currently, if
    I go to `LOTr` with a lowercase `r`, I'm not actually in the same chatroom as
    my friend who's in `LOTR` uppercase `R`. It would be nice if regardless of case
    we were all in the same room.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个很棒的想法是使聊天室不区分大小写。目前，如果我以小写`r`去`LOTr`，我实际上并不在与我朋友在`LOTR`大写`R`中的同一个聊天室。不管大小写如何，我们都在同一个房间中会很好。 '
- en: 'Next up, I''d like to make usernames unique. Currently, I can copy the URL
    and paste it in a new tab, and now I have two people with the name of Jules:'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我想让用户名唯一。目前，我可以复制URL并粘贴到新标签页中，现在我有两个名为Jules的人：
- en: '![](img/23488be5-dfa2-4487-8987-83fe4a1e7ccd.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23488be5-dfa2-4487-8987-83fe4a1e7ccd.png)'
- en: It would be cool to reject new users who also have the same name as an existing
    user.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝具有与现有用户相同名称的新用户将是很酷的。
- en: Next up, one idea is to add a list of the currently active chatrooms down below.
    This could be a select drop-down, it's going to repopulate kind of like the People's
    list repopulates.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，一个想法是在下面添加当前活动聊天室的列表。这可以是一个下拉选择，它将重新填充，类似于People列表的重新填充。
- en: This is by far the hardest feature but I think it would be really cool. That
    means I would see a drop-down between the Join button and the Room name input
    box, and it would have the two currently active rooms, `LOTr` and `LOTR` with
    an uppercase R, although hopefully if you implement that first feature we would
    only see one room. Then instead of typing in a `room` name, I could just pick
    one from the drop-down, type in a name and join that way.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这绝对是最难的功能，但我认为这将非常酷。这意味着我会在加入按钮和房间名称输入框之间看到一个下拉菜单，其中将列出两个当前活动的房间，`LOTr`和`LOTR`，尽管希望如果您首先实现了第一个功能，我们只会看到一个房间。然后，我可以从下拉菜单中选择一个，输入一个名称并以这种方式加入。
- en: These are just a few ideas of how you can continue on with the chat app.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些关于如何继续使用聊天应用程序的想法。
- en: Summary
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how we can create classes in ES6 using the `class`
    keyword. We made a `Person` class, which was just an example, and we made our
    `Users` class, which we'll actually be using throughout the book. We looked at
    adding custom methods as well as setting up our `constructor` function. Then,
    we created `removeUser`, `getUser`, and `getUserList` methods in the similar manner.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何在ES6中使用`class`关键字创建类。我们创建了一个`Person`类，这只是一个例子，然后我们创建了我们将在整本书中实际使用的`Users`类。我们看了如何添加自定义方法以及设置我们的`constructor`函数。然后，我们以类似的方式创建了`removeUser`、`getUser`和`getUserList`方法。
- en: Next, we looked into wiring up the `users` class we created and updated the
    `People` list when a user joins or left the chatroom. Then we looked into sending
    messages to a particular room and not to all the users. At last, we added a few
    ideas, which you can look into to enhance the features of the chatroom.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了如何连接我们创建的`users`类，并在用户加入或离开聊天室时更新`People`列表。然后我们研究了如何向特定房间发送消息，而不是向所有用户发送。最后，我们添加了一些想法，您可以查看以增强聊天室的功能。
- en: In the chapter, we are going to learn about Async/Await project setup.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习有关Async/Await项目设置的内容。
