- en: Working with Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与类型一起工作
- en: In the preceding chapter, we learned some basic concepts about the TypeScript
    type system, including the basics about the type inference system and the optional
    static type annotations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 TypeScript 类型系统的一些基本概念，包括类型推断系统的基础知识和可选的静态类型注解。
- en: 'In this chapter, you will learn about the main features of the TypeScript type
    system, including the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习 TypeScript 类型系统的主要功能，包括以下概念：
- en: The line between TypeScript and JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 和 JavaScript 之间的界限
- en: The features of the type system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型系统的功能
- en: Union types, intersection types, and discriminated unions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合类型、交叉类型和区分联合
- en: Type aliases and local types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名和局部类型
- en: The `typeof` and `keyof` operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typeof` 和 `keyof` 操作符'
- en: Control flow analysis and type guards
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流分析和类型守卫
- en: Non-nullable types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非空类型
- en: Generic types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Mapped types, lookup types, and conditional types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射类型、查找类型和条件类型
- en: The TypeScript type system's characteristics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 类型系统的特点
- en: In this section, we are going to learn about the main characteristics of the
    TypeScript type system, including concepts such as type inference, optional type
    annotation, and the differences between a nominal type system and a structural
    type system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 TypeScript 类型系统的主要特点，包括类型推断、可选类型注解以及名义类型系统和结构类型系统之间的差异等概念。
- en: The line between TypeScript and JavaScript
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 和 JavaScript 之间的界限
- en: 'One of the most important things that you are going to need to master to become
    a good TypeScript programmer is to be able to understand where TypeScript ends
    and JavaScript begins. It is very important to be able to understand what happens
    with our TypeScript code at three important phases:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一名优秀的 TypeScript 程序员，你需要掌握的最重要的事情之一是理解 TypeScript 和 JavaScript 之间的界限。了解我们的
    TypeScript 代码在三个重要阶段发生的事情非常重要：
- en: '**Design time**: This takes place when we are writing our TypeScript code and
    designing our application.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计时间**：这发生在我们编写 TypeScript 代码和设计应用程序时。'
- en: '**Compilation time**: This takes place when we compile our TypeScript into
    JavaScript code (some compilation errors may take place). Compilation time has
    subphases, such as parsing the TypeScript code, creating an abstract syntax tree
    (ATS), and emitting JavaScript code.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时间**：这发生在我们将 TypeScript 编译成 JavaScript 代码时（可能会出现一些编译错误）。编译时间包含子阶段，例如解析
    TypeScript 代码、创建抽象语法树（ATS）和生成 JavaScript 代码。'
- en: '**Execution time** (also known as runtime): This takes place when we execute
    the output JavaScript code generated by the TypeScript compiler.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行时间**（也称为运行时）：这发生在我们执行 TypeScript 编译器生成的输出 JavaScript 代码时。'
- en: The TypeScript types are declared or inferred at design time and used during
    compilation time, but they are not available at execution time because they are
    not part of JavaScript.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 类型在设计时声明或推断，并在编译时使用，但它们在执行时不可用，因为它们不是 JavaScript 的一部分。
- en: In this chapter, we are going to learn about many of the TypeScript type system
    features. If you are familiar with JavaScript, you will notice the differences
    straight away but, if you are not familiar with JavaScript, I would recommend
    examining the generated JavaScript output after compiling the code samples included
    in this chapter. Over time, you will slowly earn the experience required to have
    a clear vision of the line between TypeScript and JavaScript.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 TypeScript 类型系统的许多功能。如果你熟悉 JavaScript，你将立即注意到差异，但如果你不熟悉 JavaScript，我建议你在编译本章中包含的代码示例后检查生成的
    JavaScript 输出。随着时间的推移，你将逐渐获得对 TypeScript 和 JavaScript 之间界限的清晰视野。
- en: Please refer to [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding
    the Runtime*, to learn more about the execution time phase (JavaScript).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第 6 章](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml)，*理解运行时*，了解更多关于执行时间阶段（JavaScript）的信息。
- en: Type inference
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'TypeScript tries to find the types of the variables and objects in our application
    using what is known as **type inference**. When we declare a variable, TypeScript
    will try to observe the value assigned to the variables in the application to
    identify its type. Let''s examine some examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 尝试使用所谓的 **类型推断** 来查找我们应用程序中变量和对象的数据类型。当我们声明一个变量时，TypeScript 将尝试观察分配给应用程序中变量的值以确定其类型。让我们看看一些例子：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The type of the variable `myVariable1` is inferred as a number.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `myVariable1` 的类型被推断为数字。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The type of the variable `myVariable2` is inferred as a string.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `myVariable2` 的类型被推断为字符串。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The type of the variable `myVariable3` is inferred as the following type:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `myVariable3` 的类型被推断为以下类型：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The type any is assigned in the cases in which TypeScript is not able to identify
    the type of a variable. For example, given the following function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TypeScript 无法识别变量类型时，会分配 `any` 类型。例如，给定以下函数：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The type of the function `add` is inferred as the following type:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `add` 的类型被推断为以下类型：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The type `any` is problematic because it prevents the TypeScript compiler from
    identifying many potential errors. Fortunately, TypeScript features optional type
    annotations that can be used to solve this problem.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `any` 是一个问题，因为它阻止 TypeScript 编译器识别许多潜在的错误。幸运的是，TypeScript 具有可选的类型注释功能，可以用来解决这个问题。
- en: Optional static type annotations
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选静态类型注释
- en: TypeScript allows us to use type annotations to overcome the scenarios in which
    the type inference system is not powerful enough to automatically detect the type
    of a variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许我们使用类型注释来克服类型推断系统不足以自动检测变量类型的情况。
- en: 'Let''s consider the `add` function one more time:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑 `add` 函数：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The type of the function `add` is inferred as the following type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `add` 的类型被推断为以下类型：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding type is a problem because the usage of the `any` type effectively
    prevents the TypeScript compiler from detecting certain errors. For example, we
    might expect the `add` function to add two numbers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类型是一个问题，因为 `any` 类型的使用实际上阻止了 TypeScript 编译器检测某些错误。例如，我们可能期望 `add` 函数添加两个数字：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, if we pass a string as input, we will encounter an unexpected result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们传递一个字符串作为输入，我们将遇到一个意外的结果：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding error can happen very easily if, for example, the arguments provided
    to the `add` function have been extracted from an HTML input and we forget to
    parse them as a number.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，例如，提供给 `add` 函数的参数是从 HTML 输入中提取的，而我们忘记将它们解析为数字，那么前面的错误可能会非常容易发生。
- en: 'We can fix the `add` function by adding optional type annotations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加可选的类型注释来修复 `add` 函数：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can add an optional type annotation by adding a colon (`:`) after the declaration
    of a variable followed by the type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在变量声明后添加一个冒号（`:`）来添加一个可选的类型注释：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the case of functions, we can add annotations to the arguments of the function
    and its returned value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的情况下，我们可以为函数的参数及其返回值添加注释。
- en: 'Now that the type of the arguments of the `add` function are `number`, instead
    of `any`, the TypeScript compiler will be able to detect potential issues if we
    provide arguments of the `worn` type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于 `add` 函数的参数类型是 `number` 而不是 `any`，TypeScript 编译器将能够检测如果我们提供 `worn` 类型的参数时可能出现的潜在问题：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In general, we should try to leverage the type inference system and use optional
    static type annotations only when the type inference system is not powerful enough
    to automatically detect the type of a variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们应该尝试利用类型推断系统，并且只在类型推断系统不足以自动检测变量类型时才使用可选的静态类型注释。
- en: Structural type system
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化类型系统
- en: In the type system of a programming language, a type is an object with a name
    and a structure. Some types have very simple data structures (such as primitives)
    while others use complex structures (such as classes).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言的类型系统中，类型是一个具有名称和结构的对象。一些类型具有非常简单的数据结构（例如原始类型），而其他类型则使用复杂结构（例如类）。
- en: 'The type system can use two different strategies to validate that a given value
    matches the desired type:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统可以使用两种不同的策略来验证给定的值是否与期望的类型匹配：
- en: '**Nominal type system**: In this type system, values are matched against a
    type by its name'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名义类型系统**：在这个类型系统中，值是通过其名称与其类型匹配的'
- en: '**Structural type system**: In this type system, values are matched against
    a type by its structure'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化类型系统**：在这个类型系统中，值是通过其结构与其类型匹配的'
- en: 'The TypeScript type system is a structural type system because the values are
    matched against a type by its structure, as the following code snippet demonstrates:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 类型系统是一个结构化类型系统，因为值是通过其结构与其类型匹配的，如下代码片段所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code snippet, we can observe how the first two calls to the
    `getFullName` function are successful because the structure (properties and types)
    of both the `Employer` instance and the object literal match the structure of
    the `Person` interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以观察到前两次调用 `getFullName` 函数是成功的，因为 `Employer` 实例和对象字面量的结构（属性和类型）与
    `Person` 接口的结构相匹配。
- en: 'The following code snippet showcases how TypeScript would work if it used a
    nominal type system:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如果 TypeScript 使用命名类型系统，它将如何工作：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first call to `getFullName` works because the `Employer` class implements
    the `Person` interface, and the name of the type of the interface can then be
    matched against the name of the type of the function argument.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `getFullName` 是有效的，因为 `Employer` 类实现了 `Person` 接口，然后接口的类型名称可以与函数参数的类型名称相匹配。
- en: The TypeScript team is currently investigating the possibility of potentially
    adding support for a nominal type system as well. You can learn more about the
    progress at [https://github.com/Microsoft/TypeScript/issues/202](https://github.com/Microsoft/TypeScript/issues/202)*.*
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 团队目前正在调查可能添加对命名类型系统支持的可能性。您可以在 [https://github.com/Microsoft/TypeScript/issues/202](https://github.com/Microsoft/TypeScript/issues/202)*.*
    了解更多关于进展情况。
- en: Core features of the TypeScript type system
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 类型系统的核心功能
- en: In this section, we are going to learn about some of the core features of the
    TypeScript type system. This includes concepts such as union types, intersection
    guards, type guards, and type aliases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 TypeScript 类型系统的核心功能。这包括联合类型、交集守卫、类型守卫和类型别名等概念。
- en: Union types
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型
- en: 'TypeScript allows you to declare union types:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许你声明联合类型：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we have declared a variable named `path` that can
    contain a single path (string) or a collection of paths (array of strings). In
    the example, we have also set the value of the variable. We assigned a string
    and an array of strings without errors; however, when we attempted to assign a
    numeric value, we got a compilation error, because the union type didn't declare
    a number as one of the valid types of the variable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们声明了一个名为 `path` 的变量，它可以包含单个路径（字符串）或路径集合（字符串数组）。在示例中，我们还设置了变量的值。我们分配了一个字符串和一个字符串数组而没有错误；然而，当我们尝试分配一个数值时，我们得到了编译错误，因为联合类型没有将数字声明为变量的有效类型之一。
- en: 'Union types are used to declare a variable that can store a value of two or
    more types. Only the properties available in all the types present in the intersection
    type are considered valid:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型用于声明一个可以存储两种或更多类型值的变量。只有存在于交集类型中的所有类型中可用的属性才被认为是有效的：
- en: '![](img/8b061ccf-0238-48be-acee-3f26eb3689d5.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b061ccf-0238-48be-acee-3f26eb3689d5.png)'
- en: 'We can appreciate this behavior in the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中欣赏这种行为：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Type aliases
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'TypeScript allows us to declare type aliases by using the `type` keyword:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许我们使用 `type` 关键字声明类型别名：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Type aliases are exactly the same as their original types; they are simply alternative
    names. Type aliases can help us to make our code more readable, but it can also
    lead to some problems.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名与其原始类型完全相同；它们只是替代名称。类型别名可以帮助我们使代码更易于阅读，但也可能导致一些问题。
- en: If you work as part of a large team, the indiscriminate creation of aliases
    can lead to maintainability problems. The book *Maintainable JavaScript*, *Nicholas
    C. Zakas* recommends that you *"avoid modifying the objects you don't own"*. Nicholas
    was talking about adding, removing, or overriding methods in objects that have
    not been declared by you (DOM objects, BOM objects, primitive types, and third-party
    libraries), but we can apply this rule to the use of aliases as well.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你作为大型团队的一部分工作，无差别地创建别名可能会导致可维护性问题。尼古拉斯·C·扎卡斯（Nicholas C. Zakas）的书籍《可维护的 JavaScript》建议你应
    *"避免修改你不拥有的对象"*. 尼古拉斯在谈论添加、删除或覆盖你未声明的对象（DOM 对象、BOM 对象、原始类型和第三方库）中的方法，但我们可以将此规则也应用于别名使用。
- en: Intersection types
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交集类型
- en: 'When Anders Hejlsberg added intersection types to TypeScript for the first
    time, he defined them as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当安德斯·海尔斯伯格（Anders Hejlsberg）首次将交集类型添加到 TypeScript 中时，他这样定义它们：
- en: '"Intersection types are the logical complement of union types. A union type
    A | B represents an entity that has either type A or type B, whereas an intersection
    type A & B represents an entity that has both type A and type B."'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '"交集类型是联合类型的逻辑补集。联合类型 A | B 表示一个实体具有类型 A 或类型 B，而交集类型 A & B 表示一个实体同时具有类型 A 和类型
    B。"'
- en: 'The following example declares three interfaces named `A`, `B`, and `C`. Then
    it declares an object named `abc`, whose type is the intersection type of the
    interfaces `A`, `B`, and `C`. As a result, the `abc` object has properties named
    `a`, `b`, and `c`, but not `d`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例声明了三个接口名为 `A`、`B` 和 `C`。然后它声明了一个名为 `abc` 的对象，其类型是接口 `A`、`B` 和 `C` 的交集类型。因此，`abc`
    对象具有名为 `a`、`b` 和 `c` 的属性，但没有 `d`：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Intersection types can also be applied to subproperties:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 交集类型也可以应用于子属性：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'They can also be applied to functions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以应用于函数：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The properties available in one or all the types present in the intersection
    type are considered valid:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在交集类型中存在的一个或所有类型中的属性被认为是有效的：
- en: '![](img/39abf20c-3de5-49c2-9610-b46b9ac87d79.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39abf20c-3de5-49c2-9610-b46b9ac87d79.png)'
- en: 'We can appreciate this behavior in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中欣赏这种行为：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Non-nullable types
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非空类型
- en: TypeScript 2.0 introduced what are known as non-nullable types. TypeScript used
    to consider null and undefined to be valid values of every type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 2.0 引入了所谓的非空类型。TypeScript 以前将 `null` 和 `undefined` 视为每种类型的有效值。
- en: 'The following diagram represents the values that can be assigned to the type
    number when non-nullable types are disabled:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示当禁用非空类型时可以分配给数字类型的值：
- en: '![](img/a26d29c5-8b7e-4eba-89dd-163e4605358d.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a26d29c5-8b7e-4eba-89dd-163e4605358d.png)'
- en: As we can see in the preceding diagram, `undefined` and `null` are allowed as
    values of the type number, together with the `NaN` value and all the possible
    numbers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`undefined` 和 `null` 被允许作为数字类型的值，包括 `NaN` 值和所有可能的数字。
- en: NaN, standing for not a number, is a numeric data type value representing an
    undefined or non-representable value, especially in floating-point calculations.
    Systematic use of NaNs was introduced by the IEEE 754 floating-point standard
    in 1985, along with the representation of other non-finite quantities such as
    infinities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: NaN，代表“不是一个数字”，是一种数值数据类型值，表示未定义或无法表示的值，尤其是在浮点数计算中。1985年，IEEE 754 浮点标准引入了 NaN
    的系统使用，以及表示其他非有限数量（如无穷大）的表示。
- en: 'The following code snippet demonstrates how `undefined` and `null` are allowed
    as values of the type number when non-nullable types are disabled:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了当禁用非空类型时，`undefined` 和 `null` 被允许作为数字类型的值：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The same can be said about all other types:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于所有其他类型：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When non-nullable types are enabled, the values `null` and `undefined` are
    considered independent types and stop being considered as valid values of the
    type number:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用非空类型时，值 `null` 和 `undefined` 被视为独立类型，并停止被视为数字类型的有效值：
- en: '![](img/a785a982-e504-42b5-b136-735465473c16.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a785a982-e504-42b5-b136-735465473c16.png)'
- en: 'The following code snippet demonstrates how `undefined` and `null` are not
    allowed as values of the type number when non-nullable types are enabled:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了当启用非空类型时，`undefined` 和 `null` 不被允许作为数字类型的值：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The same can be said about all other types:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于所有其他类型：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can enable non-nullable types by using the `**--**strictNullChecks` compilation
    flag:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `**--**strictNullChecks` 编译标志来启用非空类型：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When non-nullable types are enabled, we can use union types to create nullable
    versions of a type:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用非空类型时，我们可以使用联合类型来创建类型的可空版本：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The --strict mode
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --严格模式
- en: 'TypeScript allows us to use the `--strict` compilation flag to enable all strict
    type checking options. Enabling `--strict` enables `--noImplicitAny`, `--noImplicitThis`,
    `--alwaysStrict`, `--strictPropertyInitialization`, and `--strictNullChecks`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 允许我们使用 `--strict` 编译标志来启用所有严格类型检查选项。启用 `--strict` 启用 `--noImplicitAny`、`--noImplicitThis`、`--alwaysStrict`、`--strictPropertyInitialization`
    和 `--strictNullChecks`：
- en: The `--strictNullChecks` compilation flag enables non-nullable types.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strictNullChecks` 编译标志启用了非空类型。'
- en: The `--noImplicitAny` flag forces us to explicitly declare the type of a variable
    when the type inference system is not able to automatically infer the correct
    type.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--noImplicitAny` 标志强制我们在类型推断系统无法自动推断正确类型时显式声明变量的类型。'
- en: The `--alwaysStrict` flag forces the TypeScript parse to use the strict mode.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--alwaysStrict` 标志强制 TypeScript 解析器使用严格模式。'
- en: The `--noImplicitThis` flag forces us to explicitly declare the type of the
    this operator in functions when the type inference system is not able to automatically
    infer the correct type.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--noImplicitThis` 标志强制我们在类型推断系统无法自动推断正确类型时，在函数中显式声明 `this` 操作符的类型。'
- en: The `--strictPropertyInitialization` flag forces class properties to be initialized.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strictPropertyInitialization` 标志强制类属性必须初始化。'
- en: We will learn more about the JavaScript use strict and the this operator in
    [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the Runtime*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 6 章 [理解运行时](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml)，*理解运行时* 中了解更多关于
    JavaScript 严格模式和 `this` 操作符的内容。
- en: Using the `--strict` compilation flag makes the TypeScript compiler much stricter.
    Enabling this option in existing large TypeScript projects can lead to the discovery
    of many errors that may require a significant effort to fix. For this reason,
    it is recommended to enable the `--strict` compilation flag in greenfield TypeScript
    projects and enable the individual flags (`--noImplicitAny`, `--noImplicitThis`,
    `--alwaysStrict`, and `--strictNullChecks`) progressively in existing TypeScript
    projects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--strict` 编译标志会使 TypeScript 编译器更加严格。在现有的大型 TypeScript 项目中启用此选项可能会导致发现许多可能需要大量努力修复的错误。因此，建议在绿色场
    TypeScript 项目中启用 `--strict` 编译标志，并在现有的 TypeScript 项目中逐步启用单个标志（`--noImplicitAny`、`--noImplicitThis`、`--alwaysStrict`
    和 `--strictNullChecks`）。
- en: The `--noImplicitReturns` compilation flag is not one of the flags enabled by
    the `--strict` flag. The flag throws an error when not all code paths in function
    return a value. It is also recommended that you enable this flag in greenfield
    TypeScript projects or when possible on existing projects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`--noImplicitReturns` 编译标志不是由 `--strict` 标志启用的标志之一。当函数中不是所有代码路径都返回值时，该标志会抛出错误。也建议在绿色场
    TypeScript 项目中启用此标志或在可能的情况下在现有项目中启用。'
- en: The typeof operator
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`typeof` 操作符'
- en: 'The `typeof` operator can be used at runtime (JavaScript):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 操作符可以在运行时（JavaScript）使用：'
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It is important to note that it can also be used at design time (TypeScript)
    only:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，它也可以在设计时（TypeScript）使用：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Type guards
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型守卫
- en: 'We can examine the type of an expression at runtime by using the `typeof` or
    `instanceof` operators. The TypeScript language service looks for these operators
    and will narrow down the inferred type accordingly when used in an `if` block:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `typeof` 或 `instanceof` 操作符在运行时检查表达式的类型。TypeScript 语言服务会查找这些操作符，并在
    `if` 块中使用时相应地缩小推断类型：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code snippet, we have declared a variable named `x` of type
    `any`. Later, we check the type of `x` at runtime by using the `typeof` operator.
    If the type of `x` results to be a string, we will try to invoke the method `splice`,
    which is supposed to be a member of the `x` variable. The TypeScript language
    service can understand the usage of `typeof` in a conditional statement. TypeScript
    will automatically assume that `x` must be a string and let us know that the `splice`
    method does not exist on the type string. This feature is known as **type guards**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个名为 `x` 的 `any` 类型变量。稍后，我们通过使用 `typeof` 操作符在运行时检查 `x` 的类型。如果
    `x` 的类型结果是字符串，我们将尝试调用 `splice` 方法，该方法应该是 `x` 变量的一个成员。TypeScript 语言服务可以理解在条件语句中使用
    `typeof` 的用法。TypeScript 会自动假设 `x` 必须是字符串，并通知我们 `splice` 方法在字符串类型上不存在。这个特性被称为 **类型守卫**。
- en: Custom type guards
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义类型守卫
- en: 'We can define custom type guards using by declaring a function with a special
    return type:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过声明一个具有特殊返回类型的函数来定义自定义类型守卫：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code snippet declares two types (`Supplier` and `Customer`); it
    then declares a custom type guard function. The custom type guard returns a Boolean
    value. The function returns true when the provided value `person` has a property
    named `orderItems` and false when the property is missing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段声明了两种类型（`Supplier` 和 `Customer`）；然后声明了一个自定义类型守卫函数。自定义类型守卫返回一个布尔值。当提供的值
    `person` 有名为 `orderItems` 的属性时，函数返回 true，当属性缺失时返回 false。
- en: The function is trying to identify the type at runtime by examining the properties
    of the value. This kind of type matching is known as **pattern matching**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过检查值的属性来尝试在运行时识别类型。这种类型匹配称为 **模式匹配**。
- en: We will learn more about pattern matching in [Chapter 7](72a4e9e7-a9ca-476d-bd54-f8dc5f76dafe.xhtml),
    *Functional Programming with TypeScript*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 7 章 [使用 TypeScript 的函数式编程](72a4e9e7-a9ca-476d-bd54-f8dc5f76dafe.xhtml)
    中了解更多关于模式匹配的内容。
- en: 'Pattern matching is not the only technique that we can use to identify if a
    value matches a type. We can also use the `instanceof` operator:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配不是我们用来识别值是否匹配类型的唯一技术。我们还可以使用 `instanceof` 运算符：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another technique that we can use to identify if a value matches a type is
    to use the `typeof` operator:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `typeof` 运算符作为识别值是否匹配类型的另一种技术：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code snippet throws a compilation error within the `if` block
    because TypeScript knows that the variable `x` must be a string within the block.
    Another error is thrown outside of the `if` block, because TypeScript cannot guarantee
    that the type of the variable x is string at that point.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段在 `if` 块内抛出编译错误，因为 TypeScript 知道变量 `x` 在该块内必须是字符串。在 `if` 块外部也会抛出另一个错误，因为
    TypeScript 无法保证在那个点变量 `x` 的类型是字符串。
- en: 'Since TypeScript 2.7, we can use the `in` operator as a type guard to narrow
    down a given type, as demonstrated by the following example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自 TypeScript 2.7 版本以来，我们可以使用 `in` 运算符作为类型守卫来缩小给定类型，如下面的示例所示：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Control flow analysis
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流分析
- en: TypeScript includes a feature known as control flow analysis that is used to
    identify the type of a variable, based on the execution flow of a program. This
    feature allows TypeScript to have more precise type inference capabilities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 包含一个称为控制流分析的功能，用于根据程序的执行流程识别变量的类型。此功能使 TypeScript 具有更精确的类型推断能力。
- en: 'The following example defines a function that takes two arguments, and the
    type of one of them (named value) is the union type of number and array of number:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一个函数，它接受两个参数，其中一个参数（命名为 value）的类型是数字和数字数组的联合类型：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Within the body of the function, we use an `if` statement to determine if the
    value variable is indeed an array of numbers or just a number. The type inference
    system will change the inferred type of the argument to match the correct type
    accordingly with the two paths of the `if...else` statement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内部，我们使用 `if` 语句来确定值变量确实是一个数字数组还是仅仅是一个数字。类型推断系统将根据 `if...else` 语句的两个路径相应地更改参数的推断类型。
- en: Control flow analysis improves the type checker's understanding of variable
    assignments and control flow statements, thereby greatly reducing the need for
    type guards.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流分析提高了类型检查器对变量赋值和控制流语句的理解，从而大大减少了类型守卫的需求。
- en: Literal types
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文字类型
- en: 'Literal types allow us to declare the exact value that a string Boolean or
    number must have. When we declare a variable using the `let` keyword, its value
    will be inferred as a primitive type:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 文字类型允许我们声明一个字符串、布尔值或数字必须具有的确切值。当我们使用 `let` 关键字声明一个变量时，其值将被推断为原始类型：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, if we use the `const` keyword, the type is inferred as the actual
    assigned value:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用 `const` 关键字，类型将被推断为实际分配的值：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Literal types can be used in combination with union types, type guards, and
    type aliases with ease:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 文字类型可以轻松与联合类型、类型守卫和类型别名结合使用：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Literal types can be used in combination with type guards and the power of control
    flow analysis to narrow union types using a technique known as discriminated unions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 文字类型可以与类型守卫和控制流分析的力量结合使用，通过称为区分联合的技术来缩小联合类型。
- en: Discriminated unions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分联合
- en: A discriminated union (also known as tagged unions or algebraic data types)
    is an advanced pattern that combines string literal types, union types, type guards,
    and types aliases.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合（也称为标签联合或代数数据类型）是一种高级模式，它结合了字符串文字类型、联合类型、类型守卫和类型别名。
- en: Discriminated unions use a type guard to narrow union types based on tests of
    a discriminant property (a string literal type) and furthermore extend that capability
    to switch statements.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 区分联合使用类型守卫根据判别属性（一个字符串文字类型）的测试来缩小联合类型，并且进一步扩展了该功能到 `switch` 语句。
- en: 'The following code snippet declares three types that share a string literal
    property named `kind`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了三个共享名为 `kind` 的字符串文字属性的类型：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then declare the union type of the three types declared in the preceding
    code snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明前面代码片段中声明的三种类型的联合类型：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding function, the `switch` statement acts as a type guard. The
    type of shape is narrowed in each case clause, according to the value of the discriminant
    property, `kind`, thereby allowing the other properties of that variant to be
    accessed without a type assertion.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，`switch` 语句充当类型守卫。根据判别属性 `kind` 的值，每个情况子句都会缩小 `shape` 的类型，从而允许访问该变体的其他属性，而无需类型断言。
- en: The never type
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: never类型
- en: 'As described in the TypeScript documentation, the `never` type has the following
    characteristics:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如TypeScript文档所述，`never`类型具有以下特性：
- en: The `never` type is a subtype of and assignable to every type.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never`类型是每个类型的子类型并可赋值给每个类型。'
- en: No type is a subtype of or assignable to `never` (except `never` itself).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何类型是`never`的子类型或可赋值给`never`（除了`never`本身）。
- en: In a function expression or arrow function with no return type annotation, if
    the function has no `return` statements or only `return` statements with expressions
    of type `never` and, if the end point of the function is not reachable (as determined
    by control flow analysis), the inferred return type for the function is `never`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有返回类型注解的函数表达式或箭头函数中，如果函数没有`return`语句或只有类型为`never`的`return`语句，并且如果函数的终点不可达（由控制流分析确定），则函数的推断返回类型为`never`。
- en: In a function with an explicit never return type annotation, all `return` statements
    (if any) must have expressions of a type `never` and the end of the function must
    not be reachable.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有显式never返回类型注解的函数中，所有`return`语句（如果有）必须具有类型为`never`的表达式，并且函数的末尾必须不可达。
- en: 'In JavaScript, when a function doesn''t explicitly return a value, it implicitly
    returns the value `undefined`. In TypeScript, the return type of such a function
    is inferred as void. When a function doesn''t complete its execution (it throws
    an error or never finishes running at all), its return type is inferred as `never`
    by TypeScript:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，当一个函数没有显式返回值时，它隐式返回值`undefined`。在TypeScript中，此类函数的返回类型被推断为`void`。当一个函数没有完成其执行（它抛出错误或根本未完成运行），TypeScript将其返回类型推断为`never`：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also encounter the `never` type when we reach impossible matches in
    discriminated unions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能在区分联合中的不可能匹配时遇到`never`类型：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code snippet, the default case will never be executed; therefore,
    the return type is inferred as the never type.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，默认情况永远不会被执行；因此，返回类型被推断为`never`类型。
- en: Enumerations
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Enumerations allow us to define a set of named constants. Since the TypeScript
    2.4 release, these named constant values can be string values. Originally, they
    could only be numeric values:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举允许我们定义一组命名的常量。自TypeScript 2.4版本发布以来，这些命名常量值可以是字符串值。最初，它们只能是数值：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A common workaround to this limitation was the usage of union types of literal
    types:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种限制的一个常见方法是使用字面量类型的联合类型：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since the TypeScript 2.4 release, enumerations with string values are also
    supported:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 自TypeScript 2.4版本发布以来，也支持具有字符串值的枚举：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Object literals
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象字面量
- en: 'Objects can be initialized using new `Object()`, `Object.create()`, or using
    the object literal notation, also known as initializer notation. An object initializer
    is a comma-delimited list of zero or more pairs of property names and values of
    an object, enclosed in curly braces:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以使用`new Object()`、`Object.create()`或使用对象字面量表示法（也称为初始化表示法）进行初始化。对象初始化器是一个逗号分隔的列表，包含零个或多个属性名和值的对，用花括号括起来：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The type inference system can automatically infer the type of object literals.
    The inferred type for the variable person declared in the preceding code snippet
    is `{ name: string, age: number }`. Alternatively, we can explicitly declare the
    type of an object literal:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '类型推断系统可以自动推断对象字面量的类型。在前面代码片段中声明的变量`person`的类型推断为`{ name: string, age: number
    }`。或者，我们也可以显式声明对象字面量的类型：'
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It is also possible to declare optional properties:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以声明可选属性：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Please refer to [Chapter 1](25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml)*, Introducing
    TypeScript,* to learn more about the difference between the empty object type
    (`{}`), the Object (uppercase) type, and the object (lowercase) type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第1章](25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml)*，介绍TypeScript*，以了解更多关于空对象类型（`{}`）、对象（大写）类型和对象（小写）类型之间的区别。
- en: Weak types
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弱类型
- en: 'A weak type is an object literal type in which all properties are optional:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 弱类型是一个对象字面量类型，其中所有属性都是可选的：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'TypeScript allows us to add a value with some or all the properties defined
    in the weak type, but it doesn''t allow us to assign properties that are not part
    of the weak type:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript允许我们向弱类型添加一些或所有已定义的属性值，但它不允许我们分配不属于弱类型的属性：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The keyof operator
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`keyof`运算符'
- en: 'The `keyof` operator can be used to generate a union type of the properties
    of an object as string literal types:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyof`运算符可以用来生成对象属性的联合类型，作为字符串字面量类型：'
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `keyof` operator can be used in combination with other operators, such
    as the `typeof` operator, for example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyof` 操作符可以与其它操作符结合使用，例如 `typeof` 操作符，例如：'
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We will find out more about the `keyof` operator later in this chapter when
    we learn about lookup types.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面学习查找类型时，了解更多关于 `keyof` 操作符的信息。
- en: Index signature
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引签名
- en: 'In JavaScript, we can access the properties of an object using the name of
    the object followed by a dot and the name of the property:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们可以使用对象名称后跟点号和属性名称来访问对象的属性：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'However, it is also possible to access the properties of an object using the
    name of the object followed by the name of the property as a string wrapped by
    brackets:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可以使用对象名称后跟属性名称作为字符串，用方括号括起来来访问对象的属性：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This behavior can be declared using what is known as the index signature:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可以使用所谓的索引签名来声明：
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As we can see in the preceding code snippet, the index signature allows us to
    specify the type of the value returned when we access a property using the brackets
    signature.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，索引签名允许我们指定使用方括号签名访问属性时返回的值的类型。
- en: Local types
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地类型
- en: 'The TypeScript type system allows us to declare types (such as type aliases,
    classes, and interfaces) within the declaration of functions and methods. In the
    early releases of TypeScript, this was not allowed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 类型系统允许我们在函数和方法的声明中声明类型（如类型别名、类和接口）。在 TypeScript 的早期版本中，这是不允许的：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Type casting
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'The TypeScript type system allows us to cast a given type using two different
    syntaxes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 类型系统允许我们使用两种不同的语法来转换给定的类型：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is important to understand that the TypeScript casting does not affect the
    runtime type of the variables.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 TypeScript 类型转换不会影响变量的运行时类型。
- en: Since Typescript 1.6, the default is `as`, because `<>` is ambiguous in `.tsx`
    files. We will learn more about `.tsx` files in [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml)*,
    Frontend Development with React and TypeScript.*
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 自 TypeScript 1.6 以来，默认为 `as`，因为在 `.tsx` 文件中 `<>` 是模糊的。我们将在第 11 章 [前端开发与 React
    和 TypeScript](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml)* 中了解更多关于 `.tsx` 文件的信息*。
- en: In general, it is recommended to avoid using type castings and prefer generic
    types instead.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议避免使用类型转换，而优先使用泛型类型。
- en: Advanced features of the TypeScript type system
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 类型系统的先进特性
- en: In this section, we are going to learn some advanced type system features such
    as generic types, mapped types, and lookup types.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习一些高级类型系统特性，例如泛型类型、映射类型和查找类型。
- en: Generic types
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: 'Generic types can help us avoid using type casting and increase the reusability
    of our code by allowing us to declare (`T`) when a function, class, or method
    is consumed, as opposed to when it is declared:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型可以帮助我们避免使用类型转换，并通过允许我们在函数、类或方法被消费时（而不是在声明时）声明（T），来增加代码的可重用性：
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding example declares a function named deserialize. The type returned
    by the function (T) is unknown at the point in which the function is declared.
    The function is then invoked on two occasions, and the type T becomes finally
    known (User and Rectangle).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例声明了一个名为 deserialize 的函数。该函数返回的类型 (T) 在函数声明点上是未知的。然后函数被调用了两次，类型 T 最终被确定（User
    和 Rectangle）。
- en: We will learn more about generic types in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,
    Object-Oriented Programming with TypeScript.*
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 4 章 [使用 TypeScript 的面向对象编程](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*
    中了解更多关于泛型类型的信息*。
- en: Generic constraints
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型约束
- en: Sometimes, we don't need the concrete type required by a function, class, or
    method, but we know that such type must adhere to a certain set of rules.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不需要函数、类或方法所需的实际类型，但我们知道这种类型必须遵循一组特定的规则。
- en: 'For example, the following code snippet declares a generic function named `isEquals`.
    However, this time the type `T` has a constraint (`T` extends `Comparable`):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段声明了一个名为 `isEquals` 的泛型函数。然而，这次类型 `T` 有一个约束（`T` extends `Comparable`）：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The constraint is used to ensure that all the types provided to `isEqual` as
    its generic type argument implement the `Comparable` interface:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该约束用于确保提供给 `isEqual` 作为其泛型类型参数的所有类型都实现了 `Comparable` 接口：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Mapped types
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型
- en: 'Mapped types are an advanced type feature that allows us to map the value of
    each of the properties of a type to a different type. For example, the following
    mapped type transforms the value of the properties of a given type to a string
    literal that matches the property name:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类型是一种高级类型特性，允许我们将类型的每个属性的值映射到不同的类型。例如，以下映射类型将给定类型的属性值转换为与属性名称匹配的字符串字面量：
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following function takes an object and returns a new object in which all
    the properties have the same names, but their values are the names of the properties:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数接受一个对象，并返回一个新的对象，其中所有属性具有相同的名称，但它们的值是属性的名称：
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Lookup types
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找类型
- en: 'Lookup types are another advanced type system feature that allow us to combine
    the `keyof` operator with generic and object literals to create advanced type
    annotations. Let''s look at an example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 查找类型是另一种高级类型系统特性，它允许我们将 `keyof` 运算符与泛型和对象字面量结合使用，以创建高级类型注解。让我们看一个例子：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The preceding function takes two generic type arguments:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能接受两个泛型类型参数：
- en: '`T` is the type of the items in the array passed as the first argument of the
    function.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T` 是函数第一个参数传递的数组中项的类型。'
- en: '`K` is the name of the properties of `T`. This requirement is enforced by a
    generic constraint (extends `keyof T`).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`K` 是 `T` 的属性名称。此要求通过泛型约束（extends `keyof T`）强制执行。'
- en: 'The function also expects two arguments:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还期望两个参数：
- en: An array of entities of type `T`.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为 `T` 的实体数组。
- en: A value of type `T[K]`. The type `T[K]` represents the type of the value of
    the property `K` in the type `T`, and it is known as lookup type.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型 `T[K]` 的值。类型 `T[K]` 表示类型 `T` 中属性 `K` 的值，它被称为查找类型。
- en: 'The preceding function can be used to filter the array of entities of type
    `T` by one of the properties of the type `T`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能可以用来通过类型 `T` 的一个属性来过滤类型为 `T` 的实体数组：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Mapped type modifiers
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型修饰符
- en: 'TypeScript 2.8 introduced a few operators that allow us to have a greater level
    of control over the definition of mapped types:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 2.8 引入了一些运算符，允许我们对映射类型的定义有更高的控制级别：
- en: We can use the `readonly` modifier to flag a property as immutable.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `readonly` 修饰符将属性标记为不可变。
- en: We can use the `?` operator to flag a property as optional.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `?` 运算符将属性标记为可选。
- en: We can use the `+` operator to apply a modifier, such as the `readonly` modifier,
    to a property in a type. We can also use the `+` operator with the `?` operator.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `+` 运算符将修饰符，如 `readonly` 修饰符，应用于类型中的属性。我们还可以使用 `+` 运算符与 `?` 运算符一起使用。
- en: We can use the `-` operator to apply a modifier, such as the `readonly` modifier
    to a property in a type. We can also use the `+` operator with the `?` operator.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `-` 运算符应用修饰符，例如将 `readonly` 修饰符应用于类型中的属性。我们还可以使用 `+` 运算符与 `?` 运算符一起使用。
- en: 'We will now examine a few examples. The code snippet declares a mapped type
    that can be used to transform a type, `T`, into a new type that contains all the
    properties in `T` but is marked as both `readonly` and `optional`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查几个例子。代码片段声明了一个映射类型，该类型可用于将类型 `T` 转换为一个新的类型，该类型包含 `T` 中的所有属性，但被标记为既是 `readonly`
    也是 `optional`：
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following type declaration is identical to the one in the preceding code
    snippet:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类型声明与前面代码片段中的类型声明相同：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following type can be used to remove the `readonly` modifier from all the
    properties in a given type `T`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类型可用于从给定类型 `T` 的所有属性中删除 `readonly` 修饰符：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can apply the `Mutable` type to the following interface to generate a new
    type. The `abc` property is no longer immutable, but the `def` property is still
    optional:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `Mutable` 类型应用于以下接口以生成一个新的类型。`abc` 属性不再不可变，但 `def` 属性仍然是可选的：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, the following code snippet declares a mapped type that can be used
    to remove the optional properties in a given type `T`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码片段声明了一个映射类型，该类型可用于从给定的类型 `T` 中删除可选属性：
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Conditional types
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件类型
- en: 'Conditional mapped types are an advanced feature introduced in TypeScript 2.8\.
    Previously in this chapter, we learned that we could use the `extends` keyword
    to declare generic constraints. When we declare a generic constraint, we are using
    the `extends` keyword as a kind of operator that allows us to check if a generic
    type (`T`) is a subtype of a given type. For example, the following code snippet
    declares two interfaces named `Animal` and `Dog`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 条件映射类型是TypeScript 2.8中引入的高级特性。在本章的前面部分，我们了解到我们可以使用`extends`关键字来声明泛型约束。当我们声明一个泛型约束时，我们实际上是在使用`extends`关键字作为一种运算符，它允许我们检查一个泛型类型（`T`）是否是给定类型的子类型。例如，以下代码片段声明了两个名为`Animal`和`Dog`的接口：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We then use the `extends` keyword as a conditional operator to generate a new
    type:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`extends`关键字作为条件运算符来生成一个新的类型：
- en: '[PRE71]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Conditional types can be used to declare some complex types. For example, the
    `Flatten` function is a function that transforms a multi-dimensional array (`[][]`)
    into an array with only one dimension (`[]`). The type of the return of `Flatten`
    function is a conditional type, because it returns an array when a multidimensional
    array is provided and a number when an array with only one dimension is provided:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 条件类型可以用来声明一些复杂类型。例如，`Flatten`函数是一个将多维数组（`[][]`）转换为一维数组（`[]`）的函数。`Flatten`函数的返回类型是一个条件类型，因为它在提供多维数组时返回一个数组，在提供一维数组时返回一个数字：
- en: '[PRE72]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The infer keyword
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`infer`关键字'
- en: 'In the preceding section, we have defined the `Flatten` type. However, this
    behavior was hardcoded to return a number when an array of one dimension is provided.
    This means that the `flatten` type only works as expected with arrays of numbers.
    Fortunately, since the TypeScript 2.8 release, we can use the `infer` keyword
    to overcome this limitation:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们已经定义了`Flatten`类型。然而，这种行为是硬编码的，当提供一个一维数组时返回一个数字。这意味着`flatten`类型仅在数字数组上按预期工作。幸运的是，自从TypeScript
    2.8发布以来，我们可以使用`infer`关键字来克服这一限制：
- en: '[PRE73]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `infer` keyword can be used in other scenarios. For example, we can use
    it to infer the return type of a function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`infer`关键字可以在其他场景中使用。例如，我们可以用它来推断函数的返回类型：'
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Built-in conditional types
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置条件类型
- en: 'In the preceding section, we have used the `ReturnType` type to extract the
    return type of a given function. The `ReturnType` type is included as a built-in
    type. TypeScript 2.8 includes many other types:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们使用了`ReturnType`类型来提取给定函数的返回类型。`ReturnType`类型是一个内置类型。TypeScript 2.8包括许多其他类型：
- en: '[PRE75]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The polymorphic this type
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态`this`类型
- en: In JavaScript, the value of the `this` operator is determined by the way a function
    or method is invoked. In a method, the `this` operator usually points to the class
    instance.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`this`操作符的值取决于函数或方法被调用的方式。在方法中，`this`操作符通常指向类实例。
- en: 'The polymorphic `this` type is an improved version of the original type inference
    for the `this` operator that introduced the following behavior as documented by
    Anders Hejlsberg:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 多态`this`类型是原始`this`操作符类型推断的改进版本，Anders Hejlsberg在文档中记录了以下行为：
- en: The type of `this` in an expression within a nonstatic class or interface member
    is an instance of some class that derives from the containing class, as opposed
    to simply an instance of the containing class.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非静态类或接口成员的表达式中，`this`的类型是某个从包含类派生出来的类的实例，而不是简单地是包含类的实例。
- en: The `this` keyword can be used in a type position within a nonstatic class or
    interface member to reference the type of this.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非静态类或接口成员的类型位置中，可以使用`this`关键字来引用`this`的类型。
- en: When a class or interface is referenced as a type, all occurrences of the `this`
    type within the class (including those inherited from base classes) are replaced
    with the type itself.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个类或接口被引用为类型时，类（包括从基类继承的）中所有`this`类型的出现都被替换为该类型本身。
- en: 'This feature makes patterns such as fluent interfaces ([https://en.wikipedia.org/wiki/Fluent_interface](https://en.wikipedia.org/wiki/Fluent_interface))
    much easier to express and implement, as we can see in the following example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性使得像流畅式接口（[https://en.wikipedia.org/wiki/Fluent_interface](https://en.wikipedia.org/wiki/Fluent_interface)）这样的模式更容易表达和实现，如下面的示例所示：
- en: '[PRE76]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: A fluent interface allows us to invoke multiple methods in an object by connecting
    them with dots, without having to write the object name each time.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅式接口允许我们通过使用点连接多个方法来在一个对象上调用多个方法，而不必每次都写对象名称。
- en: 'Since the class methods return the `this` type, we can invoke multiple methods
    without having to write the class name multiple times:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类方法返回 `this` 类型，我们可以调用多个方法而无需多次编写类名：
- en: '[PRE77]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Since the class uses the `this` type, we can extend it and the new class can
    then provide a fluent interface that includes the base methods as well:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类使用了 `this` 类型，我们可以扩展它，然后新的类可以提供一个包含基方法在内的流畅接口：
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the
    Runtime,* we will learn much more about the `this` operator.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml) *理解运行时* 中，我们将学习更多关于 `this`
    操作符的知识。
- en: Ambient declarations
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境声明
- en: 'The ambient declaration allows you to create a variable in your TypeScript
    code that will not be translated into JavaScript at compilation time. This feature
    was designed to make the integration with the existing JavaScript code and the
    **Document Object Model** (**DOM**) and **Browser Object Model** (**BOM**) easier.
    Let''s look at an example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 环境声明允许你在 TypeScript 代码中创建一个变量，该变量在编译时不会被转换为 JavaScript。这个特性是为了使与现有 JavaScript
    代码以及 **文档对象模型** (**DOM**) 和 **浏览器对象模型** (**BOM**) 的集成更加容易。让我们看一个例子：
- en: '[PRE79]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you try to call the member log of an object named `customConsole`, TypeScript
    will let us know that the `customConsole` object has not been declared:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试调用名为 `customConsole` 的对象的成员 `log`，TypeScript 将会告诉我们 `customConsole` 对象尚未声明：
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This is not a surprise. However, sometimes we want to invoke an object that
    has not been defined, for example, the `console` or `window` objects:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不令人惊讶。然而，有时我们想要调用尚未定义的对象，例如 `console` 或 `window` 对象：
- en: '[PRE81]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: When we access the DOM or BOM objects, we don't get an error because these objects
    have already been declared in a special TypeScript file known as **declaration
    files**. You can use the `declare` operator to create an ambient declaration.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问 DOM 或 BOM 对象时，不会出现错误，因为这些对象已经在名为 **声明文件** 的特殊 TypeScript 文件中声明过了。你可以使用
    `declare` 操作符来创建一个环境声明。
- en: 'In the following code snippet, we will declare an interface that is implemented
    by the `customConsole` object. We then use the `declare` operator to add the `customConsole`
    object to the scope:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将声明一个由 `customConsole` 对象实现的接口。然后我们使用 `declare` 操作符将 `customConsole`
    对象添加到作用域中：
- en: '[PRE82]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Interfaces are explained in greater detail in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,
    Object-Oriented Programming with TypeScript.*
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在 [第 4 章](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml) *使用 TypeScript 进行面向对象编程*
    中有更详细的解释。
- en: 'We can then use the `customConsole` object without compilation errors:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `customConsole` 对象而不会出现编译错误：
- en: '[PRE83]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: TypeScript includes, by default, a file named `lib.d.ts` that provides interface
    declarations for the built-in JavaScript library as well as the DOM.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 默认包含一个名为 `lib.d.ts` 的文件，它提供了内置 JavaScript 库以及 DOM 的接口声明。
- en: Declaration files use the file extension `.d.ts` and are used to increase the
    TypeScript compatibility with third-party libraries and runtime environments,
    such as Node.js or a browser.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 声明文件使用文件扩展名 `.d.ts`，用于增加 TypeScript 与第三方库和运行时环境（如 Node.js 或浏览器）的兼容性。
- en: We will learn how to work with declaration files in [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml)*,
    Working with Dependencies.*
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 5 章](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml) *与依赖项一起工作* 中学习如何使用声明文件。
- en: Type declarations – .d.ts
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型声明 – .d.ts
- en: Sometimes, we will need to consume an existing JavaScript file, but we will
    not be able to migrate it to TypeScript. A common example of this scenario is
    when we consume a third-party JavaScript library.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要消费一个现有的 JavaScript 文件，但我们将无法将其迁移到 TypeScript。这种场景的一个常见例子是我们消费第三方 JavaScript
    库。
- en: If the library is open source, we could contribute to it by migrating it to
    TypeScript. However, sometimes, using TypeScript might not align with the preferences
    of the library authors, or the migration may require a significant amount of work.
    TypeScript solves this problem by allowing us to create special kinds of files
    known as type declarations or type definitions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库是开源的，我们可以通过将其迁移到 TypeScript 来为其做出贡献。然而，有时使用 TypeScript 可能与库作者的偏好不符，或者迁移可能需要大量的工作。TypeScript
    通过允许我们创建特殊类型的文件来解决此问题，这些文件被称为类型声明或类型定义。
- en: In the previous chapter, we learned that, by default, TypeScript includes a 
    `lib.d.ts` file that provides interface declarations for the built-in JavaScript
    objects, as well as the DOM and BOM APIs.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解到 TypeScript 默认包含一个 `lib.d.ts` 文件，该文件提供了内置 JavaScript 对象的接口声明，以及 DOM
    和 BOM API。
- en: The type definition files contain the type declarations of third-party libraries.
    These files facilitate the integration between the existing JavaScript libraries
    and TypeScript.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 类型定义文件包含了第三方库的类型声明。这些文件促进了现有 JavaScript 库与 TypeScript 之间的集成。
- en: To take advantage of all the TypeScript features while consuming a JavaScript
    library, we need to install the type definition file of such library. Fortunately,
    we don't need to create the type definition files by hand, because there is an
    open source project known as **DefinitelyTyped** that already contains some type
    definition files for many of the existing JavaScript libraries.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在消费 JavaScript 库的同时充分利用 TypeScript 的所有功能，我们需要安装该库的类型定义文件。幸运的是，我们不需要手动创建类型定义文件，因为有一个名为
    **DefinitelyTyped** 的开源项目已经包含了大量现有 JavaScript 库的类型定义文件。
- en: In the early days of TypeScript development, developers had to manually download
    and install the type definition files from the DefinitelyTyped project website,
    but those days are long gone and today we can use the node package manager (npm)
    to install and manage the type definition files required by our TypeScript application.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 开发的早期阶段，开发者必须手动从 DefinitelyTyped 项目网站下载和安装类型定义文件，但那些日子已经一去不复返了，如今我们可以使用节点包管理器（npm）来安装和管理我们
    TypeScript 应用程序所需的类型定义文件。
- en: We will learn how to work with declaration files in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)*,
    Automating Your Development Workflow.*
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 9 章 [Automating Your Development Workflow](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)*
    中学习如何使用声明文件，该章节将介绍自动化您的开发工作流程。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about many of the features of the TypeScript type
    system. At this point, we should now have a good understanding of concepts such
    type inference, non-nullable types, structural typing, and control flow analysis.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 TypeScript 类型系统的许多功能。到目前为止，我们应该已经对诸如类型推断、非空类型、结构化类型和流程控制分析等概念有了很好的理解。
- en: In the next chapter, we will learn more about the usage of functions in TypeScript.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于 TypeScript 中函数的使用。
