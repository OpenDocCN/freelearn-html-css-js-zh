- en: Chapter 1. Hello, Three.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 欢迎来到Three.js
- en: This chapter will take you from zero to sixty with a new Three.js project. We'll
    cover what Three.js is, how to get started with writing code for it, and the components
    of a basic scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带你通过一个新的Three.js项目从零开始。我们将介绍Three.js是什么，如何开始为其编写代码，以及基本场景的组成部分。
- en: The wonderful world of Three.js
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三维.js的奇妙世界
- en: Three.js is a JavaScript library that simplifies displaying 3D graphics in web
    browsers. Artists, major brands, and many others are increasingly using Three.js
    to power immersive online experiences that can reach millions of people across
    many platforms. There are many inspiring demos of the technology at [http://threejs.org/](http://threejs.org/).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js是一个简化在网页浏览器中显示3D图形的JavaScript库。艺术家、大型品牌以及许多人越来越多地使用Three.js来提供可以触及数百万人的沉浸式在线体验，这些体验可以在许多平台上运行。在[http://threejs.org/](http://threejs.org/)上可以找到许多令人鼓舞的技术演示。
- en: Three.js is usually used with a new technology called **WebGL**, a JavaScript
    API for rendering graphics without plugins. The API is based on **OpenGL**, a
    desktop graphics API **(GL** stands for **graphics library**). Because it uses
    the client's graphics processing unit to accelerate rendering, WebGL is fast!
    However, many mobile browsers as well as Internet Explorer 10 and below do not
    support WebGL. Luckily, Three.js supports rendering with the **HTML5 Canvas API**
    as well as other technologies such as **Scalable Vector Graphics** instead.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js通常与一种名为**WebGL**的新技术一起使用，这是一个用于渲染图形而不需要插件的JavaScript API。该API基于**OpenGL**，一个桌面图形API（**GL**代表**图形库**）。因为它使用客户端的图形处理单元来加速渲染，所以WebGL非常快！然而，许多移动浏览器以及IE
    10及以下版本不支持WebGL。幸运的是，Three.js还支持使用**HTML5 Canvas API**以及其他技术，如**可缩放矢量图形**进行渲染。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find up-to-date information on browser support at [http://caniuse.com/webgl](http://caniuse.com/webgl).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://caniuse.com/webgl](http://caniuse.com/webgl)找到有关浏览器支持的最新信息。
- en: Three.js is originally written and maintained by *Ricardo Cabello*, who is also
    known as *Mr.Doob*. The library is open source (MIT-licensed) and is available
    from its GitHub page, [https://github.com/mrdoob/three.js](https://github.com/mrdoob/three.js).
    The documentation of Three.js is available online at [http://threejs.org/docs/](http://threejs.org/docs/).
    When the documentation is insufficient, the best place to look is the `examples`
    folder of the project, which contains a large collection of examples demonstrating
    different features. You can browse the examples online at [http://threejs.org/examples/](http://threejs.org/examples/).
    The source code in the `src` folder is also worth browsing if you need to know
    how a certain class works or what methods and properties it exposes. Developers
    respond to questions about Three.js on the Q&A site **StackOverflow**, so if you
    are confused about something, you can browse questions with the `three.js` tag
    or ask your own.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js最初由*Ricardo Cabello*编写和维护，他也被称为*Mr.Doob*。该库是开源的（MIT许可），可以从其GitHub页面获取，[https://github.com/mrdoob/three.js](https://github.com/mrdoob/three.js)。Three.js的文档可在网上找到，[http://threejs.org/docs/](http://threejs.org/docs/)。当文档不足时，最佳查看位置是项目的`examples`文件夹，其中包含大量演示不同功能的示例。你可以在[http://threejs.org/examples/](http://threejs.org/examples/)上在线浏览这些示例。如果你需要了解某个类的实现方式或它公开的方法和属性，`src`文件夹中的源代码也值得浏览。开发者们在问答网站**StackOverflow**上回答有关Three.js的问题，所以如果你对某事感到困惑，你可以浏览带有`three.js`标签的问题或提出自己的问题。
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This book was written with Version r61 of the Three.js project. Certain parts
    of the API are still under development, but anything that is likely to change
    will be pointed out when it is introduced.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用Three.js项目的版本r61编写。API的某些部分仍在开发中，但任何可能发生变化的内容将在引入时指出。
- en: Let's code!
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们编码！
- en: Because Three.js runs in web browsers, it can run on—and be developed on—many
    different platforms. In fact, we're going to build our first Three.js project
    directly in a browser!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Three.js在网页浏览器中运行，它可以在许多不同的平台上运行和开发。实际上，我们将直接在浏览器中构建我们的第一个Three.js项目！
- en: 'Open up [http://mrdoob.com/projects/htmleditor/](http://mrdoob.com/projects/htmleditor/).
    You should see HTML and JavaScript code overlaid on top of a spinning sphere-like
    shape, as shown in the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打开[http://mrdoob.com/projects/htmleditor/](http://mrdoob.com/projects/htmleditor/)。你应该会看到HTML和JavaScript代码叠加在一个旋转的球形形状之上，如下面的截图所示：
- en: '![Let''s code!](img/8539_01_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![让我们编码！](img/8539_01_01.jpg)'
- en: The online Three.js editor
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在线Three.js编辑器
- en: This is the `Hello, World` program of Three.js—the minimum code required to
    get a spinning shape rendering in the browser. The preview will automatically
    update when you change any code, so go ahead and play with it and see what happens.
    For example, try changing `THREE.MeshBasicMaterial` to `THREE.MeshNormalMaterial`.
    What happens if you change `IcosahedronGeometry` to `TorusKnotGeometry`? Try fiddling
    with some numbers. Can you make the shape rotate faster or slower?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Three.js的“Hello, World”程序——在浏览器中渲染旋转形状所需的最小代码。当你更改任何代码时，预览将自动更新，所以你可以尝试玩一玩，看看会发生什么。例如，尝试将`THREE.MeshBasicMaterial`更改为`THREE.MeshNormalMaterial`。如果你将`IcosahedronGeometry`更改为`TorusKnotGeometry`会发生什么？尝试调整一些数字。你能让形状旋转得更快或更慢吗？
- en: Been there, scene that
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已见，场景已见
- en: Let's dig deeper into our spinning-shape world and explain how it all works.
    You can follow along with this section in the online editor or type the code into
    a new HTML file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解我们的旋转形状世界，并解释它是如何工作的。你可以在这个在线编辑器中跟随本节，或者将代码输入到一个新的HTML文件中。
- en: 'First, there''s the HTML template:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是HTML模板：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Nothing surprising here. We're basically just including Three.js and removing
    the browser's default page margins. The `<canvas>` element, onto which we'll render
    our scene, will be added into the DOM by our JavaScript.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么令人惊讶的。我们基本上只是包含了Three.js，并移除了浏览器默认的页面边距。《canvas》元素，我们将渲染场景到这个元素上，将通过我们的JavaScript添加到DOM中。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of using the Three.js file from the GitHub CDN, you should download
    the latest Three.js build and include the local copy in your projects. The full
    Three.js script can be found in the `build` folder of the project or can be downloaded
    from [https://raw.github.com/mrdoob/three.js/master/build/three.js](https://raw.github.com/mrdoob/three.js/master/build/three.js).
    In production, you will want to use the minified version (`three.min.js`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用来自GitHub CDN的Three.js文件，你应该下载最新的Three.js构建版本，并将本地副本包含到你的项目中。完整的Three.js脚本可以在项目的`build`文件夹中找到，或者可以从[https://raw.github.com/mrdoob/three.js/master/build/three.js](https://raw.github.com/mrdoob/three.js/master/build/three.js)下载。在生产环境中，你将想要使用压缩版本（`three.min.js`）。
- en: 'Now comes the fun part: telling Three.js to display something. First, let''s
    declare the objects we''ll need:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候来点有趣的：告诉Three.js显示一些内容。首先，让我们声明我们将需要的对象：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, let''s give them values and explain what they do:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们给它们赋值并解释它们的作用：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A `Scene` class represents a list of objects that affect what is displayed on
    the screen, such as 3D models and lights. (Each class provided by Three.js is
    invoked as a property of the global `THREE` variable.) A scene isn't very useful
    by itself, so let's put something in it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene`类表示影响屏幕上显示内容的对象列表，例如3D模型和灯光。（Three.js提供的每个类都是作为全局`THREE`变量的一个属性调用的。）一个场景本身并不很有用，所以让我们往里面放些东西。'
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载你购买的所有示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: 'A `mesh` object can be displayed in a scene, instantiated using the `THREE.Mesh`
    constructor. It consists of `geometry`, which is the object''s shape, and a `material`,
    which is a color, image, or other texture that defines how the faces of the shape
    appear. In this case, the geometry we''ll use is `IcosahedronGeometry`, which
    is based on a 20-sided shape approximating a sphere. The constructor takes a radius
    and detail, where detail is the number of times to split each edge of the icosahedron
    to add more faces and make the shape closer to a sphere:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`mesh`对象可以在场景中显示，使用`THREE.Mesh`构造函数实例化。它由`geometry`组成，这是对象的形状，以及一个`material`，这是一个颜色、图像或其他纹理，它定义了形状的面的外观。在这种情况下，我们将使用的几何形状是`IcosahedronGeometry`，它基于一个20边形，近似于球体。构造函数接受一个半径和细节，其中细节是分割20面体的每条边的次数，以添加更多面并使形状更接近球体：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`MeshBasicMaterial` is a type of material that is not affected by the surrounding
    lighting. The options we''re passing include the color in hex format (like you''d
    use in CSS), whether to display the shape as a solid color or highlight the edges,
    and how thick to draw the wireframe, respectively.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeshBasicMaterial` 是一种不受周围光照影响的材质。我们传递的选项包括十六进制格式的颜色（就像你在 CSS 中使用的那样），是否显示形状为纯色或突出边缘，以及绘制线框的厚度。'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are many other types of geometry and materials. [Chapter 2](ch02.html
    "Chapter 2. Building a World"), *Building a World* describes them in detail.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他类型的几何形状和材料。[第二章](ch02.html "第二章。构建世界") *构建世界* 详细描述了它们。
- en: 'Now we can add our mesh to the scene:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的网格添加到场景中：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ve put together what we want to display, so the next step is to actually
    display it. Three.js accomplishes this with **renderers**, which take the objects
    in a scene, perform some calculations, and then ask the browser to display the
    result in a specific format like WebGL. The renderer creates a new `<canvas>`
    element by default that should be added to the DOM:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经组装了我们想要显示的内容，所以下一步就是实际显示它。Three.js 通过 **渲染器** 完成此操作，它对场景中的对象进行一些计算，然后要求浏览器以特定格式（如
    WebGL）显示结果。默认情况下，渲染器创建一个新的 `<canvas>` 元素，应该添加到 DOM 中：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we're using the `CanvasRenderer` as our method of displaying the scene.
    (We'll cover other renderers such as `WebGLRenderer` in [Chapter 2](ch02.html
    "Chapter 2. Building a World"), *Building a World*.) We're also telling the renderer
    to display the scene at the full size of the browser window with our `setSize()`
    call. Then we will add the renderer's canvas to the DOM with `appendChild(renderer.domElement)`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `CanvasRenderer` 作为显示场景的方法。（我们将在 [第二章](ch02.html "第二章。构建世界") *构建世界*
    中介绍其他渲染器，如 `WebGLRenderer`。）我们还通过 `setSize()` 调用告诉渲染器以浏览器窗口的全尺寸显示场景。然后我们将渲染器的画布添加到
    DOM 中，使用 `appendChild(renderer.domElement)`。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid changing the canvas' size with CSS; use the renderer's `setSize` method
    instead, which sets the `width` and `height` HTML attributes on the canvas element.
    This is because CSS describes the display size but not the render size. That is,
    if the canvas is rendered at 800 x 600, but the CSS shows it at 1024 x 768, the
    rendering will be stretched to fill the space just like if you specified the CSS
    size of an image to be larger than its true size. This can result in distortion
    and difficulty converting between "screen space" and "canvas space."
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 CSS 改变画布的大小；使用渲染器的 `setSize` 方法代替，该方法设置画布元素的 `width` 和 `height` HTML 属性。这是因为
    CSS 描述的是显示大小，而不是渲染大小。也就是说，如果画布以 800 x 600 的分辨率渲染，但 CSS 显示为 1024 x 768，渲染将被拉伸以填充空间，就像你指定了比实际大小更大的
    CSS 图像大小一样。这可能会导致扭曲，并难以在“屏幕空间”和“画布空间”之间进行转换。
- en: The one last thing we need is a `camera` object as shown in the following code
    snippet, which is something Three.js uses to tell the renderer from what perspective
    the scene should be displayed. If the player was standing in your virtual world
    and their screen represented what they could see, `camera` would be their eyes,
    `renderer` would be their brain, and `scene` would be their universe.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要的是一个 `camera` 对象，如下面的代码片段所示，这是 Three.js 使用它来告诉渲染器场景应该从哪个视角显示。如果玩家站在你的虚拟世界中，他们的屏幕代表他们能看到的内容，那么
    `camera` 就是他们的眼睛，`renderer` 就是他们的大脑，而 `scene` 就是他们的宇宙。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A `PerspectiveCamera` instance displays the world from a single point in space,
    just like your eyes. This creates a little bit of distortion due to distance (objects
    that are farther away appear smaller). There is also an `OrthographicCamera` class
    which is like looking out from a plane. Orthographic cameras are sometimes used
    for **isometric** (also known as **2.5D**) games and level editors to get accurate
    views of objects'' relative sizes. You can see the difference in the following
    figure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerspectiveCamera` 实例从空间中的一个单独点显示世界，就像你的眼睛一样。这由于距离产生了一点点扭曲（远离的物体看起来更小）。还有一个
    `OrthographicCamera` 类，就像从平面上向外看。正交相机有时用于 **等距**（也称为 **2.5D**）游戏和关卡编辑器，以获得物体相对尺寸的准确视图。你可以在以下图中看到差异：'
- en: '![Been there, scene that](img/8539_01_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![去过那里，场景如此](img/8539_01_02.jpg)'
- en: Camera projections. Top is perspective and bottom is orthographic.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机投影。上方是透视投影，下方是正交投影。
- en: The `PerspectiveCamera` object's parameters are field of view (in degrees),
    which controls how wide the camera lens is; aspect ratio, the ratio of the canvas'
    width to its height; near-plane frustum,the closest an object can be to the camera
    and still be seen; and far-plane frustum, the farthest an object can be from the
    camera and still be rendered. You'll rarely need to change these values
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerspectiveCamera` 对象的参数是视野（以度为单位），它控制着摄像机镜头的宽度；纵横比，画布宽度与高度的比率；近平面视锥体，物体可以离摄像机多近仍然可见；以及远平面视锥体，物体可以离摄像机多远仍然可以被渲染。你很少需要更改这些值'
- en: Also notice that we change the camera's location by assigning to `camera.position.z`.
    Three.js uses a **spatial coordinate system** in which, by default, the x-axis
    increases from left to right, the z-axis increases from back to front, and the
    y-axis increases upward. Most objects have a *position* and *scale*, both of which
    are represented by a three-dimensional vector (specifically `THREE.Vector3`).
    They also have a *rotation* represented by a `THREE.Euler` instance, which is
    an abstraction that allows treating rotation much like a vector. All objects are
    initialized at the position (0, 0, 0), also called the **origin**. Rotation also
    starts at (0, 0, 0), and scale starts at (1, 1, 1). Vectors are very versatile,
    but usually all you'll need to do with them is assign to the `x`, `y`, and `z`
    properties. For example, if we wanted to move the camera upward, we could increase
    `camera.position.y`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们通过将 `camera.position.z` 赋值来改变摄像机的位置。Three.js 使用一个**空间坐标系**，其中默认情况下，x轴从左到右增加，z轴从后向前增加，y轴向上增加。大多数对象都有一个
    *position* 和 *scale*，它们都由一个三维向量表示（具体为 `THREE.Vector3`）。它们还有一个由 `THREE.Euler` 实例表示的
    *rotation*，这是一个抽象，允许将旋转处理得就像向量一样。所有对象都初始化在位置（0, 0, 0），也称为**原点**。旋转也从（0, 0, 0）开始，缩放从（1,
    1, 1）开始。向量非常灵活，但通常你只需要对它们进行 `x`、`y` 和 `z` 属性的赋值。例如，如果我们想向上移动摄像机，我们可以增加 `camera.position.y`。
- en: 'Finally, we can display the scene by asking the renderer to display it from
    the camera''s perspective:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过请求渲染器从摄像机的视角显示场景来展示场景：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Hooray, a static 3D display! If you have been following along by rebuilding
    our scene from scratch, now is the point at which you can actually see the results
    of your work. Just open the HTML file in a browser. (If you're loading the `three.js`
    file from GitHub instead of locally, you'll need to be connected to the Internet.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽，一个静态的3D显示！如果你一直跟着我们从头开始重建场景，现在是你真正看到你工作成果的时候了。只需在浏览器中打开HTML文件。（如果你是从GitHub而不是本地加载
    `three.js` 文件，你需要连接到互联网。）
- en: 'A static scene isn''t very fun though, so let''s add animation by constructing
    a render loop:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态的场景并不很有趣，所以让我们通过构建一个渲染循环来添加动画：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The key here is `requestAnimationFrame()`, which executes the function passed
    to it when the browser is ready to paint a new frame. In that function, we perform
    any necessary updates to the scene (in this case, changing the mesh's `rotation`
    vector just like we changed the camera's `position` vector earlier) and then ask
    the renderer to repaint the canvas as before.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是 `requestAnimationFrame()`，当浏览器准备好绘制新帧时，它会执行传递给它的函数。在这个函数中，我们执行对场景的任何必要的更新（在这个例子中，就像我们之前改变摄像机的
    `position` 向量一样，改变网格的 `rotation` 向量），然后请求渲染器像之前一样重新绘制画布。
- en: 'Putting it all together (and also wrapping our setup code in a function for
    clarity), we get:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起（并且为了清晰起见，将设置代码封装在一个函数中），我们得到：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's animating! You've now built your first 3D world in the browser. Because
    it's in JavaScript, you can also easily send it to your friends. (In the online
    editor, click on the stacked bars icon ![Been there, scene that](img/8539_01_04.jpg)
    at the upper-right, click on the **Download** button, and then rename the downloaded
    file with a `.html` extension.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在动画化！你现在已经在浏览器中构建了你的第一个3D世界。因为它是用JavaScript编写的，你也可以很容易地将其发送给你的朋友。（在在线编辑器中，点击右上角的堆叠条形图图标
    ![去过那里，场景](img/8539_01_04.jpg)，然后点击 **下载** 按钮，并将下载的文件重命名为 `.html` 扩展名。）
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Both within the Three.js repository and online, most of the Three.js examples
    you'll find will have all their code in a single HTML file. This is convenient
    for small projects but unhealthy for larger ones. Even though most of the code
    in this book is small enough to be manageable in a single file, we will try to
    use patterns that make the code maintainable. [Chapter 5](ch05.html "Chapter 5. Design
    and Development"), *Design and Development* specifically addresses designs that
    work well at scale.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 仓库和在线上，您会发现的大多数 Three.js 示例都将所有代码放在一个单独的 HTML 文件中。这对于小型项目来说很方便，但对于大型项目来说则不健康。尽管本书中的大多数代码足够小，可以管理在一个文件中，但我们仍将尝试使用使代码可维护的模式。[第
    5 章](ch05.html "第 5 章。设计和开发")，*设计和开发*专门讨论了在规模上表现良好的设计。
- en: Choosing your environment
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择你的环境
- en: The Google Chrome browser is usually considered to be on the leading edge of
    WebGL support, so many Three.js developers work mainly in either the latest stable
    version of Chrome or the alpha-release branch, named **Canary**. Chrome has a
    lot of other advantages too, such as advanced performance profiling, the ability
    to emulate touch events, and support for inspecting canvas frames. (You can access
    these features through the Chrome Developer Tools settings. Canvas inspection
    is explained well at [http://www.html5rocks.com/en/tutorials/canvas/inspection/](http://www.html5rocks.com/en/tutorials/canvas/inspection/).)
    If you want to experiment with WebGL features that are still in development, you
    can enable some of them in Canary's **about:flags** page.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Google Chrome 浏览器通常被认为是 WebGL 支持的领先者，因此许多 Three.js 开发者主要在最新的稳定版 Chrome 或名为 **Canary**
    的 alpha 发布分支中进行工作。Chrome 还有很多其他优点，例如高级性能分析、模拟触摸事件的能力以及支持检查画布帧。（您可以通过 Chrome 开发者工具的设置访问这些功能。画布检查在
    [http://www.html5rocks.com/en/tutorials/canvas/inspection/](http://www.html5rocks.com/en/tutorials/canvas/inspection/)
    上有很好的解释。）如果您想尝试仍在开发中的 WebGL 功能，您可以在 Canary 的 **about:flags** 页面上启用其中的一些功能。
- en: When it comes to coding, the online Three.js editor is great for testing small,
    isolated concepts, but it quickly gets cumbersome for more complex projects. Most
    programming environments have solid JavaScript support, but some are better than
    others.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到编码时，在线的 Three.js 编辑器非常适合测试小型、孤立的构思，但对于更复杂的项目来说，它会很快变得繁琐。大多数编程环境都有良好的 JavaScript
    支持，但有些比其他更好。
- en: Chrome also has a script-editing environment that works well for some people.
    If you open the Chrome Developer Tools (*Ctrl* / *Cmd* + *Shift* + *I*) and switch
    to the **Sources** tab, you can configure Chrome to edit files from your local
    filesystem. This environment includes syntax highlighting, debugging, autocompletion,
    source mapping for minified files, revision control that visually shows changes,
    and the ability to run the code instantly without reloading the page. Additionally,
    you can store snippets for reuse as described at [https://developers.google.com/chrome-developer-tools/docs/authoring-development-workflow#snippets](https://developers.google.com/chrome-developer-tools/docs/authoring-development-workflow#snippets).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 还有一个适用于某些人的脚本编辑环境。如果您打开 Chrome 开发者工具 (*Ctrl* / *Cmd* + *Shift* + *I*)
    并切换到 **Sources** 选项卡，您可以将 Chrome 配置为编辑来自您本地文件系统的文件。此环境包括语法高亮、调试、自动完成、压缩文件的源映射、可视化的版本控制以及能够在不重新加载页面的情况下即时运行代码的能力。此外，您还可以存储代码片段以供重用，具体请参阅
    [https://developers.google.com/chrome-developer-tools/docs/authoring-development-workflow#snippets](https://developers.google.com/chrome-developer-tools/docs/authoring-development-workflow#snippets)。
- en: 'You can see what the editor looks like in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的屏幕截图中看到编辑器的样子：
- en: '![Choosing your environment](img/8539_01_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![选择你的环境](img/8539_01_03.jpg)'
- en: Google Chrome Developer Tools
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Google Chrome 开发者工具
- en: If you prefer to work outside of the Chrome editor, it can be tedious to constantly
    switch windows and reload the page. There are several tools that attempt to solve
    this. LiveReload ([http://livereload.com/](http://livereload.com/)) and Tin.cr
    ([http://tin.cr/](http://tin.cr/)) are the best known; they are browser extensions
    that automatically reload the page when you save a file. You may also want to
    try LightTable ([http://www.lighttable.com/](http://www.lighttable.com/)), an
    experimental IDE that also autoreloads and additionally includes tools for visually
    manipulating your code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在Chrome编辑器之外工作，频繁切换窗口和重新加载页面可能会很麻烦。有几个工具试图解决这个问题。LiveReload ([http://livereload.com/](http://livereload.com/))
    和 Tin.cr ([http://tin.cr/](http://tin.cr/)) 是最知名的；它们是浏览器扩展，当你保存文件时，会自动重新加载页面。你可能还想要尝试LightTable
    ([http://www.lighttable.com/](http://www.lighttable.com/))，这是一个实验性的IDE，它也支持自动重新加载，并且还包括了用于可视化管理你的代码的工具。
- en: If you use Sublime Text as your editor, you can install autocompletion support
    for Three.js commands through the package manager or from the Three.js repository
    itself (in `/utils/editors`).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Sublime Text作为你的编辑器，你可以通过包管理器或从Three.js仓库本身（在`/utils/editors`）安装Three.js命令的自动完成支持。
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have constructed our first 3D world with Three.js. In this chapter, we learned
    what Three.js is and does, reviewed the basic components of a Three.js scene,
    and set up our editing environment. We used the `scene`, `renderer`, `camera`,
    `mesh`, `geometry`, and `material` components for the first time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用Three.js构建了我们的第一个3D世界。在本章中，我们学习了Three.js是什么以及它的功能，回顾了Three.js场景的基本组件，并设置了我们的编辑环境。我们首次使用了`场景`、`渲染器`、`相机`、`网格`、`几何`和`材质`组件。
- en: In the next chapter, we will cover these components in more detail, including
    the different kinds of the renderer, geometry, and material components. We will
    also add lighting to the mix and make a more advanced scene.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地介绍这些组件，包括不同类型的渲染器、几何和材质组件。我们还将添加光照效果，制作一个更高级的场景。
