- en: Chapter 2. Managing Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 管理视图
- en: As we have seen in the previous chapter, Backbone views are responsible for
    managing **DOM** (**Document Object Model**) interactions between users and applications.
    A typical Backbone application is composed of many views with a very specific
    behavior; for instance, we can have a view to show contact data and another view
    to edit it. As you know, rendering a single view is a trivial task, but orchestrating
    a complex layout with multiple views can be a pain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所看到的，Backbone视图负责管理用户与应用程序之间的**DOM（文档对象模型**）交互。一个典型的Backbone应用程序由许多具有非常特定行为的视图组成；例如，我们可以有一个用于显示联系数据的视图，另一个用于编辑它。正如你所知，渲染单个视图是一个简单的任务，但协调多个视图的复杂布局可能会很痛苦。
- en: It's important to develop a better strategy to deal with complex view interactions
    to make the project easier to maintain and fun to develop. If you don't put the
    necessary attention into the organization of your views you can end up with a
    dirty DOM and messy code, which makes it hard to introduce new features or change
    existing ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发更好的策略来处理复杂的视图交互，以使项目更容易维护和开发，这一点很重要。如果你不重视视图的组织，你可能会得到一个脏DOM和混乱的代码，这使得引入新功能或更改现有功能变得困难。
- en: As we did in the previous chapter, we are going to separate responsibilities
    by identifying common view use cases and then will learn how to compose layouts
    by using small views.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所做的那样，我们将通过识别常见的视图用例来分离责任，然后我们将学习如何通过使用小视图来组合布局。
- en: 'In this chapter you will learn to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Identify common view types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别常见的视图类型
- en: Implement reusable views for common types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现可重用的视图以处理常见类型
- en: Use the reusable view types to compose complex views easily
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可重用的视图类型轻松组合复杂视图
- en: Identifying view types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别视图类型
- en: 'After working with Backbone for a while you can see common use cases for views
    emerge; they are so common they can be used for different unrelated projects.
    These views can be extracted and can be used on any project if they are built
    correctly. Looking at the Backbone documentation, Views do not implement a default
    render method, so the trick here is to define a set of views with a default render
    method for different use cases:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Backbone一段时间后，你可以看到视图的常见用例出现；它们如此常见，以至于可以用于不同的无关项目。这些视图可以被提取出来，并且如果它们被正确构建，可以在任何项目中使用。查看Backbone文档，视图不实现默认的渲染方法，所以这里的技巧是为不同的用例定义一组具有默认渲染方法的视图：
- en: '**View with model** – Render a template with model data.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有模型的视图** – 使用模型数据渲染模板。'
- en: '**View with collection** – Render a collection of views with collection data;
    it should update the list of views automatically when the collection changes.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有集合的视图** – 使用集合数据渲染视图集合；它应该在集合更改时自动更新视图列表。'
- en: '**Region** – This view acts like a container; it points to a particular DOM
    node and manages the content for that node. It''s used to render other views.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域** – 这个视图像一个容器；它指向特定的DOM节点，并管理该节点的内。它用于渲染其他视图。'
- en: '**Layout** – A layout is composed of one or more regions; it defines an HTML
    structure to organize where the regions will be placed.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局** – 布局由一个或多个区域组成；它定义了一个HTML结构来组织区域将放置的位置。'
- en: Figure 2.1 shows a simple wireframe for an application; as you can see, it is
    a very common layout found on web applications and is very useful to understand
    how the common view types are related.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1显示了一个应用程序的简单线框；正如你所见，这是一个在Web应用程序中非常常见的布局，对于理解常见的视图类型之间的关系非常有用。
- en: '![Identifying view types](img/B01962_02_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![识别视图类型](img/B01962_02_01.jpg)'
- en: 'Figure 2.1: Views, Regions, and Layout relationship'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：视图、区域和布局关系
- en: With these foundation views you will have a simple but powerful framework to
    manage your views, so you won't need to implement the `render()` method anymore.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些基础视图，你将拥有一个简单但强大的框架来管理你的视图，因此你不再需要实现`render()`方法。
- en: ModelView
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ModelView
- en: 'The simplest implementation is to render a single model; it''s a very straightforward
    algorithm. Extract data from the model and use a template engine to make the actual
    render with the data; finally, attach the result in the DOM:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的实现是渲染单个模型；这是一个非常直接的算法。从模型中提取数据，并使用模板引擎使用数据实际渲染；最后，将结果附加到DOM中：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the following code we can identify five steps to rendering the view.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们可以识别渲染视图的五个步骤。
- en: 'Get the template:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取模板：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Compile the template:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译模板：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Get data from the model:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模型获取数据：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Render the template with model data:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模型数据渲染模板：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Put the result on the DOM:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果放入DOM中：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that we return this in the `render()` method; this is useful for chaining
    calls. These steps are common for all views that need to render a model, so we
    can extract that behavior in a new view type. This view will own the generic algorithm
    and let the specific parts open to extend:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`render()`方法中返回这个对象；这对于链式调用很有用。这些步骤适用于所有需要渲染模型的视图，因此我们可以将这种行为提取到一个新的视图类型中。这个视图将拥有通用的算法，并允许特定的部分进行扩展：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The model data now is done in a separated method, `serializeData()`, allowing
    us to implement a different way to provide data to the view; however, it implements
    a default behavior that is needed in most cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 模型数据现在是在一个单独的方法`serializeData()`中完成的，这允许我们以不同的方式向视图提供数据；然而，它实现了一个在大多数情况下需要的默认行为。
- en: The template is now compiled in the process using the Underscore template engine,
    so that you have to provide the template text and let it make the rest. But this
    leaves the view highly coupled with a template engine; what if you need to use
    a different one such as Handlebars?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模板使用Underscore模板引擎在过程中编译，因此您必须提供模板文本，让它完成其余工作。但这使得视图与模板引擎高度耦合；如果您需要使用不同的模板引擎，如Handlebars，怎么办？
- en: 'We can use the same strategy as before in the `serializedData()` method, and
    put this behavior in a separated method. All template engines need two things:
    template text and data. Template text can be obtained by a jQuery selector, a
    string variable, pre-compiled template, and so on. So we will leave this open
    to the final implementation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`serializedData()`方法中使用与之前相同的策略，并将此行为放入一个单独的方法中。所有模板引擎都需要两样东西：模板文本和数据。模板文本可以通过jQuery选择器、字符串变量、预编译模板等方式获得。因此，我们将将其留给最终实现：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And, as we did with `serializedData()`, a default behavior is implemented.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，就像我们对`serializedData()`所做的那样，实现了一个默认行为。
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the `template` property can be either a function or a string.
    If a string is used, the default behavior will be to use the Underscore template
    engine. If a function is used, the function gives us the freedom to use any template
    engine.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`template`属性可以是函数或字符串。如果使用字符串，则默认行为将使用Underscore模板引擎。如果使用函数，则函数为我们提供了使用任何模板引擎的自由。
- en: 'If we want to render a model in a view, we can do something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在视图中渲染模型，我们可以这样做：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You only need to specify the template and the model, and you're done!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需指定模板和模型，然后就可以完成了！
- en: CollectionView
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CollectionView
- en: 'Backbone Collections are composed of many models, so when rendering a collection
    what we need is to render a list of `Views`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone集合由许多模型组成，因此当渲染集合时，我们需要渲染`Views`的列表：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the `modelView` property should be a View class; it could be our `ModelView`
    class of the previous section or any other view. See how for each model in the
    collection it instantiates and renders a `this.modelView` with the current model.
    As a result, an `html` variable will contain an array of all rendered views. Finally
    the `html` array can be attached easily to the `$el` element.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`modelView`属性应该是视图类；它可以是上一节中的`ModelView`类或任何其他视图。看看对于集合中的每个模型，它如何实例化和渲染一个带有当前模型的`this.modelView`。结果，`html`变量将包含所有渲染视图的数组。最后，`html`数组可以轻松地附加到`$el`元素上。
- en: 'For an example of how to use `CollectionView`, see the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用`CollectionView`的示例，请参阅以下示例：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This snippet will do the job, it will render a `MyModelView` for each model
    in the `someCollection` object and put the result list in the `#main` element.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将完成这项工作，它将为`someCollection`对象中的每个模型渲染一个`MyModelView`，并将结果列表放入`#main`元素中。
- en: However, if you add models to the collection or remove them, the view will not
    be updated. That's not a desirable behavior. When a model is added, it should
    add a new view at the end of the list; if a model is deleted from the collection,
    the view associated with that model should be deleted.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您向集合中添加模型或删除它们，视图将不会更新。这不是期望的行为。当添加模型时，它应该在列表末尾添加一个新的视图；如果从集合中删除模型，则应删除与该模型关联的视图。
- en: A quick and dirty way to sync collection changes and views is to re-render the
    entire view on every change in the collection, but this approach is very inefficient
    because client resources are consumed when re-rendering views that don't need
    to change. A better approach should exist.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一种快速且简单的方法是在集合的每次更改时重新渲染整个视图，以同步集合更改和视图，但这种方法非常低效，因为当重新渲染不需要更改的视图时，会消耗客户端资源。应该存在更好的方法。
- en: Adding new models
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新模型
- en: 'When a model is added to the collection an `add` event is triggered; we can
    create an event handler to update the view:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型被添加到集合中时，会触发一个 `add` 事件；我们可以创建一个事件处理器来更新视图：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the `addModel` method is called, it should create and render a new view
    with the data of the model added and put it at the end of the list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `addModel` 方法时，它应该创建并渲染一个新的视图，包含添加的模型的数据，并将其放在列表的末尾。
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A `renderModel()` method was added since both methods, `render()` and `modelAdded()`,
    need to render the model in the same way. The DRY principle was applied.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了 `renderModel()` 方法，因为 `render()` 和 `modelAdded()` 两个方法都需要以相同的方式渲染模型。这里应用了
    DRY 原则。
- en: When a child view is rendered, it is useful to listen for all the events for
    the given view, so that we can listen for child events from the collection.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个子视图被渲染时，监听给定视图的所有事件是有用的，这样我们就可以监听来自集合的子事件。
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our event handler is very simple; it renders the added model with the `renderModel()`
    method, attaches an event handler for any event in the view, and appends the result
    at the end of the DOM element.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件处理器非常简单；它使用 `renderModel()` 方法渲染添加的模型，为视图中的任何事件附加事件处理器，并将结果追加到 DOM 元素的末尾。
- en: Deleting models
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除模型
- en: 'When a model is removed from the collection, the view that contains that model
    should be deleted from the DOM to reflect the current state of the collection.
    Consider an event handler for the `removed` event:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型从集合中移除时，包含该模型的视图应该从 DOM 中删除，以反映集合的当前状态。考虑一个用于 `removed` 事件的处理器：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'How can we obtain the view associated with the model? There is no easy way
    to do it with the code that we have. To make it easy, we can keep track of model-view
    associations; in this way, getting the view is very easy:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获取与模型关联的视图？我们目前没有简单的方法来做这件事。为了使其更容易，我们可以跟踪模型-视图关联；这样，获取视图就非常容易：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At rendering time, we store a reference to the view in the `this.children` hash
    table for future reference, since `render()` and `modelAdded()` use the same method
    to render; this change is done in one place, the `renderModel()` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染时间，我们在 `this.children` 哈希表中存储视图的引用，以便将来参考，因为 `render()` 和 `modelAdded()`
    使用相同的方法进行渲染；这个更改在一个地方完成，即 `renderModel()` 方法。
- en: When a model is removed, the `modelRemoved()` method can easily find the view
    and remove it by calling the standard `remove()` method and destroying the reference
    in the `this.children` hash.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模型被移除时，`modelRemoved()` 方法可以轻松找到视图，并通过调用标准的 `remove()` 方法以及销毁 `this.children`
    哈希表中的引用来移除它。
- en: Destroying views
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁视图
- en: 'When a `CollectionView` is destroyed, it should remove all children views to
    clean the memory properly. This should be done by extending the `remove()` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `CollectionView` 被销毁时，它应该移除所有子视图以正确清理内存。这应该通过扩展 `remove()` 方法来完成：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, when the view needs to be removed, it will do it and clean all the children
    views.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当视图需要被移除时，它将执行此操作并清理所有子视图。
- en: Resetting the collection
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置集合
- en: 'When a collection is wiped, the view should re-render the entire collection,
    because all items were replaced:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个集合被清除时，视图应该重新渲染整个集合，因为所有项目都被替换了：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This works, but previous views should be closed too; as we saw in the previous
    section, the best place to do it is in the render method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，但之前的视图也应该关闭；正如我们在上一节中看到的，最佳做法是在渲染方法中完成它：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If a view has no items yet, the `closeChildren()` method will not do anything.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个视图还没有项目，`closeChildren()` 方法将不会做任何事情。
- en: Region
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区域
- en: A common use case is to swap between views in a common DOM element; this can
    be done by using the same `el` property in both views and calling the `render()`
    method on the view you want to see. But this way doesn't clean the memory and
    event bindings because both views will remain live in memory, even if they are
    not in the DOM.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是在一个常见的 DOM 元素之间切换视图；这可以通过在两个视图中使用相同的 `el` 属性并在你想要看到的视图中调用 `render()`
    方法来实现。但这种方式不会清理内存和事件绑定，因为两个视图都将保留在内存中，即使它们不在 DOM 中。
- en: A particularly useful scenario is when you need to switch between sub-applications,
    because sub-applications are rendered in the same DOM element normally. For example,
    when a user wants to edit contact information, he/she will click on an **Edit**
    button, and the current view will be replaced with an edit form.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有用的场景是在需要切换子应用程序时，因为子应用程序通常在同一个 DOM 元素中渲染。例如，当用户想要编辑联系信息时，他/她将点击一个 **编辑**
    按钮，当前视图将被替换为编辑表单。
- en: '![Region](img/B01962_02_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![区域](img/B01962_02_02.jpg)'
- en: 'Figure 2.2: Swapping views with regions'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：使用区域交换视图
- en: 'To switch between views, a `Region` class could be used as shown next:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图之间切换，可以使用`Region`类，如下所示：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Region` object points to an existing DOM element; to show a view on that
    element, the `show()` method should be called on the `Region` object. Note that
    views don't have the `el` property set because regions will put the element in
    the DOM and not the View itself. This gives us an extra feature, views don't need
    to set an `el` property anymore and can be rendered on any available region.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Region`对象指向一个现有的DOM元素；要在该元素上显示一个视图，应在`Region`对象上调用`show()`方法。请注意，视图没有设置`el`属性，因为区域会将元素放入DOM中，而不是视图本身。这给我们带来了一个额外功能，视图不再需要设置`el`属性，并且可以在任何可用的区域上渲染。'
- en: 'A basic region manager can be implemented with this code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码实现一个基本的区域管理器：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the `show()` method is called, it closes the current view, if any, then
    assigns a new `currentView` and opens the view. When a view is open, `Region`
    ensures that the `$el` property exists, first calling the `ensureEl()` method.
    Then the interesting part happens:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`show()`方法时，如果存在当前视图，则关闭它，然后分配一个新的`currentView`并打开视图。当一个视图打开时，`Region`确保存在`$el`属性，首先调用`ensureEl()`方法。然后发生有趣的部分：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The Backbone documentation explains how views works:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone文档解释了视图的工作方式：
- en: '*All views have a DOM element at all times (the el property), whether they''ve
    already been inserted into the page or not. In this fashion, views can be rendered
    at any time, and inserted into the DOM all at once [...]*'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*所有视图始终都有一个DOM元素（el属性），无论它们是否已经插入到页面中。以这种方式，视图可以在任何时候渲染，并一次性插入到DOM中 [...]*'
- en: 'And that''s what happens here: we render the view in memory first, calling
    `view.render()`, and then insert the result in the DOM pointed by the Region `$el`
    property.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的就是这个：我们首先在内存中渲染视图，调用`view.render()`，然后将结果插入由Region的`$el`属性指向的DOM中。
- en: A `remove()` method is implemented too, to make regions compatible with Backbone
    Views. When a region is removed, it needs to close the owned view too, so this
    allows us to do this easily.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还实现了`remove()`方法，以便使区域与Backbone Views兼容。当一个区域被移除时，它需要关闭拥有的视图，因此这使我们能够轻松地做到这一点。
- en: Imagine that we have a region that owns a `CollectionView` with many views inside;
    when the `remove()` method is called on the region, it will call the `remove()`
    method on the `CollectionView`, which will call the `remove()` method on every
    child view.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个拥有许多视图的`CollectionView`的区域；当在区域上调用`remove()`方法时，它将调用`CollectionView`上的`remove()`方法，该方法将调用每个子视图的`remove()`方法。
- en: Layout
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: A Layout is used to define structure; its intention is to create a skeleton
    where other views will be placed. A common web application layout is composed
    of a header, a sidebar, footer, and a common area, for example. With layouts we
    can define regions, in a declarative way, where these elements will be placed.
    After the layout is rendered, we can show the views we want on those views.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 布局用于定义结构；其目的是创建一个骨架，其他视图将放置在其中。一个常见的Web应用程序布局由一个页眉、一个侧边栏、页脚和一个公共区域组成，例如。使用布局，我们可以以声明的方式定义这些元素将放置的区域。在布局渲染后，我们可以在这些视图上显示我们想要的视图。
- en: 'In the following figure, we can see a layout; each of these elements is a region,
    so other views should be created to fill the regions—for example, a HeaderView
    class for the header region:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到一个布局；这些元素中的每一个都是一个区域，因此应该创建其他视图来填充这些区域——例如，为头部区域创建一个HeaderView类：
- en: '![Layout](img/B01962_02_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![布局](img/B01962_02_03.jpg)'
- en: 'Figure 2.3: A common web application layout'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：一个常见的Web应用程序布局
- en: 'An implementation of this example could be something like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的实现可能如下所示：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'See how regions are declared: a pair of names and a selector. The layout will
    expose the regions through the `getRegion()` method, which receives the name of
    the region and returns an instance of the `Region` class that can be used as seen
    in the previous section.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看看区域是如何声明的：一对名称和一个选择器。布局将通过`getRegion()`方法公开区域，该方法接收区域的名称并返回一个`Region`类的实例，可以在前一个部分中看到其用法。
- en: Also note that the layout needs to define a `template` property; it should follow
    the same rules used in the `ModelView` implementation. That template will define
    the HTML where regions will be pointed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，布局需要定义一个`template`属性；它应遵循在`ModelView`实现中使用的相同规则。该模板将定义区域将被指向的HTML。
- en: 'The following code shows how to create a Layout view:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了如何创建一个布局视图：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The layout extends directly from `ModelView` so the `render()` method acts like
    in `ModelView`, but extends its behavior creating the necessary regions after
    rendering. The `configurateRegions()` method creates a region for every region
    declared on the `regions` property. Associations between region names and `Region`
    instances are stored in the _`regions` property, to be used on future references.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 布局直接扩展自`ModelView`，因此`render()`方法的行为类似于`ModelView`，但在渲染后扩展其行为，创建必要的区域。`configurateRegions()`方法为`regions`属性上声明的每个区域创建一个区域。区域名称与`Region`实例之间的关联存储在`_regions`属性中，以供未来引用。
- en: When a layout is removed, it should close any region opened, so that all resources
    are released cleanly. That's the job of the `closeRegions()` method; it iterates
    over all regions created with `configurateRegions()` and calls the `remove()`
    method for every region.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当布局被移除时，它应该关闭任何打开的区域，以便所有资源都能干净地释放。这是`closeRegions()`方法的工作；它遍历所有使用`configurateRegions()`创建的区域，并对每个区域调用`remove()`方法。
- en: As the regions are stored in a private property called _`regions`, a method
    for accessing the regions is required; the `getRegion()` method returns the region
    instance associated with the name of the region.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区域存储在名为`_regions`的私有属性中，因此需要一个访问区域的方法；`getRegion()`方法返回与区域名称关联的区域实例。
- en: Putting it all together
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'We have created four simple but powerful new views types that can be used easily
    on projects, minimizing the effort and making less redundant code. In the next
    section, we will convert our contacts project into a more complex project, using
    what we have learned here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了四种简单但强大的新视图类型，可以在项目中轻松使用，最大限度地减少工作量并减少冗余代码。在下一节中，我们将把我们的联系人项目转换成一个更复杂的项目，使用在这里学到的知识：
- en: '![Putting it all together](img/B01962_02_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容整合在一起](img/B01962_02_04.jpg)'
- en: 'Figure 2.4: Application root layout'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：应用程序根布局
- en: 'Our application will have a root layout with three sections:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将有一个包含三个部分的根布局：
- en: Header – Will contain a navigation bar
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页眉 – 将包含导航栏
- en: Footer – Copyright information
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页脚 – 版权信息
- en: Main – This element shows all sub-applications on demand
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主视图 – 此元素根据需要显示所有子应用程序
- en: 'This layout description is not a Layout object; instead, it describes the HTM
    root content:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局描述不是布局对象；相反，它描述了HTML根内容：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this root layout, the header and footer are very straightforward, so is not
    necessary to create a separate view for them. There is a `main` div that will
    be our main region, for the whole application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个根布局中，页眉和页脚非常简单，因此没有必要为它们创建单独的视图。有一个`main` div，它将成为我们的主要区域，用于整个应用程序。
- en: Showing a list
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示列表
- en: 'The `ContactList` subapplication is responsible for rendering the collection
    in the DOM. Thus, the `ContactList` object will instantiate the necessary views:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactList`子应用程序负责在DOM中渲染集合。因此，`ContactList`对象将实例化必要的视图：'
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A layout is created to put the `CollectionView` inside; the layout template
    has a `div` with a `contact-list-layout` id that will be used as the target region:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个布局，将`CollectionView`放入其中；布局模板有一个`div`，其`contact-list-layout` ID将用作目标区域：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And the layout code is very simple:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 布局代码非常简单：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The view that renders the collection of contacts is very straightforward because
    it just need to specify the `modelView` attribute:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 展示联系人群的视图非常简单明了，因为它只需要指定`modelView`属性：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The contact card template shows the contact name, phone number, email, and
    its social networks:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人卡片模板显示联系人姓名、电话号码、电子邮件及其社交网络：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ContactListItemView` class should handle the delete and view events:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactListItemView`类应处理删除和视图事件：'
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When the user clicks on the **Delete** button, the view triggers a `contact:delete`
    event and lets the controller handle the deletion process. Because the **View**
    button is simpler than the **Delete**, we can redirect the user to the contact
    list from the view; note that delegating this very simple task to the controller
    will add more overhead without benefit.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**删除**按钮时，视图触发`contact:delete`事件，并让控制器处理删除过程。因为**视图**按钮比**删除**按钮简单，所以我们可以从视图重定向用户到联系人列表；请注意，将这个非常简单的任务委托给控制器将增加更多开销而没有好处。
- en: The action bar allow the user to add new users.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 操作栏允许用户添加新用户。
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`ContactListActionBar` just renders its template and waits for a click on its
    button.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactListActionBar`仅渲染其模板并等待对其按钮的点击。'
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the button is clicked, we redirect the user to the contact form to create
    a new user.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，我们将用户重定向到联系表单以创建新用户。
- en: Showing the details
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示详细信息
- en: 'The contact details show a read-only version of a single contact; here you
    can see all the details of a given contact but no edition. The following screenshots
    shows how it looks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人详细信息显示单个联系人的只读版本；在这里，你可以看到给定联系人的所有详细信息，但不能编辑。以下截图显示了它的外观：
- en: '![Showing the details](img/B01962_02_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![显示详细信息](img/B01962_02_05.jpg)'
- en: 'Figure 2.5: Contact details'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：联系人详细信息
- en: 'To show a read-only version of a contact, we need to first define a layout:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示联系人的只读版本，我们首先需要定义一个布局：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The layout defines two regions, one for the widget at the left and another
    one for the main content:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 布局定义了两个区域，一个用于左侧的小部件，另一个用于主要内容：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When `ContactViewLayout` is rendered, the widget and the about information should
    be rendered. The templates for these views are very simple, so for space reasons
    will not be shown here; if you want to see the details of the implementation,
    please go to the GitHub repo for this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ContactViewLayout`被渲染时，小部件和关于信息应该被渲染。这些视图的模板非常简单，所以为了节省空间，这里将不会展示；如果你想看到实现细节，请访问这本书的GitHub仓库。
- en: The `ContactAbout` view includes three buttons to go back to the list, another
    to delete the contact, and a final one to edit it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactAbout`视图包括三个按钮，用于返回列表，另一个用于删除联系人，最后一个用于编辑它。'
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we did in the `ContactList`, we will delegate the deletion process to the
    controller; views should not handle that business logic. However, the edit and
    go back button are simple URL redirections and can be implemented directly in
    the view.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`ContactList`中所做的那样，我们将删除过程委托给控制器；视图不应该处理这个业务逻辑。然而，编辑和返回按钮是简单的URL重定向，可以直接在视图中实现。
- en: Editing information
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑信息
- en: Figure 2.6 shows how the edit form for the contacts should looks. The form view
    should be able to grab information from the input boxes and update the Contact
    model passed to it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6显示了联系人编辑表单的外观。表单视图应该能够从输入框中获取信息并更新传递给它的联系人模型。
- en: 'A layout template should be created here to separate the widget at the left
    from the form view at the right:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 应在此处创建一个布局模板，以将左侧的小部件与右侧的表单视图分开：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Editing information](img/B01962_02_06.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![编辑信息](img/B01962_02_06.jpg)'
- en: 'Figure 2.6: Edit contact form'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：编辑联系人表单
- en: 'The layout defines two regions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 布局定义了两个区域：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order to edit a contact, we need to define a form:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编辑联系人，我们需要定义一个表单：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For space reasons, I have eliminated the duplicated code in the book, but you
    can see the complete code in the GitHub repo. Please note that this form will
    be used for editing and creating new contacts. For each attribute in the model,
    an input is rendered with the contents of the attribute:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间原因，我在书中删除了重复的代码，但你可以在GitHub仓库中看到完整的代码。请注意，此表单将用于编辑和创建新的联系人。对于模型中的每个属性，都会渲染一个包含属性内容的输入：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When the user clicks on the **Cancel** button, it triggers a `form:cancel` event
    that is processed by the `ContactEditor` subapplication controller.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**取消**按钮时，会触发一个由`ContactEditor`子应用控制器处理的`form:cancel`事件。
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When the model is rendered, it may or may not contain attributes due to the
    server response; for this reason, we extend the `serializeData()` method to assign
    default values.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型被渲染时，它可能包含或不包含属性，这取决于服务器响应；因此，我们扩展了`serializeData()`方法来分配默认值。
- en: When the user clicks on the **Save** button, the `saveContact()` is called,
    it gets the data from the inputs and assigns new values to the model, then triggers
    a `form:save` event to be processed by the `ContactEditor` subapplication controller.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**保存**按钮时，会调用`saveContact()`，它从输入中获取数据并将新值分配给模型，然后触发一个`form:save`事件，由`ContactEditor`子应用控制器处理。
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Rendering third-party plugins
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染第三方插件
- en: A common issue when rendering views is not rendering plugins from others because
    they are designed to work with traditional web applications but not with SPA;
    this is because many plugins are DOM-dependent, which means that the target element
    should exist in the actual DOM. To see this issue more clearly, let me show you
    an example with the jQueryUI Calendar plugin. Let's add a `birthdate` field to
    our `ContactEditor`, replacing the age field.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染视图时，一个常见的问题是未能渲染其他人的插件，因为它们是为传统的Web应用程序设计的，而不是为SPA设计的；这是因为许多插件依赖于DOM，这意味着目标元素应该存在于实际的DOM中。为了更清楚地了解这个问题，让我用一个jQueryUI日历插件示例来展示。让我们在我们的`ContactEditor`中添加一个`birthdate`字段，替换年龄字段。
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And make the proper changes in the view:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 并在视图中进行适当的更改：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To show a calendar on the `birthdate` field we need to call `$('#birthdate').datepicker()`somewhere,
    but what is the best place to do that?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`birthdate`字段上显示日历，我们需要在某个地方调用`$('#birthdate').datepicker()`，但最佳位置在哪里呢？
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After calling the `show()` method on the `region` object, the `contactForm`
    view is live in the DOM, so it makes sense to call the `datepicker()` method after
    that. However this is not a good strategy because our controller object knows
    about DOM elements, which are not its responsibility.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`region`对象调用`show()`方法后，`contactForm`视图在DOM中是活跃的，因此在该之后调用`datepicker()`方法是有意义的。然而，这不是一个好的策略，因为我们的控制器对象知道DOM元素，而这不是它的职责。
- en: Views should be responsible for dealing with the DOM, so rendering third-party
    plugins is included. Another approach could be to extend the `render()` method
    on the `FormView` class but we already have the `onRender()` callback, which is
    called after the rendering process.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 视图应该负责处理DOM，因此渲染第三方插件也包括在内。另一种方法可能是扩展`FormView`类的`render()`方法，但我们已经有了在渲染过程之后被调用的`onRender()`回调。
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: But this is not going to work because we are rendering the view on a region.
    Did you remember the `show()` method?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不会起作用，因为我们是在一个区域上渲染视图。你记得`show()`方法吗？
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The showing process first renders the view in memory and after that makes it
    available on the DOM. That's why this doesn't work. The intent of the `onRender()`
    method is to make template changes before making them available on the DOM. We
    need to add a new callback method that will be called when the view is in the
    DOM.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 显示过程首先在内存中渲染视图，然后使其在DOM中可用。这就是为什么这不起作用的原因。`onRender()`方法的目的是在将模板更改提供给DOM之前进行更改。我们需要添加一个新的回调方法，当视图在DOM中时将被调用。
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Remember to make this feature available in `CollectionView` too.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 记得也要在`CollectionView`中实现这个功能。
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, our `ContactForm` will end with something like this.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`ContactForm`将以类似以下的方式结束。
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Remember, most third-party plugins need to have the element in the DOM or they
    will not work, so you should call the plugin only after rendering the view. The
    best place to call plugins is in the extended view class so the responsibility
    for DOM manipulation is encapsulated in the view.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，大多数第三方插件需要在DOM中具有元素才能工作，否则它们将无法运行，因此你应该在渲染视图之后调用插件。调用插件的最佳位置是在扩展的视图类中，这样DOM操作的责任就被封装在视图中。
- en: Conclusions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: We started by creating common view types that are common for almost every project.
    Those views are simple in principle but powerful; we can effectively manage nested
    views without worrying about insufficient memory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了适用于几乎所有项目的通用视图类型。这些视图在原则上很简单但功能强大；我们可以有效地管理嵌套视图，而不用担心内存不足。
- en: We learned that, by encapsulating common patterns in the `render()` method,
    we can create useful view types; in this chapter, we have seen four of them but
    if you are curious I encourage you to take a look at the Marionette framework,
    which works on top of Backbone.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，通过在`render()`方法中封装常见模式，我们可以创建有用的视图类型；在本章中，我们看到了四种，但如果你好奇，我鼓励你查看Marionette框架，它建立在Backbone之上。
- en: 'Marionette includes all the views exposed here: `ItemView`, `CollectionView`,
    `LayoutView`, Regions. and other useful view types. Marionette objects behave
    very similarly to what we see here, so that you can easily interchange Marionette
    objects with those described in this chapter.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Marionette包括这里公开的所有视图：`ItemView`、`CollectionView`、`LayoutView`、区域，以及其他有用的视图类型。Marionette对象的行为与我们在这里看到的行为非常相似，因此你可以轻松地交换Marionette对象和本章中描述的对象。
- en: Plugins should be called only after the view is on the DOM, because most plugins
    are DOM-dependent. When rendering plugins, remember to do it in the view not outside
    it; the `onShow()` callback strategy ensures that the view is available on the
    DOM, and so is the best place to render third-party plugins.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 插件应该在视图进入DOM之后调用，因为大多数插件都是依赖于DOM的。在渲染插件时，请记住在视图中而不是外部进行；`onShow()`回调策略确保视图在DOM中可用，因此这是渲染第三方插件的最佳位置。
- en: In the next chapter, you will learn more about how to sync views and models.
    You will see how to manage complex data and render it effectively in views. Validation
    is an important feature for your application; you will learn how to validate models
    and use that information to display error messages on your views.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习更多关于如何同步视图和模型的内容。你将看到如何管理复杂数据并在视图中有效地渲染它。验证是应用程序的一个重要功能；你将学习如何验证模型并使用这些信息在视图中显示错误消息。
