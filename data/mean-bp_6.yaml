- en: Chapter 6. Auction Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 拍卖应用
- en: This chapter will focus on building an auction-like application that will rely
    on the previously built e-commerce application's API. It is going to be a small
    proof-of-concept application. The backend solution of our application is going
    to consume the backend API of our e-commerce application. I want the last chapter
    to be a playground for us, so we can go through some interesting technologies
    used in this book, and also have some fun with a smaller but interesting app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于构建一个类似拍卖的应用程序，它将依赖于之前构建的电子商务应用的API。它将是一个小型概念验证应用。我们应用的后端解决方案将消费我们电子商务应用的后端API。我希望最后一章能成为我们的游乐场，这样我们就可以通过这本书中使用的有趣技术，并且在一个较小但有趣的应用中有所乐趣。
- en: Setting up the base app
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本应用
- en: 'We are going to start with our classic boilerplate for an Express application.
    Follow these steps to set up the base project:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从经典的Express应用程序样板开始。按照以下步骤设置基本项目：
- en: Clone the project from GitHub at [https://github.com/robert52/express-api-starter](https://github.com/robert52/express-api-starter).
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub克隆项目：[https://github.com/robert52/express-api-starter](https://github.com/robert52/express-api-starter)。
- en: Rename your boilerplate project `auction-app`.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的样板项目重命名为`auction-app`。
- en: 'If you want, you can stop pointing to the initial Git remote repository by
    running the following command:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您愿意，可以通过运行以下命令停止指向初始Git远程仓库：
- en: '[PRE0]'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Jump to your working directory:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到您的工作目录：
- en: '[PRE1]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Install all dependencies:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所有依赖项：
- en: '[PRE2]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a development configuration file:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建开发配置文件：
- en: '[PRE3]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your configuration file, `auction-app/config/environments/development.js`,
    should look similar to the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您的配置文件，`auction-app/config/environments/development.js`，应类似于以下内容：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What we are building
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建的内容
- en: We are going to build an English auction site. The previous e-commerce application
    is going to serve us with products, and an admin can create auctions using those
    products. Auctions have different features; we are not going to discuss each of
    them, but instead we are going to describe an English auction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个英文拍卖网站。之前的电子商务应用将为我们提供产品，管理员可以使用这些产品创建拍卖。拍卖有不同的特性；我们不会逐一讨论它们，而是将描述一个英文拍卖。
- en: The most common auction is the English auction; it's a single dimensional auction,
    and the only thing considered is the bid price offered for the goods. Usually
    it's seller oriented, meaning it's one-sided.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的拍卖是英文拍卖；它是一个单维度的拍卖，唯一考虑的是为商品提供的出价。通常它是以卖家为导向的，意味着它是单方面的。
- en: Normally, a starting price is set for the auction; it's called the **reserve
    price**, under which the seller won't sell the goods. Each buyer makes a bid and
    everyone knows every bid, so it's open-cry. The winner pays the winning price.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，拍卖会设定一个起始价格；这被称为**保留价**，在此价格以下，卖家不会出售商品。每个买家都会出价，每个人都知道每个出价，因此是公开叫价。获胜者支付获胜价格。
- en: No lower bid is called than the current winning bid. Usually, the auction ends
    when no one is interested in paying the latest price. Also, an end time could
    be set for the auction.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 没有低于当前最高出价。通常，当没有人对支付最新价格感兴趣时，拍卖结束。此外，可以为拍卖设置一个结束时间。
- en: The end time could be an absolute time, in our case a standard datetime, or
    a time relative to the last bid, such as 120 seconds. Later in the chapter, we
    are going to discuss the benefits of relative time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结束时间可以是绝对时间，在我们的案例中是一个标准日期时间，或者是一个相对于最后出价的时间，例如120秒。在章节的后面，我们将讨论相对时间的好处。
- en: Data modeling
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据建模
- en: In our application, an auction is a special event in which users—or more precisely,
    bidders—can bid on an item available for sale. An item is a product from the e-commerce
    platform, but one that retains only the necessary information to be displayed
    to the user. Let's discuss each model in more detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，拍卖是一个特殊事件，用户——更准确地说，是出价者——可以对可供销售的商品进行出价。一个项目是电子商务平台上的一个产品，但它只保留显示给用户所需的信息。让我们更详细地讨论每个模型。
- en: Auction
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拍卖
- en: An auction is going to hold all the necessary information about the event. As
    discussed earlier, we are going to implement an English auction, in which we are
    going to sell goods from our main e-commerce application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 拍卖将包含关于事件的所有必要信息。如前所述，我们将实现一个英文拍卖，我们将从我们的主要电子商务应用中出售商品。
- en: An English auction is open-cry, which means that everyone is aware of each bid.
    The winner will pay the winning price. Each bid is going to increase the price
    of the goods, and the next bidder has to pay more in order to win the auction.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 英式拍卖是公开叫价，这意味着每个人都知道每个出价。获胜者将支付获胜价格。每个出价都会提高商品的价格，下一个出价者必须支付更多才能赢得拍卖。
- en: All auctions will have a reserved price, a starting value below which we are
    not going to sell our product. In other words, it is the lowest acceptable price
    by the seller.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有拍卖都将有一个保留价格，这是一个低于我们不会出售我们的产品的起始价值。换句话说，这是卖方可以接受的最低价格。
- en: To simplify things, we are going to set an end time for our auction. The last
    bid closer to the end time will be the winning bid. You could go with a relative
    time, which means that you can set a time limit from the last bid (that is, 10
    minutes) and just call the winner if no bids were made in that time frame. This
    could be very useful to prevent bid sniping.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将为我们的拍卖设置一个结束时间。最后出价最接近结束时间的出价将是获胜出价。你也可以选择相对时间，这意味着你可以从最后出价（即10分钟）设置一个时间限制，如果在那个时间段内没有出价，就宣布获胜者。这可以非常有效地防止出价狙击。
- en: For example, say you bid the starting price of 39 USD on a product. Normally,
    you have the highest bid. Now imagine that the auction is ending, but before the
    end with just few seconds another bidder attempts a bid at 47 USD. This will leave
    you with no time to react, so the last bidder wins the auction. This is how usually
    bid snipping works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你在一个产品上出价39美元作为起始价格。通常情况下，你拥有最高的出价。现在想象一下，拍卖即将结束，但在结束前只有几秒钟，另一个出价者试图以47美元的价格出价。这将让你没有时间反应，所以最后出价者赢得了拍卖。这就是通常出价狙击的工作方式。
- en: 'Let''s see the Mongoose auction schema:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Mongoose拍卖模式：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Besides the information discussed earlier, we embedded all the bids in our auction
    document. This would not be a good idea if there are going to be many bids in
    an auction, but since we are going to have a fixed-time auction, there are only
    going to be a few of them. For popular auctions, you could just move the bids
    to a separate collection and have a reference to the auction document.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前讨论的信息外，我们还将在我们的拍卖文档中嵌入所有出价。如果拍卖中有许多出价，这可能不是一个好主意，但既然我们打算进行固定时间的拍卖，出价将非常有限。对于热门拍卖，你只需将出价移动到单独的集合中，并在拍卖文档中保留引用。
- en: Bidder
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出价者
- en: 'We are using the backend API from our e-commerce application, so we don''t
    need to store users in our database. But we can store additional data about our
    bidding users. For this we can create a new model, called `app/models/bidder.js`,
    and add the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用我们电子商务应用程序的后端API，因此我们不需要在我们的数据库中存储用户。但我们可以存储有关我们的出价用户的额外数据。为此，我们可以创建一个新的模型，称为`app/models/bidder.js`，并添加以下内容：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`profileId` stores the `_id` of the user in order to have a reference to the
    user document from the e-commerce platform. You could also store additional data
    in this model and store the auctions in which the bidder is present.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`profileId`存储用户的`_id`，以便从电子商务平台引用用户文档。你还可以在这个模型中存储额外的数据，并将出价者参与的拍卖存储在模型中。'
- en: Auction backend
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拍卖后端
- en: In the previous chapter, we added a service layer to our architecture. We are
    going to follow the same pattern. Also, we are going to add an extra component
    called `Mediator`, which will serve as a single point of entry to assist us in
    communicating with different modules.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在我们的架构中添加了一个服务层。我们将遵循相同的模式。此外，我们还将添加一个额外的组件，称为`Mediator`，它将作为一个单一入口点来帮助我们与不同的模块进行通信。
- en: We will follow the mediator design pattern in the construction of our modules,
    which is a behavioral design pattern. This is going to be a single central point
    of control, through which communication flows.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在构建我们的模块时遵循中介设计模式，这是一种行为设计模式。这将是一个单一的中央控制点，通过它进行通信。
- en: The Mediator
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中介
- en: Our `Mediator` is going to be an object that will coordinate interaction with
    different modules through channels. A module can subscribe to a given event and
    get notified when that event occurs. All this event-related discussion pretty
    much makes us think about using the events core module from Node.js, which is
    used to emit named events that cause execution of the functions to be called.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Mediator`将是一个对象，它将通过通道协调与不同模块的交互。一个模块可以订阅一个给定的事件，并在该事件发生时收到通知。所有这些与事件相关的话题几乎让我们想到使用Node.js的事件核心模块，该模块用于发出命名事件，从而调用要执行的功能。
- en: 'This is a good starting point. One thing we need to solve is that our `Mediator`
    needs to be a single point of entry, and only one instance can exist at the execution
    time of our application. We could just use a singleton design pattern. With all
    this in mind, let''s implement our mediator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的起点。我们需要解决的一个问题是我们的 `Mediator` 需要是一个单点入口，并且在我们应用程序的执行时间只能存在一个实例。我们可以简单地使用单例设计模式。考虑到所有这些，让我们实现我们的中介：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This should give us a solid start for our module; for now this should be enough.
    Because we are using the ES6 features, we can just extend the `EventEmitter` class.
    Instead of exporting the whole `Mediator` class, we are exporting a function that
    checks whether there is already an instance, and if not, we just create a new
    instance of our `Mediator` class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该为我们模块的构建提供一个坚实的基础；目前这应该足够了。因为我们使用了 ES6 特性，我们可以直接扩展 `EventEmitter` 类。我们不是导出整个
    `Mediator` 类，而是导出一个函数，该函数检查是否已经存在一个实例，如果没有，我们就创建 `Mediator` 类的新实例。
- en: 'Let''s take a look at an example of how we are going to use this technique:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将如何使用这种技术的例子：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We just require the `mediator` instance, and using the `.on()` method, we subscribe
    to events and execute a function. Using the `.emit()` method, we publish the named
    event and pass a message as an argument.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要引入 `mediator` 实例，并使用 `.on()` 方法订阅事件并执行一个函数。使用 `.emit()` 方法发布命名事件，并传递一个消息作为参数。
- en: Remember when using `arrow` functions in ES6 that the `this` keyword in the
    listener function no longer points to `EventEmitter`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住在使用 ES6 中的 `箭头函数` 时，监听函数中的 `this` 关键字不再指向 `EventEmitter`。
- en: Auction manager
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拍卖管理器
- en: Instead of implementing all the business logic in the application's controller
    layer, we are going to build another service, called `AuctionManager`. This service
    will have all the necessary methods for correct execution of an auction.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在应用程序的控制器层实现所有业务逻辑，而是要构建另一个服务，称为 `AuctionManager`。这个服务将包含执行拍卖所需的所有必要方法。
- en: 'Using this technique, we can easily decide later how we are going to export
    our application''s business logic: using traditional endpoints or through WebSockets.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以在以后轻松地决定如何导出我们应用程序的业务逻辑：使用传统的端点或通过 WebSockets。
- en: 'Let''s follow a few steps to implement our auction manager:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循几个步骤来实现我们的拍卖管理器：
- en: Create a new file called `/app/services/auction-manager.js`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `/app/services/auction-manager.js` 的新文件。
- en: 'Add the necessary dependencies:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的依赖项：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the base class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义基类：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Getting all auctions method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有拍卖的方法：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Joining an auction:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加入拍卖：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we started using our mediator to emit events. At this point,
    we are emitting an event when a bidder joins the auction. This does not add much
    value for us right now, but it will come handy when we start playing around with
    our real-time communication solution.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们开始使用我们的中介来触发事件。在这个阶段，当一位竞标者加入拍卖时，我们会触发一个事件。目前这对我们来说并没有增加太多价值，但当我们开始尝试我们的实时通信解决方案时，这将会变得很有用。
- en: 'Placing a bid:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 投标：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When placing a bid, we just want to add it to the list of bids on our auction,
    and for that, we are going to use atomic operators to update the `currentPrice`
    and add the current bid. Also, after successfully placing a bid, we are going
    to emit an event for that.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行投标时，我们只想将投标添加到我们的拍卖的投标列表中，为此，我们将使用原子操作来更新 `currentPrice` 并添加当前的投标。此外，在成功投标后，我们将为该事件触发一个事件。
- en: Auctioneer
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拍卖师
- en: We are going to give a fancy name for our upcoming module, and we are going
    to call it `Auctioneer`. Why this name? Well, we are building an auction application,
    so we can add a touch of old-school feeling and add an auctioneer, which will
    call out new bids and who joins the auction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为即将推出的模块起一个花哨的名字，我们将称之为 `Auctioneer`。为什么这个名字？嗯，我们正在构建一个拍卖应用，所以我们可以添加一些复古的感觉，并添加一个拍卖师，他将宣布新的投标和谁加入了拍卖。
- en: As you must have already guessed, this will be our real-time communication module.
    This module will use `SocketIO`, and we are going to do something similar as in
    [Chapter 4](part0046_split_000.html#1BRPS1-5c78d361d97340239270192b72d53e7b "Chapter 4. Chat
    Application"), *Chat Application*, where we used the module for real-time communication.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，这将是我们实时通信模块。该模块将使用 `SocketIO`，我们将要做的事情与[第 4 章](part0046_split_000.html#1BRPS1-5c78d361d97340239270192b72d53e7b
    "第 4 章。聊天应用")中的类似，*聊天应用*，在那里我们使用了该模块进行实时通信。
- en: 'We''ll go only through the most important parts from our module to see different
    concepts in action. Let''s create a file called `app/services/auctioneer.js` and
    add the following content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只通过我们的模块中最重要的一部分来查看不同的概念在实际中的应用。让我们创建一个名为 `app/services/auctioneer.js` 的文件，并添加以下内容：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So basically, we just structured our class and called a few methods in the
    constructor. We are already familiar with a few lines of code from the constructor;
    for example, the `.initMiddlewares()` method looks similar to [Chapter 4](part0046_split_000.html#1BRPS1-5c78d361d97340239270192b72d53e7b
    "Chapter 4. Chat Application"), *Chat Application*, where we use middlewares to
    authorize and authenticate users:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，我们只是结构化我们的类并在构造函数中调用了一些方法。我们已经熟悉构造函数中的一些代码；例如，`.initMiddlewares()` 方法看起来与[第4章](part0046_split_000.html#1BRPS1-5c78d361d97340239270192b72d53e7b
    "第4章。聊天应用")，*聊天应用*相似，在那里我们使用中间件来授权和验证用户：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We made a clear split between our `SocketIO` handlers that are initialized when
    we call the `.bindHandlers()` method, and attached the listeners to our mediator
    by calling the `.bindListeners()` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调用 `.bindHandlers()` 方法时初始化了我们的 `SocketIO` 处理程序，并通过调用 `.bindListeners()`
    方法将监听器附加到我们的中介者上。
- en: 'So, our `.bindHandlers()` method will have the following structure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的 `.bindHandlers()` 方法将具有以下结构：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember that this is only partial code, and the final version will have more
    handlers. So, when a new client connects, we attach a few handlers to our socket.
    For example, in the preceding code, we listen to the `place:bid` event, which
    will be called when a user places a new bid, and the `AuctionManager` service
    will persist that bid.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这只是一个部分代码，最终版本将包含更多的处理程序。所以，当新的客户端连接时，我们将一些处理程序附加到我们的socket上。例如，在先前的代码中，我们监听
    `place:bid` 事件，当用户放置新的出价时，该事件将被调用，并且 `AuctionManager` 服务将持久化该出价。
- en: Now, obviously we would need to notify other clients about the occurred changes;
    we are not going to handle that here. Our `.placeBid()` method emits an event
    through the `Mediator` each time a new bid is successfully recorded. The only
    thing we need to do is listen for that event, which we already did when we called
    `.bindListeners()` in the Auctioneer's constructor method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要通知其他客户端关于发生的变化；我们不会在这里处理这一点。我们的 `.placeBid()` 方法在每次成功记录新的出价时通过 `Mediator`
    发出事件。我们唯一需要做的是监听该事件，这在我们调用拍卖师构造方法中的 `.bindListeners()` 时已经完成了。
- en: 'Let''s take a look at a partial code sample from the `.bindListeners()` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `.bindListeners()` 方法的一个部分代码示例：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we are listening when a bidder joins an auction, and
    we broadcast a message to each client, expecting only the triggering socket client.
    When a new bid is placed, we emit an event to each socket client. So basically,
    we have two similar broadcast functionalities but with a major difference; one
    sends a message to each client expecting the one that triggered the event, and
    the second emits to all connected clients.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们监听当一位竞标者加入拍卖时的情况，并向每个客户端广播一条消息，期望只触发事件的socket客户端。当放置新的出价时，我们向每个socket客户端发出事件。所以基本上，我们有两个类似的广播功能，但有一个主要区别；一个向每个客户端发送消息，期望触发事件的那个客户端，而第二个则向所有已连接的客户端广播。
- en: Using the service from controller
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从控制器中使用服务
- en: As we discussed earlier, our services can be consumed from any module and exposed
    in different ways to clients. Earlier, we used `AuctionManager` and exposed its
    business logic through WebSockets. Now, we are going to do the same using simple
    endpoints.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，我们的服务可以从任何模块中消费，并以不同的方式向客户端暴露。之前，我们使用了 `AuctionManager` 并通过WebSockets公开其业务逻辑。现在，我们将使用简单的端点来完成同样的工作。
- en: 'Let''s create a controller file called `app/controllers/auction.js` with the
    following content:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `app/controllers/auction.js` 的控制器文件，并包含以下内容：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have already done this many times throughout the book, so there's nothing
    new here. The controller exports a function that will attach all the auctions
    returned from the service, and later on the response will be transformed into
    a JSON response.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中已经多次这样做，所以这里没有什么新的。控制器导出一个函数，该函数将附加从服务返回的所有拍卖，并且稍后响应将被转换为JSON响应。
- en: Accessing data from the e-commerce API
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从电子商务API获取数据
- en: When creating auctions, we need additional information about the item we add
    to the auction. All the info about the product item is stored on the e-commerce
    platform built in the previous chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建拍卖时，我们需要关于我们添加到拍卖中的物品的额外信息。关于产品物品的所有信息都存储在上一章中构建的电子商务平台上。
- en: We didn't cover the creation of auctions in this chapter, but we can discuss
    the underlining communication layer with the e-commerce API. In the data modeling
    phase, we didn't discuss storing users in the database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中没有涵盖拍卖的创建，但我们可以讨论与电子商务API的底层通信层。在数据建模阶段，我们没有讨论将用户存储在数据库中。
- en: The reason for not including user management is that we are going to consume
    a third-party API to manage our users. For example, authentication and registration
    will be handled through the e-commerce platform.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不包括用户管理的原因是我们将消耗第三方API来管理我们的用户。例如，验证和注册将通过电子商务平台处理。
- en: E-commerce client service
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子商务客户端服务
- en: To communicate with the third-party API, we are going to create a service to
    proxy the requests. As we don't consume many endpoints from the API, we can create
    a single service to handle everything. As your application grows, you could easily
    group your files by domain context.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与第三方API进行通信，我们将创建一个服务来代理请求。由于我们不会从API消费很多端点，我们可以创建一个单一的服务来处理所有事情。随着你的应用程序的增长，你可以轻松地根据域上下文对文件进行分组。
- en: 'Let''s create a new file called `app/services/ecommerce-client.js`, and follow
    these steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`app/services/ecommerce-client.js`的新文件，并按照以下步骤操作：
- en: 'Declare the constants used in the service and include the dependencies:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明在服务中使用的常量并包含依赖项：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define a custom `RequestOptions` class used to configure the request object:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于配置请求对象的自定义`RequestOptions`类：
- en: '[PRE20]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To reduce the necessary code structure used to make calls with `request`, we
    defined a custom class to instantiate a default request option.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了减少使用`request`进行调用所需的代码结构，我们定义了一个自定义类来实例化默认的请求选项。
- en: 'Add the `EcommerceClient` class:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`EcommerceClient`类：
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `EcommerceClient` class is going to be our main entry point to the third-party
    API. It's more of a facade to not know the underlining data source used in our
    application.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EcommerceClient`类将成为我们访问第三方API的主要入口点。它更像是一个门面，以不知道我们应用程序中使用的底层数据源。'
- en: 'Specify how to authenticate users:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定如何验证用户：
- en: '[PRE22]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The API server will handle the authentication for us; we are just using the
    token returned when making calls to the API. Our custom `RequestOptions` class
    permits us to add extra header data, such as the `Authorization` field.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: API服务器将为我们处理验证；我们只是使用在调用API时返回的令牌。我们的自定义`RequestOptions`类允许我们添加额外的头部数据，例如`Authorization`字段。
- en: 'Append the `getProducts()` method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`getProducts()`方法：
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, with the same principle, we can retrieve data from our e-commerce
    application. The only thing is that we need to add a token to our calls. We are
    not going to discuss how we consume our service, as we have done this many times
    throughout the book.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用相同的原理，我们可以从我们的电子商务应用程序中检索数据。唯一不同的是，我们需要在我们的调用中添加一个令牌。我们不会讨论如何消费我们的服务，因为我们已经在本书中多次这样做过。
- en: It should be fairly simple to use it in a controller and configure a router
    to expose the necessary endpoints to the client application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器中使用它应该相当简单，并配置一个路由器来向客户端应用程序公开必要的端点。
- en: Frontend services
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端服务
- en: As we are touching only the most significant part of our application, we are
    going to discuss the implementation of our services used in the Angular application.
    I think it's important to understand the underlying communication layer with the
    backend application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只触及我们应用程序的最重要部分，我们将讨论在Angular应用程序中使用的服务的实现。我认为理解与后端应用程序的底层通信层是很重要的。
- en: Auction service
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拍卖服务
- en: '`AuctionService` will handle all communications with the backend API to get
    info about a specific auction, or simply get all the available auctions. To do
    that, we are going to create a new file, `public/src/services/auction.service.ts`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuctionService`将处理与后端API的所有通信，以获取特定拍卖的信息，或者简单地获取所有可用的拍卖。为此，我们将创建一个新的文件，`public/src/services/auction.service.ts`：'
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We imported our dependencies, and we''ve added an `URL` constant for better
    code readability, but you may handle your base URL configuration as you desire.
    A few things are missing before we can add the necessary methods, so let''s define
    the constructor and class props:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了我们的依赖项，并添加了一个`URL`常量以提高代码的可读性，但你可以按自己的意愿处理基本URL配置。在我们添加必要的方法之前，还有一些事情需要处理，所以让我们定义构造函数和类属性：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are exporting an Observable for a single auction and a list of auctions.
    Also, we are interested in the current auction. Besides all the familiar definitions,
    we added a third service to be used internally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出了一个用于单个拍卖和拍卖列表的 Observable。我们还对当前拍卖感兴趣。除了所有熟悉的定义外，我们还添加了一个用于内部使用的第三个服务。
- en: 'When getting a single auction or all auctions, we''ll update the next value
    of the observers, so that subscribers get notified by the occurrence of changes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取单个拍卖或所有拍卖时，我们将更新观察者的下一个值，以便订阅者通过变化的发生得到通知：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To get a single auction, we can use the following method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取单个拍卖，我们可以使用以下方法：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, this service is going to communicate with our Node.js application and store
    all the received data in an internal store. Besides getting data from the server,
    we also want to eventually store the current auction, so this piece of code should
    handle it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个服务将与我们 Node.js 应用程序通信，并将所有接收到的数据存储在内部存储中。除了从服务器获取数据外，我们最终还想存储当前的拍卖，因此这段代码应该处理它：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The socket service
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字服务
- en: The socket service is going to handle the communication with the SocketIO server.
    The benefit is that we have a single point of entry and we can abstract the underlying
    logic to the rest of the application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字服务将处理与 SocketIO 服务器的通信。好处是，我们有一个单一的入口点，并且可以将底层逻辑抽象到应用程序的其余部分。
- en: 'Create a new file called `public/src/common/socket.service.ts`, and add the
    following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `public/src/common/socket.service.ts` 的新文件，并添加以下内容：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We just import the SocketIO client and all the rest of the data types. Also,
    don''t forget to add the rest of the necessary code for your class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只导入 SocketIO 客户端和所有其他数据类型。另外，别忘了添加你类所需的其余必要代码：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An interesting thing we are doing here is to expose Observables—and the rest
    of the application can just subscribe to the stream of data—using the following
    technique:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的一件有趣的事情是，通过以下技术公开 Observables——应用程序的其余部分可以订阅数据流：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The nice part about RxJs is that we can create Observables from events. As the
    socket emits events, we can just create an Observable from that. With the preceding
    code, we can subscribe to incoming data from the backend.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: RxJs 的优点在于我们可以从事件中创建 Observables。当套接字发出事件时，我们只需从该事件创建一个 Observable。使用前面的代码，我们可以订阅来自后端的数据。
- en: 'In order to send information to the backend through SocketIO, we can expose
    an `.emit()` method that would be just a wrapper around the `.emit()` method on
    the socket client:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过 SocketIO 向后端发送信息，我们可以公开一个 `.emit()` 方法，它将只是套接字客户端上的 `.emit()` 方法的包装器：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The bid service
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投标服务
- en: 'To get the big picture, we can take a look at the `BidService` found under
    the following path: `public/src/bid/bid.service.ts`. The class will have a similar
    structure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解整体情况，我们可以查看位于以下路径下的 `BidService`：`public/src/bid/bid.service.ts`。该类将具有类似的结构：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`BidService` will interact with `SocketService` in order to place bids, which
    will be pushed to all connected clients through the Express backend application.
    We also filter each incoming bid by the currently selected auction.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`BidService` 将与 `SocketService` 交互以放置投标，这些投标将通过 Express 后端应用程序推送到所有已连接的客户端。我们还根据当前选定的拍卖过滤每个传入的投标。'
- en: When the currently selected auction changes, we want to update our local copy
    by subscribing to `currentAuction` from `AuctionService`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前选定的拍卖发生变化时，我们想通过订阅 `AuctionService` 的 `currentAuction` 来更新我们的本地副本。
- en: The bidder service
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投标服务
- en: '`BidderService` is going to be the first one to use `SocketService` and subscribe
    to changes on the `bidder` object. It will store all the incoming data from the
    backend Node.js server.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`BidderService` 将是第一个使用 `SocketService` 并订阅 `bidder` 对象变化的。它将存储来自后端 Node.js
    服务器的所有传入数据。'
- en: 'Let''s create a new file called `public/src/services/bidder.service.ts`, and
    add the following base content:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `public/src/services/bidder.service.ts` 的新文件，并添加以下基本内容：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have a starting point, we can define our constructor and declare
    all the necessary properties:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了起点，我们可以定义我们的构造函数并声明所有必要的属性：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this proof of concept, we are not going to do any HTTP calls from this service,
    and mostly we are going to store information inside the data store. The following
    `public` methods will come in handy:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个概念验证中，我们不会从这个服务中进行任何 HTTP 调用，并且我们主要会在数据存储中存储信息。以下 `public` 方法将很有用：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding logic was used in a similar form in earlier chapters. To keep
    it short, we just store the bidders or a single bidder in our data structures
    and update the next value of the observer, so that every subscriber gets notified
    to get the latest values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经以类似的形式使用了这种逻辑。为了简化，我们只需在我们的数据结构中存储竞标者或单个竞标者，并更新观察者的下一个值，这样每个订阅者都会收到通知以获取最新值。
- en: 'Earlier, we used a `Bidder` custom data type—or a model if it sounds more familiar
    to you. Let''s take a quick look at it, found under the following path—`public/src/datatypes/bidder.ts`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用了一个自定义数据类型 `Bidder`——或者如果你更熟悉，可以称之为模型。让我们快速看看它，位于以下路径——`public/src/datatypes/bidder.ts`：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Auction module
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拍卖模块
- en: We have taken the initial steps and implemented our services. Now we can start
    to use them in our components. There are many moving things in our `Auction` application.
    The most demanding part of the app will be the auction detail page.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经采取了初步步骤并实现了我们的服务。现在我们可以开始在组件中使用它们了。在我们的 `Auction` 应用程序中有很多动态元素。应用程序中最具挑战性的部分将是拍卖详情页面。
- en: The preceding code will list the details about a specific auction and also list
    the current bids. When a new bid is placed, it will be pushed to the `bids` list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将列出特定拍卖的详细信息，并列出当前的出价。当放置新的出价时，它将被推送到 `bids` 列表。
- en: 'Earlier in our services, we used the `Auction` model. Let''s take a look at
    it first. It can be found under `public/src/auction/auction.model.ts`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务中，我们之前使用了 `Auction` 模型。让我们首先看看它，它位于 `public/src/auction/auction.model.ts`：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It has a long list of properties. We are doing some initializations when we
    instantiate the model. We use a custom `Money` model, which reflects our custom
    monetary type from the backend.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它有很多属性。当我们实例化模型时，我们进行一些初始化。我们使用一个自定义的 `Money` 模型，它反映了后端的自定义货币类型。
- en: If you remember, in the `Job Board` application, we used nice URLs to access
    a company. I wanted to have the same aspect but add a little bit of a twist to
    experiment with a different structure. We have the same concept but a different
    identifier for an auction.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在 `Job Board` 应用程序中，我们使用了漂亮的 URL 来访问一家公司。我想保持同样的外观，但添加一点变化来尝试不同的结构。我们有相同的概念，但拍卖有一个不同的标识符。
- en: 'We are using the product''s slug in combination with the auction''s `_id` for
    our `identifier` property. Now let''s take a look at the `Money` model, `public/src/common/money.model.ts`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用产品的 slug 与拍卖的 `_id` 结合来作为我们的 `identifier` 属性。现在让我们看看 `Money` 模型，位于 `public/src/common/money.model.ts`：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can remember, we are using these techniques to have initial values for
    our objects and to make sure we have the necessary properties. To fresh up our
    memories, the `amount` is obtained by multiplying the `display` value with the
    `factor`. This is all done on the server side.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，我们正在使用这些技术来为我们的对象提供初始值，并确保我们有必要的属性。为了刷新我们的记忆，`amount` 是通过将 `display` 值与
    `factor` 相乘得到的。所有这些都是在服务器端完成的。
- en: The base component
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本组件
- en: 'We are going to add a base component that configures our routes. Our base component
    is usually pretty basic, without much logic; it has only routing-related logic.
    Create a new file called `public/src/auction/components/auction-base.component.ts`,
    and add the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个基本组件来配置我们的路由。我们的基本组件通常非常基础，没有太多逻辑；它只有与路由相关的逻辑。创建一个名为 `public/src/auction/components/auction-base.component.ts`
    的新文件，并添加以下代码：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The auction list
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拍卖列表
- en: 'To display a list of currently available auctions, we are going to create a
    new component, called `public/src/auction/components/auction-list.component.ts`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示当前可用的拍卖列表，我们将创建一个新的组件，名为 `public/src/auction/components/auction-list.component.ts`：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: From this component, we'll link to the auction detail. As you can see, we used
    the `identifier` as a router param. The value of the property was constructed
    inside the `Auction` model.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个组件，我们将链接到拍卖详情。正如你所见，我们使用了 `identifier` 作为路由参数。属性值是在 `Auction` 模型内部构建的。
- en: The detail page
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详情页面
- en: 'The detail page will have the most moving parts in this application. We are
    going to display the auction''s details and list all new bids. Also, the user
    can bid from this page. To implement this component, let''s follow these steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，详情页面将包含最多的动态部分。我们将显示拍卖的详细信息并列出所有新的出价。此外，用户也可以从该页面进行出价。为了实现这个组件，让我们遵循以下步骤：
- en: Create a new file called `public/src/auction/components/auction-detail.component.ts`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `public/src/auction/components/auction-detail.component.ts` 的新文件。
- en: 'Add the dependencies:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加依赖项：
- en: '[PRE42]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Configure the `Component` annotation:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `Component` 注解：
- en: '[PRE43]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加类：
- en: '[PRE44]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Implement `ngOnInit`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `ngOnInit`：
- en: '[PRE45]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add `ngOnDestroy`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ngOnDestroy`：
- en: '[PRE46]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When the component is destroyed, we want to set `currentAuction` to be empty.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当组件被销毁时，我们希望将 `currentAuction` 设置为空。
- en: 'Define the private `getAuctionId` method:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义私有的 `getAuctionId` 方法：
- en: '[PRE47]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We are using `RouterParams` to get the identifier. Because we have the nice
    URI we need to strip only the necessary information from the identifier. For that,
    we used a private method that splits the URL component into chunks and gets only
    the last portion.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `RouterParams` 来获取标识符。因为我们有一个很好的 URI，我们只需要从标识符中剥离必要的信息。为此，我们使用了一个私有方法，该方法将
    URL 组件分割成块，并只获取最后一部分。
- en: The last part of the URL is the auction's `id`. After we have the necessary
    `id`, we can retrieve the information from our API.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: URL 的最后一部分是拍卖的 `id`。在获得必要的 `id` 后，我们可以从我们的 API 中检索信息。
- en: This component uses two other components, `BidListComponent` and `BidFormComponent`.
    The first is used to display a list of bids, listen to the bids' data stream,
    and update the bids list.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件使用了两个其他组件，`BidListComponent` 和 `BidFormComponent`。第一个用于显示出价列表，监听出价数据流，并更新出价列表。
- en: The second, `BidFormComponent`, is used to make bids. It's easier to encapsulate
    all the functionalities into separate components. This way, each component can
    focus on its domain requirements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，`BidFormComponent`，用于出价。将所有功能封装到单独的组件中更容易。这样，每个组件都可以专注于其领域需求。
- en: The bid module
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出价模块
- en: We are going to close our chapter with the `bid` module, as we used many of
    its components in the previous `auction` module. Only the `bid listing` will be
    discussed, as it implies working with the underlining socket stream.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用 `bid` 模块来结束这一章，因为我们已经在之前的 `auction` 模块中使用了它的许多组件。这里只讨论 `bid listing`，因为它涉及到与底层套接字流的工作。
- en: Listing bids
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出出价
- en: From the previous `AuctionDetailComponent`, we can see that this component will
    have the bids as input. This data comes from the `auction` entity, which holds
    previously placed bids.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的 `AuctionDetailComponent` 我们可以看到，这个组件将以出价为输入。这些数据来自 `auction` 实体，它保存了之前放置的出价。
- en: 'Create a new file called `public/src/bid/components/bid-list.component.ts`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `public/src/bid/components/bid-list.component.ts` 的新文件：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We subscribe to the `bid` data stream from `BidService` to push all the new
    incoming bids and display them using `BidComponent`. The subscription is also
    stored so that we can unsubscribe from the stream when the component is destroyed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅了来自 `BidService` 的 `bid` 数据流，以推送所有新的 incoming bids 并使用 `BidComponent` 显示它们。订阅也被存储起来，这样我们可以在组件销毁时取消订阅流。
- en: The bid component
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出价组件
- en: 'Our bid component is going to be fairly simple. It will have a `bid` input,
    and after the view is initialized successfully, we are going to scroll to the
    bottom of the bid listing view. Let''s create the following component under `public/src/bid/components/bid.component.ts`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的出价组件将会相当简单。它将有一个 `bid` 输入，在视图初始化成功后，我们将滚动到出价列表视图的底部。让我们在 `public/src/bid/components/bid.component.ts`
    下创建以下组件：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Also let''s take a look at our `bid` model, `public/bid/bid.model.ts`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还让我们看看我们的 `bid` 模型，`public/bid/bid.model.ts`：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now we have a full round trip from the backend to our frontend components. Data
    is streamed from the WebSocket server to our Angular 2 application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从后端到我们的前端组件完成了一次完整的往返。数据从 WebSocket 服务器流到我们的 Angular 2 应用程序。
- en: This application had the purpose of going through all the techniques used in
    the book, and we had a chance to put together a proof of concept. The main focus
    of the chapter was to see the underlining modules, how they will be combined,
    and how data will be modeled and transmitted between each module.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的目的是浏览书中使用的所有技术，我们有机会组装一个概念验证。本章的主要重点是查看底层模块，它们将如何组合，以及数据如何在各个模块之间建模和传输。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This is our final chapter, and we created a small proof-of-concept application.
    The purpose was to go through some of the most interesting parts and methods used
    in the book and see how we can combine exciting ideas to create something small
    but powerful.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的最后一章，我们创建了一个小的概念验证应用程序。目的是浏览书中的一些最有趣的部分和方法，看看我们如何将激动人心的想法结合起来，创建出既小又强大的东西。
- en: Also, we used our existing e-commerce API to retrieve information about product
    items and manage our users. There was no reason to go through this process again
    as we can rely on third-party APIs for faster prototyping.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用了现有的电子商务 API 来检索有关产品项的信息并管理我们的用户。我们没有理由再次经历这个过程，因为我们可以在快速原型设计时依赖第三方 API。
- en: Through most of the chapters, we only touched the most important parts. All
    the necessary code can be found on the Packt Publishing website ([https://www.packtpub.com/](https://www.packtpub.com/))
    for each chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数章节中，我们只触及了最重要的部分。每个章节所需的所有代码都可以在Packt Publishing网站上找到（[https://www.packtpub.com/](https://www.packtpub.com/))。
