- en: Chapter 2. Getting Started with Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：Node.js入门
- en: 'This chapter will get you up and running with Node.js. You''ll see how quick
    this can be and how easy it is to start writing web applications. You''ll also
    choose a development environment for working with Node.js. In this chapter, we
    will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你开始使用Node.js。你会看到这有多快，以及开始编写网络应用有多容易。你还将选择一个用于Node.js开发的开发环境。在本章中，我们将涵盖以下主题：
- en: Installing Node.js
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: Writing our first Node.js web application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个Node.js网络应用程序
- en: Setting up our development environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: Installing and running Node.js
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和运行Node.js
- en: To install Node.js, visit [https://nodejs.org](https://nodejs.org), and download
    and run the installer package for the currently recommended version. The examples
    in this book are based on Node.js v6, released in April 2016 and supported through
    to April 2018.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Node.js，请访问[https://nodejs.org](https://nodejs.org)，下载并运行当前推荐版本的安装程序包。本书中的示例基于2016年4月发布的Node.js
    v6，支持到2018年4月。
- en: After installation, open up a console window (run command prompt on Windows,
    or terminal on Mac) and type `node`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，打开控制台窗口（在Windows上运行命令提示符，或在Mac上运行终端）并输入`node`。
- en: 'This opens the Node.js REPL, which works like the JavaScript console in browsers.
    Try typing in a few commands and see the output:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开Node.js的REPL，它就像浏览器中的JavaScript控制台一样工作。尝试输入几个命令并查看输出：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let''s make use of one of the Node.js-specific APIs to create an HTTP server.
    Type the following commands into the REPL (the output of each command is omitted
    from the listing below for brevity):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们利用Node.js特有的API之一来创建一个HTTP服务器。在REPL中输入以下命令（每个命令的输出为了简洁起见省略）：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now try visiting `http://localhost:3000` in your browser. Congratulations! You
    have written your first web server, in just two lines of code. The first line
    defines a callback function for handling HTTP requests and returning a response.
    The second line sets up a new server that accepts HTTP requests on port 3000 and
    invokes our callback function for each request.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试在你的浏览器中访问`http://localhost:3000`。恭喜！你只用两行代码就编写了你的第一个网络服务器。第一行定义了一个处理HTTP请求并返回响应的回调函数。第二行设置了一个新的服务器，该服务器在端口3000上接受HTTP请求，并为每个请求调用我们的回调函数。
- en: You can exit the Node.js REPL by typing `process.exit()`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入`process.exit()`来退出Node.js的REPL。
- en: Choosing an editor
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择编辑器
- en: 'Of course, we''re not going to write all of our code inside the REPL. You can
    use any text editor or IDE you like for writing JavaScript for Node.js. If you''re
    not sure what to use, try one of the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不会在REPL中编写所有的代码。你可以使用任何你喜欢的文本编辑器或IDE来编写Node.js的JavaScript代码。如果你不确定该使用什么，可以尝试以下之一：
- en: Atom ([https://atom.io/](https://atom.io/))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atom ([https://atom.io/](https://atom.io/))
- en: Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
- en: These are both free, lightweight IDEs that are actually implemented in Node.js.
    They are both available for Windows, Mac, and Linux.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是免费的、轻量级的IDE，实际上是用Node.js实现的。它们都适用于Windows、Mac和Linux。
- en: The code listings in the rest of this book will be JavaScript source code files,
    not commands to be typed into the REPL.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书其余部分中的代码列表将是JavaScript源代码文件，而不是要输入到REPL中的命令。
- en: Using an application framework
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序框架
- en: The server we created in the REPL used the low-level HTTP module built into
    Node.js. This provides an API for creating a server that reads data from requests
    and writes to responses.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在REPL中创建的服务器使用了Node.js内置的低级HTTP模块。这提供了一个API来创建一个从请求中读取数据并向响应写入的服务器。
- en: As with other programming platforms, there are frameworks available providing
    more useful high-level abstractions for writing web applications. These include
    things such as URL routing and templating engines. ASP.NET MVC, Ruby on Rails,
    and Spring MVC are all examples of such frameworks on different platforms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程平台一样，有可用的框架提供了编写网络应用的高级抽象。这些包括诸如URL路由和模板引擎等功能。ASP.NET MVC、Ruby on Rails和Spring
    MVC都是不同平台上此类框架的例子。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Example code**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: If you get stuck at any point in this book, you can follow along with the code
    at [https://github.com/NodeJsForDevelopers](https://github.com/NodeJsForDevelopers)
    (there is a repository for each chapter and a commit for each heading that introduces
    any new code).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这本书的任何地方遇到困难，你可以通过[https://github.com/NodeJsForDevelopers](https://github.com/NodeJsForDevelopers)上的代码进行跟随（每个章节都有一个存储库，每个引入新代码的标题都有一个提交）。
- en: In this book, we'll be using a framework called Express to write a web application
    in Node.js. Express is the most popular web application framework for Node.js.
    It is well suited to small-scale applications such as the one we'll be building.
    It also provides a good introduction to important concepts. Most other popular
    Node.js web application frameworks are conceptually similar to Express, and several
    are actually built on top of it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用名为 Express 的框架来在 Node.js 中编写网络应用程序。Express 是 Node.js 中最受欢迎的网络应用程序框架。它非常适合我们即将构建的小型应用程序。它还提供了对重要概念的良好介绍。大多数其他流行的
    Node.js 网络应用程序框架在概念上与 Express 类似，其中几个实际上是在其之上构建的。
- en: Getting started with Express
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Express
- en: 'To get our Express-based application started, we''ll use npm to install the
    `express-generator` package, which will create a skeleton application based on
    Express. Run the following command in the console (that is, your regular terminal,
    not inside the Node.js REPL):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的基于 Express 的应用程序，我们将使用 npm 安装 `express-generator` 包，该包将基于 Express 创建一个骨架应用程序。请在控制台（即您的常规终端，而不是
    Node.js REPL 内部）运行以下命令：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `-g` option installs the Express generator globally, so you can run it
    from anywhere. The next command we run will create a new folder to contain our
    application code, so run this command wherever you want this folder to reside:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` 选项全局安装 Express 生成器，因此您可以从任何位置运行它。我们接下来要运行的命令将创建一个新的文件夹来存放我们的应用程序代码，因此请运行此命令，以便将此文件夹放置在您希望的位置：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Templating engines**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板引擎**'
- en: Express offers a choice of templating engines. We'll be using Hogan, which is
    an implementation of the Mustache templating engine. You may already be familiar
    with Mustache from client-side libraries. Don't worry if not, though. It's very
    simple to pick up.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Express 提供了模板引擎的选择。我们将使用 Hogan，它是 Mustache 模板引擎的一个实现。您可能已经从客户端库中熟悉了 Mustache。不过，即使不熟悉也不要担心。它非常容易上手。
- en: 'As you can see from the output, this sets up a minimal standard application
    structure for us. Now run the following command (as instructed by the generator
    output) to install the modules on which our application depends:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，这为我们设置了一个最小标准应用程序结构。现在，按照生成器的指示，运行以下命令来安装我们的应用程序所依赖的模块：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The generator has created a skeleton Node.js web application for us. Let''s
    try running this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器为我们创建了一个骨架 Node.js 网络应用程序。让我们尝试运行它：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now visit `http://localhost:3000` again and you''ll see the Express welcome
    page as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次访问 `http://localhost:3000`，您将看到如此处所示的 Express 欢迎页面：
- en: '![Getting started with Express](img/image00213.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Express](img/image00213.jpeg)'
- en: Exploring our Express application
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索我们的 Express 应用程序
- en: 'Let''s look at the folders that the Express generator created for us:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Express 生成器为我们创建的文件夹：
- en: '`node_modules`: This folder contains the third-party packages that our application
    depends on, which are installed when we run `npm install` (it is common to exclude
    this directory from source control)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules`：此文件夹包含我们的应用程序所依赖的第三方包，这些包在我们运行 `npm install` 时安装（通常会将此目录排除在源代码控制之外）'
- en: '`public`: This folder contains the static assets of our application: images,
    client-side JavaScript, and CSS'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：此文件夹包含我们的应用程序的静态资源：图像、客户端 JavaScript 和 CSS'
- en: '`routes`: This folder contains the logic of our application'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`：此文件夹包含我们的应用程序的逻辑'
- en: '`views`: This folder contains the server-side templates for our application'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`：此文件夹包含我们的应用程序的服务器端模板'
- en: 'There are also some files that aren''t contained in any of the preceding folders:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些文件不包含在任何前面的文件夹中：
- en: '`package.json`: This file contains metadata about our application used by the
    `npm install` and `npm start` commands used earlier. We''ll explore this file
    further in [Chapter 4](part0025.xhtml#aid-NQU21 "Chapter 4. Introducing Node.js
    Modules"), *Introducing Node.js Modules*.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`：此文件包含我们的应用程序的元数据，这些元数据由之前使用的 `npm install` 和 `npm start` 命令使用。我们将在第
    4 章[介绍 Node.js 模块](part0025.xhtml#aid-NQU21 "第 4 章。介绍 Node.js 模块")中进一步探讨此文件。'
- en: '`app.js`: This file is the main entry point for our application, which glues
    together all of the preceding components and initializes Express. We''ll go through
    this file in more detail later on in this chapter.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.js`：此文件是应用程序的主要入口点，它将所有前面的组件粘合在一起并初始化 Express。我们将在本章后面更详细地介绍此文件。'
- en: '`bin/www`: This file is a Node.js script that launches our application. This
    is the script that gets executed when we run `npm start`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin/www`：此文件是一个 Node.js 脚本，用于启动我们的应用程序。这是当我们运行 `npm start` 时执行的脚本。'
- en: It's not important to understand everything in the `bin/www` script at this
    point. However, note that it uses the same `http.createServer` call as in the
    REPL example before. This time, though, the listener argument is not a simple
    function but is our entire application (defined in `app.js`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，理解 `bin/www` 脚本中的所有内容并不重要。然而，请注意，它使用了与REPL示例中相同的 `http.createServer` 调用。不过，这次监听器参数不是一个简单的函数，而是我们整个应用程序（定义在
    `app.js` 中）。
- en: Understanding Express routes and views
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Express路由和视图
- en: '**Routes** in Express contain the logic for handling requests and rendering
    the appropriate response. They have similar responsibilities to controllers in
    MVC frameworks such as ASP.NET, Spring MVC, or Ruby on Rails.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由** 在Express中包含处理请求和渲染适当响应的逻辑。它们在MVC框架（如ASP.NET、Spring MVC或Ruby on Rails）中的控制器有类似的责任。'
- en: 'The route that serves the page we just viewed in the browser can be found at
    `routes/index.js` and looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中为我们刚刚查看的页面服务的路由可以在 `routes/index.js` 中找到，其看起来如下所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `require` call imports the Express module. We will discuss how this works
    in much more detail in [Chapter 4](part0025.xhtml#aid-NQU21 "Chapter 4. Introducing
    Node.js Modules"), *Introducing Node.js Modules*. For now, think of it like a
    `using` or `import` statement in .NET or Java. The call to `express.Router()`
    creates a context under which we can define new routes. We will discuss this in
    more detail later on in this chapter (see *Creating modular applications with
    Express*). The `router.get()` call adds a new handler to this context for GET
    requests to the path `'/'`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 调用导入了Express模块。我们将在[第4章](part0025.xhtml#aid-NQU21 "第4章。介绍Node.js模块")中更详细地讨论它是如何工作的，*介绍Node.js模块*。现在，把它想象成.NET或Java中的
    `using` 或 `import` 语句。对 `express.Router()` 的调用创建了一个上下文，我们可以在其中定义新的路由。我们将在本章后面更详细地讨论这一点（见
    *使用Express创建模块化应用程序*）。`router.get()` 调用为这个上下文添加了一个新的处理器，用于处理 `''/''` 路径的GET请求。'
- en: The `callback` function takes a request and response argument, similar to the
    listener in our "Hello World!" server at the beginning of this chapter. However,
    the request and response in this case are objects provided by Express, with additional
    functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback` 函数接受一个请求和一个响应参数，类似于本章开头我们“Hello World!”服务器中的监听器。然而，这里的请求和响应是由Express提供的对象，具有额外的功能。'
- en: The `render` function allows us to respond with a template, which is rendered
    using the data we pass to it. This is typically the last thing you will do in
    a route's `callback` function. Here, we pass an object containing the title *Express*
    to the view template.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 函数允许我们使用传递给它的数据来响应模板，这通常是路由的 `callback` 函数中最后做的事情。在这里，我们将包含标题 *Express*
    的对象传递给视图模板。'
- en: 'The view template can be found at `views/index.hjs` and looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模板可以在 `views/index.hjs` 中找到，其看起来如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a Hogan template. As mentioned previously, Hogan is an implementation
    of Mustache, a very lightweight templating language that limits the amount of
    logic in views. You can see the full syntax of Mustache at [https://mustache.github.io/mustache.5.html](https://mustache.github.io/mustache.5.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Hogan模板。如前所述，Hogan是Mustache的一个实现，Mustache是一个非常轻量级的模板语言，它限制了视图中的逻辑量。您可以在[https://mustache.github.io/mustache.5.html](https://mustache.github.io/mustache.5.html)查看Mustache的完整语法。
- en: Our template is a simple HTML page with some special template tags. The `{{
    title }}` tags are replaced with the title field from the data passed in by the
    route.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板是一个简单的HTML页面，包含一些特殊的模板标签。`{{ title }}` 标签会被路由传递进来的数据中的标题字段所替换。
- en: 'Let''s change the heading in the view to include a name as well as a title.
    It should look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变视图中的标题，使其包含一个名称以及一个标题。它应该看起来像这样：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Try reloading the page again. You should see the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试重新加载页面。你应该会看到以下内容：
- en: '![Understanding Express routes and views](img/image00214.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![理解Express路由和视图](img/image00214.jpeg)'
- en: 'We don''t have a name yet. That''s because there is no **name** field in our
    view data. Let''s fix that by editing our route:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有名称。这是因为我们的视图数据中没有 **name** 字段。让我们通过编辑我们的路由来修复这个问题：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we refresh our browser again at this point, we still won't see the name.
    That's because our application has already loaded our route, so won't pick up
    the change.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个时候再次刷新浏览器，我们仍然看不到名称。这是因为我们的应用程序已经加载了我们的路由，所以不会检测到变化。
- en: Go back to your terminal and kill the running application. Start it again (using
    `npm start`) and reload the page in the browser. You should now see the text **Hello,
    World!**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 返回您的终端并终止正在运行的应用程序。再次启动它（使用`npm start`），并在浏览器中重新加载页面。现在您应该会看到文本**Hello, World!**。
- en: Using nodemon for automatic restarts
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用nodemon进行自动重启
- en: 'Restarting the application every time we make a change is a bit tedious. We
    can do better by running our application with **nodemon**, which will automatically
    restart the application whenever we make a change:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们进行更改时都重新启动应用程序确实有点繁琐。我们可以通过使用**nodemon**来运行我们的应用程序来做得更好，它会在我们进行更改时自动重新启动应用程序：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Try updating the `routes/index.js` file again (for example, change the name
    string to your own name), then refresh the browser. This time, the change should
    appear without you needing to manually stop and restart the application. Note
    that the process is restarted by nodemon though, so if our application stored
    any internal state, this would be lost.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试更新`routes/index.js`文件（例如，将字符串名称更改为您自己的名称），然后刷新浏览器。这次，更改应该会显示出来，而无需您手动停止和重新启动应用程序。请注意，这个过程是由nodemon重新启动的，所以如果我们的应用程序存储了任何内部状态，这将丢失。
- en: Creating modular applications with Express
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Express创建模块化应用程序
- en: 'To find out how our route gets called when a request is made, we need to look
    at the `app.js` bootstrapping file. See the following two lines:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出当请求被发送时我们的路由是如何被调用的，我们需要查看`app.js`引导文件。请看以下两行：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This tells Express to use the routing context defined in `routes/index.js` for
    requests to the root path (`'/'`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Express使用在`routes/index.js`中定义的路由上下文来处理对根路径（`'/'`）的请求。
- en: There is a similar call setting up a route under the `/users` path. Try visiting
    this path in your browser. The route that renders this response is defined in
    `/routes/users.js`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/users`路径下设置路由的类似调用。尝试在浏览器中访问此路径。定义此响应的路由在`/routes/users.js`中。
- en: Note that the route in `/routes/users.js` is *also* bound to `'/'`, the same
    as the route in `/routes/index.js`. The reason this works is that these paths
    are each relative to a separate Router instance, and the instance created in `/routes/users.js`
    is mounted under the `/users` path in `app.js`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`/routes/users.js`中的路由**也**绑定到了`'/'`，与`/routes/index.js`中的路由相同。这样做的原因是这些路径各自相对于一个单独的路由器实例，而`/routes/users.js`中创建的实例在`app.js`中的`/users`路径下挂载。
- en: This mechanism makes it easy to build large applications composed from smaller
    modules. You can think of it as similar to the Areas functionality in ASP.NET
    MVC, or simply as an alternative structure to MVC controllers grouping together
    action methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制使得构建由较小模块组成的大型应用程序变得容易。您可以将它视为类似于ASP.NET MVC中的区域功能，或者简单地将其视为MVC控制器分组操作方法的替代结构。
- en: Bootstrapping an Express application
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导Express应用程序
- en: Let's take a look at the rest of the `app.js` file. Your file might not look
    identical to the listings below due to minor differences in our versions of Express,
    but it will contain broadly the same sections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`app.js`文件的其他部分。由于Express版本之间的细微差异，您的文件可能看起来与下面的列表不完全相同，但它将包含大致相同的部分。
- en: 'The various `require()` calls at the top of the file import the modules used
    by the application, including built-in Node.js modules (HTTP and Path), third-party
    libraries, and the application''s own routes. The following lines initialize Express,
    telling it where to look for view templates and what rendering engine to use (in
    our case, Hogan):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部的各种`require()`调用导入了应用程序使用的模块，包括内置的Node.js模块（HTTP和Path）、第三方库以及应用程序自己的路由。以下行初始化Express，告诉它在哪里查找视图模板以及使用什么渲染引擎（在我们的情况下，是Hogan）。
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The rest of the file consists of calls to `app.use()`. These register various
    different **middleware** for processing the request. The order in which they are
    registered forms a request processing pipeline. You might already be familiar
    with this pattern from servlet filters in Java, or the `IAppBuilder`/`IApplicationBuilder`/`IBuilder`
    interfaces in OWIN and ASP.NET. Don't worry if not though; we'll explore middleware
    thoroughly here.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的其余部分由对`app.use()`的调用组成。这些注册了用于处理请求的各种不同的**中间件**。它们注册的顺序形成了一个请求处理管道。您可能已经熟悉这种模式来自Java中的servlet过滤器，或者来自OWIN和ASP.NET中的`IAppBuilder`/`IApplicationBuilder`/`IBuilder`接口。不过不用担心，我们将在这里彻底探讨中间件。
- en: Understanding Express middleware
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Express中间件
- en: Middleware functions are the fundamental building blocks of an Express application.
    They are simply functions that take request and response arguments (just like
    our listener functions before) and a reference to the next middleware in the chain.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数是 Express 应用程序的基本构建块。它们只是接受请求和响应参数（就像我们之前的监听函数一样）以及链中下一个中间件的引用的函数。
- en: Each middleware function can manipulate the request and response objects before
    passing onto the next middleware in the chain. By chaining middleware together
    in this way, you can build complex functionality from simple modular components.
    It also allows clean separation between your application logic and cross-cutting
    concerns such as logging, authentication, or error handling.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中间件函数都可以在传递给链中的下一个中间件之前操作请求和响应对象。通过这种方式将中间件链接在一起，你可以从简单的模块化组件构建复杂的功能。这也允许你的应用程序逻辑与诸如日志记录、身份验证或错误处理等横切关注点之间进行清晰的分离。
- en: Instead of passing control to the next middleware in the chain, a function can
    also end the processing of the request and return a response. Middleware can also
    be mounted to specific paths or router instances, for example, if we want enhanced
    logging on a particular part of our site.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不仅可以传递控制权给链中的下一个中间件，还可以结束请求的处理并返回一个响应。中间件也可以挂载到特定的路径或路由实例上，例如，如果我们想在网站的特定部分增强日志记录。
- en: 'In fact, Express routes are just another example of middleware: the routes
    that we have already looked at are ordinary middleware functions with the same
    three arguments noted above. They just happen to be mounted to a specific path
    and to return a response.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Express 路由只是中间件的一个例子：我们之前看过的路由是具有上述三个相同参数的普通中间件函数。它们只是恰好被挂载到特定的路径上，并返回一个响应。
- en: Implementing error handling
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现错误处理
- en: 'Let''s take a closer look at some of the middleware in `app.js`. First, look
    at the 404 error handler:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `app.js` 中的某些中间件。首先，看看 404 错误处理器：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function always returns a response. So why do we not always get a 404 from
    our application? Remember that middleware is called in order, and the routes (which
    are registered before this function) return a response and don't call the next
    middleware. This means that the 404 function will only be called for requests
    that don't match any route, which is exactly what we want.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数总是返回一个响应。那么为什么我们的应用程序不总是返回 404 呢？记住，中间件是按顺序调用的，并且路由（在函数注册之前）返回一个响应而不调用下一个中间件。这意味着只有不匹配任何路由的请求才会调用
    404 函数，这正是我们想要的。
- en: What about the other two error handlers in app.js? They return a 500 response
    with a custom error page. Why does our application not return a 500 response in
    all cases? How do these get executed if another middleware throws an error before
    calling `next()`?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，app.js 中的其他两个错误处理器是什么？它们返回一个带有自定义错误页面的 500 响应。为什么我们的应用程序在所有情况下都不返回 500 响应？如果另一个中间件在调用
    `next()` 之前抛出错误，这些是如何执行的？
- en: Error-handling is a special case in Express. Error-handling middleware functions
    take four arguments instead of three, with the first parameter being an error.
    They should be registered last, after all other middlewares.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 中，错误处理是一个特殊情况。错误处理中间件函数接受四个参数而不是三个，第一个参数是一个错误。它们应该在所有其他中间件之后注册。
- en: In the case of an error (either an error being thrown or a middleware function
    passing in an error argument when calling `next`), Express will skip any other
    non-error handling middleware and start executing the error handlers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现错误的情况下（无论是抛出错误还是中间件函数在调用 `next()` 时传递错误参数），Express 将跳过任何其他非错误处理中间件并开始执行错误处理器。
- en: Using Express middleware
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Express 中间件
- en: 'Let''s see some Express middleware in action by making use of cookie parsing
    middleware (which is already part of the skeleton application created by `express-generator`).
    We can do this by using a cookie to store how many times someone has visited the
    site. Update `routes/index.js` as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 cookie 解析中间件（它是 `express-generator` 创建的骨架应用程序的一部分）来查看一些 Express 中间件的实际应用。我们可以通过使用一个
    cookie 来存储某人访问网站次数来实现这一点。按照以下方式更新 `routes/index.js`：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And add a new line to `views/index.hjs`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 并在 `views/index.hjs` 中添加一行新内容：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now visit `http://localhost:3000/` again and refresh the page a few times.
    You should see the visit count increase based on the value stored in the cookie.
    To see what the cookie parsing middleware is doing for us, try deleting or commenting
    out the following line from `app.js` and reloading the page:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次访问`http://localhost:3000/`并刷新页面几次。您应该会看到访问计数根据存储在cookie中的值增加。要查看cookie解析中间件为我们做了什么，尝试删除或注释掉以下`app.js`中的这一行，然后重新加载页面：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see from the error, the `cookies` property of the request is now
    undefined. The cookie parsing middleware looks at the cookie header of the request
    and turns it into a convenient JavaScript object for us. This is a common use
    case for middleware. The `bodyParser` middleware functions do a very similar job
    with the request body, turning raw text into a JavaScript object that is easier
    to use in our routes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从错误中看到的那样，请求的`cookies`属性现在是未定义的。cookie解析中间件会查看请求的cookie头并将其转换为对我们来说方便的JavaScript对象。这是中间件的一个常见用例。`bodyParser`中间件对请求体执行非常相似的任务，将原始文本转换为JavaScript对象，使其在我们的路由中更容易使用。
- en: Note that the error response above also demonstrates our error handling middleware.
    Try commenting out the error handlers at the end of the `app.js` file and reloading
    the page again. We now get the default stack trace rather than the custom error
    response defined in our handler.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上面的错误响应还展示了我们的错误处理中间件。尝试注释掉`app.js`文件末尾的错误处理程序，然后再次重新加载页面。我们现在得到的是默认的堆栈跟踪，而不是我们在处理程序中定义的自定义错误响应。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we installed Node.js, saw how to interact with it from the
    command line, and started using it to write web applications. We learned about
    Express and how we can structure an application using routes and middleware.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们安装了Node.js，了解了如何从命令行与之交互，并开始用它来编写Web应用程序。我们学习了Express以及我们如何使用路由和中间件来构建应用程序的结构。
- en: Although we've seen some code in this chapter, we haven't really explored the
    JavaScript syntax in detail. Before adding more functionality to our application,
    we should make sure that we're up to speed with JavaScript. This is the subject
    of the next chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本章中看到了一些代码，但我们并没有真正详细地探索JavaScript语法。在我们向应用程序添加更多功能之前，我们应该确保我们对JavaScript足够熟悉。这是下一章的主题。
