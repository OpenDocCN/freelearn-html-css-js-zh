- en: Securing the Serverless Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护无服务器应用程序
- en: Handling security is an extensive and complex topic. If you don't do it right,
    you may be hacked. Even if you do everything right, you may be hacked. So it's
    important you understand the common security mechanisms to avoid exposing your
    website to vulnerabilities, and also, always follow the recommended practices
    and methodologies that have been largely tested and proven to be robust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 处理安全问题是一个广泛且复杂的话题。如果你没有正确处理，你可能会被黑客攻击。即使你做得一切正确，你也可能会被黑客攻击。因此，了解常见的安全机制以避免使你的网站暴露于漏洞是很重要的，同时，始终遵循经过大量测试和证明为稳健的推荐实践和方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basic security practices and concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本安全实践和概念
- en: Learning how to use Amazon Cognito
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 Amazon Cognito
- en: Developing the signup and login pages of the serverless store
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发无服务器商店的注册和登录页面
- en: Handling authorization and authentication of users in the backend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理后端用户的授权和身份验证
- en: By the end of this chapter, you will have acquired basic knowledge on how to
    handle security on AWS to build a serverless website.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将掌握如何在 AWS 上处理安全性的基础知识，以构建一个无服务器网站。
- en: Security basics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全基础
- en: 'One of the mantras of security experts is this: *don''t roll your own*. It
    means you should never use in a production system any kind of crypto algorithm
    or security model that you developed by yourself. Always use solutions that have
    been highly used, tested, and recommended by trusted sources. Even experienced
    people may commit errors and expose a solution to attacks, especially in the cryptography
    field, which requires advanced math. However, when a proposed solution is analyzed
    and tested by a great number of specialists, errors are much less frequent.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 安全专家的一个格言是：“不要自己动手”。这意味着你永远不应该在生产系统中使用你自己开发的任何类型的加密算法或安全模型。始终使用那些被高度使用、测试并由可信来源推荐过的解决方案。即使是经验丰富的人也可能犯错，使解决方案暴露于攻击之下，尤其是在需要高级数学的密码学领域。然而，当一个解决方案被大量专家分析和测试时，错误发生的频率会大大降低。
- en: In the security world, there is a term called **security through obscurity**.
    It is defined as a security model where the implementation mechanism is not publicly
    known, so there is a belief that it is secure because no one has prior information
    about the flaws it has. It can be indeed secure, but if used as the only form
    of protection, it is considered as a poor security practice. If a hacker is persistent
    enough, he or she can discover flaws even without knowing the internal code. In
    this case again, it's better to use a highly tested algorithm than your own.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全领域，有一个术语叫做**模糊安全**。它被定义为一种安全模型，其中实现机制不为公众所知，因此人们认为它是安全的，因为没有人在事先了解其缺陷。它确实可能是安全的，但如果将其作为唯一的保护形式，则被认为是一种较差的安全实践。如果一个黑客足够坚持不懈，即使不知道内部代码，他或她也能发现缺陷。在这种情况下，使用经过高度测试的算法比使用自己的算法更好。
- en: Security through obscurity can be compared to someone trying to protect their
    own money by burying it in the backyard when the common security mechanism would
    be to put the money in a bank. The money can be safe while buried, but it will
    be protected only until someone finds about its existence and starts to look for
    it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊安全可以比作某人试图通过在后院埋藏自己的钱来保护自己的钱，而常见的安全机制是将钱存入银行。钱在埋藏时可能是安全的，但它只能得到保护，直到有人发现它的存在并开始寻找它。
- en: Due to this reason, when dealing with security, we usually prefer to use open
    source algorithms and tools. Everyone can access and discover flaws in them, but
    there are also a great number of specialists that are involved in finding the
    vulnerabilities and fixing them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，在处理安全问题时，我们通常更喜欢使用开源算法和工具。每个人都可以访问并发现其中的缺陷，但也有很多专业人士参与寻找漏洞并修复它们。
- en: In this section, we will discuss other security concepts that everyone must
    know when building a system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论在构建系统时每个人都必须了解的其他安全概念。
- en: Information security
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息安全
- en: 'When dealing with security, there are some attributes that need to be considered.
    The most important ones are the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理安全问题时，有一些属性需要考虑。其中最重要的包括以下内容：
- en: '**Authentication**: Confirm the user''s identity by validating that the user
    is who they claim to be'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：通过验证用户是否是他们声称的人来确认用户的身份'
- en: '**Authorization**: Decide whether the user is allowed to execute the requested
    action'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：决定用户是否被允许执行请求的操作'
- en: '**Confidentiality**: Ensure that data can''t be understood by third-parties'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保密性**：确保数据不会被第三方理解'
- en: '**Integrity**: Protect the message against undetectable modifications'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：保护消息免受未检测到的修改'
- en: '**Non-repudiation**: Ensure that someone can''t deny the authenticity of their
    own message'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可否认性**：确保某人不能否认他们自己的消息的真实性'
- en: '**Availability**: Keep the system available when needed'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：在需要时保持系统可用'
- en: These terms will be better explained in the next sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语将在下一节中更好地解释。
- en: Authentication
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**认证**'
- en: Authentication is the ability to confirm the user's identity. It can be implemented
    by a login form where you request the user to type their username and password.
    If the hashed password matches what was previously saved in the database, you
    have enough proof that the user is who they claim to be. This model is good enough,
    at least for typical applications. You confirm the identity by requesting the
    user to provide what *they know*. Another kind of authentication is to request
    the user to provide what *they have*. It can be a physical device (like a dongle)
    or access to an e-mail account or phone number.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是确认用户身份的能力。可以通过登录表单实现，要求用户输入他们的用户名和密码。如果散列密码与数据库中之前保存的密码匹配，那么你有足够的证据证明用户就是他们所声称的人。这种模型对于典型应用来说足够好。你通过要求用户提供他们**知道**的信息来确认身份。另一种认证方式是要求用户提供他们**拥有**的信息。这可能是一个物理设备（如USB密钥）或对电子邮件账户或电话号码的访问。
- en: However, you can't ask the user to type their credentials for *every* request.
    As long as you *authenticate* it in the first request, you must create a security
    token that will be used in the subsequent requests. This token will be saved on
    the client side as a cookie and will be automatically sent to the server in all requests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能要求用户为**每个**请求输入他们的凭据。只要你在第一个请求中**认证**了它，你就必须创建一个将在后续请求中使用的安全令牌。此令牌将保存在客户端作为cookie，并将自动发送到服务器上的所有请求。
- en: On AWS, this token can be created using the Cognito service. How this is done
    will be described later in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS上，此令牌可以使用Cognito服务创建。如何进行此操作将在本章后面描述。
- en: Authorization
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**授权**'
- en: When a request is received in the backend, we need to check if the user is allowed
    to execute the requested action. For example, if the user wants to checkout the
    order with ID `123`, we need to make a query to the database to identify who is
    the owner of the order and compare if it is the same user.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当后端收到请求时，我们需要检查用户是否有权限执行所请求的操作。例如，如果用户想要结账订单ID为`123`，我们需要对数据库进行查询以确定订单的所有者是谁，并比较是否是同一用户。
- en: Another scenario is when we have multiple roles in an application and we need
    to restrict data access. For example, a system developed to manage school grades
    may be implemented with two roles, such as `student` and `teacher`. The teacher
    will access the system to insert or update grades, while the students will access
    the system to read those grades. In this case, the authentication system must
    restrict the actions *insert* and *update* for users that are part of the *teachers*
    group and users in the *students* group must be restricted to *read* their own
    grades.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个场景是我们在一个应用程序中有多个角色，并且我们需要限制数据访问。例如，一个用于管理学校成绩的系统可能实现了两个角色，例如`学生`和`教师`。教师将访问系统以插入或更新成绩，而学生将访问系统以读取这些成绩。在这种情况下，认证系统必须限制属于`教师`组的用户的`插入`和`更新`操作，而属于`学生`组的用户必须限制读取他们自己的成绩。
- en: Most of the time, we handle authorization in our own backend, but some serverless
    services don't require a backend and they are responsible by themselves to properly
    check the authorization. For example, in the next chapter, we are going to see
    how serverless notifications are implemented on AWS. When we use AWS IoT, if we
    want a private channel of communication between two users, we must give them access
    to one specific resource known by both and restrict access to other users to avoid
    the disclosure of private messages. This kind of authorization will be detailed
    in the next chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们在自己的后端处理授权，但一些无服务器服务不需要后端，并且它们自己负责正确检查授权。例如，在下一章中，我们将看到如何在AWS上实现无服务器通知。当我们使用AWS
    IoT时，如果我们想在两个用户之间建立私有通信通道，我们必须让他们访问双方都了解的一个特定资源，并限制其他用户的访问以避免泄露私人消息。这种授权将在下一章中详细介绍。
- en: Confidentiality
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**保密性**'
- en: In [Chapter 4](274d8aba-8e7e-4c5e-b55b-a8e1797d3057.xhtml), *Hosting the Website*,
    we learned how to use AWS Certificate Manager to request TLS certificates for
    free and how to add them to CloudFront distributions. Developing a website that
    uses HTTPS for *all* requests is the main drive to achieve confidentiality in
    the communication between the users and your site. As the data is encrypted, it's
    very hard for malicious users to decrypt and understand its contents.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](274d8aba-8e7e-4c5e-b55b-a8e1797d3057.xhtml)“托管网站”中，我们学习了如何使用AWS证书管理器免费请求TLS证书以及如何将它们添加到CloudFront分发中。开发一个对所有请求都使用HTTPS的网站是实现用户与你的网站之间通信机密性的主要驱动力。由于数据被加密，恶意用户很难解密并理解其内容。
- en: Although there are some attacks that can intercept the communication and forge
    certificates (man-in-the-middle), those require the malicious user to have access
    to the machine or network of the victim user. From our side, adding HTTPS support
    is the best thing that we can do to minimize the chance of attacks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有一些攻击可以拦截通信并伪造证书（中间人攻击），但这些攻击需要恶意用户访问受害用户的机器或网络。从我们的角度来看，添加HTTPS支持是我们能做的最好的事情，以最大限度地减少攻击的机会。
- en: Integrity
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整性
- en: Integrity is related to confidentiality. While confidentiality relies on encrypting
    a message to prevent other users from accessing its contents, integrity deals
    with protecting the messages against modifications by encrypting messages with
    digital signatures (TLS certificates).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性与机密性相关。虽然机密性依赖于加密消息以防止其他用户访问其内容，但完整性涉及通过使用数字签名（TLS证书）加密消息来保护消息免受修改。
- en: Integrity is an important concept when designing low level network systems,
    but all that matters for us is adding HTTPS support.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性是设计低级网络系统时的重要概念，但对我们来说，最重要的是添加HTTPS支持。
- en: Non-repudiation
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可否认性
- en: Non-repudiation is a term that is often confused with authentication since both
    of them have the objective to prove who has sent the message. However, the main
    difference is that authentication is more interested in a technical view and the
    non-repudiation concept is interested in legal terms, liability, and auditing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认性是一个常被与身份验证混淆的术语，因为它们的目标都是证明谁发送了消息。然而，主要区别在于身份验证更关注技术视角，而不可否认性概念更关注法律术语、责任和审计。
- en: When you have a login form with user and password input, you can authenticate
    the user who correctly knows the combination, but you can't have 100% certain
    since the credentials can be correctly guessed or stolen by a third-party. On
    the other hand, if you have a stricter access mechanism, such as a biometric entry,
    you have more credibility. However, this is not perfect either. It's just a better
    non-repudiation mechanism.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个包含用户名和密码输入的登录表单时，你可以验证知道正确组合的用户，但你不能100%确定，因为凭证可能被正确猜测或被第三方窃取。另一方面，如果你有一个更严格的访问机制，例如生物识别入口，你会有更高的可信度。然而，这也不是完美的。这只是一个更好的不可否认性机制。
- en: Availability
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性
- en: Availability is also a concept of interest in the information security field
    because availability is not restricted to how you provision your hardware to meet
    your user needs. Availability can suffer attacks and can suffer interruptions
    due to malicious users. There are attacks, such as **Distributed Denial of Service**
    (**DDoS**), that aim to create bottlenecks to disrupt site availability. In a
    DDoS attack, the targeted website is flooded with superfluous requests with the
    objective to overload the systems. This is usually accomplished by a controlled
    network of infected machines called a **botnet**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性也是信息安全领域感兴趣的概念，因为可用性不仅限于如何配置硬件以满足用户需求。可用性可能受到攻击，也可能因恶意用户而中断。存在一些攻击，如**分布式拒绝服务**（**DDoS**），旨在创建瓶颈以破坏网站可用性。在DDoS攻击中，目标网站被大量多余的请求淹没，目的是使系统过载。这通常是通过一个由受感染机器组成的受控网络完成的，称为**僵尸网络**。
- en: On AWS, all services run under the AWS Shield service, which was designed to
    protect against DDoS attacks with no additional charge. However, if you run a
    very large and important service, you may be a direct target of advanced and large
    DDoS attacks. In this case, there is a premium tier offered in the AWS Shield
    service to ensure your website's availability even in worst case scenarios. This
    requires an investment of US$ 3,000 per month, and with this, you will have 24x7
    support of a dedicated team and access to other tools for mitigation and analysis
    of DDoS attacks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS上，所有服务都在AWS Shield服务下运行，该服务旨在无需额外费用即可保护DDoS攻击。但是，如果您运行一个非常大且重要的服务，您可能成为高级和大型DDoS攻击的直接目标。在这种情况下，AWS
    Shield服务提供了一个高级层，以确保即使在最坏的情况下，您的网站也能保持可用性。这需要每月投资3000美元，并且您将获得24x7的专属团队支持，以及访问其他用于缓解和分析DDoS攻击的工具。
- en: Security on AWS
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS上的安全
- en: In this book, we use AWS credentials, roles, and policies, but security on AWS
    is much more than handling authentication and authorization of users. This is
    what we will discuss in this section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用AWS凭证、角色和政策，但AWS上的安全远不止处理用户的身份验证和授权。这就是我们将在本节中讨论的内容。
- en: Shared responsibility model
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享责任模型
- en: Security on AWS is based on a shared responsibility model. While Amazon is responsible
    for keeping the infrastructure safe, the customers are responsible for patching
    security updates to software and protecting their own user accounts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: AWS上的安全基于共享责任模型。虽然亚马逊负责保持基础设施的安全，但客户负责修补软件的安全更新并保护自己的用户账户。
- en: 'AWS''s responsibilities include the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: AWS的责任包括以下内容：
- en: Physical security of the hardware and facilities
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件和设施的安全
- en: Infrastructure of networks, virtualization, and storage
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络基础设施、虚拟化和存储
- en: Availability of services respecting **Service Level Agreements** (**SLAs**)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照服务级别协议（SLA）提供的服务可用性
- en: Security of managed services such as Lambda, RDS, DynamoDB, and others
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda、RDS、DynamoDB等托管服务的安全
- en: 'A customer''s responsibilities are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 客户的责任包括以下内容：
- en: Applying security patches to the operating system on EC2 machines
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在EC2机器上应用操作系统安全补丁
- en: Security of installed applications
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装应用程序的安全
- en: Avoiding disclosure of user credentials
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免泄露用户凭证
- en: Correct configuration of access policies and roles
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确配置访问策略和角色
- en: Firewall configurations
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙配置
- en: Network traffic protection (encrypting data to avoid disclosure of sensitive
    information)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络流量保护（加密数据以避免泄露敏感信息）
- en: Encryption of server-side data and databases
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端数据和数据库加密
- en: In the serverless model, we rely only on managed services. In this case, we
    don't need to worry about applying security patches to the operating system or
    runtime, but we do need to worry about third-party libraries that our application
    depends on to execute. Also, of course, we need to worry about all the things
    that we need to configure (firewalls, user policies, and so on), the network traffic
    (supporting HTTPS) and how data is manipulated by the application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器模型中，我们仅依赖托管服务。在这种情况下，我们不需要担心对操作系统或运行时应用安全补丁，但我们需要关注我们的应用程序依赖以执行第三方库。当然，我们还需要关注所有需要配置的事项（防火墙、用户策略等），网络流量（支持HTTPS）以及应用程序如何处理数据。
- en: The Trusted Advisor tool
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Trusted Advisor工具
- en: AWS offers a tool named Trusted Advisor, which can be accessed through [https://console.aws.amazon.com/trustedadvisor](https://console.aws.amazon.com/trustedadvisor).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: AWS提供了一款名为Trusted Advisor的工具，可以通过[https://console.aws.amazon.com/trustedadvisor](https://console.aws.amazon.com/trustedadvisor)访问。
- en: It was created to offer help on how you can optimize costs or improve performance,
    but it also helps identify security breaches and common misconfigurations. It
    searches for unrestricted access to specific ports on your EC2 machines, if Multi-Factor
    Authentication is enabled on the root account and if IAM users were created in
    your account.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它旨在提供有关如何优化成本或提高性能的帮助，但它还帮助识别安全漏洞和常见配置错误。它会搜索对您的EC2机器上特定端口的未授权访问，如果根账户启用了多因素认证，以及如果您的账户中创建了IAM用户。
- en: You need to pay for AWS premium support to unlock other features, such as cost
    optimization advice. However, security checks are free.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为AWS高级支持付费以解锁其他功能，例如成本优化建议。然而，安全检查是免费的。
- en: Pen testing
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突破测试
- en: A penetration test (or pen test) is a good practice that all big websites must
    perform periodically. Even if you have a good team of security experts, the usual
    recommendation is to hire a specialized third-party company to perform pen tests
    and to find vulnerabilities. This is because they will most likely have tools
    and procedures that your team may not have tried yet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试（或渗透测试）是所有大型网站都必须定期执行的良好实践。即使您有一支优秀的安全专家团队，通常的建议也是聘请一家专业的第三方公司进行渗透测试，以发现漏洞。这是因为他们很可能拥有您团队尚未尝试过的工具和程序。
- en: However, the caveat here is that you can't execute these tests without contacting
    AWS first. To respect their user terms, you can only try to find breaches on your
    own account and assets, in scheduled time frames (so they can disable their intrusion
    detection systems for your assets), and only on restricted services, such as EC2
    instances and RDS.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里的注意事项是，您在联系 AWS 之前不能执行这些测试。为了尊重他们的用户条款，您只能在预定的时间框架内尝试寻找您自己的账户和资产中的漏洞（这样他们可以禁用您的资产入侵检测系统），并且仅限于受限制的服务，例如
    EC2 实例和 RDS。
- en: AWS CloudTrail
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS CloudTrail
- en: AWS CloudTrail is a service that was designed to record all AWS API calls that
    are executed on your account. The output of this service is a set of log files
    that register the API caller, the date/time, the source IP address of the caller,
    the request parameters, and the response elements that were returned.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudTrail 是一项旨在记录您账户上执行的所有 AWS API 调用的服务。此服务的输出是一组日志文件，记录了 API 调用者、日期/时间、调用者的源
    IP 地址、请求参数以及返回的响应元素。
- en: This kind of service is pretty important for security analysis, in case there
    are data breaches, and for systems that need the auditing mechanism for compliance
    standards.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种服务对于安全分析非常重要，以防发生数据泄露，以及需要符合性标准审计机制的系统。
- en: MFA
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多因素认证（MFA）
- en: '**Multi-Factor Authentication** (**MFA**) is an extra security layer that everyone
    must add to their AWS root account to protect against unauthorized access. Besides
    knowing the user and password, a malicious user would also need physical access
    to your smartphone or security token, which greatly restricts the risks.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**多因素认证**（**MFA**）是一个额外的安全层，每个人都必须将其添加到他们的 AWS 根账户中，以防止未经授权的访问。除了知道用户名和密码外，恶意用户还需要物理访问您的智能手机或安全令牌，这大大限制了风险。'
- en: 'On AWS, you can use MFA through the following means:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 上，您可以通过以下方式使用 MFA：
- en: '**Virtual devices**: Application installed on Android, iPhone, or Windows phones'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟设备**：安装在 Android、iPhone 或 Windows 手机上的应用程序'
- en: '**Physical devices**: Six-digit tokens or OTP cards'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理设备**：六位数令牌或一次性密码（OTP）卡'
- en: '**SMS**: Messages received on your phone'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短信**：您手机上收到的消息'
- en: Handling authentication and authorization
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理身份验证和授权
- en: In this section, we are going to use Amazon Cognito to create the users for
    our application and to be able to handle their login. After authenticating the
    user, we will be able to give proper authorization for the tasks that they are
    allowed to execute.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Amazon Cognito 创建我们应用程序的用户，并能够处理他们的登录。在验证用户身份后，我们将能够为他们允许执行的任务提供适当的授权。
- en: Amazon Cognito
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon Cognito
- en: Cognito provides two services such as **User Pools** and **Identity Pools**.
    The first is where you create and store user credentials, the latter is where
    you set the permissions for the user to access AWS resources.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Cognito 提供两种服务，例如 **用户池** 和 **身份池**。第一种是您创建和存储用户凭证的地方，后者是您设置用户访问 AWS 资源权限的地方。
- en: We will start by creating a user pool, so we can add signup and signin features
    to our website. We will add the user pool ID to our frontend code and requests
    will be done directly to the User Pool service, without needing to be executed
    from a Lambda function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个用户池，这样我们就可以将注册和登录功能添加到我们的网站上。我们将用户池 ID 添加到我们的前端代码中，请求将直接发送到用户池服务，无需从
    Lambda 函数中执行。
- en: Later, we will configure an identity pool, which will be needed to give to the
    users temporary access to AWS resources. In our example, the user will be able
    to subscribe to IoT notifications directly, without requesting the backend to
    give this authorization.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将配置一个身份池，这将需要提供给用户临时访问 AWS 资源。在我们的示例中，用户将能够直接订阅 IoT 通知，而无需请求后端提供此授权。
- en: Creating a user pool
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户池
- en: 'Let''s take a look at the following steps to create a user pool:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下创建用户池的步骤：
- en: 'To create a user pool, we will use the console, which can be accessed through
    [https://console.aws.amazon.com/cognito](https://console.aws.amazon.com/cognito).
    Select the Manage your User Pools option:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建用户池，我们将使用控制台，您可以通过 [https://console.aws.amazon.com/cognito](https://console.aws.amazon.com/cognito)
    访问控制台。选择“管理您的用户池”选项：
- en: '![](img/6d350df7-a3fe-417d-a42b-a7c9b00cf084.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d350df7-a3fe-417d-a42b-a7c9b00cf084.png)'
- en: 'Click on Create a User Pool on the next screen, as shown in the following screenshot:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，点击创建用户池，如图所示：
- en: '![](img/1c443303-e8fd-4c6c-bd1e-c5d081e88644.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c443303-e8fd-4c6c-bd1e-c5d081e88644.png)'
- en: 'Now define a pool name for your user pool resource and check whether you want
    fast creation (using defaults) or whether you want to step through each setting.
    I''ve selected the former (Review defaults):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为您的用户池资源定义一个池名称，并检查您是想快速创建（使用默认值）还是想逐个设置每个选项。我已选择前者（审查默认值）：
- en: '![](img/cf555eaf-d3f4-41eb-a31f-2f9f4d61fb0d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf555eaf-d3f4-41eb-a31f-2f9f4d61fb0d.png)'
- en: 'The next screen will be a list of defaults that you need to revise before hitting
    Create pool:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一屏幕将显示您在点击创建池之前需要修订的默认值列表：
- en: '![](img/145b7121-247e-437e-a4bf-2027f705f6d2.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/145b7121-247e-437e-a4bf-2027f705f6d2.png)'
- en: 'The following is a list of options and what you need to consider in each of
    them:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个选项列表以及您在每个选项中需要考虑的内容：
- en: 'Attributes: This displays a list of user attributes that you can select as
    required options for login. Usually, only an e-mail is enough for most applications,
    but you can include attributes like username, phone number, or user picture. Also,
    you may set custom user attributes to be saved in your user profile.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：此选项显示您可以选择作为登录所需选项的用户属性列表。通常，对于大多数应用程序来说，一个电子邮件就足够了，但您还可以包括用户名、电话号码或用户图片等属性。此外，您还可以设置自定义用户属性以保存到您的用户配置文件中。
- en: 'Policies: This defines how strict the user''s password must be. For example,
    if you require a minimum length, special characters, and upper or lower cases.
    Also, you can restrict user creation by admins only.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略：此选项定义了用户的密码必须有多严格。例如，如果您要求最小长度、特殊字符以及大写或小写字母。此外，您还可以限制只有管理员可以创建用户。
- en: 'Verifications: You can request the user to verify the ownership of the e-mail
    address or phone number (SMS) upon registering. Cognito will send a message with
    a code for validation. Also, you can enable MFA for your users as a second layer
    of security. This feature is very important nowadays to prevent accounts being
    hacked and is already implemented by Cognito, making it very easy to integrate
    with your application. You can enable MFA by e-mail or phone.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证：您可以在用户注册时请求用户验证电子邮件地址或电话号码（短信）。Cognito 将发送一个用于验证的代码消息。此外，您可以为您的用户启用多因素认证（MFA）作为第二层安全措施。这个功能在当今社会非常重要，可以防止账户被黑客攻击，并且
    Cognito 已经实现了这一功能，使其与您的应用程序集成变得非常容易。您可以通过电子邮件或电话启用 MFA。
- en: 'Message customizations: This is related to the previous configuration where
    you can request users to validate their e-mails or phone numbers. The text of
    these messages is configurable here. Besides, you can set the e-mail messages
    to use your domain address, if it was already verified and configured in Amazon
    SES.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息定制：这与之前的配置相关，您可以在其中请求用户验证他们的电子邮件或电话号码。这些消息的文本在此可配置。此外，如果您已经在 Amazon SES 中验证并配置了域名地址，您还可以设置电子邮件消息使用您的域名地址。
- en: 'Tags: This option is useful if you want to associate the user pool with a tag
    that will show up in your billing data. With this option, you can create a tag
    with a cost center or application name for better management of cost allocation.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签：如果您想将用户池与一个将在您的计费数据中显示的标签关联起来，此选项非常有用。使用此选项，您可以创建一个带有成本中心或应用程序名称的标签，以便更好地管理成本分配。
- en: 'Devices: You can allow the device to be remembered for future accesses. This
    feature is useful as a convenience and you can also suppress MFA requests if the
    device has already been authenticated with MFA in the past.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备：您可以让设备被记住以供将来访问。此功能作为便利性而非常有用，并且如果您设备之前已经通过 MFA 进行过认证，您还可以抑制 MFA 请求。
- en: 'Apps: You need to create an application specification to restrict the applications
    that will be able to handle the login process and handle forgotten passwords for
    your application. This feature creates an application key and secret.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序：您需要创建一个应用程序规范，以限制能够处理您的应用程序登录过程和处理忘记密码的应用程序。此功能创建了一个应用程序密钥和密钥。
- en: 'Triggers: You can trigger Lambda functions in pre-signup, pre-authentication,
    post authentication, create authorization challenge, and other options. Basically,
    you can have control of server-side procedures to handle the user authentication.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器：您可以在预注册、预身份验证、身份验证后、创建授权挑战和其他选项中触发 Lambda 函数。基本上，您可以对服务器端流程进行控制以处理用户身份验证。
- en: 'After creating the user pool, you can see the assigned Pool Id and Pool ARN.
    Write down those values because they will be needed later:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户池后，你可以看到分配的 Pool Id 和 Pool ARN。将这些值记下来，因为稍后需要使用：
- en: '![](img/fb5c1830-d1e5-4365-80c9-6ca88922ac3d.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb5c1830-d1e5-4365-80c9-6ca88922ac3d.png)'
- en: 'There is still one more thing before we complete this configuration. As we
    want our website to handle signup/signin, we need to create an application ID.
    Browse the App clients field to add an application for our website and uncheck
    the Generate client secret option, since this feature is not supported by the
    JavaScript SDK:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成此配置之前，我们还需要做一件事。因为我们想让我们的网站处理注册/登录，我们需要创建一个应用程序 ID。浏览“应用客户端”字段以添加我们的网站应用程序，并取消选中“生成客户端密钥”选项，因为此功能不支持
    JavaScript SDK：
- en: '![](img/7dfe4806-0b9a-43d9-8e75-45743c2bca99.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7dfe4806-0b9a-43d9-8e75-45743c2bca99.png)'
- en: 'After creating the app client, write down the App client id:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用客户端后，记下应用客户端 ID：
- en: '![](img/3f50673c-0234-4f38-a1c9-7c29d19c0f55.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f50673c-0234-4f38-a1c9-7c29d19c0f55.png)'
- en: Creating an identity pool
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建身份池
- en: 'Now we are going to create an identity pool. Let''s take a look in the following
    steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个身份池。让我们看看以下步骤：
- en: 'The first step is to browse to the Federated Identities page that can be found
    in Cognito home or from the user pool that we have just created:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是浏览到 Cognito 主页中的“联合身份”页面，或者从我们刚刚创建的用户池中找到：
- en: '![](img/bae88957-e920-428e-bcf5-63d1f17ef604.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bae88957-e920-428e-bcf5-63d1f17ef604.png)'
- en: 'When creating a new identity pool, check the box Enable access to unauthenticated
    identities. We will configure later what resources an unsigned user can access,
    which will be different to the level of access that a signed user can have. Take
    a look at the following screenshot:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新的身份池时，请勾选“启用对未经验证身份的访问”复选框。我们稍后将会配置未签名用户可以访问哪些资源，这将与已签名用户可以访问的级别不同。请看以下截图：
- en: '![](img/ba01fc26-87ff-4b04-824f-10569dcb2ec0.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba01fc26-87ff-4b04-824f-10569dcb2ec0.png)'
- en: 'The next field is to set the Authentication providers parameter. Cognito Identity
    Pool is an *authorization* service that needs to receive as input the users from
    an *authentication* service. In our example, we will use the Cognito User Pool
    that we have just created by filling out the User Pool ID and the App Client ID
    fields, but if you want, you can add support for other providers as well, such
    as Facebook, Google+, or Twitter:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个字段是设置“身份验证提供者”参数。Cognito 身份池是一个需要接收来自“身份验证”服务的用户输入的**授权**服务。在我们的例子中，我们将使用我们刚刚通过填写用户池
    ID 和应用客户端 ID 字段创建的 Cognito 用户池，但如果你愿意，你也可以添加对其他提供者的支持，例如 Facebook、Google+ 或 Twitter：
- en: '![](img/5308f479-2279-4520-96d2-6f66a47efb60.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5308f479-2279-4520-96d2-6f66a47efb60.png)'
- en: 'Now we need to configure the access of our authenticated and unauthenticated
    users. As an example, we could allow access to a folder of a S3 bucket to allow
    the user to directly upload photos from the website, without needing the backend
    to execute this action. In our serverless store, we need to handle notifications
    with IoT. So that''s what we are going to configure next:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要配置我们的已验证和未验证用户的访问权限。作为一个例子，我们可以允许访问 S3 存储桶中的一个文件夹，以便用户可以直接从网站上传照片，而无需后端执行此操作。在我们的无服务器存储中，我们需要处理与
    IoT 相关的通知。所以这就是我们接下来要配置的内容：
- en: '![](img/71a8de15-4c10-49fa-9140-668ec87a5bfb.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71a8de15-4c10-49fa-9140-668ec87a5bfb.png)'
- en: 'You will need to edit the Policy Document option for both types (unauthenticated
    and authenticated). Start modifying the document for authenticated users:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要编辑两种类型的策略文档（未经验证和已验证）。现在开始修改已验证用户的文档：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`iot:Connect` and `iot:AttachPrincipalPolicy` requires access to every resource
    (`*`), while we need to restrict the `iot:Subscribe` to a `topicfilter/<topic>`
    resource and the `iot:Publish` and `iot:Receive` to a `topic/<topic>`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`iot:Connect` 和 `iot:AttachPrincipalPolicy` 需要访问每个资源（`*`），而我们需要将 `iot:Subscribe`
    限制为 `topicfilter/<topic>` 资源，将 `iot:Publish` 和 `iot:Receive` 限制为 `topic/<topic>`。'
- en: When building the ARNs, replace the `<region>` with the region of the AWS IoT
    that you are going to use, `<account>` with your Account ID, `<public-topic>`
    with `serverless-store-comments` and `<private-topic>` with `serverless-store-${cognito-identity.amazonaws.com:sub}`.
    The private topic will allow the authenticated user to access a topic defined
    by their federated identity.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当构建 ARN 时，将 `<region>` 替换为你将要使用的 AWS IoT 区域，将 `<account>` 替换为你的账户 ID，将 `<public-topic>`
    替换为 `serverless-store-comments`，将 `<private-topic>` 替换为 `serverless-store-${cognito-identity.amazonaws.com:sub}`。私有主题将允许经过身份验证的用户访问由其联合身份定义的主题。
- en: For unauthenticated access, use the same policy document, but remove the extra
    ARN that was added for the private topic. You can also remove the `iot:AttachPrincipalPolicy`
    since it will not be necessary for unauthenticated users.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于未经身份验证的访问，使用相同的策略文档，但移除为私有主题添加的额外 ARN。您还可以移除 `iot:AttachPrincipalPolicy`，因为它对于未经身份验证的用户将不是必需的。
- en: 'After creating the identity pool, go to the Dashboard option and click on Edit
    identity pool. You will see the Identity pool ID option in this screen. Write
    it down because it will be needed later:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建身份池之后，转到仪表板选项并点击编辑身份池。您将在该屏幕上看到身份池 ID 选项。记下来，因为稍后需要它：
- en: '![](img/c410e65d-ea69-4b0c-80e1-4deba79b7d60.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c410e65d-ea69-4b0c-80e1-4deba79b7d60.png)'
- en: Using Cognito in our serverless store
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的无服务器存储中使用 Cognito
- en: 'Now we are going to integrate our React frontend with Cognito to implement
    the signup and login pages. The authentication methods will be done directly with
    Cognito, without using a Lambda function for this. To make this work, we need
    to configure our React application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将集成我们的 React 前端与 Cognito，以实现注册和登录页面。身份验证方法将直接与 Cognito 进行，而不使用 Lambda 函数。为了使这可行，我们需要配置我们的
    React 应用程序：
- en: 'First, install the module `amazon-cognito-identity-js` in our frontend folder
    by running the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令在我们的前端文件夹中安装模块 `amazon-cognito-identity-js`：
- en: '[PRE1]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `lib` folder, create a `config.js` file to store our Cognito IDs:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `lib` 文件夹内，创建一个 `config.js` 文件来存储我们的 Cognito ID：
- en: '[PRE2]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we did in previous chapters, we have created a `services.js` file inside
    the `lib` folder to make all Ajax requests. We need to import the following from
    the Cognito module:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前几章所述，我们在 `lib` 文件夹内创建了一个 `services.js` 文件来执行所有 Ajax 请求。我们需要从 Cognito 模块导入以下内容：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we have prepared our frontend to use Cognito.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为前端使用 Cognito 准备好了。
- en: The Signup page
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册页面
- en: 'The signup form was created in [Chapter 5](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml),
    *Building the Frontend*, and it has the appearance as shown in the this screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表单在 [第 5 章](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml) 中创建，*构建前端*，其外观如图所示：
- en: '![](img/38ca87f0-c359-426c-97fc-3e2937aff779.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38ca87f0-c359-426c-97fc-3e2937aff779.png)'
- en: 'We are going to implement the handler for the Signup button by performing the
    following steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤实现注册按钮的处理程序：
- en: 'We start by creating a method in our `services.js` file that will execute a
    request to Cognito, invoking the `signUp` function that will use the e-mail and
    password provided by the form:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在我们的 `services.js` 文件中创建一个方法，该方法将执行对 Cognito 的请求，调用 `signUp` 函数，该函数将使用表单提供的电子邮件和密码：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `App` component will call this function and it will save the resulting
    user object in its state:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`App` 组件将调用此函数，并将结果用户对象保存到其状态中：'
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After registering the user successfully, we need to re-render the signup component
    to display a confirmation request. The user will be asked to fill the text input
    with the value sent to their e-mail:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户成功注册后，我们需要重新渲染注册组件以显示确认请求。用户将被要求填写发送到他们电子邮件中的文本输入值：
- en: '![](img/e57e23bc-c4fc-47ba-b592-11e35a82d889.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e57e23bc-c4fc-47ba-b592-11e35a82d889.png)'
- en: 'The request to Cognito will use the same `user` object that was returned in
    the signup result:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 Cognito 的请求将使用在注册结果中返回的相同的 `user` 对象：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the confirmation code is correct, we can use the e-mail and password that
    the user has provided and authenticate his access, without asking the user to
    type them again.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果确认码正确，我们可以使用用户提供的电子邮件和密码来验证其访问权限，而无需要求用户再次输入。
- en: How to authenticate will be defined in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如何进行身份验证将在下一节中定义。
- en: The Login page
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录页面
- en: 'Implementing the Login page to authenticate users requires a few steps. Let''s
    see how this is done by performing the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实现登录页面以验证用户需要几个步骤。让我们通过以下步骤来查看这是如何完成的：
- en: 'The Login page was also created in [Chapter 5](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml),
    *Building the Frontend* and it has this look:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录页面也在 [第 5 章](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml) *构建前端* 中创建，其外观如下：
- en: '![](img/46df45d0-e6b3-4986-8608-18f47145a2a5.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46df45d0-e6b3-4986-8608-18f47145a2a5.png)'
- en: 'The `Login` button will trigger a request to Cognito defined in the `services.js`
    file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Login` 按钮将触发 `services.js` 文件中定义的 Cognito 请求：'
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This `login` function will be used by the `App` component. After signing successfully,
    we need to save `userToken` in the state of `App`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此 `login` 函数将由 `App` 组件使用。在成功登录后，我们需要将 `userToken` 保存到 `App` 的状态中：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Persisting the user token
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化用户令牌
- en: Fortunately, the Cognito SDK will persist the user token automatically in the
    browser local storage. If the user browses your website again before the token
    expiration, the data will be there, available, without the need to request the
    user to type the e-mail/password again.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Cognito SDK 会自动将用户令牌持久化到浏览器本地存储中。如果用户在令牌过期之前再次浏览您的网站，数据将保留在那里，可供使用，无需再次请求用户输入电子邮件/密码。
- en: 'This token can be retrieved with the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此令牌可以通过以下代码检索：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Logging out
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注销
- en: 'As the user token is being persisted, we can check its existence in the `App`
    initialization (`componentDidMount`) and display a Logout button instead of a
    Login button in the navigation bar:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户令牌正在持久化，我们可以在 `App` 初始化（`componentDidMount`）时检查其存在，并在导航栏中显示注销按钮而不是登录按钮：
- en: '![](img/23081903-1f51-4f03-9bf4-98e5b23be6fd.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23081903-1f51-4f03-9bf4-98e5b23be6fd.png)'
- en: 'When clicking in this Logout button, we can clear the token executing the following
    code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击此注销按钮时，我们可以通过执行以下代码来清除令牌：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Handling authentication in Lambda functions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Lambda 函数中处理身份验证
- en: 'API Gateway has a nice integration with Cognito Pools for user authentication.
    We can configure it through the Serverless Framework to retrieve the user data
    from Cognito whenever a request with a token ID is provided. Let''s see how this
    is done by executing the following steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: API Gateway 与 Cognito Pools 在用户身份验证方面有很好的集成。我们可以通过 Serverless Framework 进行配置，以便在提供带有令牌
    ID 的请求时从 Cognito 获取用户数据。让我们通过以下步骤来查看这是如何完成的：
- en: 'Modify the `serverless.yml` file to use the Cognito User Pool authorizer:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `serverless.yml` 文件以使用 Cognito User Pool 授权器：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Include `Authorization` as a valid header when the Lambda function answer an
    `OPTIONS` request:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Lambda 函数响应 `OPTIONS` 请求时，请将 `Authorization` 作为有效的头信息包含在内：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Deploy the backend again by running the following command:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令重新部署后端：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Modify the frontend to always include the `userToken`, if it is available,
    in an `Authorization` header by executing the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下代码修改前端，以确保始终在 `Authorization` 头中包含可用的 `userToken`：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we have access to the user information in the backend. If we analyze the
    `event` object, we can retrieve the `userId` variable by executing the following
    code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问后端的用户信息。如果我们分析 `event` 对象，可以通过以下代码检索 `userId` 变量：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `userId` term is a **Universally Unique Identifier** (**UUID**). An example
    of `userId` is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`userId` 术语是一个 **通用唯一标识符**（**UUID**）。以下是一个 `userId` 的示例：'
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `claims` object offers more user data, like the e-mail, using the `email`
    property.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`claims` 对象提供了更多用户数据，如电子邮件，使用 `email` 属性。'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed the basic security concepts and how to apply
    them in a serverless project. For our demo application, we have used Amazon Cognito
    to handle the authentication and authorization of users, so you have learned how
    to implement signup, signin, and logout features.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了基本的安全概念以及如何在无服务器项目中应用它们。对于我们的演示应用程序，我们使用了 Amazon Cognito 来处理用户的身份验证和授权，因此您已经学习了如何实现注册、登录和注销功能。
- en: In the next chapter, we will use the Cognito credentials to access AWS IoT resources
    to handle serverless notifications. We will see how the backend can send messages
    to an authenticated user and how to provide real-time notifications to anonymous
    users.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Cognito 凭据来访问 AWS IoT 资源以处理无服务器通知。我们将看到后端如何向已认证用户发送消息，以及如何向匿名用户提供实时通知。
