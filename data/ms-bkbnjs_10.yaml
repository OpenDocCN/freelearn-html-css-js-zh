- en: Chapter 10. Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章 认证
- en: Most of the web applications use some kind of authorization and authentication
    subsystems to allow its users to access private information of the application.
    However, the authentication process can be tricky if you don't have a clear idea
    about how to implement it as Backbone does not provide a hint about how to do
    it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络应用程序都使用某种授权和认证子系统，以允许其用户访问应用程序的私有信息。然而，如果你对如何实现它没有清晰的想法，认证过程可能会变得复杂，因为
    Backbone 并没有提供如何实现的提示。
- en: Backbone is authentication agnostic, which means that its does not provide objects
    or tools to implement an authentication strategy. The advantage is that Backbone
    is not coupled with an authentication mechanism and the disadvantage is that you
    should care about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 是认证无关的，这意味着它不提供用于实现认证策略的对象或工具。优点是 Backbone 不与任何认证机制耦合，缺点是你应该关注它。
- en: As Backbone was made with REST APIs in mind, you will have to deal with the
    authentication mechanisms that are common in that kind of APIs. That's a good
    reason why Backbone does not impose or provide tools in order to authenticate
    users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Backbone 是基于 REST API 设计的，因此你将不得不处理那种 API 中常见的认证机制。这也是 Backbone 不强制或提供用于认证用户的工具的一个很好的原因。
- en: Another thing to keep in mind is that REST APIs should be stateless, which means
    that they do not keep track of the requests that you previously made. What it
    means for you is that if you make a login request, you will expect the server
    to recognize you on the subsequent requests; however, in a stateless server, it
    will not remember you.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是，REST API 应该是无状态的，这意味着它们不会跟踪你之前发出的请求。对你来说，这意味着如果你发出登录请求，你将期望服务器在后续请求中识别你；然而，在无状态服务器上，它不会记住你。
- en: This may sound crazy if you have not worked with REST web services before; however,
    you have to authenticate each time you make a requests to the server. That's necessary
    and there are many available ways to do it; you should consult the API documentation
    in order to know the exact details of the authentication algorithm.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有与 REST 网络服务合作过，这可能会听起来很疯狂；然而，你必须每次向服务器发送请求时都进行认证。这是必要的，并且有许多可行的方法可以实现；你应该查阅
    API 文档，以了解认证算法的确切细节。
- en: Despite the many options that are available, they are very similar each other
    with changes in just some kind of details; however, in essence, they work in a
    very similar way. Therefore, don't worry about the number of different ways that
    are available to authenticate; learn the basics and change the details.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有众多可用的选项，它们彼此之间非常相似，只是在一些细节上有所变化；然而，本质上，它们的工作方式非常相似。因此，不必担心可供使用的不同认证方式的数量；学习基础知识，然后修改细节即可。
- en: Stateless API authentication
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态 API 认证
- en: Authenticate against a stateless API implies that you should authenticate each
    time that you make a request to the server; keep in mind that a stateless server
    does not keep track of the previous requests. This means that each time you make
    a request to the server, it will process the petition as the first one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对无状态 API 进行认证意味着你应该在每次向服务器发送请求时进行认证；记住，无状态服务器不会跟踪之前的请求。这意味着每次你向服务器发送请求时，它都会将请求处理为第一个请求。
- en: As sessions are not stored in the server, you should put that information somewhere
    else. For Backbone applications, the right place to store the session data is
    the browser, you can use `localStorage` to store and retrieve the session data
    and JavaScript to manage the session.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于会话信息不会存储在服务器上，你应该将其放在其他地方。对于 Backbone 应用程序来说，存储会话数据的正确位置是浏览器，你可以使用 `localStorage`
    来存储和检索会话数据，并使用 JavaScript 来管理会话。
- en: HTTP Basic authentication
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 基本认证
- en: 'The simplest way to authenticate against a RESTFul API is with the HTTP Basic
    Authentication. The idea behind this is simple; you should include an encoded
    version of your username and password for every request you make. It may sound
    risky to send your user and password for each request, and it is. For this reason,
    it''s highly advisable to only use Basic authentication where you have the HTTPS
    connections enabled:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对 RESTful API 进行认证的最简单方式是使用 HTTP 基本认证。其背后的思想很简单；你应该在每次发送请求时包含你用户名和密码的编码版本。这可能听起来很危险，因为每次请求都发送用户名和密码，确实如此。因此，强烈建议只在启用了
    HTTPS 连接的地方使用基本认证：
- en: '![HTTP Basic authentication](img/B01962_10_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP 基本认证](img/B01962_10_01.jpg)'
- en: Figure 10.1 Basic authentication schema
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 基本认证方案
- en: 'The user and password should be sent under the `Authentication` header of the
    request. Consider the following scenario:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名和密码应在请求的`Authentication`头下发送。考虑以下场景：
- en: 'User: myuser'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户：myuser
- en: 'Password: 123456'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码：123456
- en: To encode the `Authentication` header, the user and password should be concatenated
    with the `:` character as the separator.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编码`Authentication`头，用户名和密码应使用冒号`:`作为分隔符连接。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, the string should be encoded as `base64`, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该字符串应按如下方式编码为`base64`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The resulting string should be used for every request made to the server:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的字符串应用于对服务器发出的每个请求：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The server will decode and authenticate you for each request you make. Remember
    that you should not use this mechanism without HTTPS. It's very easy for someone
    to intercept a request header and decode the string in order to discover your
    user and password.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将为每个请求解码并验证你的身份。请记住，你应该不要在没有HTTPS的情况下使用此机制。有人很容易拦截请求头并解码字符串，以发现你的用户名和密码。
- en: The OAuth2 authentication
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth2认证
- en: 'The OAuth2 protocol was made to share resources among services without the
    use of a user and password. It is possible that you have used an application where
    you can authenticate using a social network account. That''s OAuth2 in action.
    The OAuth2 authentication is an authorization framework described in RFC 6749,
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2协议是为了在服务之间共享资源而设计的，不使用用户名和密码。你可能已经使用过可以使用社交网络账户进行认证的应用程序。这就是OAuth2的实际应用。OAuth2认证是RFC
    6749中描述的授权框架，如下所示：
- en: '![The OAuth2 authentication](img/B01962_10_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![OAuth2认证](img/B01962_10_02.jpg)'
- en: Figure 10.2 OAuth2 abstract flow
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 OAuth2抽象流程
- en: 'In the preceding figure, you can see an abstract diagram of authentication
    using the OAuth2 algorithm. You can identify the next entities, as shown in the
    following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到使用OAuth2算法进行认证的抽象图。你可以识别以下实体，如下所示：
- en: A **Resource Owner** is the entity that owns the protected data. This is normally
    a person.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**是拥有受保护数据的实体。这通常是个人。'
- en: The **Web application** is the application that wants to access the private
    data of the Resource Owner.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web应用程序**是想要访问资源所有者私有数据的应用程序。'
- en: An **Authorization server** identifies and authenticates the users of the Resource
    server, where the protected data lives.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**用于识别和验证资源服务器（受保护数据所在的服务器）的用户。'
- en: An **Access token** is the data to be used in the Resource server in order to
    authorize the resource access. The Access tokens normally have an expiration time.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问令牌**是在资源服务器中用于授权资源访问的数据。访问令牌通常有一个过期时间。'
- en: The **Resource server** is the host that serves the protected data.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**是提供受保护数据的主机。'
- en: 'Note that the Resource server and the Authorization server can be the same
    host. The authentication process is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，资源服务器和授权服务器可以是同一主机。认证过程如下：
- en: The application asks for authorization to the resource owner.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序请求资源所有者的授权。
- en: The resource owner authorizes and an authorization key is issued.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源所有者授权并颁发授权密钥。
- en: The application uses the authorization key to exchange it for an access token.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序使用授权密钥来交换访问令牌。
- en: The authorization server validates the authorization key and the applications.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器验证授权密钥和应用程序。
- en: The authorization server issues an access token and returns it to the application.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器颁发访问令牌并将其返回给应用程序。
- en: The application can use the access token to access the protected resources.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序可以使用访问令牌来访问受保护资源。
- en: The issued access token should normally expire from time to time in order to
    prevent an attacker from using it maliciously. When a token expires, the application
    should repeat the authentication process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 颁发的访问令牌通常会有过期时间，以便防止攻击者恶意使用。当令牌过期时，应用程序应重复认证过程。
- en: However, it's not practical to log in each time that a token expires. In order
    to prevent this, the authorization server issues another token named `refresh
    token` that can be used to issue a new access token when the current access token
    expires.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每次令牌过期时都进行登录并不实际。为了防止这种情况，授权服务器颁发另一个名为`刷新令牌`的令牌，当当前访问令牌过期时，可以使用它来颁发新的访问令牌。
- en: Service applications
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务应用程序
- en: When you want to access the private data of a service such as Facebook, Twitter,
    Google, and so on, you must register your application with the service first.
    When you register your application with the service, they will ask you for an
    application name, description, website, and so on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想访问像Facebook、Twitter、Google等服务的私有数据时，你必须首先将该服务中的应用程序注册到该服务上。当你将该服务中的应用程序注册到服务上时，他们将会要求你提供应用程序名称、描述、网站等信息。
- en: 'When the application is registered, the service will give you some tokens to
    identify your application, these tokens include two key data, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序注册完成后，服务将为你提供一些令牌来识别你的应用程序，这些令牌包括以下两个关键数据：
- en: '**ClientID**: This univocally identifies your application against the service'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClientID**：这个唯一标识符用于在服务中识别你的应用程序'
- en: '**ClientSecret**: This is used to authenticate whether the request made with
    a given ClientID is legitimate'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClientSecret**：这用于验证使用给定ClientID发出的请求是否合法'
- en: If the REST server that you are building for your application is accessed only
    by you, you can manually generate a `ClientID` and `ClientSecret` as constant
    values in the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为应用程序构建的REST服务器只由你访问，你可以手动生成一个`ClientID`和`ClientSecret`作为应用程序中的常量值。
- en: If your REST server will expose a public API for anyone who wants to play with
    the application data, you should develop some kind of application registration
    (such as user signup) in order to allow others to register their applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的REST服务器将向任何想要玩弄应用程序数据的人公开公共API，你应该开发某种应用程序注册（例如用户注册）以便允许其他人注册他们的应用程序。
- en: OAuth2 grant types
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth2授权类型
- en: In the previous section, you have seen the OAuth2 protocol as an abstract schema
    of authentication. The RFC 6749 document specification describes four different
    ways to obtain an access token.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你已经看到了OAuth2协议作为认证的抽象模式。RFC 6749文档规范描述了四种不同的方式来获取访问令牌。
- en: Authorization code grant
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权代码授权
- en: 'Authorization code grant is the most complete authorization flow; its main
    usage is to access private resources of the user from another server:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 授权代码授权是最完整的授权流程；其主要用途是从另一个服务器访问用户的私有资源：
- en: '![Authorization code grant](img/B01962_10_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![授权代码授权](img/B01962_10_03.jpg)'
- en: Figure 10.3 Authorization code grant
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 授权代码授权
- en: Refer to preceding figure. Server App is an application server (such as Node.js,
    Python, and so on), and the API Server is a third-party server, where the private
    resources lives (such as Facebook, Google, and so on).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的图示。服务器应用程序是一个应用程序服务器（例如Node.js、Python等），API服务器是一个第三方服务器，其中包含私有资源（例如Facebook、Google等）。
- en: In the Authorization Code Grant scenario, the Server App wants to access the
    data from the API Server in benefit of the **User**. This is done through the
    Server App; as the user interacts with Backbone App, it makes requests to the
    Server App, then Server App can fetch the data from the API Server, apply some
    processing, and return a response to the Backbone App.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在授权代码授权场景中，服务器应用程序想要代表**用户**从API服务器获取数据。这是通过服务器应用程序完成的；当用户与Backbone应用程序交互时，它会向服务器应用程序发出请求，然后服务器应用程序可以从API服务器获取数据，进行一些处理，并将响应返回给Backbone应用程序。
- en: The Backbone App never establishes a single connection to the API Server, it
    is the responsibility of Server App so that Backbone App only sees a single Server
    App.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone应用程序永远不会与API服务器建立单个连接，这是服务器应用程序的责任，以确保Backbone应用程序只能看到单个服务器应用程序。
- en: Implicit Grant
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式授权
- en: 'This is a simplification of Authorization Code Grant; the usage of implicit
    grant is for pure frontend applications without server or mobile applications:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对授权代码授权的简化；隐式授权的使用是针对没有服务器或移动应用程序的纯前端应用程序：
- en: '![Implicit Grant](img/B01962_10_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![隐式授权](img/B01962_10_04.jpg)'
- en: Figure 10.4 Implicit grant
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 隐式授权
- en: In the implicit grant, App Server does not exist, therefore, the Backbone App
    should communicate directly with the API Server. Despite the simplicity of the
    implicit grant, you should be warned about the security issues.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐式授权中，App服务器不存在，因此，Backbone应用程序应直接与API服务器通信。尽管隐式授权很简单，但你应该注意其安全问题。
- en: To minimize this risk, your applications should be secured with HTTPS and do
    not use this flow type if you don't have it enabled. Another related issue is
    that this grant type does not issue a refresh token, which means that you should
    re-login when the access token expires.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化这种风险，你的应用程序应该使用HTTPS进行安全保护，并且如果你没有启用此流类型，不要使用这种流类型。另一个相关问题是，此授权类型不会颁发刷新令牌，这意味着当访问令牌过期时，你应该重新登录。
- en: Resource Owner Password Credentials Grant
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证授权
- en: This grant type is useful when the Backbone App and API Server are the same
    application. In other words, the frontend application and the backend server are
    developed by you, which means that you are not accessing to third-party resources.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当Backbone App和API服务器是同一应用程序时，此授权类型非常有用。换句话说，前端应用程序和后端服务器是由您开发的，这意味着您不是在访问第三方资源。
- en: 'As your application owns all the resources, you will need the user and password
    of the application to authenticate it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用程序拥有所有资源，您将需要应用程序的用户名和密码来对其进行身份验证：
- en: '![Resource Owner Password Credentials Grant](img/B01962_10_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![资源所有者密码凭证授权](img/B01962_10_05.jpg)'
- en: Figure 10.5 Resource owner password
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 资源所有者密码
- en: The preceding diagram is very similar to the Implicit Grant diagram; however,
    in this case, you don't need to use ClientID and ClientSecret tokens, which simplifies
    the authentication process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表与隐式授权图表非常相似；然而，在这种情况下，您不需要使用ClientID和ClientSecret令牌，这简化了身份验证过程。
- en: When you use this grant type, it feels like the classic way of authentication;
    you should send your user and password to the server and it will then tell you
    whether your credentials are valid or not. If they are valid, you will receive
    a valid access token that you can store and use as you want.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用此授权类型时，感觉就像传统的身份验证方式；您应该将您的用户名和密码发送到服务器，然后服务器会告诉您凭证是否有效。如果有效，您将收到一个有效的访问令牌，您可以存储并按需使用。
- en: Client credentials grant
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端凭证授权
- en: Client credentials grant is used when you have a trusted client that accesses
    the server resources. A business partner, for example. In this grant type, you
    are not authenticating an user but an application, therefore, you don't need an
    user or password.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个信任的客户端访问服务器资源时，会使用客户端凭证授权。例如，一个商业伙伴。在这种授权类型中，您不是验证用户，而是验证应用程序，因此不需要用户名或密码。
- en: In this grant, you should use ClientID and ClientSecret, if the API Server trusts
    the client, an access token will be issued.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个授权中，如果您信任客户端，应该使用ClientID和ClientSecret，将颁发访问令牌。
- en: '![Client credentials grant](img/B01962_10_06.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![客户端凭证授权](img/B01962_10_06.jpg)'
- en: Figure 10.6 Client credentials
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 客户端凭证
- en: Resume
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In the previous sections, you have seen how to use the OAuth2 framework to authenticate
    against a REST server; in the OAuth2, specifications are described in four ways
    to make authentication and the use of any one of them depends on the requirements
    of the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您已经看到了如何使用OAuth2框架对REST服务器进行身份验证；在OAuth2中，规范以四种方式描述，使用任何一种取决于应用程序的需求。
- en: However, the goal of the all these grant types is to get an access token that
    can be used for the next server request. Once you have an access token, the interaction
    with the API server should be transparent for Backbone App, the token should be
    send without the knowledge of rest of the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些授权类型的目标都是获取一个可以用于下一个服务器请求的访问令牌。一旦您有了访问令牌，与API服务器的交互应该对Backbone App来说是透明的，令牌应该发送，而无需应用程序其他部分的了解。
- en: Implementing HTTP Basic Authentication
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现HTTP基本身份验证
- en: Let's implement the Basic Auth protocol in `Contacts App`. As you have learned
    in the previous sections, you will need to add the `Authorization` header for
    every request that you make to the server in order to be authenticated. From the
    server side, you will need to read and parse this header.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Contacts App`中实现基本认证协议。正如您在前面的章节中学到的，您需要为向服务器发出的每个请求添加`Authorization`头，以便进行身份验证。从服务器端，您需要读取和解析此头。
- en: 'A useful `npm` package to decode the `Authorization` header has been developed.
    With the `basic-auth` module, you can read the request headers and return an object
    with two fields: `name` and `pass`, these fields can be used to authenticate the
    user. For simplicity, we will use a hardcoded user and password, not a real database:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 已经开发了一个有用的`npm`包来解码`Authorization`头。使用`basic-auth`模块，您可以读取请求头并返回一个包含两个字段的对象：`name`和`pass`，这些字段可以用来验证用户。为了简单起见，我们将使用硬编码的用户名和密码，而不是真实的数据库：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The middleware checks whether the user is `john` and the password is `doe`.
    If not, an HTTP `401` error will be sent to the client. You can use the middleware
    for each resources that you want to protect:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件会检查用户名是否为`john`且密码是否为`doe`。如果不是，将向客户端发送HTTP `401`错误。您可以为想要保护的每个资源使用中间件：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `WWW-Authenticate` header that we include in the HTTP 401 response will
    make sure that the browser prompts a dialog box asking you for a user and password.
    You can use the `john` user and the `doe` password in the dialog, then the browser
    will build and send the Authentication header for you:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 HTTP 401 响应中包含的 `WWW-Authenticate` 头部将确保浏览器弹出一个对话框要求你输入用户名和密码。你可以在对话框中使用
    `john` 用户和 `doe` 密码，然后浏览器将为你构建并发送认证头：
- en: '![Implementing HTTP Basic Authentication](img/B01962_10_07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![实现 HTTP 基本认证](img/B01962_10_07.jpg)'
- en: Figure 10.7 Basic authentication login
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 基本认证登录
- en: 'To have more control over how to ask for authentication, you can create a `form`
    view and add some routes for authentication purposes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地控制如何请求认证，你可以创建一个 `form` 视图并为认证目的添加一些路由：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `LoginView` method should handle the authentication process when the user
    clicks the **Login** button:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginView` 方法应该在用户点击 **登录** 按钮时处理认证过程：'
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A new route should be added to show the `#/login` form:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应该添加一个新的路由来显示 `#/login` 表单：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will need to include this new router when the application bootstraps, as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，你需要包含这个新的路由，如下所示：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When an unauthenticated user accesses the `#/contacts` route, Backbone Application
    should redirect them to the login form:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当未认证的用户访问 `#/contacts` 路由时，Backbone 应用程序应该将他们重定向到登录表单：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the server responds with an HTTP 401, it means that the user is not authenticated
    and you then can show the login window. Remember to remove the `WWW-Authenticate`
    response header in order to prevent the browser from showing its login dialog:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器响应 HTTP 401 时，意味着用户未认证，此时你可以显示登录窗口。请记住，为了防止浏览器显示其登录对话框，需要移除 `WWW-Authenticate`
    响应头：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Implementing HTTP Basic Authentication](img/B01962_10_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![实现 HTTP 基本认证](img/B01962_10_08.jpg)'
- en: Figure 10.8 Login form
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 登录表单
- en: 'Now that we have a login form in place, we can put the authentication code
    in it. That''s going to be done in the following three steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了登录表单，我们可以将其中的认证代码放入其中。这将分为以下三个步骤进行：
- en: Build the Authentication string.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建认证字符串。
- en: Test whether the Authentication string is valid.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试认证字符串是否有效。
- en: Save the Authentication string for future requests.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为未来的请求保存认证字符串。
- en: 'The authentication string is easy to build, you can use the `btoa()`function
    to convert strings to `base64`, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 认证字符串很容易构建，你可以使用 `btoa()` 函数将字符串转换为 `base64`，如下所示：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, you can use `authString` to test whether can get the contacts resource
    successfully. If the server answers successfully, then the user is using the right
    credentials:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `authString` 来测试是否可以成功获取联系人资源。如果服务器成功响应，则说明用户正在使用正确的凭据：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the Authentication string is valid, then the user is redirected to the contact
    list; however, the redirection will not work as expected as the `Authorization`
    header in the contact list is not sent. Remember that you should send the Authorization
    header for every request.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果认证字符串有效，则用户将被重定向到联系人列表；然而，重定向可能不会按预期工作，因为联系人列表中没有发送 `Authorization` 头部。请记住，你应该为每个请求发送
    `Authorization` 头部。
- en: 'You will need to save the `Authentication` string in `sessionStorage` to be
    used in future requests. The `sessionStorage` is similar to `localStorage`; however,
    in `sessionStorage`, the data will be removed when the browser is closed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将 `Authentication` 字符串保存在 `sessionStorage` 中，以便在未来的请求中使用。`sessionStorage`
    与 `localStorage` 类似；然而，在 `sessionStorage` 中，数据将在浏览器关闭时被移除：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `App` object will be responsible for storing the token:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 对象将负责存储令牌：'
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After the token is saved in `sessionStorage`, you should include the `Authorization`
    header for every future request:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在将令牌保存在 `sessionStorage` 中后，你应该为每个未来的请求包含 `Authorization` 头部：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the application is bootstrapped, it should look whether there is an active
    session open; if so, it should use the session, as shown in the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，它应该检查是否有活跃的会话打开；如果有，则应该使用该会话，如下所示：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The user should be able to log out. Let''s add a route for the user to log
    out in the App router:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该能够注销。让我们在 App 路由器中添加一个用户注销的路由：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The session is removed when the `auth` string is removed from `sessionStorage`
    and the Authentication header is not sent anymore:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `sessionStorage` 中移除 `auth` 字符串并且不再发送认证头时，会话将被移除：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's how you can implement authorization with the HTTP Basic Auth protocol.
    An authorization string is generated and attached for every request made to the
    server, that's done with the help of the `ajaxSetup()`method of jQuery. In the
    following section, we will see how to implement the OAuth2 protocol.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以使用HTTP基本认证协议实现授权的方法。为每个发送到服务器的请求生成并附加一个授权字符串，这是通过jQuery的 `ajaxSetup()`
    方法完成的。在下一节中，我们将看到如何实现OAuth2协议。
- en: Implementing OAuth authentication
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现OAuth认证
- en: As we did for Basic Auth, we are going to build a server-side implementation
    of the OAuth2 protocol. As the Backbone App and Server App are both built by us,
    the best grant type to choose is *Resource Owner Password Credentials Grant*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在基本认证中所做的那样，我们将构建OAuth2协议的服务端实现。由于Backbone App和Server App都是由我们构建的，因此最佳授权类型选择是
    *资源所有者密码凭证授权*。
- en: 'A difference from Basic Auth is that OAuth2 needs to add an endpoint that is
    used to issue access and refresh tokens. As described in RFC-6749, the requests
    made to this endpoint should include the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与基本认证不同，OAuth2需要添加一个用于颁发访问和刷新令牌的端点。如RFC-6749所述，对此端点发出的请求应包括以下内容：
- en: '*The client makes a request to the token endpoint by adding the following parameters
    using the "application/x-www-form-urlencoded":*'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*客户端通过使用 "application/x-www-form-urlencoded" 添加以下参数向令牌端点发起请求：*'
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*grant_type: REQUIRED. Value MUST be set to "password".*'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*grant_type：必需。值必须设置为 "password"。*'
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*username: REQUIRED. The resource owner username.*'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*用户名：必需。资源所有者的用户名。*'
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Password: REQUIRED. The resource owner password.*'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*密码：必需。资源所有者的密码。*'
- en: 'A valid request will look as shown in the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的请求将如下所示：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, the server will respond with a valid access token, an optional refresh
    token, and a token type; it could contain additional values, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器将响应一个有效的访问令牌、可选的刷新令牌和令牌类型；它可能包含其他值，如下所示：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `token_type` value tells the client about the kind of token that was issued,
    in our case, it is `Bearer`. We can start the implementation by creating the necessary
    functions in order to issue authorization tokens:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`token_type` 值告诉客户端所颁发令牌的类型，在我们的情况下，它是 `Bearer`。我们可以通过创建必要的函数来开始实现颁发授权令牌：'
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As specified in the RFC document, if the grant type is not supported, then we
    should respond with an `invalid_grant` error; and if a parameter is missing in
    the request, then we should respond with an `invalid_request` error.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如RFC文档中指定，如果未支持授权类型，则我们应该响应一个 `invalid_grant` 错误；如果请求中缺少参数，则我们应该响应一个 `invalid_request`
    错误。
- en: 'If the username and password coincide, then we can issue an authorization token:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户名和密码匹配，则我们可以颁发一个授权令牌：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The generated tokens are just a random string generated with the `generateToken()`
    function, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的令牌只是使用 `generateToken()` 函数生成的随机字符串，如下所示：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These tokens should be stored somewhere in order to be validated for future
    requests. For simplicity, in this book, we will store the tokens in memory objects;
    however, you can use a databases such as Redis for real projects:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些令牌应该存储在某个地方，以便在未来的请求中进行验证。为了简单起见，在这本书中，我们将令牌存储在内存对象中；然而，您可以使用如Redis这样的数据库进行实际项目：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `validTokens` and `refreshTokens`are hash tables store the tokens. The tokens
    in `validTokens` should be removed after the **TTL** (**Time to live**) expires,
    the `setTimeout()` call will ensure that these items are automatically removed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`validTokens` 和 `refreshTokens` 是存储令牌的哈希表。在 **TTL** （**生存时间**）到期后，`validTokens`
    中的令牌应该被移除，`setTimeout()` 调用将确保这些项自动移除。'
- en: 'To validate whether a user is authenticated, we just need to check whether
    the token is active in the `validTokens`hash table, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证用户是否已认证，我们只需检查令牌是否在 `validTokens` 哈希表中有效，如下所示：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the function that is described in this section, it is possible to implement
    OAuth2 in our Contacts App project. Let''s add a route in order to generate the
    access tokens and add a middleware to protect the resources, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本节中描述的函数，我们可以在我们的Contacts App项目中实现OAuth2。让我们添加一个路由来生成访问令牌，并添加一个中间件来保护资源，如下所示：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `oauth2Middleware` module provides the `requireAuthorization()` middleware
    and the `authenticate()`authentication handler as described in the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`oauth2Middleware` 模块提供了 `requireAuthorization()` 中间件和 `authenticate()` 认证处理器，如下所述：'
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To issue a new token, you need to call the `authorize()` function, which returns
    a valid OAuth2 response as specified in the RFC document:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了颁发新的令牌，你需要调用 `authorize()` 函数，该函数返回一个符合 RFC 文档中指定的有效 OAuth2 响应：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `requireAuthorization()` middleware is used to protect the resources with
    our OAuth2 protocol implementation. The middleware splits the token in two parts:
    the token type and the token itself; it verifies whether the token type and its
    existence in the active access tokens list is valid.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`requireAuthorization()` 中间件用于保护我们 OAuth2 协议实现中的资源。该中间件将令牌分为两部分：令牌类型和令牌本身；它验证令牌类型及其在活动访问令牌列表中的存在是否有效。'
- en: 'In the Backbone App, we can reuse the objects that we made for the Basic Auth
    protocol; however, we have to make small changes. In the `LoginView` object, you
    should change the `url` request to `/api/oauth/token` and change the method to
    `POST`, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Backbone 应用程序中，我们可以重用为基本认证协议创建的对象；然而，我们需要进行一些小的修改。在 `LoginView` 对象中，你应该将 `url`
    请求更改为 `/api/oauth/token` 并将方法更改为 `POST`，如下所示：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Authentication in Backbone applications can be tricky if you don't have a clear
    vision of how authentication works in REST servers. As Backbone is authentication
    agnostic, it does not force you to use an authentication mechanism. As a developer,
    it's your responsibility to create one or adhere to an existing one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有清晰的关于 REST 服务器中认证工作原理的视野，Backbone 应用程序中的认证可能会变得复杂。由于 Backbone 对认证是中立的，它不会强迫你使用某种认证机制。作为开发者，创建一个或遵循现有的认证机制是你的责任。
- en: In Backbone Apps, backed by stateless servers, you should move the session handling
    code to the browser. In the examples shown in this chapter, we used `sessionStorage`
    to store the access tokens; however, you can use another storage solution such
    as `localStorage` and `indexeddb`, or even cookies.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在无状态服务器的支撑下，Backbone 应用程序中，你应该将会话处理代码移动到浏览器中。在本章展示的示例中，我们使用了 `sessionStorage`
    来存储访问令牌；然而，你也可以使用其他存储解决方案，例如 `localStorage` 和 `indexeddb`，甚至 cookies。
- en: Then, we saw how to combine the theory with the practical implementation of
    the Basic Auth and OAuth2 protocols in Contacts App. The implementation was transparent
    for the rest of the application, therefore, you can switch between the implementations
    easily.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了如何在 Contacts 应用程序中将基本认证和 OAuth2 协议的理论与实践实现相结合。该实现对于应用程序的其他部分是透明的，因此，你可以轻松地在实现之间切换。
