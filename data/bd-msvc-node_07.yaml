- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Integrating Microservices in Node.js Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Node.js应用程序中集成微服务
- en: Integrating microservices in Node.js involves establishing communication and
    coordination between different services to create a cohesive and functioning system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中集成微服务涉及在不同服务之间建立通信和协调，以创建一个统一且功能齐全的系统。
- en: We’ll start this chapter by integrating microservices into Node.js applications.
    When integrating microservices into Node.js, consider the specific requirements
    of your system, the communication patterns that best suit your needs, and the
    tools and libraries available in the Node.js ecosystem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，将微服务集成到Node.js应用程序中。当将微服务集成到Node.js时，请考虑你系统的具体要求、最适合你需求的通信模式，以及Node.js生态系统中的工具和库。
- en: By the end of this chapter, you will be able to integrate microservices into
    your Node.js applications and build a robust and scalable architecture that can
    handle complex business requirements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够将微服务集成到你的Node.js应用程序中，并构建一个强大且可扩展的架构，该架构可以处理复杂的企业需求。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Synchronous HTTP/REST communication and asynchronous messaging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步HTTP/REST通信和异步消息
- en: Event-driven architecture (EDA) and API gateways
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动架构（EDA）和API网关
- en: Service mesh and caching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格和缓存
- en: Distributed tracing and database integration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪和数据库集成
- en: Monitoring and observability and error handling and resilience
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和可观察性以及错误处理和弹性
- en: Synchronous HTTP/REST communication and asynchronous messaging
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步HTTP/REST通信和异步消息
- en: In this section, we’re going to learn about synchronous HTTP/REST communication
    and asynchronous messaging, two fundamental communication patterns that are used
    in microservices architectures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习关于同步HTTP/REST通信和异步消息的内容，这两种是微服务架构中使用的两种基本通信模式。
- en: Synchronous HTTP/REST communication
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步HTTP/REST通信
- en: '**Synchronous communication** in microservices often involves HTTP/REST, where
    one microservice makes a request to another microservice to fulfill a specific
    operation.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步通信**在微服务中通常涉及HTTP/REST，其中一个微服务向另一个微服务发出请求以完成特定操作。'
- en: 'Here are the key concepts for using this form of communication:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用这种通信方式的关键概念：
- en: '**Request-response model**: Synchronous communication follows a request-response
    model where a client sends a request to a server and waits for a response. In
    RESTful APIs, this communication is typically done over HTTP/HTTPS protocols.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求-响应模型**：同步通信遵循请求-响应模型，其中客户端向服务器发送请求并等待响应。在RESTful API中，这种通信通常通过HTTP/HTTPS协议进行。'
- en: '`GET`, `POST`, `PUT`, `DELETE`, and so on) are used to perform operations on
    resources. They are used to define the operations that can be performed on resources
    within the microservices architecture. These methods are defined by the HTTP protocol.
    Let’s take a quick look at some of them:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PUT`、`DELETE`等用于对资源执行操作。它们用于定义在微服务架构中可以在资源上执行的操作。这些方法由HTTP协议定义。让我们快速看一下其中的一些：'
- en: '`GET`: Used to retrieve data from a specified resource'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：用于从指定资源检索数据'
- en: '`POST`: Used to create new data on the server'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：用于在服务器上创建新数据'
- en: '`PUT`: Used to update data on the server'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：用于在服务器上更新数据'
- en: '`PATCH`: Used to partially update data on the server'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：用于在服务器上部分更新数据'
- en: '`DELETE`: Used to remove data from the server'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：用于从服务器删除数据'
- en: In a Node.js-based microservices architecture, these HTTP methods are used to
    define the API endpoints that represent the services offered by each microservice.
    For example, a user microservice might have endpoints for retrieving user data
    using the `GET` method, creating a new user using the `POST` method, updating
    a user using the `PUT` or `PATCH` method, and deleting a user using the `DELETE`
    method. These HTTP methods are handled within a Node.js application using frameworks
    such as Express.js, which provide a straightforward way to define route handlers
    for each endpoint and HTTP method, allowing developers to easily implement the
    necessary functionality for each microservice.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在基于Node.js的微服务架构中，这些HTTP方法用于定义API端点，这些端点代表了每个微服务提供的服务。例如，一个用户微服务可能包含使用`GET`方法检索用户数据的端点，使用`POST`方法创建新用户，使用`PUT`或`PATCH`方法更新用户，以及使用`DELETE`方法删除用户。这些HTTP方法在Node.js应用程序中使用如Express.js等框架进行处理，这些框架提供了一个简单的方法来定义每个端点和HTTP方法的路由处理器，使得开发者可以轻松实现每个微服务所需的功能。
- en: '**RESTful principles**: **Representational state transfer** (**REST**) is an
    architectural style for designing networked applications. It emphasizes stateless
    communication, meaning each request from a client contains all the information
    the server needs to fulfill that request. In the context of microservices in Node.js,
    REST is commonly used to define the way services communicate with each other.
    When building microservices using Node.js, REST is often used to define the endpoints
    and the HTTP methods that the services can use to communicate with each other.
    For example, a microservice might expose a set of RESTful APIs that other microservices
    can call to perform specific actions.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RESTful原则**：**表征状态转移**（**REST**）是一种用于设计网络应用程序的架构风格。它强调无状态通信，意味着每个客户端请求都包含服务器完成该请求所需的所有信息。在Node.js微服务的上下文中，REST通常用于定义服务之间通信的方式。当使用Node.js构建微服务时，REST通常用于定义端点和服务之间通信时可以使用的HTTP方法。例如，一个微服务可能会公开一组RESTful
    API，其他微服务可以通过调用这些API来执行特定操作。'
- en: Additionally, RESTful APIs are commonly used to define the resources and data
    that can be accessed or manipulated by the microservices. This can include defining
    how data is structured, how it can be retrieved or updated, and what actions can
    be performed on the data. In Node.js, developers commonly use frameworks such
    as Express.js to create RESTful APIs for their microservices. Express.js provides
    a simple and flexible way to define routes, handle requests, and interact with
    data, making it a popular choice for building RESTful APIs in Node.js microservices.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，RESTful API通常用于定义微服务可以访问或操作的资源和数据。这可能包括定义数据的结构、如何检索或更新数据以及可以在数据上执行的操作。在Node.js中，开发者通常使用Express.js等框架来为他们的微服务创建RESTful
    API。Express.js提供了一种简单灵活的方式来定义路由、处理请求和与数据交互，使其成为在Node.js微服务中构建RESTful API的热门选择。
- en: Overall, using REST in microservices in Node.js allows developers to create
    a flexible and scalable architecture that enables different services to communicate
    and collaborate effectively.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总体而言，在Node.js微服务中使用REST可以让开发者创建一个灵活且可扩展的架构，该架构能够使不同的服务有效地进行通信和协作。
- en: '**Statelessness and scalability**: The stateless nature of REST APIs makes
    them highly scalable. Each request contains all the necessary information, and
    servers do not need to maintain session states for clients.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态和可扩展性**：REST API的无状态特性使其具有高度的可扩展性。每个请求都包含所有必要的信息，服务器不需要为客户端维护会话状态。'
- en: '`/users`, `/products`, and so on) are key abstractions in REST. Clients interact
    with resources using standard HTTP methods, and resources are represented in JSON
    or XML format.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`/users`, `/products` 等) 是REST中的关键抽象。客户端通过标准HTTP方法与资源交互，资源以JSON或XML格式表示。
- en: '**Data formats**: JSON and XML are commonly used data formats in synchronous
    communication. They provide a standard way to structure data exchanged between
    services.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据格式**：JSON和XML是同步通信中常用的数据格式。它们提供了一种标准的方式来结构化服务之间交换的数据。'
- en: These key concepts will help you when you create synchronous HTTP/REST communication
    so that you can communicate within your applications. This, in turn, will ensure
    better communication with microservices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键概念将帮助你在创建同步HTTP/REST通信时进行沟通，从而确保与微服务之间更好的通信。
- en: '*Figure 7**.1* illustrates synchronous HTTP/REST communication:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.1* 展示了同步的HTTP/REST通信：'
- en: '![Figure 7.1: Synchronous HTTP/REST communication (image by cornecoba on Freepik)](img/B14980_07_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：同步HTTP/REST通信（图片由cornecoba在Freepik提供）](img/B14980_07_01.jpg)'
- en: 'Figure 7.1: Synchronous HTTP/REST communication (image by cornecoba on Freepik)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：同步HTTP/REST通信（图片由cornecoba在Freepik提供）
- en: In microservices architecture, a combination of both synchronous HTTP/REST communication
    and asynchronous messaging is often used. This helps developers build complex
    systems faster and better overall.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，通常结合使用同步的HTTP/REST通信和异步消息传递。这有助于开发者更快、更好地构建复杂系统。
- en: With these concepts in mind, let’s take a deeper look at asynchronous messaging.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些概念的基础上，让我们更深入地探讨异步消息传递。
- en: Asynchronous messaging
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步消息传递
- en: '**Asynchronous messaging** plays a crucial role in microservices architectures,
    providing flexibility, scalability, and decoupling between services.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步消息传递**在微服务架构中发挥着至关重要的作用，提供了服务的灵活性、可扩展性和解耦。'
- en: 'Here are some of the key concepts of asynchronous messaging:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是异步消息传递的一些关键概念：
- en: '**Publish-subscribe model**: Asynchronous communication follows a publish-subscribe
    model, where services publish events to a message broker, and other services subscribe
    to these events without knowing the sender’s identity.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布-订阅模型**：异步通信遵循发布-订阅模型，其中服务将事件发布到消息代理，其他服务订阅这些事件，而无需知道发送者的身份。'
- en: '**EDA**: EDA allows microservices to react to events and messages asynchronously.
    For example, when a new user is created, an event is published, and services interested
    in user creation events can subscribe and react accordingly.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EDA**：EDA 允许微服务异步地响应事件和消息。例如，当创建新用户时，会发布一个事件，对用户创建事件感兴趣的服务可以订阅并相应地做出反应。'
- en: '**Message brokers**: Message brokers such as **RabbitMQ**, **Apache Kafka**,
    and **AWS SQS** facilitate asynchronous messaging. They decouple producers and
    consumers, ensuring that messages are delivered even if the recipient service
    is temporarily unavailable.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息代理**：如 **RabbitMQ**、**Apache Kafka** 和 **AWS SQS** 等消息代理简化了异步消息传递。它们解耦了生产者和消费者，确保即使在接收者服务暂时不可用的情况下，消息也能被传递。'
- en: '**Eventual consistency**: Asynchronous messaging often leads to eventual consistency,
    where services might not immediately reflect the latest changes. This trade-off
    between consistency and responsiveness is essential in distributed systems.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：异步消息传递通常导致最终一致性，其中服务可能不会立即反映最新的更改。这种一致性与响应性之间的权衡在分布式系统中至关重要。'
- en: '**Reliability and fault tolerance**: Asynchronous messaging improves reliability
    by allowing services to handle messages at their own pace. It also provides fault
    tolerance; if a service fails, messages are not lost and can be processed later.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性和容错性**：异步消息传递通过允许服务以自己的节奏处理消息来提高可靠性。它还提供了容错性；如果服务失败，消息不会丢失，可以在稍后处理。'
- en: '**Challenges in asynchronous systems**: Asynchronous communication introduces
    complexities such as message ordering, duplicate processing, and dealing with
    failed messages. Implementing idempotent processing and appropriate error handling
    mechanisms is crucial.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步系统的挑战**：异步通信引入了诸如消息排序、重复处理和应对失败消息等复杂性。实现幂等处理和适当的错误处理机制至关重要。'
- en: '**Microservices integration patterns**: Asynchronous messaging is often used
    in microservices integration patterns such as event sourcing, **command query
    responsibility segregation** (**CQRS**), and Sagas (to manage long-running and
    complex business transactions).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务集成模式**：异步消息传递常用于微服务集成模式，如事件溯源、**命令查询责任分离**（**CQRS**）和 Sagas（用于管理长时间运行和复杂的业务交易）。'
- en: '*Figure 7**.2* illustrates the process of asynchronous messaging:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7*。2* 展示了异步消息传递的过程：'
- en: '![Figure 7.2: Asynchronous messaging (image by teravector on Freepik)](img/B14980_07_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：异步消息传递（图片由 Freepik 上的 teravector 提供）](img/B14980_07_02.jpg)'
- en: 'Figure 7.2: Asynchronous messaging (image by teravector on Freepik)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：异步消息传递（图片由 Freepik 上的 teravector 提供）
- en: Synchronous communication is suitable for simple and immediate interactions,
    while asynchronous messaging provides flexibility, scalability, and fault tolerance
    for more complex and decoupled interactions among microservices. Which one you
    should choose depends on your specific use cases and system requirements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同步通信适用于简单和即时的交互，而异步消息传递为微服务之间更复杂和松散的交互提供了灵活性、可扩展性和容错性。您应该选择哪一个取决于您的具体用例和系统需求。
- en: In the context of microservices in Node.js, synchronous communication refers
    to a direct request-response mechanism, where the caller waits for the response
    from the target microservice before proceeding. This can be achieved through methods
    such as HTTP REST APIs, **remote procedure calls** (**RPCs**), or synchronous
    messaging systems, such as AMQP.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中的微服务背景下，同步通信指的是直接请求-响应机制，调用者等待目标微服务的响应后再继续。这可以通过 HTTP REST API、**远程过程调用**（**RPC**）或同步消息系统（如
    AMQP）等方法实现。
- en: On the other hand, asynchronous communication involves a decoupled, non-blocking
    method of communication. This can be achieved through messaging systems such as
    Apache Kafka and RabbitMQ or through EDAs that use technologies such as WebSockets
    or MQTT. In this approach, the sender does not wait for an immediate response
    and instead continues with other tasks, receiving the response later.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，异步通信涉及一种解耦、非阻塞的通信方法。这可以通过消息系统（如Apache Kafka和RabbitMQ）或使用WebSocket或MQTT等技术实现的EDAs来实现。在这种方法中，发送者不会等待立即的响应，而是继续进行其他任务，稍后接收响应。
- en: Regarding logging, Datadog and Splunk both provide comprehensive solutions for
    monitoring and logging in microservices environments. To integrate logging with
    Datadog and Splunk in a Node.js microservices architecture, you can use the respective
    libraries or SDKs provided by Datadog and Splunk. For Datadog, you can use the
    `datadog-node` library or any available community-supported integrations. This
    library collects logs, traces, and metrics from your Node.js applications and
    sends them to Datadog for visualization and analysis. Similarly, for Splunk, you
    can use the `splunk-connect-for-nodejs` library, which provides a way to easily
    send logs from your Node.js applications to Splunk for indexing and analysis.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于日志记录，Datadog和Splunk都为微服务环境提供了全面的监控和日志记录解决方案。要在Node.js微服务架构中将日志与Datadog和Splunk集成，您可以使用Datadog和Splunk提供的相应库或SDK。对于Datadog，您可以使用`datadog-node`库或任何可用的社区支持的集成。这个库从您的Node.js应用程序收集日志、跟踪和指标，并将它们发送到Datadog进行可视化和分析。同样，对于Splunk，您可以使用`splunk-connect-for-nodejs`库，它提供了一种简单地将您的Node.js应用程序中的日志发送到Splunk进行索引和分析的方法。
- en: Additionally, both Datadog and Splunk provide extensive documentation and resources
    to guide you through the process of integrating their logging solutions with your
    Node.js microservices. By leveraging the capabilities of these tools, you can
    effectively monitor, trace, and log the behavior and performance of your microservices
    architecture, enabling you to gain valuable insights and optimize your system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Datadog和Splunk都提供了广泛的文档和资源，以指导您将它们的日志解决方案与您的Node.js微服务集成。通过利用这些工具的功能，您可以有效地监控、跟踪和记录微服务架构的行为和性能，从而获得宝贵的见解并优化您的系统。
- en: Now that you understand these concepts, let’s learn about EDA and API gateways.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了这些概念，让我们来学习EDA和API网关。
- en: EDA and API gateways
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EDA和API网关
- en: EDA and API gateways can help us make the right choice when it comes to choosing
    the right architecture for our applications and also the right gateway for our
    API.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: EDA和API网关可以帮助我们在选择应用程序的正确架构以及API的正确网关时做出正确的选择。
- en: EDA
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EDA
- en: '**EDA** is a paradigm where the flow of information is determined by events.
    In the context of microservices, EDA is a powerful approach for building loosely
    coupled and scalable systems.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**EDA**是一种信息流由事件决定的范式。在微服务的上下文中，EDA是构建松散耦合和可扩展系统的一种强大方法。'
- en: 'The following concepts are involved in this architecture:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本架构涉及以下概念：
- en: '**Loose coupling**: EDA decouples microservices by allowing them to communicate
    asynchronously through events. Services emit events when certain actions occur,
    and other services can react to these events without direct coupling.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松散耦合**：EDA通过允许服务通过事件异步通信来解耦微服务。服务在发生某些操作时发出事件，其他服务可以对这些事件做出反应，而无需直接耦合。'
- en: '**Publish-subscribe model**: The publish-subscribe pattern is central to EDA.
    Services can publish events to a message broker, and other services can subscribe
    to specific event types. This pattern enables seamless communication without services
    being aware of each other.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布-订阅模型**：发布-订阅模式是EDA的核心。服务可以将事件发布到消息代理，其他服务可以订阅特定的事件类型。这种模式使得服务之间无需相互了解即可实现无缝通信。'
- en: '**Event types**: Events represent significant occurrences in the system, such
    as user registration or order placement. Events contain relevant data, allowing
    subscribers to react appropriately.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件类型**：事件代表系统中的重大事件，例如用户注册或订单放置。事件包含相关数据，使订阅者能够适当地做出反应。'
- en: '**Scalability and responsiveness**: EDA supports horizontal scalability as
    services can independently process events. This enhances system responsiveness,
    especially for processing large volumes of events.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和响应性**：EDA支持水平扩展，因为服务可以独立处理事件。这增强了系统的响应性，尤其是在处理大量事件时。'
- en: '**Event sourcing and command query responsibility segregation**: EDA pairs
    well with event sourcing, where events are stored as the primary source of truth
    for the application’s state. CQRS can be employed to separate read and write operations
    based on events, optimizing performance.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件存储和命令查询责任分离**：EDA与事件存储配合良好，其中事件作为应用状态的原始真相存储。CQRS可以根据事件分离读取和写入操作，优化性能。'
- en: '**Reliability and fault tolerance**: EDA enhances reliability. Even if a service
    is temporarily unavailable, events are not lost. Message brokers often provide
    features like retries and acknowledgments, ensuring message delivery.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性和容错性**：EDA增强了可靠性。即使某个服务暂时不可用，事件也不会丢失。消息代理通常提供重试和确认等特性，确保消息传递。'
- en: '**Complex workflows and sagas**: EDA is ideal for managing complex workflows
    and long-running transactions using the Saga pattern. Sagas orchestrate multiple
    services’ actions in response to a series of events, ensuring consistency.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的工作流和叙事**：EDA非常适合使用叙事模式管理复杂的工作流和长时间运行的交易。叙事通过一系列事件协调多个服务的操作，确保一致性。'
- en: EDA is widely used in Node.js because it ensures the stability of applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: EDA在Node.js中广泛使用，因为它确保了应用稳定性。
- en: With these concepts covered, let’s look at API gateways.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这些概念之后，让我们来看看API网关。
- en: API gateways
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API网关
- en: '**API gateways** can offer so many benefits to your application, but you must
    master the following concepts:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**API网关**可以为您的应用带来许多好处，但您必须掌握以下概念：'
- en: '**Single entry point**: An API gateway is a server that acts as a single entry
    point for managing requests from clients. It handles various tasks, such as authentication,
    request routing, load balancing, and caching.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一入口点**：API网关是一个服务器，充当管理来自客户端请求的单一入口点。它处理各种任务，如身份验证、请求路由、负载均衡和缓存。'
- en: '**Request routing**: API gateways can route requests to appropriate microservices
    based on the request’s URL, headers, or other parameters. This enables clients
    to interact with the gateway without needing to know the internal service structure.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求路由**：API网关可以根据请求的URL、头部或其他参数将请求路由到适当的微服务。这使得客户端无需了解内部服务结构即可与网关交互。'
- en: '**Authentication and authorization**: API gateways handle authentication by
    verifying user credentials and generating tokens. They also handle authorization
    by ensuring that the authenticated user has permission to access specific resources.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证和授权**：API网关通过验证用户凭据并生成令牌来处理身份验证。它们还通过确保已验证用户有权访问特定资源来处理授权。'
- en: '**Load balancing**: API gateways distribute incoming requests among multiple
    instances of microservices, ensuring even workload distribution and high availability.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：API网关在多个微服务的实例之间分配传入的请求，确保均匀的工作负载分配和高可用性。'
- en: '**Caching**: API gateways can cache responses from microservices, reducing
    the load on services and improving latency for frequently accessed data.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：API网关可以缓存来自微服务的响应，减少服务负载并提高频繁访问数据的延迟。'
- en: '**Protocol translation**: Gateways can translate communication protocols. For
    instance, they can accept HTTPS requests from clients and communicate with internal
    services over HTTP.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议转换**：网关可以转换通信协议。例如，它们可以接受来自客户端的HTTPS请求，并通过HTTP与内部服务进行通信。'
- en: '**Rate limiting and throttling**: API gateways can enforce rate limiting and
    throttling policies to prevent abuse and ensure fair usage of resources.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制和节流**：API网关可以强制执行速率限制和节流策略，以防止滥用并确保资源的公平使用。'
- en: '**Logging and monitoring**: API gateways log incoming requests and responses,
    providing valuable insights for monitoring and debugging. They often integrate
    with centralized logging and monitoring solutions.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录和监控**：API网关记录传入的请求和响应，为监控和调试提供有价值的见解。它们通常与集中式日志记录和监控解决方案集成。'
- en: '**Cross-cutting concerns**: API gateways address cross-cutting concerns, allowing
    individual microservices to focus on business logic without worrying about concerns
    such as security and protocol translation.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**横切关注点**：API网关解决横切关注点，使单个微服务能够专注于业务逻辑，无需担心诸如安全性和协议转换等问题。'
- en: API gateways act as unique points for our applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: API网关作为我们应用的独特入口点。
- en: '*Figure 7**.3* depicts API gateways:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7*.*3*展示了API网关：'
- en: '![Figure 7.3: API gateways (image by Freepik)](img/B14980_07_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：API网关（图片由Freepik提供）](img/B14980_07_03.jpg)'
- en: 'Figure 7.3: API gateways (image by Freepik)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：API网关（图片由Freepik提供）
- en: In summary, EDA provides flexibility and decoupling, enabling services to react
    to events asynchronously. API gateways, on the other hand, act as unified interfaces,
    managing various aspects of the client-service interaction and enhancing the security,
    scalability, and monitoring capabilities in a microservices ecosystem. When used
    together, they create a robust, responsive, and manageable microservices architecture.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，事件驱动架构（EDA）提供了灵活性和解耦，使服务能够异步响应事件。另一方面，API 网关充当统一的接口，管理客户端-服务交互的各个方面，并增强微服务生态系统的安全性、可扩展性和监控能力。当它们一起使用时，它们创建了一个强大、响应迅速且易于管理的微服务架构。
- en: Now, we can continue to the next section, in which we will talk about service
    mesh and caching.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续到下一节，我们将讨论服务网格和缓存。
- en: Service mesh and caching
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务网格和缓存
- en: In microservices architecture, service mesh and caching can help simplify the
    architecture of microservices and improve their performance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务网格和缓存可以帮助简化微服务的架构并提高其性能。
- en: Service mesh
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务网格
- en: '**Service mesh** is a dedicated infrastructure layer that facilitates communication,
    observability, and control between services in a microservices architecture. It
    is designed to handle complex communication patterns, provide network-level functions,
    and enhance the overall manageability of microservices.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务网格**是一个专门的基础设施层，它促进了微服务架构中服务之间的通信、可观察性和控制。它旨在处理复杂的通信模式，提供网络级功能，并增强微服务的整体可管理性。'
- en: 'The following concepts will help you start with service mesh:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下概念将帮助您开始使用服务网格：
- en: '**Service-to-service communication**: Service mesh is a dedicated infrastructure
    layer for handling service-to-service communication. It simplifies complex microservices
    architectures by managing communication between services.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务间通信**：服务网格是一个专门的基础设施层，用于处理服务间通信。它通过管理服务之间的通信来简化复杂的微服务架构。'
- en: '**Sidecar pattern**: Service mesh typically follows the sidecar pattern, where
    a proxy sidecar container is deployed alongside each microservice. These sidecars
    handle communication, leaving microservices free from network concerns.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边车模式**：服务网格通常遵循边车模式，其中在每个微服务旁边部署一个代理边车容器。这些边车处理通信，使微服务免于网络问题。'
- en: '**Traffic management**: Service mesh allows for sophisticated traffic management.
    It can handle tasks such as load balancing, retries, timeouts, and circuit breaking,
    improving reliability and fault tolerance.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量管理**：服务网格允许进行复杂的流量管理。它可以处理诸如负载均衡、重试、超时和断路器等任务，从而提高可靠性和容错性。'
- en: '**Observability**: Service mesh provides deep observability into the microservices
    ecosystem. It can collect metrics, traces, and logs, allowing for better insights
    into service behavior and performance.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察性**：服务网格为微服务生态系统提供了深入的观察能力。它可以收集指标、跟踪和日志，从而更好地了解服务行为和性能。'
- en: '**Security**: Service mesh enhances security by handling encryption, identity
    and access management, and policy enforcement. It ensures secure communication
    between services, even in a multi-cloud or hybrid environment.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：服务网格通过处理加密、身份和访问管理以及策略执行来增强安全性。即使在多云或混合环境中，它也能确保服务之间的安全通信。'
- en: '**Dynamic configuration**: Service mesh allows for dynamic configuration changes
    without requiring service redeployment. Policies, retries, and other settings
    can be adjusted in real time.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态配置**：服务网格允许进行动态配置更改，而无需重新部署服务。策略、重试和其他设置可以实时调整。'
- en: '**Traffic splitting**: Service mesh enables traffic splitting, allowing gradual
    rollouts of new features. It can send a portion of traffic to the updated service
    version, allowing for A/B testing and canary releases.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量拆分**：服务网格允许流量拆分，允许逐步推出新功能。它可以向更新的服务版本发送部分流量，从而进行 A/B 测试和金丝雀发布。'
- en: Understanding service mesh better can help you simplify the architecture of
    microservices.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地理解服务网格可以帮助您简化微服务的架构。
- en: '*Figure 7**.4* illustrates service mesh:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.4* 展示了服务网格：'
- en: '![Figure 7.4: Service mesh (image by rawpixel on Freepik)](img/B14980_07_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：服务网格（图片由 Freepik 上的 rawpixel 提供）](img/B14980_07_04.jpg)'
- en: 'Figure 7.4: Service mesh (image by rawpixel on Freepik)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：服务网格（图片由 Freepik 上的 rawpixel 提供）
- en: Service mesh is a crucial concept while developing in microservices. Next, we’ll
    look at caching.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务开发中，服务网格是一个关键概念。接下来，我们将探讨缓存。
- en: Caching
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: '**Caching** is a crucial optimization strategy in microservices architectures,
    aiming to improve performance, reduce latency, and enhance scalability.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**是微服务架构中的一种关键优化策略，旨在提高性能、减少延迟并增强可伸缩性。'
- en: 'You can improve your application by applying the following methodologies:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过应用以下方法来改进您的应用程序：
- en: '**Improved performance**: Caching stores frequently accessed data closer to
    the requestor, reducing the need to fetch it from the source. This significantly
    improves response times and reduces server load.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高性能**：缓存将频繁访问的数据存储在请求者附近，减少了从源获取数据的需要。这显著提高了响应时间并减少了服务器负载。'
- en: '**Cache invalidation**: One challenge with caching is cache invalidation. Cached
    data can become stale, leading to inconsistencies. Strategies such as time-based
    invalidation or using cache expiry can mitigate this.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存失效**：缓存的一个挑战是缓存失效。缓存数据可能会过时，导致不一致。基于时间失效或使用缓存过期策略等策略可以减轻这一问题。'
- en: '**Cache strategies**: Implement cache strategies based on the application requirements.
    Strategies include full-page caching, object caching, or query caching. Each caters
    to different types of data.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存策略**：根据应用程序需求实施缓存策略。策略包括全页缓存、对象缓存或查询缓存。每种策略都针对不同类型的数据。'
- en: '**Distributed caching**: In microservices architectures, distributed caching
    systems are crucial. Tools such as **Redis** or **Memcached** allow microservices
    to share cached data, enhancing overall system performance.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式缓存**：在微服务架构中，分布式缓存系统至关重要。例如**Redis**或**Memcached**这样的工具允许微服务共享缓存数据，从而提高整体系统性能。'
- en: '**Cache security**: Secure sensitive data in the cache, ensuring that sensitive
    information doesn’t end up in caches. This is why we must implement proper access
    controls and encryption mechanisms for cached data.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存安全**：在缓存中保护敏感数据，确保敏感信息不会最终出现在缓存中。这就是为什么我们必须为缓存数据实施适当的访问控制和加密机制。'
- en: '**Cache-aside and write-through**: Caching strategies such as cache-aside (fetch
    data from the database if not found in the cache) and write-through caching (write
    data to both cache and database simultaneously) help maintain data consistency.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存旁路和写入通过**：如缓存旁路（如果缓存中找不到数据则从数据库中获取数据）和写入通过缓存策略（同时将数据写入缓存和数据库）有助于保持数据一致性。'
- en: '**Cache monitoring**: You can perform cache monitoring to track cache hits,
    misses, and effectiveness, while also optimizing caching strategies and ensuring
    cache efficiency.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存监控**：您可以执行缓存监控以跟踪缓存命中、未命中和有效性，同时优化缓存策略并确保缓存效率。'
- en: '*Figure 7**.5* illustrates the process of caching:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7*.*5*说明了缓存的过程：'
- en: '![Figure 7.5: Caching (image by vectorjuice on Freepik)](img/B14980_07_05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：缓存（由Freepik上的vectorjuice提供）](img/B14980_07_05.jpg)'
- en: 'Figure 7.5: Caching (image by vectorjuice on Freepik)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：缓存（由Freepik上的vectorjuice提供）
- en: In summary, service mesh simplifies and enhances microservices communication,
    providing advanced features for traffic management, security, and observability.
    Caching, on the other hand, improves performance by storing frequently accessed
    data, but it requires careful management, especially concerning cache invalidation
    and consistency. Integrating these technologies effectively can significantly
    enhance the performance, reliability, and security of microservices-based applications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，服务网格简化并增强了微服务之间的通信，提供了高级的流量管理、安全和可观察性功能。另一方面，缓存通过存储频繁访问的数据来提高性能，但它需要谨慎的管理，特别是在缓存失效和一致性方面。有效地集成这些技术可以显著提高基于微服务的应用程序的性能、可靠性和安全性。
- en: In the next section, we will learn about distributed tracing and database integration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解分布式追踪和数据库集成。
- en: Distributed tracing and database integration
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式追踪和数据库集成
- en: In this section, we will learn how to implement a distributed tracing infrastructure
    and how to integrate databases for microservices.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何实现分布式追踪基础设施以及如何将数据库集成到微服务中。
- en: Let’s explore each of these topics in more detail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这些主题。
- en: Distributed tracing
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式追踪
- en: '**Distributed tracing** is a technique that’s used in microservices architectures
    to monitor, profile, and troubleshoot complex interactions between services. It
    helps visualize the flow of requests as they traverse various microservices.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式追踪**是一种在微服务架构中用于监控、分析和调试服务之间复杂交互的技术。它有助于可视化请求在穿越各种微服务时的流动。'
- en: 'Distributed tracing has the following characteristics:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪具有以下特点：
- en: '**End-to-end visibility**: Distributed tracing allows you to track requests
    as they traverse various microservices. It provides end-to-end visibility into
    the flow of requests, helping diagnose issues and optimize performance.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端可见性**：分布式跟踪允许您跟踪请求在穿越各种微服务时的路径。它提供了对请求流程的端到端可见性，有助于诊断问题和优化性能。'
- en: '**Trace context**: Distributed tracing relies on a trace context that travels
    with the request. Each service in the microservices architecture adds its information
    to the trace context, allowing correlation and visualization of the entire request
    path.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪上下文**：分布式跟踪依赖于随请求传递的跟踪上下文。微服务架构中的每个服务都会将其信息添加到跟踪上下文中，从而允许关联和可视化整个请求路径。'
- en: '**Root cause analysis**: When performance issues occur, distributed tracing
    provides a way to identify the root cause. By examining traces, developers can
    pinpoint which service or component is causing delays or errors.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根本原因分析**：当出现性能问题时，分布式跟踪提供了一种识别根本原因的方法。通过检查跟踪，开发者可以确定导致延迟或错误的特定服务或组件。'
- en: '**Distributed tracing tools**: Tools such as **Jaeger**, **Zipkin**, and **OpenTelemetry**
    facilitate distributed tracing. They collect trace data, visualize dependencies,
    and provide insights into latency bottlenecks.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式跟踪工具**：例如 **Jaeger**、**Zipkin** 和 **OpenTelemetry** 等工具简化了分布式跟踪。它们收集跟踪数据，可视化依赖关系，并提供对延迟瓶颈的洞察。'
- en: '**Performance optimization**: Distributed tracing aids in performance optimization.
    Developers can analyze traces to identify bottlenecks, optimize service interactions,
    and reduce overall system latency.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能优化**：分布式跟踪有助于性能优化。开发者可以通过分析跟踪来识别瓶颈，优化服务交互，并减少整体系统延迟。'
- en: '**Production debugging**: In production, tracing helps in debugging. When errors
    occur, traces can be examined to understand the sequence of events and the context
    in which the error happened.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产调试**：在生产环境中，跟踪有助于调试。当发生错误时，可以通过检查跟踪来了解事件序列和错误发生的上下文。'
- en: '**Simplifying complexity**: In complex microservices architectures, distributed
    tracing simplifies understanding. It provides a clear picture of how services
    interact, making it easier to maintain and evolve the system.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化复杂性**：在复杂的微服务架构中，分布式跟踪简化了理解。它提供了服务如何交互的清晰图景，使得维护和演进系统更加容易。'
- en: As you can see, distributed tracing ensures better visibility of interactions
    and layers in microservices.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，分布式跟踪确保了微服务中交互和层的更好可见性。
- en: In the next section, we will talk about database integration.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论数据库集成。
- en: Database integration
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库集成
- en: '**Database integration** is a critical aspect of microservices architecture
    that involves managing data storage, access, and interactions across multiple
    microservices.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库集成**是微服务架构的一个关键方面，涉及管理多个微服务中的数据存储、访问和交互。'
- en: 'Let’s take a look at how to integrate databases in microservices:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在微服务中集成数据库：
- en: '**Database abstraction layers**: We can use database abstraction layers such
    as **object-relational mappers** (**ORMs**) or **object-document mappers** (**ODMs**)
    to abstract away database-specific details, promote code modularity, and make
    it easier to switch databases if needed.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库抽象层**：我们可以使用数据库抽象层，如 **对象关系映射器**（**ORMs**）或 **对象文档映射器**（**ODMs**），来抽象数据库特定的细节，促进代码模块化，并在需要时更容易地切换数据库。'
- en: '**Database connection pools**: We can implement connection pooling to manage
    and reuse database connections efficiently. Connection pools prevent the overhead
    of establishing a new database connection for every request, improving performance.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库连接池**：我们可以实现连接池来高效地管理和重用数据库连接。连接池防止了为每个请求建立新的数据库连接的开销，从而提高了性能。'
- en: '**Data consistency**: To ensure data consistency across microservices, we can
    implement distributed transactions or adopt eventual consistency models based
    on the application’s requirements. Tools such as Saga patterns can manage long-running
    transactions across multiple services.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据一致性**：为确保微服务之间的数据一致性，我们可以根据应用需求实现分布式事务或采用最终一致性模型。例如，Saga模式可以管理跨多个服务的长时间运行的事务。'
- en: '**Caching strategies**: We can implement caching mechanisms to reduce the number
    of database queries. Using caching layers such as Redis to store frequently accessed
    data helps improve response times and reduces database load.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存策略**：我们可以实施缓存机制以减少数据库查询次数。使用Redis等缓存层存储频繁访问的数据有助于提高响应时间并减少数据库负载。'
- en: '**Asynchronous database operations**: For non-blocking behavior and improved
    responsiveness, we can perform asynchronous database operations. We can use techniques
    such as callbacks, **promises**, or async/await in Node.js to handle asynchronous
    tasks efficiently.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步数据库操作**：为了非阻塞行为和改进的响应性，我们可以执行异步数据库操作。在Node.js中，我们可以使用回调、**承诺**（**promises**）或async/await等技术来有效地处理异步任务。'
- en: '**Database sharding and replication**: For scalability, we can consider database
    **sharding** (horizontal partitioning of data across multiple databases) and **replication**
    (creating backup copies of databases). These techniques distribute the load and
    enhance fault tolerance.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库分片和复制**：为了可扩展性，我们可以考虑数据库**分片**（在多个数据库中跨数据水平分区）和**复制**（创建数据库的备份副本）。这些技术分散了负载并增强了容错性。'
- en: '**Security measures**: To enforce security measures at the database level,
    we can implement proper authentication, authorization, encryption, and input validation
    to protect against data breaches and SQL injection attacks. Here are some best
    practices for security in microservices developed using Node.js:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全措施**：为了在数据库级别实施安全措施，我们可以实施适当的身份验证、授权、加密和输入验证，以防止数据泄露和SQL注入攻击。以下是使用Node.js开发的微服务中的安全最佳实践：'
- en: '**Implement role-based access control** (**RBAC**): Use RBAC to manage permissions
    and access to different microservices and resources.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施基于角色的访问控制**（**RBAC**）：使用RBAC来管理对不同微服务和资源的权限和访问。'
- en: '**Use API gateways**: Implement an API gateway to manage incoming and outgoing
    traffic, enforce security policies, and implement rate limiting.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用API网关**：实施API网关以管理进出流量，执行安全策略并实施速率限制。'
- en: '**Secure communication**: Use HTTPS to encrypt communication between microservices
    and clients. Implement secure protocols such as TLS to ensure data integrity and
    confidentiality.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护通信**：使用HTTPS加密微服务和客户端之间的通信。实施安全的协议，如TLS，以确保数据完整性和机密性。'
- en: '**Input validation and sanitization**: Validate and sanitize input from clients
    to prevent injection attacks such as SQL injection, NoSQL injection, and **cross-site**
    **scripting** (**XSS**).'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证和清理**：验证并清理来自客户端的输入，以防止SQL注入、NoSQL注入和**跨站脚本**（**XSS**）等注入攻击。'
- en: '**Secure authentication and authorization**: Use industry-standard authentication
    protocols such as OAuth or JWT to authenticate and authorize users accessing microservices.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护身份验证和授权**：使用行业标准身份验证协议，如OAuth或JWT，对访问微服务的用户进行身份验证和授权。'
- en: '**Implement fine-grained logging and monitoring**: Log and monitor access to
    microservices, including authentication attempts, data access, and error handling,
    to detect and respond to security incidents.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施细粒度日志和监控**：记录并监控对微服务的访问，包括身份验证尝试、数据访问和错误处理，以检测和响应安全事件。'
- en: '**Implement security headers**: Utilize security headers such as **Content
    security policy** (**CSP**), **Strict-transport-security** (**HSTS**), and X-Content-Type-Options
    to enhance security and protect against common web vulnerabilities.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施安全头部信息**：利用安全头部信息，如**内容安全策略**（**CSP**）、**严格传输安全**（**HSTS**）和X-Content-Type-Options，以增强安全性并防范常见的网络漏洞。'
- en: '**Secure dependencies**: Regularly update and patch third-party libraries and
    dependencies to avoid security vulnerabilities.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护依赖项**：定期更新和修补第三方库和依赖项，以避免安全漏洞。'
- en: '**Use CSP**: Implement CSP headers to XSS attacks by controlling which resources
    can be loaded by web pages.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用CSP**：通过控制网页可以加载哪些资源来实施CSP头部信息，以防范XSS攻击。'
- en: '**Implement rate limiting**: Implement rate limiting to prevent brute-force
    attacks and **Denial of Service** (**DoS**) attacks.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施速率限制**：实施速率限制以防止暴力攻击和**拒绝服务**（**DoS**）攻击。'
- en: By following these best practices, you can enhance the security of your microservices
    developed using Node.js and reduce the risk of security vulnerabilities.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践，您可以增强使用Node.js开发的微服务的安全性，并降低安全漏洞的风险。
- en: '**Monitoring and analytics**: We can implement database monitoring tools to
    track performance metrics, query execution times, and resource utilization. Then,
    we can use these insights to optimize database queries and configurations for
    better efficiency.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和分析**: 我们可以实施数据库监控工具来跟踪性能指标、查询执行时间和资源利用率。然后，我们可以利用这些洞察来优化数据库查询和配置，以实现更好的效率。'
- en: '**Backup and disaster recovery**: It is important to establish backup and disaster
    recovery procedures for databases. We must regularly back up data and implement
    disaster recovery strategies to prevent data loss in case of system failures.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份和灾难恢复**: 为数据库建立备份和灾难恢复程序非常重要。我们必须定期备份数据并实施灾难恢复策略，以防止系统故障导致数据丢失。'
- en: '**Schema evolution**: As the application evolves, database schemas may need
    changes. Employing strategies such as migrations to handle schema modifications
    without disrupting the application’s functionality can help us plan for schema
    evolution.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式演进**: 随着应用程序的发展，数据库模式可能需要更改。采用如迁移等策略来处理模式修改，而不会影响应用程序的功能，可以帮助我们规划模式演进。'
- en: In summary, integrating distributed tracing ensures visibility into microservices
    interactions, facilitating effective debugging and optimization. Simultaneously,
    a well-integrated and optimized database layer is crucial for data consistency,
    scalability, security, and performance, ensuring the overall stability and responsiveness
    of the microservices architecture.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，集成分布式追踪确保了对微服务交互的可见性，促进了有效的调试和优化。同时，一个良好集成和优化的数据库层对于数据一致性、可扩展性、安全性和性能至关重要，确保了微服务架构的整体稳定性和响应性。
- en: In the next section, we are going to talk about monitoring and observability
    and error handling and resilience.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论监控和可观察性以及错误处理和弹性。
- en: Monitoring and observability and error handling and resilience
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控和可观察性以及错误处理和弹性
- en: In this section, you will learn how to monitor and observe microservices. You
    will also learn more about error handling and resilience, both of which are crucial
    aspects of developing better microservices.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何监控和观察微服务。你还将了解更多关于错误处理和弹性，这两者都是开发更好的微服务的关键方面。
- en: Let’s explore these topics in more detail.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这些主题。
- en: Monitoring and observability
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控和可观察性
- en: '**Monitoring and observability** are crucial components of microservices architecture,
    providing insights into system health, performance, and behavior.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**监控和可观察性**是微服务架构的关键组件，提供了对系统健康、性能和行为洞察。'
- en: 'Let’s take a look at the characteristics of these components:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些组件的特点：
- en: '**Metrics collection**: Monitoring involves collecting various metrics such
    as CPU usage, memory usage, request rates, error rates, and latency. These metrics
    provide insights into system performance.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标收集**: 监控涉及收集各种指标，如CPU使用率、内存使用率、请求速率、错误率和延迟。这些指标提供了对系统性能的洞察。'
- en: '**Centralized logging**: Centralized logging aggregates logs from all microservices
    into a central system (such as ELK Stack). Centralized logs simplify debugging
    and troubleshooting across the entire system.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式日志记录**: 集中式日志记录将所有微服务的日志聚合到一个中央系统（如ELK Stack）中。集中式日志简化了整个系统的调试和故障排除。'
- en: '**Distributed tracing**: Distributed tracing tools (such as Jaeger and Zipkin)
    provide end-to-end visibility into requests as they pass through different microservices.
    Traces enable detailed analysis of request flows, helping in identifying bottlenecks
    and issues.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式追踪**: 分布式追踪工具（如Jaeger和Zipkin）提供了对请求在通过不同微服务时的端到端可见性。追踪允许对请求流程进行详细分析，有助于识别瓶颈和问题。'
- en: In a distributed tracing system, it is very important to not only trace the
    happy flow of a system but also log errors and important flows in a production
    environment. By adding logging for errors and critical flows, you can gain more
    insight into the performance and behavior of your distributed system. This can
    help you identify and troubleshoot issues promptly, as well as improve the overall
    reliability and stability of the system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式追踪系统中，不仅追踪系统的正常流程非常重要，而且在生产环境中记录错误和重要流程也同样重要。通过添加错误和关键流程的日志记录，你可以更深入地了解分布式系统的性能和行为。这可以帮助你及时识别和解决问题，以及提高系统的整体可靠性和稳定性。
- en: Logging errors and important flows will provide valuable information that can
    be used for debugging and optimizing your production environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 记录错误和重要流程将提供有价值的信息，可用于调试和优化您的生产环境。
- en: '**Alerting and thresholds**: You can set up alerting mechanisms based on predefined
    thresholds to notify teams when specific metrics exceed acceptable limits, thereby
    enabling proactive issue resolution.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报和阈值**：您可以根据预定义的阈值设置警报机制，当特定指标超过可接受限制时通知团队，从而实现主动问题解决。'
- en: '**Visualization and dashboards**: You can create visualization tools and dashboards
    (using tools such as Grafana) to present data in a comprehensible manner. Visualizations
    help in real-time tracking and performance analysis.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视化和仪表板**：您可以使用可视化工具和仪表板（例如Grafana）以可理解的方式展示数据。可视化有助于实时跟踪和性能分析。'
- en: '**Anomaly detection**: We can also implement anomaly detection algorithms to
    automatically identify abnormal patterns in metrics. Anomalies could indicate
    potential issues that require investigation.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常检测**：我们还可以实施异常检测算法，以自动识别指标中的异常模式。异常可能表明需要调查的潜在问题。'
- en: '**Capacity planning**: Monitoring data can also aid capacity planning. By analyzing
    trends, teams can anticipate resource requirements and scale the infrastructure
    proactively.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容量规划**：监控数据还可以帮助进行容量规划。通过分析趋势，团队可以预测资源需求并主动扩展基础设施。'
- en: '**Cost optimization**: Monitoring data aids in cost optimization by identifying
    underutilized resources. Right-sizing instances and optimizing resource allocation
    can lead to significant cost savings.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本优化**：通过识别未充分利用的资源，监控数据有助于成本优化。调整实例大小和优化资源分配可以带来显著的成本节约。'
- en: Monitoring and observability are ongoing processes that evolve with the system.
    By adopting a comprehensive strategy that includes metrics, logs, tracing, and
    proactive testing, microservices architectures can maintain a high level of reliability
    and performance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和可观察性是随着系统发展而持续进行的过程。通过采用包括指标、日志、跟踪和主动测试在内的全面策略，微服务架构可以保持高可靠性和性能水平。
- en: '*Figure 7**.6* depicts monitoring and observability:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7*.*6*展示了监控和可观察性：'
- en: '![Figure 7.6: Monitoring and observability (image by storyset on Freepik)](img/B14980_07_06.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：监控和可观察性（图片由Freepik上的storyset提供）](img/B14980_07_06.jpg)'
- en: 'Figure 7.6: Monitoring and observability (image by storyset on Freepik)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：监控和可观察性（图片由Freepik上的storyset提供）
- en: 'Monitoring and observability can help identify crucial problems in microservices.
    There are several monitoring tools and frameworks available for monitoring microservices
    in Node.js. Here are a few commonly used ones:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和可观察性可以帮助识别微服务中的关键问题。在Node.js中，有几种监控工具和框架可用于监控微服务。以下是一些常用的工具：
- en: '**Prometheus**: Prometheus is an open source monitoring and alerting toolkit.
    It is widely used in the microservices community and has a Node.js client library
    for instrumenting Node.js applications.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prometheus**：Prometheus是一个开源的监控和警报工具包。它在微服务社区中广泛使用，并为Node.js应用程序提供客户端库以进行仪表化。'
- en: '**Grafana**: Grafana is an open source visualization and monitoring tool that
    works seamlessly with Prometheus and other data sources. It provides a rich set
    of visualizations and dashboards for monitoring microservices.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grafana**：Grafana是一个开源的可视化和监控工具，与Prometheus和其他数据源无缝协作。它为监控微服务提供了一套丰富的可视化和仪表板。'
- en: '**New Relic**: New Relic provides monitoring and observability solutions for
    microservices, including Node.js applications. It offers application performance
    monitoring, error tracking, and distributed tracing capabilities.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**New Relic**：New Relic为微服务提供监控和可观察性解决方案，包括Node.js应用程序。它提供应用程序性能监控、错误跟踪和分布式跟踪功能。'
- en: '**Datadog**: Datadog is a cloud-scale monitoring and analytics platform that
    provides monitoring, logging, and distributed tracing for microservices.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Datadog**：Datadog是一个云规模的监控和分析平台，为微服务提供监控、日志记录和分布式跟踪。'
- en: '**Dynatrace**: Dynatrace is an AI-powered monitoring and observability platform
    that provides automated instrumentation and monitoring for microservices, including
    Node.js applications.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dynatrace**：Dynatrace是一个由人工智能驱动的监控和可观察性平台，为微服务（包括Node.js应用程序）提供自动化的仪表化和监控。'
- en: These tools can help you monitor the performance, availability, and reliability
    of your microservices in a Node.js environment. Each tool has its own set of features
    and capabilities, so it’s important to evaluate them based on your specific monitoring
    requirements.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具可以帮助你在Node.js环境中监控微服务的性能、可用性和可靠性。每个工具都有自己的功能和能力，因此根据你的具体监控需求进行评估很重要。
- en: In the next section, we will learn more about error handling and resilience.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习更多关于错误处理和弹性的内容。
- en: Error handling and resilience
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理和弹性
- en: '**Error handling and resilience** are critical aspects of microservices architecture,
    ensuring that the system can gracefully handle failures and maintain its functionality.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误处理和弹性**是微服务架构的关键方面，确保系统可以优雅地处理故障并保持其功能。'
- en: 'You must be able to debug every microservice while utilizing the following
    concepts:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用以下概念的同时，你必须能够调试每个微服务：
- en: '**Graceful degradation**: Implement graceful degradation, where the system
    continues to provide limited functionality even if certain components fail. Users
    experience a degraded but still usable service.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优雅降级**：实现优雅降级，即使某些组件失败，系统也能继续提供有限的功能。用户会体验到降级但仍可用的服务。'
- en: '**Timeouts and retries**: Use timeouts and retries in communication between
    microservices. If a service doesn’t respond within a specified time, implement
    retries. Gradually increase timeout durations for successive retries.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时和重试**：在微服务之间的通信中使用超时和重试。如果一个服务在指定时间内没有响应，则实现重试。逐渐增加连续重试的超时时间。'
- en: '**Circuit breaker pattern**: If a service consistently fails, the circuit breaker
    pattern temporarily stops requests to that service. This prevents cascading failures
    and allows the service to recover.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器模式**：如果一个服务持续失败，断路器模式会暂时停止对该服务的请求。这可以防止级联故障并允许服务恢复。'
- en: '**Fallback mechanisms**: Providing fallback mechanisms when a service fails
    can return cached data, default values, or static responses, ensuring users receive
    some response even during failures.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退机制**：当服务失败时提供回退机制可以返回缓存数据、默认值或静态响应，确保即使在故障期间用户也能收到一些响应。'
- en: '**Bulkheads**: Implement bulkheads to isolate failures. Isolating components
    ensures that a failure in one part of the system doesn’t affect the entire system.
    This is especially important in scenarios with resource constraints.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防波堤**：实现防波堤以隔离故障。隔离组件确保系统某一部分的故障不会影响整个系统。这在资源受限的场景中尤为重要。'
- en: In the context of microservices and error handling, bulkheads refer to the concept
    of isolating different parts of the application to prevent failures in one area
    from affecting other areas. This can be achieved by creating separate pools of
    resources for different types of work, such as thread pools, database connections,
    and network connections. The idea is to compartmentalize the system so that errors
    or failures in one part of the application do not cascade and affect the availability
    or performance of other parts. This can help improve the system’s resilience and
    fault tolerance.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在微服务和错误处理的背景下，防波堤指的是将应用程序的不同部分隔离的概念，以防止一个区域的故障影响其他区域。这可以通过为不同类型的工作创建单独的资源池来实现，例如线程池、数据库连接和网络连接。其思想是将系统隔离开来，以便应用程序某一部分的错误或故障不会级联并影响其他部分的可用性或性能。这有助于提高系统的弹性和容错能力。
- en: For example, in a microservices architecture, implementing bulkheads can involve
    isolating the error handling and recovery strategies for each service so that
    a failure in one service does not bring down the entire system. It can also involve
    setting limits and controls on the resources used by each service to prevent resource
    exhaustion and degradation of performance.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在微服务架构中，实现防波堤可能包括隔离每个服务的错误处理和恢复策略，以便一个服务的故障不会导致整个系统崩溃。这还可能包括对每个服务使用的资源设置限制和控制，以防止资源耗尽和性能下降。
- en: '**Chaos engineering**: Practice chaos engineering to proactively identify weaknesses
    in the system. Introduce controlled failures in production-like environments to
    observe how the system behaves under stress.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混沌工程**：实践混沌工程以主动识别系统中的弱点。在生产环境类似的环境中引入可控的故障，以观察系统在压力下的行为。'
- en: '**Automatic healing**: Implementing automatic healing mechanisms with tools
    like Kubernetes which can automatically restart failed containers, ensuring rapid
    recovery from failures without manual intervention.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动恢复**：通过 Kubernetes 等工具实现自动恢复机制，这些工具可以自动重启失败的容器，确保在无需人工干预的情况下快速从故障中恢复。'
- en: '**Error codes and messages**: Clear, consistent error messages help clients
    understand failures and can guide them in taking appropriate actions.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误代码和消息**：清晰的、一致的错误消息有助于客户端理解失败，并指导他们采取适当的行动。'
- en: '**Post-mortems and root cause analysis**: Conduct post-mortems after incidents
    to understand the root cause of failures. Document findings and implement preventive
    measures to avoid similar issues in the future.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事后分析和根本原因分析**：在事件发生后进行事后分析，以了解失败的根本原因。记录发现并实施预防措施，以避免未来出现类似问题。'
- en: By keeping these concepts in mind, you will have extra power while debugging
    applications to ensure better compatibility in different environments.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过牢记这些概念，你在调试应用程序时将拥有额外的力量，以确保在不同环境中具有更好的兼容性。
- en: In summary, by combining robust monitoring and observability practices with
    effective error handling and resilience strategies, microservices architectures
    can maintain high availability, deliver reliable performance, and ensure a positive
    user experience, even in the face of unexpected challenges.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过结合强大的监控和可观察性实践、有效的错误处理和弹性策略，微服务架构可以在面对意外挑战的情况下，保持高可用性、提供可靠的性能，并确保良好的用户体验。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned a lot about microservices and how to integrate them
    into our applications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于微服务及其如何集成到我们的应用程序中的很多知识。
- en: Integrating microservices into Node.js applications involves harmoniously connecting
    independent services so that they work cohesively in a larger system. It also
    helps us integrate microservices faster and develop better applications.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将微服务集成到 Node.js 应用程序中涉及和谐地连接独立的服务，以便它们在一个更大的系统中协同工作。这也帮助我们更快地集成微服务并开发更好的应用程序。
- en: By following these integration practices, Node.js applications can leverage
    the benefits of microservices, enabling flexibility, scalability, and maintainability
    while ensuring a seamless experience for end users and other components of the
    system.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些集成实践，Node.js 应用程序可以利用微服务的优势，实现灵活性、可扩展性和可维护性，同时确保最终用户和系统其他组件的流畅体验。
- en: In the next chapter, we are going to learn how to debug microservices in Node.js
    applications.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在 Node.js 应用程序中调试微服务。
- en: Quiz time
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验时间
- en: What are the key concepts while using synchronous HTTP/REST communication?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同步 HTTP/REST 通信时，关键概念是什么？
- en: What is EDA?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EDA 是什么？
- en: What is service mesh?
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格是什么？
- en: What is caching?
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存是什么？
