- en: Using Node to Access the Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node访问文件系统
- en: '"We have persistent objects - they''re called files."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们有持久对象——它们被称为文件。"'
- en: – *Ken Thompson*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – Ken Thompson
- en: A file is simply a chunk of data that is persisted, usually, on some hard medium
    such as a hard drive. Files are normally composed of a sequence of bytes whose
    encoding maps onto some other pattern, like a sequence of numbers or electrical
    pulses. A nearly infinite number of encodings are possible, with some common ones
    being text files, image files, and music files. Files have a fixed length, and
    to be read, their character encoding must be deciphered by some sort of reader,
    such as an MP3 player or a word processor.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件只是一块数据，通常保存在硬盘等硬介质上。文件通常由一系列字节组成，其编码映射到其他模式，如一系列数字或电脉冲。几乎可以有无限数量的编码，其中一些常见的是文本文件、图像文件和音乐文件。文件具有固定长度，要读取它们，必须由某种阅读器解密其字符编码，例如MP3播放器或文字处理器。
- en: When a file is in transit, moving through a cable after it's been siphoned off
    of some storage device, it is no different than any other data stream running
    through the wire. Its previous solid state is just a stable blueprint that can
    be easily and infinitely copied.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件在传输中，从某个存储设备吸取后通过电缆移动时，它与通过电线运行的任何其他数据流没有区别。它以前的固态只是一个稳定的蓝图，可以轻松且无限地复制。
- en: We've already seen how event streams reflect the core design principles informing
    Node's design, where byte streams are to be read from and written to, and piped
    into other streams, emitting relevant stream events, such as `end`. Files are
    easily understood as being containers of data, filled with bytes that can be extracted
    or inserted partially or as a whole.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到事件流如何反映了Node设计的核心设计原则，其中字节流应该被读取和写入，并被传送到其他流中，发出相关的流事件，如`end`。文件很容易被理解为数据的容器，其中充满了可以部分或完整提取或插入的字节。
- en: In addition to their natural similarity to streams, files also display the characteristics
    of objects. Files have properties that describe the interface available for accessing
    file contents—data structures with properties and associated access methods.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们与流的自然相似性之外，文件还显示了对象的特征。文件具有描述访问文件内容的接口的属性——具有属性和相关访问方法的数据结构。
- en: A **filesystem** reflects some concept of how files should be organized—how
    they are identified, where they are stored, how they are to be accessed, and so
    forth. A common filesystem for UNIX users is the **UFS** (**Unix File System**),
    while Windows users may be familiar with **NTFS** (**New Technology File System**).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统反映了文件应该如何组织的一些概念——它们如何被识别，它们存储在哪里，如何被访问等等。UNIX用户常用的文件系统是UFS（Unix文件系统），而Windows用户可能熟悉NTFS（新技术文件系统）。
- en: It is interesting that the designers of the Plan 9 operating system (a team
    including *Ken Thompson*) decided to have *all* control interfaces represented
    as filesystems, such that all system interfaces (across devices, across applications)
    are modeled as file operations. Treating files as first-class citizens is a philosophy
    the UNIX OS also uses; using files as references to named pipes and sockets, among
    other things, gives developers enormous power when shaping data flow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Plan 9操作系统的设计者（包括Ken Thompson在内的一个团队）决定将*所有*控制接口表示为文件系统，以便所有系统接口（跨设备，跨应用程序）都被建模为文件操作。将文件视为一等公民是UNIX操作系统也使用的哲学；使用文件作为命名管道和套接字的引用等等，使开发人员在塑造数据流时拥有巨大的力量。
- en: File objects are also powerful, and the system they reside within exposes fundamental
    I/O interfaces that must be easy to use, consistent, and very fast. Not surprisingly,
    Node's `file` module exposes just such an interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象也是强大的，它们所在的系统公开了必须易于使用、一致且非常快速的基本I/O接口。不足为奇，Node的`file`模块公开了这样的接口。
- en: 'We will be considering handling files in Node from these two perspectives:
    how file data content is streamed in and out (read from and written), and how
    the attributes of file objects are modified, such as changing file permissions.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这两个角度考虑在Node中处理文件：文件数据内容如何流入和流出（读取和写入），以及如何修改文件对象的属性，如更改文件权限。
- en: Additionally, we will cover the responsibilities of the Node server, in terms
    of accepting file uploads and servicing file requests. By working through examples
    of directory iterators and file servers, the full range and behavior of Node's
    filesystem API should become clear.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将介绍Node服务器的责任，接受文件上传并处理文件请求。通过示例演示目录迭代器和文件服务器，Node的文件系统API的全部范围和行为应该变得清晰。
- en: Lastly, we'll take JavaScript back to the desktop, using GitHub's Electron framework
    to make our own desktop app, a simple file browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用GitHub的Electron框架将JavaScript带回桌面，制作我们自己的桌面应用程序，一个简单的文件浏览器。
- en: Directories, and iterating over files and folders
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录和文件夹的迭代
- en: Typically, a filesystem groups files into collections, normally referred to
    as directories. One navigates through directories to find individual files. Once
    a target file is found, the file object must be wrapped by an interface exposing
    the file contents for reading and writing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文件系统将文件分组成集合，通常称为目录。通过目录导航以找到单个文件。一旦找到目标文件，文件对象必须被包装成一个公开文件内容以供读取和写入的接口。
- en: As Node development often involves the creation of servers that both accept
    and emit file data, it should be clear how important transfer speed at this active
    and important I/O layer is. As mentioned earlier, files can also be understood
    as objects, and objects have certain attributes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node开发通常涉及创建既接受又发出文件数据的服务器，因此应该清楚这个活跃和重要的I/O层的传输速度有多重要。正如前面提到的，文件也可以被理解为对象，而对象具有某些属性。
- en: Types of files
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件类型
- en: 'There are six types of files commonly encountered on a UNIX system:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX系统上通常遇到的有六种类型的文件：
- en: '**Ordinary files**: These contain a one-dimensional array of bytes, and cannot
    contain other files.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通文件**：这些文件包含一维字节数组，不能包含其他文件。'
- en: '**Directories**: These are also files implemented in a special way such that
    they can describe collections of other files.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：这些也是以特殊方式实现的文件，可以描述其他文件的集合。'
- en: '**Sockets**: Used for IPC, allowing processes to exchange data.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：用于IPC，允许进程交换数据。'
- en: '**Named pipe**: A command such as `ps aux | grep node` creates a pipe,'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名管道**：像`ps aux | grep node`这样的命令创建了一个管道，'
- en: which is destroyed once the operation terminates. Named pipes are persistent
    and addressable, and they can be used variously by multiple processes for IPC
    indefinitely.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作终止，它就会被销毁。命名管道是持久的、可寻址的，并且可以被多个进程用于IPC。
- en: '**Device files**: These are representations of I/O devices, processes that
    accept streams of data; `/dev/null` is commonly an example of a character device
    file (accepts serial streams of I/O), and `/dev/sda` is an example of a block
    device file (allowing random access I/O for blocks of data) representing a data
    drive.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备文件**：这些是I/O设备的表示，接受数据流的进程；`/dev/null`通常是字符设备文件的一个例子（接受I/O的串行数据流），`/dev/sda`是块设备文件的一个例子（允许数据块的随机访问I/O），代表一个数据驱动器。'
- en: '**Links**: These are pointers to other files of two types: hard links and symbolic
    links. Hard links directly point to another file and are indistinguishable from
    the target file. Symbolic links are indirect pointers and are distinguishable
    from normal files.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：这些是指向其他文件的指针，有两种类型：硬链接和符号链接。硬链接直接指向另一个文件，并且与目标文件无法区分。符号链接是间接指针，并且可以与普通文件区分开。'
- en: Most Node filesystem interactions encounter only the first two types, with the
    third only indirectly via the Node API. A deeper explanation of the remaining
    types is beyond the scope of this discussion. However, Node provides a full suite
    of file operations via the `file` module, and the reader should have at least
    some familiarity with the full range and power of file types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Node文件系统交互只涉及前两种类型，第三种类型只是通过Node API间接涉及。对剩余类型的更深入解释超出了本讨论的范围。然而，Node通过`file`模块提供了完整的文件操作套件，读者应该至少对文件类型的全部范围和功能有一定的了解。
- en: 'Studying named pipes will reward the reader interested in understanding how
    Node was designed to work with streams and pipes. Try this from a terminal:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 学习命名管道将奖励那些对了解Node如何设计以与流和管道一起工作感兴趣的读者。在终端中尝试这个：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you get an expanded listing of the current directory `-ls -l`, a listing
    similar to this will be shown:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到了当前目录的扩展列表`-ls -l`，将会显示类似于这样的列表：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note the `p` flag in the file mode (the first segment, with the dashes). You''ve
    created a named `(p)ipe`. Now, enter this into the same terminal, pushing some
    bytes into the named pipe:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件模式中的`p`标志（第一个段，带有破折号）。你已经创建了一个命名的`(p)ipe`。现在，输入到同一个终端中，将一些字节推送到命名管道中：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It will seem like the process has hung. It hasn't—pipes, like water pipes, must
    be open on both ends to complete their job of flushing contents. We've pumped
    some bytes in... now what?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像进程已经挂起了。其实没有——管道，就像水管一样，必须在两端打开才能完成它们刷新内容的工作。我们已经把一些字节放进去了……现在呢？
- en: 'Open another terminal, navigate to the same directory, and enter this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端，导航到相同的目录，并输入以下内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`hello` will appear in the second terminal as the contents of `namedpipe` are
    flushed. Note that the first terminal is no longer hung—it has flushed. If you
    recall the discussion on Node streams in [Chapter 3](c7665bc9-3f44-4d7c-8318-61f9dfe962b3.xhtml), *Streaming
    Data Across Nodes and Clients,* you will note something of a resemblance with
    Unix pipes, which is intentional.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello`将出现在第二个终端中，作为`namedpipe`的内容被刷新。请注意，第一个终端不再挂起——它已经刷新了。如果你回忆一下[第3章](c7665bc9-3f44-4d7c-8318-61f9dfe962b3.xhtml)中关于Node流的讨论，*在节点和客户端之间流式传输数据*，你会注意到与Unix管道有些相似之处，这是有意为之的。'
- en: File paths
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件路径
- en: 'Most of the filesystem methods provided by Node will require the manipulation
    of file paths, and for this purpose, we make use of the `path` module. We can
    compose, decompose, and relate paths with this module. Instead of hand rolling
    your own path string splitting and regexing and concatenating routines, try to
    normalize your code by delegating path manipulation to this module:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Node提供的大多数文件系统方法都需要操作文件路径，为此，我们使用`path`模块。我们可以使用这个模块来组合、分解和关联路径。不要手动拆分你自己的路径字符串，也不要使用正则表达式和连接例程，尝试通过将路径操作委托给这个模块来规范化你的代码：
- en: 'Use `path.normalize` whenever working with a file path string whose source
    is untrusted or unreliable to ensure a predictable format:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理源不可信或不可靠的文件路径字符串时，使用`path.normalize`来确保可预测的格式：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use `path.join` whenever building a single path out of path segments:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建路径段时，使用`path.join`：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use `path.dirname` to snip the directory name out of a path:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.dirname`来剪切路径中的目录名：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use `path.basename` to manipulate the final path segment:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.basename`来操作最终的路径段：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use `path.extname` to slice from the last period (`.`) to the end of the path
    string:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.extname`从路径字符串的最后一个句点（`.`）开始切片到末尾：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use `path.relative` to find the relative path from one absolute path to another:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.relative`来找到从一个绝对路径到另一个绝对路径的相对路径：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use `path.resolve` to resolve a list of path instructions into an absolute
    path:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.resolve`来将路径指令列表解析为绝对路径：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Think of the arguments passed to `path.resolve` as being a sequence of `cd`
    calls:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递给`path.resolve`的参数视为一系列`cd`调用：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the list of arguments passed to `path.resolve` fails to deliver an absolute
    path, the current directory name is used as well. For instance, consider that
    we are in `/users/home/john/`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给`path.resolve`的参数列表未能提供绝对路径，那么当前目录名称也会被使用。例如，假设我们在`/users/home/john/`中：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These arguments resolve to a relative path `one/two/three/four` that is, therefore,
    prefixed with the current directory name.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数解析为一个相对路径`one/two/three/four`，因此，它是以当前目录名称为前缀的。
- en: File attributes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件属性
- en: A file object exposes some of its attributes, comprising a useful set of metadata
    about the file data. If one is using Node to run an HTTP server, it will be necessary
    to determine the file length of any file requested via a GET, for example. Determining
    the time a file was last modified finds uses across many types of applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象公开了一些属性，包括有关文件数据的一组有用的元数据。例如，如果使用Node运行HTTP服务器，将需要确定通过GET请求的任何文件的文件长度。确定文件上次修改的时间在许多类型的应用程序中都有用。
- en: 'To read the attributes of a file, use `fs.stat`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件的属性，使用`fs.stat`：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, `stats` will be an `fs.Stats` object describing the
    file through a map of attributes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`stats`将是描述文件的`fs.Stats`对象：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An `fs.Stats` object exposes several useful methods for accessing file attribute
    data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.Stats`对象公开了几个有用的方法来访问文件属性数据：'
- en: Use `stats.isFile` to check for standard files
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isFile`来检查标准文件
- en: Use `stats.isDirectory` to check for directories
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isDirectory`来检查目录
- en: Use `stats.isBlockDevice` to check for block type device files
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isBlockDevice`来检查块设备文件
- en: Use `stats.isCharacterDevice` to check for character type device files
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isCharacterDevice`来检查字符类型设备文件
- en: Use `stats.isSymbolicLink` after an `fs.lstat` to find symbolic links
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`fs.lstat`之后使用`stats.isSymbolicLink`来查找符号链接
- en: Use `stats.isFIFO` to identify named pipes
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isFIFO`来识别命名管道
- en: Use `stats.isSocket` to check for sockets
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isSocket`来检查套接字
- en: 'There are two further `stat` methods available:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个可用的`stat`方法：
- en: '`fs.fstat(fd, callback)`: Similar to `fs.stat`, except that a file descriptor
    `fd`is passed rather than a file path'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs.fstat(fd, callback)`: 类似于`fs.stat`，只是传递了文件描述符`fd`而不是文件路径'
- en: '`fs.lstat(path, callback)`: An `fs.stat` on a symbolic link will return an
    `fs.Stats` object for the target file, while `fs.lstat` will return an `fs.Stats`
    object for the link file itself'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs.lstat(path, callback)`: 对符号链接进行`fs.stat`将返回目标文件的`fs.Stats`对象，而`fs.lstat`将返回链接文件本身的`fs.Stats`对象'
- en: 'The following two methods simplify the file timestamp manipulation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两种方法简化了文件时间戳的操作：
- en: '`fs.utimes(path, atime, mtime, callback)`: Change the access and modify timestamps
    on a file at `path`. The access and modify times of a file are stored as instances
    of the JavaScript `Date` object. `Date.getTime` will, for example, return the
    number of milliseconds elapsed since midnight (UTC) on January 1, 1970.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs.utimes(path, atime, mtime, callback)`: 更改`path`上的文件的访问和修改时间戳。文件的访问和修改时间以JavaScript
    `Date`对象的实例存储。例如，`Date.getTime`将返回自1970年1月1日午夜（UTC）以来经过的毫秒数。'
- en: '`fs.futimes(fd, atime, mtime, callback)`: Change the access and modify timestamps
    on a file descriptor `fd`; it''s similar to `fs.utimes`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs.futimes(fd, atime, mtime, callback)`: 更改文件描述符`fd`上的访问和修改时间戳；它类似于`fs.utimes`。'
- en: 'More information about manipulating dates and times with JavaScript can be
    found at:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用JavaScript操作日期和时间的更多信息，请访问：
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)。'
- en: Opening and closing files
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开和关闭文件
- en: One of the unofficial rules governing the Node project is to not unnecessarily
    abstract away from the existing OS implementation details. As we will see, references
    to file descriptors appear throughout Node's file API. For **POSIX** (**Portable
    Operating System Interface**), a file descriptor is simply an (non-negative) integer
    uniquely referencing a specific file. Since Node modeled its filesystem methods
    on POSIX, not surprisingly, a file descriptor is represented in Node as an integer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Node项目的一个非正式规则是不要不必要地从现有的操作系统实现细节中抽象出来。正如我们将看到的，文件描述符的引用出现在整个Node的文件API中。对于**POSIX**（**可移植操作系统接口**），文件描述符只是一个（非负）整数，唯一地引用特定的文件。由于Node的文件系统方法是基于POSIX建模的，因此文件描述符在Node中表示为整数并不奇怪。
- en: 'Recalling our discussion of how devices and other elements of the OS are represented
    as files, it would stand to reason that the standard I/O streams (`stdin`, `stdout`,
    `stderr`) would also have file descriptors. In fact, that is the case:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们讨论过的设备和操作系统的其他元素是如何表示为文件的，那么标准I/O流（`stdin`，`stdout`，`stderr`）也会有文件描述符是合理的。事实上，情况就是这样的：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: File descriptors are easy to obtain and are convenient ways to pass around file
    references. Let's look at how file descriptors are created and used by examining
    how to perform low-level file open and close operations using Node. As the chapter
    progresses, we'll investigate more refined interfaces to file streams.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符易于获取，并且是传递文件引用的便捷方式。让我们看看如何通过检查如何执行低级文件打开和关闭操作来创建和使用文件描述符。随着本章的进行，我们将研究更精细的文件流接口。
- en: fs.open(path, flags, [mode], callback)
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.open(path, flags, [mode], callback)
- en: 'Trying to open a file at `path`. `callback` will receive any exceptions with
    the operation as its first argument, and a file descriptor as its second argument.
    Here, we open a file for reading:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在`path`处打开文件。`callback`将接收操作的任何异常作为其第一个参数，并将文件描述符作为其第二个参数。在这里，我们打开一个文件进行读取：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`flags` receives a string indicating the types of operations the caller expects
    to perform on the returned file descriptor. Their meanings should be clear:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags`接收一个字符串，指示调用者期望在返回的文件描述符上执行的操作类型。它们的含义应该是清楚的。'
- en: '`r`: Opening a file for reading, throwing an exception if the file doesn''t
    exist.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：打开文件进行读取，如果文件不存在则抛出异常。'
- en: '`r+`: Opening a file for both reading and writing, throwing an exception if
    the file doesn''t exist.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r+`：打开文件进行读取和写入，如果文件不存在则抛出异常。'
- en: '`w`: Opening a file for writing, creating the file if it doesn''t exist, and
    truncating the file to zero bytes if it does exist.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：打开文件进行写入，如果文件不存在则创建文件，并且如果文件存在则将文件截断为零字节。'
- en: '`wx`: Like `w`, but it opens the file in exclusive mode, which means if the
    file already exists, it will **not be opened**, and the open operation will fail.
    This is useful if multiple processes may be simultaneously trying to create the
    same file.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx`：类似于`w`，但以独占模式打开文件，这意味着如果文件已经存在，它将**不会被打开**，打开操作将失败。如果多个进程可能同时尝试创建相同的文件，则这很有用。'
- en: '`w+`: Opening a file for reading and writing, creating the file if it doesn''t
    exist, and truncating the file to zero bytes if it does exist.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w+`：打开文件进行读取和写入，如果文件不存在则创建文件，并且如果文件存在则将文件截断为零字节。'
- en: '`wx+`: Like `wx` (and `w`), additionally opening the file for reading.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx+`：类似于`wx`（和`w`），此外还打开文件进行读取。'
- en: '`a`: Opening a file for appending, creating the file if it does not exist.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：打开文件进行追加，如果文件不存在则创建文件。'
- en: '`ax`: Like **a**, but opens the file in exclusive mode, which means if the
    file already exists, it will **not be opened**, and the open operation will fail.
    This is useful if multiple processes may be simultaneously trying to create the
    same file.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax`：类似于**a**，但以独占模式打开文件，这意味着如果文件已经存在，它将**不会被打开**，打开操作将失败。如果多个进程可能同时尝试创建相同的文件，则这很有用。'
- en: '`a+`: Open a file for reading and appending, creating the file if it does not
    exist.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a+`：打开文件进行读取和追加，如果文件不存在则创建文件。'
- en: '`ax+`: Like `ax` (and `a`), additionally opening the file for reading.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax+`：类似于`ax`（和`a`），此外还打开文件进行读取。'
- en: 'When an operation may create a new file, use the optional `mode` to set permissions
    for this file in octal digits, defaulting to 0666 (refer to `fs.chmod` for more
    information about octal permissions):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作可能创建新文件时，使用可选的`mode`以八进制数字形式设置此文件的权限，默认为0666（有关八进制权限的更多信息，请参阅`fs.chmod`）：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: fs.close(fd, callback)
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.close(fd, callback)
- en: The `fs.close(fd, callback)` method closes a file descriptor. The callback receives
    one argument, any exception thrown in the call. It's a good habit to close all
    the file descriptors that have been opened.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.close(fd, callback)` 方法关闭文件描述符。回调函数接收一个参数，即调用中抛出的任何异常。关闭所有已打开的文件描述符是一个好习惯。'
- en: File operations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: Node implements the standard POSIX functions for working with files, which a
    UNIX user will be familiar with. We will not be covering each member of this extensive
    collection in depth, instead focusing on some commonly used examples. In particular,
    we will go into depth discussing the methods for opening file descriptors and
    manipulating file data, reading and manipulating file attributes, and moving through
    filesystem directories. Nevertheless, the reader is encouraged to experiment with
    the entire set, which the following list briefly describes. Note that all of these
    methods are asynchronous, non-blocking file operations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Node实现了用于处理文件的标准POSIX函数，UNIX用户会很熟悉。我们不会深入讨论这个庞大集合的每个成员，而是专注于一些常用的例子。特别是，我们将深入讨论打开文件描述符和操作文件数据的方法，读取和操作文件属性，以及在文件系统目录中移动。然而，鼓励读者尝试整套方法，以下列表简要描述了这些方法。请注意，所有这些方法都是异步的，非阻塞文件操作。
- en: fs.rename(oldName, newName, callback)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.rename(oldName, newName, callback)
- en: The `fs.rename(oldName, newName, callback)` method renames file at `oldName` to
    `newName`. The callback receives one argument, any exception thrown in the call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.rename(oldName, newName, callback)` 方法将`oldName`处的文件重命名为`newName`。回调函数接收一个参数，即调用中抛出的任何异常。'
- en: fs.truncate(path, len, callback)
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.truncate(path, len, callback)
- en: The `fs.truncate(path, len, callback)` method changes the length of the file
    at `path` by `len` bytes. If `len` represents a length shorter than the file's
    current length, the file is truncated to that length. If `len` is greater, the
    file length is padded by appending null bytes (x00) until `len` is reached. The
    callback receives one argument, any exception thrown in the call.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.truncate(path, len, callback)` 方法通过`len`字节更改`path`处文件的长度。如果`len`表示比文件当前长度更短的长度，则文件将被截断为该长度。如果`len`更大，则文件长度将通过附加空字节（x00）进行填充，直到达到`len`。回调函数接收一个参数，即调用中抛出的任何异常。'
- en: fs.ftruncate(fd, len, callback)
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.ftruncate(fd, len, callback)
- en: The `fs.ftruncate(fd, len, callback)` method is like `fs.truncate`, except that
    instead of specifying a file, a file descriptor is passed as `fd`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.ftruncate(fd, len, callback)` 方法类似于`fs.truncate`，不同之处在于不是指定文件，而是将文件描述符作为`fd`传递。'
- en: fs.chown(path, uid, gid, callback)
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.chown(path, uid, gid, callback)
- en: The `fs.chown(path, uid, gid, callback)` method changes the ownership of the
    file at `path`. Use this to set whether user `uid` or group `gid` has access to
    a file. The callback receives one argument, any exception thrown in the call.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.chown(path, uid, gid, callback)` 方法更改`path`处文件的所有权。使用此方法设置用户`uid`或组`gid`是否可以访问文件。回调函数接收一个参数，即调用中抛出的任何异常。'
- en: fs.fchown(fd, uid, gid, callback)
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.fchown(fd, uid, gid, callback)
- en: The `fs.fchown(fd, uid, gid, callback)` method is like `fs.chown`, except that
    instead of specifying a file path, a file descriptor is passed as `fd`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.fchown(fd, uid, gid, callback)` 方法与`fs.chown`类似，不同之处在于不是指定文件路径，而是将文件描述符作为`fd`传递。'
- en: fs.lchown(path, uid, gid, callback)
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.lchown(path, uid, gid, callback)
- en: The `fs.lchown(path, uid, gid, callback)` method is like `fs.chown`, except
    that in the case of symbolic links, ownership of the link file itself is changed,
    but not the referenced link.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.lchown(path, uid, gid, callback)` 方法与`fs.chown`类似，不同之处在于对于符号链接，更改的是链接文件本身的所有权，而不是引用的链接。'
- en: fs.chmod(path, mode, callback)
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.chmod(path, mode, callback)
- en: 'The `fs.chmod(path, mode, callback)` method changes the `mode`(permissions)
    on a file at `path`. You are setting the read(4), write(2), and execute(1) bits
    for this file, which can be sent in octal digits:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.chmod(path, mode, callback)` 方法更改`path`处文件的`mode`（权限）。您正在设置该文件的读取（4）、写入（2）和执行（1）位，可以以八进制数字形式发送：'
- en: '|  | [r]ead | [w]rite | E[x]ecute | Total |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  | [r]读取 | [w]写入 | E[x]执行 | 总计 |'
- en: '| Owner | **4** | **2** | **1** | **7** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 所有者 | **4** | **2** | **1** | **7** |'
- en: '| Group | **4** | **0** | **1** | **5** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 组 | **4** | **0** | **1** | **5** |'
- en: '| Other | **4** | **0** | **1** | **5** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 其他 | **4** | **0** | **1** | **5** |'
- en: '|  |  |  |  | **chmod(755)** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  | **chmod(755)** |'
- en: 'You may also use symbolic representations, such as `g+rw` for group read and
    write, similar to the arguments we saw for `file.open` earlier. For more information
    on setting file modes, consult: [http://en.wikipedia.org/wiki/Chmod](http://en.wikipedia.org/wiki/Chmod).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用符号表示，例如`g+rw`表示组读写，类似于我们之前在`file.open`中看到的参数。有关设置文件模式的更多信息，请参阅：[http://en.wikipedia.org/wiki/Chmod](http://en.wikipedia.org/wiki/Chmod)。
- en: The callback receives one argument, any exception thrown in the call.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接收一个参数，在调用中抛出的任何异常。
- en: fs.fchmod(fd, mode, callback) ----
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.fchmod(fd, mode, callback) ----
- en: The `fs.fchmod(fd, mode, callback)` method is like `fs.chmod`, except that instead
    of specifying a file path, a file descriptor is passed as `fd`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.fchmod(fd, mode, callback)`方法类似于`fs.chmod`，不同之处在于不是指定文件路径，而是将文件描述符作为`fd`传递。'
- en: fs.lchmod(path, mode, callback)
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.lchmod(path, mode, callback)
- en: The `fs.lchmod(path, mode, callback)` method is like `fs.chmod`, except that
    in the case of symbolic links, permissions on the link file itself is changed,
    but not those of the referenced link.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.lchmod(path, mode, callback)`方法类似于`fs.chmod`，不同之处在于对于符号链接，只会更改链接文件本身的权限，而不会更改引用链接的权限。'
- en: fs.link(srcPath, dstPath, callback)
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.link(srcPath, dstPath, callback)
- en: 'The `fs.link(srcPath, dstPath, callback)` creates a hard link between `srcPath`
    and `dstPath`. This is a way of creating many different paths to exactly the same
    file. For example, the following directory contains a `target.txt` file and two
    hard links—`a.txt` and `b.txt`—which each point to this file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.link(srcPath, dstPath, callback)`在`srcPath`和`dstPath`之间创建一个硬链接。这是创建指向完全相同文件的许多不同路径的一种方法。例如，以下目录包含一个`target.txt`文件和两个硬链接—`a.txt`和`b.txt`—它们各自指向这个文件：'
- en: '![](img/071fe6c3-13e6-4da9-8a4c-5df632547f06.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/071fe6c3-13e6-4da9-8a4c-5df632547f06.png)'
- en: 'Note that `target.txt` is empty. If the content of the target file is changed,
    the length of the link files will also be changed. Consider changing the content
    of the target file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`target.txt`是空的。如果更改目标文件的内容，链接文件的长度也将更改。考虑更改目标文件的内容：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This results in this new directory structure, clearly demonstrating the hard
    references:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了这种新的目录结构，清楚地展示了硬引用：
- en: '![](img/a761ddfa-c59c-4fa5-8c97-f744588b811a.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a761ddfa-c59c-4fa5-8c97-f744588b811a.png)'
- en: The callback receives one argument, any exception thrown in the call.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接收一个参数，在调用中抛出的任何异常。
- en: fs.symlink(srcPath, dstPath, [type], callback)
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.symlink(srcPath, dstPath, [type], callback)
- en: The `fs.symlink(srcPath, dstPath, [type], callback)` method creates a symbolic
    link between `srcPath` and `dstPath`. Unlike hard links created with `fs.link`,
    symbolic links are simply pointers to other files, and do not themselves respond
    to changes in the target file. The default link `type`is file. Other options are
    directory and junction, the last being a Windows-specific type that is ignored
    on other systems. The callback receives one argument, any exception thrown in
    the call.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.symlink(srcPath, dstPath, [type], callback)`方法在`srcPath`和`dstPath`之间创建一个符号链接。与使用`fs.link`创建的硬链接不同，符号链接只是指向其他文件的指针，并且本身不会对目标文件的更改做出响应。默认的链接`type`是文件。其他选项是目录和junction，最后一个是Windows特定类型，在其他系统上被忽略。回调函数接收一个参数，在调用中抛出的任何异常。'
- en: 'Compare and contrast the directory changes described in our `fs.link` discussion
    to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们在`fs.link`讨论中描述的目录更改与以下内容进行比较：
- en: '![](img/e0bc810e-ef05-4e42-af3f-9c69b5d91603.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0bc810e-ef05-4e42-af3f-9c69b5d91603.png)'
- en: 'Unlike hard links, symbolic links do not change in length when their target
    file (in this case `target.txt`) changes length. Here, we see how changing the
    target''s length from zero bytes to six bytes has no effect on the length of any
    bound symbolic links:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬链接不同，当它们的目标文件（在本例中为`target.txt`）更改长度时，符号链接的长度不会改变。在这里，我们看到将目标长度从零字节更改为六字节对任何绑定的符号链接的长度没有影响：
- en: '![](img/117fd84c-d6db-404a-b48f-87c81a872b97.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/117fd84c-d6db-404a-b48f-87c81a872b97.png)'
- en: fs.readlink(path, callback)
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.readlink(path, callback)
- en: 'The given symbolic link at `path` returns the filename of the targeted file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`path`处的符号链接返回目标文件的文件名：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: fs.realpath(path, [cache], callback)
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.realpath(path, [cache], callback)
- en: 'The `fs.realpath(path, [cache], callback)` method attempts to find the real
    path to file at `path`. This is a useful way to find the absolute path to a file,
    resolve symbolic links, and even clean up extraneous slashes and other malformed
    paths. Consider this example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.realpath(path, [cache], callback)`方法尝试找到`path`处文件的真实路径。这是查找文件的绝对路径，解析符号链接，甚至清理多余的斜杠和其他格式不正确的路径的有用方法。考虑这个例子：'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, consider this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，考虑这个：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If some of the path segments to be resolved are already known, one can pass
    a `cache` of mapped paths:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要解析的一些路径段已知，可以传递一个映射路径的`cache`：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: fs.unlink(path, callback)
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.unlink(path, callback)
- en: The `fs.unlink(path, callback)` method removes the file at `path`—equivalent
    to deleting a file. The callback receives one argument, any exception thrown in
    the call.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.unlink(path, callback)`方法删除`path`处的文件，相当于删除文件。回调函数接收一个参数，在调用中抛出的任何异常。'
- en: fs.rmdir(path, callback)
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.rmdir(path, callback)
- en: The `fs.rmdir(path, callback)` method removes the directory at `path`, equivalent
    to deleting a directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.rmdir(path, callback)`方法删除`path`处的目录，相当于删除目录。'
- en: Note that if the directory is not empty, this will throw an exception. The callback
    receives one argument, any exception thrown in the call.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果目录不为空，这将抛出异常。回调函数接收一个参数，在调用中抛出的任何异常。
- en: fs.mkdir(path, [mode], callback)
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.mkdir(path, [mode], callback)
- en: The `fs.mkdir(path, [mode], callback)` method creates a directory at `path`.
    To set the mode of the new directory, use the permission bit map described in
    `fs.chmod`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.mkdir(path, [mode], callback)`方法在`path`处创建一个目录。要设置新目录的模式，请使用`fs.chmod`中描述的权限位图。'
- en: Note that if this directory already exists, an exception will be thrown. The
    callback receives one argument, any exception thrown in the call.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果此目录已经存在，将抛出异常。回调函数接收一个参数，在调用中抛出的任何异常。
- en: fs.exists(path, callback)
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.exists(path, callback)
- en: The `fs.exists(path, callback)` method checks whether a file exists at `path`.
    The callback will receive a Boolean true or false.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.exists(path, callback)`方法检查`path`处是否存在文件。回调将接收一个布尔值true或false。'
- en: fs.fsync(fd, callback)
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.fsync(fd, callback)
- en: Between the instant a request for some data to be written to a file is made
    and that data fully exists on a storage device, the candidate data exists within
    core system buffers. This latency isn't normally relevant but, in some extreme
    cases, such as system crashes, it is necessary to insist that the file reflects
    a known state on a stable storage device.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出写入文件的某些数据的请求和该数据完全存在于存储设备上之间的瞬间，候选数据存在于核心系统缓冲区中。这种延迟通常不相关，但在一些极端情况下，例如系统崩溃，有必要坚持文件反映稳定存储设备上已知状态。
- en: '`fs.fsync` copies all in-core data of a file referenced by file descriptor
    `fd` to disk'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.fsync`将由文件描述符`fd`引用的文件的所有核心数据复制到磁盘'
- en: (or other storage device). The callback receives one argument, any exception
    thrown in the call.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: （或其他存储设备）。回调函数接收一个参数，即调用中抛出的任何异常。
- en: Synchronicity
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步性
- en: Conveniently, Node's `file` module provides synchronous counterparts for each
    of the asynchronous methods we've covered, indicated by the `Sync` suffix. For
    example, the synchronous version of `fs.mkdir` is `fs.mkdirSync`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，Node的`file`模块为我们介绍的每个异步方法提供了同步对应方法，以`Sync`为后缀表示。例如，`fs.mkdir`的同步版本是`fs.mkdirSync`。
- en: 'A synchronous call is also able to directly return its result, obviating the
    need for callbacks. While demonstrating the creation of HTTPS servers in [Chapter
    3](c7665bc9-3f44-4d7c-8318-61f9dfe962b3.xhtml), *Streaming Data Across Nodes and
    Clients*, we saw both a good use case for synchronous code and an example of direct
    assignment of results without a callback:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同步调用还能够直接返回其结果，无需回调。在[第3章](c7665bc9-3f44-4d7c-8318-61f9dfe962b3.xhtml)中演示了在HTTPS服务器中创建流数据跨节点和客户端的过程中，我们既看到了同步代码的一个很好的用例，也看到了直接分配结果而无需回调的示例：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Hey! Doesn't Node strictly enforce asynchronous programming? Isn't blocking
    code always wrong? All developers are encouraged to adhere to non-blocking designs,
    and you are encouraged to avoid synchronous coding—if facing a problem where a
    synchronous operation seems the only solution, it is likely that the problem has
    been misunderstood. Nevertheless, edge cases requiring a file object existing
    fully in memory prior to executing further instructions (a blocking operation)
    do exist. Node give a developer the power to break with asynchronous tradition
    if it is the only possible solution (which it probably isn't!).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！Node不是严格执行异步编程吗？阻塞代码不总是错误的吗？鼓励所有开发人员遵循非阻塞设计，并鼓励避免同步编码——如果面临一个同步操作似乎是唯一的解决方案的问题，那么很可能是问题被误解了。然而，确实存在一些需要在执行进一步指令之前完全存在于内存中的文件对象的边缘情况（阻塞操作）。如果这是唯一可能的解决方案（这可能并不是！），Node给开发人员提供了打破异步传统的权力。
- en: 'One synchronous operation developers regularly use (perhaps without realizing
    it) is the `require` directive:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员经常使用的一个同步操作（也许是在不知不觉中）是`require`指令：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Until the dependency targeted by require is fully initialized, subsequent JavaScript
    instructions will not execute (file loading blocks the event loop). *Ryan Dahl*
    struggled with this decision to introduce synchronous operations (file operations
    in particular) into Node, as he mentioned at a Google Tech Talk on July 2013:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`require`所指向的依赖项完全初始化之前，后续的JavaScript指令将不会执行（文件加载会阻塞事件循环）。*Ryan Dahl*在2013年7月的Google
    Tech Talk上提到，他在引入同步操作（特别是文件操作）到Node中遇到了困难：
- en: According to [http://www.youtube.com/watch?v=F6k8lTrAE2g](http://www.youtube.com/watch?v=F6k8lTrAE2g),
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[http://www.youtube.com/watch?v=F6k8lTrAE2g](http://www.youtube.com/watch?v=F6k8lTrAE2g)，
- en: '"I think this is an OK compromise. It pained me for months, to drop the purity
    of having an asynchronous module system. But, I think it''s ok.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: “我认为这是一个可以接受的妥协。几个月来，放弃异步模块系统的纯度让我感到痛苦。但是，我认为这样做是可以的。
- en: '...'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ……
- en: 'It simplifies the code a lot to be able to just stick in "require, require,
    require" and not have to do an onload callback...I think that''s been a relatively
    OK compromise. [...] There''s really two parts to your program: there''s the loading
    and starting up phase...and you don''t really care how fast that runs...you''re
    going to load modules and stuff...the setup phase of your daemon, generally, is
    synchronous. It''s when you get into your event loop for serving requests that
    you want to be very careful about this. [...] I will give people synchronous file
    I/O. If they do it in servers...it won''t be terrible, right? The important thing
    is to never let them do synchronous network I/O."'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 能够只需插入“require, require, require”而无需执行onload回调，这样简化了代码很多……我认为这是一个相对可以接受的妥协。[...]你的程序实际上有两个部分：加载和启动阶段……你并不真的关心它运行得有多快……你将加载模块和其他东西……你的守护进程的设置阶段通常是同步的。当你进入用于处理请求的事件循环时，你需要非常小心。[...]我会给人们同步文件I/O。如果他们在服务器上这样做……那不会太糟糕，对吧？重要的是永远不要让他们进行同步网络I/O。”
- en: Synchronous code does have the advantage of being eminently predictable, as
    nothing else happens until this instruction is completed. When starting up a server,
    which will happen only rarely, Dahl is suggesting that a little certainty and
    simplicity goes a long way. The loading of configuration files, for example, might
    make sense on server initialization.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同步代码的优势在于极其可预测，因为在完成此指令之前不会发生其他任何事情。当启动服务器时，这种情况很少发生，Dahl建议一点确定性和简单性可以走得更远。例如，服务器初始化时加载配置文件可能是有意义的。
- en: Sometimes a desire to use synchronous commands in Node development is simply
    a cry for help; a developer being overwhelmed by deeply nested callback structures.
    If ever faced with this pain, try some of the callback-taming libraries mentioned
    in [Chapter 2](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml), *Understanding Asynchronous
    Event-Driven Programming*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在Node开发中使用同步命令的愿望只是在请求帮助；开发人员被深度嵌套的回调结构所压倒。如果曾经面对这种痛苦，请尝试一些在[第2章](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml)中提到的回调控制库，*理解异步事件驱动编程*。
- en: Moving through directories
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览目录
- en: Let's apply what we have learned and create a directory iterator. The goal for
    this project is to create a function that will accept a directory path and return
    a JSON object reflecting the directory hierarchy of files, its nodes composed
    of file objects. We will also make our directory walker a more powerful event-based
    parser, consistent with the Node philosophy.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用我们所学到的知识，创建一个目录迭代器。这个项目的目标是创建一个函数，该函数将接受一个目录路径，并返回一个反映文件目录层次结构的JSON对象，其节点由文件对象组成。我们还将使我们的目录遍历器成为一个更强大的基于事件的解析器，与Node哲学一致。
- en: 'To move through nested directories, one must first be able to read a single
    directory. Node''s filesystem library provides the `fs.readdir` command for this
    purpose:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动到嵌套目录中，必须首先能够读取单个目录。Node的文件系统库提供了`fs.readdir`命令来实现这一目的：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Remembering that everything is a file, we will need to do more than simply
    getting a directory listing; we must determine the type of each member of our
    file list. By adding `fs.stat`, we have already completed a large majority of
    the logic:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 记住一切都是文件，我们需要做的不仅仅是获取目录列表；我们必须确定文件列表中每个成员的类型。通过添加`fs.stat`，我们已经完成了大部分逻辑：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This self-executing function receives a directory path argument `(".")`, folds
    that directory listing into an array of file names, fetches an `fs.Stats` object
    for each of these, and makes a decision based on the indicated file type (directory
    or not a directory) on what to do next. At this point, we also have the name of
    the current file and its attributes available to us. Clearly, we have already
    mapped a single directory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自执行函数接收一个目录路径参数`(".")`，将该目录列表折叠成一个文件名数组，为其中的每个文件获取一个`fs.Stats`对象，并根据指示的文件类型（目录或非目录）做出决定下一步该做什么。在这一点上，我们也已经映射了一个单个目录。
- en: 'We must now map directories within directories, storing results in a JSON object
    reflecting the nested filesystem tree, with each leaf on the tree a file object.
    Recursively passing our directory reader function paths to subdirectories and
    appending returned results as branches of the final object is the next step:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须映射目录中的目录，将结果存储在反映嵌套文件系统树的JSON对象中，树上的每个叶子都是一个文件对象。递归地将我们的目录读取器函数路径传递给子目录，并将返回的结果附加为最终对象的分支是下一步：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create a `walk` method that receives a directory path and a callback that
    receives the directory graph or an error when `walk` is complete, following Node's
    style. Not much code is needed to create a very fast, non-blocking file tree walker,
    complete with file stats.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`walk`方法，该方法接收一个目录路径和一个回调函数，该回调函数在`walk`完成时接收目录图或错误，遵循Node的风格。创建一个非常快速的、非阻塞的文件树遍历器，包括文件统计信息，不需要太多的代码。
- en: 'Now, let''s publish events whenever a directory or file is encountered, giving
    any future implementation flexibility to construct its own representation of the
    filesystem. To do this, we will use the friendly `EventEmitter` object:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在遇到目录或文件时发布事件，使任何未来的实现都能够灵活地构建自己的文件系统表示。为此，我们将使用友好的`EventEmitter`对象：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we know how to discover and address files, we can start reading from
    and writing to them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何发现和处理文件，我们可以开始从中读取和写入。
- en: Reading from a file
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: In our discussion of file descriptors, we touched on one method of opening a
    file, fetching a file descriptor, and ultimately pushing or pulling data through
    that reference. Reading files is a common operation. Sometimes, managing a read
    buffer precisely may be necessary, and Node allows byte-by-byte control. In other
    cases, one simply wants a no-frills stream that is simple to use.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论文件描述符时，我们提到了一种打开文件、获取文件描述符并最终通过该引用推送或拉取数据的方法。读取文件是一个常见的操作。有时，精确管理读取缓冲区可能是必要的，Node允许逐字节控制。在其他情况下，人们只是想要一个简单易用的无花俏流。
- en: Reading byte by byte
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐字节读取
- en: The `fs.read` method is the most low-level way Node offers for reading files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.read`方法是Node提供的读取文件的最低级别的方法。'
- en: fs.read(fd, buffer, offset, length, position, callback)
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.read(fd, buffer, offset, length, position, callback)
- en: Files are composed of ordered bytes, and these bytes are addressable by their
    `position`, relative to the beginning of in the file (position zero [0]). Once
    we have
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 文件由有序字节组成，这些字节可以通过它们相对于文件开头的`position`进行寻址（位置零[0]）。一旦我们有
- en: a file descriptor `fd`, we can begin to read `length` number of bytes and insert
    those into a `Buffer` object `buffer`, insertion beginning at a given buffer `offset`.
    For example, to copy the 8,366 bytes beginning at `position` 309 of the readable
    file `fd` into
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符`fd`，我们可以开始读取`length`字节数，并将其插入到`Buffer`对象`buffer`中，插入从给定的缓冲区`offset`开始。例如，要将从可读文件`fd`的位置309开始的8,366字节复制到
- en: a `buffer` beginning at an `offset` of 100, we will use `fs.read(fd, buffer,
    100, 8366, 309, callback)`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从`offset`为100开始的`buffer`，我们将使用`fs.read(fd, buffer, 100, 8366, 309, callback)`。
- en: 'The following code demonstrates how to open and read a file in 512 byte chunks:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何以512字节块打开和读取文件：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The resulting buffer can be piped elsewhere (including a server response object).
    It can also be manipulated using the methods of Node's `Buffer` object, such as
    conversion into a UTF8 string with `buffer.toString("utf8")`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的缓冲区可以被传送到其他地方（包括服务器响应对象）。也可以使用Node的`Buffer`对象的方法进行操作，例如使用`buffer.toString("utf8")`将其转换为UTF8字符串。
- en: Fetching an entire file at once
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次获取整个文件
- en: Often, one simply needs to fetch an entire file, without any ceremony or fine
    control. Node provides a shortcut method for exactly this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们只需要获取整个文件，而不需要任何仪式或精细控制。Node提供了一个快捷方法来实现这一点。
- en: fs.readFile(path, [options], callback)
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.readFile(path, [options], callback)
- en: 'Fetching the data contained by the `path` file can be accomplished in one step:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`path`文件中包含的数据可以在一步中完成：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We see how `callback` receives a buffer. It may be more desirable to receive
    the file data in a common encoding, such as UTF8\. We are able to specify the
    encoding of the returned data as well as the read mode using the `options` object,
    which has two possible attributes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`callback`接收一个缓冲区。可能更希望以常见编码（如UTF8）接收文件数据。我们可以使用`options`对象指定返回数据的编码以及读取模式，该对象有两个可能的属性：
- en: '**encoding**: A string, such as `utf8`, it defaults to null (no encoding)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**encoding**：一个字符串，如`utf8`，默认为null（无编码）'
- en: '**flag**: The file mode as a string, it defaults to `r`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flag**：文件模式作为字符串，默认为`r`'
- en: 'Modifying the previous example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 修改上一个例子：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating a readable stream
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可读流
- en: While `fs.readFile` is an excellent, simple way to accomplish a common task,
    it does have the significant drawback of requiring that an entire file be read
    into memory prior to any part of the file being sent to a callback. For large
    files or files of unknown size, this isn't a good solution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`fs.readFile`是一种完成常见任务的简单方法，但它有一个重大缺点，即在将文件的任何部分发送到回调之前，需要将整个文件读入内存。对于大文件或未知大小的文件，这不是一个好的解决方案。
- en: In the last chapter, we learned about data streams and the `Stream` object.
    While files are easily and naturally handled using readable streams, Node provides
    a dedicated file streaming interface that offers a compact file streaming facility
    without the extra construction work, with more flexibility than that offered by
    `fs.readFile`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了数据流和`Stream`对象。虽然文件可以很容易和自然地使用可读流处理，但Node提供了一个专用的文件流接口，提供了一种紧凑的文件流功能，无需额外的构造工作，比`fs.readFile`提供的更灵活。
- en: fs.createReadStream(path, [options])
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.createReadStream(path, [options])
- en: The `fs.createReadStream(path, [options])` method returns a readable stream
    object for file at `path`. You may then perform stream operations on the returned
    object, such as `pipe()`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.createReadStream(path, [options])`方法返回`path`文件的可读流对象。然后，您可以对返回的对象执行流操作，例如`pipe()`。'
- en: 'The following options are available:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下选项可用：
- en: '`flags`: File mode argument as a string. Defaults to `r`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：文件模式参数作为字符串。默认为`r`。'
- en: '`encoding`: One of `utf8`, `ascii`, or `base64`. Defaults to no encoding.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding`：`utf8`、`ascii`或`base64`之一。默认为无编码。'
- en: '`fd`: One may set `path` to null, instead passing the call a file descriptor.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fd`：可以将`path`设置为null，而不是传递文件描述符。'
- en: '`mode`: Octal representation of file mode, defaulting to 0666.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：文件模式的八进制表示，默认为0666。'
- en: '`bufferSize`: The chunk size, in bytes, of the internal read stream. Defaults
    to 64 * 1024 bytes. You can set this to any number, but memory allocation is strictly
    controlled by the host OS, which may ignore a request. Refer to: [https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY](https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY).'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bufferSize`：内部读取流的块大小，以字节为单位。默认为64 * 1024字节。您可以将其设置为任何数字，但内存分配严格受主机操作系统控制，可能会忽略请求。参考：[https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY](https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY)。'
- en: '`autoClose`: Whether to automatically close the file descriptor (a la `fs.close`).
    Defaults to true. You may want to set this to false and close manually if you
    are sharing a file descriptor across many streams, as closing a descriptor will
    disrupt any other readers.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoClose`：是否自动关闭文件描述符（类似于`fs.close`）。默认为true。如果您正在跨多个流共享文件描述符，则可能希望将其设置为false并手动关闭，因为关闭描述符将中断任何其他读取器。'
- en: '`start`: Begin reading from this position. Default is 0.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：从这个位置开始阅读。默认为0。'
- en: '`end`: Stop reading at this position. Default is the file byte length.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：在这个位置停止阅读。默认为文件字节长度。'
- en: Reading a file line by line
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐行读取文件
- en: While reading a file stream byte-by-byte is sufficient for any file-parsing
    job, text files in particular are often more usefully read line by line, such
    as when reading logfiles. More precisely, any stream can be understood in terms
    of the chunks of data separated by newline characters, typically `rn` on UNIX
    systems. Node provides a native module whose methods simplify access to newline-separated
    chunks in data streams.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 逐字节读取文件流对于任何文件解析工作都足够了，但特别是文本文件通常更适合逐行读取，例如读取日志文件时。更准确地说，可以将任何流理解为由换行字符分隔的数据块，通常在UNIX系统上是`rn`。Node提供了一个本地模块，其方法简化了对数据流中的换行分隔块的访问。
- en: The Readline module
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Readline模块
- en: The `Readline` module has a simple but powerful goal, that is, to make reading
    a stream of data line-by-line easier. The bulk of its interface is designed to
    make command-line prompting easier, such that interfaces taking user input are
    easier to design.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Readline`模块有一个简单但强大的目标，即使得逐行读取数据流更容易。其接口的大部分设计是为了使命令行提示更容易，以便更容易设计接受用户输入的接口。'
- en: Remembering that Node is designed for I/O, that I/O operations normally involve
    moving data between readable and writable streams, and that `stdout` and `stdin`
    are stream interfaces identical to the file streams returned by `fs.createReadStream`
    and `fs.createWriteStream`, we will look at how this module can be similarly used
    to prompt file streams for a line of text.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 记住Node是为I/O设计的，I/O操作通常涉及在可读和可写流之间移动数据，并且`stdout`和`stdin`是与`fs.createReadStream`和`fs.createWriteStream`返回的文件流相同的流接口，我们将看看如何使用这个模块类似地提示文件流以获取一行文本。
- en: 'To start working with the `Readline` module, one must create an interface defining
    the input stream and the output stream. The default interface options prioritize
    usage as a terminal interface. The options we are interested in are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`Readline`模块，必须创建一个定义输入流和输出流的接口。默认接口选项优先使用作为终端接口。我们感兴趣的选项如下：
- en: '`input`: Required. The readable stream being listened to.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input`：必需。正在监听的可读流。'
- en: '`output`: Required. The writable stream being written to.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output`：必需。正在写入的可写流。'
- en: '`terminal`: Set this to true if both the input and output streams should be
    treated like a Unix terminal, or **Teletypewriter** (**TTY**). For files, you
    will set this to false.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terminal`：如果输入和输出流都应该像Unix终端或**电传打字机**（**TTY**）一样对待，则设置为true。对于文件，您将其设置为false。'
- en: 'Reading the lines of a file is made easy through this system. For example,
    assuming that one has a dictionary file listing common words in the English language,
    one might want to read the list into an array for processing:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个系统，读取文件的行变得非常简单。例如，假设有一个列出英语常用单词的字典文件，一个人可能希望将列表读入数组进行处理：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note how we disable TTY behavior, handling the lines ourselves without redirecting
    to an output stream.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们禁用了TTY行为，自己处理行而不是重定向到输出流。
- en: 'As expected with a Node I/O module, we are working with stream events. The
    events listeners that may be of interest are as listed:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，与Node I/O模块一样，我们正在处理流事件。可能感兴趣的事件监听器如下所列：
- en: '`line`: Receives the most recently read line, as a string'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line`：接收最近读取的行，作为字符串'
- en: '`pause`: Called whenever the stream is paused'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause`：每当流被暂停时调用'
- en: '`resume`: Called whenever a stream is resumed'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resume`：每当流恢复时调用'
- en: '`close`: Called whenever a stream is closed'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close`：每当流关闭时调用'
- en: Except for `line`, these event names reflect the `Readline` methods, pause a
    stream with `Readline.pause`, `resume` with `Readline.resume`, and `close` with
    `Readline.close`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`line`之外，这些事件名称反映了`Readline`方法，使用`Readline.pause`暂停流，使用`Readline.resume`恢复流，使用`Readline.close`关闭流。
- en: Writing to a file
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件
- en: As with reading files, Node provides a rich collection of tools for writing
    to files. We'll see how Node makes it as easy to target a file's contents byte-by-byte,
    as it is to pipe continuous streams of data into a single writable file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与读取文件一样，Node提供了丰富的工具集来写入文件。我们将看到Node如何使得将文件内容按字节进行定位变得如此简单，就像将连续的数据流导入单个可写文件一样。
- en: Writing byte by byte
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐字节写入
- en: The `fs.write` method is the most low-level way Node offers for writing files.
    This method gives us precise control over where bytes will be written to in a
    file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.write`方法是Node提供的写入文件的最低级别方法。该方法使我们可以精确控制字节将被写入文件的位置。'
- en: fs.write(fd, buffer, offset, length, position, callback)
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.write(fd, buffer, offset, length, position, callback)
- en: 'To write the collection of bytes between positions 309 and 8,675 **(**length
    8,366) of `buffer` to the file referenced by file descriptor `fd`, insertion beginning
    at position 100:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`buffer`中位置309和8,675之间的字节集合（长度为8,366）插入到由文件描述符`fd`引用的文件中，从位置100开始：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that for files opened in the append (`a`) mode, some operating systems
    may ignore `position` values, always adding data to the end of the file. Additionally,
    it is unsafe to call `fs.write` multiple times on the same file without waiting
    for the callback. Use `fs.createWriteStream` in those cases.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于以追加（`a`）模式打开的文件，一些操作系统可能会忽略`position`值，始终将数据添加到文件的末尾。此外，在不等待回调的情况下多次调用`fs.write`对同一文件是不安全的。在这种情况下，请使用`fs.createWriteStream`。
- en: With such precise control, we can intelligently structure files. In the following
    (somewhat contrived) example, we create a file-based database containing indexed
    information for 6 months of baseball scores for a single team. We want to be able
    to quickly look up whether this team won or lost (or did not play) on a given
    day.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样精确的控制，我们可以智能地构造文件。在下面（有点牵强的）例子中，我们创建了一个基于文件的数据库，其中包含了一个单一团队6个月的棒球比分的索引信息。我们希望能够快速查找这个团队在某一天是赢了还是输了（或者没有比赛）。
- en: 'Since a month can have at most 31 days, we can (randomly) create a 6 x 31 grid
    of data in this file, placing one of three values in each grid cell: L (loss),
    W (win), N (no game). For fun, we also create a simple **CLI** (**Command-Line
    Interface**) to our database with a basic query language. This example should
    make it clear how `fs.read`, `fs.write`, and `Buffer` objects are used to precisely
    manipulate bytes in files:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个月最多有31天，我们可以（随机地）在这个文件中创建一个6 x 31的数据网格，将三个值中的一个放在每个网格单元中：L（输）、W（赢）、N（未比赛）。为了好玩，我们还为我们的数据库创建了一个简单的**CLI**（**命令行界面**）和一个基本的查询语言。这个例子应该清楚地说明了`fs.read`、`fs.write`和`Buffer`对象是如何精确地操作文件中的字节的：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once running, we can simply type in a month/day pair and rapidly access that
    data cell. Adding in bounds checking for the input values would be a simple improvement.
    Pushing the file stream through a visualizing UI might be a nice exercise.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，我们只需输入一个月/日对，就可以快速访问该数据单元。为输入值添加边界检查将是一个简单的改进。将文件流通过可视化UI可能是一个不错的练习。
- en: Writing large chunks of data
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入大块数据
- en: For straightforward write operations `fs.write` may be overkill. Sometimes,
    all that is needed is a way to create a new file with some content. Just as common
    is the need to append data to the end of a file, as one might do in a logging
    system. The `fs.writeFile` and `fs.appendFile` methods can help us with those
    scenarios.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的写操作，`fs.write`可能过于复杂。有时，所需的只是一种创建具有一些内容的新文件的方法。同样常见的是需要将数据追加到文件的末尾，就像在日志系统中所做的那样。`fs.writeFile`和`fs.appendFile`方法可以帮助我们处理这些情况。
- en: fs.writeFile(path, data, [options], callback)
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.writeFile(path, data, [options], callback)
- en: The `fs.writeFile(path, data, [options], callback)` method writes the contents
    of `data` to the file at `path`. The data argument can be either a buffer or
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.writeFile(path, data, [options], callback)`方法将`data`的内容写入到`path`处的文件中。data参数可以是一个缓冲区或字符串。 '
- en: 'a string. The following options are available:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串。以下选项可用：
- en: '`encoding`: Defaults to `utf8`. If data is a buffer, this option is ignored.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`编码`：默认为`utf8`。如果数据是一个缓冲区，则忽略此选项。'
- en: '`mode`: Octal representation of file mode, defaulting to 0666.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：文件模式的八进制表示，默认为0666。'
- en: '`flag`: Write flags, defaulting to `w`.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flag`：写入标志，默认为`w`。'
- en: 'Usage is straightforward:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法很简单：
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: fs.appendFile(path, data, [options], callback)
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.appendFile(path, data, [options], callback)
- en: Similar to `fs.writeFile`, except that `data` is appended to the end of the
    file at `path`. Also, the `flag` option defaults to `a`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`fs.writeFile`，不同之处在于`data`被追加到`path`文件的末尾。此外，`flag`选项默认为`a`。
- en: Creating a writable stream
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可写流
- en: If the data being written to a file arrives in chunks (such as occurs with a
    file upload), streaming that data through a `WritableStream` object interface
    provides more flexibility and efficiency.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要写入文件的数据以块的形式到达（例如文件上传时发生的情况），通过`WritableStream`对象接口将数据流式传输提供了更灵活和高效的方式。
- en: fs.createWriteStream(path, [options])
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.createWriteStream(path, [options])
- en: The `fs.createWriteStream(path, [options])` method returns a writable stream
    object for file at `path`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.createWriteStream(path, [options])`方法返回`path`文件的可写流对象。'
- en: 'The following options are available:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下选项可用：
- en: '`flags`: File mode argument as a string. Defaults to `w`.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：文件模式参数作为字符串。默认为`w`。'
- en: '`encoding`: One of `utf8`, `ascii`, or `base64`. Defaults to no encoding.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding`：`utf8`、`ascii`或`base64`中的一个。默认为无编码。'
- en: '`mode`: Octal representation of file mode, defaulting to 0666.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：文件模式的八进制表示，默认为0666。'
- en: '`start`: An offset indicating the position in the file where writing should
    begin.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：表示写入应该开始的文件中的位置的偏移量。'
- en: 'For example, this little program functions as the world''s simplest word processor,
    writing all terminal input to a file, until the terminal is closed:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个小程序作为世界上最简单的文字处理器，将所有终端输入写入文件，直到终端关闭：
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Caveats
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意事项
- en: The side effects of opening a file descriptor and reading from it are minimal,
    such that in normal development, very little thought is given to what is actually
    happening within the system. Normally, reading a file doesn't change it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件描述符并从中读取的副作用很小，因此在正常开发中，很少会考虑实际发生了什么。通常情况下，读取文件不会改变它。
- en: 'When writing to a file, a number of concerns must be addressed, such as these:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入文件时，必须解决许多问题，例如：
- en: Is there sufficient writable storage space available?
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有足够的可写存储空间？
- en: Is another process simultaneously accessing this file, or even erasing it?
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有另一个进程同时访问该文件，甚至擦除它？
- en: What must be done if a write operation fails or is unnaturally terminated mid-stream?
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果写入操作失败或在流中途被非自然地终止，必须采取什么措施？
- en: We've seen the exclusive write mode flag (`wx`) that can help in the case of
    multiple write processes simultaneously trying to create a file. Full solutions
    to all the concerns one might face when writing to files are difficult to derive
    in general, or state briefly. Node encourages asynchronous programming. Nevertheless,
    with regard to the filesystem in particular, sometimes synchronous, deterministic
    programming is necessary. You are encouraged to keep these and other issues in
    mind, and to keep I/O non-blocking whenever possible.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了独占写模式标志（`wx`），它可以在多个写入进程同时尝试创建文件的情况下提供帮助。一般来说，对文件进行写入时可能会面临的所有问题的完整解决方案都很难得出，或者简要陈述。Node鼓励异步编程。然而，特别是在文件系统方面，有时需要同步、确定性的编程。鼓励您牢记这些和其他问题，并尽可能保持I/O非阻塞。
- en: Serving static files
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: 'Anyone using Node to create a web server will need to respond intelligently
    to HTTP requests. An HTTP request to a web server for a resource expects some
    sort of response. A basic file static file server might look like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用Node创建Web服务器的人都需要对HTTP请求做出智能响应。对于Web服务器的资源的HTTP请求期望得到某种响应。一个基本的静态文件服务器可能看起来像这样：
- en: '[PRE37]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This server services GET requests on port `8000`, expecting to find a local
    file at a relative path equivalent to the URL path segment. We see how easy Node
    makes it for us to stream local file data, simply piping a `ReadableStream` into
    a `WritableStream` representing a client socket connection. This is an enormous
    amount of functionality to be safely implemented in a handful of lines.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务器在端口`8000`上服务GET请求，期望在相对路径等于URL路径段的本地文件中找到。我们看到Node是如何简单地让我们流式传输本地文件数据的，只需将`ReadableStream`传输到代表客户端套接字连接的`WritableStream`中。这是在几行代码中安全实现大量功能。
- en: Eventually, a great deal more will be added, such as handling routines for standard
    HTTP methods, handling errors and malformed requests, setting proper headers,
    managing favicon requests, and so forth.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，将会添加更多内容，例如处理标准HTTP方法的例程，处理错误和格式不正确的请求，设置适当的标头，管理网站图标请求等等。
- en: Let's build a reasonably useful file server with Node, one that will respond
    to HTTP requests by streaming back a resource and which will respect caching requests.
    In the process, we will touch on how to manage content redirection. Later on in
    this chapter, we will also look at implementing file uploads. Note that a web
    server fully compliant with all features of HTTP is a complicated beast, so what
    we are creating should be considered a good start, not an end.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Node构建一个相当有用的文件服务器，它将通过流式传输资源来响应HTTP请求，并且将遵守缓存请求。在这个过程中，我们将涉及如何管理内容重定向。在本章的后面，我们还将看到如何实现文件上传。请注意，一个完全符合HTTP所有特性的Web服务器是一个复杂的东西，因此我们正在创建的应该被视为一个良好的开始，而不是终点。
- en: Redirecting requests
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向请求
- en: Sometimes, a client will try to `GET` a URL that is incorrect or incomplete
    in some way, the resource may have been moved, or there are better ways to make
    the same request. Other times, a `POST` may create a new resource at a new location
    the client cannot know, necessitating some response header information pointing
    to the newly created URI. Let's look at two common redirection scenarios someone
    implementing a static file server with Node might face.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，客户端会尝试`GET`一个URL，但该URL不正确或不完整，资源可能已经移动，或者有更好的方法来发出相同的请求。其他时候，`POST`可能会在客户端无法知道的新位置创建一个新资源，需要一些响应头信息指向新创建的URI。让我们看看使用Node实现静态文件服务器时可能会遇到的两种常见重定向场景。
- en: 'Two response headers are fundamental to redirection:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向基本上需要两个响应头：
- en: '`Location`: This indicates a redirection to a location where said content body
    can be found'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Location`：这表示重定向到可以找到内容主体的位置'
- en: '`Content-Location`: This is meant to indicate the URL where the requester will
    find the original location of the entity enclosed in the response body'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Location`：这意味着指示请求者将在响应主体中找到实体的原始位置的URL'
- en: 'Also, there are two specific use cases for these headers:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些头还有两个特定的用例：
- en: To provide information about the location of a newly created resource
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供有关新创建资源位置的信息
- en: in response to a `POST`
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对`POST`的响应
- en: To inform the client of an alternate location for the requested resource
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知客户端请求资源的替代位置
- en: in response to a `GET`
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对`GET`的响应
- en: There are many possible pairings of `Location` and `Content-Location` headers
    with HTTP status codes, the **3xx** (redirection) set in particular. In fact,
    these headers may even appear together in the same response. The user is encouraged
    to read the relevant sections of the HTTP/1.1 specification, as only a small set
    of common cases is discussed here.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location`和`Content-Location`头与HTTP状态代码有许多可能的配对，特别是**3xx**（重定向）集。实际上，这些头甚至可以在同一个响应中一起出现。鼓励用户阅读HTTP/1.1规范的相关部分，因为这里只讨论了一小部分常见情况。'
- en: Location
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置
- en: Responding to a `POST` with a `201` status code indicates that a new resource
    has been created its URI assigned to the `Location` header and that the client
    may go ahead and use that URI in the future. Note that it is up to the client
    to decide whether, and when, to fetch this resource. As such, this is not, strictly
    speaking, a redirect.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`201`状态代码响应`POST`表示已创建新资源并将其URI分配给`Location`头，客户端可以在将来使用该URI。请注意，由客户端决定是否以及何时获取此资源。因此，严格来说，这不是重定向。
- en: 'For example, a system might create new accounts by posting new user information
    to a server, expecting to receive the location of a new user page:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，系统可能通过将新用户信息发布到服务器来创建新帐户，期望接收新用户页面的位置：
- en: '[PRE38]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Similarly, in cases where a resource creation request has been accepted but
    not yet fulfilled, a server will indicate a status of `202`. This will be the
    case in the preceding example if creation of the new user record had been delegated
    to a worker queue, which might at some point in the future create a record at
    the given `Location`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在接受但尚未完成的情况下，服务器将指示`202`状态。在前面的例子中，如果创建新用户记录的工作已被委托给工作队列，那么这将是情况。
- en: We will see a realistic implementation demonstrating this usage later on in
    the chapter, when we discuss file uploads.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到一个实际的实现，演示这种用法，当我们讨论文件上传时。
- en: Content-Location
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Content-Location
- en: 'When a `GET` is made to a resource that has multiple representations and those
    can be found at distinct resource locations, a `content-location` header for the
    particular entity should be returned. For example, content format negotiation
    is a good candidate for `Content-Location` handling. One might be interested in
    retrieving all blog posts for a given month, perhaps available at a URL such as:
    `http://example.com/september/`. GET requests with an `Accept` header of `application/json`
    will receive a response in JSON format. A request for XML will receive that representation.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当对具有多个表示形式的资源进行`GET`请求，并且这些表示形式可以在不同的资源位置找到时，应该返回特定实体的`content-location`头。例如，内容格式协商是`Content-Location`处理的一个很好的例子。可能有兴趣检索给定月份的所有博客文章，可能可以在URL上找到，比如：`http://example.com/september/`。带有`application/json`的`Accept`头的GET请求将以JSON格式接收响应。对XML的请求将接收该表示形式。
- en: 'If a caching mechanism is being used those resources may have alternate permanent
    locations, such as `http://example.com/cache/september.json` or `http://example.com/cache/september.xml`.
    One will send this additional location information via `Content-Location`, in
    a response object resembling this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在使用缓存机制，这些资源可能具有替代的永久位置，比如`http://example.com/cache/september.json`或`http://example.com/cache/september.xml`。将通过`Content-Location`发送此附加位置信息，响应对象类似于这样：
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In cases where the requested URL has been moved, permanently or temporarily,
    the **3xx** group of status codes can be used with `Content-Location` to indicate
    this state. For example, to redirect a request to a URL that has been permanently
    moved, one should send a 301 code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求的URL已经被永久或临时移动的情况下，可以使用`3xx`状态代码组和`Content-Location`来指示此状态。例如，要重定向到已永久移动的URL，应发送301代码：
- en: '[PRE40]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Implementing resource caching
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施资源缓存
- en: As a general rule, never expend resources delivering irrelevant information
    to clients. For an HTTP server, resending files that the client already possesses
    is an unnecessary I/O cost, exactly the wrong way to implement a Node server,
    increasing latency as well as the financial hit of paying for misappropriated
    bandwidth.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个一般规则，永远不要浪费资源向客户端传递无关的信息。对于HTTP服务器，重新发送客户端已经拥有的文件是不必要的I/O成本，这是实现Node服务器的错误方式，会增加延迟以及支付被挪用的带宽的财务损失。
- en: Browsers maintain a cache of the files they have already fetched, and an **Entity
    Tag** (**ETag**) identifies these files. An ETag is a response header sent by
    servers to uniquely identify entities they are returning, such as a file. When
    a file changes on a server, that server will send a different ETag for said file,
    allowing file changes to be tracked by clients.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器维护已经获取的文件的缓存，并且**实体标签**（**ETag**）标识这些文件。ETag是服务器发送的响应头，用于唯一标识它们返回的实体，比如一个文件。当服务器上的文件发生变化时，该服务器将为该文件发送一个不同的ETag，允许客户端跟踪文件的更改。
- en: 'When a client makes a request to a server for a resource contained within that
    client''s cache, that request will contain an `If-None-Match` header set to the
    value of the ETag associated with the said cached resource. The `If-None-Match`
    header can contain one or multiple ETags:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向服务器请求其缓存中包含的资源时，该请求将包含一个`If-None-Match`头，该头设置为与所述缓存资源相关联的ETag的值。`If-None-Match`头可以包含一个或多个ETag：
- en: '[PRE41]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A server understands this header and will return the full entity body of the
    requested resource only if none of the sent ETags match the current resource entity
    tag. If one of the sent ETags matches the current entity tag, the server will
    respond with a 304 (not modified) status, which should result in a browser, fetching
    the resource from its internal cache.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器理解这个头部，并且只有在发送的ETags中没有一个与当前资源实体标记匹配时，才会返回所请求资源的完整实体主体。如果发送的ETags中有一个与当前实体标记匹配，服务器将以304（未修改）状态进行响应，这应该导致浏览器从其内部缓存中获取资源。
- en: 'Assuming that we have an `fs.Stats` object available, managing cache controls
    on a resource can be done easily with Node:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`fs.Stats`对象可用，使用Node可以轻松地管理资源的缓存控制：
- en: '[PRE42]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We create an `etag` for the current file by creating an MD5 of the current file
    size and its last modified time, and match against the sent `If-None-Match` header.
    If the two do not match, the resource representation has changed, and the new
    version must be sent back to the requesting client. Note that the specific algorithm
    one should use to create an `etag` is not formally specified. The example technique
    should work well for most purposes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建当前文件大小和最后修改时间的MD5来为当前文件创建一个`etag`，并与发送的`If-None-Match`头进行匹配。如果两者不匹配，资源表示已更改，新版本必须发送回请求的客户端。请注意，应该使用哪种特定算法来创建`etag`并没有正式规定。示例技术对大多数目的应该能够很好地工作。
- en: 'Hey! What about `Last-Modified` and `If-Unmodified-Since`? These are fine headers
    and are also useful in the case of caching files. Indeed, one should set the `Last-Modified`
    header where possible when responding to entity requests. The techniques we''re
    describing here using ETag will work similarly with these tags, and in fact, using
    both Etags and these other tags is encouraged. For more information, consult:
    [http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！`Last-Modified`和`If-Unmodified-Since`呢？这些都是很好的头部，也在缓存文件的情况下很有用。事实上，当响应实体请求时，应该尽可能设置`Last-Modified`头部。我们在这里描述的使用ETag的技术将与这些标签类似地工作，实际上，鼓励同时使用ETags和这些其他标签。有关更多信息，请参阅：[http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4)。
- en: Handling file uploads
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件上传
- en: It is likely that anyone reading this sentence has had at least one experience
    with uploading a file from a client to a server. Some may have even implemented
    a file upload service, a server that will receive and do something useful with
    a multipart data stream. Within popular development environments, this task has
    been made very easy. In the PHP environment, for example, uploaded data is automatically
    processed and made globally available, neatly parsed and packaged into an array
    of files or form field values, without the developer having written a single line
    of code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能任何阅读这句话的人都至少有一次从客户端上传文件到服务器的经历。有些人甚至可能实现了文件上传服务，一个将接收并对多部分数据流执行有用操作的服务器。在流行的开发环境中，这个任务变得非常容易。例如，在PHP环境中，上传的数据会自动处理并全局可用，被整洁地解析和打包成文件或表单字段值的数组，而开发人员无需编写一行代码。
- en: Unfortunately, Node leaves implementation of file upload handling to the developer,
    a challenging bit of work many developers may be unable to successfully or safely
    complete.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Node将文件上传处理的实现留给开发人员，这是一个具有挑战性的工作，许多开发人员可能无法成功或安全地完成。
- en: Fortunately, Felix Geisendorfer created the **Formidable** module, one of the
    most important early contributions to the Node project. A widely implemented,
    enterprise-grade module with extensive test coverage, it not only makes handling
    file uploads a snap, but can be used as a complete tool for handling form submissions.
    We will use this library to add file upload capability to our file server.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Felix Geisendorfer创建了**Formidable**模块，这是Node项目中最重要的早期贡献之一。这是一个广泛实施的企业级模块，具有广泛的测试覆盖范围，它不仅使处理文件上传变得轻而易举，而且可以用作处理表单提交的完整工具。我们将使用这个库来为我们的文件服务器添加文件上传功能。
- en: For more information about how HTTP file uploads are designed, and the tricky
    implementation problems developers must overcome, consult the multipart/form-data
    specification at [http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2)
    and Geisendorfer's breakdown of how **Formidable** was conceived of and evolved
    at [http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb](http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有关HTTP文件上传设计的更多信息，以及开发人员必须克服的棘手实现问题，请参阅[http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2)中的多部分/表单数据规范，以及Geisendorfer关于**Formidable**的构想和演变的分解[http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb](http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb)。
- en: 'First, install `formidable` via npm:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过npm安装`formidable`：
- en: '[PRE43]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can now `require` it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以`require`它：
- en: '[PRE44]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will assume that file uploads will be posted to our server along a path of
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设文件上传将通过路径发布到我们的服务器上
- en: '`/uploads/`, and that the upload arrives via a HTML form that looks like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`/uploads/`，并且上传通过一个看起来像这样的HTML表单到达：'
- en: '[PRE45]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This form will allow a client to write some sort of title for the upload, and
    to select one (or multiple) files for uploading. At this point, our only responsibility
    on our server is to properly detect when a `POST` request has been made and pass
    the relevant request object to Formidable.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单将允许客户端为上传写一些标题，并选择一个（或多个）文件进行上传。在这一点上，我们服务器的唯一责任是正确检测到何时发出了`POST`请求，并将相关请求对象传递给Formidable。
- en: 'We won''t be covering every part of the comprehensive formidable API design,
    but we''ll focus on the key `POST` events the library exposes. As formidable extends
    `EventEmitter`, we use the `on(eventName,callback)` format to catch file data,
    field data, and termination events, sending a response to the client describing
    what the server has successfully processed:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖formidable API设计的每个部分，但我们将专注于库公开的关键`POST`事件。由于formidable扩展了`EventEmitter`，我们使用`on(eventName,callback)`格式来捕获文件数据、字段数据和终止事件，向客户端发送响应，描述服务器成功处理了什么：
- en: '[PRE46]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We see here how a `formidable` instance receives an `http.Incoming` object through
    its `parse` method, and how the write path for incoming files is set using the
    `uploadDir` attribute of that instance. The example sets this directory to the
    local directory. A real implementation would likely target a dedicated upload
    folder, or even direct the received file to a storage service, receiving in return
    the final storage location (perhaps receiving it via HTTP and a `Location` header...).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到一个`formidable`实例如何通过其`parse`方法接收`http.Incoming`对象，以及如何使用该实例的`uploadDir`属性设置传入文件的写入路径。该示例将此目录设置为本地目录。真实的实现可能会将目标定位到专用的上传文件夹，甚至将接收到的文件定向到存储服务，通过HTTP和`Location`头接收最终的存储位置（也许是通过HTTP接收）。
- en: 'Also note how the file event callback receives a formidable `File` object as
    a second argument, which contains important file information including the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意文件事件回调如何接收formidable `File`对象作为第二个参数，其中包含重要的文件信息，包括以下内容：
- en: '**size**: The size of the uploaded file, in bytes'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**size**：上传文件的大小，以字节为单位'
- en: '`*` **path**: The current location of the uploaded file on the local filesystem,
    such'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` **path**：上传文件在本地文件系统上的当前位置，例如'
- en: as `/tmp/bdf746a445577332e38be7cde3a98fb3`
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`/tmp/bdf746a445577332e38be7cde3a98fb3`
- en: '**name**: The original name of the file as it existed on the client filesystem,
    such as `lolcats.jpg`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**：文件在客户端文件系统上存在的原始名称，例如`lolcats.jpg`'
- en: '**type**: The file mime type, such as `image/png`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**type**：文件的MIME类型，例如`image/png`'
- en: 'In a few lines of code, we''ve implemented a significant amount of `POST` data
    management. Formidable also provides tools for handling progress indicators, dealing
    with network errors, and more, which the reader can learn about by visiting: [https://github.com/felixge/node-formidable](https://github.com/felixge/node-formidable).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在几行代码中，我们已经实现了大量的`POST`数据管理。Formidable还提供了处理进度指示器、处理网络错误等工具，读者可以通过访问以下网址了解更多信息：[https://github.com/felixge/node-formidable](https://github.com/felixge/node-formidable)。
- en: Putting it all together
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'Recalling our discussion of favicon handling from the last chapter and adding
    what we''ve learned about file caching and file uploading, we can now construct
    a simple file server handling the `GET` and `POST` requests:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在上一章中关于favicon处理的讨论，并加上我们对文件缓存和文件上传的了解，我们现在可以构建一个简单的文件服务器来处理`GET`和`POST`请求：
- en: '[PRE47]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note the 404 (not found) and 500 (internal server error) status codes.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意404（未找到）和500（内部服务器错误）状态代码。
- en: '`Content-Length` is measured in bytes, not characters. Normally, your data
    will be in single byte characters (hello is five bytes long), but this is not
    always the case. If you are determining the length of a stream buffer, use `Buffer.byteLength`.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Length`以字节为单位，而不是字符。通常，您的数据将是单字节字符（hello是五个字节长），但并非总是如此。如果您确定流缓冲区的长度，请使用`Buffer.byteLength`。'
- en: A simple file browser
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的文件浏览器
- en: 'Now, let''s take what we''ve learned about files and Node to do something that
    truly (and hopefully) no web page can; let''s directly browse the entire hard
    disk of your personal computer! To make this possible, we''ll use two powerful
    recent additions to the JavaScript and Node family: *Electron* and *Vue.js*.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用我们对文件和Node的了解来做一些真正（希望如此）没有网页可以做到的事情；让我们直接浏览您个人计算机的整个硬盘！为了实现这一点，我们将使用JavaScript和Node家族的两个强大的最近添加：*Electron*和*Vue.js*。
- en: 'Start out at your terminal with commands like these:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端开始，使用以下命令：
- en: '[PRE48]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The default answers are fine, except for the entry point—instead of `index.js`,
    type `main.js`. When you''re done, you should have a `package.json` file like
    this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 默认答案很好，除了入口点——不要输入`index.js`，而是输入`main.js`。完成后，你应该有一个像这样的`package.json`文件：
- en: '[PRE49]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s take a look at these three commands:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看这三个命令：
- en: '[PRE50]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Try the first to ensure that npm got a working copy of Electron onto your computer.
    As of this writing, the current version is v1.7.9\. The second command will execute
    electron "empty", that is, without giving it an app to run. The third command
    tells electron to run the app in this folder: Electron will read `package.json`
    to find and run `main.js`.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试第一个命令，以确保npm在您的计算机上获得了一个可用的Electron副本。截至目前，当前版本是v1.7.9。第二个命令将执行electron "empty"，即在不给它一个应用程序运行的情况下。第三个命令告诉electron在这个文件夹中运行应用程序：Electron将读取`package.json`来查找并运行`main.js`。
- en: 'Alternatively, you can use `-g` to install Electron globally, and then reach
    the executable more easily with commands like these:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`-g`全局安装Electron，然后使用以下命令更轻松地到达可执行文件：
- en: '[PRE51]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Electron
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Electron
- en: 'Let''s run the second command. The result may be surprising: a graphical window
    appears on your screen!:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行第二个命令。结果可能会让人惊讶：一个图形窗口出现在您的屏幕上！：
- en: '![](img/74646cbc-c5e5-41ff-b207-9d1524a547a4.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74646cbc-c5e5-41ff-b207-9d1524a547a4.png)'
- en: 'What is this? What is Electron? Let''s answer that question several ways: to
    the end user, to the developer or product owner, under the hood, and at the end
    of the chapter, from the perspective of JavaScript''s history and development.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么？Electron是什么？让我们以几种方式回答这个问题：对于最终用户，对于开发人员或产品所有者，底层，以及在本章末尾，从JavaScript的历史和发展的角度来看。
- en: 'To the end user, an Electron app is just a regular desktop app. Users can''t
    even tell it''s made with Electron. The unboxing flow is exactly the same: the
    user gets the app from their favorite app store, or downloads `setup.exe` from
    your website. The daily experience is also the same: the app has an icon on the
    Start menu or dock, menus where they should be, a `File|Open...` dialog—all the
    features users expect from a desktop application. You might use Slack on Windows
    or macOS, for instance, and may be surprised to learn that Slack is made with
    Electron.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终用户，Electron应用程序只是一个普通的桌面应用程序。用户甚至无法知道它是用Electron制作的。开箱即用的流程完全相同：用户可以从他们喜欢的应用商店获取应用程序，或者从你的网站下载`setup.exe`。日常体验也是一样的：应用程序在开始菜单或dock上有一个图标，菜单在应该的地方，`文件|打开...`对话框——所有用户期望从桌面应用程序中获得的功能。例如，你可能在Windows或macOS上使用Slack，并且可能会惊讶地发现Slack是用Electron制作的。
- en: To the developer or product owner, Electron is a great way to make desktop apps.
    Developers can use the modern and powerful technologies they learned for the web
    on the desktop now. All your favorite npm modules can come along, too. Product
    owners like being able to ship version 1.0 simultaneously on Windows, Mac, and
    Linux with very little additional development or testing required. Business stakeholders
    like being able to task a single group of web developers across web and desktop
    projects, instead of having to hire new individual dedicated teams (a separate
    one per target operating system) experienced in each individual native desktop
    stack.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员或产品所有者来说，Electron是制作桌面应用程序的好方法。开发人员现在可以在桌面上使用他们在网络上学到的现代和强大的技术。你喜欢的所有npm模块也可以一起使用。产品所有者喜欢能够在Windows、Mac和Linux上同时发布1.0版本，几乎不需要额外的开发或测试。业务利益相关者喜欢能够让一个Web开发人员团队同时负责Web和桌面项目，而不是不得不雇佣新的专门的团队（每个目标操作系统一个）来熟悉每个单独的本地桌面堆栈。
- en: Under the hood, Electron is pretty amazing. It's built from parts of both Chromium
    and Node, getting abilities like page rendering from Chromium, and abilities like
    buffers, files, and sockets from Node. Both Chromium and Node contain V8, and
    inside V8 a JavaScript event loop, of course. In an impressive engineering feat,
    Electron merges these two event loops together, allowing a single JavaScript event
    to run code that affects both the screen and the system.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Electron非常惊人。它由Chromium和Node的部分组成，从Chromium获取页面渲染的能力，从Node获取缓冲区、文件和套接字等能力。Chromium和Node都包含V8，当然在V8内部有一个JavaScript事件循环。在一项令人印象深刻的工程壮举中，Electron将这两个事件循环合并在一起，允许单个JavaScript事件运行代码，影响屏幕和系统。
- en: Electron is made by GitHub, which also develops the Atom text editor. To make
    Atom as hackable as the web, GitHub built it using web technologies. Realizing
    that other software teams might want to construct desktop apps this way, GitHub
    released their tools first as Atom Shell, and simplified the name to Electron.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Electron是由GitHub制作的，GitHub也开发了Atom文本编辑器。为了使Atom像网络一样易于修改，GitHub使用了网络技术构建了它。意识到其他软件团队可能希望以这种方式构建桌面应用程序，GitHub首先将他们的工具作为Atom
    Shell发布，并将名称简化为Electron。
- en: 'Now that we''ve got Electron running, let''s make Electron an app of our own.
    The `electron .` command causes Electron to look in `package.json` to see what
    it should do. There, we''re pointing it to `main.js`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让Electron运行起来了，让我们把Electron变成我们自己的应用程序。`electron .`命令会让Electron查看`package.json`来确定它应该做什么。在那里，我们指向了`main.js`：
- en: '[PRE52]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can imagine that Node is running the file, even though the executable that''s
    running it is actually Electron (which has Node and V8 inside, of course). Note
    how the code can require familiar Node modules like `path` and `url` as well as
    some new ones, such as `electron`. The code in `main.js` creates a special Electron
    browser window that''s 800 pixels wide and 800 pixels high, and navigates it to
    `index.html`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象Node正在运行这个文件，尽管实际上运行它的可执行文件是Electron（当然，Electron内部包含了Node和V8）。请注意代码如何可以引入熟悉的Node模块，比如`path`和`url`，以及一些新的模块，比如`electron`。`main.js`中的代码创建了一个特殊的Electron浏览器窗口，宽800像素，高800像素，并将其导航到`index.html`：
- en: '[PRE53]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This also looks quite familiar from what we'd expect on the web. We'll talk
    about Vue later in this chapter; right now, note the reload `button` at the top
    of the page and the `script` tag at the end.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来也很熟悉，符合我们在网络上的期望。我们将在本章后面讨论Vue；现在，请注意页面顶部的重新加载`按钮`和末尾的`script`标签。
- en: The button is useful when developing. Instead of restarting the Electron process
    at the command line, you can just make a change to this page or the JavaScript
    it brings in and see the results from hitting the Reload button. Electron doesn't
    display Chromium's default browser toolbar, where the Reload button lives, but
    View, Reload is available on the menu bar on macOS, and it's even easier to put
    a Reload button right in the page.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发时，按钮是很有用的。你可以通过点击重新加载按钮来查看对这个页面或它引入的JavaScript进行更改后的结果，而不是在命令行重新启动Electron进程。Electron不显示Chromium的默认浏览器工具栏，其中包含重新加载按钮，但在macOS的菜单栏上有“查看，重新加载”，并且可以更容易地在页面上放置一个重新加载按钮。
- en: To understand the `script` tag at the end, it's best to first get a basic understanding
    of Electron's process architecture.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解末尾的`script`标签，最好先对Electron的进程架构有一个基本的了解。
- en: Electron processes
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Electron进程
- en: 'Built from Chromium, Electron inherited Chromium''s (and Chrome''s) one-process-per-tab
    architecture. With Electron running our app, there is only one "tab": the window
    on your screen, but there are still two processes. The *main* process represents
    the underlying browser, which you started from the command line, at which point
    it read `package.json`, and then ran `main.js`. Electron''s main process can create
    new `BrowserWindow` objects, and deal with events that affect the overall lifecycle
    of the desktop app, from startup to shutdown.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 由Chromium构建，Electron继承了Chromium（和Chrome）的每个标签一个进程的架构。使用Electron运行我们的应用程序时，只有一个“标签”：你屏幕上的窗口，但仍然有两个进程。*主*进程代表底层浏览器，你可以从命令行启动它，然后它读取`package.json`，然后运行`main.js`。Electron的主进程可以创建新的`BrowserWindow`对象，并处理影响桌面应用程序整体生命周期的事件，从启动到关闭。
- en: On the page Electron opens, however, a different process, the *renderer* process,
    runs the JavaScript there. Only a renderer process is able to perform GUI-related
    tasks, like manipulating the DOM.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Electron打开的页面上，另一个进程，*渲染器*进程，运行其中的JavaScript。只有渲染器进程能够执行与GUI相关的任务，比如操作DOM。
- en: Node is available in both processes. If a module expects the DOM to be present,
    it may not work in the main process, however. For instance, jQuery fails to load
    in Electron's main process, but works fine in a renderer process, while Handlebars
    works fine in both.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Node在两个进程中都可用。如果一个模块期望DOM存在，它可能无法在主进程中工作。例如，jQuery在Electron的主进程中无法加载，但在渲染器进程中可以正常工作，而Handlebars在两者中都可以正常工作。
- en: In instances where the code in one Electron process needs to perform an action
    or get an answer from some code in the other process, the solution is Node's standard
    inter-process communication tools, described later in [Chapter 7](48e16668-9318-4577-b3c0-3f4dbce035d9.xhtml),
    *Using Multiple Processes*. Additionally, Electron conveniently wraps some of
    these in its own API.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个Electron进程中的代码需要执行某个动作或从另一个进程中的代码获取答案，解决方案是Node的标准进程间通信工具，稍后在[第7章](48e16668-9318-4577-b3c0-3f4dbce035d9.xhtml)中描述，*使用多个进程*。此外，Electron方便地将其中一些封装在自己的API中。
- en: The renderer process
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染器进程
- en: 'So far, we''ve seen Electron start, run `main.js`, and open `index.html`. In
    summary, here''s how the whole thing works:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到Electron启动，运行`main.js`，并打开`index.html`。总之，整个过程是这样工作的：
- en: 'Electron''s *main* process does the following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Electron的*主*进程执行以下操作：
- en: reads `package.json`, which tells it to then
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取`package.json`，然后告诉它
- en: run `main.js`
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`main.js`
- en: 'This causes Electron to start a *renderer* process to do this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致Electron启动一个*渲染器*进程来执行此操作：
- en: parse `index.html`, which then
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析 `index.html`，然后
- en: runs `renderer.js`
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`renderer.js`
- en: 'Let''s take a look at the code there:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那里的代码：
- en: '[PRE54]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: First, this code brings in the bluebird promise library, setting it to `Promise`.
    The call to `Promise.promisifyAll()` creates functions like `fs.lstatAsync()`,
    the promisified version of `fs.lstat()`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这段代码引入了bluebird promise库，并将其设置为`Promise`。对`Promise.promisifyAll()`的调用创建了诸如`fs.lstatAsync()`之类的函数，这是`fs.lstat()`的promise版本。
- en: Our app's core logic is factored into a single function named `go()`, which
    gets passed an absolute filesystem path the user wants the app to take a look
    at. If the path is to an image, the app shows it on the page. If the path is to
    a directory, the app lists the folder's contents.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的核心逻辑被分解为一个名为`go()`的单个函数，该函数传递给应用程序想要查看的绝对文件系统路径。如果路径是一个图像，应用程序会在页面上显示它。如果路径是一个目录，应用程序会列出文件夹的内容。
- en: To perform this logic, the preceding code first simply looks for a common image
    file extension. If not present, an asynchronous step looks at the disk with `fs.lstatAsync()`
    to then be able to call `stat.isDirectory()`. If it is a directory, another promisified
    call, `fs.readdirAsync()`, gets the directory listing.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个逻辑，前面的代码首先简单地查找一个常见的图像文件扩展名。如果不存在，一个异步步骤会使用`fs.lstatAsync()`来查看磁盘，然后能够调用`stat.isDirectory()`。如果是一个目录，另一个promise调用`fs.readdirAsync()`会获取目录列表。
- en: 'Here''s a picture of our simple Electron-powered file browser in action:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们简单的Electron文件浏览器的运行情况：
- en: '![](img/c9740216-ac9e-4e7f-a15a-74a2a6ef710e.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9740216-ac9e-4e7f-a15a-74a2a6ef710e.png)'
- en: Vue.js
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js
- en: Our app's user experience is powered by *Vue.js*, a frontend JavaScript framework
    for building and easily changing the contents of a web page. Like React, Vue lets
    you template components, put them on the page, and change them when the data underneath
    changes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的用户体验由*Vue.js*提供支持，这是一个用于构建和轻松更改网页内容的前端JavaScript框架。与React一样，Vue允许您对组件进行模板化，将它们放在页面上，并在底层数据发生变化时进行更改。
- en: React uses JSX to combine HTML tags with JavaScript code. This requires a preprocessor
    like *Babel* to transpile the JSX portions into ES6 JavaScript. In a typical React
    stack, *webpack* manages a build process that includes Babel, converting and combining
    your development files into files you'll run, test, and eventually deploy. The
    webpack dev server shows your site as you code it, even automatically refreshing
    as you change your code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: React使用JSX将HTML标记与JavaScript代码组合在一起。这需要一个预处理器，比如*Babel*，将JSX部分转译成ES6 JavaScript。在典型的React堆栈中，*webpack*管理着一个构建过程，其中包括Babel，将您的开发文件转换并组合成您将运行、测试和最终部署的文件。webpack开发服务器会在您编写代码时显示您的网站，甚至在您更改代码时自动刷新。
- en: 'Vue, however, doesn''t require a transpilation step. You can use it with webpack,
    but you can also use it with just a script tag, like this one in our app''s `index.html`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Vue不需要一个转译步骤。您可以将它与webpack一起使用，但也可以只使用一个脚本标签，就像我们应用程序的`index.html`中的这个一样：
- en: '[PRE55]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This flexibility makes it easy to get started with Vue, makes Vue easy to get
    running in Electron, and is why we've picked it for this example app.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性使得使用Vue很容易入门，在Electron中运行Vue也很容易，这也是我们选择它作为这个示例应用程序的原因。
- en: 'Back on the `index.html` page, take a look at these lines:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`index.html`页面，看看这些行：
- en: '[PRE56]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Also, in the `renderer.js` script, take a look at this part:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`renderer.js`脚本中，看看这部分：
- en: '[PRE57]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the page, `<div id="app">` identifies `div` as our app, and in the script,
    `var app = new Vue({});` creates the new JavaScript object that connects to and
    controls the *app* `div`. The data object inside `app` defines values that appear
    in the div and thus on the page. For example, `app.location`, which through some
    clever internal linking with `this` reaches into the `data` object above, is shown
    on the page where `{{ location }}` appears. Vue even watches for changes to `data.location`—set
    that to a new value and the page will update automatically. With this ability,
    Vue is said to be *reactive*.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面中，`<div id="app">`标识`div`作为我们的应用程序，在脚本中，`var app = new Vue({});`创建了连接到并控制*app*
    `div`的新JavaScript对象。`app`内部的数据对象定义了出现在div中的值，因此也出现在页面上。例如，`app.location`，通过与上面的`data`对象的一些巧妙的内部链接，显示在`{{
    location }}`出现的页面上。Vue甚至会监视对`data.location`的更改-将其设置为一个新值，页面将自动更新。有了这个能力，Vue被称为*reactive*。
- en: Browse around your local disk with the file browser we just built, and imagine
    all the desktop apps you can now create with Node and Electron.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们刚刚构建的文件浏览器在本地磁盘上浏览一下，并想象一下你现在可以使用Node和Electron创建的所有桌面应用程序。
- en: Earlier, this chapter asked, "What is Electron?" and composed different answers
    imagining different stakeholders and considering different perspectives.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们问过，“Electron是什么？”并构思了不同的答案，想象了不同的利益相关者，并考虑了不同的观点。
- en: Electron gets JavaScript one step closer to Kris Kowal's goal for the language,
    which you may remember from [Chapter 1](ad3a0c29-f1fb-4319-9042-a9f38bb0b53a.xhtml),
    *Understanding the Node Environment*, is no less than "world domination", meaning
    able to run everywhere and do anything. Also, taking JavaScript's place in the
    last few decades of computing into consideration, it achieves this with some wry
    irony.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Electron让JavaScript离Kris Kowal在[第一章](ad3a0c29-f1fb-4319-9042-a9f38bb0b53a.xhtml)中提到的语言目标更近了一步，即“理解Node环境”，这意味着能够在任何地方运行并做任何事情。此外，考虑到JavaScript在过去几十年的计算中的地位，它以一些讽刺的方式实现了这一目标。
- en: Brendan Eich created JavaScript to script small tasks within web pages running
    on browsers on personal computers in the 1990s, which had just recently gained
    bitmapped displays and graphical operating systems. There, JavaScript was tightly
    contained within the sandbox of the browser tab. The sandbox enforced strict security
    requirements, and limited it from, among other things, looking at some files.
    Close to the user and close to the screen, JavaScript could validate form data,
    and change CSS on the fly. In this first stage of life, most days, JavaScript
    animated some text.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Brendan Eich在1990年代创建了JavaScript，用于在个人电脑上运行的浏览器中的网页中脚本化小任务，这些电脑刚刚获得了位图显示和图形操作系统。在那里，JavaScript被严格限制在浏览器标签的沙盒中。沙盒执行严格的安全要求，并限制了它，不能查看一些文件等。靠近用户和屏幕，JavaScript可以验证表单数据，并实时更改CSS。在生命的第一阶段，大多数时候，JavaScript都在动画化一些文本。
- en: Node took JavaScript to the server, distancing it from the graphical screen,
    but freeing it from the confines of the browser. There, JavaScript became a competent
    and complete systems language, accessing files and sockets to perform useful and
    powerful tasks. In this second stage of life, most days, JavaScript migrated a
    database.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Node将JavaScript带到了服务器，使其远离了图形屏幕，但也使其摆脱了浏览器的限制。在那里，JavaScript成为了一种能干而完整的系统语言，访问文件和套接字以执行有用和强大的任务。在生命的第二阶段，大多数时候，JavaScript迁移了数据库。
- en: Electron takes JavaScript back to the client. Like a wandering feudal warrior
    returning to his home village after years of exile, (and, of course, distant and
    elite training) JavaScript returns with ES6 features and npm modules it developed
    in the harsh wasteland of the server, being used and developed alongside formidable
    partners (and oftentimes foes) like C++ and Java. Back on the desktop and armed
    with Electron, it can use these abilities outside of the restricted confines of
    the browser. In this third stage of life, JavaScript really can do anything.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Electron将JavaScript带回了客户端。就像一个漂泊的封建武士在被流放多年后返回家乡一样，JavaScript带着ES6功能和在服务器荒原上开发的npm模块回来了，它与强大的伙伴（有时也是敌人）如C++和Java一起被使用和开发。在桌面上并且拥有Electron的支持，它可以在浏览器的受限范围之外使用这些能力。在生命的第三阶段，JavaScript真的可以做任何事情。
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how Node's API is a comprehensive map to native filesystem
    bindings, exposing a full range of functionality to the developer while requiring
    very little code or complexity. Additionally, we saw how files are easily wrapped
    into `Stream` objects, and how this consistency with the rest of Node's design
    simplifies interactions between different types of I/O, such as between network
    data and files. Using Electron, we built a file browser that runs as a cross-platform
    native application, opening up a whole new world for Node developers.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Node的API是对本地文件系统绑定的全面映射，为开发人员提供了完整的功能范围，同时需要非常少的代码或复杂性。此外，我们还看到文件如何轻松地包装成`Stream`对象，以及这种与Node设计的一致性如何简化了不同类型I/O之间的交互，比如网络数据和文件之间的交互。使用Electron，我们构建了一个作为跨平台本地应用程序运行的文件浏览器，为Node开发人员打开了一个全新的世界。
- en: We've also learned something about how to build servers with Node that can accommodate
    regular client expectations, easily implementing file uploading and resource caching.
    Having covered the key features of Node, it is time to use these techniques in
    building larger applications able to handle many thousands of clients.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学到了一些关于如何使用Node构建服务器，以满足常规客户端的期望，轻松实现文件上传和资源缓存。在介绍了Node的关键特性之后，现在是时候在构建能够处理成千上万客户端的大型应用程序中使用这些技术了。
