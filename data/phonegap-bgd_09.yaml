- en: Chapter 9. Getting Ready for Release
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。准备发布
- en: '*So far, you''ve created your app with PhoneGap, defined the building blocks
    of its interface, and learned to use various APIs provided by PhoneGap. In this
    chapter, you will consolidate the app architecture and learn how to prepare your
    app for your final release to the public. You can optimize your application using
    various methods to give your users a solid UX experience.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，你已经使用 PhoneGap 创建了你的应用，定义了其界面的构建块，并学会了使用 PhoneGap 提供的各种 API。在本章中，你将巩固应用架构，并学习如何为你的最终发布到公众做准备。你可以使用各种方法优化你的应用，为用户提供一个坚实的用户体验。*'
- en: 'In this chapter, you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将：
- en: Learn to compress your JavaScript and also learn why this is especially important
    for a mobile app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何压缩你的 JavaScript，并了解为什么这对于移动应用尤其重要
- en: Learn how to introduce JavaScript dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何引入 JavaScript 依赖项
- en: Learn more about template engines and how to compress template files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于模板引擎以及如何压缩模板文件
- en: Create fluid, multiple views of your app using PhoneGap
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PhoneGap 创建流畅的、多个视图的应用
- en: Learn how to create hardware-accelerated transitions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建硬件加速的过渡
- en: Discover how to use common code base for web and mobile platforms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现如何使用适用于 Web 和移动平台的通用代码库
- en: Exploring JavaScript compression
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 JavaScript 压缩
- en: In computer programming, we refer to the process of removing unnecessary characters
    from the source code files, and eventually concatenating them, as **file compression**.
    When dealing with web standards, we can compress any file type, including HTML,
    CSS, and JavaScript. The main goal of this process is to reduce the file size
    in order to speed up download time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，我们将从源代码文件中删除不必要的字符，并将它们最终连接起来的过程称为 **文件压缩**。在处理 Web 标准时，我们可以压缩任何类型的文件，包括
    HTML、CSS 和 JavaScript。这个过程的主要目标是减小文件大小，以加快下载时间。
- en: One of the benefits of compressing your source code when working with PhoneGap
    is performance improvement. When dealing with a mobile app, the files are compiled
    as a single file that eventually loads external data. However, when dealing with
    an app built using PhoneGap, the files, even if they are stored locally, have
    to be loaded in the browser (that is, the **WebView**). Smaller files will be
    executed faster, so the end user will get a better experience with a more responsive
    user interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 PhoneGap 进行源代码压缩时，其中一个好处是性能提升。在处理移动应用时，文件会被编译成一个单独的文件，最终加载外部数据。然而，当处理使用
    PhoneGap 构建的应用时，即使文件存储在本地，也必须在浏览器（即 **WebView**）中加载。较小的文件将执行得更快，因此最终用户将获得一个响应性更强的用户界面，体验更佳。
- en: You may think that what really matters on a mobile device is the memory consumption,
    and that compression will not cause a great reduction of memory usage because
    the original file and the minified one are interpreted into the same code. However,
    there are compression tools that can affect the runtime performance as well. The
    following sections discuss three of the most popular compression tools that may
    help improve the performance of your app.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为在移动设备上真正重要的是内存消耗，并且压缩不会导致内存使用量的大幅减少，因为原始文件和压缩后的文件都被解释成相同的代码。然而，有一些压缩工具可以影响运行时性能。以下几节将讨论三种最流行的压缩工具，这些工具可能有助于提高你应用的性能。
- en: Google Closure Compiler
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Closure Compiler
- en: '**Google Closure** is a set of open source tools built in order to help developers
    speed up the development process of modern web applications. The project consists
    of a JavaScript optimizer, comprehensive JavaScript library, server-side and client-side
    template engine, and JavaScript style checker and style fixer. As a complete overview
    of Google Closure is beyond the scope of this book, we will focus only on the
    compiler.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Closure** 是一套开源工具，旨在帮助开发者加快现代 Web 应用的开发过程。该项目包括一个 JavaScript 优化器、全面的
    JavaScript 库、服务器端和客户端模板引擎，以及 JavaScript 风格检查器和风格修复器。由于本书的范围不包括 Google Closure
    的完整概述，我们将仅关注编译器。'
- en: 'One of the sentences that best describes the compiler comes from the online
    documentation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 描述编译器的一句话最好的来自在线文档：
- en: '*“Instead of compiling from a source language to machine code, it compiles
    from JavaScript to better JavaScript.”*'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“它不是从源语言编译到机器代码，而是从 JavaScript 编译到更好的 JavaScript。”*'
- en: 'You can use the compiler in one of the following three ways:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下三种方式之一使用编译器：
- en: You can use it online at [http://closure-compiler.appspot.com/home](http://closure-compiler.appspot.com/home)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 [http://closure-compiler.appspot.com/home](http://closure-compiler.appspot.com/home)
    在线使用它。
- en: You can download a Java application from [http://closure-compiler.googlecode.com/files/compiler-latest.zip](http://closure-compiler.googlecode.com/files/compiler-latest.zip)
    and execute it through the command-line tool
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从 [http://closure-compiler.googlecode.com/files/compiler-latest.zip](http://closure-compiler.googlecode.com/files/compiler-latest.zip)
    下载一个 Java 应用程序，并通过命令行工具执行它。
- en: You can use the API provided by Google (see [https://developers.google.com/closure/compiler/docs/gettingstarted_api](https://developers.google.com/closure/compiler/docs/gettingstarted_api))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Google 提供的 API（见 [https://developers.google.com/closure/compiler/docs/gettingstarted_api](https://developers.google.com/closure/compiler/docs/gettingstarted_api)）。
- en: When you open the online application, you can specify in the left pane the URLs
    of the scripts you want to compile, what kind of optimization you want to be applied
    to the output file, and if you want the output to be formatted for readability.
    On the right pane of the web application, you will get a report dealing with the
    original size and the optimized size of the file, the compiled code, a list of
    warnings, eventually some errors, and the POST data sent to the Closure Compiler
    APIs. The warnings provided refer to possible mistakes in the source code and
    optimization that can be performed. For a reference to possible warning messages,
    go to [https://developers.google.com/closure/compiler/docs/error-ref](https://developers.google.com/closure/compiler/docs/error-ref).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开在线应用程序时，您可以在左侧面板中指定您想要编译的脚本的 URL，您想要应用于输出文件的优化类型，以及您是否希望输出文件格式化为可读性。在网页应用程序的右侧面板中，您将获得一份报告，涉及文件的原始大小和优化大小，编译后的代码，警告列表，最终可能是一些错误，以及发送到
    Closure Compiler API 的 POST 数据。提供的警告涉及源代码中可能出现的错误和可以执行的优化。有关可能的警告消息的参考，请访问 [https://developers.google.com/closure/compiler/docs/error-ref](https://developers.google.com/closure/compiler/docs/error-ref)。
- en: '![Google Closure Compiler](img/B03476_09_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Google Closure Compiler](img/B03476_09_01.jpg)'
- en: 'If you prefer working with the command-line tool, you can download the compiler
    application and execute it, specifying the compiling options and the input and
    output files:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用命令行工具，您可以下载编译器应用程序并执行它，指定编译选项、输入文件和输出文件：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You get the same result when using the online tool; however, using the command
    line saves you an extra step: you don''t have to upload the source code first.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在线工具时，您将获得相同的结果；然而，使用命令行可以节省一个额外的步骤：您不需要首先上传源代码。
- en: When you use the advanced optimization, be aware that the renaming process will
    be more aggressive, the unused code will be removed, and the body of the function
    calls will be replaced with the body of the function itself (this process is known
    as **function inlining**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用高级优化时，请注意，重命名过程将更加激进，未使用的代码将被删除，函数调用的主体将被替换为函数本身的主体（这个过程被称为**函数内联**）。
- en: Time for action – compressing files using the Closure Compiler
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用 Closure Compiler 压缩文件
- en: 'Follow the given steps to get a compressed and optimized file using the Google
    Closure Compiler:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用 Google Closure Compiler 获取压缩和优化的文件：
- en: Download and unzip the Closure Compiler application available at [http://dl.google.com/closure-compiler/compiler-latest.zip](http://dl.google.com/closure-compiler/compiler-latest.zip).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压可在 [http://dl.google.com/closure-compiler/compiler-latest.zip](http://dl.google.com/closure-compiler/compiler-latest.zip)
    获取的 Closure Compiler 应用程序。
- en: Open the command-line tool, move to the unzipped folder, and create a folder
    named `sample`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行工具，移动到解压文件夹，并创建一个名为 `sample` 的文件夹。
- en: 'In the new folder, create three files: `index.html`, `test.js`, and `index.js`.
    You can use the following commands:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中，创建三个文件：`index.html`、`test.js` 和 `index.js`。您可以使用以下命令：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open the `test.js` file and define a self-executing function. Within the body
    of the function, declare two other functions and return one of them in order to
    be able to run this code from another JavaScript file (the purpose of the two
    functions is to mimic a real use case when some code is kept internal to a closure
    and some other is exposed through a returning object).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `test.js` 文件并定义一个自执行的函数。在函数体内部，声明两个其他函数，并返回其中一个，以便能够从另一个 JavaScript 文件（这两个函数的目的是模拟某些代码保留在闭包内部而其他代码通过返回对象公开的实际用例）中运行此代码。
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open the `index.js` file and declare a variable in order to store the result
    of the self-executing function and make a call to the `init` function returned
    by the function itself:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `index.js` 文件并声明一个变量以存储自执行函数的结果，并调用函数本身返回的 `init` 函数：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Return to the command-line tool and run the compiler against the JavaScript
    files you just created:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到命令行工具并针对你刚刚创建的 JavaScript 文件运行编译器：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Open the generated file and take a look at the source code; you will get the
    following JavaScript:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开生成的文件并查看源代码；你会得到以下 JavaScript：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Insert the `script` tag in the HTML page referring to the new optimized JavaScript
    file and open it in a browser.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HTML 页面中插入指向新优化 JavaScript 文件的 `script` 标签并在浏览器中打开它。
- en: '*What just happened?*'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: You discovered the potential of the `ADVANCED_OPTIMIZATIONS` compilation level
    of the Closure Compiler. As you can see, it's pretty aggressive. In fact, if you
    run the same command using the files you have created for your actual project,
    you will not be able to run the application as intended. In short, ensure to check
    whether the `ADVANCED_OPTIMIZATIONS` option breaks your code; if so, you should
    consider using a different level of compression.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现了 Closure Compiler 的 `ADVANCED_OPTIMIZATIONS` 编译级别的潜力。正如你所见，它相当激进。实际上，如果你使用为你的实际项目创建的文件运行相同的命令，你将无法按预期运行应用程序。简而言之，确保检查
    `ADVANCED_OPTIMIZATIONS` 选项是否破坏了你的代码；如果是这样，你应该考虑使用不同的压缩级别。
- en: Next, you will discover how to optimize and compress JavaScript modules using
    UglifyJS.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将了解如何使用 UglifyJS 优化和压缩 JavaScript 模块。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to get an exhaustive guide to the Closure Compiler, refer to the online
    reference at [https://developers.google.com/closure/compiler/docs/api-tutorial3](https://developers.google.com/closure/compiler/docs/api-tutorial3)
    or just type `$ java -jar compiler.jar --help` in your command-line tool.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得 Closure Compiler 的全面指南，请参考在线参考 [https://developers.google.com/closure/compiler/docs/api-tutorial3](https://developers.google.com/closure/compiler/docs/api-tutorial3)，或者只需在命令行工具中输入
    `$ java -jar compiler.jar --help`。
- en: UglifyJS2
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UglifyJS2
- en: The **UglifyJS** project became very popular when jQuery started to use it.
    Being used by one of the *de facto* standard JavaScript libraries resulted in
    a lot of feedback to the author, which in turn helped him fix a number of bugs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当 jQuery 开始使用它时，**UglifyJS** 项目变得非常流行。作为 *de facto* 标准JavaScript库之一的使用，导致作者收到了很多反馈，这反过来帮助他修复了大量的错误。
- en: The new version of the project, named **UglifyJS2**, is slower than the previous
    one, but the overall compression results are much better and there are more advanced
    features such as multilevel source maps (basically, it's a way to map a combined/minified
    file back to an unbuilt state) like in the Google Closure Compiler.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的新版本，命名为 **UglifyJS2**，比之前的版本慢，但整体压缩效果要好得多，并且有更多高级功能，例如多级源映射（基本上，这是一种将合并/压缩文件映射回未构建状态的方法），就像在
    Google Closure Compiler 中一样。
- en: 'UglifyJS2 is distributed as a Node.js module. In order to install it, you can
    proceed as with any other Node.js module. Open the command-line tool and use npm
    to install the `uglify-js` module:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: UglifyJS2 以 Node.js 模块的形式分发。为了安装它，你可以像安装任何其他 Node.js 模块一样进行。打开命令行工具并使用 npm 安装
    `uglify-js` 模块：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, compressing your JavaScript files just got a lot easier.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，压缩你的 JavaScript 文件变得容易多了。
- en: Time for action – using UglifyJS
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用 UglifyJS
- en: 'Let''s see how you can get a compressed version of the same files you worked
    on with the Google Closure Compiler:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用与 Google Closure Compiler 一起工作的相同文件获得压缩版本：
- en: Open your command-line tool and go to the sample folder created to test the
    Closure Compiler.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行工具并转到为测试 Closure Compiler 创建的样本文件夹。
- en: 'Type the following command in order to concatenate the JavaScript files and
    to run the UglifyJS2 compressor. For Windows, you can use the `copy` command to
    concatenate the files:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以连接 JavaScript 文件并运行 UglifyJS2 压缩器。对于 Windows，你可以使用 `copy` 命令来连接文件：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open the generated file and take a look at the source code; you will get the
    following JavaScript:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开生成的文件，查看源代码；你会得到以下 JavaScript：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Insert the `script` tag in the HTML page and open it in a browser.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HTML 页面中插入 `script` 标签并在浏览器中打开它。
- en: '*What just happened?*'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: You created a compressed version of two simple JavaScript files. As you can
    see, the output is rather different from the one created with the Closure Compiler.
    One of the main features of UglifyJS2 is that the generated output doesn't break
    the source code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个压缩版本的两个简单的JavaScript文件。如您所见，输出与使用Closure Compiler创建的输出相当不同。UglifyJS2的一个主要特点是生成的输出不会破坏源代码。
- en: For a complete reference, you can check the project page on GitHub at [https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的参考，您可以在GitHub上的项目页面进行检查，链接为[https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2)。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you run UglifyJS2 in order to compress the files created in [Chapter 4](ch04.html
    "Chapter 4. Working with Plugins"), *Working with Plugins*, you will be able to
    run the application as intended.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在[第4章](ch04.html "第4章。使用插件")“使用插件”中运行UglifyJS2以压缩文件，您将能够按预期运行应用程序。
- en: Optimization with RequireJS
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RequireJS进行优化
- en: RequireJS includes an optimization tool named **r.js** that combines related
    scripts together into build layers and minifies them via UglifyJS or the Closure
    Compiler. The tool can be used through Node.js or Java. When using the Closure
    Compiler, it's mandatory to run the tool using Java.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: RequireJS包含一个名为**r.js**的优化工具，该工具将相关的脚本组合到构建层中，并通过UglifyJS或Closure Compiler对其进行压缩。该工具可以通过Node.js或Java使用。当使用Closure
    Compiler时，必须使用Java运行该工具。
- en: The optimizer is better than using a plain concatenation script because it runs
    RequireJS as part of the optimization, so it knows how to load the plugins and
    all the dependencies of the JavaScript modules needed in your application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器比使用普通的连接脚本更好，因为它在优化过程中运行RequireJS，因此知道如何加载插件以及您应用程序中需要的所有JavaScript模块的依赖项。
- en: For an exhaustive guide to r.js, refer to the readme file available on GitHub
    at [https://github.com/jrburke/r.js](https://github.com/jrburke/r.js).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于r.js的全面指南，请参考GitHub上可用的readme文件，链接为[https://github.com/jrburke/r.js](https://github.com/jrburke/r.js)。
- en: Time for action – optimizing JavaScript with RequireJS
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 使用RequireJS优化JavaScript
- en: 'Follow these steps to optimize the source code of your app using Node.js and
    RequireJS:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用Node.js和RequireJS优化您的app的源代码：
- en: 'Install the `requirejs` module using npm from the command-line tool:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用npm从命令行工具安装`requirejs`模块：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Go to the root folder of the app you worked on in the previous chapters, create
    a file named `build.js`, and add to it the build process configuration info (that
    is, the JavaScript folder, the paths to the library used in the project, the name
    of the main file of the app, and the output folder and filename):'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您在前几章中工作的app的根目录，创建一个名为`build.js`的文件，并向其中添加构建过程配置信息（即JavaScript文件夹、项目中使用的库的路径、app的主文件名以及输出文件夹和文件名）：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the command-line tool again and execute the following command in order
    to build the app:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开命令行工具并执行以下命令以构建app：
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open the `index.html` file and change the entry point of your app in the `script`
    tag in the header:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.html`文件并更改header中的`script`标签中您的app的入口点：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open the `index.html` file in a browser.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`index.html`文件。
- en: '*What just happened?*'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: You created a compressed version of the app's JavaScript files minified in a
    single file, specifying the command-line options using a build file. The result
    is that the code of the app is now optimized using UglifyJS2 (the engine that
    works behind the scenes) and it still works perfectly. In order to get a complete
    overview of the build options, refer to the sample build file available on GitHub
    at [https://github.com/jrburke/r.js/blob/master/build/example.build.js](https://github.com/jrburke/r.js/blob/master/build/example.build.js).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个压缩版本的app的JavaScript文件，这些文件被压缩到一个单独的文件中，使用构建文件指定了命令行选项。结果是，app的代码现在使用UglifyJS2（幕后工作的引擎）进行了优化，并且仍然可以完美运行。为了获得完整的构建选项概述，请参考GitHub上可用的示例构建文件，链接为[https://github.com/jrburke/r.js/blob/master/build/example.build.js](https://github.com/jrburke/r.js/blob/master/build/example.build.js)。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you prefer to use the Closure Compiler to compress and optimize the app''s
    JavaScript files, you have to download the binaries of Rhino (an open source implementation
    of JavaScript written entirely in Java) available at [https://developer.mozilla.org/en-US/docs/Rhino/Download_Rhino](https://developer.mozilla.org/en-US/docs/Rhino/Download_Rhino),
    download r.js from the RequireJS website at [http://requirejs.org/docs/download.html#rjs](http://requirejs.org/docs/download.html#rjs),
    add the `optimize: ‘closure''` option to the build file, and execute the following
    command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你更喜欢使用Closure Compiler来压缩和优化应用程序的JavaScript文件，你必须下载Rhino的二进制文件（一个完全用Java编写的JavaScript开源实现），可在[https://developer.mozilla.org/en-US/docs/Rhino/Download_Rhino](https://developer.mozilla.org/en-US/docs/Rhino/Download_Rhino)找到，从RequireJS网站[http://requirejs.org/docs/download.html#rjs](http://requirejs.org/docs/download.html#rjs)下载r.js，在构建文件中添加`optimize:
    ‘closure''`选项，并执行以下命令：'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `classpath` refers to the full path to Rhino and the Closure Compiler.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`classpath`指的是Rhino和Closure Compiler的完整路径。
- en: Comparing compression tools
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩工具比较
- en: 'We have covered three of the most popular compression tools. Each tool has
    its pros and cons. As always, the right tool for you is the one that best fits
    your needs. The following table summarizes the results, in bytes, you can get
    compressing a RequireJS file itself with the tools we just discussed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了三种最受欢迎的压缩工具。每种工具都有其优缺点。一如既往，最适合你的工具是那个最能满足你需求的工具。以下表格总结了使用我们刚才讨论的工具压缩RequireJS文件本身可以得到的压缩结果，单位为字节：
- en: '| File | Original size | Compressor | Size |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 原始大小 | 压缩工具 | 压缩后大小 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| RequireJS | 82944 | UglifyJS2 | 24576 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| RequireJS | 82944 | UglifyJS2 | 24576 |'
- en: '| Google Closure | 13312 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| Google Closure | 13312 |'
- en: '| r.js | 15360 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| r.js | 15360 |'
- en: As you can see, in this example, Google Closure yields the best result, but
    that is not always the case. If you run the same tests on the popular RaphaelJS
    library, you get the best result with Google Closure Compiler instead. The results
    vary depending on the source code writing style; for this reason, there is no
    single best tool to use. I prefer r.js because it can run the compressor engine
    as well as handle the plugins and module dependencies very well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这个例子中，Google Closure产生了最佳结果，但这并不总是如此。如果你在流行的RaphaelJS库上运行相同的测试，你将得到Google
    Closure Compiler的最佳结果。结果取决于源代码的编写风格；因此，没有单一的最好工具可以使用。我更喜欢r.js，因为它不仅可以运行压缩引擎，而且可以很好地处理插件和模块依赖。
- en: JavaScript task runners such as Gulp or Grunt can be used to create tasks to
    link, compress, and concatenate your resources automatically whenever there are
    some changes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript任务运行器，如Gulp或Grunt，可以用来创建任务，在资源有变化时自动链接、压缩和合并资源。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other compression tools you may consider include KJScompress, Bananascript,
    JSMin, ShrinkSafe, and YUI Compressor.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还考虑的其他压缩工具有KJScompress、Bananascript、JSMin、ShrinkSafe和YUI Compressor。
- en: Using template engine compression
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板引擎压缩
- en: When you work on larger HTML projects, it's advisable to use JavaScript templating
    engines and image compressions. When the application needs to be updated frequently
    with data, templating libraries will be of much use. I strongly believe that there
    is no such thing as *the* best JavaScript template engine. Each time you work
    on a project, you have to decide which is the right engine for the job at hand.
    For instance, **Underscore.js** templates are fast and lightweight and if you
    want them already loaded in your app, then it's a good option. When using jQuery,
    the natural choice seems to be **ICanHaz.js** because it returns each template
    as a jQuery object. When you need a more robust template engine, then **Google
    Closure Templates** could be a valid option. For a comparison of templating engines,
    visit [http://garann.github.io/template-chooser/](http://garann.github.io/template-chooser/).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在较大的HTML项目上工作时，建议使用JavaScript模板引擎和图像压缩。当应用程序需要频繁更新数据时，模板库将非常有用。我坚信没有所谓的*最佳*JavaScript模板引擎。每次你开始一个项目时，你必须决定哪个引擎最适合当前任务。例如，**Underscore.js**模板快速且轻量级，如果你想在应用程序中预先加载它们，那么这是一个不错的选择。当使用jQuery时，自然的选择似乎是**ICanHaz.js**，因为它将每个模板作为jQuery对象返回。当你需要一个更健壮的模板引擎时，**Google
    Closure Templates**可能是一个有效的选择。要比较模板引擎，请访问[http://garann.github.io/template-chooser/](http://garann.github.io/template-chooser/)。
- en: In most cases, **Mustache.js** completely fits the needs of an application because
    there is no logic in the templates and because the templates are language-agnostic,
    allowing you to reuse them between frontend and backend. There are several template
    engines based on **Mustache.js**, including **Handlebars.js**, **Hogan.js**, or
    **Pistachio**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，**Mustache.js**完全符合应用程序的需求，因为没有逻辑在模板中，并且模板是语言无关的，允许您在前端和后端之间重用它们。有几个基于**Mustache.js**的模板引擎，包括**Handlebars.js**、**Hogan.js**或**Pistachio**。
- en: Handlebars.js is a superset of Mustache.js that adds some useful features such
    as block expressions, helpers, and more (refer to the online documentation at
    [http://handlebarsjs.com/](http://handlebarsjs.com/) for a complete overview).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars.js是Mustache.js的超集，它添加了一些有用的功能，如块表达式、辅助函数等（有关完整概述，请参阅[http://handlebarsjs.com/](http://handlebarsjs.com/)上的在线文档）。
- en: Hogan.js is a very powerful compiler for Mustache.js templates from Twitter.
    Hogan.js is also delivered with a command-line utility that compiles all the `*.mustache`
    templates stored in a folder; the utility is located in the `hogan.js-template/bin`
    folder. More information about Hogan.js is available on GitHub at [https://github.com/twitter/hogan.js](https://github.com/twitter/hogan.js).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Hogan.js是Twitter的Mustache.js模板的非常强大的编译器。Hogan.js还附带了一个命令行实用程序，该实用程序可以编译存储在文件夹中的所有`*.mustache`模板；实用程序位于`hogan.js-template/bin`文件夹中。有关Hogan.js的更多信息，请访问GitHub上的[https://github.com/twitter/hogan.js](https://github.com/twitter/hogan.js)。
- en: Pistachio is not just another JavaScript template engine based on Mustache.js.
    Its package contains a pure JavaScript compiler that compiles templates into self-contained
    JavaScript functions that can be used in every JavaScript environment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Pistachio不仅仅是一个基于Mustache.js的JavaScript模板引擎。它的包包含一个纯JavaScript编译器，可以将模板编译成自包含的JavaScript函数，这些函数可以在任何JavaScript环境中使用。
- en: 'In order to start using Pistachio''s compiler, you can install it as a Node.js
    module:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用Pistachio编译器，您可以将它作为Node.js模块安装：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once installed, you can compile a template by typing `pistachio` followed by
    the path to the file you want compile.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过输入`pistachio`后跟您想要编译的文件路径来编译一个模板。
- en: The interesting features of Pistachio's compiler are the capability to compile
    a template as an AMD module or CommonJS compatible module and the possibility
    to create the output as a jQuery object. A template compiled with Pistachio is
    still dynamic and can be compressed even more using the Google Closure Compiler.
    For a complete reference on Pistachio, go to [https://npmjs.org/package/pistachio](https://npmjs.org/package/pistachio).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Pistachio编译器的有趣特性是能够将模板编译为AMD模块或CommonJS兼容模块，并且可以将输出创建为jQuery对象。使用Pistachio编译的模板仍然是动态的，并且可以使用Google
    Closure Compiler进一步压缩。有关Pistachio的完整参考，请访问[https://npmjs.org/package/pistachio](https://npmjs.org/package/pistachio)。
- en: A compressed template speeds up your application rendering because you can cache
    it as a JavaScript function and avoid continuously loading and unloading it with
    an **AJAX** request (with some performance penalties involved) when the app is
    in use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩模板可以加快您的应用程序渲染速度，因为您可以将它缓存为JavaScript函数，并在应用程序使用时避免使用**AJAX**请求（涉及一些性能惩罚）不断加载和卸载它。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you want to include multiple templates in a file, you can simply store them
    in `script` tags, assign an ID to each tag, and then use the `getElementByID()`
    document object method and the `innerHTML` HTMLElement object property to render
    it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在文件中包含多个模板，您只需将它们存储在`script`标签中，为每个标签分配一个ID，然后使用`getElementByID()`文档对象方法和`innerHTML`
    HTMLElement对象属性来渲染它：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Time for action – compiling a template using Pistachio
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用Pistachio编译模板
- en: 'Create a new template file and eventually compress it using Pistachio. Follow
    the given steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的模板文件，并最终使用Pistachio将其压缩。按照以下步骤操作：
- en: Open your command-line tool and move to the folders containing the template
    files.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的命令行工具并移动到包含模板文件的文件夹中。
- en: 'Type the `pistachio` command and specify the name of the output file and the
    file to compile:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`pistachio`命令并指定输出文件名和要编译的文件名：
- en: '[PRE16]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a build file named, for instance, `template-build.js`, for the existing
    template to use when compressing the file with UglifyJS2, specifying the template
    name and the desired output filename:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为现有模板创建一个名为，例如，`template-build.js`的构建文件，以便在压缩文件时使用UglifyJS2，指定模板名称和所需的输出文件名：
- en: '[PRE17]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the r.js Node module from the command-line tool:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行工具运行r.js Node模块：
- en: '[PRE18]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Open the file and check its syntax and size.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件并检查其语法和大小。
- en: '*What just happened?*'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: You created a compressed version of the template file that is stored in a variable.
    You can now request it in the modules of the app and avoid any unnecessary XMLHttpRequest.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个存储在变量中的模板文件的压缩版本。现在您可以在应用的模块中请求它，从而避免任何不必要的XMLHttpRequest。
- en: This technique is most beneficial when working with pretty big and complex templates.
    Throughout this book, you will discover some advanced template caching techniques.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在处理相当大且复杂的模板时最有益。在这本书中，您将发现一些高级模板缓存技术。
- en: Creating fluid, multiple app views
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流畅的多个应用视图
- en: One of the strengths of PhoneGap is that the app UI and logic are built upon
    web standards. A mobile app is made up of several views that allow the user to
    interact with its core features. As for a web app, when working with PhoneGap,
    you can think of a view as a web page or a fragment of a web page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap的一个优点是，应用UI和逻辑建立在Web标准之上。一个移动应用由几个视图组成，允许用户与其核心功能交互。至于Web应用，当使用PhoneGap时，您可以将视图视为一个网页或网页的一部分。
- en: You can create multiple views in your app using different HTML pages or dynamically
    changing the markup of a single HTML page. The first approach is usually known
    as **multipage pattern**; the second one is known as **single-page pattern**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的应用中使用不同的HTML页面或动态更改单个HTML页面的标记来创建多个视图。第一种方法通常被称为**多页模式**；第二种方法被称为**单页模式**。
- en: Generally speaking, the multipage pattern is best suited to applications that
    mostly comprise static content or applications that rely mostly on the server
    for the business logic. When most of the content is static, you can package it
    using PhoneGap and deliver it as an app. When the business logic is defined on
    the server, you can think of the client as the presentation layer of your app
    and rely on a good mobile connection to make it available to users. In both cases,
    your client-side code should be pretty simple and easy to maintain.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，多页模式最适合主要包含静态内容或主要依赖服务器进行业务逻辑的应用程序。当大部分内容是静态的，您可以使用PhoneGap对其进行打包，并以应用的形式交付。当业务逻辑在服务器上定义时，您可以认为客户端是您应用的表示层，并依赖于良好的移动连接来使其对用户可用。在这两种情况下，您的客户端代码应该相当简单且易于维护。
- en: The multipage approach has some disadvantages. For instance, when the user navigates
    from one page to the next, the browser has to reload and parse all the JavaScript
    associated with the new page. Also, because the JavaScript code is reloaded, all
    application state is lost if your app does not use other techniques such as local
    storage or the HTML5 history state object to maintain it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 多页方法有一些缺点。例如，当用户从一个页面导航到下一个页面时，浏览器必须重新加载并解析与新页面相关联的所有JavaScript。此外，由于JavaScript代码被重新加载，如果您的应用没有使用其他技术（如本地存储或HTML5历史状态对象）来维护它，则所有应用程序状态都会丢失。
- en: The single-page pattern overcomes the disadvantages associated with the multipage
    approach. The PhoneGap and app JavaScript code is loaded just once, removing the
    need to pass application state from one page to the next. The disadvantage of
    this approach is an increased complexity of the JavaScript that contains most
    of the business logic and that it is required to update the UI when navigation
    occurs. Single-page applications are best written using the MVC design pattern
    and libraries such as AngularJS can be used.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 单页模式克服了与多页方法相关的缺点。PhoneGap和app JavaScript代码只需加载一次，从而消除了在页面之间传递应用程序状态的需求。这种方法的缺点是包含大部分业务逻辑的JavaScript变得更加复杂，并且需要在导航发生时更新UI。单页应用程序最好使用MVC设计模式，并可以使用如AngularJS之类的库。
- en: The most important difference between the two patterns is that with the single-page
    pattern, the PhoneGap JavaScript bridge is loaded once. There's a noticeable pause
    when it's loaded due to the fact that the link between the JavaScript APIs and
    the native counterparts is created. When the app loads the PhoneGap JavaScript
    API once, the UI appears more responsive and the user experience is improved.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式之间最重要的区别在于，使用单页模式时，PhoneGap JavaScript桥接器只需加载一次。由于JavaScript API与本地对应项之间的链接被创建，加载时会有一段明显的暂停。当应用加载一次PhoneGap
    JavaScript API时，UI看起来更加响应，用户体验得到改善。
- en: Using hardware-accelerated transitions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用硬件加速的过渡
- en: Much has been said about the use of **graphics processing unit** (**GPU**) hardware
    acceleration in smartphone and tablet web browsers. The general scheme is to offload
    tasks that would otherwise be calculated by the main CPU to the GPU in your computer's
    graphics adapter. (For a very detailed article to better understand hardware-accelerated
    transitions, go to [https://dev.sencha.com/blog/understanding-hardware-acceleration-on-mobile-browsers](https://dev.sencha.com/blog/understanding-hardware-acceleration-on-mobile-browsers).)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在智能手机和平板电脑的 Web 浏览器中使用 **图形处理单元**（**GPU**）硬件加速的讨论已经很多了。一般方案是将原本由主 CPU 计算的任务卸载到计算机显卡中的
    GPU 上。（为了更好地理解硬件加速的过渡，请参阅 [https://dev.sencha.com/blog/understanding-hardware-acceleration-on-mobile-browsers](https://dev.sencha.com/blog/understanding-hardware-acceleration-on-mobile-browsers)
    的详细文章。）
- en: 'GPU can accelerate the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 可以加速以下操作：
- en: The general layout compositing
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用布局合成
- en: All the CSS transitions
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 CSS 过渡
- en: The CSS 3D transformations
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 3D 变换
- en: All the canvas drawing operations
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有画布绘图操作
- en: You can create smooth animations with the new CSS transitions by pretty easily
    defining them in your style sheets or you can rely on external libraries.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过轻松地在样式表中定义它们或依赖外部库来使用新的 CSS 过渡创建平滑的动画。
- en: CSS transitions are supported in the latest versions of Firefox, Safari, and
    Chrome. They're supported in IE 10 and above. If CSS animations aren't supported
    in a given browser, then the properties will be applied instantly, gracefully
    degrading. There are several techniques to handle a CSS transition. I will use
    **Alice.js**, which is an interesting JavaScript library that allows you to execute
    hardware-accelerated transitions in your app.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 过渡在最新的 Firefox、Safari 和 Chrome 版本中得到支持。它们在 IE 10 及以上版本中得到支持。如果某个浏览器不支持 CSS
    动画，则属性将立即应用，优雅地降级。处理 CSS 过渡有几种技术。我将使用 **Alice.js**，这是一个有趣的 JavaScript 库，允许你在你的应用程序中执行硬件加速的过渡。
- en: AliceJS
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AliceJS
- en: AliceJS (A Lightweight Independent CSS Engine) is a JavaScript library that
    leverages hardware-accelerated capabilities of browsers in order to generate visual
    effects. One of the strengths of the library is that it doesn't rely on other
    libraries and that it's self-contained in a single JavaScript file (for a complete
    reference and some interesting examples, refer to the official website at [http://blackberry.github.com/Alice/demos/index.html](http://blackberry.github.com/Alice/demos/index.html).)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: AliceJS（轻量级独立 CSS 引擎）是一个 JavaScript 库，它利用浏览器硬件加速功能来生成视觉效果。该库的一个优点是它不依赖于其他库，并且包含在一个单独的
    JavaScript 文件中（对于完整参考和一些有趣示例，请参阅官方网站 [http://blackberry.github.com/Alice/demos/index.html](http://blackberry.github.com/Alice/demos/index.html)）。
- en: 'Each time you want to create a transition with AliceJS, you have to set up
    a configuration object. This object varies depending on the effect or plugin you
    are using. However, some configuration properties are shared between all the effects
    and plugins, including the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想使用 AliceJS 创建过渡时，你必须设置一个配置对象。这个对象根据你使用的效果或插件而变化。然而，一些配置属性在所有效果和插件之间是共享的，包括以下内容：
- en: '`elems`: This is the target element(s) or node'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elems`：这是目标元素或节点'
- en: '`rotate`: This is the rotation angle in degrees'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate`：这是旋转角度（以度为单位）'
- en: '`perspectiveOrigin`: This is the anchor point, which can be `top-left`, `top-center`,
    `top-right`, `center`, and so on, or the explicit coordinates in percentage of
    the entire size of `div`, for example, `{x: 200, y: 200}`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perspectiveOrigin`：这是锚点，可以是 `top-left`、`top-center`、`top-right`、`center` 等，或者是
    `div` 整个大小的百分比坐标，例如，`{x: 200, y: 200}`'
- en: '`duration`: This is the duration of the effect'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration`：这是效果持续时间'
- en: '`timing`: This is the easing function as per standard CSS specs'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timing`：这是按照标准 CSS 规范的缓动函数'
- en: '`delay`: This determines how long before the animation starts'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`：这决定了动画开始前的延迟时间'
- en: '`iteration`: This is the number of iterations'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iteration`：这是迭代次数'
- en: '`direction`: This specifies whether the animation should be played in reverse
    mode'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction`：这指定了动画是否应该以反向模式播放'
- en: '`playstate`: This is either `running` or `paused`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playstate`：这是 `running` 或 `paused`'
- en: 'In this way, it''s possible to easily configure a CSS-based animation without
    any additional required know-how. There are three plugins for AliceJS and they
    include a few animation types. The following is the simple code from the Alice
    documentation to create a wobble effect by using the Cheshire plugin. So, we need
    to include the core and the plugin file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，可以轻松地配置基于CSS的动画，而无需任何额外的知识。AliceJS有三个插件，包括几种动画类型。以下是从Alice文档中创建摆动效果的Cheshire插件的简单代码。因此，我们需要包含核心和插件文件：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the code is pretty simple; for a complete overview, please refer
    to the online documentation of AliceJS.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，代码相当简单；要获得完整概述，请参阅AliceJS的在线文档。
- en: Porting web applications
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口Web应用程序
- en: We know that PhoneGap/Cordova allows you to have a common code base for all
    mobile platforms. PhoneGap helps to package your HTML, CSS, and JavaScript code
    so that it can be installed in a mobile device and can be used as an app in different
    types of platforms such as Android, iOS, Firefox, and so on. It's not a surprise
    now. However, did you know that, with some planning, you can convert your existing
    web application to a hybrid mobile app?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道PhoneGap/Cordova允许你为所有移动平台拥有一个共同的代码库。PhoneGap帮助你打包HTML、CSS和JavaScript代码，以便可以在移动设备上安装，并可以作为不同类型的平台（如Android、iOS、Firefox等）上的应用程序使用。这并不令人惊讶。然而，你知道吗，通过一些规划，你可以将现有的Web应用程序转换为混合移动应用程序？
- en: If you are a web developer, you can even create a mobile app with your existing
    knowledge of web development and can sell in app marketplaces. You can save a
    lot of time and money by avoiding redevelopment.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名Web开发者，你甚至可以使用你对Web开发的现有知识来创建移动应用程序，并在应用市场中销售。通过避免重新开发，你可以节省大量时间和金钱。
- en: PhoneGap/Cordova provides a lot of APIs to access device features such as the
    camera, accelerometer, and more. In this way, PhoneGap gives developers the ability
    to create a full-featured mobile app using web technologies. However, you can't
    use such device-related APIs in your web application. So, you have to design your
    code base so that it provides modularity.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: PhoneGap/Cordova提供了许多API来访问设备功能，如相机、加速度计等。这样，PhoneGap为开发者提供了使用Web技术创建功能齐全的移动应用程序的能力。然而，你无法在你的Web应用程序中使用这些与设备相关的API。因此，你必须设计你的代码库，使其提供模块化。
- en: The way a user interacts with an Android app is different from interacting with
    an iOS app and so on. So, there has to be careful planning on the design factors
    of the app. You might need tweaks on each platform to have a better user experience.
    You can use responsive design and media queries to target multiple screen sizes,
    devices, and display destinations (standard or high-density).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与Android应用程序交互的方式与与iOS应用程序交互的方式不同，等等。因此，在应用程序的设计因素上必须进行仔细的规划。你可能需要对每个平台进行微调以获得更好的用户体验。你可以使用响应式设计和媒体查询来针对多个屏幕尺寸、设备和显示目标（标准或高密度）。
- en: Providing a robust design for a common code base is beyond the scope of this
    book. However, there are lots of success stories of porting web applications to
    hybrid mobile applications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为共同的代码库提供稳健的设计超出了本书的范围。然而，有许多将Web应用程序移植到混合移动应用程序的成功案例。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to optimize the source code of your app and
    also how to compress the templates that you use; we also saw various code compression
    methods. With this, we have completed our learning and it's time to put them to
    work. In the next chapter, we will create an app to demonstrate all our knowledge
    of PhoneGap.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何优化应用程序的源代码，以及如何压缩你使用的模板；我们还看到了各种代码压缩方法。通过这些，我们已经完成了学习，现在是时候将它们付诸实践了。在下一章中，我们将创建一个应用程序来展示我们所有的PhoneGap知识。
