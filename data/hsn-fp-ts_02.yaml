- en: Mastering Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握函数
- en: In [Chapter 1](65bf43e0-dba4-414a-b6e7-3c6f38581858.xhtml)<q>, Functional Programming
    Fundamentals</q>, we learned about some of the most fundamental functional programming
    concepts. Functions are one of the fundamental building blocks of any TypeScript
    application, and they are powerful enough to warrant an entire chapter being dedicated
    to them in order to explore their potential.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](65bf43e0-dba4-414a-b6e7-3c6f38581858.xhtml)<q>《函数式编程基础</q>中，我们学习了函数式编程的一些最基本的概念。函数是任何TypeScript应用程序的基本构建块之一，它们足够强大，以至于需要整章内容来探讨它们的潜力。
- en: 'In this chapter, we are going to master the usage of functions. The chapter
    starts with a quick recap of a number of basic concepts and then moves on to some
    less commonly known function features and use cases:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将掌握函数的使用方法。本章首先快速回顾了多个基本概念，然后转向一些不太常见的函数特性和用例：
- en: '**Function types**:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数类型**：'
- en: Function declarations and function expressions
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明和函数表达式
- en: Named and anonymous functions
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名和匿名函数
- en: '**Working with parameters**:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理参数**：'
- en: Functions with optional parameters
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有可选参数的函数
- en: Functions with default parameters
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有默认参数的函数
- en: Functions with rest parameters
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有剩余参数的函数
- en: Function overloading
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载
- en: Specialized overloading signature
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用重载签名
- en: Function scope
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作用域
- en: Immediately-invoked functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即调用的函数
- en: Tag functions and tagged templates
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签函数和标签模板
- en: Function types
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'We already know that it is possible to explicitly declare the type of an element
    in our application by using optional type annotations:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，可以通过使用可选的类型注解显式地声明应用程序中元素的类型：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous function, we specified the type of parameter `name` (`string`)
    and its return type (`string`). Sometimes, we will need to specify the types of
    the function, as opposed to specifying the types of its components (arguments
    or returned value). Let''s look at an example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们指定了参数`name`（`string`）的类型及其返回类型（`string`）。有时，我们需要指定函数的类型，而不是指定其组件（参数或返回值）的类型。让我们看一个例子：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, we have declared the `greetUnnamed` variable and its
    type. The `greetUnnamed` type is a function type that takes a string variable
    called `name` as its only parameter and returns a string after being invoked.
    After declaring the variable, a function, whose type must be equal to the variable
    type, is assigned to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了`greetUnnamed`变量及其类型。`greetUnnamed`类型是一个函数类型，它接受一个名为`name`的字符串变量作为其唯一参数，并在调用后返回一个字符串。在声明变量之后，分配给它的函数的类型必须与变量类型相等。
- en: 'We can also declare the `greetUnnamed` type and assign a function to it in
    the same line, rather than declaring it in two separate lines, as we did in the
    previous example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在相同的行中声明`greetUnnamed`类型并将其分配给一个函数，而不是像上一个例子那样在两行中分别声明：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just like in the previous example, the preceding code snippet also declares
    a variable, `greetUnnamed`, and its type. `greetUnnamed`  is a function type that
    takes a string variable called `name` as its only parameter and will return a
    string after being invoked. We will assign a function to this variable in the
    same line in which it is declared. The type of the assigned function must match
    the variable type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在先前的例子中一样，前面的代码片段也声明了一个变量`greetUnnamed`及其类型。`greetUnnamed`是一个函数类型，它接受一个名为`name`的字符串变量作为其唯一参数，并在调用后返回一个字符串。我们将在声明变量的同一行中分配一个函数给这个变量。分配的函数的类型必须与变量类型匹配。
- en: In the preceding example, we have declared the type of the `greetUnnamed`  variable
    and then assigned a function as its value. The type of function can be inferred
    from the assigned function and, for this reason, it is unnecessary to add a redundant
    type annotation. We have done this to facilitate your understanding of this section,
    but it is important to mention that adding redundant type annotations can make
    our code harder to read, and is considered a bad practice.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了`greetUnnamed`变量的类型，并将其值设为一个函数。函数的类型可以从分配的函数中推断出来，因此没有必要添加冗余的类型注解。我们这样做是为了便于你理解这一部分，但重要的是要提到，添加冗余的类型注解可能会使我们的代码更难阅读，并且被认为是一种不良实践。
- en: Named and anonymous functions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名和匿名函数
- en: 'Just as in JavaScript, TypeScript functions can be created either as a named
    function or as an anonymous function, which allows us to choose the most appropriate
    approach for an application, whether we are building a list of functions in an
    API or a one-off function to hand over to another function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如JavaScript一样，TypeScript函数可以创建为命名函数或匿名函数，这使我们能够为应用程序选择最合适的方法，无论是我们在API中构建函数列表，还是传递给另一个函数的单次函数：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see in the preceding code snippet, in TypeScript, we can add types
    to each of the parameters and then to the function itself to add a `return` type.
    TypeScript can infer the `return` type by looking at the `return` statements,
    so we can also optionally leave this off in many cases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个代码片段所示，在TypeScript中，我们可以给每个参数以及函数本身添加类型，然后添加`return`类型。TypeScript可以通过查看`return`语句来推断`return`类型，因此我们也可以在许多情况下省略它。
- en: 'There is an alternative syntax for functions that use the `=>` operator after
    the `return` type and don''t use the `function` keyword:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`return`类型后跟`=>`运算符且不使用`function`关键字的函数，存在一种替代语法：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have learned about this alternative syntax, we can return to the
    previous example in which we were assigning an anonymous function to the `greet` variable.
    We can now add type annotations to the `greet` variable to match the `anonymous`
    function signature:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这种替代语法，我们可以回到之前的例子，其中我们将匿名函数赋值给`greet`变量。现在我们可以给`greet`变量添加类型注解，以匹配`匿名`函数签名：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Keep in mind that the arrow function (`=>`) syntax changes the way the `this` operator
    works when working with classes. We will learn more about this in upcoming chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，箭头函数（`=>`）语法改变了与类一起使用时`this`运算符的工作方式。我们将在接下来的章节中了解更多关于这一点。
- en: 'The previous code snippet demonstrates how to use type annotations to force
    a variable to be a function with a specific signature. These kinds of annotation
    are commonly used when we annotate a `callback` (a function used as an argument
    of another function):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段展示了如何使用类型注解来强制一个变量成为一个具有特定签名的函数。这类注解在我们对`callback`（作为另一个函数参数使用的函数）进行注解时常用：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we are declaring a function named `add` that takes
    two numbers and a `callback` as a function. The type annotations will force the
    `callback` to return `void` and take a number as its only argument.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子中，我们正在声明一个名为`add`的函数，它接受两个数字和一个作为函数的`callback`。类型注解将强制`callback`返回`void`并仅接受一个数字作为其唯一参数。
- en: Function declarations and function expressions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数声明和函数表达式
- en: In the preceding section, we introduced the possibility of declaring functions
    with (a named function) or without (an unnamed or anonymous function) explicitly
    indicating their name, but we didn't mention that we were also using two different
    types of function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了声明带有（命名函数）或没有（未命名或匿名函数）显式指定其名称的函数的可能性，但我们没有提到我们也在使用两种不同类型的函数。
- en: 'In the following example, the named function, `greetNamed`, is a **function
    declaration** while `greetUnnamed` is a **function expression**. For the time
    being, please ignore the first two lines, which contain two `console.log` statements:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，命名函数`greetNamed`是一个**函数声明**，而`greetUnnamed`是一个**函数表达式**。目前，请忽略前两行，它们包含两个`console.log`语句：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We might think that the preceding functions are identical, but they behave differently.
    The JavaScript interpreter can evaluate a function declaration as it is being
    parsed. On the other hand, the `function` expression is part of an assignment
    and will not be evaluated until the assignment has been completed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为前述函数是相同的，但它们的行为不同。JavaScript解释器可以在解析过程中评估函数声明。另一方面，`function`表达式是赋值语句的一部分，只有在赋值完成后才会被评估。
- en: The primary cause of the different behavior of these functions is a process
    known as variable **hoisting**. We will learn more about the variable hoisting
    process in the *Function scope and hoisting *section later in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数行为不同的主要原因是称为变量**提升**的过程。我们将在本章后面的*函数作用域和提升*部分了解更多关于变量提升过程的内容。
- en: Fortunately, the TypeScript compiler can detect this error and throw a compilation-time
    error. However, if we compile the preceding TypeScript code snippet into JavaScript,
    ignore the compilation errors, and try to execute it in a web browser, we will
    observe that the first `console.log` call works. This is the case because JavaScript
    knows about the declaration function and can parse it before the program is executed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，TypeScript编译器可以检测到这个错误并在编译时抛出错误。然而，如果我们将前面的TypeScript代码片段编译成JavaScript，忽略编译错误，并在网页浏览器中尝试执行它，我们会观察到第一个`console.log`调用是有效的。这是因为JavaScript了解声明函数，可以在程序执行之前解析它。
- en: However, the second alert statement will throw an exception, to indicate that
    `greetUnnamed` is not a function. The exception is thrown because the `greetUnnamed`
    assignment must be completed before the function can be evaluated.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个警告语句将抛出异常，以表明`greetUnnamed`不是一个函数。异常抛出是因为`greetUnnamed`的赋值必须在函数评估之前完成。
- en: Working with function parameters
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理函数参数
- en: In this section, we are going to learn how to work with function parameters
    in multiple scenarios, including `optional` parameters, `default` parameters,
    and `rest` parameters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在多种场景下处理函数参数，包括`可选`参数、`默认`参数和`剩余`参数。
- en: Trailing commas in function arguments
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数中的尾随逗号
- en: Trailing commas are commas that are used after the final argument of a function.
    Using a comma after the last parameter of a function can be useful because it
    is very common to forget a comma when we modify an existing function by adding
    additional parameters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尾随逗号是用于函数最后一个参数之后的逗号。在函数的最后一个参数之后使用逗号可能很有用，因为当我们通过添加额外的参数修改现有函数时，很容易忘记添加逗号。
- en: 'For example, the following function only takes one parameter and doesn''t use
    trailing commas:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数只接受一个参数，并且没有使用尾随逗号：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Some time after the initial implementation, we might be required to add a parameter
    to the previous function. A common mistake is to declare the new parameter and
    forget to add a comma after the first parameter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始实现之后的一段时间，我们可能需要向之前的函数添加一个参数。一个常见的错误是在声明新参数时忘记在第一个参数后添加逗号：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using a trailing comma in the first version of the function could have helped
    us to prevent this common mistake:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的第一个版本中使用尾随逗号可能有助于我们防止这种常见的错误：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using a trailing comma eliminates the possibility of forgetting the comma when
    adding a new argument:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尾随逗号可以消除在添加新参数时忘记逗号的可能：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: TypeScript will throw an error if we forget a comma, so trailing commas are
    not needed as much as they are when working with JavaScript. Trailing commas are
    optional, but using them is considered good practice by many JavaScript and TypeScript
    engineers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript会抛出错误，如果我们忘记添加逗号，因此尾随逗号不像在处理JavaScript时那样必要。尾随逗号是可选的，但许多JavaScript和TypeScript工程师认为使用它们是良好的实践。
- en: Functions with optional parameters
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有可选参数的函数
- en: 'Unlike JavaScript, the TypeScript compiler will throw an error if we attempt
    to invoke a function without providing the exact number and types of parameters
    that its signature declares. Let''s look at a code sample to demonstrate it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与JavaScript不同，如果我们尝试调用一个函数而没有提供其签名声明的确切参数数量和类型，TypeScript编译器将抛出错误。让我们通过一个代码示例来演示这一点：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding function is called `add` and will take three numbers as parameters,
    named `foo`, `bar`, and `foobar`. If we attempt to invoke this function without
    providing exactly three numbers, we will get a compilation error indicating that
    the supplied parameters do not match the function''s signature:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数被命名为`add`，将接受三个数字作为参数，分别命名为`foo`、`bar`和`foobar`。如果我们尝试调用此函数而不提供恰好三个数字，我们将得到一个编译错误，表明提供的参数与函数的签名不匹配：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are scenarios in which we might want to be able to call the function without
    providing all of its arguments. TypeScript features optional parameters in functions
    to help us to increase the flexibility of our functions and overcome such scenarios.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们可能希望能够在不提供所有参数的情况下调用函数。TypeScript通过在函数中提供可选参数来帮助我们增加函数的灵活性并克服此类场景。
- en: 'We can indicate to the TypeScript compiler that we want a function''s parameter
    to be optional by appending the character `?` to its name. Let''s update the previous
    function to transform the required parameter, `foobar`, into an optional parameter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在参数名称后附加字符 `?` 来告诉 TypeScript 编译器我们希望函数的参数是可选的。让我们更新前面的函数，将必需参数 `foobar`
    转换为可选参数：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note how we have changed the `foobar` parameter name into `foobar?` and are
    checking the `foobar` type inside the function to identify whether the parameter
    was supplied as an argument to the function. After implementing these changes,
    the TypeScript compiler will allow us to invoke the function without errors when
    we supply two or three arguments to it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将 `foobar` 参数名称更改为 `foobar?` 并在函数内部检查 `foobar` 类型，以确定参数是否作为参数传递给函数。在实施这些更改后，TypeScript
    编译器将允许我们在向函数提供两个或三个参数时无错误地调用它：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is important to note that the optional parameters must always be located
    after the requisite parameters in the function's parameter list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，可选参数必须始终位于函数参数列表中的必需参数之后。
- en: Functions with default parameters
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有默认参数的函数
- en: When a function has some optional parameters, we must check whether an argument
    has been passed to the function (just like we did in the previous example) to
    prevent potential errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有一些可选参数时，我们必须检查是否向函数传递了参数（就像我们在上一个示例中所做的那样），以防止潜在的错误。
- en: 'There are a number of scenarios in which it would be more useful to provide
    a default value for a parameter when it is not supplied than to make it an optional
    parameter. Let''s rewrite the `add` function (from the previous section) using
    the inline `if` structure:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多场景，在未提供参数时为参数提供默认值比将其作为可选参数更有用。让我们使用内联 `if` 结构重写前面的 `add` 函数（来自上一节）：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is nothing wrong with the preceding function, but we can improve its
    readability by providing a default value for the `foobar` parameter instead of
    using an `optional` parameter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数没有问题，但我们可以通过为 `foobar` 参数提供一个默认值来提高其可读性，而不是使用可选参数：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To indicate that a `function` parameter is optional, we need to provide a default
    value using the `=` operator when declaring the function''s signature. After compiling
    the preceding examples, the TypeScript compiler will generate an `if` statement
    in the JavaScript output to set a default value for the `foobar` parameter if
    it is not passed as an argument to the `function`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个 `function` 参数是可选的，我们需要在声明函数签名时使用 `=` 运算符提供一个默认值。在编译前面的示例后，TypeScript 编译器将在
    JavaScript 输出中生成一个 `if` 语句，以设置 `foobar` 参数的默认值，如果它没有作为参数传递给 `function`：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is great because the TypeScript compiler generated the code required to
    prevent potential runtime errors for us.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为 TypeScript 编译器为我们生成了防止潜在运行时错误的代码。
- en: 'The `void 0` parameter is used by the TypeScript compiler to check whether
    a variable is equal to undefined. While most developers use the `undefined` variable
    to perform this kind of check, most compilers use `void 0` because it will always
    evaluate as undefined. Checking against `undefined` is less secure because its
    value could have been modified, as demonstrated by the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器使用 `void 0` 参数来检查一个变量是否等于 `undefined`。虽然大多数开发者使用 `undefined` 变量来进行这种检查，但大多数编译器使用
    `void 0`，因为它始终评估为 `undefined`。与 `undefined` 进行比较的安全性较低，因为其值可能已被修改，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Just like `optional` parameters, `default` parameters must always be located
    after any required parameters in the function's parameter list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像可选参数一样，默认参数必须始终位于函数参数列表中的任何必需参数之后。
- en: Functions with rest parameters
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有剩余参数的函数
- en: 'We have learned how to use `optional` and `default` parameters to increase
    the number of ways that we can invoke a function. Let''s return to the previous
    example one more time:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用可选和默认参数来增加调用函数的方式。让我们再次回到前面的例子：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have learned how to invoke the `add` function with two or three parameters,
    but what if we wanted to allow other developers to pass four or five parameters
    to our function? We would have to add two extra `default` or `optional` parameters.
    And what if we wanted to allow them to pass as many parameters as they need? The
    solution to this possible scenario is the use of `rest` parameters. The `rest`
    parameter syntax allows us to represent an indefinite number of arguments as an
    array:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用两个或三个参数调用 `add` 函数，但如果我们想允许其他开发者向我们的函数传递四个或五个参数怎么办？我们可能需要添加两个额外的
    `default` 或 `optional` 参数。如果我们想允许他们传递所需的所有参数怎么办？解决这种可能场景的方法是使用 `rest` 参数。`rest`
    参数语法允许我们将不定数量的参数表示为数组：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see in the preceding code snippet, we have replaced the `function`
    parameters `foo`, `bar`, and `foobar`, with just one parameter named `foo`. Note
    that the name of the parameter `foo` is preceded by an ellipsis (a set of three
    periods—not the actual ellipsis character). A `rest` parameter must be of an array
    type, or we will get a compilation error. We can now invoke the `add` function
    with as many parameters as we need:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们将 `function` 参数 `foo`、`bar` 和 `foobar` 替换为名为 `foo` 的单个参数。请注意，参数
    `foo` 的名称前面有一个省略号（一组三个点，而不是实际的省略号字符）。`rest` 参数必须是数组类型，否则我们将得到编译错误。现在我们可以使用所需数量的参数调用
    `add` 函数：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although there is no specific limit in the theoretical maximum number of arguments
    that a function can take, there are, of course, practical limits. These limits
    are entirely implementation-dependent and, most likely, will also depend exactly
    on how we are calling the function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在理论最大参数数量上没有具体限制，但当然存在实际限制。这些限制完全取决于实现，并且很可能也取决于我们如何调用函数。
- en: JavaScript functions have a built-in object called the `arguments` object. This
    object is available as a local variable named arguments. The `arguments` variable
    contains an object such as an array, which includes the arguments used when the
    function was invoked.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 函数有一个内置对象，称为 `arguments` 对象。此对象作为名为 `arguments` 的局部变量可用。`arguments`
    变量包含一个对象，类似于数组，其中包含函数被调用时使用的参数。
- en: The `arguments` object exposes some of the methods and properties provided by
    a standard array, but not all of them. Refer to the complete reference at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)
    to learn more about its peculiarities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments` 对象暴露了标准数组提供的一些方法和属性，但并非全部。有关其特性的更多信息，请参阅完整参考文档 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)。'
- en: 'If we examine the JavaScript output, we will notice that TypeScript iterates
    the `arguments` object to add the values to the `foo` variable:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 JavaScript 输出，我们会注意到 TypeScript 会迭代 `arguments` 对象，将值添加到 `foo` 变量中：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can argue that this is an extra, unnecessary iteration over the function''s
    parameters. Even though it is hard to imagine this further iteration becoming
    a performance issue, if you think that this could be a problem in terms of the
    performance of your application, you may want to consider avoiding the use of
    `rest` parameters and use an array as the only parameter of the function instead:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以争论这是对函数参数的额外、不必要的迭代。尽管很难想象这种进一步的迭代会成为性能问题，但如果您认为这可能会影响您应用程序的性能，您可能希望考虑避免使用
    `rest` 参数，而是将数组作为函数的唯一参数：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding function takes an array of numbers as its only parameter. The
    invocation API will be a little bit different from the `rest` parameters, but
    we will effectively avoid the extra iteration over the function''s argument list:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数仅接受一个数字数组作为其唯一参数。调用 API 将与 `rest` 参数略有不同，但我们将有效地避免对函数参数列表的额外迭代：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following table summarizes the parameter-related features that we have
    explored in this section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了本节中我们探索的与参数相关的功能：
- en: '| **Name** | **Operator** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **操作符** | **描述** |'
- en: '| Trailing commas | `,` | Used to facilitate adding additional parameters to
    an existing function at a later time. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 末尾逗号 | `,` | 用于便于在以后的时间向现有函数添加额外的参数。 |'
- en: '| Optional parameters | `?` | Used to describe optional arguments. When the
    argument is missed, the value of the parameter is `undefined`. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 可选参数 | `?` | 用于描述可选参数。当参数缺失时，参数的值是 `undefined`。|'
- en: '| Default parameters | `=` | Used to describe optional arguments. When the
    argument is missed, the value of the parameter takes a default value. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 默认参数 | `=` | 用于描述可选参数。当参数缺失时，参数的值采用默认值。|'
- en: '| Rest parameters | `...` | Used to describe functions with an unknown number
    of arguments. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 可变参数 | `...` | 用于描述具有未知数量参数的函数。|'
- en: In the following section, we are going to learn about function overloading.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于函数重载的内容。
- en: Function overloading
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数重载
- en: 'Function, or method, overloading is the ability to create multiple methods
    with the same name and a different number of parameters or types. In TypeScript,
    we can overload a function by specifying all function signatures (known as **overload
    signatures**) of a function, followed by a signature (known as the **implementation
    signature**). Let''s look at an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，或方法，重载是创建具有相同名称但参数数量或类型不同的多个方法的能力。在 TypeScript 中，我们可以通过指定函数的所有函数签名（称为**重载签名**），然后是一个签名（称为**实现签名**）来重载一个函数。让我们看一个例子：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we can see in the preceding example, we have overloaded the function test
    three times by adding a signature that takes a `string` as its only parameter,
    another function that takes a `number`, and a final signature that takes a `Boolean`
    as its unique parameter. It is important to note that all function signatures
    must be compatible; so, if, for example, one of the signatures tries to return
    a `number` while another tries to return a `string`, we will get a compilation
    error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的示例所示，我们通过添加一个仅接受 `string` 作为其唯一参数的签名、另一个接受 `number` 的函数和一个最终接受 `Boolean`
    作为其唯一参数的签名，三次重载了函数 test。重要的是要注意，所有函数签名都必须兼容；因此，例如，如果一个签名试图返回 `number` 而另一个试图返回
    `string`，我们将得到编译错误：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Please note that this restriction can be overcome by using a specialized overloaded
    signature, as we will learn in the following section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种限制可以通过使用专门的重载签名来克服，正如我们将在下一节中学习的那样。
- en: The implementation signature must be compatible with all the overloaded signatures,
    always be the last in the list, and take any or a union type as the type of its
    parameters.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 实现签名必须与所有重载签名兼容，始终位于列表的末尾，并接受任何或联合类型作为其参数的类型。
- en: 'Invoking the function by providing arguments that don''t match any of the types
    declared by the overload signatures will lead to a compilation error:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供与重载签名中声明的类型不匹配的参数来调用函数将导致编译错误：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Specialized overloading signature
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专门的过载签名
- en: 'We can use a specialized signature to create multiple methods with the same
    name and number of parameters, but a different return type. To create a specialized
    signature, we must indicate the type of function parameter using a string. The
    string literal is used to identify which of the function overloads is invoked:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用专门的签名创建具有相同名称和参数数量但不同返回类型的多个方法。要创建专门的签名，我们必须使用字符串来指示函数参数的类型。字符串字面量用于识别调用了哪个函数重载：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, we have declared three **specialized overloaded signatures**
    and one **non-specialized signature** for the function named `createElement`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们为名为 `createElement` 的函数声明了三个**专门的过载签名**和一个**非专门的签名**。
- en: When we declare a specialized signature in an object, it must be assignable
    to at least one non-specialized signature in the same object. This can be observed
    in the preceding example, as the `createElement` property belongs to a type that
    contains three specialized signatures, all of which are assignable to the non-specialized
    signature in the type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在对象中声明一个专门的签名时，它必须至少可分配给该对象中的一个非专门的签名。这可以从前面的示例中观察到，因为 `createElement` 属性属于一个包含三个专门签名的类型，所有这些签名都可以分配给该类型中的非专门签名。
- en: When writing overloaded declarations, we must list the non-specialized signature
    last.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写重载声明时，我们必须将非专门的签名放在最后。
- en: Function scope and hoisting
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作用域和提升
- en: Low-level languages, such as C, have low-level memory management features. In
    programming languages with a higher level of abstraction, such as TypeScript,
    values are allocated when variables are created, and automatically cleared from
    memory when they are no longer used. The process that cleans the memory is known
    as **garbage** **collection** and is performed by the JavaScript runtime garbage
    collector.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 低级语言，如C语言，具有低级内存管理功能。在具有更高抽象级别的编程语言中，如TypeScript，变量创建时分配值，不再使用时自动从内存中清除。清理内存的过程称为**垃圾回收**，由JavaScript运行时的垃圾回收器执行。
- en: The garbage collector does a great job, but it is a mistake to assume that it
    will always prevent us from facing a memory leak. The garbage collector will clear
    a variable from the memory whenever the variable is out of scope. It is important
    to understand how the TypeScript scope works in order for us to understand the
    life cycle of variables.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器做得很好，但认为它总能防止我们面对内存泄漏是错误的。垃圾回收器会在变量超出作用域时从内存中清除变量。为了理解变量的生命周期，了解TypeScript的作用域工作方式非常重要。
- en: Some programming languages use the structure of the program source code to determine
    what variables we are referring to (**lexical scoping**), while others use the
    runtime state of the program stack to determine what variable we are referring
    to (**dynamic scoping**). Most modern programming languages use lexical scoping
    (including TypeScript). Lexical scoping tends to be dramatically easier to understand
    for both humans and analysis tools than dynamic scoping.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言使用程序源代码的结构来确定我们引用的是哪个变量（**词法作用域**），而另一些则使用程序调用栈的运行时状态来确定我们引用的是哪个变量（**动态作用域**）。大多数现代编程语言使用词法作用域（包括TypeScript）。词法作用域通常比动态作用域更容易为人类和分析工具所理解。
- en: 'While, in most lexical-scoped programming languages, variables are scoped to
    a block (a section of code delimited by curly braces `{}`), in TypeScript (and
    JavaScript) variables are scoped to a function, as demonstrated by the following
    code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数词法作用域编程语言中，变量作用域限定在块内（由花括号 `{}` 分隔的代码部分），但在TypeScript（和JavaScript）中，变量作用域限定在函数内，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding function, named `foo`, contains an `if` structure. We have declared
    a numeric variable named `bar` inside the `if` statement, and later we have attempted
    to show the value of the `bar` variable using the `log` function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的名为`foo`的函数包含一个`if`结构。我们在`if`语句内部声明了一个名为`bar`的数值变量，后来我们尝试使用`log`函数来显示`bar`变量的值。
- en: We might think that the preceding code sample would throw an error in the fifth
    line because the `bar` variable should be out of scope when the `log` function
    is invoked. However, if we invoke the `foo` function, the `log` function will
    be able to display the variable `bar` without errors because all variables inside
    a function will be within the scope of the entire function body, even if they
    are inside another block of code (except a function block).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为前面的代码示例在第五行会抛出错误，因为当调用`log`函数时`bar`变量应该超出作用域。然而，如果我们调用`foo`函数，`log`函数将能够无错误地显示变量`bar`，因为函数内部的所有变量都将处于整个函数体的作用域内，即使它们位于另一个代码块内（除了函数块）。
- en: 'The following diagram displays the lexical scope at the function level (left),
    and the lexical scope at the block level (right). As we can see, there is only
    one function, but there are two blocks:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了函数级别的词法作用域（左侧），以及块级别的词法作用域（右侧）。如图所示，只有一个函数，但有两个块：
- en: '![](img/0bc4b27a-d287-41ef-84f8-4d0f8ba48f01.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bc4b27a-d287-41ef-84f8-4d0f8ba48f01.png)'
- en: The preceding code snippet might seem confusing, but it is easy to understand
    once we know that, at runtime, all the variable declarations are moved to the
    top of a function before the function is executed. This behavior is known as **hoisting**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段可能看起来有些令人困惑，但一旦我们知道在运行时，所有变量声明都会在函数执行之前移动到函数的顶部，这种行为就很容易理解了。这种行为被称为**提升**。
- en: TypeScript is compiled to JavaScript and then executed—this means that a TypeScript
    application is a JavaScript application at runtime and, for this reason, when
    we refer to the TypeScript runtime, we are talking about the JavaScript runtime.
    We will learn in depth about the runtime in [Chapter 4](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml)*,
    The Runtime – The Event Loop and The this Operator,* and [Chapter 5](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)*,
    The Runtime – Closures and Prototypes*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript被编译成JavaScript然后执行——这意味着TypeScript应用程序在运行时是一个JavaScript应用程序，因此，当我们提到TypeScript运行时，我们实际上是在谈论JavaScript运行时。我们将在[第4章](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml)*，运行时——事件循环和this操作符*和[第5章](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)*，运行时——闭包和原型*中深入探讨运行时。
- en: 'Before the preceding code snippet is executed, the runtime will move the declaration
    of the `bar` variable to the top of our function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的代码片段之前，运行时会将`bar`变量的声明移动到我们的函数顶部：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This explains why it is possible to use a variable before it is declared. Let''s
    look at an example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么可以在声明变量之前使用它。让我们看一个例子：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code snippet, we have declared a function, `foo`, and, in its
    body, we have assigned the value `0` to a variable named `bar`. At this point,
    the variable has not been declared. In the second line, we are declaring the `bar`
    variable and its type. In the last line, we are displaying the value of the `bar`
    variable using the `alert` function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个函数`foo`，并在其主体中，我们将值`0`赋给名为`bar`的变量。此时，该变量尚未声明。在第二行，我们声明了`bar`变量及其类型。在最后一行，我们使用`alert`函数显示`bar`变量的值。
- en: 'Since declaring a variable anywhere inside a function (except another function)
    is equivalent to declaring it at the top of the function, the `foo` function is
    transformed into the following at runtime:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在函数内部（除了另一个函数）声明变量（相当于在函数顶部声明它），所以`foo`函数在运行时会转换为以下形式：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Developers with a background in programming languages with block scope, such
    as Java or C#, are not used to function scope and it is one of the most criticized
    characteristics of JavaScript. The people in charge of the development of the
    ECMAScript 6 specification are aware of this, and, as a result, they have introduced
    the keywords `let` and `const`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 具有诸如Java或C#等具有块作用域的编程语言背景的开发者不习惯函数作用域，这是JavaScript最被批评的特性之一。ECMAScript 6规范的开发负责人对此有所了解，因此他们引入了关键字`let`和`const`。
- en: 'The `let` keyword allows us to set the scope of a variable to a block (`if`,
    `while`, `for`, and so on) rather than a function. We can update the first example
    in this section to showcase how the `let` keyword works:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`关键字允许我们将变量的作用域设置为块（`if`、`while`、`for`等），而不是函数。我们可以更新本节中的第一个示例来展示`let`关键字是如何工作的：'
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `bar` variable is now declared using the `let` keyword, and, as a result,
    it is only accessible inside the `if` block. The variable is not hoisted to the
    top of the `foo` function and cannot be accessed by the `alert` function outside
    the `if` statement.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`bar`变量使用`let`关键字声明，因此它只能在`if`块内部访问。变量不会被提升到`foo`函数的顶部，并且不能在`if`语句外部通过`alert`函数访问。
- en: 'While variables defined with `const` follow the same scope rules as variables
    declared with `let`, they can''t be reassigned:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`const`定义的变量遵循与使用`let`声明的变量相同的范围规则，但它们不能被重新赋值：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we attempt to compile the preceding code snippet, we will get an error because
    the `bar` variable is not accessible outside the `if` statement (just like when
    we used the `let` keyword), and a new error occurs when we try to assign a new
    value to the `bar` variable. The second error is caused because it is not possible
    to assign a new value to a constant variable once the variable has already been
    initialized.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译前面的代码片段，我们会得到一个错误，因为`bar`变量在`if`语句外部不可访问（就像我们使用`let`关键字时一样），当我们尝试给`bar`变量赋新值时，会引发新的错误。第二个错误是由于一旦变量已经被初始化，就无法给常量变量赋新值。
- en: Variables declared with the `const` keyword cannot be reassigned, but are not
    immutable. When we say that a variable is immutable, we mean that it cannot be
    modified. We will learn more about immutability in [Chapter 9](6a03c916-f7a5-439a-bea6-6facecef0347.xhtml)*,
    Functional-Reactive Programming*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`关键字声明的变量不能重新赋值，但不是不可变的。当我们说一个变量是不可变的，我们的意思是它不能被修改。我们将在[第9章](6a03c916-f7a5-439a-bea6-6facecef0347.xhtml)*，函数式响应式编程*中了解更多关于不可变性的内容。
- en: Immediately-invoked functions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立即调用的函数
- en: 'An **immediately-invoked function expression** (**IIFE**) is a design pattern
    that produces a lexical scope using function scoping. IIFE can be used to avoid
    variable hoisting from within blocks or to prevent us from polluting the global
    scope, for example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**立即调用的函数表达式**（**IIFE**）是一种设计模式，它使用函数作用域来创建词法作用域。IIFE可以用来避免在块内部提升变量，或者防止我们污染全局作用域，例如：'
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, we have wrapped the declaration of a variable (`foo`)
    with an IIFE. The `foo` variable is scoped to the IIFE function and is not available
    in the global scope, which explains the error when trying to access it on the
    last line.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们用IIFE包裹了一个变量的声明（`foo`）。`foo`变量的作用域限定在IIFE函数内，且在全局作用域中不可用，这也解释了为什么在最后一行尝试访问它时会出错。
- en: The `bar` variable is global. Therefore, it can be accessed from within and
    from outside the IIFE function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`bar`变量是全局的。因此，它可以从IIFE函数内部和外部访问。'
- en: 'We can also pass a variable to the IIFE to have better control over the creation
    of variables outside its scope:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将变量传递给IIFE，以更好地控制其作用域之外的变量创建：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Furthermore, IIFE can help us to simultaneously allow public access to methods
    while retaining privacy for variables defined within the function. Let''s look
    at an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，IIFE可以帮助我们在允许公共访问方法的同时，保留函数内部定义的变量的隐私。让我们看一个例子：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have defined a class named `Counter`, which has a private numerical attribute
    named `_i`. The class also has methods to get and set the value of the `_i` private
    property.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Counter`的类，它有一个名为`_i`的私有数值属性。该类还有获取和设置`_i`私有属性值的方法。
- en: By convention, TypeScript and JavaScript developers usually name private variables
    with names preceded by the underscore character (`_`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，TypeScript和JavaScript开发者通常使用以下划线字符（`_`）开头的名称来命名私有变量。
- en: We have also created an instance of the `Counter` class and invoked the methods
    `set`, `get`, and `increment` to observe that everything is working as expected.
    If we attempt to access the `_i` property in an instance of `Counter`, we will
    get an error because the variable is private.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个`Counter`类的实例，并调用了`set`、`get`和`increment`方法来观察一切是否按预期工作。如果我们尝试在一个`Counter`实例中访问`_i`属性，我们会得到一个错误，因为该变量是私有的。
- en: 'If we compile the preceding TypeScript code (only the class definition) and
    examine the JavaScript code generated, we will see the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译前面的TypeScript代码（仅类定义）并检查生成的JavaScript代码，我们将看到以下内容：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This generated JavaScript code will work perfectly in most scenarios, but if
    we execute it in a browser and try to create an instance of `Counter` and access
    its property `_i`, we will not get any errors because TypeScript will not generate
    runtime private properties for us. Occasionally, we will need to write our classes
    in such a way that some properties are private at runtime, for example, if we
    release a library that will be used by JavaScript developers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此生成的JavaScript代码在大多数场景下将完美运行，但如果我们在浏览器中执行它并尝试创建一个`Counter`实例并访问其属性`_i`，我们不会得到任何错误，因为TypeScript不会为我们生成运行时的私有属性。偶尔，我们需要以某种方式编写我们的类，使得某些属性在运行时是私有的，例如，如果我们发布一个将被JavaScript开发者使用的库。
- en: 'We can also use IIFE to simultaneously allow public access to methods while
    retaining privacy for variables defined within the function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用IIFE同时允许公共访问方法，同时保留函数内部定义的变量的隐私：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, everything is almost identical to TypeScript's generated
    JavaScript, except that the variable `_i` is now an object in the `Counter` closure
    instead of a property of the `Counter` class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，一切几乎与TypeScript生成的JavaScript相同，只是变量`_i`现在是一个`Counter`闭包中的对象，而不是`Counter`类的属性。
- en: Closures are functions that refer to independent (free) variables. In other
    words, the function defined in the closure remembers the environment (variables
    in the scope) in which it was created. We will discover more about closures in
    [Chapter 5](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)*, The Runtime – Closures
    and Prototypes*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是引用独立（自由）变量的函数。换句话说，闭包中定义的函数会记住其创建时的环境（作用域内的变量）。我们将在[第5章](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)*，运行时
    – 闭包和原型*中了解更多关于闭包的内容。
- en: 'If we run the generated JavaScript output in a browser and try to invoke the
    `_i` property directly, we will notice that the property is now private at runtime:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行生成的JavaScript输出并直接调用`_i`属性，我们会注意到该属性在运行时现在是私有的：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In some cases, we will need to have precise control over scope and closures,
    and our code will end up looking much more like JavaScript. If we write our application
    components (classes, modules, and so on) to be consumed by other TypeScript components,
    we will rarely have to worry about implementing runtime private properties. We
    will look in depth at the TypeScript runtime in [Chapter 4](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml)*,
    The Runtime – The Event Loop and The this Operator,* and [Chapter 5](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)*,
    The Runtime – Closures and Prototypes.*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要对作用域和闭包有精确的控制，我们的代码最终会看起来更像JavaScript。如果我们编写应用程序组件（类、模块等）以便由其他TypeScript组件使用，我们很少需要担心实现运行时私有属性。我们将在[第4章](0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml)*运行时
    – 事件循环和this操作符*和[第5章](68a4518b-0e8e-4273-8418-2751c4961ed1.xhtml)*运行时 – 闭包和原型*中深入探讨TypeScript的运行时。
- en: Tag functions and tagged templates
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签函数和带标签的模板
- en: 'In TypeScript, we can use template strings such as the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，我们可以使用如下模板字符串：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can use a template string to create a special kind of function known as a
    **tag function**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模板字符串创建一种特殊类型的函数，称为**标签函数**。
- en: We can use a `tag` function to extend or modify the standard behavior of template
    strings. When we apply a `tag` function to a template string, the template string
    becomes a tagged template.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`tag`函数来扩展或修改模板字符串的标准行为。当我们将`tag`函数应用于模板字符串时，模板字符串就变成了一个带标签的模板。
- en: 'We are going to implement a `tag` function named `htmlEscape`. To use a `tag`
    function, we must use the name of the function, followed by a template string:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个名为`htmlEscape`的`tag`函数。要使用`tag`函数，我们必须使用该函数的名称，后跟一个模板字符串：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A `tag` template must return a string and take the following arguments:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`tag`模板必须返回一个字符串并接受以下参数：
- en: A `TemplateStringsArray`, which contains all the static literals in the template
    string (`<h1>` and `</h1>` in the preceding example), is passed as the first argument.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`TemplateStringsArray`，它包含模板字符串中的所有静态字面量（如前例中的`<h1>`和`</h1>`），作为第一个参数传递。
- en: The `TemplateStringsArray` type is declared by the `lib.d.ts` file. The `lib.d.ts`
    file contains the type declarations of the native JavaScript and browser APIs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateStringsArray`类型由`lib.d.ts`文件声明。`lib.d.ts`文件包含原生JavaScript和浏览器API的类型声明。'
- en: A `rest` parameter is passed as the second parameter. The `rest` parameter contains
    all the values in the template string (name and surname in the preceding example).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`rest`参数作为第二个参数传递。`rest`参数包含模板字符串中的所有值（前例中的姓名和姓氏）。
- en: 'The signature of a `tag` function appears as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag`函数的签名如下所示：'
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s implement the `htmlEscape` tag function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`htmlEscape`标签函数：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can then invoke the function as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下调用该函数：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The template string contains values and literals. The `htmlEscape` function
    iterates through them and ensures that the HTML code is escaped in the values
    to avoid possible code injection attacks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串包含值和字面量。`htmlEscape`函数遍历它们，并确保在值中转义HTML代码，以避免可能的代码注入攻击。
- en: The main benefit of using a tagged function is that it allows us to create custom
    template string processors.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签函数的主要好处是它允许我们创建自定义的模板字符串处理器。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned a lot about functions. We have learned about
    different kinds of functions, such as named and anonymous function, and function
    declarations and function expressions. We also learned how to declare different
    types of function signatures as well as how to work with function arguments in
    multiple scenarios.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于函数的很多知识。我们学习了不同类型的函数，如命名函数和匿名函数，以及函数声明和函数表达式。我们还学习了如何声明不同类型的函数签名，以及如何在多种场景下处理函数参数。
- en: In the next chapter, we are going to learn about asynchronous programming techniques.
    We will learn why functions play a very fundamental role in the TypeScript and
    JavaScript asynchronous programming model.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习异步编程技术。我们将了解为什么函数在TypeScript和JavaScript异步编程模型中扮演着非常基础的角色。
