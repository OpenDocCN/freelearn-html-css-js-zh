- en: Chapter 1. Getting Started with Meteor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Meteor 入门
- en: 'Meteor is a framework that is essentially fast for the purpose of development
    even if you program at a slow pace. The aim of this book is to increase your development
    speed and improve quality. There are two key ingredients required to improve development:
    compilers and patterns. Compilers add functionality to your coding language, while
    patterns increase the speed at which you solve common programming issues.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 即使编程速度较慢，Meteor 也是一个本质上快速的开发框架。本书的目的是提高你的开发速度并提高质量。提高开发速度的两个关键要素是编译器和模式。编译器为你的编程语言添加功能，而模式则增加了解决常见编程问题的速度。
- en: 'This book will mostly cover patterns, but we''ll use this chapter to quick
    start compilers and understand how they relate to Meteor—a vast but simple topic.
    The compilers that we will look at are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将主要涵盖模式，但我们将使用本章快速入门编译器，并了解它们如何与 Meteor 相关——这是一个庞大但简单的主题。我们将查看的编译器如下：
- en: CoffeeScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoffeeScript
- en: Jade
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jade
- en: Stylus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本
- en: 'We will review some basic knowledge you should have about Meteor. This will
    cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾一些关于 Meteor 你应该具备的基本知识。这包括以下内容：
- en: Templates, helpers, and events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板、辅助函数和事件
- en: The event loop and the merge box
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环和合并框
- en: The must-have packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必备的包
- en: Folder structure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: CoffeeScript for Meteor
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Meteor 的 CoffeeScript
- en: CoffeeScript is a compiler for JavaScript that adds "syntactic sugar" inspired
    by Ruby, Python, and Haskell; it effectively makes the writing of JavaScript easier
    and more readable. CoffeeScript simplifies the syntax of functions, objects, arrays,
    logical statements, binding, managing scope, and much more. All CoffeeScript files
    are saved with a `.coffee` extension. We will cover functions, objects, logical
    statements, and bindings as these are some of the most commonly used features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 是一个 JavaScript 编译器，它受到 Ruby、Python 和 Haskell 的启发，添加了“语法糖”，这使得 JavaScript
    的编写更容易、更易读。CoffeeScript 简化了函数、对象、数组、逻辑语句、绑定、管理作用域等语法。所有 CoffeeScript 文件都保存为 `.coffee`
    扩展名。我们将涵盖函数、对象、逻辑语句和绑定，因为这些是使用最频繁的功能。
- en: Objects and arrays
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象和数组
- en: 'CoffeeScript gets rid of curly braces (`{}`), semicolons (`;`), and commas
    (`,`). This alone saves you from repeating unnecessary strokes on the keyboard.
    Instead, CoffeeScript emphasizes on the proper use of **tabbing**. Tabbing will
    not only make your code more readable, but it will be a key factor in making the
    code work as well. In fact, you are probably already tabbing the right way! Let''s
    look at some examples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 去掉了花括号(`{}`)、分号(`;`)和逗号`,`。仅此一项就可以让你在键盘上避免重复不必要的按键。相反，CoffeeScript
    强调正确使用**缩进**。缩进不仅会使你的代码更易读，而且将是代码正常工作的关键因素。实际上，你可能已经正确地使用了缩进！让我们看看一些例子：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://www.packtpub.com](http://www.packtpub.com)下载示例代码文件，这是你购买的所有 Packt
    出版物的链接。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: 'Here, we are creating an object named `toolbox` that contains two keys: `hammer`
    and `flashlight`. The equivalent in JavaScript will be this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `toolbox` 的对象，它包含两个键：`hammer` 和 `flashlight`。在 JavaScript 中的等效代码将是这样的：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Much easier! As you can see, we have to **tab** to indicate that both the `hammer`
    and `flashlight` properties are a part of `toolbox`. The `var` word is not allowed
    in CoffeeScript because CoffeeScript automatically applies it for you. Let''s
    have a look at how we would make an array:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单！正如你所见，我们必须**缩进**来表示 `hammer` 和 `flashlight` 属性都是 `toolbox` 的一部分。在 CoffeeScript
    中不允许使用 `var` 关键字，因为 CoffeeScript 会自动为你应用它。让我们看看我们如何创建一个数组：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we can see that we don't need to have any commas, but we do need to have
    brackets to determine that this is an array.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们不需要任何逗号，但我们需要有括号来确定这是一个数组。
- en: Logical statements and operators
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑语句和运算符
- en: 'CoffeeScript removes a lot of parenthesis (`()`) in logical statements and
    functions as well. This makes the logic of the code much easier to understand
    at first glance. Let''s look at an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 在逻辑语句和函数中移除了很多括号(`()`)，这使得代码的逻辑在第一眼看起来更容易理解。让我们看看一个例子：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we can clearly see that CoffeeScript is easier to read and
    write. CoffeeScript effectively replaces the entire **implied parenthesis** in
    any logical statement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以清楚地看到 CoffeeScript 更易于阅读和编写。CoffeeScript 有效地替换了任何逻辑语句中的所有 **隐式括号**。
- en: 'Operators such as `&&`, `||`, and `!==` are replaced by words to make the code
    more readable. Here is a list of the operators that you will be using the most:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `&&`、`||` 和 `!==` 等运算符替换为单词，可以使代码更易读。以下是您将最常使用的运算符列表：
- en: '| CoffeeScript | JavaScript |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| CoffeeScript | JavaScript |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `is` | `===` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `is` | `===` |'
- en: '| `isnt` | `!==` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `isnt` | `!==` |'
- en: '| `not` | `!` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `not` | `!` |'
- en: '| `and` | `&&` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `and` | `&&` |'
- en: '| `or` | `&#124;&#124;` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `or` | `&#124;&#124;` |'
- en: '| `true, yes, on` | `true` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `true, yes, on` | `true` |'
- en: '| `false, no, off` | `false` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `false, no, off` | `false` |'
- en: '| `@, this` | `this` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `@, this` | `this` |'
- en: 'Let''s look at a slightly more complex logical statement and see how it is
    compiled:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个稍微复杂一点的逻辑语句，并看看它是如何编译的：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how the context of `this` is passed to the `@` symbol without the need
    for a period, making `@eye_color` equal to `this.eye_color`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `this` 的上下文是如何传递给 `@` 符号而不需要点号的，这使得 `@eye_color` 等于 `this.eye_color`。
- en: Functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'A JavaScript function is a block of code designed to perform a particular task.
    JavaScript has a couple of ways of creating functions that are simplified in CoffeeScript.
    They look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 函数是一段代码块，用于执行特定任务。JavaScript 有几种创建函数的方法，在 CoffeeScript 中得到了简化。它们看起来像这样：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'CoffeeScript uses `->` instead of the `function()` keyword. The following example
    outputs a `hello_world` function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 使用 `->` 而不是 `function()` 关键字。以下示例输出一个 `hello_world` 函数：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once again, we will use a tab to specify the contents of the function so that
    there is no need for curly braces (`{}`). This means that you have to make sure
    that you have the entire logic of the function tabbed under its namespace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用制表符来指定函数的内容，这样就不需要花括号 (`{}`) 了。这意味着你必须确保整个函数的逻辑都缩进在其命名空间下。
- en: 'What about our parameters? We can use `(p1,p2) ->` where `p1` and `p2` are
    parameters. Let''s make our `hello_world` function output our name:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的参数怎么办？我们可以使用 `(p1,p2) ->`，其中 `p1` 和 `p2` 是参数。让我们让我们的 `hello_world` 函数输出我们的名字：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we can see how parameters are placed inside parentheses. We
    are also doing **string interpolation**. CoffeeScript allows the programmer to
    easily add logic to a string by escaping the string with `#{}`. Also notice that,
    unlike JavaScript, you do not have to return anything at the end of the function,
    CoffeeScript automatically returns the output of the last command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到参数是如何放在括号内的。我们还在做 **字符串插值**。CoffeeScript 允许程序员通过使用 `#{}` 转义字符串来轻松地将逻辑添加到字符串中。注意，与
    JavaScript 不同，你不需要在函数末尾返回任何内容，CoffeeScript 会自动返回最后一条命令的输出。
- en: Binding
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: 'In Meteor, we will often find ourselves using the properties of `this` within
    nested functions and callbacks. **Function binding** is very useful for these
    types of cases and helps to avoid saving data in additional variables. Function
    binding sets the value of the `this` object inside the function to the value of
    `this` outside the function. Let''s look at an example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Meteor 中，我们经常会发现自己需要在嵌套函数和回调中使用 `this` 的属性。**函数绑定** 在这些情况下非常有用，并有助于避免在额外的变量中保存数据。函数绑定将函数内部的
    `this` 对象的值设置为函数外部的 `this` 的值。让我们看一个例子：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, the `this` object will return a top-level object such as the
    browser window. This is not useful at all. Let''s bind `this` now:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`this` 对象将返回一个顶层对象，例如浏览器窗口。这毫无用处。现在让我们绑定 `this`：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The key difference is the use of `=>` instead of the expected `->` to define
    the function. Using `=>` will make the callback''s `this` object equal to the
    context of the executing function. The resulting compiled script is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别在于使用 `=>` 而不是预期的 `->` 来定义函数。使用 `=>` 将使回调的 `this` 对象等于执行函数的上下文。生成的编译脚本如下：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'CoffeeScript will improve your coding quality and speed. Still, *CoffeeScript
    is not flawless*. When you start combining functions with nested arrays, things
    can get complex and difficult to read, especially when the functions are constructed
    with multiple parameters. Let''s look at a common query that does not look as
    readable as you would expect it to be:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript 将提高你的编码质量和速度。尽管如此，*CoffeeScript 并非完美无瑕*。当你开始将函数与嵌套数组结合使用时，事情可能会变得复杂且难以阅读，尤其是在函数使用多个参数构建时。让我们看看一个看起来不像你预期的那样易于阅读的常见查询：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This collection query is passing three parameters: the `filter` object, the
    `options` object, and the callback function. To differentiate between the first
    two objects, we had to place a comma at the same level as the function and then,
    indent the second parameter. This is unwieldy, but we can use variables in order
    to make the query more readable:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合查询传递了三个参数：`filter` 对象、`options` 对象和回调函数。为了区分前两个对象，我们不得不在函数同一级别放置一个逗号，然后缩进第二个参数。这很麻烦，但我们可以使用变量来使查询更易读：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Go to [coffeescript.org](http://coffeescript.org) and play around with the language
    by clicking on the "try coffeescript" link.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [coffeescript.org](http://coffeescript.org)，通过点击“try coffeescript”链接来尝试使用该语言。
- en: Jade for Meteor
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jade for Meteor
- en: Jade works much like CoffeeScript but it is used for HTML instead. I recommend
    that you install the `mquandalle:jade` package. All the Jade files are saved with
    a `.jade` extension. This section will cover the most used aspects of Jade in
    Meteor such as HTML tags, components, and helpers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Jade 与 CoffeeScript 工作方式相似，但它用于 HTML 而不是其他。我建议您安装 `mquandalle:jade` 包。所有的 Jade
    文件都保存为 `.jade` 扩展名。本节将涵盖 Jade 在 Meteor 中最常用的方面，例如 HTML 标签、组件和助手。
- en: HTML tags
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML 标签
- en: 'Much like CoffeeScript, Jade is a language that depends heavily on tabbing.
    When you want to add children to an HTML tag, you simply use tab. Tag IDs and
    classes can be added using the CSS selector notation (`''input#name.first''`).
    This means classes are expressed with a dot (`.`) and IDs are expressed with a
    pound (`#`). Let''s look at an example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CoffeeScript 类似，Jade 是一种高度依赖缩进的编程语言。当您想向 HTML 标签添加子元素时，只需使用缩进。可以使用 CSS 选择器表示法（`'input#name.first'`）添加标签
    ID 和类。这意味着类用点（`.`）表示，ID 用井号（`#`）表示。让我们看一个例子：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, **special** attributes such as `data-bind` are added with parenthesis.
    Symbols such as `<`, `>`, and **closures** are not required anymore. In this example,
    we have a `div` tag with an `id` attribute of `"container"`, a `ul` tag with a
    `class` attribute of list, and a `li` tag with a special attribute of `data-bind`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**特殊**属性如 `data-bind` 使用括号添加。符号如 `<`、`>` 和 **闭包**不再需要。在这个例子中，我们有一个 `div`
    标签，其 `id` 属性为 `"container"`，一个 `ul` 标签，其 `class` 属性为 `list`，以及一个具有特殊属性 `data-bind`
    的 `li` 标签。
- en: You will find yourself using special attributes often for the `input` tags to
    add `value`, `placeholder`, and other attributes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现自己在 `input` 标签上经常使用特殊属性来添加 `value`、`placeholder` 和其他属性。
- en: Templates and components
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板和组件
- en: 'Meteor templates are Jade components. In Meteor, we define a template with
    the template tag and apply the special `name` attribute to create a reusable HTML
    block. In Jade, when we create a template, we create a component as well. This
    looks as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 模板是 Jade 组件。在 Meteor 中，我们使用模板标签定义模板，并应用特殊的 `name` 属性来创建可重用的 HTML 块。在
    Jade 中，当我们创建模板时，我们也创建了一个组件。这看起来如下：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we can use this template as a Jade component anywhere in our views. To
    call a Jade component, you simply prepend a plus sign to the name of the template.
    Let''s look at an example where we want to place a `landing` page inside a `main_layout`
    page:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在视图的任何地方使用这个模板作为 Jade 组件。要调用 Jade 组件，您只需在模板名称前加上一个加号。让我们看看一个例子，我们想在 `main_layout`
    页面内放置一个 `landing` 页面：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s it! Notice that we have prepended the plus (`+`) sign to the name of
    the template to call it. This is equivalent to using `{{> landing}}` in SpaceBars
    (Meteor''s version of Handlebars). Components can have parameters as well, which
    can be later used in the templates'' instance. Let''s make our example output
    someone''s name:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！请注意，我们在模板名称前加上了加号 (`+`) 来调用它。这相当于在 SpaceBars（Meteor 的 Handlebars 版本）中使用
    `{{> landing}}`。组件也可以有参数，这些参数可以在模板实例中使用。让我们通过一个例子来输出某人的名字：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding attributes to your templates can make your templates flexible as shown
    in the preceding example. Still, it is unlikely that you will have to use this
    as templates "soak up" data from their parent context.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 向您的模板添加属性可以使您的模板像前面的例子那样灵活。尽管如此，您不太可能需要这样做，因为模板“吸收”来自其父上下文的数据。
- en: Helpers
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 助手
- en: 'Helpers in Meteor are functions that return data before rendering to the view.
    We use helpers for iteration, logical statements, and variables. The two basic
    helpers are `each` and `if`, but adding the `raix:handlebar-helpers` package will
    add a dictionary of other useful helpers to keep your code from repeating. Let''s
    have a look at how we can use our helpers:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 中的辅助工具是函数，在渲染到视图之前返回数据。我们使用辅助工具进行迭代、逻辑语句和变量。两个基本辅助工具是 `each` 和 `if`，但添加
    `raix:handlebar-helpers` 包将添加其他有用的辅助工具字典，以避免代码重复。让我们看看我们如何使用我们的辅助工具：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, the `each` helper is iterating through the return value of
    another helper named `things` and if the `selected` helper resolves to `true`,
    then we will render `p.selected` with the `name` variable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`each` 辅助工具正在遍历另一个名为 `things` 的辅助工具的返回值，如果 `selected` 辅助工具解析为 `true`，则我们将渲染
    `p.selected` 并使用 `name` 变量。
- en: It's important to understand that everything that is not an HTML tag is a helper,
    and that if you want to use a helper within a tag, you need to use `{{}}` or `#{}`
    to express this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，所有不是 HTML 标签的内容都是辅助工具，如果你想在标签内使用辅助工具，你需要使用 `{{}}` 或 `#{}` 来表示这一点。
- en: Go to [jade-lang.com](http://jade-lang.com) and `handlebars.js` to know more
    specific information. With this information, you should be able to do just about
    anything.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [jade-lang.com](http://jade-lang.com) 和 `handlebars.js` 了解更具体的信息。有了这些信息，你应该能够做任何事情。
- en: Stylus for Meteor
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stylus for Meteor
- en: 'Stylus works much like CoffeeScript and Jade but it is for CSS. I recommend
    that you install `mquandalle:stylus`. This package is preinstalled with useful
    tools such as `Jeet` and `Rupture`. All Stylus files are saved with a `.styl`
    extension. There are only three things that we need to learn about Stylus: CSS
    tags, variables, and functions.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Stylus 与 CoffeeScript 和 Jade 类似，但它用于 CSS。我建议您安装 `mquandalle:stylus`。这个包预装了有用的工具，如
    `Jeet` 和 `Rupture`。所有 Stylus 文件都保存为 `.styl` 扩展名。关于 Stylus，我们只需要了解三件事：CSS 标签、变量和函数。
- en: CSS tags
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS 标签
- en: 'Stylus is a language that does away with the need for semicolons (`;`) and
    curly braces (`{}`) in exchange for making good use of tabbing. Let''s look at
    an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Stylus 是一种语言，它通过使用缩进来代替分号（`;`）和大括号（`{}`），来消除对分号和大括号的需求。让我们看看一个例子：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can see in `PART 1` how properties are defined for a class by tabbing those
    properties in `.special` is used to select an HTML tag with the `special` class
    that is a child of the `vertical-align-middle` class. Let''s look at how `PART
    1` compiles:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `PART 1` 中看到，如何通过缩进属性来定义类的属性，使用 `.special` 选择具有 `special` 类的 HTML 标签，该标签是
    `vertical-align-middle` 类的子类。让我们看看 `PART 1` 是如何编译的：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s add a more complex selector:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个更复杂的选择器：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`PART 2` has a combination of special CSS2 selectors: specific parent (`>`)
    and all elements (`*`). In this particular order, the CSS2 selectors are picking
    the "any first sibling" element only and applying the rules. Let''s look at how
    `PART 2` compiles:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`PART 2` 结合了特殊的 CSS2 选择器：特定父级（`>`）和所有元素（`*`）。在这个特定的顺序中，CSS2 选择器只选择“任何第一个兄弟元素”并应用规则。让我们看看
    `PART 2` 是如何编译的：'
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s add a new class to the current class that aligns the object to the top:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在当前类中添加一个新的类，使对象对齐到顶部：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`PART 3` uses an ampersand (`&`) to describe an element that is not a child
    but instead is concatenated with the extra class. Let''s look at how `PART 3`
    compiles:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`PART 3` 使用连字符（`&`）来描述一个不是子元素而是与额外类连接的元素。让我们看看 `PART 3` 是如何编译的：'
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Variables
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'Unlike CSS, Stylus supports variables. This keeps a lot of things manageable
    when we want to make major changes to the look of our site. Suppose we have two
    colors that we want to use throughout our site, but we know that these colors
    are going to change. Let''s define them as variables so that we can easily modify
    them later:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CSS 不同，Stylus 支持变量。当我们想要对网站的外观进行重大更改时，这可以使许多事情变得可管理。假设我们有两个颜色想要在整个网站上使用，但我们知道这些颜色将会改变。让我们将它们定义为变量，这样我们就可以轻松地在以后修改它们：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Easy right? In this example, both `primary-color` and `$secondary-color` are
    variables. Stylus optionally supports the use of the money sign (`$`) to indicate
    a variable. This can make it easier to spot variables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吗？在这个例子中，`primary-color` 和 `$secondary-color` 都是变量。Stylus 可选支持使用货币符号（`$`）来表示变量。这可以使查找变量变得更加容易。
- en: Functions/mixins
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数/混合
- en: 'Unlike CSS, Stylus supports functions too. LESS, Stylus, and **Sassy CSS**
    (**SCSS**) refer to functions as **mixins**. Functions will make your CSS concoctions
    much easier to share across a project. We will cover the two types of mixins in
    Stylus: mixins and transparent mixins.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CSS 不同，Stylus 也支持函数。LESS、Stylus 和 **Sassy CSS**（**SCSS**）将函数称为 **混入**。函数会使你的
    CSS 混合物更容易在整个项目中共享。我们将介绍 Stylus 中的两种混入类型：混入和透明混入。
- en: 'Mixins are functions that take a defined set of parameters. Let''s take a look
    at how we can write a mixin:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 混入是接受一组定义参数的函数。让我们看看我们如何编写一个混入：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we first define the `animation` mixin, and then we apply the
    mixin to the `button` HTML tag. However, there is a much easier and effective
    way of doing this via a transparent mixin.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了 `animation` 混入，然后我们将混入应用到 `button` HTML 标签上。然而，有一种更简单、更有效的方法是通过透明混入来完成这项工作。
- en: 'A transparent mixin, basically, takes all the parameters and saves them in
    an `arguments` variable without you having to define anything. Let''s have a look:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 透明混入基本上会接受所有参数并将它们保存在一个 `arguments` 变量中，而无需你定义任何内容。让我们看看：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how we did not have to define every single parameter in the mixin, and
    the `arguments` variable simply passed all the arguments that it could find. This
    is especially useful for keeping the code flexible.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不需要在混入中定义每个参数，`arguments` 变量简单地传递了它能找到的所有参数。这对于保持代码的灵活性特别有用。
- en: Stylus essentially upgrades CSS in such a way that it makes the code much easier
    to manage and therefore, ends up saving us a lot of development time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Stylus 实质上以升级 CSS 的方式，使得代码更容易管理，因此，最终为我们节省了大量开发时间。
- en: Go to [stylus-lang.com](http://stylus-lang.com) and [learnboost.github.io/stylus](http://learnboost.github.io/stylus)
    to learn more about Stylus.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [stylus-lang.com](http://stylus-lang.com) 和 [learnboost.github.io/stylus](http://learnboost.github.io/stylus)
    了解更多关于 Stylus 的信息。
- en: Templates, helpers, and events
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板、辅助函数和事件
- en: Now that we are on the same page for the languages that we are going to use
    throughout the book, let's do a quick review of some of the elements that we will
    use during our development process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对本书中将要使用的语言达成了一致，让我们快速回顾一下我们在开发过程中将使用的一些元素。
- en: Templates, helpers, and events are used to build the frontend of your application.
    Using them effectively is the key to how we design our backend as well (which
    we will address in [Chapter 2](part0021_split_000.html#page "Chapter 2. Publish
    and Subscribe Patterns"), *Publish and Subscribe Patterns*).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 模板、辅助函数和事件用于构建应用程序的前端。有效地使用它们是我们设计后端的关键（我们将在 [第 2 章](part0021_split_000.html#page
    "第 2 章。发布和订阅模式")，*发布和订阅模式*）中讨论）。
- en: Templates
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Meteor templates are the special blocks of HTML code that generate Meteor template
    objects (`Template.<yourtemplate>`). It is through Meteor template objects that
    we wire the HTML code to logic. People who have worked with an MVC framework will
    refer to these templates as views. This is a key concept to understand.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 模板是特殊的 HTML 代码块，用于生成 Meteor 模板对象（`Template.<yourtemplate>`）。正是通过 Meteor
    模板对象，我们将 HTML 代码与逻辑连接起来。使用过 MVC 框架的人会将这些模板称为视图。这是一个需要理解的关键概念。
- en: 'Open up your terminal and create a new project:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的终端并创建一个新的项目：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now let''s add our languages:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加我们的语言：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Remove the three visible files from `/basic_meteor` (do not remove any of the
    files starting with a dot), and create `/client/layout.jade`. This is something
    that exists in one way or another in every Meteor project. Let''s program:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `/basic_meteor` 中删除三个可见文件（不要删除以点开头的任何文件），并创建 `/client/layout.jade`。这是每个 Meteor
    项目以某种方式存在的东西。让我们开始编程：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Behind the scenes, Meteor is compiling our Jade templates and putting them all
    in one big file. You will never have to worry about loading `basic_template.jade`
    before `layout.jade` when it comes to templating.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Meteor 正在编译我们的 Jade 模板，并将它们全部放入一个大的文件中。在模板方面，你永远不必担心在加载 `layout.jade` 之前加载
    `basic_template.jade`。
- en: Throughout the book, we will use `meteorhacks:flow-router` and `meteorhacks:flow-layout`
    to easily navigate to different templates.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用 `meteorhacks:flow-router` 和 `meteorhacks:flow-layout` 来轻松导航到不同的模板。
- en: Creating helpers
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建辅助函数
- en: 'We have already discussed what helpers are in Jade, but how do we create helpers
    in Meteor? Let''s go back to our `basic_meteor` project and create `/client/basic_template.coffee`.
    It is important to understand that Meteor helpers are used to control the variables
    in our template. People who have worked with an MVC framework can view this file
    as a controller. Let''s write our first helper:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 Jade 中的助手是什么，但在 Meteor 中如何创建助手呢？让我们回到我们的 `basic_meteor` 项目，并创建 `/client/basic_template.coffee`。重要的是要理解，Meteor
    助手用于控制模板中的变量。那些使用过 MVC 框架的人可以将这个文件视为一个控制器。让我们编写我们的第一个助手：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that the helper is defined within the `helpers` function of the Meteor
    template object: `Template.<your_template>.helpers(<your_helpers>)`. Helpers are
    mostly functions that will return anything you want them to including Meteor collection
    cursors. Let''s bring all this together now:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，助手是在 Meteor 模板对象的 `helpers` 函数中定义的：`Template.<your_template>.helpers(<your_helpers>)`。助手主要是返回任何你想要它们返回的内容的函数，包括
    Meteor 集合游标。现在让我们把这些放在一起：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will output `Hello Mr Someone` inside the `h1` HTML tag. Let''s add a
    slightly more complex helper:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `h1` HTML 标签内输出 `Hello Mr Someone`。让我们添加一个稍微复杂一些的助手：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we are using `with` to set up the **data context** of the HTML
    tags that belong to it; this data context is equivalent to `person`. Data context
    refers to the value of `this` inside a helper. So if you set up an object as the
    data context, `this` will be equivalent to that object. Also, we iterate through
    `children` with an `each` statement so that we can list out their names.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `with` 来设置属于它的 HTML 标签的 **数据上下文**；这个数据上下文等同于 `person`。数据上下文指的是助手内部
    `this` 的值。所以如果你设置一个对象作为数据上下文，`this` 将等同于那个对象。此外，我们使用 `each` 语句遍历 `children`，以便列出它们的名称。
- en: Events
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'Meteor taps into common JavaScript HTML events such as click, change, and focus.
    An event is anything that happens to an HTML element that you are listening to.
    Suppose we want to be able to change the name of a person to one of the children
    by clicking on them. We do this through the templates'' event map. Let''s take
    a look at an example of how we can do this without using reactivity or collections:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 利用常见的 JavaScript HTML 事件，如点击、更改和焦点。事件是任何发生在你正在监听 HTML 元素上的事情。假设我们想要能够通过点击它们来将一个人的名字更改为其中一个孩子的名字。我们通过模板的事件映射来完成这个操作。让我们看看一个例子，说明我们如何在不使用响应性或集合的情况下完成这个操作：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Easy! So to catch template events, we need to use the `Template.<your_template>.events(<your_event_map>)`
    function. In this particular example, we are using jQuery to replace text.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！为了捕获模板事件，我们需要使用 `Template.<your_template>.events(<your_event_map>)` 函数。在这个特定的例子中，我们使用
    jQuery 来替换文本。
- en: 'The `event map` is an object where the properties specify a set of events to
    be handled. These events may be specified in any of the following ways:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`event map` 是一个对象，其中属性指定了一组要处理的事件。这些事件可以以下任何一种方式指定：'
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The key `string` of the event is composed of two parts: the first is always
    a type of event (click, hover, change, and so on) while the second is always a
    CSS selector.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的关键 `string` 由两部分组成：第一部分始终是事件类型（点击、悬停、更改等），而第二部分始终是 CSS 选择器。
- en: The event loop and the merge box
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环和合并框
- en: Before diving into Meteor, it is critical to understand what the event loop
    and the merge box are and how they can adversely affect your code. Both are relatively
    complex in the way that they were programmed, so we will focus on understanding
    the general concept.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究 Meteor 之前，理解事件循环和合并框是什么，以及它们如何对你的代码产生不利影响是至关重要的。两者在编程方式上都是相对复杂的，所以我们将会关注理解一般概念。
- en: The event loop
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: The event loop is like a queue; it runs a series of functions one by one. Because
    functions are processed sequentially, each function effectively blocks others
    from being processed until the function is done.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环就像一个队列；它依次运行一系列函数。因为函数是顺序处理的，所以每个函数实际上阻止其他函数在完成之前被处理。
- en: In other words, the event loop functions much like a single-line conveyor belt
    where things are being inspected. For every inspection made, the line is stopped
    and nothing moves.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，事件循环的功能就像一个单行传送带，其中事物正在被检查。对于每次检查，生产线都会停止，什么也不移动。
- en: Meteor uses Fibers – a NodeJS library – to get around this issue. Many of the
    functions that you will run will be on a separate fiber. What does this mean?
    This means that the functions will run on a separate conveyor belt for processing.
    Still, not all functions are built this way, you need to make sure your server-side
    functions do not block the server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 使用 Fibers – 一个 NodeJS 库 – 来解决这个问题。你将运行的大多数函数将在一个单独的纤维上运行。这意味着函数将在一个单独的处理传送带上运行。尽管如此，并非所有函数都是这样构建的，你需要确保你的服务器端函数不会阻止服务器。
- en: So which functions could potentially cause the server to get blocked? `Meteor.methods()`,
    `Meteor.publish()`, and `any` function that does not run inside a fiber on the
    server. Let's see how we can unblock each one and when we should do this.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪些函数可能会使服务器被阻止？`Meteor.methods()`、`Meteor.publish()` 以及任何不在服务器纤维内运行的函数。让我们看看我们如何解除每个函数的限制，以及何时应该这样做。
- en: 'Functions defined under the `Meteor.methods()` that you know are going to take
    a long time to process, should always run on a Fiber or defer time consuming code
    to a Fiber. We can quickly solve this by calling the `@unblock()` function from
    within the method. Let''s look at an example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道在 `Meteor.methods()` 下定义的函数将需要很长时间来处理，应该始终在纤维上运行或在纤维上延迟耗时的代码。我们可以通过在方法内部调用
    `@unblock()` 函数来快速解决这个问题。让我们看看一个例子：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, when you run `Meteor.call("time_consuming")`, the server will
    be blocked. When the server is blocked, other visitors won't be able to reach
    your site! Instead if you run `Meteor.call("time_consuming_unblock")`, the server
    will continue to function properly but consume more resources to do so.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你运行 `Meteor.call("time_consuming")` 时，服务器将被阻止。当服务器被阻止时，其他访客将无法访问你的网站！相反，如果你运行
    `Meteor.call("time_consuming_unblock")`，服务器将继续正常工作，但会消耗更多资源来这样做。
- en: '`Meteor.publish()` can be easily unblocked after installing the `meteorhacks:unblock`
    package as well. This one will be particularly useful when we start to make very
    complex publishers that might consume a lot of resources. Let''s look at an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 `meteorhacks:unblock` 包后，`Meteor.publish()` 也可以轻松解除限制。当我们要开始创建可能消耗大量资源的非常复杂的发布者时，这个包将特别有用。让我们看看一个例子：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we are waiting for an HTTP call to respond. This will certainly
    block the server if we subscribe to `external_API_query`, so we use `external_API_query_unblocked`
    instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在等待一个 HTTP 调用响应。如果我们订阅了 `external_API_query`，这肯定会阻止服务器，所以我们使用 `external_API_query_unblocked`
    代替。
- en: 'All other functions that run on the server and you know are going to block
    the server, should run on a fiber. Meteor has a special function to help us make
    this easy. It is called `Meteor.wrapAsync()`. Let''s see how this works:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他在服务器上运行且你知道会阻止服务器的函数，都应该在纤维上运行。Meteor 有一个特殊的功能帮助我们轻松实现这一点。它被称为 `Meteor.wrapAsync()`。让我们看看它是如何工作的：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is very important to keep the event loop in mind, especially when we're connecting
    our web application to external services that are going to cause massive delays
    to our server.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 记住事件循环非常重要，尤其是在我们将我们的网络应用程序连接到将导致服务器出现巨大延迟的外部服务时。
- en: The merge box
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并框
- en: The merge box is the algorithm that identifies all the changes that are happening
    to the database. It basically handles publishers, subscribers, and reactivity.
    The merge box also handles the initial load of data using DDP messages.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 合并框是识别数据库中所有变化的算法。它基本上处理发布者、订阅者和反应性。合并框还使用 DDP 消息处理数据的初始加载。
- en: It is important to understand that we can communicate directly with the merge
    box via all the commands that are available to us under the `Meteor.publish()`
    function. The more optimal we can make our `Meteor.publish` functions, the faster
    the site will load.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，我们可以通过在 `Meteor.publish()` 函数下可用的所有命令直接与合并框进行通信。我们能使我们的 `Meteor.publish`
    函数更加优化，网站加载速度就会更快。
- en: The beginning of our online shop
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在线商店的开始
- en: 'Throughout the book we will be developing an e-commerce website to help us
    understand the core concepts of advanced Meteor web development. Let''s begin
    by creating a new project:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将开发一个电子商务网站，以帮助我们理解高级 Meteor 网络开发的核心概念。让我们从创建一个新的项目开始：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The must-have packages
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必备的包
- en: '[Atmospherejs.com](http://Atmospherejs.com) has always been the "go to" website
    to find packages. Here you will find thousands of packages produced by the community
    for free. There are a handful of packages that we absolutely need to install to
    make our website function properly.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[Atmospherejs.com](http://Atmospherejs.com) 一直是寻找包的“必去”网站。在这里，你可以找到社区免费提供的数千个包。有一些包我们绝对需要安装，以使我们的网站正常工作。'
- en: 'First, we install the languages:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们安装语言：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, the router and functions that will help us with SEO and routing:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍路由和帮助我们的 SEO 和路由的函数：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**WARNING**: Do not run Meteor yet! Canonical could mess up your project unless
    you have it set up correctly.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：不要运行 Meteor！除非你正确设置了 canonical，否则它可能会破坏你的项目。'
- en: 'We will need a couple of packages as well to help us manage publishers:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些包来帮助我们管理发布者：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'These next packages will extend Meteor''s functions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个包将扩展 Meteor 的功能：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will need these packages to properly manage time:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些包来正确管理时间：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For the last set, we''ll be using a couple of additional packages that will
    make the design process much faster:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一组，我们将使用一些额外的包，这将使设计过程变得更快：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We need to remove some packages for security too:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要移除一些包以增强安全性：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: All of these packages will be explained in more detail throughout the book,
    but all of these are must-haves. The first package that we need to explain is
    the `wizonesolutions:canonical` package. This package makes sure that all incoming
    traffic is routed to your `ROOT_URL`, so it is particularly useful when you want
    all the traffic to go to your SSL site. The first thing that we need to do before
    running Meteor is set up canonical to run only in the production environment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包将在本书的后续章节中详细介绍，但这些都是必需的。我们需要解释的第一个包是 `wizonesolutions:canonical` 包。这个包确保所有进入的流量都被路由到你的
    `ROOT_URL`，因此当你希望所有流量都流向你的 SSL 网站时特别有用。在运行 Meteor 之前，我们需要做的第一件事是设置 canonical 以只在生产环境中运行。
- en: 'Create `/server/canonical.coffee`, and add this code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `/server/canonical.coffee` 文件，并添加以下代码：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: What are environment variables? These variables are defined within the scope
    of the deployment, and they make sure that the project knows information before
    the build finishes on the server. Information such as what database to use, which
    domains to use, and other setup information can usually be found in these variables.
    We will cover this information in the final chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是什么？这些变量是在部署的范围内定义的，并且确保在服务器上的构建完成之前项目知道这些信息。例如，使用哪个数据库、使用哪个域名以及其他设置信息通常可以在这类变量中找到。我们将在最后一章中介绍这些信息。
- en: File structure
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件结构
- en: A proper file structure is tremendously important in Meteor. We have found that
    the best way to work is with functional top-level modules. This means that every
    folder is a micro-service, and therefore can act on its own. This allows for a
    lot of modularity in the project, and it's very easy for others to understand
    what it is that you are trying to accomplish. In this section, we will cover this
    file structure and Meteor's special folders.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Meteor 中，一个合适的文件结构非常重要。我们发现，最佳的工作方式是与功能顶级模块一起工作。这意味着每个文件夹都是一个微服务，因此可以独立运行。这为项目提供了很多模块化，并且其他人很容易理解你试图实现什么。在本节中，我们将介绍这个文件结构和
    Meteor 的特殊文件夹。
- en: 'Let''s look at a sample web application folder structure:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例网络应用程序的文件夹结构：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In this folder structure, `cart` is the micro-service, and it is composed of
    a route, view, controller, and publisher. The files placed under a `/client` directory
    will be published to the client and will only run on the client. The files placed
    under a `/server` directory will only run and be accessible on the server. If
    a file is placed in none of these directories, then the file will run on both
    the client and server. The expected structure goes like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹结构中，`cart` 是一个微服务，它由路由、视图、控制器和发布者组成。放在 `/client` 目录下的文件将被发布到客户端，并且只会在客户端运行。放在
    `/server` 目录下的文件只会在服务器上运行和访问。如果一个文件放在这些目录之外，那么这个文件将在客户端和服务器上同时运行。预期的结构如下：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It's important to note that the `/lib` directory will always run before any
    other code does. Let's place our canonical file under the `/_globals/canonical/server`
    directory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`/lib` 目录将始终在所有其他代码之前运行。让我们将我们的规范文件放在 `/_globals/canonical/server` 目录下。
- en: 'Let''s create our first module: the router. Create the `/router/client/layout.jade`
    directory, and we will only have one layout throughout the project. Now let''s
    code our layout:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个模块：路由器。创建`/router/client/layout.jade`目录，在整个项目中我们只有一个布局。现在让我们编写我们的布局代码：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we have introduced the `Template.dynamic` component. This component may
    be used to render other templates dynamically by changing the value of a variable
    to the name of the template we want to render. We decided to use two variables—`nav`
    and `content`— that are controlled by the router. So, basically, the `content`
    variable will be changing to different strings that are equal to the names of
    our templates.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了`Template.dynamic`组件。该组件可以通过更改变量的值来动态渲染其他模板，该值是我们想要渲染的模板的名称。我们决定使用两个变量——`nav`和`content`——这些变量由路由器控制。所以，基本上，`content`变量将改变为不同的字符串，这些字符串等于我们模板的名称。
- en: We will create our `landing` module in the next chapter to learn not only how
    to use the router but also how to properly subscribe to data.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中创建我们的`着陆`模块，以便学习不仅如何使用路由器，而且如何正确地订阅数据。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have addressed a lot of things in this chapter. We can now program faster
    because we have tools such as CoffeeScript, Jade, and Stylus to help us. Also,
    we have learned how to use templates, helpers, and events to work with our Meteor
    frontend. Understanding the event loop and the merge box has made us a bit more
    precautious when it comes to running complex, time-consuming operations. Finally,
    we began to build a project, and we adopted a folder structure that is going to
    make development quicker.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经解决了很多问题。现在我们可以更快地编程，因为我们有了像CoffeeScript、Jade和Stylus这样的工具来帮助我们。此外，我们还学会了如何使用模板、辅助工具和事件来处理我们的Meteor前端。理解事件循环和合并框使我们处理复杂、耗时操作时更加谨慎。最后，我们开始构建项目，并采用了一种将使开发更快的项目文件夹结构。
- en: 'In the next chapter, we will cover two of the most important parts that make
    a Meteor application viable: Meteor publishers and Meteor subscribers. With these
    patterns, you will be able to produce sites that load quickly and that do not
    put too much strain on the server.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍使Meteor应用程序可行的两个最重要的部分：Meteor发布者和Meteor订阅者。使用这些模式，您将能够创建快速加载且不会对服务器造成过多压力的网站。
