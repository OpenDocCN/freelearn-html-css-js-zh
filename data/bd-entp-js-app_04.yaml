- en: Setting Up Development Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发工具
- en: The first section of this book (Chapters 1-3) was written to provide sufficient
    background knowledge so that we can code without interruption. In this chapter,
    we will actually start building our user directory application, called 'hobnob',
    by setting up our local development environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分（第 1-3 章）是为了提供足够的背景知识，以便我们能够不间断地编码。在这一章中，我们将通过设置我们的本地开发环境，开始构建我们的用户目录应用程序，称为
    'hobnob'。
- en: 'The aim of this chapter is to help you understand how different tools and standards
    in the Node.js ecosystem work together. Specifically, we''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是帮助你理解 Node.js 生态系统中的不同工具和标准是如何协同工作的。具体来说，我们将涵盖以下内容：
- en: What is **Node.js**?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 **Node.js**？
- en: Different formats/standards for JavaScript **modules**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript **模块**的不同格式/标准
- en: Managing modules with `npm` and `yarn`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `npm` 和 `yarn` 管理模块
- en: Transpiling code with **Babel**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Babel** 转译代码
- en: Watching for changes with `nodemon`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `nodemon` 监视更改
- en: Linting our code with **ESLint**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **ESLint** 检查我们的代码
- en: What is Node.js?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Node.js？
- en: As you learned in [Chapter 2](47a4c8b3-b1b3-4095-b127-621624a2fa37.xhtml), *The
    State of JavaScript*, Node.js is "JavaScript on the server". Before we move forward,
    let's delve a little deeper into understanding what that means.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 [第 2 章](47a4c8b3-b1b3-4095-b127-621624a2fa37.xhtml) 中所学到的，《JavaScript 的状态》，Node.js
    是“服务器上的 JavaScript”。在我们继续前进之前，让我们更深入地了解这意味着什么。
- en: Traditionally, JavaScript is interpreted by a JavaScript engine that converts
    JavaScript code into more optimized, machine-executable code, which then gets
    executed. The engine interprets the JavaScript code at the time it is run. This
    is unlike **compiled languages** such as C#, which must first be compiled into
    an **intermediate language** (**IL**), where this IL is then executed by the **common
    language runtime** (**CLR**), software similar in function to the JavaScript engine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，JavaScript 由一个 JavaScript 引擎解释，该引擎将 JavaScript 代码转换为更优化的、机器可执行的代码，然后执行。该引擎在运行时解释
    JavaScript 代码。这与 **编译型语言**（如 C#）不同，编译型语言必须首先编译成 **中间语言**（**IL**），然后由 **公共语言运行时**（**CLR**）执行，这种软件与
    JavaScript 引擎功能相似。
- en: Technically, it is inaccurate to classify a language as interpreted or compiled—how
    a language is processed depends on the implementation. Someone can build a compiler
    that converts JavaScript into machine code and run it; in that instance, JavaScript
    would be a compiled language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，将一种语言分类为解释型或编译型是不准确的——语言的处理方式取决于实现。有人可以构建一个将 JavaScript 转换为机器代码的编译器并运行它；在这种情况下，JavaScript
    将是一种编译型语言。
- en: However, since JavaScript is almost always interpreted by a JavaScript engine,
    you'll often hear people refer to JavaScript as an interpreted language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 JavaScript 几乎总是由 JavaScript 引擎进行解释，你经常会听到人们将 JavaScript 称为解释型语言。
- en: Different browsers use different JavaScript engines. Chrome uses V8, Firefox
    uses SpiderMonkey, WebKit browsers such as Safari use JavaScriptCore, and Microsoft
    Edge uses Chakra. Node.js uses V8 as its JavaScript engine and adds C++ bindings
    that allow it to access operating system resources, such as files and networking.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不同浏览器使用不同的 JavaScript 引擎。Chrome 使用 V8，Firefox 使用 SpiderMonkey，WebKit 浏览器（如 Safari）使用
    JavaScriptCore，而 Microsoft Edge 使用 Chakra。Node.js 使用 V8 作为其 JavaScript 引擎，并添加了
    C++ 绑定，使其能够访问操作系统资源，如文件和网络。
- en: Terminology
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: Because JavaScript was traditionally interpreted at runtime, and because runtimes
    in other languages (such as C#, mentioned before) do actually execute the code,
    many people incorrectly call the JavaScript engine the JavaScript runtime.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 通常是运行时进行解释，并且由于其他语言的运行时（如之前提到的 C#）实际上执行代码，许多人错误地将 JavaScript 引擎称为
    JavaScript 运行时。
- en: But, they are different things—the engine is the software that translates the
    high-level JavaScript code into machine-executable code, and then executes it.
    The JavaScript engine then exposes all the objects obtained from parsing the code
    to the JavaScript runtime environment, which can then use it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它们是不同的事物——引擎是将高级 JavaScript 代码转换为机器可执行代码的软件，然后执行它。JavaScript 引擎然后将从解析代码中获取的所有对象暴露给
    JavaScript 运行时环境，然后它可以使用它们。
- en: So, JavaScript in the browser and Node.js both use the same V8 engine, but run
    in different runtime environments. For example, the browser runtime environment
    provides the `window` global object, which is not available in the Node.js runtime.
    Conversely, the browser runtime lacks the `require` global, and cannot act on
    system resources such as file systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，浏览器中的JavaScript和Node.js都使用相同的V8引擎，但运行在不同的运行时环境中。例如，浏览器运行时环境提供了`window`全局对象，这在Node.js运行时中不可用。相反，浏览器运行时缺少`require`全局，并且无法对系统资源（如文件系统）进行操作。
- en: Modules
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: As mentioned in [Chapter 1](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml), *The
    Importance of Good Code*, clean code should be structured in a modular way. In
    the next few sections, we'll introduce you to the concept of modular design, before
    explaining the different module formats. Then, for the rest of the chapter, we
    will begin composing our project by incorporating existing Node modules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](c2152f5d-2812-4841-850e-9a1437d06a5c.xhtml)“好代码的重要性”中提到的，干净的代码应该以模块化的方式进行结构化。在接下来的几节中，我们将向您介绍模块化设计的概念，然后解释不同的模块格式。然后，在本章的剩余部分，我们将通过整合现有的Node模块来开始构建我们的项目。
- en: 'But first, let''s remind ourselves why modular design is important. Without
    it, the following apply:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们提醒自己模块化设计的重要性。没有它，以下情况适用：
- en: Logic from one business domain can easily be interwoven with that of another
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个业务领域的逻辑可以很容易地与另一个交织在一起
- en: When debugging, it's hard to identify where the bug is
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调试时，很难确定错误在哪里
- en: There'll likely be duplicate code
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很可能存在重复的代码
- en: 'Instead, writing modular code means the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，编写模块化代码意味着以下内容：
- en: Modules are logical separations of domains—for example, for a simple social
    network, you might have a module for user accounts, one for user profiles, one
    for posts, one for comments, and so on. This ensures a clear **separation of concerns**.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是领域的逻辑分离——例如，对于一个简单的社交网络，你可能有一个用户账户模块，一个用户资料模块，一个帖子模块，一个评论模块，等等。这确保了清晰的**关注点分离**。
- en: Each module should have a very specific purpose—that is, it should be granular.
    This ensures that there is as much **code reusability** as possible. A side effect
    of code reusability is *consistency*, because changes to the code in one location
    will be applied everywhere.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块都应该有一个非常具体的目的——也就是说，它应该是细粒度的。这确保了尽可能多的**代码复用性**。代码复用性的一个副作用是**一致性**，因为对代码在一个位置的更改将应用到每个地方。
- en: Each module provides an API for other modules to interact with—for example,
    the comments module might provide methods that allow for creating, editing, or
    deleting a comment. It should also hide internal properties and methods. This
    turns the module into a black box, encapsulating internal logic to ensure that
    the API is as minimal as is practical.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块为其他模块提供交互的API——例如，评论模块可能提供允许创建、编辑或删除评论的方法。它还应该隐藏内部属性和方法。这使得模块成为一个黑盒，封装内部逻辑以确保API尽可能最小化。
- en: By writing our code in a modular way, we'll end up with many small and manageable
    modules, instead of one uncontrollable mess.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以模块化的方式编写我们的代码，我们最终会得到许多小而可管理的模块，而不是一个无法控制的混乱。
- en: The dawn of modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的时代
- en: 'Modules were not supported in JavaScript until ECMAScript 2015, because JavaScript
    was initially designed to add small bits of interactivity to web pages, not to
    cater for building full-fledged applications. When developers wanted to use a
    library or framework, they''d simply add `<script>` tags somewhere inside the
    HTML, and that library would be loaded when the page was loaded. However, this
    is not ideal as the scripts must be loaded in the correct order. For example,
    Bootstrap (a UI framework) depends on jQuery (a utility library), so we must manually
    check that the jQuery script is added first:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript直到ECMAScript 2015才支持模块，因为JavaScript最初是为了向网页添加小块交互性而设计的，而不是为了构建完整的应用程序。当开发者想要使用库或框架时，他们只需在HTML中某个地方添加`<script>`标签，该库就会在页面加载时被加载。然而，这并不理想，因为脚本必须按正确的顺序加载。例如，Bootstrap（一个UI框架）依赖于jQuery（一个实用库），因此我们必须手动检查jQuery脚本是否首先添加：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is fine as the dependency tree is relatively small and shallow. However,
    as **single-page applications** (**SPAs**) and Node.js applications become more
    popular, applications inevitably become more complex; having to manually arrange
    hundreds of modules in the correct order is impractical and error-prone:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这在依赖树相对较小且较浅的情况下是可以的。然而，随着**单页应用程序**（**SPAs**）和Node.js应用程序变得越来越流行，应用程序不可避免地变得更加复杂；手动排列数百个模块的正确顺序既不实际又容易出错：
- en: '![](img/f04647ba-e067-422b-9d24-c1e37fe4bfee.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f04647ba-e067-422b-9d24-c1e37fe4bfee.png)'
- en: The dependency tree for the Cordova npm package, where each node represents
    a discrete module
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Cordova npm包的依赖树，其中每个节点代表一个独立的模块
- en: Furthermore, many of these scripts add variables to the global namespace, or
    extend the prototypes of existing objects (for example, `Object.prototype` or
    `Array.prototype`). Because they are usually not namespaced, the scripts can clash/interfere
    with each other, or with our code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多这些脚本都会向全局命名空间添加变量，或者扩展现有对象的原型（例如，`Object.prototype`或`Array.prototype`）。由于它们通常没有命名空间，这些脚本可能会相互冲突/干扰，或者与我们的代码冲突。
- en: Because of the increasing complexity of modern applications, developers started
    creating **package managers** to organize their modules. Moreover, standard formats
    began to appear so that modules could be shared with the wider community.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代应用程序的复杂性不断增加，开发者开始创建**包管理器**来组织他们的模块。此外，标准格式也开始出现，以便模块可以与更广泛的社区共享。
- en: At the time of writing, there are three major package managers—**npm**, **Bower**, and
    **y****arn**—and four major standards in defining JavaScript modules—**CommonJS**,
    **AMD**, **UMD**, and **ES6 modules**. Each format also has accompanying tools
    to enable them to work on browsers, such as **RequireJS**, **Browserify**, **Webpack**,
    **Rollup**, and **SystemJS**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，有三个主要的包管理器——**npm**、**Bower**和**yarn**——以及四个主要的定义JavaScript模块的标准——**CommonJS**、**AMD**、**UMD**和**ES6模块**。每种格式也有相应的工具，使它们能够在浏览器上工作，例如**RequireJS**、**Browserify**、**Webpack**、**Rollup**和**SystemJS**。
- en: In the following section, we'll give a quick overview of different types of
    package managers, modules, and their tools. At the end of this section, we'll
    look more specifically at ES6 modules, which we will use for the rest of the book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要介绍不同类型的包管理器、模块及其工具。在本节的末尾，我们将更具体地探讨ES6模块，这是我们将在本书的其余部分使用的。
- en: The birth of Node.js modules
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js模块的诞生
- en: Using modules on the client was infeasible because an application can have hundreds
    of dependencies and sub-dependencies; having to download them all when someone
    visits the page is going to increase the **time-to-first-render** (**TTFR**),
    drastically impacting the user experience (UX). Therefore, JavaScript modules,
    as we know them today, began their ascent on servers with Node.js modules.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端使用模块不可行，因为一个应用程序可能有数百个依赖和子依赖；当有人访问页面时必须下载所有这些，这将增加**首次渲染时间**（**TTFR**），极大地影响用户体验（UX）。因此，我们今天所知道的JavaScript模块，是从Node.js模块在服务器上开始发展的。
- en: 'In Node.js, a single file corresponds to a single module:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，一个文件对应一个模块：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For instance, both of the preceding files—`greeter.js` and `main.js`—are each
    their own module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面提到的两个文件——`greeter.js`和`main.js`——每个都是它们自己的模块。
- en: Adoption of the CommonJS standard
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用CommonJS标准
- en: In Node.js, modules are written in the CommonJS format, which provides two global
    objects, `require` and `exports`, that developers can use to keep their modules
    encapsulated. `require` is a function that allows the current module to import
    and use variables defined in other modules. `exports` is an object that allows
    a module to make certain variables publicly available to other modules that `require` it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，模块是以CommonJS格式编写的，它提供了两个全局对象，`require`和`exports`，开发者可以使用它们来封装他们的模块。`require`是一个函数，允许当前模块导入并使用在其他模块中定义的变量。`exports`是一个对象，允许模块使其某些变量对其他`require`它的模块公开。
- en: 'For example, we can define two functions, `helloWorld` and `internal`, in `greeter.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在`greeter.js`中定义两个函数，`helloWorld`和`internal`：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By default, these two functions can only be used within the file (within the
    module). But, when we assign the `helloWorld` function to the `sayHello` property
    of `exports`, it makes the `helloWorld` function accessible to other modules that 
    `require` the `greeter` module.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这两个函数只能在文件内（在模块内）使用。但是，当我们把`helloWorld`函数赋值给`exports`的`sayHello`属性时，它使得`helloWorld`函数可以被其他`require``greeter`模块的模块访问。
- en: 'To demonstrate this, we can `require` the greeter module in `main.js` and use
    its `sayHello` export to print a message to the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们可以在`main.js`中`require` greeter模块，并使用其`sayHello`导出向控制台打印一条消息：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To `require` a module, you can either specify its name or its file path.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要`require`一个模块，你可以指定其名称或其文件路径。
- en: 'Now, when we run `main.js`, we get a message printed in the Terminal:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行`main.js`时，我们在终端中会得到一条打印的消息：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Fulfilling the encapsulation requirement
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 满足封装要求
- en: 'You can export multiple constructs from a single module by adding them as properties
    to the `exports` object. Constructs that are not exported are not available outside
    the module because Node.js wraps its modules inside a **module wrapper**, which
    is simply a function that contains the module code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将它们作为属性添加到`exports`对象中来从单个模块导出多个构造函数。未导出的构造函数在模块外部不可用，因为Node.js在其模块内部包装了一个**模块包装器**，它只是一个包含模块代码的函数：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This fulfills the encapsulation requirement of modules; in other words, the
    module restricts direct access to certain properties and methods of the module.
    Note that this is a feature of Node.js, not CommonJS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这满足了模块的封装要求；换句话说，模块限制了直接访问模块的某些属性和方法。请注意，这是一个Node.js的特性，而不是CommonJS。
- en: Standardizing module formats
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准化模块格式
- en: Since CommonJS, multiple module formats have emerged for client-side applications,
    such as AMD and UMD. AMD, or *Asynchronous Module Definition*, is an early fork
    of the CommonJS format, and supports **asynchronous module loading**. This means
    modules that do not depend on each other can be loaded in parallel, partially
    alleviating the slow startup time that clients face if they use CommonJS on the
    browser.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 自从CommonJS以来，客户端应用程序出现了多种模块格式，例如AMD和UMD。AMD，或称**异步模块定义**，是CommonJS格式的早期分支，支持**异步模块加载**。这意味着不相互依赖的模块可以并行加载，这在一定程度上缓解了如果客户端在浏览器中使用CommonJS时遇到的缓慢启动时间。
- en: 'Whenever there are multiple unofficial standards, someone will usually come
    up with a *new* standard that''s supposed to unify them all:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每当存在多个非官方标准时，通常有人会提出一个**新的**标准来统一它们：
- en: '![](img/e0298913-b74a-4ddf-aec5-dcc9d7210b65.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0298913-b74a-4ddf-aec5-dcc9d7210b65.png)'
- en: From the XKCD comic titled "Standards" ([h](https://xkcd.com/927/)[ttps://xkcd.com/927/](https://xkcd.com/927/));
    used with permission under a Creative Commons Attribution-NonCommercial 2.5 License
    ([http://creativecommons.org/licenses/by-nc/2.5/](http://creativecommons.org/licenses/by-nc/2.5/))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 来自XKCD漫画标题为“Standards”的图片([h](https://xkcd.com/927/)[ttps://xkcd.com/927/](https://xkcd.com/927/))；在Creative
    Commons Attribution-NonCommercial 2.5许可下使用([http://creativecommons.org/licenses/by-nc/2.5/](http://creativecommons.org/licenses/by-nc/2.5/))
- en: This is what happened with UMD, or *Universal Module Definition*. UMD modules
    are compatible with both AMD and CommonJS, and this also exposes a global variable
    if you want to include it on your web page as a `<script>` tag. But, because it
    tries to be compatible with all formats, there's a lot of boilerplate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是UMD，或称**通用模块定义**的情况。UMD模块与AMD和CommonJS都兼容，并且如果你想在网页上作为`<script>`标签包含它，它也会暴露一个全局变量。但是，因为它试图与所有格式兼容，所以有很多样板代码。
- en: 'Eventually, the task of unifying JavaScript module formats was taken on by the **Ecma
    International**, which standardized modules in the ECMAScript 2015 (ES6) version
    of JavaScript. This module format uses two keywords: `import` and `export`. The
    same `greeter` example would look like this with ES6 modules:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，统一JavaScript模块格式的任务由**Ecma International**承担，它在JavaScript的ECMAScript 2015（ES6）版本中标准化了模块。这种模块格式使用两个关键字：`import`和`export`。使用ES6模块的相同`greeter`示例将如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You'd still have two files—`greeter.js` and `main.js`; the only difference here
    is that `exports.sayHello = helloWorld;` is replaced by `export default helloWorld;`,
    and `const greeter = require('./greeter.js');` is replaced by `import greeter
    from "./greeter.js";`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然会有两个文件——`greeter.js`和`main.js`；这里唯一的区别是`exports.sayHello = helloWorld;`被替换为`export
    default helloWorld;`，而`const greeter = require('./greeter.js');`被替换为`import greeter
    from "./greeter.js";`。
- en: Furthermore, ES6 modules are **static**, meaning they cannot be changed at runtime.
    In other words, you cannot decide during runtime whether a module should be imported.
    The reason for this is to allow the modules to be analyzed and the dependency
    graph to be built beforehand.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ES6模块是**静态的**，这意味着它们在运行时不能被更改。换句话说，你无法在运行时决定是否导入一个模块。这样做的原因是允许在之前分析模块并构建依赖图。
- en: Node.js and popular browsers are quickly adding support for ECMAScript 2015
    features, but currently none of them fully support modules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 和流行的浏览器正在快速添加对 ECMAScript 2015 特性的支持，但目前它们中没有一个完全支持模块。
- en: You can view the full compatibility table for ECMAScript features in the Kangax
    Compatibility Table at [kangax.github.io/compat-table/](http://kangax.github.io/compat-table/es6/).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Kangax 兼容性表（[kangax.github.io/compat-table/](http://kangax.github.io/compat-table/es6/)）中查看
    ECMAScript 特性的完整兼容性表。
- en: Luckily, there are tools that can convert ECMAScript 2015 modules into the universally
    supported CommonJS format. The most popular are **Babel** and **Traceur**. In
    this book, we will use Babel because it is the *de facto* standard.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些工具可以将 ECMAScript 2015 模块转换为普遍支持的 CommonJS 格式。最受欢迎的是 **Babel** 和 **Traceur**。在这本书中，我们将使用
    Babel，因为它是 *de facto* 标准。
- en: Installing Node
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Node
- en: 'With that background on modules out of the way, let''s begin the development
    of our application by installing Node.js on our local machine. Just like the saying
    "Many roads lead to Rome", there are many ways to install Node.js on your machine.
    You can do one of the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的背景知识已经解决之后，让我们通过在我们的本地机器上安装 Node.js 来开始我们的应用程序开发。就像俗语所说“条条大路通罗马”，安装 Node.js
    到你的机器上有许多方法。你可以做以下之一：
- en: Go to [https://nodejs.org/](https://nodejs.org/en/download/) and download its
    source code (in the form of a `*.tar.gz` archive)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 [https://nodejs.org/](https://nodejs.org/en/download/) 并下载其源代码（以 `*.tar.gz`
    归档的形式）
- en: Go to [https://nodejs.org/](https://nodejs.org/en/download/) and download an
    installer
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 [https://nodejs.org/](https://nodejs.org/en/download/) 并下载安装程序
- en: Go to [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)
    and download the Node version that's listed on your operating system's package
    repository
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)
    并下载你操作系统包仓库上列出的 Node 版本
- en: But the easiest way is to use **Node Version Manager** (**nvm**), which has
    the added benefit of allowing you to download and switch between different versions
    of Node. This is especially handy if you're working on different Node projects
    at the same time, each using a different version.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但最简单的方法是使用 **Node 版本管理器**（**nvm**），它还有一个额外的优点，就是允许你下载和切换不同版本的 Node。如果你同时在不同版本的
    Node 项目上工作，这尤其方便，每个项目使用不同的版本。
- en: There are several popular programs that manage the Node versions for you. `nvm`
    and `nave` manage Node versions per user/shell, which means different users on
    the same machine can use different versions of Node. There's also `n`, which manages
    the global/system-wide Node version. Lastly, `nodenv` can also be useful as it
    can automatically detect the correct version of Node to use for your project.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种流行的程序可以为你管理 Node 版本。`nvm` 和 `nave` 按用户/shell 管理节点版本，这意味着同一台机器上的不同用户可以使用不同的
    Node 版本。还有 `n`，它管理全局/系统范围内的 Node 版本。最后，`nodenv` 也可以很有用，因为它可以自动检测用于你的项目的正确 Node
    版本。
- en: Using nvm to install Node
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nvm 安装 Node
- en: 'You can install nvm using the shell script it provides:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用它提供的 shell 脚本来安装 nvm：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that it is never a good idea to run a shell script directly from the internet
    without first examining the content. Therefore, you should first go to [https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh](https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh)
    and check the commands that would be run before you actually run it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在没有首先检查内容的情况下直接从互联网上运行 shell 脚本从来不是一个好主意。因此，你应该首先访问 [https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh](https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh)
    并检查在真正运行之前将要运行的命令。
- en: This will clone the nvm repository to `~/.nvm` and adds a line to your profile
    (`~/.bash_profile`, `~/.zshrc`, `~/.profile`, or `~/.bashrc`) so that nvm will
    be loaded when your user logs in.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将克隆 nvm 仓库到 `~/.nvm` 并在你的配置文件（`~/.bash_profile`、`~/.zshrc`、`~/.profile` 或 `~/.bashrc`）中添加一行，以便在用户登录时加载
    nvm。
- en: 'Now, we can use nvm to install Node. First, let''s check the versions of Node
    that are available using the `nvm ls-remote` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 nvm 来安装 Node。首先，让我们使用 `nvm ls-remote` 命令检查可用的 Node 版本：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It will come back with a huge list of every Node.js version, and we can install
    a specific version by running `nvm install <version>`, where version is the version
    number (for example, `6.11.1`) or the name of the long-term support (LTS) version (for
    example, `lts/boron`):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它会返回一个包含每个 Node.js 版本的巨大列表，我们可以通过运行 `nvm install <version>` 来安装特定版本，其中版本是版本号（例如，`6.11.1`）或长期支持（LTS）版本的名称（例如，`lts/boron`）：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We want to use the latest LTS version of Node. At the time of writing, that''s
    `8.11.4`, so we can run `nvm install 8.11.4`. Better still, we can use the shorthand
    `nvm install lts/*`, which will default to the latest LTS version of Node:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用 Node 的最新 LTS 版本。在撰写本文时，那是 `8.11.4`，因此我们可以运行 `nvm install 8.11.4`。更好的是，我们可以使用简写
    `nvm install lts/*`，这将默认为 Node 的最新 LTS 版本：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can check that Node has been successfully installed by running `node -v`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行 `node -v` 来检查 Node 是否已成功安装：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we installed Node, we also automatically installed the npm CLI, which
    is the package manager for Node.js:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装 Node 时，我们也自动安装了 npm CLI，这是 Node.js 的包管理器：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Documenting Node versions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录 Node 版本
- en: 'We should document which version of Node we are running our API server with.
    To do this with nvm, we simply have to define a `.nvmrc` file in the root directory
    of our project. Then, any developers working on the API will be able to use the
    right Node version by running `nvm use`. Therefore, create a new project directory
    and run `git init` to create a new Git repository. Once that''s done, create a
    new `.nvmrc` file that contains a single line that reads `8.11.4`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该记录我们使用哪个版本的 Node 运行我们的 API 服务器。为此，使用 nvm，我们只需在我们的项目根目录中定义一个 `.nvmrc` 文件。然后，任何正在开发
    API 的开发者都可以通过运行 `nvm use` 来使用正确的 Node 版本。因此，创建一个新的项目目录并运行 `git init` 以创建一个新的 Git
    仓库。一旦完成，创建一个新的 `.nvmrc` 文件，其中包含一个读取为 `8.11.4` 的单行：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Starting projects with npm
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm 开始项目
- en: For Node.js projects, the settings and configurations are stored inside a file
    named `package.json`, located at the root of the repository. The npm CLI tool
    provides a `npm init` command, which will initiate a mini-wizard that helps you
    compose your `package.json` file. So, inside our project directory, run `npm init` to
    initiate the wizard.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Node.js 项目，设置和配置存储在一个名为 `package.json` 的文件中，位于仓库的根目录。npm CLI 工具提供了一个 `npm
    init` 命令，该命令将启动一个迷你向导，帮助您创建 `package.json` 文件。因此，在我们的项目目录中，运行 `npm init` 以启动向导。
- en: 'The wizard will ask you a series of questions, but also provides sensible defaults.
    Let''s go through each question one by one:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 向导将提出一系列问题，但也提供了合理的默认值。让我们逐个过一遍这些问题：
- en: 'package name: We are happy with the default name of `hobnob` (derived from
    the directory name), so we can just press the Return key to continue.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包名：我们对默认的 `hobnob` 名称（来自目录名）感到满意，因此我们可以直接按回车键继续。
- en: 'version: We''re going to follow semantic versioning (semver) here and use major
    version 0(`0.y.z`) to indicate that our code base is under initial development,
    and that the API is not stable. Semver also recommends that our initial release
    be `0.1.0`.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 版本：我们将遵循语义化版本控制（semver），并使用主版本 0（`0.y.z`）来表示我们的代码库处于初始开发阶段，API 不可稳定。Semver 还建议我们的初始版本为
    `0.1.0`。
- en: 'description: A brief description of your project; if we make our application
    public on [npmjs.com](http://npmjs.com), this description will appear in the search
    results.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述：对您的项目的简要描述；如果我们将应用程序公开在 [npmjs.com](http://npmjs.com)，此描述将出现在搜索结果中。
- en: 'entry point: This should point to the root of the module, and is what is run
    when other modules require your module. We have not decided on the structure of
    our application yet, so just leave it at `index.js`, and we may change it later.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 入口点：这应该指向模块的根目录，并且是其他模块需要您的模块时运行的文件。我们尚未决定应用程序的结构，所以先将其留为 `index.js`，我们可能稍后会更改它。
- en: 'test command: This will be run when we run `npm run test`. We will integrate
    with the Cucumber and Mocha testing frameworks later; for now, just leave it blank.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试命令：当我们运行 `npm run test` 时，将会执行此命令。我们稍后会集成 Cucumber 和 Mocha 测试框架；目前，只需将其留空即可。
- en: 'git repository: Use the remote repository we created earlier, for example,
    `git@github.com:d4nyll/hobnob.git`.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Git 仓库：使用我们之前创建的远程仓库，例如，`git@github.com:d4nyll/hobnob.git`。
- en: 'keywords: These are comma-separated keywords that help others search for your
    package on [npmjs.com.](https://www.npmjs.com/)'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键词：这些是逗号分隔的关键词，有助于他人搜索 [npmjs.com](https://www.npmjs.com/) 上的您的包。
- en: 'author: Put your details here in the format of `FirstName LastName <e@ma.il>
    (http://web.site/)`.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作者：请在此处以 `FirstName LastName <e@ma.il> (http://web.site/)` 的格式填写您的详细信息。
- en: 'license: The license tells others how they can use our code. It should be one
    of the identifiers in the SPDX License List ([https://spdx.org/licenses/](https://spdx.org/licenses/)).
    For example, the MIT License would be `MIT`, and the GNU General Public License
    v3.0 would be `GPL-3.0`.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许可证：许可证告诉其他人他们如何使用我们的代码。它应该是 SPDX 许可证列表中的一个标识符（[https://spdx.org/licenses/](https://spdx.org/licenses/)）。例如，MIT
    许可证将是 `MIT`，GNU 通用公共许可证 v3.0 将是 `GPL-3.0`。
- en: There are two main types of open source licenses—**permissive** licenses focus
    on allowing others to do whatever they want with your code; while **copyleft**
    licenses promote sharing and require the sharing of derivative code under the
    same terms. If you're unsure which license to choose, check out [choosealicense.com](https://choosealicense.com/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的开源许可证类型——**宽松**许可证侧重于允许他人对你的代码做任何他们想做的事情；而**版权左**许可证促进共享，并要求在相同条款下共享衍生代码。如果你不确定选择哪个许可证，请查看
    [choosealicense.com](https://choosealicense.com/)。
- en: 'After you''ve completed the wizard, it''ll show you a preview of the `package.json`
    file; press the Return key to confirm. You can also take a look at the newly-created `package.json`
    file to check:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完成向导后，它将显示 `package.json` 文件的预览；按 Return 键确认。你还可以查看新创建的 `package.json` 文件以进行检查：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `package.json` file contains information about your project, as well as
    a list of packages that your project depends on. Having a `package.json` file,
    it allows collaborators to quickly set up the project on their local environment—all
    they have to do is run `npm install`, and all the project's dependencies will
    be installed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件包含有关你的项目的信息，以及项目所依赖的包列表。拥有 `package.json` 文件，它允许协作者快速在本地环境中设置项目——他们只需运行
    `npm install`，项目所有依赖项就会被安装。'
- en: Using yarn instead of npm
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 yarn 代替 npm
- en: '`npm` is the default package manager, but Facebook, in collaboration with Exponent,
    Google, and Tilde, has since developed a better alternative, called `yarn`, which
    we will use instead.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 是默认的包管理器，但 Facebook 与 Exponent、Google 和 Tilde 合作，已经开发了一个更好的替代品，称为 `yarn`，我们将使用它。'
- en: '`yarn` ([https://yarnpkg.com/en/](https://yarnpkg.com/en/)) uses the same [https://www.npmjs.com/](https://www.npmjs.com/)
    registry as the `npm` CLI. Since they both just install packages inside `node_modules`
    directories and write to `package.json`, you can use `npm` and `yarn` interchangeably.
    The differences are in their methods for resolving and downloading dependencies.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarn` ([https://yarnpkg.com/en/](https://yarnpkg.com/en/)) 使用与 `npm` CLI 相同的
    [https://www.npmjs.com/](https://www.npmjs.com/) 注册表。由于它们两者都在 `node_modules` 目录中安装包并写入
    `package.json`，因此你可以互换使用 `npm` 和 `yarn`。它们之间的区别在于解决和下载依赖项的方法。'
- en: Package version locking
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件包版本锁定
- en: When we specify our dependencies inside our `package.json` file, we can use
    symbols to indicate a range of acceptable versions. For example, `>version` means
    the installed version must be greater than a certain version, `~version` means
    approximately equivalent (which means it can be up to the next minor version),
    and `^version` means compatible (which usually means the highest version without
    a change in the major version). This means that given the same `package.json`
    file, it's likely that you'll install a different set of package versions than
    your colleagues.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `package.json` 文件中指定依赖项时，我们可以使用符号来表示可接受版本的范围。例如，`>version` 表示安装的版本必须大于某个版本，`~version`
    表示大约等效（这意味着它可以达到下一个次版本），而 `^version` 表示兼容（通常意味着最高版本且主要版本没有变化）。这意味着，给定相同的 `package.json`
    文件，你安装的包版本集可能与同事不同。
- en: '`yarn`, by default, creates a **lock file**, `yarn.lock`. The lock file ensures
    that the exact version of every package is recorded, so that everyone who installs
    using the lock file will have exactly the same version of every package.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarn` 默认创建一个锁文件，即 `yarn.lock`。锁文件确保记录了每个包的确切版本，因此使用锁文件安装的人将拥有每个包的完全相同的版本。'
- en: '`npm`, on the other hand, only made its lock files as defaults in version 5.0.0
    with `package-lock.json`. Prior to this, developers had to run `npm shrinkwrap` manually
    to generate a `npm-shrinkwrap.json` file—the predecessor to `package-lock.json`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`npm` 在 5.0.0 版本中将锁文件作为默认设置，即 `package-lock.json`。在此之前，开发者必须手动运行 `npm shrinkwrap`
    来生成 `npm-shrinkwrap.json` 文件——这是 `package-lock.json` 的前身。
- en: Offline cache
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线缓存
- en: When you install a package with `yarn`, it will save a copy of it at `~/.yarn-cache`.
    So, the next time you need to install a package in one of your projects, `yarn`
    will check this cache and use the local copy if possible. This saves a round trip
    to the server each time and allows you to work offline.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `yarn` 安装一个包时，它会在 `~/.yarn-cache` 中保存一个副本。因此，下次你需要在你项目中的一个包中安装包时，`yarn`
    会检查这个缓存，并在可能的情况下使用本地副本。这每次都节省了往返服务器的行程，并允许你离线工作。
- en: Speed
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度
- en: When you install a package and its dependencies, `npm` installs them sequentially,
    whereas `yarn` installs them in parallel. This means installing with `yarn` is
    consistently faster.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装一个包及其依赖项时，`npm` 会按顺序安装它们，而 `yarn` 会并行安装它们。这意味着使用 `yarn` 安装始终更快。
- en: Installing yarn
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 yarn
- en: 'There are many methods by which you can install `yarn`. The simplest one is
    to install it through npm (yes, this is quite ironic):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过许多方法安装 `yarn`。最简单的一种是通过 npm 安装它（是的，这相当讽刺）：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, this is not recommended because the packages are not signed, which
    means you cannot be sure it came from an authentic source; this poses a security
    risk. Therefore, it is recommended to follow the official installation instructions
    outlined at [https://yarnpkg.com/en/docs/install#windows-stable](https://yarnpkg.com/en/docs/install#windows-stable).
    For a Ubuntu machine, we should run the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不推荐，因为包没有被签名，这意味着你无法确定它来自一个可信的来源；这构成了安全风险。因此，建议遵循在 [https://yarnpkg.com/en/docs/install#windows-stable](https://yarnpkg.com/en/docs/install#windows-stable)
    中概述的官方安装说明。对于 Ubuntu 机器，我们应该运行以下命令：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Getting familiar with the yarn CLI
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 yarn CLI
- en: '`yarn` has most of the functionality for the `npm` CLI. The following table
    compares the corresponding commands:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarn` 拥有 `npm` CLI 的大多数功能。以下表格比较了相应的命令：'
- en: '| **Yarn 0.24.5** | **npm CLI 5.0.0** | **Description** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **Yarn 0.24.5** | **npm CLI 5.0.0** | **描述** |'
- en: '| `yarn` | `npm` | Alias for `yarn install` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `yarn` | `npm` | `yarn install` 的别名 |'
- en: '| `yarn install` | `npm install` | Installs dependencies specified in `yarn.lock`
    and `package.json` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `yarn install` | `npm install` | 安装 `yarn.lock` 和 `package.json` 中指定的依赖项
    |'
- en: '| `yarn add <package>` | `npm install <package>` | Installs the package, adds
    it to the dependencies list, and generates lock files (prior to 5.0.0, npm CLI
    required a `--save` flag) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `yarn add <package>` | `npm install <package>` | 安装包，将其添加到依赖列表，并生成锁文件（在 5.0.0
    之前，npm CLI 需要一个 `--save` 标志）|'
- en: '| `yarn remove <package>` | `npm uninstall <package>` | Uninstalls the package
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `yarn remove <package>` | `npm uninstall <package>` | 卸载指定的包 |'
- en: '| `yarn global add <package>` | `npm install <package> --global` | Installs
    a package globally |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `yarn global add <package>` | `npm install <package> --global` | 在全局范围内安装包
    |'
- en: '| `yarn upgrade` | `rm -rf node_modules && npm install` | Upgrades all packages
    to the latest version, as allowed by `package.json` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `yarn upgrade` | `rm -rf node_modules && npm install` | 将所有包升级到 `package.json`
    允许的最新版本 |'
- en: '| `yarn init` | `npm init` | Initializes the development of a package by following
    a short wizard |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `yarn init` | `npm init` | 通过简短的向导初始化包的开发 |'
- en: 'Apart from the basics, `yarn` also has some non-essential, but otherwise neat,
    features that''ll help you in your workflow:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本功能外，`yarn` 还有一些非基本但实用的功能，可以帮助你在工作流程中：
- en: '`yarn licenses ls`: Prints out, on the console, a list of packages, their URLs
    and their licenses'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn licenses ls`：在控制台上打印出包列表、它们的 URL 和它们的许可证'
- en: '`yarn licenses generate-disclaimer`: Generates a text file containing the licenses
    of all the dependencies'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn licenses generate-disclaimer`：生成包含所有依赖项许可证的文本文件'
- en: '`yarn why`: Generates a dependency graph to figure out why a package was downloaded—for
    example, it might be a dependency of a dependency of our application'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn why`：生成依赖图以确定为什么下载了某个包——例如，它可能是我们应用程序依赖项的依赖项'
- en: '`yarn upgrade-interactive`: Provides an interactive wizard that allows you
    to selectively upgrade outdated packages'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn upgrade-interactive`：提供一个交互式向导，允许你选择性地升级过时的包'
- en: You can get a full list of CLI commands at [https://yarnpkg.com/en/docs/cli/](https://yarnpkg.com/en/docs/cli/),
    or by running `yarn help` on your Terminal.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://yarnpkg.com/en/docs/cli/](https://yarnpkg.com/en/docs/cli/) 获取完整的
    CLI 命令列表，或者通过在终端运行 `yarn help` 来获取。
- en: npm and yarn, together
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm 和 yarn，共同
- en: '`yarn` is an improvement on `npm`, in terms of speed, consistency, security,
    and the general aesthetics of its console output. This has, in turn, made `npm`
    better—`npm` v5.0.0 introduced the following changes, obtained from the official
    announcement on the npm blog:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarn` 是对 `npm` 的改进，在速度、一致性、安全性以及控制台输出的整体美观性方面。这使得 `npm` 更好——`npm` v5.0.0 引入了以下变更，这些变更来自
    npm 博客的官方公告：'
- en: '`npm` will `--save` by default now. Additionally, `package-lock.json` will
    be automatically created unless an instance of `npm-shrinkwrap.json` exists.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` 现在默认使用 `--save`。此外，如果不存在 `npm-shrinkwrap.json` 实例，将自动创建 `package-lock.json`。'
- en: Package metadata, package download, and caching infrastructure have been replaced. The
    new cache is very fault-tolerant and supports concurrent access.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包的元数据、包下载和缓存基础设施已被替换。新的缓存非常容错，并支持并发访问。
- en: Running `npm` while offline will no longer insist on retrying network requests.
    `npm` will now immediately fall back to the cache if possible, or fail.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在离线状态下运行 `npm` 将不再坚持重试网络请求。如果可能，`npm` 现在将立即回退到缓存，或者失败。
- en: Creating an HTTP server
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 HTTP 服务器
- en: Next, we need to set up our project so that it can run ES6 code, specifically
    the ES6 modules feature. To demonstrate this, and also to show you how to debug
    your code, we're just going to create a simple HTTP server that always returns
    the string Hello, World!.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们的项目，使其能够运行 ES6 代码，特别是 ES6 模块功能。为了演示这一点，并展示如何调试你的代码，我们将创建一个简单的 HTTP
    服务器，该服务器总是返回字符串 Hello, World!。
- en: Normally, when we follow a TDD workflow, we should be writing our tests before
    we write our application code. However, for the purpose of demonstrating these
    tools, we will make a small exception here.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们遵循 TDD 工作流程时，我们应该在我们编写应用程序代码之前编写测试。然而，为了演示这些工具，我们将在这里稍作例外。
- en: 'Node.js provides the HTTP module, which contains a `createServer()` method
    ([https://nodejs.org/api/http.html#http_http_createserver_requestlistener](https://nodejs.org/api/http.html#http_http_createserver_requestlistener))that
    allows you to provision HTTP servers. At the root of your project directory, create
    an `index.js` file and add the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 提供了 HTTP 模块，其中包含一个 `createServer()` 方法 ([https://nodejs.org/api/http.html#http_http_createserver_requestlistener](https://nodejs.org/api/http.html#http_http_createserver_requestlistener))，允许你配置
    HTTP 服务器。在你的项目目录根目录下创建一个 `index.js` 文件，并添加以下内容：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are able to use ES6 syntax (such as `const`) here because ES2015 support
    has been good since Version 6 of Node. But ES6 modules are still unsupported,
    even in the latest version of Node. Therefore, we are using CommonJS's `require`
    syntax instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够在这里使用 ES6 语法（如 `const`），因为自 Node 版本 6 以来对 ES2015 的支持已经很好。但 ES6 模块仍然不受支持，即使在
    Node 的最新版本中也是如此。因此，我们使用 CommonJS 的 `require` 语法。
- en: Later in this chapter, we will demonstrate how to convert our source code to
    be written with the ES6 modules feature, using Babel to transpile it back to the
    universally supported CommonJS syntax.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将演示如何使用 Babel 将源代码转换为使用 ES6 模块功能编写的代码，并将其转译回广泛支持的 CommonJS 语法。
- en: To see the level of support for ES2015+ features in different versions of Node,
    go to [node.green](http://node.green/).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看不同版本的 Node 对 ES2015+ 特性的支持程度，请访问 [node.green](http://node.green/)。
- en: 'Once you''ve done that, open up a terminal and run `node index.js`. This should
    have started a server on `localhost:8080`. Now, if we send a request to `localhost:8080`,
    for instance by using a web browser, it''ll return with the text `Hello, World!`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，打开一个终端并运行 `node index.js`。这应该在 `localhost:8080` 上启动了一个服务器。现在，如果我们向 `localhost:8080`
    发送请求，例如通过使用网页浏览器，它将返回文本 `Hello, World!`：
- en: '![](img/04a1fff3-90f6-4284-86a1-e8d24de232a5.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04a1fff3-90f6-4284-86a1-e8d24de232a5.png)'
- en: 'If you get an `Error: listen EADDRINUSE :::8080` error, it means something
    else is using port `8080`; in that case, either terminate the process bound to
    port `8080`, or choose a different port instead by changing the number passed
    into `server.listen()`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你得到 `Error: listen EADDRINUSE :::8080` 错误，这意味着其他东西正在使用端口 `8080`；在这种情况下，要么终止绑定到端口
    `8080` 的进程，要么通过更改传递给 `server.listen()` 的数字来选择不同的端口。'
- en: The `node` process is currently running in the **foreground** and will continue
    to listen for further requests. To stop the `node` process (and thus our server),
    press Ctrl + C.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`node` 进程目前处于 **前台** 运行，并将继续监听进一步的请求。要停止 `node` 进程（以及我们的服务器），请按 Ctrl + C。'
- en: Pressing Ctrl + C sends an **interrupt signal** (`SIGINT`) to the Node program,
    which handles it and terminates the server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 按 Ctrl + C 会向 Node 程序发送一个 **中断信号** (`SIGINT`)，程序会处理该信号并终止服务器。
- en: Our HTTP server in detail
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们详细探讨 HTTP 服务器
- en: 'Let''s break down our HTTP server code to see what''s really going on. First,
    we `require` the `http` package so we can access the HTTP module''s methods:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们的 HTTP 服务器代码，看看实际上发生了什么。首先，我们 `require` 了 `http` 包，以便我们可以访问 HTTP 模块的方法：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we use the `createServer` method to create a server instance that listens
    to incoming requests. Inside it, we pass in a **request handler** function that
    takes a `req` and `res` parameters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `createServer` 方法创建一个服务器实例，该实例监听传入的请求。在其内部，我们传入一个 **请求处理器** 函数，该函数接受
    `req` 和 `res` 参数。
- en: Most developers use `req` and `res` as shorthands for "request" and "response"
    parameter names, but you can use any variable names you like.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者使用 `req` 和 `res` 作为“请求”和“响应”参数名称的缩写，但您可以使用您喜欢的任何变量名。
- en: The `req` parameter is an object containing information about the request, such
    as its origin IP, URL, protocol, body payload (if any), and so on. The `res` object
    provides methods that help you prepare the response message to send back to the
    client; for example, you can set the header, add a response body, specify the
    content type of the body, and so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`req` 参数是一个包含有关请求信息的对象，例如其原始 IP、URL、协议、正文负载（如果有）等。`res` 对象提供了帮助您准备响应消息并发送回客户端的方法；例如，您可以设置标题、添加响应正文、指定正文的内容类型等。'
- en: 'When we run `res.end()`, it finishes the preparation of the response and sends
    it back to the client. Here, we disregard what the request was, and it simply
    returns with `Hello, World!`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `res.end()` 时，它完成响应的准备并将其发送回客户端。在这里，我们忽略请求的内容，它简单地返回 `Hello, World!`：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have created a server instance and configured its response, the
    last step is to give it a port and instruct it to listen for requests on that
    port.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个服务器实例并配置了其响应，最后一步是为它指定一个端口并指示它在该端口上监听请求。
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Transpiling ES6 with Babel
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Babel 转译 ES6
- en: We've been using the CommonJS `require` syntax for modules; let's change it
    to use the ES6 module syntax (using `import`).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用 CommonJS 的 `require` 语法来处理模块；让我们改为使用 ES6 模块语法（使用 `import`）。
- en: 'In your code, update the first line to use `import`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，更新第一行以使用 `import`：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we try to run our server by executing `node index.js`, it will throw a `SyntaxError:
    Unexpected token import` error. This is because Node.js support for modules is
    still experimental, and not likely to be supported without the `--experimental-modules`
    flag until late 2018.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们尝试通过执行 `node index.js` 来运行我们的服务器时，它将抛出 `SyntaxError: Unexpected token import`
    错误。这是因为 Node.js 对模块的支持仍然是实验性的，并且在没有 `--experimental-modules` 标志的情况下，可能直到 2018
    年晚些时候才可能得到支持。'
- en: 'This means that for us to write our source code using ES6 modules, we need
    to add an extra step that will transpile the unsupported syntax into supported
    syntax. There are a few compilers/transpilers available for us to choose from:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为了我们能够使用 ES6 模块编写源代码，我们需要添加一个额外的步骤，该步骤将不支持的语法转译为支持的语法。我们有几个编译器/转译器可供选择：
- en: '**Babel**: The most popular and de facto standard for JavaScript compilers/transpilers.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Babel**：JavaScript 编译器/转译器的最受欢迎和事实上的标准。'
- en: '**Traceur**: Another compiler by Google.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Traceur**：Google 另一个编译器。'
- en: '**The TypeScript compiler**: TypeScript is a superset of JavaScript that provides
    static typing. Since valid JavaScript is also valid TypeScript, the TypeScript
    compiler can also act as an ES6 to ES5 transpiler.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript 编译器**：TypeScript 是 JavaScript 的超集，它提供了静态类型。由于有效的 JavaScript 也是有效的
    TypeScript，TypeScript 编译器也可以作为 ES6 到 ES5 的转译器。'
- en: '**The Closure compiler**: A compiler that optimizes your JavaScript by parsing
    and analyzing it, removing dead code, refactoring existing code, and minimizing
    the final results. It also warns the user of common mistakes. The Closure compiler
    supports the ES6 syntax, but transpiles everything down to ES5.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Closure 编译器**：一种通过解析和分析您的 JavaScript 来优化它的编译器，移除死代码，重构现有代码，并最小化最终结果。它还会警告用户常见的错误。Closure
    编译器支持 ES6 语法，但将所有内容转译为 ES5。'
- en: Whilst the TypeScript and Closure compilers are able to transpile ES6 to ES5,
    it is not their primary function; thus naturally, these features are of limited
    use here. Babel and Traceur are tools whose sole purpose is to transform the ES6/7/8/9
    and **ESNext** syntax to JavaScript that is supported by the environment, and
    so would be more suitable for our use. Of the two, Babel is, by far, the most
    popular and active, and will be the one we use in this project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TypeScript 和 Closure 编译器能够将 ES6 转换为 ES5，但这不是它们的主要功能；因此，这些功能在这里的使用有限。Babel
    和 Traceur 是专门用于将 ES6/7/8/9 和 **ESNext** 语法转换为环境支持的 JavaScript 的工具，因此更适合我们的使用。在这两个工具中，Babel
    是最受欢迎和最活跃的，我们将在这个项目中使用它。
- en: ESNext is a collective term for features that have been submitted by members
    of the community, but have not gone through Ecma's review process (the T39 Process),
    and thus have not been incorporated into the ECMAScript standard.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ESNext 是一个集合术语，用于指代由社区成员提交但尚未通过 Ecma 的审查过程（T39 流程）的功能，因此尚未纳入 ECMAScript 标准。
- en: 'There are 5 stages to the T39 Process: Strawman (Stage 0), Proposal (Stage
    1), Draft (Stage 2), Candidate (Stage 3), and Finished (Stage 4). You can get
    a more detailed description of each stage by going to [https://tc39.github.io/process-document/](https://tc39.github.io/process-document/).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: T39 流程有 5 个阶段：草稿（阶段 0）、提案（阶段 1）、草案（阶段 2）、候选（阶段 3）和完成（阶段 4）。你可以通过访问 [https://tc39.github.io/process-document/](https://tc39.github.io/process-document/)
    获取每个阶段的更详细描述。
- en: Babel is a transpiler...and more!
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Babel 是一个转换器……还有更多！
- en: 'Babel can transpile ES6/7/8/9 and ESNext syntax into syntax that works in the
    targeted environment. For example, let''s say we have a module that uses arrow
    functions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 可以将 ES6/7/8/9 和 ESNext 语法转换为在目标环境中工作的语法。例如，假设我们有一个使用箭头函数的模块：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we want this to be available on the browser, Babel can transpile it to ES5:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让它在浏览器上可用，Babel 可以将其转换为 ES5：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, if we are running Node v8.11.4, which natively supports arrow functions,
    it will leave the function unmodified.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们正在运行 Node v8.11.4，它原生支持箭头函数，它将不会修改该函数。
- en: Apart from supporting new ECMAScript versions, it also supports commonly used
    syntax such as JSX (used by React) and Flow static type annotations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了支持新的 ECMAScript 版本外，它还支持常用的语法，如 JSX（由 React 使用）和 Flow 静态类型注解。
- en: Different faces of Babel
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Babel 的不同方面
- en: Babel is a suite of tools—it is both a command-line tool, and a polyfill, and
    the packages are split up into many parts, such as `@babel/cli`, `@babel/register`, `@babel/node`,
    and `@babel/core`, all of which allow you to run ESNext code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 是一系列工具——它既是命令行工具，也是 polyfill，并且这些包被拆分为许多部分，如 `@babel/cli`、`@babel/register`、`@babel/node`
    和 `@babel/core`，所有这些都可以让你运行 ESNext 代码。
- en: So first, let's understand what the different parts of Babel actually are, and
    how we can use Babel in our application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们了解 Babel 的不同部分实际上是什么，以及我们如何在我们的应用程序中使用 Babel。
- en: '@babel/cli'
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@babel/cli'
- en: 'The Babel CLI is the most common (and easiest) way to run Babel. It gives you
    an executable (`babel`) which you can use on the terminal to transpile files and
    directories. It is available on [npmjs.com](http://npmjs.com), and so we can install
    it using yarn:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Babel CLI 是运行 Babel 最常见（也是最容易）的方式。它提供了一个可执行文件（`babel`），你可以在终端中使用它来转换文件和目录。它可在
    [npmjs.com](http://npmjs.com) 上找到，因此我们可以使用 yarn 安装它：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '@babel/register'
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@babel/register'
- en: The `@babel/cli` package allows you to transpile source code ahead of time;
    on the other hand, `@babel/register` transpiles it at runtime.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`@babel/cli` 包允许你预先转换源代码；另一方面，`@babel/register` 在运行时进行转换。'
- en: Using @babel/register for tests
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @babel/register 进行测试
- en: '`@babel/register` is useful during testing, as it allows you to write ESNext
    inside your tests, as they will be transpiled down before the tests are run.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`@babel/register` 在测试期间非常有用，因为它允许你在测试中编写 ESNext 代码，因为它们将在测试运行之前被转换。'
- en: The alternative is to transpile manually using the `babel` CLI, and perform
    the tests on the transpiled code. This is acceptable; however, the line numbers
    on the transpiled code will not match the ones in the source code, making it harder
    to identify the failing test(s). Furthermore, since there is likely to be more
    boilerplate code in the transpiled code, the test coverage statistics might not
    be accurate.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方案是使用 `babel` CLI 手动转换，并在转换后的代码上执行测试。这是可以接受的；然而，转换代码的行号将不会与源代码中的行号匹配，这使得识别失败的测试变得困难。此外，由于转换代码中可能包含更多的样板代码，测试覆盖率统计可能不准确。
- en: Therefore, using `@babel/register` is recommended for running tests written
    in ES6.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议使用 `@babel/register` 来运行用 ES6 编写的测试。
- en: '@babel/node'
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@babel/node'
- en: 'While the `@babel/register` hook can integrate with other tools such as `mocha` and `nyc` and
    acts as a middle step, `@babel/node` is a stand-in replacement for `node` and supports
    ESNext syntax:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `@babel/register` 钩子可以与其他工具（如 `mocha` 和 `nyc`）集成并充当中间步骤，但 `@babel/node` 是
    `node` 的替代品并支持 ESNext 语法：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is provided for convenience, to help you get started. It's not meant to be
    used in production since, like `@babel/register`, it transpiles the source code
    at runtime, which is highly inefficient.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了方便，帮助你开始。它不打算在生产环境中使用，因为，就像 `@babel/register` 一样，它会在运行时转换源代码，这非常低效。
- en: '@babel/core'
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@babel/core'
- en: '`@babel/cli`, `@babel/register`, `@babel/node`, and several other packages all
    depend on `@babel/core`, which as its name implies contains the core logic behind
    Babel. In addition, the `@babel/core` package exposes API methods that you can
    use inside your code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`@babel/cli`、`@babel/register`、`@babel/node` 以及其他几个包都依赖于 `@babel/core`，正如其名称所暗示的，它包含
    Babel 的核心逻辑。此外，`@babel/core` 包公开了你可以用于代码中的 API 方法：'
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '@babel/polyfill'
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@babel/polyfill'
- en: Newer versions of ECMAScript provide new and cleaner syntax, and Babel transpiles
    the new syntax down to older versions of ECMAScript. However, this is more difficult
    (if not impossible) to do in the same way if you're using newer JavaScript *APIs*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 的新版本提供了新的、更简洁的语法，Babel 将新语法转换为旧版本的 ECMAScript。然而，如果你使用的是新的 JavaScript
    *APIs*，这样做可能更困难（甚至不可能）。
- en: For example, if you're using the new `fetch` API instead of `XMLHttpRequest`,
    Babel won't be able to transpile this down. For APIs, we must use a polyfill;
    luckily, Babel provides the `@babel/polyfill` package.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在使用新的 `fetch` API 而不是 `XMLHttpRequest`，Babel 将无法将其转换为旧版本。对于 APIs，我们必须使用
    polyfill；幸运的是，Babel 提供了 `@babel/polyfill` 包。
- en: A polyfill is code that checks whether a feature is supported in the environment,
    and if not, provides methods that mimic the native implementation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Polyfill 是一种代码，它会检查环境是否支持某个功能，如果不支持，则提供模拟原生实现的方法。
- en: 'To use the polyfill, you must first install it as a dependency (not a development
    dependency):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 polyfill，你必须首先将其作为依赖项（而不是开发依赖项）安装：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, import the `@babel/polyfill` package at the top of your code and it''ll
    mutate existing global variables to polyfill methods that are not yet supported:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在代码顶部导入 `@babel/polyfill` 包，它将修改现有的全局变量以 polyfill 尚未支持的方法：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`@babel/polyfill` uses `core-js` as its underlying polyfill.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`@babel/polyfill` 使用 `core-js` 作为其底层的 polyfill。'
- en: Adding Babel CLI and polyfill
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Babel CLI 和 polyfill
- en: 'We''ll be using the Babel CLI to transpile our code, while also adding the
    Babel polyfill in order to make use of newer JavaScript APIs. Therefore, while
    still inside your project directory, run the following two commands:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Babel CLI 来转换我们的代码，同时添加 Babel polyfill 以利用新的 JavaScript APIs。因此，尽管你仍然在项目目录内，但请运行以下两个命令：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We used the `--dev` flag when we ran `yarn add @babel/core @babel/cli`, and
    this is because we want to include them as **development dependencies**. Development
    dependencies may include build tools, test runners, documentation generators,
    linters, and anything else that are used during development, but not used by the
    application itself.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `yarn add @babel/core @babel/cli` 时，我们使用了 `--dev` 标志，这是因为我们希望将它们包括为 **开发依赖项**。开发依赖项可能包括构建工具、测试运行器、文档生成器、linters
    以及在开发期间使用但应用程序本身不使用的任何其他工具。
- en: This is done so that if someone wants to use our package in their project, they
    can just `npm install` our package and its dependencies, without also downloading
    the development dependencies.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了如果有人想在他们的项目中使用我们的包，他们只需 `npm install` 我们包及其依赖项，而无需也下载开发依赖项。
- en: Using Babel CLI to transpile our code
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Babel CLI 转换我们的代码
- en: 'Now, let''s use the Babel CLI to transpile our code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Babel CLI 来转换我们的代码：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding command uses `npx`, a tool that was introduced with `npm` v5.2.0\.
    `npx` allows you to run binaries install locally (within your project's `node_modules`
    directory, as opposed to globally) using a very tidy syntax. Instead of typing
    `./node_modules/.bin/babel index.js -o compile.js`, you can shorten it to `npx
    babel index.js -o compile.js`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用了 `npx`，这是一个与 `npm` v5.2.0 一起引入的工具。`npx` 允许你使用非常整洁的语法在本地运行二进制文件（在你的项目的
    `node_modules` 目录内，而不是全局），例如，你可以将 `./node_modules/.bin/babel index.js -o compile.js`
    简化为 `npx babel index.js -o compile.js`。
- en: Here, we are using npx to run the local `babel` executable, which will transpile
    our `index.js` file and output it as `compiled.js`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用npx运行本地的`babel`可执行文件，它将转换我们的`index.js`文件并将其输出为`compiled.js`。
- en: 'If you compare the two files, you''ll see that apart from formatting changes
    (such as whitespace), the two files should be identical. This is because the Babel
    CLI, by default, will simply copy files from one place to another. To give it
    functionality, we must add plugins and specify them in a configuration file. So
    next, let''s create that configuration file. At the root of the project directory,
    create a new file named `.babelrc` and add the following lines:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您比较这两个文件，您会看到除了格式更改（如空白）之外，这两个文件应该是相同的。这是因为Babel CLI默认情况下将简单地从一处复制文件到另一处。为了给它添加功能，我们必须添加插件并在配置文件中指定它们。所以接下来，让我们创建那个配置文件。在项目目录的根目录下，创建一个名为`.babelrc`的新文件，并添加以下行：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Plugins and presets
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件和预设
- en: '**Plugins** tell Babel how to transform your code, and **presets** are predefined
    groups of plugins. For example, you have the `es2017` preset, which includes the
    plugins `syntax-trailing-function-commas` and `transform-async-to-generator`,
    which are required to support ECMAScript 2017 syntax. There''s also the `react` preset,
    which includes the `transform-react-jsx` plugin (among others) to allow Babel
    to understand JSX.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**插件**告诉Babel如何转换您的代码，而**预设**是预定义的插件组。例如，您有`es2017`预设，它包括`syntax-trailing-function-commas`和`transform-async-to-generator`插件，这些插件是支持ECMAScript
    2017语法的必需品。还有一个`react`预设，它包括`transform-react-jsx`插件（以及其他插件），允许Babel理解JSX。'
- en: 'To use a plugin or preset, you can install it as a development dependency,
    and specify it in the `.babelrc`. For example, if I want to support ECMAScript
    2017 syntax, but also the `rest` and `spread` operators for objects (a ES2018
    feature), I could run the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用插件或预设，您可以将其作为开发依赖项安装，并在`.babelrc`中指定它。例如，如果我想支持ECMAScript 2017语法，同时支持对象的`rest`和`spread`操作符（ES2018的功能），我可以运行以下命令：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And, add the setting into `.babelrc`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将设置添加到`.babelrc`中：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The env preset
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: env预设
- en: However, in the previous approach, you have to manually keep track of which
    ECMAScript features you've used, and determine whether they are compatible with
    the version of Node.js you have installed on your machine. Babel provides a better
    alternative, the `env` preset, which is available as the `@babel/preset-env` package.
    This preset will use the kangax ECMAScript compatibility tables ([kangax.github.io/compat-table/](http://kangax.github.io/compat-table/))
    to determine which features are unsupported by your environment, and download
    the appropriate Babel plugins.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在先前的方法中，您必须手动跟踪您使用了哪些ECMAScript功能，并确定它们是否与您在机器上安装的Node.js版本兼容。Babel提供了一个更好的替代方案，即`env`预设，它作为`@babel/preset-env`包提供。此预设将使用kangax
    ECMAScript兼容性表([kangax.github.io/compat-table/](http://kangax.github.io/compat-table/))来确定哪些功能不受您的环境支持，并下载适当的Babel插件。
- en: This is great for our use case, because we don't want to transpile everything
    into ES5, only the `import`/`export` module syntax. Using the `env` preset will
    ensure that only the minimum number of transformations are made to our code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们用例来说很棒，因为我们不希望将所有内容都转换为ES5，只转换`import`/`export`模块语法。使用`env`预设将确保对我们的代码只进行最小数量的转换。
- en: 'In fact, if you go to the `npmjs.com` page for `@babel/preset-es2017` or similar
    packages, you''ll see that they have been deprecated in favor of the `@babel/preset-env`
    package. Therefore, we should remove the previous plugins and presets, and use
    the `env` preset instead:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果您访问`npmjs.com`页面上的`@babel/preset-es2017`或类似包，您会看到它们已经被废弃，转而使用`@babel/preset-env`包。因此，我们应该删除之前的插件和预设，并使用`env`预设：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, replace the content of our `.babelrc` with the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将我们的`.babelrc`内容替换为以下内容：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you do not specify a targeted environment, the `env` preset will default
    to using the latest official version of ECMAScript, not including stage-x proposals.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有指定目标环境，`env`预设将默认使用最新的官方ECMAScript版本，不包括stage-x提案。
- en: 'The API we are writing is intended to be run only on the server, using Node,
    so we should specify that in the configuration. We can specify the exact version
    of Node we want to support, but even better, we can ask Babel to detect it for
    us using the target option `"node": "current"`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '我们正在编写的API旨在仅在服务器上运行，使用Node，因此我们应该在配置中指定这一点。我们可以指定我们想要支持的Node的确切版本，但更好的是，我们可以让Babel使用target选项`"node":
    "current"`为我们检测它。'
- en: 'So, replace `.babelrc` with the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将`.babelrc`替换为以下内容：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Great! Now we can continue writing in ES6\. When we want to run our program,
    we can simply transpile it using Babel, and run the compiled script:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们可以继续用 ES6 编写了。当我们想要运行我们的程序时，我们可以简单地使用 Babel 转换它，然后运行编译后的脚本：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You should, once again, receive the `'Hello World!'` text as the response when
    you send a `GET` request to `localhost:8080`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，当你向`localhost:8080`发送`GET`请求时，你应该会收到`'Hello World!'`文本作为响应。
- en: Separating source and distribution code
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离源代码和发布代码
- en: Usually, the source code consists of many files, nested inside multiple directories.
    We can transpile each file and place them next to the corresponding source file,
    but this is not ideal as it is hard to separate the distribution code from the
    source. Therefore, it's preferable to separate the source and distribution code
    into two different directories.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，源代码由许多文件组成，嵌套在多个目录中。我们可以转换每个文件并将它们放置在相应的源文件旁边，但这并不是最佳做法，因为很难将发布代码与源代码分开。因此，最好将源代码和发布代码分别放在两个不同的目录中。
- en: 'Therefore, let''s remove the existing `compiled.js`, and create two new directories
    called `src` and `dist`. Also, move the `index.js` file into the `src` directory:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们删除现有的 `compiled.js`，并创建两个新的目录，分别称为 `src` 和 `dist`。同时，将 `index.js` 文件移动到
    `src` 目录中：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we should build our project again, but this time supplying the `-d` flag
    to the Babel CLI, which will compile files in our `src` directory into an output
    directory. We should also remove our existing `dist` directory before we build
    to ensure no artifacts are left behind from the previous build:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该再次构建我们的项目，但这次向 Babel CLI 提供一个 `-d` 标志，它将编译我们`src`目录中的文件到输出目录。在构建之前，我们应该删除现有的`dist`目录，以确保没有留下前一次构建的任何工件：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Importing the Babel polyfill
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入 Babel polyfill
- en: 'Lastly, inside the `src/index.js` file, import the polyfill at the top of the
    file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`src/index.js`文件中，将 polyfill 导入到文件顶部：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will allow us to use new JavaScript APIs, such as `fetch`. Again, transpile
    the modified source code by executing `rm -rf dist/ && npx babel src -d dist`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够使用新的 JavaScript API，例如`fetch`。再次，通过执行`rm -rf dist/ && npx babel src -d
    dist`来转换修改后的源代码。
- en: Consolidating commands with npm scripts
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 npm 脚本合并命令
- en: It's troublesome to have to type `rm -rf dist/ && npx babel src -d dist` each
    time you want to build your project. Instead, we should use **npm scripts** to
    consolidate this command into a simpler one.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 每次想要构建项目时，都必须手动输入`rm -rf dist/ && npx babel src -d dist`命令，这实在麻烦。相反，我们应该使用**npm
    脚本**将这个命令合并成一个更简单的命令。
- en: 'In your `package.json` file, add a new `build` sub-property to the `scripts`
    property, and set it to a string representing the command we want to run:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`package.json`文件中，向`scripts`属性添加一个新的`build`子属性，并将其设置为表示我们想要运行的命令的字符串：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, instead of typing  `rm -rf dist/ && npx babel src -d dist`, you can just
    type `yarn run build`, or `npm run build`—much less cumbersome! By adding this
    script into `package.json`, it allows you to share this with other developers,
    so everyone can benefit from this convenience.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不再需要输入`rm -rf dist/ && npx babel src -d dist`，你只需输入`yarn run build`或`npm
    run build`——这样就不那么麻烦了！通过将此脚本添加到`package.json`中，它允许你与其他开发者共享，这样每个人都可以从中受益。
- en: 'We can also create a `serve` script, which will build our application and then
    run it:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个 `serve` 脚本，它将构建我们的应用程序然后运行它：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When we integrate with testing frameworks and documentation tools in subsequent
    chapters, we will add even more scripts here.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的章节中，当我们与测试框架和文档工具集成时，我们将在其中添加更多的脚本。
- en: Ensuring cross-platform compatibility
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保跨平台兼容性
- en: Before we move on, we should try to ensure our npm scripts work across multiple
    platforms. So, if we have a developer working on a Mac, and another on a Linux
    machine, the script would work for both of them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该尝试确保我们的 npm 脚本在多个平台上都能工作。所以，如果我们有一个开发者在使用 Mac，另一个在使用 Linux 机器，脚本将适用于他们两个。
- en: For example, if you want to remove the `dist` directory using `cmd` in Windows,
    you'd have to run `rd /s /q dist`; while using Ubuntu's default shell (Bash),
    you'll run `rm -rf dist`. To ensure our npm script will work everywhere, we can
    use a Node package called `rimraf` ([https://www.npmjs.com/package/rimraf](https://www.npmjs.com/package/rimraf)[).
    First, install it:](https://www.npmjs.com/package/rimraf)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在 Windows 上使用 `cmd` 删除 `dist` 目录，你需要运行`rd /s /q dist`；而使用 Ubuntu 的默认
    shell（Bash），你会运行`rm -rf dist`。为了确保我们的 npm 脚本在所有地方都能工作，我们可以使用一个名为 `rimraf` 的 Node
    包（[https://www.npmjs.com/package/rimraf](https://www.npmjs.com/package/rimraf)）。首先，安装它：](https://www.npmjs.com/package/rimraf)
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And now update our `build` script to use `rimraf`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新我们的`build`脚本以使用`rimraf`：
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Automating development using nodemon
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nodemon自动化开发
- en: At the moment, to see the final product, we have to run the `build` script after
    each time we modify our source code. While this is fine, it can be annoying and
    a time-waster. `nodemon` is a tool that monitors for changes in our code and automatically
    restarts the `node` process when a change is detected. This can speed up development
    and testing, as we no longer need to run the `build` and `serve` scripts manually.
    Furthermore, the API served from our machine will always be the most up-to-date
    version.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，为了看到最终产品，我们必须在每次修改源代码后运行`build`脚本。虽然这没问题，但可能会很烦人且浪费时间。`nodemon`是一个工具，它监视代码中的变更，并在检测到变更时自动重启`node`进程。这可以加快开发和测试的速度，因为我们不再需要手动运行`build`和`serve`脚本。此外，从我们的机器上提供的API将始终是最新的版本。
- en: 'First, let''s install `nodemon`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装`nodemon`：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, add a `watch` script that uses `nodemon` instead of `node`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个使用`nodemon`而不是`node`的`watch`脚本：
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This command instructs nodemon to watch for file changes in the `src` directory
    and, whenever one is detected, to execute `yarn run serve` and restart our server.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令指示nodemon监视`src`目录中的文件变更，并在检测到变更时执行`yarn run serve`并重启我们的服务器。
- en: 'Now, run `yarn run watch`, and make a small file change in `src/index.js` (for
    example, change the text returned in the response). Pay attention to the console
    and you''ll see nodemon detecting changes and restarting our server:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`yarn run watch`，并在`src/index.js`（例如，更改响应中返回的文本）中进行小的文件更改。注意控制台，你会看到nodemon检测到变更并重启我们的服务器：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Linting with ESLint
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ESLint进行代码检查
- en: Finally, we should take care to maintain a consistent code style throughout
    our project. Code styles are subjective, stylistic choices that do not alter the
    function of the program, for example, whether to use spaces or tabs, or whether
    to use `camelCase` or `underscore_case` when naming variables.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该注意在整个项目中保持一致的代码风格。代码风格是主观的，是风格选择，不会改变程序的功能，例如，是否使用空格或制表符，或者命名变量时是否使用`camelCase`或`underscore_case`。
- en: 'Having a consistent code style is important for the following reasons:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 保持一致的代码风格对于以下原因很重要：
- en: It makes the code more readable.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使代码更易读。
- en: 'When working with others, contributors may override each other''s style changes.
    For instance, contributor A may change all string literals to using single-quotes,
    and contributor B may change it back to double-quotes in a subsequent commit. This
    is a problem because:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与他人合作时，贡献者可能会覆盖彼此的风格变更。例如，贡献者A可能会将所有字符串字面量更改为使用单引号，而贡献者B可能会在后续提交中将其改回双引号。这是一个问题，因为：
- en: Time and effort are wasted
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浪费时间和精力
- en: It can lead to ill-feelings because no one likes their work being overwriten
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能会导致不良情绪，因为没有人喜欢自己的工作被覆盖
- en: Changes become hard to review, and the pertinent changes may be submerged under
    the stylistic changes.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更变得难以审查，相关的变更可能会被风格变更所淹没。
- en: Once a set of code style rules is defined, a **linter** can be used to enforce
    those rules. A linter is a static analysis tool that scans your code and identifies
    code styles that do not adhere to those rules, as well as identifying potential
    bugs that arise due to syntax errors.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了一套代码风格规则，就可以使用**代码检查器**来强制执行这些规则。代码检查器是一个静态分析工具，它扫描你的代码并识别不符合这些规则的代码风格，以及由于语法错误而产生的潜在错误。
- en: '*ESLint* is an open source linter for JavaScript. To use it, you would first
    document your rules inside a configuration file named `.eslintrc`. It is designed
    to be pluggable, which means developers can override the default rules and compose
    their own set of code style rules. Any violations can also be given a severity
    level of warning or error. It also provides useful features such as the `--init`
    flag, which initiates a wizard to help you compose your configuration file, as
    well as the `--fix` flag, which automatically fixes any violations that do not
    require human intervention.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*ESLint*是一个开源的JavaScript代码检查工具。要使用它，你首先需要在名为`.eslintrc`的配置文件中记录你的规则。它被设计为可插拔的，这意味着开发者可以覆盖默认规则并组合自己的代码风格规则集。任何违规也可以被赋予警告或错误的严重级别。它还提供了有用的功能，例如`--init`标志，它启动一个向导来帮助你创建配置文件，以及`--fix`标志，它可以自动修复不需要人工干预的任何违规。'
- en: Installing ESLint
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装ESLint
- en: 'Let''s install ESLint and run its initiation wizard:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装ESLint并运行其初始化向导：
- en: '[PRE48]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For this project, we are going to be using Airbnb''s JavaScript style guide,
    which you can find at [https://github.com/airbnb/javascript](https://github.com/airbnb/javascript).
    Therefore, use your arrow keys to select the Use a popular style guide option,
    and press the Return key. On the next question, select the Airbnb option:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将使用Airbnb的JavaScript风格指南，您可以在[https://github.com/airbnb/javascript](https://github.com/airbnb/javascript)找到它。因此，使用你的箭头键选择“使用流行的风格指南”选项，并按回车键。在下一个问题中，选择Airbnb选项：
- en: '[PRE49]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, it''ll ask questions about React and the configuration format; select
    the No and JSON options, respectively:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将询问有关React和配置格式的问题；分别选择“否”和JSON选项：
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lastly, it will check whether we have the required dependencies installed,
    and if not, prompt us to install them. Select the Yes option here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将检查我们是否安装了所需的依赖项，如果没有，会提示我们安装它们。在这里选择“是”选项：
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This completes the wizard, and you should now see an `.eslintrc.json` file
    at the root of your repository, which simply reads as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了向导，现在你应该在你的仓库根目录下看到一个`.eslintrc.json`文件，它简单地如下所示：
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Linting our code
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的代码
- en: 'Now, let''s run `eslint` on our `src/index.js` to discover problems with our
    code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`src/index.js`上运行`eslint`以发现我们代码中的问题：
- en: '[PRE53]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Follow the instructions and fix those issues, or pass the `--fix` flag to have
    ESLint fix the issues for you automatically. At the end, you should end up with
    a file that looks like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明修复这些问题，或者传递`--fix`标志让ESLint自动为您修复问题。最后，你应该得到一个看起来像这样的文件：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Adding lint script to package.json
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在package.json中添加lint脚本
- en: 'Just as we did with the `build`, `serve`, and `watch` npm scripts, we can add
    a `fix` and `lint` script into our `package.json`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对`build`、`serve`和`watch`npm脚本所做的那样，我们可以在`package.json`中添加一个`fix`和`lint`脚本：
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, we can run `yarn run lint` to lint our entire project.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`yarn run lint`来检查我们的整个项目。
- en: Installing the ESLint extension
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装ESLint扩展
- en: 'While we can run ESLint manually, it would be even better for developer experience
    if these errors were pointed out as we are developing. To do that, we can install
    an ESLint extension for your code editor or IDE. For example, the Visual Studio
    Code ESLint Extension will add red and yellow squiggly lines below any violations:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以手动运行ESLint，但如果这些错误在我们开发时就被指出，那么开发者的体验会更好。为了做到这一点，我们可以在代码编辑器或IDE中安装ESLint扩展。例如，Visual
    Studio Code ESLint扩展将在任何违规下添加红色和黄色的波浪线：
- en: '![](img/f61e6395-1eaf-463d-ab3f-c3300fa10f2e.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f61e6395-1eaf-463d-ab3f-c3300fa10f2e.jpg)'
- en: There are a lot more integrations available for editors and build tools; you
    can find a comprehensive list at [https://eslint.org/docs/user-guide/integrations](https://eslint.org/docs/user-guide/integrations).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于编辑器和构建工具的集成有很多；您可以在[https://eslint.org/docs/user-guide/integrations](https://eslint.org/docs/user-guide/integrations)找到一份完整的列表。
- en: Adding pre-commit hooks
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加pre-commit钩子
- en: However, we're not quite finished yet. Many developers are careless and forgetful.
    Even with `eslint` installed and the extension configured, they may still forget
    to run the lint command before committing badly styled code. To help them, we
    can implement **Git hooks**, which are programs that are triggerred to run at
    defined points in Git's execution.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完全完成。许多开发者粗心大意，容易忘记。即使安装了`eslint`并配置了扩展，他们也可能在提交格式不良的代码前忘记运行lint命令。为了帮助他们，我们可以实现**Git钩子**，这些是触发在Git执行过程中定义点的程序。
- en: By default, Git hooks are stored inside the `.git/hooks` directory. If you look
    inside the directory, you'll find many sample hooks with the `.sample` file extension.
    The one we are interested in is the `pre-commit` hook, which is executed after
    the `git commit` command is issued, but before the actual commit is made.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Git钩子存储在`.git/hooks`目录中。如果你查看该目录，你会找到许多具有`.sample`文件扩展名的示例钩子。我们感兴趣的是`pre-commit`钩子，它在`git
    commit`命令发出后执行，但在实际提交之前。
- en: Hooks are written as a shell script. For the `pre-commit` hook, we can abort
    the commit by returning a non-zero exit code. Conveniently, when ESLint detects
    code style violations, it will exit with a status code of `1`; therefore, in our
    script, we can simply return the exit code returned by `eslint`. When writing
    a hook manually, you should take care to only use syntax that abides by the POSIX
    standard, because other developers may use a different type of shell from you.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子是用外壳脚本编写的。对于`pre-commit`钩子，我们可以通过返回非零退出码来终止提交。方便的是，当ESLint检测到代码风格违规时，它将以状态码`1`退出；因此，在我们的脚本中，我们可以简单地返回`eslint`返回的退出码。当手动编写钩子时，你应该注意只使用遵循POSIX标准的语法，因为其他开发者可能使用与你不同的外壳类型。
- en: 'However, if writing shell scripts manually sounds like too much work for you,
    there''s a tool called **Husky**, which hugely simplifies the process for us.
    Let''s install it:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你觉得手动编写外壳脚本工作量太大，有一个名为**Husky**的工具，它可以大大简化这个过程。让我们安装它：
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Husky will insert its own Git hooks into our project. In these hooks, it will
    check our `package.json` for scripts with special names and run them. For instance,
    our `pre-commit` hook will check for a script named `precommit`. Therefore, to
    run our lint command with Husky, all we have to do is add a new npm script called
    `precommit`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Husky将插入它自己的Git钩子到我们的项目中。在这些钩子中，它将检查`package.json`中具有特殊名称的脚本并运行它们。例如，我们的`pre-commit`钩子将检查名为`precommit`的脚本。因此，要使用Husky运行我们的lint命令，我们只需添加一个名为`precommit`的新npm脚本：
- en: '[PRE57]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, if we try to commit any badly formatted code, it will throw an error and
    abort:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试提交格式错误的代码，它将抛出错误并终止：
- en: '[PRE58]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Committing our code into Git
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的代码提交到Git
- en: We have finished bootstrapping our project by setting up an HTTP server and
    enabling ourselves to write in ES6\. So, let's actually commit this block of code
    into Git.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置HTTP服务器并使我们能够使用ES6来完成了项目的初始化。因此，让我们实际上将这一块代码提交到Git中。
- en: Note that we could have created a new commit each time we added a new script,
    or integrated with a new tool, but because the bootstrapping of a project can
    be considered as one logical unit, we're committing all of that into one commit.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们本可以在每次添加新脚本或集成新工具时创建一个新的提交，但因为我们认为项目的初始化可以被视为一个逻辑单元，所以我们把这些都提交到一个提交中。
- en: Also, note that we are not going to be creating a `dev` branch just yet, as
    bootstrapping a project is not considered to be a "feature." Remember that branches
    are here to help us separate our commits by business domains; if branching provides
    no benefit for us, then it's better to be pragmatic, rather than dogmatic.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们目前不会创建一个`dev`分支，因为项目的初始化不被视为一个“功能”。记住，分支是用来帮助我们根据业务领域分离提交的；如果我们从分支中得不到任何好处，那么务实比教条更好。
- en: 'Let''s run `git status` to see which files we can track in our Git repository:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`git status`来查看我们可以在Git仓库中跟踪哪些文件：
- en: '[PRE59]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The list of files listed by the `git status` command includes the `node_modules/`
    and `dist/` directories, both of which do not constitute the core logic of our
    application. Furthermore, they can be regenerated from our source code—`node_modules/`
    from the `package.json` and `yarn.lock` files, and `dist/` from the `src/` directory.
    Moreover, the `node_modules/` directory can be very large, as it includes a copy
    of all third-party libraries we are depending on in our application. Therefore,
    let's make sure the `node_modules/` and `dist/` directories are not tracked in
    our Git repository.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`git status`命令列出的文件列表包括`node_modules/`和`dist/`目录，这两个目录都不构成我们应用程序的核心逻辑。此外，它们可以从我们的源代码中重新生成——`node_modules/`来自`package.json`和`yarn.lock`文件，而`dist/`来自`src/`目录。此外，`node_modules/`目录可能非常大，因为它包含了我们在应用程序中依赖的所有第三方库的副本。因此，让我们确保`node_modules/`和`dist/`目录不被跟踪在我们的Git仓库中。'
- en: Using .gitignore to ignore files
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`.gitignore`忽略文件
- en: 'Git allows for a special `.gitignore` file that allows us to specify which
    files Git should ignore. So, create a `.gitignore` file at the project root directory,
    and add the following lines:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Git允许一个特殊的`.gitignore`文件，允许我们指定Git应该忽略哪些文件。因此，在项目根目录下创建一个`.gitignore`文件，并添加以下行：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, when we run `git status` again, `node_modules/` and `dist/` are gone from
    our list, and `.gitignore` is added:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们再次运行`git status`时，`node_modules/`和`dist/`已从我们的列表中消失，而`.gitignore`被添加：
- en: '[PRE61]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Apart from the `node_modules/` and `dist/` directories, there will be many other
    files we'll eventually want Git to ignore; for example, a `yarn-error.log` is
    generated whenever `yarn` encounters an error. It is for our information only
    and should not be tracked on Git. While we can keep adding more and more lines
    to the `.gitignore` file as is required, many others working with Node.js have
    already worked together to compile a list of common files and directories that
    most projects should ignore; we can use that as a basis and modify it as needed.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `node_modules/` 和 `dist/` 目录外，我们最终还希望 Git 忽略许多其他文件；例如，每当 `yarn` 遇到错误时都会生成一个
    `yarn-error.log` 文件。它仅用于我们的信息，不应在 Git 上跟踪。虽然我们可以根据需要继续向 `.gitignore` 文件中添加更多行，但许多使用
    Node.js 的人已经共同工作，编制了一份大多数项目应忽略的常见文件和目录列表；我们可以以此为基础，并根据需要进行修改。
- en: Go to [github.com/github/gitignore/blob/master/Node.gitignore](https://github.com/github/gitignore/blob/master/Node.gitignore)
    and replace our `.gitignore` file with the content of the `Node.gitignore` file;
    but remember to add the `dist/` entry back at the end.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [github.com/github/gitignore/blob/master/Node.gitignore](https://github.com/github/gitignore/blob/master/Node.gitignore)
    并将我们的 `.gitignore` 文件替换为 `Node.gitignore` 文件的内容；但请记住在最后添加回 `dist/` 条目。
- en: 'Now, let''s add everything to the staging area and commit them:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有内容添加到暂存区并提交：
- en: '[PRE62]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the start of this chapter, we looked at the difference between CommonJS and
    ES6 modules, and settled on using the new ES6 module syntax, which uses the `import`
    and `export` keywords.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们探讨了 CommonJS 和 ES6 模块之间的区别，并决定使用新的 ES6 模块语法，该语法使用 `import` 和 `export`
    关键字。
- en: Next, we installed Node on our machine using nvm, and got acquainted with the
    `npm` and `yarn` package managers. We then set up a simple HTTP server using the
    native `http` Node module. After that, we used Babel to transpile our ESNext code
    into a syntax supported by our local environment. We also set up `nodemon` to
    watch for changes in our code and restart the server whenever a change is detected.
    Lastly, we incorporated ESLint to spot problems in our code, and use a `pre-commit`
    Git hook to run the linter automatically before each commit.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 nvm 在我们的机器上安装了 Node，并熟悉了 `npm` 和 `yarn` 包管理器。然后，我们使用原生的 `http` Node
    模块设置了一个简单的 HTTP 服务器。之后，我们使用 Babel 将我们的 ESNext 代码转换为本地环境支持的语法。我们还设置了 `nodemon`
    来监视代码中的更改，并在检测到更改时重新启动服务器。最后，我们引入了 ESLint 来查找代码中的问题，并使用 `pre-commit` Git 钩子在每次提交前自动运行代码检查器。
- en: In the next chapter, we will be following a **test-driven development** (**TDD**)
    approach to develop our API server, to provide functionalities for clients to
    **create, read, update, and delete** (**CRUD**) user objects on our database,
    using **ElasticSearch** as our data storage solution.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将采用 **测试驱动开发**（**TDD**）的方法来开发我们的 API 服务器，为客户端提供在数据库中创建、读取、更新和删除（**CRUD**）用户对象的功能，使用
    **ElasticSearch** 作为我们的数据存储解决方案。
- en: In general, each subsequent chapter will incorporate a new set of tools to the
    application. The book will focus first on the backend, server-side code, later
    moving on to frontend, client-side code, before rounding off the book by looking
    at implementing an automated deployment process.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每一章都会将一组新的工具集成到应用程序中。本书将首先关注后端、服务器端代码，然后转向前端、客户端代码，最后通过查看实现自动化部署过程来结束全书。
