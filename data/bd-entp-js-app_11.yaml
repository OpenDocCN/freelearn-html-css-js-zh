- en: Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: 'In the previous chapters, we adopted a **Test-Driven Development** (**TDD**)
    approach to developing a backend API server, which exposes a user directory platform.
    However, there are still many areas for improvement in our workflow:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们采用了一种 **测试驱动开发** (**TDD**) 的方法来开发一个后端 API 服务器，该服务器公开了一个用户目录平台。然而，在我们的工作流程中仍有许多可以改进的地方：
- en: We are running tests on our local, development environment, which may contain
    artifacts that lead to inaccurate test results
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在我们的本地、开发环境中运行测试，这可能包含导致测试结果不准确的艺术品
- en: Carrying out all these steps manually is slow and error-prone
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动执行所有这些步骤既慢又容易出错
- en: In this chapter, we are going to eliminate these two issues by integrating with a
    **Continuous Integration** server. In essence, a CI server is a service that watches
    for changes in your repository, and then automatically runs the test suite inside
    a clean environment. This ensures the test results are more deterministic and
    repeatable. In other words, it prevents situations where something works on one
    person's machine but not another's.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过集成一个 **持续集成** 服务器来消除这两个问题。本质上，CI 服务器是一种监视仓库更改的服务，然后在一个干净的环境中自动运行测试套件。这确保了测试结果更加确定性和可重复性。换句话说，它防止了在某些人的机器上工作但在另一些人的机器上不工作的情况。
- en: 'By following this chapter, you will:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本章，你将：
- en: Understand what CI is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CI 是什么
- en: Integrate our GitHub repository with a hosted CI platform called **Travis**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的 GitHub 仓库与名为 **Travis** 的托管 CI 平台集成
- en: Set up a self-hosted **Jenkins** server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个自托管的 **Jenkins** 服务器
- en: Set up our test suite to run whenever a new change is pushed to GitHub
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新的更改推送到 GitHub 时，设置我们的测试套件运行
- en: Understand **pipelines,** especially the difference between **declarative**
    and **scripted pipelines**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 **管道**，特别是 **声明式** 和 **脚本式管道** 之间的区别
- en: Continuous Integration (CI)
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成 (CI)
- en: On a large-scale project, you're going to have many developers working on many
    features, releases, hotfixes, and so on, at the same time. CI is the practice
    of *integrating* work from different developers continuously. This means merging
    code from feature branches into the `dev` branch, or from a release branch into
    `master`. At every integration point, there's a chance that the integration would
    cause something to break. Therefore, we must perform tests at these integration
    points, and only carry through with the integration if all tests pass.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大规模项目中，你将同时有许多开发者正在开发许多功能、发布、热修复等。CI 是一种 *持续集成* 不同开发者工作的实践。这意味着将功能分支的代码合并到
    `dev` 分支，或者从发布分支合并到 `master`。在每次集成点，都有可能集成导致某些东西出错。因此，我们必须在这些集成点进行测试，并且只有当所有测试通过时才进行集成。
- en: We already do this in our current workflow, but it is done manually. By having
    automated builds and tests that detect errors in these integration points, it
    allows members of a software development team to integrate their work frequently.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在当前的工作流程中这样做，但它是以手动方式完成的。通过自动构建和测试来检测这些集成点中的错误，它允许软件开发团队的成员频繁地集成他们的工作。
- en: By practicing CI, we can abide by the "test early, test often" mantra, and ensure
    bugs are identified and fixed as early as possible. It also means that at any
    point, we will always have a fully functional codebase that can be deployed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实践 CI，我们可以遵守“尽早测试，经常测试”的格言，并确保尽早识别和修复错误。这也意味着在任何时候，我们都将始终有一个可以部署的完全功能性的代码库。
- en: We have already laid the groundwork for following this practice by using a robust
    Git workflow and having a comprehensive test suite. The next step is to introduce
    a CI server into the mix.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过使用健壮的 Git 工作流程和拥有全面的测试套件为遵循此实践奠定了基础。下一步是引入 CI 服务器。
- en: Picking a CI server
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个 CI 服务器
- en: 'There are many online CI services (such as **Travis**, **CircleCI**, **Bamboo**,
    and **Shippable**) as well as self-hosted CI-capable platforms (such as **Jenkins**,
    **TeamCity**, **CruiseControl**, and **BuildBot**). For CI, they pretty much have
    the same set of capabilities, and can perform the following tasks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多在线 CI 服务（例如 **Travis**、**CircleCI**、**Bamboo** 和 **Shippable**）以及自托管的 CI
    兼容平台（例如 **Jenkins**、**TeamCity**、**CruiseControl** 和 **BuildBot**）。对于 CI，它们基本上具有相同的功能集，并且可以执行以下任务：
- en: Hook onto events and perform predefined tasks when triggered. For instance,
    when a new Git commit is pushed to the repository, the CI server would build the
    application and run the tests.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当触发事件时，挂钩到事件并执行预定义的任务。例如，当新的 Git 提交被推送到仓库时，CI 服务器将构建应用程序并运行测试。
- en: Run tasks in a clean, standalone environment.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个干净、独立的环境中运行任务。
- en: Chain tasks together so that some tasks are triggered on the completion of the
    previous tasks. For instance, after the tests have finished, email the build and
    tests results to all developers.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务链在一起，以便某些任务在先前任务完成后触发。例如，测试完成后，将构建和测试结果通过电子邮件发送给所有开发者。
- en: Store history of the builds and test results.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储构建和测试结果的历史记录。
- en: 'Since each CI platform is able to fulfill our requirements, our decision of
    which CI server to pick boils down to whether to use a hosted or self-hosted solution.
    As always, there''re pros and cons to each approach:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个CI平台都能满足我们的需求，我们选择哪个CI服务器的决定归结于是否使用托管或自托管解决方案。一如既往，每种方法都有其优缺点：
- en: '**Costs**: Most hosted CI services are free for open source projects but require
    a paid plan for private repositories. However, hosting your own CI server also
    incurs costs of running the server.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：大多数托管CI服务对开源项目是免费的，但私有仓库需要付费计划。然而，托管自己的CI服务器也会产生运行服务器的成本。'
- en: '**Self-Reliance**: Relying on external services for your workflow means if
    the external service is down, your workflow will be broken. However, most hosted
    CI services have very good uptime, so availability should not be a huge issue.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自给自足**：依赖外部服务进行工作流程意味着如果外部服务中断，工作流程将会中断。然而，大多数托管CI服务都有非常好的正常运行时间，因此可用性不应成为重大问题。'
- en: '**Flexibility**: With a self-hosted solution, you have complete control over
    the CI server, and can extend the code and feature set with plugins or packages.
    On the other hand, if you require a feature that is not supported in a hosted
    CI server, you''d have to raise a support ticket/feature request and hope it will
    get implemented.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：使用自托管解决方案，你可以完全控制CI服务器，并通过插件或包扩展代码和功能集。另一方面，如果你需要一个托管CI服务器不支持的功能，你必须提出支持票据/功能请求，并希望它会被实现。'
- en: In this chapter, we are going to demonstrate both the hosted and self-hosted
    solutions, using Travis and Jenkins, respectively. The majority of the chapter,
    however, will focus on Jenkins, as it is a much more powerful and generic automation
    server than Travis.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分别使用Travis和Jenkins演示托管和自托管解决方案。然而，本章的大部分内容将专注于Jenkins，因为它是比Travis更强大、更通用的自动化服务器。
- en: Integrating with Travis CI
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Travis CI
- en: Travis is an online CI service that installs, builds, and tests our project.
    Travis is free for open source projects and integrates well with other popular
    services such as GitHub. There's also nothing to install—all we have to do is
    include a `.travis.yml` configuration file at the root of our repository, and
    configure the repository in Travis's web application. Travis has a very shallow
    learning curve and can save us a lot of time. To get started, go to [travis-ci.org](https://travis-ci.org/) and
    sign in using your GitHub account.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Travis是一个在线CI服务，用于安装、构建和测试我们的项目。Travis对开源项目是免费的，并且与其他流行的服务如GitHub很好地集成。而且无需安装——我们只需在我们的仓库根目录中包含一个`.travis.yml`配置文件，并在Travis的Web应用程序中配置仓库即可。Travis的学习曲线非常平缓，可以为我们节省大量时间。要开始，请访问[travis-ci.org](https://travis-ci.org/)并使用你的GitHub账户登录。
- en: Travis has two URLs [travis-ci.org](https://travis-ci.org/), which is used for
    open source projects, and [travis-ci.com](https://travis-ci.com/), which is used
    for private projects. Make sure you're using the right one.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Travis有两个URL [travis-ci.org](https://travis-ci.org/)，用于开源项目，以及 [travis-ci.com](https://travis-ci.com/)，用于私有项目。请确保你使用的是正确的URL。
- en: 'It will ask you for many permissions; these permissions are required for Travis
    to do the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它会要求你提供许多权限；这些权限是Travis执行以下操作所必需的：
- en: '**Read the contents of all repositories associated with your account**: This
    allows Travis to view the content of the `.travis.yml` file, as well as to be
    able to clone your repository in order to build/test it.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取与你账户关联的所有仓库的内容**：这允许Travis查看`.travis.yml`文件的内容，以及能够克隆你的仓库以进行构建/测试。'
- en: '**Install webhooks and services**: This allows Travis to add hooks into your
    repositories, so that when any changes are pushed to your repository, GitHub can
    inform Travis and execute the instructions defined in the `.travis.yml` file.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装webhooks和服务**：这允许Travis将钩子添加到你的仓库中，因此当任何更改推送到你的仓库时，GitHub可以通知Travis并执行`.travis.yml`文件中定义的指令。'
- en: '**Register with the Commit Status API**: This allows Travis to inform GitHub
    of the result of a build/test, so that GitHub can update its UI.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册到提交状态 API**：这允许 Travis 通知 GitHub 构建测试的结果，以便 GitHub 可以更新其用户界面。'
- en: 'After you''ve reviewed these permissions, click Authorize travis-ci:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在你审查了这些权限之后，点击授权 travis-ci：
- en: '![](img/1e2d927e-fad4-4539-bde3-3bb2083570a7.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e2d927e-fad4-4539-bde3-3bb2083570a7.png)'
- en: 'After the authorization step, you''ll be brought back to the main Travis dashboard,
    where you can see every repository under your control:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在授权步骤之后，你将被带回到主要的 Travis 仪表板，在那里你可以看到你控制下的每个仓库：
- en: '![](img/efc2755d-dff6-4c83-baa3-74532477e8f8.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/efc2755d-dff6-4c83-baa3-74532477e8f8.png)'
- en: Here, we only have one project, which we should enable by clicking on the toggle
    button. This will make Travis install a GitHub service hook for that repository.
    Once installed, GitHub will send a message to Travis whenever changes are pushed
    to that repository.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只有一个项目，我们应该通过点击切换按钮来启用它。这将使 Travis 为该仓库安装一个 GitHub 服务钩子。一旦安装，GitHub 就会在更改推送到该仓库时向
    Travis 发送消息。
- en: Configuring Travis CI
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Travis CI
- en: Travis will now be notified of any changes in the repository, but we haven't
    provided it with instructions to execute once a change is detected. Therefore,
    at the root of our project directory, create a configuration file named `.travis.yml`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Travis 现在将通知仓库中的任何更改，但我们还没有提供检测到更改后要执行的指令。因此，在项目目录的根目录下创建一个名为 `.travis.yml`
    的配置文件。
- en: Note the period (`.`) before `travis`, and also that the file extension is `yml`,
    not `yaml`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `travis` 前面的点（`.`），以及文件扩展名是 `yml`，而不是 `yaml`。
- en: Specifying the language
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定语言
- en: In `.travis.yml`, we must first specify the primary language our project is
    written in. This allows Travis to install the required dependencies, and use appropriate
    default settings and configurations. For example, if we specify that our project
    is written in Node.js, Travis will, by default, configure itself to install dependencies
    by running `npm install`, and test the application by running `npm test`. It'll
    also look for a `yarn.lock` file at the root directory, and if it's present, use
    the `yarn install` and `yarn run test` commands instead.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.travis.yml` 中，我们首先必须指定项目编写的主要语言。这允许 Travis 安装所需的依赖项，并使用适当的默认设置和配置。例如，如果我们指定我们的项目是用
    Node.js 编写的，Travis 将默认配置自己通过运行 `npm install` 来安装依赖项，并通过运行 `npm test` 来测试应用程序。它还会在根目录中查找
    `yarn.lock` 文件，如果存在，则使用 `yarn install` 和 `yarn run test` 命令。
- en: 'Therefore, add the following line inside our `.travis.yml` file to inform Travis
    that this project uses Node.js:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `.travis.yml` 文件内添加以下行来通知 Travis 该项目使用 Node.js：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With Node.js, you can also specify which version of Node.js (or io.js) you want
    the build and tests to run on. You can specify Node versions by their major, minor,
    and patch versions, and it will get the latest version that satisfies that criteria.
    You can also use the string `"node"` to get the latest stable Node.js release,
    or `"lts/*"` for the latest LTS Node.js release.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node.js，你还可以指定构建和测试要运行的 Node.js（或 io.js）版本。你可以通过主版本、次版本和补丁版本来指定 Node 版本，它将获取满足该标准的最新版本。你也可以使用字符串
    `"node"` 来获取最新的稳定版 Node.js，或者使用 `"lts/*"` 来获取最新的 LTS 版本 Node.js。
- en: Since this is a server-side application, we have control over the environment
    our application is run in. Therefore, if we want to, we can run our test only
    against the Node.js version specified in the `.nvmrc` file (`8.11.4`). However,
    since this process is automated, and Travis can run these tests in parallel, the
    cost of running additional tests is very low. Therefore, we should run our tests
    against future Node.js versions; doing so will prevent deprecated syntax from
    being introduced into our project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个服务器端应用程序，我们控制着应用程序运行的环境。因此，如果我们想的话，我们可以在 `.nvmrc` 文件中指定的 Node.js 版本（`8.11.4`）上运行我们的测试。然而，由于这个过程是自动化的，Travis
    可以并行运行这些测试，因此运行额外测试的成本非常低。因此，我们应该针对未来的 Node.js 版本运行我们的测试；这样做将防止过时的语法被引入到我们的项目中。
- en: 'Therefore, update our `.travis.yml` to the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更新我们的 `.travis.yml` 到以下内容：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Setting up databases
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库
- en: 'Our code also depends on a running instance of Elasticsearch; therefore, we
    need to specify this requirement in the `.travis.yml` file by adding a `services`
    property:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码还依赖于一个运行中的 Elasticsearch 实例；因此，我们需要在 `.travis.yml` 文件中通过添加 `services` 属性来指定这个需求：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will install and start Elasticsearch on the Travis server instance using
    the default configuration (namely, port `9200`). However, it is advisable to run
    a specific version of Elasticsearch—the same version we are running locally—to
    ensure we get results that are consistent with our development environment. Therefore,
    below the `services` block, add the following `before_install` block:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 Travis 服务器实例上使用默认配置（即端口 `9200`）安装并启动 Elasticsearch。然而，建议运行特定的 Elasticsearch
    版本——与我们本地运行的相同版本——以确保我们得到与我们的开发环境一致的结果。因此，在 `services` 块下方添加以下 `before_install`
    块：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Elasticsearch service may take some time to start; therefore, we should
    also tell Travis to wait a few seconds before attempting to run the tests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 服务可能需要一些时间才能启动；因此，我们也应该告诉 Travis 在尝试运行测试之前等待几秒钟。
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting environment variables
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: 'Lastly, our application reads variables from the environment. Since the `.env`
    and `test.env` files are not included as part of our repository, we need to manually
    provide them to Travis. We can do this by adding an `env.global` block:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的应用程序从环境中读取变量。由于 `.env` 和 `test.env` 文件不是我们仓库的一部分，我们需要手动将它们提供给 Travis。我们可以通过添加一个
    `env.global` 块来完成此操作：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our final `.travis.yml` should look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的 `.travis.yml` 应该看起来像这样：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For more information about different fields in the `.travis.yml` file, check
    out [docs.travis-ci.com/user/customizing-the-build/](https://docs.travis-ci.com/user/customizing-the-build/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `.travis.yml` 文件中不同字段的详细信息，请参阅 [docs.travis-ci.com/user/customizing-the-build/](https://docs.travis-ci.com/user/customizing-the-build/)。
- en: Activating our project
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活我们的项目
- en: 'Next, go to [travis-ci.org](https://travis-ci.org) to ensure your project is
    activated:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，前往 [travis-ci.org](https://travis-ci.org) 确保您的项目已激活：
- en: '![](img/cd405fdf-8dd6-46bd-91ba-79e6123f3704.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd405fdf-8dd6-46bd-91ba-79e6123f3704.png)'
- en: Now, commit `.travis.yml` to the root of the project directory, and push the
    change to GitHub. The GitHub service hook will now notify Travis of the change,
    and Travis will clone the repository, build the application, and run the tests.
    After the tests are complete (or aborted in cases of error), it will show a report
    on the Travis dashboard. The results will also be shared with GitHub so that it
    can update its UI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `.travis.yml` 提交到项目目录的根目录，并将更改推送到 GitHub。GitHub 服务钩子现在将通知 Travis 发生更改，Travis
    将克隆仓库，构建应用程序，并运行测试。测试完成后（或在出现错误的情况下终止），它将在 Travis 仪表板上显示报告。结果也将与 GitHub 共享，以便它可以更新其用户界面。
- en: Examining Travis CI results
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 Travis CI 结果
- en: 'A Travis build will either pass or fail. If the build fails, it will be accompanied
    by a red cross:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Travis 构建要么通过要么失败。如果构建失败，它将伴随一个红色交叉：
- en: '![](img/24ebb3ff-c1bd-4347-9f2b-528a3688de68.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24ebb3ff-c1bd-4347-9f2b-528a3688de68.png)'
- en: 'By default, Travis will also send an email notifying us of the result of the
    build and tests:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Travis 还会发送一封电子邮件通知我们构建和测试的结果：
- en: '![](img/d98e8647-f081-4847-8cec-172c573eed1c.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d98e8647-f081-4847-8cec-172c573eed1c.jpg)'
- en: 'Travis also integrates with GitHub''s Commit Status API ([developer.github.com/v3/repos/statuses/](https://developer.github.com/v3/repos/statuses/)),
    which allows third parties to attach a status to commits. Here, Travis is attaching
    the failure state to the comment, which shows up as a red cross indicator next
    to the commit time:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Travis 还集成了 GitHub 的 Commit Status API ([developer.github.com/v3/repos/statuses/](https://developer.github.com/v3/repos/statuses/))，这使得第三方可以为提交附加状态。在这里，Travis
    将失败状态附加到注释中，显示为提交时间旁边的红色交叉指示器：
- en: '![](img/f8b3b2ad-3496-4c7c-887a-6c5b3db10eed.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8b3b2ad-3496-4c7c-887a-6c5b3db10eed.png)'
- en: 'But, most importantly, each run also saves the history of the logs, so in cases
    of error, the developers are able to pinpoint the issue and fix it quickly:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但最重要的是，每次运行还会保存日志的历史记录，因此，在出现错误的情况下，开发者能够快速定位问题并进行修复：
- en: '![](img/7537f940-ef7b-4c27-8de0-441761843896.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7537f940-ef7b-4c27-8de0-441761843896.png)'
- en: Continuous Integration with Jenkins
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Jenkins 的持续集成
- en: Now you know how to integrate with Travis CI, and know what you can expect from
    a CI server, let's try to replicate the same results using Jenkins, a self-hosted
    alternative. We have chosen Jenkins here because, at the time of writing, it is
    the most popular CI tool, with over 1 million users and 150,000 installs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何与 Travis CI 集成，并了解可以从 CI 服务器期望什么，让我们尝试使用 Jenkins，一个自托管的替代方案，来复制相同的结果。我们在这里选择
    Jenkins 是因为，在撰写本文时，它是最受欢迎的 CI 工具，拥有超过 100 万用户和 15 万次安装。
- en: First, we will give you a brief introduction to Jenkins, and then we'll install
    and integrate it with our repository.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为您简要介绍 Jenkins，然后我们将安装并集成它到我们的仓库中。
- en: Introduction to Jenkins
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins 简介
- en: 'While Travis is purely a CI server, Jenkins is much more powerful. Generally
    speaking, Jenkins is an open source **automation server**. This means it can automate
    any processes that are tricky to do by hand, either because it is repetitive,
    time-consuming, prone to human errors, or all of the above. For example, we can
    use Jenkins for the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Travis 是一个纯 CI 服务器，但 Jenkins 的功能更为强大。一般来说，Jenkins 是一个开源的**自动化服务器**。这意味着它可以自动化任何手工操作困难的过程，无论是由于重复性、耗时、易出错，还是以上所有原因。例如，我们可以使用
    Jenkins 进行以下操作：
- en: Building/packaging applications
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建/打包应用程序
- en: Dynamically generating documentation
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态生成文档
- en: Running pre-deployment E2E/integration/unit/UI tests
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行部署前 E2E/集成/单元/UI 测试
- en: Deployment onto various testing environments (for example, development, staging)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到各种测试环境（例如，开发、预发布）
- en: Running post-deployment tests
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行部署后测试
- en: Deployment onto the production environment
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序部署到生产环境
- en: Furthermore, these processes can be chained together to form workflows, where
    the execution of one process depends on the result of the previous process. There
    are two ways of configuring these automated workflows—as **freestyle projects**,
    or as **pipelines**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些过程可以串联起来形成工作流程，其中某个过程的执行依赖于前一个过程的结果。配置这些自动化工作流程有两种方式——作为**自由式项目**，或作为**管道**。
- en: Freestyle projects
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自由式项目
- en: Freestyle projects (a.k.a. **jobs**, or simply **projects**) were the original
    method for which all automated tasks must be defined in Jenkins. A freestyle project
    is simply a set of user-defined tasks that Jenkins should perform. For example,
    a project may involve building an application from a Git repository, while another
    project is used to run tests on this built application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 自由式项目（又称**工作**，或简称**项目**）是所有自动化任务在 Jenkins 中必须定义的原始方法。自由式项目简单来说就是 Jenkins 应执行的一组用户定义的任务。例如，一个项目可能涉及从
    Git 仓库构建应用程序，而另一个项目则用于在此构建的应用程序上运行测试。
- en: The terms **freestyle project**, **project**, and **job** are synonymous with
    each other. The term **job** is commonly used in the UI of the web interface,
    but it has been deprecated and we will use the term **project** in this book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**自由式项目**、**项目**和**工作**是同义的。术语**工作**在 Web 界面的 UI 中常用，但它已被弃用，在这本书中我们将使用术语**项目**。
- en: 'You can configure a freestyle project using the web interface, which allows
    you to define the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Web 界面配置自由式项目，这允许你定义以下内容：
- en: '**Source Code Management** (**SCM**): Specifies how Jenkins can obtain the
    starting source code for it to build/test.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码管理**（**SCM**）：指定 Jenkins 如何获取构建/测试的起始源代码。'
- en: '**Build triggers**: Specifies when this project should execute. For example,
    you may want to trigger a build when a new commit is pushed to the repository;
    or build the project every night at 00:00 to produce the nightly build.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建触发器**：指定此项目何时执行。例如，你可能希望在将新提交推送到仓库时触发构建；或者每晚 00:00 构建项目以生成夜间构建。'
- en: '**Build environment**.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建环境**。'
- en: '**Build**: Allows you to specify build steps. Despite its name, you can actually
    run any shell command, such as test runners, as a build step.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：允许你指定构建步骤。尽管其名称如此，你实际上可以将任何 shell 命令，如测试运行器，作为构建步骤运行。'
- en: '**Post-build action**: Allows you to specify commands to execute after the
    build steps have been completed. You can, for instance, send the test results
    to the system administrator via email. Furthermore, you can use the post-build
    action to trigger another project to execute. This way, you can form a chain of
    projects that run one after another.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建后操作**：允许你在构建步骤完成后执行指定命令。例如，你可以通过电子邮件将测试结果发送给系统管理员。此外，你可以使用构建后操作来触发另一个项目执行。这样，你可以形成一个项目链，一个接一个地运行。'
- en: Pipeline
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: 'Freestyle projects are powerful and have been the status quo for many years.
    However, it is found lacking in several areas:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 自由式项目功能强大，并且多年来一直是主流。然而，它在几个方面被发现存在不足：
- en: When Hudson, Jenkins' predecessor, was written, using a UI for configuration
    was the norm. However, in the last few years, the ecosystem has moved towards **Configuration-as-Code**
    (**CaC**), where the configuration can be tracked in source control.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Jenkins 的前身 Hudson 被编写时，使用 UI 进行配置是标准做法。然而，在过去的几年里，生态系统已经转向 **Configuration-as-Code**
    (**CaC**)，其中配置可以在源代码控制中进行跟踪。
- en: Jenkins saves the configurations files for freestyle projects on the Jenkins
    server under `/var/lib/jenkins/jobs/`. This means if the Jenkins server is destroyed,
    all the configuration settings would be lost. Furthermore, the configuration file
    is written in XML and is hard to read.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins 将 freestyle 项目的配置文件保存在 Jenkins 服务器上的 `/var/lib/jenkins/jobs/` 目录下。这意味着如果
    Jenkins 服务器被破坏，所有的配置设置都会丢失。此外，配置文件是用 XML 编写的，难以阅读。
- en: While it is possible to chain multiple freestyle projects together using post-build
    actions, you are likely to end up with a lot of duplicate projects, each with
    different post-build action steps.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然使用后置构建操作将多个 freestyle 项目链接在一起是可能的，但你很可能会最终拥有许多重复的项目，每个项目都有不同的后置构建操作步骤。
- en: 'To address these issues, Jenkins 2.0 came with a feature called **P****ipeline**,
    which allow you to do the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，Jenkins 2.0 引入了一个名为 **P****ipeline** 的功能，它允许你执行以下操作：
- en: Instead of linking multiple freestyle projects together via post-action build
    steps, you can, with Pipeline, specify many sequential **steps**, which can optionally
    be grouped into **stages**. In a Pipeline, the execution of a downstream step/stage
    depends on the outcome of the previous step/stage in the chain. Only when the
    previous steps are successful will the subsequent steps be run. For example, if
    the tests did not pass, then the deployment step would not run.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与通过后置构建步骤将多个 freestyle 项目链接在一起不同，使用 Pipeline，你可以指定许多顺序的 **步骤**，这些步骤可以可选地分组为
    **阶段**。在 Pipeline 中，下游步骤/阶段的执行取决于链中先前步骤/阶段的输出。只有当前面的步骤成功时，后续的步骤才会运行。例如，如果测试没有通过，那么部署步骤就不会执行。
- en: 'Allows you to specify steps using a `Jenkinsfile`: A configuration file that
    is part of your codebase. This CaC (or "pipeline as code") approach means all
    changes made to the pipeline can be tracked in Git, Pipelines can be branched
    and merged, and any broken pipelines can be reverted back to the last-known-good
    version. Furthermore, even if the Jenkins server is corrupt, the configuration
    will still survive as the `Jenkinsfile` is stored in the repository, not the Jenkins
    server; this also means that you can build the project using any Jenkins server
    that has access to the repository.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你使用 `Jenkinsfile` 指定步骤：这是你代码库的一部分的配置文件。这种 CaC（或“pipeline as code”）方法意味着对 pipeline
    所做的所有更改都可以在 Git 中跟踪，Pipeline 可以进行分支和合并，任何损坏的 Pipeline 都可以回滚到最后已知良好的版本。此外，即使 Jenkins
    服务器损坏，配置也会幸存，因为 `Jenkinsfile` 存储在仓库中，而不是 Jenkins 服务器上；这也意味着你可以使用任何可以访问仓库的 Jenkins
    服务器来构建项目。
- en: Note that you can still define your Pipeline using the Jenkins web UI, although
    using a Jenkinsfile checked into your Git repository is the recommended approach.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你仍然可以使用 Jenkins 网页界面来定义你的 Pipeline，尽管将 Jenkinsfile 检入 Git 仓库是推荐的方法。
- en: 'The pipeline feature is enabled by the pipeline plugin, which is installed
    by default. To define a pipeline, you have to write in a pipeline **Domain Specific
    Language** (**DSL**) syntax and save it inside a text file named `Jenkinsfile`.
    A simple `Jenkinsfile` looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Pipeline 功能由默认安装的 pipeline 插件启用。要定义一个 pipeline，你必须使用 pipeline **领域特定语言** (**DSL**)
    语法编写，并将其保存到名为 `Jenkinsfile` 的文本文件中。一个简单的 `Jenkinsfile` 看起来像这样：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the remainder of this chapter, we will focus on using Jenkins to replicate
    the functions of Travis CI, specifically the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将专注于使用 Jenkins 来复制 Travis CI 的功能，具体包括以下内容：
- en: Integrate with GitHub so that a message will be sent to our Jenkins server whenever
    changes are pushed to our project repository
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 GitHub 集成，以便在将更改推送到我们的项目仓库时向我们的 Jenkins 服务器发送消息
- en: Whenever Jenkins receives that message, it will check out the source code and
    run the tests inside a clean and isolated environment
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当 Jenkins 收到那条消息时，它将检出源代码，并在一个干净且隔离的环境中运行测试
- en: Setting up a new Jenkins server
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新的 Jenkins 服务器
- en: With the Travis-GitHub integration, when GitHub detects a change on any branches
    in the repository, it will send a message to Travis's server(s), which will clone
    the repository, build it, and run the tests. Therefore, to replicate this behavior
    with Jenkins, we must set up a Jenkins CI service to receive GitHub's messages
    and run our tests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Travis-GitHub 集成，当 GitHub 检测到存储库中任何分支的更改时，它将向 Travis 的服务器发送消息，服务器将克隆存储库，构建它并运行测试。因此，为了使用
    Jenkins 复制此行为，我们必须设置一个 Jenkins CI 服务来接收 GitHub 的消息并运行我们的测试。
- en: We can run our Jenkins server on the same machine as our API server. However,
    if our Jenkins job somehow crashes the machine, it will cause our API server to
    go down as well. Therefore, it's much safer to deploy Jenkins CI on its own separate
    server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在与我们的 API 服务器相同的机器上运行我们的 Jenkins 服务器。然而，如果我们的 Jenkins 作业意外地使机器崩溃，它也会使我们的
    API 服务器关闭。因此，将 Jenkins CI 部署在单独的服务器上要安全得多。
- en: Therefore, go to your VPS provider (we'll use DigitalOcean here) and provision
    a new VPS server. The Jenkins server uses around 600 MB of memory when idle; therefore,
    choose a VPS with at least 2 GB of memory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前往您的 VPS 提供商（我们将使用 DigitalOcean）并配置一个新的 VPS 服务器。Jenkins 服务器在空闲时大约使用 600 MB
    的内存；因此，选择至少有 2 GB 内存的服务器。
- en: If you forgot how to set up and provision a new VPS, refer back to [Chapter
    10](673a49d6-f4c5-47b4-afec-af3ff031f150.xhtml), *Deploying Your Application on
    a VPS*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记了如何设置和配置新的 VPS，请参阅第 10 章，*在 VPS 上部署您的应用程序*。
- en: Also, since we have an SSH key pair already, we can simply select that SSH key
    to be used for this VPS, without having to manually upload our SSH key onto the
    server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们已经有了一对 SSH 密钥，我们可以简单地选择该 SSH 密钥用于此 VPS，而无需手动将我们的 SSH 密钥上传到服务器。
- en: Creating the jenkins user
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Jenkins 用户
- en: 'Once you have a VPS running, create a user called `jenkins` with `sudo` privileges:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个运行的 VPS，请使用 `sudo` 权限创建一个名为 `jenkins` 的用户：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, to allow us to log into the server as the power-restricted user `jenkins`
    and not `root`, we must first add the public key of our development machine to
    `/home/jenkins/.ssh/authorized_keys`; the easiest way to do that is to copy the
    `/root/.ssh/` directory and change its owner:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了允许我们以受限用户 `jenkins` 而不是 `root` 登录服务器，我们必须首先将我们的开发机的公钥添加到 `/home/jenkins/.ssh/authorized_keys`；最简单的方法是复制
    `/root/.ssh/` 目录并更改其所有者：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, disable password authentication and root login by editing `/etc/ssh/sshd_config`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过编辑 `/etc/ssh/sshd_config` 来禁用密码认证和 root 登录：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Reload the SSH daemon for the new settings to take effect:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载 SSH 守护进程以使新设置生效：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On a new Terminal, try logging in using the `jenkins` user. Once that's done,
    continue the rest of the setup as `jenkins`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的终端中，尝试使用 `jenkins` 用户登录。一旦完成，继续以 `jenkins` 的身份完成其余的设置。
- en: Configuring time
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置时间
- en: 'Next, let''s configure the timezone and NTP synchronization:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置时区和 NTP 同步：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Installing Java
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Java
- en: 'Then, we need to install and configure Java (replace `java-8-openjdk-amd64`
    with your version of Java):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要安装和配置 Java（将 `java-8-openjdk-amd64` 替换为您的 Java 版本）：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At the time of this writing, Jenkins work best with Java 8\. Java 10 and 11
    support are still experimental (see [jenkins.io/blog/2018/06/17/running-jenkins-with-java10-11/](https://jenkins.io/blog/2018/06/17/running-jenkins-with-java10-11/)). 
    This is why we are using the `openjdk-8-jdk` package instead of `default-jdk`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Jenkins 与 Java 8 配合得最好。Java 10 和 11 的支持仍然是实验性的（见 [jenkins.io/blog/2018/06/17/running-jenkins-with-java10-11/](https://jenkins.io/blog/2018/06/17/running-jenkins-with-java10-11/)）。这就是为什么我们使用
    `openjdk-8-jdk` 软件包而不是 `default-jdk` 的原因。
- en: Installing Jenkins
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Jenkins
- en: 'There are two main versions of Jenkins:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 有两个主要版本：
- en: '**Weekly**: Released every week.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每周**：每周发布一次。'
- en: '**Long-term Support** (**LTS**): Released every 12 weeks. The Jenkins team
    picks the most stable release from the last time an LTS was released, and designates
    that as the next LTS version.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长期支持**（**LTS**）：每12周发布一次。Jenkins 团队从上次 LTS 发布以来选择最稳定的版本，并将其指定为下一个 LTS 版本。'
- en: For enterprise platforms, we want the most recent and stable version; therefore,
    we will install the latest LTS version, which is currently `2.138.1`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业平台，我们希望使用最新且最稳定的版本；因此，我们将安装最新的 LTS 版本，目前是 `2.138.1`。
- en: 'There are many ways to install Jenkins, listed as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Jenkins 有许多方法，如下所示：
- en: It is distributed as a **Web Application ARchive** (**WAR**), or `.war`, file,
    which is simply a collection of resources that, together, constitute a web application.
    A WAR file is how web applications written in Java are distributed; any operating
    system that supports Java would be able to run the WAR file. You can download
    it from [mirrors.jenkins.io/war-stable/latest/jenkins.war](http://mirrors.jenkins.io/war-stable/latest/jenkins.war)
    and run it directly with `java -jar jenkins.war --httpPort=8765`. It'll then be
    available on port `8765`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以 **Web 应用程序存档**（**WAR**）或`.war`文件的形式分发，这只是一个资源集合，这些资源共同构成了一个 Web 应用程序。WAR
    文件是 Java 编写的 Web 应用程序的分发方式；任何支持 Java 的操作系统都能够运行 WAR 文件。您可以从[mirrors.jenkins.io/war-stable/latest/jenkins.war](http://mirrors.jenkins.io/war-stable/latest/jenkins.war)下载它，并使用`java
    -jar jenkins.war --httpPort=8765`直接运行它。然后它将在端口`8765`上可用。
- en: As a Docker container, which you can download from [hub.docker.com/r/jenkins/jenkins/.](https://hub.docker.com/r/jenkins/jenkins/)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Docker 容器，您可以从[hub.docker.com/r/jenkins/jenkins/](https://hub.docker.com/r/jenkins/jenkins/)下载。
- en: As a distribution-specific package—different operating systems also maintain
    their own Jenkins package in their repository. Jenkins packages from the most
    common systems, including Ubuntu/Debian, Red Hat/Fedora/CentOS, Windows, and macOS,
    are maintained by the Jenkins team.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为特定发行版的软件包——不同的操作系统也在它们的仓库中维护自己的 Jenkins 软件包。包括 Ubuntu/Debian、Red Hat/Fedora/CentOS、Windows
    和 macOS 在内的最常见系统的 Jenkins 软件包由 Jenkins 团队维护。
- en: Ideally, we would run our Jenkins server (and everything else for that matter)
    inside isolated Docker containers, however, that requires an understanding of
    containers and Docker, which will be overwhelming to learn alongside Jenkins.
    Therefore, in this chapter, we will use the Jenkins package provided by the APT
    repositories, and you can migrate to using Docker after reading [Chapter 17](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml),
    *Migrating to Docker*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们将在隔离的 Docker 容器内运行我们的 Jenkins 服务器（以及所有其他相关内容），然而，这需要了解容器和 Docker，这将在学习
    Jenkins 的同时变得过于复杂。因此，在本章中，我们将使用 APT 仓库提供的 Jenkins 软件包，您可以在阅读第 17 章[迁移到 Docker](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml)后迁移到使用
    Docker。
- en: 'First, get the public key for the Jenkins repository and add it to APT; this
    allows APT to verify the authenticity of the package:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取 Jenkins 仓库的公钥并将其添加到 APT；这允许 APT 验证软件包的真实性：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we need to add the Jenkins repository to the list of repositories that
    APT will search for. This list is stored at `/etc/apt/sources.list`, as well as
    in files within the `/etc/apt/sources.list.d/` directory. Therefore, run the following
    command, which will create a new `jenkins.list` file and store the repository
    address inside:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 Jenkins 仓库添加到 APT 将要搜索的仓库列表中。这个列表存储在`/etc/apt/sources.list`中，以及`/etc/apt/sources.list.d/`目录下的文件中。因此，运行以下命令，这将创建一个新的`jenkins.list`文件并将仓库地址存储在其中：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, update our local package index and install Jenkins:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新我们的本地软件包索引并安装 Jenkins：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The installation will do several things, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 安装将执行以下操作：
- en: Download the WAR file and place it at `/usr/share/jenkins`
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 WAR 文件并将其放置在`/usr/share/jenkins`。
- en: Create a new user called `jenkins` which will run the service
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`jenkins`的新用户，该用户将运行服务。
- en: Set up Jenkins as a service/daemon that runs when the system first starts
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Jenkins 设置为在系统首次启动时运行的服务/守护进程。
- en: Create a `/var/log/jenkins/jenkins.log` file and direct all output from Jenkins
    to this file
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`/var/log/jenkins/jenkins.log`文件，并将 Jenkins 的所有输出都重定向到这个文件。
- en: You can check the status of the Jenkins service by running `sudo systemctl status
    jenkins.service`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`sudo systemctl status jenkins.service`来检查 Jenkins 服务的状态。
- en: Jenkins runs as a service in the background. It utilizes the Jetty server ([eclipse.org/jetty/](http://www.eclipse.org/jetty/))
    to provide a web interface for users to interact with. By default, this server
    will bind to port `8080`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 作为后台服务运行。它使用 Jetty 服务器([eclipse.org/jetty/](http://www.eclipse.org/jetty/))为用户提供一个交互的
    Web 界面。默认情况下，此服务器将绑定到端口`8080`。
- en: '`8080` is a very common port. If you''re running Jenkins on an existing server
    where port `8080` is bound by another process, you can change Jenkins'' default
    port by editing the `HTTP_PORT` entry inside Jenkins'' configuration file —`/etc/default/jenkins`.
    To put this change into effect, make sure you run `sudo systemctl restart jenkins.service`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`8080`是一个非常常见的端口。如果您在运行 Jenkins 的现有服务器上，端口`8080`已被另一个进程绑定，您可以通过编辑 Jenkins 配置文件中的`HTTP_PORT`条目来更改
    Jenkins 的默认端口——`/etc/default/jenkins`。为了使此更改生效，请确保您运行`sudo systemctl restart jenkins.service`。'
- en: Installing NGINX as a reverse proxy
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 NGINX 作为反向代理。
- en: 'Now, if you go to `http://<server-ip>:8080` on your browser, you''ll see the
    Jenkins setup screen. But ideally, we want to use a human-friendly hostname. So,
    just as we did with our API server, let''s install NGINX to reverse proxy requests
    from `jenkins.hobnob.social` to `http://localhost:8080`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在浏览器中访问 `http://<server-ip>:8080`，您将看到 Jenkins 设置屏幕。但理想情况下，我们希望使用一个易于记忆的主机名。所以，就像我们为
    API 服务器所做的那样，让我们安装 NGINX 来反向代理来自 `jenkins.hobnob.social` 的请求到 `http://localhost:8080`：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in the `/etc/nginx/nginx.conf` file, add a line after `include /etc/nginx/conf.d/*.conf;`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `/etc/nginx/nginx.conf` 文件中，在 `include /etc/nginx/conf.d/*.conf;` 之后添加一行：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, create a configuration file for Jenkins at `/etc/nginx/sites-available/jenkins.hobnob.social` and
    paste in the following content:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `/etc/nginx/sites-available/jenkins.hobnob.social` 创建一个 Jenkins 配置文件，并粘贴以下内容：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This configuration is taken from [wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx](https://wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx).
    The most pertinent parts are highlighted in preceding bold.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置来自 [wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx](https://wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx)。最相关的部分已在前面加粗。
- en: When a request comes in for `jenkins.hobnob.social`, it will match the `location
    /` block, which then proxies the request to the service running at the `proxy_pass`
    directive (`http://localhost:8080`). Likewise, when the internal service returns
    with a response, the `proxy_redirect` directive will rewrite the `Location` header
    of the response and replace `http://localhost:8080` with `http://jenkins.hobnob.social`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当有请求到达 `jenkins.hobnob.social` 时，它将匹配 `location /` 块，然后通过 `proxy_pass` 指令（`http://localhost:8080`）代理请求到运行在该指令的服务。同样，当内部服务返回响应时，`proxy_redirect`
    指令将重写响应的 `Location` 头部，并将 `http://localhost:8080` 替换为 `http://jenkins.hobnob.social`。
- en: 'Now that our server block is ready, add it to the `/etc/nginx/sites-enabled/` directory
    using a symbolic link:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了服务器块，使用符号链接将其添加到 `/etc/nginx/sites-enabled/` 目录：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Lastly, make sure our NGINX configuration does not contain any syntax errors,
    and start it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保我们的 NGINX 配置没有语法错误，并启动它：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Configuring the firewall
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置防火墙
- en: 'To complete our NGINX setup, configure the firewall to ensure traffic can reach
    port `80`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的 NGINX 配置，配置防火墙以确保流量可以到达端口 `80`：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Updating our DNS records
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的 DNS 记录
- en: Now, our Jenkins server should be available on port `80`, but we are still accessing
    our server via an IP address. Therefore, the next step is to configure our DNS
    records to direct traffic destined for `jenkins.hobnob.social` to our VPS.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 Jenkins 服务器应该可以通过端口 `80` 访问，但我们仍然通过 IP 地址访问我们的服务器。因此，下一步是配置我们的 DNS 记录，将流量指向
    `jenkins.hobnob.social` 的流量导向我们的 VPS。
- en: 'On DigitalOcean, go to the Networking tab at the top and add a new `A` record
    pointing the hostname `jenkins.hobnob.social` to our VPS instance:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DigitalOcean 上，转到顶部的网络选项卡并添加一个新的 `A` 记录，将主机名 `jenkins.hobnob.social` 指向我们的
    VPS 实例：
- en: '![](img/0b410a9c-3ad0-4986-b9ce-ff1810a8b961.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b410a9c-3ad0-4986-b9ce-ff1810a8b961.png)'
- en: Now, our Jenkins server instance should be available at `jenkins.hobnob.social`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 Jenkins 服务器实例应该可以通过 `jenkins.hobnob.social` 访问。
- en: Configuring Jenkins
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Jenkins
- en: Now, we are ready to configure Jenkins. Navigate to `jenkins.hobnob.social` on
    your browser; there you'll see a setup wizard.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备配置 Jenkins。在您的浏览器中导航到 `jenkins.hobnob.social`；在那里您将看到一个设置向导。
- en: When Jenkins was installed, a password was written to a file at `/var/lib/jenkins/secrets/initialAdminPassword`,
    which only the system administrator (or users with `sudo` privileges) will have
    access to. This is to ensure that the person accessing the setup wizard is the
    system administrator and not some malicious party.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Jenkins 安装时，一个密码被写入到 `/var/lib/jenkins/secrets/initialAdminPassword` 文件中，只有系统管理员（或具有
    `sudo` 特权的用户）才能访问。这是为了确保访问设置向导的人是系统管理员，而不是恶意第三方。
- en: 'Therefore, the first step is to copy the contents of the `/var/lib/jenkins/secrets/initialAdminPassword`
    file and paste it into the wizard:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是复制 `/var/lib/jenkins/secrets/initialAdminPassword` 文件的内容，并将其粘贴到向导中：
- en: '![](img/99437f2c-3e0b-4a05-a581-42e5dce10684.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99437f2c-3e0b-4a05-a581-42e5dce10684.png)'
- en: 'On the next screen, you''ll be presented with the Customize Jenkins screen,
    where you can choose to install **plugins**. Jenkins, on its own, is just a platform
    that enables automation and has few features itself. Its functionalities are modularized
    into plugins. There are over 1,300 plugins, including integration with the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏，你将看到自定义 Jenkins 屏幕界面，你可以选择安装 **插件**。Jenkins 本身只是一个启用自动化的平台，它本身具有很少的功能。其功能被模块化为插件。有超过
    1300 个插件，包括以下集成：
- en: Version control systems
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制系统
- en: Bug databases
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷数据库
- en: Build tools
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具
- en: Testing frameworks
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试框架
- en: 'Pick Install suggested plugins to install the most commonly used plugins, including
    the Git and GitHub plugins we will use later. You can track the progress of the
    installation on the next screen:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 选择安装建议的插件以安装最常用的插件，包括我们稍后将要使用的 Git 和 GitHub 插件。你可以在下一屏跟踪安装进度：
- en: '![](img/58b808c2-b01c-4fa7-9d6b-9d787011c4b1.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58b808c2-b01c-4fa7-9d6b-9d787011c4b1.png)'
- en: Lastly, you'll be prompted to create an administrative user for the web interface,
    which you'll use to continue the setup process (so remember your username and
    password!).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将被提示为 Web 界面创建一个管理员用户，你将使用它来继续设置过程（所以记住你的用户名和密码！）。
- en: 'Great, now we will have successfully installed Jenkins and have it running
    on a public URL:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们已经成功安装了 Jenkins，并且它正在公共 URL 上运行：
- en: '![](img/3cbb07f9-d80f-408a-853f-07e1585365f5.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3cbb07f9-d80f-408a-853f-07e1585365f5.png)'
- en: Composing a Jenkinsfile
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Jenkinsfile
- en: Now that we have set up our Jenkins instance, we are ready to define our Pipeline using
    the Pipeline DSL. Let's take a look at the Pipeline DSL syntax.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 Jenkins 实例，我们准备使用 Pipeline DSL 定义我们的 Pipeline。让我们看看 Pipeline DSL 语法。
- en: The Pipeline DSL syntax
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pipeline DSL 语法
- en: 'There are a number of global variables, keywords, and directives that can be
    used inside any Pipeline, for example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 Pipeline 中都可以使用许多全局变量、关键字和指令，例如：
- en: '`env`: Environment variables'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`：环境变量'
- en: '`params`: Parameters set when configuring the pipeline'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`：在配置管道时设置的参数'
- en: '`currentBuild`: Information about the current build, such as results, display
    name, and so on'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentBuild`：有关当前构建的信息，例如结果、显示名称等'
- en: The complete Global Variables list can be found at `/pipeline-syntax/globals`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的全局变量列表可以在 `/pipeline-syntax/globals` 找到。
- en: There are keywords which are available only inside steps. For example, the `sh` keyword
    allows you to specify some arbitrary shell command to run, and you can use `echo` to
    print something into the console output.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些关键字只能在步骤内部使用。例如，`sh` 关键字允许你指定一些任意 shell 命令来运行，你可以使用 `echo` 将某些内容打印到控制台输出。
- en: The DSL syntax can also be extended. For example, the JUnit plugin adds the `junit` step
    to the Pipeline vocabulary, which allows your step to aggregate test reports.
    In this chapter, we will use the Docker Pipeline plugin, which adds a `docker`
    keyword to run our tests inside a Docker container. More on this later.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: DSL 语法也可以扩展。例如，JUnit 插件将 `junit` 步骤添加到 Pipeline 词汇表中，这使得你的步骤可以聚合测试报告。在本章中，我们将使用
    Docker Pipeline 插件，该插件添加了一个 `docker` 关键字来在 Docker 容器中运行我们的测试。关于这一点，我们将在后面详细说明。
- en: Declarative versus scripted pipelines
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式与脚本式 Pipeline 的比较
- en: There are two syntaxes to define Pipelines—declarative and scripted. Originally,
    the Pipeline plugin supported only scripted pipelines, but Declarative Pipeline
    syntax 1.0 was added in February 2017 with Pipeline 2.5. Both of these syntaxes
    use the same underlying execution engine to execute instructions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 Pipeline 有两种语法——声明式和脚本式。最初，Pipeline 插件只支持脚本式 Pipeline，但声明式 Pipeline 语法 1.0
    在 2017 年 2 月随着 Pipeline 2.5 的发布被添加。这两种语法都使用相同的底层执行引擎来执行指令。
- en: A Scripted Pipeline allows you to define your instructions using a full-featured
    programming language called **Groovy**; because of this, you are able to be very
    expressive. The downside is that the code may be less understandable, and thus
    less maintainable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本式 Pipeline 允许你使用一个功能齐全的编程语言 **Groovy** 来定义你的指令；正因为如此，你可以非常灵活。缺点是代码可能不太容易理解，因此维护性较差。
- en: The Declarative Pipeline syntax brings structure to the Pipeline, which means
    it's easier to check the file for syntax errors, provide linting help. But with
    Declarative Pipelines, you can only define instructions that are supported by
    the syntax.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式 Pipeline 语法为 Pipeline 带来了结构，这意味着检查文件中的语法错误更容易，提供代码检查帮助。但是，使用声明式 Pipeline，你只能定义由语法支持的指令。
- en: Therefore, you should use the Declarative Pipeline syntax *wherever possible*,
    and fall back to the Scripted Pipelines only when there are instructions that
    cannot be achieved using a Declarative Pipeline.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该尽可能使用声明式流水线语法，只有在无法使用声明式流水线实现指令时才回退到脚本式流水线。
- en: The declarative pipeline
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式流水线
- en: Every declarative pipeline must start with the `pipeline` directive. Within
    the `pipeline` directive are, usually, the `agent`, `stages`, and `step` directives.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每个声明式流水线都必须以`pipeline`指令开始。在`pipeline`指令中，通常是`agent`、`stages`和`step`指令。
- en: The `agent` directive tells Jenkins to allocate an executor and workspace for
    this part of the Pipeline. A workspace is simply a directory in the filesystem
    where Jenkins can work with the files to run the build, and an executor is simply
    a thread that executes the task. When you use the `agent` directive, it will also
    download the source repository and save it to the workspace, so that the code
    is available for subsequent stages.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`agent`指令告诉Jenkins为流水线的这部分分配一个执行器和工作空间。工作空间只是文件系统中Jenkins可以与之交互以运行构建的目录，而执行器只是一个执行任务的线程。当你使用`agent`指令时，它还会下载源代码库并将其保存到工作空间，以便后续阶段可以使用代码。'
- en: 'A typical declarative pipeline might look like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的声明式流水线可能看起来像这样：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The scripted pipeline
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本式流水线
- en: A declarative pipeline must be defined within a `pipeline` directive that includes
    an `agent` directive; for scripted pipelines, the Pipeline must be enclosed within
    the `node` directive.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pipeline`指令中必须定义一个声明式流水线，该指令包括一个`agent`指令；对于脚本式流水线，流水线必须被包含在`node`指令中。
- en: 'The `node` directive in a Scripted Pipeline is similar to the `agent` directive
    in the Declarative Pipeline, and allocates an executor and workspace for the pipeline.
    Unlike the `agent` directive, the node will not automatically download the source
    repository and save it to your workspace; instead, you have to specify that manually
    using the `checkout scm` step:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本式流水线中的`node`指令类似于声明式流水线中的`agent`指令，并为流水线分配一个执行器和工作空间。与`agent`指令不同，节点不会自动下载源代码库并将其保存到你的工作空间；相反，你必须使用`checkout
    scm`步骤手动指定：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`scm` is a special variable that represents the version of the repository that
    triggered the build.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`scm`是一个特殊变量，代表触发构建的代码库版本。'
- en: Setting up the environment
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: To ensure that the build and test steps execute consistently, we should run
    them inside a **container**, which is an ephemeral, pre-configured, isolated environment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保构建和测试步骤能够一致地执行，我们应该在**容器**内运行它们，这是一个短暂的、预先配置的、隔离的环境。
- en: A container is similar to a virtual machine, but uses fewer resources and is
    quicker to provision. Creating containers is cheap; this allows us to create containers,
    run the tests, and then discard them afterward.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 容器类似于虚拟机，但使用更少的资源，并且部署更快。创建容器成本低廉；这允许我们创建容器，运行测试，然后丢弃它们。
- en: We will dive more in-depth into Docker in [Chapter 17](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml), *Migrating
    to Docker*; for now, it's sufficient to understand that a Docker container provides
    an isolated and consistent environment for us to run our builds and tests.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第17章[迁移到Docker](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml)中更深入地探讨Docker；目前，理解Docker容器为我们提供了一个隔离和一致的环境来运行我们的构建和测试就足够了。
- en: 'Docker is the most popular container framework out there, and we will run our
    builds and tests inside Docker containers. In your repository, add the following
    Scripted Pipeline into a `Jenkinsfile` file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是目前最受欢迎的容器框架，我们将在Docker容器内运行我们的构建和测试。在你的仓库中，将以下脚本式流水线添加到`Jenkinsfile`文件中：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `docker` variable is provided by the Docker Pipeline plugin, and allows
    you to run Docker-related functions within a Pipeline. Here, we are using `docker.image()`
    to pull in an image. The image's `withRun` method will use `docker run` to run
    the image on the host.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker`变量由Docker流水线插件提供，允许你在流水线中运行与Docker相关的函数。在这里，我们使用`docker.image()`来拉取镜像。镜像的`withRun`方法将使用`docker
    run`在主机上运行该镜像。'
- en: Here, we are running the `elasticsearch-oss` image, and passing in the `discovery.type`
    flag—the same one that we've been using in previous chapters. Once the container
    is running, Jenkins will execute all the commands specified within the `withRun`
    block *on the host*, and then automatically exit once all the commands inside
    the body have finished.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在运行 `elasticsearch-oss` 镜像，并传递 `discovery.type` 标志——这是我们之前章节中使用过的同一个标志。一旦容器运行，Jenkins
    将执行 `withRun` 块内指定的所有命令，然后在主体内的所有命令完成后自动退出。
- en: Within the `withRun` block, we are specifying a `docker.image().inside()` block.
    Similar to `withRun`, commands inside the `inside` block will run once the container
    is up, but these instructions will run *inside the container*, instead of on the
    host. This is where we will run our tests.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `withRun` 块内，我们指定了一个 `docker.image().inside()` 块。类似于 `withRun`，`inside` 块内的命令将在容器启动后运行，但这些指令将在容器内运行，而不是在主机上。这就是我们将运行测试的地方。
- en: Finally, we are passing in a `--link` flag to `inside`. This uses legacy Docker
    container links to provide our `node:8.11.4` container with information about
    the `elasticsearch-oss` container, such as its address and ports. This allows
    our API application to connect to the database.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向 `inside` 传递一个 `--link` 标志。这使用旧的 Docker 容器链接来为我们提供 `node:8.11.4` 容器关于
    `elasticsearch-oss` 容器的信息，例如其地址和端口。这允许我们的 API 应用程序连接到数据库。
- en: 'The `--link` flag has the following syntax:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`--link` 标志的语法如下：'
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, `<name or id>` is the name or ID of the container we want to link to,
    and `alias` is a string that allows us to refer to this link by name. After `withRun` has
    successfully run a container, it will provide the body with a container object,
    `c`, which has an `id` property we can use in the link.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<name or id>` 是我们想要链接的容器的名称或 ID，而 `alias` 是一个字符串，允许我们通过名称来引用这个链接。在 `withRun`
    成功运行一个容器后，它将向主体提供一个容器对象 `c`，该对象有一个 `id` 属性，我们可以在链接中使用。
- en: Once a container is linked, Docker will set several environment variables to
    provide information about the linked container. For instance, we can find out
    the IP address of the linked container by referring to the value of `DB_PORT_9200_TCP_ADDR`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器被链接，Docker 将设置几个环境变量来提供有关链接容器的信息。例如，我们可以通过引用 `DB_PORT_9200_TCP_ADDR` 的值来找出链接容器的
    IP 地址。
- en: You can see a full list of environment variables set by Docker at [docs.docker.com/network/links/#environment-variables](https://docs.docker.com/network/links/#environment-variables).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [docs.docker.com/network/links/#environment-variables](https://docs.docker.com/network/links/#environment-variables)
    查看Docker设置的所有环境变量的完整列表。
- en: Save this `Jenkinsfile` and push it to the remote repository.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此 `Jenkinsfile` 并将其推送到远程仓库。
- en: Installing Docker
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: 'Since Jenkins now relies on Docker, we must install Docker on this Jenkins
    server:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jenkins 现在依赖于 Docker，我们必须在此 Jenkins 服务器上安装 Docker：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This installation will do a few things, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此安装将执行以下几件事：
- en: Install the Docker Engine, which runs as a daemon in the background
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker 引擎，它作为守护进程在后台运行
- en: Install the Docker client, which is a command-line tool (`docker`) we can run
    in our Terminal
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker 客户端，它是一个命令行工具（`docker`），我们可以在我们的终端中运行
- en: Create a user on our machine called `docker`, and assign it to the `docker`
    group
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的机器上创建一个名为 `docker` 的用户，并将其分配给 `docker` 组
- en: To check Docker is installed properly, you can check its status by running `sudo
    systemctl status docker`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 Docker 是否正确安装，你可以通过运行 `sudo systemctl status docker` 来检查其状态。
- en: 'By default, the docker command must be invoked with root privileges. The exception
    to this rule is if the user is `docker`, or if the user is in the `docker` group.
    We are running our Jenkins server under the user `jenkins`; therefore, to allow
    our Jenkins server to spawn new Docker containers, we must add the `jenkins` user
    to the `docker` group:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，必须以 root 权限调用 docker 命令。这个规则的例外是如果用户是 `docker`，或者如果用户在 `docker` 组中。我们正在用
    `jenkins` 用户运行 Jenkins 服务器；因此，为了允许我们的 Jenkins 服务器生成新的 Docker 容器，我们必须将 `jenkins`
    用户添加到 `docker` 组中：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To check that this is successful, run the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查这是否成功，请运行以下命令：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, restart the Jenkins service for this change to take effect:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重新启动 Jenkins 服务以使此更改生效：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Integration with GitHub
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 GitHub 集成
- en: We now have a `Jenkinsfile` that provides instructions on how to run the tests,
    and a Jenkins server to run them; the only thing left is to set up a service hook
    with GitHub, so that it will trigger the Jenkins Pipeline whenever changes are
    pushed to the repository.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`Jenkinsfile`，它提供了如何运行测试的说明，以及一个用于运行测试的Jenkins服务器；剩下要做的就是设置GitHub的服务钩子，以便在将更改推送到仓库时触发Jenkins
    Pipeline。
- en: Providing access to the repository
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供对仓库的访问权限
- en: 'First and foremost, we must provide our Jenkins server with permissions to
    access our repository, as well as to set up service hooks. There are several ways
    to do this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须为我们提供Jenkins服务器访问我们的仓库以及设置服务钩子的权限。有几种方法可以做到这一点：
- en: Create a Personal Access (OAuth) Token on GitHub, which essentially allows your
    Jenkins server to masquerade as you. The benefits of this approach are that you
    can have one token that can be used everywhere to access all repositories under
    your control. However, although the scope of the token can be restricted, these
    permissions are applicable for all repositories under your account. Thus, this
    approach does not allow you to set granular permissions for each repository.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub上创建一个个人访问（OAuth）令牌，这本质上允许你的Jenkins服务器伪装成你。这种方法的优点是你可以有一个可以在任何地方使用的令牌，以访问你控制下的所有仓库。然而，尽管令牌的作用域可以被限制，但这些权限适用于你账户下的所有仓库。因此，这种方法不允许你为每个仓库设置细粒度的权限。
- en: Create a new user on GitHub that represents the Jenkins server, and add that
    user as a collaborator into your repository. After creating the account, you'll
    need to create a new SSH key pair on your Jenkins host machine, and add the public
    key to GitHub (just as you would for a normal user). Then, configure your Jenkins
    server to use this SSH key to communicate with GitHub.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub上创建一个新的用户代表Jenkins服务器，并将该用户添加到你的仓库中作为协作者。创建账户后，你需要在Jenkins主机机器上创建一个新的SSH密钥对，并将公钥添加到GitHub（就像为普通用户做的那样）。然后，配置你的Jenkins服务器使用此SSH密钥与GitHub通信。
- en: The benefits of this approach are that it allows you to separate your identity
    from the Jenkin servers, and you can simply add the Jenkin GitHub user to any
    other repository that you wish to grant access to the Jenkins server.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法的优点是它允许你将你的身份与Jenkins服务器分离，并且你可以简单地将Jenkins GitHub用户添加到你希望授予Jenkins服务器访问权限的任何其他仓库。
- en: As in Step 2, create a new user on GitHub that represents the Jenkin server,
    and set up a new SSH key pair. Then, go to your repository and click on the Settings
    tab. In the sidebar, click Deploy Keys, then click Add deploy key. Now, paste
    your SSH key into the text area and save.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如步骤2中所述，在GitHub上创建一个新的用户代表Jenkins服务器，并设置一个新的SSH密钥对。然后，转到你的仓库并点击设置选项卡。在侧边栏中，点击部署密钥，然后点击添加部署密钥。现在，将你的SSH密钥粘贴到文本区域并保存。
- en: The benefits of this approach are that you can grant access to only a single
    repository. They are called **Deploy keys** precisely because this method is used
    a lot for automated deployments. You can set the permission for the deploy key
    to be read-only (so they only clone, build, and deploy), or both read and write
    permissions (so they can also push changes back to the repository).
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法的优点是你可以仅授予对单个仓库的访问权限。它们被称为**部署密钥**，正是因为这种方法经常用于自动化部署。你可以设置部署密钥的权限为只读（这样它们只能克隆、构建和部署），或者读写权限（这样它们也可以将更改推回仓库）。
- en: To keep it simple, we are going to use the Personal Access Token method, as
    outlined in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将使用下一节中概述的个人访问令牌方法。
- en: The Personal Access (OAuth) Token
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人访问（OAuth）令牌
- en: 'Go to [github.com/settings/tokens](https://github.com/settings/tokens) and
    click on Generate new token. Select the repo, admin:repo_hook, and admin:org_hook
    scopes:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[github.com/settings/tokens](https://github.com/settings/tokens)并点击生成新令牌。选择repo、admin:repo_hook和admin:org_hook作用域：
- en: '![](img/b6630e9c-2586-4332-bb2c-3bfa4c3e062e.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6630e9c-2586-4332-bb2c-3bfa4c3e062e.png)'
- en: 'Now, a new token is generated:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，生成了一个新令牌：
- en: '![](img/4d55b352-2dc2-4aaa-9f89-22069cce546b.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d55b352-2dc2-4aaa-9f89-22069cce546b.png)'
- en: Next, we can add this token to the **Credentials** store in Jenkins, which is
    like a password manager and stores our credentials for us to reference inside
    our configuration. Click on the Credentials entry from the sidebar on the left
    of the Jenkins UI.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将此令牌添加到Jenkins中的**凭据**存储中，它就像一个密码管理器，为我们存储凭据以便在配置中引用。点击Jenkins UI左侧侧边栏中的凭据条目。
- en: 'Next, under Stores scoped to Jenkins, click on the arrow next to the (global)
    link and then Add credentials. This will allow you to add your Personal Access
    Token to be available to the whole of Jenkins server:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在“针对 Jenkins 的存储”下，点击“(全局)”链接旁边的箭头，然后添加凭据。这将允许您将个人访问令牌添加到 Jenkins 服务器中：
- en: '![](img/2dfe208a-9f81-4da1-ba9b-0b6315bb73cb.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2dfe208a-9f81-4da1-ba9b-0b6315bb73cb.png)'
- en: 'Then, in the form that appears, input the following values:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在出现的表单中，输入以下值：
- en: '![](img/f3b2b491-6639-422a-a13d-b073605f2a82.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3b2b491-6639-422a-a13d-b073605f2a82.png)'
- en: There are two options available for the Scope field—system or global. A system-scoped
    credential can be used by the Jenkins instance itself, but not in freestyle projects
    or pipelines. Global-scoped credentials can be used by all. The ID is an internal
    unique ID that is used to identify this credential; if left blank, an ID will
    be generated automatically.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 范围字段有两个选项——系统或全局。系统范围的凭据可以被 Jenkins 实例本身使用，但不能在自由式项目或管道中使用。全局范围的凭据可以被所有人使用。ID
    是用于识别此凭据的内部唯一标识符；如果留空，将自动生成一个 ID。
- en: Using the GitHub plugin
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub 插件
- en: 'To integrate with GitHub so that changes pushed to the repository will trigger
    a build on Jenkins, we will need to use two plugins:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 GitHub 集成，以便将更改推送到仓库时在 Jenkins 上触发构建，我们需要使用两个插件：
- en: '**Git plugin** ([plugins.jenkins.io/git](https://plugins.jenkins.io/git)):
    Enables Jenkins to clone and pull from any Git repository that it has access to.
    Also adds Git-specific environment variables to the build environment so you can
    use it during any build steps.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git 插件** ([plugins.jenkins.io/git](https://plugins.jenkins.io/git))：使 Jenkins
    能够克隆和从它有访问权限的任何 Git 仓库中拉取。同时，在构建环境中添加 Git 特定的环境变量，以便您可以在任何构建步骤中使用它。'
- en: '**GitHub plugin** ([plugins.jenkins.io/github](https://plugins.jenkins.io/github)):
    Allows you to set up a service hook on GitHub that will send a message to our
    Jenkins instance each time a change is pushed to GitHub. The GitHub plugin also
    depends on the Git plugin.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub 插件** ([plugins.jenkins.io/github](https://plugins.jenkins.io/github))：允许您在
    GitHub 上设置一个服务钩子，每次有更改推送到 GitHub 时，都会向我们的 Jenkins 实例发送消息。GitHub 插件还依赖于 Git 插件。'
- en: These two plugins should be installed if you followed the standard installation;
    otherwise, install them before moving forward.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循了标准安装流程，则应安装这两个插件；否则，在继续之前请安装它们。
- en: 'For the GitHub plugin to automatically set up service hooks for us, we must
    provide it with the credentials we stored earlier. Go to Manage Jenkins | Configure
    Systems and under the GitHub section, add a new GitHub Server:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 GitHub 插件为我们自动设置服务钩子，我们必须提供之前存储的凭据。转到“管理 Jenkins”|“配置系统”，然后在 GitHub 部分，添加一个新的
    GitHub 服务器：
- en: '![](img/82ad4aaa-335e-485e-aa5e-8c08fb15ae02.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82ad4aaa-335e-485e-aa5e-8c08fb15ae02.png)'
- en: In the Credentials field, select the credential we stored in the previous name.
    Then, click Test connection so Jenkins can send a dummy request to GitHub to ensure
    the token is a valid one. Now, our GitHub plugin will be able to perform actions
    on our behalf.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在凭据字段中，选择我们在之前步骤中存储的凭据。然后，点击测试连接，以便 Jenkins 可以向 GitHub 发送一个模拟请求来确保令牌是有效的。现在，我们的
    GitHub 插件将能够代表我们执行操作。
- en: Setting up GitHub service hooks manually
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动设置 GitHub 服务钩子
- en: 'Next, go to our `Hobnob` repository on GitHub and select Settings | Integrations
    & services. You should see a list of services that hook onto events on GitHub,
    including the Travis service we added at the beginning of this chapter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到 GitHub 上的“Hobnob”仓库，并选择“设置”|“集成与服务”。您应该会看到一个服务列表，这些服务连接到 GitHub 上的事件，包括我们在本章开头添加的
    Travis 服务：
- en: '![](img/19fa6e47-56af-4b77-b168-7ea84c454df2.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19fa6e47-56af-4b77-b168-7ea84c454df2.png)'
- en: 'Next, we need to add the Jenkins (GitHub plugin) to the list of services:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 Jenkins（GitHub 插件）添加到服务列表中：
- en: '![](img/7b33b7da-dcb8-4ecc-899f-390a90efd838.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b33b7da-dcb8-4ecc-899f-390a90efd838.png)'
- en: 'On the next screen, GitHub will ask you to specify the Jenkins hook url; this
    is the URL that GitHub uses to inform our Jenkins instance of a change in the
    repository. Jenkins uses a single post-commit hook URL for all the repositories;
    by default, this has the format of `http://<ip-or-hostname>/github-webhook/`.
    So for us, we will use `http://jenkins.hobnob.social/github-webhook/`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏幕上，GitHub 将要求您指定 Jenkins 钩子 URL；这是 GitHub 用于通知我们的 Jenkins 实例仓库变更的 URL。Jenkins
    使用单个 post-commit 钩子 URL 来处理所有仓库；默认情况下，其格式为 `http://<ip-or-hostname>/github-webhook/`。因此，对于我们来说，我们将使用
    `http://jenkins.hobnob.social/github-webhook/`：
- en: '![](img/e7163bf8-54c9-4b64-a8e1-3ea4dcd34786.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7163bf8-54c9-4b64-a8e1-3ea4dcd34786.png)'
- en: 'This will add the Service Hook to GitHub, but it''ll also indicate that it
    has never been triggered:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为GitHub添加服务钩子，但也会表明它从未被触发：
- en: '![](img/c359edd8-701c-47bf-81b0-ad1b425dbd9b.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c359edd8-701c-47bf-81b0-ad1b425dbd9b.png)'
- en: Next, we need to create the pipeline on Jenkins so that when the service hook
    is triggered, we can run our pipeline as defined in the `Jenkinsfile`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在Jenkins上创建管道，以便当服务钩子被触发时，我们可以运行在`Jenkinsfile`中定义的管道。
- en: Creating a new folder
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新文件夹
- en: But before we create a pipeline, we know that our application will consist of
    two parts—a backend API server and a frontend web interface. We will eventually
    use Jenkins to build both of these applications, and so it would be wise to separate
    the pipelines into two separate groups, which in the context of Jenkins, is a
    folder.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们创建管道之前，我们知道我们的应用程序将包括两个部分——一个后端API服务器和一个前端Web界面。我们最终将使用Jenkins来构建这两个应用程序，因此将管道分成两个独立的组是明智的，在Jenkins的上下文中，这相当于一个文件夹。
- en: 'To create a new folder, click on the New Item link found on the left-hand side
    of the interface. You''ll then be presented with the following screen:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新文件夹，请点击界面左侧的“新建项目”链接。然后，您将看到以下屏幕：
- en: '![](img/0eb17864-b848-4298-9787-45d23d9f727a.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0eb17864-b848-4298-9787-45d23d9f727a.png)'
- en: Under the Name parameter, enter a name that identifies this folder and acts
    as a namespace for all projects grouped under this folder. This name will also
    be used in the URL path, as well as the directory name in the filesystem, therefore,
    you should pick a name that does not contain spaces or special characters (especially
    slashes).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在“名称”参数下，输入一个标识此文件夹并作为此文件夹下所有项目命名空间的名称。此名称也将用于URL路径以及文件系统中的目录名称，因此，你应该选择一个不包含空格或特殊字符（尤其是斜杠）的名称。
- en: You may optionally specify a Display Name and Description. Click Save and the
    folder will be created and can be accessed through the URL, [http://jenkins.hobnob.social/job/backend/](http://jenkins.hobnob.social/job/backend/).
    Next, we are going to create a new pipeline under this folder.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以可选地指定显示名称和描述。点击保存，文件夹将被创建，可以通过URL访问，[http://jenkins.hobnob.social/job/backend/](http://jenkins.hobnob.social/job/backend/)。接下来，我们将在该文件夹下创建一个新的管道。
- en: Creating a new pipeline
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新管道
- en: 'Navigate to `http://jenkins.hobnob.social/job/backend/` and click on the New
    Item link again, but this time select the Pipeline option:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 `http://jenkins.hobnob.social/job/backend/` 并再次点击“新建项目”链接，但这次选择“管道”选项：
- en: '![](img/21ebfb29-eac9-4615-b902-b7e1537d2aee.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21ebfb29-eac9-4615-b902-b7e1537d2aee.png)'
- en: 'In the General section, check the GitHub project checkbox and paste in the
    URL to your GitHub project:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在“常规”部分，勾选“GitHub项目”复选框并粘贴您GitHub项目的URL：
- en: '![](img/19b30e70-8b79-40d1-a0f9-b1566f6900ec.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19b30e70-8b79-40d1-a0f9-b1566f6900ec.png)'
- en: 'Then, in the Build Triggers section, check the option for GitHub hook trigger
    for GITScm polling. This means this pipeline will be executed every time our webhook
    endpoint (`http://jenkins.hobnob.social/github-webhook/`) receives a message from
    GitHub related to this GitHub project:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在“构建触发器”部分，勾选“GitHub钩子触发器”以进行GITScm轮询。这意味着每次我们的webhook端点（`http://jenkins.hobnob.social/github-webhook/`）收到与这个GitHub项目相关的GitHub消息时，这个管道将被执行：
- en: '![](img/440e7c87-f61c-4454-b69a-f03c52f9c483.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/440e7c87-f61c-4454-b69a-f03c52f9c483.png)'
- en: 'Next, under the Pipeline section, select Pipeline script from SCM and make
    sure Script Path is set to Jenkinsfile. This will tell Jenkins to use the Jenkins
    file from the repository. Then, click on Add repository and paste in the repository
    URL. Lastly, in Branches to build, enter the value `*/*` so that the pipeline
    will trigger based on changes on any branch:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在“管道”部分，选择“从源代码管理器中选择管道脚本”并确保“脚本路径”设置为Jenkinsfile。这将告诉Jenkins使用存储库中的Jenkins文件。然后，点击“添加仓库”并粘贴仓库URL。最后，在“构建分支”中输入值`*/*`，以便管道根据任何分支的更改触发：
- en: '![](img/5a8c6f08-6b59-4750-a2dd-4fd488d6a3a6.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a8c6f08-6b59-4750-a2dd-4fd488d6a3a6.png)'
- en: Save the pipeline, and move on to running our first build!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 保存管道，然后继续运行我们的第一个构建！
- en: Running the first build
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行第一个构建
- en: Now, run `git commit --amend` to change the commit hash; this will be sufficient
    to constitute a change. Push this change to the remote repository. Fingers crossed,
    this should trigger the build on our Jenkins server.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`git commit --amend`来更改提交哈希；这将足以构成一个更改。将此更改推送到远程仓库。 fingers crossed，这应该会在我们的Jenkins服务器上触发构建。
- en: First, it will download the repository and it into a workspace located at `/var/lib/jenkins/jobs`,
    then, it will run the instructions specified in our `Jenkinsfile`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它将下载仓库并将其放入位于`/var/lib/jenkins/jobs`的工作区中，然后，它将运行我们在`Jenkinsfile`中指定的指令。
- en: 'When a build (freestyle project or pipeline) is triggered, it will be added
    to the list of builds in the Build History sidebar on the left. The indicator
    to the left of the build shows the status of the build. Initially, it will be
    flashing blue, indicating it is running but not yet complete. Once the pipeline
    has completed execution, the indicator will change to a non-flashing blue or red,
    representing a successful or failed build:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建（自由风格项目或管道）被触发时，它将被添加到左侧构建历史侧边栏中的构建列表中。构建左侧的指示器显示构建的状态。最初，它将以闪烁的蓝色显示，表示正在运行但尚未完成。一旦管道完成执行，指示器将变为非闪烁的蓝色或红色，表示构建成功或失败：
- en: '![](img/b0510767-7849-4803-b9ce-e34c6fce0040.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0510767-7849-4803-b9ce-e34c6fce0040.png)'
- en: 'You can keep track of the progress of the pipeline by going to the Console
    Output tab and reading the `stdout` produced. However, if you prefer a visual
    representation, you can look at the **Stage View**, which displays a table with
    colored blocks, where green represents a passing stage, and red represents a failed
    stage. This is provided by the pipeline stage view plugin ([plugins.jenkins.io/pipeline-stage-view](https://plugins.jenkins.io/pipeline-stage-view)),
    which is installed by default:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问“控制台输出”标签并阅读产生的`stdout`来跟踪管道的进度。然而，如果您更喜欢视觉表示，您可以查看**阶段视图**，它显示一个带有彩色块的表格，其中绿色代表通过的阶段，红色代表失败的阶段。这是由管道阶段视图插件提供的，该插件默认安装：([plugins.jenkins.io/pipeline-stage-view](https://plugins.jenkins.io/pipeline-stage-view))：
- en: '![](img/04f1e1f2-72cf-43de-93b6-045657b25561.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04f1e1f2-72cf-43de-93b6-045657b25561.png)'
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have integrated our project with two CI services—Travis
    and Jenkins. With CI, we are able to trigger tests to run after certain events
    and automate the testing of our app. We have also used Docker to provide an isolated
    environment for our tests, ensuring our tests remain reliable and repeatable. In
    [Chapter 17](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml), *Migrating to Docker*,
    we will even migrate our entire deployment to using Docker.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经将我们的项目与两个CI服务——Travis和Jenkins集成。有了CI，我们能够在某些事件之后触发测试运行，并自动测试我们的应用程序。我们还使用了Docker为我们的测试提供一个隔离的环境，确保我们的测试保持可靠和可重复。在[第17章](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml)“迁移到Docker”中，我们甚至将整个部署迁移到使用Docker。
- en: In the next chapter, we will learn how to secure our application by implement
    authentication and authorization checks in our API.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过在我们的API中实现身份验证和授权检查来保护我们的应用程序。
