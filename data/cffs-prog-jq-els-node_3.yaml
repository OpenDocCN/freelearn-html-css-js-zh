- en: Chapter 3. CoffeeScript and jQuery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。CoffeeScript和jQuery
- en: '**jQuery** is a cross-browser compatible library designed to simplify the life
    of an HTML application developer. It was first released by John Resig in 2006
    and has since become the most popular JavaScript library in the world, and is
    used in millions of websites.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**jQuery**是一个跨浏览器兼容的库，旨在简化HTML应用程序开发人员的生活。它由John Resig于2006年首次发布，自那以后已成为世界上最流行的JavaScript库，并在数百万个网站中使用。'
- en: Why did it become so popular? Well, jQuery has a couple of nice features like
    easy DOM manipulation and querying, event handling, and animation, as well as
    AJAX support. All these combined together makes programming against the DOM and
    programming in JavaScript much better.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它变得如此受欢迎？嗯，jQuery有一些不错的功能，如简单的DOM操作和查询、事件处理和动画，以及AJAX支持。所有这些结合在一起使得针对DOM编程和JavaScript编程变得更好。
- en: The library has also been highly optimized in terms of cross-browser compatibility
    and speed and thus using jQuery's DOM traversal and manipulation functions not
    only save you from writing tedious code, but it's also usually much faster than
    the code that you could write yourself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 该库在跨浏览器兼容性和速度方面也经过了高度优化，因此使用jQuery的DOM遍历和操作函数不仅可以节省您编写繁琐代码的时间，而且通常比您自己编写的代码快得多。
- en: As it turns out, jQuery and CoffeeScript go very well together, and when combined,
    provides a powerful toolset to write web applications in a succinct and expressive
    manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，jQuery和CoffeeScript非常搭配，结合起来提供了一个强大的工具集，以简洁和表达力的方式编写Web应用程序。
- en: 'In this chapter, we''ll do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Explore some of the high level features of jQuery and talk about what it gives
    you
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索jQuery的一些高级功能，并讨论它给您带来了什么
- en: Learn how to use CoffeeScript and jQuery in the browser
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在浏览器中使用CoffeeScript和jQuery
- en: Build a simple to-do list app using jQuery and CoffeeScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery和CoffeeScript构建一个简单的待办事项列表应用程序
- en: Let's start by discussing the jQuery library in more detail, and discover what
    makes it so useful.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先更详细地讨论jQuery库，并发现它的有用之处。
- en: Finding and changing elements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找和更改元素
- en: In web browsers, the DOM, or Document Object Model, is the representation of
    the elements in an HTML document used to interact with programmatically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中，DOM或文档对象模型是用于与HTML文档中的元素进行编程交互的表示。
- en: In JavaScript, you'll find yourself doing a lot of DOM traversal to find elements
    that you're interested in and then manipulate them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，您会发现自己需要进行大量的DOM遍历，以查找您感兴趣的元素，然后对它们进行操作。
- en: To accomplish this using just the standard JavaScript libraries, you'll usually
    need to use a combination of the `document.getElementsByName`, `document.getElementById`,
    and `document.getElementsById` methods. As soon as your HTML structure starts
    getting complex, this usually means that you would have to combine these methods
    in an awkward and cumbersome iteration code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用标准的JavaScript库来实现这一点，通常需要使用`document.getElementsByName`、`document.getElementById`和`document.getElementsById`方法的组合。一旦您的HTML结构开始变得复杂，这通常意味着您将不得不在笨拙和繁琐的迭代代码中组合这些方法。
- en: Code written in this fashion usually makes a lot of assumptions about the structure
    of your HTML, which means that it will usually break if the HTML changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写的代码通常对HTML的结构做出了很多假设，这意味着如果HTML发生变化，它通常会中断。
- en: The $ function
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $函数
- en: With jQuery, a lot of this imperative style code becomes much simpler with the
    `$` function—jQuery's factory method (a method that creates instances of jQuery
    classes) and the entry point into most of the library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`$`函数（jQuery的工厂方法，用于创建jQuery类的实例）和大部分库的入口点，许多这种命令式风格的代码变得更简单。
- en: This function usually takes a CSS selector string as an argument, which can
    be used to select one or multiple elements according to their element name, ID,
    class attribute, or other attribute values. This method will return a jQuery object
    that contains one or more elements that matches the selector.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通常以CSS选择器字符串作为参数，该参数可用于根据元素名称、ID、类属性或其他属性值选择一个或多个元素。此方法将返回一个包含与选择器匹配的一个或多个元素的jQuery对象。
- en: 'Here, we''ll select all the `input` tags in a document with a class of `address`,
    using the `$` function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`$`函数选择文档中所有具有`address`类的`input`标签：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can then manipulate or interrogate these elements using a multitude of
    functions, often called **commands**. The following are just a few of the common
    jQuery commands and what they are used for:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用多种函数来操作或查询这些元素，通常称为**命令**。以下是一些常见的jQuery命令及其用途：
- en: '`addClass`: This adds a CSS class to an element'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addClass`：这将向元素添加一个CSS类'
- en: '`removeClass`: This removes a CSS class from an element'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeClass`：这从元素中删除一个CSS类'
- en: '`attr`: This gets a attribute from an element'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr`：这从元素中获取一个属性'
- en: '`hasClass`: This checks for the existence of a CSS class on an element'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasClass`：这检查元素上是否存在CSS类'
- en: '`html`: This gets or sets the HTML text of an element'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html`：这获取或设置元素的HTML文本'
- en: '`val`: This gets or sets the element value'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val`：这获取或设置元素的值'
- en: '`show`: This displays an element'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show`：这显示一个元素'
- en: '`hide`: This hides an element'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hide`：这隐藏一个元素'
- en: '`parent`: This gets the parent of an element'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`：这获取一个元素的父元素'
- en: '`appendTo`: This appends a child element'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendTo`：这附加一个子元素'
- en: '`fadeIn`: This fades in an element'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fadeIn`：这淡入一个元素'
- en: '`fadeout`: This fades out an element'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fadeout`：这淡出一个元素'
- en: Most of the commands return a jQuery object that can be used to chain other
    commands onto them. By chaining commands, you can use the output of one command
    as the input of the next. This powerful technique lets you write very short and
    succinct transformations on parts of the HTML document.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数命令返回一个jQuery对象，可以用来链接其他命令。通过链接命令，您可以使用一个命令的输出作为下一个命令的输入。这种强大的技术让您可以对HTML文档的部分进行非常简短和简洁的转换。
- en: 'Let''s say that we want to highlight and enable all the `address` inputs in
    an HTML form; jQuery allows us to do something similar to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要突出显示并启用HTML表单中的所有`address`输入；jQuery允许我们做类似于这样的事情：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we once again select all the `input` tags with an `address` class. We
    add the `highlighted` class to each using the `addClass` command, and then remove
    the `disabled` attribute by chaining a call to the `removeAttr` command.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次选择所有具有`address`类的`input`标签。我们使用`addClass`命令为每个标签添加`highlighted`类，并通过链接到`removeAttr`命令来移除`disabled`属性。
- en: Utility functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用函数
- en: 'jQuery also comes with a host of utility functions that generally improves
    your day-to-day JavaScript programming experience. These are all in the form of
    methods on the global jQuery object like this: `$.methodName`. For instance, one
    of the most widely used utilities is the `each` method, that can be used to iterate
    over arrays or objects, and would be called as follows (in CoffeeScript):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery还提供了许多实用函数，通常可以改善您日常的JavaScript编程体验。这些都是作为全局jQuery对象的方法的形式，如`$.methodName`。例如，其中一个最常用的实用程序是`each`方法，可用于迭代数组或对象，并且可以按如下方式调用（在CoffeeScript中）：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: jQuery's utility methods range from array and collection helper methods, time
    and string manipulation, as well as a host of other useful JavaScript and browser
    related functions. A lot of these functions stem from the everyday needs of a
    lot of JavaScript programmers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的实用方法涵盖了数组和集合的辅助方法，时间和字符串操作，以及许多其他有用的JavaScript和与浏览器相关的函数。许多这些函数源自许多JavaScript程序员的日常需求。
- en: Often, you'll find a function that applies to a common problem or pattern you
    face yourself when writing JavaScript or CoffeeScript. You can find a detailed
    list of the functions at [http://api.jquery.com/category/utilities/](http://api.jquery.com/category/utilities/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会发现一个适用于您自己在编写JavaScript或CoffeeScript时遇到的常见问题或模式的函数。您可以在[http://api.jquery.com/category/utilities/](http://api.jquery.com/category/utilities/)找到这些函数的详细列表。
- en: Ajax methods
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax方法
- en: jQuery provides the `$.ajax` method to perform Ajax requests that work across
    browsers. Traditionally, this has been a pain to do, since browsers all implemented
    different interfaces for handling Ajax. jQuery takes care of all of that and provides
    a simpler, callback-based way of constructing and executing Ajax requests. This
    means that you can declaratively specify how the Ajax call should be made and
    then provide functions that jQuery will call back when the request succeeds or
    fails.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了`$.ajax`方法来执行跨浏览器的Ajax请求。传统上，这一直是一个痛点，因为各种浏览器都实现了不同的接口来处理Ajax。jQuery处理了所有这些，并提供了一种更简单的基于回调的方式来构建和执行Ajax请求。这意味着您可以声明性地指定应该如何进行Ajax调用，然后提供函数，jQuery将在请求成功或失败时回调。
- en: Using jQuery
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery
- en: Using jQuery in the browser is very simple; you just need to include the jQuery
    library in your HTML file. You can either download the latest version of jQuery
    from their site ([http://docs.jquery.com/Downloading_jQuery](http://docs.jquery.com/Downloading_jQuery))
    and reference that, or you can directly link to a **Content Delivery Network**
    (**CDN**) version of the library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中使用jQuery非常简单；您只需要在HTML文件中包含jQuery库。您可以从他们的网站下载最新版本的jQuery（[http://docs.jquery.com/Downloading_jQuery](http://docs.jquery.com/Downloading_jQuery)）并引用，或者您可以直接链接到**内容传送网络**（**CDN**）版本的库。
- en: Following is an example of how you might do it. This snippet comes from the
    excellent HTML5 Boilerplate project ([http://html5boilerplate.com/](http://html5boilerplate.com/)).
    Here we include the latest minified jQuery from a Google CDN, but we will also
    include a local version if including from the CDN fails.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例。这段代码来自优秀的HTML5 Boilerplate项目（[http://html5boilerplate.com/](http://html5boilerplate.com/)）。在这里，我们包含了来自Google
    CDN的最新压缩版jQuery，但如果从CDN引用失败，我们也将包含本地版本。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using CoffeeScript and jQuery in the browser
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中使用CoffeeScript和jQuery
- en: Before we can start playing with jQuery and CoffeeScript, let's talk about how
    you go about writing CoffeeScript code that runs in the browser.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用jQuery和CoffeeScript之前，让我们谈谈如何编写在浏览器中运行的CoffeeScript代码。
- en: Compiling CoffeeScript
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译CoffeeScript
- en: The most common way of compiling CoffeeScript for a web application is to run
    the `coffee` command to watch one or more CoffeeScript files for changes and then
    to compile them to JavaScript. The output will then be included in your web application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为Web应用程序编译CoffeeScript的最常见方法是运行`coffee`命令，以监视一个或多个CoffeeScript文件的更改，然后将它们编译为JavaScript。然后将输出包含在您的Web应用程序中。
- en: 'As an example, we''ll organize our project folder structure to look something
    like the following folder structure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将组织我们的项目文件夹结构，看起来像以下文件夹结构：
- en: '![Compiling CoffeeScript](img/9588_03_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![编译CoffeeScript](img/9588_03_01.jpg)'
- en: ''''
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ''''
- en: The **src** folder is where your CoffeeScript files would go. We could then
    start a CoffeeScript compiler to watch that folder and compile the JavaScript
    to our **public/js** folder.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**src**文件夹是您的CoffeeScript文件所在的位置。然后，我们可以启动一个CoffeeScript编译器来监视该文件夹，并将JavaScript编译到我们的**public/js**文件夹中。'
- en: 'This is what the CoffeeScript command would look like:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CoffeeScript命令的样子：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Keep this command running in the background in its own terminal window and it
    will recompile your CoffeeScript files when you save them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己的终端窗口中保持此命令运行，并在保存文件时重新编译您的CoffeeScript文件。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**CoffeeScript tags**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript标签
- en: Another way of running CoffeeScript in the browser is to include CoffeeScript
    inline in the document enclosed in the `<script type="text/coffeescript">` tag
    and then to include the minified CoffeeScript compiler script (`coffee-script.js`)
    in your document. This will compile, and then run all the inline CoffeeScript
    in the page.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行CoffeeScript的另一种方法是在文档中包含内联的CoffeeScript，包含在`<script type="text/coffeescript">`标签中，然后在文档中包含压缩的CoffeeScript编译器脚本（`coffee-script.js`）。这将编译并运行页面中的所有内联CoffeeScript。
- en: This isn't meant for serious use, since you will pay a serious performance penalty
    for the compiling step each time the page is loaded. However, it can be quite
    useful from time to time to just quickly play around with some CoffeeScript in
    the browser without setting up a complete compiler chain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是为了严肃使用，因为每次加载页面时都会为编译步骤付出严重的性能代价。然而，有时候在浏览器中快速玩一下CoffeeScript可能会非常有用，而不需要设置完整的编译器链。
- en: jQuery and CoffeeScript
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery和CoffeeScript
- en: 'Let''s put something in our CoffeeScript file to see if we can successfully
    hook it up with jQuery. In the `src` folder, create a file named `app.coffee`
    and include the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的CoffeeScript文件中放一些东西，看看我们是否可以成功地将其与jQuery连接起来。在`src`文件夹中，创建一个名为`app.coffee`的文件，并包含以下代码：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This sets up the jQuery's `$(document).ready()` function that will be called
    when the application is initialized. Here we are using the shorthand syntax for
    it, by just passing an anonymous function to the `$` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了jQuery的`$(document).ready()`函数，该函数在应用程序初始化时将被调用。在这里，我们使用了它的简写语法，只需将一个匿名函数传递给`$`函数。
- en: 'You should now have an `app.js` file in the `public/js` folder with content
    similar to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在`public/js`文件夹中有一个`app.js`文件，内容类似于这样：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, we need to include this file as well as the jQuery in our application''s
    HTML file. In the `public/index.html` file, add the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们应用程序的HTML文件中包含这个文件以及jQuery。在`public/index.html`文件中，添加以下代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code creates our HTML skeleton, and includes jQuery (using the
    Google CDN) as well as our application code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码创建了我们的HTML骨架，并包含了jQuery（使用Google CDN）以及我们的应用程序代码。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/](http://www.PacktPub.com/)
    support and register to have the files e-mailed directly to you.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.PacktPub.com](http://www.PacktPub.com)购买的所有Packt图书的帐户中下载示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.PacktPub.com/](http://www.PacktPub.com/)支持并注册，以便直接通过电子邮件接收文件。
- en: Testing it all
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试全部
- en: 'We should now be able to run our application by opening our `index.html` file
    in a browser. If all went well, we should see our alert pop-up window, as shown
    in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够通过在浏览器中打开我们的`index.html`文件来运行我们的应用程序。如果一切顺利，我们应该看到我们的警报弹出窗口，如下面的截图所示：
- en: '![Testing it all](img/9588_03_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![测试全部](img/9588_03_02.jpg)'
- en: Running a local web server
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行本地Web服务器
- en: While we can easily test our web application from the disk for now, we might
    want to host it on a local web server soon, especially if we wanted to start doing
    Ajax. Since we already have Node.js installed, it should be really easy to run
    a web server, for which we only need to serve static content for now. Luckily,
    there is an npm package that will do just that for us; it is named **http-server**
    and can be found at [https://github.com/nodeapps/http-server](https://github.com/nodeapps/http-server).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在可以从磁盘轻松测试我们的Web应用程序，但是很快我们可能想要将其托管在本地Web服务器上，特别是如果我们想要开始进行Ajax。由于我们已经安装了Node.js，所以运行Web服务器应该非常容易，我们现在只需要为静态内容提供服务。幸运的是，有一个npm包可以为我们做到这一点；它名为**http-server**，可以在[https://github.com/nodeapps/http-server](https://github.com/nodeapps/http-server)找到。
- en: 'To install it, just run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，只需运行以下命令：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And then, we execute it by navigating to our application folder and entering
    this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过导航到我们的应用程序文件夹并输入以下内容来执行它：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will host all the files in the public folder on port **8080**. We should
    now be able to navigate to our hosted site by using the URL `http://localhost:8080/`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口**8080**上托管public文件夹中的所有文件。现在，我们应该能够通过使用URL `http://localhost:8080/`来访问我们托管的站点。
- en: Our application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的应用程序
- en: In the rest of this chapter, we will be building a jQuery application using
    CoffeeScript. The application is a to-do list app, which can be used to keep track
    of your daily tasks and how you completed them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将使用CoffeeScript构建一个jQuery应用程序。该应用程序是一个待办事项列表应用程序，可用于跟踪您的日常任务以及您如何完成它们。
- en: TodoMVC
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TodoMVC
- en: I have modeled a lot of the application on some of the TodoMVC project's source
    code, which is in the public domain. This project is a showcase of different JavaScript
    MVC frameworks all used to build the same application, and can be very useful
    when evaluating frameworks. If you wanted to check it out, it can be found at
    [http://addyosmani.github.com/todomvc/](http://addyosmani.github.com/todomvc/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经模仿了TodoMVC项目的一些源代码来建模应用程序，该项目属于公共领域。该项目展示了不同的JavaScript MVC框架，所有这些框架都用于构建相同的应用程序，在评估框架时可能非常有用。如果你想要查看它，可以在[http://addyosmani.github.com/todomvc/](http://addyosmani.github.com/todomvc/)找到。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**MVC** , or Model–view–controller, is a widely used application architecture
    pattern that aims to simplify code and reduce coupling by splitting application
    concerns into three domain object types. We''ll talk about MVC a bit more later
    on in the book.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC**，或者模型-视图-控制器，是一种广泛使用的应用程序架构模式，旨在通过将应用程序关注点分为三种领域对象类型来简化代码并减少耦合。我们将在本书的后面更详细地讨论MVC。'
- en: We will mostly base our application on the TodoMVC project to get the awesome-looking
    stylesheets that come with it as well as a well-designed HTML5 structure. However,
    most of the client-side JavaScript will be rewritten in CoffeeScript and it will
    be simplified and modified quite a lot for illustration purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要基于TodoMVC项目来构建我们的应用程序，以获得与之配套的令人赞叹的样式表以及精心设计的HTML5结构。然而，大部分客户端JavaScript将被重写为CoffeeScript，并且为了说明的目的将被简化和修改很多。
- en: So without further ado, let's get to it!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，话不多说，让我们开始吧！
- en: Our initial HTML
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的初始HTML
- en: 'First, we''ll add some HTML that will allow us to enter to-do items and view
    a list of existing items. In `index.html`, add the following code to the `body`
    tag, right before the included `script` tags:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一些HTML，以便我们可以输入待办事项并查看现有项目的列表。在`index.html`中，在包含的`script`标签之前，将以下代码添加到`body`标签中：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's briefly walk through the structure of the preceding markup. First, we
    have a section with the `todoapp` ID, that will serve as the main part of the
    app. It consists of a `header` tag, which will house our input for creating new
    items, a `main` section, which will list all our to-do items, and a `footer` section
    that will have the **Clear completed** button. Before we open this page in the
    browser, let's remove the previous alert line from our `app.coffee` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地浏览一下前面标记的结构。首先，我们有一个带有`todoapp`ID的部分，它将作为应用程序的主要部分。它包括一个`header`标签，用于创建新项目的输入，一个`main`部分，用于列出所有待办事项，以及一个`footer`部分，其中有**清除已完成**按钮。在我们在浏览器中打开这个页面之前，让我们从我们的`app.coffee`文件中删除之前的警报行。
- en: When you navigate to this page, it won't look like much. That is because our
    HTML hasn't been styled at all. Download the `styles.css` file for this chapter
    and copy it to the `public/css` folder. It should now look much better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导航到这个页面时，它看起来不怎么样。这是因为我们的HTML还没有被样式化。下载本章的`styles.css`文件，并将其复制到`public/css`文件夹中。现在它应该看起来好多了。
- en: Initializing our app
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化我们的应用程序
- en: Most jQuery apps, including ours, follow a similar pattern. We create a `$(document).ready`
    handler which in turn performs page initialization, usually including hooking
    up event handlers for user actions. Let's do this in our `app.coffee` file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数jQuery应用程序，包括我们的应用程序，都遵循类似的模式。我们创建一个`$(document).ready`处理程序，然后执行页面初始化，通常包括为用户操作挂接事件处理程序。让我们在我们的`app.coffee`文件中这样做。
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, in the previous code snippet, we create a class called `TodoApp` that
    will represent our application. It has a constructor that calls the `bindEvents`
    method, which for now just displays an alert message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个名为`TodoApp`的类，它将代表我们的应用程序。它有一个构造函数，调用`bindEvents`方法，目前只显示一个警报消息。
- en: We set up jQuery's `$(document).ready` event handler to create an instance of
    our `TodoApp`. When you reload the page, you should see the **binding events**
    alert pop-up window.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了jQuery的`$(document).ready`事件处理程序来创建我们的`TodoApp`的一个实例。当你重新加载页面时，你应该会看到**绑定事件**的警报弹出窗口。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Not seeing the expected output?**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有看到预期的输出？**'
- en: Remember to keep an eye on the output of the coffee compiler running in the
    background. If you have made any syntax errors, then the compiler will spit out
    an error message. Once you have fixed it, the compiler should recompile your new
    JavaScript file. Remember that CoffeeScript is whitespace sensitive. If you come
    across any errors that you don't understand, check your indentation carefully.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记得要留意后台运行的咖啡编译器的输出。如果有任何语法错误，编译器会输出错误消息。一旦你修复了它，编译器应该会重新编译你的新JavaScript文件。记住，CoffeeScript对空白很敏感。如果遇到任何你不理解的错误，请仔细检查缩进。
- en: Adding a to-do item
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加待办事项
- en: 'Now we can add the event handling to actually add a to-do item to the list.
    In our `bindEvents` function, we''ll select the `new-todo` input and handle its
    `keyup` event. We bind that to call the `create` method on our class, which we''ll
    also go and define; this is shown in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加事件处理来实际将待办事项添加到列表中。在我们的`bindEvents`函数中，我们将选择`new-todo`输入并处理它的`keyup`事件。我们将绑定它来调用我们类的`create`方法，我们也将去定义它；这在下面的代码片段中显示：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `$('#new-todo')` function uses the jQuery CSS selector syntax to get the
    input with the `new-todo` ID, the `on` method binds the `create` method to its
    `'keyup'` event, which fires whenever a key is pressed while the input has focus.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(''#new-todo'')`函数使用jQuery的CSS选择器语法来获取具有`new-todo`ID的输入，`on`方法将`create`方法绑定到它的`''keyup''`事件，每当输入有焦点时按下键时触发。'
- en: In the `create` function, we can get a reference to the input by using the `$(this)`
    function, which will always return the element that generated the event. We assign
    this to the `$input` variable. Using variable names that are prefixed with `$`
    is a common convention when assigning jQuery variables. We can then get the value
    of the input using the `val()` function and assign it a local `val` variable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create`函数中，我们可以通过使用`$(this)`函数来获取输入的引用，它将始终返回生成事件的元素。我们将这个赋给`$input`变量。在分配jQuery变量时，使用以`$`为前缀的变量名是一种常见的约定。然后我们可以使用`val()`函数获取输入的值，并将其赋给一个本地的`val`变量。
- en: We can see if the *Enter* key was pressed by checking if the `which` property
    of the `keyup` event is equal to `13`. If so, and if the `val` variable is not
    `null`, we can go ahead and create the to-do item. For now, we'll just output
    its value using an alert message.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查`keyup`事件的`which`属性是否等于`13`来判断*Enter*键是否被按下。如果是，并且`val`变量不是`null`，我们可以继续创建待办事项。现在，我们只会使用警报消息输出它的值。
- en: Once we create the item, where shall we put it? In lots of traditional web apps,
    this data will typically be stored on the server using an Ajax request. We would
    like to keep this app simple for now and just keep these items around on the client
    side for now. The HTML5 specification defines a mechanism for us called **localStorage**,
    to do just that.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了项目，我们应该把它放在哪里？在许多传统的Web应用程序中，这些数据通常会使用Ajax请求存储在服务器上。我们希望现在保持这个应用程序简单，暂时只在客户端保留这些项目。HTML5规范为我们定义了一个叫做**localStorage**的机制，可以做到这一点。
- en: Using localStorage
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用localStorage
- en: '`localStorage` is part of the new HTML5 specification and allows you to store
    and retrieve objects in a local database that lives in the browser. The interface
    is quite simple; in supported browsers a global variable named `localStorage`
    will be present. This variable has the following three important methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`是新的HTML5规范的一部分，允许你在浏览器中存储和检索对象的本地数据库。接口非常简单；在支持的浏览器中，会存在一个名为`localStorage`的全局变量。这个变量有以下三个重要的方法：'
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both the `key` and `value` parameters are strings. Strings stored in the `localStorage`
    variable hang around even when the page is refreshed. You can store up to 5 MB
    in the `localStorage` variable in most browsers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`和`value`参数都是字符串。存储在`localStorage`变量中的字符串即使在页面刷新时也会保留。在大多数浏览器中，你可以在`localStorage`变量中存储多达5MB的数据。'
- en: 'Because we want to store the to-do items as a complex object rather than a
    string, we use the commonly used technique of converting to and from a JSON object
    when setting and getting items from `localStorage`. To do so, we''ll add two methods
    to the prototype of the `Storage` class, which will then be available on the global
    `localStorage` object. Add the following code snippet to the top of our `app.coffee`
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想将待办事项存储为一个复杂的对象而不是一个字符串，所以在设置和从`localStorage`获取项目时，我们使用了常用的将对象转换为JSON对象的技术。为此，我们将在`Storage`类的原型中添加两个方法，然后这些方法将在全局`localStorage`对象上可用。在我们的`app.coffee`文件的顶部添加以下代码片段：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we use the `::` operator to add the `setObj` and `getObj` methods to the
    `Storage` class. These functions wrap the `localStorage` object's `getItem` and
    `setItem` methods by converting the object to and from JSON.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`::`运算符将`setObj`和`getObj`方法添加到`Storage`类中。这些函数通过将对象转换为JSON来包装`localStorage`对象的`getItem`和`setItem`方法。
- en: We are now finally ready to create our to-do item and store it in `localStorage`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好创建我们的待办事项并将其存储在`localStorage`中。
- en: 'Here is the rest of our `create` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们`create`方法的其余部分：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In order for us to uniquely identify tasks, we'll use the simplest thing we
    can, and just generate a big random number to use as an ID. This is not the most
    sophisticated way of identifying documents and you should probably not use this
    in a production setting. However, it's quite simple to implement, and serves our
    purposes well for now.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了唯一标识任务，我们将使用最简单的方法，只生成一个大的随机数作为ID。这不是最复杂的标识文档的方法，您可能不应该在生产环境中使用这种方法。但是，它很容易实现，并且暂时很好地满足了我们的目的。
- en: After generating the ID, we can now put the to-do item in our local database
    using our `setObj` method. We pass in a title that we got from the `input` tag
    value, and default the item to not completed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 生成ID后，我们现在可以使用我们的`setObj`方法将待办事项放入我们的本地数据库。我们传入了一个从`input`标签值中获取的标题，并将项目默认为未完成。
- en: Lastly, we clear the value of `$input` to give the user visual input that `create`
    was successful.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们清除了`$input`的值，以便用户可以直观地看到`create`是成功的。
- en: 'We should now be able to test our little app and see if the to-do items do
    get stored into `localStorage`. The Google Chrome Developer Tools will allow you
    to inspect `localStorage` in the **Resources** tab. After adding a couple of tasks,
    you should be able to see them here, as shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够测试我们的小应用程序，并查看待办事项是否被存储到`localStorage`中。谷歌Chrome开发者工具将允许您在**资源**选项卡中检查`localStorage`。添加几个任务后，您应该能够在这里看到它们，如下面的截图所示：
- en: '![Using localStorage](img/9588_03_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![使用localStorage](img/9588_03_03.jpg)'
- en: Displaying the to-do items
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示待办事项
- en: Now that we can store a list of to-do items, it would be nice if we could see
    them on screen. To do so, we will add a `displayItems` method. This will iterate
    through the local list of to-do items and display them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以存储一个待办事项列表，如果我们能在屏幕上看到它们就更好了。为此，我们将添加一个`displayItems`方法。这将遍历待办事项的本地列表并显示它们。
- en: 'Add the following code to our `TodoApp`, after the `create` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`TodoApp`中添加以下代码，放在`create`方法之后：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we should be able to call this method from the `create` method, as highlighted
    in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够从`create`方法中调用这个方法，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s run this code to see what happens. When we do, we get the following
    error:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这段代码看看会发生什么。当我们这样做时，我们会得到以下错误：
- en: '**Uncaught TypeError: Object #<HTMLInputElement> has no method ''displayItems''**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**Uncaught TypeError: Object #<HTMLInputElement> has no method ''displayItems''**'
- en: So what's happening here? It seems that the call to `@displayItems()` is trying
    to call the method on an instance of `HTMLInputElement` instead of `TodoApp`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？似乎对`@displayItems()`的调用试图在`HTMLInputElement`的实例上调用该方法，而不是在`TodoApp`上调用。
- en: This happens because jQuery will set the value of `this` to reference the element
    that raised the event. When we bind a class method as an event handler, jQuery
    will in essence "highjack" `this` to not point to the class itself. It is an important
    caveat that you should know of when working with jQuery and classes in CoffeeScript.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为jQuery会将`this`的值设置为引发事件的元素。当我们将类方法绑定为事件处理程序时，jQuery实际上会“劫持”`this`，使其不指向类本身。这是在使用jQuery和CoffeeScript中应该知道的一个重要注意事项。
- en: 'To fix it, we can use the CoffeeScript fat arrow when we set up the `keyup`
    event handler, which will ensure that the value of `this` remains intact. Let''s
    modify our `bindEvents` method to look similar to the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复它，我们可以在设置`keyup`事件处理程序时使用CoffeeScript的fat箭头，这将确保`this`的值保持不变。让我们修改我们的`bindEvents`方法，使其看起来类似于以下代码：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is just one more thing though; in our `createItem` method, we used `$(this)`
    to get the value of the `input` element that raised the event. Since switching
    to the fat arrow, this will now be pointing to our `TodoApp` instance. Luckily,
    the event argument that gets passed in has a target property that also points
    to our input. Change the first line of the `create` method similar to the following
    code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一件事了；在我们的`createItem`方法中，我们使用`$(this)`来获取引发事件的`input`元素的值。由于切换到了fat箭头，现在这将指向我们的`TodoApp`实例。幸运的是，传递的事件参数有一个target属性，也指向我们的输入。将`create`方法的第一行更改为以下代码片段：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now when we create an item, we should see the "displaying items" alert, meaning
    the `displayItems` method has been hooked up correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建一个项目时，我们应该看到“显示项目”警报，这意味着`displayItems`方法已经正确连接。
- en: We can do one better. Since the `$input` tag will need to be looked up every
    time the `create` method is fired, we can just store it in a class variable so
    that it can be re-used.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做得更好。由于每次触发`create`方法时都需要查找`$input`标签，我们可以将其存储在一个类变量中，以便可以重复使用。
- en: 'The best place for this would be right when the app starts up. Let''s create
    a `cacheElements` method that does just that, and gets called in the constructor—this
    is highlighted in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最好放在应用程序启动时。让我们创建一个`cacheElements`方法来做到这一点，并在构造函数中调用它-这在下面的代码中有所突出：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `cacheElements` call assigns a class variable called `@$input` , which is
    then used throughout our class. This `@$` syntax might look strange at first,
    but it does convey a lot of information in a few keystrokes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheElements`调用分配了一个名为`@$input`的类变量，然后在我们的类中使用它。这种`@$`语法一开始可能看起来很奇怪，但它可以用几个按键传达很多信息。'
- en: Showing the to-do items
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示待办事项
- en: 'We should now be able to show the items. In the `displayItems` method, we''ll
    iterate through all the `localStorage` keys and use them to get each corresponding
    to-do item. For each item we''ll add a `li` child element to the `ul` element
    with the `todo-list` ID. Before we start working with the `$(''#todo-list'')`
    element, let''s cache its value like we did with `@$input`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够显示项目了。在`displayItems`方法中，我们将遍历所有`localStorage`键，并使用它们获取每个对应的待办事项。对于每个项目，我们将向`todo-list`
    ID的`ul`元素添加一个`li`子元素。在开始使用`$('#todo-list')`元素之前，让我们像我们对`@$input`所做的那样缓存它的值：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have modified the `displayItems` method a bit. First, we remove any
    existing child list items from `$@todoList`, then we loop through each key in
    `localStorage`, get the object with that key, and send that item to the `addItem`
    method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们稍微修改了`displayItems`方法。首先，我们从`$@todoList`中删除任何现有的子列表项，然后我们循环遍历`localStorage`中的每个键，获取具有该键的对象，并将该项目发送到`addItem`方法。
- en: The `addItem` method builds an HTML string representation of a to-do item and
    then uses jQuery's `append` function to append a child element to `$@todoList`
    . Together with a label for the title, we also create a checkbox to set the task
    as completed and a button to remove the task.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`addItem`方法构建了待办事项的HTML字符串表示，然后使用jQuery的`append`函数将子元素附加到`$@todoList`。除了标题的标签之外，我们还创建了一个复选框来设置任务为已完成，并创建了一个按钮来删除任务。'
- en: Notice the `data-id` attribute on the `li` element. This is an HTML5 data attribute,
    which lets you add arbitrary data attributes to any element. We will use this
    to link each `li` to its to-do item in the `localStorage` object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`li`元素上的`data-id`属性。这是HTML5数据属性，它允许您向任何元素添加任意数据属性。我们将使用它将每个`li`链接到`localStorage`对象中的待办事项。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although CoffeeScript can make building HTML strings like these a bit easier,
    it can quickly become cumbersome to define markup within your client-side code.
    We have done so here mostly for illustration purposes; it's probably better to
    use a JavaScript templating library, such as Handlebars ([http://handlebarsjs.com/](http://handlebarsjs.com/)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CoffeeScript可以使构建HTML字符串变得更容易一些，但在客户端代码中定义标记很快就会变得繁琐。我们在这里主要是为了说明目的而这样做；最好使用JavaScript模板库，比如Handlebars（[http://handlebarsjs.com/](http://handlebarsjs.com/)）。
- en: These types of libraries allow you define templates within your markup and then
    compile them with a specific context, which then gives you a nicely formatted
    HTML that you can then append to the elements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的库允许您在您的标记中定义模板，然后使用特定上下文编译它们，然后为您提供一个漂亮格式的HTML，然后您可以将其附加到元素上。
- en: 'One last thing, now that we can display items after one is created, let''s
    add the `displayItems` call to the constructor, so that we can display existing
    to-do items; this call is highlighted in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事，现在我们可以在创建项目后显示项目，让我们将`displayItems`调用添加到构造函数中，以便我们可以显示现有的待办事项；这个调用在下面的代码中突出显示：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Removing and completing items
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除和完成项目
- en: 'Let''s hook up the remove task button. We add an event handler for it follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接移除任务按钮。我们为它添加一个事件处理程序如下：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we handle click events on any child element on `@$todoList` with a `.destroy`
    class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处理`@$todoList`上任何子元素的点击事件，带有`.destroy`类。
- en: We once again create the handler with the fat arrow, calling a `@destroy` method
    and passing in the target, which should be the **destroy** button that was clicked.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用胖箭头创建处理程序，调用`@destroy`方法并传入目标，这应该是被点击的**destroy**按钮。
- en: 'We now need to create the `@destroy` method using the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使用以下代码片段创建`@destroy`方法：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `closest` function will find the `li` element that is defined nearest to
    the button itself. We use jQuery's `data` function to retrieve its `data-id` attribute,
    which we can then use to remove the to-do item from `localStorage`. One more call
    is made to `@displayItems` to refresh the view.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`closest`函数将找到距离按钮最近定义的`li`元素。我们使用jQuery的`data`函数检索其`data-id`属性，然后我们可以使用它从`localStorage`中删除待办事项。还要调用一次`@displayItems`来刷新视图。'
- en: 'Completing an item will follow a very similar pattern; that is, we add an event
    handler, which is highlighted in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 完成项目将遵循非常相似的模式；也就是说，我们添加一个事件处理程序，如下面的代码中所示：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This time we handle the `''change''` event, which will fire whenever a completed
    checkbox is checked or unchecked. This in turn will call the `@toggle` method,
    which is coded as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们处理了`'change'`事件，每当选中或取消选中已完成复选框时都会触发。这将调用`@toggle`方法，其代码如下：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method also uses the `closest` function to get the ID of the to-do item.
    It loads up the object from `localStorage`, toggles the value of `completed`,
    and then saves it back to `localStorage` using the `setObj` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法还使用`closest`函数来获取待办事项的ID。它从`localStorage`中加载对象，切换`completed`的值，然后使用`setObj`方法将其保存回`localStorage`。
- en: Now, it's your turn!
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在轮到你了！
- en: As a final exercise for you, I will ask you to make the **Clear completed**
    button work.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的练习，我要求您使**清除已完成**按钮起作用。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned what jQuery is, and what its strengths and benefits
    are. We also learned how to combine the powerful features of jQuery with CoffeeScript
    to write complex web applications with much less effort and complexity. jQuery
    is a very large library and we have just scratched the surface of what it has
    to offer. I urge you to spend some more time learning the library itself, and
    to do so using CoffeeScript.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了jQuery是什么，以及它的优势和好处是什么。我们还学习了如何将jQuery的强大功能与CoffeeScript结合起来，以更少的工作量和复杂性编写复杂的Web应用程序。jQuery是一个非常庞大的库，我们只是触及了它所提供的一小部分。我建议您花一些时间学习库本身，并使用CoffeeScript进行学习。
- en: Next up, we'll start by having a look at how you would start interacting with
    sever-side code using CoffeeScript and Rails.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将首先看一下如何使用CoffeeScript和Rails开始与服务器端代码进行交互。
