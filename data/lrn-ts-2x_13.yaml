- en: Application Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用性能
- en: In computer science, a system resource, or simply a resource, is any physical
    or virtual component of limited availability within a computer system. Every device
    connected to a computer system is a resource. Every internal system component
    is also a resource.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，系统资源，或简单地称为资源，是计算机系统内有限可用性的任何物理或虚拟组件。连接到计算机系统的每个设备都是资源。每个内部系统组件也是资源。
- en: In this chapter, we are going to learn how we can manage the available resources
    of a system efficiently to achieve great application performance. We will learn
    about the different kinds of resources, performance factors, and performance profiling
    techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何有效地管理系统的可用资源以实现卓越的应用性能。我们将了解不同种类的资源、性能因素和性能分析技术。
- en: The chapter starts by introducing some core performance concepts, such as latency
    or bandwidth, and continues showcasing how to measure and monitor performance
    as part of the continuous integration process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍了一些核心性能概念，例如延迟或带宽，然后继续展示如何作为持续集成过程的一部分来衡量和监控性能。
- en: 'As we have already learned in previous chapters, we can use TypeScript to generate
    JavaScript code that can be executed in many different environments. In this chapter,
    we are going to learn about performance profiling and optimization techniques,
    which are mainly applicable to the development of web applications. We are going
    to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中学到的，我们可以使用TypeScript生成可以在许多不同环境中执行JavaScript代码。在本章中，我们将学习关于性能分析和优化技术，这些技术主要适用于Web应用程序的开发。我们将涵盖以下主题：
- en: Performance and resources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和资源
- en: Aspects of performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能方面
- en: Memory profiling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分析
- en: Network profiling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络分析
- en: CPU and GPU profiling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU和GPU分析
- en: Performance testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance recommendations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能建议
- en: Performance automation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能自动化
- en: Prerequisites
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: We are about to learn how to perform some performance analysis tasks; however,
    before that, we need to install a few tools in our development environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将学习如何执行一些性能分析任务；然而，在此之前，我们需要在我们的开发环境中安装一些工具。
- en: Google Chrome
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Chrome
- en: Before we get started, we need to install Google Chrome. We can download it
    at [https://www.google.com/chrome/browser/desktop/index.html](https://www.google.com/chrome/browser/desktop/index.html).
    We are going to learn how to use the Google Chrome developer tools to perform
    some performance analysis tasks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要安装Google Chrome。我们可以在[https://www.google.com/chrome/browser/desktop/index.html](https://www.google.com/chrome/browser/desktop/index.html)下载它。我们将学习如何使用Google
    Chrome开发者工具来执行一些性能分析任务。
- en: Node.js
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js
- en: 'If you didn''t install Node.js in the previous chapters, you can visit [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    to download the installer for your operating system. There are two main versions
    of Node.js available: **Long Term Support** (**LTS**) and **Current**. We recommend
    using the LTS version.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在前面的章节中没有安装Node.js，你可以访问[https://nodejs.org/en/download/](https://nodejs.org/en/download/)下载适用于你操作系统的安装程序。Node.js有两种主要版本可供选择：**长期支持**（**LTS**）和**当前**。我们建议使用LTS版本。
- en: Performance and resources
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和资源
- en: Before we get our hands dirty doing some performance analysis, we must first
    spend some time understanding some core concepts and aspects of performance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行性能分析之前，我们必须首先花些时间了解一些核心概念和性能的方面。
- en: 'A good application is one that has a set of desirable characteristics, which
    includes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的应用程序具有一系列期望的特性，包括：
- en: Functionality
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性
- en: Reliability
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性
- en: Usability
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Reusability
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用性
- en: Efficiency
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率
- en: Maintainability
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性
- en: Portability
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植性
- en: Over the course of this book so far, we have learned a lot about maintainability
    and reusability. In this chapter, we will focus on performance, which is closely
    related to reliability and maintainability.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书到目前为止的篇幅中，我们已经学到了很多关于可维护性和可重用性的知识。在本章中，我们将重点关注性能，它与可靠性和可维护性密切相关。
- en: The term performance refers to the amount of useful work accomplished compared
    with the time and resources used. A resource is a physical (such as CPU, RAM,
    GPU HDD, and so on) or virtual (such as CPU times, RAM regions, files, and so
    on) component with limited availability. Because the availability of a resource
    is limited, each resource is shared between processes. When a process finishes
    using a resource, it must release it before any other process can use it. Managing
    available resources in an efficient manner will help reduce the time other processes
    spend waiting for the resources to become available.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是指与所使用的时间和资源相比完成的有用工作的量。资源是一个具有有限可用性的物理（如CPU、RAM、GPU、HDD等）或虚拟（如CPU时间、RAM区域、文件等）组件。由于资源的可用性有限，每个资源在进程之间共享。当一个进程完成使用资源后，它必须在其他任何进程可以使用它之前释放它。以有效的方式管理可用资源将有助于减少其他进程等待资源变得可用的时间。
- en: 'When we work on a web application, we need to keep in mind that the following
    resources will have limited availability:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发Web应用时，我们需要记住以下资源将具有有限的可用性：
- en: '**Central Processing Unit** (**CPU**): This carries out the instructions of
    a computer program by performing the basic arithmetic, logical, control, and input/output
    (I/O) operations specified by the instructions.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中央处理器**（**CPU**）：通过执行由指令指定的基本算术、逻辑、控制和输入/输出（I/O）操作来执行计算机程序的指令。'
- en: '**Graphics Processor Unit** (**GPU**): This is a specialized processor used
    in the manipulation and alteration of memory to accelerate the creation of images
    in a frame buffer. A frame buffer is an area of the RAM used to hold the frame
    of data that is continuously being sent to the screen. The GPU is used when we
    create applications that use the WebGL API or when we use CSS animations.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形处理器单元**（**GPU**）：这是一种用于在帧缓冲区中创建图像时加速内存操作和修改的专用处理器。帧缓冲区是RAM中用于存储不断发送到屏幕的数据帧的区域。当创建使用WebGL
    API的应用程序或使用CSS动画时，我们会使用GPU。'
- en: '**Random Access Memory** (**RAM**): This allows data items to be read and written
    in approximately the same amount of time, regardless of the order in which data
    items are accessed. When we declare a variable, it will be stored in RAM; when
    the variable is out of the scope, it will be removed from RAM by the garbage collector.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机存取存储器**（**RAM**）：这允许以大约相同的时间读取和写入数据项，无论访问数据项的顺序如何。当我们声明一个变量时，它将被存储在RAM中；当变量超出作用域时，它将通过垃圾收集器从RAM中删除。'
- en: '**Hard Disk Drive** (**HDD**) and **Solid-State Drive** (**SSD**): Both of
    these resources are data storage devices used to store and retrieve data. Frontend
    web applications don''t usually use persistent data storage extensively. However,
    we should keep in mind that whenever we store an object in a persistent manner
    (such as cookies, local storage, IndexedDB and so on), the performance of our
    application will be affected by the availability of the HDD or SSD.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬盘驱动器**（**HDD**）和**固态驱动器**（**SSD**）：这两种资源都是用于存储和检索数据的存储设备。前端Web应用通常不会大量使用持久数据存储。然而，我们应该记住，无论何时以持久方式存储对象（如cookies、本地存储、IndexedDB等），我们的应用程序的性能都会受到硬盘或固态硬盘可用性的影响。'
- en: '**Network throughput**: This determines how much actual data can be sent per
    unit of time across a network. The network throughput is determined by factors
    such as the network latency or bandwidth (we will discover more about these factors
    later in this chapter).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络吞吐量**：这决定了在单位时间内通过网络可以发送多少实际数据。网络吞吐量由网络延迟或带宽等因素决定（我们将在本章后面发现更多关于这些因素的信息）。'
- en: Common performance metrics
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见性能指标
- en: Performance can be affected by the availability of multiple types of physical
    and virtual devices. This explains the existence of multiple performance metrics
    (factors to measure performance). Some popular performance metrics include availability,
    response time, processing speed, latency, bandwidth, and scalability. These measurement
    mechanisms are usually directly related to one of the general resources (such
    as CPU, network throughput and so on) that were listed in the preceding section.
    We will now look at each of these performance metrics in detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 性能可能会受到多种物理和虚拟设备的可用性的影响。这解释了为什么存在多个性能指标（用于衡量性能的因素）。一些流行的性能指标包括可用性、响应时间、处理速度、延迟、带宽和可伸缩性。这些测量机制通常与前面列出的某个通用资源（如CPU、网络吞吐量等）直接相关。现在我们将详细查看每个这些性能指标。
- en: Availability
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性
- en: If a system is not available at some stage, even if it is only partially unavailable,
    we will perceive it as bad performance. The availability of a system can be improved
    by improving its reliability, maintainability, and testability. If the system
    is easy to test and maintain, it will also be easy to increase its reliability.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统在某些阶段不可用，即使只是部分不可用，我们也会认为其性能不佳。通过提高系统的可靠性、可维护性和可测试性，可以提高系统的可用性。如果系统易于测试和维护，那么提高其可靠性也将变得容易。
- en: Response time
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应时间
- en: 'The response time is the amount of time that it takes to respond to a request
    for a service. A service here does not refer to a web service; a service can be
    any unit of work. The response time is influenced by the network throughput can
    be divided into three parts:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 响应时间是指响应服务请求所需的时间。这里的“服务”并不指代网络服务；服务可以是任何工作单元。响应时间受网络吞吐量的影响，可以分为三个部分：
- en: '**Wait time**: The amount of time that the requests will spend waiting for
    other requests that took place earlier to be completed.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待时间**：请求将花费的时间等待之前发生并完成的其他请求。'
- en: '**Service time**: The amount of time that it takes for the service (unit of
    work) to be completed.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务时间**：服务（工作单元）完成所需的时间。'
- en: '**Transmission time**: Once the unit of work has been completed, the response
    will be sent back to the requester. The time that it takes for the response to
    be transmitted is known as the transmission time.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输时间**：一旦工作单元完成，响应将被发送回请求者。响应传输所需的时间称为传输时间。'
- en: Processing speed
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理速度
- en: Processing speed (also known as clock rate) refers to the frequency at which
    a processing unit (CPU or GPU) runs. An application contains many units of work.
    Each unit of work is composed of instructions for the processor; usually, the
    processors can perform an instruction in each clock tick. Since a few clock ticks
    are required for an operation to be completed, the higher the clock rate (processing
    speed), the more instructions that will be completed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 处理速度（也称为时钟频率）是指处理单元（CPU或GPU）运行的频率。一个应用程序包含许多工作单元。每个工作单元由处理器的指令组成；通常，处理器可以在每个时钟周期内执行一条指令。由于操作完成需要几个时钟周期，因此时钟频率（处理速度）越高，完成的指令就越多。
- en: Bandwidth
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带宽
- en: Whenever we mention bandwidth in this chapter, we will be referring to the network
    bandwidth. The bandwidth, or data transfer rate, is the amount of data that can
    be carried from one point to another in a given time. The network bandwidth is
    usually expressed in bits per second.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中提到带宽时，我们将指的是网络带宽。带宽，或数据传输率，是指在给定时间内可以从一个点传输到另一个点的数据量。网络带宽通常以每秒比特数来表示。
- en: Latency
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟
- en: Latency is a term we can apply to many elements in a system; however, when working
    on web applications, we will use this term to refer to network latency. Network
    latency indicates any delay that occurs in data communication over the network.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是一个可以应用于系统许多元素的术语；然而，当我们在处理Web应用程序时，我们将使用这个术语来指代网络延迟。网络延迟表示在网络数据通信中发生的任何延迟。
- en: High latency creates bottlenecks in the communication bandwidth. The impact
    of latency on network bandwidth can be temporary or persistent, based on the cause
    of the delays. High latency can be caused by problems in the medium (cables or
    wireless signals), problems with routers and gateways, and anti-virus, among others.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 高延迟会在通信带宽中造成瓶颈。延迟对网络带宽的影响可能是暂时的或持续的，这取决于延迟的原因。高延迟可能由介质（电缆或无线信号）的问题、路由器和网关的问题以及防病毒软件等问题引起。
- en: Network performance can be affected by many factors. Some of these factors can
    degrade the network throughput. For example, a high packet loss, latency, and
    jitter will reduce the network throughput, while a high bandwidth will increase
    it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 网络性能可能受到许多因素的影响。其中一些因素可能会降低网络吞吐量。例如，高数据包丢失、延迟和抖动会降低网络吞吐量，而高带宽则会提高它。
- en: Scalability
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Scalability is the ability of a system to handle a growing amount of work. A
    system with good scalability will be able to pass some performance tests, such
    as spike or stress testing. We will learn more about performance tests (such as
    spike and stress) later in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性是指系统处理不断增长的工作量的能力。具有良好可扩展性的系统将能够通过一些性能测试，例如峰值或压力测试。我们将在本章后面了解更多关于性能测试（如峰值和压力测试）的内容。
- en: Performance analysis
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: Performance analysis (also known as performance profiling) is the observation
    and study of the usage of the available system resources by an application. We
    will perform profiling to identify performance issues in our applications. A different
    performance profiling process with specific tools will be carried out for each
    type of resource. For example, CPU profiling can be performed using the system
    monitor of our OS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析（也称为性能分析）是观察和研究中应用程序使用的可用系统资源。我们将进行性能分析以识别应用程序中的性能问题。对于每种类型的资源，将执行不同的性能分析过程。例如，可以使用我们操作系统的系统监视器进行CPU分析。
- en: We will now learn how to use the Google Chrome's developer tools to perform
    some network profiling tasks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何使用Google Chrome的开发者工具执行一些网络分析任务。
- en: Network performance analysis
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络性能分析
- en: We are going to start by analyzing network performance. Not so long ago, to
    be able to analyze the network performance of an application, we would have to
    write a small network logging application from scratch. Fortunately, today, things
    are much easier thanks to the arrival of the performance timing API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先分析网络性能。不久前，为了能够分析应用程序的网络性能，我们必须从头开始编写一个小型的网络日志应用程序。幸运的是，今天，由于性能计时API的出现，事情变得容易多了。
- en: The performance timing API allows us to access detailed network timing data
    for each loaded resource. You can learn more about it at [http://www.w3.org/TR/resource-timing/](http://www.w3.org/TR/resource-timing/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 性能计时API允许我们访问每个加载资源的详细网络计时数据。您可以在[http://www.w3.org/TR/resource-timing/](http://www.w3.org/TR/resource-timing/)了解更多信息。
- en: 'The following diagram illustrates the network timing data points that the API
    provides:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了API提供的网络计时数据点：
- en: '![](img/ff3aa358-6f64-411c-a247-470e819248c2.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff3aa358-6f64-411c-a247-470e819248c2.png)'
- en: network timing data points
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 网络计时数据点
- en: 'We can access the performance timing API via the `window` object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`window`对象访问性能计时API：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The performance attribute in the `window` object has some properties (`memory`,
    `navigation`, and `timing`) and methods (`clearMarks`, `clearMeasures`, and `getEntries`).
    We can use the `getEntries` function to access an array which contains the taming
    data points of each request:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`window`对象中的性能属性包含一些属性（`memory`、`navigation`和`timing`）和方法（`clearMarks`、`clearMeasures`和`getEntries`）。我们可以使用`getEntries`函数来访问一个包含每个请求的驯服数据点的数组：'
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each entity in the array is an instance of `PerformanceResourceTiming`, which
    contains the following information:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的每个实体都是`PerformanceResourceTiming`的一个实例，它包含以下信息：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unfortunately, the timing data points in the preceding format may not be useful
    if they are not presented in a visual way. Fortunately, there are some tools that
    can help us to analyze it with ease. We will now learn about some of these tools.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果这些时间数据点不以可视化的方式呈现，那么它们可能没有用。幸运的是，有一些工具可以帮助我们轻松分析它。现在，我们将了解一些这些工具。
- en: The first tool is a browser extension called **performance-bookmarklet**. This
    extension is open source and is available for Chrome and Firefox. The extension
    download links can be found at [https://github.com/micmro/performance-bookmarklet](https://github.com/micmro/performance-bookmarklet).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一款工具是一个名为**performance-bookmarklet**的浏览器扩展。这个扩展是开源的，适用于Chrome和Firefox。扩展下载链接可以在[https://github.com/micmro/performance-bookmarklet](https://github.com/micmro/performance-bookmarklet)找到。
- en: 'In the following screenshot, we can see one of the graphs generated by the
    extension. The graphs display the performance typing API information visually,
    allowing us to spot performance issues with ease:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我们可以看到由扩展生成的图表之一。图表以可视化的方式显示性能计时API信息，使我们能够轻松地发现性能问题：
- en: '![](img/246869e0-dffa-4839-95be-4a472ef40d8c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/246869e0-dffa-4839-95be-4a472ef40d8c.png)'
- en: 'Alternatively, we can use the network panel in the Chrome developer tools to
    perform network performance profiling. To access the network panel, open Google
    Chrome, navigate to View | Developer, and then navigate to Developer Tools:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用Chrome开发者工具中的网络面板来执行网络性能分析。要访问网络面板，请打开Google Chrome，导航到视图 | 开发者，然后导航到开发者工具：
- en: '![](img/8aa43eaa-4586-49d1-a68d-9f55838aa5e7.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8aa43eaa-4586-49d1-a68d-9f55838aa5e7.png)'
- en: Windows and Linux users can access the developer tools by pressing the *F12*
    key. OS X users can access it using the *Alt* + *Cmd* + *I* shortcut.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Windows和Linux用户可以通过按*F12*键访问开发者工具。OS X用户可以使用*Alt* + *Cmd* + *I*快捷键访问它。
- en: 'Once the developer tools are visible, we can access the Network tab by clicking
    on it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发者工具可见，我们可以通过点击它来访问网络标签：
- en: '![](img/3374dcfe-1dbd-4321-b75e-1086358fb8e2.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3374dcfe-1dbd-4321-b75e-1086358fb8e2.png)'
- en: Network tab
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 网络标签
- en: 'Clicking on the Network tab will lead us to a screen like the one seen here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 点击网络标签将带我们到一个类似于这里看到的屏幕：
- en: '![](img/69fcde60-1409-4553-b926-ad0a26b4bbef.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69fcde60-1409-4553-b926-ad0a26b4bbef.png)'
- en: As we can observe, the information is presented in a table in which each file
    loaded is displayed as a row. On the right-hand side, we can see the timeline
    column. The timeline displays the performance timing API in a visual way, just
    like the performance-bookmarklet extension.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所观察到的，信息以表格的形式呈现，其中每个加载的文件都显示为一行。在右侧，我们可以看到时间线列。时间线以可视化的方式显示性能时间API，就像性能-bookmarklet扩展一样。
- en: 'Two very important elements in the timeline column are the red and blue vertical
    lines. These lines let us know when the `DOMContentLoaded` event is triggered
    (blue line), after which the `onLoad` event is triggered (red line):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线列中有两个非常重要的元素是红色和蓝色的垂直线。这些线条让我们知道何时触发`DOMContentLoaded`事件（蓝色线条），之后触发`onLoad`事件（红色线条）：
- en: The blue line indicates when the `DOMContentLoaded` event was fired. The `DOMContentLoaded`
    event is fired when the engine has completed parsing of the main document.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝线表示`DOMContentLoaded`事件被触发的时间。当引擎完成对主文档的解析时，会触发`DOMContentLoaded`事件。
- en: 'The red line indicates when the `onLoad` event was fired. The `onLoad` event
    is fired when all the page''s resources have been loaded:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红线表示`onLoad`事件被触发的时间。当页面上所有资源都加载完毕时，会触发`onLoad`事件：
- en: '![](img/adb6b47f-9afb-4587-8ada-c6bcb938a946.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adb6b47f-9afb-4587-8ada-c6bcb938a946.png)'
- en: We can examine which requests were completed when these events were fired to
    get an idea of the overall page responsiveness and loading times.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查这些事件触发时完成的请求，来了解整体页面的响应性和加载时间。
- en: 'If we hover over one of the cells of the timing column, we will be able to
    see each of the performance timing API data points:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将鼠标悬停在时间列的任何一个单元格上，我们将能够看到每个性能时间API数据点：
- en: '![](img/ebc2a7b9-1ddc-47a4-bf0c-9d6c4747703c.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebc2a7b9-1ddc-47a4-bf0c-9d6c4747703c.png)'
- en: 'It is interesting to know that this developer tool reads this information using
    the performance timing API. We will now learn more about the meaning of each of
    the data points:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这个开发者工具使用性能时间API读取这些信息。我们现在将更深入地了解每个数据点的含义：
- en: '| **Performance timing API data point** | **Description** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **性能时间API数据点** | **描述** |'
- en: '| Stalled/Blocking | The amount of time spent waiting by the request before
    it can be sent; there is a maximum number of open TCP connections for an origin.
    When the limit is reached, some requests will display blocking time, rather than
    stalled time. There is a maximum of 6 TCP connections to the same origin (domain
    address). |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 阻塞/停滞 | 请求在发送之前等待的时间；对于源有一个最大数量的开放TCP连接。当达到限制时，一些请求将显示阻塞时间，而不是停滞时间。同一源（域名地址）的最大TCP连接数为6个。|'
- en: '| Proxy negotiation | The amount of time spent negotiating a connection with
    a proxy server. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 代理协商 | 与代理服务器协商连接所花费的时间。|'
- en: '| DNS lookup | The amount of time spent resolving a DNS address; resolving
    a DNS requires a full round-trip to do the DNS server for each domain on the page.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| DNS查找 | 解析DNS地址所花费的时间；解析DNS需要每个页面上每个域的DNS服务器进行完整往返。|'
- en: '| Initial connection / connecting | The amount of time spent establishing a
    connection. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 初始连接/连接中 | 建立连接所花费的时间。|'
- en: '| SSL | The amount of time spent establishing an SSL connection. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| SSL | 建立SSL连接所花费的时间。|'
- en: '| Request sent / sending | The amount of time spent issuing the network request;
    typically, a fraction of a millisecond. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 请求发送/发送中 | 发出网络请求所花费的时间；通常，是毫秒的一部分。|'
- en: '| Waiting (TTFB) | The amount of time spent waiting for the initial byte to
    be received—**time to first byte** (**TTFB**); the TTFB can be used to find out
    the latency of a round trip to the server in addition to the time spent waiting
    for the server to deliver the response. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 等待（TTFB） | 接收初始字节数据所花费的时间——**首次字节时间**（**TTFB**）；TTFB可以用来找出往返服务器的延迟，以及等待服务器发送响应所花费的时间。|'
- en: '| Content download / downloading | The amount of time spent waiting for the
    response data to be received. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 内容下载/下载中 | 等待响应数据接收所花费的时间。|'
- en: Please refer to the official Google Chrome documentation at [https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#timing-explanation](https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#timing-explanation)
    to learn more about the timing API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方Google Chrome文档[https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#timing-explanation](https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#timing-explanation)，了解更多关于时间API的信息。
- en: Network performance and user experience
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络性能和用户体验
- en: 'Now that we know how we can analyze network performance, it is time to identify
    the performance goals we should aim for. Numerous studies have proved that it
    is important to keep loading times as low as possible to achieve a great **user
    experience** (**UX**). The Akamai study, published in September 2009, interviewed
    1,048 online shoppers and found that:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何分析网络性能，是时候确定我们应该追求的性能目标了。许多研究表明，为了实现良好的**用户体验**（**UX**），保持加载时间尽可能低是很重要的。Akamai在2009年9月发表的一项研究，对1,048名在线购物者进行了调查，发现：
- en: 47 percent of people expect a web page to load in two seconds or less
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 47%的人期望网页在两秒或更短的时间内加载完成
- en: 40 percent of people will abandon a web page if it takes more than three seconds
    to load
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果页面加载超过三秒，40%的人会放弃网页
- en: 52 percent of online shoppers claim that quick page loads are important for
    their loyalty to a site
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 52%的在线购物者声称快速页面加载对他们对网站的忠诚度很重要
- en: 14 percent of people will start shopping at a different site if page loads are
    slow
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果页面加载速度慢，14%的人会开始在不同的网站上购物
- en: 23 percent of people will stop shopping or even walk away from their computer
    if page loads are slow
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果页面加载速度慢，23%的人会停止购物甚至离开电脑
- en: 64 percent of shoppers who are dissatisfied with their site visit will go somewhere
    else to shop next time
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对网站访问不满意的有64%的购物者下次购物时会去其他地方
- en: You can read the full Akamai study at [https://www.akamai.com/us/en/about/news/press/2009-press/akamai-reveals-2-seconds-as-the-new-threshold-of-acceptability-for-ecommerce-web-page-response-times.jsp](https://www.akamai.com/us/en/about/news/press/2009-press/akamai-reveals-2-seconds-as-the-new-threshold-of-acceptability-for-ecommerce-web-page-response-times.jsp).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.akamai.com/us/en/about/news/press/2009-press/akamai-reveals-2-seconds-as-the-new-threshold-of-acceptability-for-ecommerce-web-page-response-times.jsp](https://www.akamai.com/us/en/about/news/press/2009-press/akamai-reveals-2-seconds-as-the-new-threshold-of-acceptability-for-ecommerce-web-page-response-times.jsp)阅读完整的Akamai研究。
- en: From the preceding study conclusions, we should assume that network performance
    matters. Our priority should be to try to improve the loading speed of our applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的研究结论中，我们应该假设网络性能很重要。我们的首要任务是尝试提高我们应用程序的加载速度。
- en: 'If we try to improve the performance of a site to ensure that it loads in less
    than two seconds, we might make a common mistake: trying to get the `onLoad` event
    to be triggered in under two seconds.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图提高网站的性能以确保它在两秒内加载完成，我们可能会犯一个常见的错误：试图在两秒内触发`onLoad`事件。
- en: 'While triggering the `onLoad` event as early as possible will probably improve
    the network performance of an application, it doesn''t mean that the user experience
    will be equally improved. The `onLoad` event is insufficient in determining performance.
    We can demonstrate this by comparing the loading performance of the Twitter and
    Amazon websites. As we can see in the following screenshot, users can engage with
    Amazon much sooner than with Twitter. Even though the `onLoad` event is the same
    on both sites, the user experience is drastically different:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管尽早触发`onLoad`事件可能会提高应用程序的网络性能，但这并不意味着用户体验会同样得到改善。`onLoad`事件不足以确定性能。我们可以通过比较Twitter和Amazon网站的加载性能来证明这一点。正如以下截图所示，用户可以比在Twitter上更快地与Amazon互动。尽管两个网站上的`onLoad`事件相同，但用户体验却截然不同：
- en: '![](img/be19ba8b-7883-49bc-81ac-7ef457d1a54a.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be19ba8b-7883-49bc-81ac-7ef457d1a54a.png)'
- en: Twitter and Amazon websites
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter和Amazon网站
- en: The preceding example demonstrates why it is important to try to load the web
    contents in such a way that the user engagement can begin as early as possible.
    One way to achieve this is by ensuring that we only load the minimum necessary
    assets on initial page load. We can then asynchronously load all the secondary
    assets.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子说明了为什么尝试以尽可能早的方式加载网页内容以开始用户互动是很重要的。实现这一目标的一种方法是通过确保我们在初始页面加载时只加载必要的最小资产。然后我们可以异步加载所有次要资产。
- en: Refer to [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml), *Working with
    Functions,* to learn more about asynchronous programming with TypeScript.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第3章[82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml]，*与函数一起工作*，了解使用TypeScript进行异步编程的更多信息。
- en: Network performance best practices and rules
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络性能最佳实践和规则
- en: Another way to analyze the performance of a web application is by using a best
    practices tool for network performance, such as the **Google PageSpeed Insights**
    application or the **Yahoo YSlow** application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 分析Web应用性能的另一种方法是使用网络性能最佳实践工具，例如**Google PageSpeed Insights**应用或**Yahoo YSlow**应用。
- en: 'Google PageSpeed Insights can be used online or as a Google Chrome extension.
    To try this tool, we can visit the online version at [https://developers.google.com/speed/pagespeed/insights/](https://developers.google.com/speed/pagespeed/insights/)
    and insert the URL of the web application that we want to analyze. In just a few
    seconds, we will get a report like the one in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Google PageSpeed Insights 可以在线使用或作为Google Chrome扩展使用。要尝试此工具，我们可以访问在线版本[https://developers.google.com/speed/pagespeed/insights/](https://developers.google.com/speed/pagespeed/insights/)并插入我们想要分析的Web应用的URL。几秒钟后，我们将得到如下截图所示的报告：
- en: '![](img/a8f32bde-7fba-4fd7-8d95-86ab32bf222c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8f32bde-7fba-4fd7-8d95-86ab32bf222c.png)'
- en: 'The report contains some effective recommendations that will help us to improve
    network performance and overall user experience of our web applications. Google
    PageSpeed Insights uses the following rules to rate the speed of a web application:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 报告包含一些有效的建议，将帮助我们提高Web应用的网络性能和整体用户体验。Google PageSpeed Insights使用以下规则来评估Web应用的速度：
- en: Avoid landing page redirects
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免落地页重定向
- en: Enable compression
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用压缩
- en: Improve server response time
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高服务器响应时间
- en: Leverage browser caching
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用浏览器缓存
- en: Minify resources
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩资源
- en: Optimize images
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化图片
- en: Optimize CSS delivery
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化CSS交付
- en: Prioritize visible content
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先处理可见内容
- en: Remove render-blocking JavaScript
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除渲染阻塞的JavaScript
- en: Use asynchronous scripts
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步脚本
- en: If we click on the score of one of the rules, we will be able to see recommendations
    and details that will help us to understand what is wrong and what we need to
    do to increase the score achieved.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击某条规则的分数，我们将能够看到推荐和详细信息，这将帮助我们了解哪里出了问题以及我们需要做什么来提高得分。
- en: 'On the other hand, Yahoo YSlow is available as a browser extension, a Node.js
    module, and a PhantomJS plugin, among other options. We can find the right version
    for our needs at [http://yslow.org/](http://yslow.org/). YSlow generates a report
    that will provide us with a general score and a detailed score of the website,
    like the one in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Yahoo YSlow可以作为浏览器扩展、Node.js模块和PhantomJS插件等多种方式使用。我们可以在[http://yslow.org/](http://yslow.org/)找到适合我们需求的正确版本。YSlow生成一份报告，将为我们提供网站的一般得分和详细得分，如下面的截图所示：
- en: '![](img/e0155934-8539-4b7b-92e2-a0c6b6e99541.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0155934-8539-4b7b-92e2-a0c6b6e99541.png)'
- en: 'YSlow uses the following set of rules to rate the speed of a web application:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: YSlow使用以下规则集来评估Web应用的速度：
- en: Minimize HTTP requests
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化HTTP请求
- en: Use a content delivery network
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容分发网络
- en: Avoid empty `src` or `href`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免空的`src`或`href`
- en: Add an expires or a cache-control header
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加过期或缓存控制头
- en: GZIP components
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GZIP组件
- en: Put stylesheets at the top
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将样式表放在顶部
- en: Put scripts at the bottom
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将脚本放在底部
- en: Avoid CSS expressions
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免CSS表达式
- en: Make JavaScript and CSS external
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JavaScript 和 CSS 外部化
- en: Reduce DNS lookups
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少DNS查找
- en: Minify JavaScript and CSS
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩JavaScript和CSS
- en: Avoid redirects
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免重定向
- en: Remove duplicate scripts
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除重复的脚本
- en: Configure ETags
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置ETags
- en: Make Ajax cacheable
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使Ajax可缓存
- en: Use GET for Ajax requests
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GET进行Ajax请求
- en: Reduce the number of DOM elements
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少DOM元素数量
- en: Prevent 404 errors
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止404错误
- en: Reduce cookie size
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少cookie大小
- en: Use cookie-free domains for components
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为组件使用无cookie域名
- en: Avoid filters
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过滤器
- en: Do not scale images in HTML
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在HTML中缩放图片
- en: Make `favicon.ico` small and cacheable
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`favicon.ico`文件小且可缓存
- en: If we click on the score of one of the rules, we will see some recommendations
    and details that will help us to understand what is wrong and what we need to
    do to increase the score achieved for one particular rule.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击某条规则的分数，我们将看到一些推荐和详细信息，这将帮助我们了解哪里出了问题以及我们需要做什么来提高特定规则的得分。
- en: If you want to learn more about network performance optimization, please look
    at the book *High Performance Browser Networking* by *Ilya Grigorik*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于网络性能优化的信息，请参阅由*Ilya Grigorik*撰写的书籍《高性能浏览器网络》。
- en: GPU performance analysis
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU性能分析
- en: Rendering elements in a web application is sometimes accelerated by the GPU.
    The GPU is specialized in the processing of graphics-related instructions and
    can, therefore, deliver a much better performance than the CPU when it comes to
    graphics. For example, CSS3 animations in modern web browsers are accelerated
    by the GPU, while the CPU performs JavaScript animations. In the past, the only
    way to achieve some animations was via JavaScript. But today, we should avoid
    its usage when possible and use CSS3 instead.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，渲染元素有时会通过GPU加速。GPU专门处理与图形相关的指令，因此在图形方面，它能够提供比CPU更好的性能。例如，在现代Web浏览器中，CSS3动画是通过GPU加速的，而CPU执行JavaScript动画。在过去，实现某些动画的唯一方法是通过JavaScript。但今天，我们应该尽可能避免使用它，而使用CSS3。
- en: In recent years, direct access to the GPU from a web browser has become possible
    thanks to the WebGL API. This API allows web developers to create 3D games and
    other highly visual 3D applications powered by the GPU.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，由于WebGL API的出现，从Web浏览器直接访问GPU已成为可能。这个API允许Web开发者利用GPU创建3D游戏和其他高度可视化的3D应用程序。
- en: Frames per second (FPS)
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每秒帧数（FPS）
- en: 'We will not go into much detail about the performance of 3D applications, because
    it is an extensive field and we could write an entire book about it. However,
    we will learn about an important concept that can be applied to any web application:
    **frames per second** (**FPS**), or frame rate. When the web application is displayed
    on the screen, it is done at several images (frames) per second. A low frame rate
    can be detrimental to the overall user experience when perceived by the users.
    A lot of research has been carried out on this topic, and 60 frames per second
    seem to be the optimum frame rate for great user experience. It is also worth
    mentioning that maintaining a constant frame rate, even if it is a low one like
    30 FPS, is considered better than an inestable frame rate.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地讨论3D应用程序的性能，因为这是一个广泛的领域，我们甚至可以为此写一本书。然而，我们将了解一个可以应用于任何Web应用程序的重要概念：**每秒帧数**（**FPS**），或帧率。当Web应用程序在屏幕上显示时，它是以每秒几帧的图像（帧）来完成的。如果用户感知到帧率低，可能会对整体用户体验产生不利影响。关于这个主题已经进行了大量的研究，60帧每秒似乎是最适合良好用户体验的帧率。值得一提的是，即使帧率是30
    FPS这样的低值，保持一个恒定的帧率也被认为比不稳定的帧率要好。
- en: Whenever we develop a web application, we should look at the frame rate and
    try to prevent it from dropping below 40 FPS, which is especially important for
    animations and user actions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们开发Web应用程序，我们都应该关注帧率，并尝试防止其低于40 FPS，这对于动画和用户操作尤其重要。
- en: 'We can use Google Chrome to monitor the FPS in our web applications. We need
    to open the development tools (*Ctrl* + *Shift* + *I*), click on the upper-right
    icon next to the *X* icon with the tooltip *Customize and control devtools*. We
    can then select More tools | Rendering:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Google Chrome来监控我们的Web应用程序中的FPS。我们需要打开开发工具（*Ctrl* + *Shift* + *I*），点击右上角与*X*图标相邻的图标，其工具提示为*自定义和控制开发工具*。然后我们可以选择更多工具
    | 渲染：
- en: '![](img/f53648c6-4db3-45e8-a298-cae3f78393cc.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f53648c6-4db3-45e8-a298-cae3f78393cc.png)'
- en: 'The preceding instructions will display a new panel with the title Rendering.
    We must then enable the FPS meter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令将显示一个标题为渲染的新面板。然后我们必须启用FPS计数值：
- en: '![](img/3b0a2407-5332-4366-89f1-beb3791046cf.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b0a2407-5332-4366-89f1-beb3791046cf.png)'
- en: 'The FPS meter should be displayed in the upper-right corner of the screen:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: FPS计数值应显示在屏幕的右上角：
- en: '![](img/c826d45d-00fb-4ac2-9075-7197592357e5.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c826d45d-00fb-4ac2-9075-7197592357e5.jpg)'
- en: The FPS counter allows us to see the number of frames per second and the GPU
    memory being consumed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: FPS计数器使我们能够看到每秒的帧数和正在消耗的GPU内存。
- en: Some advanced WebGL applications may require an in-depth performance analysis.
    For such cases, Chrome provides the Trace Event Profiling Tool. If you wish to
    learn more about this tool, visit the official page at [https://www.chromium.org/developers/how-tos/trace-event-profiling-tool](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级WebGL应用程序可能需要深入的性能分析。对于这种情况，Chrome提供了Trace Event Profiling Tool。如果您想了解更多关于这个工具的信息，请访问官方页面[https://www.chromium.org/developers/how-tos/trace-event-profiling-tool](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool)。
- en: CPU performance analysis
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU性能分析
- en: 'To analyze the usage of the processing time, we will examine the call stack
    of our application. We will examine each of the functions invoked and how long
    it takes to complete their execution. We can access all this information by opening
    the Profiles tab in the Google Chrome developer tools:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析处理时间的使用情况，我们将检查应用程序的调用栈。我们将检查每个调用的函数及其执行完成所需的时间。我们可以通过在Google Chrome开发者工具中打开“性能”选项卡来访问所有这些信息：
- en: '![](img/ad3e72f1-efae-46b7-956e-b1a6ed0b2d4a.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![时间线截图](img/ad3e72f1-efae-46b7-956e-b1a6ed0b2d4a.png)'
- en: 'In this tab, we can select Collect JavaScript CPU Profile and then click on
    the Start button to start recording the CPU usage. Being able to select when we
    want to start and stop recording the CPU usage helps us select the specific functions
    that we want to analyze. If, for example, we want to analyze a function named
    `foo`, all we need to do is start recording the CPU usage, invoke the `foo` function,
    and stop recording. A timeline like the one in the following screenshot will then
    be displayed:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在此选项卡中，我们可以选择收集JavaScript CPU性能报告，然后点击“开始”按钮以开始记录CPU使用情况。能够选择何时开始和停止记录CPU使用情况有助于我们选择要分析的具体函数。例如，如果我们想分析名为`foo`的函数，我们只需要开始记录CPU使用情况，调用`foo`函数，然后停止记录。随后将显示如下截图所示的时间线：
- en: '![](img/d3aec896-894c-4cad-bf08-92bde38c6d32.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![性能截图](img/d3aec896-894c-4cad-bf08-92bde38c6d32.png)'
- en: Timeline
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线
- en: 'The timeline displays the functions invoked in chronological order (horizontal
    axis). The timeline also displays the call stack of these functions (vertical
    axis). When we hover over one of these functions, we will be able to see its details
    in the lower-left corner of the timeline:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线按时间顺序显示调用的函数（水平轴）。时间线还显示了这些函数的调用栈（垂直轴）。当我们悬停在其中一个函数上时，我们将在时间线的左下角看到其详细信息：
- en: '![](img/762a4b61-4079-4882-99a2-678adad39ee5.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![时间线截图](img/762a4b61-4079-4882-99a2-678adad39ee5.png)'
- en: 'The details include the following information:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息包括以下信息：
- en: 'Name: The name of the function'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：函数的名称
- en: 'Self-time: The time spent on the completion of the current invocation of the
    function; we will consider the time spent in the execution of the statements within
    the function, not including any functions that it called'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义时间：完成当前函数调用所花费的时间；我们将考虑函数内部语句的执行时间，不包括它调用的任何函数
- en: 'Total time: The total time spent on the completion of the current invocation
    of the function; we will consider the time spent in the execution of the statements
    within the function, including functions that it called'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总时间：完成当前函数调用的总时间；我们将考虑函数内部语句的执行时间，包括它调用的函数
- en: 'Aggregated self-time: The time for all invocations of the function across the
    recording, not including functions called by this function'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合自定义时间：在整个录制过程中，函数所有调用的总时间，不包括由该函数调用的函数
- en: 'Aggregated total time: The time for all invocations of the function across
    the recording, including functions called by this function'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合总时间：在整个录制过程中，函数所有调用的总时间，包括由该函数调用的函数
- en: As we have learned in the previous chapters, all the JavaScript code is executed
    in one single thread at runtime; for this reason, when a function is executed,
    no other function can be executed. When the execution of a function takes too
    long to be completed, the application becomes unresponsive.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前几章所学，所有JavaScript代码在运行时都在一个单独的线程中执行；因此，当一个函数正在执行时，没有其他函数可以执行。当函数的执行时间过长时，应用程序会变得无响应。
- en: We can solve this problem by reducing the amount of time required by the long-running
    function. We can use the CPU profile report to identify which functions are consuming
    too much processing time. Once we have identified these functions, we can refactor
    them to try to improve the application responsiveness. Some common improvements
    include using an asynchronous execution flow when possible, and reducing the size
    of the functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过减少长时间运行函数所需的时间来解决此问题。我们可以使用CPU性能报告来识别哪些函数消耗了过多的处理时间。一旦我们确定了这些函数，我们可以重构它们以尝试提高应用程序的响应性。一些常见的改进包括在可能的情况下使用异步执行流程，并减小函数的大小。
- en: Memory performance analysis
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存性能分析
- en: When we declare a variable, it is allocated in the RAM. Sometime after, the
    variable is out of the scope; it is cleared from memory by the garbage collector.
    Sometimes, we can generate a scenario in which a variable never goes out of scope.
    If the variable never goes out of scope, it will never be cleared from the memory.
    This can eventually lead to some serious memory leaking issues. A **memory leak**
    is the continuous loss of available memory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个变量时，它会在RAM中分配。有时之后，变量超出作用域；它会被垃圾回收器从内存中清除。有时，我们可以生成一个变量永远不会超出作用域的场景。如果变量永远不会超出作用域，它将永远不会从内存中清除。这最终可能导致一些严重的内存泄漏问题。**内存泄漏**是指可用内存的持续损失。
- en: When dealing with memory leaks, we can take advantage of the Google Chrome developer
    tools to identify the cause of the problem with ease.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理内存泄漏时，我们可以利用Google Chrome开发者工具轻松地确定问题的原因。
- en: 'The first thing that we might wonder is whether our application has memory
    leaks. We can find out by visiting the timeline and clicking on the upper-left
    icon to start recording the resource usage. Once we stop recording, a timeline
    graph like the one in the following screenshot will be displayed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会首先想知道我们的应用程序是否存在内存泄漏。我们可以通过访问时间轴并点击左上角的图标来开始记录资源使用情况来找出答案。一旦我们停止记录，就会显示一个类似于以下截图的时间轴图：
- en: '![](img/60105d50-7848-450b-b035-9809e999a5a3.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60105d50-7848-450b-b035-9809e999a5a3.png)'
- en: In the timeline, we can select Memory to see the memory usage (Used JS Heap)
    over time (blue line in the screenshot). In the preceding example, we can see
    a notable drop towards the end of the line. That is a good sign because it indicates
    that most of the used memory has been cleared when the page has finished loading.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间轴中，我们可以选择“内存”来查看随时间变化的内存使用情况（截图中的蓝色线条表示“已用JS堆”）。在先前的例子中，我们可以看到在时间轴的末端有一个显著的下降。这是一个好兆头，因为它表明当页面加载完成后，大部分已使用的内存已经被清除。
- en: The memory leaks can also take place after loading; in that case, we can use
    the application for a while and observe how the memory usage varies in the graph
    to identify the cause of the leak.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏也可能在加载后发生；在这种情况下，我们可以使用应用程序一段时间，并观察图中内存使用情况的变化，以确定泄漏的原因。
- en: 'An alternative way to detect memory leaks is by observing the memory allocations.
    We can access this information by recording the heap allocations in the Memory
    tab:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 检测内存泄漏的另一种方法是观察内存分配。我们可以通过在“内存”标签页中记录堆分配来访问这些信息：
- en: '![](img/7c5511ce-333a-4a34-a810-275a1916df3a.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c5511ce-333a-4a34-a810-275a1916df3a.png)'
- en: The report will be displayed after we have recorded some usage of the resources.
    We can do this by selecting Record allocation timeline and clicking on the Stake
    snapshot button. We then need to stop recording by clicking on the red dot displayed
    on the upper-left side of the development tools.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录了一些资源使用情况后，报告将显示。我们可以通过选择“记录分配时间轴”并点击“快照”按钮来做到这一点。然后我们需要通过点击开发工具左上角显示的红点来停止记录。
- en: 'The memory allocation report will display a timeline like the one in the following
    screenshot. Each of the blue lines is a memory allocation that took place during
    the recorded period. The height of the line represents the amount of memory used.
    As we can see, the memory is almost cleared completely around the eighth second:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配报告将显示一个类似于以下截图的时间轴。每一条蓝色线条都表示在记录期间发生的内存分配。线条的高度表示使用的内存量。正如我们所见，内存在大约第八秒时几乎被完全清除：
- en: '![](img/e9ebd42f-221a-4b8d-8fbb-d97dc4182f41.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9ebd42f-221a-4b8d-8fbb-d97dc4182f41.png)'
- en: 'If we click on one of the blue lines, we will be able to navigate through all
    the variables that were stored in memory when the allocation took place and examine
    their values. It is also possible to take a memory snapshot at any given point
    from the Profiles tab:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击其中一条蓝色线条，我们将能够导航到在分配发生时存储在内存中的所有变量，并检查它们的值。从“配置文件”标签页也可以在任何给定点获取内存快照：
- en: '![](img/66c927aa-c944-4602-9031-03aac884446a.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66c927aa-c944-4602-9031-03aac884446a.png)'
- en: 'This feature is particularly useful when we are debugging and we want to see
    the memory usage at a breakpoint. The memory snapshot works like the details view
    in the previously explained allocations view:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在我们调试并希望看到断点处的内存使用情况时特别有用。内存快照的工作方式类似于之前解释的分配视图中的详细视图：
- en: '![](img/439f929c-a983-4265-a3e7-2aae4a9729f3.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/439f929c-a983-4265-a3e7-2aae4a9729f3.png)'
- en: As we can see in the preceding screenshot, the memory snapshot allows us to
    navigate through all the variables that were stored in memory when the snapshot
    was taken and examine their values.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，内存快照允许我们在快照被捕获时导航到存储在内存中的所有变量，并检查它们的值。
- en: The garbage collector
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收器
- en: Programming languages with a low level of abstraction have low-level memory
    management mechanisms. On the other hand, in languages with a higher level of
    abstraction, such as C# or JavaScript, the memory is automatically allocated and
    freed by a process known as the garbage collector.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有着低抽象级别的编程语言具有低级内存管理机制。另一方面，在具有更高抽象级别的语言中，如C#或JavaScript，内存通过称为垃圾回收器的过程自动分配和释放。
- en: The JavaScript garbage collector does a great job when it comes to memory management,
    but it doesn't mean that we don't need to care about memory management.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到内存管理时，JavaScript垃圾回收器做得很好，但这并不意味着我们不需要关心内存管理。
- en: 'Independent of which programming language we are working with, the memory life
    cycle pretty much follows the same pattern:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用哪种编程语言，内存生命周期基本上遵循相同的模式：
- en: Allocate the memory you need
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配你需要的内存
- en: Use the memory (read/write)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内存（读取/写入）
- en: Release the allocated memory when it is not needed anymore
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不再需要时释放分配的内存
- en: 'The garbage collector will try to release the allocated memory when is not
    needed anymore, using a variation of an algorithm known as the **mark-and-sweep
    algorithm**. The garbage collector performs periodical scans to identify objects
    that are out of the scope and can be freed from the memory. The scan is divided
    into two phases: the first one is known as a **mark,** because the garbage collector
    will flag or mark the items that can be freed from memory. During the second phase,
    known as a **sweep**, the garbage collector will free the memory consumed by the
    items marked in the previous phase.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要分配的内存时，垃圾回收器将尝试释放它，使用一种称为**标记-清除算法**的算法变体。垃圾回收器执行周期性扫描以识别超出作用域的对象，这些对象可以从内存中释放。扫描分为两个阶段：第一个阶段被称为**标记**，因为垃圾回收器将标记可以释放内存的项目。在第二个阶段，称为**清除**，垃圾回收器将释放前一个阶段标记的项目所消耗的内存。
- en: The garbage collector is usually able to identify when an item can be cleared
    from the memory; but we, as developers, must try to ensure that objects get out
    of scope when we don't need them anymore. If a variable never gets out of the
    scope, it will be allocated in memory forever, potentially leading to a severe
    memory leak issue.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器通常能够识别何时可以清除内存中的项目；但作为开发者，我们必须尝试确保当不再需要对象时，对象能够超出作用域。如果一个变量从未超出作用域，它将永远分配在内存中，这可能导致严重的内存泄漏问题。
- en: 'The number of references pointing to an item in memory will prevent it from
    being freed from memory. For this reason, most cases of memory leaks can be fixed
    by ensuring that there are no permanent references to variables. Here are a few
    rules that can help us to prevent potential memory leak issues:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 指向内存中项目的引用数量将阻止其从内存中释放。因此，大多数内存泄漏案例可以通过确保没有对变量的永久引用来修复。以下是一些可以帮助我们防止潜在内存泄漏问题的规则：
- en: Remember to clear intervals when you don't need them anymore
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记得在不再需要时清除间隔
- en: Remember to clear event listeners when you don't need them anymore
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记得在不再需要时清除事件监听器
- en: Remember that when you create a closure, the inner function will remember the
    context in which it was declared, which means that there will be some extra items
    allocated in memory
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，当你创建闭包时，内部函数将记住其声明的上下文，这意味着将分配一些额外的内存项。
- en: Remember that when using object composition, if circular references are created,
    you can end up having some variables that will never be cleared from memory
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，当使用对象组合时，如果创建了循环引用，你可能会遇到一些变量将永远不会从内存中清除。
- en: 'It is important to mention that Node.js processes assume that there will be
    at least 1.5 GB of RAM available, which can cause some problems when the system
    has less than 1.5 GB of RAM available because the garbage collector will not try
    to free any unused memory until the process has consumed almost 1.5 GB of RAM.
    If only 1 GB is available, the process will crash, because we will run out of
    memory before the garbage collector tries to clean the unused memory. We can solve
    this problem using the `max_old_space_size` flag:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，Node.js 进程假定至少有 1.5 GB 的 RAM 可用，当系统可用 RAM 低于 1.5 GB 时可能会引起一些问题，因为垃圾回收器不会尝试释放任何未使用的内存，直到进程消耗了几乎
    1.5 GB 的 RAM。如果只有 1 GB 可用，进程将会崩溃，因为我们将在垃圾回收器尝试清理未使用内存之前耗尽内存。我们可以使用 `max_old_space_size`
    标志来解决这个问题：
- en: '[PRE3]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Performance analysis in Node.js applications
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 应用程序的性能分析
- en: We have learned how to use the Google Chrome development tools to analyze frontend
    application. However, the same tools can also be used to analyze backend applications
    powered by Node.js.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用 Google Chrome 开发工具来分析前端应用程序。然而，相同的工具也可以用来分析由 Node.js 驱动的后端应用程序。
- en: 'To use the Google Chrome development tools to analyze a Node.js application,
    we need to start the Node.js application using the `--inspect` flag:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Google Chrome 开发工具分析 Node.js 应用程序，我们需要使用 `--inspect` 标志启动 Node.js 应用程序：
- en: '[PRE4]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then we need to visit the `chrome://inspect` URL using Google Chrome.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用 Google Chrome 访问 `chrome://inspect` URL。
- en: 'If everything went well, we should be able to see the following screen:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该能看到以下屏幕：
- en: '![](img/f0badd2f-5691-485a-9243-42c56c9458ca.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0badd2f-5691-485a-9243-42c56c9458ca.png)'
- en: We then need to click on the inspect link, which should be available under the
    Remote Target section. A new window should be opened then. The window will display
    the Google Chrome developer tools, ready to analyze the Node.js application.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要点击“检查”链接，该链接应在“远程目标”部分下可用。随后应该会打开一个新窗口。该窗口将显示 Google Chrome 开发者工具，准备分析
    Node.js 应用程序。
- en: Alternatively, we can use the **Node.js V8 --inspector Manager** (**NiM**) extension
    for Google Chrome, which allows us to access the Node.js inspector more easily.
    You can download the extension by visiting [https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 Google Chrome 的 **Node.js V8 --inspector Manager** （**NiM**）扩展程序，它允许我们更轻松地访问
    Node.js 检查器。您可以通过访问 [https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj](https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj)
    下载此扩展程序。
- en: Performance automation
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能自动化
- en: In this section, we will understand how we can automate many of the performance
    optimization tasks, from concatenation and compression of contents to the automation
    of the performance monitoring and performance testing processes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何自动化许多性能优化任务，从内容的连接和压缩到性能监控和性能测试过程的自动化。
- en: Performance optimization automation
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化自动化
- en: After analyzing the performance of our application, we will start working on
    some performance optimizations. Many of these optimizations involve the concatenation
    and compression of some of the application's components.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析完我们应用程序的性能后，我们将开始着手进行一些性能优化。许多这些优化涉及应用程序某些组件的连接和压缩。
- en: We will also have to create a new version of the concatenated and compressed
    contents every time one of the original components (not concatenated and not compressed)
    changes. Because these include many highly repetitive tasks, we can use tools
    like Gulp or Webpack to perform many of these tasks for us.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每当原始组件（未连接和未压缩）之一发生变化时，我们还需要创建一个新的连接和压缩内容的版本。因为这些包括许多高度重复的任务，我们可以使用 Gulp 或 Webpack
    等工具为我们执行许多这些任务。
- en: We can use these tools to concatenate and compress components, optimize images,
    generate a cache manifest file, and perform many other performance optimization
    tasks.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些工具来连接和压缩组件，优化图像，生成缓存清单文件，以及执行许多其他性能优化任务。
- en: If you would like to learn more about Gulp and Webpack, refer to [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml),
    *Automating Your Development Workflow*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于 Gulp 和 Webpack 的信息，请参阅第 9 章，*自动化您的开发工作流程*。
- en: Performance monitoring automation
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能监控自动化
- en: We have seen that we can automate many of the performance optimization tasks
    using the Gulp task runner. Similarly, we can also automate the performance monitoring
    process.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以使用Gulp任务运行器自动化许多性能优化任务。同样，我们也可以自动化性能监控过程。
- en: 'To monitor the performance of an existing application, we will need to collect
    some data that will allow us to compare the application performance over time.
    Depending on how we collect the data, we can identify three different types of
    performance monitoring:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监控现有应用程序的性能，我们需要收集一些数据，这将使我们能够比较应用程序随时间的变化。根据我们收集数据的方式，我们可以识别三种不同的性能监控类型：
- en: '**Real user monitoring** (**RUM**): This is a type of solution used to capture
    performance data from real user visits. The collection of data is performed by
    a small JavaScript code snippet loaded in the browser. This type of solution can
    help us to collect data and discover performance trends and patterns.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实用户监控** (**RUM**)：这是一种用于从真实用户访问中捕获性能数据的解决方案。数据收集是通过在浏览器中加载的小段JavaScript代码完成的。此类解决方案可以帮助我们收集数据并发现性能趋势和模式。'
- en: '**Simulated browsers**: This type of solution is used to capture performance
    data from simulated browsers, which is the cheaper option, but it is limited,
    because simulated browsers cannot offer as accurate a representation of the real
    user experience.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟浏览器**：此类解决方案用于从模拟浏览器中捕获性能数据，这是更经济的选择，但它有限制，因为模拟浏览器无法提供与真实用户体验一样准确的表示。'
- en: '**Real-browser monitoring**: This is used to capture performance data of real
    browsers. This information provides a more accurate representation of the real
    user experience, as the data is collected using exactly what a user would see
    if he or she visited the site with the given environment (browser, geographic
    location, and network throughput).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实浏览器监控**：这是用于捕获真实浏览器性能数据的方法。这些信息提供了对真实用户体验的更准确表示，因为数据是使用用户访问网站时看到的 exactly
    what a user would see if he or she visited the site with the given environment
    (browser, geographic location, and network throughput).'
- en: Web browsers can be configured to generate **HTTP Archive** (**HAR**) files.
    A HAR file uses a common format for recording HTTP tracing information. This file
    contains a variety of information, but, for our purposes, it has a record of each
    object being loaded by a browser.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Web浏览器可以被配置为生成**HTTP Archive** (**HAR**)文件。HAR文件使用一个通用的格式来记录HTTP跟踪信息。此文件包含各种信息，但，就我们的目的而言，它记录了浏览器加载的每个对象。
- en: There are multiple scripts available online that showcase how to collect the
    data. One of the examples, `netsniff.js`, exports the network traffic in HAR format.
    The `netsniff.js` file (and other examples) can be found at [https://github.com/ariya/phantomjs/blob/master/examples/netsniff.js](https://github.com/ariya/phantomjs/blob/master/examples/netsniff.js).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在线上有多个脚本展示了如何收集数据。其中一个例子，`netsniff.js`，导出网络流量为HAR格式。`netsniff.js`文件（和其他示例）可以在[https://github.com/ariya/phantomjs/blob/master/examples/netsniff.js](https://github.com/ariya/phantomjs/blob/master/examples/netsniff.js)找到。
- en: Once we have generated the HAR files, we can use another application to see
    the collected performance information in a visual timeline. This application is
    called HAR Viewer and can be found at [https://github.com/janodvarko/harviewer](https://github.com/janodvarko/harviewer).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们生成了HAR文件，我们可以使用另一个应用程序以可视时间线查看收集到的性能信息。这个应用程序叫做HAR Viewer，可以在[https://github.com/janodvarko/harviewer](https://github.com/janodvarko/harviewer)找到。
- en: Alternatively, we could write a custom script or Gulp task to read the HAR files
    and break the automated build if the application performance doesn't meet our
    needs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以编写一个自定义脚本或Gulp任务来读取HAR文件，并在应用程序性能不符合我们的需求时中断自动化构建。
- en: It is also possible to run the YSlow performance analysis report and integrate
    it with the automated build.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以运行YSlow性能分析报告并将其与自动化构建集成。
- en: If you are considering using RUM, look at the New Relic solutions at [http://newrelic.com/](http://newrelic.com/)
    or Google Analytics at [http://www.google.com/analytics/](http://www.google.com/analytics/).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑使用RUM，请查看New Relic的解决方案，网址为[http://newrelic.com/](http://newrelic.com/)，或者Google
    Analytics，网址为[http://www.google.com/analytics/](http://www.google.com/analytics/).
- en: Performance testing automation
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试自动化
- en: 'Another way to improve the performance of an application is to write automated
    performance tests. These tests can be used to guarantee that the system meets
    a set of performance goals. There are multiple types of performance testing, but
    some of the most common ones include the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 提高应用程序性能的另一种方法是编写自动性能测试。这些测试可以用来确保系统满足一系列性能目标。性能测试有多种类型，但其中一些最常见的是以下几种：
- en: '**Load testing**: This is the most basic form of performance testing. We can
    use a load test to understand the behavior of the system under a specific expected
    load (number of concurrent users, number of transactions, and duration).'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：这是最基本的性能测试形式。我们可以使用负载测试来了解系统在特定预期负载（并发用户数、事务数和持续时间）下的行为。'
- en: '**Stress testing**: This is normally used to understand the maximum capacity
    limits of an application. This kind of test determines if an application can handle
    an extreme number of requests. Stress testing is not useful when working on a
    client-side application. However, it can be helpful when working on a Node.js
    application, since Node.js applications can have many simultaneous users.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**：这种测试通常用于了解应用程序的最大容量限制。这种测试确定应用程序是否能够处理极端数量的请求。当在客户端应用程序上工作时，压力测试并不适用。然而，当在
    Node.js 应用程序上工作时，它可能很有帮助，因为 Node.js 应用程序可以有多个并发用户。'
- en: '**Soak testing**: Also known as endurance testing. This kind of test is like
    the stress test, but instead of using an extreme load, it uses the expected load
    for a continued period. It is a common practice to collect memory usage data during
    this kind of test to detect potential memory leaks. This kind of test helps us
    to tell if the performance suffers degradation after a continued period.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '** soak 测试**：也称为耐久性测试。这种测试类似于压力测试，但不是使用极端负载，而是使用持续一段时间的预期负载。在测试期间收集内存使用数据是一种常见做法，用于检测潜在的内存泄漏。这种测试有助于我们判断在持续一段时间后性能是否有所下降。'
- en: '**Spike testing**: This is also like the stress test, but instead of using
    an extreme time load during a continued period, it uses sudden intervals of the
    extreme and expected load. This kind of test helps us to determine if an application
    can handle dramatic changes in load.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**峰值测试**：这也类似于压力测试，但不是在持续期间使用极端时间负载，而是使用突然的极端和预期负载间隔。这种测试有助于我们确定应用程序是否能够处理负载的剧烈变化。'
- en: '**Configuration testing**: This is used to determine the effects of configuration
    changes to the performance and behavior of an application. A common example would
    be experimenting with different methods of load balancing.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置测试**：这种测试用于确定配置更改对应用程序性能和行为的影响。一个常见的例子是尝试不同的负载均衡方法。'
- en: Exception handling
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Understanding how to use the available resources efficiently will help us to
    create better applications. Similarly, understanding how to handle runtime errors
    will help us to improve the overall quality of our applications. Exception handling
    in TypeScript involves three main language elements.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何有效地使用可用资源将帮助我们创建更好的应用程序。同样，了解如何处理运行时错误将帮助我们提高应用程序的整体质量。TypeScript 中的异常处理涉及三个主要语言元素。
- en: The Error class
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Error` 类'
- en: 'When a runtime error takes place, an instance of the `Error` class is thrown:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生运行时错误时，会抛出一个 `Error` 类的实例：
- en: '[PRE5]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can create custom errors in a couple of different ways. The easiest way
    to achieve it is by passing a string as an argument to the `Error` class constructor:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种不同的方式创建自定义错误。实现它的最简单方法是向 `Error` 类构造函数传递一个字符串作为参数：
- en: '[PRE6]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we need more customizable and advanced control over custom exceptions, we
    can use inheritance to achieve it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要对自定义异常有更多可定制和高级的控制，我们可以使用继承来实现：
- en: '[PRE7]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code snippet, we have declared a class named `Exception`, which
    inherits from the `Error` class. In the class constructor, we have set the prototype
    explicitly. This is a requirement since TypeScript 2.1, caused by some limitations.
    You can learn more details about this limitation at [https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work](https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个名为 `Exception` 的类，它继承自 `Error` 类。在类构造函数中，我们显式地设置了原型。这是由于一些限制，从
    TypeScript 2.1 开始的要求。你可以在 [https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work](https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work)
    了解更多关于这个限制的详细信息。
- en: The try...catch statements and throw statements
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try...catch 语句和 throw 语句
- en: 'A `catch` clause contains statements that specify what to do if an exception
    is thrown in the `try` block. We should perform some operations in the `try` block
    and, if they fail, the program execution flow will move from the `try` block to
    the `catch` block. Additionally, there is an optional block known as `finally`,
    which is executed after both the `try` and `catch` (if there was an `exception`
    in the `catch`) blocks:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch` 子句包含在 `try` 块中抛出异常时要执行的语句。我们应该在 `try` 块中执行一些操作，如果它们失败，程序执行流程将从 `try`
    块移动到 `catch` 块。此外，还有一个可选的 `finally` 块，它在 `try` 和 `catch` 块（如果 `catch` 块中有异常）之后执行：'
- en: '[PRE8]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is also important to mention that in the majority of programming languages,
    including TypeScript, throwing and catching exceptions is an expensive operation
    regarding resource consumption. We should use these statements if we need them,
    but sometimes it is necessary to avoid them because they can potentially negatively
    affect the performance of our applications.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，在包括 TypeScript 在内的绝大多数编程语言中，抛出和捕获异常是一项资源消耗较大的操作。如果我们需要使用这些语句，就应该使用它们，但有时为了避免它们可能对应用程序性能产生负面影响，有时有必要避免使用它们。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned what performance is and how the availability
    of resources can influence it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了性能是什么以及资源可用性如何影响它。
- en: We have also learned how to use some tools to analyze the way a TypeScript application
    uses available resources. These tools allow us to spot some possible issues, such
    as a low frame rate, memory leaks, and high loading times. We have also discovered
    that we can automate many kinds of the performance optimization tasks as well
    as the performance monitoring and testing processes.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用一些工具来分析 TypeScript 应用程序使用可用资源的方式。这些工具使我们能够发现一些可能的问题，例如帧率低、内存泄漏和高加载时间。我们还发现，我们可以自动化许多性能优化任务，以及性能监控和测试过程。
- en: In the following chapter, we are going to learn how we can automate the testing
    process of our TypeScript applications to achieve great application maintainability
    and reliability.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何自动化我们的 TypeScript 应用程序的测试过程，以实现出色的应用程序可维护性和可靠性。
