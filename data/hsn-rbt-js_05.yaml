- en: Using a Light Sensor to Create a Night-Light
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用光传感器创建夜灯
- en: In this chapter, we will look at the ways we can still use analog sensors with
    Johnny-Five and the Raspberry Pi, even without the Pi having built-in analog input
    pins. We'll use that knowledge to build a night-light that turns on and off an
    LED based on the ambient light in the room.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨即使没有Pi内置的模拟输入引脚，我们仍然可以使用Johnny-Five和Raspberry Pi使用模拟传感器的方法。我们将利用这些知识来构建一个夜灯，该夜灯根据房间内的环境光打开和关闭LED。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using an analog sensor with the Pi
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pi的模拟传感器
- en: The ambient light sensor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境光传感器
- en: Creating our night-light
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的夜灯
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this project, you will need a regular LED of any color, and a TSL2561 light
    sensor, available on Adafruit ([https://www.adafruit.com/product/439](https://www.adafruit.com/product/439)) and
    through many other providers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，您需要一个任何颜色的普通LED和一个TSL2561光传感器，可在Adafruit([https://www.adafruit.com/product/439](https://www.adafruit.com/product/439))和其他许多供应商处购买。
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Hands-On-Robotics-with-JavaScript/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Robotics-with-JavaScript/tree/master/Chapter05).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在[https://github.com/PacktPublishing/Hands-On-Robotics-with-JavaScript/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Robotics-with-JavaScript/tree/master/Chapter05)找到。
- en: Using an analog sensor with the Pi
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pi的模拟传感器
- en: We talked about the lack of multiple PWM output pins on the Pi in [Chapter 3](c7b761b9-d526-4998-8ec4-375debe53806.xhtml),* Building **Interactive
    Projects with RGB LED*, but an issue we haven't entirely addressed yet is with
    inputs. Digital inputs, such as buttons and switches, anything that is either
    on or off, are easy with the Pi, any digital output pin can also be used as a
    digital input pin. But what about things that require more than two states, such
    as sensors that detect light, temperature, moisture, distances, or anything else
    we'd like to measure in quantity? The answer lies in using specialized communication
    protocols developed over the years that allow digital pins to communicate analog
    information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](c7b761b9-d526-4998-8ec4-375debe53806.xhtml)中讨论了Pi上多路PWM输出引脚的缺乏，*构建**交互式RGB
    LED项目*，但我们尚未完全解决的问题是与输入相关的问题。数字输入，如按钮和开关，对于Pi来说很简单，任何数字输出引脚也可以用作数字输入引脚。但对于需要超过两种状态的事物，比如检测光、温度、湿度、距离或其他我们想要测量的任何事物，怎么办呢？答案在于使用多年来开发的专用通信协议，这些协议允许数字引脚通信模拟信息。
- en: Finding the right sensors for your Pi project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的Pi项目寻找合适的传感器
- en: When you're looking at sensors for a Raspberry Pi project, you need to be sure
    that any analog sensor you use has a digital interface. The two most common are
    I²C and SPI, and we'll talk about how to tell which your sensor has (or hasn't!)
    and whether that device can be used with Johnny-Five.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在寻找Raspberry Pi项目的传感器时，您需要确保您使用的任何模拟传感器都有数字接口。最常见的是I²C和SPI，我们将讨论如何判断您的传感器是否有（或没有！）以及该设备是否可以与Johnny-Five一起使用。
- en: I2C devices
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I2C设备
- en: I²C devices require two more pins to work along with power and a ground pin—an
    SDA (data) and SCL (clock) pin. The details of how these are used is beyond the
    scope of this book (see the *Further reading* section for more information), but
    do know that you can hook multiple devices to the same SDA and SCL pins, so long
    as the devices have different I²C addresses. The address is a two-digit hex number,
    that is easy to find for nearly all I²C devices, and in some cases the address
    can be configured physically on the device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: I²C设备需要两个额外的引脚才能与电源和地线引脚一起工作——一个SDA（数据）引脚和一个SCL（时钟）引脚。这些引脚如何使用的细节超出了本书的范围（有关更多信息，请参阅*进一步阅读*部分），但要知道，只要设备有不同的I²C地址，您就可以将多个设备连接到相同的SDA和SCL引脚。地址是一个两位十六进制数，对于几乎所有I²C设备来说都很容易找到，在某些情况下，地址可以在设备上物理配置。
- en: For this chapter's project, we will be using the TSL2561, which can have two
    different addresses configured to it. We'll stick with the default, 0x39 (on the
    Adafruit model) for now.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的项目，我们将使用TSL2561，它可以配置两个不同的地址。现在我们将使用默认的0x39（在Adafruit型号上）。
- en: SPI
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPI
- en: 'SPI devices get tricky quickly, you need five pins: power, ground, microcontroller
    to sensor data (MOSI), sensor to microcontroller data (MISO), and a chip select
    line. While multiple devices on a set of SPI pins can share MISO and MOSI pins,
    they each need their own chip select pin, so the microcontroller can signal the
    device it wishes to communicate with.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 设备很快就会变得复杂，您需要五个引脚：电源、地、微控制器到传感器数据（MOSI）、传感器到微控制器数据（MISO）和芯片选择线。虽然一组 SPI
    引脚上的多个设备可以共享 MISO 和 MOSI 引脚，但每个设备都需要自己的芯片选择引脚，这样微控制器就可以向它想要通信的设备发出信号。
- en: How to determine if your sensor will work with Johnny-Five
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何确定您的传感器是否与 Johnny-Five 兼容
- en: The best way to see if there already are drivers for the sensor you are eyeing
    in Johnny-Five is to check the documentation at the Johnny-Five website. Find
    the sensor type, and find out what chip the sensor is using (for example, our
    light sensor uses the TSL2561). Then, on the API page for the sensor, at the top,
    is nearly always a list of supported controllers and chips. If the chip number
    on your sensor matches one in that list, it is already compatible with Johnny-Five: just
    remember that even though analog sensors are compatible with Johnny-Five, they
    will not work with the Pi, because it has no analog input pins of its own.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您在 Johnny-Five 中关注的传感器是否已有驱动程序，最好的方法是检查 Johnny-Five 网站的文档。找到传感器类型，并了解传感器使用的是哪种芯片（例如，我们的光传感器使用的是
    TSL2561）。然后，在传感器的 API 页面顶部，几乎总是有一个支持的控制器和芯片列表。如果您的传感器上的芯片编号与列表中的某个编号匹配，则它已经与 Johnny-Five
    兼容：只需记住，尽管模拟传感器与 Johnny-Five 兼容，但它们不会与 Pi 一起工作，因为 Pi 没有自己的模拟输入引脚。
- en: 'As an example, here''s the list of supported light-sensor controllers and chips,
    and you can see the **TSL2561** in the list, so we''re good to start building
    out our project:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是支持的光传感器控制器和芯片列表，您可以在列表中看到 **TSL2561**，所以我们准备好开始构建我们的项目：
- en: '![](img/5063ccb7-d5df-43c7-aee8-c4aef9c0f966.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5063ccb7-d5df-43c7-aee8-c4aef9c0f966.png)'
- en: The ambient light sensor
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境光传感器
- en: To get started with our night-light project, we'll start by wiring up our TSL2561
    I²C light sensor and making sure we get good data reads by having it print out
    to the command line.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的夜灯项目，我们将首先连接我们的 TSL2561 I²C 光传感器，并确保通过将其打印到命令行来获取良好的数据读取。
- en: Wiring up the sensor
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接传感器
- en: In order to wire up our light sensor, we'll need to know which are the SDA and
    SCL pins of the Pi. For the Pi 3 and 3 B+, SDA is P1-P3 and SCL is P1-P5; these
    are also usually labelled on the cobblers as **SDA** and **SCL**. In order to
    get the sensor working, we'll need the power pin; this sensor is not 5V tolerant,
    so we'll need to use a 3.3V power pin. We can attach GND on the sensor to any
    ground pin.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接我们的光传感器，我们需要知道 Pi 的 SDA 和 SCL 引脚是哪些。对于 Pi 3 和 3 B+，SDA 是 P1-P3，SCL 是 P1-P5；这些通常也标有
    **SDA** 和 **SCL**。为了使传感器工作，我们需要电源引脚；这个传感器不耐受 5V，所以我们需要使用 3.3V 电源引脚。我们可以将传感器的 GND
    连接到任何地线引脚。
- en: 'The SDA and SCL pins on the sensor need to be connected to the SDA and SCL
    pins on the Pi, respectively. In the end, your light sensor should be wired up
    like the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器上的 SDA 和 SCL 引脚需要分别连接到 Pi 上的 SDA 和 SCL 引脚。最后，您的光传感器应该按照以下图示连接：
- en: '![](img/08e749e2-e6d3-47a9-a742-966da27ca45e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08e749e2-e6d3-47a9-a742-966da27ca45e.png)'
- en: Now that we've wired up our sensor, it's time to figure out how to print that
    data using Johnny-Five and other Node.js modules so we can make sure it's up and
    running.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了传感器，是时候考虑如何使用 Johnny-Five 和其他 Node.js 模块打印数据，以确保它正在运行。
- en: Writing a program to get readings and print them to the command line
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写程序读取数据并将其打印到命令行
- en: Sensor object events in Johnny-Five are different from button events, because,
    well, sensors are different to buttons! Let's take a look at the differences and
    how to get the data we need from our light sensor.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Johnny-Five 中的传感器对象事件与按钮事件不同，因为，嗯，传感器与按钮不同！让我们看看它们之间的差异以及如何从我们的光传感器获取所需的数据。
- en: The Johnny-Five sensor events
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Johnny-Five 传感器事件
- en: 'The two main events we''ll see from sensors are `data` and `change`. The only
    real difference is in the name: `data` events are fired every time data is retrieved,
    while `change` is fired when the data changes. I tend to use `change` when building
    sensor-based projects unless I''m distinctly logging data over time.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从传感器看到的两个主要事件是 `data` 和 `change`。唯一的真正区别在于名称：`data` 事件在每次检索数据时都会触发，而 `change`
    事件在数据变化时触发。我倾向于在构建基于传感器的项目时使用 `change`，除非我明确地需要记录随时间变化的数据。
- en: You can configure the time between data collection in the construction of the
    sensor object, as well as the threshold that the change in data must pass in order
    to fire the `change` event.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在传感器对象的构造函数中配置数据收集的时间间隔，以及数据变化必须通过的阈值才能触发`change`事件。
- en: Handling sensor data in the event handler
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在事件处理器中处理传感器数据
- en: When you receive data from a sensor, it will be attached to the JavaScript `this` object,
    so when you create a callback for the event handler, do not use the arrow syntax,
    as you will lose the bindings Johnny-Five places on the `this` object in JavaScript.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从传感器接收数据时，它将被附加到JavaScript的`this`对象上，因此当你为事件处理器创建回调时，不要使用箭头语法，因为这样你会失去Johnny-Five在JavaScript的`this`对象上设置的绑定。
- en: 'Here''s an example of a generic data handler for a `change` event on a Johnny-Five
    sensor:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个Johnny-Five传感器上`change`事件的通用数据处理器示例：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we've established how we'll get the data, let's talk about what the
    data will look like and how we can manipulate it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了如何获取数据，让我们谈谈数据将是什么样子以及我们如何可以操作它。
- en: Using and formatting Johnny-Five sensor data
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用和格式化Johnny-Five传感器数据
- en: 'There are many ways to receive the data sent from a sensor in Johnny-Five,
    as you can see by the documentation shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Johnny-Five中接收传感器发送的数据有很多种方法，正如以下截图所示的文档所示：
- en: '![](img/19c05048-c270-424c-aad9-680bcd6674fa.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19c05048-c270-424c-aad9-680bcd6674fa.png)'
- en: 'Boolean, raw, analog, constrained, and value can leave you with a lot to process.
    What each one means is shown in the preceding diagram, however take note that
    there is a good reason the default value is the same as analog: a scaled reading
    between `0` and `255`. It has a lot to do with the variety of sensors available,
    the varying granularities of data, and using scaling to make sure you only have
    to keep one number range in mind, regardless of how many sensors you are using.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值、原始值、模拟值、约束值和值可能会让你有很多要处理的数据。每个值的意义在前面的图中都有展示，然而请注意，默认值与模拟值相同的原因：一个介于`0`和`255`之间的缩放读取值。这与可用的传感器种类、数据的粒度变化以及使用缩放以确保你只需要记住一个数字范围有很大关系，无论你使用多少个传感器。
- en: Using .scaleTo() and .fscaleTo() to fine-tune measurements
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.scaleTo()和.fscaleTo()来微调测量值
- en: 'If you''d like to impose an arbitrary scale on your sensor (say `0` – `100`
    for percentage), you have some options built into the Johnny-Five API: `.scaleTo()`
    and `.fscaleTo()`. These will scale the raw value from the sensor to match the
    min and max values you pass in:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要对你的传感器施加一个任意的比例（比如`0` – `100`表示百分比），Johnny-Five API中内置了一些选项：`.scaleTo()`和`.fscaleTo()`。这些选项会将传感器的原始值缩放到你传入的最小值和最大值：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we know how to handle the data, let's start on our night-light by creating
    code to print the light-sensor values to the command line. This will also allow
    us to tweak the change threshold setting and determine what value of the light
    sensor we should use as an indicator to turn our LED off and on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何处理数据，让我们开始创建代码来将光传感器值打印到命令行。这将允许我们调整变化阈值设置，并确定我们应该使用哪个光传感器值作为指示器来打开和关闭我们的LED。
- en: Printing sensor data to the command line
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将传感器数据打印到命令行
- en: 'To print data from our sensor to the command line, we''ll use the code in `print-light-sensor.js`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要将传感器数据打印到命令行，我们将使用`print-light-sensor.js`中的代码：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your output on run should look something like this, with the numbers varying
    when you cover or shine light onto the sensor:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时的输出应该看起来像这样，数字在覆盖或照射传感器时会有所变化：
- en: '![](img/e2e2b978-5c46-402b-94b2-c68616aec74e.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2e2b978-5c46-402b-94b2-c68616aec74e.png)'
- en: This is nice, but a little hard to comprehend. What we'll do next is add in
    the `npm` module `barcli` to show a nice bar graph that allows us to comprehend
    in real time the data we're seeing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但有点难以理解。接下来，我们将添加`npm`模块`barcli`来显示一个漂亮的条形图，使我们能够实时理解我们看到的数据。
- en: Using barcli to make the data easier to see
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用barcli使数据更容易观察
- en: That data stream can be hard to process! Let's take a look at leveraging the
    power of Node.js to make this easier to see.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那个数据流可能很难处理！让我们看看如何利用Node.js的强大功能使这个过程更容易观察。
- en: 'In your `project` folder, run:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`project`文件夹中运行：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To install `barcli`, a library that creates bar graphs in the Terminal.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`barcli`，这是一个在终端中创建条形图的库。
- en: Reading the `barcli` documentation (see *Further reading*), we'll need to import
    `barcli`, construct a `barcli` object with the settings we need, then tell when
    to update and with what data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读关于`barcli`的文档（见*进一步阅读*），我们需要导入`barcli`，使用我们需要的设置构造一个`barcli`对象，然后告诉何时更新以及使用什么数据。
- en: Importing barcli and constructing our barcli graph
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入barcli并构建我们的barcli图表
- en: 'To import `barcli`, at the top of your `print-light-sensor.js` file, following
    the other `require()` statements, add:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入`barcli`，在你的`print-light-sensor.js`文件顶部，在其他的`require()`语句之后，添加：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, in the `board.on(''ready'')` handler, we''ll add the bar graph constructor:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`board.on('ready')`处理程序中，我们将添加条形图构造函数：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Getting the bar graph to update
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取条形图更新
- en: 'Remove the `console.log()` line from the `lightSensor.on(''change'')` handler
    and replace it with:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从`lightSensor.on('change')`处理程序中删除`console.log()`行，并用以下内容替换：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then you''re ready to roll! Move the `project` folder over to the Pi, navigate
    to the folder in your Pi SSH session, and run:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你就可以开始了！将`project`文件夹移动到Pi上，在Pi的SSH会话中导航到该文件夹，并运行：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To make sure that `barcli` is properly installed on the Pi, run the command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`barcli`在Pi上正确安装，运行以下命令：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see a bar graph now, shown as follows, that changes when you shine
    light on or cover the sensor:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到一个条形图，如下所示，当你在传感器上照射光线或遮住传感器时，它会改变：
- en: '![](img/7b680808-4d11-4c56-b112-81b666c9bfda.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b680808-4d11-4c56-b112-81b666c9bfda.png)'
- en: Now, for our night-light project, you'll want to find a value for the light
    sensor that we will use to turn the LED on and off; `barcli` makes this much easier
    by making that value much easier to see.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们的夜灯项目，你需要找到一个用于控制LED开关的光传感器值；`barcli`通过使该值更容易看到，使这个过程变得容易得多。
- en: Once you've got the value that works for you (I settled on `25`), we're ready
    to build our night-light.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了适合你的值（我选择了`25`），我们就准备好构建我们的夜灯了。
- en: Creating our night-light
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的夜灯
- en: Now that we know our light sensor works, we can add an LED and create our night-light.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们的光传感器工作正常，我们可以添加一个LED并创建我们的夜灯。
- en: Wiring up the LED
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接LED
- en: 'Connect the short leg of your LED to a ground rail using a 330K ohm resistor,
    and wire the long leg to GPIO #5, also known as P1-29:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '使用一个330K欧姆电阻将你的LED的短腿连接到地轨，并将长腿连接到GPIO #5，也称为P1-29：'
- en: '![](img/419275ca-1a2e-46dc-8099-bdfd3405f453.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/419275ca-1a2e-46dc-8099-bdfd3405f453.png)'
- en: Coding this project
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码这个项目
- en: Create a file in the same folder as the other files from this chapter, and copy
    the contents of `print-light-sensor-readings.js` into it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在与本章其他文件相同的文件夹中创建一个文件，并将`print-light-sensor-readings.js`的内容复制到其中。
- en: 'In the start of the `board.on(''ready'')` handler, add a constructor for our
    LED:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`board.on('ready')`处理程序的开始处，添加我们的LED构造函数：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And in the `lightSensor.on(''change'')` function, replace the `console.log`
    statement with the logic that will turn the LED on and off:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lightSensor.on('change')`函数中，将`console.log`语句替换为将LED开关的逻辑：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And we''re ready to run! Load the folder onto your Pi, navigate to the folder
    in your Pi''s SSH session, and run:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了运行！将文件夹加载到你的Pi上，在Pi的SSH会话中导航到该文件夹，并运行：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you cover the light sensor with your thumb, the LED should light up, as
    shown in the following image:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用大拇指遮住光传感器时，LED应该亮起，如下面的图片所示：
- en: '![](img/1a0b501d-17db-4c6c-92c7-6c77f6a3a8af.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a0b501d-17db-4c6c-92c7-6c77f6a3a8af.png)'
- en: 'And when you remove your thumb (in a well-lit room), the LED will turn off,
    as shown in the following image:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移开你的大拇指（在一个明亮的环境中），LED将关闭，如下面的图片所示：
- en: '![](img/ba983d0e-e9c4-41e4-8477-b24f5d9feb18.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba983d0e-e9c4-41e4-8477-b24f5d9feb18.png)'
- en: And with that, you have successfully coded and built your night-light!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你已经成功编码并构建了你的夜灯！
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about analog sensors and the limitations of the
    Pi for analog input. We learned about digital interfaces that allow us to collect
    analog data in Pi projects. We used this knowledge to set up a light sensor, with
    bar graphs from `barcli` to find a good threshold for an LED to turn on and off.
    Finally, we used all of this together to build a night light that illuminates
    in the dark and turns off in the light.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于模拟传感器和树莓派模拟输入的限制。我们学习了允许我们在树莓派项目中收集模拟数据的数字接口。我们使用这些知识来设置一个光传感器，使用`barcli`的条形图来找到一个好的阈值，使LED开关。最后，我们将所有这些结合起来，构建了一个在黑暗中照亮并在光亮时关闭的夜灯。
- en: Questions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an analog input sensor?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是模拟输入传感器？
- en: Why can't analog input sensors directly interface with the Raspberry Pi?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么模拟输入传感器不能直接与树莓派接口？
- en: Name two digital interfaces we can use with the Pi to collect analog data.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两种我们可以与Pi一起使用来收集模拟数据的数字接口。
- en: What two pins (besides power and ground) do I²C sensors need to operate?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了电源和地线之外，I²C传感器需要哪两个引脚才能运行？
- en: Name the events that a sensor object can fire.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出传感器对象可以触发的事件。
- en: Why is `barcli` helpful in processing changing sensor data?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`barcli`在处理变化中的传感器数据时很有帮助？
- en: Further reading
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**More information on analog inputs**: [https://learn.sparkfun.com/tutorials/analog-to-digital-conversion](https://learn.sparkfun.com/tutorials/analog-to-digital-conversion)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于模拟输入的更多信息**：[https://learn.sparkfun.com/tutorials/analog-to-digital-conversion](https://learn.sparkfun.com/tutorials/analog-to-digital-conversion)'
- en: '**More information on SPI**: [https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于SPI的更多信息**：[https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi)'
- en: '**More information on I²C**: [https://learn.sparkfun.com/tutorials/i2c](https://learn.sparkfun.com/tutorials/i2c)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于I²C的更多信息**：[https://learn.sparkfun.com/tutorials/i2c](https://learn.sparkfun.com/tutorials/i2c)'
- en: '**More information on using SPI and I²C with the Pi**: [https://learn.sparkfun.com/tutorials/raspberry-pi-spi-and-i2c-tutorial](https://learn.sparkfun.com/tutorials/raspberry-pi-spi-and-i2c-tutorial)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于在Pi上使用SPI和I²C的更多信息**：[https://learn.sparkfun.com/tutorials/raspberry-pi-spi-and-i2c-tutorial](https://learn.sparkfun.com/tutorials/raspberry-pi-spi-and-i2c-tutorial)'
