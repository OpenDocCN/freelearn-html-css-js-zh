- en: Testing Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的应用程序
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Testing components with Jest and Enzyme
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest和Enzyme测试组件
- en: Testing reducers and mappings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试reducers和映射
- en: Testing actions and thunks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试actions和thunks
- en: Testing changes with snapshots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用快照测试更改
- en: Measuring test coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量测试覆盖率
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we dealt with debugging. Now let's add some unit testing
    recipes to round out all we'll need for development. As we've seen before, having
    good unit testing helps not only with development, but also as a preventive tool
    to avoid regression bugs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们处理了调试。现在让我们添加一些单元测试配方，以满足我们开发所需的一切。正如我们以前所见，良好的单元测试不仅有助于开发，还可以作为预防工具，避免回归错误。
- en: Testing components with Jest and Enzyme
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest和Enzyme测试组件
- en: Back in [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and
    Debugging Your Server*, we did unit testing for our `Node` code, and we used `Jest`
    for it. As we said there, an advantage of this package is that we can also use
    it with `React` (or `React Native`, which we'll be looking at in [Chapter 11](c6b4a41a-3937-419b-8b75-2d6e96452702.xhtml),
    *Creating Mobile Apps with React Native*), so everything we learned about earlier
    in this book still holds; give it a quick look over if you will, so we won't have
    to repeat ourselves here.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)，*测试和调试您的服务器*，我们对`Node`代码进行了单元测试，并且我们使用了`Jest`。正如我们所说的，这个包的一个优点是我们也可以将其与`React`（或`React
    Native`一起使用，我们将在[第11章](c6b4a41a-3937-419b-8b75-2d6e96452702.xhtml)中查看*使用React
    Native创建移动应用程序*），所以我们之前在本书中学到的一切仍然有效；如果你愿意，快速浏览一下，这样我们就不必在这里重复了。
- en: What shall we test? Obviously, we'll have to write unit tests for our components,
    but since we've been using `Redux`, we'll also require tests for reducers, actions,
    and thunks; we'll cover all of these topics in this section and the following
    ones. Some of these tests will be quite simple to write, and for others, some
    more work will be needed. Let's get started, then!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该测试什么？显然，我们必须为我们的组件编写单元测试，但由于我们一直在使用`Redux`，我们还需要为reducers、actions和thunks编写测试；我们将在本节和接下来的节中涵盖所有这些主题。其中一些测试将非常简单，而其他一些则需要更多的工作。那么，让我们开始吧！
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For `Node`, we had to install `Jest` on our own, but `create-react-app` already
    does that for us, so it's one less thing to worry about. (If you created the `React`
    application on your own, by writing your own configuration files then you should
    take a look at [https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started)
    to see how to proceed.) We will, however, also use `Enzyme`, a package that will
    simplify making assertions about, or manipulating, the HTML that your components
    produce in a way that is quite similar to `jQuery`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Node`，我们必须自己安装`Jest`，但`create-react-app`已经为我们做了这件事，所以这是一件少了的事情需要担心。（如果你自己创建了`React`应用程序，通过编写自己的配置文件，那么你应该看一下[https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started)来了解如何继续。）然而，我们还将使用`Enzyme`，这是一个可以简化对组件生成的HTML进行断言或操作的包，这与`jQuery`非常相似。
- en: If you want to learn more about these functions, or if you haven't used `jQuery`
    for a while (my own case!), read about `cheerio`, the package that's used by `Enzyme`,
    at [https://github.com/cheeriojs/cheerio](https://github.com/cheeriojs/cheerio).
    For `Enzyme` itself, including its configuration, you can visit its GitHub site
    at [https://github.com/airbnb/enzyme](https://github.com/airbnb/enzyme).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于这些功能，或者如果你有一段时间没有使用`jQuery`了（就像我自己一样！），请阅读有关`cheerio`的信息，这是`Enzyme`使用的包，网址是[https://github.com/cheeriojs/cheerio](https://github.com/cheeriojs/cheerio)。关于`Enzyme`本身，包括其配置，你可以访问其GitHub网站[https://github.com/airbnb/enzyme](https://github.com/airbnb/enzyme)。
- en: 'Since we are using version 16 of `React`, the current way to install the package
    is as follows; the `enzyme-adapter-react-16` additional package is needed to link
    `Enzyme` with `React`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是`React`的16版本，安装该包的当前方式如下；需要`enzyme-adapter-react-16`附加包来将`Enzyme`与`React`链接起来：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another nice thing is that we won''t need to do any particular configuration,
    because `create-react-app` also takes care of setting everything up. However,
    should you decide that you need something special, `react-app-rewired` will help:
    check out [https://github.com/timarney/react-app-rewired](https://github.com/timarney/react-app-rewired)
    for more on that.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，我们不需要进行任何特殊配置，因为`create-react-app`也会负责设置一切。然而，如果你决定需要一些特殊的东西，`react-app-rewired`会帮助你：在[https://github.com/timarney/react-app-rewired](https://github.com/timarney/react-app-rewired)上查看更多信息。
- en: We have everything we need; let's get testing!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有一切所需的东西；让我们开始测试吧！
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: What components should we test? We have worked with connected and unconnected
    components already, but we'll focus on the latter here. Why? Connected components
    get their props and dispatch logic from the `mapStateToProps()` and `mapDispatchToProps()`
    functions; we can trust this is so, and therefore we don't actually have to test
    it. If you want, you could set up a store and verify that those two functions
    do their job—but those test are trivial to write, and I wouldn't suggest that
    you actually need them. Instead, we'll focus on the unconnected version of the
    components and fully test them. We'll set up all of the tests here, and then we'll
    look at how to run them, and what output to expect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该测试哪些组件？我们已经使用过连接和未连接的组件，但我们将在这里专注于后者。为什么？连接的组件从`mapStateToProps()`和`mapDispatchToProps()`函数中获取它们的props和dispatch逻辑；我们可以相信这是这样的，因此我们实际上不需要测试它。如果你愿意，你可以设置一个存储并验证这两个函数是否起作用，但这些测试很容易编写，我不建议你真的需要它们。相反，我们将专注于组件的未连接版本并对其进行全面测试。我们将在这里设置所有的测试，然后我们将看看如何运行它们，以及期望的输出是什么。
- en: Testing a component without events
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试没有事件的组件
- en: We want to test a component, so let's pick up a suitable one. For our first
    unit testing, let's work with the `<RegionsTable>` component, which didn't process
    any events; it was just a display component. Tests are usually named the same
    way as the component, but changing the extension from `.js` to `.test.js`—or to
    `.spec.js`, but I like `.test.js` better. Pick whatever you want, and just be
    consistent about it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测试一个组件，所以让我们选择一个合适的组件。对于我们的第一个单元测试，让我们使用`<RegionsTable>`组件，它没有处理任何事件；它只是一个显示组件。测试通常与组件同名，但将扩展名从`.js`改为`.test.js`——或者`.spec.js`，但我更喜欢`.test.js`。随便选，只要保持一致。
- en: First, let's start by considering what should we test. The specification for
    our component says that it works differently depending on whether it receives
    an empty or non-empty list of countries. In the first case, we can test that the
    produced HTML text includes *No regions*, and in the second case, we should verify
    that all of the provided regions do appear in the output. Of course, you can think
    up more detailed, specific cases, but try not to make your tests too *brittle*,
    meaning that the slightest change in implementation will make your tests fail.
    The tests that I described may not cover all cases, but it's pretty certain that
    even if you were to implement the component in a different way, the tests should
    still be successful.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从考虑我们应该测试什么开始。我们组件的规范说明它的工作方式取决于它接收到的国家列表是空的还是非空的。在第一种情况下，我们可以测试生成的HTML文本是否包含*No
    regions*，在第二种情况下，我们应该验证提供的所有地区是否出现在输出中。当然，你可以想出更详细、更具体的情况，但尽量不要让你的测试太*脆弱*，意思是实现的细微变化会导致测试失败。我描述的测试可能并不涵盖所有情况，但几乎可以肯定，即使你以不同的方式实现组件，测试仍然应该成功。
- en: 'Starting out with the actual tests, all of them will start in a similar way:
    with us needing to import to necessary libraries, plus the component to test,
    and setting up `Enzyme` and its adapter. In the following code, I''ll highlight
    the related lines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 开始实际测试时，它们都会以类似的方式开始：我们需要导入必要的库，以及要测试的组件，并设置`Enzyme`及其适配器。在下面的代码中，我将突出显示相关的行：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Like we did earlier, we''ll start using `describe()` and `it()` to set up different
    test cases. To check the empty regions list case, we can just use a few lines
    of code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们将使用`describe()`和`it()`来设置不同的测试用例。要检查空地区列表的情况，我们只需要使用几行代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use `Enzyme.render()` to generate the DOM for our component, and the `.text()`
    method to generate a text version of it. With the latter, we just need to verify
    that the desired text appears so that the whole test is really short.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Enzyme.render()`来为我们的组件生成DOM，使用`.text()`方法生成其文本版本。通过后者，我们只需要验证所需的文本是否出现，因此整个测试非常简短。
- en: 'We also had a second use case, in which we provided a non-empty list of regions.
    The code is similar, but obviously longer; let''s check out the code first, and
    we''ll explain it after:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有第二个用例，其中我们提供了一个非空的地区列表。代码类似，但显然更长；让我们先看看代码，然后再解释它：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The logic is pretty similar: render the components, produce text, check that
    the right content is there. As we said, you could also verify if each region is
    within a `<li>` element, and if they have keys, and so on; keep in mind, however,
    what we wrote about brittle tests, and avoid over-specifying the tests, so that
    only one possible, specific, given implementation of the component could pass
    them!'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非常相似：渲染组件，生成文本，检查正确的内容是否存在。正如我们所说，你也可以验证每个地区是否在`<li>`元素内，以及它们是否有键等；然而，要记住我们关于脆弱测试的写法，并避免过度规定测试，以便只有一个可能的、特定的组件实现才能通过它们！
- en: Testing a component with events
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试带有事件的组件
- en: Now we want to test a component with events. For this, the `<CountrySelect>`
    component will come in handy, because it can process some events, and it will
    call some callbacks accordingly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要测试一个带有事件的组件。为此，`<CountrySelect>`组件会很方便，因为它可以处理一些事件，并且会相应地调用一些回调函数。
- en: 'First of all, let''s see the initial setup, including a list of countries that
    we''ll be using for different tests:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下初始设置，包括我们将用于不同测试的国家列表：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, what cases will we write unit tests for? Let''s start with the case in
    which no list of countries is given: according to what we wanted, in that case,
    the component would have to use a prop, such as `getCountries()`, to get the necessary
    data. We''ll use *spies* again (we saw them in the *Using spies* section of [Chapter
    5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and Debugging Your Server*)
    to simulate and test the necessary behavior:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为哪些情况编写单元测试？让我们从没有给出国家列表的情况开始：根据我们的要求，在这种情况下，组件将不得不使用一个属性，比如`getCountries()`，来获取必要的数据。我们将再次使用*spy*（我们在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)的*使用spy*部分中看到它们）来模拟和测试必要的行为：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are creating two spies: one for the `onSelect` event handler, and one to
    get the list of countries. Testing that the output of the component includes the
    `"Loading countries"` text is simple; let''s focus on the spies instead. We expect
    that the component should have called the function to get the list of countries
    (but only once!) and that the event handler should not have been called: the last
    two checks take care of this.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个spy：一个用于`onSelect`事件处理程序，一个用于获取国家列表。测试组件输出是否包含`"Loading countries"`文本很简单；让我们专注于spy。我们期望组件应该调用获取国家列表的函数（但只调用一次！），并且事件处理程序不应该被调用：最后两个检查就解决了这个问题。
- en: 'Now, what should happen if a list had been provided? We can write a similar
    test, and just verify, for a difference, that the component didn''t call the function
    to get the (already given) countries; I have highlighted the related code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果提供了一个国家列表，会发生什么？我们可以编写类似的测试，只是验证一个不同之处，即组件没有调用函数来获取（已经给出的）国家；我已经突出显示了相关代码：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given the tests we have already written, this part of the code should have
    been easy to understand: we have already seen similar tests before, so we don''t
    have anything new to explain here.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们已经编写的测试，这部分代码应该很容易理解：我们之前已经看到类似的测试，所以这里没有新的东西需要解释。
- en: 'Let''s get to the final, more interesting, situation: how do we simulate that
    the user selected something? For this, we''ll have to detect the `<select>` element
    within our `<CountrySelect>` component, and for that I decided to provide a name
    attribute: I changed a single line in the component''s original `render()` method
    and changed it from `<select onChange={this.onSelect}>` to `<select onChange={this.onSelect}
    name="selectCountry**"**>`, so that I have a way to get at the element. Of course,
    you could object to changing the original component code in any way, and you could
    also very correctly add that this makes the test somewhat brittler than before;
    should the component be re-coded in a different way, without using a `<select>`
    element, the test would automatically fail, and you''d be right. This is a judgment
    call as to how far to go in the tests, and what extra baggage is needed.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来到最终、更有趣的情况：我们如何模拟用户选择了某些东西？为此，我们将不得不检测`<CountrySelect>`组件中的`<select>`元素，为此我决定提供一个name属性：我在组件原始的`render()`方法中改变了一行，并将其从`<select
    onChange={this.onSelect}>`改为`<select onChange={this.onSelect} name="selectCountry**"**>`，这样我就有了一种方法来获取元素。当然，你可能会反对以任何方式改变原始组件代码，你也可以非常正确地指出，这使得测试比以前更加脆弱；如果组件以不同的方式重新编码，而不使用`<select>`元素，测试将自动失败，你是对的。这是一个关于测试到何种程度以及需要什么额外负担的判断。
- en: 'To finish our suite of tests, we want to verify that the correct event handler
    is called:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的测试套件，我们要验证正确的事件处理程序是否被调用：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have to use some DOM traversal to find the desired element, and then use
    `.simulate()` to fire an event. Since no actual event is really fired, we'll have
    to provide the values it would include, which in our case is `.target.value`.
    Then we can finish our test by verifying that the event handler was called once
    with the right value (`"UY"`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用一些DOM遍历来找到所需的元素，然后使用`.simulate()`来触发事件。由于实际上并没有真正触发任何事件，我们必须提供它可能包含的值，这在我们的情况下是`.target.value`。然后我们可以通过验证事件处理程序是否以正确的值（"UY"）被调用一次来完成我们的测试。
- en: We have written our component tests; let's see how they work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了组件测试；让我们看看它们是如何工作的。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Running the tests is simple: you just need to use `npm test`, in the same way
    that we did for `Node`, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试很简单：您只需要使用`npm test`，就像我们为`Node`做的那样：
- en: '![](img/2bc5d279-3ef0-42a8-a616-4c933d5cfe2c.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bc5d279-3ef0-42a8-a616-4c933d5cfe2c.png)'
- en: The Jest output is in the same style as we saw for Node; the Snapshots total
    will be explained later
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Jest的输出与我们在Node中看到的样式相同；快照总数将在后面解释
- en: '`Jest` is set up to automatically watch for changes, so if you modify any file,
    testing will proceed again – the `q` command will stop the watch mode, and you''ll
    have to use `a` to run all tests, or `p` and `t` to filter some tests to run.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jest`被设置为自动监视更改，因此如果您修改任何文件，测试将再次进行 - `q`命令将停止监视模式，您将不得不使用`a`来运行所有测试，或者`p`和`t`来过滤一些要运行的测试。'
- en: We have now seen how to test components. However, some extra work is needed,
    because in our examples, we haven't dealt with any `Redux`-related matters, such
    as dispatching actions or thunks; let's move on to other kinds of tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何测试组件。然而，还需要一些额外的工作，因为在我们的示例中，我们还没有处理任何与`Redux`相关的事项，比如分发操作或thunks；让我们转向其他类型的测试。
- en: Testing reducers and mappings
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试reducers和映射
- en: 'After testing the components, we are now moving on to a simpler set of tests:
    first, reducers; and then mappings such as `mapStateToProps()` and `mapDispatchToProps()`.
    Why are these tests easier to write? Because in all of these cases, we are dealing
    with pure functions, without side effects, that produce their output based only
    on their inputs. We already dealt with these sort of functions earlier in this
    book when we did testing for Node, so now we''ll make do with a short section.
    The only particular care we''ll have is to verify that no function (for example,
    a reducer) attempts to modify the state, but other than that, it''s simple to
    test all the way. In this recipe, let''s look at the different kind of tests we''ll
    need for reducers and mappings.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试完组件之后，我们现在转向一个更简单的测试集：首先是reducers；然后是`mapStateToProps()`和`mapDispatchToProps()`等映射。为什么这些测试更容易编写？因为在所有这些情况下，我们都在处理纯函数，没有副作用，它们的输出仅基于它们的输入。我们在本书早期处理了这些类型的函数，当时我们为Node进行了测试，所以现在我们将用一个简短的部分来完成。我们唯一需要特别注意的是验证没有函数（例如reducer）试图修改状态，但除此之外，测试都很简单。在这个配方中，让我们看看我们为reducers和映射需要哪些不同类型的测试。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll have to test the reducers and mappings, so let's start by thinking about
    how you would test a reducer. There are two key things to verify: first, that
    given an input state, it produces a correct output state, and second, that the
    reducer doesn't modify the original state. The first condition is pretty obvious,
    but the second can easily be missed – and a reducer that modifies the current
    state can produce hard-to-find bugs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不测试reducers和映射，所以让我们首先考虑如何测试reducer。有两个关键的事情需要验证：首先，给定一个输入状态，它产生一个正确的输出状态，其次，reducer不修改原始状态。第一个条件是非常明显的，但第二个条件很容易被忽视
    - 修改当前状态的reducer可能会产生难以发现的错误。
- en: 'Let''s look at how we could test our countries and regions application''s reducer.
    First, since all tests are analog, we''ll just see a couple of them, for two of
    all the possible actions – but of course, you want to test *all* of the actions,
    right? We''ll also include another test to verify that for unknown actions, the
    reducer just returns the initial state, unchanged in every way:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何测试我们的国家和地区应用程序的reducer。首先，由于所有测试都是类似的，我们只会看到其中的一些，针对所有可能的操作中的两个 - 但当然，你想测试*所有*的操作，对吧？我们还将包括另一个测试，以验证对于未知操作，reducer只返回初始状态，以任何方式都不改变：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Are you wondering about `Enzyme`, and why we skipped it? We only need it when
    we are rendering components, so for testing reducers or actions (as we'll be doing
    soon), it's not required at all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否想知道`Enzyme`，以及为什么我们跳过它？我们只在渲染组件时才需要它，所以对于测试reducer或操作（正如我们很快将要做的那样），根本不需要它。
- en: 'Each test for the reducer will be the same, and follow these steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: reducer的每个测试都是相同的，并遵循以下步骤：
- en: Define an `initialState` and use `JSON.stringify()` to save its original string
    representation.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`initialState`并使用`JSON.stringify()`保存其原始字符串表示。
- en: Invoke the reducer and use `.toEqual()` (a `Jest` method that does deep, recursive,
    equality comparison between objects) to verify that the new state fully matches
    what you expect it to be.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用reducer并使用`.toEqual()`（一个`Jest`方法，它在对象之间进行深度、递归的相等比较）来验证新状态是否完全匹配您期望的状态。
- en: Check that the `initialState` JSON representation still matches the original
    value.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`initialState`的JSON表示是否仍然与原始值匹配。
- en: I used dummy values for countries and regions, but if you want to be even more
    careful, you could specify complete, correct values instead of things like `{
    something:2 }` or `"whatever"`; it's up to you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我为国家和地区使用了虚拟值，但如果您想更加小心，您可以指定完整、正确的值，而不是像`{ something:2 }`或`"whatever"`这样的值；这取决于您。
- en: You may want to take a look at `redux-testkit` at [https://github.com/wix/redux-testkit](https://github.com/wix/redux-testkit);
    this package can help you write reducer tests, automatically checking whether
    the state has been modified.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想看看`redux-testkit`在[https://github.com/wix/redux-testkit](https://github.com/wix/redux-testkit)；这个包可以帮助您编写reducer测试，自动检查状态是否已被修改。
- en: 'After writing these tests, it should be fairly obvious that writing a test
    for a mapping function is the same thing. For example, when we set up the `<ConnectedRegionsTable>`
    component, we wrote a `getProps()` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这些测试后，很明显为映射函数编写测试是相同的。例如，当我们设置`<ConnectedRegionsTable>`组件时，我们编写了一个`getProps()`函数：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We would have to export the function (we didn''t at the time, because it wasn''t
    going to be used elsewhere) and then a test could be performed, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须导出该函数（当时我们没有这样做，因为它不会在其他地方使用），然后可以执行测试，如下所示：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How does this work? Let's see what happens when we run these tests.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？让我们看看运行这些测试时会发生什么。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Using `npm test` will produce a nice *all green* output, meaning that all of
    the tests have passed, as in the previous section; no need to see that again.
    In each individual test, we apply the technique that was described earlier: set
    up state, save a string version of it, apply the reducer or the mapper function,
    check it matches what you wanted it to produce, and check that the original state
    still matches the saved version.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm test`将产生一个很好的*全部绿色*输出，这意味着所有测试都已通过，就像前一节一样；不需要再次看到。在每个单独的测试中，我们应用了之前描述的技术：设置状态，保存其字符串版本，应用reducer或mapper函数，检查它是否与您希望它产生的匹配，并检查原始状态是否仍然与保存的版本匹配。
- en: 'Imagine that somebody accidentally modified the `getProps()` function that
    we tested so that instead of returning the regions, it returned the countries
    list, like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，有人意外地修改了我们测试的`getProps()`函数，以便它返回地区而不是返回国家列表，如下所示：
- en: '![](img/2ebf4518-d321-4d02-8e10-d6b3d6077def.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ebf4518-d321-4d02-8e10-d6b3d6077def.png)'
- en: Any unexpected change in a mapping (or reducer) function would be detected by
    our usage of the .toEqual() method,
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`.toEqual()`方法检测到映射（或reducer）函数的任何意外更改，
- en: which does a deep comparison of the produced and expected values
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 进行产生和预期值的深度比较
- en: So, these simple tests can help you be safe against accidental changes – including
    the addition, removal, or modification of the expected values. This is a good
    safety net!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些简单的测试可以帮助您防止意外更改-包括预期值的添加、删除或修改。这是一个很好的安全网！
- en: Testing actions and thunks
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试操作和thunks
- en: To finish our testing goals, we have to look at how we can test actions and
    thunks. Testing the former is really trivial after everything we've done so far,
    because it's just a matter of calling an action creator and checking the fields
    on the produced action, but testing thunks, which will surely involve an asynchronous
    service call and will surely dispatch several – OK, that's interesting!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的测试目标，我们必须看看如何测试操作和thunks。测试前者在我们迄今为止所做的一切之后真的非常琐碎，因为只需要调用一个操作创建者并检查生成的操作上的字段，但是测试thunks，这肯定会涉及异步服务调用，并且肯定会分发几个-好吧，这很有趣！
- en: We'll skip the simpler action tests (though we'll get to test them, anyway,
    as you'll see) and we'll dive in directly to writing unit tests for our thunks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过更简单的操作测试（尽管我们将测试它们，正如您将看到的那样），并直接开始编写我们的thunks的单元测试。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A good tool that we''ll need here is `redux-mock-store`, a small package that
    lets us work with a fake store, aping all its functionality, and providing with
    some calls, such as `.getActions()`, to inspect which actions were dispatched,
    in what order, with which data, and so on. The installation is simple, as usual:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要的一个好工具是`redux-mock-store`，这是一个小包，让我们可以使用一个假存储，模仿其所有功能，并提供一些调用，比如`.getActions()`，以检查分发了哪些操作，以什么顺序，带有哪些数据等等。安装很简单，像往常一样：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may be wondering how we'll manage to mock the API service calls. Depending
    on your architecture, if you have thunks directly using things like `axios()`
    or `fetch()` to contact a service, then you will certainly need a corresponding
    mock package. However, since we spirited away those API calls in separate packages,
    we can do very well by mocking the whole call so that no AJAX calls will ever
    be done; we'll get to this soon.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道我们将如何管理模拟API服务调用。根据您的架构，如果您的thunks直接使用`axios()`或`fetch()`之类的东西来联系服务，那么您肯定需要相应的模拟包。但是，由于我们将这些API调用分离到单独的包中，我们可以通过模拟整个调用来很好地完成，以便不会进行任何AJAX调用；我们很快就会做到这一点。
- en: Check out the full documentation for `redux-mock-store` at its GitHub site,
    over at [https://github.com/dmitry-zaets/redux-mock-store](https://github.com/dmitry-zaets/redux-mock-store).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看`redux-mock-store`的完整文档，网址是 [https://github.com/dmitry-zaets/redux-mock-store](https://github.com/dmitry-zaets/redux-mock-store)。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We want to test actions. Let's take a look at how we can execute those tests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要测试动作。让我们看看如何执行这些测试。
- en: 'Since we''ve been working with our countries-and-regions example a lot, let''s
    finish by testing (at least some of) its actions and thunks: `getCountries()`
    is a good example, and quite similar to `getRegions()`. It will be good to remember
    that particular code here, so let''s take a look:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一直在大量使用我们的国家和地区示例，让我们通过测试（至少一部分）其动作和thunk来结束：`getCountries()`是一个很好的例子，而且与`getRegions()`非常相似。在这里，记住特定的代码将是很有帮助的，让我们来看一下：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To begin with, it dispatches an action to mark that a request is being done.
    Then it waits for the result of a web service call; this will require mocking!
    Finally, if the call was successful, an action is dispatched, including the received
    list of countries. On a failed call, a different action is dispatched, but showing
    the failure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它分发一个动作来标记正在进行的请求。然后，它等待网络服务调用的结果；这将需要模拟！最后，如果调用成功，将分发一个包括接收到的国家列表的动作。在失败的调用上，将分发一个不同的动作，但显示失败。
- en: 'Now let''s consider the following—how can we deal with the API call? The `world.actions.js`
    source code directly imports `getCountriesAPI()` from a module, but `Jest` has
    a feature just for that: we can mock a full module, providing mocks or spies for
    whichever functions we desire, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一下-我们如何处理API调用？`world.actions.js`源代码直接从一个模块中导入`getCountriesAPI()`，但是`Jest`专门为此提供了一个功能：我们可以模拟一个完整的模块，为我们想要的任何函数提供模拟或间谍，如下所示：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Whenever the `getCountries()` function calls `getCountriesAPI()`, our mocked
    module will be used and a promise (`mockPromise`) will be returned; it's up to
    us to appropriately decide what should that promise be, and we'll make that choice
    depending on whether we want a test to fail or succeed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`getCountries()`函数调用`getCountriesAPI()`时，我们的模拟模块将被使用，并且将返回一个承诺（`mockPromise`）；我们需要适当地决定这个承诺应该是什么，并且根据我们想要测试失败或成功来做出选择。
- en: Now that we have a way to intercept API calls and have them produce any result
    we want, we can move on to writing the actual tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了拦截API调用并使其产生我们想要的任何结果的方法，我们可以继续编写实际的测试。
- en: 'Let''s deal with the *happy path* first, in which the API call for countries
    is successful, with no problems. A test can be written in the following way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理*快乐路径*，在这种情况下，国家的API调用是成功的，没有问题。测试可以以以下方式编写：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How is this code structured?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结构是怎样的？
- en: We initially define some data (`fakeCountries`) that will be returned by our
    `mockPromise`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一些数据（`fakeCountries`），这些数据将由我们的`mockPromise`返回。
- en: Then we create a mock store, according to the `redux-mock-store` documentation;
    we are only using the `thunk` middleware in our case, but you may add more. In
    fact, in our original code, we followed `thunk` with `logger`, but that's not
    relevant for our testing.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，根据`redux-mock-store`的文档，我们创建了一个模拟商店；在我们的情况下，我们只使用了`thunk`中间件，但您可以添加更多。实际上，在我们的原始代码中，我们在`thunk`后面跟着`logger`，但这对我们的测试不相关。
- en: After that, we `store.dispatch()` the `getCountries()` thunk and await its results.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们`store.dispatch()`了`getCountries()` thunk并等待其结果。
- en: Once everything is done, we use `store.getActions()` to get the list of actions
    that were actually dispatched.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切都完成后，我们使用`store.getActions()`来获取实际分发的动作列表。
- en: We test that our `getCountriesAPI()` function was called; if it hasn't been,
    we'll be in deep trouble!
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试我们的`getCountriesAPI()`函数是否被调用；如果没有被调用，我们将陷入严重麻烦！
- en: Finally, we test all of the dispatched actions, checking their `type` and other
    attributes. This is, in fact, an indirect test on the action creators themselves!
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们测试了所有分发的动作，检查它们的`type`和其他属性。实际上，这是对动作创建者本身的间接测试！
- en: 'Now that we''ve looked at a successful case, let''s simulate that the API call
    somehow failed. To simulate this, all we have to do is define a different promise
    for the `getCountriesAPI()` call to return:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看过一个成功的案例，让我们假设API调用以某种方式失败了。为了模拟这一点，我们所要做的就是为`getCountriesAPI()`调用定义一个不同的承诺来返回：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What''s different in this case? Our `mockPromise` is now set to fail, so the
    tests for the second dispatched actions vary: in this case, instead of success
    and a list of countries, we just get a failure—but the rest of the test is essentially
    the same.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下有什么不同？我们的`mockPromise`现在设置为失败，因此第二个分发的动作的测试会有所不同：在这种情况下，我们只会得到一个失败，而不是成功和国家列表-但是测试的其余部分基本相同。
- en: 'Let''s finish with an extra case. When we coded our thunks, we saw that we
    could access the current state by means of a `getState()` function and act differently
    depending on its contents. We could have coded our `getCountries()` function to
    avoid doing an API call if the list of countries had already been obtained, for
    a small optimization; the key part would have been as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们完成一个额外的案例。当我们编写thunk时，我们发现我们可以通过`getState()`函数访问当前状态，并根据其内容采取不同的行动。我们本来可以编写我们的`getCountries()`函数，以避免在已经获得国家列表时进行API调用，以进行小优化；关键部分将如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'How could we test this case? The difference would be in how we set up the store,
    and what actions actually get dispatched:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何测试这种情况？不同之处在于我们如何设置商店，以及实际分发了哪些动作：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we set up the store, we can provide it with initial values, as in this
    case, in which we make believe that some countries (fake data!) are already loaded.
    A special requirement: we must use `jest.resetAllMocks()`, because otherwise we
    won''t be able to check that `getCountriesAPI()` wasn''t called – because it *was*
    called, but by the *previous* tests. Then, after dispatching the thunk, we just
    check that the API wasn''t called and that zero actions were dispatched: everything''s
    OK!'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置存储时，我们可以提供初始值，就像在这种情况下，我们假设一些国家（虚假数据！）已经被加载。一个特殊的要求：我们必须使用`jest.resetAllMocks()`，否则我们将无法检查`getCountriesAPI()`是否被调用
    - 因为它*被*调用了，但是由*之前*的测试调用的。然后，在分派thunk之后，我们只需检查API是否未被调用，并且未分派任何操作：一切正常！
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There isn''t much to running these tests, and `npm test` is all we need. We
    can see the results for both our tests (the original and the optimized `getCountries()`
    functions), and the passing result shows that everything is as expected. The output,
    when you run a single test, is more detailed, showing each individual test:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些测试并不复杂，只需要`npm test`。我们可以看到我们的两个测试的结果（原始和优化后的`getCountries()`函数），通过的结果表明一切都如预期那样。当您运行单个测试时，输出会更详细，显示每个单独的测试：
- en: '![](img/a944b54a-a57d-4e97-970b-323c4771c36d.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a944b54a-a57d-4e97-970b-323c4771c36d.png)'
- en: The tests for actions and thunks require a bit more setup, but run in the same
    way. We're getting a more detailed output because we're running a single test
    this time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于操作和thunk的测试需要更多的设置，但以相同的方式运行。这次我们运行单个测试，因此获得了更详细的输出。
- en: Testing changes with Snapshots
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用快照测试进行更改
- en: 'So far, we''ve been looking at automatic tests for components, events, and
    actions, so let''s end this chapter by considering a testing tool that isn''t
    really a part of TDD, but rather a safeguard against unwanted or unexpected changes
    after the fact: *snapshots*. (In TDD, tests would be written before coding the
    component, but you''ll see that this is impossible here.) Snapshot tests work
    like this: you render a UI component, capture what HTML was produced, and then
    that is compared to a reference capture that was previously stored. If both captures
    do not match, either somebody made an unexpected change or the change was actually
    expected. If this is the case, you''ll have to verify that the new capture is
    correct and then drop the old one.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在看组件、事件和操作的自动测试，因此让我们通过考虑一个测试工具来结束本章，这个测试工具并不真正是TDD的一部分，而是对事后不希望或不期望的更改的一种保障：*快照*。（在TDD中，测试将在编写组件代码之前编写，但您会看到这在这里是不可能的。）快照测试的工作方式如下：您渲染一个UI组件，捕获生成了什么HTML，然后将其与先前存储的参考捕获进行比较。如果两个捕获不匹配，要么有人做了意外的更改，要么更改实际上是预期的。如果是这种情况，您将不得不验证新的捕获是否正确，然后放弃旧的捕获。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can use snapshot testing for all of our components, but it''s more interesting
    for those whose output varies in terms of their props, so different behaviors
    are to be expected. We will be using a different way of rendering: instead of
    producing HTML elements, we''ll use renderers that produce text output that can
    be stored and compared in a easy way.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为所有组件使用快照测试，但对于那些在其属性方面变化的组件来说，这更有趣，因此可以预期不同的行为。我们将使用不同的渲染方式：而不是生成HTML元素，我们将使用生成文本输出的渲染器，这样可以轻松存储和比较。
- en: 'First, the simplest cases are for components with a standard, fixed kind of
    output. We have some examples of that: for our `<ClicksDisplay>` component, the
    test would be written as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最简单的情况是具有标准固定输出的组件。我们有一些例子：对于我们的`<ClicksDisplay>`组件，测试将写成如下形式：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Basically, we import the special `TestRenderer` renderer function, use it to
    produce output for our component, and then compare that with the stored snapshot;
    we''ll see how this looks soon. Tests are pretty much always the same: for our
    `<Counter>` component, the test code would be totally analog:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们导入特殊的`TestRenderer`渲染器函数，使用它为我们的组件生成输出，然后将其与存储的快照进行比较；我们很快就会看到这是什么样子。测试基本上总是相同的：对于我们的`<Counter>`组件，测试代码将是完全类似的：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The differences are minimal; it's just a matter of providing the correct expected
    props, and nothing more. Let's move on to more interesting cases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 差异很小；只需提供正确的预期属性，没有其他。让我们继续进行更有趣的案例。
- en: Should you have to render an object with prop values that cannot be predetermined
    (not the most likely case), you'll have to use special *Property Matchers*; you
    can read more about them at [https://jestjs.io/docs/en/snapshot-testing#property-matchers](https://jestjs.io/docs/en/snapshot-testing#property-matchers).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须使用无法预先确定的属性值来渲染对象（这不太可能），您将不得不使用特殊的*属性匹配器*；您可以在[https://jestjs.io/docs/en/snapshot-testing#property-matchers](https://jestjs.io/docs/en/snapshot-testing#property-matchers)了解更多信息。
- en: 'When you have components whose output varies depending on their props, snapshot
    tests become more interesting because they let you verify that different results
    are produced as expected. With our countries and regions code, we had these kind
    of cases: for example, the `<RegionsTable>` component was expected to display
    a list of regions (if any were provided) or a `"No regions"` text (if none were
    available). We should write these tests, then. Let''s proceed:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有组件的输出取决于其属性时，快照测试变得更有趣，因为它们可以让您验证不同的结果是否如预期那样产生。对于我们的国家和地区代码，我们有这样的情况：例如，`<RegionsTable>`组件预期显示区域列表（如果提供了），或者显示"没有区域"文本（如果没有可用的）。我们应该编写这些测试。让我们继续：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have two distinct cases, just like we described previously: one snapshot
    will match the *no regions* case, and the other will match what''s expected if
    some regions were given. For the `<CountrySelect>` component, the code would be
    similar:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种不同的情况，就像我们之前描述的那样：一个快照将匹配*没有区域*的情况，另一个将匹配如果提供了一些区域的预期情况。对于`<CountrySelect>`组件，代码将类似：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, testing components with more than one possible output isn't hard at all,
    and only requires you to write more than one snapshot test; a simple solution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试具有多个可能输出的组件并不难，只需要编写多个快照测试；一个简单的解决方案。
- en: 'Finally, in order to simplify tests, when you have components that themselves
    have more components, using shallow rendering helps concentrate on the main, high
    level aspects, and leave the details of the inner components'' rendering to other
    tests. We could whip up something like this, with an invented `<CountryAndRegions>`
    component that shows both our countries'' drop-down and regions table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了简化测试，当您的组件本身有更多的组件时，使用浅渲染有助于集中在主要的高级方面，并将内部组件的渲染细节留给其他测试。我们可以像这样快速创建一个虚构的`<CountryAndRegions>`组件，显示我们国家的下拉菜单和地区表：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the way to use the `ShallowRenderer` differs from the other renderer:
    you must create a new object, call its `.render()` method, and not use `.toJSON()`
    anymore. We''ll look at how this new test differs from the previous ones soon.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`ShallowRenderer`的方式与其他渲染器不同：您必须创建一个新对象，调用其`.render()`方法，而不再使用`.toJSON()`。我们将很快看一下这个新测试与以前的测试有何不同。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Running snapshots is no different from running other tests: you run the `Jest`
    test script, and all the tests run together.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行快照与运行其他测试没有什么不同：您运行`Jest`测试脚本，所有测试一起运行。
- en: Running the tests
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'If you run `npm test`, like we did earlier, you''ll now get an output similar
    to the following listing:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像之前一样运行`npm test`，您现在会得到类似以下清单的输出：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The only visible difference is that you get a specific count of snapshots (seven,
    in this case), but there's something more.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一可见的区别是您会得到特定数量的快照（在这种情况下为七个），但还有更多。
- en: The produced snapshot files
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成的快照文件
- en: 'If you check the source code directories, you''ll find some new `__snapshots__`
    directories, with some `.snap` files in it. For example, in the `/regionsApp`
    directory, you''d find this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查源代码目录，您会发现一些新的`__snapshots__`目录，其中包含一些`.snap`文件。例如，在`/regionsApp`目录中，您会发现这个：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For each `.test.js` file that includes snapshots, you''ll find a corresponding
    `.snap` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个包含快照的`.test.js`文件，您会找到一个相应的`.snap`文件：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The contents of those files show the snapshots that were taken at runtime.
    For example, the `countrySelect.test.js.snap` file includes the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的内容显示了运行时生成的快照。例如，`countrySelect.test.js.snap`文件包括以下代码：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can see the output for both our cases: one with a full list of countries,
    and another for when the countries were being loaded, waiting for the service
    response to arrive.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们两种情况的输出：一个是完整的国家列表，另一个是在加载国家时，等待服务响应到达时的情况。
- en: 'We can also see a shallow test in the `countryAndRegions.test.js.snap` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`countryAndRegions.test.js.snap`文件中看到一个浅层测试：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, note that the `<CountrySelect>` and `<RegionsTable>` components
    weren't expanded; this means that you are testing only the high level snapshot
    here, as desired.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，请注意`<CountrySelect>`和`<RegionsTable>`组件没有展开；这意味着您只在这里测试高级快照，这是期望的。
- en: Regenerating snapshots
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新生成快照
- en: 'What happens if a component has changed? Just for the sake of it, I made a
    pretty small change to a component. Upon running the tests, I got a FAIL message,
    with a comparison, that was produced by the usual `diff` command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件发生了变化会发生什么？仅仅为了这个目的，我对一个组件进行了一个非常小的更改。运行测试后，我收到了一个FAIL消息，附带了一个比较，这是由通常的`diff`命令生成的：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What should you do, then? You should first verify whether the change is correct
    or not, and in the former case, you could either delete the `.snap` file (so that
    it will get regenerated next time) or you can press `u`, as shown in the test
    summary:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您应该怎么做呢？您应该首先验证更改是否正确，如果是这样，您可以删除`.snap`文件（这样它将在下次重新生成），或者您可以按`u`键，如测试摘要中所示：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Be careful! If you just regenerate the snapshot without verifying that the output
    is correct, the tests will be worthless; a very bad result!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！如果您只是重新生成快照而没有验证输出是否正确，那么测试将毫无意义；这是一个非常糟糕的结果！
- en: Measuring test coverage
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量测试覆盖率
- en: We already saw how to get coverage for `Jest` tests back in the *Measuring your
    test coverage* section of [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server*, so in this recipe, we'll just go over some
    small changes that we'll be making to the test.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第5章](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml)的*测量测试覆盖率*部分看到了如何为`Jest`测试获取覆盖率，因此在这个示例中，我们将简要介绍一些我们将对测试进行的小改动。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We want to measure how thorough our testing is, so let''s look at the necessary
    steps. When working with `Node`, we directly invoked the `jest` command. Here,
    however, as the application was built by `create-react-app`, we''ll have to work
    a bit differently. We''ll have to add a new script to `package.json` that will
    invoke our tests with extra parameters:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要衡量我们的测试有多彻底，所以让我们看看必要的步骤。在使用`Node`时，我们直接调用了`jest`命令。然而，在这里，由于应用是由`create-react-app`构建的，我们将不得不以稍有不同的方式工作。我们将不得不向`package.json`添加一个新的脚本，以便用额外的参数调用我们的测试：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `--coverage` option will produce a coverage report, and also generate a
    `/coverage` directory, in the same way as with `Node`, and the `--no-cache` option
    will force Jest to regenerate all results instead of depending on previously,
    possibly no longer valid, cached values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`--coverage`选项将生成一个覆盖率报告，并生成一个`/coverage`目录，与`Node`一样，`--no-cache`选项将强制Jest重新生成所有结果，而不是依赖于先前可能不再有效的缓存值。'
- en: Our `.gitignore` file includes a line reading `/coverage`, so the generated
    files won't be pushed to the Git server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`.gitignore`文件包括一行内容为`/coverage`，因此生成的文件不会被推送到Git服务器。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you run `npm run coverage`, you'll get both a text output and a HTML one.
    The former looks like what's shown in the following screenshot; you'll have to
    accept that in reality, lines are colored green, yellow, or red, depending on
    the achieved degree of coverage.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`npm run coverage`，你将得到文本输出和HTML输出。前者看起来像下面截图中显示的内容；你必须接受现实中，行是绿色、黄色或红色的，取决于覆盖程度。
- en: In our case, we got quite a lot of red since we only wrote a few tests, instead
    of going for a full test suite; you may work on completing it on your own, as
    an *exercise for the reader*!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们得到了很多红色，因为我们只写了一些测试，而不是进行完整的测试套件；你可以自己完成它，作为读者的练习！
- en: '![](img/a0cb50fd-0796-45ee-8c26-ceb6372e87dc.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0cb50fd-0796-45ee-8c26-ceb6372e87dc.png)'
- en: The colored ASCII output shows the coverage evaluations for all of our source
    code files; green means good coverage, yellow a medium one,
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有色ASCII输出显示了我们所有源代码文件的覆盖评估；绿色表示良好的覆盖，黄色表示中等覆盖，
- en: and red means a poor result. Since we only wrote a few tests, we are getting
    plenty of red!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 红色表示结果不佳。由于我们只写了一些测试，我们得到了很多红色！
- en: 'If you open the `/coverage/lcov-report/index.html` file in a browser, you''ll
    get the same sort of result as in the `Node` chapter, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中打开`/coverage/lcov-report/index.html`文件，你会得到与`Node`章节中相同类型的结果，如下所示：
- en: '![](img/a01440be-90b8-4af6-9e6e-9b274b2b22d8.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a01440be-90b8-4af6-9e6e-9b274b2b22d8.png)'
- en: The HTML output lets you browse the directories and files of your project. If
    you click on a specific file, you can even see which lines and functions were
    executed, and which were skipped by your tests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: HTML输出允许您浏览项目的目录和文件。如果您点击特定文件，甚至可以看到哪些行和函数被执行，哪些被测试跳过。
- en: If you want, you can even use the `coverageThreshold` configuration object to
    specify coverage levels that must be reached, in order for the tests to be considered
    sufficient; see [https://jestjs.io/docs/en/configuration.html#coveragethreshold-object](https://jestjs.io/docs/en/configuration.html#coveragethreshold-object)
    for more on this.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，甚至可以使用`coverageThreshold`配置对象来指定必须达到的覆盖水平，以便测试被认为是足够的；有关更多信息，请参阅[https://jestjs.io/docs/en/configuration.html#coveragethreshold-object](https://jestjs.io/docs/en/configuration.html#coveragethreshold-object)。
- en: We have now finished working with `React` and `Redux`, we've looked at how to
    build web applications, and we've used our previously developed `Node` server
    backend. Let's move on to other types of development, starting with mobile applications,
    also with JS!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了与`React`和`Redux`的工作，我们已经看过了如何构建Web应用程序，并且使用了之前开发的`Node`服务器后端。让我们继续进行其他类型的开发，首先是移动应用程序，同样也是用JS！
