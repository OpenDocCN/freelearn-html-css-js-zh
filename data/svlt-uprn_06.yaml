- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Forms and Data Submission
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单和数据提交
- en: In the previous chapter, we went into some of the finer details behind loading
    data in SvelteKit. While loading data is important, it is equally important that
    we understand how to empower users to submit that data. That is why this chapter
    will explore some of the finer details behind forms and actions in SvelteKit.
    While not all applications *have* to accept data from users, the ones that do
    so in an intuitive manner tend to rise above the rest. After all, some of the
    best user experiences are taken for granted because they simply work. It’s when
    things break that users begin paying attention to them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了SvelteKit中加载数据的一些细节。虽然加载数据很重要，但同样重要的是我们要了解如何让用户提交数据。这就是为什么本章将探讨SvelteKit中表单和动作的一些细节。虽然并非所有应用程序都必须接受用户的数据，但那些以直观方式这样做的一般会脱颖而出。毕竟，一些最好的用户体验被认为是理所当然的，因为它们只是简单地工作。只有当事情出错时，用户才会开始关注它们。
- en: Throughout this chapter, we’ll learn how leveraging `<form>` elements can keep
    our application accessible and our code minimal. Integrating those forms with
    easily implemented actions lets us take the submitted data and process it accordingly.
    And finally, we’ll look at how we can soften some of the edges of the standard
    user experience surrounding forms by adding progressive enhancements. To do all
    of this, we’ll put the finishing touches on the login form we started previously.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何利用`<form>`元素来保持我们的应用程序的可访问性和代码的简洁性。将这些表单与易于实现的动作集成，使我们能够根据需要处理提交的数据。最后，我们将探讨如何通过添加渐进式增强来软化围绕表单的标准用户体验的一些边缘。为了完成所有这些，我们将对之前开始的登录表单进行最后的润色。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Form Setup
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单设置
- en: Analyzing Actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作分析
- en: Enhancing Forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高表单功能
- en: Upon completing this chapter, you should feel comfortable creating your very
    own login form, and you’ll know how to go forward and accept all types of data
    from users of your SvelteKit-based application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该能够轻松地创建自己的登录表单，并且你会知道如何继续前进并接受你基于SvelteKit的应用程序的用户的所有类型的数据。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter06](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter06).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter06](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter06)。
- en: Form Setup
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单设置
- en: We took a glance at using forms and actions together in [*Chapter 4*](B19024_04_Final_AM.xhtml#_idTextAnchor060).
    And while covering `RequestEvent` in the previous chapter, we began creating the
    code necessary to authenticate a user in our application with cookies. However,
    in that example, we never gave the user a means to provide a username or password.
    We also never created the cookie in the application. Instead, we opted to manually
    create one using the browser’s developer tools. It’s time we bring the whole thing
    together. Since we’ve covered the logic related to `load()`, as well as the details
    surrounding `RequestEvent`, we can continue building off of our previous example.
    A good place to start would be the login form itself. After all, we can’t log
    a user in without giving them a place to do so.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B19024_04_Final_AM.xhtml#_idTextAnchor060)中简要地看了如何一起使用表单和动作。虽然在上一章中涵盖了`RequestEvent`，我们开始创建必要的代码以使用cookie在我们的应用程序中验证用户。然而，在那个例子中，我们从未给用户提供提供用户名或密码的手段。我们也从未在应用程序中创建cookie。相反，我们选择使用浏览器的开发者工具手动创建一个。现在是时候将所有这些整合在一起了。由于我们已经涵盖了与`load()`相关的逻辑以及与`RequestEvent`相关的细节，我们可以继续构建之前的例子。一个不错的起点是登录表单本身。毕竟，如果没有提供一个地方让他们登录，我们就无法让用户登录。
- en: 'But before we create the form, let’s go ahead and add a link to the login page
    in our navigation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们创建表单之前，让我们先在我们的导航中添加一个指向登录页面的链接：
- en: src/lib/Nav.svelte
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib/Nav.svelte
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The change is as simple as copying an existing `<li>` element and replacing
    the route and text inside `<a>`. This will make navigating and testing our login
    functionality simpler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改就像复制一个现有的`<li>`元素，并替换`<a>`内的路由和文本一样简单。这将使导航和测试我们的登录功能变得更加简单。
- en: 'Next, let’s start with the actual form. Looking back at the file we created
    to show users a successful login based on their cookie, we’ll need to make several
    changes. Firstly, we’ll import the `enhance` module from `$app/forms`. We’ll discuss
    some of the magic behind this one later in this chapter, so don’t worry about
    it for now. Next, we’ll want to export the `form` variable so that we can signal
    to the user the status of their login. Finally, we’ll need to create the `<form>`
    element with appropriate inputs and give it some styling:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从实际的表单开始。回顾一下我们创建的用于根据用户的 cookie 显示成功登录的文件，我们需要进行一些修改。首先，我们将从 `$app/forms`
    中导入 `enhance` 模块。我们将在本章后面讨论这个背后的部分魔法，所以现在不用担心。接下来，我们将想要导出 `form` 变量，以便我们可以向用户指示他们的登录状态。最后，我们需要创建一个带有适当输入的
    `<form>` 元素，并给它一些样式：
- en: src/routes/login/+page.svelte
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/login/+page.svelte
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that you’ve seen the additions altogether, let’s discuss them. Aside from
    the new imports and exports, the next change you’ll notice is the Svelte directive
    checking whether or not `form?.msg` is set. If that is set, we display the message.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了所有的添加内容，让我们来讨论一下。除了新的导入和导出之外，您接下来会注意到的下一个变化是 Svelte 指令检查 `form?.msg`
    是否已设置。如果已设置，我们将显示该消息。
- en: data versus form
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据与表单
- en: The `form` prop comes to us from the data returned by our login action (which
    will be created in the next section). Remember that we include `export let data;`
    to get access to the data prop returned from `load()`. In the same vein, we include
    `export let form;` to retrieve data that has been returned by form actions. The
    data returned can also be retrieved anywhere in the application via the `$``page.form`
    store.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`form` 属性来自我们的登录操作返回的数据（将在下一节中创建）。记住，我们包含 `export let data;` 以获取 `load()` 返回的数据属性。同样，我们包含
    `export let form;` 以检索由表单操作返回的数据。返回的数据也可以通过应用程序中的 `$page.form` 存储在任何地方检索。'
- en: The next big change is the addition of the `<form>` element. It makes use of
    the `enhance` module we imported earlier, sets the HTTP method to POST, and sends
    its data to the `login` action located at `src/routes/login/+page.server.js`.
    We *must set the HTTP method to POST*; otherwise, our form will attempt to submit
    data via a GET request, and we don’t want to be sending passwords around insecurely.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重大变化是添加了 `<form>` 元素。它使用了我们之前导入的 `enhance` 模块，将 HTTP 方法设置为 POST，并将数据发送到位于
    `src/routes/login/+page.server.js` 的 `login` 操作。我们必须将 HTTP 方法设置为 POST；否则，我们的表单将尝试通过
    GET 请求提交数据，我们不希望在不安全的情况下发送密码。
- en: We’ve then included the appropriate markup for inputs, labels, and buttons.
    For now, we’re only referencing one form action to manage logging a user in. If
    we wanted to enable registration or password reset functionality and keep the
    subsequent actions in the same file as our login action, we could leverage the
    `formaction` property. However, `formaction` is intended to be used when you have
    multiple buttons referring to separate endpoints within the same `<form>` element.
    In a password reset scenario, we would likely need another `<form>` element specifying
    the email to send our password reset link. Likewise, with registration, we would
    probably need to obtain a user’s email, as well as their username and password,
    so having both of those within the context of a form that *only* accepts username
    and password details makes little sense. In each of these cases, it would make
    more sense to create a separate form for each of the features and specify the
    action directly on the `<form>` element. It may still make sense to keep logic
    concerning authentication in a single `+page.server.js` file for the sake of project
    organization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后包括了输入、标签和按钮的适当标记。目前，我们只引用了一个表单操作来管理用户的登录。如果我们想启用注册或密码重置功能，并保持后续操作与我们的登录操作在同一文件中，我们可以利用
    `formaction` 属性。然而，`formaction` 属性旨在用于您有多个按钮引用同一 `<form>` 元素内的不同端点时。在密码重置场景中，我们可能需要另一个
    `<form>` 元素来指定发送密码重置链接的电子邮件。同样，在注册的情况下，我们可能需要获取用户的电子邮件，以及他们的用户名和密码，因此在只接受用户名和密码详情的表单中包含这两者几乎没有意义。在这些情况下，为每个功能创建一个单独的表单并直接在
    `<form>` 元素上指定操作会更有意义。出于项目组织的目的，仍然可能有必要将有关身份验证的逻辑保持在单个 `+page.server.js` 文件中。
- en: The actual markup for creating a form is relatively straightforward to implement.
    We’ve just seen that we need to specify the method as well as the action to be
    called. And to obtain information returned from our action, we’ll need to include
    `export let form;` on the page while making use of data returned from the action.
    Now that you’ve seen a few variations of it, you should be comfortable creating
    forms to accept data from your users. Of course, a form doesn’t do much good if
    we don’t make use of the submitted data. In the next section, we’ll create an
    action to handle the data collected by the form. To ensure our action works smoothly,
    we’ll need to set up a database and discuss some security best practices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表单的实际标记相对简单易行。我们刚刚看到，我们需要指定方法以及要调用的动作。为了获取从我们的动作返回的信息，我们需要在页面上包含`export let
    form;`并利用从动作返回的数据。现在你已经看到了它的几种变体，你应该能够轻松地创建表单以从用户那里获取数据。当然，如果我们不利用提交的数据，表单就没有什么用处。在下一节中，我们将创建一个动作来处理表单收集的数据。为了确保我们的动作能够顺利工作，我们需要设置一个数据库并讨论一些安全最佳实践。
- en: Analyzing Actions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析动作
- en: 'In [*Chapter 4*](B19024_04_Final_AM.xhtml#_idTextAnchor060), we spent a section
    looking at how actions worked. Now, it’s time that we took a closer look at them
    and how they work under the hood. But before we begin, we’ll need to set up another
    fake database and briefly discuss security. Once we’ve done that, we’ll finish
    adding logic to our application and authenticate valid users. This section will
    cover the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B19024_04_Final_AM.xhtml#_idTextAnchor060)中，我们花了一部分时间来探讨动作是如何工作的。现在，是时候更深入地研究它们以及它们在底层是如何工作的了。但在我们开始之前，我们需要设置另一个模拟数据库并简要讨论安全问题。一旦我们完成这些，我们将完成向我们的应用程序添加逻辑并验证有效用户的工作。本节将涵盖以下内容：
- en: Database setup
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库设置
- en: Passwords and security
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码和安全
- en: Login action
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录动作
- en: After all of this, you’ll have a general understanding of how to finally create
    a login form for your own SvelteKit application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些，你将大致了解如何最终为你的SvelteKit应用程序创建一个登录表单。
- en: Database setup
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库设置
- en: 'Of course, this isn’t a real database. We’re going to utilize yet another JSON
    file that will store our user data and help us simulate looking up a user and
    their hashed password. It should look something like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是一个真正的数据库。我们将利用另一个JSON文件来存储我们的用户数据，并帮助我们模拟查找用户及其散列密码。它看起来应该像这样：
- en: src/lib/users.json
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib/users.json
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This file is a simple array containing two user objects and various properties
    related to our users. For this demonstration, the values of these properties are
    trivial, but the values of `identity` and `password` are of particular interest
    to us, as we will see in the next section. The `identity` property would normally
    correspond to a user session ID stored in another table. It should also utilize
    a unique identifier and not be easily guessable. If it were, anyone could authenticate
    to our application as any user by simply creating the identity cookie on their
    device with a valid session ID. In this example, `identity` makes use of the **Crypto
    Web API** to generate a random **Universally Unique Identifier** (**UUID**). The
    Crypto Web API should not be used for hashing passwords. For this demonstration,
    we’ll only be using it to create a UUID that will be saved in a cookie used to
    authenticate a user. For your testing purposes, the value could be any unique
    string, but this example aims to be relatively realistic. To keep this material
    from diverging too far from the directive of learning SvelteKit, this is all we’ll
    need to include for our fake user database.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是一个简单的数组，包含两个用户对象以及与我们的用户相关的各种属性。在这个演示中，这些属性的值是微不足道的，但`identity`和`password`的值对我们特别感兴趣，正如我们将在下一节中看到的。`identity`属性通常对应于存储在另一个表中的用户会话ID。它应该使用一个唯一的标识符，并且不容易被猜到。如果它很容易被猜到，任何人都可以通过在他们的设备上创建带有有效会话ID的标识符cookie来认证我们的应用程序作为任何用户。在这个例子中，`identity`使用了**Crypto
    Web API**来生成一个随机的**通用唯一标识符**（**UUID**）。不应该使用Crypto Web API进行密码散列。在这个演示中，我们只会用它来创建一个将被保存在用于认证用户的cookie中的UUID。为了测试目的，这个值可以是任何唯一的字符串，但这个例子旨在相对真实。为了使这些材料不偏离学习SvelteKit的指导方针，我们只需要包括这些内容来构建我们的模拟用户数据库。
- en: Passwords and Security
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码和安全
- en: Because authentication is such a common feature found in web applications, it
    would be a disservice to not further elaborate on how to properly implement it.
    And because when done improperly it can have such disastrous consequences, we’ll
    learn how to implement it securely. While we’re still not connecting to a real
    database and are instead storing our user passwords in a JSON file (which is highly
    advised against for anything other than demonstration purposes), we will observe
    how to properly hash passwords with another package installed via npm.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于身份验证是网络应用中非常常见的功能，如果不进一步阐述如何正确实现它，那就太不合适了。而且因为如果实现不当，可能会产生灾难性的后果，我们将学习如何安全地实现它。虽然我们目前还没有连接到真实的数据库，而是将用户密码存储在JSON文件中（除了演示目的之外，强烈建议不要这样做），但我们将观察如何使用另一个通过npm安装的包正确地哈希密码。
- en: 'To proceed further, we’ll need to install **bcrypt**. In your terminal, run
    the following command in the project directory:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续前进，我们需要安装**bcrypt**。在你的终端中，在项目目录中运行以下命令：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once this has been done, we can generate hashes with the following code. This
    code will only be temporary as it will give us a convenient way to generate the
    hashes for our passwords as well as UUIDs for the `identity` property of our user
    objects. These can then be added to your `users.json` file to simulate looking
    up a user password from a database. We’ll demonstrate login functionality to utilize
    it afterward:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以使用以下代码生成哈希。这段代码将是临时的，因为它将为我们提供一个方便的方法来生成密码的哈希以及用户对象`identity`属性的UUID。然后可以将这些添加到你的`users.json`文件中，模拟从数据库中查找用户密码。我们将在之后演示登录功能来利用它：
- en: src/routes/login/+page.server.js
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/login/+page.server.js
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `+page.server.js` file imports the `bcrypt` module we just installed with
    npm. It then creates the login action that our `<form>` element submits data to.
    It retrieves the form data submitted by the login form via the `crypto.randomUUID();`
    into the console of the developer tools. Upon navigating to `/login` in your browser,
    filling in the password field of the form, submitting it, and then opening the
    server console in your terminal, you will be able to copy the hash and the randomly
    generated UUID to the respective `password` and `identity` properties of each
    user in your `users.json`. In this way, you can create passwords for your users.
    If you’re using the code in this book’s GitHub repository, the hashes for each
    of the users were derived from the following strings:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`+page.server.js`文件导入了我们刚刚使用npm安装的`bcrypt`模块。然后它创建了一个登录操作，我们的`<form>`元素会将数据提交到这个操作。它通过`crypto.randomUUID();`从开发者工具的控制台检索登录表单提交的表单数据。当你在浏览器中导航到`/login`，填写表单的密码字段，提交它，然后在你的终端中打开服务器控制台时，你将能够将哈希和随机生成的UUID复制到每个用户的`users.json`文件中相应的`password`和`identity`属性中。这样，你就可以为你的用户创建密码。如果你正在使用本书GitHub仓库中的代码，每个用户的哈希都是从以下字符串派生出来的：
- en: '**password**'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**password**'
- en: '**jimmy**'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**jimmy**'
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It should go without saying but these are considered bad passwords. Under no
    circumstances should you ever attempt to use these passwords or their hashes outside
    of this demonstration.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，这些被认为是糟糕的密码。在任何情况下都不应该尝试使用这些密码或它们的哈希，除非是在这个演示中。
- en: While we’re on the subject of security, we should take this opportunity to note
    some practices to avoid. It’s important that we developers do not use *shared
    variables* to store sensitive data. To clarify, that doesn’t mean to not use variables
    to store sensitive data. Rather, we should avoid setting a variable in a form
    action that could then be available in `load()`. For a bad practice example, consider
    a developer declaring a variable for storing chat messages at the highest scope
    level of a `+page.server.js` file, assigning message data to it in a form action,
    and then returning the same variable in the same file’s `load()` function. Doing
    so would have the potential to allow user B to view the chat messages for user
    A. This spillover of data can be avoided by immediately returning the data to
    the page instead. These same guidelines also apply to Svelte stores. When managing
    data on the server, we should never set the state of a store as doing so on the
    server could potentially make it available to all users on that server.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论安全性的话题时，我们应该抓住这个机会指出一些应避免的做法。重要的是我们开发者不要使用*共享变量*来存储敏感数据。为了澄清，这并不意味着不能使用变量来存储敏感数据。相反，我们应该避免在表单操作中设置变量，这样变量随后可能会在`load()`函数中可用。以一个不良做法的例子来说，考虑一个开发者在一个`+page.server.js`文件的最高作用域级别声明一个变量来存储聊天消息，在表单操作中将消息数据赋值给它，然后在同一文件的`load()`函数中返回相同的变量。这样做可能会让用户B查看用户A的聊天消息。通过立即将数据返回到页面，可以避免这种数据泄露。这些相同的指南也适用于Svelte存储。在服务器上管理数据时，我们永远不应该设置存储的状态，因为在服务器上这样做可能会使所有该服务器上的用户都能访问到。
- en: Now that we know how to create hashed passwords and UUIDs, we can follow some
    basic best practices surrounding security. If you’re ever in doubt, consult the
    official SvelteKit documentation. As technologies change, so too can best practices.
    In the next section, we’ll see how can finally finish the login form by creating
    the action to tie it all together.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建哈希密码和UUID，我们可以遵循一些关于安全性的基本最佳实践。如果你有任何疑问，请查阅官方SvelteKit文档。随着技术的变化，最佳实践也可能随之改变。在下一节中，我们将看到如何通过创建一个将所有这些联系在一起的操作来最终完成登录表单。
- en: Login Action
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录操作
- en: After all of that setup, we’ve finally made it. We can now complete the action
    used by the form to log our user in and set a cookie in their browser. I’m sure
    you’re ready by now, so let’s dive into it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些设置之后，我们终于做到了。现在我们可以完成表单使用的操作来让我们的用户登录并在他们的浏览器中设置一个cookie。我相信你现在已经准备好了，让我们深入探讨吧。
- en: 'Previously in this file, we created some code to generate hashes for our passwords
    to test against. We can do away with that code and replace it with code that will
    look in our database for a matching username, check the provided password against
    the found user’s hashed password, and set a cookie on the user’s device:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们之前创建了一些代码来生成密码的哈希值以供测试。我们可以去掉这些代码，用代码替换它，该代码将在我们的数据库中查找匹配的用户名，将提供的密码与找到的用户哈希密码进行比较，并在用户的设备上设置一个cookie：
- en: src/routes/login/+page.server.js
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/login/+page.server.js
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this new version, we still import the `bcrypt` module but we’ve also added
    the import of `user.json`. We then added `cookies` to the destructured `RequestEvent`
    parameter. After setting up the `login` action, we get the data submitted by the
    `<form>` element and put it into the `form` constant. Next, we use `filter()`
    to check against the username of each element in the `users` array. Any matches
    are added to the `exists` constant. We then use `filter()` again to check the
    submitted password against the hashed password of every user in `exists`. If a
    match is found, it is added to the `auth` constant. If either `exists` or `auth`
    contains no items in their arrays, we return a message that the login attempt
    was invalid.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本中，我们仍然导入了`bcrypt`模块，但我们还添加了`user.json`的导入。然后我们向解构的`RequestEvent`参数中添加了`cookies`。在设置`login`操作后，我们获取由`<form>`元素提交的数据，并将其放入`form`常量中。接下来，我们使用`filter()`来检查`users`数组中每个元素的用户名。任何匹配项都被添加到`exists`常量中。然后我们再次使用`filter()`来检查提交的密码与`exists`中每个用户的哈希密码。如果找到匹配项，它将被添加到`auth`常量中。如果`exists`或`auth`的数组中没有项目，我们返回一条消息，表示登录尝试无效。
- en: Combatting account enumeration
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗账户枚举
- en: We should never return a message alerting the user that their username (or email)
    was correct but that the provided password failed. Doing so would allow malicious
    actors to enumerate valid accounts, essentially guessing usernames in quick succession.
    Once done, it becomes trivial for attackers to compile a list of valid usernames
    and begin brute-forcing passwords on real accounts. Since users are not well known
    for creating strong passwords, this could lead to account takeovers for multiple
    accounts. This is why we only return a message alerting the user that their login
    attempt failed. Whether or not their username or password was incorrect is for
    them to figure out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝不应该返回一个消息，告诉用户他们的用户名（或电子邮件）是正确的，但提供的密码失败了。这样做将允许恶意行为者枚举有效账户，本质上是在短时间内连续猜测用户名。一旦完成，攻击者就可以轻松地编制一个有效用户名的列表，并开始在真实账户上尝试暴力破解密码。由于用户并不以创建强密码而闻名，这可能导致多个账户的账户接管。这就是为什么我们只返回一个消息，告诉用户他们的登录尝试失败了。无论他们的用户名或密码是否正确，这是他们需要自己弄清楚的事情。
- en: If a user was successful in logging in, we use `cookies.set()` to send the `Set-Cookie`
    headers telling the client to set the `identity` cookie to the user’s session
    ID on the root directory of the domain. We must specify the root path in the options;
    otherwise, our cookie will default to only working at the highest level route
    where it was set – in this case, only on pages such as `/login`. You can imagine
    how frustrating that would be for users. We can then check whether the user is
    authorized to access functionality at various locations across the application.
    To remove the same cookie and log a user out, we could use `cookies.delete()`
    while passing in the name of the cookie, as well as our path.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户成功登录，我们使用`cookies.set()`发送`Set-Cookie`头部信息，告诉客户端将`identity`cookie设置为用户的会话ID，在域名的根目录下。我们必须在选项中指定根路径；否则，我们的cookie将默认只在设置的最高级别路由上工作——在这种情况下，仅在诸如`/login`之类的页面上工作。你可以想象这对用户来说是多么令人沮丧。然后我们可以检查用户是否有权访问应用程序中各个位置的功能。要删除相同的cookie并注销用户，我们可以使用`cookies.delete()`，同时传入cookie的名称以及我们的路径。
- en: 'Finally, to show users whether or not their login attempt was successful, we’ll
    need to make a couple of adjustments to our root server layout. If you recall,
    we previously only checked whether `identity === ''1''`. With a fake database
    implemented, we can instead check against our user’s JSON file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了向用户显示他们的登录尝试是否成功，我们需要对我们的根服务器布局进行一些调整。如果你还记得，我们之前只检查了`identity === '1'`。在实现了假数据库之后，我们可以改为与我们的用户JSON文件进行比对：
- en: src/routes/+layout.server.js
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/+layout.server.js
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since we need to check the `identity` cookie value against those that exist
    in `users.json`, we’ll need to import it first. We don’t need to change anything
    with the `data` constant yet, so we can leave the code related to notifications
    alone. We must then utilize `filter()` to find whether any users exist with the
    value obtained from the identity cookie and assign those found to the `exists`
    constant. If `exists` has values, we obtain the first one found and harness the
    power of a destructuring assignment to avoid passing the user's password into
    `data.user`. This is done to prevent including sensitive data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要将`identity`cookie的值与`users.json`中存在的值进行比对，我们首先需要导入它。目前我们不需要对`data`常量进行任何更改，因此我们可以保留与通知相关的代码。然后我们必须使用`filter()`来查找是否有任何用户具有从身份cookie获取的值，并将找到的这些用户分配给`exists`常量。如果`exists`有值，我们就获取第一个找到的值，并利用解构赋值的强大功能来避免将用户的密码传递给`data.user`。这样做是为了防止包含敏感数据。
- en: Now that we’ve put it all together, we can verify that the login works by navigating
    to `/login` in our browser and typing in the appropriate details. If you have
    created your own hashes, you’ll need to use the strings you provided to successfully
    authenticate. Upon submitting the form, we should be greeted by the status message,
    as well as the welcome message from `src/routes/login/+page.svelte`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有这些放在一起，我们可以通过在浏览器中导航到`/login`并输入适当的详细信息来验证登录是否正常工作。如果你创建了自定义的散列，你需要使用你提供的字符串来成功进行身份验证。提交表单后，我们应该看到状态消息，以及来自`src/routes/login/+page.svelte`的欢迎消息。
- en: To recap, in this section, we created a fake user database using a JSON file.
    We included our secure password hashes in that file to check against. When a username
    and password are submitted from the `<form>` element in `src/routes/login/+page.svelte`,
    that data is retrieved using the `src/routes/login/+page.server.js`. We then checked
    for the username as well as that user’s hashed password; if found, we send the
    `Set-Cookie` headers in our response by way of `cookies.set()` and send a *Success*
    status message. If a login attempt does not match a username or password, we return
    an *Invalid Login* status message. Now that we know how to create a form and submit
    our data to the appropriate actions, let’s examine some methods that can improve
    the user experience of our application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，在本节中，我们使用JSON文件创建了一个假的用户数据库。我们在该文件中包含了我们的安全密码散列以供检查。当从`src/routes/login/+page.svelte`中的`<form>`元素提交用户名和密码时，使用`src/routes/login/+page.server.js`检索这些数据。然后我们检查用户名以及该用户的散列密码；如果找到匹配项，我们通过`cookies.set()`发送响应中的`Set-Cookie`头，并发送一个*成功*状态消息。如果登录尝试与用户名或密码不匹配，我们返回一个*无效登录*状态消息。现在我们已经知道如何创建表单并将我们的数据提交到适当的操作，让我们来探讨一些可以改善我们应用程序用户体验的方法。
- en: Enhancing Forms
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强表单
- en: 'To reduce the friction inherent in forms on the web, SvelteKit provides us
    with a few options. We saw the first of those options earlier when we set `use:enhance`
    on our login form. This one is great for keeping the page from redirecting as
    it can submit the form data in the background, which means our page doesn’t need
    to be reloaded. Another tool we’ve yet to see is what SvelteKit calls **snapshots**.
    In this section, we’ll look at both and how they can help improve the experience
    of your application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少网页表单中固有的摩擦，SvelteKit为我们提供了一些选项。我们之前在设置登录表单的`use:enhance`时看到了这些选项中的第一个。这个选项非常适合防止页面重定向，因为它可以在后台提交表单数据，这意味着我们的页面不需要重新加载。我们还没有看到的是SvelteKit所说的**快照**。在本节中，我们将探讨这两个工具以及它们如何帮助改善您应用程序的体验：
- en: '`enhance`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enhance`'
- en: Snapshots
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照
- en: After completing this section, you’ll be capable of building forms for your
    users that will be intuitive and streamlined, leading to far greater chances of
    acceptance by users of your application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本节后，您将能够构建出直观且流畅的表单供您的用户使用，这将大大增加用户接受您应用程序的可能性。
- en: enhance
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: enhance
- en: By importing `enhance` from `$app/forms`, we can progressively enhance the flow
    of `<form>` elements. This means that we can submit the data without requiring
    a page reload, which would normally be found when submitting an `<form>` element.
    We’ve seen this action a couple of times now but in both cases we never discussed
    how it works.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`$app/forms`导入`enhance`，我们可以逐步增强`<form>`元素的处理流程。这意味着我们可以在不要求页面重新加载的情况下提交数据，这在提交`<form>`元素时通常是必须的。我们已经看到这个动作出现了几次，但在两种情况下我们都没有讨论它是如何工作的。
- en: The first step that’s taken by `enhance` is updating the `form` property. We
    were able to observe this with the Svelte directive located in `src/routes/login/+page.svelte`,
    which checks whether `form?.msg` is set. Because Svelte is reactive, when `enhance`
    updates `form`, we can immediately view the change and display our message. `enhance`
    will also update `$page.form` and `$page.status`, which are both properties of
    the Svelte `$page` store. This store gives us information about the currently
    displayed page. `$page.form` will contain the same data returned from the form
    action, whereas `$page.status` will contain HTTP status code data. We first saw
    an example of the `$page` store used in the *Dynamic routing* section of [*Chapter
    4*](B19024_04_Final_AM.xhtml#_idTextAnchor060).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`enhance`采取的第一步是更新`form`属性。我们通过位于`src/routes/login/+page.svelte`中的Svelte指令观察到这一点，该指令检查`form?.msg`是否已设置。由于Svelte是响应式的，当`enhance`更新`form`时，我们可以立即查看更改并显示我们的消息。`enhance`还会更新`$page.form`和`$page.status`，这两个都是Svelte
    `$page`存储的属性。这个存储提供了有关当前显示页面的信息。`$page.form`将包含来自表单操作的相同数据，而`$page.status`将包含HTTP状态码数据。我们第一次在[*第4章*](B19024_04_Final_AM.xhtml#_idTextAnchor060)的*动态路由*部分看到了`$page`存储的例子。'
- en: Upon receiving a successful response, `enhance` will reset the `<form>` element
    and force the appropriate `load()` functions to rerun by calling `invalidateAll()`.
    It will then resolve any redirects, render the nearest `+error.svelte` (if an
    error occurred), and reset the focus to the correct element as if the page was
    being loaded for the first time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到成功响应后，`enhance` 将重置 `<form>` 元素，并通过调用 `invalidateAll()` 强制适当的 `load()` 函数重新运行。然后，它将解析任何重定向，渲染最近的
    `+error.svelte`（如果发生错误），并将焦点重置到正确的元素，就像页面是第一次被加载一样。
- en: Should `enhance` be used on a `<form>` element with an action to an entirely
    different route, `enhance` `form` or `$page`. This is because it aims to emulate
    native browser behavior and submission of data across routes like this would normally
    trigger a page reload. To force it to update these properties, you will need to
    pass a callback function to `enhance`. The callback function can then use `applyAction`
    to update the stores accordingly. The `applyAction()` function accepts a SvelteKit
    `ActionResult` type and can also be imported from `$app/forms`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `enhance` 应用于具有指向完全不同路由的动作的 `<form>` 元素，`enhance` `form` 或 `$page`。这是因为它的目的是模拟原生浏览器行为，并且像这样跨路由提交数据通常会触发页面刷新。要强制更新这些属性，您需要传递一个回调函数给
    `enhance`。然后，回调函数可以使用 `applyAction` 来相应地更新存储。`applyAction()` 函数接受一个 SvelteKit
    `ActionResult` 类型，也可以从 `$app/forms` 中导入。
- en: Snapshots
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快照
- en: One commonly frustrating experience endured by users is caused by navigating
    away from a page after filling out a large form but before that form has been
    submitted. No matter the cause, losing data that took significant time to enter
    is painful.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 用户经常遇到的一种令人沮丧的经历是在填写完一个大型表单后，但在提交该表单之前离开页面。无论原因如何，丢失花费了大量时间输入的数据都是痛苦的。
- en: 'By persisting `<form>` data in a snapshot, we can make it easier for users
    to pick up where they left off. Fewer headaches for users means a better experience
    with our application. And implementing it is a breeze as we only need to export
    a `snapshot` constant with the `capture` and `restore` properties set. To see
    it in action, let’s persist the comment form data we built earlier:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在快照中持久化 `<form>` 数据，我们可以使用户更容易地继续他们离开的地方。用户头痛的减少意味着使用我们的应用程序的体验更好。而且实现起来非常简单，我们只需要导出一个带有
    `capture` 和 `restore` 属性设置的 `snapshot` 常量。要看到它的实际效果，让我们持久化我们之前构建的评论表单数据：
- en: src/routes/comment/+page.svelte
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/comment/+page.svelte
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this new version, we’ve only made three significant changes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新版本中，我们只做了三项重要的更改：
- en: Added `let comment = '';` so that we may capture and restore the input value
    to our JS.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了 `let comment = '';` 以便我们可以捕获并恢复到我们的 JS 中的输入值。
- en: 'Added the snapshot object with `export` `const snapshot`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了带有 `export` 的快照对象 `const snapshot`：
- en: The `capture` property calls an anonymous function just before the page updates
    when navigating away. This function only needs to return the values we wish to
    capture and restore later – in this case, the value associated with `comment`.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在导航离开页面之前更新页面时，`capture` 属性会调用一个匿名函数。这个函数只需要返回我们希望捕获并在稍后恢复的值——在这种情况下，与 `comment`
    相关的值。
- en: '`restore` is called immediately after the page is loaded and assigns the parameter
    it was called with to `comment`.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`restore` 在页面加载后立即调用，并将调用它的参数分配给 `comment`。'
- en: We bind the value of the comment’s `<text>` input to the `comment` variable
    so that the input’s value may be retrieved on capture and set on restore.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将评论的 `<text>` 输入的值绑定到 `comment` 变量，以便在捕获时检索输入的值，并在恢复时设置。
- en: Once you have implemented these changes, you can test them out by opening the
    `/comment` route in your browser, typing in a test comment, and navigating away
    to another page. When you click *Back* in your browser, you will observe the data
    that was restored just as you left it. Because snapshots persist the data they
    capture to Session Storage, you can open your browser developer tools and observe
    the data. In Firefox, you can find it under `/comment` page by clicking the link
    in the menu will not trigger a restore as it is considered navigating to a new
    page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这些更改后，您可以通过在浏览器中打开 `/comment` 路由，输入一个测试评论，然后导航到另一个页面来测试它们。当您在浏览器中点击 *后退* 时，您将观察到恢复的数据正如您离开时一样。因为快照将它们捕获的数据持久化到会话存储中，您可以通过打开浏览器开发者工具来观察这些数据。在
    Firefox 中，您可以通过点击菜单中的链接找到它，但不会触发恢复，因为它被视为导航到新页面。
- en: Knowing how to progressively and seamlessly enhance your forms can lead to an
    experience that will keep users coming back. By running form submissions in the
    background, we can make use of Svelte’s reactivity to provide immediate and useful
    feedback to users. And with the use of snapshots, we can preserve a user’s progress
    on simple or complex forms. With this knowledge, you can now go forth and build
    intuitive experiences into your applications.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何逐步且无缝地增强你的表单可以带来一个让用户不断回访的体验。通过在后台运行表单提交，我们可以利用 Svelte 的响应性为用户提供即时且有用的反馈。并且通过使用快照，我们可以保存用户在简单或复杂表单上的进度。有了这些知识，你现在可以着手将直观的体验构建到你的应用程序中。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by building a simple `<form>` element that accepts a
    username and password. On the same page component, we relayed the status of the
    authentication attempt back to the user. After this, we created a form action
    that looked up the username and compared the provided password with a hashed value.
    If successful, we logged the user in by setting a cookie on their device. If unsuccessful,
    we informed the user that their attempt had failed. We also briefly discussed
    some security best practices surrounding authenticating users with our application.
    We then examined how experiences with `<form>` elements can be improved by using
    `enhance` and snapshots. Having done all of this, we can be confident in any forms
    we implement in future SvelteKit projects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章开始时构建了一个简单的 `<form>` 元素，用于接受用户名和密码。在同一页面组件中，我们将身份验证尝试的状态反馈给用户。之后，我们创建了一个表单操作，用于查找用户名并比较提供的密码与哈希值。如果成功，我们在用户的设备上设置一个cookie来登录用户。如果失败，我们通知用户他们的尝试失败了。我们还简要讨论了围绕使用我们的应用程序对用户进行身份验证的一些安全最佳实践。然后我们考察了如何通过使用
    `enhance` 和快照来改进 `<form>` 元素的体验。完成所有这些后，我们可以对在未来的 SvelteKit 项目中实施的任何表单充满信心。
- en: With everything we’ve covered up until this point, you should be able to put
    together a basic website or application. In the next chapter, we’ll cover more
    advanced functionality that can truly showcase the power of building with SvelteKit.
    We will look at even more advanced routing concepts noting how they’ve made use
    of features we’ve already discussed and explaining some that have yet to be covered.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了所有内容，你应该能够构建一个基本的网站或应用程序。在下一章中，我们将介绍更多高级功能，这些功能可以真正展示使用 SvelteKit
    构建的力量。我们将探讨更高级的路由概念，指出它们是如何利用我们已经讨论过的功能，并解释一些尚未涉及的内容。
- en: Resources
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'The following are the resources for this chapter:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的资源：
- en: 'bcrypt: [https://github.com/kelektiv/node.bcrypt.js](https://github.com/kelektiv/node.bcrypt.js)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'bcrypt: [https://github.com/kelektiv/node.bcrypt.js](https://github.com/kelektiv/node.bcrypt.js)'
- en: 'Crypto Web API: [https://developer.mozilla.org/en-US/docs/Web/API/Crypto](https://developer.mozilla.org/en-US/docs/Web/API/Crypto)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Crypto Web API: [https://developer.mozilla.org/en-US/docs/Web/API/Crypto](https://developer.mozilla.org/en-US/docs/Web/API/Crypto)'
