- en: Chapter 8. SOLID Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. SOLID原则
- en: SOLID Principles are well-known Object-Oriented Design (**OOD**)principles summarized
    by Uncle Bob (Robert C. Martin). The word SOLID comes from the initials of the
    five principles it refers to, including **Single responsibility principle**, **Open-closed
    principle**, **Liskov substitution principle**, **Interface segregation principle**
    and **Dependency inversion principle**. Those principles are closely related to
    each other, and can be a great guidance in practice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是由Uncle Bob（罗伯特·C·马丁）总结的知名面向对象设计（**OOD**）原则。SOLID这个词来源于它所代表的五个原则的首字母缩写，包括**单一职责原则**、**开闭原则**、**里氏替换原则**、**接口隔离原则**和**依赖倒置原则**。这些原则彼此之间紧密相关，并在实践中可以提供很好的指导。
- en: 'Here is a widely used summary of SOLID principles from Uncle Bob:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Uncle Bob广泛使用的SOLID原则总结：
- en: '**Single responsibility principle**: A class should have one, and only one,
    reason to change'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**：一个类应该只有一个，且仅有一个改变的理由'
- en: '**Open-closed principle**: You should be able to extend a classes behavior,
    without modifying it'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**：你应该能够扩展一个类的行为，而不需要修改它'
- en: '**Liskov substitution principle**: Derived classes must be substitutable for
    their base classes'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**：派生类必须可替换其基类'
- en: '**Interface segregation principle**: Make fine-grained interfaces that are
    client specific'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**：创建细粒度的、特定于客户端的接口'
- en: '**Dependency inversion principle**: Depend on abstractions, not on concretions'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**：依赖于抽象，而不是具体实现'
- en: In this chapter, we will walk through them and find out how those principles
    can help form a design that *smells* nice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐一探讨这些原则，并了解这些原则如何帮助形成一个“闻起来”很好的设计。
- en: But before we proceed, I want to mention that a few of the reasons why those
    principles exist might be related to the age in which they were raised, the languages
    and their building or distributing process people were working with, and even
    computing resources. When being applied to JavaScript and TypeScript projects
    nowadays, some of the details may not be necessary. Think more about what problems
    those principles want to prevent people from getting into, rather than the literal
    descriptions of how a principle should be followed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们继续之前，我想提到，这些原则存在的一些原因可能与它们被提出时的时代、人们使用的语言以及他们的构建或分发过程有关，甚至与计算资源有关。当应用于当今的JavaScript和TypeScript项目时，其中的一些细节可能不是必要的。更多地思考这些原则想要防止人们陷入的问题，而不是一个原则应该如何遵循的直文字面描述。
- en: Single responsibility principle
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The single responsibility principle declares that a class should have one, and
    only one reason to change. And the definition of the world *reason* in this sentence
    is important.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则声明，一个类应该只有一个，且仅有一个改变的理由。在这句话中，“理由”这个词的定义很重要。
- en: Example
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider a `Command` class that is designed to work with both command-line
    interface and graphical user interface:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`Command`类，它被设计成可以与命令行界面和图形用户界面一起工作：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To make this actually work, `execute` method would need to handle both the
    command execution and result displaying:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这真正工作，`execute`方法需要处理命令执行和结果显示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, there are two reasons for changes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有两个改变的理由：
- en: How a command gets executed.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令是如何被执行的。
- en: How the result of a command gets displayed in different environments.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令的结果如何在不同的环境中显示。
- en: 'Those reasons lead to changes in different dimensions and violate the single
    responsibility principle. This might result in a messy situation over time. A
    better solution is to have those two responsibilities separated and managed by
    the `CommandEnvironment`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原因导致在不同维度上的变化，并违反了单一职责原则。这可能会导致随着时间的推移出现混乱的情况。更好的解决方案是将这两个职责分开，并由`CommandEnvironment`来管理：
- en: '![Example](img/image_08_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![示例](img/image_08_001.jpg)'
- en: Does this look familiar to you? Because it is a variant of the Visitor Pattern.
    Now it is the environment that executes a specific command and handles its result
    based on a concrete environment class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来熟悉吗？因为它是一种访问者模式的变体。现在，是环境在执行特定命令并基于具体环境类处理其结果。
- en: Choosing an axis
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一个轴
- en: You might be thinking, doesn't `CommandResult` violate the single responsibility
    principle by having the abilities to display content in a different environment?
    Yes, and no. When the axis of this reason is set to displaying content, it does
    not; but if the axis is set to displaying in a specific environment, it does.
    But take the overall structure into consideration, the result of a command is
    expected to be an output that can adapt to a different environment. And thus the
    reason is one-dimensional and confirms the principle.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，`CommandResult`不是通过在不同的环境中显示内容的能力而违反了单一职责原则吗？是的，也不是。当这个原因的轴线设置为显示内容时，它没有；但如果轴线设置为在特定环境中显示，它就做到了。但考虑到整体结构，命令的结果预期是一个可以适应不同环境的输出。因此，这个原因是单维的，并证实了这个原则。
- en: Open-closed principle
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: 'The open-closed principle declares that you should be able to extend a class''
    behavior, without modifying it. This principle is raised by Bertrand Meyer in
    1988:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 开放封闭原则声明，你应该能够扩展一个类的行为，而不需要修改它。这个原则是由Bertrand Meyer在1988年提出的：
- en: '*Software entities (classes, modules, functions, etc.) should be open for extension,
    but closed for modification.*'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*软件实体（类、模块、函数等）应该对扩展开放，但对修改封闭*。'
- en: 'A program depends on all the entities it uses, that means changing the already-being-used
    part of those entities may just crash the entire program. So the idea of the open-closed
    principle is straightforward: we''d better have entities that never change in
    any way other than extending itself.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序依赖于它所使用的所有实体，这意味着改变这些实体已经被使用的部分可能会使整个程序崩溃。因此，开放封闭原则的想法很简单：我们最好有那些除了自我扩展外不会以任何方式改变的实体。
- en: That means once a test is written and passing, ideally, it should never be changed
    for newly added features (and it needs to keep passing, of course). Again, ideally.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦编写并通过测试，理想情况下，它应该永远不会因为新添加的功能而改变（当然，它需要继续通过测试）。再次强调，理想情况下。
- en: Example
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: Consider an API hub that handles HTTP requests to and responses from the server.
    We are going to have several files written as modules, including `http-client.ts`,
    `hub.ts` and `app.ts` (but we won't actually write `http-client.ts` in this example,
    you will need to use some imagination).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个处理服务器请求和响应的API中心。我们将有几个以模块形式编写的文件，包括`http-client.ts`、`hub.ts`和`app.ts`（但在这个例子中，我们实际上不会编写`http-client.ts`，你需要发挥一些想象力）。
- en: Save the code below as file `hub.ts`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将下面的代码保存为文件`hub.ts`。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And save the code below as file `app.ts`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将下面的代码保存为文件`app.ts`。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Bravely done! Now we have `app.ts` badly coupled with `http-client.ts`. And
    if we want to adapt this API hub to something like WebSocket, BANG.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 勇敢地完成了！现在我们有了`app.ts`与`http-client.ts`严重耦合。如果我们想将这个API中心适配到像WebSocket这样的东西，BANG。
- en: So how can we create entities that are open for extension, but closed for modification?
    The key is a *stable abstraction that adapts*. Consider the storage and client
    example we took with Adapter Pattern in [Chapter 4](ch04.html "Chapter 4. Structural
    Design Patterns"), *Structural Design Patterns* we had a `Storage` interface that
    isolates implementation of database operations from the client. And assuming that
    the interface is well-designed to meet upcoming feature requirements, it is possible
    that it will never change or just need to be extended during the life cycle of
    the program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何创建那些对扩展开放但对修改封闭的实体呢？关键在于一个*稳定的抽象，能够适应变化*。考虑我们在[第4章](ch04.html "第4章。结构型设计模式")中使用的适配器模式示例，*结构型设计模式*中，我们有一个`Storage`接口，它将数据库操作的实现与客户端隔离开。假设该接口设计得很好，能够满足即将到来的功能需求，那么它可能永远不会改变，或者在整个程序生命周期中只需要扩展。
- en: Abstraction in JavaScript and TypeScript
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript和TypeScript中的抽象
- en: Guess what, our beloved JavaScript does not have an interface, and it is dynamically
    typed. We were not even able to actually write an interface. However, we could
    still write down documentation about the abstraction and create new concrete implementations
    just by obeying that description.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看，我们心爱的JavaScript没有接口，它是动态类型的。我们甚至无法实际编写一个接口。然而，我们仍然可以写下关于抽象的文档，并仅通过遵守该描述来创建新的具体实现。
- en: 'But TypeScript offers interface, and we can certainly take advantage of it.
    Consider the `CommandResult` class in the previous section. We were writing it
    as a concrete class, but it may have subclasses that override the `print` or `render`
    method for customized output. However, the type system in TypeScript cares only
    about the shape of a type. That means, while you are declaring an entity with
    type `CommandResult`, the entity does not need to be an instance of `CommandResult`:
    any object with a compatible type (namely has methods `print` and `render` with
    proper signatures in this case) will do the job.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但TypeScript提供了接口，我们当然可以利用它。考虑前一个章节中的`CommandResult`类。我们将其编写为一个具体类，但它可能有子类会覆盖`print`或`render`方法以实现定制输出。然而，TypeScript中的类型系统只关心类型的形状。这意味着，当你声明一个类型为`CommandResult`的实体时，该实体不需要是`CommandResult`的一个实例：任何具有兼容类型（在这种情况下即具有具有适当签名的`print`和`render`方法的任何对象）都可以完成这项工作。
- en: 'For example, the following code is valid:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码是有效的：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Refactor earlier
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 早期重构
- en: 'I double stressed that the open-closed principle can only be perfectly followed
    under ideal scenarios. That can be a result of two reasons:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次强调，开放封闭原则只有在理想情况下才能完美遵循。这可能有两个原因：
- en: '*Not all entities in a system can be open to extension and closed to modification
    at the same time*. There will always be changes that need to break the closure
    of existing entities to complete their functionalities. When we are designing
    the interfaces, we need different strategies for creating stable closures for
    different foreseeable situations. But this requires notable experience and no
    one can do it perfectly.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*并非系统中的所有实体都能同时开放于扩展而封闭于修改*。总会有需要打破现有实体封闭性以完成其功能性的变化。当我们设计接口时，我们需要针对不同可预见的情境采取不同的策略来创建稳定的封闭。但这需要显著的经验，而且没有人能做得完美。'
- en: '*None of us is too good at designing a program that lasts long and stays healthy
    forever*. Even with thorough consideration, abstractions designed at the beginning
    can be choppy facing the changing requirements.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*我们中没有谁是设计出持久且健康程序的高手*。即使经过深思熟虑，最初设计的抽象在面对不断变化的需求时也可能显得粗糙。'
- en: So when we are expecting the entities to be closed for modification, it does
    not mean that we should just stand there and watch it being closed. Instead, when
    things are still under control, we should refactor and *keep the abstraction in
    the status of being open to extension and closed to modification* at the time
    point of refactoring.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们期望实体对修改封闭时，并不意味着我们应该只是站在那里看着它被封闭。相反，当事情还在控制之下时，我们应该重构，并在重构时*保持抽象处于开放于扩展和封闭于修改的状态*。
- en: Liskov substitution principle
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: The open-closed principle is the essential principle of keeping code maintainable
    and reusable. And the key to the open-closed principle is abstraction with polymorphism.
    Behaviors like implementing interfaces, or extending classes make polymorphic
    *shapes*, but that might not be enough.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 开放封闭原则是保持代码可维护和可重用的基本原则。而开放封闭原则的关键在于抽象的多态性。像实现接口或扩展类这样的行为会形成多态的*形状*，但这可能还不够。
- en: 'The Liskov substitution principle declares that derived classes must be substitutable
    for their base classes. Or in the words of Barbara Liskov, who raised this principle:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Liskov替换原则声明，派生类必须可替换为其基类。或者用提出这一原则的Barbara Liskov的话说：
- en: '*What is wanted here is something like the following substitution property:
    If for each object o1 of type S there is an object o2 of type T such that for
    all programs P defined in terms of T, the behavior of P is unchanged when o1 is
    substituted for o2 then S is a subtype of T.*'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们想要的类似于以下替换属性：如果对于类型S的每个对象o1，都有一个类型T的对象o2，对于所有以T定义的程序P，当用o1替换o2时，P的行为保持不变，那么S是T的子类型*。'
- en: 'Never mind. Let''s try another one: *any foreseeable usage of the instance
    of a class should be working with the instances of its derived classes.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无关紧要。让我们再试一个：*任何可预见的类实例的使用都应该与该类的派生类的实例一起工作*。
- en: Example
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'And here we go with a straightforward violation example. Consider `Noodles`
    and `InstantNoodles` (a subclass of `Noodles`) to be cooked:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们用一个直接的违反示例来开始。考虑`Noodles`和`InstantNoodles`（`Noodles`的一个子类）被烹饪的情况：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now if we want to have some fried noodles... The `cookNoodles` function does
    not seem to be capable of handling that. Clearly, this violates the Liskov substitution
    principle, though it does not mean that it's a bad design.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们想要一些炒面... `cookNoodles`函数似乎无法处理这种情况。显然，这违反了Liskov替换原则，但这并不意味着它是一个糟糕的设计。
- en: 'Let''s consider another example written by Uncle Bob in his article talking
    about this principle. We are creating class `Square` which is a subclass of `Rectangle`,
    but instead of adding new features, it adds a constraint to `Rectangle`: the width
    and height of a square should always be equal to each other. Assume we have a
    `Rectangle` class that allows its width and height to be set:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑Uncle Bob在其关于此原则的文章中写的另一个例子。我们正在创建一个名为`Square`的类，它是`Rectangle`的子类，但不是添加新功能，而是给`Rectangle`添加了一个约束：正方形的宽度和高度应该始终相等。假设我们有一个允许设置宽度和高度的`Rectangle`类：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we have a problem with its subclass `Square`, because it gets `width` and
    `height` setters from `Rectangle` while it shouldn't. We can certainly override
    those setters and make both of them update width and height simultaneously. But
    in some situations, the client might just not want that, because doing so will
    make the program harder to be predicted.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们遇到了其子类`Square`的问题，因为它从`Rectangle`获得了`width`和`height`设置器，而它不应该这样做。我们当然可以覆盖这些设置器并使它们同时更新宽度和高度。但在某些情况下，客户端可能并不希望这样做，因为这样做会使程序更难预测。
- en: The `Square` and `Rectangle` example violates the Liskov substitution principle.
    Not because we didn't find a good way to inherit, but because `Square` does not
    conform the behavior of `Rectangle` and should not be a subclass of it at the
    beginning.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Square`和`Rectangle`示例违反了Liskov替换原则。不是因为我们没有找到一种好的继承方式，而是因为`Square`不符合`Rectangle`的行为，它一开始就不应该成为它的子类。'
- en: The constraints of substitution
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换约束
- en: Type is an important part in a programming language, even in JavaScript. But
    having the same *shape*, being on the same hierarchy does not mean they can be
    the substitution of another without some pain. More than just the *shape*, the
    complete behavior is what really matters for implementations that hold to the
    Liskov substitution principle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是编程语言中的一个重要部分，即使在JavaScript中也是如此。但拥有相同的*形状*，处于相同的层次结构并不意味着它们可以在不引起痛苦的情况下相互替换。不仅仅是*形状*，完整的行为了解Liskov替换原则所坚持的实现才是真正重要的。
- en: Interface segregation principle
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: We've already discussed the important role played by abstractions in object-oriented
    design. The abstractions and their derived classes without separation usually
    come up with hierarchical tree structures. That means when you choose to create
    a branch, you create a parallel abstraction to all of those on another branch.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了抽象在面向对象设计中所扮演的重要角色。通常，抽象及其未分离的派生类会形成层次树结构。这意味着当你选择创建一个分支时，你为另一个分支上的所有对象创建了一个并行抽象。
- en: 'For a family of classes with only one level of inheritance, this is not a problem:
    because it is just what you want to have those classes derived from. But for a
    hierarchy with greater depth, it could be.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只有一层继承的类族，这并不是问题：因为这正是你希望那些类从其派生出来的。但对于深度更大的层次结构，这可能会成为问题。
- en: Example
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider the `TextReader` example we took with Template Method Pattern in [Chapter
    6](ch06.html "Chapter 6. Behavioral Design Patterns: Continuous"), *Behavioral
    Design Patterns: Continuous* we had `FileAsciiTextReader` and `HttpAsciiTextReader`
    derived from `AsciiTextReader`. But what if we want to have other readers that
    understand UTF-8 encoding?'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在[第6章](ch06.html "第6章。行为设计模式：连续")中用到的`TextReader`示例，在[行为设计模式：连续](ch06.html
    "第6章。行为设计模式：连续")中，我们有`FileAsciiTextReader`和`HttpAsciiTextReader`从`AsciiTextReader`派生出来。但如果我们想要其他理解UTF-8编码的读取器怎么办？
- en: 'To achieve that goal, we have two common options: separate the interface into
    two for different objects that cooperate, or separate the interface into two then
    get them implemented by a single class.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们有两个常见的选择：将接口分离成两个，用于不同对象之间的协作，或者将接口分离成两个，然后由单个类实现。
- en: 'For the first case, we can refactor the code with two abstractions, `BytesReader`
    and `TextReader`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，我们可以通过两个抽象类`BytesReader`和`TextReader`来重构代码：
- en: '![Example](img/image_08_002.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![示例](img/image_08_002.jpg)'
- en: 'And for the second case, we can separate method `readAllBytes` and `decodeBytes`
    onto two interfaces, for example, `BytesReader` and `BytesDecoder`. Thus we may
    implement them separately and use techniques like mixin to put them together:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种情况，我们可以将`readAllBytes`和`decodeBytes`方法分离到两个接口上，例如，`BytesReader`和`BytesDecoder`。因此，我们可以分别实现它们，并使用混入等技术将它们组合在一起：
- en: '![Example](img/image_08_003.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![示例](img/image_08_003.jpg)'
- en: An interesting point about this example is that `TextReader` above itself is
    an abstract class. To make this mixin actually work, we need to create a concrete
    class of `TextReader` (without actually implementing `readAllBytes` and `decodeBytes`),
    and then mixin two concrete classes of `BytesReader` and `BytesDecoder`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个例子的一个有趣的观点是，上面的`TextReader`本身就是一个抽象类。为了使这个混入（mixin）真正工作，我们需要创建一个`TextReader`的具体类（实际上不需要实现`readAllBytes`和`decodeBytes`），然后混入两个`BytesReader`和`BytesDecoder`的具体类。
- en: Proper granularity
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合适的粒度
- en: It is said that by creating smaller interfaces, we can avoid a client from using
    big classes with features that it never needs. This may cause unnecessary usage
    of resources, but in practice, that usually won't be a problem. The most important
    part of the interface segregation principle is still about keeping code maintainable
    and reusable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 据说，通过创建更小的接口，我们可以避免客户端使用它不需要功能的庞大类。这可能会导致不必要的资源使用，但在实践中，这通常不会成为问题。接口分离原则最重要的部分仍然是关于保持代码的可维护性和可重用性。
- en: Then the question comes out again, how small should an interface be? I don't
    think I have a simple answer for that. But I am sure that being too small might
    not help.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后问题再次出现，接口应该有多小？我不认为我有一个简单的答案。但我确信，太小可能不会有所帮助。
- en: Dependency inversion principle
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: When we talk about dependencies, the natural sense is about dependencies from
    bottom to top, just like how buildings are built. But unlike a building that stands
    for tens of years with little change, software keeps changing during its life
    cycle. Every change costs, more or less.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论依赖时，自然的理解是从下到上的依赖，就像建筑物的建造过程一样。但与可以持续数十年几乎不变化的建筑物不同，软件在其生命周期中不断变化。每一次变化都有成本，或多或少。
- en: The dependency inversion principle declares that entities should depend on abstractions,
    not on concretions. Higher level code should not depend directly on low-level
    implementations, instead, it should depend on abstractions that *lead to* those
    implementations. And this is why things are *inverse*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则声明，实体应该依赖于抽象，而不是具体实现。高级代码不应该直接依赖于低级实现，而应该依赖于导致这些实现的抽象。这就是为什么它是“倒置”的。
- en: Example
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Still taking the HTTP client and API hub as an example, which obviously violates
    the dependency inversion principle, taking the foreseeable application into consideration,
    what the API hub should depend on is a messaging mechanism bridging client and
    server, but not bare HTTP client. This means we should have an abstraction layer
    of messaging before the concrete implementation of HTTP client:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然以HTTP客户端和API中心为例，这显然违反了依赖倒置原则，考虑到可预见的应用，API中心应该依赖于一个连接客户端和服务器的信息传递机制，而不是裸露的HTTP客户端。这意味着我们应该在HTTP客户端的具体实现之前有一个信息传递的抽象层：
- en: '![Example](img/image_08_004.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![示例](img/image_08_004.jpg)'
- en: Separating layers
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离层
- en: Compared to other principles discussed in this chapter, the dependency inversion
    principle cares more about the scope of modules or packages. As the abstraction
    might usually be more stable than concrete implementations, by following dependency
    inversion principle, we can minimize the impact from low-level changes to higher
    level behaviors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章讨论的其他原则相比，依赖倒置原则更关注模块或包的范围。由于抽象通常比具体实现更稳定，遵循依赖倒置原则，我们可以最小化低级变化对高级行为的影响。
- en: But for JavaScript (or TypeScript) projects as the language is dynamically typed,
    this principle is more about an idea of guidance that leads to a stable abstraction
    between different layers of code implementation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于JavaScript（或TypeScript）项目来说，由于语言是动态类型的，这个原则更多的是一种指导性的思想，它引导不同层代码实现之间形成稳定的抽象。
- en: Originally, an important benefit of following this principle is that, if modules
    or packages are relatively larger, separating them by abstraction could save a
    lot of time in compilation. But for JavaScript, we don't have to worry about that;
    and for TypeScript, we don't have to recompile the entire project for making changes
    to separated modules either.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，遵循这一原则的一个重要好处是，如果模块或包相对较大，通过抽象分离它们可以在编译过程中节省大量时间。但对于JavaScript，我们不必担心这一点；而对于TypeScript，我们也不必为了对分离的模块进行更改而重新编译整个项目。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked through the well-known SOLID principles with simple
    examples. Sometimes, following those principles could lead us to a useful design
    pattern. And we also found that those principles are strongly bound to each other.
    Usually violating one of them may indicate other violations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过简单的示例介绍了众所周知的SOLID原则。有时，遵循这些原则可能会引导我们到一个有用的设计模式。我们还发现，这些原则之间有着强烈的联系。通常，违反其中之一可能表明存在其他违规行为。
- en: Those principles could be extremely helpful for OOD, but could also be overkill
    if they are applied without proper adaptions. A well-designed system should have
    those principles confirmed just right, or it might harm.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则对于面向对象设计（OOD）可能非常有帮助，但如果应用不当，也可能过度。一个设计良好的系统应该恰好确认这些原则，否则可能会造成伤害。
- en: In the next chapter, instead of theories, we'll have more time with a complete
    workflow with testing and continuous integration involved.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将有更多时间来探讨一个完整的流程，其中包括测试和持续集成。
