- en: 13\. JavaScript Programming Paradigms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. JavaScript 编程范式
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to apply different JavaScript paradigms;
    use prototypes, inheritance, and anonymous functions; list different types of
    data scopes and closures; declare variables using hoisting; and explain JavaScript
    memory management.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够应用不同的 JavaScript 编程范式；使用原型、继承和匿名函数；列出不同类型的数据作用域和闭包；使用提升声明变量；并解释 JavaScript
    内存管理。
- en: In this chapter, we will dig deep into the core features of JavaScript that
    make it a very diverse and multi-paradigm programming language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨使 JavaScript 成为一个非常多样化和多范式编程语言的核心特性。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we know the importance of JavaScript at the browser level and its power
    at the server level. We have learned how to install Node.js on the system and
    how to write and execute code. Also, we have gained a huge amount of knowledge
    about the internal and external modules of Node.js. Moreover, web sockets and
    working with databases were also covered in the previous chapters. We learned
    all of this through interesting activities and exercises. Now it's time to strengthen
    this knowledge and learn about the root concepts of JavaScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 JavaScript 在浏览器级别的重要性以及其在服务器级别的能力。我们学习了如何在系统上安装 Node.js 以及如何编写和执行代码。此外，我们还获得了大量关于
    Node.js 内部和外部模块的知识。此外，上一章还涵盖了 Web Sockets 和与数据库的工作。我们都是通过有趣的活动和练习来学习这些内容的。现在，是时候加强这些知识，并学习
    JavaScript 的根本概念了。
- en: In this chapter, we will go through the different types of JavaScript programming
    paradigms. During the learning phase of any programming language, people usually
    code in a procedural way; instead of planning, they put most of their focus on
    execution and understanding the concepts of that particular programming language.
    But when it comes to working on real-life problems, the procedural way is not
    a scalable option. Luckily, we have a lot of different types of code implementation
    techniques that we can use to model real-life entities with a programming language,
    such as the **object-oriented programming** paradigm, or **OOP**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同类型的 JavaScript 编程范式。在任何编程语言的学习阶段，人们通常以过程式的方式编码；而不是规划，他们把大部分精力放在执行和理解该特定编程语言的概念上。但是，当涉及到解决现实生活中的问题时，过程式的方法并不是一个可扩展的选项。幸运的是，我们有大量的不同类型的代码实现技术，我们可以使用这些技术用编程语言来模拟现实生活中的实体，例如面向对象编程范式，或
    **OOP**。
- en: Let's take a real-world example in which we have to build a project for our
    college. There will be teachers, clerks, students, heads of departments, and so
    on. One way of implementing this project is to write the logic for each of these
    entities separately, which is not a scalable option, and it will not be a flexible
    solution either. Another way is to use the OOP approach, in which we will create
    one `Person` model that will hold a person's designations as keys in the object.
    This way, we are separating people from their designations. We can easily implement
    changes in either `Person` or entities, that is, heads, teachers, students, and
    so on. All the changes to `Person` will automatically be implemented on entities
    because they belong to the `Person` class. There are a lot of other approaches
    that we can use to solve the same types of problems. We will go through some of
    them in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个现实世界的例子来说明，我们需要为我们的大学构建一个项目。这里会有教师、职员、学生、系主任等等。实现这个项目的一种方式是为这些实体中的每一个分别编写逻辑，这并不是一个可扩展的选项，而且它也不会是一个灵活的解决方案。另一种方式是使用面向对象的方法，其中我们将创建一个
    `Person` 模型，该模型将使用对象中的键来存储人的职位。这样，我们就将人与他们的职位分离开了。我们可以轻松地在 `Person` 或实体（即系主任、教师、学生等）中实现更改。对
    `Person` 的所有更改将自动应用于实体，因为它们属于 `Person` 类。我们可以使用很多其他方法来解决相同类型的问题。在本章中，我们将探讨其中的一些。
- en: After that, you will learn what prototypes are and how to use them to achieve
    inheritance. There are a lot of other basics as well. Let's start.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将学习原型是什么以及如何使用它们来实现继承。还有很多其他基础知识。让我们开始吧。
- en: JavaScript Paradigms
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 编程范式
- en: A programming paradigm is a way or method in which we write code to solve different
    types of problems. Since there are a lot of ways to code, there are a lot of programming
    paradigms that developers use to write code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编程范式是我们编写代码以解决不同类型问题的方法或方法。由于有大量的编码方式，因此开发者使用了许多编程范式来编写代码。
- en: JavaScript is a multi-paradigm scripting language, which means that it is very
    dynamic in nature and supports various types of programming styles, such as object-oriented,
    imperative, and functional programming. In this book, we will discuss the three
    main programming paradigms that are popular among developers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种多范式脚本语言，这意味着它在本质上非常动态，支持各种类型的编程风格，如面向对象、命令式和函数式编程。在这本书中，我们将讨论在开发者中流行的三种主要编程范式。
- en: 'We can divide programming paradigms into two categories:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将编程范式分为两类：
- en: Imperative, which includes **Procedural Programming** and **OOP**
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式，包括**程序化编程**和**面向对象**
- en: Declarative, which includes **Functional Programming**
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式，包括**函数式编程**
- en: In this chapter, we will discuss procedural and object-oriented programming.
    Functional programming is quite popular, and there are a lot of concepts to learn,
    so we have dedicated one chapter, named Functional Programming, to cover that
    topic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论程序化和面向对象编程。函数式编程相当流行，有很多概念需要学习，所以我们专门用一章，名为函数式编程，来涵盖这个主题。
- en: The Procedural Paradigm
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序化范式
- en: As the name suggests, this paradigm follows the procedural pattern. In this
    paradigm, we divide our whole program into routines and subroutines. The process
    flow is very linear and synchronous in this coding pattern. It follows a top-down
    approach to programming. It simply involves breaking down the desired result in
    some routines and smaller subroutines. These subroutines will be further divided
    into processes, which will then be executed to achieve the desired result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，这个范式遵循程序化模式。在这个范式中，我们将整个程序划分为例程和子例程。在这个编码模式中，流程非常线性且同步。它遵循自顶向下的编程方法。它仅仅涉及将期望的结果分解为一些例程和更小的子例程。这些子例程将进一步划分为过程，然后执行以实现期望的结果。
- en: Procedural programming uses a top-down approach to write an application, while
    OOP follows a zigzag approach to the data flow. Reusability is one of the most
    important factors when developing large applications. There is less reusability
    in procedural programming compared with OOP, and that is the reason why the object-oriented
    approach is more popular in scalable applications. When developing programs using
    procedural programming, we might plan out a program without thinking about recycling
    code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化编程使用自顶向下的方法来编写应用程序，而面向对象编程则遵循数据流的之字形方法。在开发大型应用程序时，可重用性是最重要的因素之一。与面向对象编程相比，程序化编程的可重用性较低，这也是面向对象方法在可扩展应用程序中更受欢迎的原因。在用程序化编程开发程序时，我们可能会在没有考虑代码重用的前提下规划程序。
- en: The data flow is sequential in procedural programming, but that doesn't mean
    we do not have to plan the data flow. Planning is still involved in procedural
    programming. It takes a much more literal approach. Procedural programming applications
    are structured more like a story format. The procedural approach makes the development
    process much simpler, but it consumes more time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序化编程中，数据流是顺序的，但这并不意味着我们不需要规划数据流。在程序化编程中仍然涉及到规划。它采取了一种更加字面的方法。程序化编程应用程序的结构更像是故事格式。程序化方法使开发过程变得更加简单，但消耗的时间更多。
- en: 'The pros of adapting to the procedural paradigm are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 采用程序化范式的优点如下：
- en: A lot of learning resources can be found online.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网上可以找到大量的学习资源。
- en: It has an easier way to track process flow.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有更简单的方式来跟踪流程。
- en: The implementation of programs is very easy.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的实现非常简单。
- en: 'The cons of adapting to the procedural paradigm are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 采用程序化范式的缺点如下：
- en: It is difficult to relate to the real world.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现实世界难以相关联。
- en: There is less data security.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据安全性较低。
- en: It is difficult to solve complex problems with this approach.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种方法解决复杂问题比较困难。
- en: The procedural approach is one of the basic approaches that most people use
    when they start learning code. So, to strengthen our concepts, it's always better
    to practice what we have just learned. Let's do an exercise in which we will implement
    a very basic and simple function using straightforward procedural programming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化方法是在人们开始学习代码时使用的基本方法之一。因此，为了加强我们的概念，始终练习我们刚刚学到的内容是更好的。让我们做一个练习，我们将使用直接的程序化编程来实现一个非常基本和简单的函数。
- en: 'Exercise 13.01: Implementing Procedural Programming'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01：实现程序化编程
- en: 'In this exercise, we have a string and we have to capitalize every word in
    it. As per the procedural approach, we have to implement it in such a way that
    each statement executes in a top-down manner. This means that we will start with
    the first statement and by the last statement, we will have our result. In order
    to do that, we have to perform some operations. Let''s look at them one by one:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们有一个字符串，我们必须将其中的每个单词都转换为大写。按照程序性方法，我们必须以自顶向下的方式实现它。这意味着我们将从第一个语句开始，到最后的语句，我们将得到我们的结果。为了做到这一点，我们必须执行一些操作。让我们逐一查看它们：
- en: First, let's create an empty file and call it `procedural.js`. You can change
    the name if you want.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个空文件，并将其命名为`procedural.js`。如果您想的话，可以更改名称。
- en: 'Let''s write a function called `toCapitalize()`, which will take one argument
    as an input. The input parameter will be of the string type only:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个名为`toCapitalize()`的函数，它将接受一个参数作为输入。输入参数只能是字符串类型：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside this function, let''s first split the input string using spaces. This
    will divide the input string into words and will return an array of all those
    words:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数内部，让我们首先使用空格将输入字符串分割开。这将把输入字符串分割成单词，并返回所有这些单词的数组：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After this statement, `arrayOfString` will hold an array of words, that is [
    '`Once'`, '`upon'`, '`a'`, '`time'`, '`in'`, '`new'`, '`york'`].
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个语句之后，`arrayOfString`将包含一个单词数组，即`['Once', 'upon', 'a', 'time', 'in', 'new',
    'york']`。
- en: 'Let''s loop over the array:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们遍历这个数组：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside this `for` loop, extract the first letter of all the words and save
    the result in a variable:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`for`循环内部，提取所有单词的首字母，并将结果保存到一个变量中：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s make this letter uppercase using the `toUpperCase()` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`toUpperCase()`方法将这个字母转换为大写：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, remove the first letter of every word from the input string and replace
    it with the one we just made uppercase:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从输入字符串中移除每个单词的首字母，并用我们刚刚制作的大写字母替换它：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, let''s join all the words of the array, including the spaces, to make
    a sentence again and return it as the output of the function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将数组中的所有单词连接起来，包括空格，再次形成一个句子，并将其作为函数的输出返回：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can pass any string to this function and it will return the string with
    all the words with the first letter in uppercase:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将任何字符串传递给这个函数，它将返回所有单词首字母大写的字符串：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s execute this script with Node.js and look at the output:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用Node.js执行这个脚本并查看输出：
- en: '![Figure 13.1: Output of the procedural exercise'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1：程序性练习的输出'
- en: '](img/C14377_13_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_13_01.jpg](img/C14377_13_01.jpg)'
- en: 'Figure 13.1: Output of the procedural exercise'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：程序性练习的输出
- en: 'As you can see, we now have our desired output: the first letter of each word
    is uppercase. In the code, we have called a lot of methods, such as `split`, `toUpperCase`,
    `slice`, and `join`. All these functions were called in a top-down manner. We
    started with the first statement of this function, where we had our input string,
    and then we processed the input. After the execution of the last statement of
    this function, we have our desired result. This is a simple example of the implementation
    of procedural programming. Next, we will learn how to implement the object-oriented
    approach in programming.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在得到了期望的输出：每个单词的首字母都大写。在代码中，我们调用了许多方法，例如`split`、`toUpperCase`、`slice`和`join`。所有这些函数都是自顶向下调用的。我们从这个函数的第一个语句开始，其中包含我们的输入字符串，然后处理输入。在执行这个函数的最后一个语句之后，我们得到了期望的结果。这是一个程序性编程实现的简单例子。接下来，我们将学习如何实现编程中的面向对象方法。
- en: The Object-Oriented Paradigm
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象范式
- en: The object-oriented paradigm is one of the most popular paradigms used by developers.
    A lot of programming languages are oriented to this paradigm. The reason for its
    popularity is its ability to model real-life things in code. In this paradigm,
    we can create objects that will represent entities in the real world.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象范式是开发者使用最广泛的范式之一。许多编程语言都倾向于这种范式。其受欢迎的原因在于它能够用代码模拟现实生活中的事物。在这个范式中，我们可以创建代表现实世界实体的对象。
- en: 'We use classes to imitate real-world categories, and then we can create objects
    from those classes, which will act like entities. All classes in JavaScript have
    one constructor function that will execute every time we initiate new instances
    of that object. We use the `Class` keyword to create a class, and `constructor`
    is a default function inside each class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类来模仿现实世界的类别，然后我们可以从这些类中创建对象，这些对象将充当实体。JavaScript 中的所有类都有一个构造函数，每次我们初始化该对象的新的实例时，它都会执行。我们使用
    `Class` 关键字来创建一个类，`constructor` 是每个类内部的一个默认函数：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Whatever we are initializing in the `constructor` function will have a scope
    level of this whole class. We can use the `new` keyword to create instances of
    this object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `constructor` 函数中初始化的任何内容都将具有整个类的范围级别。我们可以使用 `new` 关键字来创建这个对象的实例：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the parameter passed when creating the new instance will get passed straight
    to the `constructor` function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建新实例时传递的参数将直接传递给 `constructor` 函数。
- en: 'Exercise 13.02: Implementing OOP'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.02：实现面向对象编程
- en: The object-oriented paradigm is the best one to implement because we can relate
    the code to real life. We create classes of real-world entities, such as cars,
    furniture, and electronics, and create instances of those classes to represent
    real-world objects. For example, imagine you have a car from the manufacturer
    Audi. The car is an entity that we can represent as a class in OOP. We can create
    an instance of this `car` class, which will represent your car, and this instance
    will hold information about you, such as that the car's owner is you and the car's
    manufacturer is Audi. Each instance will act as the registration of that vehicle.
    That way, we can create relations between the code and the real world.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象范式是最好的实现方式，因为我们可以将代码与现实生活联系起来。我们创建现实世界实体的类，如汽车、家具和电子产品，并创建这些类的实例来表示现实世界的对象。例如，想象你有一辆来自奥迪制造商的汽车。这辆汽车是一个实体，我们可以将其表示为一个面向对象的类。我们可以创建这个
    `car` 类的实例，它将代表你的汽车，并且这个实例将包含关于你的信息，例如汽车的所有者是你，制造商是奥迪。每个实例都将作为该车辆的登记。这样，我们可以在代码和现实世界之间建立关系。
- en: The best way to understand this is by taking an example from the real world
    and implementing it. Let's consider a simple program that displays information
    about the living beings on Earth. To do this, we have to make a class of living
    beings and we can create multiple instances of that class, such as `Humans`, `Animals`,
    and `Plants`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，最好的方式是从现实世界中的例子入手并实现它。让我们考虑一个简单的程序，该程序显示地球上生物的信息。为此，我们必须创建一个生物类，并且我们可以创建该类的多个实例，例如
    `Humans`、`Animals` 和 `Plants`。
- en: 'To start this off, we have to first create a class of `Humans`. There are a
    lot of things that are common in humans, such as age, weight, height, and skin
    and hair color, but in this case, we are only interested in showing their age,
    name, and gender:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个话题，我们首先需要创建一个名为 `Humans` 的类。人类有很多共同的特征，比如年龄、体重、身高，以及肤色和发色，但在这个例子中，我们只对展示他们的年龄、姓名和性别感兴趣：
- en: Let's create an empty file and call it `humans.js`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个空文件，并将其命名为 `humans.js`。
- en: 'Now, let''s create a class called `Humans` and a `constructor` function, which
    will take `name`, `age`, and `gender` as parameters:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为 `Humans` 的类和一个 `constructor` 函数，这个函数将接受 `name`、`age` 和 `gender`
    作为参数：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s create one more method inside this class, which will print the values
    of `name`, `age`, and `gender` because only the methods of this class have access
    to class variables:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在类中创建一个额外的函数，该函数将打印 `name`、`age` 和 `gender` 的值，因为只有这个类的函数才能访问类变量：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From our `Humans` class, we can now create some instances that represent actual
    humans:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的 `Humans` 类中，我们现在可以创建一些实例，代表真实的人类：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we will print both of these objects. They will contain all the information
    we passed to the constructor when we created them:![Figure 13.2: Output for the
    object-oriented exercise'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将打印这两个对象。它们将包含我们在创建它们时传递给构造函数的所有信息：![图 13.2：面向对象练习的输出
- en: '](img/C14377_13_02.jpg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_13_02.jpg)'
- en: 'Figure 13.2: Output for the object-oriented exercise'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：面向对象练习的输出
- en: As you can see, we now have two instances of the `Humans` class, each of which
    holds information about a human. We can treat these two instances as real humans.
    They have their own `name`, `age`, and `gender`. This will help you a lot when
    writing code because you know the object you are writing the logic for. Similarly,
    we can implement any real-world entity as a class and can create multiple objects
    of that class, which can represent real-world objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在有两个`Humans`类的实例，每个实例都包含有关一个人的信息。我们可以将这些两个实例视为真实的人类。他们有自己的`name`、`age`和`gender`属性。这在编写代码时将非常有帮助，因为你知道你正在为哪个对象编写逻辑。同样，我们可以将任何现实世界的实体实现为一个类，并可以创建该类的多个对象，这些对象可以代表现实世界的对象。
- en: So far, we know there are a lot of benefits of using OOP, and some of them are
    very useful. Next, we'll look at two very important features that this paradigm
    provides – encapsulation and inheritance. Let's go through each of them and see
    how we can use these concepts with JavaScript.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道使用面向对象编程有很多好处，其中一些非常有用。接下来，我们将探讨这个范式提供的两个非常重要的特性——封装和继承。让我们逐一了解这些概念，并看看我们如何使用JavaScript来实现这些概念。
- en: Encapsulation
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封装
- en: One benefit of using OOP is that it protects the data in classes. We can add
    data to classes that will only be available for the class' methods. Other classes
    will not be able to access that data. It works as a protective shield for the
    class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面向对象编程（OOP）的一个好处是它保护了类中的数据。我们可以向类中添加只有类的方法才能访问的数据。其他类将无法访问这些数据。它就像一个保护盾牌，保护着类。
- en: As we saw in the previous example, the scope of the `name`, `age`, and `gender`
    variables was limited to the class. All the methods initialized in the class can
    have access to those variables. This is how we can protect data inside a class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个例子中所见，`name`、`age`和`gender`变量的作用域仅限于类。在类中初始化的所有方法都可以访问这些变量。这就是我们如何在类内部保护数据的方式。
- en: Inheritance
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is a way in which one class can have access to the properties of
    another class. In the last example, humans can have a lot of different types of
    professions. So, we can inherit the `Humans` class by professions as well. Let's
    examine this concept by doing an exercise. In the last exercise, we created a
    `Humans` class that holds the name, gender, and age information. We will extend
    this class further by creating a new class called `Teacher`. This class will hold
    all the properties of the `Humans` class along with some additional properties
    describing the subject they teach, grades, and more. This will give you an idea
    of how classes are extended and how parent class properties are inherited by other
    classes. Let's jump into the code now.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一种方式，其中一个类可以访问另一个类的属性。在上一个例子中，人类可以有各种各样的职业。因此，我们也可以通过职业来继承`Humans`类。让我们通过一个练习来检验这个概念。在上一个练习中，我们创建了一个包含姓名、性别和年龄信息的`Humans`类。我们将通过创建一个新的类`Teacher`来进一步扩展这个类。这个类将包含`Humans`类的所有属性，以及一些额外的属性，描述他们教授的科目、成绩等。这将给你一个关于类如何扩展以及父类属性如何被其他类继承的直观印象。现在让我们进入代码。
- en: 'Exercise 13.03: Inheritance Implementation Using the extends Keyword'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.03：使用`extends`关键字实现继承
- en: 'Let''s create a class called `Teacher` that will inherit the properties of
    the `Humans` class. We will use the `extends` keyword to inherit from classes
    in this exercise:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Teacher`的类，它将继承`Humans`类的属性。我们将使用`extends`关键字来继承本练习中的类：
- en: 'Use the `extends` keyword to inherit from the class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extends`关键字来继承类：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inside this class, we have to pass all the necessary parameters to the `constructor`
    function. Inside the `constructor` function, we will call the `super` function
    and pass the parameters required for the parent class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，我们必须将所有必要的参数传递给`constructor`函数。在`constructor`函数内部，我们将调用`super`函数并传递父类所需的参数：
- en: '[PRE14]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `name`, `age`, and `gender` are parameters of the `Humans` class. Using
    the `super` function, we passed these parameters to the `Humans` class and the
    rest of the variables, that is, `subject` and `grade`, are a part of the `Teacher`
    class.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，`name`、`age`和`gender`是`Humans`类的参数。使用`super`函数，我们将这些参数传递给了`Humans`类，其余的变量，即`subject`和`grade`，是`Teacher`类的一部分。
- en: 'Let''s have an `info` method in the `Teacher` class that will print all the
    variables of that class:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Teacher`类中有一个`info`方法，它会打印出该类的所有变量：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After we have finished creating the `Teache`r class, let''s create an instance
    of it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们完成`Teacher`类的创建后，让我们创建一个它的实例：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, let''s run this script with Node.js:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们用 Node.js 运行这个脚本：
- en: '![Figure 13.3: Teacher instance after inheritance'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.3：继承后的 Teacher 实例](img/C14377_13_03.jpg)'
- en: '](img/C14377_13_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_13_03.jpg](img/C14377_13_03.jpg)'
- en: 'Figure 13.3: Teacher instance after inheritance'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.3：继承后的 Teacher 实例](img/C14377_13_03.jpg)'
- en: 'As you can see in the output, there are some properties, such as `name`, `age`,
    and `gender`, that are not present in the `Teacher` class. These properties are
    inherited from the `Humans` class, which we implemented in *Exercise 13.02: Implementing
    OOP*.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所示，有一些属性，如 `name`、`age` 和 `gender`，在 `Teacher` 类中不存在。这些属性是从我们实现的 `Humans`
    类继承而来的，该类在 *练习 13.02：实现 OOP* 中实现。
- en: Now that we know how to achieve inheritance using JavaScript, we can now create
    multiple objects of the `Teacher` class that will inherit all the properties of
    their parent class, `Humans`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 JavaScript 实现继承，我们现在可以创建多个 `Teacher` 类的实例，这些实例将继承其父类 `Humans` 的所有属性。
- en: 'Let''s look at some of the pros of adopting the object-oriented paradigm:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看采用面向对象范式的优点：
- en: '**Reusability**: We can use already-created classes again and again without
    creating new classes.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：我们可以反复使用已经创建的类，而无需创建新类。'
- en: '**Real-Life modeling**: We can model a real-world concept using OOP, such as
    a chair, person, or car. This makes understanding the implementation easy.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现实生活建模**：我们可以使用面向对象编程（OOP）来模拟现实世界的概念，例如椅子、人或汽车。这使得理解实现变得容易。'
- en: '**Parallel development**: Classes can be independent, which means we can develop
    more than one class at a time. This results in quicker project development.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行开发**：类可以独立，这意味着我们可以同时开发多个类。这导致项目开发更快。'
- en: '**Team independency**: As OOP supports parallel development, teams can work
    independently of each other.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队独立性**：由于面向对象编程支持并行开发，团队可以相互独立工作。'
- en: '**Secured development**: OOP features, such as inheritance and encapsulation,
    hide data from other classes, thereby improving security. The internal data of
    a class can''t be accessed by external functions.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全开发**：面向对象编程的特性，如继承和封装，隐藏了数据，从而提高了安全性。类的内部数据不能被外部函数访问。'
- en: 'The possible cons of using the object-oriented paradigm:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面向对象范式的可能缺点：
- en: '**Unnecessary code:** It can create an enormous amount of unnecessary and bloated
    code if it''s not implemented with proper planning.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不必要的代码**：如果没有适当的规划，它可能会创建大量不必要的冗余代码。'
- en: '**Duplication**: As OOP can be implemented for each individual class, it can
    lead to code duplication.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码重复**：由于面向对象编程可以为每个单独的类实现，因此可能导致代码重复。'
- en: '**Early planning**: Programmers should have a proper plan before designing
    a program.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早期规划**：程序员在设计程序之前应该有一个适当的计划。'
- en: '**Project size**: Projects developed with OOP are often larger than projects
    developed with other approaches, such as the procedural paradigm.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目规模**：使用面向对象编程开发的项目通常比使用其他方法（如过程式范式）开发的项目更大。'
- en: In this section, we have learned about different types of programming paradigms
    we can use with JavaScript. We dug deep into two of the most popular paradigms
    – procedural and object-oriented. We went through different pros and cons of both
    paradigms. We also learned about two of the most important features of OOP, which
    are encapsulation and inheritance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了可以使用 JavaScript 的不同编程范式。我们深入探讨了两种最流行的范式——过程式和面向对象。我们讨论了两种范式的不同优缺点。我们还学习了面向对象编程的两个最重要的特性，即封装和继承。
- en: Basic JavaScript Concepts
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本JavaScript概念
- en: Programming paradigms are important, but to understand them in detail, we need
    a basic understanding of different JavaScript concepts. So, let's go through some
    of the core concepts of JavaScript, which will help you get a grasp of JavaScript
    and give you a better understanding of how we can use programming paradigms to
    build scalable solutions to problems.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 编程范式很重要，但要详细了解它们，我们需要对不同的 JavaScript 概念有一个基本的了解。因此，让我们回顾一些 JavaScript 的核心概念，这将帮助您掌握
    JavaScript，并更好地理解我们如何使用编程范式来构建可扩展的解决方案。
- en: Prototypes and Prototypical Inheritance
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型和原型继承
- en: Objects are very important because they help us manipulate JavaScript to achieve
    the functionality we want. There are a lot of ways to create objects in JavaScript.
    One of the ways is by using a `constructor` function, and whenever we create a
    function, the JavaScript engine adds a `prototype` property to the function. This
    `prototype` property is an object that has a `constructor` property by default.
    This constructor points back to the parent functions. You can see this function
    by calling `functionName.prototype`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对象非常重要，因为它们帮助我们操作 JavaScript 以实现我们想要的功能。在 JavaScript 中有很多创建对象的方法。其中一种方法是通过使用
    `constructor` 函数，每次我们创建一个函数时，JavaScript 引擎都会向该函数添加一个 `prototype` 属性。这个 `prototype`
    属性是一个默认包含 `constructor` 属性的对象。这个构造函数指向父函数。你可以通过调用 `functionName.prototype` 来看到这个函数。
- en: 'Let''s first create a function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个函数：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s check its `prototype` property by entering `PersonName.prototype`.The
    output will be as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过输入 `PersonName.prototype` 来检查它的 `prototype` 属性。输出将如下所示：
- en: '![Figure 13.4: Prototype property of objects'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4：对象的原型属性'
- en: '](img/C14377_13_04.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_13_04.jpg)'
- en: 'Figure 13.4: Prototype property of objects'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：对象的原型属性
- en: As you can see, we have created a function named `Person` and JavaScript automatically
    binds a `prototype` property to it. You can print the `prototype` and you can
    see that there is a `constructor` property, which holds all the metadata of the
    parent function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了一个名为 `Person` 的函数，JavaScript 自动将其绑定到一个 `prototype` 属性上。你可以打印 `prototype`
    并看到有一个 `constructor` 属性，它包含了父函数的所有元数据。
- en: What Is Prototypical Inheritance?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是原型继承？
- en: As we know, everything in JavaScript is an object. Every string, integer, array,
    object, and function that you define is an object of its respective parent class.
    Each object in JavaScript holds a `proto` property (`__proto__` keys inside child
    objects are usually referred to as `proto` properties) that holds all the properties
    of its parent class. We can use these `proto` properties to implement inheritance.
    These `prototype` objects act as template objects from which all the child objects
    will inherit methods and properties. We can also override the properties of a
    parent class using this `prototype` property. This linking of prototypes is referred
    to as a prototype chain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，JavaScript 中的所有内容都是一个对象。每一个字符串、整数、数组、对象和定义的函数都是其相应父类的一个对象。JavaScript 中的每个对象都包含一个
    `proto` 属性（子对象内部的 `__proto__` 键通常被称为 `proto` 属性），它包含了其父类的所有属性。我们可以使用这些 `proto`
    属性来实现继承。这些 `prototype` 对象作为模板对象，所有子对象都将从中继承方法和属性。我们也可以使用这个 `prototype` 属性来覆盖父类的属性。这种原型链接被称为原型链。
- en: 'Exercise 13.04: Prototypical Inheritance Implementation'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.04：原型继承实现
- en: 'In this exercise, let''s implement a very simple function that will take a
    first name and a last name as parameters and return the full name. After this
    exercise, you should be completely clear on how prototypical inheritance works
    and the differences between the two approaches to achieve this output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，让我们实现一个非常简单的函数，它将接受一个名字和一个姓氏作为参数，并返回全名。完成这个练习后，你应该完全清楚原型继承是如何工作的，以及实现这种输出两种方法的区别：
- en: We can implement `firstName` and `lastName` child functions inside the `PersonName`
    parent function that will have the scope to use the values of the parent function.
    We can bind the functions to their parent's prototype because the parent function
    can always access the scope of a child function. Let's implement and observe both
    approaches. Open the Google Chrome Developer Tools console using the `F12` key.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在 `PersonName` 父函数内部实现 `firstName` 和 `lastName` 子函数，这样它们就能使用父函数的值。我们可以将这些函数绑定到它们的父原型上，因为父函数总能访问子函数的作用域。让我们实现并观察这两种方法。使用
    `F12` 键打开 Google Chrome 开发者工具控制台。
- en: 'Use this constructor function to create some objects and paste the code in
    the console:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个构造函数创建一些对象，并将代码粘贴到控制台中：
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Whenever we use a `constructor` function to create objects, JavaScript adds
    a property to its object, which is `_proto_`. This `_proto_` property holds the
    link to the prototype of the main function, which can be seen in the following
    output:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当我们使用 `constructor` 函数创建对象时，JavaScript 都会向其对象添加一个属性，即 `_proto_`。这个 `_proto_`
    属性包含了指向主函数原型的链接，这在下面的输出中可以看到：
- en: '![Figure 13.5: Prototype property of instances created with the new keyword'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.5：使用 `new` 关键字创建的实例的原型属性'
- en: '](img/C14377_13_05.jpg)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_13_05.jpg)'
- en: 'Figure 13.5: Prototype property of instances created with the new keyword'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.5：使用`new`关键字创建的实例的原型属性
- en: As you can see here, the `pName1` object has a `__proto__` property that directly
    points to the prototype of its parent, `PersonName.prototype`. In the next step,
    we can use this `prototype` property to achieve inheritance using JavaScript.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，`pName1`对象有一个`__proto__`属性，它直接指向其父`PersonName.prototype`的原型。在下一步中，我们可以使用这个`prototype`属性通过JavaScript实现继承。
- en: 'Let''s bind the `fullName` function with the `prototype` property of `Person`
    instead of defining it inside the function:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`fullName`函数绑定到`Person`的`prototype`属性上，而不是在函数内部定义它：
- en: '[PRE19]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, create two objects of the `PersonName` method using the `new` keyword:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`new`关键字创建两个`PersonName`方法的对象：
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All the objects created here with the `new` keyword will now contain a `proto`
    property, which will point to its parent prototype, and all the functions and
    properties defined in the parent prototype will be accessible to all its child
    objects. In other words, if we create a function and bind it to the prototype
    of the parent function, that function will be accessible to all its objects using
    the prototype chain object. Now, call the `fullName` function, which is defined
    in the `prototype` property of the `Person` method, using its objects:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里使用`new`关键字创建的所有对象现在都将包含一个`proto`属性，该属性将指向其父原型，并且父原型中定义的所有函数和属性都将对所有子对象可访问。换句话说，如果我们创建一个函数并将其绑定到父函数的原型上，那么这个函数将通过原型链对所有对象可访问。现在，使用其对象调用定义在`Person`方法`prototype`属性中的`fullName`函数：
- en: '[PRE21]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 13.6: Example of a prototype chain'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6：原型链示例'
- en: '](img/C14377_13_06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_13_06.jpg)'
- en: 'Figure 13.6: Example of a prototype chain'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：原型链示例
- en: 'In this exercise, we declare a constructor function (`PersonName`), then we
    create a function (`fullName`) and bind it to its prototype. Then, we create two
    child objects using the function''s constructor. You can see that both of these
    objects have access to the `fullName` function, which is in their parent''s prototype.
    This way, we have achieved inheritance using a prototype chain, as visualized
    in *Figure 13.7*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们声明了一个构造函数（`PersonName`），然后创建了一个函数（`fullName`）并将其绑定到其原型上。接着，我们使用该函数的构造函数创建了两个子对象。你可以看到这两个对象都可以访问到`fullName`函数，该函数位于它们的父原型中。这样，我们就通过原型链实现了继承，如图*13.7*所示：
- en: '![Figure 13.7: References of the __proto__ property'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7：__proto__属性的引用'
- en: '](img/C14377_13_07.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_13_07.jpg)'
- en: 'Figure 13.7: References of the __proto__ property'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：__proto__属性的引用
- en: Now we can create as many instances of `PersonName` as we want, and all those
    instances will always have access to `PersonName.fullName`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建任意多的`PersonName`实例，并且所有这些实例都将始终可以访问`PersonName.fullName`。
- en: We can even modify the prototypes and the changes will be reflected in all of
    its child objects instantaneously.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以修改原型，并且这些更改将立即反映在其所有子对象中。
- en: Anonymous Functions
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'Objects in the JavaScript language are very tricky. Everything in JavaScript
    is an object. So, functions in JavaScript are considered functional objects and
    can be used in the same way as we use objects. Functions in JavaScript can be
    passed as arguments to other functions as well. Any function that also returns
    a function is called a function factory. Let''s have a look at an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言中的对象非常复杂。JavaScript中的所有东西都是对象。因此，JavaScript中的函数被视为功能性对象，可以像使用对象一样使用。JavaScript中的函数也可以作为参数传递给其他函数。任何返回函数的函数都称为函数工厂。让我们来看一个例子：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, we have called a function, `calculateSum`, and passed two
    parameters to it. One is a number and the other one is a function. This function
    will return a new function, which will display the passed function followed by
    the result, as can be seen in the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们调用了一个函数`calculateSum`，并向它传递了两个参数。一个是数字，另一个是函数。这个函数将返回一个新的函数，该函数将显示传递的函数和结果，如下面的输出所示：
- en: '![Figure 13.8: Examples of anonymous functions'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8：匿名函数示例'
- en: '](img/C14377_13_08.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_13_08.jpg)'
- en: 'Figure 13.8: Examples of anonymous functions'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：匿名函数的示例
- en: In the example, you can see we have used a lot of functions without naming them.
    These functions are very important in JavaScript. A function declared with no
    particular name is called an anonymous function. We use anonymous functions a
    lot when programming in JavaScript. These types of functions are declared dynamically
    at runtime and can be passed as parameters to other functions. For example, `Function
    () {}` is a typical example of an anonymous function. You can assign the return
    value of this function to any variable. Creating functions with this approach
    allows us to create functions on the go. Anonymous functions are mainly used in
    callbacks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，您可以看到我们使用了大量未命名的函数。这些函数在 JavaScript 中非常重要。没有特定名称声明的函数称为匿名函数。我们在用 JavaScript
    编程时经常使用匿名函数。这类函数在运行时动态声明，并可以作为参数传递给其他函数。例如，`Function () {}` 是匿名函数的典型示例。您可以将此函数的返回值赋给任何变量。以这种方式创建函数允许我们在运行时创建函数。匿名函数主要用于回调。
- en: The Differences between Named Functions and Anonymous Functions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名函数和无名函数之间的区别
- en: 'The major difference between named and anonymous functions is that when you
    declare a named function, the compiler allocates a stored memory block to that
    function. So, if you have to call it, you can use the name to call it. But with
    anonymous functions, the memory block is assigned to them and the address is returned,
    which we can then store in a variable. This helps us initialize functions in places
    where we can''t declare named functions. We can even change the name with which
    we can call this function by assigning the function to another variable. This
    can be visualized in the following diagram:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数和无名函数之间的主要区别在于，当您声明一个命名函数时，编译器会为该函数分配一个存储内存块。因此，如果您必须调用它，您可以使用名称来调用它。但是，对于匿名函数，内存块被分配给它们，并返回地址，然后我们可以将其存储在变量中。这有助于我们在不能声明命名函数的地方初始化函数。我们甚至可以通过将函数赋给另一个变量来更改调用此函数的名称。这可以在以下图中表示：
- en: '![Figure 13.9: Named versus anonymous functions'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.9：命名函数与匿名函数的比较'
- en: '](img/C14377_13_09.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_13_09.jpg](img/C14377_13_09.jpg)'
- en: 'Figure 13.9: Named versus anonymous functions'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9：命名函数与匿名函数的比较
- en: Data Scope
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据作用域
- en: Data scoping determines the accessibility of variables, functions, and objects
    in your code during runtime. This means the scope of a variable is controlled
    by the location of the variable declaration.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 数据作用域确定在运行时您的代码中变量、函数和对象的访问性。这意味着变量的作用域由变量声明的位置控制。
- en: 'In JavaScript, there are two main types of scopes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，存在两种主要的范围类型：
- en: Global scope
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局作用域
- en: Local scope, which includes **function level** and **block level**
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部作用域，包括**函数级**和**块级**
- en: Global Scope
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局作用域
- en: Every JavaScript application has a global scope in which we can define anything
    that all the functions in our application can access. All the variables defined
    outside the functions, blocks, and modules have a global scope. Global variables
    are available for the lifetime of the application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 JavaScript 应用程序都有一个全局作用域，我们可以定义所有函数都可以访问的内容。所有在函数、块和模块外部定义的变量都具有全局作用域。全局变量在整个应用程序的生命周期内都是可用的。
- en: 'Another way of creating global variables is to use predefined global variables
    such as `process` (in Node.js) and `window` (in browsers). You can bind any value
    to these already defined global variables, and you can access them from anywhere
    inside the application. For example, let''s add the `NODE_VERSION` value to the
    `env` property of `process`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 创建全局变量的另一种方式是使用预定义的全局变量，例如 `process`（在 Node.js 中）和 `window`（在浏览器中）。您可以将任何值绑定到这些已定义的全局变量上，并且您可以从应用程序的任何地方访问它们。例如，让我们将
    `NODE_VERSION` 值添加到 `process` 的 `env` 属性中：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `process` variable has a global scope during the execution of the program.
    Now, we can access the value that we''ve set (`NODE_VERSION = 10.08`) anywhere
    in our program:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行过程中，`process` 变量具有全局作用域。现在，我们可以在程序的任何地方访问我们设置的值（`NODE_VERSION = 10.08`）：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Local Scope
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部作用域
- en: Variables defined within a function or a block are in a local scope. Only those
    functions that are defined inside that function or block can have access to those
    variables.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数或块内定义的变量处于局部作用域。只有定义在该函数或块内部的函数才能访问这些变量。
- en: Function-Level Scope
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数级作用域
- en: 'In JavaScript, each function has its own scope. All the variables and functions
    defined inside that function will have access to only each other:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，每个函数都有自己的作用域。在该函数内部定义的所有变量和函数将只能访问彼此：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, both functions have different levels of scope. `Function B` can''t access
    the variables defined in `Function A`. The scope of both functions is highlighted
    in the following figure:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个函数有不同的作用域级别。`函数B`无法访问`函数A`中定义的变量。以下图中突出了两个函数的作用域：
- en: '![Figure 13.10: Example of function-level scope'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.10：函数级作用域的示例'
- en: '](img/C14377_13_10.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_13_10.jpg)'
- en: 'Figure 13.10: Example of function-level scope'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.10：函数级作用域的示例'
- en: Block-Level Scope
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块级作用域
- en: 'Block-level scope is similar to function-level scope, but in this type of scope
    we do not initialize any functions. We can separate the scope of variables by
    creating blocks in JavaScript:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 块级作用域类似于函数级作用域，但在这类作用域中，我们不初始化任何函数。我们可以在JavaScript中创建块来分离变量的作用域：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We use curly braces to create blocks in JavaScript. The second block can't access
    any variables created in the first block.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JavaScript中使用花括号来创建块。第二个块无法访问第一个块中创建的任何变量。
- en: Hoisting
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升机制
- en: We now know that the scope of variables and functions depends on where they
    are declared, but there is an interesting concept in JavaScript, which is called
    **hoisting**. Hoisting is a feature in which the interpreter moves the declarations
    of functions and variables to the top of their scope. This means that variable
    declarations are processed before any code is executed. When any scope is processed,
    first, the whole scope is searched for variable and function declarations. Then,
    the memory space is allocated for each of the variables and functions. After this,
    the body of the function or block is executed line by line.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道变量和函数的作用域取决于它们声明的位置，但JavaScript中有一个有趣的概念，称为**提升**。提升是一个特性，其中解释器将函数和变量的声明移动到它们作用域的顶部。这意味着变量声明在执行任何代码之前被处理。当处理任何作用域时，首先搜索整个作用域中的变量和函数声明。然后，为每个变量和函数分配内存空间。之后，按行执行函数或块的主体。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Hoisting only moves the declaration of the variables and functions, not the
    assignment. The assignment stays in the same position.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提升只移动变量和函数的声明，而不移动赋值。赋值保持在相同的位置。
- en: 'Functions are hoisted first followed by the variables. So, it is a good practice
    to always first declare functions and then work on the implementation part:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先提升，然后是变量。因此，始终首先声明函数然后处理实现部分是一个好习惯：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, both of the blocks will return `undefined`. The output of both blocks
    is the same. The position of the declaration doesn't matter inside a block. The
    first block will not throw any errors relating to variables not being defined.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个块都将返回`undefined`。两个块输出相同。在块内部，声明的位置并不重要。第一个块不会抛出任何与未定义变量相关的错误。
- en: The Difference between var and let
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`var`和`let`之间的差异'
- en: 'In the case of `var`, after creating variable definitions, each of the variables
    is initialized with an undefined value, but in the case of `let`/`const`, the
    initialization to undefined does not happen until the line of the declaration.
    In the following code, the variable is in the Temporal Dead Zone and accessing
    it results in a reference error:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`var`的情况下，在创建变量定义之后，每个变量都被初始化为未定义值，但在`let`/`const`的情况下，直到声明行才会发生初始化为未定义的操作。在以下代码中，变量处于临时死区，访问它会导致引用错误：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s execute this and see the difference by observing the different outputs
    of `var` and `let`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行这个，通过观察`var`和`let`的不同输出来看差异：
- en: '![Figure 13.11: let keyword usage'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.11：`let`关键字的使用'
- en: '](img/C14377_13_11.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_13_11.jpg)'
- en: 'Figure 13.11: let keyword usage'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：`let`关键字的使用
- en: 'In the preceding figure, you can see that if we use `let`, it throws a reference
    error. Let''s look at the output using the `var` keyword:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到如果我们使用`let`，它会抛出一个引用错误。让我们看看使用`var`关键字时的输出：
- en: '![Figure 13.12: var keyword usage'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12：`var`关键字的使用'
- en: '](img/C14377_13_12.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_13_12.jpg)'
- en: 'Figure 13.12: var keyword usage'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：`var`关键字的使用
- en: We see that using the `var` keyword gives the same undefined output for both
    blocks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到使用`var`关键字为两个块都提供了相同的未定义输出。
- en: Closures
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'A closure is a feature in JavaScript where a function defined inside another
    function has access to the parent function''s variables. A closure has three scope
    chains:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是JavaScript中的一个特性，其中一个函数定义在另一个函数内部，可以访问父函数的变量。闭包有三个作用域链：
- en: 'Own scope : Variables defined between its curly brackets'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自作用域：在其花括号内定义的变量
- en: 'Parent function: Properties defined in the parent function'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父函数：在父函数中定义的属性
- en: 'Global variables: Properties defined in the global scope'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量：在全局作用域中定义的属性
- en: 'Let''s have a look at an example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have one main function, which is `outer`. Then, we have declared a `count`
    variable with a value of `1`. We have one more function, `inner`, which is using
    and incrementing the value of `count`. Then, we return the `inner` function. The
    output of the preceding code is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个主要函数，即`outer`。然后，我们声明了一个值为`1`的`count`变量。我们还有一个`inner`函数，它正在使用并增加`count`的值。然后，我们返回`inner`函数。前面代码的输出如下：
- en: '![Figure 13.13: Example of closures'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.13：闭包示例](img/C14377_13_13.jpg)'
- en: '](img/C14377_13_13.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_13_13.jpg)'
- en: 'Figure 13.13: Example of closures'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13：闭包示例
- en: When we first call the `outer('A') function`, we are creating a scope for the
    `count` variable and the `inner` function. Then, we return the `inner` function
    and save its address in `funA()`. We did the same with `funB()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次调用`outer('A')`函数时，我们为`count`变量和`inner`函数创建了一个作用域。然后，我们返回`inner`函数并将其地址保存在`funA()`中。我们对`funB()`也做了同样的事情。
- en: When we called `funA()` first, it had access to the `count` variable because
    it was in its parent function. So, it printed the value of `count` and updated
    it by adding `1`. When we called it again, it again accessed the parent scope
    and got the updated value of `count`. JavaScript is able to achieve this because
    of closures.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首先调用`funA()`函数时，它能够访问`count`变量，因为它在其父函数中。所以，它打印了`count`的值，并通过添加`1`来更新它。当我们再次调用它时，它再次访问父作用域并获取`count`的更新值。JavaScript能够实现这一点，归功于闭包。
- en: In this section, we have learned about a lot of the basic features of JavaScript.
    We started with prototypes and used them to implement inheritance. Then, we learned
    about anonymous and named functions and how to use them. We also learned about
    different types of data scopes in JavaScript. Finally, we learned about hoisting
    and closures, which are among the most complicated and important features provided
    by JavaScript.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了JavaScript的许多基本功能。我们从原型开始，并使用它们来实现继承。然后，我们学习了匿名和命名函数以及如何使用它们。我们还学习了JavaScript中不同类型的数据作用域。最后，我们学习了提升和闭包，这些是JavaScript提供的最复杂和最重要的功能之一。
- en: JavaScript Memory Management
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript内存管理
- en: In other technical languages, such as C and C++, memory allocation and deallocation
    is an additional task. We have to use the `malloc()` and `free()` functions in
    C to allocate and deallocate memory for our variables. Thankfully, we do not have
    to take care of memory allocation in JavaScript anymore. JavaScript has a garbage
    collector built into it. JavaScript automatically allocates and frees up memory
    when objects are created and destroyed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他技术语言中，如C和C++，内存分配和释放是一个额外的任务。我们必须在C中使用`malloc()`和`free()`函数为我们的变量分配和释放内存。幸运的是，我们不再需要在JavaScript中关心内存分配了。JavaScript内置了垃圾回收器。JavaScript在对象创建和销毁时自动分配和释放内存。
- en: Memory Life Cycle
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存生命周期
- en: 'The memory life cycle of most programming languages is the same. It doesn''t
    matter which language you are using, whether JavaScript, Python, or Java, the
    allocation and deallocation of memory is almost the same. They all follow three
    steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言的内存生命周期是相同的。无论你使用的是JavaScript、Python还是Java，内存的分配和释放几乎都是相同的。它们都遵循三个步骤：
- en: Allocate the memory.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配内存。
- en: Use the allocated memory.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分配的内存。
- en: Free the allocated memory.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放分配的内存。
- en: The first and last parts are explicit in low-level languages, which means developers
    have to write code for the allocation and deallocation of memory, but it is mostly
    implicit in high-level languages such as JavaScript. During the compilation of
    your code, the compiler examines all primitive data types used in the code and
    calculates how much memory your program will take. It then allocates the required
    memory to the program in the call stack space. This process of the allocation
    of memory is called static memory allocation. During runtime, the memory allocation
    works in a LIFO (last-in, first-out) manner, which means as functions are called
    and terminated, their memory is added on top of the existing memory and is removed
    in a LIFO order.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在低级语言中，第一和最后部分是显式的，这意味着开发者必须编写代码来分配和释放内存，但在像JavaScript这样的高级语言中，这通常是隐式的。在编译你的代码时，编译器会检查代码中使用的所有原始数据类型，并计算程序将占用多少内存。然后，它将所需的内存分配到程序的调用栈空间中。这个过程称为静态内存分配。在运行时，内存分配以LIFO（后进先出）的方式进行，这意味着随着函数的调用和终止，它们的内存被添加到现有内存的顶部，并以LIFO顺序移除。
- en: Static versus Dynamic Allocation
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分配与动态分配
- en: 'There are two types of memory allocation, static and dynamic. Static allocation
    is performed at compile time only. When we compile our code, the compiler figures
    out all the static variables and assigns them memory at that time. Here''s an
    example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种内存分配类型，静态和动态。静态分配仅在编译时执行。当我们编译代码时，编译器会确定所有静态变量并在那时分配内存。以下是一个示例：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Dynamic allocation, as the name suggests, is done at runtime only because sometimes
    we do not know the exact size of the data, for example, when assigning the response
    of an API to a variable. In this case, we do not know exactly what the API will
    send us, so the memory will be allocated during runtime:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，动态分配仅在运行时执行，因为有时我们不知道数据的确切大小，例如，当将API的响应分配给变量时。在这种情况下，我们不知道API会发送给我们什么，因此内存将在运行时分配：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we can't predict the size of the JSON object in advance, so
    this variable will be allocated dynamically. Some of the main differences between
    static and dynamic memory allocation are detailed in the next section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们无法提前预测JSON对象的大小，因此这个变量将动态分配。静态和动态内存分配之间的主要区别将在下一节中详细说明。
- en: 'The following are the features of static memory allocation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为静态内存分配的特点：
- en: Allocates during compile time
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时分配
- en: Uses stack storage
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用堆存储
- en: Good to use when the required amount of memory is known
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已知所需内存量时使用较好
- en: Uses LIFO (Last In, First Out)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LIFO（后进先出）
- en: Faster execution than a dynamic allocation
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比动态分配执行更快
- en: More efficient
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高效
- en: Higher performance
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能更高
- en: 'The following are the features of dynamic memory allocation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为动态内存分配的特点：
- en: Allocates during runtime
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时分配
- en: Uses heap storage
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用堆存储
- en: Good to use when the required amount of memory is unknown
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所需内存量未知时使用较好
- en: No order of assignment
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有分配顺序
- en: Slower execution than a static allocation
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比静态分配执行更慢
- en: Less efficient than a static allocation
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比静态分配效率低
- en: Slower performance because of memory allocation at runtime
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于运行时内存分配，性能较慢
- en: Releasing Memory
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放内存
- en: The most difficult task is to discern situations when the allocated memory is
    no longer required. JavaScript's garbage collector comes in handy when it comes
    to finding and clearing out unused memory.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最困难的任务是确定何时分配的内存不再需要。当需要找到和清除未使用的内存时，JavaScript的垃圾回收器非常有用。
- en: Reference-Counting Garbage Collection
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用计数垃圾回收
- en: One way of finding usable variables is by finding their references. If any variable
    has more than one reference, it means that it is possible to use this variable.
    But if we remove all the references to any variable, it becomes useless and it
    will be garbage collected by JavaScript in the next cycle.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 找到可用的变量的一种方法是通过找到它们的引用。如果任何变量有多个引用，这意味着可以使用这个变量。但如果我们移除任何变量的所有引用，它就变得无用，并且JavaScript将在下一个周期中回收它。
- en: 'Let''s say we have a nested object, `obj`. It has a property called `a`, and
    another property, `b`. Now, `obj` is referencing `a` and `a` is referencing `b`.
    The only way to access `b` is through `a`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个嵌套对象`obj`。它有一个名为`a`的属性，还有一个名为`b`的属性。现在，`obj`引用`a`，而`a`引用`b`。访问`b`的唯一方法是通过`a`：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we change the reference of `a` to `b`, then `b` will be garbage collected:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`a`的引用更改为`b`，则`b`将被垃圾回收：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, as there is no reference to `b`, the garbage collector will delete it and
    free the memory.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于没有对`b`的引用，垃圾回收器将删除它并释放内存。
- en: In this section, we learned about how JavaScript automatically manages memory
    and does memory management for us. We learned about static and heap storage devices
    and had an overview of how the garbage collector in JavaScript works. We went
    through reference garbage collection as one of the many ways a garbage collector
    uses to find and clear unused memory in JavaScript programs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了JavaScript如何自动管理内存，以及它如何为我们进行内存管理。我们了解了静态和堆存储设备，并对JavaScript中的垃圾回收器的工作原理进行了概述。我们探讨了引用垃圾回收作为垃圾回收器在JavaScript程序中查找和清除未使用内存的许多方法之一。
- en: 'Activity 13.01: Creating a Calculator App'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动练习13.01：创建计算器应用程序
- en: In this chapter, we have learned about different types of paradigms that we
    can use when programming with JavaScript. Now it's time to sharpen our knowledge
    of these paradigms and make sure we know the difference between them when implementing
    paradigms in the real world.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在用JavaScript编程时可以使用的不同类型的范式。现在，是时候加深我们对这些范式的了解，并确保我们在现实世界中实现范式时知道它们之间的区别。
- en: Let's build a simple calculator application using both a procedural and object-oriented
    approach, which will give us a clear example of implementing the solution to a
    problem with different paradigms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用过程式和面向对象两种方法构建一个简单的计算器应用程序，这将为我们提供一个清晰的示例，说明如何以不同的范式实现问题的解决方案。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的高级步骤如下：
- en: Create an empty file and call it `procedural.js`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空文件并命名为`procedural.js`。
- en: Initialize an array that will maintain the history of function calls.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个数组，该数组将维护函数调用的历史记录。
- en: Create simple `addition`, `subtraction`, `multiplication`, `division`, and `power`
    functions.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建简单的`addition`、`subtraction`、`multiplication`、`division`和`power`函数。
- en: Create a `history` function that will maintain the history of function calls.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`history`函数，该函数将维护函数调用的历史记录。
- en: Call all the functions one by one with some random numbers as parameters.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个调用所有函数，并使用一些随机数字作为参数。
- en: Now print the history to check the output.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打印历史记录以检查输出。
- en: Now, build the app using OOP. Create a class and call it `calculator`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用面向对象编程（OOP）构建应用程序。创建一个类并命名为`calculator`。
- en: Initialize a `historyList` array, which will maintain the history of all function
    calls.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个`historyList`数组，该数组将维护所有函数调用的历史记录。
- en: Create simple `add`, `subtract`, `multiply`, `divide`, and `pow` methods.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建简单的`add`、`subtract`、`multiply`、`divide`和`pow`方法。
- en: Add one more method, which will show the history of the operations.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个额外的函数，该函数将显示操作的历史记录。
- en: Create an instance of this class and call its method with simple numbers to
    perform mathematical operations.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建此类的实例，并使用简单的数字调用其方法以执行数学运算。
- en: Call the `history` method of the `calculator` class to check the history.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`calculator`类的`history`方法以检查历史记录。
- en: 'Using both a procedural and an object-oriented approach, the output of this
    code will be as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过程式和面向对象两种方法，此代码的输出结果如下：
- en: '![Figure 13.14: The same output using the procedural and the object-oriented
    approach'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.14：使用过程式和面向对象方法得到相同输出](img/C14377_13_14.jpg)'
- en: '](img/C14377_13_14.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_13_14.jpg)'
- en: 'Figure 13.14: The same output using the procedural and the object-oriented
    approach'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14：使用过程式和面向对象方法得到相同输出
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 754.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第754页找到。
- en: You will see that, the outputs of both scripts are exactly the same, but the
    way we implemented them is completely different. This implementation tells us
    that there is more than one way to solve a problem. The best way depends on a
    lot of factors, such as team size, project plans, expectations of the project,
    and others. So, finally, we have achieved the same solution to the same problem.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到，两个脚本的输出完全相同，但我们的实现方式完全不同。这种实现方式告诉我们，解决问题有多种方法。最佳方法取决于许多因素，例如团队规模、项目计划、项目期望等。因此，最终，我们实现了相同问题的相同解决方案。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far in this book, we have covered client-side and server-side JavaScript
    execution. You learned about the importance of scope in JavaScript, along with
    the basics necessary for a solid foundation in JavaScript.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们已经涵盖了客户端和服务器端JavaScript的执行。你学习了JavaScript中作用域的重要性，以及JavaScript坚实基础所需的基本知识。
- en: In this chapter, we learned about different programming paradigms. We discussed
    two of the popular approaches used by developers, namely procedural and object-oriented.
    Then, we explored the uses of prototypes, data scopes, hoisting, and closures.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了不同的编程范式。我们讨论了开发者常用的两种流行方法，即过程式和面向对象。然后，我们探讨了原型、数据作用域、提升和闭包的用法。
- en: 'Now, let''s dig deep into the final and most important programming paradigm,
    which is used by a lot of developers: functional programming. In the next chapter,
    we will learn a lot about functional programming, including how and when to use
    it.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨最后一个也是最关键的编程范式，许多开发者都在使用：函数式编程。在下一章中，我们将学习很多关于函数式编程的知识，包括何时以及如何使用它。
