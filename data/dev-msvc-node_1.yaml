- en: Chapter 1. Microservices Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 微服务架构
- en: Microservices are becoming more and more popular. Nowadays, pretty much every
    engineer on a green field project should be considering using microservices in
    order to improve the quality of the systems they build. They should know the architectural
    principles involving such systems. We will expose the difference between microservices
    and **Service-Oriented Architecture** (**SOA**). We will also introduce a great
    platform to write microservices, **Node.js**, which will allow us to create high-performing
    microservices with very little effort.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务变得越来越受欢迎。如今，几乎每个在绿地项目上工作的工程师都应该考虑使用微服务来提高他们构建的系统的质量。他们应该了解涉及这种系统的架构原则。我们将介绍微服务和**面向服务的架构**（**SOA**）之间的区别。我们还将介绍一个很棒的平台来编写微服务，**Node.js**，它将允许我们轻松创建高性能的微服务。
- en: 'In this chapter, you will learn about microservices from the architectural
    point of view:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将从架构的角度了解微服务：
- en: What are microservices?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: Microservice-oriented architectures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向微服务的架构
- en: Key benefits
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要好处
- en: SOA versus Microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOA与微服务
- en: Why Node.js?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择Node.js？
- en: Need for microservices
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的需求
- en: The world of software development has evolved quickly in the past 40 years.
    One of the key points of this evolution has been the size of these systems. From
    the days of MS-DOS, we have taken a hundred-fold leap into our present systems.
    This growth in size creates a need for better ways of organizing code and software
    components. Usually, when a company grows due to business needs, known as **organic
    growth**, the software is organized on a monolithic architecture as it is the
    easiest and quickest way of building software. After few years (or even months),
    adding new features becomes harder due to the coupled nature of the created software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发领域在过去40年里发展迅速。这种发展的关键点之一是这些系统的规模。从MS-DOS时代开始，我们已经跨越了百倍的飞跃进入了我们现在的系统。规模的增长需要更好的组织代码和软件组件的方式。通常，当一家公司因业务需求而增长时，被称为**有机增长**，软件会以单片架构的方式组织，因为这是构建软件的最简单、最快速的方式。几年后（甚至几个月后），由于所创建软件的耦合性，添加新功能变得更加困难。
- en: Monolithic software
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单片软件
- en: 'The natural trend for new high-tech companies such as Amazon or Netflix is
    building their new software using microservices, which is the ideal scenario:
    they get a huge advantage of microservices-oriented software (through out this
    book, you will learn how) in order to scale up their new products without a big
    effort. The problem is that not all companies can plan their software upfront.
    Instead of planning, these companies build software based on the organic growth
    experienced: few software components group business flows by affinity. It is not
    rare to see companies with two big software components: the user-facing website
    and the internal administration tools. This is usually known as a **monolithic
    software architecture**.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 像亚马逊或Netflix这样的新高科技公司的自然趋势是使用微服务构建他们的新软件，这是理想的情况：他们通过微服务导向的软件获得了巨大的优势（在本书中，您将学习如何），以便在不费吹灰之力的情况下扩展他们的新产品。问题在于，并非所有公司都能提前规划他们的软件。这些公司不是根据规划，而是根据经验的有机增长来构建软件：少数软件组件通过亲和力组合业务流程。看到只有两个大型软件组件的公司并不罕见：用户界面网站和内部管理工具。这通常被称为**单片软件架构**。
- en: Some of these companies face big problems when trying to scale the engineering
    teams. It is hard to coordinate teams that build, deploy, and maintain a single
    software component. Clashes on releases and reintroduction of bugs are a common
    problem that drains a large chunk of energy from the teams. One of the solution
    to this problem (it comes with benefits) is to split the monolithic software into
    microservices so that the teams are able to specialize in a few smaller modules
    and autonomous and isolated software components that can be versioned, updated,
    and deployed without interfering with the rest of the systems of the company.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司在尝试扩展工程团队时面临着很大的问题。协调构建、部署和维护单个软件组件的团队是很困难的。发布冲突和错误的重新引入是一个常见问题，会耗费团队大量的精力。解决这个问题的一个方法（它带来了好处）是将单片软件拆分为微服务，这样团队就能专注于一些较小的模块和自主的、独立的软件组件，这些组件可以进行版本控制、更新和部署，而不会干扰公司其他系统的运行。
- en: Splitting the monolith into microservices enables the engineering team to create
    isolated and autonomous units of work that are highly specialized in a given task
    such as sending e-mails, processing card payments, and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将单体架构拆分为微服务使工程团队能够创建独立和自主的工作单元，这些单元在特定任务上高度专业化，比如发送电子邮件、处理信用卡支付等等。
- en: Microservices in the real world
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界中的微服务
- en: 'Microservices are small software components that are specialized in one task
    and work together to achieve a higher-level task. Forget about software for a
    second and think about how a company works. When someone applies for a job in
    a company, he applies for a given position: software engineer, system administrator,
    office manager. The reason for this can be summarized in one word: specialization.
    If you are used to work as a software engineer, you will get better with the experience
    and add more value to the company. The fact that you don''t know how to deal with
    a customer, won''t affect your performance as that is not your area of expertise
    and will hardly add any value to your day-to-day work.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是专门从事一项任务并共同完成更高级任务的小型软件组件。暂时不要考虑软件，想想一家公司是如何运作的。当有人在公司申请工作时，他申请一个特定的职位：软件工程师、系统管理员、办公室经理。这一点的原因可以用一个词来概括：专业化。如果你习惯于担任软件工程师，你会随着经验的增加而变得更加优秀，并为公司增加更多的价值。你不知道如何与客户打交道并不会影响你的表现，因为那不是你的专业领域，也不会对你的日常工作增加任何价值。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Specialization is often the key to improve the efficiency. Doing one thing and
    doing it right is one of the mantras of software development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 专业化通常是提高效率的关键。专注于一件事并做到完美是软件开发的口头禅之一。
- en: A microservice is an autonomous unit of work that can execute one task without
    interfering with other parts of the system, similar to what a job position is
    to a company. This has a number of benefits that can be used in favor of the engineering
    team in order to help scale the systems of a company.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个可以执行一个任务而不干扰系统其他部分的自主工作单元，类似于公司的一个职位。这有一些好处，可以用来帮助公司的工程团队扩展系统规模。
- en: 'Nowadays, hundreds of systems are built using microservices-oriented architectures,
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，数百个系统都是使用微服务导向架构构建的，如下所示：
- en: '**Netflix**: This is one of the most popular streaming services, it has built
    an entire ecosystem of applications that collaborate in order to provide a reliable
    and scalable streaming system used across the globe.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Netflix**：这是最受欢迎的流媒体服务之一，它构建了一个整个应用生态系统，以便提供一个可靠和可扩展的流媒体系统，被全球范围内使用。'
- en: '**Spotify**: This is one of the leading music streaming services in the world,
    it has built this application using microservices. Every single widget of the
    application (which is a website exposed as a desktop app using Chromium Embedded
    Framework) is a different microservice that can be updated individually.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spotify**：这是世界上领先的音乐流媒体服务之一，它使用微服务构建了这个应用。应用程序的每个小部件（这是一个使用Chromium嵌入式框架作为桌面应用程序公开的网站）都是一个可以单独更新的不同微服务。'
- en: Microservice-oriented architectures
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务导向架构
- en: Microservices-oriented architectures have some particularities that makes them
    desirable for any mid/large-sized company that wants to keep their IT systems
    resilient and in scale up/down-ready status.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务导向架构具有一些特点，使得它们对任何希望保持其IT系统具有弹性并处于可扩展状态的中大型公司都是可取的。
- en: How is it better?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它为什么更好？
- en: They are not the holy grail of software engineering, but, when handled with
    care, they become the perfect approach to solve most of the big problems faced
    by tech-dependent companies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它们并不是软件工程的圣杯，但是，当小心处理时，它们成为解决大多数技术依赖型公司面临的重大问题的完美方法。
- en: It is important to keep the key principles of the microservices-oriented architecture's
    design in mind, such as resilience, composability, elasticity, and so on; otherwise,
    you could end up with a monolithic application split across different machines
    that produces problems rather than an elegant solution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要牢记微服务导向架构设计的关键原则，比如弹性、可组合性、弹性等；否则，你可能会得到一个跨不同机器拆分的单片应用，而不是一个优雅的解决方案。
- en: Shortcomings
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: 'There is also some criticism around microservices-oriented architectures, as
    they introduce some problems to deal with, such as latency, traceability, and
    configuration management that are not present with monolithic-based software.
    Some of the problems are described as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务导向架构也存在一些批评，因为它们引入了一些需要处理的问题，比如延迟、可追溯性和配置管理，这些问题在基于单片软件的系统中是不存在的。一些问题描述如下：
- en: '**Network latency**: Microservices have a distributed nature so that network
    latency has to be accounted for'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络延迟**：微服务具有分布式特性，因此需要考虑网络延迟'
- en: '**Operations overhead**: More servers indicate more maintenance'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运维开销**：更多的服务器意味着更多的维护'
- en: '**Eventual consistency**: On highly transactional systems, we need to factor
    into implementation the fact that the data could be inconsistent during a period
    of time (we will talk about it later in this chapter)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：在高交易系统中，我们需要考虑到数据在一段时间内可能不一致（我们将在本章后面讨论这个问题）'
- en: In general, engineers should try to evaluate the pros and cons of this approach
    and make a decision on whether to use microservices or not in order to fit the
    business needs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，工程师们应该尝试评估这种方法的利弊，并决定是否使用微服务以适应业务需求。
- en: Microservices-oriented architectures have some particularities that need to
    be taken into consideration. When a software engineer is writing monolithic software,
    there are some problems that are completely overlooked due to the nature of the
    software being built.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务导向架构有一些需要考虑的特殊之处。当软件工程师编写单片软件时，由于正在构建的软件的性质，有些问题是完全被忽视的。
- en: For example, imagine that our software needs to send e-mails. In a monolithic
    software, we would just add the functionality to the core of the application.
    We might even choose to create a dedicated module to deal with e-mails (which
    seems like a good idea). Now, imagine that we are creating a microservice and,
    instead of adding a functionality to a big software artifact, we create a dedicated
    service that can be deployed and versioned independently. In this case, we will
    have an extra step that we didn't have to take into consideration, the **network
    latency**, to reach the new microservice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下我们的软件需要发送电子邮件。在单片软件中，我们只需将功能添加到应用程序的核心中。我们甚至可以选择创建一个专门的模块来处理电子邮件（这似乎是一个好主意）。现在，想象我们正在创建一个微服务，而不是将功能添加到一个大型软件构件中，我们创建了一个可以独立部署和版本化的专用服务。在这种情况下，我们将有一个额外的步骤，我们不得不考虑到**网络延迟**，以达到新的微服务。
- en: In the preceding example, no matter what approach (monolithic or microservices)
    you are taking to build the software, is not a big deal; for example, if an e-mail
    is lost, it is not the end of the world. As per definition, the e-mail delivery
    is not guaranteed, so our application will still work, although we might receive
    a few complaints from our customers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，无论采用何种方法（单片或微服务）构建软件，都不是什么大问题；例如，如果一封电子邮件丢失，也不是世界末日。根据定义，电子邮件的传递并不是有保障的，所以我们的应用程序仍然可以工作，尽管我们可能会收到一些来自客户的投诉。
- en: Key design principles
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键设计原则
- en: 'There are a few key design principles that need to be taken into consideration
    when building microservices. There is no golden rule and, as microservices are
    a recent concept, sometimes there is even a lack of consensus on what practices
    to follow. In general, we can assume the following design principles:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务时，有一些关键的设计原则需要考虑。并没有一条金科玉律，由于微服务是一个较新的概念，有时甚至在应该遵循哪些实践方面缺乏共识。总的来说，我们可以假设以下设计原则：
- en: Microservices are business units that model the company processes.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是模拟公司流程的业务单元。
- en: They are smart endpoints that contain the business logic and communicate using
    simple channels and protocols.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是包含业务逻辑并使用简单通道和协议进行通信的智能端点。
- en: Microservices-oriented architectures are decentralized by definition. This helps
    to build robust and resilient software.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向微服务的架构从本质上是分散的。这有助于构建健壮和有弹性的软件。
- en: Business units, no components
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务单元，无组件
- en: One of the most enjoyable sides of software engineering is creating a new project.
    This is where you can apply all your creativity, try new architectural concepts,
    frameworks, or methodologies. Unfortunately, it is not a common situation in a
    mature company. Usually, what we do is create new components inside the existing
    software. One of the best design principles that you can follow when creating
    new components is keeping the coupling as low as possible with the rest of the
    software, so that it works as an independent unit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程最令人愉快的一面之一就是创建一个新项目。这是你可以应用所有创造力，尝试新的架构概念、框架或方法论的地方。不幸的是，在成熟的公司中，这并不是一种常见情况。通常，我们所做的是在现有软件内部创建新组件。在创建新组件时，你可以遵循的最佳设计原则之一就是尽可能地降低与其他软件的耦合，使其作为一个独立的单元运行。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keeping a low level of coupling allows a software component to be converted
    into a microservice with little to no effort.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 保持低耦合度可以使软件组件很容易转换为微服务。
- en: 'Consider a real-world example: the application of your company now needs to
    be able to process payments.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个现实世界的例子：你公司的应用现在需要能够处理支付。
- en: 'The logical decision here would be creating a new module that knows how to
    deal with the chosen payment provider (credit cards, PayPal, and so on) and allows
    us to keep all the payment-related business logic inside of it. Let''s define
    the interface in the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里逻辑上的决定是创建一个新模块，它知道如何处理所选择的支付提供商（信用卡、PayPal等），并允许我们将所有与支付相关的业务逻辑放在其中。让我们在以下代码中定义接口：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple interface can be understood by everyone, but it is the key when
    moving towards microservices. We have encapsulated all the business knowledge
    behind an interface so that we could theoretically switch the payment provider
    without affecting the rest of the application—the implementation details are hidden
    from the outer world.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的接口可以被所有人理解，但在向微服务迈进时它是关键的。我们已经将所有业务知识封装在接口后面，因此理论上我们可以切换支付提供商而不影响应用程序的其他部分——实现细节对外界是隐藏的。
- en: 'The following is what we know until now:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道以下内容：
- en: We know the method name, therefore, we know how to invoke the service
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道方法名称，因此知道如何调用服务。
- en: The method could throw an exception of the `MyBusinessException` type, forcing
    the calling code to deal with it
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法可能会抛出`MyBusinessException`类型的异常，迫使调用代码处理它。
- en: We know that the input parameter is a `PaymentRequest` instance
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道输入参数是一个`PaymentRequest`实例。
- en: The response is a known object
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应是一个已知对象
- en: 'We have created a highly cohesive and loosely coupled business unit. Let''s
    justify this affirmation in the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个高内聚和松耦合的业务单元。让我们在接下来的内容中证明这一点：
- en: '**Highly cohesive**: All the code inside the payments module will do only one
    thing, that is, deal with payments and all the aspects of calling a third-party
    service (connection handling, response codes, and so on), such as a debit card
    processor.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高内聚：支付模块内的所有代码只会做一件事，即处理支付和调用第三方服务的所有方面（连接处理、响应代码等），比如借记卡处理器。
- en: '**Loosely coupled**: What happens if, for some reason, we need to switch to
    a new payment processor? Is there any information bleeding out of the interface?
    Would we need to change the calling code due to changes in the contract? The answer
    is no. The implementation of the payment service interface will always be a modular
    unit of work.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松耦合：如果出于某种原因，我们需要切换到新的支付处理器会发生什么？接口中是否有任何信息泄漏？由于合同的变化，我们是否需要更改调用代码？答案是否定的。支付服务接口的实现将始终是一个模块化的工作单元。
- en: 'The following diagram shows how a system composed of many components gets one
    of them (payment service) stripped out into a microservice:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了一个由许多组件组成的系统中的一个组件（支付服务）被剥离成一个微服务的过程。
- en: '![Business units, no components](img/B04889_01_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![业务单元，无组件](img/B04889_01_01.jpg)'
- en: Once this module is implemented, we will be able to process the payments and
    our monolithic application will have another functionality that could be a good
    candidate to extract into a microservice.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个模块实现了，我们就能够处理支付，我们的单片应用程序将具有另一个功能，这可能是一个很好的候选项，可以提取为微服务。
- en: Now, we can rollout new versions of the payment service, as long as the interface
    does not change, as well as the contract with the rest of the world (our system
    or third parties), hasn't changed. That is why it is so important to keep the
    implementation independent from interfacing, even though the language does not
    provide support for interfaces.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只要接口没有改变，与世界其他部分（我们的系统或第三方）的合同没有改变，我们就可以推出支付服务的新版本。这就是为什么保持实现与接口独立是如此重要的原因，即使语言不提供接口支持。
- en: We can also scale up and deploy as many payment services as we require so that
    we can satisfy the business needs without unnecessarily scaling the rest of the
    application that might not be under pressure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展并部署尽可能多的支付服务，以满足业务需求，而不必扩展可能没有压力的应用程序的其他部分。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载本书的示例代码文件。如果您在其他地方购买了本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接发送到您的电子邮件。
- en: 'You can download the code files by following these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录或注册到我们的网站。
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的**SUPPORT**标签上。
- en: Click on **Code Downloads & Errata**.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击**代码下载和勘误**。
- en: Enter the name of the book in the **Search** box.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入书名。
- en: Select the book for which you're looking to download the code files.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择您购买本书的地方。
- en: Click on **Code Download**.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击**代码下载**。
- en: You can also download the code files by clicking on the **Code Files** button
    on the book's webpage at the Packt Publishing website. This page can be accessed
    by entering the book's name in the **Search** box. Please note that you need to
    be logged in to your Packt account.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过单击Packt Publishing网站上书籍页面上的**代码文件**按钮来下载代码文件。可以通过在**搜索**框中输入书名来访问此页面。请注意，您需要登录到您的Packt帐户。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件后，请确保使用以下最新版本的软件解压或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinRAR / 7-Zip for Windows
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipeg / iZip / UnRarX for Mac
- en: 7-Zip / PeaZip for Linux
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7-Zip / PeaZip for Linux
- en: Smart services, dumb communication pipes
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能服务，愚蠢的通信管道
- en: '**Hyper Text Transfer Protocol** (**HTTP**) is one of the best things to have
    ever happened to the Internet. Imagine a protocol that was designed to be state-less,
    but was hacked through the use of cookies in order to hold the status of the client.
    This was during the age of Web 1.0, when no one was talking about REST APIs or
    mobile apps. Let''s see an example of an HTTP request:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）是互联网上发生的最好的事情之一。想象一种设计为无状态的协议，但通过使用Cookie进行黑客攻击以保持客户端状态。这是在Web
    1.0时代，当时没有人谈论REST API或移动应用程序。让我们看一个HTTP请求的示例：'
- en: '![Smart services, dumb communication pipes](img/B04889_01_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: 智能服务，愚蠢的通信管道
- en: As you can see, it is a *human readable* protocol that does not need to be explained
    in order to be understood.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一种*人类可读*的协议，不需要解释就能理解。
- en: 'Nowadays, it is broadly understood that HTTP is not confined to be used in
    the Web, and as it was designed, it is now used as a general purpose protocol
    to transfer data from one endpoint to another. HTTP is all you need for the communication
    between microservices: a protocol to transfer data and recover from transmission
    errors (when possible).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，人们广泛认识到HTTP并不局限于在Web中使用，并且正如它被设计的那样，它现在被用作从一个端点向另一个端点传输数据的通用协议。HTTP是微服务之间通信所需的一切：一种传输数据和从传输错误中恢复的协议（在可能的情况下）。
- en: In the past few years, especially within the enterprise world, there has been
    an effort to create smart communication mechanisms such as **BPEL**. BPEL stands
    for **Business Process Execution Language**, and instead of focusing on communication
    actions, it focuses on actions around business steps.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年中，特别是在企业界，已经努力创建智能通信机制，如**BPEL**。 BPEL代表**业务流程执行语言**，它不是专注于通信动作，而是专注于围绕业务步骤的动作。
- en: This introduces some level of complexity in the communication protocol and makes
    the business logic of the application bleed into it from the endpoints, causing
    some level of coupling between the endpoints.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了一定程度的通信协议复杂性，并使应用程序的业务逻辑从端点渗入其中，导致端点之间存在一定程度的耦合。
- en: The business logic should stay within the endpoints and not bleed into the communication
    channel so that the system can be easily tested and scaled. The lesson learned
    through the years is that the communication layer must be a plain and simple protocol
    that ensures the transmission of the data and the endpoints (microservices).These
    endpoints should embed into their implementation the fact that a service could
    be down for a period of time (this is called resilience, we will talk about this
    later in this chapter) or the network could cause communication issues.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑应该保留在端点内，而不应渗入通信通道，以便系统可以轻松测试和扩展。多年来学到的教训是，通信层必须是一种简单明了的协议，以确保数据和端点（微服务）的传输。这些端点应该在其实现中嵌入一个事实，即服务可能会在一段时间内停机（这称为弹性，在本章后面我们将讨论这一点），或者网络可能会导致通信问题。
- en: HTTP usually is the most used protocol when building microservices-oriented
    software but another interesting option that needs to be explored is the use of
    queues, such as Rabbit MQ and Kafka, to facilitate the communication between endpoints.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建面向微服务的软件时，通常使用HTTP协议，但另一个有趣的选择是使用队列，如Rabbit MQ和Kafka，以促进端点之间的通信。
- en: The queueing technology provides a clean approach to manage the communication
    in a buffered way, encapsulating the complexities of acknowledging messages on
    highly transactional systems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 排队技术以一种缓冲方式提供了一种清晰的方法来管理通信，封装了高度事务性系统上确认消息的复杂性。
- en: Decentralization
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去中心化
- en: One of the major cons of monolithic applications is the centralization of everything
    on a single (or few) software components and databases. This, more often than
    not, leads to huge data stores that needs to be replicated and scaled according
    to the needs of the company and centralized governance of the flows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的一个主要缺点是将一切集中在单个（或少数）软件组件和数据库上。这往往导致需要复制和根据公司需求和流程的集中治理而扩展的庞大数据存储。
- en: Microservices aim for decentralization. Instead of having a huge database, why
    not split the data according to the business units explained earlier?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务旨在分散化。与其拥有一个庞大的数据库，为什么不根据之前解释的业务单元来分割数据呢？
- en: 'Some of the readers could use the transactionality as one of the main reasons
    for not doing it. Consider the following scenario:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会将事务性作为不这样做的主要原因之一。考虑以下情景：
- en: A customer buys an item in our microservices-oriented online shop.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顾客在我们面向微服务的在线商店购买商品。
- en: 'When paying for the item, the system issues the following calls:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在支付商品时，系统发出以下调用：
- en: A call to the financial system of the company to create a transaction with the
    payment.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用公司财务系统创建付款交易。
- en: A call to the warehouse system to dispatch the book.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用仓库系统发货图书。
- en: A call to the mailing system to subscribe the customer to the newsletter.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用邮件系统订阅客户的通讯。
- en: In a monolithic software, all the calls would be wrapped in a transaction, so
    if, for some reason, any of the calls fails, the data on the other calls won't
    be persisted in the database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体软件中，所有调用都将包装在一个事务中，因此，如果由于某种原因，任何调用失败，其他调用中的数据将不会持久保存在数据库中。
- en: 'When you learn about designing databases, one of the first and the most important
    principles are summarized by the **ACID** acronym:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习设计数据库时，其中一个最重要的原则是由**ACID**首字母缩写总结的。
- en: '**Atomicity**: Each transaction will be all or nothing. If one part fails,
    no changes are persisted on the database.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：每个事务要么全部成功，要么全部失败。如果某一部分失败，数据库中就不会有任何更改。'
- en: '**Consistency**: Changes to the data through transactions need to guarantee
    its consistency.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：通过事务对数据的更改需要保证其一致性。'
- en: '**Isolation**: The result of concurrent execution of transactions results in
    a system state that would be obtained if the transactions were executed serially.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：并发执行事务的结果会导致系统状态，这个状态可以通过串行执行事务来获得。'
- en: '**Durability**: Once the transaction is committed, the data persists.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：一旦事务提交，数据就会持久保存。'
- en: On a microservices-oriented software, the ACID principle is not guaranteed globally.
    Microservices will commit the transaction locally, but there are no mechanisms
    that can guarantee a 100% integrity of the global transaction. It would be possible
    to dispatch the book without processing the payment, unless we factor in specific
    rules to prevent it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向微服务的软件中，ACID原则在全局上并不保证。微服务将在本地提交事务，但没有机制可以保证全局事务的100%完整性。可以在没有处理付款的情况下发货，除非我们考虑特定规则来防止这种情况。
- en: On a microservices-oriented architecture, the transactionality of the data is
    not guaranteed, so we need to factor the failure into the implementation. A way
    to solve (although, workaround is a more appropriate word) this problem is decentralizing
    the governance and data storage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向微服务的架构中，数据的事务性并不受到保证，因此我们需要将失败因素考虑到实现中。解决这个问题的一种方法（尽管，变通更合适）是分散治理和数据存储。
- en: When building microservices, we need to embed in the design, the fact that one
    or more components could fail and degrade the functionality according to the availability
    of the software.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务时，我们需要在设计中嵌入这样一个事实，即一个或多个组件可能会失败，并根据软件的可用性降低功能。
- en: 'Let''s take a look at the following diagram:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图表：
- en: '![Decentralization](img/B04889_01_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![分散化](img/B04889_01_03.jpg)'
- en: 'This diagram represents the sequence of execution on a monolithic software.
    A sequential list of calls that, no matter what, are going to be executed following
    the ACID principle: either all the calls (transactions) succeed or none of them
    do.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表代表了单体软件的执行顺序。一系列调用的顺序，无论如何，都将遵循ACID原则进行执行：要么所有调用（事务）成功，要么都不成功。
- en: This is only possible as the framework and database engine designers have developed
    the concept of transactions to guarantee the transactionality of the data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有可能是因为框架和数据库引擎设计者已经开发了事务的概念，以保证数据的事务性。
- en: When working with microservices, we need to account for what the engineers call
    eventual consistency. After a partial fail on a transaction, each microservice
    instance should store the information required to recover the transaction so that
    the information will be eventually consistent. Following the previous example,
    if we send the book without processing the payment, the payment gateway will have
    a failed transaction that someone will process later on, making the data consistent
    again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用微服务时，我们需要考虑工程师所说的最终一致性。在事务部分失败后，每个微服务实例都应该存储恢复事务所需的信息，以便最终使信息一致。根据前面的例子，如果我们在没有处理付款的情况下发送图书，付款网关将有一个失败的事务，稍后会有人处理，使数据再次一致。
- en: The best way to solve this problem is decentralizing the governance. Every endpoint
    should be able to take a local decision that affects the global scope of the transaction.
    We will talk more about this subject in [Chapter 3](ch03.html "Chapter 3. From
    the Monolith to Microservices"), *From the Monolith to Microservices*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最佳方法是分散治理。每个端点都应该能够做出影响事务全局范围的本地决策。我们将在[第3章](ch03.html "第3章 从单体到微服务")中更多地讨论这个主题，*从单体到微服务*。
- en: Technology alignment
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术对齐
- en: 'When building a new software, there is always a concept that every developer
    should keep in mind: **standards**.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建新软件时，有一个概念是每个开发人员都应该牢记的：**标准**。
- en: Standards guarantee that your service will be technologically independent so
    that it will be easy to build the integrations using a different programming language
    or technologies.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 标准保证您的服务将是技术独立的，因此使用不同的编程语言或技术构建集成将变得容易。
- en: One of the advantages of modeling a system with microservices is that we can
    choose the right technology for the right job so that we can be quite efficient
    when tackling problems. When building monolithic software, it is fairly hard to
    combine technologies like we can do with microservices. Usually, in a monolithic
    software, we are tied to the technology that we choose in the beginning.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务对系统进行建模的一个优势是，我们可以选择适合特定工作的正确技术，这样在解决问题时可以非常高效。在构建单片软件时，很难像微服务那样结合技术。通常，在单片软件中，我们被绑定到最初选择的技术上。
- en: '**Java Remote Method Invocation** (**RMI**) is one example of the non-standard
    protocols that should be avoided if you want your system to be open to new technologies.
    It is a great way of connecting software components written in Java, but the developers
    will struggle (if not fail) to invoke an RMI method using Node.js. This will tie
    our architecture to a given language, which from the microservices point of view,
    will kill one of the most interesting advantages: **technology heterogeneity**.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Java远程方法调用（RMI）是一个非标准协议的例子，如果您希望系统对新技术开放，应该避免使用它。这是连接使用Java编写的软件组件的绝佳方式，但开发人员将很难（甚至无法）使用Node.js调用RMI方法。这将使我们的架构与特定语言绑定，从微服务的角度来看，这将破坏最有趣的优势之一：技术异构性。
- en: How small is too small?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 太小了有多小？
- en: 'Once we have decided to model our system as a set of microservices, there is
    always one question that needs an answer: *how small is too small?*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定将系统建模为一组微服务，就会有一个需要回答的问题：太小了有多小？
- en: 'The answer is always tricky and probably disappointing: *it depends*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 答案总是棘手的，可能令人失望：“这取决于”。
- en: The right size of the microservices in a given system depends on the structure
    of the company as well as the ability to create software components that are easily
    manageable by a small team of developers. It also depends on the technical needs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定系统中微服务的正确大小取决于公司的结构，以及创建易于小型开发团队管理的软件组件的能力。它还取决于技术需求。
- en: Imagine a system that receives and processes banking files; as you are probably
    aware, all the payments between banks are sent in files with a specific known
    format (such as **Single Euro Payments Area** (**SEPA**) for Euro payments). One
    of the particularities of this type of systems is the large number of different
    files that the system needs to know how to process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个接收和处理银行文件的系统；您可能知道，银行之间的所有支付都以特定已知格式的文件发送（例如欧洲单一支付区域（SEPA）用于欧元支付）。这种系统的一个特点是系统需要知道如何处理大量不同类型的文件。
- en: The first approach for this problem is tackling it from the microservices point
    of view, separating it from any other service creating a unit of work, and creating
    one microservice for each type of file. It will enable us to be able to rollout
    modifications for the existing file processors without interfering with the rest
    of the system. It will also enable us to keep processing files even though one
    of the services is experiencing problems.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一种方法是从微服务的角度来解决，将其与任何其他服务分离，创建一个工作单元，并为每种类型的文件创建一个微服务。这将使我们能够在不干扰系统其他部分的情况下推出现有文件处理器的修改。这也将使我们能够在一个服务出现问题时继续处理文件。
- en: The microservices should be as small as needed, but keep in mind that every
    microservice adds an overhead to the operations team that needs to manage a new
    service. Try to answer the question *how small is too small?* in terms of manageability,
    scalability, and specialization. The microservice should be small enough to be
    managed and scaled up (or down) quickly without affecting the rest of the system,
    by a single person; and it should do only one thing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该足够小，但要记住，每个微服务都会给运维团队增加负担，他们需要管理一个新的服务。试着从可管理性、可扩展性和专业化的角度回答“太小了有多小？”这个问题。微服务应该足够小，可以由一个人快速管理和扩展（或缩小），而不影响系统的其他部分；它应该只做一件事。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As a general rule, a microservice should be small enough to be completely rewritten
    in a sprint.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个一般规则，一个微服务应该足够小，可以在一个迭代中完全重写。
- en: Key benefits
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键好处
- en: In the previous topic, we talked about what a microservices-oriented architecture
    is. I also exposed the design principles that I have learned from experience,
    as well as showed a few benefits of this type of architecture.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的话题中，我们谈到了什么是面向微服务的架构。我还介绍了我从经验中学到的设计原则，以及这种架构的一些好处。
- en: Now, it is time to outline these key benefits and show how they will help us
    to improve the quality of our software, as well as be able to quickly accommodate
    the new business requirements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候概述这些关键好处，并展示它们将如何帮助我们提高软件质量，以及能够快速适应新的业务需求。
- en: Resilience
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性
- en: Resilience is defined in Wikipedia as *the ability of a system to cope with
    change*. I like to think about resilience as the *ability of a system to gracefully
    recover from an exception* (transitory hardware failure, unexpectedly high network
    latency, and so on) or a stress period without affecting the performance of the
    system once the situation has been resolved.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科中将弹性定义为“系统应对变化的能力”。我喜欢将弹性看作是“系统从异常中优雅恢复的能力”（瞬时硬件故障，意外高网络延迟等），或者在压力期间不影响系统性能的能力，一旦情况得到解决。
- en: Although it sounds simple, when building microservices-oriented software, the
    source of problems broadens due to the distributed nature of the system, sometimes
    making it hard (or even impossible) to prevent all abnormal situations.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管听起来很简单，但在构建面向微服务的软件时，由于系统的分布性质，问题的来源变得更加广泛，有时很难（甚至不可能）防止所有异常情况。
- en: 'Resilience is the ability to gracefully recover from errors. It also adds another
    level of complexity: if one microservice is experiencing problems, can we prevent
    a general failure? Ideally, we should build our system in a way that the service
    response is degraded instead of resulting in a general failure, although this
    is not always easy.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是从错误中优雅地恢复的能力。它还增加了另一层复杂性：如果一个微服务遇到问题，我们能否防止一般性的失败？理想情况下，我们应该以一种方式构建我们的系统，使服务响应降级而不是导致一般性的失败，尽管这并不总是容易的。
- en: Scalability
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Nowadays, one of the common problems in companies is the scalability of the
    systems. If you have worked on a monolithic software before, I am sure that you
    have experienced capacity problems at some point, alongside the growth of the
    company.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，公司中常见的问题之一是系统的可伸缩性。如果您以前曾在单片软件上工作过，我相信您在公司增长的同时曾经遇到过容量问题。
- en: Usually, these problems are not across all the layers or subsystems of the application.
    There is always a subsystem or service that performs significantly slower than
    the rest, causing the entire application to fail if it is not able to cope with
    the demand.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些问题并不跨越应用程序的所有层或子系统。总会有一个子系统或服务的性能明显比其他部分慢，导致整个应用程序无法满足需求而失败。
- en: 'The following diagram describes how a microservice can be scaled up (two mailing
    services) without interfering with the rest of the system:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了如何扩展微服务（两个邮件服务），而不会干扰系统的其他部分：
- en: '![Scalability](img/B04889_01_04.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![可伸缩性](img/B04889_01_04.jpg)'
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An example of these weak points in the world of car insurance is the service
    that calculates the quote for a given list of risk factors. Would it make sense
    to scale the full application just to satisfy the demand for this particular part?
    If the answer that you have in mind is *no*, you are one step closer to embracing
    microservices. Microservices enable you to scale parts of the system as the demand
    ramps up for a particular area of it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在汽车保险领域中，一个弱点的例子是计算给定风险因素列表的报价的服务。为了满足这一特定部分的需求，扩展整个应用程序是否有意义？如果你心中的答案是*不*，那么你离微服务更近了一步。微服务使您能够在特定区域的需求增加时扩展系统的部分。
- en: If our insurance system was a microservice-oriented software, the only thing
    needed to resolve the high demand for quote calculations would've been to spawn
    more instances of the microservice (or microservices) responsible for their calculation.
    Please bear in mind that scaling up services could add an overhead for operating
    them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的保险系统是面向微服务的软件，解决报价计算的高需求所需的唯一事情就是生成更多负责计算的微服务实例（或微服务）。请记住，扩展服务可能会增加操作的开销。
- en: Technology heterogeneity
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术异构
- en: The world of software is changing every few months. New languages are coming
    to the industry as a de facto standard for a certain type of systems. A few years
    ago, Ruby on Rails appeared at the scene and rose as one of the most used web
    frameworks for new projects in 2013\. Golang (a language created by Google) is
    becoming a trend nowadays as it combines huge performance with an elegant and
    simple syntax that can be learned by anyone with some experience in another programming
    language in a matter of days.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 软件世界每隔几个月都在变化。新的语言正在成为某种类型系统的事实标准。几年前，Ruby on Rails出现在舞台上，并成为2013年新项目中最常用的Web框架之一。Golang（由谷歌创建的语言）如今正在成为一种趋势，因为它将巨大的性能与优雅简单的语法结合在一起，可以在几天内被任何有其他编程语言经验的人学会。
- en: In the past, I have used Python and Java as successful alternatives to write
    microservices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，我曾使用Python和Java作为编写微服务的成功替代方案。
- en: Java especially, since Spring Boot was released, is an attractive technology
    stack to write agile (to write and operate) microservices.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是自从Spring Boot发布以来，Java是一个吸引人的技术栈，用于编写敏捷（编写和操作）微服务。
- en: Django, is also a powerful framework on Python to write microservices. Being
    very similar to Ruby on Rails, it automates database migrations and makes the
    creation of **CRUD** (**Create Read Update Delete**) services an incredibly easy
    task.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Django，也是一个强大的Python框架，用于编写微服务。它与Ruby on Rails非常相似，自动化数据库迁移，并使创建**CRUD**（创建读取更新删除）服务变得非常容易。
- en: Node.js took the advantage of a well-known language, JavaScript, to create a
    new server-side stack that is changing the way engineers create new software.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js利用了一种众所周知的语言JavaScript，创建了一个改变工程师创建新软件方式的新的服务器端堆栈。
- en: 'So, what is wrong in combining all of them? In all fairness, it is an advantage:
    *we can choose the right tool for the right job*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，将它们结合起来有什么问题吗？公平地说，这是一个优势：*我们可以选择合适的工具来做合适的工作*。
- en: Microservices-oriented architectures enable you to do it, as long as the integration
    technologies are standard. As you learned before, a microservice is a *small and
    independent piece of software that can operate by itself*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 只要集成技术是标准的，微服务导向的架构使您能够这样做。正如您之前学到的，微服务是*一个可以独立运行的小型软件*。
- en: 'The following diagram shows how the microservices hide data storage/gathering,
    having only the communication points in common—making them a good example of low
    coupling (one service implementation change won''t interfere with any other service):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了微服务如何隐藏数据存储/收集，只有通信点是共同的——这使它们成为低耦合的一个很好的例子（一个服务实现的更改不会干扰任何其他服务）：
- en: '![Technology heterogeneity](img/B04889_01_05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![技术异构](img/B04889_01_05.jpg)'
- en: We have talked about performance earlier. There are always parts of our systems
    that are under more pressure than others. With modern multicore CPUs, parallel
    (concurrent) programming could solve some of these performance issues, however,
    Node.js is not a good language to parallelize tasks. We could choose to rewrite
    the microservice under pressure using a more appropriate language, such as Erlang,
    to manage concurrency in a more elegant way. It should take no more than two weeks
    to do it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经谈到了性能。我们的系统中总会有一些部分承受的压力比其他部分大。使用现代多核CPU，并行（并发）编程可以解决一些性能问题，然而，Node.js不是一个很好的并行化任务的语言。我们可以选择使用更合适的语言，比如Erlang，来重写承受压力的微服务，以更优雅的方式管理并发。这应该不会超过两周的时间。
- en: 'There is a downside to using multiple technologies on the same system: the
    developers and system administrators need to know all (or a few) of them. Companies
    that embraced microservices usually try to stick with one core technology (in
    this book, we will be using Node.js) and some auxiliary technologies (although
    we will be using Docker to manage the deployments, we could use Capistrano or
    Fabricator to manage the releases).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一系统上使用多种技术也有不利之处：开发人员和系统管理员需要了解所有（或部分）技术。采用微服务的公司通常会尝试坚持一种核心技术（在本书中，我们将使用Node.js）和一些辅助技术（尽管我们将使用Docker来管理部署，我们也可以使用Capistrano或Fabricator来管理发布）。
- en: Replaceability
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可替换性
- en: Replaceability is the ability to change one component of a system without interfering
    with how the system behaves.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可替换性是指在不干扰系统行为的情况下更改系统组件的能力。
- en: 'When talking about software, replaceability comes along with low coupling.
    We should be writing our microservices in a way that the internal logic will not
    be exposed to the calling services so that the clients of a given service do not
    need to know about how it is implemented, just the interface. Let''s take a look
    at the following example. It is written in Java as we only need to see the interface
    to identify the pitfalls:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到软件时，可替换性伴随着低耦合。我们应该以一种方式编写我们的微服务，使得内部逻辑不会暴露给调用服务，这样给定服务的客户端不需要知道它是如何实现的，只需要知道接口。让我们看下面的例子。它是用Java编写的，因为我们只需要看到接口就能识别出问题：
- en: '[PRE1]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This interface, at first look, is self explanatory. It checks whether a given
    IP is in a given country and throws a `SOAPFaultException`, which is a big problem.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口，乍一看，就很清楚。它检查给定IP是否在给定国家，并抛出一个`SOAPFaultException`，这是一个大问题。
- en: 'If we build the client that consumes this service, factoring into their logic,
    capture, and processing of the `SoapFaultException`, we are exposing internal
    implementation details to the outer world and making it hard to replace the `GeoIpService`
    interface. Also, the fact that we are creating a service related to a part of
    our application logic is an indication of the creation of a **bounded context**:
    a highly cohesive service or set of services that work together to achieve one
    purpose.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建了消费此服务的客户端，将`SoapFaultException`的捕获和处理纳入其逻辑，我们就向外界暴露了内部实现细节，并且使得替换`GeoIpService`接口变得困难。此外，我们创建与应用程序逻辑部分相关的服务的事实表明我们正在创建一个**有界上下文**：一个高度内聚的服务或一组服务，它们共同工作以实现一个目的。
- en: Independence
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立性
- en: 'No matter how hard we try, the human brain is not designed to solve complex
    problems. The most efficient mode of functioning for the human brain is one thing
    at the time so that we *break down complex problems into smaller ones*. Microservices-oriented
    architectures should follow this approach: all the services should be independent
    and interact through the interface up to a point that they can be developed by
    different groups of engineers without any interaction, aside from agreeing the
    interfaces. This will enable a company adopting microservices to scale up, or
    down, the engineering teams, depending on the business needs, making the business
    agile in responding to peaks of demand or periods of quietness.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何努力，人脑并不是设计来解决复杂问题的。人脑最有效的运作模式是一次只处理一件事，这样我们就可以*将复杂问题分解为更小的问题*。面向微服务的架构应该遵循这种方法：所有服务应该是独立的，并通过接口进行交互，直到可以由不同的工程师组开发而无需任何交互，除了达成接口协议。这将使得采用微服务的公司能够根据业务需求扩大或缩小工程团队，使得业务能够灵活地应对需求高峰或低谷期。
- en: Why is replaceability important?
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么可替换性很重要？
- en: In a previous section, we talked about the right size of a microservice. As
    a general rule of thumb, a team should be able to rewrite and deploy a microservice
    in a sprint. The reason behind it is the **technical debt**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们谈到了微服务的合适规模。作为一个经验法则，一个团队应该能够在一个迭代中重写并部署一个微服务。其背后的原因是**技术债务**。
- en: I would define technical debt as the deviation from the original technical design
    to deliver the expected functionality within a planned deadline. Some of these
    sacrifices or wrong assumptions often lead to poorly written software that needs
    to be completely refactored or rewritten.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我将技术债务定义为从原始技术设计偏离以在计划的截止日期内交付预期功能。这些牺牲或错误的假设通常导致需要完全重构或重写的糟糕软件。
- en: In the preceding example, the interface is exposing to the outer world the fact
    that we are using **SOAP** to call a web service, but we will need to change the
    code on the client side as a REST client has certainly nothing to do with SOAP
    exceptions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，接口向外界暴露了我们使用**SOAP**调用Web服务的事实，但我们需要在客户端代码中进行更改，因为REST客户端肯定与SOAP异常无关。
- en: Easy to deploy
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 易于部署
- en: Microservices should be easy to deploy.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该易于部署。
- en: Being software developers, we are well aware that a lot of things could go wrong,
    preventing a software from being deployed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发人员，我们深知很多事情可能会出错，阻止软件部署。
- en: 'Microservices, as stated before, should be easy to deploy for a number of reasons,
    as stated in the following list:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，微服务应该易于部署，出于多种原因，如下列表所述：
- en: Small amount of business logic (remember the *two weeks re-write from scratch*
    rule of thumb) leading into simpler deployments.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 少量业务逻辑（记住*从零开始重写两周*的经验法则）导致更简单的部署。
- en: Microservices are autonomous units of work, so upgrading a service is a contained
    problem on a complex system. No need to re-deploy the entire system.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是自主的工作单元，因此升级服务是复杂系统中的一个封闭问题。无需重新部署整个系统。
- en: Infrastructure and configuration on microservices architectures should be automated
    as much as possible. Later in the book, we will learn how to use Docker to deploy
    microservices and what are the benefits over the traditional deployment techniques
    are.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构中的基础设施和配置应尽可能自动化。在本书的后面，我们将学习如何使用Docker部署微服务以及传统部署技术的好处。
- en: SOA versus microservices
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOA与微服务
- en: '**Service-Oriented Architectures** (**SOA**) has been around for a number of
    years. SOA is a great principle to design software. They are self-contained components
    providing services to other components. As we agreed before, it is all about maintaining
    low coupling on the different modules of the system as if it was a puzzle so that
    we can replace the pieces without causing a big impact on the overall system.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务的架构**（**SOA**）已经存在了很多年。SOA是设计软件的一个很好的原则。它们是为其他组件提供服务的自包含组件。正如我们之前所同意的，这一切都是关于在系统的不同模块之间保持低耦合，就像拼图一样，这样我们就可以替换部件而不会对整个系统造成重大影响。'
- en: In principle, SOA looks very similar to microservices architectures. So what
    is the difference?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，SOA看起来与微服务架构非常相似。那么区别在哪里呢？
- en: 'Microservices are fine-grained SOA components. In other words, a single SOA
    component can be decomposed in a number of microservices that can work together
    in order to provide the same level of functionality:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是细粒度的SOA组件。换句话说，单个SOA组件可以分解为多个微服务，这些微服务可以共同工作以提供相同级别的功能：
- en: '![SOA versus microservices](img/B04889_01_06.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![SOA与微服务](img/B04889_01_06.jpg)'
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Microservices are fine-grained SOA components. They are lightweight services
    with a narrow focus.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是细粒度的SOA组件。它们是专注于狭窄领域的轻量级服务。
- en: Another difference between microservices and SOA is the technologies used for
    interconnecting and writing the services.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和SOA之间的另一个区别是用于互连和编写服务的技术。
- en: J2EE is a technology stack that was designed to write SOA architectures as it
    enforced enterprise standards. Java Naming and Directory Interface, Enterprise
    Java Beans, and **Enterprise Service Bus** (**ESB**) were the ecosystems where
    SOA applications were built and maintained. Although ESB is a standard, very few
    engineers who graduated after 2005 have heard about ESB, even fewer have used
    it, and nowadays the modern frameworks such as Ruby on Rails do not even consider
    such complex pieces of software.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: J2EE是一个旨在编写SOA架构的技术栈，因为它强制执行企业标准。Java命名和目录接口，企业JavaBean和**企业服务总线**（**ESB**）是构建和维护SOA应用程序的生态系统。尽管ESB是一个标准，但在2005年后毕业的工程师中很少有人听说过ESB，甚至更少的人使用过它，而如今的现代框架如Ruby
    on Rails甚至不考虑这样复杂的软件。
- en: On the other hand, microservices enforce the use of standards (such as HTTP)
    that are broadly known and broadly interoperable. We can choose the right language
    or tool to build a component (microservice) following one of the key benefits
    explained earlier in this chapter, in the *Technology heterogeneity* section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，微服务强制使用广泛知名和广泛可互操作的标准（如HTTP）。我们可以选择正确的语言或工具来构建一个组件（微服务），遵循本章前面解释的关键优势之一，在*技术异构性*部分。
- en: 'Aside from the technology stack and the size of the services, there is an even
    bigger difference between SOA and microservices: the domain model. Earlier in
    this chapter, we have talked about decentralization. Decentralization of the governance,
    but, moreover, decentralization of the data. In a microservices-based software,
    every microservice should store its own data locally, isolating the domain models
    to a single service; whereas, on an SOA oriented-software, the data is usually
    stored in a few big databases and the services share the domain models.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了技术栈和服务的规模之外，SOA和微服务之间还有一个更大的区别：领域模型。在本章的前面，我们已经谈到了分权化。治理的分权化，更重要的是数据的分权化。在基于微服务的软件中，每个微服务都应该在本地存储自己的数据，将领域模型隔离到单个服务中；而在面向SOA的软件中，数据通常存储在几个大型数据库中，服务共享领域模型。
- en: Why Node.js?
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Node.js？
- en: A few years ago, I didn't believe in Node.js. To me, it was a trend more than
    a real tool to solve problems… JavaScript in the server? That didn't look right.
    In all fairness, I didn't even like JavaScript. Then, the modern frameworks such
    as jQuery or Angular.js came to the rescue. They solved one of the problems, which
    was the cross-browser compatibility. Where before we needed to factor in at least
    three different browsers, after jQuery all this logic was nicely encapsulated
    in a library so that we didn't need to worry about compatibility as long as we
    followed the jQuery documentation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我不相信Node.js。对我来说，它更像是一种解决问题的真正工具而不是趋势……在服务器上使用JavaScript？那看起来不对劲。公平地说，我甚至不喜欢JavaScript。然后，现代框架如jQuery或Angular.js出现了。它们解决了一个问题，即跨浏览器兼容性。在使用jQuery之前，我们需要考虑至少三种不同的浏览器，但使用jQuery后，所有这些逻辑都被很好地封装在一个库中，只要我们遵循jQuery的文档，就不需要担心兼容性。
- en: Then, JavaScript became more popular. Suddenly, all the internal tools were
    written with **Single-Page Application** (**SPA**) frameworks with a heavy usage
    of JavaScript, therefore, the majority of developers nowadays, one way or another,
    are proficient in JavaScript.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，JavaScript变得更受欢迎。突然之间，所有内部工具都是用**单页应用**（**SPA**）框架编写的，大量使用JavaScript，因此，如今大多数开发人员或多或少都精通JavaScript。
- en: Then, someone decided to take JavaScript out of the browser, which was a great
    idea. Rhino, Node.js, and Nashorn are examples of runtimes that can execute standalone
    JavaScript. Some of them can even interact with the Java code, enabling the developer
    to import Java classes into a JavaScript program, which gives you the access to
    an endless set of frameworks already written in Java.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有人决定将JavaScript从浏览器中移出，这是一个很好的主意。Rhino、Node.js和Nashorn是可以执行独立JavaScript的运行时的例子。它们中的一些甚至可以与Java代码交互，使开发人员能够将Java类导入JavaScript程序，从而获得对已经用Java编写的无数框架的访问。
- en: 'Let''s focus on **Node.js**. Node.js is the perfect candidate for microservices-oriented
    architectures for a number of reasons, as stated in the following list:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于**Node.js**。Node.js是面向微服务架构的完美候选者，原因如下列表所述：
- en: Easy to learn (although it can be hard to master)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于学习（尽管可能很难掌握）
- en: Easy to scale
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展
- en: Highly testable
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度可测试
- en: Easy to deploy
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于部署
- en: Dependency management through **npm**
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**npm**进行依赖管理
- en: There are hundreds of libraries to integrate with the majority of standard protocols
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有数百个库可以与大多数标准协议集成
- en: These reasons, along with others that we will develop in the following chapters,
    make Node.js the perfect candidate for building solid microservices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原因，以及我们将在接下来的章节中开发的其他原因，使Node.js成为构建可靠微服务的完美候选者。
- en: API aggregation
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API聚合
- en: '**Seneca** is the framework that I have chosen for development in the following
    chapters. One of the most attractive characteristics of Seneca is API aggregation.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**Seneca**是我在接下来的章节中选择的框架。Seneca最吸引人的特点之一是API聚合。'
- en: API aggregation is an advanced technique to compose an interface by aggregating
    different functionalities (plugins, methods, and so on) to it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: API聚合是一种高级技术，通过聚合不同的功能（插件、方法等）来组成一个接口。
- en: 'Let''s take a look at the following example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE2]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding example uses Express, a very popular web framework for Node.js.
    This framework is also built around the API aggregation technique. Let's take
    a look at the fourth and seventh lines. In these lines, the developer registers
    two methods that are to be executed when someone hits the URLs `/sayhello` and
    `/saygoodbye` with a GET request. In other words, the application is composed
    of different smaller and independent implementations that are exposed to the outer
    world on a single interface, in this case, an app listening on the `3000` port.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子使用了Express，这是一个非常流行的Node.js Web框架。这个框架也是围绕API聚合技术构建的。让我们看一下第四行和第七行。在这些行中，开发人员注册了两种方法，当有人用GET请求命中URL
    `/sayhello` 和 `/saygoodbye` 时，这些方法将被执行。换句话说，该应用程序由不同的较小和独立的实现组成，这些实现在单个接口上向外部世界公开，即在`3000`端口上监听的应用程序。
- en: In the following chapters, I will explain why this property is important and
    how to take advantage of it when building (and scaling) microservices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将解释为什么这个属性很重要，以及在构建（和扩展）微服务时如何利用它。
- en: The future of Node.js
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js的未来
- en: JavaScript was first designed to be a language executed in the web browser.
    For those who worked or studied, using C/C++ was very familiar and that was the
    key for its adoption as a standard for the dynamic manipulation of documents in
    Web 2.0\. **Asynchronous JavaScript and XML** (**AJAX**) was the detonator for
    JavaScript growth. Different browsers had different implementations of the request
    objects so that the developers had a hard time to write a cross-browser code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最初是设计为在Web浏览器中执行的语言。对于那些工作或学习过的人来说，使用C/C++非常熟悉，这是它作为Web 2.0动态文档操作标准的关键。**异步JavaScript和XML**（**AJAX**）是JavaScript增长的催化剂。不同的浏览器对请求对象有不同的实现，因此开发人员很难编写跨浏览器代码。
- en: The lack of standards led to the creation of many frameworks that encapsulated
    the logic behind AJAX, making easy-to-write cross-browser scripts.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的缺乏导致了许多框架的创建，这些框架封装了AJAX背后的逻辑，使得跨浏览器脚本编写变得容易。
- en: JavaScript is a script language. It was not designed to be object oriented,
    neither was it designed to be the language of choice for large applications as
    the code tends to get chaotic and it is hard to enforce standards across different
    companies on how the code should be laid out. Every single company where I worked
    has different *best practices* and some of them are even contradictory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种脚本语言。它并不是为了面向对象而设计的，也不是为了成为大型应用程序的首选语言，因为代码往往会变得混乱，很难在不同公司之间强制执行代码的布局标准。我工作过的每家公司都有不同的*最佳实践*，有些甚至是相互矛盾的。
- en: '**European Computer Manufacturers Association** (**ECMA**) came to the rescue.
    **ECMAScript 6**, the next standard for ECMA languages (JavaScript, ActionScript,
    Rhino, and so on) introduces the concept of classes, inheritance, collections,
    and a number of interesting features that will make the development of JavaScript
    software easier and more standard than the actual V8 specification.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧洲计算机制造商协会**（**ECMA**）挺身而出。**ECMAScript 6**，ECMA语言（JavaScript、ActionScript、Rhino等）的下一个标准引入了类、继承、集合等概念，以及一些有趣的功能，这将使JavaScript软件的开发比实际的V8规范更容易和更标准。'
- en: One of these features that I consider more interesting is the introduction of
    the **class** keyword that allows us to model our JavaScript software with objects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为最有趣的一个特性之一是引入了**class**关键字，它允许我们用对象来建模我们的JavaScript软件。
- en: At the moment, the majority of browsers support a large number of these features,
    but when it comes to Node.js, only a few of them are implemented by default and
    some of them are implemented by passing special flags to the interpreter (harmony
    flags).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，大多数浏览器支持大量这些功能，但是当涉及到Node.js时，默认情况下只有少数功能被实现，一些功能需要通过向解释器传递特殊标志（harmony标志）来实现。
- en: In this book, I will try to avoid the ECMAScript 6 features, sticking to the
    V8 specification as it is widely known by the majority of developers and, once
    someone knows JavaScript V8, it is fairly easy to ramp up on ECMAScript 6.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将尽量避免使用ECMAScript 6的特性，而是坚持使用V8规范，因为它被大多数开发人员所熟知，一旦有人了解了JavaScript V8，就很容易上手ECMAScript
    6。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we studied the key concepts around microservices, as well as
    the best practices to be followed when designing high-quality software components
    towards building robust and resilient software architectures that enable us to
    respond quickly to the business needs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了围绕微服务的关键概念，以及在设计高质量软件组件时应遵循的最佳实践，以构建健壮和有弹性的软件架构，使我们能够快速响应业务需求。
- en: You have also learned the key benefits such as the possibility of using the
    right language for the right service (technology heterogeneity) on the microservices-oriented
    architectures as well as some of the pitfalls that could make our life harder,
    such as the overhead on the operational side caused by the distributed nature
    of the microservices-oriented architectures.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学到了一些关键的好处，比如在面向微服务的架构中使用合适的语言来提供合适的服务（技术异构性），以及一些可能让我们的生活变得更加困难的陷阱，比如由于微服务导致的操作负担。
- en: Finally, we discussed why Node.js is a great tool for building microservices,
    as well as how we could benefit from JavaScript to build high-quality software
    components through techniques like API aggregation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了为什么Node.js是构建微服务的好工具，以及我们如何能够通过JavaScript从API聚合等技术来构建高质量的软件组件。
- en: In the following chapters, we will be developing the concepts discussed in this
    chapter, with code examples and further explanation about the topics I have learned
    over the years.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将开发本章讨论的概念，提供代码示例，并进一步解释我多年来学到的主题。
- en: As explained before, we will focus on the V8 version of JavaScript, but I will
    provide some hints on how to easily write upgradeable components to embrace ECMAScript
    6.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所解释的，我们将专注于JavaScript的V8版本，但我将提供一些提示，介绍如何轻松编写可升级的组件以适应ECMAScript 6。
