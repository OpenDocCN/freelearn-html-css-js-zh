- en: Chapter 1. Introduction and Composition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。介绍和构成
- en: High performance is hard, and it depends on many factors. Best performance should
    be a constant goal for developers. To achieve it, a developer must know the programming
    language they use and, more importantly, how the language performs under heavy
    loads, these being disk, memory, network, and processor usage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能很难，它取决于许多因素。开发人员应该不断追求最佳性能。为了实现这一点，开发人员必须了解他们使用的编程语言，更重要的是，了解语言在重负载下的性能表现，包括磁盘、内存、网络和处理器的使用情况。
- en: Developers will make the most out of a language if they know its weaknesses.
    In a perfect world, since every job is different, a developer should look for
    the best tool for the job. But this is not feasible and a developer wouldn't be
    able to know every best tool, so they have to look for the second best tool for
    every job. A developer will excel if they know few tools but master them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员只有了解语言的弱点，才能充分利用它。在一个完美的世界中，由于每个工作都不同，开发人员应该寻找最适合工作的工具。但这是不可行的，开发人员不可能知道每个最佳工具，因此他们必须为每个工作寻找第二最佳的工具。如果开发人员了解少量工具但能够精通它们，他们将会表现出色。
- en: As a metaphor, a hammer is used to drive nails, and you can also use it to break
    objects apart or forge metals, but you shouldn't use it to drive screws. The same
    applies to languages and platforms. Some platforms are very good for a lot of
    jobs but perform really badly at other jobs. This performance can sometimes be
    mitigated, but at other times, can't be avoided and you should look for better
    tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为隐喻，锤子用来钉钉子，你也可以用它来打碎物体或锻造金属，但不应该用它来拧螺丝。语言和平台也是如此。有些平台非常适合做很多工作，但在其他工作上表现非常糟糕。有时可以缓解这种性能问题，但有时无法避免，这时就需要寻找更好的工具。
- en: Node.js is not a language; it's actually a platform built on top of V8, Google's
    open source JavaScript engine. This engine implements ECMAScript, which itself
    is a simple and very flexible language. I say "simple" because it has no way of
    accessing the network, accessing the disk, or talking to other processes. It can't
    even stop execution since it has no kind of exit instruction. This language needs
    some kind of interface model on top of it to be useful. Node.js does this by exposing
    a (preferably) nonblocking I/O model using libuv. This nonblocking API allows
    you to access the filesystem, connect to network services and execute child processes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js不是一种语言；它实际上是建立在V8之上的平台，V8是谷歌开源的JavaScript引擎。这个引擎实现了ECMAScript，它本身是一种简单而非常灵活的语言。我说“简单”，是因为它没有访问网络、访问磁盘或与其他进程通信的方式。它甚至无法停止执行，因为它没有任何退出指令。这种语言需要在其上面构建一种接口模型才能发挥作用。Node.js通过使用libuv暴露了一个（最好是）非阻塞的I/O模型来实现这一点。这种非阻塞API允许您访问文件系统，连接到网络服务并执行子进程。
- en: 'The API also has two other important elements: buffers and streams. Since JavaScript
    strings are Unicode friendly, buffers were introduced to help deal with binary
    data. Streams are used as simple event interfaces to pass data around. Buffers
    and streams are used all over the API when reading file contents or receiving
    network packets.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: API还有另外两个重要元素：缓冲区和流。由于JavaScript字符串对Unicode友好，引入了缓冲区来处理二进制数据。流用作简单的事件接口来传递数据。在读取文件内容或接收网络数据包时，API中到处都使用缓冲区和流。
- en: A stream is a module, similar to the network module. When loaded, it provides
    access to some base classes that help create readable, writable, duplex, and transform
    streams. These can be used to perform all sorts of data manipulation in a simplified
    and unified format.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 流是一个模块，类似于网络模块。加载后，它提供对一些基本类的访问，这些类有助于创建可读、可写、双工和转换流。这些可以用来以简化和统一的格式执行各种数据操作。
- en: The buffers module easily becomes your best friend when converting binary data
    formats to some other format, for example, JSON. Multiple read and write methods
    help you convert integers and floats, signed or not, big endian or little endian,
    from 8 bits to 8 bytes long.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当将二进制数据格式转换为其他格式（例如JSON）时，缓冲区模块很容易成为您的好朋友。多个读取和写入方法帮助您转换整数和浮点数，有符号或无符号，大端或小端，从8位到8字节长。
- en: Most of the platform is designed to be simple, small, and stable. It's designed
    and ready to create some high-performance applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分平台都设计成简单、小巧和稳定。它们被设计和准备用来创建一些高性能的应用程序。
- en: Performance analysis
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: Performance is the amount of work completed in a defined period of time and
    with a set of defined resources. It can be analyzed using one or more metrics
    that depend on the performance goal. The goal can be low latency, low memory footprint,
    reduced processor usage, or even reduced power consumption.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是在一定时间内使用一组定义的资源完成的工作量。可以使用一个或多个取决于性能目标的度量标准来分析性能。目标可以是低延迟、低内存占用、减少处理器使用，甚至减少功耗。
- en: The act of performance analysis is also called **profiling**. Profiling is very
    important for making optimized applications and is achieved by instrumenting either
    the source or the instance of the application. By instrumenting the source, developers
    can spot common performance weak spots. By instrumenting an application instance,
    they can test the application on different environments. This type of instrumentation
    can also be known by the name **benchmarking**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析的行为也被称为**分析**。分析对于制作优化的应用程序非常重要，可以通过对应用程序的源代码或实例进行仪器化来实现。通过对源代码进行仪器化，开发人员可以发现常见的性能弱点。通过对应用程序实例进行仪器化，他们可以在不同的环境中测试应用程序。这种类型的仪器化也可以被称为**基准测试**。
- en: Node.js is known for being fast. Actually, it's not that fast; it's just as
    fast as your resources allow it. What Node.js is best at is not blocking your
    application because of an I/O task. The perception of performance can be misleading
    in Node.js applications. In some other languages, when an application task gets
    blocked—for example, by a disk operation—all other tasks can be affected. In the
    case of Node.js, this doesn't happen—usually.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 以快速著称。实际上，它并不是那么快；它只能达到你的资源允许的速度。Node.js 最擅长的是不会因为 I/O 任务而阻塞你的应用程序。在
    Node.js 应用程序中，性能的感知可能会误导。在其他一些语言中，当应用程序任务被阻塞时——例如，由于磁盘操作——所有其他任务都会受到影响。但在 Node.js
    中，这种情况通常不会发生。
- en: Some people look at the platform as being single threaded, which isn't true.
    Your code runs on a thread, but there are a few more threads responsible for I/O
    operations. Since these operations are extremely slow compared to the processor's
    performance, they run on a separate thread and signal the platform when they have
    information for your application. Applications blocking I/O operations perform
    poorly. Since Node.js doesn't block I/O unless you want it to, other operations
    can be performed while waiting for I/O. This greatly improves performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为这个平台是单线程的，这是不正确的。你的代码在一个线程上运行，但还有一些线程负责 I/O 操作。由于这些操作与处理器性能相比极其缓慢，它们在一个单独的线程上运行，并在它们为你的应用程序提供信息时通知平台。阻塞
    I/O 操作的应用程序性能不佳。由于 Node.js 不会阻塞 I/O，除非你希望它这样做，因此在等待 I/O 时可以执行其他操作。这极大地提高了性能。
- en: V8 is an open source Google project and is the JavaScript engine behind Node.js.
    It's responsible for compiling and executing JavaScript, as well as managing your
    application's memory needs. It is designed with performance in mind. V8 follows
    several design principles to improve language performance. The engine has a profiler
    and one of the best and fast garbage collectors that exist, which is one of the
    keys to its performance. It also does not compile the language into byte code;
    it compiles it directly into machine code on the first execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: V8 是一个开源的谷歌项目，是 Node.js 背后的 JavaScript 引擎。它负责编译和执行 JavaScript，以及管理应用程序的内存需求。它是以性能为目标设计的。V8
    遵循几个设计原则来提高语言性能。该引擎具有分析器和最好和最快的垃圾收集器之一，这是其性能的关键之一。它也不会将语言编译成字节码；它会在第一次执行时直接将其编译成机器码。
- en: 'A good background in the development environment will greatly increase the
    chances of success in developing high-performance applications. It''s very important
    to know how dereferencing works, or why your variables should avoid switching
    types. Here are other useful tips you would want to follow. You can use a style
    guide like JSCS and a linter like JSHint to enforce them to for yourself and your
    team. Here are some of them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中具有良好的背景将极大地增加开发高性能应用程序成功的机会。了解解引用的工作原理或者为什么你的变量应该避免切换类型非常重要。以下是其他一些有用的提示，你可能想要遵循。你可以使用像
    JSCS 这样的样式指南和像 JSHint 这样的代码检查工具来强制执行它们，对自己和团队都是如此。以下是其中一些：
- en: Write small functions, as they're more easily optimized
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写小函数，因为它们更容易优化
- en: Use monomorphic parameters and variables
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单态参数和变量
- en: Prefer arrays to manipulate data, as integer-indexed elements are faster
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更喜欢使用数组来操作数据，因为整数索引元素更快
- en: Try to have small objects and avoid long prototype chains
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量使用小对象，避免长的原型链。
- en: Avoid cloning objects because big objects will slow the operations
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免克隆对象，因为大对象会减慢操作
- en: Monitoring
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控
- en: After an application is put into production mode, performance analysis becomes
    even more important, as users will be more demanding than you were. Users don't
    accept anything that takes more than a second, and monitoring the application's
    behavior over time and over some specific loads will be extremely important, as
    it will point to you where your platform is failing or will fail next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序投入生产模式后，性能分析变得更加重要，因为用户的要求会比你更苛刻。用户不会接受任何超过一秒的东西，随着时间和特定负载的增加，监控应用程序的行为将变得极为重要，因为它将指出你的平台在哪里出现了问题或将在下一步出现问题。
- en: 'Yes, your application may fail, and the best you can do is be prepared. Create
    a backup plan, have fallback hardware, and create service probes. Essentially,
    anticipate all the scenarios you can think of, and remember that your application
    will still fail. Here are some of those scenarios and aspects that you should
    monitor:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你的应用程序可能会失败，你能做的最好的就是做好准备。制定备份计划，备用硬件，并创建服务探针。基本上，预测你能想到的所有情景，并记住你的应用程序仍然会失败。以下是你应该监控的一些情景和方面：
- en: When in production, application usage is of extreme importance to understand
    where your application is heading in terms of data size or memory usage. It's
    important that you carefully define source code probes to monitor metrics—not
    only performance metrics, such as requests per second or concurrent requests,
    but also error rate and exception percentage per request served. Your application
    emits errors and sometimes throws exceptions; it's normal and you shouldn't ignore
    them.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中，应用程序的使用情况对于了解应用程序在数据大小或内存使用方面的发展方向至关重要。重要的是，你要仔细定义源代码探针来监控指标——不仅是性能指标，比如每秒请求或并发请求，还有错误率和每个请求服务的异常百分比。你的应用程序会发出错误，有时会抛出异常；这是正常的，你不应该忽视它们。
- en: Don't forget the rest of the infrastructure. If your application must perform
    at high standards, your infrastructure should too. Your server power supply should
    be uninterruptible and stable, as instability will degrade your hardware faster
    than it should.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忘记其他基础设施。如果你的应用程序必须达到高标准，你的基础设施也应该如此。你的服务器电源供应应该是不间断的和稳定的，因为不稳定会比应有的更快地降低你的硬件性能。
- en: Choose your disks wisely, as faster disks are more expensive and usually come
    in smaller storage sizes. Sometimes, however, this is actually not a bad decision
    when your application doesn't need that much storage and speed is considered more
    important. But don't just look at the gigabytes per dollar. Sometimes, it's more
    important to look at the gigabits per second per dollar.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明智地选择你的磁盘，因为更快的磁盘更昂贵，通常存储容量更小。然而，当你的应用程序不需要那么多存储空间而速度更重要时，这实际上并不是一个坏决定。但不要只看每美元的千兆字节。有时，更重要的是看每美元的千兆位每秒。
- en: Also, your server temperature and server room should be monitored. High temperatures
    degrades performance and your hardware has an operation temperature limit. Security,
    both physical and virtual, is also very important. Everything counts for the standards
    of high performance, as an application that stops serving its users is not performing
    at all.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，你的服务器温度和机房应该受到监控。高温会降低性能，你的硬件有操作温度限制。安全性，无论是物理的还是虚拟的，也非常重要。一切都符合高性能的标准，因为停止为用户提供服务的应用程序根本就不是在表现。
- en: Getting high performance
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获得高性能
- en: Planning is essential in order to achieve the best results possible. High performance
    is built from the ground up and starts with how you plan and develop. It obviously
    depends on physical resources, as you can't perform well when you don't have sufficient
    memory to accomplish your task, but it also depends greatly on how you plan and
    develop an application. Mastering tools will give much better performance chances
    than just using them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 规划对于实现最佳结果至关重要。高性能是从基础开始构建的，从你的规划和开发方式开始。这显然取决于物理资源，因为当你没有足够的内存来完成任务时，你无法表现良好，但它也极大地取决于你如何规划和开发应用程序。精通工具将比仅仅使用它们带来更好的性能机会。
- en: Setting the bar high from the beginning of development will force the planning
    to be more prudent. Some bad planning of the database layer can really downgrade
    performance. Also, cautious planning will cause developers to think more about
    use cases and program more consciously.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发的一开始就设定高标准将迫使规划更加谨慎。数据库层的糟糕规划会严重降低性能。谨慎的规划也会促使开发人员更多地考虑使用情况并更加谨慎地编程。
- en: High performance is when you have to think about a new set of resources (processor,
    memory, storage) because all that you have is exhausted, not just because one
    resource is. A high-performance application shouldn't need a second server when
    a little processor is used and the disk is full. In such a case, you just need
    bigger disks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能意味着当你的所有资源都耗尽时，你必须考虑新的资源（处理器、内存、存储），而不仅仅是因为某一资源耗尽。高性能应用程序不应该在使用少量处理器和磁盘已满时需要第二台服务器。在这种情况下，你只需要更大的磁盘。
- en: Applications can't be designed as monolithic these days. An increasing user
    base enforces a distributed architecture, or at least one that can distribute
    load by having multiple instances. This is very important to accommodate in the
    beginning of the planning, as it will be harder to change an application that
    is already in production.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的应用程序不能设计为单片式。不断增长的用户群强制采用分布式架构，或者至少可以通过多个实例分配负载。这在规划初期就很重要，因为改变已经投入生产的应用程序会更加困难。
- en: Most common applications will start performing worse over time, not because
    of deficit of processing power but because of increasing data size on databases
    and disks. You'll notice that the importance of memory increases and fallback
    disks become critical to avoiding downtime. It's very important that an application
    be able to scale horizontally, whether to shard data across servers or across
    regions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常见的应用程序随着时间的推移会表现得更差，不是因为处理能力不足，而是因为数据库和磁盘上的数据量增加。你会注意到内存的重要性增加，备用磁盘对于避免停机时间至关重要。应用程序能够水平扩展非常重要，无论是将数据分片到服务器上还是跨区域分片。
- en: A distributed architecture also increases performance. Geographically distributed
    servers can be more closed to clients and give a perception of performance. Also,
    databases distributed by more servers will handle more traffic as a whole and
    allow DevOps to accomplish zero downtime goals. This is also very useful for maintenance,
    as nodes can be brought down for support without affecting the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式架构也会提高性能。地理分布的服务器可以更接近客户端，并给人以性能感知。此外，由更多服务器分布的数据库将作为一个整体处理更多流量，并允许DevOps实现零停机目标。这对于维护也非常有用，因为节点可以在不影响应用程序的情况下进行支持。
- en: Testing and benchmarking
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和基准测试
- en: To know whether an application performs well or not under specific environments,
    we have to test it. This kind of test is called a benchmark. Benchmarking is important
    to do and it's specific to every application. Even for the same language and platform,
    different applications might perform differently, either because of the way in
    which some parts of an application were structured or the way in which a database
    was designed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道应用程序在特定环境下是否表现良好，我们必须进行测试。这种测试称为基准测试。基准测试对每个应用程序都很重要。即使是相同的语言和平台，不同的应用程序可能表现不同，这可能是因为应用程序的某些部分的结构方式或数据库设计方式不同。
- en: Analyzing the performance will indicate bottleneck of your application, or if
    you may, the parts of the application that perform not good as others. These are
    the parts that need to be improved. Constantly trying to improve the worst performing
    parts will elevate the application's overall performance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分析性能将指示应用程序的瓶颈，或者说，表现不佳的部分。这些部分需要改进。不断尝试改进表现最差的部分将提升应用程序的整体性能。
- en: 'There are plenty of tools out there, some more specific or focused on JavaScript
    applications, such as benchmarkjs ([http://benchmarkjs.com/](http://benchmarkjs.com/))
    and ben ([https://github.com/substack/node-ben](https://github.com/substack/node-ben)),
    and others more generic, such as ab ([http://httpd.apache.org/docs/2.2/programs/ab.html](http://httpd.apache.org/docs/2.2/programs/ab.html))
    and httpload ([https://github.com/perusio/httpload](https://github.com/perusio/httpload)).
    There are several types of benchmark tests depending on the goal, they are as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具可以使用，有些更专注于JavaScript应用程序，比如benchmarkjs ([http://benchmarkjs.com/](http://benchmarkjs.com/))
    和 ben ([https://github.com/substack/node-ben](https://github.com/substack/node-ben))，还有一些更通用的，比如ab
    ([http://httpd.apache.org/docs/2.2/programs/ab.html](http://httpd.apache.org/docs/2.2/programs/ab.html))
    和 httpload ([https://github.com/perusio/httpload](https://github.com/perusio/httpload))。根据目标，有几种不同类型的基准测试，它们如下：
- en: '**Load testing** is the simplest form of benchmarking. It is done to find out
    how the application performs under a specific load. You can test and find out
    how many connections an application accepts per second, or how many traffic bytes
    an application can handle. An application load can be checked by looking at the
    external performance, such as traffic, and also internal performance, such as
    the processor used or the memory consumed.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**是基准测试的最简单形式。它用于查看应用程序在特定负载下的性能。你可以测试并了解应用程序每秒接受多少连接，或者应用程序可以处理多少流量字节。应用程序的负载可以通过查看外部性能（如流量）和内部性能（如使用的处理器或消耗的内存）来检查。'
- en: '**Soak testing** is used to see how an application performs during a more extended
    period of time. It is done when an application tends to degrade over time and
    analysis is needed to see how it reacts. This type of test is important in order
    to detect memory leaks, as some applications can perform well in some basic tests,
    but over time, the memory leaks and their performance can degrade.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浸泡测试**用于查看应用程序在更长时间内的性能。当应用程序随着时间的推移而变得不稳定，需要进行分析以查看其反应时，就会进行这种测试。这种测试类型对于检测内存泄漏非常重要，因为一些应用程序在一些基本测试中可能表现良好，但随着时间的推移，内存泄漏和性能可能会下降。'
- en: '**Spike testing** is used when a load is increased very fast to see how the
    application reacts and performs. This test is very useful and important in applications
    that can have spike usages, and operators need to know how the application will
    react. Twitter is a good example of an application environment that can be affected
    by usage spikes (in world events such as sports or religious dates), and need
    to know how the infrastructure will handle them.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**峰值测试**是在负载迅速增加时使用的，以查看应用程序的反应和性能。这种测试在可能出现峰值使用的应用程序中非常有用和重要，运营商需要知道应用程序将如何反应。Twitter是一个很好的例子，它的应用环境可能会受到使用峰值的影响（比如体育赛事或宗教日期），需要知道基础设施将如何处理它们。'
- en: All of these tests can become harder as your application grows. Since your user
    base gets bigger, your application scales and you lose the ability to be able
    to load test with the resources you have. It's good to be prepared for this moment,
    especially to be prepared to monitor performance and keep track of soaks and spikes
    as your application users start to be the ones responsible for continuously test
    load.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，所有这些测试都会变得更加困难。随着用户群的增长，应用程序的规模扩大，你失去了使用现有资源进行负载测试的能力。最好为这一时刻做好准备，特别是为了监控性能并跟踪浸泡和峰值，因为你的应用程序用户开始负责持续测试负载。
- en: Composition in applications
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序中的组合
- en: Because of this continuous demand of performant applications, composition becomes
    very important. Composition is a practice where you split the application into
    several smaller and simpler parts, making them easier to understand, develop,
    and maintain. It also makes them easier to test and improve.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对高性能应用程序的持续需求，组合变得非常重要。组合是一种实践，你将应用程序分解为几个更小、更简单的部分，使它们更容易理解、开发和维护。它还使它们更容易测试和改进。
- en: Avoid creating big, monolithic code bases. They don't work well when you need
    to make a change, and they also don't work well if you need to test and analyze
    any part of the code to improve it and make it perform better.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 避免创建庞大的、单一的代码库。当你需要进行更改时，它们效果不佳，如果你需要测试和分析代码的任何部分以改进性能，也不会起作用。
- en: The Node.js platform helps you—and in some ways, forces you to—compose your
    code. **Node.js Package Manager** (**NPM**) is a great module publishing service.
    You can download other people's modules and publish your own as well. There are
    tens of thousands of modules published, which means that you don't have to reinvent
    the wheel in most cases. This is good since you can avoid wasting time on creating
    a module and use a module that is already in production and used by many people,
    which normally means that bugs will be tracked faster and improvements will be
    delivered even faster.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js平台帮助你——在某些方面，迫使你——组合你的代码。**Node.js包管理器**（**NPM**）是一个很棒的模块发布服务。你可以下载其他人的模块，也可以发布自己的模块。已经发布了数以万计的模块，这意味着在大多数情况下你不必重复造轮子。这很好，因为你可以避免浪费时间去创建一个模块，而是使用已经在生产中并被许多人使用的模块，这通常意味着错误将更快地被跟踪，改进也将更快地交付。
- en: The Node.js platform allows developers to easily separate code. You don't have
    to do this, as the platform doesn't force you to, but you should try and follow
    some good practices, such as the ones described in the following sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js平台允许开发人员轻松地分离代码。虽然平台并不强制你这样做，但你应该尝试并遵循一些良好的实践，比如下面描述的实践。
- en: Using NPM
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用NPM
- en: Don't rewrite code unless you need to. Take your time to try some available
    modules, and choose the one that is right for you. This reduces the probability
    of writing faulty code and helps published modules that have a bigger user base.
    Bugs will be spotted earlier, and more people in different environments will test
    fixes. Moreover, you will be using a more resilient module.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除非需要，否则不要重写代码。花时间尝试一些可用的模块，并选择适合您的模块。这降低了编写错误代码的概率，并有助于发布的模块具有更大的用户群。错误将更早地被发现，并且不同环境中的更多人将测试修复。此外，您将使用更具弹性的模块。
- en: One important and neglected task after starting to use some modules is to track
    changes and, whenever possible, keep using recent stable versions. If a dependency
    module has not been updated for a year, you can spot a problem later, but you
    will have a hard time figuring out what changed between two versions that are
    a year apart. Node.js modules tend to be improved over time and API changes are
    not rare. Always upgrade with caution and don't forget to test.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用一些模块后，一个重要而被忽视的任务是跟踪变化，并在可能的情况下继续使用最新的稳定版本。如果一个依赖模块一年没有更新，您可能会在以后发现问题，但在一年之间的两个版本之间找出变化是很困难的。Node.js模块往往会随着时间的推移而得到改进，API的变化并不罕见。始终谨慎升级，并不要忘记测试。
- en: Separating your code
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将您的代码分离
- en: 'Again, you should always split your code into smaller parts. Node.js helps
    you do this in a very easy way. You should not have files bigger than 5 kB. If
    you have, you better think about splitting it. Also, as a good rule, each user-defined
    object should have its own separate file. Name your files accordingly:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您应该始终将代码拆分为较小的部分。Node.js可以帮助您以非常简单的方式做到这一点。您的文件不应该超过5kB。如果超过了，最好考虑拆分。此外，作为一个良好的规则，每个用户定义的对象应该有自己单独的文件。根据文件命名：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Another good rule to check whether you have a file bigger than it should be;
    that is, it should be easy to read and understand in less than 5 minutes by someone
    new to the application. If not, it means that it's too complex and it will be
    harder to track and fix bugs later on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好的规则是检查您是否有一个比应该更大的文件；也就是说，它应该在不到5分钟的时间内由一个新的应用程序用户轻松阅读和理解。如果不是，这意味着它太复杂了，以后跟踪和修复错误将更加困难。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that later on, when your application becomes huge, you will be like
    a new developer when opening a file to fix something. You can't remember all of
    the code of the application, and you need to absorb a file behavior fast.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当您的应用程序变得庞大时，当打开一个文件进行修复时，您将像一个新的开发人员一样。您无法记住应用程序的所有代码，需要快速吸收文件的行为。
- en: Embracing asynchronous tasks
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拥抱异步任务
- en: 'The platform is designed to be asynchronous, so you shouldn''t go against it.
    Sometimes, it can be really hard to make some recursive tasks or even simply cycle
    through a list of tasks that have to run serially. You should avoid creating a
    module to handle asynchronous tasks, as there are some used and tested by hundreds
    of thousands of people out there. For instance, `async` is a simple and very practical
    way of helping the developer perform better, and the learning curve is very smooth:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该平台设计为异步，因此您不应该违背它。有时，对一些递归任务或者简单地循环执行一系列需要串行运行的任务可能会非常困难。您应该避免创建一个处理异步任务的模块，因为有一些模块被成千上万的人使用和测试。例如，`async`是帮助开发人员更好地执行的一种简单而实用的方式，学习曲线非常平滑：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This module has a lot of methods similar to the ones you find in the array object,
    such as map, reduce, filter, and each, but for iterating asynchronously. This
    is extremely useful when your application gets more complex and some user actions
    require some serialized tasks. Error handling is also done correctly and the execution
    stop is done as expected. The module helps run serial or parallel tasks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块有很多类似于数组对象中的方法，比如map、reduce、filter和each，但是用于异步迭代。当您的应用程序变得更加复杂，一些用户操作需要一些串行任务时，这是非常有用的。错误处理也被正确地执行，执行停止也如预期般完成。该模块有助于运行串行或并行任务。
- en: Also, serial tasks that would usually enforce a developer to nest calls and
    enter the callback hell can simply be avoided. This is especially useful when,
    for example, you need to perform a transaction on a database with several queries
    involved.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常需要串行任务的情况下，开发人员通常需要嵌套调用并进入回调地狱，但可以简单地避免这种情况。特别是在需要执行涉及多个查询的数据库事务时，这是非常有用的。
- en: Another common mistake when writing asynchronous code is throwing errors. Callbacks
    are called outside the scope where they are defined, and so you cannot just put
    the callback inside a `try`/`catch` block. Therefore, avoid doing this unless
    it's a very critical error that should make your application stop and quit. In
    Node.js, throwing an exception without catching it will trigger an `uncaughtException`
    event.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编写异步代码时的另一个常见错误是抛出错误。回调在定义它们的范围之外被调用，因此您不能简单地将回调放在`try`/`catch`块中。因此，除非这是一个非常关键的错误，应该使您的应用程序停止并退出，否则避免这样做。在Node.js中，抛出异常而不捕获它将触发`uncaughtException`事件。
- en: The platform has a rule that is consensual for most developers—the so-called
    error-first callback style. This rule is of extreme importance, since it allows
    an easier reuse of your code. Even if you have a function where there's no chance
    of throwing an error, or when you just don't want it to throw and use some kind
    of error handling inside the function, your callback should always reserve the
    first argument for an error event if it's always null. This will allow your function
    to be used with an `async` module. Also, other developers will be counting on
    this style when debugging, so always reverse the first argument as an error object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该平台有一个对大多数开发人员来说是共识的规则——所谓的错误优先回调风格。这个规则非常重要，因为它允许更容易地重用您的代码。即使您有一个函数，其中没有抛出错误的机会，或者当您不希望它抛出并在函数内部使用某种错误处理时，您的回调应该始终将第一个参数保留给错误事件，即使它总是null。这将允许您的函数与`async`模块一起使用。此外，其他开发人员在调试时将依赖这种风格，因此始终将第一个参数作为错误对象保留。
- en: 'Plus, you should always reserve the last argument of the function as the callback.
    Never define arguments after your callback:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该始终将函数的最后一个参数保留为回调。永远不要在回调之后定义参数：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using library functions
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用库函数
- en: Library functions are another type of module you should use. They help in handling
    repetitive tasks, and every developer has to perform such tasks. Some of these
    repetitive tasks can be done with no effort, just by using a library function
    from lodash or underscore. They are an important part of your code and have good
    optimizations that you don't even have to think about. Many cycling tasks, such
    as finding an object in an array based on an object key, or mapping an array of
    objects to an array of keys of every object, are one-liners in these libraries.
    Read the documentation first to avoid using the library and not fully using its
    potential.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 库函数是您应该使用的另一种模块类型。它们有助于处理重复的任务，每个开发人员都必须执行这些任务。一些重复的任务可以毫不费力地完成，只需使用lodash或underscore中的库函数。它们是您代码的重要部分，并且具有良好的优化，您甚至无需考虑。许多循环任务，例如基于对象键在数组中查找对象，或将对象数组映射到每个对象的键数组，都可以在这些库中用一行代码完成。首先阅读文档，以避免使用库而未充分利用其潜力。
- en: Although these kinds of modules can be useful, they can also downgrade performance
    if they are not chosen well. Some modules are designed to help developers in some
    tasks, but do not target performance—just convenience. In other words, these modules
    can help you develop faster, but you shouldn't forget the complexity of each function.
    Otherwise, you will be calling the same function several times because you forget
    about its complexity, instead of calling it once and saving the results.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些类型的模块可能很有用，但如果选择不当，它们也可能降低性能。一些模块旨在帮助开发人员完成某些任务，但并不针对性能，只是为了方便。换句话说，这些模块可以帮助您更快地开发，但您不应忘记每个函数的复杂性。否则，您将因为忘记其复杂性而多次调用同一个函数，而不是调用一次并保存结果。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that high performance is not seen when you develop the application
    and test with one or two users. At that time, the application performs at a good
    speed, since data size and user count is still small. It's later on that you may
    regret some of your design decisions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当您开发应用程序并与一两个用户进行测试时，并不能看到高性能。那时，应用程序的速度表现良好，因为数据大小和用户数量仍然很小。但以后，您可能会后悔一些设计决定。
- en: Using function rules
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数规则
- en: 'Functions are very important in this platform. This is no surprise since the
    language is functional and has first-class functions. There are some rules you
    should follow when writing functions that will make your life easier when debugging
    or optimizing it later. They also avoid some errors as they try to enforce some
    common structure. Once again, you can enforce these rules using, for example,
    JSCS ([http://jscs.info/](http://jscs.info/)):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在这个平台上非常重要。这并不奇怪，因为这种语言是功能性的，并且具有一流的函数。在编写函数时，有一些规则您应该遵循，这将使您在以后调试或优化时更加轻松。它们还可以避免一些错误，因为它们试图强制执行一些常见的结构。再次强调，您可以使用JSCS等工具来强制执行这些规则。
- en: 'Always name your functions, especially when they''re closures used as callbacks.
    This allows you to identify them in stack traces when your code breaks. Also,
    they allow a new developer to rapidly know what the function is supposed to do.
    Still, avoid long names:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 始终为您的函数命名，特别是当它们作为闭包用作回调时。这样可以在代码中断时识别它们在堆栈跟踪中的位置。此外，它们允许新开发人员迅速了解函数应该做什么。但是，避免使用过长的名称：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Don''t nest your conditions, and return as early as possible. If you have a
    condition that must return something in a function and if you return, you don''t
    have to use the `else` statement. You also avoid a new indent level, reducing
    your code and simplifying its revision. If you don''t do this, you will end up
    in a condition hell, with several levels if you have two or more conditions to
    satisfy:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要嵌套您的条件，并尽早返回。如果您在函数中有一个必须返回的条件，并且如果您返回了，您就不必使用`else`语句。这样还可以避免新的缩进级别，减少代码并简化其修订。如果您不这样做，如果有两个或更多条件需要满足，您最终会陷入条件地狱，有几个级别：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Create small and simple functions. Don't span your functions for more lines
    than your screen can handle. Even if your task cannot be reused, split the function
    into smaller ones. It is even better to put it into a new module and publish it.
    In this way, you can reuse them at the frontend if you need them. This can also
    allow the engine to optimize some smaller functions when it is unable to optimize
    the previous big function. Again, this is important if you don't want a developer
    to be reading your application code for a week or two before being able to touch
    anything.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建小而简单的函数。不要让您的函数跨越屏幕可处理的行数。即使您的任务无法重用，也将函数拆分为更小的函数。最好将其放入新模块并发布。这样，如果需要，您可以在前端重用它们。这也可以使引擎在无法优化之前的大函数时优化一些较小的函数。再次强调，如果您不希望开发人员在能够触及任何内容之前阅读您的应用程序代码一两周，这一点非常重要。
- en: Testing your modules
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试您的模块
- en: Testing your modules is a hard job and is usually neglected, but it's very important
    to make tests for your modules. The first ones are the hard ones. Look for a test
    tool that you like, such as vows, chai, or mocha. If you don't know how to start,
    read a module's documentation, or another module's test code. But don't give up
    on testing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的模块是一项艰巨的工作，通常被忽视，但对于为您的模块编写测试非常重要。最初的测试是最困难的。寻找一个您喜欢的测试工具，比如vows、chai或mocha。如果您不知道如何开始，请阅读模块的文档，或者其他模块的测试代码。但不要放弃测试。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need help, read the test tools' websites mentioned earlier, as they usually
    help you get started. Alternatively, you can take a look at Igor's post ([https://semaphoreci.com/community/tutorials/getting-started-with-node-js-and-mocha](https://semaphoreci.com/community/tutorials/getting-started-with-node-js-and-mocha))at
    semaphore.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要帮助，请阅读前面提到的测试工具网站，因为它们通常会帮助您入门。或者，您可以查看Igor的文章（https://semaphoreci.com/community/tutorials/getting-started-with-node-js-and-mocha）在semaphore。
- en: After you start adding one or two tests, more will follow. One big advantage
    of testing your module from the beginning is that when you spot a bug, you can
    make a test case for it, to be able to reproduce it and avoid it in the future.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始添加一个或两个测试，就会有更多的测试跟随。从一开始就测试您的模块的一个重要优势是，当您发现一个错误时，您可以为其制作一个测试用例，以便能够重现它并在将来避免它。
- en: Code coverage is not crucial but can help you see how your tests cover your
    module code base, and if you're just testing a small part. There are some coverage
    modules, such as `istanbul` or `jscoverage`; choose the one that works best for
    you. Code coverage is done together with testing, so if you don't test it, you
    won't be able to see the coverage.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率并不是至关重要的，但可以帮助您了解您的测试覆盖了模块代码的程度，以及您是否只是测试了一小部分。有一些覆盖率模块，比如`istanbul`或`jscoverage`；选择最适合您的那个。代码覆盖率是与测试一起完成的，所以如果您不进行测试，就无法看到覆盖率。
- en: As you might want to improve the performance of an application, every dependency
    module should be looked at for improvements. This can be done only if you test
    them. Dependency version management is of great importance, and it can be hard
    to keep track of new versions and changes, but they might give you some good news.
    Sometimes, modules are refactored and performance is boosted. A good example of
    this is database access modules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能想要改进应用程序的性能一样，每个依赖模块都应该被检查以进行改进。只有在测试它们时才能做到这一点。依赖版本管理非常重要，但很难跟踪新版本和更改，但它们可能会给您一些好消息。有时，模块会被重构，性能会得到提升。一个很好的例子是数据库访问模块。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Together, Node.js and NPM make a very good platform for developing high-performance
    applications. Since the language behind them is JavaScript and most applications
    these days are web applications, these combinations make it an even more appealing
    choice, as it's one less server-side language to learn (such as PHP or Ruby) and
    can ultimately allow a developer to share code on the client and server sides.
    Also, frontend and backend developers can share, read, and improve each other's
    code. Many developers pick this formula and bring with them many of their habits
    from the client side. Some of these habits are not applicable because on the server
    side, asynchronous tasks must rule as there are many clients connected (as opposed
    to one) and performance becomes crucial.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js和NPM一起构成了一个非常好的平台，用于开发高性能的应用程序。由于它们背后的语言是JavaScript，而且大多数应用程序都是Web应用程序，这些组合使它成为一个更具吸引力的选择，因为它是一个不需要学习的服务器端语言（如PHP或Ruby），最终可以允许开发人员在客户端和服务器端共享代码。此外，前端和后端开发人员可以共享、阅读和改进彼此的代码。许多开发人员选择这种模式，并带来了许多他们从客户端带来的习惯。其中一些习惯不适用，因为在服务器端，异步任务必须起作用，因为有许多连接的客户端（而不是一个），性能变得至关重要。
- en: In the next chapter, we will cover some development patterns that help applications
    stay simple, fast, and scalable as more clients come along and start putting pressure
    on your infrastructure.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些开发模式，帮助应用程序保持简单、快速和可扩展，随着更多客户端的加入，开始对您的基础设施施加压力。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID为bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他使用都需要版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止，并违反适用法律。保留所有权利。
