- en: Securing Cloud-Native Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护云原生系统
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将介绍以下菜谱：
- en: Securing your cloud account
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护您的云账户
- en: Creating a federated identity pool
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建联合身份池
- en: Implementing sign up, sign in, and sign out
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现注册、登录和注销
- en: Securing an API Gateway with OpenID Connect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenID Connect 保护 API 网关
- en: Implementing a custom authorizer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义授权器
- en: Authorizing a GraphQL-based service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权基于 GraphQL 的服务
- en: Implementing a JWT filter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 JWT 过滤器
- en: Using envelope encryption
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信封加密
- en: Creating an SSL certificate for encryption in transit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为传输加密创建 SSL 证书
- en: Configuring a web application firewall
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Web 应用程序防火墙
- en: Replicating the data lake for disaster recovery
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制数据湖以进行灾难恢复
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Security in the cloud is based on the shared responsibility model. Below a certain
    line in the stack is the responsibility of the cloud provider and above that line
    is the responsibility of the cloud consumer. Cloud-native and serverless computing
    push that line higher and higher. This allows teams to focus their efforts on
    what they know best—their business domains. With the security mechanisms provided
    by the cloud, teams can practice *security-by-design* and concentrate on *defense-in-depth*
    techniques to secure their data. In each recipe, so far, we have seen how serverless
    computing requires us to define security policies between components at each layer
    in the stack. The recipes in this chapter will cover securing our cloud accounts,
    securing our applications with OAuth 2.0/Open ID Connect, securing our data at
    rest, and creating a perimeter around our cloud-native systems by delegating aspects
    of security to the edge of the cloud.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 云中的安全基于共享责任模型。在栈的某个以下线是云提供商的责任，以上线是云消费者的责任。云原生和无服务器计算将这条线推得越来越高。这使得团队能够专注于他们最擅长的领域——他们的业务领域。借助云提供的安全机制，团队能够实践
    *设计安全* 并专注于 *深度防御* 技术来保护他们的数据。到目前为止，在每一个菜谱中，我们都看到了无服务器计算如何要求我们在栈的每一层定义组件之间的安全策略。本章中的菜谱将涵盖保护我们的云账户、使用
    OAuth 2.0/Open ID Connect 保护我们的应用程序、保护我们的静态数据以及通过将安全的一些方面委托给云边缘来在我们的云原生系统周围创建一个边界。
- en: Securing your cloud account
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的云账户
- en: Everything we do to secure our cloud-native systems is all for nothing if we
    do not endeavor to secure our cloud accounts as well. There is a set of best practices
    that we must put in place for every cloud account we create. As we strive to create
    autonomous services, we should leverage the natural bulkhead between cloud accounts
    by grouping related services into more, fine-grained accounts instead of fewer,
    coarse-grained accounts. In this recipe, we will see how treating accounts as
    code enables us to manage many accounts easily by applying the same infrastructure-as-code
    practices we employ to manage our many autonomous services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不努力保护我们的云账户，那么我们所做的一切来保护我们的云原生系统都是徒劳的。我们必须为每个创建的云账户实施一系列最佳实践。随着我们努力创建自主服务，我们应该利用云账户之间的自然隔板，通过将相关服务分组到更多、更细粒度的账户中，而不是更少、更粗粒度的账户中。在这个菜谱中，我们将看到将账户视为代码如何使我们能够通过应用我们用于管理许多自主服务的相同基础设施即代码实践，轻松地管理许多账户。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the project from the following template:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Navigate to the `cncb-account-as-code` directory with `cd cncb-account-as-code`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cd cncb-account-as-code` 切换到 `cncb-account-as-code` 目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看名为 `serverless.yml` 的文件，其内容如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Update `accountNumber` in `serverless.yml`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `serverless.yml` 中更新 `accountNumber`。
- en: Install the dependencies with `npm install`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm install` 安装依赖
- en: Run the tests with `npm test`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm test` 运行测试
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看在 `.serverless` 目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署栈：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中查看栈和资源。
- en: Uncomment `cfnRole` and then deploy again with the `force` flag with `npm run
    dp:lcl -- -s $MY_STAGE --force`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释 `cfnRole`，然后使用带有 `force` 标志的 `npm run dp:lcl -- -s $MY_STAGE --force` 再次部署。
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm run rm:lcl -- -s $MY_STAGE` 删除栈
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Every account I create starts off with the same essential security settings
    using a `serverless.yml`, such as the one in this recipe. I create no other stacks
    in the account until this account-scoped stack is created. All further changes,
    other than creating users, are delivered as changes to this stack. The first responsibility
    of this stack is to turn on `CloudTrail`. In [Chapter 7](64a4c0f7-3b2d-4638-a52c-f72953ff66d9.xhtml),
    *Optimizing Observability*, we will see how we can use this audit trail to monitor
    and alert about unexpected changes to security policies. `AuditBucket` is also
    a candidate for replicating to the recovery account as discussed in the *Replicating
    the data lake for disaster recovery* recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建的每个账户都使用`serverless.yml`文件开始，例如本食谱中的文件。在创建此账户范围堆栈之前，我不会在账户中创建其他堆栈。除创建用户之外的所有进一步更改都作为对此堆栈的更改交付。此堆栈的首要责任是启用`CloudTrail`。在第7章*优化可观察性*中，我们将看到如何使用此审计跟踪来监控和警报关于安全策略意外更改的情况。"AuditBucket"也是复制到恢复账户的候选者，如*复制数据湖以进行灾难恢复*食谱中讨论的那样。
- en: Next, the stack creates the user groups that will be used for granting permissions
    to all users of the account. The `AdminUserGroup`, `PowerUserGroup`, and `ReadOnlyUserGroup` groups
    are a good starting point, along with using the managed policies provided by AWS.
    As the usage of the account matures, these groups will evolve using the same approach
    discussed in [Chapter 6](390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml), *Building
    a Continuous Deployment Pipeline*. However, only the security policies are codified.
    The assignment of users to groups is a manual process that should follow an appropriate
    approval process. The stack includes the `MfaOrHqRequired`, policy to require
    **Multi-Factor Authentication** (**MFA**) and whitelist the corporate IP addresses,
    but it is disabled initially. It should certainly be enabled for all production
    accounts. In a development account, most developers are assigned to the power
    user group, so that they can freely experiment with cloud services. The power
    user group has no IAM permissions, so an optional `ManageAccessKey` policy is
    included to allow power users to manage their access keys. Note, it is very important
    to control the usage of access keys and frequently rotate them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，堆栈创建用于授予所有账户用户权限的用户组。`AdminUserGroup`、`PowerUserGroup`和`ReadOnlyUserGroup`组是一个良好的起点，同时使用AWS提供的托管策略。随着账户使用的成熟，这些组将使用第6章中讨论的相同方法进行演变，即*构建持续部署管道*。然而，只有安全策略被编码化。用户到组的分配是一个手动过程，应该遵循适当的审批流程。堆栈包括`MfaOrHqRequired`策略，要求**多因素认证**（**MFA**）并允许企业IP地址白名单，但最初是禁用的。对于所有生产账户，肯定应该启用它。在开发账户中，大多数开发者被分配到高级用户组，这样他们可以自由地实验云服务。高级用户组没有IAM权限，因此包含一个可选的`ManageAccessKey`策略，允许高级用户管理他们的访问密钥。请注意，控制访问密钥的使用并频繁轮换它们非常重要。
- en: When executing a `serverless.yml` file, we need an access key. As an added security
    measure, CloudFormation supports the use of a service role that allows CloudFormation
    to assume a specific role with temporary credentials. Using the `cfnRole` attribute
    in a `serverless.yml` file enables this feature. This stack creates an initial
    `CloudFormationServiceRole` that should be used by all stacks. As the account
    matures, this role should be tuned to the least possible privileges. The `ExecuteCloudFormationPolicy`
    included only has enough permissions to execute a `serverless.yml` file. This
    policy will be used by `CiCdUser`, which we will use in [Chapter 6](390bdaaf-5f53-4d65-8a6c-2e47c815f2b3.xhtml),
    *Building a Continuous Deployment Pipeline*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`serverless.yml`文件时，我们需要一个访问密钥。作为额外的安全措施，CloudFormation支持使用服务角色，允许CloudFormation假定具有临时凭证的特定角色。使用`serverless.yml`文件中的`cfnRole`属性启用此功能。此堆栈创建一个初始的`CloudFormationServiceRole`，所有堆栈都应使用此角色。随着账户的成熟，此角色应调整到尽可能少的权限。包含的`ExecuteCloudFormationPolicy`只有足够的权限来执行`serverless.yml`文件。此策略将由`CiCdUser`使用，我们将在第6章*构建持续部署管道*中使用它。
- en: Creating a federated identity pool
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建联合身份池
- en: Managing users is a requirement of virtually every system. Over a long career,
    I can certainly attest to creating identity management functionality over and
    over again. Fortunately, we can now get this functionality as a service from many
    providers, including our cloud providers. And because there are so many options
    available, we need a federated solution that delegates to many other identity
    management systems while presenting a single, unified model to our cloud-native
    system. In this recipe, we will show how to create an *AWS Cognito user pool*,
    which we will then use in other recipes to secure our services.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 管理用户是几乎所有系统的要求。在漫长的职业生涯中，我确实可以证明反复创建身份管理功能。幸运的是，我们现在可以从许多提供商那里获得此功能，包括我们的云提供商。由于有这么多选项可用，我们需要一个联邦解决方案，它将委托给许多其他身份管理系统，同时向我们的云原生系统呈现一个单一、统一的模型。在此配方中，我们将展示如何创建一个
    *AWS Cognito 用户池*，然后我们将在其他配方中使用它来保护我们的服务。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the project from the following template:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Navigate to the `cncb-cognito-pool` directory with `cd cncb-cognito-pool`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cd cncb-cognito-pool` 命令进入 `cncb-cognito-pool` 目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为 `serverless.yml` 的文件，其内容如下：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Install the dependencies with `npm install`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm install` 安装依赖项。
- en: Run the tests with `npm test`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm test` 运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `.serverless` 目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署堆栈：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中检查堆栈和资源。
- en: Access `loginURL` from the stack output to verify that the user pool was created
    successfully.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从堆栈输出访问 `loginURL` 以验证用户池是否已成功创建。
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，使用 `npm run rm:lcl -- -s $MY_STAGE` 删除堆栈。
- en: We will be referencing this user pool in other recipes in this chapter, so remove
    this stack after you are finished with this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的其他配方中引用此用户池，因此您完成本章后请删除此堆栈。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe simply codifies the creation of an AWS Cognito user pool. Like any
    other infrastructure resource, we want to treat it as code and manage it in a
    continuous delivery pipeline. For this recipe, we define the bare essentials.
    You will want to define any additional attributes that you want the pool to manage.
    For this recipe, we just specify the `email` attribute.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方仅将 AWS Cognito 用户池的创建过程规范化。像任何其他基础设施资源一样，我们希望将其视为代码并在持续交付管道中管理。对于此配方，我们定义了最基本的内容。您可能需要定义任何希望池管理的附加属性。对于此配方，我们仅指定了
    `email` 属性。
- en: It is important to understand that these attributes cannot be changed via CloudFormation
    without creating a new user pool, which has a ripple effect on any resources that
    are dependent on the user pool. So, expect to focus some effort on experimenting
    upfront with the right combination of attributes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，这些属性不能通过 CloudFormation 进行更改，除非创建一个新的用户池，这将对其依赖的用户池的任何资源产生连锁反应。因此，请预计您需要投入一些精力来提前实验正确的属性组合。
- en: For each application that will rely on this user pool, we need to define a `UserPoolClient`.
    Each application would typically define the client in a stack that it manages.
    However, it is important not to overuse a single user pool. Once again this is
    a question of autonomy. If the pool of users and the applications used by those
    users are truly independent, then they should be managed in separate Cognito user
    pools, even if that requires some duplication of effort. For example, if you find
    yourself writing complicated logic using Cognito user groups to segregate users unnaturally,
    then you may be better off with multiple user pools. An example of misuse is mixing
    employees and customers in the same user pool.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将依赖于此用户池的每个应用程序，我们需要定义一个 `UserPoolClient`。每个应用程序通常会将其定义在它管理的堆栈中。然而，过度使用单个用户池是很重要的。这再次是一个关于自主性的问题。如果用户池和那些用户使用的应用程序确实是独立的，那么它们应该分别管理在不同的
    Cognito 用户池中，即使这需要一些重复的工作。例如，如果您发现自己正在使用 Cognito 用户组编写复杂的逻辑来不自然地隔离用户，那么您可能更适合使用多个用户池。一个误用的例子是将员工和客户混合在同一个用户池中。
- en: CloudFormation, as of the writing of this chapter, does not have full support
    for the Cognito API. Therefore a plugin is used for the additional settings on
    the `UserPoolClient`, such as `domain`, `callbackUrls`, and `allowedOAuthFlows`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本章时，CloudFormation 对 Cognito API 的支持并不完整。因此，使用插件来处理 `UserPoolClient` 的附加设置，例如
    `domain`、`callbackUrls` 和 `allowedOAuthFlows`。
- en: Implementing sign up, sign in, and sign out
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现注册、登录和注销
- en: Implementing sign up, sign in, and sign out over and over again is not very
    lean. Implementing this logic in a single-page application is also not desirable.
    In this recipe, we will see how to implement the *OpenID Connect Implicit Flow*
    in a single-page application to authenticate users with the *AWS Cognito Hosted
    UI*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重复实现注册、登录和注销并不高效。在单页应用程序中实现此逻辑也不理想。在这个菜谱中，我们将了解如何在单页应用程序中实现*OpenID Connect隐式流*以使用*AWS
    Cognito托管UI*对用户进行认证。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create the project from the following template:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Navigate to the `cncb-cognito-signin` directory with `cd cncb-cognito-signin`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd cncb-cognito-signin`导航到`cncb-cognito-signin`目录。
- en: 'Review the file named `src/App.js` with the following content and update the
    `clientId` and `domain` fields with the values from the `userPool` stack output
    in the previous recipe:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看名为`src/App.js`的文件，其内容如下，并使用上一个菜谱中`userPool`堆栈输出的值更新`clientId`和`domain`字段：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Review the file named `src/Home.js` with the following content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看名为`src/Home.js`的文件，其内容如下：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Install the dependencies with `npm install`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装依赖项。
- en: Run the app locally with `npm start`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm start`在本地运行应用程序。
- en: Browse to `http://localhost:3000`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:3000`。
- en: Click the `Sign Up` link and follow the instructions.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`注册`链接并按照说明操作。
- en: Click the `Sign Out` link and then `Sign In` again.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`注销`链接，然后再次登录。
- en: Review the `idToken` displayed on the page.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看页面上的`idToken`。
- en: We will use these screens to create a valid `idToken` in the authorization recipes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些屏幕在授权菜谱中创建有效的`idToken`。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Adding sign up, sign in, and sign out to a single-page app is very straightforward.
    We include some additional libraries, initialize them with the proper configurations,
    and decorate the existing code. In this recipe, we make these changes to our simple
    example React application. AWS provides the `amazon-cognito-auth-js` library to
    simplify this task and we wrap it in some React components in `src/authenticate`
    folder. First, we initialize the `CognitoSecurity` component in the `src/App.js`.
    Next, we set up `SecureRoute` for the `Home` component that will redirect to the
    *Cognito hosted UI* if the user is not authenticated. The `ImpicitCallback` component
    will handle the redirect after the user logs in. Finally, we add the `withAuth`
    decorator to the `Home` component. In more elaborate applications, we would just
    be decorating more routes and components. The framework handles everything else,
    such as saving the **JSON Web Token** (**JWT**) to local storage and making it
    available for use in the `auth` property. For example, the `Home` component displays
    the tokens (`auth.getSession()`) and provides a logout button (`auth.logout`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将注册、登录和注销功能添加到单页应用中非常简单。我们包括一些额外的库，用适当的配置初始化它们，并装饰现有的代码。在这个菜谱中，我们对我们的简单React应用程序进行了这些更改。AWS提供了`amazon-cognito-auth-js`库来简化这项任务，我们在`src/authenticate`文件夹中用一些React组件包装它。首先，我们在`src/App.js`中初始化`CognitoSecurity`组件。接下来，我们为`Home`组件设置`SecureRoute`，如果用户未认证，将重定向到*Cognito托管UI*。`ImpicitCallback`组件将在用户登录后处理重定向。最后，我们将`withAuth`装饰器添加到`Home`组件上。在更复杂的应用程序中，我们只需装饰更多的路由和组件。框架处理其他所有事情，例如将**JSON
    Web Token**（JWT）保存到本地存储，并在`auth`属性中使用它。例如，`Home`组件显示令牌（`auth.getSession()`）并提供注销按钮（`auth.logout`）。
- en: Securing an API Gateway with OpenID Connect
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenID Connect保护API网关
- en: One of the advantages of using an API Gateway is that we are pushing security
    concerns, such as authorization, to the perimeter of our system and away from
    our internal resources. This simplifies the internal code and improves scalability.
    In this recipe, we will configure an *AWS API Gateway* to authorize against an
    *AWS Cognito user pool*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API网关的一个优点是将安全关注点，如授权，推到我们系统的外围，远离我们的内部资源。这简化了内部代码并提高了可扩展性。在这个菜谱中，我们将配置一个*AWS
    API网关*以对*AWS Cognito用户池*进行授权。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要根据*创建联合身份池*菜谱中创建的Cognito用户池和*实现注册、登录和注销*菜谱中创建的示例应用程序来创建本菜谱中使用的身份令牌。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create the project from the following template:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Navigate to the `cncb-cognito-authorizer` directory with `cd cncb-cognito-authorizer`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd cncb-cognito-authorizer`进入`cncb-cognito-authorizer`目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为`serverless.yml`的文件，其内容如下：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Install the dependencies with `npm install`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装依赖项。
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test -- -s $MY_STAGE`运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`.serverless`目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署栈：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中检查栈和资源。
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to attempt
    to access the service without an `Authorization` token:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新`<API-ID>`后，调用以下`curl`命令，尝试在不使用`Authorization`令牌的情况下访问服务：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use the app in the previous recipe to sign in and generate `idToken`, and then
    export `idToken` with the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前一个菜谱中的应用程序登录并生成`idToken`，然后使用以下命令导出`idToken`：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to access the
    service successfully with an `Authorization` token:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新`<API-ID>`后，调用以下`curl`命令，以使用`Authorization`令牌成功访问服务：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run rm:lcl -- -s $MY_STAGE`删除栈，一旦您完成操作。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The combination of the AWS API Gateway, AWS Cognito, and the Serverless Framework
    make securing a service with OpenID Connect extremely straightforward. The AWS
    API Gateway can use authorizer functions to control access to a service. These
    functions verify the JWT passed in the `Authorization` header and return an IAM
    policy. We will delve into these details in the *Implementing a custom authorizer*
    recipe. AWS Cognito provides an authorizer function that verifies the JWTs generated
    by a specific user pool. In the `serverless.yml` file, we simply need to set `authorizer`
    to the `userPoolArn` of the specific Cognito user pool. Once authorized, the API
    Gateway passes the decode `claims` from the JWT along to the lambda function in
    the `requestContext`, so this data can be used in the business logic, if needs
    be.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: AWS API网关、AWS Cognito和Serverless Framework的组合使得使用OpenID Connect保护服务变得极其简单。AWS
    API网关可以使用授权器函数来控制对服务的访问。这些函数验证`Authorization`头中传递的JWT，并返回IAM策略。我们将在*实现自定义授权器*菜谱中深入了解这些细节。AWS
    Cognito提供了一个授权器函数，用于验证特定用户池生成的JWT。在`serverless.yml`文件中，我们只需将`authorizer`设置为特定Cognito用户池的`userPoolArn`。一旦授权，API网关将JWT的解码`claims`传递到`requestContext`中的lambda函数，以便在业务逻辑中（如果需要）使用这些数据。
- en: Implementing a custom authorizer
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义授权器
- en: In the *Securing an API Gateway with OpenID Connect* recipe, we leveraged the
    Cognito authorizer that is provided by AWS. This is one of the advantages of using
    Cognito. However, this is not the only option. Sometimes we may want more control
    over the policy that is returned. In other cases, we may need to use a third-party
    tool such as *Auth0* or *Okta*. In this recipe, we will show how to support these
    scenarios by implementing a custom authorizer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用OpenID Connect保护API网关*的菜谱中，我们利用了AWS提供的Cognito授权器。这是使用Cognito的一个优点。然而，这并不是唯一的选择。有时我们可能希望对返回的策略有更多的控制。在其他情况下，我们可能需要使用第三方工具，如*Auth0*或*Okta*。在这个菜谱中，我们将通过实现自定义授权器来展示如何支持这些场景。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用在*创建联合身份验证池*菜谱中创建的Cognito用户池和在*实现注册、登录和注销*菜谱中创建的示例应用程序来创建本菜谱中使用的身份令牌。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the project from the following template:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Navigate to the `cncb-custom-authorizer` directory with `cd cncb-custom-authorizer`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd cncb-custom-authorizer`进入`cncb-custom-authorizer`目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为`serverless.yml`的文件，其内容如下：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Review the file named `handler.js` with the following content:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为`handler.js`的文件，其内容如下：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Install the dependencies with `npm install`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装依赖项。
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test -- -s $MY_STAGE`运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`.serverless`目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署栈：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中检查栈和资源。
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to attempt
    to access the service without an `Authorization` token:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`<API-ID>`后，调用以下`curl`命令，尝试在不使用`Authorization`令牌的情况下访问服务：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the app in the *Implementing sign up, sign in, and sign out* recipe to
    sign in and generate `idToken`, and then export `idToken` with the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*实现注册、登录和注销*配方中的应用程序进行登录并生成`idToken`，然后使用以下命令导出`idToken`：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Invoke the following `curl` command, after updating `<API-ID>`, to access the
    service successfully with an `Authorization` token:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`<API-ID>`后，调用以下`curl`命令，使用`Authorization`令牌成功访问服务：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成使用`npm run rm:lcl -- -s $MY_STAGE`后，删除堆栈。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The process for connecting a custom authorizer to the API Gateway is the same
    as with the Cognito authorizer. We can implement the `authorizer` function in
    the same project, as we have in this recipe, or it can be implemented in another
    stack so that it can be shared across services. The `jwks-rsa` and `jsonwebtoken`
    open source libraries implement the bulk of the logic. First, we assert the presence
    of the token and `decode` it. Next, we use the key ID (`kid`) that is present
    in the decoded token to retrieve the `.well-known/jwks.json` public key for the
    issuer. Then, we verify the signature of the token against the key and assert
    that the audience (`aud`) and issuer (`iss`) are as expected. Finally, the function
    returns an IAM policy that grants access to the service based on the path. The
    `claims` of the token are also returned in the `context` field so that they can
    be forwarded to the backend function. If any validations fail then we return an
    `Unauthorized` error.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将自定义授权器连接到API网关的过程与Cognito授权器相同。我们可以在与配方相同的项目中实现`authorizer`函数，或者它可以在另一个堆栈中实现，以便可以在服务之间共享。`jwks-rsa`和`jsonwebtoken`开源库实现了大部分逻辑。首先，我们断言令牌的存在并对其进行解码。然后，我们使用解码令牌中存在的键ID（`kid`）检索发行者的`.well-known/jwks.json`公钥。然后，我们验证令牌的签名与密钥，并断言受众（`aud`）和发行者（`iss`）符合预期。最后，函数返回一个基于路径授予服务访问权限的IAM策略。令牌的`claims`也返回在`context`字段中，以便可以将其转发到后端函数。如果任何验证失败，则返回`Unauthorized`错误。
- en: The claims object must be flattened, otherwise `AuthorizerConfigurationException`
    is thrown.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 声明对象必须被展平，否则会抛出`AuthorizerConfigurationException`异常。
- en: Authorizing a GraphQL-based service
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权基于GraphQL的服务
- en: We have seen how to use a *JWT* to authorize access to services. In addition
    to this coarse-grained access control, we can also leverage the claims in the
    JWT to perform fine-grained, role-based access control. In this recipe, we will
    show how to use directives to create annotations that are used to define role-based
    permissions declaratively in a GraphQL schema.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用*JWT*来授权对服务的访问。除了这种粗粒度的访问控制之外，我们还可以利用JWT中的声明来执行细粒度、基于角色的访问控制。在此配方中，我们将展示如何使用指令创建用于在GraphQL模式中声明性定义基于角色的权限的注释。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
    You will need to assign the `Author` group, via the Cognito Console, to the user
    that you will use in this recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要根据*创建联合身份池*配方中创建的Cognito用户池和*实现注册、登录和注销*配方中创建的示例应用程序来创建在此配方中使用的身份令牌。您需要通过Cognito控制台将`Author`组分配给您在此配方中使用的用户。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the project from the following template:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Navigate to the `cncb-graphql-jwt` directory with `cd cncb-graphql-jwt`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd cncb-graphql-jwt`命令导航到`cncb-graphql-jwt`目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为`serverless.yml`的文件，其内容如下：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Review the `index.js`, `schema/thing/typedefs.js`, and `directives.js` files
    with the following content:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以下内容的`index.js`、`schema/thing/typedefs.js`和`directives.js`文件：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Install the dependencies with `npm install`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装依赖项。
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test -- -s $MY_STAGE`运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`.serverless`目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署堆栈：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中检查堆栈和资源。
- en: 'Use the app in the *Implementing sign up, sign in, and sign out* recipe to
    sign in and generate `idToken`, and then export `idToken` with the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*实现注册、登录和注销*菜谱中的应用程序进行登录并生成`idToken`，然后使用以下命令导出`idToken`：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Invoke the following `curl` commands, after updating `<API-ID>`, to successfully
    access the service with an `Authorization` token:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新`<API-ID>`后，调用以下`curl`命令以使用`Authorization`令牌成功访问服务：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run rm:lcl -- -s $MY_STAGE`命令完成操作后删除堆栈。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The service is configured with a Cognito `authorizer` that verifies the token
    and forwards `claims`. These `claims` include the `groups` that the user is a
    member of. At design time, we want to define the roles declaratively that are
    required to access privileged actions. In GraphQL, we can annotate a `schema`
    using `directives`. In this recipe, we define a `hasRole` directive and implement
    a `resolver` that checks the allowed `roles` defined in the annotation against `groups`
    present in the claims, and then it either allows or denies access. The `resolver`
    logic is decoupled from `schema` and the annotations in `schema` are straightforward
    and clean.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 服务配置了一个Cognito `authorizer`，该`authorizer`验证令牌并转发`claims`。这些`claims`包括用户是成员的`groups`。在设计时，我们希望声明性地定义访问特权操作的所需角色。在GraphQL中，我们可以使用`directives`来注释`schema`。在这个菜谱中，我们定义了一个`hasRole`指令并实现了一个`resolver`，该`resolver`将注释中定义的允许`roles`与声明中存在的`groups`进行比较，然后允许或拒绝访问。`resolver`逻辑与`schema`和`schema`中的注释解耦，并且注释简单且清晰。
- en: Implementing a JWT filter
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现JWT过滤器
- en: We have seen how to use a JWT to authorize access to services and how we can
    use the claims in the token to perform fine-grained, role-based authorization
    on actions within a service. We usually need to control access at the data instance
    level as well. For example, a customer should only have access to his or her data,
    or an employee should only have access to the data for a specific division. To
    accomplish this, we typically adorn filters to queries based on the user's entitlements.
    In a RESTful API, this information is usually included in the URL as path parameters
    as well. It is typical to use path parameters to perform queries.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用JWT来授权访问服务，以及我们如何使用令牌中的声明在服务内部执行细粒度、基于角色的授权。我们通常还需要在数据实例级别上控制访问。例如，客户只能访问他或她的数据，或者员工只能访问特定部门的资料。为了实现这一点，我们通常根据用户的权限装饰查询。在RESTful
    API中，这些信息通常包含在URL中作为路径参数。使用路径参数进行查询是典型的做法。
- en: However, we want to use the claims in the JWT to perform filters instead, because
    the values in the token are asserted by the authenticity of the token signature.
    In this recipe, we will demonstrate how to use the claims in the JWT to create
    query filters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望使用JWT中的声明来执行过滤，因为令牌中的值是由令牌签名的真实性断言的。在这个菜谱中，我们将演示如何使用JWT中的声明来创建查询过滤器。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need the Cognito user pool created in the *Creating a federated identity
    pool* recipe and the sample application created in the *Implementing sign up,
    sign in, and sign out* recipe to create the identity token used in this recipe.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用在*创建联合身份池*菜谱中创建的Cognito用户池和在*实现注册、登录和注销*菜谱中创建的示例应用程序来创建本菜谱中使用的身份令牌。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create the project from the following template:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Navigate to the `cncb-jwt-filter` directory with `cd cncb-jwt-filter`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd cncb-jwt-filter`命令导航到`cncb-jwt-filter`目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看名为`serverless.yml`的文件，其内容如下：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Review the file named `handler.js` with the following content:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看名为`handler.js`的文件，其内容如下：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Install the dependencies with `npm install`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`命令安装依赖项。
- en: Run the tests with `npm test -- -s $MY_STAGE`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test -- -s $MY_STAGE`命令运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看在`.serverless`目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署堆栈：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中查看堆栈和资源。
- en: 'Use the app in the *Implementing sign up, sign in, and sign out* recipe to
    sign in and generate `idToken`, and then export `idToken` with the following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*实现注册、登录和注销*菜谱中的应用程序进行登录并生成`idToken`，然后使用以下命令导出`idToken`：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Invoke the following `curl` commands, after updating `<API-ID>`, to access
    data successfully within the restrictions of the  `Authorization` token:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `<API-ID>` 后，调用以下 `curl` 命令，以在 `Authorization` 令牌的限制内成功访问数据：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Take a look at the logs:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看日志：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm run rm:lcl -- -s $MY_STAGE` 完成后，删除堆栈。
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The client of an API can use any values to formulate a URL, but it cannot tamper
    with the content of the JWT token because the issuer has signed the token. Therefore,
    we need to override any request values with the values from the token. In this
    recipe, we are saving and retrieving data for a specific user as determined by
    the subject or subclaim in the user's token. The service is configured with an
    `authorizer` that verifies the token and forwards `claims`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: API 的客户端可以使用任何值来构建 URL，但不能篡改 JWT 令牌的内容，因为发行者已经签发了令牌。因此，我们需要用令牌中的值覆盖任何请求值。在这个菜谱中，我们根据用户的令牌中的主题或子声明保存和检索特定用户的数据。服务配置了一个
    `authorizer`，用于验证令牌并转发 `claims`。
- en: To simplify the example, the subject is used as the `HASH` key and the data
    `uuid` as the `RANGE` key. When the data is retrieved, we assert the query parameter
    against the value in the token and return a `401` `statusCode` if they do not
    match. If they match, we use the value from the token in the actual query to guard
    against any bugs in the assertion logic that could inadvertently return unauthorized
    data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化示例，主题被用作 `HASH` 键，数据 `uuid` 作为 `RANGE` 键。当数据被检索时，我们将查询参数与令牌中的值进行比较，如果它们不匹配，则返回
    `401` `statusCode`。如果它们匹配，我们使用令牌中的值在实际查询中，以防止断言逻辑中的任何错误意外返回未经授权的数据。
- en: Using envelope encryption
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信封加密
- en: Encrypting data at rest is critical for most systems. We must ensure the privacy
    of our customer's data and of our corporate data. Unfortunately, we all too often
    turn on disk-based encryption and then check off the requirement as complete.
    However, this only protects the data when the disk is disconnected from the system.
    When the disk is connected, then the data is automatically decrypted when it is
    read from disk. For example, create a DynamoDB table with server-side encryption
    enabled and then create some data and view it in the console. So long as you have
    permission, you will be able to see the data in clear text. To truly ensure the
    privacy of data at rest, we must encrypt data at the application level and effectively
    redact all sensitive information. In this recipe, we use the AWS **Key Management
    Service** (**KMS**) and a technique called *envelope encryption* to secure data
    at rest in a DynamoDB table.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数系统来说，在静态数据上加密数据至关重要。我们必须确保我们客户的隐私和公司数据的隐私。不幸的是，我们经常打开基于磁盘的加密，然后勾选要求已完成。然而，这仅在磁盘从系统中断开时保护数据。当磁盘连接时，数据在从磁盘读取时自动解密。例如，创建一个启用服务器端加密的
    DynamoDB 表，然后创建一些数据并在控制台中查看它。只要你有权限，你将能够以明文形式看到数据。为了真正确保静态数据的隐私，我们必须在应用程序级别加密数据，并有效地删除所有敏感信息。在这个菜谱中，我们使用
    AWS **密钥管理服务**（**KMS**）和一种称为 *信封加密* 的技术来保护 DynamoDB 表中的静态数据。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the project from the following template:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Navigate to the `cncb-envelope-encryption` directory with `cd cncb-envelope-encryption`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cd cncb-envelope-encryption` 命令导航到 `cncb-envelope-encryption` 目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看名为 `serverless.yml` 的文件，其内容如下：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Review the file named `handler.js` with the following content:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看名为 `handler.js` 的文件，其内容如下：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Install the dependencies with `npm install`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm install` 安装依赖。
- en: Run the tests with `npm test`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm test` 运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看在 `.serverless` 目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署堆栈：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 控制台中查看堆栈和资源。
- en: 'Invoke the following `curl` commands, after updating `<API-ID>`, to encrypt
    and decrypt data:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `<API-ID>` 后，调用以下 `curl` 命令以加密和解密数据：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Review the encrypted data in the DynamoDB Console.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看在 DynamoDB 控制台中加密的数据。
- en: 'Take a look at the logs:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看日志：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm run rm:lcl -- -s $MY_STAGE` 完成后，删除堆栈。
- en: KMS is not included in the AWS free tier.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: KMS 不包含在 AWS 免费层中。
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Envelope encryption is, in essence, the practice of encrypting one key with
    another key; sensitive data is encrypted with a data key and then the data key
    is encrypted with a master key. In this recipe, the `save` function encrypts the
    data before saving it to DynamoDB, and the `get` function decrypts the data after
    retrieving it from DynamoDB and before returning the data to the caller. In the
    `serverless.yml` file, we define a KMS `MasterKey` and a `MasterKeyAlias`. The
    alias facilitates the rotation of the master key. The `save` function calls `kms.generateDataKey`
    to create a data key for the object. Each object gets its own data key and a new
    key is generated each time the object is saved. Again, this practice facilitates
    key rotation. Following the *security-by-design* practice, we identify which fields
    are sensitive as we design and develop a service. In this recipe, we encrypt all of the
    fields individually. The data key is used to encrypt each field locally using
    an `AES` encryption library. The data key was also encrypted by the master key
    and returned to the `CyphertextBlob` field when the data key was generated. The
    encrypted data key is stored alongside the data so that it can be decrypted by
    the `get` function. The `get` function has direct access to the encrypted data
    key once the data has been retrieved from the database. The `get` function has
    been granted permission to call `kms.decrypt` to decrypt the data key. This piece
    of the puzzle is crucial. Access to the master key must be restricted as per the
    least privilege principle. The fields are decrypted locally using an AES encryption
    library so that they can be returned to the caller.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 信封加密本质上是一种使用一个密钥加密另一个密钥的实践；敏感数据首先使用数据密钥进行加密，然后数据密钥再使用主密钥进行加密。在这个配方中，`save`函数在将数据保存到DynamoDB之前对其进行加密，而`get`函数在从DynamoDB检索数据并在将其返回给调用者之前对其进行解密。在`serverless.yml`文件中，我们定义了一个KMS
    `MasterKey`和一个`MasterKeyAlias`。别名便于主密钥的轮换。`save`函数调用`kms.generateDataKey`来为对象创建一个数据密钥。每个对象都有自己的数据密钥，每次对象被保存时都会生成一个新的密钥。再次强调，这种做法便于密钥轮换。遵循*设计安全*实践，我们在设计和开发服务时确定哪些字段是敏感的。在这个配方中，我们单独加密所有字段。数据密钥用于使用`AES`加密库在本地加密每个字段。当生成数据密钥时，数据密钥也被主密钥加密并返回到`CyphertextBlob`字段。加密后的数据密钥与数据一起存储，以便`get`函数可以对其进行解密。`get`函数在从数据库检索数据后可以直接访问加密的数据密钥。`get`函数已被授权调用`kms.decrypt`来解密数据密钥。这个环节至关重要。必须根据最小权限原则限制对主密钥的访问。字段使用AES加密库在本地解密，以便可以返回给调用者。
- en: Creating an SSL certificate for encryption in transit
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于传输加密的SSL证书
- en: Encrypting data in transit is critical for systems with sensitive data, which
    accounts for most systems these days. Fully managed cloud services, such as function-as-a-service,
    cloud-native databases, and API Gateways, encrypt data in transit as a matter
    of course. This helps ensure that our data in motion is secured across the full
    stack, with little to no effort on our part. However, we ultimately want to expose
    our cloud-native resources via custom domain names. To do this and support SSL,
    we must provide our own SSL certificates. This process can be tedious and we must
    ensure that we rotate certificates in a timely manner before they expire and cause
    a system outage. Fortunately, more and more cloud providers are offering fully
    managed certificates that are automatically rotated. In the recipe, we will use
    the *AWS Certificate Manager* to create a certificate and associate it with a
    *CloudFront* distribution.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含敏感数据的系统，传输中的数据加密至关重要，这占到了当今大多数系统。完全管理的云服务，如函数即服务、云原生数据库和API网关，将数据传输加密作为一项常规操作。这有助于确保我们的数据在运动过程中在整个堆栈中得到保护，而我们几乎不需要付出任何努力。然而，我们最终希望通过自定义域名公开我们的云原生资源。为了做到这一点并支持SSL，我们必须提供自己的SSL证书。这个过程可能很繁琐，我们必须确保在证书到期并导致系统故障之前及时轮换证书。幸运的是，越来越多的云服务提供商正在提供自动轮换的完全管理证书。在这个配方中，我们将使用*AWS证书管理器*来创建证书并将其与*CloudFront*分发关联。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a registered domain name and a Route 53 hosted zone that you can
    use in this recipe to create a subdomain for the site that will be deployed, and
    you will need authority to approve the creation of the certificate or access to
    someone with the authority.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个已注册的域名和一个可以用于此配方创建将要部署的站点的子域的Route 53托管区域，并且您需要有权批准证书的创建或有权访问具有该权限的人。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the project from the following template:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Navigate to the `cncb-ssl-cert` directory with `cd cncb-ssl-cert`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd cncb-ssl-cert`导航到`cncb-ssl-cert`目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下内容的`serverless.yml`文件：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Update the `serverless.yml` file with your `hostedZoneId` and  `validationDomain`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的`hostedZoneId`和`validationDomain`更新`serverless.yml`文件。
- en: Install the dependencies with `npm install`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装依赖项。
- en: Run the tests with `npm test`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test`运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`.serverless`目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署堆栈：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To complete this step, an authorized person is needed to receive the certificate
    approval request email and approve the creation of the certificate. The CloudFormation
    stack will appear to pause until the certificate is approved.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此步骤，需要授权人员接收证书批准请求电子邮件并批准证书的创建。CloudFormation堆栈将暂停，直到证书获得批准。
- en: Review the stack and resources in the AWS Console.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中查看堆栈和资源。
- en: 'Invoke the following `curl` command with the `WebsiteURL` from the stack output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用堆栈输出中的`WebsiteURL`调用以下`curl`命令：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成操作后，使用`npm run rm:lcl -- -s $MY_STAGE`删除堆栈。
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the resources section of the `serverless.yml` file, we define the `WildcardCertificate`
    resource to instruct the AWS Certificate Manager to create the desired certificate.
    We create a wildcard certificate so that it can be used by many services. It is
    important to specify the correct `validationDomain`, because this will be used
    to request approval before creating the certificate. You must also provide `hostedZoneId`
    for the top-level domain name. Everything else is handled by the `serverless-spa-config`
    plugin. The recipe deploys a simple site consisting of an `index.html` page. The
    `endpoint` for the site is used to create a Route 53 record set in the hosted
    zone and is assigned as the alias of the site's CloudFront distribution. The wildcard
    certificate matches the endpoint and its `acmCertificateArn` is assigned to the
    distribution. Ultimately, we can access `WebsiteURL` with the `https` protocol
    and the custom domain name.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`serverless.yml`文件的资源部分，我们定义了`WildcardCertificate`资源，以指示AWS证书管理器创建所需的证书。我们创建了一个通配符证书，以便它可以由许多服务使用。指定正确的`validationDomain`非常重要，因为这将用于在创建证书之前请求批准。您还必须为顶级域名提供`hostedZoneId`。其余一切由`serverless-spa-config`插件处理。该配方部署了一个由`index.html`页面组成的简单网站。该网站的`endpoint`用于在托管区域中创建Route
    53记录集，并将其分配为网站的CloudFront分发的别名。通配符证书与端点匹配，其`acmCertificateArn`分配给分发。最终，我们可以使用`https`协议和自定义域名访问`WebsiteURL`。
- en: Configuring a web application firewall
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Web应用防火墙
- en: A **web application firewall** (**WAF**) is an important tool for controlling
    the traffic of a cloud-native system. A WAF protects the system by blocking traffic
    from common exploits such as bad bots, SQL injection, **Cross-Site Scripting**
    (**XSS**), HTTP floods, and known attackers. We effectively create a perimeter
    around the system that blocks traffic at the edge of the cloud before it can impact
    system resources. We can use many of the techniques in this book to monitor internal
    and external resources and dynamically update the firewall rules as the flow of
    traffic changes. Managed rules are also available on the market, so we can leverage
    the extensive security expertise of third parties. In this recipe, we will demonstrate
    how the pieces fit together by creating a rule to block traffic from outside a
    corporate network and associate the WAF with a *CloudFront* distribution.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web应用防火墙**（**WAF**）是控制云原生系统流量的重要工具。WAF通过阻止来自常见漏洞，如恶意机器人、SQL注入、**跨站脚本攻击**（**XSS**）、HTTP洪水和已知攻击者的流量来保护系统。我们有效地在系统周围创建了一个外围，在流量能够影响系统资源之前，在云边缘阻止流量。我们可以使用本书中的许多技术来监控内部和外部资源，并根据流量变化动态更新防火墙规则。市场上也有可用的托管规则，因此我们可以利用第三方广泛的安全专业知识。在本配方中，我们将通过创建一个阻止来自企业网络外部的流量的规则，并将WAF与*CloudFront*分发关联起来，来展示这些组件是如何组合在一起的。'
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the project from the following template:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建项目：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Navigate to the `cncb-waf` directory with `cd cncb-waf`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd cncb-waf`导航到`cncb-waf`目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下内容的`serverless.yml`文件：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Determine your corporate external public IP address by logging in to your VPN
    and then executing the following command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过登录VPN并执行以下命令来确定您的企业外部公共IP地址：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Update `WhitelistIPSet` in the `serverless.yml` file with your IP address followed
    by `/32`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`serverless.yml`文件中更新`WhitelistIPSet`，后跟你的IP地址和`/32`。
- en: Install the dependencies with `npm install`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装依赖项。
- en: Run the tests with `npm test`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test`运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看在`.serverless`目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署堆栈：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Review the stack and resources in the AWS Console.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中查看堆栈和资源。
- en: Browse to the `WebsiteDistributionURL` listed in the stack outputs while connecting
    to your VPN and you will be able to access the page.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接VPN的同时浏览堆栈输出中列出的`WebsiteDistributionURL`，您将能够访问该页面。
- en: Now, disconnect from the VPN and you will be denied access to the page once
    the cache has cleared.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，断开VPN连接，一旦缓存清除，您将无法访问页面。
- en: Remove the stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成使用`npm run rm:lcl -- -s $MY_STAGE`后，请移除堆栈。
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing to note is that usage of the AWS WAF is predicated on using
    CloudFront. The `serverless-spa-config` plugin creates the CloudFront distribution
    and assigns `webACLId`. For this recipe, we are securing a simple `index.html`
    page. We create a static `WebACL` to block everything except a single IP address.
    We define the `WhitelistIPSet` for the single address and associate it with `WhitelistRule`.
    Then, we associate the rule with an **access control list** (**ACL**) and define
    the default action to `BLOCK` all access, and then an action to `ALLOW` access
    based on `WhitelistRule`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，使用AWS WAF的前提是使用CloudFront。`serverless-spa-config`插件创建CloudFront分布并分配`webACLId`。对于这个配方，我们正在保护一个简单的`index.html`页面。我们创建一个静态的`WebACL`来阻止除单个IP地址之外的所有内容。我们为单个地址定义`WhitelistIPSet`并将其与`WhitelistRule`关联。然后，我们将规则与访问控制列表（ACL）关联，并将默认操作定义为`BLOCK`所有访问，然后基于`WhitelistRule`定义一个允许访问的操作。
- en: This example is useful, but it only scratches the surface of what is possible.
    For example, we could uncomment the logging configuration for the CloudFront distribution
    and then process the access logs and dynamically create rules based on suspicious
    activity. On a daily basis, we can retrieve public reputation lists and update
    the rule sets as well. Defining and maintaining effective rules can be a full-time
    effort, therefore the fully managed rules that are available on the AWS marketplace
    are an attractive alternative for, or companion to, custom rules.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例很有用，但它只是触及了可能性的表面。例如，我们可以取消注释CloudFront分布的日志配置，然后根据可疑活动处理访问日志并动态创建规则。在日常生活中，我们还可以检索公共声誉列表并更新规则集。定义和维护有效的规则可能是一项全职工作，因此AWS市场上可用的完全管理的规则是自定义规则的有吸引力的替代品或补充。
- en: Replicating the data lake for disaster recovery
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制数据湖以进行灾难恢复
- en: When I first read this story about Code Spaces ([https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html](https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html)),
    I was a bit horrified until I realized that this company perished so that we could all learn
    from its experience. Code Spaces was a company that used AWS and their account
    was hijacked and held to ransom. They fought back and the entire contents of their
    account were deleted, including their backups, and they simply went out of business.
    Proper use of MFA and proper access key hygiene is critical to ward off such attacks.
    It is also crucial to maintain backups as an entirely separate and disconnected
    account, so that the breach of a single account does not spell disaster for an
    entire system and company. In this recipe, we will use the S3 replication feature
    to replicate buckets to a dedicated recovery account. At a minimum, this technique
    should be used to replicate the contents of the data lake, since the events in
    the data lake can be replayed to recreate the system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次阅读关于Code Spaces（[https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html](https://www.infoworld.com/article/2608076/data-center/murder-in-the-amazon-cloud.html)）的故事时，我有点害怕，直到我意识到这家公司之所以倒闭，是为了让我们都能从它的经验中学习。Code
    Spaces是一家使用AWS的公司，他们的账户被黑客入侵并被勒索。他们进行了反击，他们的整个账户内容，包括备份，都被删除了，他们就这样倒闭了。正确使用多因素认证（MFA）和良好的访问密钥卫生习惯对于防止此类攻击至关重要。同样重要的是，要维护一个完全独立且断开的备份账户，这样单个账户的泄露就不会给整个系统和公司带来灾难。在这个菜谱中，我们将使用S3复制功能将存储桶复制到专门的恢复账户。至少，这项技术应该用于复制数据湖的内容，因为数据湖中的事件可以被重放以重建系统。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the source and recovery projects from the following templates:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下模板创建源和恢复项目：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Navigate to the `cncb-dr-recovery-account` directory with `cd cncb-dr-recovery-account`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd cncb-dr-recovery-account`导航到`cncb-dr-recovery-account`目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为`serverless.yml`的文件，其内容如下：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Install the dependencies with `npm install`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装依赖项。
- en: Run the tests with `npm test`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test`运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`.serverless`目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署栈：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Navigate to the `cncb-dr-src1-account` directory with `cd cncb-dr-src1-account`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd cncb-dr-src1-account`导航到`cncb-dr-src1-account`目录。
- en: 'Review the file named `serverless.yml` with the following content:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查名为`serverless.yml`的文件，其内容如下：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Install the dependencies with `npm install`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`安装依赖项。
- en: Run the tests with `npm test`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm test`运行测试。
- en: Review the contents generated in the `.serverless` directory.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`.serverless`目录中生成的内容。
- en: 'Deploy the stack:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署栈：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Review the stacks and buckets in the AWS Console.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中检查栈和存储桶。
- en: 'Invoke the following command to load data:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令加载数据：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Review the contents of both buckets to see that the data has replicated.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查两个存储桶的内容，以确保数据已复制。
- en: Remove each stack once you are finished with `npm run rm:lcl -- -s $MY_STAGE`
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，使用`npm run rm:lcl -- -s $MY_STAGE`删除每个栈。
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: AWS S3 does all the heavy lifting of replicating the contents of one bucket
    to another. We just have to define what and where we want to replicate and set
    up all the permissions correctly. It is important to replicate to a separate account
    that is completely disconnected from any other accounts to ensure that a breach
    in another account does not impact the recovery account. To simplify this recipe,
    we will use a single account, but this does not change the CloudFormation templates
    other than the account number value. It is also a good idea to replicate into
    a region that you are not otherwise using, so that an outage in one of your regions
    does not also mean there is an outage in your recovery region. Next, we need to
    create a corresponding bucket in the recovery account for every source bucket
    that we want to replicate. It is a good idea to use a naming convention with prefixes
    and/or suffixes to differentiate the source bucket easily from the destination
    bucket. All of the buckets must turn on versioning to support replication. The
    source buckets grant permission to the S3 service to perform the replication,
    and the destination buckets grant permission to the source account to write to
    the recovery account. We also transfer ownership of the replicated contents to
    the recovery account. Ultimately, if the contents are completely deleted from
    the source bucket, the destination bucket will still contain the contents along
    with the deletion marker.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: AWS S3负责将一个存储桶的内容复制到另一个存储桶的所有繁重工作。我们只需定义要复制的内容和位置，并正确设置所有权限即可。将数据复制到完全与任何其他账户断开连接的单独账户中非常重要，以确保另一个账户的漏洞不会影响恢复账户。为了简化这个流程，我们将使用单个账户，但这并不会改变除了账户编号值之外的CloudFormation模板。将数据复制到您通常不使用的区域也是一个好主意，这样您某个区域的故障就不会导致您的恢复区域也出现故障。接下来，我们需要为每个要复制的源存储桶在恢复账户中创建相应的存储桶。使用前缀和/或后缀的命名约定来轻松区分源存储桶和目标存储桶是一个好主意。所有存储桶都必须开启版本控制以支持复制。源存储桶授予S3服务执行复制的权限，而目标存储桶授予源账户向恢复账户写入的权限。我们还把复制的文件内容的所有权转让给恢复账户。最终，如果源存储桶中的内容被完全删除，目标存储桶仍然会包含这些内容以及删除标记。
