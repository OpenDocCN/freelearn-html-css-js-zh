- en: Applying Advanced Service Worker Cache Strategies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用高级服务工作者缓存策略
- en: It's time to take our progressive web app capabilities up a notch. So far, you
    have learned how to add to the home screen experience, core service worker concepts,
    and how to make your site secure. In this chapter, we will dive into advanced
    service worker concepts and a brand new progressive web app, PWA tickets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候提升我们的渐进式Web应用能力了。到目前为止，你已经学会了如何添加到主屏幕体验、核心服务工作者概念以及如何使你的网站安全。在本章中，我们将深入探讨高级服务工作者概念和全新的渐进式Web应用，PWA门票。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is PWA tickets?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是PWA门票？
- en: How to run a local, mock API server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运行本地、模拟API服务器
- en: PWA application architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWA应用程序架构
- en: Importing utility libraries to a service worker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实用库导入服务工作者中
- en: A service worker response manager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者响应管理器
- en: Advanced caching strategies and techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级缓存策略和技术
- en: Caching invalidation techniques
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存失效技术
- en: What is PWA tickets?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是PWA门票？
- en: The PWA tickets application is an example hosted service application designed
    to resemble an online ticket purchasing solution. While there are many aspects
    of this application I could have focused on, this book focuses on the consumer
    app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PWA门票应用程序是一个托管服务应用程序的示例，旨在模仿在线购票解决方案。虽然我可以关注这个应用程序的许多方面，但本书专注于消费者应用程序。
- en: 'The following screenshot is the PWA ticket home page, which displays a list
    of cards for upcoming events that the customer can purchase tickets for. Card
    refers to the UI metaphor that is used to style the block representing items in
    a list:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是PWA门票首页，显示了客户可以购买门票的即将举行的活动卡片列表。卡片是指用于样式化列表中项的UI隐喻：
- en: '![](img/00091.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: A real ticket service application would be a suite of apps including an administrative
    application and an app for ushers to validate tickets. For this book, I will focus
    on the consumer client experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真实的门票服务应用程序将包括一套应用程序，包括管理应用程序和用于验证门票的应用程序。对于这本书，我将专注于消费者客户端体验。
- en: The consumer version of the application features user login, profile management,
    access to a list of future events, the ability to buy tickets, and the user's
    ticket purchase history.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的消费者版本具有用户登录、资料管理、访问未来事件列表、购买门票的能力以及用户的购票历史。
- en: The application itself consists of a live API and static web pages, but the
    real area of focus for this chapter is some of the advanced service worker concepts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序本身由实时API和静态网页组成，但本章真正关注的焦点是一些高级服务工作者概念。
- en: The service worker evaluates each `fetch` request and processes it differently.
    The service worker pre-caches critical assets, but also defines custom rules for
    different routes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者评估每个 `fetch` 请求并对其进行不同的处理。服务工作者预先缓存关键资源，但也为不同的路由定义自定义规则。
- en: Another new advanced concept is the idea of cache invalidation. This is where
    you define a rule that applies to cached responses and determines if a network
    request should be made and the cache invalidated. This is an important concept
    to understand because it gives you full control over your applications, caching
    rules and allows you to manage how much is stored in the cache.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新的高级概念是缓存失效的想法。这是你定义适用于缓存响应的规则，并确定是否应该发起网络请求以及使缓存失效的地方。这是一个重要的概念，因为它让你完全控制你的应用程序、缓存规则，并允许你管理缓存中存储的内容量。
- en: 'The PWA tickets application will demonstrate some new concepts and tactics,
    which will help you create professional progressive web apps, such as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PWA门票应用程序将展示一些新的概念和策略，这将帮助你创建专业的渐进式Web应用，例如以下内容：
- en: Service worker templating
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者模板
- en: Cache invalidation
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存失效
- en: Triggering different cache strategies based on a requested URL
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据请求的URL触发不同的缓存策略
- en: Using `importScripts`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `importScripts`
- en: Reviewing the PWA ticket application
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查PWA门票应用程序
- en: 'Let''s take look at the different sections that our application will consist
    of. There are eight main page areas of the application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看应用程序将包含的不同部分。应用程序有八个主要页面区域：
- en: Home
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首页
- en: User Profile
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户资料
- en: Events
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动
- en: Tickets
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门票
- en: Cart
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车
- en: Contact
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系方式
- en: Configure
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Login
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录
- en: 'Tickets and events both consist of two pages: one for a list and another for
    an item detail. The application also features our first pages, which make POST
    requests to an API rather than just a GET request. This introduces a new `fetch`
    method that our service worker must handle correctly'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 票务和事件都包含两个页面：一个是列表页，另一个是项目详情页。该应用还包含我们的第一个页面，这些页面会向API发起POST请求，而不仅仅是GET请求。这引入了一个新的`fetch`方法，我们的service
    worker必须正确处理。
- en: The homepage lists 10 future events, followed by a list of user purchased tickets.
    Each item utilizes a card, which is styled using the bootstrap card classes. Each
    ticket card also has a button to show the item's details.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首页列出了10个即将举行的事件，后面跟着用户购买的票务列表。每个条目都使用bootstrap卡片类进行样式化。每个票务卡片还有一个按钮来显示项目的详情。
- en: The user profile page list the user's contact information and some of their
    most recently purchased tickets. It also features a button to update the user
    profile. This will toggle the view from read-only to edit mode.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用户个人资料页面列出了用户的联系信息和一些他们最近购买的票务。它还包含一个更新用户资料的按钮。这将切换视图从只读模式到编辑模式。
- en: 'The application''s navigation consists of Events, Tickets, Profile, Logout,
    and a Search field:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的导航包括事件、票务、个人资料、注销和一个搜索字段：
- en: '![](img/00092.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00092.jpeg)'
- en: A user can enter a search term and whatever page they are on will automatically
    update to show any matching events without making a round trip to load a new page.
    It does this by making an AJAX call and rendering the results in the browser and
    service worker.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以输入搜索词，无论他们处于哪个页面，都会自动更新以显示任何匹配的事件，而无需加载新页面。这是通过发起一个AJAX调用并在浏览器和service worker中渲染结果来实现的。
- en: The application's API is not representative of a production quality search feature,
    but serves our purpose. It will match any event that contains the phrase entered
    in the search box.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的API并不代表一个生产质量的搜索功能，但它服务于我们的目的。它将匹配搜索框中输入的任何包含的短语的事件。
- en: 'The events page will list all future events that are available in the system.
    Again, each event is a card with a button to view the event''s details. The event''s
    details page shows a little more information and includes a list of tickets that
    are available to purchase:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 事件页面将列出系统中所有可用的未来事件。同样，每个事件都是一个带有查看事件详情按钮的卡片。事件的详情页面显示了更多一些信息，并包括可供购买的票务列表：
- en: '![](img/00093.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00093.jpeg)'
- en: A true ticket service app would offer a more sophisticated way to find tickets,
    but I wanted to keep this simple for demonstration purposes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正的票务服务应用会提供一种更复杂的方式来查找票务，但我希望为了演示目的保持其简单性。
- en: When a user buys a ticket, they must confirm the purchase and then it is added
    to their profile
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户购买票务时，他们必须确认购买，然后它会被添加到他们的个人资料中。
- en: 'Selecting the tickets link in the Now bar takes the user to a list of their
    purchased tickets. From here, they can view the details of any ticket, which includes
    a QR code. The QR code is meant to simulate what modern E-ticket solutions use
    for ushers and gate agents to scan when you enter a venue or when you need to
    find your seat:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Now栏中选择票务链接会将用户带到他们购买的票务列表。从这里，他们可以查看任何票务的详情，包括一个二维码。二维码旨在模拟现代电子票务解决方案在进入场地或需要找到座位时
    usher 和 gate agent 扫描的内容：
- en: '![](img/00094.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00094.jpeg)'
- en: This is where the usher's app would come into play. They could use their phone
    to scan the QR code to confirm the ticket and allow the customer into the venue.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 usher 的应用可以发挥作用的地方。他们可以使用手机扫描二维码以确认票务并允许顾客进入场地。
- en: There is also a contact page where a user could submit a message to the system
    administrators. It is mostly used to demonstrate how to handle post messages using
    fetch and the service worker.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里还有一个联系页面，用户可以向系统管理员提交信息。这主要用于演示如何使用fetch和service worker来处理帖子消息。
- en: 'Finally, the entire application requires a user to be authenticated. Each page
    does a quick verification if the user is logged in, and if not, loads the login
    page:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，整个应用要求用户进行身份验证。每个页面都会快速验证用户是否已登录，如果没有，则会加载登录页面：
- en: '![](img/00095.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00095.jpeg)'
- en: The user logs in by entering a username and password. The credentials are sent
    to the API for verification. The API returns the user's profile, which simulates
    an authentication token. The authentication token is persisted and `IndexedDB`
    (using `localForage`), and verified before each page load.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过输入用户名和密码进行登录。凭证被发送到API进行验证。API返回用户的个人资料，这模拟了一个身份验证令牌。身份验证令牌被持久化，并在每次页面加载前进行验证。
- en: The user does not yet have a profile they can select. They can use the create
    new profile link and add themselves to the system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用户目前还没有可以选择的个人资料。他们可以使用创建新个人资料链接并将自己添加到系统中。
- en: 'The following function is the application''s API call to log a user into the
    application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是应用程序的API调用，用于将用户登录到应用程序：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the username and password are passed to the API using the `queryString`.
    I would not do this normally, but I needed a way to work with json-server and
    it did not seem to offer a way to match without a custom function using a POST.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用户名和密码是通过`queryString`传递给API的。我通常不会这样做，但我需要一种与json-server一起工作的方式，它似乎没有提供使用POST匹配的自定义函数的方式。
- en: You would not want to do this in production because it exposes credentials.
    When posting the credentials as part of the request body, they are shielded behind
    HTTPS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您不希望在生产环境中这样做，因为这会暴露凭证。当将凭证作为请求体的一部分发送时，它们被HTTPS保护。
- en: The PWA ticket application includes a minimal feature set, which I feel will
    help demonstrate the concepts covered in the last three chapters. This introduction
    to how the application works does not quite cover everything. I invite you to
    clone the source code ([https://github.com/docluv/pwa-ticket](https://github.com/docluv/pwa-ticket))
    and run it locally.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: PWA车票应用程序包含一个最小功能集，我认为这将有助于展示前三章中涵盖的概念。这个关于应用程序如何工作的介绍并没有涵盖所有内容。我邀请您克隆源代码([https://github.com/docluv/pwa-ticket](https://github.com/docluv/pwa-ticket))并在本地运行它。
- en: Using the JSON server for an API
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON服务器作为API
- en: When you build modern applications, the frontend almost always communicates
    with an API to interact with a date source. The API is the gateway to the backend
    application and can be consumed by any client application, such as a Progressive
    Web App.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建现代应用程序时，前端几乎总是通过API与数据源进行交互。API是后端应用程序的入口，可以被任何客户端应用程序消费，例如渐进式Web应用程序。
- en: Developing against an API can be rather tricky when you don't want to develop
    the entire API first. In the podcast application, we simply loaded a pre-rendered
    JSON to simulate an API. The podcast application only made a GET request and did
    not do any post requests or attempts to update the underlying data model.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不想首先开发整个API时，针对API进行开发可能会相当棘手。在播客应用程序中，我们只是加载了一个预渲染的JSON来模拟API。播客应用程序只进行了GET请求，没有进行任何POST请求或尝试更新底层数据模型。
- en: 'The PWA ticket application does make post requests and attempts to update the
    underlying data model, but rather than building out an entire infrastructure for
    this, I found a nice solution: json-server ([https://github.com/typicode/json-server](https://github.com/typicode/json-server)).
    This is a node module that works much like the http-server we used for the previous
    applications.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: PWA车票应用程序确实会进行POST请求并尝试更新底层数据模型，但与其构建整个基础设施，我找到了一个很好的解决方案：json-server([https://github.com/typicode/json-server](https://github.com/typicode/json-server))。这是一个类似于我们用于前几个应用程序的http-server的node模块。
- en: 'The real advantage of json-server is its built-in ability to create a fully
    functioning API based on a JSON data model. You must install the module like any
    other node module: by using `npm install` and including a reference to it in your
    `packages.json` file.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: json-server的真正优势在于其内置的创建基于JSON数据模型的完整功能API的能力。您必须像安装任何其他node模块一样安装该模块：使用`npm
    install`并在您的`package.json`文件中包含对其的引用。
- en: Before you execute the server, you must create a data source. This is just another
    JSON file. Rather than manually creating the data and the data model, I chose
    to write a script that uses the faker module ([https://github.com/marak/Faker.js/](https://github.com/marak/Faker.js/)).
    This can also be installed using the standard NPM tasks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在您执行服务器之前，您必须创建一个数据源。这只是一个JSON文件。而不是手动创建数据和数据模型，我选择编写一个使用faker模块([https://github.com/marak/Faker.js/](https://github.com/marak/Faker.js/))的脚本。这也可以使用标准的NPM任务进行安装。
- en: faker is a pretty cool node module that allows you to dynamically generate massive
    amounts of fake data for you to build your application around. This is one of
    the more troubling aspects of front and web development in my opinion, because
    you need large amounts of data to validate your application logic. However, that
    takes a long time to create. Faker eliminates this problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: faker是一个相当酷的node模块，允许你动态地为你生成大量虚假数据，以便你围绕这些数据构建应用程序。在我看来，这是前端和Web开发中更令人烦恼的方面之一，因为你需要大量数据来验证你的应用程序逻辑。然而，创建这些数据需要很长时间。Faker消除了这个问题。
- en: Combining json-server and faker together allows you to create a very complex
    and deep API and data source. You can emulate just about every aspect of your
    potential API and backend with these two modules.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将json-server和faker结合使用，可以创建一个非常复杂和深入API和数据源。你可以使用这两个模块模拟你潜在API和后端的几乎所有方面。
- en: As I created the PWA ticket application, I modified the data model numerous
    times trying to get things just right. Rather than hand coding all of the data,
    I was able to write a script to rebuild the database from scratch.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建PWA票务应用程序的过程中，我多次修改数据模型，试图使其恰到好处。而不是手动编码所有数据，我能够编写一个脚本来从头开始重建数据库。
- en: 'The project source repository includes a top-level folder called `utils`. In
    this folder, there are a couple of scripts: one to generate fake data and another
    to render the pages. The fake data script utilizes a combination of faker and
    some fixed data sources.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 项目源代码库包括一个名为`utils`的顶级文件夹。在这个文件夹中，有几个脚本：一个用于生成虚假数据，另一个用于渲染页面。虚假数据脚本利用了faker和一些固定数据源的组合。
- en: Faker has the capability to generate data of all kinds, including images. However,
    I found the images that it generates and uses to be a slow, random image generation
    service. Rather than rely on those images, I chose to fix a small set of 8 venue
    images and 8 headshot images. The 16 images are stored under the website's `img`
    folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Faker具有生成各种类型数据的能力，包括图像。然而，我发现它生成的和使用图像是一个缓慢的、随机的图像生成服务。与其依赖这些图像，我选择固定一组8张场馆图像和8张肖像图像。这16张图像存储在网站的`img`文件夹下。
- en: 'You will also notice a method to generate QR codes. This is also done with
    a pair of node modules: one to generate a QR code image and another to save that
    image to disk.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到一个生成二维码的方法。这也是通过一对node模块完成的：一个用于生成二维码图像，另一个用于将图像保存到磁盘。
- en: A QR code is generated for each ticket and represents the ticket's unique identifier.
    Each barcode image that is generated is saved to the website in the barcodes folder.
    Each barcode image is a `.gif` file and has the extension appended to its name.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每张票都会生成一个二维码，代表票的唯一标识符。生成的每个条形码图像都保存在网站的`barcodes`文件夹中。每个条形码图像是一个`.gif`文件，并且扩展名附加在其名称之后。
- en: While these node modules are critical to running the PWA ticket application,
    they are not directly related to service workers and progressive web apps. I do
    want to take a little time to explain how they work so that you can use the source
    code locally.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些node模块对于运行PWA票务应用程序至关重要，但它们与服务工作者和渐进式Web应用程序没有直接关系。我确实想花点时间解释它们是如何工作的，这样你就可以在本地使用源代码。
- en: Making a database and the API
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库和API
- en: 'The JSON server allows you to host a local REST API by supporting basic CRUD
    operations without writing any code. The node module works by reading a source
    file with a complete JSON object. The PWA ticket app relies on a JSON data structure,
    which is outlined here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JSON服务器允许你通过支持基本的CRUD操作而不编写任何代码来托管本地REST API。该node模块通过读取包含完整JSON对象的源文件来工作。PWA票务应用程序依赖于JSON数据结构，如下所述：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can configure the data source to include methods to return data based on
    supplied parameters. I chose not to do this in order to keep things simple. Hence,
    this explains the use of both the `futureEvents` and `pastEvents` arrays instead
    of creating these lists on demand.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置数据源以包含基于提供的参数返回数据的方法。我选择不这样做，以保持事情简单。因此，这解释了为什么使用`futureEvents`和`pastEvents`数组，而不是按需创建这些列表。
- en: 'To execute `json-server`, run the command-line utility with the `--watch` switch.
    The watch switch causes `json-server` to update when the source data file updates:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行`json-server`，使用带有`--watch`开关的命令行实用程序。watch开关会导致`json-server`在源数据文件更新时更新：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The PWA ticket source code has the `db.json` data source file in the root folder.
    The server creates RESTful end points that map to the names of the top-level objects.
    It also doubles as a static file server. You just need to watch out for overlapping
    paths between the objects in the data file and pages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: PWA 票据源代码在根目录中有 `db.json` 数据源文件。服务器创建 RESTful 端点，映射到顶级对象的名称。它还充当静态文件服务器。你只需注意数据文件中的对象和页面之间的重叠路径。
- en: 'I ran into a scenario where I duplicated routes in the same site using `json-server`
    while creating this demonstration application. This forced me to run two instances
    of the web server: one for the API and one for the website.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此演示应用程序时，我遇到了使用 `json-server` 在同一站点重复路由的场景。这迫使我运行两个网络服务器实例：一个用于 API，一个用于网站。
- en: 'For localhost-based servers, you can specify different port numbers to run
    multiple local servers. You can define the port number by adding the `-port` switch
    to the command-line interface:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 localhost 的服务器，你可以指定不同的端口号来运行多个本地服务器。你可以通过在命令行界面添加 `-port` 开关来定义端口号：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I ran into some frustration trying to launch a static web server-only instance,
    so I chose to launch the API using `json-server` and the static website using
    `http-server`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试启动仅静态网络服务器的实例时，我遇到了一些挫折，所以我选择使用 `json-server` 启动 API，并使用 `http-server` 启动静态网站。
- en: 'You can run both local web servers from a command line, one console instance
    each, since they are running a server:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从命令行运行两个本地网络服务器，每个服务器一个控制台实例，因为它们正在运行服务器：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another advantage of running the API server on a different port is that it helps
    emulate cross-domain access, or CORS.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的端口上运行 API 服务器的一个优点是它有助于模拟跨域访问，或称为 CORS。
- en: CORS stands for **cross origin resource sharing** and was created to allow browsers
    to more securely request resources on external domains. It relies on the browser
    using extra headers to manage access to the external resource, typically via AJAX.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 代表 **跨源资源共享**，是为了允许浏览器更安全地请求外部域的资源而创建的。它依赖于浏览器使用额外的头信息来管理对外部资源的访问，通常是通过
    AJAX 实现的。
- en: CORS-specific headers are added by the server to tell the browser which domains
    are allowed to access the resource.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器会添加 CORS 特定的头信息，以告知浏览器哪些域名可以访问资源。
- en: 'To retrieve the data, you can load a URI that corresponds to the API server
    and the name of the object:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索数据，你可以加载一个与 API 服务器和对象名称相对应的 URI：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example URL returns an array of user objects:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例 URL 返回一个用户对象的数组：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are more advanced features available with json-server, but this should
    be enough for you to understand how to run the site locally.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: json-server 提供了更多高级功能，但这应该足以让你了解如何在本地运行站点。
- en: Using faker
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 faker
- en: Before you can host the API using json-server, you need the source data file.
    This is where the faker module is helpful. Creating enough data for a realistic
    test environment has always been one of my top challenges. Today, it seems like
    there are libraries or tools like faker available for most platforms.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用 json-server 托管 API 之前，你需要源数据文件。这正是 faker 模块发挥作用的地方。为真实测试环境创建足够的数据始终是我面临的最大挑战之一。今天，似乎大多数平台都有像
    faker 这样的库或工具。
- en: 'Since I use Node.js for the majority of my projects, faker stands out as a
    powerful tool. It just requires a script to generate the data. This script is
    in the `/utils` folder, `generate-fake-data.js`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我大多数项目都使用 Node.js，因此 faker 是一个突出的强大工具。它只需要一个脚本来生成数据。此脚本位于 `/utils` 文件夹中的 `generate-fake-data.js`：
- en: '![](img/00096.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00096.jpeg)'
- en: This script helped me not only generate the file data set, but also allowed
    me to continually modify the source data as the overall model evolved.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本不仅帮助我生成了文件数据集，还允许我在整体模型演变的过程中不断修改源数据。
- en: This script generates a random number of users, events, and tickets, and maps
    them randomly together to create a complete database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本生成随机数量的用户、事件和票据，并将它们随机映射在一起以创建完整的数据库。
- en: 'I won''t go into all of the details of possible data types available from `faker`.
    This is how the script generates a new user:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细介绍 `faker` 可用的所有可能的数据类型。这是脚本生成新用户的方式：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `faker` object has different top-level data types with various methods to
    generate properly formatted, random data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`faker` 对象具有不同的顶级数据类型，并提供各种方法来生成格式正确、随机的数据。'
- en: The data values generated by faker are in the correct or expected format. I
    love some of the text values it generates. I encourage you to read through some
    of them because they create some rather humorous values and combinations! For
    example, *Generic Plastic Cheese*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由 faker 生成的数据值处于正确的或预期的格式。我喜欢它生成的一些文本值。我鼓励你阅读其中的一些，因为它们创造了一些相当幽默的值和组合！例如，*通用塑料奶酪*。
- en: The script is self-contained and will create a fresh database each time it runs.
    Plus, when you launch json-server using the `-watch` switch, the API will automatically
    update for the new data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是自包含的，每次运行时都会创建一个新的数据库。此外，当你使用 `-watch` 开关启动 json-server 时，API 将自动更新以适应新数据。
- en: 'The next aspect of the database remains: QR codes!'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的下一个方面仍然是：二维码！
- en: Generating QR codes
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成二维码
- en: 'Modern ticketing solutions are more about barcodes and QR codes than the physical
    ticket. To create a life-like ticket application, I needed to create custom QR
    codes for each ticket. Again, a pair of node modules made this very straightforward:
    `qr-encode` ([http://cryptocoinjs.com/modules/misc/qr-encode/](http://cryptocoinjs.com/modules/misc/qr-encode/))
    and `ba64`([https://www.npmjs.com/package/ba64](https://www.npmjs.com/package/ba64)).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现代票务解决方案更多地关注条形码和二维码，而不是实体票。为了创建逼真的票务应用程序，我需要为每张票创建自定义的二维码。同样，一对 node 模块使这一过程变得非常简单：`qr-encode`
    ([http://cryptocoinjs.com/modules/misc/qr-encode/](http://cryptocoinjs.com/modules/misc/qr-encode/))
    和 `ba64`([https://www.npmjs.com/package/ba64](https://www.npmjs.com/package/ba64))。
- en: 'qr-encode converts strings into one of a variety of QR code options. The following
    code shows you how to use the `qr` method to generate `dataURI`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`qr-encode` 将字符串转换为多种二维码选项之一。以下代码展示了如何使用 `qr` 方法生成 `dataURI`：'
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `qr` method returns a `base64` encoded data buffer. You still need to convert
    this into a physical file. This is where `ba64` helps. It converts the `base64`
    encoded buffer into a file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`qr` 方法返回一个 `base64` 编码的数据缓冲区。你仍然需要将其转换为物理文件。这正是 `ba64` 发挥作用的地方。它将 `base64`
    编码的缓冲区转换为文件：'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `qrCodePath` points the local path to the `public/qrcodes` folder. The
    script will delete the existing QR image file and create the new QR codes as each
    ticket is generate:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`qrCodePath` 指向 `public/qrcodes` 文件夹的本地路径。脚本将删除现有的二维码图像文件，并在每张票生成时创建新的二维码：'
- en: '![](img/00097.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: The QR code encodes the ticket's unique identifier, which is a GUID generated
    by faker. This ensures that each ticket can be identified by scanning the QR code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 二维码编码了票的唯一标识符，这是一个由 faker 生成的 GUID。这确保了每张票可以通过扫描二维码来识别。
- en: 'Now that the data is generated, and we have a way to serve both the API and
    website, we just need one more thing: the website.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经生成，我们也有了服务 API 和网站的方法，我们只需要一件事：网站。
- en: Rendering the website
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染网站
- en: The 2048 and Podstr apps were based on static websites. While the Podstr app
    used some dynamically rendered pages, most of it was pre-rendered. It also had
    a script to create the HTML pages, but this was not as integral to the demonstration
    as the PWA ticket application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 2048 和 Podstr 应用程序基于静态网站。虽然 Podstr 应用程序使用了一些动态渲染的页面，但大部分是预先渲染的。它还有一个创建 HTML
    页面的脚本，但这个脚本在演示中并不像 PWA 票务应用程序那样关键。
- en: The PWA ticket application has a script to render the core pages by combining
    an app shell and the individual pages markup for the actual page. This is handy
    because it allows you to update the app shell and the pages independently as well
    as customize the rendering script for different environments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: PWA 票务应用程序有一个脚本，通过结合应用程序外壳和实际页面的单个页面标记来渲染核心页面。这很方便，因为它允许你独立更新应用程序外壳和页面，以及为不同的环境定制渲染脚本。
- en: For example, before deploying to production, you will want to bundle and minify
    some style sheets and scripts. As you will see in the next chapter, you will also
    want to reduce the assets, such as styles using tooling.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在部署到生产环境之前，你可能想要捆绑和压缩一些样式表和脚本。正如你将在下一章中看到的，你还将想要使用工具减少资产，例如使用样式。
- en: 'The source markup files are in the site''s HTML folders, `/public/html` and
    `/public/html/pages`, respectively. The rendering script loops over these files
    and loads a corresponding data file defining page-specific configuration data:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 源标记文件位于网站的 HTML 文件夹中，分别是 `/public/html` 和 `/public/html/pages`。渲染脚本会遍历这些文件，并加载定义页面特定配置数据的相应数据文件：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The PWA ticket application has some simple configuration objects. The properties
    are used to define components in each page, like the route or folder to save the
    final rendered file to. These properties are used in the rendering pipeline to
    produce the final page based on a common template.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: PWA票据应用有一些简单的配置对象。这些属性用于定义每个页面中的组件，如路由或文件夹，用于保存最终渲染的文件。这些属性在渲染管道中使用，以基于通用模板生成最终页面。
- en: 'The script is run from the command line:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是从命令行运行的：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The console will log each page as it is rendered.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台将记录每个页面的渲染过程。
- en: The PWA ticket application is more advanced than the Podstr app because most
    of the pages are rendered on the client, not as a full static website. The reason
    the ticket application relies on client-side rendering is due to each page being
    tied to the user's profile and ticket purchase.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: PWA票据应用比Podstr应用更先进，因为大多数页面都是在客户端渲染的，而不是作为一个完整的静态网站。票据应用依赖于客户端渲染的原因是每个页面都与用户的个人资料和购票相关。
- en: This chapter will explore these scenarios and how the service worker can enhance
    the overall experience.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨这些场景以及服务工作者如何增强整体体验。
- en: The PWA ticket rendering architecture and logic
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PWA票据的渲染架构和逻辑
- en: We introduced the concept of an app shell earlier in this book. As a quick recap,
    this is where the application uses a common markup file to manage the common `HEAD`
    and layout features. This shell is then combined with individual pages to compose
    each page.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中较早地介绍了应用壳的概念。快速回顾一下，这是应用使用一个通用的标记文件来管理常见的`HEAD`和布局功能的地方。然后这个壳与单个页面结合，组成每个页面。
- en: The concept has a mass adoption due to the recent rise of single page applications.
    Progressive web apps can benefit from this concept, but do not need to rely on
    rendering the markup in the UI thread.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最近单页应用的兴起，这个概念得到了广泛的应用。渐进式Web应用可以从中受益，但不需要依赖于在UI线程中渲染标记。
- en: 'Instead, the markup can be rendered in the service worker. The technique is
    similar: it uses `Mustache`, a JavaScript template library, to merge the data
    into the markup template. The rendered page markup is returned to the client.
    I will review the code for this later in this chapter.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，标记可以在服务工作者中渲染。技术类似：它使用`Mustache`，一个JavaScript模板库，将数据合并到标记模板中。渲染的页面标记返回给客户端。我将在本章稍后回顾这段代码。
- en: This technique is the practical application of the final caching strategy, *Service
    Worker Templating*, which was discussed in the [Chapter 7](part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d),
    *Service Worker Caching Patterns*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是最终缓存策略的实用应用，即*Service Worker 模板化*，这在第7章[Service Worker 缓存模式](part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d)中讨论过。
- en: The PWA ticket JavaScript architecture
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PWA票据的JavaScript架构
- en: Similar to the Podstr application, the PWA ticket app utilizes a combination
    of third-party libraries and application-specific JavaScript.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与Podstr应用类似，PWA票据应用结合了第三方库和应用特定的JavaScript。
- en: 'The following screenshot shows how the JavaScript files are organized in the
    source code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了JavaScript文件在源代码中的组织方式：
- en: '![](img/00098.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: The custom service worker logic or workflow utilizes different libraries to
    render content on the client. The two third-party libraries are `localForage`
    for `IndexedDB` interactions and `Mustache` to render markup.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 定制的服务工作者逻辑或工作流程利用不同的库在客户端渲染内容。两个第三方库是用于`IndexedDB`交互的`localForage`和用于渲染标记的`Mustache`。
- en: '`localForage` ([https://localforage.github.io/localForage/](https://localforage.github.io/localForage/))
    is another `IndexedDB` wrapper. It provides a simple interface that mimics `localStorage`.
    The main difference is that `localForage` supports promises, making it asynchronous.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`localForage` ([https://localforage.github.io/localForage/](https://localforage.github.io/localForage/))
    是另一个`IndexedDB`包装器。它提供了一个简单的接口，模仿`localStorage`。主要区别在于`localForage`支持`Promise`，使其异步。'
- en: There are three `polyfils`, and these are `Object.assign`, `Promise`, and `Fetch`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个`polyfills`，它们是`Object.assign`、`Promise`和`Fetch`。
- en: 'Each page uses a few application-specific libraries: `api` and `push-mgr`,
    and common application modules. Each page has a page-specific script to drive
    the user experience.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面使用一些特定于应用的库：`api`和`push-mgr`，以及通用应用模块。每个页面都有一个特定的脚本来驱动用户体验。
- en: The application module handles the common UI components, which are hamburger
    menu toggle, logout, search, and authentication validation. It also registers
    the service worker and manages the push notifications at a high level.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序模块处理常见的UI组件，包括汉堡菜单切换、注销、搜索和身份验证验证。它还注册了服务工作者并在较高层次上管理推送通知。
- en: Because the common user interface is simple, I combined these components in
    single script to keep things simpler to manage. Notice that there is no reference
    to jQuery or more complex frameworks to drive the UI. The entire app script is
    roughly 200 lines of nicely spaced code. Individual page scripts are much shorter,
    so there is not a lot of application-specific code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于常见的用户界面很简单，我将这些组件合并到单个脚本中，以保持管理简单。请注意，没有引用jQuery或更复杂的框架来驱动UI。整个应用程序脚本大约有200行整齐排列的代码。单个页面脚本要短得多，因此没有很多特定于应用程序的代码。
- en: 'The `api.js` file is a module that contains methods to interact with the application''s
    API. Because the application is small, I placed all the methods in a single module.
    For a more complex application, you would want to refactor to separate modules
    to make the code easier to maintain:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`api.js`文件是一个包含与应用程序API交互方法的模块。由于应用程序较小，我将所有方法放置在单个模块中。对于更复杂的应用程序，您可能希望重构为独立的模块以使代码更容易维护：'
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method creates a global variable, `pwaTicketAPI`, which can be accessed
    by individual page controller modules to interact with the API.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建了一个全局变量`pwaTicketAPI`，可以被单个页面控制器模块访问以与API交互。
- en: 'Each method wraps a fetch call to an API endpoint:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都封装了对API端点的获取调用：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Most of the API methods make GET requests, but a few make POST requests to
    update or create new records:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数API方法执行GET请求，但少数方法执行POST请求以更新或创建新记录：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Each page controller uses an **Immediately Invoked Function Expression** (**IIFE**)
    to isolate the page logic from the global scope:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面控制器都使用**立即调用的函数表达式**（**IIFE**）来隔离页面逻辑与全局作用域：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Each of the pages follows a common pattern of retrieving data from the API
    and rendering markup to build the page. Most pages have a placeholder with a spinning
    disc. This is replaced when the markup is rendered:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面都遵循从API获取数据并渲染标记以构建页面的通用模式。大多数页面都有一个带有旋转圆盘的占位符。当渲染标记时，它会替换：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The main app-shell has a main element with the `content-target` class. This
    class name is used as a reference to select the element and set the inner HTML
    with the dynamically rendered text:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序外壳有一个具有`content-target`类的`main`元素。这个类名用作选择元素的参考，并使用动态渲染的文本设置内部HTML：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should have noticed how I used `_d.qs()` to select the target element.
    This is a simple utility object that I created to eliminate the need to write
    `document.querySelector()` and the related selector methods. I don''t know about
    you, but I get tired of typing that out everywhere and it''s sort of long for
    the simplicity of jQuery''s selector syntax:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经注意到了我如何使用`_d.qs()`来选择目标元素。这是一个简单的实用程序对象，我创建它来消除编写`document.querySelector()`和相关选择器方法的需要。我不知道你是否和我一样，但我厌倦了到处输入这些内容，而且对于jQuery的选择器语法来说有点长：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This utility provides a simple shorthand to select elements, but without the
    overhead of jQuery.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此实用程序提供了一个简单的简写来选择元素，但无需jQuery的开销。
- en: The PWA ticket service worker architecture
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PWA票据服务工作者架构
- en: The 2048 and Podstr apps have relied on a single script. The PWA ticket app
    uses more complex techniques like importing libraries to drive the logic.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 2048和Podstr应用程序依赖于单个脚本。PWA票据应用程序使用更复杂的技巧，如导入库来驱动逻辑。
- en: 'Service workers can load external scripts using the `importScripts` method.
    This function is available in the global scope and accepts an array of URLs. These
    are additional scripts and work much like the node.js `require` system:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 服务工作者可以使用`importScripts`方法加载外部脚本。此函数在全局范围内可用，并接受一个URL数组。这些是额外的脚本，工作方式类似于node.js的`require`系统：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first two scripts are also used in the client code. `localForage` is an
    `IndexedDB` wrapper and the API script manages access to the API and authentication
    token. The `Mustache` library file is imported in the `ResponseManager` module
    and I will cover how it is used later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个脚本也用于客户端代码。`localForage`是一个`IndexedDB`包装器，API脚本管理对API和身份验证令牌的访问。`Mustache`库文件在`ResponseManager`模块中导入，我将在稍后介绍其用法。
- en: The remaining scripts are common service worker libraries to help with caching
    strategies, such as cache invalidation and push management. Each service worker
    library contains a JavaScript class with methods to manage an aspect of the cache
    strategy and life cycle.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的脚本是一些常见的服务工作者库，用于帮助缓存策略，例如缓存失效和推送管理。每个服务工作者库都包含一个JavaScript类，其中包含用于管理缓存策略和生命周期的方法。
- en: Importing scripts is a great way to refactor your service worker logic into
    smaller units that can be reused and easier to maintain. I have reviewed several
    service workers that were over 10,000 lines of code. Any time you have a large
    code file, you tend to introduce unwanted maintenance issues.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 导入脚本是将服务工作者逻辑重构为更小单元的绝佳方式，这些单元可以复用且更容易维护。我审查了几个超过10,000行代码的服务工作者。每次你有一个大代码文件时，你往往会引入不希望出现的维护问题。
- en: The first problem large code files create is navigating the code. Even with
    modern development environments and nice keyboard shortcuts, it is very easy to
    get lost in the code. If you have ever wasted time looking for functions and coordinating
    variables, you know what this is like.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大代码文件首先造成的问题是导航代码。即使有现代开发环境和不错的键盘快捷键，也很容易在代码中迷失方向。如果你曾经浪费时间寻找函数和协调变量，你就知道这是什么感觉。
- en: Another common problem is managing team access to the code. When you have two
    or more developers with their hands in a single file, this introduces too many
    opportunities for code merges. Code merging is one of my least favorite developer
    activities, especially when someone else wrote the other version.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见问题是管理团队对代码的访问。当你有两个或更多开发者同时在一个文件上工作时，这会引入太多的代码合并机会。代码合并是我最不喜欢的开发者活动之一，尤其是当其他人编写了另一个版本时。
- en: The last problem I see when large files are created is no code reuse. When you
    refactor your code into smaller modules, not only are they focused on a single
    responsibility, the classes, modules, and so on, can be reused in other areas
    of the application or across different applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建大文件时，我看到的最后一个问题是缺乏代码复用。当你将代码重构为更小的模块时，它们不仅专注于单一职责，类、模块等还可以在其他应用程序区域或不同应用程序中复用。
- en: This is why I like importing scripts in service workers. The 2048 service worker
    was very simple and did not warrant this tactic. The Podstr app could use the
    `importScripts` capabilities, but I chose to save this till now. For a true production
    version of Podstr, I would have to refactor the code to import different scripts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我喜欢在服务工作者中导入脚本。2048服务工作者非常简单，并不需要这种策略。Podstr应用可以使用`importScripts`功能，但我选择将其保留到今天。对于Podstr的真正生产版本，我必须重构代码以导入不同的脚本。
- en: One drawback of importing scripts to your service worker is regarding updating
    the scripts. They are not updated when the service worker is updated. Unfortunately,
    I am still not clear on when these files will update from the server. I have read
    references saying that the imported scripts should following normal browser cache
    or cache-control invalidation, and others claimed that this is not working as
    expected.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本导入服务工作者的一个缺点是关于脚本的更新。当服务工作者更新时，它们不会更新。不幸的是，我仍然不清楚这些文件何时会从服务器更新。我读过一些参考资料说导入的脚本应该遵循正常的浏览器缓存或缓存控制失效，而其他人声称这并没有按预期工作。
- en: There are some open discussions about this problem in the specification chats,
    but at this point, I think a true solution has not been adopted.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范讨论中，有一些关于这个问题的开放讨论，但到目前为止，我认为还没有采用真正的解决方案。
- en: Either way, during development, this issue can be very frustrating. You need
    to update these files frequently as you update the code. The best way I have found
    to force these files to update is to manually unregister the service worker.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，在开发过程中，这个问题可能会非常令人沮丧。你需要频繁更新这些文件，因为代码更新。我发现强制这些文件更新的最佳方式是手动注销服务工作者。
- en: After unregistering the service worker, reloading the page registers the service
    worker again and it will execute the `importScripts` method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在注销服务工作者后，重新加载页面会再次注册服务工作者，并执行`importScripts`方法。
- en: 'There is one *bug* with this technique that I am currently seeing in the Chrome
    developer tools, and this is that each unregistered service worker leaves its
    footprint in the tools:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我在Chrome开发者工具中看到的一个与这种技术相关的*bug*是，每个注销的服务工作者都会在工具中留下痕迹：
- en: '![](img/00099.gif)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.gif)'
- en: You can close the tools to reset the service worker panel. If you can tolerate
    scrolling down to the current, active service worker, you can avoid this step.
    I think this is just an issue with the developer tools UI not properly refreshing
    when a service worker is unregistered manually.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以关闭工具以重置服务工作者面板。如果您可以忍受向下滚动到当前的活动服务工作者，您可以避免此步骤。我认为这只是一个问题，即当手动注销服务工作者时，开发者工具
    UI 没有正确刷新。
- en: '`importScripts` can also be used in any script that is imported by the service
    worker. In fact, the service worker''s global scope is available to these scripts.
    Any variable declared in the service worker''s global scope is available in the
    scripts. This also refers to any objects exported from the other imported scripts.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`importScripts` 也可以用于由服务工作者导入的任何脚本。实际上，服务工作者的全局作用域对这些脚本可用。在服务工作者全局作用域中声明的任何变量在脚本中都是可用的。这也适用于从其他导入的脚本导出的任何对象。'
- en: The node request system is similar to the `importScript` method. They both load
    external scripts to create methods and objects you can use in your script, which
    in this case is the service worker.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 节点请求系统与 `importScript` 方法类似。它们都加载外部脚本以创建您可以在脚本中使用的方法和对象，在这种情况下是服务工作者。
- en: The ResponseManager
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ResponseManager
- en: 'The `ResponseManager` contains common logic that correlates to some of the
    caching strategies covered in [Chapter 7](part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d),
    *Service Worker Caching Patterns*. The `ResponseManager` class contains a condensed
    set of cache strategies and the corresponding methods for five caching strategies:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseManager` 包含与第 7 章（[part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d]）中介绍的一些缓存策略相关的常用逻辑，即
    *Service Worker 缓存模式*。`ResponseManager` 类包含一组压缩的缓存策略及其对应的方法，用于五种缓存策略：'
- en: Cache only
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅缓存
- en: Network only
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅网络
- en: Cache falling back to network
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存回退到网络
- en: Cache falling back to network and caching response
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存回退到网络并缓存响应
- en: Cache falling back to network, render result, and cache
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存回退到网络、渲染结果和缓存
- en: 'This is the `ResponseManager` class definition with method signatures:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `ResponseManager` 类的定义以及方法签名：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `cacheOnly` and `networkOnly` method do exactly what their name implies,
    returning a response either from just the cache or just the network:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheOnly` 和 `networkOnly` 方法确实如其名称所暗示的那样，要么只从缓存返回响应，要么只从网络返回响应：'
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`cacheFallingBackToNetwork` checks if a response has been cached and if not,
    makes a network request to fetch the response. The response is not cached.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheFallingBackToNetwork` 检查是否有缓存响应，如果没有，则通过网络请求获取响应。响应不会被缓存。'
- en: '`cacheFallingBackToNetworkCache` repeats that logic, but caches the network
    response.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheFallingBackToNetworkCache` 重复了该逻辑，但会缓存网络响应。'
- en: There are two additional helper methods, which are `fetchText` and `fetchJson`.
    These two methods specifically help the render result strategy to retrieve HTML
    templates and fetch JSON from the API.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个额外的辅助方法，分别是 `fetchText` 和 `fetchJson`。这两个方法专门帮助渲染结果策略检索 HTML 模板并从 API 获取
    JSON 数据。
- en: '`fetchText` is used to retrieve HTML files. `fetchJSON` makes an API call to
    get data. The `fetchAndRenderCache` method utilizes a supplied option parameter
    to execute the API call.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchText` 用于检索 HTML 文件。`fetchJSON` 通过 API 调用获取数据。`fetchAndRenderCache` 方法使用提供的选项参数执行
    API 调用。'
- en: I covered the core concepts around these caching strategies in previous chapters.
    However, I do want to review the `fetchAndRenderCache` strategy because it was
    not covered in detail.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我在之前的章节中介绍了这些缓存策略的核心概念。然而，我确实想回顾一下 `fetchAndRenderCache` 策略，因为它没有详细说明。
- en: The goal of this strategy is to dynamically render a response in the service
    worker and cache the rendered result for the next request. This works great in
    applications like the PWA ticket app, which are highly dynamic.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略的目标是在服务工作者中动态渲染响应并将其缓存以供下一次请求使用。这在像 PWA 票务应用程序这样的高度动态应用程序中效果很好。
- en: While you could pre-render all the HTML pages on the server for any app, it
    may not be as efficient or cost-effective as rendering on demand. In the past,
    we have relied on run-time rendering systems such as ASP.NET, PHP, and so on,
    on the server and large single page app frameworks on the client.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在服务器上为任何应用程序预先渲染所有 HTML 页面，但这可能不如按需渲染高效或成本效益高。在过去，我们依赖于服务器上的运行时渲染系统，如 ASP.NET、PHP
    等，以及客户端的大型单页应用程序框架。
- en: It does not matter how you render the markup; the process is always the same.
    You merge data with a markup template. The engine you are using utilizes some
    sort of merge field syntax and replaces those fields with the matching values
    in the source data.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您如何渲染标记，过程始终相同。您将数据与标记模板合并。您所使用的引擎利用某种合并字段语法，并用源数据中匹配的值替换这些字段。
- en: 'I prefer to use `Mustache` ([http://mustache.github.io/](http://mustache.github.io/))
    because the syntax is relatively simple:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用`Mustache` ([http://mustache.github.io/](http://mustache.github.io/))，因为其语法相对简单：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`Mustache` gets its name from the use of two curly braces to denote the merge
    field. The render method will merge a JSON object''s properties with the matching
    field name. It can do single records or create a repeated list using the same
    template. It also supports basic `if...else` logic and a few other features.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mustache`的名字来源于使用两个花括号来表示合并字段。渲染方法将JSON对象的属性与匹配的字段名合并。它可以使用相同的模板处理单个记录或创建重复的列表。它还支持基本的`if...else`逻辑和一些其他功能。'
- en: 'The PWA ticket application uses `Mustache` templates for most pages, both for
    single records and lists. The application templates are stored in the `/templates`
    folder:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: PWA票据应用程序在大多数页面中使用`Mustache`模板，无论是单个记录还是列表。应用程序模板存储在`/templates`文件夹中：
- en: '![](img/00100.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: The JavaScript `Mustache` library can be used on the client or as a node module.
    I use it on both the server and client in many applications. It's great because
    you can make a single template and use it anywhere in the application and not
    worry about the rendering library being different.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript `Mustache`库可以在客户端或作为node模块使用。我在许多应用程序中在服务器和客户端都使用它。它很棒，因为您可以在应用程序的任何地方使用单个模板，而不用担心渲染库的不同。
- en: If you are following any of the mainstream JavaScript frameworks, they all have
    mature server-side rendering components. I think this is an important trend because
    these frameworks have caused a lot of performance issues and made many sites impossible
    to index in search engines.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在遵循任何主流JavaScript框架，它们都有成熟的服务器端渲染组件。我认为这是一个重要的趋势，因为这些框架已经导致了许多性能问题，并使许多网站无法在搜索引擎中索引。
- en: The rise of these server-side components should give these frameworks a longer
    lifespan and help them to produce better quality user experiences by moving their
    heavy logic to the server. This is also good since so many developers have invested
    many hours learning their proprietary syntaxes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务器端组件的兴起应该会给这些框架带来更长的生命周期，并帮助他们通过将重逻辑移动到服务器来提供更好的用户体验。这对开发者来说也很好，因为许多开发者已经投入了大量时间学习他们的专有语法。
- en: The `fetchAndRenderResponseCache` method executes service worker level run-time
    rendering. It accepts an options parameter that contains different properties
    which are required to drive the strategy.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchAndRenderResponseCache`方法执行服务工作者级别的运行时渲染。它接受一个包含不同属性的选项参数，这些属性是驱动策略所必需的。'
- en: 'I highly recommend pairing this method with a call to cache to see if the response
    is available. The `ResponseManager` has a `cacheOnly` method you can utilize:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议将此方法与一个调用缓存来查看响应是否可用的调用配对。`ResponseManager`有一个可以使用的`cacheOnly`方法：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The method uses a JavaScript object as its only parameter. It should have the
    following properties:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用一个JavaScript对象作为其唯一参数。它应该具有以下属性：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These values are used to drive the logic and make it flexible enough to be
    reused by different pages and components in any application:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值用于驱动逻辑，并使其足够灵活，可以在任何应用程序的不同页面和组件中重用：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first step in the sequence is to retrieve the page's HTML. This is done
    by passing the `pageURL` value to the `fetchText` method. This should resolve
    the page's core HTML.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 序列中的第一步是检索页面的HTML。这是通过将`pageURL`值传递给`fetchText`方法来完成的。这应该解析页面的核心HTML。
- en: Next, the template is fetched using the same method. This time, the resolved
    template HTML is injected in the `pageHTML`. It does this be replacing a custom
    token, `/<%template%>/g`, in the HTML page. Again, this is to make the page template
    more flexible. You could prerender the entire page with the template included.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用相同的方法获取模板。这次，将解析后的模板HTML注入到`pageHTML`中。它是通过在HTML页面中替换自定义标记`/<%template%>/g`来做到这一点的。同样，这是为了使页面模板更加灵活。您可以使用模板预渲染整个页面。
- en: I do this because I want the application to be able to fallback to using classic
    client-side rendering if service workers are not supported.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做是因为我想让应用程序能够在不支持服务工作者的情况下回退到使用经典客户端渲染。
- en: 'At this point, you should have the page''s full HTML, short of rendering with
    the data. The following step retrieves the data from the API using the supplied
    method. This method should return a promise, which means you can just return the
    fetch you use to call the API:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该已经拥有了页面的完整HTML，只是还没有用数据来渲染。接下来的步骤是使用提供的方法从API中检索数据。这个方法应该返回一个promise，这意味着你可以直接返回用于调用API的fetch：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The API method should resolve the response to JSON. The data is then rendered
    with the `pageTemplate` using the `Mustache.render` method. This creates the final
    HTML we want!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: API方法应该将响应解析为JSON。然后使用`pageTemplate`和`Mustache.render`方法渲染数据。这样就创建了我们所需要的最终HTML！
- en: 'Now for some cool magic. The logic creates a new `Response` object and clones
    it. The clone is saved to the named cache and the new response is returned so
    that it can be rendered for the user:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来点酷炫的魔法。逻辑创建了一个新的`Response`对象并克隆了它。克隆被保存到命名的缓存中，新的响应被返回以便可以用于用户渲染：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This may seem like a lot of work, but it can be done pretty quickly assuming
    that the call to the API is fast. I do recommend pre-caching the page and the
    data template markup ahead of time. The pre-cache is a good place to do this.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一项繁重的工作，但假设API调用很快，这可以很快完成。我确实建议预先缓存页面和数据模板标记。预缓存是一个很好的地方来做这件事。
- en: You might also consider caching these responses in a special template cache
    so that you can apply appropriate invalidation rules to ensure that they do not
    become too stale.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以考虑将这些响应缓存到一个特殊的模板缓存中，这样你就可以应用适当的失效规则，确保它们不会变得过于陈旧。
- en: Using the request method to determine the caching strategy
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求方法确定缓存策略
- en: One of the magical aspects of HTTP is its use of different properties to trigger
    actions. The HTTP method provides a descriptive way to trigger a response. There
    are a variety of possible HTTP methods, with PUT, GET, POST, and DELETE being
    the most common methods.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的一个神奇之处在于它使用不同的属性来触发操作。HTTP方法提供了一种描述性的方式来触发响应。有各种可能的HTTP方法，其中PUT、GET、POST和DELETE是最常见的方法。
- en: Those methods correspond to **create**, **retrieve**, **update**, and **delete**
    (**CRUD**) actions. Cache is a powerful tool to make your application respond
    faster, but not all responses should be cached. The HTTP method can be a primary
    signal to trigger an appropriate caching strategy.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法对应于**创建**、**检索**、**更新**和**删除**（**CRUD**）操作。缓存是一个强大的工具，可以使你的应用程序响应更快，但并非所有响应都应该被缓存。HTTP方法可以是一个触发适当缓存策略的主要信号。
- en: The first two applications, 2048 and Podstr, use only GET requests. The PWA
    ticket application utilizes POST methods, which should not be cached. When a user
    registers, *buys* a ticket, updates their profile, or submits a contact request,
    a POST request is made to the API.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个应用程序，2048和Podstr，仅使用GET请求。PWA票据应用程序使用POST方法，这些方法不应该被缓存。当用户注册、*购买*票据、更新他们的个人资料或提交联系请求时，会向API发送POST请求。
- en: 'The API response is typically used to determine success or some sort of failure
    state. These responses should not be cached. If they were, your request might
    not be sent to the server:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: API响应通常用于确定成功或某种失败状态。这些响应不应该被缓存。如果它们被缓存，你的请求可能不会被发送到服务器：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Matching routes with caching strategies
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配路由与缓存策略
- en: Utilizing different caching strategies involves some way of triggering specific
    strategies for different response types or routes. The more complex your application
    is, the more potential routes and media types you may need to manage.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 利用不同的缓存策略涉及到一种触发特定策略以针对不同响应类型或路由的方式。你的应用程序越复杂，你可能需要管理的潜在路由和媒体类型就越多。
- en: This can be done by defining an array of rules driven by URL routes. I recommend
    using regular expressions to match routes, especially when the route has a common
    base with a large variety options. A good example would be an e-commerce site's
    product details page. This could be a URL to a pre-rendered page or might involve
    a `QueryString` value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过定义一个由URL路由驱动的规则数组来完成。我建议使用正则表达式来匹配路由，尤其是在路由有一个与大量选项的共同基础时。一个很好的例子是一个电子商务网站的产品详情页面。这可能是一个指向预渲染页面的URL，或者可能涉及一个`QueryString`值。
- en: For the PWA tickets application, I am demonstrating how to define a dynamic
    route for event details using a regular expression and another for the QR code
    images.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PWA票据应用程序，我将演示如何使用正则表达式定义一个用于活动详情的动态路由，以及另一个用于二维码图像的路由。
- en: 'A QR code request triggers the cache falling back to the network and then cache
    the response pattern. An event request triggers the service worker rendering strategy.
    This involves an extra property with values to drive the strategy:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: QR码请求触发缓存回退到网络，然后缓存响应模式。事件请求触发服务工作者渲染策略。这涉及一个额外的属性，其中包含驱动策略的值：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Instead of having a complex fetch event handler, you should refactor the logic
    to a separate method. Pass the event object to your handler:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是有一个复杂的fetch事件处理器，你应该将逻辑重构为单独的方法。将事件对象传递给你的处理器：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The magic happens by testing the requested URL against the array of rules.
    This is done by testing the URL against each one of the rules `url` values. This
    testing is done using JavaScript''s regular expression `test()` method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将请求的URL与规则数组中的每个规则的`url`值进行测试，发生魔法般的事情。这是通过使用JavaScript的正则表达式`test()`方法完成的：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This method returns the matching rule object. If no matching rule has been
    defined, you can coalesce the rule value to an empty object:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回匹配的规则对象。如果没有定义匹配规则，你可以将规则值合并到一个空对象中：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After identifying a matching rule, the strategy can be executed using a JavaScript
    switch statement. The `responseManager` has the logic for each strategy. Make
    sure you pass the `request` object and the target `cacheName`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别到匹配规则后，可以使用JavaScript的switch语句执行策略。`responseManager`具有每个策略的逻辑。确保传递`request`对象和目标`cacheName`：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'I like to make the cache falling back to the network caching the response my
    default strategy. By stacking this strategy in the case expression, the code only
    needs to be included once:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将缓存回退到网络缓存的响应作为我的默认策略。通过在case表达式中堆叠此策略，代码只需包含一次：
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This approach relies on configuring routes and their corresponding caching strategy.
    This is similar to the WorkBox approach. I will explore Workbox, a node module
    to help you scaffold complex service workers, in the next chapter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法依赖于配置路由及其相应的缓存策略。这与WorkBox方法类似。我将在下一章中探讨Workbox，这是一个帮助您构建复杂服务工作者的Node模块。
- en: Cache invalidation strategies
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存失效策略
- en: Just like there are caching strategies, there are cache invalidation strategies
    you can employ to keep your cache from getting out of control. The PWA tickets
    application uses a maximum items strategy to control how many responses are cached,
    but there are other strategies you can use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 就像有缓存策略一样，还有你可以采用的缓存失效策略来防止缓存失控。PWA票据应用程序使用最大项策略来控制缓存的响应数量，但你还可以使用其他策略。
- en: Unique hash names and long time-to-live values
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 唯一哈希名称和长生存期值
- en: A popular technique to make updating assets easier with long time to live values
    is using hash values in the file name. This is because a hash which is generated
    based on the file's contents means that the algorithm generates a relatively unique
    value.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希值在文件名中是一种流行的技术，可以简化具有长生存期值的资产的更新。这是因为基于文件内容的哈希值意味着算法生成了一个相对唯一的价值。
- en: The unique name creates a new URL for the asset and assigns a new Cache-Control
    value to the asset. This works well with style sheets, scripts and images, and
    other static resources.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一名称为资产创建一个新的URL，并分配一个新的Cache-Control值给资产。这对于样式表、脚本、图像和其他静态资源都适用。
- en: 'MD5 hash values are the most common way to create these unique values. Node.js
    has a built-in `crypto` module with MD5 hash capabilities:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: MD5哈希值是创建这些唯一值最常见的方式。Node.js有一个内置的`crypto`模块，具有MD5哈希功能：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The data parameter is the contents of the file. For a style sheet or script,
    it is the data is the text in the file. The digest is a unique value you can use
    to name the file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 数据参数是文件的内容。对于样式表或脚本，数据是文件中的文本。摘要是一个可以用来命名文件的唯一值：
- en: '![](img/00101.gif)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.gif)'
- en: This technique works great, but requires a somewhat complicated build process
    to update file names in all the referencing files. I don't encourage this technique
    for a local development environment, but for production, this is a very powerful
    cache busting technique. Just keep in mind that you need to update references
    in all HTML files and potentially in your service worker or other files that may
    reference these unique file names.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术效果很好，但需要相当复杂的构建过程来更新所有引用文件的文件名。我不鼓励在本地开发环境中使用此技术，但对于生产环境，这是一个非常强大的缓存破坏技术。只需记住，您需要更新所有HTML文件中的引用，以及可能引用这些唯一文件名的服务工作者或其他文件。
- en: I think this might be a bit complex for many sites, especially without a formal
    system underlying the site that supports this technique. It's best if the hash
    technique is transparent to the developer and more or less automatic.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这对许多网站来说可能有点复杂，尤其是在没有支持此技术的正式系统的情况下。如果哈希技术对开发者来说是透明的，并且几乎是自动的，那就最好了。
- en: Unfortunately, this is not common today. There are other techniques you can
    utilize that provide more granular control and possibly more control over how
    much data you cache. The following techniques can be used in your service worker
    to manage how long responses are cached.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不常见。您还可以利用其他技术，这些技术提供了更细粒度的控制，并且可能对您缓存的数据量有更多的控制。以下技术可以在您的服务工作者中使用，以管理响应的缓存时间。
- en: Maximum items in a cache
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存中的最大项数
- en: A simpler cache invalidation strategy is limiting the number of items persisted.
    I call this **Maximum Item Invalidation**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的缓存失效策略是限制持久项的数量。我称之为**最大项失效**。
- en: This requires service worker logic to check how many items are saved in a specifically
    named cache. If the cache has saved the maximum number of responses, at least
    one response is removed before adding a new item.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要服务工作者逻辑来检查特定命名的缓存中保存了多少项。如果缓存已保存最大数量的响应，则在添加新项之前至少会移除一个响应。
- en: This strategy requires multiple named caches, which correlate to different types
    of responses. Each named cache can have a different item limit assigned to manage
    the different types of responses. You can also assign a difference cache invalidation
    strategy, which will be discussed shortly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略需要多个命名缓存，这些缓存与不同类型的响应相关联。每个命名缓存可以分配不同的项限制，以管理不同类型的响应。您还可以分配不同的缓存失效策略，这将在稍后讨论。
- en: The ticket application has named caches for events, which are dynamically rendered
    as they are requested. I arbitrarily chose a limit of 20 events to make it easier
    to demonstrate the strategy. It also has a QR code named cache with a limit of
    five responses, again, somewhat arbitrary.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 票务应用程序为事件命名了缓存，这些事件在请求时动态渲染。我随意选择了20个事件的限制，以便更容易展示策略。它还有一个名为缓存二维码的缓存，限制为五个响应，这同样有些随意。
- en: You will need to choose an appropriate value for your application and types
    of responses. Remember, your storage quota is a combination all the different
    storage mediums and varies by device and capacities.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为您的应用程序和响应类型选择一个合适的值。记住，您的存储配额是所有不同存储介质的组合，并且根据设备和容量而变化。
- en: I typically use more liberal values for text responses and smaller values for
    binary files like images. Until you know how your site is used by your customers,
    you may need to adjust this value.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常为文本响应使用更宽松的值，为像图像这样的二进制文件使用较小的值。直到您知道您的客户如何使用您的网站，您可能需要调整此值。
- en: If you managed a site like Amazon.com, you would have access to data that tells
    you how many products a user visits in an average session. So, maybe you make
    sure you can cache that many product pages and associated images. I would probably
    cache most of their watch list products and everything in their shopping cart.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您管理像Amazon.com这样的网站，您将能够访问数据，这些数据告诉您用户在平均会话中访问了多少个产品。因此，您可能确保可以缓存那么多的产品页面和相关图像。我可能会缓存他们大部分的观看列表产品和购物车中的所有内容。
- en: 'Every site and application is different, and within those sites there are unique
    page and data types that need a varied cache limit:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网站和应用都是不同的，在这些网站中，有独特的页面和数据类型需要不同的缓存限制：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Just like there is not a magic number of total items you should cap a named
    cache capacity, not all caches should be limited by a maximum number of items.
    You should also consider limiting based on time.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 就像没有限制总项数的神奇数字一样，不是所有的缓存都应该通过最大项数来限制。您还应该考虑基于时间来限制。
- en: Purging stale responses using time to live
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生存时间清除陈旧的响应
- en: The next cache invalidation strategy is based on how long a response can be
    cached. If you don't have access to the Cache-Control header, it may be challenging
    to determine how long to cache the response.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个缓存失效策略是基于响应可以缓存多长时间。如果您无法访问Cache-Control头，确定响应的缓存时间可能会很具挑战性。
- en: 'The good news is that the Cache-Control header is not the only way to determine
    a response''s cache lifespan. When responses are added to a named cache, a `"date"`
    value is added. You can use the cached date value to apply a timeout rule to the
    cached responses:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Cache-Control 头部并不是确定响应缓存生命周期的唯一方式。当响应被添加到命名缓存中时，会添加一个 `"date"` 值。你可以使用缓存的日期值来为缓存的响应应用超时规则：
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When a cached response becomes stale, you can delete it. The next time the asset
    is requested, the default caching strategy triggers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当缓存的响应变得过时时，你可以删除它。下次请求该资产时，默认的缓存策略会触发。
- en: Executing ResponseManager
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 ResponseManager
- en: 'Instead of writing a complex routine to fetch and cache a response directly
    in the service worker''s `fetch` event handler, you can use the `ResponseManager`.
    Because the caching strategy logic is contained within the module, you can pass
    the request and `cacheName` to have it execute:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在服务工作者的 `fetch` 事件处理器中直接编写一个复杂的程序来获取和缓存响应，你可以使用 `ResponseManager`。因为缓存策略逻辑包含在模块中，你可以传递请求和
    `cacheName` 来执行：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, the response is returned as a result of the promise chain.
    It also executes the cache's `InvalidatationManager.cacheCleanUp` method to make
    sure that the cache does not contain too many items or stale items.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，响应作为承诺链的结果返回。它还执行缓存的 `InvalidatationManager.cacheCleanUp` 方法，以确保缓存中不包含太多项目或过时项目。
- en: The Invalidation Manager
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无效化管理器
- en: 'The Invalidation Manager is a special module that handles implementing the
    maximum items and time to live invalidation strategies. The script is imported
    to the service worker using the `importScripts` method:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 无效化管理器是一个特殊的模块，用于处理实现最大项目和生存时间无效化策略。脚本使用 `importScripts` 方法导入到服务工作者中：
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This module has a method called `cacheCleanup`, which loops over the set of
    invalidation rules that are supplied in the constructor, as shown earlier. As
    it loops through the rules, it executes each strategy against a named cache. The
    invalidation rules are defined when the class is instantiated by passing an array
    of rules.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块有一个名为 `cacheCleanup` 的方法，它遍历在构造函数中提供的无效化规则集，如前所述。在遍历规则时，它针对命名缓存执行每个策略。无效化规则是在类实例化时通过传递规则数组定义的。
- en: The class can process two invalidation strategies, which are `maxItems` and
    `ttl` (time to live). Each item in the rules array is an object defining the named
    cache, the strategy to apply to the cache, and the options for the strategy.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 该类可以处理两种无效化策略，即 `maxItems` 和 `ttl`（生存时间）。规则数组中的每个项目都是一个对象，定义了命名缓存、应用于缓存的策略和策略的选项。
- en: The `ttl` `strategyOptions` is the maximum time frame a cached item can remain
    cached. In the preceding example, the `preCached` items can remain for a week
    before they will be purged. Once they are purged, a network request is made, which
    updates the asset.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttl` 的 `strategyOptions` 是缓存项目可以保持缓存的最大时间框架。在前面的例子中，`preCached` 项目可以在一周后才会被清除。一旦被清除，就会发起网络请求，更新资产。'
- en: The `maxItems` `strategyOptions` has a `max` property, which defines the maximum
    number of cached items a named cache can persist. In this example, I chose an
    arbitrarily low number of 10 items to help demonstrate the principle.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxItems` 的 `strategyOptions` 有一个 `max` 属性，它定义了命名缓存可以持久存储的最大缓存项目数。在这个例子中，我选择了一个任意低的数字
    10 项来帮助说明原理。'
- en: 'The `strategyOptions` property is an object, even though right now there are
    only single properties for each strategy. By using an object, it allows additional
    properties to be added later and for potential future strategies to have different
    property options:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`strategyOptions` 属性是一个对象，尽管现在每个策略只有一个属性。通过使用对象，它允许以后添加更多属性，并为潜在的未来策略提供不同的属性选项：'
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `cacheCleanUp` method can be invoked at any time. It is always executed
    when a new `InvalidationManger` is created, or when your service worker first
    wakes up.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheCleanUp` 方法可以在任何时候调用。它总是在创建新的 `InvalidationManger` 或你的服务工作者首次唤醒时执行。'
- en: This may not be good enough for your application. You could periodically execute
    this method based on a timer or after items are cached.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不足以满足你的应用程序。你可以根据计时器或项目缓存后定期执行此方法。
- en: maxItems strategy
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`maxItems` 策略'
- en: The `maxItems` strategy limits how many items can be stored in a named cache.
    It works by opening the named cache, and then retrieving an array of requests
    using the keys method.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxItems` 策略限制了可以存储在命名缓存中的项目数量。它通过打开命名缓存，然后使用键方法检索请求数组来实现。'
- en: The routine then compares the number of stored items (`keys.length`) to the
    maximum number of items allowed in this cache. If there are more items than the
    quota, the number of items exceeding the quota is calculated.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 程序随后将存储的项目数量（`keys.length`）与在此缓存中允许的最大项目数进行比较。如果项目数量超过配额，则计算超出配额的项目数量。
- en: 'A `for` loop is then executed to delete the first item from the cache and repeats
    until the number of items to purge have been deleted:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行一个`for`循环来从缓存中删除第一个项目，并重复此操作，直到删除了要清除的项目数量：
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You may be wondering why you could not use the Array `pop` or `slice` methods
    to remove the cache items. This is because caches do not provide an array interface,
    and thus there are no native array methods.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么不能使用数组的`pop`或`slice`方法来删除缓存项。这是因为缓存不提供数组接口，因此没有原生数组方法。
- en: Instead, you must create a loop or custom routine to individually delete cached
    items.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您必须创建一个循环或自定义程序来逐个删除缓存项。
- en: The time-to-live invalidation strategy
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存活时间失效策略
- en: Like the `maxItems` strategy, the `updateStaleEntries` strategy opens a reference
    to the named cache and gets a list of the cached requests. This time, individual
    requests must be retrieved from the cache.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与`maxItems`策略类似，`updateStaleEntries`策略打开对命名缓存的引用，并获取缓存请求的列表。这次，必须从缓存中检索单个请求。
- en: 'This requires calling the cache''s match method by passing a request object
    (key). This will return the stored response with a `date` header. This is added
    when the item is added to the cache and can be used to determine if the response
    is stale:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要通过传递一个请求对象（键）来调用缓存的匹配方法。这将返回带有`date`头的存储响应。这是在项目添加到缓存时添加的，可以用来确定响应是否已过时：
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After retrieving the cached date, the `DateManager` can be used to test if the
    response is stale or past its expiration time. If the item has expired, it is
    deleted from the cache.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索到缓存日期后，可以使用`DateManager`来测试响应是否已过时或已过期。如果项目已过期，则从缓存中删除。
- en: Using a real-time asset manifest
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实时资产清单
- en: 'A more complex technique I have used to manage service worker caches is the
    manifest file. This technique involves maintaining a file with a JSON object with
    caching rules:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我用来管理服务工作者缓存的一个更复杂的技术是清单文件。这项技术涉及维护一个包含缓存规则的JSON对象的文件：
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: To leverage this technique, you would process the dynamic requests by testing
    their URL against the supplied routes. This can be done using a regular expression.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这项技术，您需要通过将动态请求的URL与提供的路由进行测试来处理这些请求。这可以通过正则表达式来完成。
- en: 'This process is very similar to the way the routes and caching strategies were
    defined and triggered earlier. The request URL is tested against a regular expression
    to identify the caching strategy to use:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与之前定义和触发路由和缓存策略的方式非常相似。请求URL会与正则表达式进行测试，以确定要使用的缓存策略：
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The manifest file is dynamically loaded when the service worker is first instantiated.
    The way I manage when the manifest is updated is by persisting a series of values
    in `indexedDB`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务工作者首次实例化时，清单文件会动态加载。我管理清单更新的方式是通过在`indexedDB`中持久化一系列值：
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The reason I chose to control the manifest file's time to live manually is to
    avoid potential issues with the browser cache. It is important that you set the
    manifest's cache headers to not allow the resource to be cached by the browser
    or proxy servers.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择手动控制清单文件的存活时间是为了避免与浏览器缓存相关的潜在问题。您必须设置清单的缓存头，不允许浏览器或代理服务器缓存资源。
- en: I set the default time to live to 24 hours, just like the built-in service worker's
    time to live. This keeps the service worker from loading the manifest too often,
    but not so long that it could get out of sync from the server.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我将默认的存活时间设置为24小时，就像内置的服务工作者存活时间一样。这可以防止服务工作者频繁加载清单，但又不至于太长，以至于可能与服务端不同步。
- en: The ticket app does not use this technique, but I did include an example manifest
    file and some of the additional support modules you might need. I reserve this
    technique for more complex applications, and it does require some investment to
    maintain. Specifically, you would need a utility to keep the manifest file updated
    that I feel is outside the scope of this book.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 票务应用不使用这项技术，但我确实包含了一个示例清单文件和一些可能需要的附加支持模块。我将这项技术保留用于更复杂的应用，并且它确实需要一些维护工作。具体来说，您需要一个工具来保持清单文件更新，我认为这超出了本书的范围。
- en: How much should you cache?
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应该缓存多少？
- en: I mentioned earlier that you need to determine how your application's data should
    be cached. The type of data and how it will be used should be used as guidelines
    as to how it is managed in your service worker.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，你需要确定应用程序的数据应该如何缓存。数据类型及其使用方式应作为指导方针，以了解如何在服务工作者中管理。
- en: I want you to also consider your user. Not everyone has access to an unlimited
    high-speed connection or a large disk. Many smartphones still come with just 8
    GB of storage, which after the operating system and all the photos and videos
    consumers record, there is not much room left.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我还希望你考虑你的用户。并不是每个人都能访问到无限的高速连接或大硬盘。许多智能手机仍然只配备了8 GB的存储空间，在操作系统和所有消费者记录的照片和视频之后，几乎没有剩余空间。
- en: Just because you could cache your entire application, including images and data,
    does not mean you should. Nicholas Hoizey ([https://nicolas-hoizey.com/2017/01/how-much-data-should-my-service-worker-put-upfront-in-the-offline-cache.html](https://nicolas-hoizey.com/2017/01/how-much-data-should-my-service-worker-put-upfront-in-the-offline-cache.html))
    demonstrates that that tactic could have a negative impact on your application.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 只因为你能够缓存整个应用程序，包括图片和数据，并不意味着你应该这样做。尼古拉斯·霍伊兹（[https://nicolas-hoizey.com/2017/01/how-much-data-should-my-service-worker-put-upfront-in-the-offline-cache.html](https://nicolas-hoizey.com/2017/01/how-much-data-should-my-service-worker-put-upfront-in-the-offline-cache.html)）展示了这种策略可能会对你的应用程序产生负面影响。
- en: 'You might want to consider adding an experience where the user can configure
    your application to control how resources are persisted. Just like we saw with
    push notification management, you might want to add the ability for the user to
    determine how many events or tickets (in the example application) are cached and
    how long ticket QR codes are available:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要考虑添加一个用户可以配置应用程序以控制资源持久化的体验。就像我们在推送通知管理中看到的那样，你可能希望添加用户确定缓存多少事件或票据（在示例应用程序中）以及票据二维码可用的时长：
- en: '![](img/00102.jpeg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.jpeg)'
- en: You can still use the helper modules covered in this chapter. The caching and
    invalidation strategies wont change, just the settings they use to execute the
    actions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以使用本章中涵盖的辅助模块。缓存和失效策略不会改变，只是它们执行操作时使用的设置。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This has been a very long chapter with some advanced concepts being covered.
    You learned how to trigger different caching strategies based on the request URL,
    modularizing the service worker logic, and employing cache invalidation strategies.
    Plus, you got to play with a new progressive web app!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常长的章节，涉及了一些高级概念。你学习了如何根据请求URL触发不同的缓存策略，模块化服务工作者逻辑，并采用缓存失效策略。此外，你还可以玩一个新的渐进式Web应用程序！
- en: There was a lot of valuable information and source code covered in this chapter,
    but these examples should only serve as a base reference for your applications.
    Not only should you be a good steward of the storage your application is allocated,
    but you should be mindful of your users' data plans.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的有用信息和源代码，但这些示例仅应作为你应用程序的基础参考。你不仅应该成为分配给你的应用程序存储的良好管理者，还应该关注用户的数据计划。
- en: In the next chapter, we'll continue to review how to use service workers and
    caching to make applications perform better. You will also see how to use available
    tools to evaluate and diagnose performance issues so that you can make a better
    application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨如何使用服务工作者和缓存来提高应用程序的性能。你还将看到如何使用可用的工具来评估和诊断性能问题，以便你可以制作出更好的应用程序。
