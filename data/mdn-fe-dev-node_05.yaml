- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Enhancing Code Quality with Linters and Formatters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Linters 和格式化工具提升代码质量
- en: Up to this chapter, we’ve dealt mostly with constructs and code that has been
    in the hot path – that is, directly necessary to actually do something. However,
    in most projects, there are many parts that are not directly useful or visible.
    Quite often, these parts play a crucial role in keeping projects at a certain
    quality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章为止，我们主要处理的是在热路径上的结构和代码——也就是说，直接必要的，以实际做某事。然而，在大多数项目中，有许多部分不是直接有用或可见的。这些部分往往在保持项目一定质量方面起着至关重要的作用。
- en: One example in the field of software project quality enhancers is the tooling
    that is used to ensure certain coding standards are being followed. Those tools
    can appear in many categories – the most prominent categories being **linters**
    and **formatters**. In general, these tools can be categorized as auxiliary tooling.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目质量增强领域的例子之一是用于确保遵循某些编码标准的工具。这些工具可以出现在许多类别中——最突出的类别是 **linters** 和 **formatters**。通常，这些工具可以归类为辅助工具。
- en: In this chapter, we’ll learn what types of auxiliary tooling exist and why we’d
    potentially want to use some extra tooling to enhance our project’s code quality.
    We’ll introduce the most important auxiliary tools such as **ESLint**, **Stylelint**,
    and **Prettier**. We will also have a look at how these tools are integrated or
    used with standard text editors such as VS Code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习存在哪些类型的辅助工具，以及我们为什么可能想要使用一些额外的工具来提升我们项目的代码质量。我们将介绍最重要的辅助工具，如 **ESLint**、**Stylelint**
    和 **Prettier**。我们还将探讨这些工具如何与标准文本编辑器，如 VS Code，集成或使用。
- en: With the auxiliary tools presented in this chapter, you’ll be able to have an
    outstanding positive impact on any Node.js-based frontend project that you’ll
    contribute to.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章介绍的辅助工具，你将能够对任何你将贡献的基于 Node.js 的前端项目产生卓越的积极影响。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Understanding auxiliary tooling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解辅助工具
- en: Using ESLint and alternatives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ESLint 和替代方案
- en: Introducing Stylelint
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Stylelint
- en: Setting up Prettier and EditorConfig
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Prettier 和 EditorConfig
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter05](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可在 [https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter05](https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter05)
    找到。
- en: The CiA videos for this chapter can be accessed at [https://bit.ly/3fLWnyP](https://bit.ly/3fLWnyP).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的 CiA 视频可在 [https://bit.ly/3fLWnyP](https://bit.ly/3fLWnyP) 访问。
- en: Understanding auxiliary tooling
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解辅助工具
- en: When most people think about software, they’ll have applications such as Microsoft
    Word, games such as Minecraft, or web applications such as Facebook in mind. Thanks
    to popular media, the widespread opinion is that these applications are written
    by individual geniuses that hack some ones and zeroes into an obscure interface.
    The reality could not be more far off.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当大多数人想到软件时，他们可能会想到微软 Word 这样的应用程序、Minecraft 这样的游戏，或者 Facebook 这样的网络应用程序。多亏了流行媒体，普遍的观点是这些应用程序是由个人天才编写的，他们将这些零和一黑客进一个晦涩的界面。现实情况可能完全相反。
- en: As you know, to create any kind of software, lots of libraries, tooling, and
    – in many cases – large teams are necessary. However, what most people underestimate
    is the effort to just keep the ball rolling – that is, to still be able to add
    new features to the existing software. There are several issues that contribute
    to this feature slowdown.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，要创建任何类型的软件，需要大量的库、工具——在许多情况下——以及大型团队。然而，大多数人低估了仅仅保持项目进展的努力——也就是说，仍然能够向现有软件添加新功能。有几个问题导致了这种功能放缓。
- en: On the one hand, the complexity within software always rises. This is whether
    we want it or not – with every new feature, a project becomes more challenging.
    In addition, larger software tends to be written by more developers – and every
    developer has a slightly different preference and style. This quickly becomes
    a mess for new developers or even those with experience in the project but who
    are working in areas that they did not touch beforehand.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，软件内部的复杂性总是会增加。无论我们是否愿意，随着每个新功能的加入，项目都会变得更加具有挑战性。此外，较大的软件往往由更多的开发者编写——每个开发者都有略微不同的偏好和风格。这很快就会让新开发者甚至那些在项目中拥有经验但之前未曾接触过这些领域的开发者陷入混乱。
- en: One way to tame the rise of complexity is the introduction of processes. For
    instance, the process of conducting pull requests with reviews is already presented
    to spread knowledge about new features, detect issues, and discuss findings. At
    the end of a good pull request review, the code should be in a state where the
    new additions fit well into the whole project, both functionally and technically.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一种控制复杂性上升的方法是引入流程。例如，进行带有审查的拉取请求的过程已经提出，以传播关于新功能的知识，检测问题，并讨论发现。在良好的拉取请求审查结束时，代码应该处于新添加的功能在功能和技术上都能很好地融入整个项目状态。
- en: 'Today, everything is about automation. Therefore, while having manual processes
    such as a code review might be good and necessary, we usually prefer automated
    processes. This is exactly where all the auxiliary tooling comes in. Take, for
    instance, a potential discussion about code formatting within a code review. Let’s
    say a part of the code looks as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切关于自动化。因此，尽管手动流程如代码审查可能很好且必要，我们通常更喜欢自动化流程。这正是所有辅助工具发挥作用的地方。以代码审查中关于代码格式的潜在讨论为例。假设代码的一部分如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code itself is fine – the `div` function should perform a division, and
    of course, it does that. Nevertheless, the formatting is way off. A reviewer might
    complain that the parameters of the function should be properly formatted using
    a space after a comma. Another reviewer might not like the return statement, which
    would break without the use of parenthesis. A third review could remark on the
    missing optional semicolon and that the indentation is just a single space.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身是好的——`div`函数应该执行除法，当然，它确实做到了。然而，格式却大相径庭。一个审阅者可能会抱怨函数的参数应该使用逗号后的空格进行适当的格式化。另一个审阅者可能不喜欢没有使用括号的返回语句。第三个审阅者可能会指出缺少可选的分号以及缩进仅有一个空格。
- en: 'Now, after everything is set and done, a new version of the code would be pushed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切设置和完成后，代码的新版本将被推送：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, the second reviewer might bring up a discussion of why the semicolon
    was introduced – it is only optional in this case and the code works without it.
    At this point, a new reviewer joins and questions the introduction of the function
    at all: “Why is a function for division needed in the first place? There is nothing
    new or interesting here.”'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第二个审阅者可能会提出关于分号引入的讨论——在这种情况下，分号是可选的，代码没有它也能工作。此时，一个新的审阅者加入并质疑引入函数的必要性：“为什么需要除法函数？这里没有什么新奇的或有趣的地方。”
- en: Consequently, you’ll see that much time was wasted on all sides. Instead of
    discussing the business need of the function in the first place, time was – and
    is still – spent discussing formalities that should be aligned and corrected automatically.
    This is where linters and formatters come into play. They can take the task of
    making code beautiful to read by following the standard that was set for a project.
    Hence, a team would need to agree only once on the tabs versus spaces debate or
    the use of semicolons. The tooling takes care of actually applying the decision.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你会看到在各方面都浪费了大量的时间。与其首先讨论函数的业务需求，不如把时间花在讨论应该自动对齐和纠正的正式程序上。这正是linters和formatters发挥作用的地方。它们可以通过遵循为项目设定的标准来完成任务，使代码易于阅读。因此，团队只需要就制表符与空格的争论或分号的使用达成一致。工具负责实际应用决策。
- en: Semicolons in JavaScript
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的分号
- en: JavaScript is quite loose regarding syntax. While other languages have rules
    and constructs that always need to be followed, JavaScript has many optional constructs
    in its specification. For instance, semicolons are – up to some degree – optional.
    There are a few cases where you’d need a semicolon to avoid nasty surprises such
    as in the head of `for`-loops, but for the most part, you could just drop them
    and your code would still work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对语法的限制相对宽松。虽然其他语言有必须遵循的规则和结构，但 JavaScript 在其规范中包含了许多可选的结构。例如，分号在某种程度上是可选的。在某些情况下，你需要分号来避免诸如在
    `for` 循环头部出现的令人不快的意外，但大多数情况下，你可以直接去掉它们，代码仍然可以正常工作。
- en: There are many areas in which auxiliary tooling makes sense. Sure, the alignment
    of code itself is nice, but even things such as commit messages when working with
    a project’s version control system or checking whether documentation was supplied
    can be useful.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多领域，辅助工具是有意义的。当然，代码本身的排列是好的，但即使是像在使用项目版本控制系统时的提交信息或检查是否提供了文档这样的事情也可以是有用的。
- en: While checking the actual syntax – for example, the use of whitespace and newlines,
    is a common use case – an even more important one is to check the actual code
    constructs for some patterns. The validation of the used patterns is often referred
    to as **linting** – with a category of tools known as **linters**. A tool that
    excels in that space is **ESLint**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查实际语法——例如，空格和换行符的使用，这是一个常见用例——一个更加重要的用例是检查实际的代码结构以查找某些模式。对所使用模式的验证通常被称为 **linting**——一类被称为
    **linters** 的工具。在这个领域表现出色的工具是 **ESLint**。
- en: Using ESLint and alternatives
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ESLint 和替代方案
- en: ESLint statically analyzes code to identify common patterns and find problems.
    It can be used as a library from your Node.js applications, as a tool from your
    Node.js scripts, in your CI/CD pipelines, or implicitly within your code editor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 静态分析代码以识别常见模式并查找问题。它可以作为 Node.js 应用程序中的库、Node.js 脚本中的工具、CI/CD 管道中的工具，或者在代码编辑器中隐式使用。
- en: 'The general recommendation is to install ESLint locally in your Node.js project.
    A local installation can be done with your favorite package manager, such as npm:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议在 Node.js 项目中本地安装 ESLint。可以使用您喜欢的包管理器，如 npm 来进行本地安装：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In most cases, you’ll want to specify the `--save-dev` flag. This will add a
    dependency to the development dependencies, which are not installed in consuming
    applications and will be skipped for production installations. Indeed, development
    dependencies are only interesting during the project’s actual development.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您会想要指定 `--save-dev` 标志。这将添加一个开发依赖项，这些依赖项不会在消费应用程序中安装，并且在生产安装中将被跳过。实际上，开发依赖项只在项目的实际开发期间才有意义。
- en: 'Alternatively, you can also make ESLint a global tool. This way, you can run
    ESLint even in projects and code files that do not already include it. To install
    ESLint globally, you need to run the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以将 ESLint 设置为全局工具。这样，您就可以在尚未包含 ESLint 的项目和代码文件中运行 ESLint。要全局安装 ESLint，需要运行以下命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Potentially, you’ll need elevated shell access (e.g., using `sudo`) to install
    ESLint globally. The general recommendation is to avoid using elevated shell access,
    which implies avoiding global installations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要提升 shell 访问权限（例如，使用 `sudo`）来全局安装 ESLint。一般建议避免使用提升的 shell 访问权限，这意味着避免全局安装。
- en: Global versus local installations
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 全局安装与本地安装
- en: npm is not only a great way to distribute packages but also to distribute tools.
    The standard installation of npm creates a special directory for such tools. This
    dedicated directory is added to your system’s `PATH` variable, allowing direct
    execution of anything that is inside the directory. By using a global installation,
    a tool such as ESLint is added to the dedicated directory, giving us the option
    of running it just by typing `eslint` in the command line.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: npm 不仅是一种很好的分发包的方式，也是一种分发工具的方式。npm 的标准安装创建了一个专门用于此类工具的目录。这个专用目录被添加到您的系统 `PATH`
    变量中，允许直接执行目录中的任何内容。通过使用全局安装，像 ESLint 这样的工具被添加到专用目录中，使我们能够通过在命令行中键入 `eslint` 来运行它。
- en: On the other hand, tools in a local installation are not placed in the dedicated
    directory. Instead, they are available in the `node_modules/.bin` folder. To avoid
    running lengthy commands such as `./node_modules/.bin/eslint`, we can use the
    `npx` utility.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，本地安装的工具不会放在专门的目录中。相反，它们在 `node_modules/.bin` 文件夹中可用。为了避免运行像 `./node_modules/.bin/eslint`
    这样冗长的命令，我们可以使用 `npx` 工具。
- en: '`npx` is a task runner installed together with Node.js and npm. It intelligently
    checks whether the provided script is installed locally or globally. If nothing
    is found, then a package is temporarily downloaded from the npm registry, executing
    the script from the temporary installation. Consequently, running `npx eslint`
    in a project where ESLint is installed will start the linting.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`npx` 是与 Node.js 和 npm 一起安装的任务运行器。它会智能地检查提供的脚本是否已本地或全局安装。如果没有找到任何内容，则从 npm
    注册表临时下载一个包，从临时安装中执行脚本。因此，在已安装 ESLint 的项目中运行 `npx eslint` 将启动代码检查。'
- en: 'Let’s initialize a new project (`npm init -y`) and install `eslint` as a development
    dependency. Now that you’ve installed ESLint, you can actually use it on some
    sample code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们初始化一个新的项目（`npm init -y`）并将 `eslint` 作为开发依赖项安装。现在你已经安装了 ESLint，你可以在一些示例代码上实际使用它：
- en: 'For this, we can leverage the sample from the previous section:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这一点，我们可以利用上一节中的示例：
- en: index.js
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before we can run `eslint`, we also need to create a configuration. Having a
    configuration file is something that almost all utilities for frontend development
    will require. In the case of ESLint, the configuration file should be named `.eslintrc`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们运行 `eslint` 之前，我们还需要创建一个配置。对于前端开发的大多数工具来说，拥有一个配置文件是必需的。在 ESLint 的情况下，配置文件应该命名为
    `.eslintrc`。
- en: 'Place the following `.eslintrc` file in the same directory as `package.json`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 `.eslintrc` 文件放置在与 `package.json` 相同的目录中：
- en: .eslintrc
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: .eslintrc
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are different ways to write a configuration way for ESLint. In the preceding
    snippet, we used the JSON format, which should feel quite familiar for anyone
    with a JavaScript or web development background. Another common approach is to
    use the YAML format.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为 ESLint 编写配置方式有多种。在前面的代码片段中，我们使用了 JSON 格式，这对于有 JavaScript 或 Web 开发背景的人来说应该非常熟悉。另一种常见的方法是使用
    YAML 格式。
- en: In the preceding configuration, we instruct ESLint to stop looking for parent
    configurations. As this is indeed the configuration for our project, we can stop
    at this level. Additionally, we configure ESLint’s parser to actually parse ESM
    following a very recent specification. Finally, we configure the rule for semicolons
    to throw an error if semicolons are missing.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们指示 ESLint 停止查找父配置。因为这个确实是我们的项目配置，我们可以在这里停止。此外，我们配置 ESLint 的解析器实际按照非常新的规范解析
    ESM。最后，我们配置了分号规则，如果缺少分号则抛出错误。
- en: 'The result of applying this ruleset can be seen in the following code snippet.
    Running `npx eslint` starting on all JavaScript files from the current directory
    (`.`) looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此规则集的结果可以在以下代码片段中看到。从当前目录（`.`）开始运行 `npx eslint` 的样子如下：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As expected, the linter complains. However, this kind of complaint is certainly
    in the positive region. Rather constructively, ESLint also tells us about the
    option to automatically fix the issue.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，检查器会抱怨。然而，这种抱怨肯定是在积极区域。相当建设性地，ESLint 还告诉我们有关自动修复问题的选项。
- en: 'Let’s run the same command with the suggested `--``fix` option:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用建议的 `--fix` 选项运行相同的命令：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'No output here. Indeed, this is a good thing. The missing semicolon has been
    inserted:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有输出。实际上，这是好事。缺失的分号已经被插入：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How about other rules? What if we want to force code to use anonymous arrow
    functions instead of the named functions? While many things can be covered by
    the rules coming directly with ESLint, the system can be extended with rules from
    third-party packages. Third-party packages that bring in additional functionality
    for ESLint are called ESLint plugins.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他规则怎么样？如果我们想强制代码使用匿名箭头函数而不是命名函数呢？虽然 ESLint 直接提供的规则可以覆盖许多内容，但系统可以通过第三方包的规则进行扩展。为
    ESLint 带来额外功能的第三方包被称为 ESLint 插件。
- en: 'To bring in a rule to enforce the usage of anonymous arrow functions, we can
    use an ESLint plugin. The package for this is called `eslint-plugin-prefer-arrow`.
    Let’s install it first:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要引入一个规则来强制使用匿名箭头函数，我们可以使用 ESLint 插件。这个插件的包名为 `eslint-plugin-prefer-arrow`。让我们首先安装它：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can change the configuration. We need to include a reference to the
    plugin and also specify the rule:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以更改配置。我们需要包含对插件的引用，并指定规则：
- en: .eslintrc
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: .eslintrc
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this configuration, we can now test whether the function declaration is
    indeed qualified as an error:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这种配置，我们现在可以测试函数声明是否确实被认定为错误：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In contrast to the previous error, we are not seeing any hint of an automatic
    fix here. In such cases, the author of the code has to do all the changes to please
    the linter manually.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的错误相比，我们在这里没有看到任何自动修复的迹象。在这种情况下，代码的作者必须手动进行所有更改以满足linting工具的要求。
- en: There are plenty of alternatives to ESLint. In the past, the TypeScript-specific
    variant TSLint was quite popular. However, a couple of years ago, the team behind
    TSLint decided to actually merge their rules into ESLint – also making ESLint
    the de facto standard for linting TypeScript files. Today, the most popular alternatives
    are **Rome**, **quick-lint-js**, and **JSHint**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint有很多替代方案。在过去，TypeScript特定的变体TSLint相当受欢迎。然而，几年前，TSLint背后的团队决定将他们的规则合并到ESLint中——这也使得ESLint成为了linting
    TypeScript文件的既定标准。如今，最受欢迎的替代方案是**Rome**、**quick-lint-js**和**JSHint**。
- en: Rome is an all-in-one tooling that combines several utilities into one cohesive
    application. While Rome is not written in JavaScript using Node.js, it still integrates
    nicely into the standard frontend tooling. One of the aspects covered in Rome
    is linting. At the time of writing, Rome is, unfortunately, not yet feature-complete
    and still in an early alpha version, but its performance and convenience benefits
    are a clear advantage.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Rome是一个将多个实用工具结合成一个统一应用程序的全能工具。虽然Rome不是用JavaScript和Node.js编写的，但它仍然很好地集成到标准前端工具中。Rome涵盖的一个方面是linting。在撰写本文时，遗憾的是，Rome尚未功能完善，仍在早期alpha版本中，但它的性能和便利性优势是明显的。
- en: The **quick-lint-js** package is a small tool that does not require configuration
    and is tuned to outperform ESLint in execution time. The downside of this is that
    quick-lint-js has fewer features and is less flexible in its design.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**quick-lint-js**包是一个小巧的工具，无需配置，并且针对执行时间优于ESLint进行了优化。缺点是quick-lint-js功能较少，设计上不太灵活。'
- en: Lastly, one of the golden classics in the linting field is **JSHint**. Originally,
    it was created as a more configurable version of **JSLint**, which can be considered
    the first popular linter for JavaScript. One of the issues with JSHint is that
    it does not support the latest and greatest features of the **ECMAScript** standard.
    If you are looking for ES2020 support, then JSHint can be discarded. Likewise,
    JSHint is a bit more restrictive on extensibility. In JSHint, you cannot define
    custom rules. However, if something is missing in JSHint, you’ll not be able to
    just add it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在linting领域的一个黄金经典是**JSHint**。最初，它被创建为一个更可配置的**JSLint**版本，可以被认为是JavaScript的第一个流行linter。JSHint的一个问题是它不支持**ECMAScript**标准的最新和最伟大的功能。如果你正在寻找ES2020支持，那么JSHint可以被舍弃。同样，JSHint在可扩展性方面也更为严格。在JSHint中，你不能定义自定义规则。然而，如果你在JSHint中缺少某些功能，你将无法简单地添加它们。
- en: The biggest advantage of ESLint, however, is that it already has the ecosystem
    that others are potentially missing. One area where ESLint shines is editor support.
    *Figure 5**.1* shows the entry of the official ESLint extension on the VS Code
    Marketplace.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ESLint最大的优势是它已经拥有了其他人可能缺少的生态系统。ESLint在编辑器支持方面表现出色。*图5.1*显示了VS Code Marketplace上官方ESLint扩展的入口。
- en: '![Figure 5.1 – Entry of the official ESLint extension on the VS Code Marketplace
    ](img/Figure_5.1_B18989.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – VS Code Marketplace上官方ESLint扩展的入口](img/Figure_5.1_B18989.jpg)'
- en: Figure 5.1 – Entry of the official ESLint extension on the VS Code Marketplace
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – VS Code Marketplace上官方ESLint扩展的入口
- en: Similar plugins exist for other editors. Some editors such as Brackets even
    come with an ESLint integration preinstalled.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他编辑器也存在类似的插件。一些编辑器，如Brackets，甚至预装了ESLint集成。
- en: The editor integration will indicate ESLint issues directly in the code. This
    is really helpful during development. Instead of waiting for code quality inspection
    results after the code has been written, you can directly see issues when they
    appear. This way, you’ll be able to fix them immediately, instead of being required
    to come back to previously closed files later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器集成会在代码中直接显示ESLint问题。这在开发过程中非常有帮助。你不必等待代码质量检查结果，而是在问题出现时就能直接看到它们。这样，你就可以立即修复它们，而不是需要稍后返回之前已关闭的文件。
- en: In almost all editor integrations, you’ll not only get some squiggles or similar
    visual hints when ESLint finds an issue but also the possibility to run a quick
    fix. Running a quick fix will trigger ESLint’s repair functionality. In the preceding
    command line usage, we triggered this behavior by using the `--``fix` flag.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有的编辑器集成中，当 ESLint 发现问题时，你不仅会得到一些波浪线或类似的视觉提示，还可以运行快速修复。运行快速修复将触发 ESLint 的修复功能。在前面的命令行使用中，我们通过使用
    `--fix` 标志触发了这种行为。
- en: '*Figure 5**.2* shows how VS Code reports the issues found by ESLint on the
    given example file, `index.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.2* 展示了 VS Code 如何报告在给定示例文件 `index.js` 中由 ESLint 发现的问题：'
- en: '![Figure 5.2 – ESLint integration reporting issues in VS Code ](img/Figure_5.2_B18989.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – ESLint 在 VS Code 中集成报告问题](img/Figure_5.2_B18989.jpg)'
- en: Figure 5.2 – ESLint integration reporting issues in VS Code
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – ESLint 在 VS Code 中集成报告问题
- en: In general, it makes sense to define a sound basis for linting rules. The basis,
    however, should not be too large. Too many rules will ultimately have the opposite
    effect. Instead of empowering a team by finding a common style and avoiding problematic
    patterns, the constraints are too heavy – essentially slowing down or even blocking
    progress on new features. Therefore, the recommendation is to start with a few
    rules and add new ones when certain code issues come up more often in pull request
    reviews. This way, the set of linting rules will evolve with the project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，为代码检查规则定义一个坚实的基础是有意义的。然而，这个基础不应过大。过多的规则最终会产生相反的效果。与其通过寻找共同风格和避免问题模式来增强团队的能力，不如过于严格的约束——这本质上会减慢甚至阻碍新功能的进展。因此，建议从少量规则开始，当某些代码问题在拉取请求审查中频繁出现时再添加新规则。这样，代码检查规则集将随着项目的发展而演变。
- en: While linting JavaScript source files is definitely one of the most important
    tasks, it is by far not the only kind of source file you’ll encounter in modern
    frontend development. Arguably, the second most important type of files are stylesheets
    such as **CSS** or **SCSS**. For those, we can rely on another tool for linting
    called Stylelint.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然检查 JavaScript 源文件无疑是现代前端开发中最重要任务之一，但它绝不是你将遇到的唯一类型的源文件。可以说，第二重要的文件类型是样式表，如
    **CSS** 或 **SCSS**。对于这些，我们可以依赖另一个名为 Stylelint 的代码检查工具。
- en: Introducing Stylelint
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Stylelint
- en: Stylelint is a linter for CSS files and can be extended to also understand CSS
    dialects such as SCSS, **Sass**, **Less**, or **SugarCSS**. It has over 170 built-in
    rules but, much like ESLint, provides support for custom rules.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Stylelint 是一个用于 CSS 文件的代码检查工具，并且可以扩展以理解 CSS 方言，如 SCSS、**Sass**、**Less** 或 **SugarCSS**。它拥有超过
    170 个内置规则，但与 ESLint 类似，也提供了自定义规则的支持。
- en: 'To install Stylelint, we can follow the same steps as with ESLint:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Stylelint 时，我们可以遵循与 ESLint 相同的步骤：
- en: 'Here, it usually makes sense to rely on the standard configuration provided
    by Stylelint. Unlike ESLint, the standard configuration is released in a separate
    package and, therefore, needs to be installed as well. The command to install
    both packages as development dependencies looks like this:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，通常有理由依赖 Stylelint 提供的标准配置。与 ESLint 不同，标准配置以单独的包发布，因此也需要安装。安装这两个包作为开发依赖项的命令如下：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In any case, we still require a configuration file. For the moment, it is sufficient
    to just let `stylelint` know that we want to use the configuration from the `stylelint-config-standard`
    package. Here, we can write another configuration file next to the project’s `package.json`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何情况下，我们仍然需要一个配置文件。目前，只需让 `stylelint` 知道我们想使用 `stylelint-config-standard` 包中的配置即可。在这里，我们可以在项目的
    `package.json` 旁边编写另一个配置文件：
- en: .stylelintrc
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: .stylelintrc
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let’s introduce some problematic CSS files to try out the `stylelint`
    utility:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们引入一些有问题的 CSS 文件来尝试 `stylelint` 工具：
- en: style.css
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: style.css
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding snippet has several issues. On one hand, we’ll overwrite the `padding-left`
    property by using the `padding` shorthand afterward. On the other hand, we’ll
    use an invalid color hex code. Finally, we might want to have a new line between
    different declaration blocks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段存在几个问题。一方面，我们会在之后使用 `padding` 简写属性覆盖 `padding-left` 属性。另一方面，我们会使用一个无效的颜色十六进制代码。最后，我们可能希望在不同的声明块之间有一个新行。
- en: 'We can run the `stylelint` utility with the `npx` task runner – just like how
    we triggered `eslint`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `npx` 任务运行器运行 `stylelint` 工具——就像我们触发 `eslint` 一样：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There is quite a list of issues coming out! Luckily, just like with `eslint`,
    we can use the `--fix` flag to automatically fix as much as possible:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出现的问题列表相当长！幸运的是，就像 `eslint` 一样，我们可以使用 `--fix` 标志自动修复尽可能多的问题：
- en: '[PRE38]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: While the cosmetic issues dealing with spaces and newlines can be tackled automatically
    by Stylelint, the remaining two issues (`3:5` and `6:12`) require a bit more brainpower
    to be fixed. The first issue requires a decision of whether we want to either
    remove the `padding-left` property or move it after the usage of the `padding`
    shorthand. The second issue requires us to actually think about a valid color
    to use. Here, Stylelint cannot possibly know which color we had in mind when writing
    the code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然处理空格和换行符的视觉问题可以通过 Stylelint 自动解决，但剩余的两个问题（`3:5` 和 `6:12`）需要更多的思考才能修复。第一个问题需要我们决定是删除
    `padding-left` 属性还是将其移动到 `padding` 简写使用之后。第二个问题要求我们实际考虑一个有效的颜色来使用。在这里，Stylelint
    不可能知道我们在编写代码时心中所想的颜色。
- en: Stylelint is not only very useful but is also quite unique. In the world of
    CSS linters, there are not many options. Mostly, people tend to rely on their
    tooling – for example, Sass or Less, to already give them some errors and warnings.
    Stylelint goes a bit further. In addition to the rich set of in-built rules and
    its flexibility via plugins, Stylelint also offers a rich ecosystem. As with ESLint,
    many editors have an integration for Stylelint.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Stylelint 不仅非常实用，而且相当独特。在 CSS 代码风格检查的世界里，选择并不多。大多数人倾向于依赖他们的工具——例如 Sass 或 Less，以提前给出一些错误和警告。Stylelint
    则更进一步。除了丰富的内置规则和通过插件提供的灵活性外，Stylelint 还提供了一个丰富的生态系统。就像 ESLint 一样，许多编辑器都集成了 Stylelint。
- en: With all the linting in place, we can now turn to an even softer part of code
    cosmetics – how code is structured visually. A tool to help us here is **Prettier**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有代码风格检查工具配置完成后，我们现在可以转向代码美学的更柔和部分——代码的视觉结构。在这里帮助我们的是 **Prettier** 工具。
- en: Setting up Prettier and EditorConfig
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Prettier 和 EditorConfig
- en: Prettier is a code formatter that works with a lot of different source files.
    Among the supported file types, we have plain JavaScript, Flow, TypeScript, HTML,
    CSS, SASS, Markdown, and many more. Prettier is also integrated into many different
    editors such as Atom, Emacs, Sublime Text, Vim, Visual Studio, or VS Code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier 是一款与众多不同源文件兼容的代码格式化工具。在支持的文件类型中，包括纯 JavaScript、Flow、TypeScript、HTML、CSS、SASS、Markdown
    等多种格式。Prettier 还集成了许多不同的编辑器，例如 Atom、Emacs、Sublime Text、Vim、Visual Studio 或 VS
    Code。
- en: 'Let’s dig into installing and configuring the Prettier formatter:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解安装和配置 Prettier 格式化器：
- en: 'Such as the previous tools, Prettier can be installed locally or globally.
    Adding Prettier to an existing project can be done by installing the `prettier`
    package from the npm registry:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的工具一样，Prettier 可以本地或全局安装。将 Prettier 添加到现有项目可以通过从 npm 注册表安装 `prettier` 包来完成：
- en: '[PRE45]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Prettier can format JavaScript code even without any configuration. To run
    Prettier on an existing code file, you can use the `prettier` utility with `npx`.
    For instance, to apply formatting to your previous code file, you can run:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prettier 可以在不进行任何配置的情况下格式化 JavaScript 代码。要在现有的代码文件上运行 Prettier，您可以使用 `npx` 运行
    `prettier` 工具。例如，要将格式应用于您之前的代码文件，您可以运行：
- en: '[PRE46]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this case, Prettier just printed the result of the formatting in the command
    line. It also added a semicolon to the end of the statement. Let’s configure Prettier
    to *not* add semicolons at the end of statements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Prettier 只在命令行中打印了格式化结果。它还在语句的末尾添加了分号。让我们配置 Prettier 以 **不** 在语句末尾添加分号。
- en: 'To configure Prettier, a `.prettierrc` file should be added to the root of
    the project – right next to `package.json`. The file can be written with JSON.
    An example is shown here:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置 Prettier，应在项目的根目录中添加一个 `.prettierrc` 文件——紧挨着 `package.json`。该文件可以用 JSON
    编写。以下是一个示例：
- en: .prettierrc
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: .prettierrc
- en: '[PRE50]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The provided example sets the indentation to four spaces. It instructs Prettier
    to always use single quotes instead of double quotes for strings when possible.
    Most importantly, we disable the use of semicolons.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的示例将缩进设置为四个空格。它指示 Prettier 在可能的情况下始终使用单引号而不是双引号来表示字符串。最重要的是，我们禁用了分号的使用。
- en: 'With the preceding configuration in place, we can run `prettier` again:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述配置到位后，我们可以再次运行 `prettier`：
- en: '[PRE51]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The effect is striking. Now, four spaces instead of two are being used. The
    semicolon is dropped. The configuration has been successfully applied. However,
    one thing that is still left open is to actually overwrite the existing file.
    After all, getting the formatting code in the command line is nice but not worth
    a lot if we did not really format the original file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果非常明显。现在，使用的是四个空格而不是两个。分号被省略了。配置已成功应用。然而，还有一件事是实际覆盖现有文件。毕竟，在命令行中获取格式化代码很好，但如果我们没有真正格式化原始文件，那么这并没有多少价值。
- en: 'For `prettier` to apply the changes, the `--write` flag needs to be used. The
    command from *step 4* would therefore change to the following:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 `prettier` 应用更改，需要使用 `--write` 标志。因此，*步骤 4* 中的命令将更改为以下内容：
- en: '[PRE55]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The output now prints a summary of all the files that have and have not been
    changed. With the preceding command, only the `index.js` file is formatted; however,
    the `prettier` utility would also accept wild cards such as `*` to indicate placeholders
    matching multiple files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在会打印出所有已更改和未更改的文件的摘要。使用前面的命令，只有 `index.js` 文件被格式化；然而，`prettier` 工具也会接受通配符，如
    `*`，以指示匹配多个文件的占位符。
- en: Globs
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Many Node.js utilities accept a special kind of syntax to match multiple files.
    Very often, this syntax comes directly or is at least inspired by the `glob` package,
    which copied the notation from Unix. The syntax defines so-called globs – that
    is, patterns that allow matching files. In this regular expression-like syntax,
    `*` matches 0 or more characters in a single path segment, while `?` matches exactly
    a single character. Another useful construct is `**`, which can be used to denote
    0 or more directories. A pattern such as `**/*.js` would thus match any `.js`
    file in the current directory and any subdirectory. More details on the `glob`
    package and its syntax can be found at [https://www.npmjs.com/package/glob](https://www.npmjs.com/package/glob).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Node.js 工具接受一种特殊的语法来匹配多个文件。这种语法通常直接来自或至少受到 `glob` 包的启发，该包从 Unix 中复制了符号。这种语法定义了所谓的
    globs——即允许匹配文件的模式。在这种类似于正则表达式的语法中，`*` 匹配单个路径段中的 0 个或多个字符，而 `?` 匹配恰好一个字符。另一个有用的结构是
    `**`，它可以用来表示 0 个或多个目录。例如，`**/*.js` 的模式将匹配当前目录及其子目录中的任何 `.js` 文件。更多关于 `glob` 包及其语法的详细信息可以在
    [https://www.npmjs.com/package/glob](https://www.npmjs.com/package/glob) 找到。
- en: While Prettier is great for many kinds of source files, it surely cannot tackle
    text files in general. Quite often, however, we want to establish general formatting
    rules for anything in our project. This is where **EditorConfig** comes in.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Prettier 对于许多类型的源文件来说很棒，但它肯定无法处理一般的文本文件。然而，我们经常希望为项目中的任何内容建立通用的格式化规则。这就是
    **EditorConfig** 发挥作用的地方。
- en: EditorConfig is a standard to help maintain consistent coding styles for a project.
    It is established by a file named `.editorconfig`. Pretty much every editor supports
    this file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: EditorConfig 是一个标准，用于帮助维护项目的一致编码风格。它由一个名为 `.editorconfig` 的文件建立。几乎每个编辑器都支持这个文件。
- en: 'An `.editorconfig` example looks like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `.editorconfig` 的示例如下：
- en: .editorconfig
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: .editorconfig
- en: '[PRE57]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As with ESLint, we can use nested configuration files – that is, specialize
    the configuration for subdirectories by having another `.editorconfig` file in
    them. The `root = true` configuration tells the editor to stop traversing the
    file system upward for additional configuration files. Otherwise, this file has
    only a single section, `[*]`, matching all text files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ESLint 一样，我们可以使用嵌套配置文件——也就是说，通过在它们中放置另一个 `.editorconfig` 文件来为子目录专门配置。`root
    = true` 配置告诉编辑器停止向上遍历文件系统以查找额外的配置文件。否则，此文件只有一个部分，`[*]`，匹配所有文本文件。
- en: 'The ruleset in the preceding example above would actually tell an editor to
    exclusively use the line feed (`lf`) character to end lines. While this is the
    standard on Unix-based systems, Windows users would usually get two characters
    to end lines: line feed (`lf`) and carriage return (`cr`) – the so-called `lfcr`
    convention. In addition, the ruleset would introduce an empty line at the end
    of each file. By definition, each text file would use two spaces as an indentation
    level.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例中的规则集实际上会告诉编辑器只使用行结束符（`lf`）来结束行。虽然这是基于 Unix 的系统的标准，但 Windows 用户通常会得到两个字符来结束行：行结束符（`lf`）和回车符（`cr`）——所谓的
    `lfcr` 习惯。此外，规则集会在每个文件的末尾引入一个空行。根据定义，每个文本文件都会使用两个空格作为缩进级别。
- en: 'While such a configuration is nice, it can be in direct conflict with the Prettier
    configuration. However, another great thing about Prettier is that it can work
    hand in hand with EditorConfig. Let’s rewire the previous configuration to also
    use EditorConfig:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样的配置很棒，但它可能与Prettier配置直接冲突。然而，Prettier的另一个优点是它可以与EditorConfig协同工作。让我们重新配置之前的配置，使其也使用EditorConfig：
- en: .prettierrc
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`.prettierrc`'
- en: '[PRE58]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Since Prettier rules will always take precedence and overwrite the ones from
    the `.editorconfig` file, it makes sense to remove conflicting rules. Otherwise,
    we will be only left with the JavaScript-specific formatting rules – for example,
    for semicolons and the preferred quote style, in `.prettierrc`. The general text
    formatting rules are now specified via EditorConfig implicitly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Prettier规则始终优先级最高，并覆盖`.editorconfig`文件中的规则，因此删除冲突规则是有意义的。否则，我们只剩下JavaScript特定的格式化规则——例如，在`.prettierrc`中关于分号和首选引号样式——。现在，通用文本格式化规则通过EditorConfig隐式指定。
- en: With all this in mind, let’s recap what we’ve learned in this chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们回顾一下本章所学的内容。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how code quality can be enhanced with the help
    of linters and formatters. You can now use common tools such as EditorConfig,
    Prettier, Stylelint, or ESLint. You are now able to add, configure, and run these
    tools in any project that you like.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何借助linters和formatters来提高代码质量。现在您可以使用诸如EditorConfig、Prettier、Stylelint或ESLint等常用工具。您现在可以在您喜欢的任何项目中添加、配置和运行这些工具。
- en: At this point, you can contribute to pretty much all frontend projects that
    are based on Node.js for their tooling. Also, you can introduce great quality
    enhancers such as Prettier. Once successfully introduced, these tools ensure that
    certain quality gates are always fulfilled. In the case of Prettier, discussions
    about code style are mostly a thing of the past – helping teams all around the
    world to actually focus on the actual problem instead of dealing with code cosmetics.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以为几乎所有基于Node.js的前端项目做出贡献，这些项目在工具方面都基于Node.js。此外，您还可以引入如Prettier这样的高质量增强器。一旦成功引入，这些工具将确保某些质量关卡始终得到满足。在Prettier的情况下，关于代码风格的讨论大多已成为过去式——帮助全球各地的团队真正专注于实际问题，而不是处理代码的表面问题。
- en: A downside to keep in mind is that most of these tools have some assumptions
    about your code. So, if your code uses, for instance, one of the flavors we discussed
    in [*Chapter 4*](B18989_04.xhtml#_idTextAnchor042), *Using Different Flavors of
    JavaScript*, then you’ll most likely need to teach some of your tools about this
    flavor, too. Quite often, this only requires the installation of a plugin, but
    in severe cases, you are left with the decision to either abandon the tool or
    stop using the flavor for your project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个缺点是，这些工具中的大多数都对您的代码有一些假设。因此，如果您的代码使用了，例如，我们在[*第4章*](B18989_04.xhtml#_idTextAnchor042)“使用JavaScript的不同版本”中讨论的版本之一，那么您很可能需要教您的工具关于这个版本的知识。通常情况下，这只需要安装一个插件，但在严重的情况下，您将面临放弃工具或停止在项目中使用该版本的选择。
- en: 'In the next chapter, we will take an in-depth look at perhaps the most important
    tooling for frontend developers: bundlers.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨对于前端开发者来说可能最重要的工具：打包器。
